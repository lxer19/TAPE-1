URL: ftp://ftp.research.microsoft.com/users/palarson/icde94_yl.ps
Refering-URL: http://www.research.microsoft.com/~palarson/publications.htm
Root-URL: http://www.research.microsoft.com
Email: fpwyan,palarsong@bluebox.uwaterloo.ca  
Title: Performing Group-By before Join  
Author: Weipeng P. Yan Per -Ake Larson 
Date: 1994  
Note: Appears in Proceedings of the 10th IEEE International Conference on Data  
Address: Waterloo, Ontario, Canada N2L 3G1  p89-100, Houston, TX,  
Affiliation: Department of Computer Science, University of Waterloo  Engineering,  
Abstract: Assume that we have an SQL query containing joins and a group-by. The standard way of evaluating this type of query is to first perform all the joins and then the group-by operation. However, it may be possible to perform the group-by early, that is, to push the group-by operation past one or more joins. Early grouping may reduce the query processing cost by reducing the amount of data participating in joins. We formally define the problem, adhering strictly to the semantics of NULL and duplicate elimination in SQL2, and prove necessary and sufficient conditions for deciding when this transformation is valid. In practice, it may be expensive or even impossible to test whether the conditions are satisfied. Therefore, we also present a more practical algorithm that tests a simpler, sufficient condition. This algorithm is fast and detects a large subclass of transformable queries. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. J. Date and Hugh Darwen. </author> <title> A Guide to the SQL Standard: a user's guide. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, third edition, </address> <year> 1993. </year>
Reference-contexts: to determine under what conditions this expression is equivalent to d [SGA 1 ; SGA 2 ; F AA][C 0 ](F [AA] A [GA 1 +; AA] where FAA are the columns generated by applying the arithmetic expressions F to columns AA. 4.2 The semantics of NULL in SQL2 SQL2 <ref> [7, 8, 1] </ref> represents missing information by a special value NULL. It adopts a three-valued logic in evaluating a conditional expression, having three possible truth values, namely true, false and unknown. in a search condition returns unknown if any one of the values is NULL or both values are NULL.
Reference: [2] <author> Umeshwar Dayal. </author> <title> Of nests and trees: A unified approach to processing queries that contain nested subqueries, aggregates, and quantifiers. </title> <booktitle> In Proceedings of the 13th International Conference on Very Large Data Bases, </booktitle> <pages> pages 197-208, </pages> <address> Brighton, England, August 1987. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Klug [6] observed that in some cases, the result from a join is already grouped correctly. Nested-loop and sort merge joins, the most widely used join methods, both have this property. In this case, explicit grouping is not needed and the join can be pipelined with aggregation. Dayal <ref> [2] </ref> stated, without proof, that the necessary condition for such technique is that the group-by columns must be a primary key of the outer table in the join. This is the only work we know of which attempts to reduce the cost of group-by by utilizing information about primary keys. <p> This technique not only increases the chance of a query being tested transformable, but also provides the optimizer more choices of execution plans for a query. In addition, we are investigating algorithms for performing grouping and how to detect when the group-by operation can be pipelined with other operations <ref> [6, 2] </ref>.
Reference: [3] <author> Richard A. Ganski and Harry K. T. Wong. </author> <title> Optimization of nested queries revisited. </title> <booktitle> In Proceedings of ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 23-33, </pages> <address> San Fran-cisco, California, </address> <month> May </month> <year> 1987. </year>
Reference: [4] <author> Werner Kiessling. </author> <title> On semantic reefs and efficient processing of correlation queries with aggregates. </title> <booktitle> In Proceedings of the 11th International Conference on Very Large Data Bases, </booktitle> <pages> pages 241-249, </pages> <address> Stockholm, Sweden, August 1985. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [5] <author> Won Kim. </author> <title> On optimizing an SQL-like nested query. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(3) </volume> <pages> 443-469, </pages> <month> September </month> <year> 1982. </year>
Reference: [6] <author> A. Klug. </author> <title> Access paths in the "abe" statistical query facility. </title> <booktitle> In Proceedings of ACM SIG-MOD International Conference on Management of Data, </booktitle> <pages> pages 161-173, </pages> <address> Orlendo, Fla., </address> <month> June 2-4 </month> <year> 1982. </year>
Reference-contexts: It is widely recognized that the aggregation computation can be performed while grouping (which is usually implemented by sorting). This can save both time and space since the amount of data to be sorted decreases during sorting. This technique is referred to as pipelining. Klug <ref> [6] </ref> observed that in some cases, the result from a join is already grouped correctly. Nested-loop and sort merge joins, the most widely used join methods, both have this property. In this case, explicit grouping is not needed and the join can be pipelined with aggregation. <p> This technique not only increases the chance of a query being tested transformable, but also provides the optimizer more choices of execution plans for a query. In addition, we are investigating algorithms for performing grouping and how to detect when the group-by operation can be pipelined with other operations <ref> [6, 2] </ref>.
Reference: [7] <author> ISO/IEC SQL 92. </author> <title> Information Technology - Database languages - SQL. Reference number ISO/IEC 9075:1992(E), </title> <month> November </month> <year> 1992. </year>
Reference-contexts: Note that subqueries are allowed. The grouping columns mentioned in the GROUP BY clause may contain columns from R 1 and R 2 , denoted by GA 1 and GA 2 , respectively. According to SQL2 <ref> [7] </ref>, the selection columns in the SELECT clause must be a subset of the grouping columns. We denote the selection columns as SGA 1 and SGA 2 , subsets of GA 1 and GA 2 , respectively. <p> to determine under what conditions this expression is equivalent to d [SGA 1 ; SGA 2 ; F AA][C 0 ](F [AA] A [GA 1 +; AA] where FAA are the columns generated by applying the arithmetic expressions F to columns AA. 4.2 The semantics of NULL in SQL2 SQL2 <ref> [7, 8, 1] </ref> represents missing information by a special value NULL. It adopts a three-valued logic in evaluating a conditional expression, having three possible truth values, namely true, false and unknown. in a search condition returns unknown if any one of the values is NULL or both values are NULL. <p> In addition, a special equality operator, n =, which is also specified in Figure 3, is proposed to reflect the "NULL equal to NULL" characteristics of SQL duplicate operations. 4.3 Functional dependencies SQL2 <ref> [7] </ref> provides facilities for defining (primary) keys of base tables. Note that a key definition implies two constraints: (a) no two rows can have the same key value and (b) no column of a key can be NULL. <p> To achieve this, we can make use of semantic integrity constraints and the conditions specified in the query. SQL2 <ref> [7] </ref> allows users to specify integrity constraints on the valid state of SQL data and these constraints are enforced by the SQL implementation. Therefore, in any valid database instance, we can assume that all integrity constraints hold in the join result of R 1 and R 2 .
Reference: [8] <author> Jim Melton and Alan R. Simon. </author> <title> Understanding the new SQL: A Complete Guide. </title> <publisher> Morgan Kauf-mann, </publisher> <year> 1993. </year>
Reference-contexts: to determine under what conditions this expression is equivalent to d [SGA 1 ; SGA 2 ; F AA][C 0 ](F [AA] A [GA 1 +; AA] where FAA are the columns generated by applying the arithmetic expressions F to columns AA. 4.2 The semantics of NULL in SQL2 SQL2 <ref> [7, 8, 1] </ref> represents missing information by a special value NULL. It adopts a three-valued logic in evaluating a conditional expression, having three possible truth values, namely true, false and unknown. in a search condition returns unknown if any one of the values is NULL or both values are NULL.
Reference: [9] <author> M. Negri, G. Pelagatti, and L. Sbattella. </author> <title> Formal semantics of SQL queries. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(3) </volume> <pages> 513-534, </pages> <month> September </month> <year> 1991. </year>
Reference: [10] <author> Gunter von Bultzingsloewen. </author> <title> Translating and optimizing SQL queries having aggregates. </title> <booktitle> In Proceedings of the 13th International Conference on Very Large Data Bases, </booktitle> <pages> pages 235-243, </pages> <address> Brighton, England, August 1987. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [11] <author> Weipeng P. Yan and Per -Ake Larson. </author> <title> Performing group-by before join. </title> <type> Technical Report CS 93-46, </type> <institution> Department of Computer Science, University of Waterloo, Waterloo, </institution> <address> Ontario, Canada, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: For some proofs in this paper, we only present brief sketches to save space. We also omit proofs that are trivial. Complete proofs can be found <ref> [11] </ref>. Lemma 1 : The expression E 0 A [GA 1 +; AA]G [GA 1 +][C 1 ]R 1 fi [C 2 ]R 2 ) is equivalent to E 2 . <p> The difference between E 2 and E 0 2 is that E 0 2 does not remove the columns other than GA 2 + of table [C 2 ]R 2 before the join. In practice, the optimizer usually removes these unnecessary columns to reduce the data volume. See <ref> [11] </ref> for the proof. <p> See <ref> [11] </ref> for the proof. <p> Consequently, the two conditions F D 1 and F D 2 become sufficient but not nec essary. See <ref> [11] </ref> for the proof. 6 TestFD: a fast algorithm to test the condition To apply the transformation in Theorem 2, i.e., to push grouping past a join, we need an algorithm to test whether the functional dependencies F D 1 and F D 2 are guaranteed to hold in the join <p> Similarly, the conditions of the query also hold in the join result. We can make use of this information to determine whether the functional dependencies F D 1 and F D 2 hold. In <ref> [11] </ref>, we proposed a method to test the conditions F D 1 and F D 2 which exploits the semantic constraints in SQL. <p> Input: Predicates C 1 ; C 0 ; C 2 ; T 1 ; T 2 ; key constraints of R 1 and R 2 . Output: YES or NO. 4 See <ref> [11] </ref> for delailed description for these constraints. 96 1. Convert C 1 ^ C 0 ^ C 2 ^ T 1 ^ T 2 into conjunctive normal form: C = D 1 ^ D 2 ^ ::: ^ D m . 2. <p> Theorem 3 : If the algorithm TestFD returns YES, F D 1 and F D 2 hold in [C 1 ^ C 0 ^ C2](R 1 fi R 2 ). See <ref> [11] </ref> for the proof of this theorem. Example 3 : Assume that we have three tables: UserAccount (UserId, Machine, UserName) PrinterAuth (UserId, Machine, PNo, Usage) Printer (PNo, Speed, Make) The UserAccount table stores information about user accounts. (UserId, Machine) is the primary key.
References-found: 11

