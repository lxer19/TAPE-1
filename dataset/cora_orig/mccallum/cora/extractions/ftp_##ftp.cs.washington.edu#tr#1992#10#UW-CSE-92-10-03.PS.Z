URL: ftp://ftp.cs.washington.edu/tr/1992/10/UW-CSE-92-10-03.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Email: fsitaram,shawg@cs.washington.edu  
Title: A Prototyping Environment for Specifying, Executing and Checking Communicating Real-time State Machines  
Author: Sitaram C. V. Raju and Alan C. Shaw 
Address: Seattle WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: We describe a toolset, consisting of a graphical editor, a simulator, and an assertion checker, for prototyping distributed real-time systems that are specified as Communicating Real-time State Machines (CRSMs). CRSMs are timed state machines that communicate synchronously over uni-directional channels. The system behavior of CRSMs is characterized by a time-stamped trace of communication events. Safety and timing assertions on the trace of communication events are expressed in a notation based on Real-Time Logic. We illustrate the novel aspects of the simulator and assertion checker by specifying a traffic-light controller and other real-time systems.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Attiya and N. A. Lynch, </author> <title> "Time Bounds for Real-time Process Control in the Presence of Timing Uncertainty", </title> <booktitle> Proc. IEEE Real-time Systems Symp., </booktitle> <pages> pp. 268-284, </pages> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: Finally, the new model of time in CRSMs (both for describing the passage of time and for specifying timeouts) also distinguishes our work from the ones listed above. Traces are used for reasoning about the behavior of general systems in [8], and for real-time systems in <ref> [1, 14] </ref>. Our method of reasoning with traces is noteworthy because it is based on Real-Time Logic (RTL) [5]. RTL is well suited for real-time systems because it deals with event times and can differentiate multiple occurrences of the same event. <p> Nexttime is used as the time interval on the succeeding transition to schedule the approaching signal. 1 The current implementation uses a C/C++ procedure. 6 AMBULANCE red green yel yel green strtoyellow ? turn_red - r=1; y=0; g=0;- <ref> [1] </ref> turn_yellow -r=0; y=1; g=0;- [1] turn_red turn_green -r=0; y=0; g=1;- [1] turn_yellow -r=0; y=1; g=0;- [1] getapptime avetoyellow ? -r=0; y=0; g=1;- [1] turn_green - printf ("enter time, direction: "); scanf ("%d %d", &nexttime, &direction); - [0] before ! [8,10] strtored ? strtogreen ? avetored ? avetogreen ? befaft after <p> Nexttime is used as the time interval on the succeeding transition to schedule the approaching signal. 1 The current implementation uses a C/C++ procedure. 6 AMBULANCE red green yel yel green strtoyellow ? turn_red - r=1; y=0; g=0;- <ref> [1] </ref> turn_yellow -r=0; y=1; g=0;- [1] turn_red turn_green -r=0; y=0; g=1;- [1] turn_yellow -r=0; y=1; g=0;- [1] getapptime avetoyellow ? -r=0; y=0; g=1;- [1] turn_green - printf ("enter time, direction: "); scanf ("%d %d", &nexttime, &direction); - [0] before ! [8,10] strtored ? strtogreen ? avetored ? avetogreen ? befaft after ! [6,8] start start approaching <p> Nexttime is used as the time interval on the succeeding transition to schedule the approaching signal. 1 The current implementation uses a C/C++ procedure. 6 AMBULANCE red green yel yel green strtoyellow ? turn_red - r=1; y=0; g=0;- <ref> [1] </ref> turn_yellow -r=0; y=1; g=0;- [1] turn_red turn_green -r=0; y=0; g=1;- [1] turn_yellow -r=0; y=1; g=0;- [1] getapptime avetoyellow ? -r=0; y=0; g=1;- [1] turn_green - printf ("enter time, direction: "); scanf ("%d %d", &nexttime, &direction); - [0] before ! [8,10] strtored ? strtogreen ? avetored ? avetogreen ? befaft after ! [6,8] start start approaching (direction) ! [nexttime] AVELIGHT STRLIGHT - <p> the time interval on the succeeding transition to schedule the approaching signal. 1 The current implementation uses a C/C++ procedure. 6 AMBULANCE red green yel yel green strtoyellow ? turn_red - r=1; y=0; g=0;- <ref> [1] </ref> turn_yellow -r=0; y=1; g=0;- [1] turn_red turn_green -r=0; y=0; g=1;- [1] turn_yellow -r=0; y=1; g=0;- [1] getapptime avetoyellow ? -r=0; y=0; g=1;- [1] turn_green - printf ("enter time, direction: "); scanf ("%d %d", &nexttime, &direction); - [0] before ! [8,10] strtored ? strtogreen ? avetored ? avetogreen ? befaft after ! [6,8] start start approaching (direction) ! [nexttime] AVELIGHT STRLIGHT - r=1; y=0; g=0;- [1] -r=1; <p> to schedule the approaching signal. 1 The current implementation uses a C/C++ procedure. 6 AMBULANCE red green yel yel green strtoyellow ? turn_red - r=1; y=0; g=0;- <ref> [1] </ref> turn_yellow -r=0; y=1; g=0;- [1] turn_red turn_green -r=0; y=0; g=1;- [1] turn_yellow -r=0; y=1; g=0;- [1] getapptime avetoyellow ? -r=0; y=0; g=1;- [1] turn_green - printf ("enter time, direction: "); scanf ("%d %d", &nexttime, &direction); - [0] before ! [8,10] strtored ? strtogreen ? avetored ? avetogreen ? befaft after ! [6,8] start start approaching (direction) ! [nexttime] AVELIGHT STRLIGHT - r=1; y=0; g=0;- [1] -r=1; y=g=0;- [1] 7 CONTROLLER (dir==0) before ? <p> g=0;- <ref> [1] </ref> getapptime avetoyellow ? -r=0; y=0; g=1;- [1] turn_green - printf ("enter time, direction: "); scanf ("%d %d", &nexttime, &direction); - [0] before ! [8,10] strtored ? strtogreen ? avetored ? avetogreen ? befaft after ! [6,8] start start approaching (direction) ! [nexttime] AVELIGHT STRLIGHT - r=1; y=0; g=0;- [1] -r=1; y=g=0;- [1] 7 CONTROLLER (dir==0) before ? / avetogreen ! / after ? / avetoyellow ! / timer ?[5] / avetored ! avetoyellow ! n3 timer ? [5] * * grn) avetored ! avetored ! n1 (both red) (both red) (both red) strtogreen ! strtored ! (dir==1) before ? <p> avetoyellow ? -r=0; y=0; g=1;- <ref> [1] </ref> turn_green - printf ("enter time, direction: "); scanf ("%d %d", &nexttime, &direction); - [0] before ! [8,10] strtored ? strtogreen ? avetored ? avetogreen ? befaft after ! [6,8] start start approaching (direction) ! [nexttime] AVELIGHT STRLIGHT - r=1; y=0; g=0;- [1] -r=1; y=g=0;- [1] 7 CONTROLLER (dir==0) before ? / avetogreen ! / after ? / avetoyellow ! / timer ?[5] / avetored ! avetoyellow ! n3 timer ? [5] * * grn) avetored ! avetored ! n1 (both red) (both red) (both red) strtogreen ! strtored ! (dir==1) before ? / strtogreen !
Reference: [2] <author> S. Chodrow, F. Jahanian and M. Donner, </author> <title> "Run-time Monitoring of Real-time Systems", </title> <booktitle> Proc. IEEE Real-time Systems Symp., </booktitle> <pages> pages 74-83, </pages> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: The above delay constraint can be specified by the formula, 8i @(before; i) @(approaching; i) + 5 The reason for choosing RTL is that its occurrence function can be used to distinguish different occurrences of the same event. In addition, earlier work on using RTL for run-time monitoring <ref> [2, 12] </ref> motivated us to use similar ideas for checking executable specifications. <p> int ind, int *result); int value (char *channel, char *field, int ind, int *result); int value (char *channel, char *field, int ind, float *result); int value (char *channel, char *field, int ind, char *result); int index (char *channel, int ind); A similar history data structure and interface was used in <ref> [2] </ref>. Function time retrieves the communication time and function value retrieves the data value. The first parameter channel is the channel name. Parameter field in the value function specifies the desired message field. Ind is the event occurrence index. <p> in history in order to check 5 We spotted an error in an earlier specification of the Controller because it had violated this assertion. 17 tick ? update timer (x) ? tick ! timer (y) ? -x = x + 10- [0] timer ? [x-y] -/* update calendar time */- <ref> [2] </ref> curtime (ctime) ! PERIODIC TICKERCOMPUTER CALENDAR the periodic timing constraint. Note that this assertion would not catch the violation if the Ticker halted and stopped generating ticks.
Reference: [3] <author> D. Drusinsky and D. Harel, </author> <title> "Using Statecharts for Hardware Description and Synthesis", </title> <journal> IEEE Trans. on CAD 8,7, </journal> <pages> pages 798-807, </pages> <month> July </month> <year> 1989. </year> <month> 22 </month>
Reference-contexts: Finally, the methods for checking or verifying the above properties must be computationally efficient. As an example to illustrate our specification languages and prototyping environment we will describe a real-time system for controlling traffic lights. It was inspired by the traffic light controller presented in <ref> [3] </ref>, but is completely different in detail from that example: A computer system controls the traffic lights at an intersection of an avenue and street. The avenue and street traffic lights have inputs avetored, avetoyellow, ave togreen and strtored, strtoyellow, strtogreen, respectively.
Reference: [4] <author> A. Gabrielian and M. Franklin, </author> <title> "Multilevel Specification of Real-time Systems", </title> <journal> Comm. of the ACM 34,5, </journal> <pages> pages 50-60, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Unlike CRSMs, Modechart does not allow events to have message components. Both Statecharts and Modechart use a shared memory model, whereas CRSMs present a distributed model. Reference [13] describes the ROOM methodology and its associated toolset. ROOM combines object-oriented methods (including inheritance) and Statecharts. Hierarchical Multi-State Machines (HMS) <ref> [4] </ref> is an executable notation that blends ideas from Petri-nets, Statecharts and temporal logic. Finally, the new model of time in CRSMs (both for describing the passage of time and for specifying timeouts) also distinguishes our work from the ones listed above.
Reference: [5] <author> F. Jahanian and A. Mok, </author> <title> "Safety Analysis of Timing Properties in Real-time Systems", </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 12, 9, </volume> <pages> pages 890-904, </pages> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: Traces are used for reasoning about the behavior of general systems in [8], and for real-time systems in [1, 14]. Our method of reasoning with traces is noteworthy because it is based on Real-Time Logic (RTL) <ref> [5] </ref>. RTL is well suited for real-time systems because it deals with event times and can differentiate multiple occurrences of the same event. We believe that such use of timing assertions for analysis of executable specifications is novel. The rest of the paper is organized as follows. <p> The behavior of a system is characterized by the history of time-stamped communication events on its channels, i.e. a history of the messages transmitted. The assertion language is based on Real-Time Logic (RTL) <ref> [5, 6] </ref>, which views a computation as a sequence of event occurrences. In our context, the only events of interest are instances of communication on channels. Both safety and timing properties are expressed as assertions about the relations between channel events. <p> ? avetored ? avetogreen ? befaft after ! [6,8] start start approaching (direction) ! [nexttime] AVELIGHT STRLIGHT - r=1; y=0; g=0;- [1] -r=1; y=g=0;- [1] 7 CONTROLLER (dir==0) before ? / avetogreen ! / after ? / avetoyellow ! / timer ?<ref> [5] </ref> / avetored ! avetoyellow ! n3 timer ? [5] * * grn) avetored ! avetored ! n1 (both red) (both red) (both red) strtogreen ! strtored ! (dir==1) before ? / strtogreen ! / after ? / n10 * timer ? [5] * * * strtoyellow ! n8 *: approaching (dir) ? avetogreen ! timer ? [45] avetoyellow ! <p> / after ? / avetoyellow ! / timer ?<ref> [5] </ref> / avetored ! avetoyellow ! n3 timer ? [5] * * grn) avetored ! avetored ! n1 (both red) (both red) (both red) strtogreen ! strtored ! (dir==1) before ? / strtogreen ! / after ? / n10 * timer ? [5] * * * strtoyellow ! n8 *: approaching (dir) ? avetogreen ! timer ? [45] avetoyellow ! timer ? [5] strtoyellow ! / timer ?[5] / strtored ! strtored ! timer ? [5] * * strtoyellow ! (str grn) yel) timer ? [45] 8 The Controller can be thought of <p> grn) avetored ! avetored ! n1 (both red) (both red) (both red) strtogreen ! strtored ! (dir==1) before ? / strtogreen ! / after ? / n10 * timer ? <ref> [5] </ref> * * * strtoyellow ! n8 *: approaching (dir) ? avetogreen ! timer ? [45] avetoyellow ! timer ? [5] strtoyellow ! / timer ?[5] / strtored ! strtored ! timer ? [5] * * strtoyellow ! (str grn) yel) timer ? [45] 8 The Controller can be thought of as being in two modes: normal and interrupted. States n 1 through n 10 comprise the normal mode. <p> ! strtored ! (dir==1) before ? / strtogreen ! / after ? / n10 * timer ? <ref> [5] </ref> * * * strtoyellow ! n8 *: approaching (dir) ? avetogreen ! timer ? [45] avetoyellow ! timer ? [5] strtoyellow ! / timer ?[5] / strtored ! strtored ! timer ? [5] * * strtoyellow ! (str grn) yel) timer ? [45] 8 The Controller can be thought of as being in two modes: normal and interrupted. States n 1 through n 10 comprise the normal mode.
Reference: [6] <author> F. Jahanian and A. Goyal, </author> <title> "A Formalism for Monitoring Real-time Constraints at Run-time", </title> <booktitle> Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 148-155, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The behavior of a system is characterized by the history of time-stamped communication events on its channels, i.e. a history of the messages transmitted. The assertion language is based on Real-Time Logic (RTL) <ref> [5, 6] </ref>, which views a computation as a sequence of event occurrences. In our context, the only events of interest are instances of communication on channels. Both safety and timing properties are expressed as assertions about the relations between channel events.
Reference: [7] <author> C. Hoare, </author> <title> "Communicating Sequential Processes", </title> <journal> Comm. of the ACM 21,8, </journal> <pages> pages 666-677, </pages> <month> Aug. </month> <year> 1978. </year>
Reference-contexts: Machines communicate synchronously (as in CSP <ref> [7, 8] </ref>) and instantaneously through messages over uni-directional channels. The set of machines and channels for the traffic-light controller and its environment is shown in Figure 1. <p> The basic idea is that code that is invoked in response to channel events gathers statistics. We use a real-time version of the well-known dining philosophers problem <ref> [7] </ref> to illustrate the idea by measuring the fraction of total time that each philosopher spends on eating. The example has 3 philosophers, 3 forks and a room. The CRSM for philosopher 1 is shown in Figure 9. First the philosopher requests to enter the room by signaling p1 enter.
Reference: [8] <author> C. Hoare, </author> <title> Communicating Sequential Processes, </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1985. </year>
Reference-contexts: Finally, the new model of time in CRSMs (both for describing the passage of time and for specifying timeouts) also distinguishes our work from the ones listed above. Traces are used for reasoning about the behavior of general systems in <ref> [8] </ref>, and for real-time systems in [1, 14]. Our method of reasoning with traces is noteworthy because it is based on Real-Time Logic (RTL) [5]. RTL is well suited for real-time systems because it deals with event times and can differentiate multiple occurrences of the same event. <p> Machines communicate synchronously (as in CSP <ref> [7, 8] </ref>) and instantaneously through messages over uni-directional channels. The set of machines and channels for the traffic-light controller and its environment is shown in Figure 1.
Reference: [9] <author> D. Harel, "Statecharts: </author> <title> A Visual Formalism for Complex Systems", </title> <booktitle> Science of Computer Programming 8,3, </booktitle> <pages> pages 231-274, </pages> <year> 1987. </year>
Reference-contexts: A substantial amount of research has been done on executable specifications and proto-typing of real-time systems. We give a brief survey and comparison of specification methods that are state machine based, because these are most closely related to our work. Statemate [10] is a tool for executing Statecharts <ref> [9] </ref>. Statecharts use broadcast for event communication, whereas CRSMs use message passing. Modechart is similar to Statecharts, but emphasizes the timing properties of systems; a simulator for Modechart is presented in [15]. Unlike CRSMs, Modechart does not allow events to have message components.
Reference: [10] <author> D. Harel et al., "Statemate: </author> <title> A Working Environment for the Development of Complex Reactive Systems", </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 16,4,pages 403-414, </volume> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: A substantial amount of research has been done on executable specifications and proto-typing of real-time systems. We give a brief survey and comparison of specification methods that are state machine based, because these are most closely related to our work. Statemate <ref> [10] </ref> is a tool for executing Statecharts [9]. Statecharts use broadcast for event communication, whereas CRSMs use message passing. Modechart is similar to Statecharts, but emphasizes the timing properties of systems; a simulator for Modechart is presented in [15]. Unlike CRSMs, Modechart does not allow events to have message components.
Reference: [11] <author> Luqi, V. Berzins and R. T. Yeh, </author> <title> "A Prototyping Language for Real-time Software", </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 14,10, </volume> <pages> pages 1409-1423, </pages> <month> Oct. </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Executable specifications have been advocated as a promising method for understanding the requirements specification of systems, and for developing systems incrementally <ref> [11, 18] </ref>. An executable specification serves as a prototype of the final implementation. The main advantage of prototyping systems is that it gives the designer feedback that what is being specified is indeed what is desired.
Reference: [12] <author> S. Raju, R. Rajkumar and F. Jahanian, </author> <title> "Monitoring Timing Constraints in Distributed Real-time Systems", </title> <type> TR 92-09-03, </type> <institution> Dept. of Computer Science and Eng., University of Washington, </institution> <month> Sept. </month> <year> 1992. </year> <note> (To appear in Proc. IEEE Real-time Systems Symp., </note> <month> Dec. </month> <year> 1992.) </year>
Reference-contexts: The above delay constraint can be specified by the formula, 8i @(before; i) @(approaching; i) + 5 The reason for choosing RTL is that its occurrence function can be used to distinguish different occurrences of the same event. In addition, earlier work on using RTL for run-time monitoring <ref> [2, 12] </ref> motivated us to use similar ideas for checking executable specifications. <p> The assumptions are: * the external interface of CRSMs is preserved in the implementation * the message components of channels and the interface between the corresponding mod ules in the implementation are the same. A run-time monitor for checking timing constraints in distributed real-time systems is described in <ref> [12] </ref>. The run-time monitor is based on RTL formalism, and histories are maintained for events. The assertions that can be checked are delays and deadlines only, unlike the arbitrary constraints in our assertion language. Our assertions can be translated, in a straightforward manner, into a similar monitor. <p> The assertions that can be checked are delays and deadlines only, unlike the arbitrary constraints in our assertion language. Our assertions can be translated, in a straightforward manner, into a similar monitor. The main change to the monitor described in <ref> [12] </ref> will be to have it execute user-defined assertion code in response to events. Many 20 issues have not been addressed, such as the potential interference caused by monitoring, and more research is needed on this topic.
Reference: [13] <author> B. Selic et al., </author> <title> "ROOM: An Object-Oriented Methodology for Developing Real-time Systems", </title> <booktitle> Proc. International Workshop on Computer-Aided Software Eng., </booktitle> <month> July </month> <year> 1992. </year>
Reference-contexts: Modechart is similar to Statecharts, but emphasizes the timing properties of systems; a simulator for Modechart is presented in [15]. Unlike CRSMs, Modechart does not allow events to have message components. Both Statecharts and Modechart use a shared memory model, whereas CRSMs present a distributed model. Reference <ref> [13] </ref> describes the ROOM methodology and its associated toolset. ROOM combines object-oriented methods (including inheritance) and Statecharts. Hierarchical Multi-State Machines (HMS) [4] is an executable notation that blends ideas from Petri-nets, Statecharts and temporal logic.
Reference: [14] <author> A. Shaw, </author> <title> "Communicating Real-time State Machines", </title> <journal> IEEE Trans. on Software Eng., </journal> <month> Sept. </month> <year> 1992. </year> <note> (An earlier version was published as TR 91-08-09, </note> <institution> Dept. of Computer Science and Eng., University of Washington, </institution> <month> Aug. </month> <year> 1991.) </year>
Reference-contexts: CRSMs, introduced in <ref> [14] </ref>, are an executable scheme for specifying the requirements of both a real-time system and its physical environment. They are timed state machines that communicate synchronously over unidirectional channels. <p> This paper makes two contributions: First, the prototyping environment serves as a validation of the execution algorithm and paper design of CRSMs described in <ref> [14] </ref>. Second, the paper presents a novel and useful method of specifying safety and timing properties, and checking them during simulation. A substantial amount of research has been done on executable specifications and proto-typing of real-time systems. <p> Finally, the new model of time in CRSMs (both for describing the passage of time and for specifying timeouts) also distinguishes our work from the ones listed above. Traces are used for reasoning about the behavior of general systems in [8], and for real-time systems in <ref> [1, 14] </ref>. Our method of reasoning with traces is noteworthy because it is based on Real-Time Logic (RTL) [5]. RTL is well suited for real-time systems because it deals with event times and can differentiate multiple occurrences of the same event. <p> One language describes the behavior of the system including the physical interfaces. The other specifies the safety and timing constraints that the system must satisfy. 3 Avelight Strlight avetored avetoyellow strtoyellow before approaching (integer direction) Controller Ambulance strtogreenavetogreen strtored after The system specification language is based on CRSMs <ref> [14] </ref>, which are timed state machines that run concurrently except when they need to communicate. Machines communicate synchronously (as in CSP [7, 8]) and instantaneously through messages over uni-directional channels. The set of machines and channels for the traffic-light controller and its environment is shown in Figure 1. <p> The text form can also be used for entering the description of CRSMs and assertions directly. There are two issues in the design of the simulator. One is whether to use discrete ticks for time or some approximation to continuous time. The CRSM scheme as described in <ref> [14] </ref> uses continuous time. We chose to use discrete time as it simplifies some of the implementation details. The second issue is whether to have a compiled or an interpreted simulator. <p> The text form is translated into a C++ program that is then compiled and linked with the simulator/assertion checking library to form an executable file. The major classes in the C++ program correspond naturally to CRSM, channel, and assertion. The simulator uses an event-driven algorithm as described in <ref> [14] </ref>. The simulator steps through the execution under user control (either a single step or a sequence of steps). <p> If any assertions are triggered, the corresponding constraint checking code is invoked. We have not analyzed the performance of the simulator and assertion checker in detail yet. For the specification examples described in this paper and in <ref> [14] </ref>, the simulator/assertion checker responds to single-step commands from the user in real-time. 5 Experiments We used the simulator and assertion checker described in the previous section to experimentally validate most of the example specifications described in [14]. <p> For the specification examples described in this paper and in <ref> [14] </ref>, the simulator/assertion checker responds to single-step commands from the user in real-time. 5 Experiments We used the simulator and assertion checker described in the previous section to experimentally validate most of the example specifications described in [14]. These included a real-time bounded buffer; a mouse clicker recognizer that distinguishes among single clicks, double clicks and selections; and a train crossing gate controller. In each case, we validated the examples by observing simulator output and by checking relevant assertions during execution. <p> Finally, we hope to use the environment for larger and more practical examples. 7 Conclusions We have described a prototyping environment for specifying, executing and checking CRSMs. The environment serves as a validation of the simulator algorithm and the CRSM examples described in <ref> [14] </ref>. The environment has also proved useful in understanding and debugging specifications. We defined a novel assertion language for specifying timing assertions, and illustrated its use by specifying common timing constraints and some safety properties.
Reference: [15] <author> D. A. Stuart and P. C. Clements, "Clairvoyance, </author> <title> Capricious Timing Faults, Causality and Real-time Specifications", </title> <booktitle> Proc. IEEE Real-time Systems Symp., </booktitle> <pages> pages 254-263, </pages> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: Statemate [10] is a tool for executing Statecharts [9]. Statecharts use broadcast for event communication, whereas CRSMs use message passing. Modechart is similar to Statecharts, but emphasizes the timing properties of systems; a simulator for Modechart is presented in <ref> [15] </ref>. Unlike CRSMs, Modechart does not allow events to have message components. Both Statecharts and Modechart use a shared memory model, whereas CRSMs present a distributed model. Reference [13] describes the ROOM methodology and its associated toolset. ROOM combines object-oriented methods (including inheritance) and Statecharts.
Reference: [16] <author> R. Swick and M. S. Ackerman, </author> <title> "The X Toolkit: More Bricks for Building User-Interfaces or Widgets for Hire", </title> <booktitle> Proc. Winter Usenix Conference, </booktitle> <pages> pages 221-228, </pages> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: The tools have been implemented in C/C++ on a Decstation 5000 running UNIX. The relation between the tools is shown in Figure 5. The graphical editor is an extension of an existing graph editor called Xsim [17]. Xsim runs on the X-window system and uses Athena widgets <ref> [16] </ref>. The graphical editor has two modes: global and local. The global mode is used for creating the global system of CRSMs and the interconnecting channels. The local mode is used for creating the state diagram of a machine.
Reference: [17] <author> G. Thomas, </author> <title> "Xsim 2.0 User's Guide", </title> <institution> Dept. of Computer Science and Eng., University of Washington, </institution> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: The tools have been implemented in C/C++ on a Decstation 5000 running UNIX. The relation between the tools is shown in Figure 5. The graphical editor is an extension of an existing graph editor called Xsim <ref> [17] </ref>. Xsim runs on the X-window system and uses Athena widgets [16]. The graphical editor has two modes: global and local. The global mode is used for creating the global system of CRSMs and the interconnecting channels. The local mode is used for creating the state diagram of a machine.
Reference: [18] <author> P. Zave, </author> <title> "An Operational Approach to Requirements Specification for Embedded Systems", </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 8,3, </volume> <pages> pages 250-269, </pages> <month> May </month> <year> 1982. </year> <month> 23 </month>
Reference-contexts: 1 Introduction Executable specifications have been advocated as a promising method for understanding the requirements specification of systems, and for developing systems incrementally <ref> [11, 18] </ref>. An executable specification serves as a prototype of the final implementation. The main advantage of prototyping systems is that it gives the designer feedback that what is being specified is indeed what is desired.
References-found: 18

