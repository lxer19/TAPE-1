URL: ftp://ftp.eecs.umich.edu/groups/gasm/babel.abst.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: boerger@di.unipi.it  ffraguas,mariog@dia.ucm.es  
Title: A model for mathematical analysis of functional logic programs and their implementations  
Author: Egon Borger a Francisco J. Lopez-Fraguas and Mario Rodrguez-Artalejo b 
Address: Pisa, Cso Italia 40, I-56100 PISA,  28040 Madrid,Spain,  
Affiliation: a Dip. di Informatica, Universita di  b Dep. Informatica Automatica, Universidad Complutense, Av. Complutense s/n,  
Abstract: We extend the mathematical definition and analysis of Prolog program execution on the WAM, developed in [2,3], to functional logic languages and machines. As reference language we choose the functional logic programming language BABEL [8]. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> E. Borger, F. J. Lopez Fraguas, and M. </author> <title> Rodrguez Artalejo. Towards a mathematical specification of narrowing machines. </title> <type> Research report DIA 94/5, </type> <institution> Dep. Informatica y Automatica, Universidad Complutense, Madrid, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: We will consider here only the first order subset of the language, and will omit correctness proofs for our refinements. For details and extensions we refer to <ref> [1] </ref>. fl In: B. Pehrson and I. Simon (Eds.) IFIP 13th World Computer Congress 1994, Volume I: Technology/Foundations, Elsevier, Amsterdam. y This research has been partially supported by the Spanish National Project TIC92-0793-C02-01 "PDR" 2 2. <p> For exact formulation and proof of the correctness statements see <ref> [1] </ref>. Structure sharing for expressions can be obtained in a provably correct way as follows. When during narrowing the left hand side of a defining rule is replaced by its right hand side, we put only the source code expression involved, without applying the unifying substitution which is kept apart. <p> is changed to be without applying the unifying substitution, and b) the substitution must be applied to those occurrences of currexp or expressions e in the rules , where the condition to be checked or the operation to be performed on those expressions really depend on the substitution ; see <ref> [1] </ref>. Refining the normal form test means to define the is normal form function used in the evaluation starting rule. <p> The optimized last return rule expresses this by adding a conditional update for lastnode: if lastnode = currnode & cands = [ ] then lastnode : = bfather For the specification of other optimizations, see again <ref> [1] </ref>.
Reference: 2. <author> E. Borger and D. Rosenzweig. </author> <title> A simple mathematical model for full Prolog. </title> <institution> Research report TR-33/92, Dipartimento di Informatica, Universita di Pisa, Pisa, </institution> <month> October </month> <year> 1992. </year> <note> to appear in Science of Computer Programming, </note> <year> 1994. </year>
Reference-contexts: 1. Introduction We extend the core Prolog model of <ref> [2] </ref> to a model for the functional logic programming language BABEL [8] by adding, to Prolog's backtracking structure, rules for the reduction of functional expressions to normal form. <p> We expect from the reader also basic knowledge of logic programming and term rewriting, and assume familiarity with <ref> [2] </ref>. For BABEL we note here only that programs consist of defining rules of the form f (t 1 ; :::; t n ) := r where r may be a guarded expression (b ! e). <p> The narrowing-backtracking core For the top level description of BABEL it suffices to enrich the core model for Prolog defined in <ref> [2] </ref> as follows. <p> For the initialization it is assumed that pos is the empty position and mode is Eval . The backtracking behaviour of BABEL programs is defined by the corresponding two Prolog rules in <ref> [2] </ref>, handling expressions and their positions instead of goals: in the Call rule, currexp = f (e 1 ; : : : ; e n ) is added as condition; the Selection rule, when switching to mode Eval, uses unification of currexp with the left hand side of the candidate defining <p> then the evaluation has to stop and to continue at another (brother- or father-) expression, as described by the construction rule: if mode = Apply & is construction (currexp) then mode : = Continue We skip the rules for predefined functions which can be defined like Prolog built-in predicates in <ref> [2] </ref>. 3. BABEL stack algebras In order to come closer to a realistic implementation, in this section we refine BABEL tree algebras by structure sharing for expressions, explicit computation of the normal form condition and embedding of the backtracking tree structure into a stack.
Reference: 3. <author> E. Borger and D. Rosenzweig. </author> <title> The WAM definition and compiler correctness. </title> <institution> Research report TR-14/92, Dipartimento di Informatica, Universita di Pisa, Pisa, </institution> <year> 1992. </year> <note> to appear in: Logic Programming: Formal Methods and Practical Applications (C.Beierle, </note> <editor> L.Plumer, Eds.), North-Holland, </editor> <booktitle> Series in Computer Science and Artificial Intelligence, </booktitle> <year> 1994. </year>
Reference-contexts: atomic (e) recognizes if the expression e is a variable or a constant symbol c: if mode = Eval thenif :atomic (currexp) then pos : = pos:1 else mode : = Continue The provably corret refinement to stack representation of BABEL trees is similar to the corresponding stack implementation in <ref> [3] </ref> and therefore skipped here. 4. Localizing the environment and Optimizations The normal form computation for expressions is localized in two steps: introduction of states which control normalization of subexpressions, completed by subsequent replacement of `global' by dedicated `local' environments.
Reference: 4. <author> A.J. Field and P.G. Harrison. </author> <title> Functional Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Thus the machinery of [2,3] for mathematical description and analysis of logic programs, is linked to functional logic programs and their implementation on machines which typically combine the WAM [9] with features from reduction machines <ref> [4] </ref> for functional languages (see also [7]). The fundamental concept which allows us to describe complex program and machine structure by simple abstract mathematical specifications is Gurevich's notion of evolving algebras which we will use throughout and for which we refer the reader to [5].
Reference: 5. <author> Y. Gurevich. </author> <title> Evolving algebras. A tutorial introduction. </title> <journal> Bulletin of EATCS, </journal> <volume> 43 </volume> <pages> 264-284, </pages> <year> 1991. </year>
Reference-contexts: The fundamental concept which allows us to describe complex program and machine structure by simple abstract mathematical specifications is Gurevich's notion of evolving algebras which we will use throughout and for which we refer the reader to <ref> [5] </ref>. We expect from the reader also basic knowledge of logic programming and term rewriting, and assume familiarity with [2].
Reference: 6. <author> H. Kuchen, R. Loogen, J.J Moreno Navarro, and M. </author> <title> Rodrguez Artalejo. Graph-based implementation of a functional logic language. </title> <booktitle> In ESOP, volume 432 of Lecture Notes in Computer Science, </booktitle> <pages> pages 271-290. </pages> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: refinements which are directed towards implementation of functional logic programs: structure sharing for expressions, explicit computation of the normal form condition, embedding of the backtracking tree into a stack, localization of the normal form computation for expressions (introducing local environments for computation of subex-pressions) together with some optimizations in IBAM <ref> [6] </ref>, a (graph|) narrowing machine actually implementing innermost BABEL.
Reference: 7. <author> R. Loogen. </author> <title> Relating the implementation techniques of functional and functional logic languages. to appear in New Generation Computing. </title> <type> 7 </type>
Reference-contexts: Thus the machinery of [2,3] for mathematical description and analysis of logic programs, is linked to functional logic programs and their implementation on machines which typically combine the WAM [9] with features from reduction machines [4] for functional languages (see also <ref> [7] </ref>). The fundamental concept which allows us to describe complex program and machine structure by simple abstract mathematical specifications is Gurevich's notion of evolving algebras which we will use throughout and for which we refer the reader to [5].
Reference: 8. <author> J.J Moreno Navarro and M. </author> <title> Rodrguez Artalejo. Logic programming with functions and predicates: The language BABEL. </title> <journal> Journal of Logic Programming, </journal> <volume> 12 </volume> <pages> 189-223, </pages> <year> 1992. </year>
Reference-contexts: 1. Introduction We extend the core Prolog model of [2] to a model for the functional logic programming language BABEL <ref> [8] </ref> by adding, to Prolog's backtracking structure, rules for the reduction of functional expressions to normal form.
Reference: 9. <author> D.H.D. Warren. </author> <title> An abstract prolog instruction set. </title> <type> Technical Note 309, </type> <institution> SRI International, </institution> <address> Menlo Park, </address> <year> 1983. </year>
Reference-contexts: Thus the machinery of [2,3] for mathematical description and analysis of logic programs, is linked to functional logic programs and their implementation on machines which typically combine the WAM <ref> [9] </ref> with features from reduction machines [4] for functional languages (see also [7]).
References-found: 9

