URL: http://www.cs.cornell.edu/Info/People/crary/papers/tt-semant.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/crary/papers/
Root-URL: 
Email: crary@cs.cornell.edu  
Title: Programming Language Semantics in Foundational Type Theory  
Author: K. Crary 
Keyword: Semantics, program verification, type theory, functional programming  
Address: Ithaca, New York 14853  
Affiliation: Cornell University  
Abstract: There are compelling benefits to using foundational type theory as a framework for programming language semantics. I give a semantics of an expressive programming calculus in the foundational type theory of Nuprl. Previous type-theoretic semantics have used less expressive type theories, or have sacrificed important programming constructs such as recursion and modules. The primary mechanisms of this semantics are partial types, for typing recursion, set types, for encoding power and singleton kinds, which are used for subtyping and module programming, and very dependent function types, for encoding signatures. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Allen, S. </author> <title> (1987) A non-type-theoretic definition of Martin-Lof's types. </title> <booktitle> In Second IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 215-221, </pages> <address> Ithaca, New York. </address>
Reference: <author> Birkedal, L. and Harper, R. </author> <title> (1997) Relational interpretations of recursive types in an operational setting. </title> <booktitle> In Theoretical Aspects of Computer Software. </booktitle>
Reference: <author> Constable, R., Allen, S., Bromley, H., Cleaveland, W., Cremer, J., Harper, R., Howe, D., Knoblock, T., Mendler, N., Panangaden, P., Sasaki, J., and Smith, S. </author> <title> (1986) Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall. </publisher>
Reference: <author> Constable, R. L. </author> <title> (1985) Constructive mathematics as a programming logic I: Some principles of theory. </title> <booktitle> In Topics in the Theory of Computation, volume 24 of Annals of Discrete Mathematics, </booktitle> <pages> pages 21-37. </pages> <address> Elsevier. </address> <booktitle> Selected papers of the International Conference on Foundations of Computation Theory 1983. </booktitle>
Reference-contexts: The power kind P i (t ) contains only subtypes of t and the singleton kind S i (t ) contains only types that are equal to t ; other types must be left out. The mechanism for achieving this exclusion is the set type <ref> (Constable, 1985) </ref>. If S is a type and P [] is a predicate over S, then the set type fz : S j P [z]g contains all elements z of S such that P [z] is true.
Reference: <author> Constable, R. L. </author> <title> (1991) Type theory as a foundation for computer science. </title> <booktitle> In Theoretical Aspects of Computer Software 1991, volume 526 of Lecture Notes in Computer Science, </booktitle> <pages> pages 226-243, </pages> <address> Sendai, Japan. </address> <publisher> Springer-Verlag. </publisher>
Reference: <author> Constable, R. L. and Crary, K. </author> <title> (1997) Computational complexity and induction for partial computable functions in type theory. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University. </institution>
Reference: <author> Constable, R. L. and Smith, S. F. </author> <title> (1987) Partial objects in constructive type theory. </title> <booktitle> In Second IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 183-193, </pages> <address> Ithaca, New York. </address>
Reference: <author> Coquand, T. and Huet, G. </author> <title> (1988) The calculus of constructions. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 95-120. </pages>
Reference-contexts: The type theory of Mendler (1987) provides such impredicative features and is quite similar to Nuprl; I have not used that framework in this paper out of desire to use a simpler and more standard theory. The Calculus of Constructions <ref> (Coquand and Huet, 1988) </ref> also supplies impredicative features and could likely also support the semantics in this paper. 6 CONCLUSION Aside from its advantages for formal program reasoning, embedding programming languages into type theory allows a researcher to bring the full power of type theory to bear on a programming problem.
Reference: <author> Crary, K. </author> <title> (1997) Foundations for the implementation of higher-order subtyping. </title> <booktitle> In 1997 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 125-135, </pages> <address> Amsterdam. </address>
Reference: <author> Crary, K. </author> <title> (1998a) Admissibility of fixpoint induction over partial types. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University. </institution>
Reference: <author> Crary, K. </author> <title> (1998b) Programming language semantics in foundational type theory. </title> <type> Technical Report TR98-1666, </type> <institution> Department of Computer Science, Cornell University. </institution>
Reference-contexts: Section 4 contains the embedding that is the central technical contribution of the paper. Section 5 discusses promising directions for future work. Finally, Section 6 contains brief concluding remarks. Due to space limitations, many technical details have been omitted; these may be found in the companion technical report <ref> (Crary, 1998b) </ref>. 2 THE K PROGRAMMING CALCULUS As a case study to illustrate my technique, I use a predicative variant of K , the high-level typed intermediate language in the KML compiler (Crary, 1998c). In this section we discuss K .
Reference: <author> Crary, K. </author> <title> (1998c) Type-Theoretic Methodology for Practical Programming Languages. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York. </address> <publisher> Forthcoming. </publisher>
Reference-contexts: to space limitations, many technical details have been omitted; these may be found in the companion technical report (Crary, 1998b). 2 THE K PROGRAMMING CALCULUS As a case study to illustrate my technique, I use a predicative variant of K , the high-level typed intermediate language in the KML compiler <ref> (Crary, 1998c) </ref>. In this section we discuss K . In the interest of brevity, the discussion assumes knowledge of several well-known programming constructs. The syntax rules of K appear in Figure 1.
Reference: <author> Girard, J.-Y. </author> <title> (1972) Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII. </institution>
Reference-contexts: In this section we discuss K . In the interest of brevity, the discussion assumes knowledge of several well-known programming constructs. The syntax rules of K appear in Figure 1. The overall structure of the calculus is similar to the higher-order polymorphic lambda calculus <ref> (Girard, 1972) </ref> augmented with records at the term and type constructor level (and their corresponding types and kinds), and a fixpoint operator at the term level. <p> To handle polymorphism we want to have functions that can take types as arguments. These can be typed with the dependent types discussed above if one adds a type of all types. Unfortunately, a single type of all types is known to make the theory inconsistent <ref> (Girard, 1972) </ref>, so instead the type theory includes a predicative hierarchy of universes, U 1 ; U 2 ; U 3 ; etc.
Reference: <author> Harper, R. </author> <title> (1992) Constructing type systems over an operational semantics. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 14 </volume> <pages> 71-84. </pages>
Reference: <author> Harper, R. and Lillibridge, M. </author> <title> (1994) A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Twenty-First ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 123-137, </pages> <address> Portland, Oregon. </address>
Reference: <author> Harper, R. and Mitchell, J. C. </author> <title> (1993) On the type structure of Standard ML. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 211-252. </pages>
Reference: <author> Harper, R., Mitchell, J. C., and Moggi, E. </author> <title> (1990) Higher-order modules and the References 19 phase distinction. </title> <booktitle> In Seventeenth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 341-354, </pages> <address> San Francisco. </address>
Reference-contexts: Proof. Not difficult, but outside the scope of this paper (see Crary (1998c)). Corollary 3 (Type Preservation) If ` K e : t and [[e]] 7! fl t then t 2 [[t ]]. Another consequence of the soundness theorem is that the phase distinction <ref> (Harper et al., 1990) </ref> is respected in K : all type expressions converge and therefore types may be computed in a compile-time phase. This is expressed by Corollary 4: Corollary 4 (Phase Distinction) If ` K c : then there exists canonical t such that [[c]] 7! fl t. Proof.
Reference: <author> Harper, R. and Stone, C. </author> <title> (1998) A type-theoretic interpretation of Standard ML. In Proof, Language and Interaction: Essays in Honour of Robin Milner. The MIT Press. </title> <note> To appear. </note>
Reference-contexts: The typing judgement ; ` K e : c indicates that (in kind context and type context ) the term e has type c. Finally, the valuability judgement <ref> (Harper and Stone, 1998) </ref> ; ` K e # c indicates that the term e has type c and evaluates without computational effects (in this setting this means just that it terminates).
Reference: <author> Hickey, J. J. </author> <title> (1996) Formal objects in type theory using very dependent types. </title> <booktitle> In Foundations of Object Oriented Languages 3. </booktitle>
Reference-contexts: So we want a type of functions whose return type can depend not only upon their arguments but upon their own return values! The type I will use for this embedding is a very dependent function type <ref> (Hickey, 1996) </ref>. This type is a generalization of the dependent function type (itself a generalization of the ordinary function type) and like it, the very dependent function type's members are just lambda abstractions. The difference is in the specification of a function's return type.
Reference: <author> Howard, W. </author> <title> (1980) The formulas-as-types notion of construction. </title> <editor> In Seldin, J. P. and Hindley, J. R., editors, </editor> <booktitle> To H.B. Curry: Essays on Combinatory Logic, Lambda-Calculus and Formalism, </booktitle> <pages> pages 479-490. </pages> <publisher> Academic Press. </publisher>
Reference-contexts: It is primarily those programming features that I will use in the embedding. The logic of types is obtained through the propositions-as-types isomorphism <ref> (Howard, 1980) </ref>, but this will not be critical to our purposes. Detailed discussions of type theory, including the logic of types, appear in Martin-Lof (1982) and Constable (1991), and Nuprl specifically is discussed in Constable et al. (1986).
Reference: <author> Howe, D. J. </author> <title> (1996) Semantic foundations for embedding HOL in Nuprl. </title> <type> Technical report, </type> <institution> Bell Labs. </institution>
Reference-contexts: This semantics is also useful even if one ultimately desires a semantics in some framework other than type theory. Martin-Lof type theory is closely tied to a structured operational semantics and has denotational models in many frameworks including partial equivalence relations (Allen, 1987; Harper, 1992), set theory <ref> (Howe, 1996) </ref> and domain theory (Rezus, 1985; Palmgren and Stoltenberg-Hansen, 1989). Thus, foundational type theory may be used as a "semantic intermediate language." The paper is organized as follows: Section 2 presents the paper's object language, K .
Reference: <author> Kreitz, C. </author> <title> (1997) Formal reasoning about communications systems I. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University. </institution>
Reference: <author> Martin-Lof, P. </author> <booktitle> (1982) Constructive mathematics and computer programming. In Sixth International Congress of Logic, Methodology and Philosophy of Science, volume 104 of Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> pages 153-175. </pages> <publisher> North-Holland. </publisher>
Reference: <author> Mendler, P. F. </author> <title> (1987) Inductive Definition in Type Theory. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York. </address>
Reference: <author> Milner, R., Tofte, M., Harper, R., and MacQueen, D. </author> <title> (1997) The Definition of Standard ML (Revised). </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts. </address>
Reference-contexts: Reynolds gave a type-theoretic interpretation of Idealized Algol, and Harper and Mitchell did the same for a simplified fragment of Standard ML. Recently, Harper and Stone (1998) have given such an interpretation of full Standard ML (Revised) <ref> (Milner et al., 1997) </ref>. However, in each of these cases, the type theories used were not sufficiently rich to form a foundation for mathematical reasoning; for example, they were unable to express equality or induction principles.
Reference: <author> Palmgren, E. and Stoltenberg-Hansen, V. </author> <title> (1989) Domain interpretations of intu-itionistic type theory. U.U.D.M. </title> <type> Report 1989:1, </type> <institution> Uppsala University, Department of Mathematics. </institution>
Reference: <author> Peyton Jones, S. L. and Wadler, P. </author> <title> (1993) Imperative functional programming. </title> <booktitle> In Twentieth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <address> Charleston, South Carolina. </address>
Reference-contexts: One promising device for doing this is to encode stateful computations as monads <ref> (Peyton Jones and Wadler, 1993) </ref>, but this raises two difficulties. In order to encode references in monads, all expressions that may side-effect the store must take the store as an argument. The problem is how to assign a type to the store.
Reference: <author> Reynolds, J. C. </author> <title> (1981) The essence of Algol. </title> <editor> In de Bakker, J. W. and van Vliet, J. C., editors, </editor> <booktitle> Proceedings of the International Symposium on Algorithmic Languages, </booktitle> <pages> pages 345-372, </pages> <address> Amsterdam. </address> <publisher> North-Holland. </publisher>
Reference: <author> Rezus, A. </author> <title> (1985) Semantics of constructive type theory. </title> <type> Technical Report 70, </type> <institution> Infor-matics Department, Faculty of Science, Nijmegen, University, The Netherlands. </institution>
Reference: <author> Scott, D. and Strachey, C. </author> <title> (1971) Toward a mathematical semantics for computer languages. </title> <booktitle> In Proceedings of the Symposium on Computers and Automata, volume 21 of Microwave Research Institute Symposia Series. </booktitle> <institution> Polytechnic Institute of Brooklyn. </institution>
Reference-contexts: Adjusting this interpretation to make the power kind constructive resulted in a proof-passing technique used to implement higher-order coercive subtyping in KML. Furthermore, the simplicity of the semantics makes it attractive to use as a mathematical model similar in spirit, if not in detail, to the Scott-Strachey program <ref> (Scott and Stratchey, 1971) </ref>. This semantics works out so neatly because type theory provides built-in structure well-suited for analysis of programming. Most importantly, type theory provides structured data and an intrinsic notion of computation.
Reference: <author> Smith, S. F. </author> <title> (1989) Partial Objects in Type Theory. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York. </address> <note> BIOGRAPHY Karl Crary earned his B.S. in Computer Science from Carnegie Mellon University in 1993 and is now a Ph.D. </note> <editor> candidate at Cornell University. </editor> <title> His main interests include programming language design and semantics, type theory, and typed compilation. </title>
Reference-contexts: Then [[f ]] fl The second subgoal, that the type T be admissible, is a technical condition related to the notion of admissibility in LCF. This condition is required because fixpoint induction can be derived from the recursive typing rule <ref> (Smith, 1989) </ref>. However, all the types used in the embedding in this paper are admissible, so I ignore the admissibility condition in this paper. Additional details appear in Crary (1998a). y This terminology can be somewhat confusing. A total type is one that contains only convergent expressions.
References-found: 31

