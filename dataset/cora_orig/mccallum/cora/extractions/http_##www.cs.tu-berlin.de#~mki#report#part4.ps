URL: http://www.cs.tu-berlin.de/~mki/report/part4.ps
Refering-URL: http://www.cs.tu-berlin.de/~mki/report/tr.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Functional Programming by Analogy  
Author: E. Heymann, D. Matzke, R. Mercy, M. Muller and K. Schadler 
Abstract: In this paper we describe how the principles of problem solving by analogy can be applied to the domain of functional program synthesis. For this reason, we treat programs as syntactical structures. We discuss two different methods to handle these structures: (a) a graph metric for determining the distance between two program schemes, and (b) the Structure Mapping Engine (an existing system to examine analogical processing). Furthermore we show experimental results and discuss them. 
Abstract-found: 1
Intro-found: 1
Reference: [ 1 ] <author> N. </author> <title> Dershowitz Programming by analogy, </title> <booktitle> in Machine Learning, Vol. II 1986 </booktitle>
Reference-contexts: One area of application for within-domain analogies is programming by analogy. In programming by analogy the base and the target are drawn from the same domain (programming). There exist some approaches of programming by analogy. In <ref> [ 1 ] </ref> Dershowitz describes a deductive approach to create imperative programs by finding analogies between program specifications, generating schemes of program specifications and instantiate them. Dershowitz uses modification, transformation and substitution to develop a program with a given specification by a known specification and its program.
Reference: [ 2 ] <author> B. </author> <note> Falkenhainer The SME user's manual, Version 2E. in Technical Report UIUCDCS-R-88-1421 , 1988. </note>
Reference-contexts: We only need a tree metric (we will use the tree-to-tree distance as described in [ 6 ] ) because the RPS and initial trees we regard, are directed non-cyclic graphs. * Mapping and Adaptation. The Structure Mapping Engine (SME) (see [ 3 ] and <ref> [ 2 ] </ref> ) is a program to examine analogical processes. It concentrates on the subprocess of mapping and adaption. It takes a problem description for a base and a target, and finds the greatest consistent match for them, trying to transfer informations from the base to the target problem.
Reference: [ 3 ] <author> B. Falkenhainer, K.D. Forbus and D. Gentner. </author> - <title> The structure mapping engine; algorithm and examples. </title> <journal> in Artificial Intelligence, </journal> <volume> 41: </volume> <pages> 1-63, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction The idea of solving problems by analogy is, to use already known problems and their solutions to solve a new problem. Analogical Reasoning can be characterized by three stages <ref> [ 3 ] </ref> : * Access A solved problem or case which is most similar to the new problem, has to be retrieved from a database. * Mapping and Adaptation. The retrieved case has to be adapted to fit the new problem. <p> We only need a tree metric (we will use the tree-to-tree distance as described in [ 6 ] ) because the RPS and initial trees we regard, are directed non-cyclic graphs. * Mapping and Adaptation. The Structure Mapping Engine (SME) (see <ref> [ 3 ] </ref> and [ 2 ] ) is a program to examine analogical processes. It concentrates on the subprocess of mapping and adaption.
Reference: [ 4 ] <author> A.J. </author> <title> Field, P.G. Harrison Functional Programming, </title> <publisher> Addison-Wesley 1988 </publisher>
Reference: [ 5 ] <author> D. Gentner. </author> <title> Structure mapping: a theoretical framework for analogy. </title> <booktitle> in Cognitive Science, </booktitle> <volume> 7: </volume> <pages> 155-170, </pages> <year> 1983. </year>
Reference: [ 6 ] <author> S.-Y. Lu. </author> <title> A tree-to-tree distance and its application to cluster analysis. </title> <journal> in IEEE Transaction on Pattern Analysis and Machine Intelligence, </journal> <volume> Vol. 2, </volume> <year> 1979. </year>
Reference-contexts: This can be achieved by using a graph metric. We only need a tree metric (we will use the tree-to-tree distance as described in <ref> [ 6 ] </ref> ) because the RPS and initial trees we regard, are directed non-cyclic graphs. * Mapping and Adaptation. The Structure Mapping Engine (SME) (see [ 3 ] and [ 2 ] ) is a program to examine analogical processes. It concentrates on the subprocess of mapping and adaption.
Reference: [ 7 ] <author> G. L. </author> <title> Steele Common LISP, </title> <publisher> Digital Press 1990 </publisher>
Reference-contexts: An example of an RPS is shown in figure 1. An initial tree of the same function is shown in figure 2. For the representation of our RPS and initial trees, we will use LISP <ref> [ 7 ] </ref> . 2.1 Finding The Most Similar RPS by Using a Graph Metric As the examples in our database are RPS's, we need to expand them to gather initial trees.
Reference: [ 8 ] <author> E. </author> <title> Tanaka A metric between unrooted and unordered trees and its Bottom-Up Computing Method. </title> <journal> in Transactions on Pattern Analysis and Machine Intelligence, </journal> <volume> Vol. 16, No. 12, </volume> <month> December </month> <year> 1994. </year>
Reference: [ 9 ] <author> S. Vosniadou, A. </author> <title> Ortony Similarity and analogical reasoning: a synthesis in Similarity and analogical reasoning, </title> <editor> S. Vosniadou, A. Ortony (editors), </editor> <publisher> Cambridge Univ. Press., </publisher> <address> Cambridge 1989 </address>
Reference-contexts: The retrieved case has to be adapted to fit the new problem. To achieve this, it is possibly necessary to substitute certain relations or objects. * Evaluation It has to be proved that the adapted solution solves the new problem. There are two kinds of analogies discussed in literature <ref> [ 9 ] </ref> : between-domain analogy and within-domain analogy. In between-domain analogy the analogically related items are drawn from the conceptually different or remote domains. In the within-domain analogy the items are drawn from the same domain, or at least from conceptually very close domains [ 9 ] . <p> of analogies discussed in literature <ref> [ 9 ] </ref> : between-domain analogy and within-domain analogy. In between-domain analogy the analogically related items are drawn from the conceptually different or remote domains. In the within-domain analogy the items are drawn from the same domain, or at least from conceptually very close domains [ 9 ] . An example for between-domain analogy is the Rutherford analogy: "The atom is like the solar system". The source or base domain of the "solar system" is astronomy and the domain of the "atom" (the target) is atomic physics.
Reference: [ 10 ] <author> Robert S. </author> <title> Williams Learning to program by examining and modifying cases in Proceedings of the fifth international conference on machine learning, </title> <editor> J. Laird (editor), </editor> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1988 </year>
Reference-contexts: Dershowitz uses modification, transformation and substitution to develop a program with a given specification by a known specification and its program. Like in other deductive approaches, the system needs much knowledge about programming. An inductive approach of programming by analogy is the system TA from Williams <ref> [ 10 ] </ref> . This system builds a case base of previously encountered functional programs, by using emulation networks to store informations about programs, patches and bugs. TA has an interactive component, which asks the user to decide between acceptable code fragments for the new program.
Reference: [ 11 ] <editor> Fritz Wysotzki Representation and induction of infinite concepts and recursive action sequences, </editor> <booktitle> in Proceedings of 8th IJCAI, </booktitle> <address> Karlsruhe, </address> <year> 1983 </year>
Reference-contexts: To make program code comparable we treat programs as structured objects, built up by using an algebraic semantic. Variables and constants are treated as objects. Functions are the relations, which exist between them. The approach of regarding programs as structured objects is described in Wysotzki <ref> [ 11 ] </ref> : A recursive program scheme (RPS) is synthesized by induction from a finite program, which is represented by an initial tree. In the last induction step, Wysotzki abstracts from the interpretation of the function symbols to get a generalized form of the RPS. <p> With these we can ver ify the inferred RPS. 2 The General Approach Our approach is based on the RPS and initial trees mentioned before <ref> [ 11 ] </ref> . An example of an RPS is shown in figure 1. An initial tree of the same function is shown in figure 2. <p> Expanding a Recursive Program Scheme A RPS is inferred from a finite program represented as a initial tree (see <ref> [ 11 ] </ref> ). Expanding a RPS means to inverse this process and build up an initial tree out of this RPS. Each RPS has to contain the head and the body of its function. The body contains the recursive call of the function with substituted parameter values.
References-found: 11

