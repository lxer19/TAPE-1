URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tm.outbox/MIT-LCS-TM-515.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/catatm.html
Root-URL: 
Email: rosario@theory.lcs.mit.edu  
Title: Using non-interactive proofs to achieve independence efficiently and securely  
Author: Rosario Gennaro 
Date: November 4, 1994  
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  
Abstract: Independence or simultaneous broadcast is a fundamental tool to achieve security in fault tolerant distributed computing. It allows n players to commit to independently chosen values. In this paper we present a constant round protocol to perform this task. Previous solutions were all O(log n) rounds. In the process we develop a new and stronger formal definition from this problem. As an example of the importance of independence in distributed protocols, we show an attack on the Sako-Kilian election scheme presented at CRYPTO 94 made possible by the protocol failure on achieving independence. Using our techniques we will show how to modify the scheme to make it secure. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Josh Benaloh and Moti Yung. </author> <title> Distributing the power of a government to en hance the privacy of voters. </title> <booktitle> In 5th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 52-62, </pages> <year> 1986. </year>
Reference-contexts: Their scheme is based on a previous protocol of Benaloh and Yung <ref> [1] </ref>.
Reference: [2] <author> Manuel Blum, Alfredo DeSantis, Silvio Micali, and Giuseppe Persiano. </author> <title> Non interactive zero-knowledge. </title> <journal> SIAM Journal of Computing, </journal> <volume> 20(6) </volume> <pages> 1084-1118, </pages> <month> De-cember </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Independence is a fundamental tool to achieve security in fault tolerant distributed protocols. In this paper we present improved results based on a careful exploitation of the properties of non-interactive proofs <ref> [2] </ref>. In particular we will exhibit the first constant round protocol for the problem of simultaneous broadcast (previous solutions were O (log n) rounds where n is the number of processors in the system). In the process we will develop a new and stronger formal definition for this problem. <p> More in detail: 1. We describe a constant round protocol for simultaneous broadcast. In doing that we will heavily rely on the properties of non-interactive zero-knowledge proofs as introduced by Blum, De Santis, Micali and Persiano in <ref> [2] </ref>. 2. We refine the definition of independence to a stronger one. In fact both in [3] and in [5] they define the independence property with respect to a polynomial-time bounded observer. <p> For details readers are referred to the original paper by Blum et al. <ref> [2] </ref> on non-interactive zero-knowledge proofs and the later one by De Santis and Persiano for the specific case of proofs of knowledge [4]. In this section we will also prove a technical lemma which will be useful to us later. <p> In <ref> [2] </ref> the authors describe a NIZKPS for the language SAT and so for all NP. In their protocol the Prover can be a polynomial time machine provided he knows a satisfying assignment for the formula. Protocols of this kind are called proofs of knowledge. <p> Notice that one of the consequences of this lemma is that access to the random string before the choice of the theorem y, does not help in proving false theorems. This fact was already mentioned in the original paper <ref> [2] </ref> and will be important later. 2.1 The Fiat-Shamir heuristic The Fiat-Shamir heuristic is a less rigorous but more efficient way of building noninteractive proofs. The heuristic is based on a secure hash function. <p> Then assume the existence of a pseudo-random function generator like the one in [7]. Then i = f t i1 (t i2 ). Remark: We do not need to generate a new string i for each time we perform the protocol. Indeed using results in <ref> [2, 6] </ref> it is known that multiple theorems can be proven using the same random string. 4 Election Protocols At CRYPTO 94 Sako and Kilian presented a new voting scheme based on partially compatible homomorphisms [10]. Their scheme is based on a previous protocol of Benaloh and Yung [1].
Reference: [3] <author> Benny Chor and Michael Rabin. </author> <title> Achieving independence in logarithmic number of rounds. </title> <booktitle> In 6th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 260-268, </pages> <year> 1987. </year>
Reference-contexts: Using our techniques we will show how to fix this problem and make Sako-Kilian scheme secure. 1 1.1 Why independence? The problem of independence in distributed protocols has been put forward by Chor and Rabin in <ref> [3] </ref> and subsequently by Dolev, Dwork and Naor in [5]. <p> As pointed out in [5] independence is clearly an extension of the concept of semantic security. 1 This example has been adapted from a similar one described in [5] 2 1.2 Previous work Chor and Rabin in <ref> [3] </ref> put forward a first formal definition for the problem of simultaneous broadcast: a protocol that allows n players to independently announce n bits. Their solution requires O (log n) rounds to complete. Clearly this protocol solves the coin flipping problem. <p> We describe a constant round protocol for simultaneous broadcast. In doing that we will heavily rely on the properties of non-interactive zero-knowledge proofs as introduced by Blum, De Santis, Micali and Persiano in [2]. 2. We refine the definition of independence to a stronger one. In fact both in <ref> [3] </ref> and in [5] they define the independence property with respect to a polynomial-time bounded observer. That is no polynomial-time Turing machine that has access to a random sample of successful executions of the protocol is able to detect any correlation among the committed values of the players. <p> This formalization guarantees statistical independence of the committed values. This is where our definition differs from the ones presented previously. In fact the definitions in <ref> [3, 5] </ref> require the values b i and r to appear independent to a probabilistic polynomial time judge. If we assume the players to be computationally bounded this is enough to guarantee the independence of their actions. <p> As pointed out in <ref> [3] </ref> and [5] the problem is eliminated by requiring each party to provide a zero-knowledge proof of knowledge of the committed bit. <p> Suppose in fact that a faulty P i and a correct P j are concurrently providing zero-knowledge proofs, then when queried P i could use P j as an oracle to answer his queries. Chor-Rabin in <ref> [3] </ref> solve this problem by a clever way of scheduling the zero-knowledge proofs. In their protocol each player P i broadcast his encryption scheme 7 E i and the encrypted value E i (b i ). Then each player proves in zero-knowledge that he knows b i .
Reference: [4] <author> Alfredo DeSantis and Giuseppe Persiano. </author> <title> Zero-knowledge proofs of knowledge without interaction. </title> <booktitle> In 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1992. </year>
Reference-contexts: For details readers are referred to the original paper by Blum et al. [2] on non-interactive zero-knowledge proofs and the later one by De Santis and Persiano for the specific case of proofs of knowledge <ref> [4] </ref>. In this section we will also prove a technical lemma which will be useful to us later. In a non-interactive proof, prover P and verifier V share a common input x and a random string . <p> In [2] the authors describe a NIZKPS for the language SAT and so for all NP. In their protocol the Prover can be a polynomial time machine provided he knows a satisfying assignment for the formula. Protocols of this kind are called proofs of knowledge. In that case (see <ref> [4] </ref>) the soundness condition is changed to one requiring the Prover to know a witness of the theorem whenever he convinces the Verifier. By "knowing a witness" we mean as usual that there exists a knowledge extractor M which given access to P efficiently produces a witness.
Reference: [5] <author> Danny Dolev, Cynthia Dwork, and Moni Naor. </author> <title> Non-malleable cryptography. </title> <booktitle> In 23rd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 542-552, </pages> <year> 1991. </year>
Reference-contexts: Using our techniques we will show how to fix this problem and make Sako-Kilian scheme secure. 1 1.1 Why independence? The problem of independence in distributed protocols has been put forward by Chor and Rabin in [3] and subsequently by Dolev, Dwork and Naor in <ref> [5] </ref>. Informally this means that we are looking for protocols in which two or more parties announce some values and we want to prevent any of them to correlate in any manner his/her own values to the values that the other parties have announced. <p> The reason is that the definition of semantic security for cryptosystems [9] guarantees that given a cyphertext we cannot learn anything about the corresponding cleartext. However in distributed settings this is not enough: we want the cyphertext to be completely useless. As pointed out in <ref> [5] </ref> independence is clearly an extension of the concept of semantic security. 1 This example has been adapted from a similar one described in [5] 2 1.2 Previous work Chor and Rabin in [3] put forward a first formal definition for the problem of simultaneous broadcast: a protocol that allows n <p> However in distributed settings this is not enough: we want the cyphertext to be completely useless. As pointed out in <ref> [5] </ref> independence is clearly an extension of the concept of semantic security. 1 This example has been adapted from a similar one described in [5] 2 1.2 Previous work Chor and Rabin in [3] put forward a first formal definition for the problem of simultaneous broadcast: a protocol that allows n players to independently announce n bits. Their solution requires O (log n) rounds to complete. Clearly this protocol solves the coin flipping problem. <p> In doing that we will heavily rely on the properties of non-interactive zero-knowledge proofs as introduced by Blum, De Santis, Micali and Persiano in [2]. 2. We refine the definition of independence to a stronger one. In fact both in [3] and in <ref> [5] </ref> they define the independence property with respect to a polynomial-time bounded observer. That is no polynomial-time Turing machine that has access to a random sample of successful executions of the protocol is able to detect any correlation among the committed values of the players. <p> This formalization guarantees statistical independence of the committed values. This is where our definition differs from the ones presented previously. In fact the definitions in <ref> [3, 5] </ref> require the values b i and r to appear independent to a probabilistic polynomial time judge. If we assume the players to be computationally bounded this is enough to guarantee the independence of their actions. <p> As pointed out in [3] and <ref> [5] </ref> the problem is eliminated by requiring each party to provide a zero-knowledge proof of knowledge of the committed bit.
Reference: [6] <author> Uri Feige, Dror Lapidot, and Adi Shamir. </author> <title> Multiple non-interactive zero knowledge proofs. </title> <booktitle> In 31st IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: Then each player will share his value among all other player using the VSS protocol from [8]. The total number of rounds will be constant. To be able to use NIZK proofs we must assume the existence of trapdoor permutations (see <ref> [6] </ref>). We assume that the players share a random string nk bits long where k is the length needed from the reference string in order to do a NIZKP in our protocol. <p> Then assume the existence of a pseudo-random function generator like the one in [7]. Then i = f t i1 (t i2 ). Remark: We do not need to generate a new string i for each time we perform the protocol. Indeed using results in <ref> [2, 6] </ref> it is known that multiple theorems can be proven using the same random string. 4 Election Protocols At CRYPTO 94 Sako and Kilian presented a new voting scheme based on partially compatible homomorphisms [10]. Their scheme is based on a previous protocol of Benaloh and Yung [1].
Reference: [7] <author> Oded Goldreich, Shafi Goldwasser, and Silvio Micali. </author> <title> How to construct random functions. </title> <journal> Journal of the ACM, </journal> <volume> 33 </volume> <pages> 792-807, </pages> <year> 1986. </year>
Reference-contexts: Then assume the existence of a pseudo-random function generator like the one in <ref> [7] </ref>. Then i = f t i1 (t i2 ). Remark: We do not need to generate a new string i for each time we perform the protocol.
Reference: [8] <author> Oded Goldreich, Silvio Micali, and Avi Wigderson. </author> <title> Proofs that yield nothing but their validity or all languages in np have zero-knowledge proof systems. </title> <journal> Journal of the ACM, </journal> <volume> 38(1) </volume> <pages> 691-729, </pages> <year> 1991. </year>
Reference-contexts: Because of Lemma 1 this will eliminate the risk of correlation. Then each player will share his value among all other player using the VSS protocol from <ref> [8] </ref>. The total number of rounds will be constant. To be able to use NIZK proofs we must assume the existence of trapdoor permutations (see [6]). <p> If t + 1 such votes are casted P i is disqualified and his value is assumed to be ? 4. Each non-disqualified process P i shares his value b i among all players using the VSS protocol of <ref> [8] </ref>. I.e., P i chooses a random polynomial R i (x) of degree t, such that R (0) = b i . P i sends to player P j the value R i (j) encrypted with P j 's public key.
Reference: [9] <author> Shafi Goldwasser and Silvio Micali. </author> <title> Probabilisitc encryption. </title> <journal> Journal of Com puter and System Sciences, </journal> <volume> 28 </volume> <pages> 270-299, </pages> <year> 1984. </year>
Reference-contexts: The examples above show that encryption is necessary to this task, but not sufficient. The reason is that the definition of semantic security for cryptosystems <ref> [9] </ref> guarantees that given a cyphertext we cannot learn anything about the corresponding cleartext. However in distributed settings this is not enough: we want the cyphertext to be completely useless. <p> In the following description of the protocol, let t = n 2 be the allowed fault tolerance. Protocol 1 1. Each process P i publishes his own public key encryption scheme E i . E i is actually a probabilistic encryption scheme as in <ref> [9] </ref> 2.
Reference: [10] <author> Kazue Sako and Joe Kilian. </author> <title> Secure voting using partially compatible homo morphisms. </title> <booktitle> In CRYPTO'94, volume 839 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <month> 13 </month>
Reference-contexts: In the process we will develop a new and stronger formal definition for this problem. Finally as a practical example of the importance of achieving independence in distributed protocol we show an attack to the Sako-Kilian election scheme <ref> [10] </ref> made possible by the protocol failure on achieving independence. <p> A fortiori this will be valid for the players themselves and the adversary since we assume them to be polynomially bounded. 3. We present an attack on the Sako-Kilian election scheme presented at CRYPTO 94 <ref> [10] </ref>. The idea of using non-interactive proofs to reduce the rounds of communication in a protocol is not new. For example this is what Sako and Kilian do in their protocol. However one must be careful in the use of such a powerful tool. <p> Indeed using results in [2, 6] it is known that multiple theorems can be proven using the same random string. 4 Election Protocols At CRYPTO 94 Sako and Kilian presented a new voting scheme based on partially compatible homomorphisms <ref> [10] </ref>. Their scheme is based on a previous protocol of Benaloh and Yung [1]. <p> In particular they make extended use of the Fiat-Shamir heuristic for removing interaction from proofs of knowledge and so improve substantially on the round complexity of the protocol. In this section we will show that the scheme described in <ref> [10] </ref> fails on achieving independence between votes casted by different players. The problem lies on a wrong application of the Fiat-Shamir scheme that brings consequences similar to the ones described in Section 2.1. <p> Finally set T = t 1 + t 2 . T is equal to the difference between "yes" and "no" votes. The zero-knowledge protocol to check the correctness of the proof can be found in the original paper <ref> [10] </ref>. It is a straightforward commit-challenge-reveal protocol. To eliminate interaction the Fiat-Shamir heuristic is used.
References-found: 10

