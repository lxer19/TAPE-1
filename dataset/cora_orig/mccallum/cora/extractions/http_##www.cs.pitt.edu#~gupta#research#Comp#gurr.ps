URL: http://www.cs.pitt.edu/~gupta/research/Comp/gurr.ps
Refering-URL: http://www.cs.pitt.edu/~gupta/research/scheduling.html
Root-URL: 
Email: berson@cs.pitt.edu  gupta@cs.pitt.edu  soffa@cs.pitt.edu  
Phone: Fax: (412) 624-5249  
Title: GURRR: A Global Unified Resource Requirements Representation  
Author: David A. Berson Rajiv Gupta Mary Lou Soffa 
Address: Pittsburgh Pittsburgh, Pa. 15260  
Affiliation: Computer Science Department University of  
Abstract: When compiling for instruction level parallelism (ILP), the integration of the optimization phases can lead to an improvement in the quality of code generated. However, since several different representations of a program are used in the various phases, only a partial integration has been achieved to date. We present a program representation that combines resource requirements and availability information with control and data dependence information. The representation enables the integration of several optimizing phases, including transformations, register allocation, and instruction scheduling. The basis of this integration is the simultaneous allocation of different types of resources. We define the representation and show how it is constructed. We then formulate several optimization phases to use the representation to achieve better integration. 
Abstract-found: 1
Intro-found: 1
Reference: [AEBK94] <author> Wolfgang Ambrosch, M. Anton Ertl, Felix Beer, and Andreas Krall. </author> <title> Dependence-conscious global register allocation. </title> <booktitle> In Proceedings of the Conference on Computer Languages and Systems Architecture, </booktitle> <address> Zurich, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: Typically, a graph coloring approach is used to address register demands. The Register Interference Graph is constructed to indicate which variables compete for registers. The PDG can be used to build a register interference graph that more accurately reflects overlapping live ranges in parallel programs <ref> [Pin93, NP93, AEBK94] </ref>. The interference graph provides a method for measuring register demands. In practice, an inaccurate measure of demands is computed by counting the number of other values that a given value interferes with. A more accurate method could find cliques in the interference graph.
Reference: [AN88a] <author> Alexander Aiken and Alexandru Nicolau. </author> <title> A development environment for horizontal microcode. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 14(5), </volume> <year> 1988. </year>
Reference-contexts: Resource Spackling was designed to be a framework that could combine the resource usage information with several global code motion mechanisms and their corresponding representations. The representations and mechanisms include the PDG using Region Scheduling [GS90] and the Control Flow Graph using either Trace Scheduling [Fis81] or Percolation Scheduling <ref> [AN88a] </ref>. The resource usage information computed did not include hierarchical resource requirements. 7 Summary We have presented the Global Unified Resource Requirements Representation (GURRR) as a representation for use in integrating phases of a compiler for instruction level parallelism.
Reference: [AN88b] <author> Alexander Aiken and Alexandru Nicolau. </author> <title> Optimal loop parallelization. </title> <booktitle> In Proc. of Sigplan '88 Conf. on Programming Language Design and Implementation , ACM Sigplan Notices, </booktitle> <volume> volume 23, </volume> <year> 1988. </year>
Reference-contexts: Region Scheduling does attempt to expose an appropriate amount of parallelism, but uses coarse estimates that do not consider register demands [GS90]. The special case of exposing parallelism through software pipelining has received attention for scheduling the resulting parallelism, <ref> [Lam88, AN88b] </ref> and more recent work has also considered register allocation [RLTS92, NG93]. To address the interactions between register allocation and instruction scheduling phases, we present a new representation that incorporates resource requirements and availability. <p> The resulting set of instructions B 1 , T1 2 , T2 2 , and A 3 can be used as the kernel of a software pipeline <ref> [Lam88, AN88b] </ref>. 5 Incremental Updating of GURRR In order to consider the impact of transformations on the allocation of resources, GURRR is able to reflect changes in resource requirements resulting from the transformations applied to the program.
Reference: [ASU86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ull-man. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: The CFG is used to collect a variety of information, including dataflow dependencies and live value ranges <ref> [ASU86] </ref>. Extensions to the CFG such as Traces [Fis81] and Super Blocks [HMC + 93] have been developed in an effort to support global code motion. The CFG is also traditionally used to construct register interference graphs.
Reference: [AWZ88] <author> B. Alpern, M. N. Wegman, and F. K. Zadeck. </author> <title> Detecting equality of values in programs. </title> <booktitle> In Conf. Rec. 15th ACM Symp. on Prin. of Programming Languages, </booktitle> <year> 1988. </year>
Reference-contexts: Regions support more powerful global code motion techniques than are possible on the CFG [GS90, BR91]. Static Single Assignment (SSA) form uniquely names to each definition of a variable [RWZ88]. The use of unique names simplifies constant propagation and other analyses <ref> [AWZ88] </ref>. SSA was originally formulated on the CFG but has been incorporated in PDG based representations [BMO90]. The Program Structure Tree (PST) is a hierarchical representation that can be used by divide-and-conquer algorithms to speedup dataflow analysis and computation of SSA.
Reference: [BGS93] <author> David A. Berson, Rajiv Gupta, and Mary Lou Soffa. </author> <title> URSA: A Unified ReSource Allocator for registers and functional units in VLIW architectures. </title> <booktitle> In Proc. of IFIP WG 10.3 Working Conference on Architectures and Compliation Techniques for Fine and Medium Grain Parallelism, </booktitle> <year> 1993. </year> <note> (also available as University of Pitts-burgh Computer Science Department Technical Report 92-21). 33 </note>
Reference-contexts: Resource allocation decisions only need to be made when there are locations in a program segment that require more instances of a resource than are available. Advanced resource allocation algorithms, such as those based on the Measure and Reduce paradigm <ref> [BGS93] </ref> and to some extent global schedulers, move instructions from locations where there are insufficient instances of a resource to locations where extra resource instances are available. Thus, the resource usage information must indicate all locations where resources are either over-utilized or under-utilized. <p> A program is executable if and only if all segments are executable. Ideally, the representation should supply precise resource measurements. In previous work we have shown that computing precise register measurements for parallel architectures or when code reordering is considered is NP-complete <ref> [BGS93] </ref>. Thus, there is a trade-off between the precision of the measurements and the time taken to compute them. We have developed fast heuristics for measuring register requirements that are demonstrably precise. The measurability of the representation allows resource usage information for all resources to be computed. <p> Excessive sets are the nodes in the locations where a resource is over-utilized. The resource requirements of a region are measured by finding the minimum number of disjoint allocation chains that contain all instruction and subregion nodes in a region <ref> [BGS93] </ref>. The reuse edges composing allocation chains are marked as such. The allocation chains in a region are used to locate the two indicators of resource usage levels: excessive sets and resource holes. Excessive sets are annotated in the region node. <p> Control, data, and temporal dependencies, and reuse edges are indicated by bold, normal, dashed, and dotted lines, respectively. To improve readability only the reuse edges for registers have been drawn. The selection of the nodes that can reuse the registers used by instructions A and B is described elsewhere <ref> [BGS93] </ref>. To be considered useful for unified resource allocation GURRR must satisfy the unified representation properties. GURRR satisfies the Measurability property by using the reuse edges and allocation chains to compute each region's requirements for all resources. <p> For non-spanning resources, avail [n] is the set of n's closest ancestors that use R. Computing avail [n] for spanning resources requires a special component analysis. The identification and analysis of most components can be performed in graph linear time. However, for a few components the analysis is NP-Complete <ref> [BGS93] </ref>. We formulate the component analysis as a minimal set covering problem and use a graph linear greedy heuristic that has a ratio bound of lnjXj + 1, where X is the number of nodes in the component [CLR90] 1 . <p> Without some form of resource usage information the Executability property cannot be satisfied GURRR uses results from our earlier work. In the Unified ReSource Allocator (URSA) we developed the Measure and Reduce paradigm and the algorithms to measure resource requirements, i.e., allocation chains, and find excessive sets <ref> [BGS93] </ref>. URSA was designed to operate on large basic blocks, such as those resulting from Trace Scheduling. Simple transformations were used to reduce the excessive resource requirements by introducing temporal dependencies to sequentialize the excessive demands.
Reference: [BGS94] <author> David A. Berson, Rajiv Gupta, and Mary Lou Soffa. </author> <title> Resource Spackling: A framework for integrating register allocation in local and global schedulers. </title> <booktitle> In Proc. of IFIP WG 10.3 Working Conference on Parallel Architectures and Compilation Techniques, </booktitle> <year> 1994. </year> <note> (also available as University of Pittsburgh Computer Science Department Technical Report 94-09). </note>
Reference-contexts: There are several cases when different sets of spill instructions need to be inserted, depending on whether the spanning hole is a Free or Slack hole and where the uses of the value (s) computed by the selected nodes occur. Details are given elsewhere <ref> [BGS94] </ref>. The goal during the selection of holes is to minimize any increase in the execution time of the region. Therefore, the holes selected should meet two requirements. <p> Simple transformations were used to reduce the excessive resource requirements by introducing temporal dependencies to sequentialize the excessive demands. Resource Spackling introduced the notion of resource holes and used the resource usage information to develop reduction transformations that moved excessive resource demands to resource holes <ref> [BGS94] </ref>. These reduction transformations are used for local scheduling and when performing global code motion. Resource Spackling was designed to be a framework that could combine the resource usage information with several global code motion mechanisms and their corresponding representations.
Reference: [BMO90] <author> Robert A. Ballance, Arthur B. Maccabe, and Karl J. Ottenstein. </author> <title> The program dependence web: A representation supporting control-, data-, and demand-driven interpretation of imperative languages. </title> <booktitle> In Proc. of Sigplan '90 Conf. on Programming Language Design and Implementation, </booktitle> <year> 1990. </year>
Reference-contexts: Static Single Assignment (SSA) form uniquely names to each definition of a variable [RWZ88]. The use of unique names simplifies constant propagation and other analyses [AWZ88]. SSA was originally formulated on the CFG but has been incorporated in PDG based representations <ref> [BMO90] </ref>. The Program Structure Tree (PST) is a hierarchical representation that can be used by divide-and-conquer algorithms to speedup dataflow analysis and computation of SSA. The PST does not directly identify the control dependencies used by region based global code motion algorithms. <p> A number of representations allowing direct interpretation have been proposed, including the Dependence Flow Graph [PBJ + 91, JP93] and Value Dependence [WCES94], but do not contain control dependence information. The Program Dependence Web <ref> [BMO90] </ref> is an interpretable representation that places a variation of SSA form on the PDG. Our current research has not examined uses requiring an interpretable representation and has concentrated on global code motion algorithms that exploit control dependence information. None of the representations mentioned satisfactorily meet the unified representation properties.
Reference: [BR91] <author> David Bernstein and Michael Rodeh. </author> <title> Global instruction scheduling for superscalar machines. </title> <booktitle> In Proc. of Sigplan '91 Conf. on Programming Language Design and Implementation, </booktitle> <year> 1991. </year>
Reference-contexts: The Program Dependence Graph (PDG) combines Control and Data dependence information to simplify many transformations [FOW87]. Control dependencies are used to identify regions of instructions that execute under the same conditions. Regions support more powerful global code motion techniques than are possible on the CFG <ref> [GS90, BR91] </ref>. Static Single Assignment (SSA) form uniquely names to each definition of a variable [RWZ88]. The use of unique names simplifies constant propagation and other analyses [AWZ88]. SSA was originally formulated on the CFG but has been incorporated in PDG based representations [BMO90].
Reference: [CK91] <author> David Callahan and Brain Koblenz. </author> <title> Register allocation via heirachical graph coloring. </title> <booktitle> In Proc. of Sigplan '91 Conf. on Programming Language Design and Implementation, </booktitle> <year> 1991. </year>
Reference-contexts: Next, we examine the integration of global code motions and register allocation. Finally, we integrate parallelizing transformations with resource allocation. 4.1 Global Register Allocation and Instruction Scheduling Hierarchical register allocation on the Control Flow Graph has been suggested by Callahan and Kennedy <ref> [CK91] </ref>, and on the PDG by Norris and Pollock [NP94]. GURRR supports full integration of hierarchical register allocation and instruction scheduling. The allocations are performed on a region by region basis during a bottom-up traversal of the forward control dependencies.
Reference: [CLR90] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: However, for a few components the analysis is NP-Complete [BGS93]. We formulate the component analysis as a minimal set covering problem and use a graph linear greedy heuristic that has a ratio bound of lnjXj + 1, where X is the number of nodes in the component <ref> [CLR90] </ref> 1 . The computation of avail [n] and CanReuse are graph linear and the resulting Reuse DAGs contain O (N 2 ) reuse edges. 1 In our limited experimentation the components requiring the heuristic had six or fewer nodes. The heuristic always found a precise answer.
Reference: [Dil50] <author> R. P. </author> <title> Dilworth. A decomposition theorem for partially ordered sets. </title> <journal> Annuals of Mathematics, </journal> <volume> 51, </volume> <year> 1950. </year>
Reference-contexts: The capability of measuring the resource requirements is based on a result by Dilworth, which states that the maximum number of independent elements in a partial order is equal to the number of chains in a minimum decomposition <ref> [Dil50] </ref>. Thus, the maximum resource requirements of Reuse DAG can be computed by finding the minimum number of allocation chains that cover the Reuse DAG.
Reference: [Dow94] <author> Chyi-Ren Dow. </author> <title> Pivot: A program paralleliza-tion and visualization environment. </title> <type> Technical Report Technical Report 94-22, Ph.D. Dissertation, </type> <institution> University of Pittsburgh, Computer Science Department, </institution> <year> 1994. </year>
Reference-contexts: It would be useful to be able to estimate the impact of a possible transformation on the resource requirements. In this section we sketch techniques for incrementally updating GURRR. In previous work on specifying transformations a basic set of program edits to describe the transformations has been used <ref> [WS91, Dow94] </ref>. We define the following set of Standard Edit Functions (SEFs), which apply a transformation to the elements of a PDG.
Reference: [FF65] <author> L. R. Ford and D. R. Fulkerson. </author> <title> Flows in Networks. </title> <publisher> Princeton University Press, </publisher> <address> Princeton, N.J., </address> <year> 1965. </year>
Reference-contexts: Thus, the maximum resource requirements of Reuse DAG can be computed by finding the minimum number of allocation chains that cover the Reuse DAG. Ford and Fulkerson have shown that computing a minimum chain decomposition can be performed using bipartite matching <ref> [FF65] </ref>, in O ( p N E) time [HK73]. In practice the matching is performed on the Reuse R DAG. The matching edges are labeled as such with one in-coming and one out going matching edge per instance of R used by the node.
Reference: [Fis81] <author> Joseph A. Fisher. </author> <title> Trace scheduling: A technique for global microcode compaction. </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-30(7), </volume> <year> 1981. </year>
Reference-contexts: The CFG is used to collect a variety of information, including dataflow dependencies and live value ranges [ASU86]. Extensions to the CFG such as Traces <ref> [Fis81] </ref> and Super Blocks [HMC + 93] have been developed in an effort to support global code motion. The CFG is also traditionally used to construct register interference graphs. The Program Dependence Graph (PDG) combines Control and Data dependence information to simplify many transformations [FOW87]. <p> Resource Spackling was designed to be a framework that could combine the resource usage information with several global code motion mechanisms and their corresponding representations. The representations and mechanisms include the PDG using Region Scheduling [GS90] and the Control Flow Graph using either Trace Scheduling <ref> [Fis81] </ref> or Percolation Scheduling [AN88a]. The resource usage information computed did not include hierarchical resource requirements. 7 Summary We have presented the Global Unified Resource Requirements Representation (GURRR) as a representation for use in integrating phases of a compiler for instruction level parallelism.
Reference: [FOW87] <author> Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Trans. Prog. Lang. and Systems, </journal> <volume> 9(3), </volume> <year> 1987. </year>
Reference-contexts: The CFG is also traditionally used to construct register interference graphs. The Program Dependence Graph (PDG) combines Control and Data dependence information to simplify many transformations <ref> [FOW87] </ref>. Control dependencies are used to identify regions of instructions that execute under the same conditions. Regions support more powerful global code motion techniques than are possible on the CFG [GS90, BR91]. Static Single Assignment (SSA) form uniquely names to each definition of a variable [RWZ88].
Reference: [GH88] <author> James R. Goodman and Wie-Chung Hsu. </author> <title> Code scheduling and register allocation in large basic blocks. </title> <booktitle> In Proc. of ACM Supercomputing Conf., </booktitle> <year> 1988. </year>
Reference-contexts: Recent works have developed methods to incorporate some information from one phase into the other, but are unable to fully represent register allocation and instruction scheduling in a single representation and thus do not achieve the full integration of allocating functional units and registers simultaneously <ref> [GH88, NP93] </ref>. Little work has been done on integrating other back-end phases as well. Typically other back-end phases, such as global code motion, code optimizations, and loop transformations are performed without considering their impact on register allocation.
Reference: [GS90] <author> Rajiv Gupta and Mary Lou Soffa. </author> <title> Region scheduling: An approach for detecting and redistributing parallelism. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 16(4), </volume> <year> 1990. </year>
Reference-contexts: The result is that too much par-allelism may be exposed and then must be removed by the scheduler. Region Scheduling does attempt to expose an appropriate amount of parallelism, but uses coarse estimates that do not consider register demands <ref> [GS90] </ref>. The special case of exposing parallelism through software pipelining has received attention for scheduling the resulting parallelism, [Lam88, AN88b] and more recent work has also considered register allocation [RLTS92, NG93]. <p> The Program Dependence Graph (PDG) combines Control and Data dependence information to simplify many transformations [FOW87]. Control dependencies are used to identify regions of instructions that execute under the same conditions. Regions support more powerful global code motion techniques than are possible on the CFG <ref> [GS90, BR91] </ref>. Static Single Assignment (SSA) form uniquely names to each definition of a variable [RWZ88]. The use of unique names simplifies constant propagation and other analyses [AWZ88]. SSA was originally formulated on the CFG but has been incorporated in PDG based representations [BMO90]. <p> These reduction transformations are used for local scheduling and when performing global code motion. Resource Spackling was designed to be a framework that could combine the resource usage information with several global code motion mechanisms and their corresponding representations. The representations and mechanisms include the PDG using Region Scheduling <ref> [GS90] </ref> and the Control Flow Graph using either Trace Scheduling [Fis81] or Percolation Scheduling [AN88a].
Reference: [HK73] <author> John E. Hopcroft and Richard M. Karp. </author> <title> An N 5=2 algorithm for maximum matchings in bipartite graphs. </title> <journal> SIAM JOURNAL of Computing, </journal> <volume> 2(4), </volume> <year> 1973. </year>
Reference-contexts: Thus, the maximum resource requirements of Reuse DAG can be computed by finding the minimum number of allocation chains that cover the Reuse DAG. Ford and Fulkerson have shown that computing a minimum chain decomposition can be performed using bipartite matching [FF65], in O ( p N E) time <ref> [HK73] </ref>. In practice the matching is performed on the Reuse R DAG. The matching edges are labeled as such with one in-coming and one out going matching edge per instance of R used by the node.
Reference: [HMC + 93] <author> Wen-Mei W. Hwu, Scott A. Mahlke, William Y. Chen, Pohua P. Chang, Nancy J. Warter, Roger A. Bringmann, Roland G. Ouellette, Richard E. Hank, Tokuzo Kiyohara, Grant E. Haab, John G. Holm, and Daniel M. Lavery. </author> <title> The Superblock: An effective technique for VLIW and superscalar compliation. </title> <booktitle> In The Journal of Supercomputing, volume A, </booktitle> <year> 1993. </year>
Reference-contexts: The CFG is used to collect a variety of information, including dataflow dependencies and live value ranges [ASU86]. Extensions to the CFG such as Traces [Fis81] and Super Blocks <ref> [HMC + 93] </ref> have been developed in an effort to support global code motion. The CFG is also traditionally used to construct register interference graphs. The Program Dependence Graph (PDG) combines Control and Data dependence information to simplify many transformations [FOW87].
Reference: [JP93] <author> Richard Johnson and Keshav Pingali. </author> <title> Dependence-based program analysis. </title> <booktitle> In Proc. of Sigplan '93 Conf. on Programming Language Design and Implementation, </booktitle> <year> 1993. </year>
Reference-contexts: The PST does not directly identify the control dependencies used by region based global code motion algorithms. A number of representations allowing direct interpretation have been proposed, including the Dependence Flow Graph <ref> [PBJ + 91, JP93] </ref> and Value Dependence [WCES94], but do not contain control dependence information. The Program Dependence Web [BMO90] is an interpretable representation that places a variation of SSA form on the PDG.
Reference: [Lam88] <author> Monica Lam. </author> <title> Software pipelining: An effective scheduling technique for VLIW machines. </title> <booktitle> In Proc. of Sigplan '88 Conf. on Programming Language Design and Implementation , ACM Sig-plan Notices, </booktitle> <volume> volume 23, </volume> <year> 1988. </year>
Reference-contexts: Region Scheduling does attempt to expose an appropriate amount of parallelism, but uses coarse estimates that do not consider register demands [GS90]. The special case of exposing parallelism through software pipelining has received attention for scheduling the resulting parallelism, <ref> [Lam88, AN88b] </ref> and more recent work has also considered register allocation [RLTS92, NG93]. To address the interactions between register allocation and instruction scheduling phases, we present a new representation that incorporates resource requirements and availability. <p> The resulting set of instructions B 1 , T1 2 , T2 2 , and A 3 can be used as the kernel of a software pipeline <ref> [Lam88, AN88b] </ref>. 5 Incremental Updating of GURRR In order to consider the impact of transformations on the allocation of resources, GURRR is able to reflect changes in resource requirements resulting from the transformations applied to the program.
Reference: [NG93] <author> Qi Ning and Guang R. Gao. </author> <title> A novel framework of register allocation for software pipelining. </title> <booktitle> In Conf. Rec. 20th ACM Symp. on Prin. of Programming Languages, </booktitle> <year> 1993. </year>
Reference-contexts: The special case of exposing parallelism through software pipelining has received attention for scheduling the resulting parallelism, [Lam88, AN88b] and more recent work has also considered register allocation <ref> [RLTS92, NG93] </ref>. To address the interactions between register allocation and instruction scheduling phases, we present a new representation that incorporates resource requirements and availability. This representation permits the impact of each decision in a phase to be determined from several key indicators of program execution.
Reference: [NP93] <author> Cindy Norris and Lori Pollock. </author> <title> A scheduler-sensitive global register allocator. </title> <booktitle> In Proc. of Supercomputing '93, </booktitle> <year> 1993. </year>
Reference-contexts: The nodes in the graph are then colored with colors indicating the register assigned to a node's live value. Recent techniques have been developed to compute the additional interferences that can occur due to parallel instruction execution and instruction reordering <ref> [Pin93, NP93] </ref>. However, the interference graph does not provide precise information to indicate the effect of an allocation decision on the execution time of the program. Instruction scheduling is typically performed on a dependence DAG using some variant of list scheduling. <p> Recent works have developed methods to incorporate some information from one phase into the other, but are unable to fully represent register allocation and instruction scheduling in a single representation and thus do not achieve the full integration of allocating functional units and registers simultaneously <ref> [GH88, NP93] </ref>. Little work has been done on integrating other back-end phases as well. Typically other back-end phases, such as global code motion, code optimizations, and loop transformations are performed without considering their impact on register allocation. <p> Typically, a graph coloring approach is used to address register demands. The Register Interference Graph is constructed to indicate which variables compete for registers. The PDG can be used to build a register interference graph that more accurately reflects overlapping live ranges in parallel programs <ref> [Pin93, NP93, AEBK94] </ref>. The interference graph provides a method for measuring register demands. In practice, an inaccurate measure of demands is computed by counting the number of other values that a given value interferes with. A more accurate method could find cliques in the interference graph.
Reference: [NP94] <author> Cindy Norris and Lori L. Pollock. </author> <title> Register allocation over the program dependence graph. </title> <booktitle> In Proc. of Sigplan '94 Conf. on Programming Language Design and Implementation, </booktitle> <year> 1994. </year>
Reference-contexts: Finally, we integrate parallelizing transformations with resource allocation. 4.1 Global Register Allocation and Instruction Scheduling Hierarchical register allocation on the Control Flow Graph has been suggested by Callahan and Kennedy [CK91], and on the PDG by Norris and Pollock <ref> [NP94] </ref>. GURRR supports full integration of hierarchical register allocation and instruction scheduling. The allocations are performed on a region by region basis during a bottom-up traversal of the forward control dependencies.
Reference: [PBJ + 91] <author> K. Pingali, M. Beck, R. Johnson, M. Moudgill, and P. Stodghill. </author> <title> Dependence flow graphs: An algebraic approach to program dependencies. </title> <booktitle> In Conf. Rec. 18th ACM Symp. on Prin. of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: The PST does not directly identify the control dependencies used by region based global code motion algorithms. A number of representations allowing direct interpretation have been proposed, including the Dependence Flow Graph <ref> [PBJ + 91, JP93] </ref> and Value Dependence [WCES94], but do not contain control dependence information. The Program Dependence Web [BMO90] is an interpretable representation that places a variation of SSA form on the PDG.
Reference: [Pin93] <author> Shlomit S. Pinter. </author> <title> Register allocation with instruction scheduling: A new approach. </title> <booktitle> In Proc. of Sigplan '93 Conf. on Programming Language Design and Implementation, </booktitle> <year> 1993. </year>
Reference-contexts: The nodes in the graph are then colored with colors indicating the register assigned to a node's live value. Recent techniques have been developed to compute the additional interferences that can occur due to parallel instruction execution and instruction reordering <ref> [Pin93, NP93] </ref>. However, the interference graph does not provide precise information to indicate the effect of an allocation decision on the execution time of the program. Instruction scheduling is typically performed on a dependence DAG using some variant of list scheduling. <p> Typically, a graph coloring approach is used to address register demands. The Register Interference Graph is constructed to indicate which variables compete for registers. The PDG can be used to build a register interference graph that more accurately reflects overlapping live ranges in parallel programs <ref> [Pin93, NP93, AEBK94] </ref>. The interference graph provides a method for measuring register demands. In practice, an inaccurate measure of demands is computed by counting the number of other values that a given value interferes with. A more accurate method could find cliques in the interference graph.
Reference: [RLTS92] <author> B. R. Rau, M. Lee, P.P. Tirumalai, and M. S. Schlansker. </author> <title> Register allocation for software pipelined loops. </title> <booktitle> In Proc. of Sigplan '92 Conf. on Programming Language Design and Implementation, </booktitle> <year> 1992. </year>
Reference-contexts: The special case of exposing parallelism through software pipelining has received attention for scheduling the resulting parallelism, [Lam88, AN88b] and more recent work has also considered register allocation <ref> [RLTS92, NG93] </ref>. To address the interactions between register allocation and instruction scheduling phases, we present a new representation that incorporates resource requirements and availability. This representation permits the impact of each decision in a phase to be determined from several key indicators of program execution.
Reference: [RWZ88] <author> B. K. Rosen, M. N. Wegman, and F. K. Zadeck. </author> <title> Global value numbers and redundant computations. </title> <booktitle> In Conf. Rec. 15th ACM Symp. on Prin. of Programming Languages, </booktitle> <year> 1988. </year>
Reference-contexts: Control dependencies are used to identify regions of instructions that execute under the same conditions. Regions support more powerful global code motion techniques than are possible on the CFG [GS90, BR91]. Static Single Assignment (SSA) form uniquely names to each definition of a variable <ref> [RWZ88] </ref>. The use of unique names simplifies constant propagation and other analyses [AWZ88]. SSA was originally formulated on the CFG but has been incorporated in PDG based representations [BMO90].
Reference: [WCES94] <author> Daniel Weise, Roger F. Crew, Michael Ernst, and Bjarne Steensgaard. </author> <title> Value dependence graphs: Representation without taxation. </title> <booktitle> In Conf. Rec. 21st ACM Symp. on Prin. of Programming Languages, </booktitle> <year> 1994. </year>
Reference-contexts: The PST does not directly identify the control dependencies used by region based global code motion algorithms. A number of representations allowing direct interpretation have been proposed, including the Dependence Flow Graph [PBJ + 91, JP93] and Value Dependence <ref> [WCES94] </ref>, but do not contain control dependence information. The Program Dependence Web [BMO90] is an interpretable representation that places a variation of SSA form on the PDG.
Reference: [WS91] <author> Deborah Whitfield and Mary Lou Soffa. </author> <title> Automatic generation of global optimizers. </title> <booktitle> In Proc. of Sigplan '91 Conf. on Programming Language Design and Implementation, </booktitle> <year> 1991. </year> <month> 34 </month>
Reference-contexts: It would be useful to be able to estimate the impact of a possible transformation on the resource requirements. In this section we sketch techniques for incrementally updating GURRR. In previous work on specifying transformations a basic set of program edits to describe the transformations has been used <ref> [WS91, Dow94] </ref>. We define the following set of Standard Edit Functions (SEFs), which apply a transformation to the elements of a PDG.
References-found: 31

