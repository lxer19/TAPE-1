URL: ftp://ftp.eecs.umich.edu/people/rundenst/papers/r-96-21.ps
Refering-URL: http://www.eecs.umich.edu/~rundenst/group/papers.html
Root-URL: http://www.cs.umich.edu
Email: e-mail: kuno@umich.edu, rundenst@eecs.umich.edu  
Title: The Satisfiability-Indicating Multi-Index Organization for Maintaining Materialized Path Query OODB Views  
Author: Harumi A. Kuno Elke A. Rundensteiner 
Keyword: Incremental view maintenance, path queries, data warehousing, view materialization, and object-oriented databases.  
Note: This work was supported in part by the NSF RIA grant #IRI-9309076, NSF NYI grant #IRI 94-57609, and the University of Michigan Faculty Award Program, Intel, and AT&T. Harumi Kuno is also grateful for support from the NASA Graduate Student Researchers Program.  
Address: Ann Arbor, MI 48109-2122  
Affiliation: Dept. of Elect. Engin. and Computer Science, Software Systems Research Laboratory The University of Michigan,  University of Michigan  
Pubnum: Technical Report CSE-TR-302-96  
Abstract: Materialized database views allow applications to benefit from the powerful flexibility of views while minimizing the performance penalties traditionally associated with views. However, the need to maintain materialized views in the face of updates limits the variety of queries that can be used to define them. In this paper we address the problem of incrementally maintaining OODB views formed using path queries. Traditional index organizations are not well suited for this task. The indexing needs of the path query view problem are unique in that because the contents of the materialized view are cached and can be queried directly, the primary use for a supplemental index is during the propagation of updates rather than during query processing. Furthermore, traditional index organizations do not distinguish between single-valued and multi-valued attributes, and thus do not account for the fact that multi-valued attributes enable a single object at the head of a path to be associated with multiple instantiations of the path, any number of which could satisfy the path query predicate. This means that if an updated path involves a multi-valued attribute then the aggregation hierarchy of the object at the head of the path must be completely re-calculated in order to determine whether or not that object participates in an alternative instantiation that fulfills the view query predicate despite the update. As a solution, we introduce a new Satisfiability Indicating Multi-Index (SMX) organization, which maintains partial information indicating whether or not a given endpoint satisfies the query predicate rather than what the exact value of the endpoint is. This new structure offers a number of benefits. (1) At most one path position forward must be traversed to determine whether or not the endpoint of an instantiation of the path fulfills a given path query predicate. (2) The SMX index structure only needs to be updated when the validity of an object's instantiation (in terms of the query predicate) changes. (3) No more than one path position forward must ever be traversed in order to identify whether or not a given object participates in any alternative instantiations that fulfill a given path query predicate. In addition to proposing this new index organization, we also present cost models and analytic evaluations comparing the performance of the SMX organization to those of the multi, nested, and path index organizations with regards to calculating the effects of updates upon views. The results of our evaluations indicate that the SMX dramatically improves upon the performance of traditional index structures with respect to the problem of path query view maintenance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Baralis and S. Ceria nd S. Paraboschi. </author> <title> Conservative timestamp revisited for materialized view maintenance in a data warehouse. </title> <booktitle> Proceedings of the SIGMOD Workshop on Materialized Views: Techniques and Applications, </booktitle> <pages> pages 1-9, </pages> <year> 1996. </year>
Reference-contexts: For example, the need for improved access to diverse data sources has spurred a recent interest in supporting queries across multiple information sources in a transparent fashion (e.g., data warehouses and digital libraries <ref> [19, 1] </ref>). Materialized database views are a recognized means of achieving such interoperability among applications, allowing applications to benefit from the powerful flexibility of view technology while minimizing the performance penalties traditionally associated with views.
Reference: [2] <author> E. Bertino and P. Foscoli. </author> <title> Index organizations for object-oriented database systems. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 7(2) </volume> <pages> 193-209, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: The cost of retrieving or maintaining a single index record in an SMX organization is thus very similar to that of performing the corresponding operation under an MX organization. As other researchers have previously discussed and contrasted the cost of performing basic functions using traditional index organizations <ref> [2, 4] </ref>, we confine our model of the costs of performing basic operations to a comparison between the SMX and MX operations. 5.1.1 Storage Costs Each SMX index record extends the MX index record with additional information as described in Section 4. <p> Indexing Techniques. We also considered the work of previous researchers who have compared index structures when designing our SMX organization. In particular, the work of Bertino et al. informed us of the costs and issues involved in the performance of basic operations with traditional index organizations <ref> [2, 4] </ref>. However, note that traditional indexing techniques have the goal of supporting the evaluation of queries.
Reference: [3] <author> J. Blakeley, P. Larson, and F. Tompa. </author> <title> Efficiently updating materialized views. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 61-71, </pages> <year> 1986. </year>
Reference-contexts: Insofar as queries can be performed over multiple tables that are joined, select-project-join (SPJ) views are the traditional counterpart to path query views. Maintaining materialized SPJ views is a well-studied problem in the relational world <ref> [5, 17, 3] </ref>. Gupta and Blakeley present formal partial-information-based view maintenance techniques that infer knowledge about the state of the underlying base relations using local information (such as the view definition, the update, the current view materialization, and varying amounts of base relation replicas) [5].
Reference: [4] <author> S. Choenni, E. Bertino, H. M. Blanken, and T. Chang. </author> <title> On the selection of optimal index configurations in OO databases. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 526-537, </pages> <year> 1994. </year>
Reference-contexts: We calculate cost in terms of the number of page accesses, and assume that a page contains objects of only one class. Table 2 presents the system parameters, adapted from the work of Choenni et al. <ref> [4] </ref> and Korth and Silberschatz [9], used in the following equations. Table 3 lists the path-query-view-specific parameters used in our equations. parameter definition CRIR X Cost of retrieving an index record with organization X . CM IR X Cost of maintaining an index record with organization X. <p> The cost of retrieving or maintaining a single index record in an SMX organization is thus very similar to that of performing the corresponding operation under an MX organization. As other researchers have previously discussed and contrasted the cost of performing basic functions using traditional index organizations <ref> [2, 4] </ref>, we confine our model of the costs of performing basic operations to a comparison between the SMX and MX operations. 5.1.1 Storage Costs Each SMX index record extends the MX index record with additional information as described in Section 4. <p> Indexing Techniques. We also considered the work of previous researchers who have compared index structures when designing our SMX organization. In particular, the work of Bertino et al. informed us of the costs and issues involved in the performance of basic operations with traditional index organizations <ref> [2, 4] </ref>. However, note that traditional indexing techniques have the goal of supporting the evaluation of queries.
Reference: [5] <author> A. Gupta and J.A. Blakeley. </author> <title> Using partial information to update materialized views. </title> <journal> Information Systems, </journal> <volume> 20(8) </volume> <pages> 641-662, </pages> <year> 1995. </year>
Reference-contexts: Insofar as queries can be performed over multiple tables that are joined, select-project-join (SPJ) views are the traditional counterpart to path query views. Maintaining materialized SPJ views is a well-studied problem in the relational world <ref> [5, 17, 3] </ref>. Gupta and Blakeley present formal partial-information-based view maintenance techniques that infer knowledge about the state of the underlying base relations using local information (such as the view definition, the update, the current view materialization, and varying amounts of base relation replicas) [5]. <p> Gupta and Blakeley present formal partial-information-based view maintenance techniques that infer knowledge about the state of the underlying base relations using local information (such as the view definition, the update, the current view materialization, and varying amounts of base relation replicas) <ref> [5] </ref>. Segev and Zhao propose a join pattern indexing technique for materialized rule-derived data that allows the identification of join completion without reading base relations [17]. <p> They identify classes of materialized views according to the amount of information needed to maintain them in the face of updates <ref> [5] </ref>, and demonstrate necessary and sufficient conditions for determining the amount of information needed to update a materialized select-project-join view. Segev and Zhao propose a join pattern indexing technique for materialized rule-derived data that allows the identification of join completion without reading base relations [17].
Reference: [6] <author> V. Harinarayan, A. Rajaraman, and J.D. Ullman. </author> <title> Implementing data cubes efficiently. </title> <booktitle> SIGMOD, </booktitle> <pages> page XXXX, </pages> <year> 1996. </year>
Reference-contexts: Support for such views would be a valuable contribution to MultiView's functionality. Furthermore, although a number of researchers have studied the problem of maintaining materialized aggregation functions in relational databases <ref> [15, 6] </ref>, to the best of our knowledge, this problem has not been examined in an object-oriented context.
Reference: [7] <author> A. Kemper, C. Kilger, and G. Moerkotte. </author> <title> Function materialization in object bases. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 258-267, </pages> <year> 1991. </year>
Reference-contexts: To the best of our knowledge, only two other research groups have addressed the topic of maintaining materialized path query views in object-oriented databases. Kemper et al.'s work on function materialization addresses the problem of precomputing function results <ref> [7, 8] </ref>. Konomi et al. discuss a solution to supporting a type of join class that is formed along the aggregation graph [10]. <p> They do not address the more general problem of path query views, which is the focus of this paper, nor do they provide any cost models or performance analyses. Function Materialization. The work of Kemper et al. on function materialization is closely related to OODB view materialization <ref> [7, 8] </ref>. The goal of function materialization is the precomputation and maintenance of function results. Similar to the SMX satisfaction indicator solution, Kemper et al. associate a validity value with each object that can serve as an argument to a function.
Reference: [8] <author> A. Kemper, C. Kilger, and G. Moerkotte. </author> <title> Function materialization in object bases: Design, realization, and evaluation. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <pages> pages 587-608, </pages> <year> 1994. </year>
Reference-contexts: To the best of our knowledge, only two other research groups have addressed the topic of maintaining materialized path query views in object-oriented databases. Kemper et al.'s work on function materialization addresses the problem of precomputing function results <ref> [7, 8] </ref>. Konomi et al. discuss a solution to supporting a type of join class that is formed along the aggregation graph [10]. <p> They do not address the more general problem of path query views, which is the focus of this paper, nor do they provide any cost models or performance analyses. Function Materialization. The work of Kemper et al. on function materialization is closely related to OODB view materialization <ref> [7, 8] </ref>. The goal of function materialization is the precomputation and maintenance of function results. Similar to the SMX satisfaction indicator solution, Kemper et al. associate a validity value with each object that can serve as an argument to a function.
Reference: [9] <author> W. Kim and J. Seo. </author> <title> Classifying schematic and data heterogeneity in multidatabase systems. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 12-18, </pages> <year> 1991. </year>
Reference-contexts: We calculate cost in terms of the number of page accesses, and assume that a page contains objects of only one class. Table 2 presents the system parameters, adapted from the work of Choenni et al. [4] and Korth and Silberschatz <ref> [9] </ref>, used in the following equations. Table 3 lists the path-query-view-specific parameters used in our equations. parameter definition CRIR X Cost of retrieving an index record with organization X . CM IR X Cost of maintaining an index record with organization X.
Reference: [10] <author> S. Konomi, T. Furukawa, and Y. Kambayashi. </author> <title> Super-key classes for updating materialized derived classes in object bases. </title> <booktitle> In International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 310-326, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Kemper et al.'s work on function materialization addresses the problem of precomputing function results [7, 8]. Konomi et al. discuss a solution to supporting a type of join class that is formed along the aggregation graph <ref> [10] </ref>. Readers might also note that in [12] we discussed the path query view problem and proposed an initial technique for the maintenance of such views; however, none of the techniques proposed in the current work have been previously introduced. <p> However, because such references are implemented as stored oids rather than as direct pointers, following one link object to another requires a retrieval of the link object by oid, which is equivalent to the retrieval of a multi-index record in our SMX solution. Konomi et al. <ref> [10] </ref> use superkey classes to maintain consistency for a particular type of join class formed along an existing path in the aggregation graph. Superkey classes facilitate the incremental update and elimination of duplicates for materialized views produced by relational expressions that include projections.
Reference: [11] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Materialized object-oriented views in MultiView. </title> <booktitle> In ACM Research Issues in Data Engineering Workshop, </booktitle> <pages> pages 78-85, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: We have previously discussed the problem of view materialization in the context of object-oriented databases (OODBs) and proposed algorithms that exploit object-oriented characteristics in order to provide the incremental maintenance of materialized virtual classes created using the standard view query operators <ref> [11, 13, 14] </ref>. In this paper we address the problem of the incremental maintenance of materialized virtual classes formed using selection queries on aggregation paths (or short, path query views). <p> Finally, we discuss related work in Section 8, and present our conclusions and future work in Section 9. 2 The MultiView Model and System In this section, we briefly review the basic object model principles of the MultiView system. More details are given in [16] and <ref> [11] </ref>. Let O be an infinite set of object instances, or short, objects. Each object O i 2 O consists of state (instance variables or attributes), behavior (methods to which the object can respond), and a unique object identifier.
Reference: [12] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Augmented inherited multi-index structure for maintenance of materialized path query views. </title> <booktitle> In ACM Research Issues in Data Engineering Workshop, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: Kemper et al.'s work on function materialization addresses the problem of precomputing function results [7, 8]. Konomi et al. discuss a solution to supporting a type of join class that is formed along the aggregation graph [10]. Readers might also note that in <ref> [12] </ref> we discussed the path query view problem and proposed an initial technique for the maintenance of such views; however, none of the techniques proposed in the current work have been previously introduced.
Reference: [13] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> The MultiView OODB view system: Design and implementation. </title> <editor> In Harold Ossher and William Harrison, editors, </editor> <booktitle> Accepted by Theory and Practice of Object Systems (TAPOS), Special Issue on Subjectivity in Object-Oriented Systems. </booktitle> <publisher> John Wiley New York, </publisher> <year> 1996. </year>
Reference-contexts: We have previously discussed the problem of view materialization in the context of object-oriented databases (OODBs) and proposed algorithms that exploit object-oriented characteristics in order to provide the incremental maintenance of materialized virtual classes created using the standard view query operators <ref> [11, 13, 14] </ref>. In this paper we address the problem of the incremental maintenance of materialized virtual classes formed using selection queries on aggregation paths (or short, path query views). <p> Virtual classes are defined by the application of a query operator to one or two classes that restructures the source classes' type and/or extent membership. MultiView provides a virtual-class-forming algebra that includes the following operators: difference, hide, intersect, join, refine, select, and union <ref> [16, 13] </ref>. These queries determine the methods, instance variables, and extent of the virtual classes. The join operator can be object-generating; all other operators are object-preserving. Let Q be the set of all possible queries.
Reference: [14] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Using object-oriented principles to optimize update propagation to materialized views. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 310-317, </pages> <year> 1996. </year> <month> 24 </month>
Reference-contexts: We have previously discussed the problem of view materialization in the context of object-oriented databases (OODBs) and proposed algorithms that exploit object-oriented characteristics in order to provide the incremental maintenance of materialized virtual classes created using the standard view query operators <ref> [11, 13, 14] </ref>. In this paper we address the problem of the incremental maintenance of materialized virtual classes formed using selection queries on aggregation paths (or short, path query views).
Reference: [15] <author> D. Quass. </author> <title> Maintenance expressions for views with aggregation. </title> <booktitle> Proceedings of the SIGMOD Workshop on Material--ized Views: Techniques and Applications, </booktitle> <pages> pages 110-118, </pages> <year> 1996. </year>
Reference-contexts: Support for such views would be a valuable contribution to MultiView's functionality. Furthermore, although a number of researchers have studied the problem of maintaining materialized aggregation functions in relational databases <ref> [15, 6] </ref>, to the best of our knowledge, this problem has not been examined in an object-oriented context.
Reference: [16] <author> E. A. Rundensteiner. </author> <title> MultiView: A methodology for supporting multiple views in object-oriented databases. </title> <booktitle> In 18th VLDB Conference, </booktitle> <pages> pages 187-198, </pages> <year> 1992. </year>
Reference-contexts: Finally, we discuss related work in Section 8, and present our conclusions and future work in Section 9. 2 The MultiView Model and System In this section, we briefly review the basic object model principles of the MultiView system. More details are given in <ref> [16] </ref> and [11]. Let O be an infinite set of object instances, or short, objects. Each object O i 2 O consists of state (instance variables or attributes), behavior (methods to which the object can respond), and a unique object identifier. <p> Virtual classes are defined by the application of a query operator to one or two classes that restructures the source classes' type and/or extent membership. MultiView provides a virtual-class-forming algebra that includes the following operators: difference, hide, intersect, join, refine, select, and union <ref> [16, 13] </ref>. These queries determine the methods, instance variables, and extent of the virtual classes. The join operator can be object-generating; all other operators are object-preserving. Let Q be the set of all possible queries.
Reference: [17] <author> A. Segev and J. L. Zhao. </author> <title> Efficient maintenance of rule-derived data through join pattern indexing. </title> <booktitle> In International Conference on Information and Knowledge Management, </booktitle> <pages> pages 194-205, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Insofar as queries can be performed over multiple tables that are joined, select-project-join (SPJ) views are the traditional counterpart to path query views. Maintaining materialized SPJ views is a well-studied problem in the relational world <ref> [5, 17, 3] </ref>. Gupta and Blakeley present formal partial-information-based view maintenance techniques that infer knowledge about the state of the underlying base relations using local information (such as the view definition, the update, the current view materialization, and varying amounts of base relation replicas) [5]. <p> Segev and Zhao propose a join pattern indexing technique for materialized rule-derived data that allows the identification of join completion without reading base relations <ref> [17] </ref>. <p> Segev and Zhao propose a join pattern indexing technique for materialized rule-derived data that allows the identification of join completion without reading base relations <ref> [17] </ref>. A join pattern relation is a precomputation of complete (all join attributes instantiated) and incomplete (not all join attributes instantiated) joins that satisfy the constraints of a rule. Join pattern indexing represents join relationships between existing tuples.
Reference: [18] <author> E. J. Shekita and M. J. Carey. </author> <title> Performance enhancement through replication in an object-oriented dbms. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 325-336, </pages> <year> 1989. </year>
Reference-contexts: Join pattern information more closely resembles a path index than a multi-index, and thus needs to be maintained in the face of all updates (unlike the SMX satisfaction indicators). Shekita and Carey selectively replicate individual data fields in order to improve query processing performance by eliminating some functional joins <ref> [18] </ref>. <p> Shekita and Carey create special link objects to maintain inverse mappings that associate objects with the objects that reference them <ref> [18] </ref>. These link objects are like the entries in a multi-index, except that the database objects maintain references to the link objects and the link objects maintain references to the link objects that precede them along the aggregation graph.
Reference: [19] <author> Y. Zhuge, H. Garcia-Molina, J. Hammer, and J. Widom. </author> <title> View maintenance in a warehousing environment. </title> <booktitle> In SIGMOD, </booktitle> <year> 1995. </year>
Reference-contexts: For example, the need for improved access to diverse data sources has spurred a recent interest in supporting queries across multiple information sources in a transparent fashion (e.g., data warehouses and digital libraries <ref> [19, 1] </ref>). Materialized database views are a recognized means of achieving such interoperability among applications, allowing applications to benefit from the powerful flexibility of view technology while minimizing the performance penalties traditionally associated with views.
References-found: 19

