URL: ftp://ic.eecs.berkeley.edu/pub/Memos_Conference/eurodac95.SPA.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~vigyan/publications/index.html
Root-URL: http://www.cs.berkeley.edu
Title: Exploiting Power-up Delay for Sequential Optimization  
Author: Vigyan Singhal Carl Pixley Adnan Aziz Robert K. Brayton 
Abstract: Recent work has identified the notion of safe replacement for sequential synchronous designs that may not have reset hardware or even explicitly known initial states. Safe replacement requires that a replacement design be indistinguishable from the original from the very first clock cycle after power-up. However, in almost any realistic application, the design is allowed to stabilize for many clock cycles before it is used. In this paper, we investigate the safety of a replacement if the replacement design is allowed to be clocked some cycles (that is, delayed) with arbitrary inputs before the design is reset. Having argued the safety of delay replacements, we investigate a new method of sequential optimization based upon the notion. We present experimental results to demonstrate that significant area optimizations can be gained by using this new notion of delay replaceability, and that there is a trade-off between the allowed number of clock cycles after power-up and the amount of optimization that can be obtained. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Pixley, </author> <title> A Theory and Implementation of Sequential Hardware Equivalence, </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> vol. 11, </volume> <pages> pp. 1469-1494, </pages> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: This, however, raises a harder question about what it means for one sequential design without hardware reset to safely replace another. Furthermore, initializing such a design is a consequence of the interaction of a design with its environment. Reflection <ref> [1] </ref> and experience show that, in the absence of knowledge about the intended use of a design and information about its environment, a necessary condition for safe replacement is that the State Transition Graphs (STGs) of a design and its replacement have equivalent Terminal Strongly Connected Components (TSCCs). <p> Courtyard Dr., Suite 200, Austin, TX 78730, USA z Department of EECS, University of California, Berkeley, CA 94720, USA required. In <ref> [1] </ref>, it was suggested that a necessary (but not sufficient) condition is that, in addition to having identical TSCCs, a design and its replacement have at least one synchronizing sequence in common. <p> Since designs are finite state machines, for any design, there is a bound on the number of onion rings. Elimination of all such ephemeral states for all clock cycles leaves a set of states, called the outer-envelope (OE) <ref> [1] </ref> or D 1 (see Section 4 of this paper). Many well-crafted designs have ephemeral states due to the fact that binary encoding often leaves some states of the implementation without a corresponding state in the specified design. These states should be ephemeral. <p> It is important to note that for any of the approaches, only the transient behavior of the designs is modified. Specifically, the outer-envelope is unchanged. Previous efforts have been made to tackle the sequential design replacement problem 1 . A notion of design equivalence was defined in <ref> [1] </ref>; however, they did not present any approach to use that notion for logic optimization. Another notion of equivalence was suggested in [7] which was used for sequential resynthesis by redundancy removal in [8]. <p> Using the terminology in [5], this number n is the number of onion rings of the design D. D 1 is also the same as the outer-envelope (OE) of <ref> [1] </ref>. We refer to states in D 1 as the stable states of D, and the states in D nD 1 as the transient states of D.
Reference: [2] <author> V. Singhal and C. Pixley, </author> <title> The Verification Problem for Safe Replaceability, </title> <booktitle> in Proc. of the Conf. on Computer-Aided Verification (D. </booktitle> <editor> L. Dill, ed.), </editor> <volume> vol. </volume> <booktitle> 818 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 311-323, </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: In [1], it was suggested that a necessary (but not sufficient) condition is that, in addition to having identical TSCCs, a design and its replacement have at least one synchronizing sequence in common. More recently a safe replacement condition was presented <ref> [2] </ref> which implies that every synchronization sequence for the original design also synchronizes the replacement design (this is equivalent to the redundant condition for fault detection in [3]). It was argued that that this notion of safe replacement was the weakest possible without knowledge or assumptions about the design's environment. <p> The precise condition for safe replacement was presented in <ref> [2] </ref>: Definition 2 Design D 1 is a safe replacement for design D 0 (denoted by D 1 D 0 ) if given any state s 1 2 D 1 and any finite input sequence 2 I fl , there exists some state s 0 2 D 0 such that the <p> As an example of safe replacement, consider designs P and Q in Figures 1 and 2, respectively. It can easily be seen that Q P (see <ref> [2] </ref> for details). It was shown in [2] that Definition 2 is the weakest condition which guarantees that no environment can detect the replacement. The replacement is indistinguishable from the original design even for environments which can observe and control the design from the very first clock cycle after power-up. <p> As an example of safe replacement, consider designs P and Q in Figures 1 and 2, respectively. It can easily be seen that Q P (see <ref> [2] </ref> for details). It was shown in [2] that Definition 2 is the weakest condition which guarantees that no environment can detect the replacement. The replacement is indistinguishable from the original design even for environments which can observe and control the design from the very first clock cycle after power-up. <p> The replacement is indistinguishable from the original design even for environments which can observe and control the design from the very first clock cycle after power-up. We frequently use the following two observations from <ref> [2] </ref>: * If each state of design C is equivalent to a state in design D, then C D, but C D does not imply that every state of design C is equivalent to a state in design D. * The relation is transitive.
Reference: [3] <author> I. Pomeranz and S. M. Reddy, </author> <title> Classification of Faults in Synchronous Sequential Circuits, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 42, </volume> <pages> pp. 1066-1077, </pages> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: More recently a safe replacement condition was presented [2] which implies that every synchronization sequence for the original design also synchronizes the replacement design (this is equivalent to the redundant condition for fault detection in <ref> [3] </ref>). It was argued that that this notion of safe replacement was the weakest possible without knowledge or assumptions about the design's environment. Based upon the notion of safe replacement, a sequential synthesis approach was developed [4] that guaranteed that the new, optimized design would be a safe replacement.
Reference: [4] <author> C. Pixley, V. Singhal, A. Aziz, and R. K. Brayton, </author> <title> Multilevel Synthesis for Safe Replaceability, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <address> (San Jose, CA), </address> <pages> pp. 442-449, </pages> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: It was argued that that this notion of safe replacement was the weakest possible without knowledge or assumptions about the design's environment. Based upon the notion of safe replacement, a sequential synthesis approach was developed <ref> [4] </ref> that guaranteed that the new, optimized design would be a safe replacement. However, it was noticed that several effective optimization techniques, such as re-timing, did not always result in safe replacements. To understand why, consider the state transition graph again. <p> Also one-hot encodings of machines with n states results in 2 n n states which may also be ephemeral. In addition, a forward retiming move across a fanout junction will also create ephemeral states [6]. However, all retiming moves preserve the outer-envelope. The sequential method employed in <ref> [4] </ref> uses an aliasing technique. A core set of states is identified (all states except the 1-cycle ephemeral states). Then any 1-cycle ephemeral state, say s, is allowed to act like an alias. <p> Once we have the BDD for the Boolean relation Q ( ~ i; ~x; ~o; ~y) we can use standard BDD-based multi-level synthesis techniques to propagate this flexibility to individual nodes in the network and then minimize the nodes <ref> [4, 15] </ref>. 6 Experiments In this section we report experimental results using the algorithm described in Section 5 on ISCAS85 sequential circuits. We used BDDs to manipulate the Boolean relations and sets. We focused on the area reduction for n-delay replacements. We report results for various values of n. <p> First we show the optimizations obtained by just doing the standard multi-level combinational optimization [17] us ing observability don't cares (ODC) propagated to the individual nodes in the network. We also show the optimizations obtained by the safe replacement resynthesis method described in <ref> [4] </ref>. Then, we show the results of the method presented in this paper for n-delay replacements for n = 1; 2; 5; 1. The table shows that for many examples, significant additional optimizations are obtained by allowing power-up delay. <p> In the experiments above, the initial nodes of the circuits have been collapsed minimally. We see that safe replaceability gives very marginal improvements over pure combinational reductions, and at a much larger CPU time cost. For this reason, it was argued in <ref> [4] </ref> that we might get better use of the safe replaceability notion by using larger node sizes in the circuits. They increased the node sizes in these benchmark circuits by using SIS commands eliminate 10 or collapse.
Reference: [5] <author> S.-W. Jeong, </author> <title> Binary Decision Diagrams and their Applications to Implicit Enumeration Techniques in Logic Synthesis. </title> <type> PhD thesis, </type> <institution> Department of Electrical and Computer Engineering, University of Colorado, Boulder, </institution> <address> CO 80309, </address> <year> 1992. </year>
Reference-contexts: States such as s 2 cannot re-appear after two clock cycles, no matter what inputs are given during the two cycles. The n-cycle ephemeral state sets form an onion ring structure in the STG <ref> [5] </ref>. The 1-cycle ephemeral states constitute onion ring 1, 2-cycle ephemeral states constitute onion ring 2, and so on. Since designs are finite state machines, for any design, there is a bound on the number of onion rings. <p> The design D 1 can be obtained by a fixed-point operation starting from D, because D 1 n , where n is the smallest number such that D = D . Using the terminology in <ref> [5] </ref>, this number n is the number of onion rings of the design D. D 1 is also the same as the outer-envelope (OE) of [1]. <p> Let the original design D have (k +1) different delayed designs, D 0 ; D 1 ; : : : ; D k ; for any j k : D j = D k = D 1 . These (k+1) delayed designs form an onion ring structure <ref> [5] </ref>. Clearly any state reachable from itself under some input sequence belongs to each D i and to D 1 . We will not alter the behavior of any such state (a stable state). All the flexibility for resynthesis comes from the set of transient states, i.e.
Reference: [6] <author> V. Singhal, C. Pixley, R. L. Rudell, and R. K. Brayton, </author> <title> The Validity of Retiming Sequential Circuits, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <address> (San Francisco, CA), </address> <pages> pp. 316-321, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: These states should be ephemeral. Also one-hot encodings of machines with n states results in 2 n n states which may also be ephemeral. In addition, a forward retiming move across a fanout junction will also create ephemeral states <ref> [6] </ref>. However, all retiming moves preserve the outer-envelope. The sequential method employed in [4] uses an aliasing technique. A core set of states is identified (all states except the 1-cycle ephemeral states). Then any 1-cycle ephemeral state, say s, is allowed to act like an alias. <p> A sequential resynthesis technique relevant to our model is retiming and resynthesis [10]. Retiming and resynthesis results in delay-safe replacements as shown in <ref> [11, 6] </ref>. However, this approach has not given much optimization for arbitrary control logic, and also the benchmark circuits; it seems to work best for pipelined data paths [10]. Another method for sequential optimization is the use of synchronous recurrence equations as described in [12]. <p> We should note here that Leiserson and Saxe [11] had a similar notion for valid replacements which they used to justify the validity of retimed designs (see also <ref> [6] </ref>). They considered a replacement design C a valid replacement of design D if each state in C n equivalent to a state in D. It should be clear that their notion is strictly stronger than ours, and thus allows less flexibility for replacement.
Reference: [7] <author> K.-T. Cheng, </author> <title> Redundancy Removal for Sequential Circuits Without Reset States, </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> vol. 12, </volume> <pages> pp. 13-24, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: Specifically, the outer-envelope is unchanged. Previous efforts have been made to tackle the sequential design replacement problem 1 . A notion of design equivalence was defined in [1]; however, they did not present any approach to use that notion for logic optimization. Another notion of equivalence was suggested in <ref> [7] </ref> which was used for sequential resynthesis by redundancy removal in [8]. Their notion of redundancy results in replacements which are not 0-cycle delay-safe replacements [9]; it has not been shown that if their replacements are n-cycle delay-safe replacements, neither what this n might be.
Reference: [8] <author> L. Entrena and K.-T. Cheng, </author> <title> Sequential Logic Optimization by Redundancy Addition and Removal, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <address> (Santa Clara, CA), </address> <pages> pp. 310-315, </pages> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: A notion of design equivalence was defined in [1]; however, they did not present any approach to use that notion for logic optimization. Another notion of equivalence was suggested in [7] which was used for sequential resynthesis by redundancy removal in <ref> [8] </ref>. Their notion of redundancy results in replacements which are not 0-cycle delay-safe replacements [9]; it has not been shown that if their replacements are n-cycle delay-safe replacements, neither what this n might be. A sequential resynthesis technique relevant to our model is retiming and resynthesis [10].
Reference: [9] <author> M. A. Iyer, D. E. Long, and M. Abramovici, </author> <title> Identifying Sequential Redundancies Without Search. </title> <type> Unpublished manuscript, </type> <year> 1995. </year>
Reference-contexts: Another notion of equivalence was suggested in [7] which was used for sequential resynthesis by redundancy removal in [8]. Their notion of redundancy results in replacements which are not 0-cycle delay-safe replacements <ref> [9] </ref>; it has not been shown that if their replacements are n-cycle delay-safe replacements, neither what this n might be. A sequential resynthesis technique relevant to our model is retiming and resynthesis [10]. Retiming and resynthesis results in delay-safe replacements as shown in [11, 6].
Reference: [10] <author> S. Malik, E. M. Sentovich, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <title> Retiming and Resynthesis: Optimization of Sequential Networks with Combinational Techniques, </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> vol. 10, </volume> <pages> pp. 74-84, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: Their notion of redundancy results in replacements which are not 0-cycle delay-safe replacements [9]; it has not been shown that if their replacements are n-cycle delay-safe replacements, neither what this n might be. A sequential resynthesis technique relevant to our model is retiming and resynthesis <ref> [10] </ref>. Retiming and resynthesis results in delay-safe replacements as shown in [11, 6]. However, this approach has not given much optimization for arbitrary control logic, and also the benchmark circuits; it seems to work best for pipelined data paths [10]. <p> sequential resynthesis technique relevant to our model is retiming and resynthesis <ref> [10] </ref>. Retiming and resynthesis results in delay-safe replacements as shown in [11, 6]. However, this approach has not given much optimization for arbitrary control logic, and also the benchmark circuits; it seems to work best for pipelined data paths [10]. Another method for sequential optimization is the use of synchronous recurrence equations as described in [12]. While we suspect that synchronous recurrence equations [12] might lead to valid delay-safe replacements, our procedure returns greater area optimizations and consume less CPU time (see Section 6).
Reference: [11] <author> C. E. Leiserson and J. B. Saxe, </author> <title> Optimizing Synchronous Systems, </title> <journal> Journal of VLSI and Computer Systems, </journal> <volume> vol. 1, </volume> <pages> pp. 41-67, </pages> <month> Spring </month> <year> 1983. </year>
Reference-contexts: A sequential resynthesis technique relevant to our model is retiming and resynthesis [10]. Retiming and resynthesis results in delay-safe replacements as shown in <ref> [11, 6] </ref>. However, this approach has not given much optimization for arbitrary control logic, and also the benchmark circuits; it seems to work best for pipelined data paths [10]. Another method for sequential optimization is the use of synchronous recurrence equations as described in [12]. <p> We should note here that Leiserson and Saxe <ref> [11] </ref> had a similar notion for valid replacements which they used to justify the validity of retimed designs (see also [6]). They considered a replacement design C a valid replacement of design D if each state in C n equivalent to a state in D.
Reference: [12] <author> M. Damiani and G. De Micheli, </author> <title> Recurrence Equations and the Optimization of Synchronous Logic Circuits, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <address> (Anaheim, CA), </address> <pages> pp. 556-561, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: However, this approach has not given much optimization for arbitrary control logic, and also the benchmark circuits; it seems to work best for pipelined data paths [10]. Another method for sequential optimization is the use of synchronous recurrence equations as described in <ref> [12] </ref>. While we suspect that synchronous recurrence equations [12] might lead to valid delay-safe replacements, our procedure returns greater area optimizations and consume less CPU time (see Section 6). Moreover, it is not clear how the initialization slack n can be used by the method described in [12] so that it <p> Another method for sequential optimization is the use of synchronous recurrence equations as described in <ref> [12] </ref>. While we suspect that synchronous recurrence equations [12] might lead to valid delay-safe replacements, our procedure returns greater area optimizations and consume less CPU time (see Section 6). Moreover, it is not clear how the initialization slack n can be used by the method described in [12] so that it is guaranteed that the replacement is an n-cycle <p> as described in <ref> [12] </ref>. While we suspect that synchronous recurrence equations [12] might lead to valid delay-safe replacements, our procedure returns greater area optimizations and consume less CPU time (see Section 6). Moreover, it is not clear how the initialization slack n can be used by the method described in [12] so that it is guaranteed that the replacement is an n-cycle safe-replacement. <p> Both these constraints are avoided by the resynthesis method presented in Section 5. This leads to a much smaller BDD to express the relation Q, and hence, faster multi-level resynthesis. We suspect that synchronous recurrence equations <ref> [12] </ref> also lead to delay replacements. <p> However, the experimental results presented there indicate that using synchronous recurrence equations is not very effective; our optimization method (using the SIS commands sweep; eliminate -1 followed by the optimization procedure described in this paper) produces smaller circuits using less CPU times than those reported in <ref> [12] </ref>. (Note that the CPU times indicated in Table 1 do not include the time used by the SIS preprocessing commands; however, for all the examples, that time is much less than the times reported for the sequential optimizations. However, the CPU times reported in [12] are greater than double the <p> times than those reported in <ref> [12] </ref>. (Note that the CPU times indicated in Table 1 do not include the time used by the SIS preprocessing commands; however, for all the examples, that time is much less than the times reported for the sequential optimizations. However, the CPU times reported in [12] are greater than double the times reported in Table 1.) We performed an experiment on one of the benchmark circuits with large number of onion rings (s526) to explore the tradeoffs between flexibility and the power-up delay allowed. The results are in Table 2.
Reference: [13] <author> V. Singhal, C. Pixley, A. Aziz, and R. K. Brayton, </author> <title> Delaying Safeness for More Flexibility, </title> <type> Tech. Rep. </type> <institution> UCB/ERL M95/5, Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: It should be clear that their notion is strictly stronger than ours, and thus allows less flexibility for replacement. The following two properties of delay replacements follow (we refer the reader to <ref> [13] </ref> for the proofs of all the results that are presented in this paper): Proposition 4.1 If C n D, and m &gt; n, then C m D. <p> However, we found an example which illustrated that delay-preserving replacements do not have nice compositionality properties which allow us to make substitutions on sub-pieces of designs. Thus, the iterative optimization strategy that we proposed in the previous sub-section will not work. The reader is referred to <ref> [13] </ref> for the above-mentioned example and other properties of delay-preserving replacements. That paper also relates delay-preserving replacements to delay replacements (called delay-accumulating replacements in [13]) and includes an interesting result which shows that in the limit, as n approaches 1, these two notions converge. 5 Resynthesis for Delay Replaceability Typically, the <p> Thus, the iterative optimization strategy that we proposed in the previous sub-section will not work. The reader is referred to <ref> [13] </ref> for the above-mentioned example and other properties of delay-preserving replacements. That paper also relates delay-preserving replacements to delay replacements (called delay-accumulating replacements in [13]) and includes an interesting result which shows that in the limit, as n approaches 1, these two notions converge. 5 Resynthesis for Delay Replaceability Typically, the synthesis process has two stages: first, the set of all possible implementations is characterized using the flexibility given by the replacement condition. <p> They increased the node sizes in these benchmark circuits by using SIS commands eliminate 10 or collapse. For the sake of completeness, we ran our algorithm on these starting points also. For the results, the reader is referred to <ref> [13] </ref>. This experiment showed that once again, using n-delay replacements instead of safe replacements allows us greater flexibility for resynthesis and gives much better optimizations.
Reference: [14] <author> A. Aziz, T. R. Shiple, V. Singhal, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <title> Formula-Dependent Equivalence for Compositional CTL Model Checking, </title> <booktitle> in Proc. of the Conf. on Computer-Aided Verification (D. </booktitle> <editor> L. Dill, ed.), </editor> <volume> vol. </volume> <booktitle> 818 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 324-336, </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: The remaining inputs and outputs will be primary inputs and primary outputs of the composed design. Given designs A and B, we will use A B to denote their composition. A formal definition of design composition is given in <ref> [14] </ref>. We obtain the following result which shows that composing two delay replacements adds up the delays. Proposition 4.3 If Q m n D, then (Q C) p (R D), where p = max (m; n).
Reference: [15] <author> H. Savoj and R. K. Brayton, </author> <title> Observability Relations and Observability Don't Cares, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <address> (Santa Clara, CA), </address> <pages> pp. 518-521, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: We will then use this relation to do multi-level resynthesis on our design. First, we informally describe the flexibility which will be specified later using a Boolean relation Q. We note here that techniques for using a Boolean relation to do multi-level synthesis <ref> [15] </ref> require the relation to be such that the starting design satisfies the relation. The Boolean relation is such that the behavior of the states in D n (the stable states) is preserved. <p> Once we have the BDD for the Boolean relation Q ( ~ i; ~x; ~o; ~y) we can use standard BDD-based multi-level synthesis techniques to propagate this flexibility to individual nodes in the network and then minimize the nodes <ref> [4, 15] </ref>. 6 Experiments In this section we report experimental results using the algorithm described in Section 5 on ISCAS85 sequential circuits. We used BDDs to manipulate the Boolean relations and sets. We focused on the area reduction for n-delay replacements. We report results for various values of n.
Reference: [16] <author> E. M. Sentovich, K. J. Singh, C. Moon, H. Savoj, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <title> Sequential Circuit Design Using Synthesis and Optimization, </title> <booktitle> in Proc. Intl. Conf. on Computer Design, </booktitle> <address> (Cambridge, MA), </address> <pages> pp. 328-333, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: We focused on the area reduction for n-delay replacements. We report results for various values of n. The experimental results, obtained using a DECstation5900 are shown in Table 1. The starting circuits were obtained from IS-CAS89 benchmark circuits with the SIS commands (sweep; eliminate -1) applied <ref> [16] </ref>. These eliminate single-input and constant nodes and collapse nodes which do not fan out to more than one node. First we show the optimizations obtained by just doing the standard multi-level combinational optimization [17] us ing observability don't cares (ODC) propagated to the individual nodes in the network.
Reference: [17] <author> H. Savoj, R. K. Brayton, and H. Touati, </author> <title> Extracting Local Don't Cares for Network Optimization, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <address> (Santa Clara, CA), </address> <pages> pp. 514-517, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: These eliminate single-input and constant nodes and collapse nodes which do not fan out to more than one node. First we show the optimizations obtained by just doing the standard multi-level combinational optimization <ref> [17] </ref> us ing observability don't cares (ODC) propagated to the individual nodes in the network. We also show the optimizations obtained by the safe replacement resynthesis method described in [4].
References-found: 17

