URL: ftp://st.cs.uiuc.edu/pub/papers/refactoring/refactoring-superclasses.ps
Refering-URL: http://st-www.cs.uiuc.edu/users/johnson/professional.html
Root-URL: http://www.cs.uiuc.edu
Email: opdyke@iexist.att.com  johnson@cs.uiuc.edu  
Title: Creating Abstract Superclasses by Refactoring  
Author: William F. Opdyke Ralph E. Johnson 
Address: 60566  Urbana, Illinois 61801  
Affiliation: AT&T Bell Laboratories Naperville, Illinois  Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract: This paper focuses on object-oriented programming and one kind of structure-improving transformation (refactoring) that is unique to object-oriented programming: finding abstract superclasses. We decompose the operation of finding an abstract superclass into a set of refactoring steps, and provide examples. We discuss techniques that can automate or automatically support these steps. We also consider some of the conditions that must be satisfied to perform a refactoring safely; sometimes to satisfy these conditions other refactorings must first be applied. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> AT&T. </author> <title> UNIX System V User Reference Manual. </title> <journal> AT&T, </journal> <year> 1984. </year>
Reference-contexts: An early version of the Choices file system framework supported only the BSD UNIX file format. Then, it was extended to handle both BSD UNIX and UNIX System V <ref> [1] </ref> file formats. To support both formats, the Inode class was changed as follows: 1. the Inode class was renamed to BSDInode, 2 Inode is standard UNIX R fl operating system terminology; it is a contraction of the term index node.
Reference: [2] <author> Robert Balzer. </author> <title> A fifteen-year perspective on automatic programming. </title> <booktitle> In Software Reusability Volume II: Applications and Experience, </booktitle> <pages> pages 289-311, </pages> <year> 1989. </year>
Reference-contexts: Refactoring is also similar to the more traditional program transformation work, which usually has the goal of improving efficiency, of converting abstract program schemas into code, or of transforming an abstract design into a concrete program <ref> [2, 6, 15] </ref>. These systems often perform the inverse transformations to ours, since refactorings often are used to make programs more abstract and are not usually concerned with efficiency. Refactoring is a practical problem that needs better support.
Reference: [3] <author> Jay Banerjee and Won Kim. </author> <title> Semantics and implementation of schema evolution in object-oriented databases. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <year> 1987. </year>
Reference-contexts: Several of them are based on dataflow techniques, and can almost certainly be improved upon. However, the undecidability of the basic problem requires that any algorithm for checking preconditions will be too conservative. Refactoring is similar to the schema modification in databases <ref> [3, 16, 22] </ref>. The main difference is that schema modification is concerned only with data, while refactorings are concerned with both data and program. On the other hand, the work on schema modification is concerned with updating the existing objects in the database.
Reference: [4] <author> Carol Sue Beckman-Davies. </author> <title> Finding Program Differences Based on Syntactic Tree Structure. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1989. </year>
Reference-contexts: Before the function body can be migrated to the superclass, differences need to be separated from the common code. The approaches for detecting program differences involve string comparison, tree comparison or a combination of these techniques <ref> [4] </ref>. The approaches represent the differences between programs as a set of edit operations (code insertion, replacement and deletion), to get from one program to the other. Program differences have been studied in regard to spelling correction [13, 27], parsing error correction [28], version storage [24] and other uses.
Reference: [5] <author> Paul L. Bergstein. </author> <title> Object-preserving class transformations. </title> <booktitle> In Proceedings of OOPSLA `91, </booktitle> <year> 1991. </year>
Reference-contexts: In these cases, understanding refactoring is crucial. Refactoring has always been carried out manually, but there have been several studies of how to automate or partially automate it. Casais [7] and Berg stein <ref> [5] </ref> have both invented algorithms to create ab-stract classes from a set of concrete classes. These algorithms do the easy part of abstraction, which is moving common features to a single class.
Reference: [6] <author> R. M. Burstall and J. Darlington. </author> <title> A transformation system for developing recursive programs. </title> <journal> Journal of the ACM, </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <year> 1977. </year>
Reference-contexts: Refactoring is also similar to the more traditional program transformation work, which usually has the goal of improving efficiency, of converting abstract program schemas into code, or of transforming an abstract design into a concrete program <ref> [2, 6, 15] </ref>. These systems often perform the inverse transformations to ours, since refactorings often are used to make programs more abstract and are not usually concerned with efficiency. Refactoring is a practical problem that needs better support.
Reference: [7] <author> Eduardo Casais. </author> <title> Reorganizing an Object System, </title> <type> pages 161-189. </type> <institution> Centre Universitair d'Informatique, Universite de Geneve, </institution> <year> 1989. </year>
Reference-contexts: In these cases, understanding refactoring is crucial. Refactoring has always been carried out manually, but there have been several studies of how to automate or partially automate it. Casais <ref> [7] </ref> and Berg stein [5] have both invented algorithms to create ab-stract classes from a set of concrete classes. These algorithms do the easy part of abstraction, which is moving common features to a single class.
Reference: [8] <author> N. Dershowitz. </author> <title> Programming by analogy. Machine Learning: An Artificial Intelligence Approach (R.S. </title> <editor> Michalski, J. G. Carbonell and T. M. Mitchell, eds), </editor> <volume> 2 </volume> <pages> 395-424, </pages> <year> 1986. </year>
Reference-contexts: These functions clearly don't share a common abstraction, but automatically matching on attributes of the signature won't detect this. Such hueristics, despite their shortcomings, may be powerful enough to support practical refactoring tasks. More powerful similarity detection is possible in some cases <ref> [8, 11] </ref>.
Reference: [9] <author> L. Peter Deutsch. </author> <title> Design reuse and frameworks in the Smalltalk-80 system. </title> <booktitle> In Software Reusability Volume II: Applications and Experience, </booktitle> <pages> pages 57-72, </pages> <year> 1989. </year>
Reference-contexts: Refactoring is also important in developing reusable software, especially frameworks [14, 20, 21]. Frameworks are program skeletons that can be "fleshed out" to construct a complete program <ref> [9, 30] </ref>. Frameworks are usually developed by generalizing a set of concrete applications. Sometimes frameworks are developed by careful planning, starting with a domain analysis and a study of several applications in the problem domain. In these cases refactoring is less important.
Reference: [10] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Abstract classes are an important design technique, but are not always directly supported by object-oriented programming languages. Although statically typed languages such as C++ often have a way to give a signature for an operation without giving an implementation (e.g. pure virtual functions in C++ <ref> [10] </ref>), untyped languages such as Smalltalk specify abstract classes only by convention.
Reference: [11] <author> R. Greiner. </author> <title> Learning by understanding analogies. </title> <journal> Artificial Intelligence, </journal> <volume> 35 </volume> <pages> 81-125, </pages> <year> 1988. </year>
Reference-contexts: These functions clearly don't share a common abstraction, but automatically matching on attributes of the signature won't detect this. Such hueristics, despite their shortcomings, may be powerful enough to support practical refactoring tasks. More powerful similarity detection is possible in some cases <ref> [8, 11] </ref>.
Reference: [12] <author> William G. Griswold. </author> <title> Program Restructuring as an Aid in Software Maintenance. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <year> 1991. </year>
Reference-contexts: It should be noted that any kind of program can be refactored, not just object-oriented ones, though the set of possible refactorings depends on the style of the program. For example, Griswald refactored Scheme programs <ref> [12] </ref>. In fact, though he didn't study the object-oriented transformations that are the subject of this paper, he showed how to implement some of the simpler refactorings that we will use, such as converting code segments into procedures.
Reference: [13] <author> Patrick A. V. Hall and Geoff R. Dowling. </author> <title> Approximate string matching. </title> <journal> Computing Surveys, </journal> <volume> 12(4) </volume> <pages> 381-402, </pages> <month> December </month> <year> 1980. </year>
Reference-contexts: The approaches represent the differences between programs as a set of edit operations (code insertion, replacement and deletion), to get from one program to the other. Program differences have been studied in regard to spelling correction <ref> [13, 27] </ref>, parsing error correction [28], version storage [24] and other uses. String comparison finds the minimum cost sequence of edit operations to convert one string into another. Tree comparison algorithms detect syntactic differences between programs by building syntax trees and comparing the trees.
Reference: [14] <author> Ralph E. Johnson and Brian Foote. </author> <title> Designing reusable classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(2) </volume> <pages> 22-35, </pages> <year> 1988. </year>
Reference-contexts: A common practice in the object-oriented community is to interleave periods of growth with consolidation periods in which the program is refactored (restructured) to make it smaller and easier to understand [18]. Refactoring is also important in developing reusable software, especially frameworks <ref> [14, 20, 21] </ref>. Frameworks are program skeletons that can be "fleshed out" to construct a complete program [9, 30]. Frameworks are usually developed by generalizing a set of concrete applications.
Reference: [15] <author> W. Lewis Johnson and Martin Feather. </author> <title> Building an evolution transformation library. </title> <booktitle> In Proceedings of the 12th International Conference on Software Engineering, </booktitle> <pages> pages 238-247, </pages> <year> 1990. </year>
Reference-contexts: Refactoring is also similar to the more traditional program transformation work, which usually has the goal of improving efficiency, of converting abstract program schemas into code, or of transforming an abstract design into a concrete program <ref> [2, 6, 15] </ref>. These systems often perform the inverse transformations to ours, since refactorings often are used to make programs more abstract and are not usually concerned with efficiency. Refactoring is a practical problem that needs better support.
Reference: [16] <author> Won Kim. </author> <title> Introduction to Object-Oriented Databases. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Several of them are based on dataflow techniques, and can almost certainly be improved upon. However, the undecidability of the basic problem requires that any algorithm for checking preconditions will be too conservative. Refactoring is similar to the schema modification in databases <ref> [3, 16, 22] </ref>. The main difference is that schema modification is concerned only with data, while refactorings are concerned with both data and program. On the other hand, the work on schema modification is concerned with updating the existing objects in the database.
Reference: [17] <author> Peter W. Madany. </author> <title> An Object-Oriented Framework for Filesystems. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year> <note> Also Technical Report No. </note> <institution> UIUCDCS-R-92-1751, Department of Computer Science, University of Illinois at Urbana-Champaign. </institution>
Reference-contexts: The next example shows a case where code replacement is done later in the refactor-ing process. 2.2 Inode Example The second example describes how refactorings were applied to improve the Inode 2 class during the design of the Choices file system framework <ref> [17] </ref>. An Inode contains a description of the disk layout of a file and other information such as the file owner, access permissions and access times. The Choices object-oriented operating system project at the University of Illinois has defined an operating system framework consisting of interlocking frameworks for file systems [17], <p> <ref> [17] </ref>. An Inode contains a description of the disk layout of a file and other information such as the file owner, access permissions and access times. The Choices object-oriented operating system project at the University of Illinois has defined an operating system framework consisting of interlocking frameworks for file systems [17], virtual memory [26], communication [31], and process scheduling [25]. An early version of the Choices file system framework supported only the BSD UNIX file format. Then, it was extended to handle both BSD UNIX and UNIX System V [1] file formats.
Reference: [18] <author> Jeff McKenna. </author> <title> A proposal for change management for smalltalk. </title> <type> Smalltalk Report, 1(5) </type> <pages> 1-3, </pages> <year> 1991. </year>
Reference-contexts: A common practice in the object-oriented community is to interleave periods of growth with consolidation periods in which the program is refactored (restructured) to make it smaller and easier to understand <ref> [18] </ref>. Refactoring is also important in developing reusable software, especially frameworks [14, 20, 21]. Frameworks are program skeletons that can be "fleshed out" to construct a complete program [9, 30]. Frameworks are usually developed by generalizing a set of concrete applications.
Reference: [19] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: This paper is about techniques for incrementally rewriting programs and improving their structure. It focuses on object-oriented programming and one kind of structure-improving transformation that is unique to object-oriented programming: finding abstract superclasses. Object-oriented programming is touted as being more reusable and extensible than conventional programming <ref> [19] </ref>. Nonetheless, the structure of an object-oriented program still deteriorates as features are added. As an object-oriented program grows, class hierarchies get larger and less rational, code is duplicated, and individual classes get larger and harder to understand.
Reference: [20] <author> William F. Opdyke. </author> <title> Refactoring Object-Oriented Frameworks. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year> <note> Also Technical Report No. </note> <institution> UIUCDCS-R-92-1759, Department of Computer Science, University of Illinois at Urbana-Champaign. </institution>
Reference-contexts: A common practice in the object-oriented community is to interleave periods of growth with consolidation periods in which the program is refactored (restructured) to make it smaller and easier to understand [18]. Refactoring is also important in developing reusable software, especially frameworks <ref> [14, 20, 21] </ref>. Frameworks are program skeletons that can be "fleshed out" to construct a complete program [9, 30]. Frameworks are usually developed by generalizing a set of concrete applications. <p> It is easy to generalize this to more than two classes. A and B must already have a common superclass, or no super-classes. If necessary, one of them can be moved in the superclass graph so that they become sibling classes <ref> [20] </ref>. The first important step in creating an abstract superclass S of a pair of classes A and B is to create an empty class with a unique name that is a sibling of A and B. <p> The prior examples (in particular, step 6 of the Matrix example and step 4 of the Inode example) illustrate the subsequent refactoring steps involved in creating an abstract superclass, which are defined below <ref> [20] </ref>: * adding function signatures to the superclass protocol (after making them compatible in both sub classes) * making functions bodies (and the variables referenced by them) compatible in both subclasses * migrating common variables to the superclass * migrating common code to the superclass. 3.1 Adding Function Signatures To The <p> There is a range of assistance that we could expect from a tool. Hueristics could be applied to determine, based on structural attributes of the function signatures, what refactorings would be needed to make them match <ref> [20] </ref>. In the above example, the tool could prompt the user that a renaming was needed, and provide a menu of choices: one of the functions could be renamed to match the other function, or both could be given an (identical) new name. <p> Tree comparison algorithms are more expensive than string comparison approaches, but are not as sensitive to minor differences in coding style (for example, extra spaces or blank lines). These techniques can be used in refactoring as follows <ref> [20] </ref>: Suppose the function commonFunction is defined in classes C1 and C2. <p> As with function signatures, structural heuristics could detect structural similarities (in name, access control mode and type). In cases where the attributes of the variables differ, refactorings can be applied to make them conform <ref> [20] </ref>. Once the attributes of a variable in both subclasses match, the variable can be moved to the abstract superclass. 3.4 Migrating Common Code to the Abstract Superclass Before migrating the function body to the superclass, any differences between the functions need to be determined. <p> A third reason is that any change to a program, including a refactoring, can introduce defects into it. We have addressed the first problem by specifying a set of refactorings that are commonly used in the object-oriented community <ref> [20, 21] </ref>. <p> What abstractions are meaningful depends on the application and on the designer. This implies that refactoring tasks, especially the more complex tasks, require some interaction with the designer. Nevertheless, much support can be provided by a refactoring tool <ref> [20] </ref>. We have algorithms for all of our refactorings, though many of these algorithms require several inputs from a user. Each algorithm has a precondition; if the precondition is met then the algorithm is behavior preserving and will not introduce any defects into the program.
Reference: [21] <author> William F. Opdyke and Ralph E. Johnson. </author> <title> Refactoring: An aid in designing application frameworks and evolving object-oriented systems. </title> <booktitle> In Proceedings of Symposium on Object-Oriented Programming Emphasizing Practical Applications (SOOPPA), </booktitle> <month> September </month> <year> 1990. </year>
Reference-contexts: A common practice in the object-oriented community is to interleave periods of growth with consolidation periods in which the program is refactored (restructured) to make it smaller and easier to understand [18]. Refactoring is also important in developing reusable software, especially frameworks <ref> [14, 20, 21] </ref>. Frameworks are program skeletons that can be "fleshed out" to construct a complete program [9, 30]. Frameworks are usually developed by generalizing a set of concrete applications. <p> A third reason is that any change to a program, including a refactoring, can introduce defects into it. We have addressed the first problem by specifying a set of refactorings that are commonly used in the object-oriented community <ref> [20, 21] </ref>.
Reference: [22] <author> D. Jason Penney and Jacob Stein. </author> <title> Class modification in the GemStone object-oriented dbms. </title> <booktitle> In Proceedings of OOPSLA `87, </booktitle> <year> 1987. </year>
Reference-contexts: Several of them are based on dataflow techniques, and can almost certainly be improved upon. However, the undecidability of the basic problem requires that any algorithm for checking preconditions will be too conservative. Refactoring is similar to the schema modification in databases <ref> [3, 16, 22] </ref>. The main difference is that schema modification is concerned only with data, while refactorings are concerned with both data and program. On the other hand, the work on schema modification is concerned with updating the existing objects in the database.
Reference: [23] <author> Edward J. </author> <title> Rak. Two redesign tools for Small-talk. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1990. </year>
Reference-contexts: In order for the new functions to represent meaningful abstractions, this "common" code might really belong together with the differing segments in those new functions. This suggests that automated analysis should be combined with user interaction, such as the approach Rak <ref> [23] </ref> describes for abstracting a function (Small-talk method) into a superclass from its subclass implementations. 3.3 Moving Variables Having created the abstract superclass and determined the function signatures, it is sometimes necessary to add member variables to the abstract su-perclass.
Reference: [24] <author> Marc J. Rochkind. </author> <title> The source code control system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1(4):364-370, </volume> <month> December </month> <year> 1975. </year>
Reference-contexts: The approaches represent the differences between programs as a set of edit operations (code insertion, replacement and deletion), to get from one program to the other. Program differences have been studied in regard to spelling correction [13, 27], parsing error correction [28], version storage <ref> [24] </ref> and other uses. String comparison finds the minimum cost sequence of edit operations to convert one string into another. Tree comparison algorithms detect syntactic differences between programs by building syntax trees and comparing the trees.
Reference: [25] <author> Vince Russo, Gary Johnston, and Roy H. Camp-bell. </author> <title> Process Management in Multiprocessor Operating Systems using Class Hierarchical Design. </title> <booktitle> In Proceedings of OOPSLA '88, </booktitle> <address> San Diego, Ca., </address> <month> September </month> <year> 1988. </year>
Reference-contexts: The Choices object-oriented operating system project at the University of Illinois has defined an operating system framework consisting of interlocking frameworks for file systems [17], virtual memory [26], communication [31], and process scheduling <ref> [25] </ref>. An early version of the Choices file system framework supported only the BSD UNIX file format. Then, it was extended to handle both BSD UNIX and UNIX System V [1] file formats.
Reference: [26] <author> Vincent Russo and Roy H. Campbell. </author> <title> Virtual Memory and Backing Storage Management in Multiprocessor Operating Systems using Class Hierarchical Design. </title> <note> In Submitted to OOPSLA '89, 1989. Also available as University of Illinois Technical Report. </note>
Reference-contexts: The Choices object-oriented operating system project at the University of Illinois has defined an operating system framework consisting of interlocking frameworks for file systems [17], virtual memory <ref> [26] </ref>, communication [31], and process scheduling [25]. An early version of the Choices file system framework supported only the BSD UNIX file format. Then, it was extended to handle both BSD UNIX and UNIX System V [1] file formats.
Reference: [27] <author> David Sankoff and Joseph B. Kruskal. </author> <title> Macro-molecular sequences. In Time Warps, String Edits, and Macromolecules: The Theory and Practice of Sequence Comparison (D. </title> <editor> Sankoff and J. Kruskal, </editor> <booktitle> eds), </booktitle> <pages> pages 45-53, </pages> <year> 1983. </year>
Reference-contexts: The approaches represent the differences between programs as a set of edit operations (code insertion, replacement and deletion), to get from one program to the other. Program differences have been studied in regard to spelling correction <ref> [13, 27] </ref>, parsing error correction [28], version storage [24] and other uses. String comparison finds the minimum cost sequence of edit operations to convert one string into another. Tree comparison algorithms detect syntactic differences between programs by building syntax trees and comparing the trees.
Reference: [28] <author> Robert A. Wagner. </author> <title> Order-n correction for regular languages. </title> <journal> Communications of the ACM, </journal> <volume> 17(5) </volume> <pages> 265-268, </pages> <year> 1974. </year>
Reference-contexts: The approaches represent the differences between programs as a set of edit operations (code insertion, replacement and deletion), to get from one program to the other. Program differences have been studied in regard to spelling correction [13, 27], parsing error correction <ref> [28] </ref>, version storage [24] and other uses. String comparison finds the minimum cost sequence of edit operations to convert one string into another. Tree comparison algorithms detect syntactic differences between programs by building syntax trees and comparing the trees.
Reference: [29] <author> Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener. </author> <title> Designing Object-Oriented Software. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: This bottom up discovery can happen early in the life-cycle of a system: Wirfs-Brock et. al. show how to find abstract classes during an early design phase before any algorithms have been specified <ref> [29] </ref>.
Reference: [30] <author> Rebecca J. Wirfs-Brock and Ralph E. Johnson. </author> <title> A survey of current research in object-oriented design. </title> <journal> Communications of the ACM, </journal> <month> September </month> <year> 1990. </year>
Reference-contexts: Refactoring is also important in developing reusable software, especially frameworks [14, 20, 21]. Frameworks are program skeletons that can be "fleshed out" to construct a complete program <ref> [9, 30] </ref>. Frameworks are usually developed by generalizing a set of concrete applications. Sometimes frameworks are developed by careful planning, starting with a domain analysis and a study of several applications in the problem domain. In these cases refactoring is less important. <p> Below we describe what can be automated, what cannot be automated, and what that are still up in the air. 2 Examples of Finding Ab stract Classes An abstract class is a class designed to be used only as a superclass <ref> [30] </ref>. This is in contrast to the normal way that a class is used, which is both by making instances of it and by using it as a superclass.
Reference: [31] <author> Jonathan Zweig and Ralph Johnson. Conduits: </author> <title> A communication abstraction in C++. </title> <booktitle> In Proceedings of the USENIX C++ Workshop, </booktitle> <pages> pages 191-203, </pages> <year> 1990. </year>
Reference-contexts: The Choices object-oriented operating system project at the University of Illinois has defined an operating system framework consisting of interlocking frameworks for file systems [17], virtual memory [26], communication <ref> [31] </ref>, and process scheduling [25]. An early version of the Choices file system framework supported only the BSD UNIX file format. Then, it was extended to handle both BSD UNIX and UNIX System V [1] file formats.
References-found: 31

