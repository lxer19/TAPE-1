URL: http://www.ri.cmu.edu/afs/cs/usr/eugeneng/www/costs.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/usr/eugeneng/www/publications.html
Root-URL: 
Email: nara,eugeneng,dylan,tiwary,levy @cs.washington.edu  
Title: Reducing the Virtual Memory Overhead of Swizzling  
Author: Vivek Narasayya, Tze Sing Eugene Ng, Dylan McNamee, Ashutosh Tiwary, Hank Levy 
Address: Seattle.  
Affiliation: University of Washington,  
Abstract: Swizzling is a mechanism used by OODBs and persistent object systems to convert pointers from their disk format to a more efficient in-memory format. Previous studies of swizzling have focussed on analyzing the CPU overhead of pointer translation and studying trade-offs in different approaches to swizzling. In this paper, we show that there is an additional indirect but important cost associated with swizzling: swizzling a read-only page causes it to be dirty with respect to the operating system. At the onset of paging, these read-only pages may be written to the swap file unnecessarily. We propose a simple modification to the operating system that reduces the impact of this overhead on application performance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Boral, W. Alexander, L. Clay, G. Copeland, S. Danforth, M. Franklin, B. Hart, M. Smith, and P. Vlduriez. </author> <title> Prototyping bubba, a highly parallel database system. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(2):424, </volume> <year> 1990. </year>
Reference-contexts: Making the pages in the buffer pool clean prevents paging of read-only data. OODB buffer management can be integrated with virtual memory <ref> [1] </ref> [4] by mapping the database into the virtual memory of the application. The virtual memory system is responsible for paging data to and from the mapped file. Once again, swizzling causes read-only pages to be dirty.
Reference: [2] <author> M. J. Carey, D. J. Dewitt, and J. F. Naughton. </author> <title> The oo7 benchmark. </title> <booktitle> 1993 ACM Sigmod. International Conference on Management of Data, </booktitle> <address> 2(22):1221, </address> <month> May </month> <year> 1993. </year> <title> Average swizzling cost per page in Texas Estimated time for a page-out using a micro-benchmark 3 ms 13 ms Table 2: Cost of swizzling vs Cost of page-out </title>
Reference-contexts: The numbers reported are the averages of three separate runs. We used the T1 traversal of the OO7 benchmark <ref> [2] </ref> as our read-only workload and varied the database size from 23 MB to 86 MB. A read-only application should never have to page-out data. Therefore, the page-outs measured in the experiment are, by our definition, the VM overhead in Texas.
Reference: [3] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinred. </author> <title> The objectstore database system. </title> <journal> Communications of the ACM, </journal> <volume> 10(34), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: If the page is referenced again, then the application saves 10 ms on the average; if not it saves the full 13 ms. An alternative to clearing the dirty bit is to avoid swiz-zling in the first place. OODBs, such as QuickStore [9] and ObjectStore <ref> [3] </ref>, attempt to avoid swizzling by locating the database segment at the same virtual address of the application each time. However, avoiding swizzling alone doesnt avoid VM overhead, because pages are still dirty due to copying from the file system buffer.
Reference: [4] <author> D. McNamee, V. Narasayya, A. Tiwary, H. Levy, J. Chase, and Y. Gao. </author> <title> Virtual memory alternatives for client buffer management in transaction system. </title> <note> Submitted for Publication, </note> <year> 1996. </year>
Reference-contexts: However, avoiding swizzling alone doesnt avoid VM overhead, because pages are still dirty due to copying from the file system buffer. Integrating buffer management with virtual memory <ref> [4] </ref> and avoiding swizzling would eliminate VM overhead for these systems. Another way to avoid VM overhead is to map a file backed by an NFS server that provides clean swizzled pages to the application. The drawback of this scheme is that it requires extensive modifications to the NFS server. <p> Making the pages in the buffer pool clean prevents paging of read-only data. OODB buffer management can be integrated with virtual memory [1] <ref> [4] </ref> by mapping the database into the virtual memory of the application. The virtual memory system is responsible for paging data to and from the mapped file. Once again, swizzling causes read-only pages to be dirty.
Reference: [5] <author> J. E. B. Moss. </author> <title> Working with persistent objects: To swizzle or not to swizzle. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 8(18):657673, </volume> <month> August </month> <year> 1992. </year>
Reference-contexts: Swizzling is a complex technique with a number of dimensions [7]. Previous swizzling studies have analyzed the costs of pointer translation <ref> [5] </ref> and explored trade-offs such as software vs. virtual memory hardware swizzling, eager vs. lazy swizzling, and object grain vs. page grain swizzling [8].
Reference: [6] <author> V. Singhal, S. V. Kakkad, and P. R. Wilson. </author> <title> Texas: An efficient, portable persistent store. </title> <booktitle> Proceedings of Fifth International Workshop on Persistent Object Sytems, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: We call these unnecessary page-outs the virtual memory overhead (VM overhead) of swizzling, since they are caused by the interaction of swizzling and the virtual memory system. In the next section we describe and quantify the VM overhead problem in the context of Texas <ref> [6] </ref>, an OODB that employs pointer swizzling using virtual memory hardware. In Section 3 we propose a solution to this problem that involves a small change to the operating system, and argue that it can be used to improve performance of predominantly read-only workloads.
Reference: [7] <author> S. J. White. </author> <title> Pointer swizzling techniques for object-oriented database systems. </title> <type> Ph.d. Thesis. </type> <institution> University of Wisconsin, Madison, </institution> <year> 1994. </year>
Reference-contexts: Swizzling converts pointers from their disk format (an object identifier) to a more efficient in-memory format (a virtual memory address) when persistent objects are brought into memory by the OODB. Swizzling is a complex technique with a number of dimensions <ref> [7] </ref>. Previous swizzling studies have analyzed the costs of pointer translation [5] and explored trade-offs such as software vs. virtual memory hardware swizzling, eager vs. lazy swizzling, and object grain vs. page grain swizzling [8].
Reference: [8] <author> S. J. White and D. J. Dewitt. </author> <title> A performance study of alternative object faulting and pointer swizzling strategies. </title> <booktitle> Proceedings of the 18th VLDB Conference, </booktitle> <address> Vancouver, Canada, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Swizzling is a complex technique with a number of dimensions [7]. Previous swizzling studies have analyzed the costs of pointer translation [5] and explored trade-offs such as software vs. virtual memory hardware swizzling, eager vs. lazy swizzling, and object grain vs. page grain swizzling <ref> [8] </ref>. These studies do not identify or quantify an important indirect cost of swizzling that occurs due to the interaction of swizzled pages with the operating system (OS).
Reference: [9] <author> S. J. White and D. J. Dewitt. </author> <title> Quickstore: A high performance mapped object store. </title> <booktitle> Proceedings of the 1994 ACM-SIGMOD Conference on the Management of Data , Minneapolis, </booktitle> <address> MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: If the page is referenced again, then the application saves 10 ms on the average; if not it saves the full 13 ms. An alternative to clearing the dirty bit is to avoid swiz-zling in the first place. OODBs, such as QuickStore <ref> [9] </ref> and ObjectStore [3], attempt to avoid swizzling by locating the database segment at the same virtual address of the application each time. However, avoiding swizzling alone doesnt avoid VM overhead, because pages are still dirty due to copying from the file system buffer.
Reference: [10] <author> P. R. Wilson. </author> <title> Pointer swizzling at page fault time: Efficiently supporting huge address spaces on standard hardware. </title> <journal> ACM SIGARCH Computer Architecture News, </journal> <volume> 4(19), </volume> <month> June </month> <year> 1991. </year>
Reference-contexts: We summarize and conclude in Section 5. 2 Quantifying the VM overhead VM overhead can occur in any OODB that swizzles. In this section we describe and quantify VM overhead in Texas for the OO7 workload. Texas uses pointer swizzling at page fault time <ref> [10] </ref> to provide a mapping from persistent to virtual memory. To ensure that the first access to a page is intercepted, Texas access protects the page. When a page fault occurs, Texas swizzles the page by overwriting pointers in the persistent format with virtual addresses.
References-found: 10

