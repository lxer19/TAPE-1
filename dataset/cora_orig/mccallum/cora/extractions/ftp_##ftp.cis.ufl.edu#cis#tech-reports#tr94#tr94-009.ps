URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr94/tr94-009.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr94-abstracts.html
Root-URL: http://www.cis.ufl.edu
Email: pk@cis.ufl.edu ted@cis.ufl.edu  
Title: Implementing Distributed Search Structures  
Author: Padmashree Krishna Theodore Johnson 
Date: March 26, 1994  
Address: Gainesville, FL 32611  
Affiliation: Computer and Information Sciences Department University of Florida  
Abstract: Distributed search structures are useful for parallel databases and in maintaining distributed storage systems. In this paper we discuss some issues in the design and implementation of distributed B-trees, such as methods for low-overhead synchronization of tree restructuring, node mobility and replication strategies. We have implemented a distributed B-tree that replicates the index and also performs data load balancing. Replication of the index provides for high throughput access, and data balancing allows for balanced processor and space utilization. For replication, we propose two different strategies, namely, full replication wherein the entire index is replicated at each processor and path replication where if a processor owns a leaf node, it also holds the index nodes on the path from the root to that leaf node. We present an algorithm for dynamic data-load balancing which uses node mobility mechanisms. We present some performance results of our algorithms. We find that path replication will create a scalable distributed B-tree. Keywords: Data Structures, Distributed Databases, Load-balancing, Path Replication, Full Repli cation.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bal, H. E. and Tannenbaum, A. S. </author> <title> Distributed Programming with Shared Data, </title> <booktitle> IEEE International Conference on Computer Languages, </booktitle> <year> 1988, </year> <pages> pp. 82-90. </pages>
Reference-contexts: In what is called the TOTAL structure the entire data are replicated at each processor [16]. This increases the availability and fault tolerance but places a high demand on memory requirements. A compromise is to set up a balance between memory usage and cost considerations <ref> [1] </ref>. The multi-version memory algorithm proposed by Wang and Weihl [20] reduces the amount of synchronization and communication needed to maintain replicated copies. Several algorithms have been proposed for replicating a node [3]. Lazy replication has been proposed by Ladin et al., for replicating servers [14].
Reference: [2] <author> Bayer R. and McCreight E. </author> <title> Concurrency of operations on B-trees, </title> <journal> Acta Informatica 1, </journal> <year> 1972, </year> <pages> pp. 173-189. </pages>
Reference-contexts: Finally, we present the performance results of our algorithms, where we find that the path-replication strategy for replicating performs better than full replication and is also scalable. 2 Previous Work Several approaches to concurrent access of the B-tree have been proposed <ref> [2] </ref>, [13], [15], [18]. Sagiv [17], and Lehman and Yao [13] use a link technique to reduce contention. Parallel B-trees using multi-version memory have been proposed by Wang and Weihl [20]. The algorithm is designed for software cache management and is suitable for cache-coherent shared memory multiprocessors.
Reference: [3] <author> Bernstein, P. A., Hadzilacos, V. and Goodman, N. </author> <title> Concurreny Control and Recovery in Database Systems, </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: A compromise is to set up a balance between memory usage and cost considerations [1]. The multi-version memory algorithm proposed by Wang and Weihl [20] reduces the amount of synchronization and communication needed to maintain replicated copies. Several algorithms have been proposed for replicating a node <ref> [3] </ref>. Lazy replication has been proposed by Ladin et al., for replicating servers [14]. Replicas communicate information among themselves by lazily exchanging gossip messages. Several authors have explored the construction of non-blocking and wait-free concurrent data structures in a shared-memory environment [7, 19].
Reference: [4] <author> P.A. Bernstein and V. Hadzilacos and N. </author> <title> Goodman Concurrency Control and Recovery in Database Systems, </title> <publisher> Addison-Wesley, </publisher> <year> 1987 </year>
Reference-contexts: Our algorithms require considerably less overhead, since we do not 2 broadcast, but look at relative nodes to find out where the node has moved. A search structure node can be replicated using one of several well-known algorithms <ref> [4] </ref>. In what is called the TOTAL structure the entire data are replicated at each processor [16]. This increases the availability and fault tolerance but places a high demand on memory requirements. A compromise is to set up a balance between memory usage and cost considerations [1].
Reference: [5] <author> F.B. Bastani and S.S. </author> <title> Iyengar and I-Ling Yen Concurrent Maintenance of Data Structures in a Distributed Environment, </title> <journal> The Computer Journal, </journal> <volume> Vol. 21, No. 2, </volume> <year> 1982, </year> <pages> pp. 165-174. </pages>
Reference: [6] <author> Colbrook A., Brewer A. E., Dellarocas C.N. and Weihl E. W. </author> <title> An Algorithm for Concurrent Search Trees, </title> <booktitle> Proccedings of the 20th International Conference on Parallel Processing, </booktitle> <year> 1991, </year> <pages> pp. 38-41. </pages>
Reference-contexts: Restructuring decisions are made locally thereby reducing the communication overhead and increasing parallelism. The paper also deals with the data balancing among processors. They suggest a way of reducing communication cost for data balancing by storing neighboring leaves on the same processor. Colbrook, et al. <ref> [6] </ref> have proposed a pipelined distributed B-tree, where each level of the tree is maintained by a different processor. We used this approach as a preliminary design for our distributed B-tree.
Reference: [7] <author> Herlihy, M. </author> <title> A Methodology for Implementing Highly Concurrent Data Structures, </title> <booktitle> Proceeding of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, ACM 1989, </booktitle> <pages> pp. 197-206. </pages>
Reference-contexts: Lazy replication has been proposed by Ladin et al., for replicating servers [14]. Replicas communicate information among themselves by lazily exchanging gossip messages. Several authors have explored the construction of non-blocking and wait-free concurrent data structures in a shared-memory environment <ref> [7, 19] </ref>. These algorithms enhance concurrency because a slow operation never blocks a fast operation. In a previous paper, we have proposed fixed copy and variable copy algorithms for lazy updates on a distributed B-tree and provided a theoretical framework for replication [10].
Reference: [8] <author> Johnson T. and Shasha D. </author> <title> A Framework for the performance Analysis of Concurrent B-tree Algorithms, </title> <booktitle> Proceedings of the 9th ACM Symposium on Principles of Database Systems, </booktitle> <month> April </month> <year> 1990. </year> <month> 24 </month>
Reference-contexts: A B-link tree is a B + -tree in which every node contains a pointer to its right sibling. Concurrent B-link tree algorithms [13, 17] have been found to provide the highest concurrency of all concurrent B-tree algorithms <ref> [8] </ref>. In addition, operations on a B-link tree access one node at a time. A B-link tree's high performance and node independence makes it the most attractive starting point for constructing a distributed search structure. <p> Since the B-tree property guarantees that the keys are nicely distributed among the nodes <ref> [8] </ref>, a noticeable performance enhancement may not be observed in a uniformly distributed data pattern. So, to study the effect of our load balancing algorithm when the distribution changes, we have introduced hot spots in our key generation pattern.
Reference: [9] <author> Johnson T. and Colbrook A. </author> <title> A Distributed Data-Balanced Dictionary Based on the B-link Tree, </title> <booktitle> International Parallel Processing Symposium, </booktitle> <month> March </month> <year> 1992, </year> <pages> pp. 319-325. </pages>
Reference-contexts: Every processor has a copy of the leaf node and the updates to the copies are made in a `lazy' manner. A multi-version memory allows a process to read an "old version" of data. Therefore, individual reads and writes appear no longer atomic. Johnson and Colbrook <ref> [9] </ref> present a distributed B-tree suitable for message passing architectures. The interior nodes are replicated to improve parallelism and alleviate the bottleneck. Restructuring decisions are made locally thereby reducing the communication overhead and increasing parallelism. The paper also deals with the data balancing among processors.
Reference: [10] <author> Johnson, T. and Krishna, P. </author> <title> Lazy Updates for Distributed Search Structures SIGMOD '93. </title>
Reference-contexts: In this paper we present two mechanisms, namely full replication and path replication for replicating the index of the B-tree. The theoretical framework for these algorithms has been developed in a previous paper <ref> [10] </ref>. Here, we discuss some issues in implementing the algorithms. This paper also addresses the issue of data balancing, wherein every processor has a limited maximum load that it can hold. When the load at a processor increases beyond a threshold, some of the nodes are moved to another processor. <p> These algorithms enhance concurrency because a slow operation never blocks a fast operation. In a previous paper, we have proposed fixed copy and variable copy algorithms for lazy updates on a distributed B-tree and provided a theoretical framework for replication <ref> [10] </ref>. Lazy update algorithms are similar to lazy replication algorithms because both use the semantics of an operation to reduce the cost of maintaining replicated copies. The effects of an operation can be lazily sent to the other servers, perhaps on piggybacked messages. <p> The purpose of this will be explained shortly in section 4.4.3. * Level Number: Every node is associated with a level number. The level number, which indicates the distance to a leaf, is useful in recovery from misnavigation <ref> [10] </ref>. * Links to Relatives: The parent, siblings and children are the relatives of a node. A typical node would have a pointer to the primary parent, local parent, children, and siblings. A pointer to a node contains the node's name and version number. <p> We have taken the approach of the single-copy mobile nodes algorithm proposed in a previous paper <ref> [10] </ref>. We will briefly discuss it here. Every node has only a single-copy, but the nodes can migrate from processor to processor. When a node migrates, it informs its neighbors of the new address.
Reference: [11] <author> Jul E., Levy H., Hutchinson N. and Black A. </author> <title> Fine Grained Mobility in the Emerald System, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 6, No. 1, </volume> <month> February </month> <year> 1988, </year> <pages> pp. 109-133. </pages>
Reference-contexts: The parallelism achieved is limited by the height of the B-tree, and the processors are not data balanced since the processor holding the leaf nodes has more nodes than other processors. In the context of node mobility, object mobility has been proposed in Emerald <ref> [11] </ref>. Objects keep forwarding information even after they have moved to another node and use a broadcast protocol if no forwarding information is available. Our algorithms require considerably less overhead, since we do not 2 broadcast, but look at relative nodes to find out where the node has moved.
Reference: [12] <institution> KSR1 Principles of Operation, Copyright Kendall Research Corporation, </institution> <year> 1991. </year>
Reference: [13] <author> Lehman P.L., and Yao S.B. </author> <title> Efficient Locking for Concurrent Operations on B-trees, </title> <journal> ACM Transactions on Database Systems 6, </journal> <month> December </month> <year> 1981, </year> <pages> pp. 650-670. </pages>
Reference-contexts: Finally, we present the performance results of our algorithms, where we find that the path-replication strategy for replicating performs better than full replication and is also scalable. 2 Previous Work Several approaches to concurrent access of the B-tree have been proposed [2], <ref> [13] </ref>, [15], [18]. Sagiv [17], and Lehman and Yao [13] use a link technique to reduce contention. Parallel B-trees using multi-version memory have been proposed by Wang and Weihl [20]. The algorithm is designed for software cache management and is suitable for cache-coherent shared memory multiprocessors. <p> we present the performance results of our algorithms, where we find that the path-replication strategy for replicating performs better than full replication and is also scalable. 2 Previous Work Several approaches to concurrent access of the B-tree have been proposed [2], <ref> [13] </ref>, [15], [18]. Sagiv [17], and Lehman and Yao [13] use a link technique to reduce contention. Parallel B-trees using multi-version memory have been proposed by Wang and Weihl [20]. The algorithm is designed for software cache management and is suitable for cache-coherent shared memory multiprocessors. <p> In a B + -tree, the keys are stored in the leaves and the non-leaf nodes serve as the index. A B-link tree is a B + -tree in which every node contains a pointer to its right sibling. Concurrent B-link tree algorithms <ref> [13, 17] </ref> have been found to provide the highest concurrency of all concurrent B-tree algorithms [8]. In addition, operations on a B-link tree access one node at a time. A B-link tree's high performance and node independence makes it the most attractive starting point for constructing a distributed search structure.
Reference: [14] <author> Ladin R., Liskov B., and Shira L. </author> <title> Providing High Reliability Using Lazy Replication, </title> <journal> ACM Transactions on Computer Systems Vol. </journal> <volume> 10, No. 4, </volume> <year> 1992, </year> <pages> pp. 360-391. </pages>
Reference-contexts: The multi-version memory algorithm proposed by Wang and Weihl [20] reduces the amount of synchronization and communication needed to maintain replicated copies. Several algorithms have been proposed for replicating a node [3]. Lazy replication has been proposed by Ladin et al., for replicating servers <ref> [14] </ref>. Replicas communicate information among themselves by lazily exchanging gossip messages. Several authors have explored the construction of non-blocking and wait-free concurrent data structures in a shared-memory environment [7, 19]. These algorithms enhance concurrency because a slow operation never blocks a fast operation.
Reference: [15] <author> Miller R. and Snyder L. </author> <title> Multiple Access to B-trees, </title> <booktitle> Proccedings of the 1978 Conference on Information Sciences and Systems, </booktitle> <institution> Johns Hopkins University, Baltimore, </institution> <month> March </month> <year> 1978, </year> <pages> pp. 400-408. </pages>
Reference-contexts: Finally, we present the performance results of our algorithms, where we find that the path-replication strategy for replicating performs better than full replication and is also scalable. 2 Previous Work Several approaches to concurrent access of the B-tree have been proposed [2], [13], <ref> [15] </ref>, [18]. Sagiv [17], and Lehman and Yao [13] use a link technique to reduce contention. Parallel B-trees using multi-version memory have been proposed by Wang and Weihl [20]. The algorithm is designed for software cache management and is suitable for cache-coherent shared memory multiprocessors.
Reference: [16] <author> Peleg D. </author> <title> Distributed Data Structures: A Complexity-Oriented View, </title> <booktitle> Fourth International Workshop on Distributed Algorithms, </booktitle> <year> 1990. </year>
Reference-contexts: A search structure node can be replicated using one of several well-known algorithms [4]. In what is called the TOTAL structure the entire data are replicated at each processor <ref> [16] </ref>. This increases the availability and fault tolerance but places a high demand on memory requirements. A compromise is to set up a balance between memory usage and cost considerations [1].
Reference: [17] <author> Sagiv Y. </author> <title> Concurrent Operations on B-Trees with Overtaking, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 33(2), </volume> <month> October </month> <year> 1986, </year> <pages> pp. 275-296. </pages>
Reference-contexts: Finally, we present the performance results of our algorithms, where we find that the path-replication strategy for replicating performs better than full replication and is also scalable. 2 Previous Work Several approaches to concurrent access of the B-tree have been proposed [2], [13], [15], [18]. Sagiv <ref> [17] </ref>, and Lehman and Yao [13] use a link technique to reduce contention. Parallel B-trees using multi-version memory have been proposed by Wang and Weihl [20]. The algorithm is designed for software cache management and is suitable for cache-coherent shared memory multiprocessors. <p> In a B + -tree, the keys are stored in the leaves and the non-leaf nodes serve as the index. A B-link tree is a B + -tree in which every node contains a pointer to its right sibling. Concurrent B-link tree algorithms <ref> [13, 17] </ref> have been found to provide the highest concurrency of all concurrent B-tree algorithms [8]. In addition, operations on a B-link tree access one node at a time. A B-link tree's high performance and node independence makes it the most attractive starting point for constructing a distributed search structure.
Reference: [18] <author> Samadi B. </author> <title> B-trees in a system with multiple users, </title> <journal> Information Processing Letters, </journal> <volume> 5, </volume> <year> 1976, </year> <pages> pp. 107-112. </pages>
Reference-contexts: Finally, we present the performance results of our algorithms, where we find that the path-replication strategy for replicating performs better than full replication and is also scalable. 2 Previous Work Several approaches to concurrent access of the B-tree have been proposed [2], [13], [15], <ref> [18] </ref>. Sagiv [17], and Lehman and Yao [13] use a link technique to reduce contention. Parallel B-trees using multi-version memory have been proposed by Wang and Weihl [20]. The algorithm is designed for software cache management and is suitable for cache-coherent shared memory multiprocessors.
Reference: [19] <author> Turek J., Shasha D., and Prakash S. </author> <title> Locking without Blocking: Making Lock Based Concurrent Data Structure Algorithms Nonblocking, </title> <booktitle> ACM Symposium on Principles of Database Systems, </booktitle> <year> 1992, </year> <pages> pp. 212-222. </pages>
Reference-contexts: Lazy replication has been proposed by Ladin et al., for replicating servers [14]. Replicas communicate information among themselves by lazily exchanging gossip messages. Several authors have explored the construction of non-blocking and wait-free concurrent data structures in a shared-memory environment <ref> [7, 19] </ref>. These algorithms enhance concurrency because a slow operation never blocks a fast operation. In a previous paper, we have proposed fixed copy and variable copy algorithms for lazy updates on a distributed B-tree and provided a theoretical framework for replication [10].
Reference: [20] <author> Weihl E. W. and Wang P. </author> <title> Multi-version Memory: Software cache Management for Concurrent B-Trees, </title> <booktitle> Proceedings of the 2nd IEEE Symposium on Parallel and Distributed Processing, </booktitle> <year> 1990, </year> <pages> pp. 650-655. </pages>
Reference-contexts: Sagiv [17], and Lehman and Yao [13] use a link technique to reduce contention. Parallel B-trees using multi-version memory have been proposed by Wang and Weihl <ref> [20] </ref>. The algorithm is designed for software cache management and is suitable for cache-coherent shared memory multiprocessors. Every processor has a copy of the leaf node and the updates to the copies are made in a `lazy' manner. <p> This increases the availability and fault tolerance but places a high demand on memory requirements. A compromise is to set up a balance between memory usage and cost considerations [1]. The multi-version memory algorithm proposed by Wang and Weihl <ref> [20] </ref> reduces the amount of synchronization and communication needed to maintain replicated copies. Several algorithms have been proposed for replicating a node [3]. Lazy replication has been proposed by Ladin et al., for replicating servers [14]. Replicas communicate information among themselves by lazily exchanging gossip messages.
References-found: 20

