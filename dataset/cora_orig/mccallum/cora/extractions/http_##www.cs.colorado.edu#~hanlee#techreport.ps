URL: http://www.cs.colorado.edu/~hanlee/techreport.ps
Refering-URL: http://www.cs.colorado.edu/~hanlee/
Root-URL: http://www.cs.colorado.edu
Email: E-mail: fcooperb,hanlee,zorng@cs.colorado.edu  
Phone: Telephone: (303) 492-4398 FAX: (303) 492-2844  
Title: ProfBuilder: A Package for Rapidly Building Java Execution Profilers  
Author: Brian F. Cooper, Han B. Lee, and Benjamin G. Zorn 
Date: April 1998  
Address: Campus Box 430  Boulder, CO 80309-0430 USA  Boulder  
Affiliation: Department of Computer Science  University of Colorado  ffi University of Colorado at  
Pubnum: CU-CS-853-98  
Abstract: Technical Report CU-CS-853-98 Department of Computer Science Campus Box 430 University of Colorado Boulder, Colorado 80309 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Glenn Ammons, Thomas Ball, and James R. Larus. </author> <title> Exploiting hardware performance counters with flow and context sensitive profiling. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI-97), volume 32, 5 of ACM SIGPLAN Notices, </booktitle> <pages> pages 85-96, </pages> <address> New York, June 1997. </address> <publisher> ACM Press. </publisher>
Reference-contexts: ProfBuilder uses the Bytecode Instrumenting Tool (BIT) invented by Lee and Zorn [8, 7] to instrument compiled Java programs. The central data structure of ProfBuilder is the Calling Context Tree (CCT) <ref> [1] </ref>, which is used to model the execution of an application and to store arbitrary measurements of dynamic behavior, such as branch outcomes or memory allocations. <p> In Section 8, we present our conclusions. 2 Background In order to fully understand ProfBuilder, it is first important to understand its two underlying technologies, the CCT and BIT. Section 2.1 describes the Calling Context Tree, and Section 2.2 describes BIT. 2.1 Calling Context Tree Ammons, Ball and Larus <ref> [1] </ref> describe three data structures for recording the runtime behavior of programs, the dynamic call graph, the dynamic call tree, and the new structure they propose, the Calling Context Tree. In a dynamic call graph, each subroutine is represented as a vertex, and calls are represented as edges. <p> JLex/JavaLexBitSet.resize ( 12) | JLex/JavaLexBitSet.nbits2size ( 3499882) ***** | JLex/CNfa2Dfa.e_closure ( 1457610) ** | JLex/JavaLexBitSet.set (13472313) ********************| JLex/CNfa2Dfa.sortStates ( 2888) | JLex/CNfa2Dfa.add_to_dstates ( 988) | JLex/CAlloc.newCDfa ...(remaining output omitted) 20 7 Related Work The data structure and algorithms for the Calling Context Tree were described by Ammons, Ball and Larus <ref> [1] </ref>. The data structure was written as described in their paper, with a few modifications for the Java environment, specifically using arrays of integers instead of hardware counters to record metrics. Digital Equipment Corporation developed ATOM [11], or Analysis Tools using OM, for instrumenting binaries on DEC machines.
Reference: [2] <author> Elliot Berk. JLex: </author> <title> A lexical analyzer generator for Java. </title> <note> Available at http://www.cs.princeton.edu/~appel/modern/java/JLex. </note>
Reference-contexts: We discuss performance issues related to using the tools to instrument programs and show data on various Java applications. We also discuss the results of using IProfTool to optimize JLex <ref> [2] </ref>, a lexical analyzer generator. An examination of the bytecode instruction profile for JLex allowed us to identify a significant performance bottleneck, and upon reimplementation of a single procedure, the execution time of the application was cut by 15%. This paper is organized as follows. <p> IProfTool was used to instrument several programs in order to measure the overhead. These programs are JLex, a lexical analyzer generator <ref> [2] </ref>, aster, an Asteroids space game (also used in [10]), espresso, a Java compiler [9], and java cup, a "Constructor for Useful Parsers" [4]. Table 1 summarizes each application, including execution time and compiled bytecode size. <p> For the program, we chose JLex, a lexical analyzer generator for Java written by Elliot Berk and similar to lex <ref> [2] </ref>. This program is an example of a moderately sized, publicly distributed Java application written by an outside party. We were able to instrument the program and collect data without any prior understanding of the source code or underlying algorithms.
Reference: [3] <author> Susan L. Graham, Peter B. Kessler, and Marshall K. McKusick. </author> <title> An execution profiler for modular programs. </title> <journal> Software|Practice and Experience, </journal> <volume> 13 </volume> <pages> 671-685, </pages> <year> 1983. </year>
Reference-contexts: These factors suggest that Java applications are a good target for optimizations based on dynamic execution data. The concept of execution profiling has a long history and has been widely available in successful tools, such as gprof <ref> [3] </ref>, which generates a hierarchical profile of an application. ProfBuilder is a meta-tool for building sophisticated tools in the style of gprof with a small amount of effort. ProfBuilder provides a fast and easy way to create a variety of profiling tools with a small amount of code. <p> The Calling Context Tree tools use BIT to instrument the bytecode. Both ATOM and BIT allow the user to construct tools that monitor dynamic program execution by inserting calls to analysis routine directly into the compiled code. Profiling tools originated with gprof <ref> [3] </ref>, a dynamic execution profiler. gprof describes path profiles by describing the caller/callee connection between two routines. From these connections, the structure of the call graph is inferred.
Reference: [4] <author> Scott Hudson. </author> <title> Java based constructor of useful parsers (CUP). </title> <note> Available at http://www.cc.gatech.edu/gvu/people/Faculty/hudson/java cup/home.html. </note>
Reference-contexts: IProfTool was used to instrument several programs in order to measure the overhead. These programs are JLex, a lexical analyzer generator [2], aster, an Asteroids space game (also used in [10]), espresso, a Java compiler [9], and java cup, a "Constructor for Useful Parsers" <ref> [4] </ref>. Table 1 summarizes each application, including execution time and compiled bytecode size. The applications were compiled and run using Sun's JDK version 1.1.5 on a machine with a 233 Mhz Pentium II with 64 MB of RAM. The JDK and applications were run under Windows NT version 4.0.
Reference: [5] <author> James R. Larus and Eric Schnarr. EEL: </author> <title> Machine-independent executable editing. </title> <booktitle> In Proceedings of the 1995 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 291-300, </pages> <address> La Jolla, CA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: BIT is one of the binary editing or executable editing tools that offer a library of routines for modifying executable files. Other tools in this group include the OM system [12], EEL <ref> [5] </ref>, and ATOM [11]. These tools operate on object codes for a variety of operating systems and architectures while BIT works on JVM class files.
Reference: [6] <author> Alvin R. Lebeck and David A. Wood. </author> <title> Cache profiling and the SPEC benchmarks: A case study. </title> <journal> Computer, </journal> <volume> 27(10) </volume> <pages> 15-26, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: From these connections, the structure of the call graph is inferred. Descendents based on gprof include HiProf [13], a commercial hierarchical profiling tool for the x86 architecture that inspired our IProfTool, mprof [14], a memory allocation profiler that is the basis for the MProfTool described here, and cprof <ref> [6] </ref>, a cache profiler. Each of these tools can be used to profile programs written in languages like C, but are not implemented for Java bytecode. Sun's JDK version 1.1.5 provides a profiling mechanism for Java programs by specifying the -prof option to the interpreter.
Reference: [7] <author> Han Bok Lee. </author> <title> BIT: Bytecode instrumenting tool. </title> <type> Master's thesis, </type> <institution> University of Colorado, Boulder, Department of Computer Science, University of Colorado, Boulder, CO, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: ProfBuilder provides a fast and easy way to create a variety of profiling tools with a small amount of code. ProfBuilder uses the Bytecode Instrumenting Tool (BIT) invented by Lee and Zorn <ref> [8, 7] </ref> to instrument compiled Java programs. The central data structure of ProfBuilder is the Calling Context Tree (CCT) [1], which is used to model the execution of an application and to store arbitrary measurements of dynamic behavior, such as branch outcomes or memory allocations. <p> Digital Equipment Corporation developed ATOM [11], or Analysis Tools using OM, for instrumenting binaries on DEC machines. Lee and Zorn developed BIT <ref> [7, 8] </ref>, a Java tool similar to ATOM. The Calling Context Tree tools use BIT to instrument the bytecode. Both ATOM and BIT allow the user to construct tools that monitor dynamic program execution by inserting calls to analysis routine directly into the compiled code.
Reference: [8] <author> Han Bok Lee and Benjamin G. Zorn. </author> <title> BIT: A tool for instrumenting Java bytcodes. </title> <booktitle> In Proceedings of the 1997 USENIX Symposium on Internet Technologies and Systems (USITS97), </booktitle> <pages> pages 73-82, </pages> <address> Monterey, CA, </address> <month> December </month> <year> 1997. </year> <institution> USENIX Association. </institution>
Reference-contexts: ProfBuilder provides a fast and easy way to create a variety of profiling tools with a small amount of code. ProfBuilder uses the Bytecode Instrumenting Tool (BIT) invented by Lee and Zorn <ref> [8, 7] </ref> to instrument compiled Java programs. The central data structure of ProfBuilder is the Calling Context Tree (CCT) [1], which is used to model the execution of an application and to store arbitrary measurements of dynamic behavior, such as branch outcomes or memory allocations. <p> Digital Equipment Corporation developed ATOM [11], or Analysis Tools using OM, for instrumenting binaries on DEC machines. Lee and Zorn developed BIT <ref> [7, 8] </ref>, a Java tool similar to ATOM. The Calling Context Tree tools use BIT to instrument the bytecode. Both ATOM and BIT allow the user to construct tools that monitor dynamic program execution by inserting calls to analysis routine directly into the compiled code.
Reference: [9] <author> Martin Odersky, Michael Philippsen, and Christian Kemper. EspressoGrinder. </author> <note> Available at http://wwwipd.ira.uka.de/~espresso. </note>
Reference-contexts: IProfTool was used to instrument several programs in order to measure the overhead. These programs are JLex, a lexical analyzer generator [2], aster, an Asteroids space game (also used in [10]), espresso, a Java compiler <ref> [9] </ref>, and java cup, a "Constructor for Useful Parsers" [4]. Table 1 summarizes each application, including execution time and compiled bytecode size. The applications were compiled and run using Sun's JDK version 1.1.5 on a machine with a 233 Mhz Pentium II with 64 MB of RAM.
Reference: [10] <author> Theodore H. Romer, Dennis Lee, Geoffrey M. Voelker, Alec Wolman, Wayne A. Wong, Jean-Loup Baer, Brian N. Bershad, and Henry M. Levy. </author> <title> The structure and performance of interpreters. </title> <booktitle> In Proceedings of the 7th International Conference on Architectural Support for Programming Language and Operating Systems (ASPLOS VII), </booktitle> <pages> pages 150-159, </pages> <address> Cambridge, MA, </address> <month> October </month> <year> 1996. </year> <month> 22 </month>
Reference-contexts: IProfTool was used to instrument several programs in order to measure the overhead. These programs are JLex, a lexical analyzer generator [2], aster, an Asteroids space game (also used in <ref> [10] </ref>), espresso, a Java compiler [9], and java cup, a "Constructor for Useful Parsers" [4]. Table 1 summarizes each application, including execution time and compiled bytecode size.
Reference: [11] <author> A. Srivastava and A. Eustace. </author> <title> ATOM: A system for building customized program analysis tools. </title> <booktitle> In Proceedings of the SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 196-205. </pages> <publisher> ACM, </publisher> <year> 1994. </year>
Reference-contexts: BIT is one of the binary editing or executable editing tools that offer a library of routines for modifying executable files. Other tools in this group include the OM system [12], EEL [5], and ATOM <ref> [11] </ref>. These tools operate on object codes for a variety of operating systems and architectures while BIT works on JVM class files. BIT hierarchically decomposes the JVM bytecodes in a class file into different entities including methods, basic blocks and bytecode instructions, and provides facilities for navigating through these entities. <p> The data structure was written as described in their paper, with a few modifications for the Java environment, specifically using arrays of integers instead of hardware counters to record metrics. Digital Equipment Corporation developed ATOM <ref> [11] </ref>, or Analysis Tools using OM, for instrumenting binaries on DEC machines. Lee and Zorn developed BIT [7, 8], a Java tool similar to ATOM. The Calling Context Tree tools use BIT to instrument the bytecode.
Reference: [12] <author> Amitabh Srivastava and David W. Wall. </author> <title> A practical system for intermodule code optimizations at link-time. </title> <journal> Journal of Programming Languages, </journal> <month> March </month> <year> 1993. </year>
Reference-contexts: BIT is one of the binary editing or executable editing tools that offer a library of routines for modifying executable files. Other tools in this group include the OM system <ref> [12] </ref>, EEL [5], and ATOM [11]. These tools operate on object codes for a variety of operating systems and architectures while BIT works on JVM class files.
Reference: [13] <author> Inc. TracePoint. </author> <title> Hierarchical profiling white paper. </title> <note> Available at http://www.tracepoint.com/frames.html, 1997. </note>
Reference-contexts: Profiling tools originated with gprof [3], a dynamic execution profiler. gprof describes path profiles by describing the caller/callee connection between two routines. From these connections, the structure of the call graph is inferred. Descendents based on gprof include HiProf <ref> [13] </ref>, a commercial hierarchical profiling tool for the x86 architecture that inspired our IProfTool, mprof [14], a memory allocation profiler that is the basis for the MProfTool described here, and cprof [6], a cache profiler.
Reference: [14] <author> Benjamin Zorn and Paul Hilfinger. </author> <title> A memory allocation profiler for C and Lisp programs. </title> <booktitle> In Proceedings of the Summer 1988 USENIX Conference, </booktitle> <pages> pages 223-237, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1988. </year> <month> 23 </month>
Reference-contexts: From these connections, the structure of the call graph is inferred. Descendents based on gprof include HiProf [13], a commercial hierarchical profiling tool for the x86 architecture that inspired our IProfTool, mprof <ref> [14] </ref>, a memory allocation profiler that is the basis for the MProfTool described here, and cprof [6], a cache profiler. Each of these tools can be used to profile programs written in languages like C, but are not implemented for Java bytecode.
References-found: 14

