URL: http://www.cs.cmu.edu/~dbj/ftp/jalg.ps.gz
Refering-URL: http://www.cs.cmu.edu/~dbj/ft.html
Root-URL: 
Phone: (713) 527-4834  
Title: Recovery in Distributed Systems Using Optimistic Message Logging and Checkpointing  
Author: David B. Johnson Willy Zwaenepoel 
Note: This work was supported in part by the National Science Foundation under grants CDA-8619893 and CCR-8716914, and by the Office of Naval Research under contract ONR N00014-88-K-0140.  
Address: P.O. Box 1892 Houston, Texas 77251-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: Message logging and checkpointing can provide fault tolerance in distributed systems in which all process communication is through messages. This paper presents a general model for reasoning about recovery in these systems. Using this model, we prove that the set of recoverable system states that have occurred during any single execution of the system forms a lattice, and that therefore, there is always a unique maximum recoverable system state, which never decreases. Based on this model, we present an algorithm for determining this maximum recoverable state, and prove its correctness. Our algorithm utilizes all logged messages and checkpoints, and thus always finds the maximum recoverable state possible. Previous recovery methods using optimistic message logging and checkpointing have not considered the existing checkpoints, and thus may not find this maximum state. Furthermore, by utilizing the checkpoints, some messages received by a process before it was checkpointed may not need to be logged. Using our algorithm also adds less communication overhead to the system than do previous methods. Our model and algorithm can be used with any message logging protocol, whether pessimistic or optimistic, but their full generality is only required with optimistic logging protocols. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Philip A. Bernstein, Vassos Hadzilacos, and Nathan Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction Message logging and checkpointing can be used to provide fault tolerance in a distributed system in which all process communication is through messages. Each message received by a process is saved in a message log on stable storage <ref> [11, 1] </ref>, and the state of each process is occasionally saved as a checkpoint to stable storage. No coordination is required between the checkpointing of different processes or between message logging and checkpointing. <p> Logging on stable storage is used to record state changes of modified objects during the execution of a transaction. Typically, the entire state of each object is recorded, although logical logging <ref> [1] </ref> records only the names of operations performed and their parameters, such that they can be reexecuted during recovery, much the same as reexecuting processes based on logged messages.
Reference: [2] <author> Anita Borg, Jim Baumbach, and Sam Glazer. </author> <title> A message system supporting fault tolerance. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 90-99. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1983. </year>
Reference-contexts: Typically, these systems use a pessimistic protocol for message logging. Each message is synchronously logged as it is received, either by blocking the receiver until the message is logged <ref> [2, 14] </ref>, or by blocking the receiver if it attempts to send a new message before all received messages are logged [8]. Recovery based on pessimistic message logging is straightforward. <p> The recovery state algorithm is executed and calls FIND REC with = 1 and k = 1 for state interval 1 of process 1. FIND REC sets RV to h1; 0; 0i and MAX to h1; 1; 0i. Since MAX <ref> [2] </ref> &gt; RV [2], a stable state interval ff 1 of process 2 is needed to make a consistent system state. However, no such state interval of process 2 is currently stable, and FIND REC therefore returns false. <p> The recovery state algorithm is executed and calls FIND REC with = 1 and k = 1 for state interval 1 of process 1. FIND REC sets RV to h1; 0; 0i and MAX to h1; 1; 0i. Since MAX <ref> [2] </ref> &gt; RV [2], a stable state interval ff 1 of process 2 is needed to make a consistent system state. However, no such state interval of process 2 is currently stable, and FIND REC therefore returns false. <p> The recovery state algorithm calls FIND REC, which sets RV to h0; 0; 1i and MAX to h0; 1; 1i. Since MAX <ref> [2] </ref> &gt; RV [2], a stable state interval ff 1 of process 2 is required. State interval 2 of process 2 is the minimum such stable state interval. Using its dependency vector, RV and MAX are updated, yielding the value h0; 2; 1i for both. <p> The recovery state algorithm calls FIND REC, which sets RV to h0; 0; 1i and MAX to h0; 1; 1i. Since MAX <ref> [2] </ref> &gt; RV [2], a stable state interval ff 1 of process 2 is required. State interval 2 of process 2 is the minimum such stable state interval. Using its dependency vector, RV and MAX are updated, yielding the value h0; 2; 1i for both. <p> In the protocols used by the TARGON/32 system [3], its predecessor Auros <ref> [2] </ref>, and the Publishing mechanism [14], the receiver of a message is blocked until the message is logged, and therefore, each state interval is stable before the process begins execution in that state interval. <p> This work unifies existing approaches to fault tolerance using message logging and checkpointing published in the literature, including those using pessimistic message logging <ref> [2, 14, 3, 8] </ref> and those using optimistic methods [21, 19]. By using this model to reason about these types of fault-tolerance methods, properties of them that are independent of the message logging protocol used can be deduced and proven.
Reference: [3] <author> Anita Borg, Wolfgang Blau, Wolfgang Graetsch, Ferdinand Herrmann, and Wolfgang Oberle. </author> <title> Fault tolerance under UNIX. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(1) </volume> <pages> 1-24, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: In the protocols used by the TARGON/32 system <ref> [3] </ref>, its predecessor Auros [2], and the Publishing mechanism [14], the receiver of a message is blocked until the message is logged, and therefore, each state interval is stable before the process begins execution in that state interval. <p> This work unifies existing approaches to fault tolerance using message logging and checkpointing published in the literature, including those using pessimistic message logging <ref> [2, 14, 3, 8] </ref> and those using optimistic methods [21, 19]. By using this model to reason about these types of fault-tolerance methods, properties of them that are independent of the message logging protocol used can be deduced and proven.
Reference: [4] <author> K. Mani Chandy and Leslie Lamport. </author> <title> Distributed snapshots: Determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: A system state is called consistent if it could have been seen at some instant by an outside observer during the preceding execution of the system from its initial state, regardless of the relative speeds of the component 7 processes <ref> [4] </ref>. After recovery from a failure, the system must be recovered to a consistent system state. This ensures that the total execution of the system is equivalent to some possible failure-free execution. <p> However, Virtual Time is designed to support the synchronization required by particular distributed applications such as discrete event simulation, rather than to provide general-purpose process fault tolerance. Checkpointing has also been used without message logging to provide fault tolerance in distributed systems <ref> [4, 9] </ref>. A global checkpoint, composed of an independent checkpoint for each process in the system, is recorded such that this set of checkpoints forms a consistent system state. The system can therefore be recovered by restoring each process to its state in any global checkpoint.
Reference: [5] <author> Roger Haskin, Yoni Malachi, Wayne Sawdon, and Gregory Chan. </author> <title> Recovery management in QuickSilver. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 82-108, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Message logging removes any need for synchronization during checkpointing, and allows checkpointing to be performed less frequently without sacrificing the ability to commit output to the outside world. Different forms of logging and checkpointing have also been used to support recovery in systems based on atomic transactions <ref> [12, 13, 20, 5] </ref>. Logging on stable storage is used to record state changes of modified objects during the execution of a transaction. <p> Smaller transactions may be used to avoid these problems, but this increases the amount of logging and the frequency of stable storage synchronization. The QuickSilver system <ref> [5] </ref> addresses these problems by allowing individual transactions to be checkpointed during their execution.
Reference: [6] <author> David Jefferson, Brian Beckman, Fred Wieland, Leo Blume, Mike DiLoreto, Phil Hontalas, Pierre Laroche, Kathy Sturdevant, Jack Tupman, Van Warren, John Wedel, Herb Younger, and Steve Bellenot. </author> <title> Distributed simulation and the Time Warp operating system. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 77-93. </pages> <publisher> ACM, </publisher> <month> November </month> <year> 1987. </year>
Reference-contexts: This approach is also used by the Time Warp system <ref> [6] </ref>, through its Virtual Time method [7], using message logging and checkpointing. However, Virtual Time is designed to support the synchronization required by particular distributed applications such as discrete event simulation, rather than to provide general-purpose process fault tolerance.
Reference: [7] <author> David R. Jefferson. </author> <title> Virtual time. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(3) </volume> <pages> 404-425, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: This approach is also used by the Time Warp system [6], through its Virtual Time method <ref> [7] </ref>, using message logging and checkpointing. However, Virtual Time is designed to support the synchronization required by particular distributed applications such as discrete event simulation, rather than to provide general-purpose process fault tolerance. Checkpointing has also been used without message logging to provide fault tolerance in distributed systems [4, 9].
Reference: [8] <author> David B. Johnson and Willy Zwaenepoel. </author> <title> Sender-based message logging. </title> <booktitle> In The Seventeenth Annual International Symposium on Fault-Tolerant Computing: Digest of Papers, </booktitle> <pages> pages 14-19. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: Each message is synchronously logged as it is received, either by blocking the receiver until the message is logged [2, 14], or by blocking the receiver if it attempts to send a new message before all received messages are logged <ref> [8] </ref>. Recovery based on pessimistic message logging is straightforward. <p> In the sender-based message logging protocol <ref> [8] </ref>, each process is instead blocked if attempts to send a new message when any messages it has received are not yet logged. <p> This work unifies existing approaches to fault tolerance using message logging and checkpointing published in the literature, including those using pessimistic message logging <ref> [2, 14, 3, 8] </ref> and those using optimistic methods [21, 19]. By using this model to reason about these types of fault-tolerance methods, properties of them that are independent of the message logging protocol used can be deduced and proven.
Reference: [9] <author> Richard Koo and Sam Toueg. </author> <title> Checkpointing and rollback-recovery for distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(1):23-31, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: However, Virtual Time is designed to support the synchronization required by particular distributed applications such as discrete event simulation, rather than to provide general-purpose process fault tolerance. Checkpointing has also been used without message logging to provide fault tolerance in distributed systems <ref> [4, 9] </ref>. A global checkpoint, composed of an independent checkpoint for each process in the system, is recorded such that this set of checkpoints forms a consistent system state. The system can therefore be recovered by restoring each process to its state in any global checkpoint. <p> Also, process execution may be blocked during checkpointing in order to guarantee the recording of a consistent system state <ref> [9] </ref>. Message logging removes any need for synchronization during checkpointing, and allows checkpointing to be performed less frequently without sacrificing the ability to commit output to the outside world.
Reference: [10] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: The system history relation differs from Lamport's happened before relation <ref> [10] </ref> in that it orders the system states that result from events rather than the events themselves, and that only state intervals (started by the receipt of a message) constitute events. To illustrate this partial order, Figure 1 shows a system of four communicating processes.
Reference: [11] <author> Butler W. Lampson and Howard E. Sturgis. </author> <title> Crash recovery in a distributed data storage system. </title> <type> Technical report, </type> <institution> Xerox Palo Alto Research Center, Palo Alto, California, </institution> <month> April </month> <year> 1979. </year>
Reference-contexts: 1 Introduction Message logging and checkpointing can be used to provide fault tolerance in a distributed system in which all process communication is through messages. Each message received by a process is saved in a message log on stable storage <ref> [11, 1] </ref>, and the state of each process is occasionally saved as a checkpoint to stable storage. No coordination is required between the checkpointing of different processes or between message logging and checkpointing.
Reference: [12] <author> C. Mohan, B. Lindsay, and R. Obermarck. </author> <title> Transaction management in the R fl distributed database management system. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 11(4) </volume> <pages> 378-396, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: Message logging removes any need for synchronization during checkpointing, and allows checkpointing to be performed less frequently without sacrificing the ability to commit output to the outside world. Different forms of logging and checkpointing have also been used to support recovery in systems based on atomic transactions <ref> [12, 13, 20, 5] </ref>. Logging on stable storage is used to record state changes of modified objects during the execution of a transaction. <p> However, this extra logging can be reduced through the use of special commit protocols, such as the Presumed Commit and Presumed Abort protocols <ref> [12] </ref>. To recover a transaction using this logging, however, the entire transaction must be reexecuted, which may lengthen recovery times, and may prevent the recovery of transactions whose running times exceed the mean time between failures in the system.
Reference: [13] <author> Brian M. Oki, Barbara H. Liskov, and Robert W. Scheifler. </author> <title> Reliable object storage to support atomic actions. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 147-159. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1985. </year> <month> 32 </month>
Reference-contexts: Message logging removes any need for synchronization during checkpointing, and allows checkpointing to be performed less frequently without sacrificing the ability to commit output to the outside world. Different forms of logging and checkpointing have also been used to support recovery in systems based on atomic transactions <ref> [12, 13, 20, 5] </ref>. Logging on stable storage is used to record state changes of modified objects during the execution of a transaction.
Reference: [14] <author> Michael L. Powell and David L. Presotto. </author> <title> Publishing: A reliable broadcast communication mechanism. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 100-109. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1983. </year>
Reference-contexts: Typically, these systems use a pessimistic protocol for message logging. Each message is synchronously logged as it is received, either by blocking the receiver until the message is logged <ref> [2, 14] </ref>, or by blocking the receiver if it attempts to send a new message before all received messages are logged [8]. Recovery based on pessimistic message logging is straightforward. <p> In the protocols used by the TARGON/32 system [3], its predecessor Auros [2], and the Publishing mechanism <ref> [14] </ref>, the receiver of a message is blocked until the message is logged, and therefore, each state interval is stable before the process begins execution in that state interval. <p> This work unifies existing approaches to fault tolerance using message logging and checkpointing published in the literature, including those using pessimistic message logging <ref> [2, 14, 3, 8] </ref> and those using optimistic methods [21, 19]. By using this model to reason about these types of fault-tolerance methods, properties of them that are independent of the message logging protocol used can be deduced and proven.
Reference: [15] <author> Brian Randell. </author> <title> System structure for software fault tolerance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1(2):220-232, </volume> <month> June </month> <year> 1975. </year>
Reference-contexts: Rolling back this process may cause other processes to become orphans, which must also be rolled back during recovery. The domino effect <ref> [15, 16] </ref> is an uncontrolled propagation of such process rollbacks, and must be avoided to guarantee progress in the system in spite of failures. Recovery based on optimistic message logging must construct the "most recent" combination of process states that can be recovered such that no process is an orphan. <p> Thus system 12 state R itself must remain recoverable. Since the set R forms a lattice, any new current recovery state established after state R must be greater than R. As discussed in Section 1, the domino effect <ref> [15, 16] </ref> is an uncontrolled propagation of rollbacks necessary to recover the system state following a failure. In this model, an occurrence of the domino effect would take the form of a propagation of dependencies that prevent the current recovery state from advancing.
Reference: [16] <author> David L. Russell. </author> <title> State restoration in systems of communicating processes. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(2):183-194, </volume> <month> March </month> <year> 1980. </year>
Reference-contexts: Rolling back this process may cause other processes to become orphans, which must also be rolled back during recovery. The domino effect <ref> [15, 16] </ref> is an uncontrolled propagation of such process rollbacks, and must be avoided to guarantee progress in the system in spite of failures. Recovery based on optimistic message logging must construct the "most recent" combination of process states that can be recovered such that no process is an orphan. <p> Thus system 12 state R itself must remain recoverable. Since the set R forms a lattice, any new current recovery state established after state R must be greater than R. As discussed in Section 1, the domino effect <ref> [15, 16] </ref> is an uncontrolled propagation of rollbacks necessary to recover the system state following a failure. In this model, an occurrence of the domino effect would take the form of a propagation of dependencies that prevent the current recovery state from advancing.
Reference: [17] <author> Richard D. Schlichting and Fred B. Schneider. </author> <title> Fail-stop processors: An approach to design ing fault-tolerant distributed computing systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 1(3) </volume> <pages> 222-238, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: No coordination is required between the checkpointing of different processes or between message logging and checkpointing. The execution of each process is assumed to be deterministic between received messages, and all processes are assumed to execute on fail-stop processors <ref> [17] </ref>. Typically, these systems use a pessimistic protocol for message logging. <p> The model does not assume the use of any particular message logging protocol, and applies equally well to systems using either pessimistic or optimistic message logging methods. All processes are assumed to execute on fail-stop processors <ref> [17] </ref> connected by a communication network, but reliable delivery of messages on the network is not required. 2.1 Process States The execution of each process is divided into separate intervals by the messages that the process receives.
Reference: [18] <author> Fred B. Schneider. </author> <title> The state machine approach: A tutorial. </title> <type> Technical Report TR 86-800, </type> <institution> Cornell University, </institution> <address> Ithaca, New York, </address> <month> June </month> <year> 1987. </year> <booktitle> To appear in Proceedings of a Workshop on Fault-Tolerant Distributed Computing, Lecture Notes in Computer Science series, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York. </address>
Reference-contexts: Optimistic message logging removes the need for synchronization 28 between execution and message logging, and thus optimistic methods should outperform pessimistic methods when failures are infrequent. 5.3 Other Methods The general approach used by these message logging and checkpointing methods has been called the state machine approach <ref> [18] </ref>, which assumes that program execution for each input is deterministic and is based only on the program state at the time of the input and on the input itself.
Reference: [19] <author> A. Prasad Sistla and Jennifer L. Welch. </author> <title> Efficient distributed recovery using message logging. </title> <booktitle> In Proceedings of the Eighth Annual ACM Symposium on Principles of Distributed Computing. ACM, </booktitle> <month> August </month> <year> 1989. </year> <note> To appear. </note>
Reference-contexts: Using these messages, the process then reexecutes to the state it had after originally receiving them. Messages sent by the process during this reexecution that are duplicates of those sent before the failure are ignored. Other systems, though, use an optimistic message logging protocol <ref> [21, 19] </ref>. The receiver of a message is not blocked, and messages are logged asynchronously after receipt, for example by grouping several messages and writing them to stable storage in a single operation. <p> Based on this model, we present an algorithm for determining this unique maximum recoverable system state, and prove its correctness. Our algorithm always finds this maximum recoverable system state, by utilizing all logged messages and checkpoints. Previous fault-tolerance methods using optimistic message logging and checkpointing <ref> [21, 19] </ref> have not considered the existing checkpoints, and thus may not find this maximum state. Furthermore, by utilizing checkpoints, some messages received by a process before its checkpoint was recorded may not need to be logged. <p> Our work has been partially motivated by Strom and 26 Yemini's Optimistic Recovery [21], and recently Sistla and Welch have proposed a new optimistic message logging method <ref> [19] </ref>, based in part on some aspects of both Strom and Yemini's system and our work. Our system is unique among these in that it always finds the maximum recoverable system state. <p> With our model, processes must synchronize during recovery to be notified of the reuse of the indices of any rolled back state intervals. 27 Sistla and Welch have proposed two alternative recovery algorithms based on optimistic message logging <ref> [19] </ref>. One algorithm tags each message sent with a transitive dependency vector as in Strom and Yemini's system, whereas the other algorithm tags each message only with the sender's current state interval index as in our system. <p> The recovery state algorithm and recovery procedure presented in this paper improve on earlier work with fault-tolerance using optimistic message logging by Strom and Yemini [21] and by Sistla and Welch <ref> [19] </ref>. Although their methods allow less centralized control of recovery, and may allow output to the outside world to be committed earlier, they add significantly more communication to the system. <p> This work unifies existing approaches to fault tolerance using message logging and checkpointing published in the literature, including those using pessimistic message logging [2, 14, 3, 8] and those using optimistic methods <ref> [21, 19] </ref>. By using this model to reason about these types of fault-tolerance methods, properties of them that are independent of the message logging protocol used can be deduced and proven.
Reference: [20] <author> Alfred Z. Spector. </author> <title> Distributed transaction processing and the Camelot system. </title> <editor> In Yakup Paker, Jean-Pierre Banatre, and Muslim Bozyigit, editors, </editor> <booktitle> Distributed Operating Systems: Theory and Practice, volume 28 of NATO Advanced Science Institute Series F: Computer and Systems Sciences, </booktitle> <pages> pages 331-353. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Also available as Technical Report CMU-CS-87-100, </note> <institution> Department of Computer Science, Carnegie-Mellon University, Pittsburgh, Pennsylvania, </institution> <month> January </month> <year> 1987. </year>
Reference-contexts: Message logging removes any need for synchronization during checkpointing, and allows checkpointing to be performed less frequently without sacrificing the ability to commit output to the outside world. Different forms of logging and checkpointing have also been used to support recovery in systems based on atomic transactions <ref> [12, 13, 20, 5] </ref>. Logging on stable storage is used to record state changes of modified objects during the execution of a transaction.
Reference: [21] <author> Robert E. Strom and Shaula Yemini. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> August </month> <year> 1985. </year> <month> 33 </month>
Reference-contexts: Using these messages, the process then reexecutes to the state it had after originally receiving them. Messages sent by the process during this reexecution that are duplicates of those sent before the failure are ignored. Other systems, though, use an optimistic message logging protocol <ref> [21, 19] </ref>. The receiver of a message is not blocked, and messages are logged asynchronously after receipt, for example by grouping several messages and writing them to stable storage in a single operation. <p> Based on this model, we present an algorithm for determining this unique maximum recoverable system state, and prove its correctness. Our algorithm always finds this maximum recoverable system state, by utilizing all logged messages and checkpoints. Previous fault-tolerance methods using optimistic message logging and checkpointing <ref> [21, 19] </ref> have not considered the existing checkpoints, and thus may not find this maximum state. Furthermore, by utilizing checkpoints, some messages received by a process before its checkpoint was recorded may not need to be logged. <p> Our work has been partially motivated by Strom and 26 Yemini's Optimistic Recovery <ref> [21] </ref>, and recently Sistla and Welch have proposed a new optimistic message logging method [19], based in part on some aspects of both Strom and Yemini's system and our work. Our system is unique among these in that it always finds the maximum recoverable system state. <p> If needed, reliable delivery can also be incorporated into our model simply by assuming an acknowledgement message immediately following each message receipt. In Strom and Yemini's Optimistic Recovery <ref> [21] </ref>, each message sent is tagged with a transitive dependency vector, which has size proportional to the number of processes. <p> Optimistic message logging methods thus constitute a beneficial performance tradeoff in environments where failures are infrequent and failure-free performance is of primary concern. The recovery state algorithm and recovery procedure presented in this paper improve on earlier work with fault-tolerance using optimistic message logging by Strom and Yemini <ref> [21] </ref> and by Sistla and Welch [19]. Although their methods allow less centralized control of recovery, and may allow output to the outside world to be committed earlier, they add significantly more communication to the system. <p> This work unifies existing approaches to fault tolerance using message logging and checkpointing published in the literature, including those using pessimistic message logging [2, 14, 3, 8] and those using optimistic methods <ref> [21, 19] </ref>. By using this model to reason about these types of fault-tolerance methods, properties of them that are independent of the message logging protocol used can be deduced and proven.
References-found: 21

