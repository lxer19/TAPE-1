URL: http://www.cs.utexas.edu/users/ckwong/sgc/sigcomm98preprint.ps
Refering-URL: http://www.cs.utexas.edu/users/ckwong/sgc/index.html
Root-URL: 
Email: fckwong,gouda,lamg@cs.utexas.edu  
Title: Secure Group Communications Using Key Graphs  
Author: Chung Kei Wong Mohamed Gouda Simon S. Lam 
Address: Austin, TX 78712-1188  
Affiliation: Department of Computer Sciences University of Texas at Austin  
Abstract: Many emerging applications (e.g., teleconference, real-time information services, pay per view, distributed interactive simulation, and collaborative work) are based upon a group communications model, i.e., they require packet delivery from one or more authorized senders to a very large number of authorized receivers. As a result, securing group communications (i.e., providing confidentiality, integrity, and authenticity of messages delivered between group members) will become a critical networking issue. In this paper, we present a novel solution to the scalability problem of group/multicast key management. We formalize the notion of a secure group as a triple (U; K; R) where U denotes a set of users, K a set of keys held by the users, and R a user-key relation. We then introduce key graphs to specify secure groups. For a special class of key graphs, we present three strategies for securely distributing rekey messages after a join/leave, and specify protocols for joining and leaving a secure group. The rekeying strategies and join/leave protocols are implemented in a prototype group key server we have built. We present measurement results from experiments and discuss performance comparisons. We show that our group key management service, using any of the three rekeying strategies, is scalable to large groups with frequent joins and leaves. In particular, the average measured processing time per join/leave increases linearly with the logarithm of group size. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Tony Ballardie. </author> <title> Scalable Multicast Key Distribution, </title> <booktitle> RFC 1949, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: That is, large groups whose members join and leave frequently pose a scalability problem. The topic of secure group communications has been investigated <ref> [1, 2, 8, 15] </ref>. Also the problem of how to distribute a secret to a group of users has been addressed in the cryptography literature [3, 5, 7, 18].
Reference: [2] <author> Tony Ballardie and Jon Crowcroft. Multicast-Specific Security Threats and Counter-Measures. </author> <booktitle> In Proceedings Symposium on Network and Distributed System Security, </booktitle> <year> 1995. </year>
Reference-contexts: That is, large groups whose members join and leave frequently pose a scalability problem. The topic of secure group communications has been investigated <ref> [1, 2, 8, 15] </ref>. Also the problem of how to distribute a secret to a group of users has been addressed in the cryptography literature [3, 5, 7, 18].
Reference: [3] <author> Shimshon Berkovits. </author> <title> How to Broadcast a Secret. </title> <editor> In D.W. Davies, editor, </editor> <booktitle> Advances in cryptology, EURO-CRYPT '91, volume 547 of Lecture Notes in Computer Science, </booktitle> <pages> pages 535-541. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: That is, large groups whose members join and leave frequently pose a scalability problem. The topic of secure group communications has been investigated [1, 2, 8, 15]. Also the problem of how to distribute a secret to a group of users has been addressed in the cryptography literature <ref> [3, 5, 7, 18] </ref>. However, with the exception of [15], no one has addressed the need for frequent key changes and the associated scalability problem for a very large group.
Reference: [4] <author> R. Bird, I. Gopal, A. Herzberg, P. Janson, S. Kutten, R. Molva, and M. Yung. </author> <title> The KryptoKnight family of light-weight protocols for authentication and key distribution. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 3(1), </volume> <month> February </month> <year> 1995. </year>
Reference-contexts: Initially, the client and server mutually authenticate each other using an authentication protocol or service; subsequently, a symmetric key is created and shared by them to be used for pairwise confidential communications <ref> [4, 17, 19, 22] </ref>. This procedure can be extended to a group as follows: Let there be a trusted group server which is given membership information to exercise group access control. When a client wants to join the group, the client and group server mutually authenticate using an authentication protocol.
Reference: [5] <author> Guang-Huei Chiou and Wen-Tsuen Chen. </author> <title> Secure Broadcasting Using the Secure Lock. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(8) </volume> <pages> 929-934, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: That is, large groups whose members join and leave frequently pose a scalability problem. The topic of secure group communications has been investigated [1, 2, 8, 15]. Also the problem of how to distribute a secret to a group of users has been addressed in the cryptography literature <ref> [3, 5, 7, 18] </ref>. However, with the exception of [15], no one has addressed the need for frequent key changes and the associated scalability problem for a very large group.
Reference: [6] <author> Stephen E. Deering. </author> <title> Multicast Routing in Internet-works and Extended LANs. </title> <booktitle> In Proceedings of ACM SIGCOMM '88, </booktitle> <month> August </month> <year> 1988. </year>
Reference-contexts: MDA 904-94-C-6106. Experiments were performed on equipment procured with National Science Foundation grant no. CDA-9624082. To appear in Proceedings of ACM SIGCOMM '98, Septem-ber 2-4, 1998, Vancouver, Canada. efficient, best-effort delivery service to large groups <ref> [6] </ref>. We envision that deployment of network applications requiring group communications will accelerate in coming years. While the technical issues of securing unicast communications for client-server computing are fairly well understood, the technical issues of securing group communications are not.
Reference: [7] <author> Amos Fiat and Moni Naor. </author> <title> Broadcast Encryption. </title> <editor> In Douglas R. Stinson, editor, </editor> <booktitle> Advances in cryptology, CRYPTO '93, volume 773 of Lecture Notes in Computer Science, </booktitle> <pages> pages 480-491. </pages> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: That is, large groups whose members join and leave frequently pose a scalability problem. The topic of secure group communications has been investigated [1, 2, 8, 15]. Also the problem of how to distribute a secret to a group of users has been addressed in the cryptography literature <ref> [3, 5, 7, 18] </ref>. However, with the exception of [15], no one has addressed the need for frequent key changes and the associated scalability problem for a very large group.
Reference: [8] <author> Li Gong. Enclaves: </author> <title> Enabling Secure Collaboration over the Internet. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <pages> pages 567-575, </pages> <month> April </month> <year> 1997. </year>
Reference-contexts: That is, large groups whose members join and leave frequently pose a scalability problem. The topic of secure group communications has been investigated <ref> [1, 2, 8, 15] </ref>. Also the problem of how to distribute a secret to a group of users has been addressed in the cryptography literature [3, 5, 7, 18].
Reference: [9] <author> H. Harney and C. Muckenhirn. </author> <title> Group Key Management Protocol (GKMP) Architecture, </title> <booktitle> RFC 2094, </booktitle> <month> July </month> <year> 1997. </year>
Reference-contexts: Conceptually, since every point-to-multipoint communication can be represented as a set of point-to-point communications, the current technology base for securing unicast communications can be extended in a straightforward manner to secure group communications <ref> [9, 10] </ref>. However, such an extension is not scalable to large groups. For a more concrete illustration of this point, we outline a typical procedure for securing unicast communications between a client and a server. <p> In the following subsections, we first present protocols for joining and leaving a secure group specified by a star key graph. These protocols correspond to conventional rekey-ing procedures informally described in the Introduction <ref> [9, 10] </ref>. We then consider secure groups specified by tree key graphs. With a hierarchy of group and subgroup keys, rekey-ing after a join/leave can be carried out in a variety of ways.
Reference: [10] <author> H. Harney and C. Muckenhirn. </author> <title> Group Key Management Protocol (GKMP) Specification, </title> <booktitle> RFC 2093, </booktitle> <month> July </month> <year> 1997. </year>
Reference-contexts: Conceptually, since every point-to-multipoint communication can be represented as a set of point-to-point communications, the current technology base for securing unicast communications can be extended in a straightforward manner to secure group communications <ref> [9, 10] </ref>. However, such an extension is not scalable to large groups. For a more concrete illustration of this point, we outline a typical procedure for securing unicast communications between a client and a server. <p> In the following subsections, we first present protocols for joining and leaving a secure group specified by a star key graph. These protocols correspond to conventional rekey-ing procedures informally described in the Introduction <ref> [9, 10] </ref>. We then consider secure groups specified by tree key graphs. With a hierarchy of group and subgroup keys, rekey-ing after a join/leave can be carried out in a variety of ways.
Reference: [11] <author> J. B. Lacy, D. P. Mitchell, and W. M. </author> <title> Schell. </title> <booktitle> CryptoLib: cryptography in software. In Proceedings of USENIX: 4th UNIX Security Symposium, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: A client-simulator runs on the other SGI simulating a large number of clients. Actual rekey messages, as well as join, join-ack, leave, leave-ack messages, are sent between individual clients and the server using UDP over the 100 Mbps Ethernet. Cryptographic routines from the publicly available CrytoLib library are used <ref> [11] </ref>. For each experiment with an initial group size n, the client-simulator first sent n join requests, and the server built a key tree. Then the client-simulator sent 1000 join/ leave requests.
Reference: [12] <author> Simon S. Lam and Chung Kei Wong. </author> <title> Keystone: A Group Key Management Service. Work in progress, </title> <institution> Department of Computer Sciences, The University of Texas at Austin. </institution>
Reference-contexts: For these applications, the key trees of different group keys are merged to form a key graph <ref> [12] </ref>. Acknowledgement We thank Craig Partridge for his constructive comments in shepherding the final revision of this paper.
Reference: [13] <author> Brian Neil Levine and J.J. Garcia-Luna-Aceves. </author> <title> Improving Internet Multicast with Routing Labels. </title> <booktitle> In Proceedings of International Conference on Network Protocols, </booktitle> <year> 1997. </year>
Reference-contexts: Alternatively, the method in <ref> [13] </ref> may be used in lieu of allocating a large number of multicast addresses for subgroups. See Section 7 for more discussion. 5 oriented rekeying) while the encryption cost is 2 (h 1). <p> If the rekey messages are sent via unicast (because the network provides no support for subgroup multicast), the network load generated would be much greater than that of group-oriented rekeying. It is possible to support subgroup multicast by the method in <ref> [13] </ref> or by allocating a large number of multi-cast addresses, one for each subgroup that share a key in the key tree being used.
Reference: [14] <author> Ralph C. Merkle. </author> <title> A Certified Digital Signature. </title> <booktitle> In Advances in Cryptology - CRYPTO '89, </booktitle> <year> 1989. </year>
Reference-contexts: This would require m digital signature operations for m messages. We next describe a technique, implemented in our prototype key server, for signing a set of messages using just a single digital signature operation. The technique is based upon a scheme proposed by Merkle <ref> [14] </ref>. Suppose there are four messages with message digests d 1 ; d 2 ; d 3 , and d 4 . Construct message D 12 containing d 1 and d 2 , and compute message digest d 12 = h (D 12 ).
Reference: [15] <author> Suvo Mittra. Iolus: </author> <title> A Framework for Scalable Secure Multicasting. </title> <booktitle> In Proceedings of ACM SIGCOMM '97, </booktitle> <year> 1997. </year>
Reference-contexts: That is, large groups whose members join and leave frequently pose a scalability problem. The topic of secure group communications has been investigated <ref> [1, 2, 8, 15] </ref>. Also the problem of how to distribute a secret to a group of users has been addressed in the cryptography literature [3, 5, 7, 18]. <p> The topic of secure group communications has been investigated [1, 2, 8, 15]. Also the problem of how to distribute a secret to a group of users has been addressed in the cryptography literature [3, 5, 7, 18]. However, with the exception of <ref> [15] </ref>, no one has addressed the need for frequent key changes and the associated scalability problem for a very large group. The approach proposed in Iolus [15] to improve scalability is to decompose a large group of clients into many subgroups and employ a hierarchy of group security agents. 1.1 Our <p> However, with the exception of <ref> [15] </ref>, no one has addressed the need for frequent key changes and the associated scalability problem for a very large group. The approach proposed in Iolus [15] to improve scalability is to decompose a large group of clients into many subgroups and employ a hierarchy of group security agents. 1.1 Our approach We present in this paper a different hierarchical approach to improve scalability. <p> Instead of a hierarchy of group security agents, we employ a hierarchy of keys. A detailed comparison of our approach and the Iolus approach <ref> [15] </ref> is given in Section 6. <p> client is relatively small, and is very close to the analytical result, d=(d 1) shown in Table 3 in Section 3. 10 6 Related Work The scalability problem of group key management for a large group with frequent joins and leaves was previously addressed by Mittra with his Iolus system <ref> [15] </ref>. Both Iolus and our approach solve the scalability problem by making use of a hierarchy. The similarity, however, ends here. The system architectures are very different in the two approaches. We next compare them by considering a tree hierarchy with a single root (i.e., a single secure group). <p> Secure rekeying after a leave requires more work than after a join because, unlike a join, the previous group key cannot used and n rekey messages are required (this is referred to in <ref> [15] </ref> as a 1 does not equal n type problem). This is precisely the problem solved by using a hierarchy in both approaches. The main difference between Iolus and our approach is in how the 1 affects n type problem [15] is addressed. <p> n rekey messages are required (this is referred to in <ref> [15] </ref> as a 1 does not equal n type problem). This is precisely the problem solved by using a hierarchy in both approaches. The main difference between Iolus and our approach is in how the 1 affects n type problem [15] is addressed. In our approach, every time a client joins/leaves the secure group a rekeying operation is required which affects the entire group. Note that this is not a scalability concern in our approach because the server cost is O (log (n)) and the client cost is O (1). <p> Each agent decrypts using one subgroup key to retrieve the message key and reencrypts it with another subgroup key for forwarding <ref> [15] </ref>. That is, most of the work in handling the 1 affects n type problem is performed in Iolus when a client sends a message confidentially to the entire group (rather than when a client joins/leaves the group).
Reference: [16] <author> B. Clifford Neuman. </author> <title> Proxy-Based Authorization and Accounting for Distributed Systems. </title> <booktitle> In Proceedings of 13th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 283-291, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Server 7 The authorization function may be o*oaded to an authorization server. In this case, the authorization server provides an authorized user with a ticket to join the secure group <ref> [16, 23] </ref>. The user submits the ticket together with its join request to server s. s also generates a new group key k U 0 for the root node, encrypts it with the individual key k u of user u, and sends the encrypted new group key to u.
Reference: [17] <author> Jennifer G. Steiner, Clifford Neuman, and Jeffrey I. Schiller. </author> <title> Kerberos: An Authentication Service for Open Network Systems. </title> <booktitle> In USENIX Winter Conference, </booktitle> <pages> pages 191-202, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Initially, the client and server mutually authenticate each other using an authentication protocol or service; subsequently, a symmetric key is created and shared by them to be used for pairwise confidential communications <ref> [4, 17, 19, 22] </ref>. This procedure can be extended to a group as follows: Let there be a trusted group server which is given membership information to exercise group access control. When a client wants to join the group, the client and group server mutually authenticate using an authentication protocol. <p> If user u is not authorized to join the group, server s sends a join-denied reply to u. If the join request is granted, we assume that the session key distributed as a result of the authentication exchange <ref> [17, 22] </ref> will be used as the individual key k u of u.
Reference: [18] <author> D.R. Stinson. </author> <title> On Some Methods for Unconditionally Secure Key Distribution and Broadcast Encryption. Designs, </title> <journal> Codes and Cryptography, </journal> (12):215-243, 1997. 
Reference-contexts: That is, large groups whose members join and leave frequently pose a scalability problem. The topic of secure group communications has been investigated [1, 2, 8, 15]. Also the problem of how to distribute a secret to a group of users has been addressed in the cryptography literature <ref> [3, 5, 7, 18] </ref>. However, with the exception of [15], no one has addressed the need for frequent key changes and the associated scalability problem for a very large group.
Reference: [19] <author> J.J. Tardo and K. Alagappan. SPX: </author> <title> Global authentication using public key certificates. </title> <booktitle> In Proceedings of 12th IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 232-244, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Initially, the client and server mutually authenticate each other using an authentication protocol or service; subsequently, a symmetric key is created and shared by them to be used for pairwise confidential communications <ref> [4, 17, 19, 22] </ref>. This procedure can be extended to a group as follows: Let there be a trusted group server which is given membership information to exercise group access control. When a client wants to join the group, the client and group server mutually authenticate using an authentication protocol.
Reference: [20] <author> Debby M. Wallner, Eric J. Harder, and Ryan C. Agee. </author> <title> Key Management for Multicast: Issues and Architectures. </title> <type> Working draft, </type> <institution> National Security Agency, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: User u has key k if and only if (u; k) is in R. 4 A similar observation was independently made in <ref> [20] </ref> at about the same time as when this paper was first published as a technical report [21]. 2 Each secure group has a trusted group server responsible for generating and securely distributing keys in K to users in the group. 5 Specifically, the group server knows the user set U
Reference: [21] <author> Chung Kei Wong, Mohamed Gouda, and Simon S. Lam. </author> <title> Secure Group Communications Using Key Graphs. </title> <type> Technical Report TR 97-23, </type> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: User u has key k if and only if (u; k) is in R. 4 A similar observation was independently made in [20] at about the same time as when this paper was first published as a technical report <ref> [21] </ref>. 2 Each secure group has a trusted group server responsible for generating and securely distributing keys in K to users in the group. 5 Specifically, the group server knows the user set U and the key set K, and maintains the user-key relation R. <p> This suggests the following key-covering problem: Given a secure group (U; K; R), and a subset S of U , find a minimum size subset K 0 of K such that userset (K 0 ) = S. Unfortunately, the key-covering problem in general is NP-hard <ref> [21] </ref>. 2.2 Special classes of key graphs We next consider key graphs with special structures for which the key covering problem can be easily solved. <p> In our prototype implementation, rekey messages have additional fields, such as, subgroup labels for new keys, server digital signature, message integrity check, timestamp, etc. (See <ref> [21] </ref> for rekey message format.) 3.2 Leaving a star key graph (1) u ! s : f leave-request g k u (2) s ! u : f leave-granted g k u (3) s : randomly generate a new group key k U 0 (4) for each user v in U except <p> These costs are from the protocols described above for star and tree key graphs, and from <ref> [21] </ref> for complete key graphs. (Key-oriented or group-oriented rekeying is assumed for tree key graphs.) For a key tree, recall that d and h denote the degree and height of the tree respectively. <p> In this case, for a non-requesting user u, the average cost of u for a join or a leave is less than d d1 which is independent of the size of the tree (derivation in <ref> [21] </ref>).
Reference: [22] <author> Thomas Y.C. Woo, Raghuram Bindignavle, Shaowen Su, and Simon S. Lam. SNP: </author> <title> An interface for secure network programming. </title> <booktitle> In Proceedings of USENIX'94 Summer Technical Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Initially, the client and server mutually authenticate each other using an authentication protocol or service; subsequently, a symmetric key is created and shared by them to be used for pairwise confidential communications <ref> [4, 17, 19, 22] </ref>. This procedure can be extended to a group as follows: Let there be a trusted group server which is given membership information to exercise group access control. When a client wants to join the group, the client and group server mutually authenticate using an authentication protocol. <p> If user u is not authorized to join the group, server s sends a join-denied reply to u. If the join request is granted, we assume that the session key distributed as a result of the authentication exchange <ref> [17, 22] </ref> will be used as the individual key k u of u.
Reference: [23] <author> Thomas Y.C. Woo and Simon S. Lam. </author> <title> Designing a Distributed Authorization Service. </title> <booktitle> In Proceedings IEEE INFOCOM '98, </booktitle> <address> San Francisco, </address> <month> March </month> <year> 1998. </year> <month> 12 </month>
Reference-contexts: Server 7 The authorization function may be o*oaded to an authorization server. In this case, the authorization server provides an authorized user with a ticket to join the secure group <ref> [16, 23] </ref>. The user submits the ticket together with its join request to server s. s also generates a new group key k U 0 for the root node, encrypts it with the individual key k u of user u, and sends the encrypted new group key to u.
References-found: 23

