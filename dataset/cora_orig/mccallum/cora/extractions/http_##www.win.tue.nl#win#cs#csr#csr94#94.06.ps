URL: http://www.win.tue.nl/win/cs/csr/csr94/94.06.ps
Refering-URL: http://www.win.tue.nl/win/cs/csr/csr94.html
Root-URL: http://www.win.tue.nl
Phone: 2  3  
Title: Time and the Order of Abstract Events in Distributed Computations  
Author: Twan Basten Thomas Kunz James Black Michael Coffin and David Taylor 
Keyword: Key words: Distributed systems Event abstraction Causality- Precedence relation Partial order Vector time  
Address: The Netherlands  Germany  Waterloo, Waterloo, Ontario, Canada  
Affiliation: 1 Department of Mathematics and Computing Science, Eindhoven University of Technology, Eindhoven,  Department of Computer Science, Technical University of Darmstadt, Darmstadt,  Department of Computer Science, University of  
Abstract: An important problem in event-based models of distributed computations is the amount of behavioral information. Even for simple applications, the number of events is large and the causal structure is complex. Event abstraction can be used to reduce the apparent complexity of a distributed computation. This paper discusses one important aspect of event abstraction: causality among abstract events. Logical vector time and a derived notion called reversed vector time can be used to assign two meaningful timestamps to abstract events. These timestamps can be used to efficiently determine causal relationships between arbitrary abstract events. The class of convex abstract events is identified as a subclass of abstract events that is general enough to be widely applicable and restricted enough to simplify timestamping. For this class, ordinary vector time is sufficient to determine causal relationships. At the cost of some extra computational effort, the timestamps derived for convex abstract events can also be used for arbitrary abstract events, overcoming the need for reversed timestamping. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A.A. Basten. </author> <title> Event Abstraction in Modeling Distributed Computations. </title> <editor> In K. Ecker, editor, </editor> <booktitle> Proceedings of the 11th. Workshop on Parallel Processing, </booktitle> <address> Lessach, Austria, </address> <month> September </month> <year> 1993. </year> <note> To appear as Informatik-Bericht, </note> <institution> Technische Universitat Clausthal, Germany, </institution> <note> 20 pp. in ms. </note>
Reference-contexts: Causality among abstract events is defined, and timestamp schemes are derived to efficiently determine causal relationships between abstract events. Each timestamp scheme is formally proven correct. Other important issues in event abstraction, such as specifying abstract behavior and the automatic recognition of abstract events to construct abstract views <ref> [1, 2] </ref>, are beyond the scope of this paper. Given a hierarchy of abstract descriptions of program behavior, an application can be evaluated at an arbitrary level. Using the timestamp schemes presented in this paper, program behavior can be visualized or even simulated at any level of abstraction.
Reference: 2. <author> A.A. Basten. </author> <title> Hierarchical Event-Based Behavioral Abstraction in Interactive Distributed Debugging: A Theoretical Approach. </title> <type> Master's thesis, </type> <institution> Eindhoven University of Technology, Department of Mathematics and Computing Science, </institution> <address> The Netherlands, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: Causality among abstract events is defined, and timestamp schemes are derived to efficiently determine causal relationships between abstract events. Each timestamp scheme is formally proven correct. Other important issues in event abstraction, such as specifying abstract behavior and the automatic recognition of abstract events to construct abstract views <ref> [1, 2] </ref>, are beyond the scope of this paper. Given a hierarchy of abstract descriptions of program behavior, an application can be evaluated at an arbitrary level. Using the timestamp schemes presented in this paper, program behavior can be visualized or even simulated at any level of abstraction. <p> Summers [18] models synchronous communication as a pair of mutually related events. A drawback of this model is that the precedence relation is no longer a partial order, which raises theoretical problems. In <ref> [2] </ref>, synchronous communication is modeled as a single event occurring in two processes simultaneously. This model is more abstract than the model presented above. Unfortunately, it has some theoretical problems that will be discussed shortly. The relation can be used to express concurrency in a natural way. <p> Note that p i e = pe " E i and that p i e is a cut, but not necessarily a consistent cut. The two definitions of causal past and causal past in a process are essential to the results presented in this paper. In <ref> [2] </ref>, some of these results are given for a slightly different model of distributed computations that models synchronous communication as a single event occurring in two processes simultaneously. As mentioned, this model raises some theoretical problems. <p> If e has a predecessor in process j, then the causal past in process i, p i e, is not a cut. The set p i e is not left-closed under l . As a consequence, some definitions and derivations given in <ref> [2] </ref> are not correct. However, it is believed that the definitions and derivations can be adapted in such a way that the results remain valid. Another possibility is to adapt the model of synchronous communication so that sets of events representing processes are disjoint.
Reference: 3. <author> E. Best and B. Randell. </author> <title> A Formal Model of Atomicity in Asynchronous Systems. </title> <journal> Acta Informatica, </journal> <volume> 16 </volume> <pages> 93-124, </pages> <year> 1981. </year>
Reference-contexts: Convexity is useful as well. First, convex abstract events are easier to recognize automatically than arbitrary abstract events, because it is not necessary to filter out interfering events. Second, they are more general and therefore more widely applicable than, for example, complete precedence abstractions [18] and contractions <ref> [3, 8, 18] </ref>. Third, since there are no interfering events, convex abstract events are considerably easier to display than arbitrary abstract events. Finally, this section shows that determining causality among convex abstract events requires less timestamping effort than determining causality among arbitrary abstract events.
Reference: 4. <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight Causal and Atomic Group Multicast. </title> <type> Technical Report 91-1192, </type> <institution> Computer Science Department, Cornell University, </institution> <address> Ithaca, New York, USA, </address> <month> February </month> <year> 1991. </year>
Reference-contexts: To determine causal relationships between events, logical-timestamp schemes have been pro-posed [10, 12, 15, 16, 17]. Logical time has been used for many different purposes: implementing causal broadcasts <ref> [4] </ref>, measuring concurrency [6], detecting global predicates [9], implementing distributed breakpoints [13], computing consistent global snapshots [16], and visualizing program behavior [19]. However, experience shows that even for simple distributed applications, the amount of behavioral information is very large, and the causality structure is very complex.
Reference: 5. <author> J.P. Black, M.H. Coffin, D.J. Taylor, T. Kunz, and A.A. Basten. </author> <title> Linking Specification, Abstraction, and Debugging. </title> <type> CCNG Technical Report E-232, </type> <institution> Computer Communications and Networks Group, University of Waterloo, </institution> <address> Ontario, Canada, </address> <month> November </month> <year> 1993. </year> <note> Submitted 1993.11.04 to IBM Systems Journal, 26pp in ms. </note>
Reference-contexts: In addition, the programmer often has difficulties managing too much behavioral information. Therefore, it is desirable to reduce the amount of information that must be considered at once. A powerful way to reduce the apparent complexity of a computation is abstraction <ref> [5] </ref>. This paper focuses on one type of abstraction, namely event abstraction. Primitive events are grouped together into high-level abstract events, hiding their internal structure and creating an abstract view of the computation. <p> The precise rules for maintaining the local clocks in such a way that the timestamps satisfy the function T are as follows. The rules adapt the definitions of Fidge [10, 11, 12] and Mattern [16, 17] for synchronous communication. Small variations on the rules can be found in <ref> [5, 8, 18] </ref>. 1. Initialization: Initially, all the local clocks are set to the zero vector. 2. Ticking: At the occurrence of an event in process i 2 P, component i of the local clock, C i :i, is incremented by one. 3.
Reference: 6. <author> B. Charron-Bost. </author> <title> Combinatorics and Geometry of Consistent Cuts: Application to Concurrency Theory. </title> <editor> In J.-C. Bermond and M. Raynal, editors, </editor> <booktitle> Distributed Algorithms, volume 392 of Lecture Notes in Computer Science, </booktitle> <pages> pages 45-56. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1989. </year> <booktitle> Proceedings of the 3rd International Workshop WDAG '89, </booktitle> <address> Nice, France, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: To determine causal relationships between events, logical-timestamp schemes have been pro-posed [10, 12, 15, 16, 17]. Logical time has been used for many different purposes: implementing causal broadcasts [4], measuring concurrency <ref> [6] </ref>, detecting global predicates [9], implementing distributed breakpoints [13], computing consistent global snapshots [16], and visualizing program behavior [19]. However, experience shows that even for simple distributed applications, the amount of behavioral information is very large, and the causality structure is very complex. <p> Essentially, a distributed computation is a pair (E; ), where E is the set of primitive events and is an ordering relation that models causal precedence. The detailed model given in the remainder of this subsection is based mainly on previous definitions of Mattern [16, 17], Charron-Bost <ref> [6, 7] </ref>, and Fidge [11, 12]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [15]. The algebraic structure underlying the model is Winskel's elementary event structure [20]. <p> We prefer this model of synchronous communication over other models of synchronous communication in the literature. Charron-Bost et al. <ref> [6] </ref>, Cheung [8], and Fidge [11, 12] model synchronous communication as a pair of unrelated events. This has the disadvantage that a synchronous communication cannot be distinguished from a pair of concurrent events. Summers [18] models synchronous communication as a pair of mutually related events. <p> The infimum and supremum of sets of cuts are defined by set intersection and set union respectively. In distributed computing, the subset of consistent cuts is of particular interest. Consistent cuts characterize the set of global states that might actually occur during a distributed computation. Definition 2.3. (Consistent cut, <ref> [6, 16, 17, 20] </ref>) A set C E is called a consistent cut of E if and only if for all events e 0 2 C and e 1 2 E, e 1 e 0 ) e 1 2 C. A consistent cut is left-closed under . <p> Event e 0 precedes event e 1 since all the predecessors of e 0 are also predecessors of e 1 . pe 0 T:e 1 pe 1 Definition 2.5. (Causal past, <ref> [6, 17, 20] </ref>) The function p: : E ! 2 E defines the causal past of an event as follows. For any e 2 E, pe = fe 0 2 E j e 0 eg. Note that pe is a consistent cut. <p> For any e 2 E, pe = fe 0 2 E j e 0 eg. Note that pe is a consistent cut. The causal past of an event in some process i is the set of all its predecessors in i. Definition 2.6. (Causal past in a process, <ref> [6] </ref>) For any i 2 P, the function p i : : E ! 2 E i defines the causal past in process i of an event as follows. For any e 2 E, p i e = fe 0 2 E i j e 0 eg. <p> Theorem 2.10. (Precedence test for primitive events [16, 17]) For any events e 0 ; e 1 2 E, e 0 e 1 , T:e 0 T:e 1 . Proof. <ref> [6] </ref> Assume that e 0 e 1 . Since is transitive, it follows that, for any process i 2 P, p i e 0 p i e 1 . Definition 2.9 (Timestamp function) yields T:e 0 T:e 1 .
Reference: 7. <author> B. Charron-Bost, F. Mattern, and G. Tel. </author> <title> Synchronous and Asynchronous Communication in Distributed Computations. </title> <type> Technical Report LITP 91.55, </type> <institution> Institut Blaise Pascal, Universite Paris 7, Paris, France, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: Essentially, a distributed computation is a pair (E; ), where E is the set of primitive events and is an ordering relation that models causal precedence. The detailed model given in the remainder of this subsection is based mainly on previous definitions of Mattern [16, 17], Charron-Bost <ref> [6, 7] </ref>, and Fidge [11, 12]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [15]. The algebraic structure underlying the model is Winskel's elementary event structure [20].
Reference: 8. <author> W.-H. Cheung. </author> <title> Process and Event Abstraction for Debugging Distributed Programs. </title> <type> Ph.D. Thesis, CCNG Technical Report T-189, </type> <institution> University of Waterloo, Department of Computer Science, Waterloo, </institution> <address> Ontario, Canada, </address> <year> 1989. </year>
Reference-contexts: Doing so, performance can be increased and only information that is of interest to the user is taken into consideration. To date, there has been no sound theoretical treatment in the literature of causality and logical time for arbitrary abstract events. Previous work at Waterloo <ref> [8, 14, 18] </ref> discusses abstract events with restrictive structural properties only. Event sets with these structural properties create abstract views of an execution that conform to the partial order among primitive events. Times-tamping algorithms for these abstract events are given. <p> We prefer this model of synchronous communication over other models of synchronous communication in the literature. Charron-Bost et al. [6], Cheung <ref> [8] </ref>, and Fidge [11, 12] model synchronous communication as a pair of unrelated events. This has the disadvantage that a synchronous communication cannot be distinguished from a pair of concurrent events. Summers [18] models synchronous communication as a pair of mutually related events. <p> The precise rules for maintaining the local clocks in such a way that the timestamps satisfy the function T are as follows. The rules adapt the definitions of Fidge [10, 11, 12] and Mattern [16, 17] for synchronous communication. Small variations on the rules can be found in <ref> [5, 8, 18] </ref>. 1. Initialization: Initially, all the local clocks are set to the zero vector. 2. Ticking: At the occurrence of an event in process i 2 P, component i of the local clock, C i :i, is incremented by one. 3. <p> The first approach is to restrict the structure of abstract events so that the precedence relation is guaranteed to be a partial order, and then to try to timestamp these restricted abstract events in a meaningful way. This is the approach taken by Cheung <ref> [8] </ref>, Kunz [14], and Summers [18]. Unfortunately, imposing structural requirements that guarantee transitivity and anti-symmetry either makes the resulting abstractions difficult to manage or severely limits their expressiveness. <p> Convexity is useful as well. First, convex abstract events are easier to recognize automatically than arbitrary abstract events, because it is not necessary to filter out interfering events. Second, they are more general and therefore more widely applicable than, for example, complete precedence abstractions [18] and contractions <ref> [3, 8, 18] </ref>. Third, since there are no interfering events, convex abstract events are considerably easier to display than arbitrary abstract events. Finally, this section shows that determining causality among convex abstract events requires less timestamping effort than determining causality among arbitrary abstract events.
Reference: 9. <author> R. Cooper and K. Marzullo. </author> <title> Consistent Detection of Global Predicates. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 163-173, </pages> <address> Santa Cruz, California, US, USA, </address> <month> May </month> <year> 1991. </year> <note> The proceedings appeared also as ACM SIGPLAN Notices, 26(12), </note> <month> December </month> <year> 1991. </year>
Reference-contexts: To determine causal relationships between events, logical-timestamp schemes have been pro-posed [10, 12, 15, 16, 17]. Logical time has been used for many different purposes: implementing causal broadcasts [4], measuring concurrency [6], detecting global predicates <ref> [9] </ref>, implementing distributed breakpoints [13], computing consistent global snapshots [16], and visualizing program behavior [19]. However, experience shows that even for simple distributed applications, the amount of behavioral information is very large, and the causality structure is very complex.
Reference: 10. <author> C.J. Fidge. </author> <title> Timestamps in Message Passing Systems that Preserve the Partial Ordering. </title> <booktitle> In Proceedings of the 11th Australian Computer Science Conference, </booktitle> <pages> pages 55-66, </pages> <address> Brisbane, Australia, </address> <month> February </month> <year> 1988. </year>
Reference-contexts: Lamport [15] has shown that causality among primitive events can be accurately modeled by a partial order. ? This work was supported in part by the Natural Sciences and Engineering Research Council of Canada. To determine causal relationships between events, logical-timestamp schemes have been pro-posed <ref> [10, 12, 15, 16, 17] </ref>. Logical time has been used for many different purposes: implementing causal broadcasts [4], measuring concurrency [6], detecting global predicates [9], implementing distributed breakpoints [13], computing consistent global snapshots [16], and visualizing program behavior [19]. <p> Since the precedence relation is a partial order, it is not possible to use 4 physical time or any other totally ordered set as a characterization. For this reason, Mattern [16, 17] and Fidge <ref> [10, 12] </ref> independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport [15]. In this subsection, we summarize some definitions and results given by Mattern in [17]. <p> The precise rules for maintaining the local clocks in such a way that the timestamps satisfy the function T are as follows. The rules adapt the definitions of Fidge <ref> [10, 11, 12] </ref> and Mattern [16, 17] for synchronous communication. Small variations on the rules can be found in [5, 8, 18]. 1. Initialization: Initially, all the local clocks are set to the zero vector. 2.
Reference: 11. <author> C.J. Fidge. </author> <title> Dynamic Analysis of Event Orderings in Message-Passing Systems. </title> <type> PhD thesis, </type> <institution> Australian National University, Department of Computer Science, Canberra, Australia, </institution> <year> 1989. </year>
Reference-contexts: The detailed model given in the remainder of this subsection is based mainly on previous definitions of Mattern [16, 17], Charron-Bost [6, 7], and Fidge <ref> [11, 12] </ref>. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [15]. The algebraic structure underlying the model is Winskel's elementary event structure [20]. <p> The precedence relation extends the "happens before" relation as defined by Lamport [15] to synchronous communication in a natural way. The condition C2, originally given by Fidge <ref> [11, 12] </ref>, means that a synchronous communication can be interpreted as if it occurred instantaneously. <p> We prefer this model of synchronous communication over other models of synchronous communication in the literature. Charron-Bost et al. [6], Cheung [8], and Fidge <ref> [11, 12] </ref> model synchronous communication as a pair of unrelated events. This has the disadvantage that a synchronous communication cannot be distinguished from a pair of concurrent events. Summers [18] models synchronous communication as a pair of mutually related events. <p> The precise rules for maintaining the local clocks in such a way that the timestamps satisfy the function T are as follows. The rules adapt the definitions of Fidge <ref> [10, 11, 12] </ref> and Mattern [16, 17] for synchronous communication. Small variations on the rules can be found in [5, 8, 18]. 1. Initialization: Initially, all the local clocks are set to the zero vector. 2.
Reference: 12. <author> C.J. Fidge. </author> <title> Logical Time in Distributed Computing Systems. </title> <journal> IEEE Computer, </journal> <volume> 24(8) </volume> <pages> 28-33, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Lamport [15] has shown that causality among primitive events can be accurately modeled by a partial order. ? This work was supported in part by the Natural Sciences and Engineering Research Council of Canada. To determine causal relationships between events, logical-timestamp schemes have been pro-posed <ref> [10, 12, 15, 16, 17] </ref>. Logical time has been used for many different purposes: implementing causal broadcasts [4], measuring concurrency [6], detecting global predicates [9], implementing distributed breakpoints [13], computing consistent global snapshots [16], and visualizing program behavior [19]. <p> The detailed model given in the remainder of this subsection is based mainly on previous definitions of Mattern [16, 17], Charron-Bost [6, 7], and Fidge <ref> [11, 12] </ref>. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [15]. The algebraic structure underlying the model is Winskel's elementary event structure [20]. <p> The precedence relation extends the "happens before" relation as defined by Lamport [15] to synchronous communication in a natural way. The condition C2, originally given by Fidge <ref> [11, 12] </ref>, means that a synchronous communication can be interpreted as if it occurred instantaneously. <p> We prefer this model of synchronous communication over other models of synchronous communication in the literature. Charron-Bost et al. [6], Cheung [8], and Fidge <ref> [11, 12] </ref> model synchronous communication as a pair of unrelated events. This has the disadvantage that a synchronous communication cannot be distinguished from a pair of concurrent events. Summers [18] models synchronous communication as a pair of mutually related events. <p> Since the precedence relation is a partial order, it is not possible to use 4 physical time or any other totally ordered set as a characterization. For this reason, Mattern [16, 17] and Fidge <ref> [10, 12] </ref> independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport [15]. In this subsection, we summarize some definitions and results given by Mattern in [17]. <p> However, vector representation of timestamps is not essential. If the number of processes is not known, the timestamp of an event can be defined as a set of pairs, where each pair consists of a process identifier and the corresponding timestamp component <ref> [12] </ref>. The following theorem shows that the timestamps as defined above can be used to determine the causal relation between primitive events. <p> The precise rules for maintaining the local clocks in such a way that the timestamps satisfy the function T are as follows. The rules adapt the definitions of Fidge <ref> [10, 11, 12] </ref> and Mattern [16, 17] for synchronous communication. Small variations on the rules can be found in [5, 8, 18]. 1. Initialization: Initially, all the local clocks are set to the zero vector. 2.
Reference: 13. <author> D. Haban and W. Weigel. </author> <title> Global Events and Global Breakpoints in Distributed Systems. </title> <booktitle> In Proceedings of the 21st Annual Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 166-175, </pages> <address> Kailua-Kona, Hawaii, USA, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: To determine causal relationships between events, logical-timestamp schemes have been pro-posed [10, 12, 15, 16, 17]. Logical time has been used for many different purposes: implementing causal broadcasts [4], measuring concurrency [6], detecting global predicates [9], implementing distributed breakpoints <ref> [13] </ref>, computing consistent global snapshots [16], and visualizing program behavior [19]. However, experience shows that even for simple distributed applications, the amount of behavioral information is very large, and the causality structure is very complex.
Reference: 14. <author> T. Kunz. </author> <title> Event Abstraction: Some Definitions and Theorems. </title> <type> Technical Report TI-1/93, </type> <institution> Technische Hochschule Darmstadt, Fachbereich Informatik, Darmstadt, Germany, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Doing so, performance can be increased and only information that is of interest to the user is taken into consideration. To date, there has been no sound theoretical treatment in the literature of causality and logical time for arbitrary abstract events. Previous work at Waterloo <ref> [8, 14, 18] </ref> discusses abstract events with restrictive structural properties only. Event sets with these structural properties create abstract views of an execution that conform to the partial order among primitive events. Times-tamping algorithms for these abstract events are given. <p> Times-tamping algorithms for these abstract events are given. While such structures are attractive because the set of abstract events is again partially ordered, it appears that they are not general enough to be useful; many apparently intuitive abstract events do not satisfy the constraints (see also <ref> [14] </ref>). Thus, this paper takes another approach, starting with no structural requirements on abstract events, and recognizing that it is not feasible in practice to maintain a partial order on them. The paper is organized as follows. <p> The first approach is to restrict the structure of abstract events so that the precedence relation is guaranteed to be a partial order, and then to try to timestamp these restricted abstract events in a meaningful way. This is the approach taken by Cheung [8], Kunz <ref> [14] </ref>, and Summers [18]. Unfortunately, imposing structural requirements that guarantee transitivity and anti-symmetry either makes the resulting abstractions difficult to manage or severely limits their expressiveness.
Reference: 15. <author> L. Lamport. </author> <title> Time, Clocks and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: 1 Introduction A distributed application consists of a number of autonomous sequential processes, cooperating to achieve a common goal. Cooperation includes both communication and synchronization, and is achieved by the exchange of messages. Following Lamport <ref> [15] </ref>, a distributed computation is modeled as an ordered set of events. An event represents some activity performed by some process and is considered to take place at an instant in time. Typically, the lowest-level observable events, or primitive events, are computations local to processes and interprocess-communication events. <p> However, sending a message might be unrelated to a write action on a file local to another process. Neither event precedes the other and they are said to be concurrent. Lamport <ref> [15] </ref> has shown that causality among primitive events can be accurately modeled by a partial order. ? This work was supported in part by the Natural Sciences and Engineering Research Council of Canada. To determine causal relationships between events, logical-timestamp schemes have been pro-posed [10, 12, 15, 16, 17]. <p> Lamport [15] has shown that causality among primitive events can be accurately modeled by a partial order. ? This work was supported in part by the Natural Sciences and Engineering Research Council of Canada. To determine causal relationships between events, logical-timestamp schemes have been pro-posed <ref> [10, 12, 15, 16, 17] </ref>. Logical time has been used for many different purposes: implementing causal broadcasts [4], measuring concurrency [6], detecting global predicates [9], implementing distributed breakpoints [13], computing consistent global snapshots [16], and visualizing program behavior [19]. <p> The detailed model given in the remainder of this subsection is based mainly on previous definitions of Mattern [16, 17], Charron-Bost [6, 7], and Fidge [11, 12]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport <ref> [15] </ref>. The algebraic structure underlying the model is Winskel's elementary event structure [20]. The set of primitive events E is the union of N mutually disjoint sets of events, E 0 ; : : : ; E N 1 , where N is the number of processes. <p> The precedence relation extends the "happens before" relation as defined by Lamport <ref> [15] </ref> to synchronous communication in a natural way. The condition C2, originally given by Fidge [11, 12], means that a synchronous communication can be interpreted as if it occurred instantaneously. <p> For this reason, Mattern [16, 17] and Fidge [10, 12] independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport <ref> [15] </ref>. In this subsection, we summarize some definitions and results given by Mattern in [17]. They form the basis for the remaining sections of this paper that discuss timestamping abstract events or sets of primitive events.
Reference: 16. <author> F. Mattern. </author> <title> Virtual Time and Global States of Distributed Systems. </title> <editor> In M. Cosnard et al., editor, </editor> <booktitle> Parallel and Distributed Algorithms, </booktitle> <pages> pages 215-226. </pages> <publisher> Elsevier Science Publishers B.V., Amsterdam, North-Holland, </publisher> <address> The Netherlands, </address> <year> 1989. </year> <booktitle> Proceedings of the International Workshop held in Gers, </booktitle> <address> France, </address> <month> October, </month> <year> 1988. </year>
Reference-contexts: Lamport [15] has shown that causality among primitive events can be accurately modeled by a partial order. ? This work was supported in part by the Natural Sciences and Engineering Research Council of Canada. To determine causal relationships between events, logical-timestamp schemes have been pro-posed <ref> [10, 12, 15, 16, 17] </ref>. Logical time has been used for many different purposes: implementing causal broadcasts [4], measuring concurrency [6], detecting global predicates [9], implementing distributed breakpoints [13], computing consistent global snapshots [16], and visualizing program behavior [19]. <p> To determine causal relationships between events, logical-timestamp schemes have been pro-posed [10, 12, 15, 16, 17]. Logical time has been used for many different purposes: implementing causal broadcasts [4], measuring concurrency [6], detecting global predicates [9], implementing distributed breakpoints [13], computing consistent global snapshots <ref> [16] </ref>, and visualizing program behavior [19]. However, experience shows that even for simple distributed applications, the amount of behavioral information is very large, and the causality structure is very complex. <p> Essentially, a distributed computation is a pair (E; ), where E is the set of primitive events and is an ordering relation that models causal precedence. The detailed model given in the remainder of this subsection is based mainly on previous definitions of Mattern <ref> [16, 17] </ref>, Charron-Bost [6, 7], and Fidge [11, 12]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [15]. The algebraic structure underlying the model is Winskel's elementary event structure [20]. <p> A cut is the event-based equivalent of a global state. Formalizing the notion of cuts is useful to better understand the causality structure of a distributed computation. The proofs of many results to follow depend on the introduction of cuts. The following definition and theorem are due to Mattern <ref> [16, 17] </ref>. <p> The infimum and supremum of sets of cuts are defined by set intersection and set union respectively. In distributed computing, the subset of consistent cuts is of particular interest. Consistent cuts characterize the set of global states that might actually occur during a distributed computation. Definition 2.3. (Consistent cut, <ref> [6, 16, 17, 20] </ref>) A set C E is called a consistent cut of E if and only if for all events e 0 2 C and e 1 2 E, e 1 e 0 ) e 1 2 C. A consistent cut is left-closed under . <p> A consistent cut is left-closed under . The set of all consistent cuts of a distributed computation is denoted by C . Theorem 2.4. (Structure of consistent cuts, <ref> [16, 17, 20] </ref>) The set of consistent cuts, with the ordering defined by , is a complete lattice. 2.2 Vector time As explained before, for many applications in distributed computing, it is useful to have a characterization of causality. <p> Since the precedence relation is a partial order, it is not possible to use 4 physical time or any other totally ordered set as a characterization. For this reason, Mattern <ref> [16, 17] </ref> and Fidge [10, 12] independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport [15]. In this subsection, we summarize some definitions and results given by Mattern in [17]. <p> For two vectors t 0 ; t 1 2 IN N , we define t 0 t 1 to mean t 0 :i t 1 :i for all i, 0 i &lt; N . Theorem 2.10. (Precedence test for primitive events <ref> [16, 17] </ref>) For any events e 0 ; e 1 2 E, e 0 e 1 , T:e 0 T:e 1 . Proof. [6] Assume that e 0 e 1 . <p> It provides an efficient way to determine precedence among primitive events; at most N integer comparisons are necessary. Precedence can be determined even more efficiently if it is known in which process an event occurs. 6 Theorem 2.11. (Precedence test for primitive events <ref> [16] </ref>) For any i 2 P and events e 0 2 E i and e 1 2 E, e 0 e 1 , T:e 0 :i T:e 1 :i. Proof. Assume that e 0 e 1 . It follows that p i e 0 p i e 1 . <p> The precise rules for maintaining the local clocks in such a way that the timestamps satisfy the function T are as follows. The rules adapt the definitions of Fidge [10, 11, 12] and Mattern <ref> [16, 17] </ref> for synchronous communication. Small variations on the rules can be found in [5, 8, 18]. 1. Initialization: Initially, all the local clocks are set to the zero vector. 2.
Reference: 17. <author> F. Mattern. </author> <title> On the Relativistic Structure of Logical Time in Distributed Systems. </title> <journal> Bigre, </journal> <volume> 78 </volume> <pages> 3-20, </pages> <month> March </month> <year> 1992. </year> <booktitle> Proceedings of the workshop: Datation et Controle des Executions Reparties, December 4th, 1991, Rennes, </booktitle> <address> France. </address>
Reference-contexts: Lamport [15] has shown that causality among primitive events can be accurately modeled by a partial order. ? This work was supported in part by the Natural Sciences and Engineering Research Council of Canada. To determine causal relationships between events, logical-timestamp schemes have been pro-posed <ref> [10, 12, 15, 16, 17] </ref>. Logical time has been used for many different purposes: implementing causal broadcasts [4], measuring concurrency [6], detecting global predicates [9], implementing distributed breakpoints [13], computing consistent global snapshots [16], and visualizing program behavior [19]. <p> Essentially, a distributed computation is a pair (E; ), where E is the set of primitive events and is an ordering relation that models causal precedence. The detailed model given in the remainder of this subsection is based mainly on previous definitions of Mattern <ref> [16, 17] </ref>, Charron-Bost [6, 7], and Fidge [11, 12]. Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [15]. The algebraic structure underlying the model is Winskel's elementary event structure [20]. <p> A cut is the event-based equivalent of a global state. Formalizing the notion of cuts is useful to better understand the causality structure of a distributed computation. The proofs of many results to follow depend on the introduction of cuts. The following definition and theorem are due to Mattern <ref> [16, 17] </ref>. <p> The infimum and supremum of sets of cuts are defined by set intersection and set union respectively. In distributed computing, the subset of consistent cuts is of particular interest. Consistent cuts characterize the set of global states that might actually occur during a distributed computation. Definition 2.3. (Consistent cut, <ref> [6, 16, 17, 20] </ref>) A set C E is called a consistent cut of E if and only if for all events e 0 2 C and e 1 2 E, e 1 e 0 ) e 1 2 C. A consistent cut is left-closed under . <p> A consistent cut is left-closed under . The set of all consistent cuts of a distributed computation is denoted by C . Theorem 2.4. (Structure of consistent cuts, <ref> [16, 17, 20] </ref>) The set of consistent cuts, with the ordering defined by , is a complete lattice. 2.2 Vector time As explained before, for many applications in distributed computing, it is useful to have a characterization of causality. <p> Since the precedence relation is a partial order, it is not possible to use 4 physical time or any other totally ordered set as a characterization. For this reason, Mattern <ref> [16, 17] </ref> and Fidge [10, 12] independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport [15]. In this subsection, we summarize some definitions and results given by Mattern in [17]. <p> For this reason, Mattern [16, 17] and Fidge [10, 12] independently introduced partially ordered vector time. Vector time extends the idea of logical clocks introduced by Lamport [15]. In this subsection, we summarize some definitions and results given by Mattern in <ref> [17] </ref>. They form the basis for the remaining sections of this paper that discuss timestamping abstract events or sets of primitive events. An event causally precedes another event if and only if all its predecessors are also predecessors of the other event. <p> Event e 0 precedes event e 1 since all the predecessors of e 0 are also predecessors of e 1 . pe 0 T:e 1 pe 1 Definition 2.5. (Causal past, <ref> [6, 17, 20] </ref>) The function p: : E ! 2 E defines the causal past of an event as follows. For any e 2 E, pe = fe 0 2 E j e 0 eg. Note that pe is a consistent cut. <p> Another possibility is to adapt the model of synchronous communication so that sets of events representing processes are disjoint. This is the approach pursued in this paper. Definition 2.5 yields the following useful result. Corollary 2.7. <ref> [17, 20] </ref> For any event e 2 E and any consistent cut C 2 C , e 2 C , pe C. Proof. <p> For two vectors t 0 ; t 1 2 IN N , we define t 0 t 1 to mean t 0 :i t 1 :i for all i, 0 i &lt; N . Theorem 2.10. (Precedence test for primitive events <ref> [16, 17] </ref>) For any events e 0 ; e 1 2 E, e 0 e 1 , T:e 0 T:e 1 . Proof. [6] Assume that e 0 e 1 . <p> The precise rules for maintaining the local clocks in such a way that the timestamps satisfy the function T are as follows. The rules adapt the definitions of Fidge [10, 11, 12] and Mattern <ref> [16, 17] </ref> for synchronous communication. Small variations on the rules can be found in [5, 8, 18]. 1. Initialization: Initially, all the local clocks are set to the zero vector. 2. <p> As mentioned, the global time at any point during a computation consists of the vector of all the local counter values. This is formalized in the following definition. Definition 2.12. (Global time of a cut, <ref> [17] </ref>) The function T : C l ! IN N defines the global time of a cut. For any cut C, component i, where 0 i &lt; N , of the time vector is defined as T :C:i = jC " E i j. <p> For any i 2 P and any event e 2 E, T :p i e:j = T :pe:j, for j = i 0, otherwise Proof. It follows from Definitions 2.5 (Causal past), 2.6 (Causal past in a process), and 2.12 (Global time of a cut). 2 Corollary 2.14. <ref> [17] </ref> For any event e 2 E, T :pe = T:e. Proof. It follows from Definitions 2.5 (Causal past), 2.9 (Timestamp function), and 2.12 (Global time of a cut). 2 Corollary 2.14 states that the timestamp of an event reflects its causal past. <p> Proof. It follows from Definitions 2.5 (Causal past), 2.9 (Timestamp function), and 2.12 (Global time of a cut). 2 Corollary 2.14 states that the timestamp of an event reflects its causal past. This is exactly what is shown in Figure 1. Corollary 2.15. <ref> [17] </ref> For any cuts C 0 ; C 1 2 C l , C 0 C 1 , T :C 0 T :C 1 . Proof. <p> It follows from Definitions 2.1 (Cut) and 2.12 (Global time of a cut). 2 Corollary 2.15 implies that the function T is an isomorphism between the two complete lattices (C l ; ) and (T l ; ), as well as the following. Theorem 2.16. (Structure of time vectors, <ref> [17] </ref>) The set of time vectors, T l , with the ordering defined by , forms a complete lattice. It is isomorphic to the lattice (C l ; ). Proof.
Reference: 18. <author> J.A. Summers. </author> <title> Precedence-Preserving Abstraction for Distributed Debugging. </title> <type> Master's thesis, </type> <institution> University of Waterloo, Dept. of Computer Science, Waterloo, </institution> <address> Ontario, Canada, </address> <year> 1992. </year>
Reference-contexts: Doing so, performance can be increased and only information that is of interest to the user is taken into consideration. To date, there has been no sound theoretical treatment in the literature of causality and logical time for arbitrary abstract events. Previous work at Waterloo <ref> [8, 14, 18] </ref> discusses abstract events with restrictive structural properties only. Event sets with these structural properties create abstract views of an execution that conform to the partial order among primitive events. Times-tamping algorithms for these abstract events are given. <p> Charron-Bost et al. [6], Cheung [8], and Fidge [11, 12] model synchronous communication as a pair of unrelated events. This has the disadvantage that a synchronous communication cannot be distinguished from a pair of concurrent events. Summers <ref> [18] </ref> models synchronous communication as a pair of mutually related events. A drawback of this model is that the precedence relation is no longer a partial order, which raises theoretical problems. In [2], synchronous communication is modeled as a single event occurring in two processes simultaneously. <p> The precise rules for maintaining the local clocks in such a way that the timestamps satisfy the function T are as follows. The rules adapt the definitions of Fidge [10, 11, 12] and Mattern [16, 17] for synchronous communication. Small variations on the rules can be found in <ref> [5, 8, 18] </ref>. 1. Initialization: Initially, all the local clocks are set to the zero vector. 2. Ticking: At the occurrence of an event in process i 2 P, component i of the local clock, C i :i, is incremented by one. 3. <p> The first approach is to restrict the structure of abstract events so that the precedence relation is guaranteed to be a partial order, and then to try to timestamp these restricted abstract events in a meaningful way. This is the approach taken by Cheung [8], Kunz [14], and Summers <ref> [18] </ref>. Unfortunately, imposing structural requirements that guarantee transitivity and anti-symmetry either makes the resulting abstractions difficult to manage or severely limits their expressiveness. The second approach, pursued in this paper, is to allow more flexible abstract-event structures at the cost of increasing the difficulty of obtaining and comparing timestamp vectors. <p> Convexity is useful as well. First, convex abstract events are easier to recognize automatically than arbitrary abstract events, because it is not necessary to filter out interfering events. Second, they are more general and therefore more widely applicable than, for example, complete precedence abstractions <ref> [18] </ref> and contractions [3, 8, 18]. Third, since there are no interfering events, convex abstract events are considerably easier to display than arbitrary abstract events. Finally, this section shows that determining causality among convex abstract events requires less timestamping effort than determining causality among arbitrary abstract events. <p> Convexity is useful as well. First, convex abstract events are easier to recognize automatically than arbitrary abstract events, because it is not necessary to filter out interfering events. Second, they are more general and therefore more widely applicable than, for example, complete precedence abstractions [18] and contractions <ref> [3, 8, 18] </ref>. Third, since there are no interfering events, convex abstract events are considerably easier to display than arbitrary abstract events. Finally, this section shows that determining causality among convex abstract events requires less timestamping effort than determining causality among arbitrary abstract events.
Reference: 19. <author> D.J. Taylor. </author> <title> A Prototype Debugger for Hermes. </title> <booktitle> In Proceedings of the 1992 CAS Conference, </booktitle> <volume> Volume I, </volume> <pages> pages 29-42, </pages> <address> Toronto, Ont., Canada, </address> <month> November </month> <year> 1992. </year> <institution> IBM Canada Ltd. Laboratory, Centre for Advanced Studies. </institution> <month> 28 </month>
Reference-contexts: To determine causal relationships between events, logical-timestamp schemes have been pro-posed [10, 12, 15, 16, 17]. Logical time has been used for many different purposes: implementing causal broadcasts [4], measuring concurrency [6], detecting global predicates [9], implementing distributed breakpoints [13], computing consistent global snapshots [16], and visualizing program behavior <ref> [19] </ref>. However, experience shows that even for simple distributed applications, the amount of behavioral information is very large, and the causality structure is very complex. Applications that must cope with this huge amount of information become slow and often need many resources (disk storage, memory, processor time).
Reference: 20. <author> G. Winskel. </author> <title> An Introduction to Event Structures. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozen--berg, editors, </editor> <title> Linear Time, Branching Time and Partial Order in Logics and Models for Concurrency, </title> <booktitle> volume 354 of Lecture Notes in Computer Science, </booktitle> <pages> pages 364-397. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1989. </year> <title> Proceedings of a workshop held in Noordwijkerhout, </title> <booktitle> the Netherlands, May/June 1988. </booktitle> <pages> 29 </pages>
Reference-contexts: Their definitions are, in turn, based on the "happens before" relation introduced by Lamport [15]. The algebraic structure underlying the model is Winskel's elementary event structure <ref> [20] </ref>. The set of primitive events E is the union of N mutually disjoint sets of events, E 0 ; : : : ; E N 1 , where N is the number of processes. Each of these sets represents a local computation. It is assumed that E is finite. <p> The infimum and supremum of sets of cuts are defined by set intersection and set union respectively. In distributed computing, the subset of consistent cuts is of particular interest. Consistent cuts characterize the set of global states that might actually occur during a distributed computation. Definition 2.3. (Consistent cut, <ref> [6, 16, 17, 20] </ref>) A set C E is called a consistent cut of E if and only if for all events e 0 2 C and e 1 2 E, e 1 e 0 ) e 1 2 C. A consistent cut is left-closed under . <p> A consistent cut is left-closed under . The set of all consistent cuts of a distributed computation is denoted by C . Theorem 2.4. (Structure of consistent cuts, <ref> [16, 17, 20] </ref>) The set of consistent cuts, with the ordering defined by , is a complete lattice. 2.2 Vector time As explained before, for many applications in distributed computing, it is useful to have a characterization of causality. <p> Event e 0 precedes event e 1 since all the predecessors of e 0 are also predecessors of e 1 . pe 0 T:e 1 pe 1 Definition 2.5. (Causal past, <ref> [6, 17, 20] </ref>) The function p: : E ! 2 E defines the causal past of an event as follows. For any e 2 E, pe = fe 0 2 E j e 0 eg. Note that pe is a consistent cut. <p> Another possibility is to adapt the model of synchronous communication so that sets of events representing processes are disjoint. This is the approach pursued in this paper. Definition 2.5 yields the following useful result. Corollary 2.7. <ref> [17, 20] </ref> For any event e 2 E and any consistent cut C 2 C , e 2 C , pe C. Proof.
References-found: 20

