URL: http://actor.cs.vt.edu/~siva/workshop/papers/myers.ps
Refering-URL: http://actor.cs.vt.edu/~siva/workshop/papers.html
Root-URL: http://www.cs.vt.edu
Email: andru@lcs.mit.edu  
Title: A Meta-Object Protocol for Parameterized Types  
Author: Andrew C. Myers 
Affiliation: MIT Laboratory for Computer Science  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mark Day, Robert Gruber, Barbara Liskov, and Andrew C. Myers. </author> <title> Theta reference manual, </title> <note> 1994. To appear as memo of the Programming Methodology Group, </note> <institution> Laboratory for Computer Science, MIT. </institution>
Reference-contexts: 1 Introduction Thor [6] is a persistent object system that provides access to client applications written in a variety of programming languages. The semantics of Thor objects are defined in Theta <ref> [1] </ref>, a safe, statically-typed object-oriented programming language. In addition to subtype polymorphism and inheritance, Theta provides parametric polymorphism, an abstraction mechanism that is coming to be recognized as an essential language feature. Thor also provides a meta-object protocol that explicitly manifests Theta types as objects.
Reference: [2] <author> L. DeMichiel and R. Gabriel. </author> <title> The Common Lisp Object System: An overview. </title> <booktitle> In Proc. of European Conference on Object-Oriented Programming, </booktitle> <year> 1987. </year>
Reference-contexts: All types are represented by type objects of type Type, though different kinds of types correspond to different implementations of Type. A type is described by a collection of slots, which for most types correspond to methods. The slot-based approach is similar to that in CLOS <ref> [2, 4] </ref>, though as shown later, Theta also provides encapsulation.
Reference: [3] <author> Adele Goldberg and David Robson. Small-talk-80: </author> <title> The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: These implemented types are yielded by the supertypes iterator. Note that in Theta, object types do not describe creator routines. Objects are created by stand-alone procedures. This approach differs from Smalltalk-80, where object creation methods are added to the class object itself <ref> [3] </ref>. Extending class objects requires a new metaclass for every class in the system.
Reference: [4] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaob-ject Protocol. </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: All types are represented by type objects of type Type, though different kinds of types correspond to different implementations of Type. A type is described by a collection of slots, which for most types correspond to methods. The slot-based approach is similar to that in CLOS <ref> [2, 4] </ref>, though as shown later, Theta also provides encapsulation.
Reference: [5] <author> B. Liskov and et al. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: returns (bool) &lt; collection [T] % a mutable set insert (x: T) signals (duplicate) contains (x: T) returns (bool) equal (s: set [T]) returns (bool) end set The parameterized type set is not a type; it is a type generator that, for appropriate types T, generates the corresponding set types <ref> [5] </ref>. This process is called instantiation, and the individual types, such as set [int], are called instantia-tions. A parameterized object type, such as set, is a member of the type PType.
Reference: [6] <author> Barbara Liskov, Mark Day, and Liuba Shrira. </author> <title> Distributed object management in Thor. </title> <editor> In M. Tamer Ozsu, Umesh Dayal, and Patrick Valduriez, editors, </editor> <booktitle> Distributed Object Management. </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction Thor <ref> [6] </ref> is a persistent object system that provides access to client applications written in a variety of programming languages. The semantics of Thor objects are defined in Theta [1], a safe, statically-typed object-oriented programming language.
Reference: [7] <author> Andrew C. Myers. </author> <title> Fast object operations in a persistent programming system. </title> <type> Technical Report MIT/LCS/TR-599, </type> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, MA, </address> <month> January </month> <year> 1994. </year> <type> Master's thesis. </type>
Reference-contexts: However, as far as the compiler is concerned, Param is a type. For example, in the following code, an operation is performed using a Param. The invocation of equal is achieved by a process different from ordinary method dispatch <ref> [7, 8] </ref>. x,y: T if x.equal (y) then ... end A type parameter has operations corresponding to its where clauses, and these operations are yielded by the slots iterator if invoked on the corresponding Param object. <p> An interesting topic for future research is the addition of methods to the type object that specify how slots should be manipulated. Such a user-defined type kind would not be as efficient as the built-in Theta type kinds (which are about as fast as persistent C++ implementations <ref> [7] </ref>), but could provide different slot access semantics. 5 Conclusion Thor type objects engage in a meta-object protocol that describes the behavior of Theta, a statically-typed object-oriented language with parametric polymorphism.
Reference: [8] <author> Andrew C. Myers and Barbara Liskov. </author> <title> Efficient implementation of parameterized types despite subtyping, </title> <month> July </month> <year> 1994. </year> <note> Thor Design Note #9. Also at: ftp::/pion.lcs.mit.edu/pub/thor/ptypes.ps. 5 </note>
Reference-contexts: However, as far as the compiler is concerned, Param is a type. For example, in the following code, an operation is performed using a Param. The invocation of equal is achieved by a process different from ordinary method dispatch <ref> [7, 8] </ref>. x,y: T if x.equal (y) then ... end A type parameter has operations corresponding to its where clauses, and these operations are yielded by the slots iterator if invoked on the corresponding Param object. <p> It is in implementing ClassInstn that most of the complexity of parameterization appears, since class instantiations must actually instantiate code. In Thor, code instantiation does not require du plicating code for each instantiation <ref> [8] </ref>. 4 4 Creating New Types As described in Section 3, new types can be added to the system by calls to the instantiate methods of parameterized type and class objects. New record types are created similarly, though this is not described here.
References-found: 8

