URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR464.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Title: PUTTING IT IN CONTEXT: A SYNTACTIC THEORY OF INCREMENTAL PROGRAM CONSTRUCTION  
Author: Shinn-Der Lee 
Degree: Submitted to the faculty of the University Graduate School in partial fulfillment of the requirements for the degree Doctor of Philosophy in the  
Date: June 1996  
Affiliation: Department of Computer Science Indiana University  
Abstract: This report is based on work supported in part by the National Science Foundation grants numbered CCR 93-02114 and CDA 93-12614. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi, Luca Cardelli, Pierre-Louis Curien, and Jean-Jacques Levy. </author> <title> Explicit substitutions. </title> <booktitle> In Proceedings of the 17th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 31-46, </pages> <year> 1990. </year>
Reference-contexts: Although variable renaming is traditionally used as a means to avoid inadvertent variable capture, it is not essential to the understanding of programming with the - calculus. By tinkering with the representation of -terms [9, 14, 34] or the definition of fi-substitution <ref> [1] </ref>, the fi-reduction rule can be framed in a setting in which variable 13 renaming is unnecessary. We have found that variable renaming is indispensable to our work, however. Our incremental compiled code construction operations rely exclusively on the renaming of variables to model the linking of separately-developed program components. <p> It is not essential to the understanding of functional programming, however. Indeed, by tinkering with the representation of -terms and the definition of the fi-reduction rule, the -calculus can be framed in a nameless setting and therefore rendering ff-conversion unnecessary <ref> [1, 9, 10, 14] </ref>. We are obliged to discuss it in detail since our incremental compiled code construction operations rely exclusively on variable renaming to model the linking of separately-developed program components. We should point out the similarity between the two substitution meta-operations hy=xie and [y=x]e. <p> The reason is that each fi-substitution operation incurs potentially many ff-conversion steps to avoid variable capture. Many have come up with variations of the -calculus to facilitate efficient implementation <ref> [1, 14, 41, 56, 72] </ref>. In particular, in his AU-TOMATH project [15], de Bruijn uses a version of the -calculus in which each variable reference is replaced by its lexical address, which is the distance between the 131 variable reference and its binding -parameter.
Reference: [2] <author> Martn Abadi and Luca Cardelli. </author> <title> A theory of primitive objects: Untyped and first-order systems. </title> <booktitle> In Theoretical Aspects of Computer Software, </booktitle> <pages> pages 296-320. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Moreover, virtual references can decide by themselves on which of the many versions of future modifications to 22 take as their permanent denotation. All in all, we are able to show that object-oriented programming can be modeled with compile-time linking, rather than run-time environment lookup or record field selection <ref> [2, 5, 22, 23, 24, 32, 37, 51, 57, 60, 74] </ref>. Lisp [66] and its dialects such as Scheme [4, 21] employ an interactive evaluator as a means for incremental program development. An interactive evaluator uses an ever-growing environment to keep track of the bindings produced by previously evaluated define-expressions. <p> There are many issues concerning our context-enhancing schema left unexplored. Among them are: typing The typing of object-oriented programming languages is currently a very active research area <ref> [2, 32, 51, 57] </ref>. Some of the crucial notions underlying the programming paradigm are shared by our context-enriched calculi. <p> Furthermore, since some of the crucial notions underlying object-oriented programming are shared by our context-enriched calculi, 185 it is tempting to investigate if our incremental program construction mechanisms simplify or complicate typing issues of object-oriented programming languages <ref> [2, 32, 51, 57] </ref>. 9.3.3 Garbage Collecting Redundant Parameters In the context-enriched -calculi we rely on the meta-notion of indistinguishability ( ) to remove redundant parameters from free identifier abstractions. We are wondering if such redundant parameters can be removed without resorting to indistinguishability. A positive answer seems reachable.
Reference: [3] <author> Martn Abadi, Luca Cardelli, and Ramesh Viswanathan. </author> <title> An interpretation of objects and object types. </title> <booktitle> In Proceedings of the 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1996. </year>
Reference: [4] <author> Harold Abelson and Gerald Jay Sussman with Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Incremental program development amounts to filling in the blanks of well-planned program structures with new experimental components, or assembling new programs from previously developed and thoroughly tested components, or a combination of both. To illustrate, the following example, which is taken from Abelson and Sussman <ref> [4] </ref>, shows an interactive Scheme [21] programming session that develops a program for computing the square root of a given number x using Newton's method of successive approximations (the interactive Scheme evaluator issues a prompt (&gt;) preceded by a number added for reference purposes when it is ready to accept the <p> All in all, we are able to show that object-oriented programming can be modeled with compile-time linking, rather than run-time environment lookup or record field selection [2, 5, 22, 23, 24, 32, 37, 51, 57, 60, 74]. Lisp [66] and its dialects such as Scheme <ref> [4, 21] </ref> employ an interactive evaluator as a means for incremental program development. An interactive evaluator uses an ever-growing environment to keep track of the bindings produced by previously evaluated define-expressions. <p> The interactive environment thus constitutes an incrementally constructed program. Traditionally, the adaptive behavior of an interactive system is explained in terms of side effects [21] or dynamic binding <ref> [4] </ref>. We are able to describe the adaptive nature of interactive programming as yet another form of incremental program construction based on relinkable variable references. <p> To summarize, modeling virtual references as relinkables is desirable because of the simplicity, clarity, and flexibility they provide. 8.2 Interactive Programming Lisp [66] and its dialects such as Scheme <ref> [4, 21] </ref> employ an interactive evaluator as a means for incremental program development. Conceptually, an interactive evaluator uses an ever-growing interactive environment to keep track of the results produced by previously evaluated define-expressions.
Reference: [5] <author> Norman Adams and Jonathan Rees. </author> <title> Object-oriented programming in Scheme. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 277-288, </pages> <year> 1988. </year>
Reference-contexts: Moreover, virtual references can decide by themselves on which of the many versions of future modifications to 22 take as their permanent denotation. All in all, we are able to show that object-oriented programming can be modeled with compile-time linking, rather than run-time environment lookup or record field selection <ref> [2, 5, 22, 23, 24, 32, 37, 51, 57, 60, 74] </ref>. Lisp [66] and its dialects such as Scheme [4, 21] employ an interactive evaluator as a means for incremental program development. An interactive evaluator uses an ever-growing environment to keep track of the bindings produced by previously evaluated define-expressions.
Reference: [6] <author> Hassan At-Kaci and Jacques Garrigue. </author> <title> Label-selective -calculus: Syntax and confluence. </title> <booktitle> In Proceedings of the 13th International Conference on Foundations of Software Technologies and Theoretical Computer Science, </booktitle> <pages> pages 24-40, </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The difference has a profound effect on the philosophical view of software composition. In the view of Dami's N-calculus, as well as other extensions of the -calculus with name-based programming mechanisms such as records [19], label-selective -calculus <ref> [6] </ref>, transparent data parameters 182 [36, 40], and quasi-static procedures [42], composing programs is about passing named parameters among program components, a notion tied to the computational behavior of programs.
Reference: [7] <author> H. P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics, Revised edition. </title> <publisher> North-Holland, </publisher> <year> 1984. </year> <pages> 187 188 </pages>
Reference-contexts: (inclusion) of code that models the reuse of 6 existing program components and the renaming of variables that models the linking of existing program components. 1.1 Incremental Program Construction We address the difficulties involved in enhancing a programming language with incremental program construction capabilities in terms of the pure -calculus <ref> [7] </ref>. We choose the -calculus as a representative to convey our design methodology for two reasons. First, the -calculus possesses all the basic obstacles to incremental program construction inherently associated with most languages. <p> It is associated with a separate meta-notion called contexts <ref> [7] </ref>. <p> The rest of this chapter provides an overview of our work. Each section below is a short summary of one of the succeeding chapters. 1.2 Lambda Calculus As a starting point, we survey the basics of the untyped -calculus <ref> [7] </ref>. We pay special attention to two fundamental concepts of the -calculus that are most relevant to our work, namely, variable renaming and contexts. <p> The way computation is actually modeled has little impact on our schema. We therefore choose to illustrate our schema on the -calculus that has the least complicated description|the call-by-name untyped pure -calculus. For an in-depth 25 26 treatment of the -calculus, the reader is advised to consult the literature <ref> [7, 33, 34] </ref>. <p> There are many ways to prove the theorem. We will not repeat them here but refer the interested reader to the literature <ref> [7, 69] </ref>. 2.6 Programming with Lambda Calculus Programming with the -calculus is programming with functions. <p> To model linking, we turn to the notion of contexts <ref> [7] </ref>. Recall the one-hole contexts C [] introduced earlier in Section 2.2 to characterize the compatible closure of notions of reduction. A one-hole context C [] is a -term with a single hole [] in it.
Reference: [8] <author> Henk Barendregt. </author> <title> Self-interpretation in lambda calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(2) </volume> <pages> 229-234, </pages> <year> 1991. </year>
Reference-contexts: The context-enriched version of a -calculus is capable of compiling the -contexts incrementally, a goal designed into our schema. It is therefore possible to express the compilation of the CC-contexts in the CC-calculus. That is, there is a self-compiler <ref> [8, 52] </ref> for CC. Furthermore, we can show that the self-compiler is metacir-cular [45]. That is, each category of evolved CC-contexts can be translated directly into the machine code of the same category of CC-terms, no auxiliary notions or mechanisms are necessary. <p> That is, CC is a "fixpoint" of our design methodology. 5.4 Metacircular Self-Compilation As shown in Chapter 4, the context-enriched version of a calculus is capable of compiling the original calculus. Here, we demonstrate the compilation of CC in the 101 CC-calculus itself, thus yielding a self-compiler for CC <ref> [8, 52] </ref>.
Reference: [9] <author> Klaus J. Berkling and Elfriede Fehr. </author> <title> A consistent extension of the lambda-calculus as a base for functional programming languages. </title> <journal> Information and Control, </journal> <volume> 55 </volume> <pages> 89-101, </pages> <year> 1982. </year>
Reference-contexts: Although variable renaming is traditionally used as a means to avoid inadvertent variable capture, it is not essential to the understanding of programming with the - calculus. By tinkering with the representation of -terms <ref> [9, 14, 34] </ref> or the definition of fi-substitution [1], the fi-reduction rule can be framed in a setting in which variable 13 renaming is unnecessary. We have found that variable renaming is indispensable to our work, however. <p> Each constituent x k is a variable reference x 20 with a lexical address k <ref> [9, 10, 14] </ref>. It refers to the kth nearest enclosing function parameter named x. Hence, the reference x 2 in x:y:x:[x 2 ] refers to the underlined function parameter, not the one overlined. <p> It is not essential to the understanding of functional programming, however. Indeed, by tinkering with the representation of -terms and the definition of the fi-reduction rule, the -calculus can be framed in a nameless setting and therefore rendering ff-conversion unnecessary <ref> [1, 9, 10, 14] </ref>. We are obliged to discuss it in detail since our incremental compiled code construction operations rely exclusively on variable renaming to model the linking of separately-developed program components. We should point out the similarity between the two substitution meta-operations hy=xie and [y=x]e. <p> An immediate consequence is that the calculus employs no variable names. There is therefore no need for ff-conversion. Motivated by the same efficiency concerns, Berkling and Fehr <ref> [9, 10] </ref> propose independently a -calculus that can be characterized as an integration of de Bruijn's nameless -calculus with the standard nameful version of the -calculus.
Reference: [10] <author> Klaus J. Berkling and Elfriede Fehr. </author> <title> A modification of the -calculus as a base for functional programming languages. </title> <booktitle> In Proceedings of the International Colloquium on Automata, Languages and Programming, </booktitle> <pages> pages 35-47, </pages> <booktitle> Lecture Notes in Computer Science 140. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: Each constituent x k is a variable reference x 20 with a lexical address k <ref> [9, 10, 14] </ref>. It refers to the kth nearest enclosing function parameter named x. Hence, the reference x 2 in x:y:x:[x 2 ] refers to the underlined function parameter, not the one overlined. <p> It is not essential to the understanding of functional programming, however. Indeed, by tinkering with the representation of -terms and the definition of the fi-reduction rule, the -calculus can be framed in a nameless setting and therefore rendering ff-conversion unnecessary <ref> [1, 9, 10, 14] </ref>. We are obliged to discuss it in detail since our incremental compiled code construction operations rely exclusively on variable renaming to model the linking of separately-developed program components. We should point out the similarity between the two substitution meta-operations hy=xie and [y=x]e. <p> An immediate consequence is that the calculus employs no variable names. There is therefore no need for ff-conversion. Motivated by the same efficiency concerns, Berkling and Fehr <ref> [9, 10] </ref> propose independently a -calculus that can be characterized as an integration of de Bruijn's nameless -calculus with the standard nameful version of the -calculus.
Reference: [11] <author> Gilad Bracha and William Cook. </author> <title> Mixin-based inheritance. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming: Systems, Languages and Applications, </booktitle> <pages> pages 303-311, </pages> <year> 1990. </year>
Reference-contexts: Modules provide the information hiding facilities needed for an object system [64, 65]. Incremental module combination operations such as moverride are the means for reusing existing objects to form new objects. This style of inheritance is often referred to as mixin-based <ref> [11] </ref>. 166 The feature unique to our object system is the incorporation of relinkables to model late binding virtual references.
Reference: [12] <author> Gilad Bracha and Gary Lindstrom. </author> <title> Modularity meets Inheritance. </title> <booktitle> In Proceedings of the International Conference on Computer Languages, </booktitle> <pages> pages 282-290, </pages> <year> 1992. </year>
Reference-contexts: With our context-enriched calculi, program composition is about linking program components together, a notion that is completely independent of the computational behavior of programs. 9.2.3 Jigsaw Jigsaw <ref> [12, 13] </ref> is a framework for designing modular programming languages based on the idea that inheritance is an essential linguistic mechanism for module manipulation. A module is an abstract class [46, 68]. It is a mutually recursive scope consisting of definitions and declarations. Definitions bind names to values.
Reference: [13] <author> Gilad Bracha. </author> <title> The Programming Language Jigsaw: Mixins, Modularity and Multiple Inheritance. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1992. </year>
Reference-contexts: With our context-enriched calculi, program composition is about linking program components together, a notion that is completely independent of the computational behavior of programs. 9.2.3 Jigsaw Jigsaw <ref> [12, 13] </ref> is a framework for designing modular programming languages based on the idea that inheritance is an essential linguistic mechanism for module manipulation. A module is an abstract class [46, 68]. It is a mutually recursive scope consisting of definitions and declarations. Definitions bind names to values.
Reference: [14] <author> N. G. de Bruijn. </author> <title> Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation. </title> <journal> Indagationes Mathematicae, </journal> <volume> 34 </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference-contexts: Although variable renaming is traditionally used as a means to avoid inadvertent variable capture, it is not essential to the understanding of programming with the - calculus. By tinkering with the representation of -terms <ref> [9, 14, 34] </ref> or the definition of fi-substitution [1], the fi-reduction rule can be framed in a setting in which variable 13 renaming is unnecessary. We have found that variable renaming is indispensable to our work, however. <p> Each constituent x k is a variable reference x 20 with a lexical address k <ref> [9, 10, 14] </ref>. It refers to the kth nearest enclosing function parameter named x. Hence, the reference x 2 in x:y:x:[x 2 ] refers to the underlined function parameter, not the one overlined. <p> It is not essential to the understanding of functional programming, however. Indeed, by tinkering with the representation of -terms and the definition of the fi-reduction rule, the -calculus can be framed in a nameless setting and therefore rendering ff-conversion unnecessary <ref> [1, 9, 10, 14] </ref>. We are obliged to discuss it in detail since our incremental compiled code construction operations rely exclusively on variable renaming to model the linking of separately-developed program components. We should point out the similarity between the two substitution meta-operations hy=xie and [y=x]e. <p> The reason is that each fi-substitution operation incurs potentially many ff-conversion steps to avoid variable capture. Many have come up with variations of the -calculus to facilitate efficient implementation <ref> [1, 14, 41, 56, 72] </ref>. In particular, in his AU-TOMATH project [15], de Bruijn uses a version of the -calculus in which each variable reference is replaced by its lexical address, which is the distance between the 131 variable reference and its binding -parameter.
Reference: [15] <author> N. G. de Bruijn. </author> <title> A survey of the project AUTOMATH. In To H.B. </title> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus, and Formalism, </booktitle> <pages> pages 579-606, </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: The reason is that each fi-substitution operation incurs potentially many ff-conversion steps to avoid variable capture. Many have come up with variations of the -calculus to facilitate efficient implementation [1, 14, 41, 56, 72]. In particular, in his AU-TOMATH project <ref> [15] </ref>, de Bruijn uses a version of the -calculus in which each variable reference is replaced by its lexical address, which is the distance between the 131 variable reference and its binding -parameter. An immediate consequence is that the calculus employs no variable names.
Reference: [16] <author> M.W. Bunder. </author> <title> An extension of Klop's counterexample to the Church-Rosser property to lambda-calculus with other ordered pair combinators. </title> <journal> Theoretical Computer Science, </journal> <volume> 39 </volume> <pages> 337-342, </pages> <year> 1985. </year> <month> 189 </month>
Reference-contexts: he 1 ; : : : ; e n i j n Of course, we should also extend the -calculus with the following notion of reduction: n i ) 39 In any case, care must be taken to preserve the Church-Rosser property when new ffi-rules are added to the -calculus <ref> [16, 39] </ref>. According to the Hindley-Rosen Lemma, the added ffi-rules must be shown to be Church-Rosser; moreover, they must commute with the existing fi-rule. In the thesis, we demonstrate our context-enriching schema only on the pure - calculi, but will use the applied -calculi in examples.
Reference: [17] <author> Luca Cardelli. </author> <title> Compiling a functional language. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 208-217, </pages> <year> 1984. </year>
Reference-contexts: our schema simplifies or complicates typing issues. implementation Efficient implementation should not be the deciding factor of the practicality of our schema, but a stronger case can be presented if we have one. (Build it and they will come.) Many of the clever implementation techniques employed in some popular functional <ref> [17, 27, 56, 62] </ref> and object-oriented languages [20, 25, 26] may be applicable to our context-enriched calculi. The above issues, as well as related work, are discussed in Chapter 9. <p> For instance, it is easy 184 to determine the binding parameter of a statically-scoped variable reference when we know enough about the context in which it is used. Consequently, such a variable reference can be translated into a simple lexical address relative to the closure representation of some -abstraction <ref> [17, 27, 62] </ref>. Adapting such an implementation technique to our free identifier abstractions becomes a non-trivial task since the context of the free identifier references has yet to be built. It is therefore impossible to translate them into some fixed lexical addresses beforehand.
Reference: [18] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Survey, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <year> 1985. </year>
Reference-contexts: It means that our incremental compiled code construction operations must also perform type checking (or type in-ferencing) duties. Since there is a diverse array of type systems <ref> [18, 50] </ref>, it is a major undertaking to study the various typing disciplines they impose on our incremental compiled code constructors. An extensive exploration of the typing of our context-enriched calculi is at the top of our agenda.
Reference: [19] <author> Luca Cardelli and John C. Mitchell. </author> <note> Operations on records. In [32]. </note>
Reference-contexts: In contrast, in our context-enriched calculi, names are used in incremental program construction steps. The difference has a profound effect on the philosophical view of software composition. In the view of Dami's N-calculus, as well as other extensions of the -calculus with name-based programming mechanisms such as records <ref> [19] </ref>, label-selective -calculus [6], transparent data parameters 182 [36, 40], and quasi-static procedures [42], composing programs is about passing named parameters among program components, a notion tied to the computational behavior of programs.
Reference: [20] <author> Craig Chambers, David Ungar, and Eugene Lee. </author> <title> An efficient implementation of SELF, a dynamically-typed object-oriented language based on prototypes. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 4(3) </volume> <pages> 243-281, </pages> <year> 1991. </year>
Reference-contexts: implementation Efficient implementation should not be the deciding factor of the practicality of our schema, but a stronger case can be presented if we have one. (Build it and they will come.) Many of the clever implementation techniques employed in some popular functional [17, 27, 56, 62] and object-oriented languages <ref> [20, 25, 26] </ref> may be applicable to our context-enriched calculi. The above issues, as well as related work, are discussed in Chapter 9. <p> Intuitively, the compiled code construction operations induced by our schema are run-time operations. It is therefore conceivable that they require run-time code generation <ref> [20, 43] </ref>. We are inclined to believe that some form of run-time code generation is inevitable when efficiency is a relevant issue.
Reference: [21] <editor> William Clinger and Jonathan Rees (editors). </editor> <title> Revised 4 report on the algorithmic language Scheme. </title> <journal> Lisp Pointers, </journal> <volume> 4(3) </volume> <pages> 1-55, </pages> <year> 1991. </year>
Reference-contexts: To illustrate, the following example, which is taken from Abelson and Sussman [4], shows an interactive Scheme <ref> [21] </ref> programming session that develops a program for computing the square root of a given number x using Newton's method of successive approximations (the interactive Scheme evaluator issues a prompt (&gt;) preceded by a number added for reference purposes when it is ready to accept the next input expression): 3 1&gt; <p> All in all, we are able to show that object-oriented programming can be modeled with compile-time linking, rather than run-time environment lookup or record field selection [2, 5, 22, 23, 24, 32, 37, 51, 57, 60, 74]. Lisp [66] and its dialects such as Scheme <ref> [4, 21] </ref> employ an interactive evaluator as a means for incremental program development. An interactive evaluator uses an ever-growing environment to keep track of the bindings produced by previously evaluated define-expressions. <p> The binding is then used to extend or override the existing interactive environment to yield a new environment for the evaluation of the next expression. The interactive environment thus constitutes an incrementally constructed program. Traditionally, the adaptive behavior of an interactive system is explained in terms of side effects <ref> [21] </ref> or dynamic binding [4]. We are able to describe the adaptive nature of interactive programming as yet another form of incremental program construction based on relinkable variable references. <p> A case in point is the denotational approach of Scott and Strachey [48, 61, 67]. As a computational notion, the -calculus is Turing-complete; every computable function is definable in the -calculus [38]. As a programming notion, its features form the core of many contemporary high-level programming languages <ref> [21, 49] </ref>. One of the reasons that make -calculus the quintessential representative used in conveying new programming notions is its concise and expressive syntax. In our case, the -calculus also happens to exhibit all the obstacles to incremental program construction that are inherent to statically-scoped languages. <p> To summarize, modeling virtual references as relinkables is desirable because of the simplicity, clarity, and flexibility they provide. 8.2 Interactive Programming Lisp [66] and its dialects such as Scheme <ref> [4, 21] </ref> employ an interactive evaluator as a means for incremental program development. Conceptually, an interactive evaluator uses an ever-growing interactive environment to keep track of the results produced by previously evaluated define-expressions. <p> The interactive session above demonstrates the fact that the function foo is responsive to the changes to the definition of bar. Traditionally, the adaptive behavior of the reference bar used in foo is explained in terms of side effects <ref> [21] </ref>. That is, during (or before) the evaluation of the definition of the function foo, a cell is allocated in the interactive environment for the function bar. When bar is defined 169 or redefined, its latest denotation is deposited into the cell.
Reference: [22] <author> William Cook and Jens Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming: Systems, Languages and Applications, </booktitle> <pages> pages 433-443, </pages> <year> 1989. </year>
Reference-contexts: Moreover, virtual references can decide by themselves on which of the many versions of future modifications to 22 take as their permanent denotation. All in all, we are able to show that object-oriented programming can be modeled with compile-time linking, rather than run-time environment lookup or record field selection <ref> [2, 5, 22, 23, 24, 32, 37, 51, 57, 60, 74] </ref>. Lisp [66] and its dialects such as Scheme [4, 21] employ an interactive evaluator as a means for incremental program development. An interactive evaluator uses an ever-growing environment to keep track of the bindings produced by previously evaluated define-expressions. <p> denotation of the variable y is e, then the denotation of the virtual reference x is also e, which is expressed in our system as a provisionally-instantiated relinkable x ~ e. 167 Our semantics of inheritance is the same fixpoint semantics of Kamin [37], Reddy [60], and Cook and Palsberg <ref> [22] </ref>. In their descriptions of objects, late binding intra-object virtual attribute references are modeled as run-time variable lookups from the environment denoted by some pseudo-variable self. Moreover, the same pseudo-variable self is overloaded to explain object self-reference as well. <p> Jigsaw shares our view that modules and objects are closely related incremental programming concepts that should be supported in a single system. The main difference lies in the way virtual attribute references are resolved. Jigsaw's semantics is based upon a denotational model of inheritance <ref> [22, 60] </ref> where modules are modeled as record generators, which are functions from records to records, and attribute references are translated into record field selections. Module manipulation operators are then defined as operations on such record generators. These record generator operations are responsible for building records incrementally.
Reference: [23] <author> William Cook. </author> <title> A Denotational Semantics of Inheritance. </title> <type> PhD thesis, </type> <institution> Brown University, </institution> <year> 1989. </year>
Reference-contexts: Moreover, virtual references can decide by themselves on which of the many versions of future modifications to 22 take as their permanent denotation. All in all, we are able to show that object-oriented programming can be modeled with compile-time linking, rather than run-time environment lookup or record field selection <ref> [2, 5, 22, 23, 24, 32, 37, 51, 57, 60, 74] </ref>. Lisp [66] and its dialects such as Scheme [4, 21] employ an interactive evaluator as a means for incremental program development. An interactive evaluator uses an ever-growing environment to keep track of the bindings produced by previously evaluated define-expressions.
Reference: [24] <author> Laurent Dami. </author> <title> Software Composition: Towards an Integration of Functional and Object-Oriented Approaches. </title> <type> PhD thesis, </type> <institution> University of Geneva, </institution> <year> 1994. </year>
Reference-contexts: Moreover, virtual references can decide by themselves on which of the many versions of future modifications to 22 take as their permanent denotation. All in all, we are able to show that object-oriented programming can be modeled with compile-time linking, rather than run-time environment lookup or record field selection <ref> [2, 5, 22, 23, 24, 32, 37, 51, 57, 60, 74] </ref>. Lisp [66] and its dialects such as Scheme [4, 21] employ an interactive evaluator as a means for incremental program development. An interactive evaluator uses an ever-growing environment to keep track of the bindings produced by previously evaluated define-expressions. <p> Reasoning with free identifier abstractions is more natural than reasoning with environments precisely because they separate specification issues from implementation issues concerning free variables, a fundamental re quirement for any useful abstraction mechanism. 9.2.2 Lambda Calculus with Names Dami's -calculus with names N <ref> [24] </ref> extends the -calculus with keyword parameters to facilitate program extensibility.
Reference: [25] <author> L. Peter Deutsch and Allan M. Schiffman. </author> <title> Efficient implementation of the Smalltalk-80 system. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 297-302, </pages> <year> 1984. </year>
Reference-contexts: implementation Efficient implementation should not be the deciding factor of the practicality of our schema, but a stronger case can be presented if we have one. (Build it and they will come.) Many of the clever implementation techniques employed in some popular functional [17, 27, 56, 62] and object-oriented languages <ref> [20, 25, 26] </ref> may be applicable to our context-enriched calculi. The above issues, as well as related work, are discussed in Chapter 9.
Reference: [26] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: implementation Efficient implementation should not be the deciding factor of the practicality of our schema, but a stronger case can be presented if we have one. (Build it and they will come.) Many of the clever implementation techniques employed in some popular functional [17, 27, 56, 62] and object-oriented languages <ref> [20, 25, 26] </ref> may be applicable to our context-enriched calculi. The above issues, as well as related work, are discussed in Chapter 9. <p> Meanwhile, the latest link of the virtual reference d is updated to the defining variable d 0 supplied by the modifier deltaM, thus inheriting the new dist-attribute. So, similar to C++ <ref> [26] </ref>, but unlike Smalltalk [30], the objects aCP and aMP show that virtual references need not rely on some pseudo-variable such as self. <p> Conceptually, when the linking relation of a virtual variable is altered during the construction of a new object, the variable's slot in the virtual table is updated to reflect the necessary change. A prominent example using such a technique to implement late binding virtual references efficiently is C++ <ref> [26] </ref>. In our system, a slot is associated with each individual virtual variable reference. That is, x [y] models a table entry for the virtual reference x whose current contents is the location of the variable y. <p> Our description of incremental programming is more attractive since it has a cleaner semantics for modules and objects. Moreover, the semantic description very closely resembles actual implementations employed by object-oriented languages such as C++ <ref> [26] </ref>. 9.3 Future Work There are many issues concerning our context-enriching schema left to be explored. First and foremost is the need of an effective implementation for our context-enriched calculi.
Reference: [27] <author> Marc Feeley and Guy Lapalme. </author> <title> Closure generation based on viewing lambda as epsilon plus compile. </title> <journal> Journal of Computer Languages, </journal> <volume> 17(4) </volume> <pages> 251-267, </pages> <year> 1992. </year> <month> 190 </month>
Reference-contexts: our schema simplifies or complicates typing issues. implementation Efficient implementation should not be the deciding factor of the practicality of our schema, but a stronger case can be presented if we have one. (Build it and they will come.) Many of the clever implementation techniques employed in some popular functional <ref> [17, 27, 56, 62] </ref> and object-oriented languages [20, 25, 26] may be applicable to our context-enriched calculi. The above issues, as well as related work, are discussed in Chapter 9. <p> For instance, it is easy 184 to determine the binding parameter of a statically-scoped variable reference when we know enough about the context in which it is used. Consequently, such a variable reference can be translated into a simple lexical address relative to the closure representation of some -abstraction <ref> [17, 27, 62] </ref>. Adapting such an implementation technique to our free identifier abstractions becomes a non-trivial task since the context of the free identifier references has yet to be built. It is therefore impossible to translate them into some fixed lexical addresses beforehand.
Reference: [28] <author> Matthias Felleisen and Daniel P. Friedman. </author> <title> A closer look at export and import statements. </title> <journal> Journal of Computer Languages, </journal> <volume> 11(1) </volume> <pages> 29-37, </pages> <year> 1986. </year>
Reference: [29] <author> Matthias Felleisen and Robert Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 102 </volume> <pages> 235-271, </pages> <year> 1992. </year>
Reference-contexts: Each of them possesses particular idiosyncrasies inherent to the type of computation it is intended to model. Examples are -calculi that employ call-by-name or call-by-value evaluation strategies [58], -calculi that include constants and sophisticated datatypes [35], -calculi that embody imperative features such as assignments <ref> [29, 53] </ref> and continuations [29]. Our schema applies to them all. Of concern to us is how to construct programs incrementally. The way computation is actually modeled has little impact on our schema. <p> Each of them possesses particular idiosyncrasies inherent to the type of computation it is intended to model. Examples are -calculi that employ call-by-name or call-by-value evaluation strategies [58], -calculi that include constants and sophisticated datatypes [35], -calculi that embody imperative features such as assignments [29, 53] and continuations <ref> [29] </ref>. Our schema applies to them all. Of concern to us is how to construct programs incrementally. The way computation is actually modeled has little impact on our schema. We therefore choose to illustrate our schema on the -calculus that has the least complicated description|the call-by-name untyped pure -calculus.
Reference: [30] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison Wesley, </publisher> <year> 1983. </year>
Reference-contexts: A relinkable variable reference [y 2 ; x 2 ; y 1 ; x 1 ] is a virtual reference that can be linked to either of the two attributes denoted by x or y. Hence, unlike Smalltalk <ref> [30] </ref>, but similar to C++ [68], our object system does not rely on some pseudo-variable named self to accomplish intra-object virtual attribute references. Instead, the pseudo-variable is strictly reserved for the purpose of object self-reference. <p> Meanwhile, the latest link of the virtual reference d is updated to the defining variable d 0 supplied by the modifier deltaM, thus inheriting the new dist-attribute. So, similar to C++ [26], but unlike Smalltalk <ref> [30] </ref>, the objects aCP and aMP show that virtual references need not rely on some pseudo-variable such as self.
Reference: [31] <author> James Gosling and Henry McGilton. </author> <title> The Java language environment: A white paper. Sun Microsystems, </title> <year> 1995. </year>
Reference-contexts: The three most essential features of object-oriented programming are object encapsulation, inheritance, and late binding <ref> [31] </ref>. Object encapsulation is about information hiding and modularity. Objects interact with one another only through clearly specified import and export interfaces. Object inheritance implements code reuse and code organization. It is the mechanism by which new and enhanced objects can be defined in terms of existing objects.
Reference: [32] <author> Carl A. Gunter and John C. Mitchell. </author> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Language Design. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Moreover, virtual references can decide by themselves on which of the many versions of future modifications to 22 take as their permanent denotation. All in all, we are able to show that object-oriented programming can be modeled with compile-time linking, rather than run-time environment lookup or record field selection <ref> [2, 5, 22, 23, 24, 32, 37, 51, 57, 60, 74] </ref>. Lisp [66] and its dialects such as Scheme [4, 21] employ an interactive evaluator as a means for incremental program development. An interactive evaluator uses an ever-growing environment to keep track of the bindings produced by previously evaluated define-expressions. <p> There are many issues concerning our context-enhancing schema left unexplored. Among them are: typing The typing of object-oriented programming languages is currently a very active research area <ref> [2, 32, 51, 57] </ref>. Some of the crucial notions underlying the programming paradigm are shared by our context-enriched calculi. <p> Furthermore, since some of the crucial notions underlying object-oriented programming are shared by our context-enriched calculi, 185 it is tempting to investigate if our incremental program construction mechanisms simplify or complicate typing issues of object-oriented programming languages <ref> [2, 32, 51, 57] </ref>. 9.3.3 Garbage Collecting Redundant Parameters In the context-enriched -calculi we rely on the meta-notion of indistinguishability ( ) to remove redundant parameters from free identifier abstractions. We are wondering if such redundant parameters can be removed without resorting to indistinguishability. A positive answer seems reachable.
Reference: [33] <author> Chris Hankin. </author> <title> Lambda Calculi: A Guide For Computer Scientists. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: The way computation is actually modeled has little impact on our schema. We therefore choose to illustrate our schema on the -calculus that has the least complicated description|the call-by-name untyped pure -calculus. For an in-depth 25 26 treatment of the -calculus, the reader is advised to consult the literature <ref> [7, 33, 34] </ref>.
Reference: [34] <author> J. Roger Hindley and Jonathan P. Seldin. </author> <title> Introduction to Combinators and -Calculus. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: Although variable renaming is traditionally used as a means to avoid inadvertent variable capture, it is not essential to the understanding of programming with the - calculus. By tinkering with the representation of -terms <ref> [9, 14, 34] </ref> or the definition of fi-substitution [1], the fi-reduction rule can be framed in a setting in which variable 13 renaming is unnecessary. We have found that variable renaming is indispensable to our work, however. <p> The way computation is actually modeled has little impact on our schema. We therefore choose to illustrate our schema on the -calculus that has the least complicated description|the call-by-name untyped pure -calculus. For an in-depth 25 26 treatment of the -calculus, the reader is advised to consult the literature <ref> [7, 33, 34] </ref>.
Reference: [35] <author> Paul Hudak. </author> <title> Conception, evolution, and application of functional programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 359-411, </pages> <year> 1989. </year>
Reference-contexts: There are many variants of the untyped -calculus. Each of them possesses particular idiosyncrasies inherent to the type of computation it is intended to model. Examples are -calculi that employ call-by-name or call-by-value evaluation strategies [58], -calculi that include constants and sophisticated datatypes <ref> [35] </ref>, -calculi that embody imperative features such as assignments [29, 53] and continuations [29]. Our schema applies to them all. Of concern to us is how to construct programs incrementally. The way computation is actually modeled has little impact on our schema. <p> An alternative is to augment the - calculus with basic constants and datatype constructors along with their associated notions of reduction (these notions of reduction are known as ffi-rules). Such extensions of the -calculus are often called applied -calculi <ref> [35] </ref>.
Reference: [36] <author> Stanley Jefferson, Shinn-Der Lee, and Daniel P. Friedman. </author> <title> A syntactic theory of transparent parameterization. </title> <booktitle> In Proceedings of the 3rd European Symposium on Programming, </booktitle> <pages> pages 211-226, </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The difference has a profound effect on the philosophical view of software composition. In the view of Dami's N-calculus, as well as other extensions of the -calculus with name-based programming mechanisms such as records [19], label-selective -calculus [6], transparent data parameters 182 <ref> [36, 40] </ref>, and quasi-static procedures [42], composing programs is about passing named parameters among program components, a notion tied to the computational behavior of programs.
Reference: [37] <author> Samuel N. Kamin. </author> <title> Inheritance in Smalltalk-80: A denotational definition. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 80-87, </pages> <year> 1988. </year>
Reference-contexts: Moreover, virtual references can decide by themselves on which of the many versions of future modifications to 22 take as their permanent denotation. All in all, we are able to show that object-oriented programming can be modeled with compile-time linking, rather than run-time environment lookup or record field selection <ref> [2, 5, 22, 23, 24, 32, 37, 51, 57, 60, 74] </ref>. Lisp [66] and its dialects such as Scheme [4, 21] employ an interactive evaluator as a means for incremental program development. An interactive evaluator uses an ever-growing environment to keep track of the bindings produced by previously evaluated define-expressions. <p> Consequently, if the denotation of the variable y is e, then the denotation of the virtual reference x is also e, which is expressed in our system as a provisionally-instantiated relinkable x ~ e. 167 Our semantics of inheritance is the same fixpoint semantics of Kamin <ref> [37] </ref>, Reddy [60], and Cook and Palsberg [22]. In their descriptions of objects, late binding intra-object virtual attribute references are modeled as run-time variable lookups from the environment denoted by some pseudo-variable self. Moreover, the same pseudo-variable self is overloaded to explain object self-reference as well.
Reference: [38] <author> Stephen C. Kleene. </author> <title> -Definability and recursiveness. </title> <journal> Duke Mathematical Journal, </journal> <volume> 2 </volume> <pages> 340-353, </pages> <year> 1936. </year> <month> 191 </month>
Reference-contexts: As a mathematical notion, it is used for defining programming language semantics. A case in point is the denotational approach of Scott and Strachey [48, 61, 67]. As a computational notion, the -calculus is Turing-complete; every computable function is definable in the -calculus <ref> [38] </ref>. As a programming notion, its features form the core of many contemporary high-level programming languages [21, 49]. One of the reasons that make -calculus the quintessential representative used in conveying new programming notions is its concise and expressive syntax.
Reference: [39] <author> J.W. Klop. </author> <title> Combinatory Reduction Systems. </title> <publisher> Mathematical Centre Tracts 127, Mathematisch Centrum, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: he 1 ; : : : ; e n i j n Of course, we should also extend the -calculus with the following notion of reduction: n i ) 39 In any case, care must be taken to preserve the Church-Rosser property when new ffi-rules are added to the -calculus <ref> [16, 39] </ref>. According to the Hindley-Rosen Lemma, the added ffi-rules must be shown to be Church-Rosser; moreover, they must commute with the existing fi-rule. In the thesis, we demonstrate our context-enriching schema only on the pure - calculi, but will use the applied -calculi in examples.
Reference: [40] <author> John Lamping. </author> <title> A unified system of parameterization for programming languages. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 316-326, </pages> <year> 1988. </year>
Reference-contexts: The difference has a profound effect on the philosophical view of software composition. In the view of Dami's N-calculus, as well as other extensions of the -calculus with name-based programming mechanisms such as records [19], label-selective -calculus [6], transparent data parameters 182 <ref> [36, 40] </ref>, and quasi-static procedures [42], composing programs is about passing named parameters among program components, a notion tied to the computational behavior of programs.
Reference: [41] <author> Peter J. Landin. </author> <title> The mechanical evaluation of expressions. </title> <journal> Computer Journal, </journal> <volume> 6(4) </volume> <pages> 308-320, </pages> <year> 1964. </year>
Reference-contexts: The reason is that each fi-substitution operation incurs potentially many ff-conversion steps to avoid variable capture. Many have come up with variations of the -calculus to facilitate efficient implementation <ref> [1, 14, 41, 56, 72] </ref>. In particular, in his AU-TOMATH project [15], de Bruijn uses a version of the -calculus in which each variable reference is replaced by its lexical address, which is the distance between the 131 variable reference and its binding -parameter.
Reference: [42] <author> Shinn-Der Lee and Daniel P. Friedman. </author> <title> Quasi-static scoping: Sharing variable bindings across multiple lexical scopes. </title> <booktitle> In Proceedings of the 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 479-492, </pages> <year> 1993. </year>
Reference-contexts: Unlike -parameters, -parameter variables are quasi-statically scoped <ref> [42] </ref>. The free occurrences of x i in e are not statically linked to the -parameter x i : x i ; they can be relinked . Such quasi-statically scoped -parameter variables facilitate the sought-after variable linking mechanism needed in incremental program construction. <p> It relies on the fact that the parameter variables x 1 ; : : : ; x n of fx 1 : x 1 ; : : : ; x n : x n g:e are quasi-statically scoped <ref> [42] </ref>. <p> The difference has a profound effect on the philosophical view of software composition. In the view of Dami's N-calculus, as well as other extensions of the -calculus with name-based programming mechanisms such as records [19], label-selective -calculus [6], transparent data parameters 182 [36, 40], and quasi-static procedures <ref> [42] </ref>, composing programs is about passing named parameters among program components, a notion tied to the computational behavior of programs.
Reference: [43] <author> Mark Leone and Peter Lee. </author> <title> Lightweight run-time code generation. </title> <booktitle> In Proceedings of the ACM Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <year> 1994. </year>
Reference-contexts: Intuitively, the compiled code construction operations induced by our schema are run-time operations. It is therefore conceivable that they require run-time code generation <ref> [20, 43] </ref>. We are inclined to believe that some form of run-time code generation is inevitable when efficiency is a relevant issue.
Reference: [44] <author> John McCarthy. </author> <title> Towards a mathematical science of computation. </title> <booktitle> In Proceedings of IFIP Congress 63, </booktitle> <pages> pages 21-28. </pages> <publisher> North-Holland, </publisher> <year> 1963. </year>
Reference-contexts: So, to express in C a compiler for the -calculus, all we need then is an abstract source code representation <ref> [44] </ref> for -contexts: * for the source code encoding of e, there are predicates to tell whether e is an identifier, an abstraction, or an application; * there are mechanisms to break the encoding of each composite evolved -context e down to (the encoding of) its components; and * there is
Reference: [45] <editor> John McCarthy et al. </editor> <title> LISP 1.5 Programmer's Manual. </title> <publisher> MIT Press, </publisher> <year> 1965. </year>
Reference-contexts: It is therefore possible to express the compilation of the CC-contexts in the CC-calculus. That is, there is a self-compiler [8, 52] for CC. Furthermore, we can show that the self-compiler is metacir-cular <ref> [45] </ref>. That is, each category of evolved CC-contexts can be translated directly into the machine code of the same category of CC-terms, no auxiliary notions or mechanisms are necessary. <p> of the compilation of the context's ([[ ]] c -encoded) components: C [[x:e]] c = lam x (C [[e]] c ) C [[:e]] c = phi (C [[e]] c ) 102 The compiler C is metacircular since it translates each category of evolved CC-contexts into the same category of CC-terms <ref> [45] </ref>: Theorem 5.3 Let e be an evolved CC-context and z 1 ; : : : ; z m be the applied identifiers of e.
Reference: [46] <author> Bertrand Meyer. </author> <title> Eiffel the Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: A module is an abstract class <ref> [46, 68] </ref>. It is a mutually recursive scope consisting of definitions and declarations. Definitions bind names to values. Declarations specify pure virtual attribute references. Inheritance covers the notions of code reuse and late binding. Module operators reuse preexisting modules to produce new modules.
Reference: [47] <author> James S. Miller and Guillermo J. Rozas. </author> <title> Free variables and first-class environments. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 4(2) </volume> <pages> 107-141, </pages> <year> 1991. </year>
Reference-contexts: In the following section we demonstrate one such programming mechanism, namely, first-class environments <ref> [47] </ref>. 3.8.2 First-Class Environments Our notion of an environment is a finite function mapping program symbols x to compiled code :e represented as the sequence [hx 1 ; 1 :e 1 i; : : : ; hx n ; n :e n i] where each pair hx i ; i :e <p> Hence, we can define a run-time evaluator eval in the style of Lisp [66] and MIT Scheme <ref> [47] </ref> as follows: eval xy:(load (link y x)) where the arguments x and y should denote a piece of compiled code and a first-class environment, respectively.
Reference: [48] <author> Robert Milne and Christopher Strachey. </author> <title> A Theory of Programming Language Semantics. </title> <publisher> Chapman and Hall, </publisher> <year> 1976. </year>
Reference-contexts: As a mathematical notion, it is used for defining programming language semantics. A case in point is the denotational approach of Scott and Strachey <ref> [48, 61, 67] </ref>. As a computational notion, the -calculus is Turing-complete; every computable function is definable in the -calculus [38]. As a programming notion, its features form the core of many contemporary high-level programming languages [21, 49].
Reference: [49] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year> <month> 192 </month>
Reference-contexts: A case in point is the denotational approach of Scott and Strachey [48, 61, 67]. As a computational notion, the -calculus is Turing-complete; every computable function is definable in the -calculus [38]. As a programming notion, its features form the core of many contemporary high-level programming languages <ref> [21, 49] </ref>. One of the reasons that make -calculus the quintessential representative used in conveying new programming notions is its concise and expressive syntax. In our case, the -calculus also happens to exhibit all the obstacles to incremental program construction that are inherent to statically-scoped languages. <p> They are more efficient to implement directly than their syntactically expanded counterparts [56]. Furthermore, in a statically-typed language, they are essential to polymorphic type inference because the scope of each denotation term is known statically <ref> [49] </ref>. Most importantly, they occur so often in programs that they deserve a special status. In our work, we take the best of both views. Semantically, we regard definitions as syntactic sugar to avoid introducing additional mechanisms to explain their computational behavior.
Reference: [50] <author> John C. Mitchell. </author> <title> Type systems for programming languages. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Volume B, </volume> <pages> pages 365-458. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: It means that our incremental compiled code construction operations must also perform type checking (or type in-ferencing) duties. Since there is a diverse array of type systems <ref> [18, 50] </ref>, it is a major undertaking to study the various typing disciplines they impose on our incremental compiled code constructors. An extensive exploration of the typing of our context-enriched calculi is at the top of our agenda.
Reference: [51] <author> John C. Mitchell, Furio Honsell, and Kathleen Fisher. </author> <title> A lambda calculus of objects and method specialization. </title> <booktitle> In Proceedings of the 8th IEEE Symposium on Logic In Computer Science, </booktitle> <year> 1993. </year>
Reference-contexts: Moreover, virtual references can decide by themselves on which of the many versions of future modifications to 22 take as their permanent denotation. All in all, we are able to show that object-oriented programming can be modeled with compile-time linking, rather than run-time environment lookup or record field selection <ref> [2, 5, 22, 23, 24, 32, 37, 51, 57, 60, 74] </ref>. Lisp [66] and its dialects such as Scheme [4, 21] employ an interactive evaluator as a means for incremental program development. An interactive evaluator uses an ever-growing environment to keep track of the bindings produced by previously evaluated define-expressions. <p> There are many issues concerning our context-enhancing schema left unexplored. Among them are: typing The typing of object-oriented programming languages is currently a very active research area <ref> [2, 32, 51, 57] </ref>. Some of the crucial notions underlying the programming paradigm are shared by our context-enriched calculi. <p> Furthermore, since some of the crucial notions underlying object-oriented programming are shared by our context-enriched calculi, 185 it is tempting to investigate if our incremental program construction mechanisms simplify or complicate typing issues of object-oriented programming languages <ref> [2, 32, 51, 57] </ref>. 9.3.3 Garbage Collecting Redundant Parameters In the context-enriched -calculi we rely on the meta-notion of indistinguishability ( ) to remove redundant parameters from free identifier abstractions. We are wondering if such redundant parameters can be removed without resorting to indistinguishability. A positive answer seems reachable.
Reference: [52] <author> Torben . Mogensen. </author> <title> Efficient self-interpretation in lambda calculus. </title> <type> Technical Report, </type> <institution> DIKU, University of Copenhagen, </institution> <year> 1994. </year>
Reference-contexts: The context-enriched version of a -calculus is capable of compiling the -contexts incrementally, a goal designed into our schema. It is therefore possible to express the compilation of the CC-contexts in the CC-calculus. That is, there is a self-compiler <ref> [8, 52] </ref> for CC. Furthermore, we can show that the self-compiler is metacir-cular [45]. That is, each category of evolved CC-contexts can be translated directly into the machine code of the same category of CC-terms, no auxiliary notions or mechanisms are necessary. <p> That is, CC is a "fixpoint" of our design methodology. 5.4 Metacircular Self-Compilation As shown in Chapter 4, the context-enriched version of a calculus is capable of compiling the original calculus. Here, we demonstrate the compilation of CC in the 101 CC-calculus itself, thus yielding a self-compiler for CC <ref> [8, 52] </ref>.
Reference: [53] <author> Martin Odersky, Dan Rabin, and Paul Hudak. </author> <title> Call by name, assignments, and the lambda calculus. </title> <booktitle> In Proceedings of the 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 43-56, </pages> <year> 1993. </year>
Reference-contexts: Each of them possesses particular idiosyncrasies inherent to the type of computation it is intended to model. Examples are -calculi that employ call-by-name or call-by-value evaluation strategies [58], -calculi that include constants and sophisticated datatypes [35], -calculi that embody imperative features such as assignments <ref> [29, 53] </ref> and continuations [29]. Our schema applies to them all. Of concern to us is how to construct programs incrementally. The way computation is actually modeled has little impact on our schema.
Reference: [54] <author> Atsushi Ohori. </author> <title> A compilation method for ML-style polymorphic record calculi. </title> <booktitle> In Proceedings of the 19th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 154-165, </pages> <year> 1992. </year>
Reference: [55] <author> D. L. Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> CACM, </journal> <volume> 15(12) </volume> <pages> 1053-1058, </pages> <year> 1972. </year>
Reference-contexts: The linking device at the heart of incremental program construction is still the same old variable capture, however. 6.4 Modules As mentioned before, definition abstractions h"; i:d are substitutes for definitions d as first-class citizens. They are modules <ref> [55, 73] </ref> represented as a distinct category of compiled code. The defining variables of d are exported via the parameter specification "; the parameters specified in are the import variables of d. The compiled code operator let is the means to express module importation.
Reference: [56] <editor> Simon L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: our schema simplifies or complicates typing issues. implementation Efficient implementation should not be the deciding factor of the practicality of our schema, but a stronger case can be presented if we have one. (Build it and they will come.) Many of the clever implementation techniques employed in some popular functional <ref> [17, 27, 56, 62] </ref> and object-oriented languages [20, 25, 26] may be applicable to our context-enriched calculi. The above issues, as well as related work, are discussed in Chapter 9. <p> There are compelling reasons to take definitions as core constructs of a programming language, however. They are more efficient to implement directly than their syntactically expanded counterparts <ref> [56] </ref>. Furthermore, in a statically-typed language, they are essential to polymorphic type inference because the scope of each denotation term is known statically [49]. Most importantly, they occur so often in programs that they deserve a special status. In our work, we take the best of both views. <p> The reason is that each fi-substitution operation incurs potentially many ff-conversion steps to avoid variable capture. Many have come up with variations of the -calculus to facilitate efficient implementation <ref> [1, 14, 41, 56, 72] </ref>. In particular, in his AU-TOMATH project [15], de Bruijn uses a version of the -calculus in which each variable reference is replaced by its lexical address, which is the distance between the 131 variable reference and its binding -parameter.
Reference: [57] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-248, </pages> <year> 1994. </year>
Reference-contexts: Moreover, virtual references can decide by themselves on which of the many versions of future modifications to 22 take as their permanent denotation. All in all, we are able to show that object-oriented programming can be modeled with compile-time linking, rather than run-time environment lookup or record field selection <ref> [2, 5, 22, 23, 24, 32, 37, 51, 57, 60, 74] </ref>. Lisp [66] and its dialects such as Scheme [4, 21] employ an interactive evaluator as a means for incremental program development. An interactive evaluator uses an ever-growing environment to keep track of the bindings produced by previously evaluated define-expressions. <p> There are many issues concerning our context-enhancing schema left unexplored. Among them are: typing The typing of object-oriented programming languages is currently a very active research area <ref> [2, 32, 51, 57] </ref>. Some of the crucial notions underlying the programming paradigm are shared by our context-enriched calculi. <p> Furthermore, since some of the crucial notions underlying object-oriented programming are shared by our context-enriched calculi, 185 it is tempting to investigate if our incremental program construction mechanisms simplify or complicate typing issues of object-oriented programming languages <ref> [2, 32, 51, 57] </ref>. 9.3.3 Garbage Collecting Redundant Parameters In the context-enriched -calculi we rely on the meta-notion of indistinguishability ( ) to remove redundant parameters from free identifier abstractions. We are wondering if such redundant parameters can be removed without resorting to indistinguishability. A positive answer seems reachable.
Reference: [58] <author> Gordon D. Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: There are many variants of the untyped -calculus. Each of them possesses particular idiosyncrasies inherent to the type of computation it is intended to model. Examples are -calculi that employ call-by-name or call-by-value evaluation strategies <ref> [58] </ref>, -calculi that include constants and sophisticated datatypes [35], -calculi that embody imperative features such as assignments [29, 53] and continuations [29]. Our schema applies to them all. Of concern to us is how to construct programs incrementally. The way computation is actually modeled has little impact on our schema.
Reference: [59] <author> Gordon D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1981. </year> <month> 193 </month>
Reference-contexts: In the second part of this thesis we apply the schema to intricate variable defining and referencing mechanisms to provide the advanced linking capabilities required by popular incremental programming paradigms. 18 1.6 Context-Enriched Calculus of Definitions We extend the -calculus with definitions d, which are more elaborate variable defining mechanisms <ref> [59] </ref>: e ::= x j x:e j e e j let d in e The computational behavior of the new -terms let d in e can be explained in terms of the following syntactic expansion: let fx 1 = e 1 ; : : : ; x n = e n <p> we arrive at an elegant and extensible alternative that is a module manipulation calculus in which linking is modeled by, as expected, variable capture. 6.1 Definitions The variable defining mechanisms of concern are adapted from Plotkin's work in which he uses them to illustrate his structural approach to operational semantics <ref> [59] </ref>.
Reference: [60] <author> Uday S. Reddy. </author> <title> Objects as closures: Abstract semantics of object-oriented languages. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 289-297, </pages> <year> 1988. </year>
Reference-contexts: Moreover, virtual references can decide by themselves on which of the many versions of future modifications to 22 take as their permanent denotation. All in all, we are able to show that object-oriented programming can be modeled with compile-time linking, rather than run-time environment lookup or record field selection <ref> [2, 5, 22, 23, 24, 32, 37, 51, 57, 60, 74] </ref>. Lisp [66] and its dialects such as Scheme [4, 21] employ an interactive evaluator as a means for incremental program development. An interactive evaluator uses an ever-growing environment to keep track of the bindings produced by previously evaluated define-expressions. <p> Consequently, if the denotation of the variable y is e, then the denotation of the virtual reference x is also e, which is expressed in our system as a provisionally-instantiated relinkable x ~ e. 167 Our semantics of inheritance is the same fixpoint semantics of Kamin [37], Reddy <ref> [60] </ref>, and Cook and Palsberg [22]. In their descriptions of objects, late binding intra-object virtual attribute references are modeled as run-time variable lookups from the environment denoted by some pseudo-variable self. Moreover, the same pseudo-variable self is overloaded to explain object self-reference as well. <p> Jigsaw shares our view that modules and objects are closely related incremental programming concepts that should be supported in a single system. The main difference lies in the way virtual attribute references are resolved. Jigsaw's semantics is based upon a denotational model of inheritance <ref> [22, 60] </ref> where modules are modeled as record generators, which are functions from records to records, and attribute references are translated into record field selections. Module manipulation operators are then defined as operations on such record generators. These record generator operations are responsible for building records incrementally.
Reference: [61] <author> David A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, </publisher> <year> 1986. </year>
Reference-contexts: As a mathematical notion, it is used for defining programming language semantics. A case in point is the denotational approach of Scott and Strachey <ref> [48, 61, 67] </ref>. As a computational notion, the -calculus is Turing-complete; every computable function is definable in the -calculus [38]. As a programming notion, its features form the core of many contemporary high-level programming languages [21, 49].
Reference: [62] <author> Zhong Shao and Andrew W. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 150-161, </pages> <year> 1994. </year>
Reference-contexts: our schema simplifies or complicates typing issues. implementation Efficient implementation should not be the deciding factor of the practicality of our schema, but a stronger case can be presented if we have one. (Build it and they will come.) Many of the clever implementation techniques employed in some popular functional <ref> [17, 27, 56, 62] </ref> and object-oriented languages [20, 25, 26] may be applicable to our context-enriched calculi. The above issues, as well as related work, are discussed in Chapter 9. <p> For instance, it is easy 184 to determine the binding parameter of a statically-scoped variable reference when we know enough about the context in which it is used. Consequently, such a variable reference can be translated into a simple lexical address relative to the closure representation of some -abstraction <ref> [17, 27, 62] </ref>. Adapting such an implementation technique to our free identifier abstractions becomes a non-trivial task since the context of the free identifier references has yet to be built. It is therefore impossible to translate them into some fixed lexical addresses beforehand.
Reference: [63] <editor> Bruce Shriver and Peter Wegner. </editor> <booktitle> Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference: [64] <author> Alan Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming: Systems, Languages and Applications, </booktitle> <pages> pages 38-45, </pages> <year> 1986. </year>
Reference-contexts: Consequently, any future changes to the dist-attribute of bMP does not have a rippling effect on the closer-attribute. 8.1.5 Discussions To summarize, objects are modules with relinkables. Modules provide the information hiding facilities needed for an object system <ref> [64, 65] </ref>. Incremental module combination operations such as moverride are the means for reusing existing objects to form new objects. This style of inheritance is often referred to as mixin-based [11]. 166 The feature unique to our object system is the incorporation of relinkables to model late binding virtual references.
Reference: [65] <author> Alan Snyder. </author> <title> Inheritance and the development of encapsulation software components. </title> <booktitle> In [63]. </booktitle>
Reference-contexts: Consequently, any future changes to the dist-attribute of bMP does not have a rippling effect on the closer-attribute. 8.1.5 Discussions To summarize, objects are modules with relinkables. Modules provide the information hiding facilities needed for an object system <ref> [64, 65] </ref>. Incremental module combination operations such as moverride are the means for reusing existing objects to form new objects. This style of inheritance is often referred to as mixin-based [11]. 166 The feature unique to our object system is the incorporation of relinkables to model late binding virtual references.
Reference: [66] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language, Second Edition. </title> <publisher> Digital Press, </publisher> <year> 1990. </year>
Reference-contexts: All in all, we are able to show that object-oriented programming can be modeled with compile-time linking, rather than run-time environment lookup or record field selection [2, 5, 22, 23, 24, 32, 37, 51, 57, 60, 74]. Lisp <ref> [66] </ref> and its dialects such as Scheme [4, 21] employ an interactive evaluator as a means for incremental program development. An interactive evaluator uses an ever-growing environment to keep track of the bindings produced by previously evaluated define-expressions. <p> Hence, we can define a run-time evaluator eval in the style of Lisp <ref> [66] </ref> and MIT Scheme [47] as follows: eval xy:(load (link y x)) where the arguments x and y should denote a piece of compiled code and a first-class environment, respectively. <p> Indeed, the notion of relinkables covers many commonly found variable referencing mechanisms. For instance, a statically-scoped variable reference can be seen merely as a degenerate relinkable that cannot be relinked. A Common Lisp optional keyword parameter <ref> [66] </ref> is a relinkable that has been associated with a default denotation and can be relinked once to its optional denotation. A late binding C++ virtual reference [68] is a relinkable that can be relinked an arbitrary number of times. Relinkables may seem counterintuitive to static scope. <p> To summarize, modeling virtual references as relinkables is desirable because of the simplicity, clarity, and flexibility they provide. 8.2 Interactive Programming Lisp <ref> [66] </ref> and its dialects such as Scheme [4, 21] employ an interactive evaluator as a means for incremental program development. Conceptually, an interactive evaluator uses an ever-growing interactive environment to keep track of the results produced by previously evaluated define-expressions.
Reference: [67] <author> Joseph E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1981. </year>
Reference-contexts: As a mathematical notion, it is used for defining programming language semantics. A case in point is the denotational approach of Scott and Strachey <ref> [48, 61, 67] </ref>. As a computational notion, the -calculus is Turing-complete; every computable function is definable in the -calculus [38]. As a programming notion, its features form the core of many contemporary high-level programming languages [21, 49]. <p> Last but not least, we can determine if x and y are the same identifier by comparing their encodings [[x]] c and [[y]] c using the predicate eq? defined in Section 3.8.1. The representation schema [[ ]] c is also generative <ref> [67] </ref>, the representation of an evolved -context is constructible from the encodings of the context's components. A generative encoding schema allows for incremental construction of source code. <p> None of them explicitly supports incremental code construction. To simplify the discussion, we take the liberty of altering their syntax in the style of our context calculi. 9.2.1 Denotational Semantics of Lambda Calculus The direct style denotational semantics of the -calculus <ref> [67] </ref> shown in Figure 9.1 constitutes a view of incremental program construction involving computational fi-steps and environment lookups. <p> The meaning E [[e]] of (the syntax [[e]] of) a -term e is usually defined in an abstract mathematical model of the -calculus known as domains <ref> [67] </ref>. Here, in contrast to common practice, we elect to remain metacircular; that is, E [[e]] is merely another -term.
Reference: [68] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language, second edition. </title> <publisher> Addison Wesley, </publisher> <year> 1991 </year>
Reference-contexts: A relinkable variable reference [y 2 ; x 2 ; y 1 ; x 1 ] is a virtual reference that can be linked to either of the two attributes denoted by x or y. Hence, unlike Smalltalk [30], but similar to C++ <ref> [68] </ref>, our object system does not rely on some pseudo-variable named self to accomplish intra-object virtual attribute references. Instead, the pseudo-variable is strictly reserved for the purpose of object self-reference. Furthermore, our virtual references can be sealed off individually so that their links are not subject to future modifications. <p> A Common Lisp optional keyword parameter [66] is a relinkable that has been associated with a default denotation and can be relinked once to its optional denotation. A late binding C++ virtual reference <ref> [68] </ref> is a relinkable that can be relinked an arbitrary number of times. Relinkables may seem counterintuitive to static scope. Indeed, as indicated above, relinkables exhibit behavior that strongly resembles dynamically-scoped variables since their linking relation does not appear to be fixed. <p> A module is an abstract class <ref> [46, 68] </ref>. It is a mutually recursive scope consisting of definitions and declarations. Definitions bind names to values. Declarations specify pure virtual attribute references. Inheritance covers the notions of code reuse and late binding. Module operators reuse preexisting modules to produce new modules.
Reference: [69] <author> Masako Takahashi. </author> <title> Parallel reductions in -calculus. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 7 </volume> <pages> 113-123, </pages> <year> 1989. </year> <month> 194 </month>
Reference-contexts: There are many ways to prove the theorem. We will not repeat them here but refer the interested reader to the literature <ref> [7, 69] </ref>. 2.6 Programming with Lambda Calculus Programming with the -calculus is programming with functions.
Reference: [70] <author> Carolyn Talcott. </author> <title> Binding structures. </title> <editor> In Vladimir Lifschitz, editor, </editor> <booktitle> Artificial Intelligence and Mathematical Theory of Computation, </booktitle> <pages> pages 427-448. </pages> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: For comparison, S ((x:x) h) (x:x) S (h) and ! [S (y)=x]S (h) 4.3.1 Binding Structures The second simulation of -contexts is based on Talcott's binding structures <ref> [70, 71] </ref>, which combine -contexts and -terms at the meta-langauge level.
Reference: [71] <author> Carolyn Talcott. </author> <title> A theory of binding structures and applications to rewriting. </title> <journal> Theoretical Computer Science, </journal> <volume> 112 </volume> <pages> 99-143, </pages> <year> 1993. </year>
Reference-contexts: For comparison, S ((x:x) h) (x:x) S (h) and ! [S (y)=x]S (h) 4.3.1 Binding Structures The second simulation of -contexts is based on Talcott's binding structures <ref> [70, 71] </ref>, which combine -contexts and -terms at the meta-langauge level.
Reference: [72] <author> David A. Turner. </author> <title> A new implementation technique for applicative languages. </title> <journal> Software Practice and Experience, </journal> <volume> 9 </volume> <pages> 31-49, </pages> <year> 1979. </year>
Reference-contexts: The reason is that each fi-substitution operation incurs potentially many ff-conversion steps to avoid variable capture. Many have come up with variations of the -calculus to facilitate efficient implementation <ref> [1, 14, 41, 56, 72] </ref>. In particular, in his AU-TOMATH project [15], de Bruijn uses a version of the -calculus in which each variable reference is replaced by its lexical address, which is the distance between the 131 variable reference and its binding -parameter.
Reference: [73] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: By assigning a new category of compiled code abstractions for evolved D-contexts, we have abstractions that import and export variables through identifiers (external names). They are modules <ref> [73] </ref>. The context-enriched calculus of definitions DD is therefore a module manipulation language. <p> The linking device at the heart of incremental program construction is still the same old variable capture, however. 6.4 Modules As mentioned before, definition abstractions h"; i:d are substitutes for definitions d as first-class citizens. They are modules <ref> [55, 73] </ref> represented as a distinct category of compiled code. The defining variables of d are exported via the parameter specification "; the parameters specified in are the import variables of d. The compiled code operator let is the means to express module importation.

References-found: 73

