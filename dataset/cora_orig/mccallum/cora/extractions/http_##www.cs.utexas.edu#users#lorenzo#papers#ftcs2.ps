URL: http://www.cs.utexas.edu/users/lorenzo/papers/ftcs2.ps
Refering-URL: http://www.cs.utexas.edu/users/lorenzo/publications.html
Root-URL: 
Title: Nonblocking and Orphan-Free Message Logging Protocols  
Author: Lorenzo Alvisi Bruce Hoppe Keith Marzullo 
Address: Ithaca NY 14853  
Affiliation: Cornell University Department of Computer Science  
Abstract: Currently existing message logging protocols demonstrate a classic pessimistic vs. optimistic tradeoff. We show that the optimistic-pessimistic tradeoff is not inherent to the problem of message logging. We construct a message-logging protocol that has the positive features of both optimistic and pessimistic protocols: our protocol prevents orphans and allows simple failure recovery; however, it requires no blocking in failure-free runs. Furthermore, this protocol does not introduce any additional message overhead as compared to one implemented for a system in which messages may be lost but processes do not crash. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Lorenzo Alvisi, Bruce Hoppe, and Keith Marzullo. </author> <title> Non-blocking and orphan-free message logging protocols. </title> <type> Technical Report TR92-1317, </type> <institution> Cornell University Department of Computer Science, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: Section 5 discusses the performance of an implementation our protocol, and Section 6 concludes the paper. Due to space limitations, there are no proofs about the correctness of the protocols in this paper. The interested reader can find the proofs in <ref> [1] </ref>. 2 System Model We assume that processes communicate only by exchanging messages, and that a process never sends a message to itself. The system is asynchronous: there exists no bound on the relative speeds of processes, no bound on message transmission delays, and no global time source.
Reference: [2] <author> Anita Borg, J. Baumbach, and S. Glazer. </author> <title> A message system supporting fault tolerance. </title> <booktitle> In Proceedings of the Symposium on Operating Systems Principles, </booktitle> <pages> pages 90-99. </pages> <publisher> ACM SIGOPS, </publisher> <month> October </month> <year> 1983. </year>
Reference-contexts: These two design decisionspessimistic vs. optimistic and receiver-based logging vs. sender-based loggingare independent. In particular, there exist pessimistic receiver-based logging protocols <ref> [2, 12] </ref>, optimistic receiver-based logging protocols [17, 15], pessimistic sender-based log ging protocols [9, 7] and optimistic sender-based logging protocols [9, 8]. All message logging protocols must address the problem of communication with the environment.
Reference: [3] <author> Navin Budhiraja, Keith Marzullo, Fred B. Schneider, and Sam Toueg. </author> <title> Primary-backup protocols: Lower bounds and optimal implementations. </title> <booktitle> In Proceedings of the Third IFIP Conference on Dependable Computing for Critical Applications, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: Message logging protocols are not the only techniques for making systems robust against process crashes. For example, active replication [14] or passive replication <ref> [3] </ref> are commonly-used techniques for masking failures more severe than crash failures.
Reference: [4] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots: determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: The collection of local states is a consistent global state if all pairs of states are mutually consistent <ref> [4] </ref>; 3 otherwise it is inconsistent. With message logging protocols, an inconsistent global state arises when a lost message occurs due to optimistic recovery. <p> Thus, in the act of recovering, it will send the same sequence of messages as before. Any duplicate message m sent during recovery is acknowledged and discarded if the destination has already received m. 4 3 This definition is different from that of <ref> [4] </ref> in that it is defined in terms of deliver events rather than receive events.
Reference: [5] <author> F. Cristian, B. Dancey, and J. Dehn. </author> <title> Fault-tolerance in the Advanced Automation System. </title> <booktitle> In Digest of Papers: 20th IEEE International Conference on Fault-Tolerant Computing. IEEE Computer Society, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: We are also examining how the message logging protocol can be further optimized by using the semantics of the application. For example, this research was first motivated by discussions with a group at IBM FSC in the AAS project <ref> [5] </ref>. In this system, processes are assumed to be usually functional and can recover by simply receiving new messages.
Reference: [6] <author> E. N. Elnozahy and W. Zwaenepoel. Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback and fast output commit. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41(5) </volume> <pages> 526-531, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: However, we are designing a protocol that can tolerate f 1 simultaneous crashes, implements the stable log property, and has the same efficiency as the protocol presented here. This generalized protocol is similar to the Manetho protocol <ref> [6] </ref> with the exception that in Application No P'back Full Half-run Full-run P'back P'back Log Scenario Log Only Log Recovery Recovery Size Ovhd Ovhd spray 11.8 13.9 14.7 7.5 15.4 1.6 18% 25% blast 11.0 12.4 13.7 8.4 16.2 3.0 13% 25% our protocol f is a parameter and in Manetho
Reference: [7] <author> D. B. Johnson. </author> <title> Distributed System Fault Tolerance Using Message Logging and Checkpointing. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> December </month> <year> 1989. </year> <note> Available as report COMP TR89-101. </note>
Reference-contexts: The receive sequence number can be piggybacked on the acknowledgement of message m, but the extra acknowledgement from the sender may require an additional message; and in pessimistic sender-based logging, the receiver still must block until it receives the final acknowledgement <ref> [7] </ref>. A further problem with sender-based logging is that multiple concurrent failures may make a process unable to recover its previous state even when a pessimistic protocol is used. <p> These two design decisionspessimistic vs. optimistic and receiver-based logging vs. sender-based loggingare independent. In particular, there exist pessimistic receiver-based logging protocols [2, 12], optimistic receiver-based logging protocols [17, 15], pessimistic sender-based log ging protocols <ref> [9, 7] </ref> and optimistic sender-based logging protocols [9, 8]. All message logging protocols must address the problem of communication with the environment. For input, the data from the environment must be stored in a location that is accessible for the purpose of replay. <p> On the other hand, blast needs, on average, to piggyback more information than spray on each message (P'back Size). Our message logging overhead of 25% (Log Ovhd) is comparable to performance figures of pessimistic sender-based logging <ref> [7] </ref>. It should be noted, however, that the measurements for sender-based logging refer to an application in which the protocol performs especially well, in that it does not have to block or send any extra messages.
Reference: [8] <author> D. B. Johnson. </author> <type> Personal communication, </type> <month> November </month> <year> 1992. </year>
Reference-contexts: These two design decisionspessimistic vs. optimistic and receiver-based logging vs. sender-based loggingare independent. In particular, there exist pessimistic receiver-based logging protocols [2, 12], optimistic receiver-based logging protocols [17, 15], pessimistic sender-based log ging protocols [9, 7] and optimistic sender-based logging protocols <ref> [9, 8] </ref>. All message logging protocols must address the problem of communication with the environment. For input, the data from the environment must be stored in a location that is accessible for the purpose of replay.
Reference: [9] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Sender-based message logging. </title> <booktitle> In Digest of Papers: 17 Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 14-19. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: Unfortunately, such a receiver-based protocol requires an implementation of stable storage that will survive the crash of the receiving process. Another choice, called sender-based logging, is to log each message m in the sender's volatile storage <ref> [9] </ref>. Doing so requires the receiver to tell the sender what receive sequence number was assigned to m. Furthermore, the receiver does not know that m is logged until it receives an extra acknowledgement from the sender indicating that the receive sequence number has been recorded. <p> These two design decisionspessimistic vs. optimistic and receiver-based logging vs. sender-based loggingare independent. In particular, there exist pessimistic receiver-based logging protocols [2, 12], optimistic receiver-based logging protocols [17, 15], pessimistic sender-based log ging protocols <ref> [9, 7] </ref> and optimistic sender-based logging protocols [9, 8]. All message logging protocols must address the problem of communication with the environment. For input, the data from the environment must be stored in a location that is accessible for the purpose of replay. <p> These two design decisionspessimistic vs. optimistic and receiver-based logging vs. sender-based loggingare independent. In particular, there exist pessimistic receiver-based logging protocols [2, 12], optimistic receiver-based logging protocols [17, 15], pessimistic sender-based log ging protocols [9, 7] and optimistic sender-based logging protocols <ref> [9, 8] </ref>. All message logging protocols must address the problem of communication with the environment. For input, the data from the environment must be stored in a location that is accessible for the purpose of replay. <p> Following <ref> [9] </ref>, a message m is partially logged if the four attributes m:source; m:dest; m:data; m:ssn are defined in L, and m is fully logged if all five attributes are defined in L. Finally, L p is the subset of messages m 2 L such that m:dest = p.
Reference: [10] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Recovery in distributed systems using optimistic message logging and checkpointing. </title> <journal> Journal of Algorithms, </journal> <volume> 11 </volume> <pages> 462-491, </pages> <year> 1990. </year>
Reference-contexts: Another design decision in message logging protocols is where each message is to be logged. An obvious choice is to log at the receiving process, since it is the receiving process that assigns the receive sequence number to an incoming message <ref> [17, 10] </ref>. Unfortunately, such a receiver-based protocol requires an implementation of stable storage that will survive the crash of the receiving process. Another choice, called sender-based logging, is to log each message m in the sender's volatile storage [9].
Reference: [11] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Hence, the order in which a process receives messages is nondeterministic. The execution of a system of n processes is represented by a run, which is an irreflexive partial ordering of the send events, receive events and delivery events ordered by potential causality <ref> [11] </ref>. Delivery events are local to a process and represent the delivery of a received message to the application. For any message m from process p to process q, q delivers m only if it has received m, and q delivers m no more than once.
Reference: [12] <author> M.L. Powell and D.L. Presotto. </author> <title> Publishing: A reliable broadcast communication mechanism. </title> <booktitle> In Proceedings of the Ninth Symposium on Operating System Principles, </booktitle> <pages> pages 100-109. </pages> <publisher> ACM SIGOPS, </publisher> <month> October </month> <year> 1983. </year>
Reference-contexts: These two design decisionspessimistic vs. optimistic and receiver-based logging vs. sender-based loggingare independent. In particular, there exist pessimistic receiver-based logging protocols <ref> [2, 12] </ref>, optimistic receiver-based logging protocols [17, 15], pessimistic sender-based log ging protocols [9, 7] and optimistic sender-based logging protocols [9, 8]. All message logging protocols must address the problem of communication with the environment.
Reference: [13] <author> Fred B. Schneider. </author> <title> Byzantine generals in action: Implementing fail-stop processors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(2) </volume> <pages> 145-154, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: For any message m from process p to process q, q delivers m only if it has received m, and q delivers m no more than once. We assume a fail-stop failure model for the processes <ref> [13] </ref>. We assume channels to be FIFO, in that if process p sends m 1 and then m 2 to process q, then q will not receive m 2 before receiving m 1 .
Reference: [14] <author> Fred B. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> Computing Surveys, </journal> <volume> 22(3) </volume> <pages> 299-319, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: When a process crashes, a new process is created, given the appropriate recorded local state, and then sent the logged messages in the order they were originally received. Message logging protocols are not the only techniques for making systems robust against process crashes. For example, active replication <ref> [14] </ref> or passive replication [3] are commonly-used techniques for masking failures more severe than crash failures.
Reference: [15] <author> A.P. Sistla and J.L. Welch. </author> <title> Efficient distributed recovery using message logging. </title> <booktitle> In Proceedings of the Eighth Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 223-238. </pages> <publisher> ACM SIGACT/SIGOPS, </publisher> <month> August </month> <year> 1989. </year>
Reference-contexts: These two design decisionspessimistic vs. optimistic and receiver-based logging vs. sender-based loggingare independent. In particular, there exist pessimistic receiver-based logging protocols [2, 12], optimistic receiver-based logging protocols <ref> [17, 15] </ref>, pessimistic sender-based log ging protocols [9, 7] and optimistic sender-based logging protocols [9, 8]. All message logging protocols must address the problem of communication with the environment. For input, the data from the environment must be stored in a location that is accessible for the purpose of replay.
Reference: [16] <author> R. E. Strom, D. F. Bacon, and S. A. Yemini. </author> <title> Volatile logging in n-fault-tolerant distributed systems. </title> <booktitle> In Proceedings of the Eighteenth Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 44-49, </pages> <year> 1988. </year>
Reference-contexts: The result is similar to the null logging technique described in <ref> [16] </ref>. Process p logs receive sequence numbers in order to record the nondeterministic characteristics of a run. Since channels are FIFO, however, p need only log the order in which p interleaves messages from different parents.
Reference: [17] <author> R. E. Strom and S. Yemeni. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: For any message m delivered by process p, its receive sequence number, denoted m:rsn, represents the order in which m was delivered: m:rsn = ` if m is the ` th message delivered by p <ref> [17] </ref>. <p> Hence, process q would no longer be consistent with p once q delivers m 0 . Such a message m is called a lost message, message m 0 an orphan message and the state of process q an orphan state <ref> [17] </ref>. Protocols that can create orphan states are called optimistic because the likelihood of creating an orphan state is (hopefully) small. A pessimistic protocol is one in which each process p never sends a message m 0 until it knows that all messages delivered before sending m 0 are logged. <p> Another design decision in message logging protocols is where each message is to be logged. An obvious choice is to log at the receiving process, since it is the receiving process that assigns the receive sequence number to an incoming message <ref> [17, 10] </ref>. Unfortunately, such a receiver-based protocol requires an implementation of stable storage that will survive the crash of the receiving process. Another choice, called sender-based logging, is to log each message m in the sender's volatile storage [9]. <p> These two design decisionspessimistic vs. optimistic and receiver-based logging vs. sender-based loggingare independent. In particular, there exist pessimistic receiver-based logging protocols [2, 12], optimistic receiver-based logging protocols <ref> [17, 15] </ref>, pessimistic sender-based log ging protocols [9, 7] and optimistic sender-based logging protocols [9, 8]. All message logging protocols must address the problem of communication with the environment. For input, the data from the environment must be stored in a location that is accessible for the purpose of replay.
References-found: 17

