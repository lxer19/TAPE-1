URL: http://www.cs.mu.oz.au/tr_db/mu_97_05.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: (lee@cs.mu.OZ.AU, http://www.cs.mu.oz.au/~lee)  
Title: A three-valued declarative debugging scheme  
Author: Lee Naish 
Address: Parkville, Victoria 3052 Australia  
Affiliation: Department of Computer Science University of Melbourne  
Pubnum: Technical Report 97/5  
Abstract: Declarative debugging has many advantages over conventional approaches to debugging for logic and functional programs. This paper extends a previously defined scheme for declarative debugging in which computations were considered either correct or erroneous. We argue that a third value, "inadmissible", should be supported and show how this can be done. Two classes of bugs are defined: one equivalent to the bugs defined by the two valued scheme, the other associated with inadmissibility. It is shown how different instances of the scheme can be used to diagnose type errors, mode errors, violated assertions and abnormal termination as well as the more familiar classes of bugs detected by declarative debuggers. Consequences for the semantics of logic programs and how type schemes can be reconstructed using three valued logic are briefly addressed. Keywords: logic programming, declarative debugging, types, modes, assertions, abnormal termination, three valued logic, semantics 
Abstract-found: 1
Intro-found: 1
Reference: [BM95] <author> J. Boye and J. Maluszynski. </author> <title> Two aspects of directional types. </title> <editor> In Leon Sterling, editor, </editor> <booktitle> Proceedings of the Twelfth International Conference on Logic Programming, </booktitle> <pages> pages 747-761, </pages> <address> Kanagawa, Japan, </address> <month> June </month> <year> 1995. </year>
Reference: [DM88] <author> Wlodzimierz Drabent and Jan Maluszynski. </author> <title> Inductive assertions method for logic programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 133-155, </pages> <year> 1988. </year>
Reference-contexts: Nevertheless, types allow us to diagnose the error better. 5.3 Assertions As discussed in [Nai93], types in this scheme can be used in a similar way to assertions in imperative languages. Other forms of assertions have also been proposed for logic programs <ref> [DM88] </ref>. These assertions can express things such as a certain argument is a variable at the time of a call, which cannot be expressed by the type scheme. The standard top-down left to right execution of Prolog is assumed since this meta-level information depends on the execution order.
Reference: [DNTM88] <author> Wlodek Drabent, Simin Nadjm-Tehrani, and Jan Maluszynski. </author> <title> The use of assertions in algorithmic debugging. </title> <booktitle> In Proceedings of the 1988 International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 573-581, </pages> <address> Tokyo, Japan, </address> <month> December </month> <year> 1988. </year>
Reference-contexts: This is the basis for our current work. We also note the existence of debuggers which allow "don't know" answers to questions <ref> [DNTM88] </ref>. This is a desirable feature but is not related to the issue of inadmissibility. It just allows the user to avoid saying which of two truth values is associated with a node. <p> The oset_max node shown in italics would be considered erroneous in the two valued scheme but inadmissible in the three valued scheme. Using the two valued scheme, one explanation is that oset_max ([2,3,1],Y) misses the answer Y=3 (the oset_max node is buggy). See [Nai97] or <ref> [DNTM88] </ref> for a more technical description of this class of bugs. The other explanation is to say that missing the answer Y=3 is correct since the list is not sorted (the oset_max node is correct and hence ltmax is buggy).
Reference: [FBJ88] <author> Melvin Fitting and Marion Ben-Jacob. </author> <title> Stratified and three-valued logic programming semantics. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Proceedings of the Fifth International Conference/Symposium on Logic Programming, </booktitle> <pages> pages 1054-1069, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference: [Kun87] <author> Kenneth Kunen. </author> <title> Negation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(4) </volume> <pages> 289-308, </pages> <month> December </month> <year> 1987. </year>
Reference: [Nai92] <author> Lee Naish. </author> <title> Types and the intended meaning of logic programs. </title> <editor> In Frank Pfenning, editor, </editor> <booktitle> Types in logic programming, </booktitle> <pages> pages 189-216. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1992. </year>
Reference-contexts: In general, calls which violate assumptions must be considered true if they succeed and false if they fail <ref> [Nai92] </ref>. Thus the intended interpretation must depend on the implementation rather than the other way around. It is not possible to first decide on a simple intuitive intended behaviour (semantics) for the program then derive an efficient implementation. We now briefly examine another example where sortedness is important. <p> Instead, the intended interpretation should capture the fact that these calls should never occur. Some early work on declarative debugging introduced the idea of inadmissible calls [Per86], though no declarative meaning was given. Subsequent work built on these ideas [PC88] and work on types <ref> [Nai92] </ref> gave a declarative reconstruction of this idea, identifying inadmissible calls with ill-typed atoms (where types could be defined using arbitrary predicates). This is the basis for our current work. We also note the existence of debuggers which allow "don't know" answers to questions [DNTM88]. <p> The debugger above simply returns all the nodes using backtracking. 5 Instances of the scheme We now present several instances of the three-valued debugging scheme to illustrate its usefulness and flexibility. 5.1 Types | wrong answers A very general approach to types in logic programming is presented in <ref> [Nai92] </ref>. The main motivation was to clarify the intended declarative meaning of programs and reconcile the 5 fact that typical logic programs have atoms which succeed even though they are not true in the intended interpretation (for example, calls to merge where arguments are not lists). <p> That is, the type checks need not be executed at runtime. A definite program is type correct if for every ground clause instance with a well typed head and a body which succeeds, the body is well typed <ref> [Nai92] </ref>. The suggested type definition language was Horn clauses. This allows definition of the usual classes of types such as lists and trees and also allows more complex "types" to be defined, such as sorted lists. <p> Note that despite the ill-typed call, the clause is type correct. The bug can only lead to missing answers, not wrong answers, and type correctness is related to wrong answers (when negation is present there is a stricter definition <ref> [Nai92] </ref>). Nevertheless, types allow us to diagnose the error better. 5.3 Assertions As discussed in [Nai93], types in this scheme can be used in a similar way to assertions in imperative languages. Other forms of assertions have also been proposed for logic programs [DM88].
Reference: [Nai93] <author> Lee Naish. </author> <title> Verification of logic programs and imperative programs. </title> <editor> In Jean-Marie Jacquet, editor, </editor> <booktitle> Constructing logic programs, </booktitle> <pages> pages 143-164. </pages> <publisher> Wiley, </publisher> <address> Chichester, England, </address> <year> 1993. </year>
Reference-contexts: The bug can only lead to missing answers, not wrong answers, and type correctness is related to wrong answers (when negation is present there is a stricter definition [Nai92]). Nevertheless, types allow us to diagnose the error better. 5.3 Assertions As discussed in <ref> [Nai93] </ref>, types in this scheme can be used in a similar way to assertions in imperative languages. Other forms of assertions have also been proposed for logic programs [DM88].
Reference: [Nai96] <author> Lee Naish. </author> <title> A declarative view of modes. </title> <booktitle> In Proceedings of the 1996 Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 185-199. </pages> <publisher> MIT Press, </publisher> <month> September </month> <year> 1996. </year>
Reference-contexts: well typed outputs, and 2. result in only well typed calls in the body of any matching clause (which succeeds 3 ). 3 The condition that the clause succeeds is often ignored due to the focus on decidable sufficient conditions for correctness. 9 The declarative view of modes presented in <ref> [Nai96] </ref> can be seen as a higher level version of directed types. Mode declarations define a set of atoms (the mode set ) which should be a superset of the success set.
Reference: [Nai97] <author> Lee Naish. </author> <title> A declarative debugging scheme. </title> <journal> Journal of Functional and Logic Programming, </journal> <volume> 1997(3), </volume> <month> April </month> <year> 1997. </year>
Reference-contexts: The cause of the difference is isolated to a small section of code which must contain a bug. Shapiro's work has been extended and refined in many ways. The two developments which are the key to this paper are the early work of Pereira [Per86] and our recent work <ref> [Nai97] </ref>. Our work, summarised in the next section, presented a scheme for declarative debugging which generalised many previous approaches. <p> Declarative debuggers search for such nodes in the proof tree using information about the intended behaviour of the program (typically asking the user about the correctness of atoms in the tree). The previous declarative debugging scheme <ref> [Nai97] </ref> proposed generalises wrong answer diagnosis for Prolog and is based on two assumptions. The first is that a computation can be described using a tree. The root of the tree describes the overall result of the computation 1 and its children describe the result of sub-computations. <p> The oset_max node shown in italics would be considered erroneous in the two valued scheme but inadmissible in the three valued scheme. Using the two valued scheme, one explanation is that oset_max ([2,3,1],Y) misses the answer Y=3 (the oset_max node is buggy). See <ref> [Nai97] </ref> or [DNTM88] for a more technical description of this class of bugs. The other explanation is to say that missing the answer Y=3 is correct since the list is not sorted (the oset_max node is correct and hence ltmax is buggy).
Reference: [NDZ89] <author> L. Naish, P. W. Dart, and J. Zobel. </author> <title> The NU-prolog debugging environment. </title> <editor> In Antonio Porto, editor, </editor> <booktitle> Proceedings of the Sixth International Conference on Logic Programming, </booktitle> <address> Lisboa, Portugal, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: One advantage of the debugger gathering purely declarative information is that is can be reused more readily than procedural information. For example, the NUDE system <ref> [NDZ89] </ref> uses such information to avoid asking questions in the debugger and also for automatic testing. For this reason we prefer the declarative three-valued scheme to a non-declarative adaptation of the two-valued scheme. 7 Semantics of logic programs We have argued that, for debugging purposes, three truth values are desirable.
Reference: [PC88] <author> Luis Moniz Pereira and Miguel Calejo. </author> <title> A framework for prolog debugging. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Proceedings of the Fifth International Conference/Symposium on Logic Programming, </booktitle> <pages> pages 481-495, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year> <month> 13 </month>
Reference-contexts: Instead, the intended interpretation should capture the fact that these calls should never occur. Some early work on declarative debugging introduced the idea of inadmissible calls [Per86], though no declarative meaning was given. Subsequent work built on these ideas <ref> [PC88] </ref> and work on types [Nai92] gave a declarative reconstruction of this idea, identifying inadmissible calls with ill-typed atoms (where types could be defined using arbitrary predicates). This is the basis for our current work. We also note the existence of debuggers which allow "don't know" answers to questions [DNTM88]. <p> Definition A node in a tree is e-buggy if it is erroneous but all children are correct. The second kind of buggy node definition involves inadmissibility. It corresponds to the combination of sub-computations violating some assumption. It is consistent with the "inadmissible call bug" definition of <ref> [PC88] </ref>, assuming inadmissible calls are not considered "bug manifestations". 1 This question lead to our previous work on types and ultimately to this paper 4 Definition A node in a tree is i-buggy if it is erroneous and has an inadmissible child and no erroneous children. Consider the gtmax example. <p> Note that inadmissibility is not necessarily closed under instantiation and the programmer's intentions must include some non-declarative aspects of the language. System predicates are used as an example of inadmissible calls in <ref> [PC88] </ref>, but no algorithm for diagnosing abnormal termination is given. The tree which represents the computation can be generalised to allow for aborted computations in the following way.
Reference: [Per86] <author> Luis Moniz Pereira. </author> <title> Rational debugging in logic programming. </title> <editor> In Ehud Shapiro, editor, </editor> <booktitle> Proceedings of the Third International Conference on Logic Programming, </booktitle> <pages> pages 203-210, </pages> <address> London, England, </address> <month> July </month> <year> 1986. </year> <note> published as Lecture Notes in Computer Science 225 by Springer-Verlag. </note>
Reference-contexts: The cause of the difference is isolated to a small section of code which must contain a bug. Shapiro's work has been extended and refined in many ways. The two developments which are the key to this paper are the early work of Pereira <ref> [Per86] </ref> and our recent work [Nai97]. Our work, summarised in the next section, presented a scheme for declarative debugging which generalised many previous approaches. <p> Instead, the intended interpretation should capture the fact that these calls should never occur. Some early work on declarative debugging introduced the idea of inadmissible calls <ref> [Per86] </ref>, though no declarative meaning was given. Subsequent work built on these ideas [PC88] and work on types [Nai92] gave a declarative reconstruction of this idea, identifying inadmissible calls with ill-typed atoms (where types could be defined using arbitrary predicates). This is the basis for our current work.
Reference: [RNP92] <author> Yann Rouzaud and Lan Nguyen-Phuong. </author> <title> Integrating modes and subtypes into a Prolog type-checker. </title> <booktitle> In Proceedings of the Ninth Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 85-97, </pages> <year> 1992. </year>
Reference: [Sha83] <author> Ehud Y. Shapiro. </author> <title> Algorithmic program debugging. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1983. </year>
Reference-contexts: 1 Introduction Declarative debugging was first introduced in <ref> [Sha83] </ref> for diagnosing wrong and missing answers in Prolog. The fundamental idea of declarative debugging is that the programmer (or some other oracle) has an intended interpretation of the program (how the program should behave) and debuggers can query the programmer to obtain this information.
Reference: [SHC95] <author> Zoltan Somogyi, Fergus J. Henderson, and Thomas Conway. </author> <title> Mercury: an efficient purely declarative logic programming language. </title> <booktitle> In Proceedings of the Australian Computer Science Conference, </booktitle> <pages> pages 499-512, </pages> <address> Glenelg, Australia, </address> <month> February </month> <year> 1995. </year> <month> 14 </month>
Reference-contexts: Examples include division by zero and arguments being of the wrong type or insufficiently instantiated. It is also reasonable for user-defined procedures to abort under certain conditions. For example, in Mercury <ref> [SHC95] </ref>, procedures can call the special builtin error to assist with determinism analysis or for defensive programming or documentation. In general, these errors depend on the execution order, due to the treatment of failure and errors which depend on instantiation.
References-found: 15

