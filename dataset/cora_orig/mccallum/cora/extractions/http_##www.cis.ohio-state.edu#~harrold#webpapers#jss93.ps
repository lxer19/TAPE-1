URL: http://www.cis.ohio-state.edu/~harrold/webpapers/jss93.ps
Refering-URL: http://www.cis.ohio-state.edu/~harrold/allpapers.html
Root-URL: 
Email: email: ofut@cs.clemson.edu  
Phone: phone: 803-656-5882  
Title: A Software Metric System for Module Coupling  
Author: A. Jefferson Offutt Mary Jean Harrold Priyadarshan Kolte 
Keyword: software design, coupling, data flow, program slicing.  
Address: Clemson, SC 29634-1906  
Affiliation: Department of Computer Science Clemson University  
Abstract: Low module coupling is considered to be a desirable quality for modular programs to have. Previously, coupling has been defined subjectively, and not quantified, making it difficult to use in practice. In this paper, we extend previous work to reflect newer programming languages, and quantify coupling by developing a general software metric system that allows us to automatically measure coupling. We have precisely defined the levels of coupling so that they can be determined algorithmically, incorporated the notion of direction into the coupling levels, and accounted for different types of non-local variables present in modern programming languages. With our system, we can measure the coupling between all pairs of modules in a system, measure the coupling of a particular module with all other modules in a system, and measure the coupling of an entire system. We have implemented our metric system so that it measures the coupling between pairs of procedures in arbitrary C programs and have analyzed several well-used systems of various sizes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Next, GetSummary performs data flow analysis using the definition and use information to obtain the sets of reachable uses of all definitions in A. Since each module is an individual procedure, we use traditional intraprocedural data flow analysis techniques <ref> [1] </ref> to compute the reachable use sets. For each definition, a du set is constructed that contains all reachable uses of that definition. Finally, GetSummary uses the data flow information and a forward slicing technique to classify each formal parameter as having a C-use, a P-use or an I-use.
Reference: [2] <author> Constantine and Yourdon. </author> <title> Structured Design. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1979. </year>
Reference-contexts: As such, they may be used to suggest parts of the program that are prone to errors. An important way to reduce complexity is to increase modularization [10]. As part of their structured design methodology, Constantine and Yourdon <ref> [2] </ref> suggested that modularity of software design be measured with two qualitative properties: cohesion and coupling. Cohesion describes a module's functionality; the highest degree of cohesion is obtained when a module performs one function. <p> Second, we incorporate the notion of bidirection into our coupling model to measure both in and out couplings between modules. Although Fenton and Melton [4] include bidirectional coupling, the earlier researchers, Myers [10], Page-Jones [13], and Constantine and Yourdon <ref> [2] </ref> made no mention of coupling via return values. Third, we extend coupling levels to include a combination of data and control coupling, introducing levels that were merged with data coupling in Myer's levels.
Reference: [3] <author> R. A. DeMillo, D. S. Guindi, K. N. King, W. M. McCracken, and A. J. Offutt. </author> <title> An extended overview of the Mothra software testing environment. </title> <booktitle> In Proceedings of the Second Workshop on Software Testing, Verification, and Analysis, </booktitle> <pages> pages 142-151, </pages> <address> Banff Alberta, July 1988. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: SC is a relatively small public domain spreadsheet program that was originally written by James Gosling. Make is the GNU version 3.60 release of the UNIX dependency-compilation utility. GCC is release 1.37.1 of the GNU C compiler, a large and recently written production quality program. Mothra <ref> [3, 9] </ref> is a mutation-based software testing system that is composed of about a dozen separate programs, or tools, all of which use a common library. It tests programs written in Fortran 77.
Reference: [4] <author> N. Fenton and A. Melton. </author> <title> Deriving structurally based software measures. </title> <journal> The Journal of Systems and Software, </journal> <volume> 12(3) </volume> <pages> 177-886, </pages> <month> July </month> <year> 1990. </year> <month> 16 </month>
Reference-contexts: Other researchers [15, 8, 6, 14] have used coupling levels or similar measures to evaluate the complexity of software design and relate this complexity to the number of software faults. Recently, Fenton and Melton <ref> [4] </ref> developed a measurement theory that provides a basis for defining software complexity and used hand-derived coupling measures to demonstrate their theory. <p> Finally, the system uses the coupling levels and numbers of interconnections to compute a coupling measure that is based on a complexity metric that is similar to Fenton and Melton's <ref> [4] </ref>. We have implemented our metric system to identify coupling measures for modules 1 We follow earlier researchers and consider a module to be a single procedure/function, rather than a collection of procedures. 1 written in the C programming language and have analyzed several well-used systems of various sizes. <p> They found that procedures with the highest coupling had up to seven times as many faults as procedures that exhibited low coupling. Again, our algorithms compute a more precise coupling measure, extending Hutchens, Selby, and Basili's work to get a more precise measure of software quality. Fenton and Melton <ref> [4] </ref> presented a way to measure the structure of software and applied it using coupling. They described a measure of complexity of software design that used hand-derived pairwise coupling between modules. <p> First, we define several types of global coupling to reflect scoping features in modern programming languages (such as non-local variables). Second, we incorporate the notion of bidirection into our coupling model to measure both in and out couplings between modules. Although Fenton and Melton <ref> [4] </ref> include bidirectional coupling, the earlier researchers, Myers [10], Page-Jones [13], and Constantine and Yourdon [2] made no mention of coupling via return values. Third, we extend coupling levels to include a combination of data and control coupling, introducing levels that were merged with data coupling in Myer's levels. <p> Finally, the coupling levels and interconnection numbers are used to get an overall coupling measure for the system. Although any coupling measure can be used, we present and use an adjusted version of that given by Fenton and Melton <ref> [4] </ref>. Though we discuss a software metric system to compute the coupling between pairs of modules, the resulting measures are easily combined to gain a coupling measure for an integrated system. <p> Any measure that uses the coupling level and number of interconnections can be used. We adjust Fenton and Melton's measure <ref> [4] </ref> that incorporates the coupling level with the number of interconnections, which was given in section 2. For a coupling level, i, the coupling measure is proportional to the number of interconnections n. <p> This was true for all of the software we examined, and if true in general, might indicate that complexity measures that incorporate the number of connections, such as Fenton and Melton's <ref> [4] </ref>, provide more detail than necessary. 5 Future Work Although module coupling is widely accepted as a way to evaluate the quality of design, its importance depends on whether coupling can be used effectively in the software production process.
Reference: [5] <author> P. G. Frankl and E. J. Weyuker. </author> <title> An applicable family of data flow testing criteria. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-14(10):1483-1498, </volume> <month> October </month> <year> 1988. </year>
Reference-contexts: To precisely define our coupling levels, we classify each call and return parameter by the way it is used in the module. We borrow the classification of uses as computation-uses (C-uses) and predicate-uses (P-uses) from data flow testing <ref> [5] </ref> and define indirect-uses (I-uses). A C-use occurs whenever a variable (or parameter) is used in an assignment or output statement. A P-use occurs whenever a variable is used in a predicate statement. An I-use occurs whenever a variable is a C-use that affects some predicate in the module.
Reference: [6] <author> D. H. Hutchens and V. R. Basili. </author> <title> System structure analysis: Clustering with data bindings. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(8) </volume> <pages> 749-757, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: Myers [10] refined the concept of coupling by presenting well-defined, though informal, levels of coupling. Since his levels were neither precise nor prescriptive definitions, coupling could only be determined by hand, leaving room for subjective interpretations of the levels. Other researchers <ref> [15, 8, 6, 14] </ref> have used coupling levels or similar measures to evaluate the complexity of software design and relate this complexity to the number of software faults. <p> Because the coupling levels that we measure are at a finer level of detail, we are extending Kafura and Henry's work in a way that should result in a more precise measure of software quality. Hutchens and Basili <ref> [6] </ref> proposed the use of clustering with data bindings for measuring software quality. A potential data binding occurs when a variable is in the scope of two procedures (e.g., x is in the scope of P and Q). A used data binding occurs when the two procedures use the variable. <p> Specifically, data bindings do not differentiate between data computation and control uses, and do not differentiate parameter values from global structures. Selby and Basili [14] used Hutchens and Basili's data binding measurements <ref> [6] </ref> to measure a 148,000 line system from a production environment. They collected error data during the testing phase, and applied five tools to calculate data bindings using clustering. <p> Selby and Basili [14] had a similar experiment based on the clustering measure proposed by Hutchens and Basili <ref> [6] </ref>. In the future, we plan to repeat such an experiment, using our automated means of determining coupling, and using our revised coupling levels. As mentioned in section 3.3, our implementation does not include external coupling.
Reference: [7] <author> P. Jalote. </author> <title> An Integrated Approach to Software Engineering. </title> <publisher> Springer-Verlag, </publisher> <address> New York NY, </address> <year> 1991. </year>
Reference-contexts: However, module coupling is still considered to be an imprecise measure of software complexity. Jalote states, "Coupling is an abstract concept and is as yet not quantifiable" <ref> [7] </ref>. In this paper, we extend previous work to reflect newer programming languages, and quantify coupling by developing a general software metric system that allows us to automatically measure coupling.
Reference: [8] <author> D. Kafura and S. Henry. </author> <title> Software quality metrics based on interconnectivity. </title> <journal> The Journal of Systems and Software, </journal> <volume> 2 </volume> <pages> 121-131, </pages> <year> 1981. </year>
Reference-contexts: Myers [10] refined the concept of coupling by presenting well-defined, though informal, levels of coupling. Since his levels were neither precise nor prescriptive definitions, coupling could only be determined by hand, leaving room for subjective interpretations of the levels. Other researchers <ref> [15, 8, 6, 14] </ref> have used coupling levels or similar measures to evaluate the complexity of software design and relate this complexity to the number of software faults. <p> Our software metric system fulfills Kafura and Henry's <ref> [8] </ref> four criteria for a practical and powerful software metric system. First, our system is usable in a large-scale system environment, as demonstrated by our measurements of several large-scale systems such as the Free Software Foundation, Inc's C compiler (GCC) 2 . <p> On the other hand, they evaluated design documents, allowing them to compute coupling levels before implementation, whereas our implementation requires the code to be written (the exact information we need is detailed in section 3.2). Kafura and Henry <ref> [8] </ref> suggested a similar method for measuring software based on information flow. They derived their metrics from procedures by considering the flow of information to input parameters, output parameters, and global data structures.
Reference: [9] <author> K. N. King and A. J. Offutt. </author> <title> A Fortran language system for mutation-based software testing. </title> <journal> Software-Practice and Experience, </journal> <volume> 21(7) </volume> <pages> 686-718, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: SC is a relatively small public domain spreadsheet program that was originally written by James Gosling. Make is the GNU version 3.60 release of the UNIX dependency-compilation utility. GCC is release 1.37.1 of the GNU C compiler, a large and recently written production quality program. Mothra <ref> [3, 9] </ref> is a mutation-based software testing system that is composed of about a dozen separate programs, or tools, all of which use a common library. It tests programs written in Fortran 77.
Reference: [10] <author> G. Myers. </author> <title> Reliable Software Through Composite Design. </title> <publisher> Mason and Lipscomb Publishers, </publisher> <address> New York NY, </address> <year> 1974. </year>
Reference-contexts: 1 Introduction Software complexity measures are meant to indicate whether the software has desirable attributes such as understandability, testability, maintainability, and reliability. As such, they may be used to suggest parts of the program that are prone to errors. An important way to reduce complexity is to increase modularization <ref> [10] </ref>. As part of their structured design methodology, Constantine and Yourdon [2] suggested that modularity of software design be measured with two qualitative properties: cohesion and coupling. Cohesion describes a module's functionality; the highest degree of cohesion is obtained when a module performs one function. <p> Myers <ref> [10] </ref> refined the concept of coupling by presenting well-defined, though informal, levels of coupling. Since his levels were neither precise nor prescriptive definitions, coupling could only be determined by hand, leaving room for subjective interpretations of the levels. <p> In section 5.1, we discuss several ideas for future work, including ideas for extending our metric system to handle modules containing more than one procedure. Finally, concluding remarks are given in section 6. 2 Coupling Myers <ref> [10] </ref> defined six distinct levels of coupling to measure the interdependence among the modules; we include no coupling as the zeroth level. The coupling levels were ordered by Page-Jones [13] according to their effects on the understandability, maintainability, modifiability and reusability of the coupled modules. <p> Second, we incorporate the notion of bidirection into our coupling model to measure both in and out couplings between modules. Although Fenton and Melton [4] include bidirectional coupling, the earlier researchers, Myers <ref> [10] </ref>, Page-Jones [13], and Constantine and Yourdon [2] made no mention of coupling via return values. Third, we extend coupling levels to include a combination of data and control coupling, introducing levels that were merged with data coupling in Myer's levels.
Reference: [11] <author> A. J. Offutt and S. D. Lee. </author> <title> IMSCU programmer's reference manual. </title> <type> Technical report 91-121, </type> <institution> Department of Computer Science, Clemson University, Clemson SC, </institution> <year> 1991. </year>
Reference-contexts: Mothra [3, 9] is a mutation-based software testing system that is composed of about a dozen separate programs, or tools, all of which use a common library. It tests programs written in Fortran 77. IMSCU <ref> [12, 11] </ref> is a smaller-scale mutation testing system designed for educational purposes that tests programs written in a subset-Pascal language.
Reference: [12] <author> A. J. Offutt and R. H. Untch. </author> <title> Integrating research, reuse, and integration into software engineering courses. </title> <booktitle> In 1992 SEI Conference on Software Engineering Education, </booktitle> <address> San Diego, California, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Mothra [3, 9] is a mutation-based software testing system that is composed of about a dozen separate programs, or tools, all of which use a common library. It tests programs written in Fortran 77. IMSCU <ref> [12, 11] </ref> is a smaller-scale mutation testing system designed for educational purposes that tests programs written in a subset-Pascal language.
Reference: [13] <author> M. Page-Jones. </author> <title> The Practical Guide to Structured Systems Design. </title> <publisher> YOURDON Press, </publisher> <address> New York, NY, </address> <year> 1980. </year>
Reference-contexts: On the other hand, coupling is the degree of interdependence between pairs of modules; the minimum degree of coupling is obtained by making modules as independent as possible. Ideally, a well designed software system maximizes cohesion and minimizes coupling 1 . Page-Jones <ref> [13] </ref> gives three principle reasons why low coupling between modules is desirable: (1) fewer interconnections between modules reduce the chance that a fault in one module will cause a failure in other modules, (2) fewer interconnections between modules reduce the chance that changes in one module cause problems in other modules, <p> Finally, concluding remarks are given in section 6. 2 Coupling Myers [10] defined six distinct levels of coupling to measure the interdependence among the modules; we include no coupling as the zeroth level. The coupling levels were ordered by Page-Jones <ref> [13] </ref> according to their effects on the understandability, maintainability, modifiability and reusability of the coupled modules. If two modules are coupled in more than one way, they are considered to be coupled at the highest level: 0. Independent Coupling No coupling between the modules. 1. <p> Common Coupling Two modules are common coupled if they refer to the same global data. 6. Content Coupling Two modules are content coupled if they access and change each other's internal data state or procedural state. Page-Jones <ref> [13] </ref> also introduced the notion of tramp coupling, where data may flow through many intermediate modules from where the data are defined to where they are used. This differs from the other coupling levels in that it measures the coupling among many modules instead of just two modules. <p> Second, we incorporate the notion of bidirection into our coupling model to measure both in and out couplings between modules. Although Fenton and Melton [4] include bidirectional coupling, the earlier researchers, Myers [10], Page-Jones <ref> [13] </ref>, and Constantine and Yourdon [2] made no mention of coupling via return values. Third, we extend coupling levels to include a combination of data and control coupling, introducing levels that were merged with data coupling in Myer's levels. <p> Tramp Coupling (bidirectional) A formal parameter in A is passed to B as an actual parameter, B subsequently passes the corresponding formal parameter to another procedure without B having accessed or changed the variable. We used Page-Jone's original ordering <ref> [13] </ref> to develop our coupling levels. We inserted Call coupling before all levels that involve data passing. We added scalar and stamp data/control coupling after the control couplings because they exhibit the worst of both data and control coupling.
Reference: [14] <author> R. W. Selby and V. R. Basili. </author> <title> Analyzing error-prone system structure. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(2) </volume> <pages> 141-152, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: Myers [10] refined the concept of coupling by presenting well-defined, though informal, levels of coupling. Since his levels were neither precise nor prescriptive definitions, coupling could only be determined by hand, leaving room for subjective interpretations of the levels. Other researchers <ref> [15, 8, 6, 14] </ref> have used coupling levels or similar measures to evaluate the complexity of software design and relate this complexity to the number of software faults. <p> Like Kafura and Henry, they derive their measures from program source, but do not derive as detailed a measurement as does coupling. Specifically, data bindings do not differentiate between data computation and control uses, and do not differentiate parameter values from global structures. Selby and Basili <ref> [14] </ref> used Hutchens and Basili's data binding measurements [6] to measure a 148,000 line system from a production environment. They collected error data during the testing phase, and applied five tools to calculate data bindings using clustering. <p> As mentioned in section 2, Troy and Zweben [15] studied the relationship of coupling to the number of faults found in programs, and found that module coupling was a good predictor of the number of faults in software. Selby and Basili <ref> [14] </ref> had a similar experiment based on the clustering measure proposed by Hutchens and Basili [6]. In the future, we plan to repeat such an experiment, using our automated means of determining coupling, and using our revised coupling levels. <p> We plan experiments to determine the relationship between our coupling measures of a program/system and the number of faults (similar to what Troy and Zweben [15] and Basili and Selby <ref> [14] </ref> have done). We expect that the ability to automatically measure module coupling will allow programmers to use this important measurement in practical situations such as determining the maintainability of the system, the difficulty of regression testing when changes are made, and the reusability of modules.
Reference: [15] <author> D. A. Troy and S. H. </author> <title> Zweben. Measuring the quality of structured designs. </title> <journal> The Journal of Systems and Software, </journal> <volume> 2 </volume> <pages> 112-120, </pages> <year> 1981. </year>
Reference-contexts: Myers [10] refined the concept of coupling by presenting well-defined, though informal, levels of coupling. Since his levels were neither precise nor prescriptive definitions, coupling could only be determined by hand, leaving room for subjective interpretations of the levels. Other researchers <ref> [15, 8, 6, 14] </ref> have used coupling levels or similar measures to evaluate the complexity of software design and relate this complexity to the number of software faults. <p> Tramp coupling is usually a pathological form of data coupling, but can also be stamp or control coupling. Since Myer's initial work on coupling, several researchers have used coupling or related measures to evaluate software. Troy and Zweben <ref> [15] </ref> used coupling to measure the quality of a design by relating the 2 c fl1987, 1989 Free Software Foundation, Inc., 675 Mass Avenue, Cambridge, MA 02139. 2 level of coupling to the number of faults in the software. <p> One use of module coupling is as a way to predict faults in the software. As mentioned in section 2, Troy and Zweben <ref> [15] </ref> studied the relationship of coupling to the number of faults found in programs, and found that module coupling was a good predictor of the number of faults in software. Selby and Basili [14] had a similar experiment based on the clustering measure proposed by Hutchens and Basili [6]. <p> We plan experiments to determine the relationship between our coupling measures of a program/system and the number of faults (similar to what Troy and Zweben <ref> [15] </ref> and Basili and Selby [14] have done). We expect that the ability to automatically measure module coupling will allow programmers to use this important measurement in practical situations such as determining the maintainability of the system, the difficulty of regression testing when changes are made, and the reusability of modules.
Reference: [16] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10(4) </volume> <pages> 352-357, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Our metric system first determines the variable use information needed to compute the coupling measure using a mixture of textual inspection, data flow analysis, and a restricted form of program slicing <ref> [16] </ref>. Next, the system identifies the levels of coupling and numbers of interconnections among the modules. The central component of the system uses an algorithm that precisely identifies the level of coupling and the number of interconnections of that level between two modules.
Reference: [17] <author> W. Wulf and M. Shaw. </author> <title> Global variables considered harmful. </title> <journal> Sigplan Notices, </journal> <volume> 8(2) </volume> <pages> 28-34, </pages> <month> February </month> <year> 1973. </year>
Reference-contexts: Make was the only program with a larger number of module pairs coupled at the scalar data level than at an other level, although almost as many module pairs in it were global coupled. Since extensive use of global data is widely considered to be dangerous <ref> [17] </ref>, these results are disturbing. They seem to indicate that our theoretical ideas of good software engineering habits are not followed in practice as well as we would like, and perhaps that they are more difficult to follow than we would expect.
References-found: 17

