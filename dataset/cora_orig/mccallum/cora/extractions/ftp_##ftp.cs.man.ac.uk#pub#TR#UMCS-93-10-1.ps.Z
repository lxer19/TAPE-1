URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-93-10-1.ps.Z
Refering-URL: http://www.cs.man.ac.uk/cstechrep/Abstracts/UMCS-93-10-1.html
Root-URL: http://www.cs.man.ac.uk
Title: Process-Algebraic Foundations for an Object-Based Design Notation  
Author: C. B. Jones 
Affiliation: Computer Science University of Manchester  
Pubnum: Technical Report UMCS-93-10-1  
Abstract-found: 0
Intro-found: 1
Reference: [Ame89] <author> Pierre America. </author> <title> Issues in the design of a parallel object-oriented language. </title> <journal> Formal Aspects of Computing, </journal> <volume> 1(4), </volume> <year> 1989. </year>
Reference-contexts: The design notation used in both of these papers is currently known as ofi. Rather than being viewed as a contending programming language, it is hoped that ofi will be used as a design notation for the development of programs in languages like POOL <ref> [Ame89] </ref>, ABCL [Yon90], Beta [KMMN91], Modula-3 [Nel91] or UFO [Sar92]. But if sound development methods are required design notations have to be given semantics. For example, the transformation rules used in [Jon93a] have to be shown to preserve observational equivalence.
Reference: [Ame91] <editor> P. America, editor. ECOOP'91, </editor> <booktitle> volume 612 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [AR89] <author> Pierre America and Jan Rutten. </author> <title> A Parallel Object-Oriented Language: Design and Semantic Foundations. </title> <type> PhD thesis, </type> <institution> Free University of Amsterdam, </institution> <year> 1989. </year>
Reference-contexts: But if sound development methods are required design notations have to be given semantics. For example, the transformation rules used in [Jon93a] have to be shown to preserve observational equivalence. A denotational semantics for ofi would have to deal with concurrency (relevant papers include <ref> [Wol88, AR89, AR92, dBdV91] </ref>). In some respects, a semantics based on resumptions fits this sort of parallel object-based language quite well but there are some difficulties and these would even be shared by an operational semantics.
Reference: [AR92] <author> Pierre America and Jan Rutten. </author> <title> A layered semantics for a parallel object-oriented language. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4(4) </volume> <pages> 376-408, </pages> <year> 1992. </year>
Reference-contexts: But if sound development methods are required design notations have to be given semantics. For example, the transformation rules used in [Jon93a] have to be shown to preserve observational equivalence. A denotational semantics for ofi would have to deal with concurrency (relevant papers include <ref> [Wol88, AR89, AR92, dBdV91] </ref>). In some respects, a semantics based on resumptions fits this sort of parallel object-based language quite well but there are some difficulties and these would even be shared by an operational semantics.
Reference: [Bae90] <author> J. C. M. Baeten, </author> <title> editor. Applications of Process Algebra. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference: [Bes93] <editor> E. Best, editor. CONCUR'93: </editor> <booktitle> 4th International Conference on Concurrency Theory, volume 715 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [Bro89] <author> Manfred Broy. </author> <title> On bounded buffers: Modularity, robustness, and reliability in reactive systems. </title> <type> Technical Report MIP-8920, </type> <institution> Universitat Passau, Fakultat fur mathematik und Informatik, </institution> <month> June </month> <year> 1989. </year>
Reference: [BW90] <author> J. C. M. Baeten and W. P. Weijland, </author> <title> editors. Process Algebra. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference: [CC93] <author> Pierre Collette and Antonio Cau. </author> <title> Parallel composition of assumption-commitment specifications, 1993. </title> <type> private communication. </type>
Reference-contexts: As the logic used in [Jon93c] stabilizes, it will be necessary to undertake justification of its interference rules and this will require proofs about the relationship between logical expressions and ofi statements. Furthermore, continuing work on general properties of rely/guarantee specifications (notably <ref> [Col93, CC93] </ref>) could force reconsideration of the approach taken in [Jon93c]. 9.2 Related work The reader is referred to [MPW92, Mil92b] for notes on the evolution of process algebras which permit name passing. Milner discusses useful examples of representing imperative languages in CCS already in [Mil89].
Reference: [Col93] <author> Pierre Collette. </author> <title> Application of the composition principle to Unity-like specifications. </title> <booktitle> In [GJ93], </booktitle> <pages> pages 230-242, </pages> <year> 1993. </year>
Reference-contexts: As the logic used in [Jon93c] stabilizes, it will be necessary to undertake justification of its interference rules and this will require proofs about the relationship between logical expressions and ofi statements. Furthermore, continuing work on general properties of rely/guarantee specifications (notably <ref> [Col93, CC93] </ref>) could force reconsideration of the approach taken in [Jon93c]. 9.2 Related work The reader is referred to [MPW92, Mil92b] for notes on the evolution of process algebras which permit name passing. Milner discusses useful examples of representing imperative languages in CCS already in [Mil89].
Reference: [dBdV91] <author> J. W. de Bakker and E. P. de Vink. </author> <title> Rendez-vous with metric semantics. </title> <booktitle> In Proceedings of the REX Workshop on Semantics: Foundations and Applications, volume 506 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: But if sound development methods are required design notations have to be given semantics. For example, the transformation rules used in [Jon93a] have to be shown to preserve observational equivalence. A denotational semantics for ofi would have to deal with concurrency (relevant papers include <ref> [Wol88, AR89, AR92, dBdV91] </ref>). In some respects, a semantics based on resumptions fits this sort of parallel object-based language quite well but there are some difficulties and these would even be shared by an operational semantics.
Reference: [dR85] <author> W. P. de Roever. </author> <title> The quest for compositionality: A survey of assertion-based proof systems for concurrent programs: Part I: Concurrency based on shared variables. </title> <editor> In E. J. Neuhold and G. Chroust, editors, </editor> <booktitle> Formal Models in Programming. </booktitle> <publisher> North-Holland, </publisher> <year> 1985. </year> <month> 17 </month>
Reference-contexts: Relatively simple specification ideas (e.g. pre and post-conditions) suffice for the compositional development of sequential programs; interference makes it difficult to find useful compositional approaches for concurrent programs (an interesting account of this quest is contained in <ref> [dR85, HdR86] </ref>). The research reported in this paper is intended to contribute to the quest for compositional development methods for concurrent programs: the use of some notions from object-oriented languages is a means to tame interference rather than a (fashionable) end in itself.
Reference: [GJ93] <editor> M-C. Gaudel and J-P. Jouannaud, editors. TAPSOFT'93: </editor> <booktitle> Theory and Practice of Software Development, volume 668 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [HdR86] <author> J. Hooman and W. P. de Roever. </author> <title> The quest goes on: a survey of proof systems for partial correctness of CSP. </title> <editor> In J.W. de Bakker, W. P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Current Trends in Concurrency, </booktitle> <pages> pages 343-395. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <note> LNCS 224. </note>
Reference-contexts: Relatively simple specification ideas (e.g. pre and post-conditions) suffice for the compositional development of sequential programs; interference makes it difficult to find useful compositional approaches for concurrent programs (an interesting account of this quest is contained in <ref> [dR85, HdR86] </ref>). The research reported in this paper is intended to contribute to the quest for compositional development methods for concurrent programs: the use of some notions from object-oriented languages is a means to tame interference rather than a (fashionable) end in itself.
Reference: [Hen90] <author> M. Hennessy. </author> <title> The Semantics of Programming Languages. </title> <publisher> John Wiley, </publisher> <year> 1990. </year>
Reference: [HJ89] <author> C. A. R. Hoare and C. B. Jones. </author> <booktitle> Essays in Computing Science. </booktitle> <publisher> Prentice Hall International, </publisher> <year> 1989. </year>
Reference: [Hoa75] <author> C. A. R. Hoare. </author> <title> Recursive data structures. </title> <journal> International Journal of Computer & Information Sciences, </journal> <volume> 4(2) </volume> <pages> 105-132, </pages> <month> June </month> <year> 1975. </year> <note> see also, Chapter 14 of [HJ89]. </note>
Reference: [Hoa78] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <month> August </month> <year> 1978. </year> <note> see also, Chapter 16 of [HJ89]. </note>
Reference: [Hoa85] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference: [HT91a] <author> K. Honda and M. Tokoro. </author> <title> An object calculus for asynchronous communication. </title> <booktitle> In [Ame91], </booktitle> <pages> pages 133-147, </pages> <year> 1991. </year>
Reference-contexts: Other researchers who have provided semantics for object-oriented languages based on process algebras include Honda and Tokoro [HT91b] (based on <ref> [HT91a] </ref>) and [Vaa90] (employs the process algebra known as ACP). Davide Sangiorgi's work on the higher-order -calculus [San93b, San93a] provides strong arguments for using a higher-order calculus; [Wal93c] actually provides a mapping from ofi to the higher-order -calculus; and the proofs in [Wal93a] are based on this notion.
Reference: [HT91b] <author> K. Honda and M. Tokoro. </author> <title> A small calculus for concurrent objects. </title> <journal> ACM, OOPS Messenger, </journal> <volume> 2(2) </volume> <pages> 50-54, </pages> <year> 1991. </year>
Reference-contexts: Other researchers who have provided semantics for object-oriented languages based on process algebras include Honda and Tokoro <ref> [HT91b] </ref> (based on [HT91a]) and [Vaa90] (employs the process algebra known as ACP).
Reference: [HY93] <author> Kohei Honda and Nobuko Yoshida. </author> <title> On reduction-based process semantics, 1993. </title> <type> private communication. </type>
Reference-contexts: Another author who has investigated calculi which are suitable for object-oriented programming languages is Oscar Nierstrasz. His `object calculus' in [Nie92] can be compared to the higher-order -calculus. Further developments by the group at Keio University (e.g. <ref> [HY93] </ref>) on the -calculus could influence the approach to the required formalization of the proofs; furthermore [VH93] considers the problem of principal types in the -calculus. Acknowledgements The author is grateful for financial support from the SERC who fund his Senior Research Fellowship.
Reference: [IM91] <editor> T. Ito and A. R. Meyer, editors. </editor> <booktitle> TACS'91 Proceedings of the International Conference on Theoretical Aspects of Computer Science, Sendai, Japan, volume 526 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [Jon91] <editor> C. B. Jones. Interference resumed. In P. Bailes, editor, </editor> <booktitle> Engineering Safe Software, </booktitle> <pages> pages 31-56. </pages> <publisher> Australian Computer Society, </publisher> <year> 1991. </year>
Reference-contexts: Central to the justification of observational equivalence is the use of invariants on the object graphs which can arise. Interference can not always be controlled in this way and [Jon93c] shows how a logic notation discussed in <ref> [Jon91] </ref> can be used to reason about interference over complex object graphs. The design notation used in both of these papers is currently known as ofi.
Reference: [Jon92] <author> C. B. Jones. </author> <title> An object-based design method for concurrent programs. </title> <type> Technical Report UMCS-92-12-1, </type> <institution> Manchester University, </institution> <year> 1992. </year>
Reference-contexts: Although the arguments given below are hopefully convincing, they are not completely formal and the current paper might be viewed as a challenge which could stimulate the development of new approaches to equivalence proofs. 1 The main content of these two papers are combined in <ref> [Jon92] </ref> but the appendix there on a possible approach to the semantics of ofi is superseded by the current report. 2 Section 2 below introduces ofi by an example. <p> It is intended that no ofi program can be written which is sensitive to this difference but this conjecture has not yet been proved. Walker - in [Wal93a] constructs a detailed argument for the special case shown in Appendix A. 9 Discussion 9.1 Further work As discussed in <ref> [Jon92] </ref> some language issues remain to be resolved in ofi itself. One radical alternative which might be considered is to follow the Smalltalk-80 idea of getting by without a while statement and using block statements in the language. <p> As also discussed in <ref> [Jon92] </ref>, ofi needs an extension in order to handle situations where method calls cannot necessarily be accepted. <p> A preliminary sketch of the mapping from ofi to the polyadic -calculus is given in <ref> [Jon92] </ref>. In [Wal93b], Walker, amongst other things, provides a mapping from POOL to the polyadic -calculus and this again prompted revision of the mapping which is finally presented in [Jon93b] and repeated in Appendix C here.
Reference: [Jon93a] <author> C. B. Jones. </author> <title> Constraining interference in an object-based design method. </title> <booktitle> In [GJ93], </booktitle> <pages> pages 136-150, </pages> <year> 1993. </year>
Reference-contexts: The research reported in this paper is intended to contribute to the quest for compositional development methods for concurrent programs: the use of some notions from object-oriented languages is a means to tame interference rather than a (fashionable) end in itself. Two papers - <ref> [Jon93a, Jon93c] </ref> 1 indicate that selected features from object-oriented languages might further the quest for compositional development methods (they also provide references which trace the evolution of the ideas). <p> A way of limiting interference in object-based languages is exploited in <ref> [Jon93a] </ref> to show how concurrency can be introduced by transformations. Central to the justification of observational equivalence is the use of invariants on the object graphs which can arise. <p> But if sound development methods are required design notations have to be given semantics. For example, the transformation rules used in <ref> [Jon93a] </ref> have to be shown to preserve observational equivalence. A denotational semantics for ofi would have to deal with concurrency (relevant papers include [Wol88, AR89, AR92, dBdV91]). <p> It would be necessary in order to write such a specification to use some sort of `ghost variables'. The text presented in Figure 1 is actually developed in <ref> [Jon93a] </ref> via a sequential (i.e. non-concurrent) version of the same algorithm. The sequential version differs from that presented in Figure 1 by having the return statements placed at the end of add and remove methods and the yield statement in test written as a return. <p> 1 l 2 l 00 )(BoolEval (l 0 ; l 1 ; l 2 ) j [[e]]l 0 j (l 1 ():[[s]]l 00 + l 2 ():l ) j l 00 ():W ) In [Jon93c], a parallel construct is used in the ofi design notation; this is not used in <ref> [Jon93a] </ref> and is not considered in Appendix C but it could be mapped in much the way that Milner discusses Section 8.3 of [Mil89]. (Recall that Milner explains there why adding a sequential composition operator to interleaving-based process calculi can complicate the algebra.) 6 A specific transformation Many simple transformations such <p> Acknowledgements The author is grateful for financial support from the SERC who fund his Senior Research Fellowship. Technical acknowledgements to people who have helped with the evolution of ofi itself are contained in <ref> [Jon93a, Jon93c] </ref>. This report is based on two papers: [Jon93b] was specifically 16 influenced by comments from Kohei Honda, Colin Stirling, Robin Milner, Davide Sangiorgi and above all by detailed reviews from David Walker. Valuable comments were received during seminars at IFIP WG 2.3, Oslo, Edinburgh and Geneva Universities.
Reference: [Jon93b] <author> C. B. Jones. </author> <title> A pi-calculus semantics for an object-based design notation. </title> <booktitle> In [Bes93], </booktitle> <pages> pages 158-172, </pages> <year> 1993. </year>
Reference-contexts: A preliminary sketch of the mapping from ofi to the polyadic -calculus is given in [Jon92]. In [Wal93b], Walker, amongst other things, provides a mapping from POOL to the polyadic -calculus and this again prompted revision of the mapping which is finally presented in <ref> [Jon93b] </ref> and repeated in Appendix C here. Other researchers who have provided semantics for object-oriented languages based on process algebras include Honda and Tokoro [HT91b] (based on [HT91a]) and [Vaa90] (employs the process algebra known as ACP). <p> Acknowledgements The author is grateful for financial support from the SERC who fund his Senior Research Fellowship. Technical acknowledgements to people who have helped with the evolution of ofi itself are contained in [Jon93a, Jon93c]. This report is based on two papers: <ref> [Jon93b] </ref> was specifically 16 influenced by comments from Kohei Honda, Colin Stirling, Robin Milner, Davide Sangiorgi and above all by detailed reviews from David Walker. Valuable comments were received during seminars at IFIP WG 2.3, Oslo, Edinburgh and Geneva Universities.
Reference: [Jon93c] <author> C. B. Jones. </author> <title> Reasoning about interference in an object-based design method. </title> <booktitle> In [WL93], </booktitle> <pages> pages 1-18, </pages> <year> 1993. </year>
Reference-contexts: The research reported in this paper is intended to contribute to the quest for compositional development methods for concurrent programs: the use of some notions from object-oriented languages is a means to tame interference rather than a (fashionable) end in itself. Two papers - <ref> [Jon93a, Jon93c] </ref> 1 indicate that selected features from object-oriented languages might further the quest for compositional development methods (they also provide references which trace the evolution of the ideas). <p> Central to the justification of observational equivalence is the use of invariants on the object graphs which can arise. Interference can not always be controlled in this way and <ref> [Jon93c] </ref> shows how a logic notation discussed in [Jon91] can be used to reason about interference over complex object graphs. The design notation used in both of these papers is currently known as ofi. <p> e do s od can be modelled by the recursive equation W = (l 0 l 1 l 2 l 00 )(BoolEval (l 0 ; l 1 ; l 2 ) j [[e]]l 0 j (l 1 ():[[s]]l 00 + l 2 ():l ) j l 00 ():W ) In <ref> [Jon93c] </ref>, a parallel construct is used in the ofi design notation; this is not used in [Jon93a] and is not considered in Appendix C but it could be mapped in much the way that Milner discusses Section 8.3 of [Mil89]. (Recall that Milner explains there why adding a sequential composition operator <p> Although the arguments in Sections 7 are hopefully convincing, more formality would permit the use of mechanical proof tools which might be worthwhile as more proofs are needed. Moreover, the challenge of such formalization could yield new insights into notions of behavioural equivalences. As the logic used in <ref> [Jon93c] </ref> stabilizes, it will be necessary to undertake justification of its interference rules and this will require proofs about the relationship between logical expressions and ofi statements. Furthermore, continuing work on general properties of rely/guarantee specifications (notably [Col93, CC93]) could force reconsideration of the approach taken in [Jon93c]. 9.2 Related work <p> logic used in <ref> [Jon93c] </ref> stabilizes, it will be necessary to undertake justification of its interference rules and this will require proofs about the relationship between logical expressions and ofi statements. Furthermore, continuing work on general properties of rely/guarantee specifications (notably [Col93, CC93]) could force reconsideration of the approach taken in [Jon93c]. 9.2 Related work The reader is referred to [MPW92, Mil92b] for notes on the evolution of process algebras which permit name passing. Milner discusses useful examples of representing imperative languages in CCS already in [Mil89]. <p> Acknowledgements The author is grateful for financial support from the SERC who fund his Senior Research Fellowship. Technical acknowledgements to people who have helped with the evolution of ofi itself are contained in <ref> [Jon93a, Jon93c] </ref>. This report is based on two papers: [Jon93b] was specifically 16 influenced by comments from Kohei Honda, Colin Stirling, Robin Milner, Davide Sangiorgi and above all by detailed reviews from David Walker. Valuable comments were received during seminars at IFIP WG 2.3, Oslo, Edinburgh and Geneva Universities.
Reference: [Jon94] <author> C. B. Jones. </author> <title> Process algebra arguments about an object-based design notation. </title> <editor> In A. W. Roscoe, editor, </editor> <booktitle> Essays in Honour of C.A.R. Hoare, chapter 14. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: Valuable comments were received during seminars at IFIP WG 2.3, Oslo, Edinburgh and Geneva Universities. The presentation in <ref> [Jon94] </ref> was influenced by comments on an earlier version by David Walker and by discussions with Samson Abramsky and Colin Stirling (in Tokyo!).
Reference: [KMMN91] <author> B. B. Kristensen, O. L. Madsen, B. Moller-Pedersen, and K. Nygaard. </author> <title> Object oriented programming in the Beta programming language. </title> <type> Technical report, </type> <institution> University of Oslo, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: The design notation used in both of these papers is currently known as ofi. Rather than being viewed as a contending programming language, it is hoped that ofi will be used as a design notation for the development of programs in languages like POOL [Ame89], ABCL [Yon90], Beta <ref> [KMMN91] </ref>, Modula-3 [Nel91] or UFO [Sar92]. But if sound development methods are required design notations have to be given semantics. For example, the transformation rules used in [Jon93a] have to be shown to preserve observational equivalence.
Reference: [Lan66] <author> P. J. Landin. </author> <title> The next 700 programming languages. </title> <journal> Communications of the ACM, </journal> <volume> 9 </volume> <pages> 157-166, </pages> <year> 1966. </year>
Reference-contexts: In the spirit of Peter Landin's <ref> [Lan66] </ref> - -calculus equivalents of increasingly complex ofi texts are considered; a complete mapping function is given in Appendix C. 3.1 Representing Boolean values Just as in the pure untyped -calculus, values such as Booleans and integers have to be constructed from the raw -calculus.
Reference: [Mil80] <author> R. Milner. </author> <title> A Calculus for Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1980. </year>
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: + l 2 ():l ) j l 00 ():W ) In [Jon93c], a parallel construct is used in the ofi design notation; this is not used in [Jon93a] and is not considered in Appendix C but it could be mapped in much the way that Milner discusses Section 8.3 of <ref> [Mil89] </ref>. (Recall that Milner explains there why adding a sequential composition operator to interleaving-based process calculi can complicate the algebra.) 6 A specific transformation Many simple transformations such as removing temporary variables could be considered; in this paper attention is focused on transformations which affect concurrency. <p> Milner discusses useful examples of representing imperative languages in CCS already in <ref> [Mil89] </ref>. An early version of the mapping contained in this paper was nearly complete when [Wal91] was sent to the current author.
Reference: [Mil92a] <author> R. Milner. </author> <title> Functions as processes. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(2) </volume> <pages> 119-141, </pages> <year> 1992. </year>
Reference: [Mil92b] <author> R. Milner. </author> <title> The polyadic -calculus: A tutorial. </title> <editor> In M. Broy, editor, </editor> <title> Logic and Algebra of Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The approach followed here is to map the constructs of ofi to the -calculus <ref> [MPW92, Mil92b] </ref>. It would be possible to argue that this semantics is also giving too fine a level of granularity but in this case the -calculus has an algebra which makes it easy to reason about equivalencies between processes. <p> : : ) The name u can be seen as a `capability' 3 ; the naming rules of the -calculus ensure that different instances of c do not interfere with each other; interference can only occur when the owner of the name u shares it between parallel threads. (As in <ref> [Mil92b] </ref>, replication could also be used to model the sort of recursion which unfolds a new body as it is required; here, recursion is used directly.) So, the model of each instance is (with B u used recursively at the end of either method) B u = :M u 2 The <p> The fact that only one method can be active in any instance of Bit is regulated by the way the recursion on B u works. It is worth recording the SORTs (cf. <ref> [Mil92b] </ref>) for this definition: bit : B ; u: U ; ff w : A w ; ff r : A r ; ! w : w ; ! r : r ; s v : S V ; a v : A V where 8 &gt; : A w 7! <p> Furthermore, continuing work on general properties of rely/guarantee specifications (notably [Col93, CC93]) could force reconsideration of the approach taken in [Jon93c]. 9.2 Related work The reader is referred to <ref> [MPW92, Mil92b] </ref> for notes on the evolution of process algebras which permit name passing. Milner discusses useful examples of representing imperative languages in CCS already in [Mil89]. An early version of the mapping contained in this paper was nearly complete when [Wal91] was sent to the current author.
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes. </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year>
Reference-contexts: The approach followed here is to map the constructs of ofi to the -calculus <ref> [MPW92, Mil92b] </ref>. It would be possible to argue that this semantics is also giving too fine a level of granularity but in this case the -calculus has an algebra which makes it easy to reason about equivalencies between processes. <p> Furthermore, continuing work on general properties of rely/guarantee specifications (notably [Col93, CC93]) could force reconsideration of the approach taken in [Jon93c]. 9.2 Related work The reader is referred to <ref> [MPW92, Mil92b] </ref> for notes on the evolution of process algebras which permit name passing. Milner discusses useful examples of representing imperative languages in CCS already in [Mil89]. An early version of the mapping contained in this paper was nearly complete when [Wal91] was sent to the current author.
Reference: [Nel91] <author> G. Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Rather than being viewed as a contending programming language, it is hoped that ofi will be used as a design notation for the development of programs in languages like POOL [Ame89], ABCL [Yon90], Beta [KMMN91], Modula-3 <ref> [Nel91] </ref> or UFO [Sar92]. But if sound development methods are required design notations have to be given semantics. For example, the transformation rules used in [Jon93a] have to be shown to preserve observational equivalence.
Reference: [Nie92] <author> Oscar Nierstrasz. </author> <title> Towards an object calculus. </title> <editor> In M. Tokoro, O. Nierstrasz, and P.Wegner, editors, ECOOP'91, </editor> <booktitle> volume 612 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-20. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Another author who has investigated calculi which are suitable for object-oriented programming languages is Oscar Nierstrasz. His `object calculus' in <ref> [Nie92] </ref> can be compared to the higher-order -calculus. Further developments by the group at Keio University (e.g. [HY93]) on the -calculus could influence the approach to the required formalization of the proofs; furthermore [VH93] considers the problem of principal types in the -calculus.
Reference: [San93a] <author> D. Sangiorgi. </author> <title> From pi-calculus to higher-order pi-calculus and back. </title> <booktitle> In [GJ93], </booktitle> <pages> pages 151-166, </pages> <year> 1993. </year>
Reference-contexts: Other researchers who have provided semantics for object-oriented languages based on process algebras include Honda and Tokoro [HT91b] (based on [HT91a]) and [Vaa90] (employs the process algebra known as ACP). Davide Sangiorgi's work on the higher-order -calculus <ref> [San93b, San93a] </ref> provides strong arguments for using a higher-order calculus; [Wal93c] actually provides a mapping from ofi to the higher-order -calculus; and the proofs in [Wal93a] are based on this notion.
Reference: [San93b] <author> Davide Sangiorgi. </author> <title> Expressing Mobility in Process Algebras: First-Order and Higher-Order Paradigms. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Edinburgh University, </institution> <month> May </month> <year> 1993. </year> <note> printed as ECS-LFCS-93-266. </note>
Reference-contexts: Other researchers who have provided semantics for object-oriented languages based on process algebras include Honda and Tokoro [HT91b] (based on [HT91a]) and [Vaa90] (employs the process algebra known as ACP). Davide Sangiorgi's work on the higher-order -calculus <ref> [San93b, San93a] </ref> provides strong arguments for using a higher-order calculus; [Wal93c] actually provides a mapping from ofi to the higher-order -calculus; and the proofs in [Wal93a] are based on this notion.
Reference: [Sar92] <author> J. Sargeant. </author> <title> UFO united functions and objects draft language description. </title> <type> Technical Report UMCS-92-4-3, </type> <institution> Manchester University, </institution> <year> 1992. </year>
Reference-contexts: Rather than being viewed as a contending programming language, it is hoped that ofi will be used as a design notation for the development of programs in languages like POOL [Ame89], ABCL [Yon90], Beta [KMMN91], Modula-3 [Nel91] or UFO <ref> [Sar92] </ref>. But if sound development methods are required design notations have to be given semantics. For example, the transformation rules used in [Jon93a] have to be shown to preserve observational equivalence. A denotational semantics for ofi would have to deal with concurrency (relevant papers include [Wol88, AR89, AR92, dBdV91]).
Reference: [Vaa90] <author> F. W. Vaandrager. </author> <title> Process algebra semantics of POOL. </title> <booktitle> In [Bae90], </booktitle> <pages> pages 173-236, </pages> <year> 1990. </year>
Reference-contexts: Other researchers who have provided semantics for object-oriented languages based on process algebras include Honda and Tokoro [HT91b] (based on [HT91a]) and <ref> [Vaa90] </ref> (employs the process algebra known as ACP). Davide Sangiorgi's work on the higher-order -calculus [San93b, San93a] provides strong arguments for using a higher-order calculus; [Wal93c] actually provides a mapping from ofi to the higher-order -calculus; and the proofs in [Wal93a] are based on this notion.
Reference: [VH93] <author> V. T. Vasconcelos and K. Honda. </author> <title> Principal typing schemes in a polyadic -calculus. </title> <booktitle> In CONCUR'93, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: His `object calculus' in [Nie92] can be compared to the higher-order -calculus. Further developments by the group at Keio University (e.g. [HY93]) on the -calculus could influence the approach to the required formalization of the proofs; furthermore <ref> [VH93] </ref> considers the problem of principal types in the -calculus. Acknowledgements The author is grateful for financial support from the SERC who fund his Senior Research Fellowship. Technical acknowledgements to people who have helped with the evolution of ofi itself are contained in [Jon93a, Jon93c].
Reference: [Wal91] <author> D. Walker. </author> <title> -calculus semantics for object-oriented programming languages. </title> <booktitle> In [IM91], </booktitle> <pages> pages 532-547, </pages> <year> 1991. </year>
Reference-contexts: Milner discusses useful examples of representing imperative languages in CCS already in [Mil89]. An early version of the mapping contained in this paper was nearly complete when <ref> [Wal91] </ref> was sent to the current author. In that paper, Walker maps POOL to the monadic version of the -calculus but the paper had a stimulating effect on the mapping from ofi to the polyadic -calculus and resulted in a number of simplifications.
Reference: [Wal93a] <author> D. Walker. </author> <title> Algebraic proofs of properties of objects, </title> <month> July </month> <year> 1993. </year> <type> Draft paper, private communication. </type>
Reference-contexts: It is intended that no ofi program can be written which is sensitive to this difference but this conjecture has not yet been proved. Walker - in <ref> [Wal93a] </ref> constructs a detailed argument for the special case shown in Appendix A. 9 Discussion 9.1 Further work As discussed in [Jon92] some language issues remain to be resolved in ofi itself. <p> Davide Sangiorgi's work on the higher-order -calculus [San93b, San93a] provides strong arguments for using a higher-order calculus; [Wal93c] actually provides a mapping from ofi to the higher-order -calculus; and the proofs in <ref> [Wal93a] </ref> are based on this notion. The current author's concern is that the extra power of the higher-order calculus may make it more difficult to prove the sort of results which are needed here. As is seen in [Wal93a], it is in fact only necessary to use a second-order version of <p> a mapping from ofi to the higher-order -calculus; and the proofs in <ref> [Wal93a] </ref> are based on this notion. The current author's concern is that the extra power of the higher-order calculus may make it more difficult to prove the sort of results which are needed here. As is seen in [Wal93a], it is in fact only necessary to use a second-order version of the -calculus and even this is only really needed to provide a better model for value passing. <p> It is still a research issue to establish whether the extra power actually makes the sort of proof considered in the current paper easier or not: it is a tenet of object-oriented thinking that everything is passed as a name. David Walker in <ref> [Wal93a] </ref> has shown that two specific ofi transformations can be proved weakly bi-similar; it is hoped to combine the formality of that proof with the generality of arguing about the transformation rules themselves in a future paper.
Reference: [Wal93b] <author> D. Walker. </author> <title> Objects in the -calculus. </title> <journal> Information and Computation, </journal> <note> 1993. (to appear in). 19 </note>
Reference-contexts: A preliminary sketch of the mapping from ofi to the polyadic -calculus is given in [Jon92]. In <ref> [Wal93b] </ref>, Walker, amongst other things, provides a mapping from POOL to the polyadic -calculus and this again prompted revision of the mapping which is finally presented in [Jon93b] and repeated in Appendix C here.
Reference: [Wal93c] <author> D. Walker. </author> <title> Process calculus and parallel object-oriented programming languages. </title> <booktitle> In International Summer Institute on Parallel Computer Architectures, Languages, and Algorithms, </booktitle> <address> Prague, </address> <year> 1993. </year>
Reference-contexts: Other researchers who have provided semantics for object-oriented languages based on process algebras include Honda and Tokoro [HT91b] (based on [HT91a]) and [Vaa90] (employs the process algebra known as ACP). Davide Sangiorgi's work on the higher-order -calculus [San93b, San93a] provides strong arguments for using a higher-order calculus; <ref> [Wal93c] </ref> actually provides a mapping from ofi to the higher-order -calculus; and the proofs in [Wal93a] are based on this notion. The current author's concern is that the extra power of the higher-order calculus may make it more difficult to prove the sort of results which are needed here.
Reference: [WL93] <author> J. C. P. Woodcock and P. G. Larsen, editors. FME'93: </author> <title> Industrial-Strength Formal Methods, </title> <booktitle> volume 670 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [Wol88] <author> Mario I. Wolczko. </author> <title> Semantics of Object-Oriented Languages. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Manchester, </institution> <year> 1988. </year>
Reference-contexts: But if sound development methods are required design notations have to be given semantics. For example, the transformation rules used in [Jon93a] have to be shown to preserve observational equivalence. A denotational semantics for ofi would have to deal with concurrency (relevant papers include <ref> [Wol88, AR89, AR92, dBdV91] </ref>). In some respects, a semantics based on resumptions fits this sort of parallel object-based language quite well but there are some difficulties and these would even be shared by an operational semantics.
Reference: [Yon90] <editor> Akinori Yonezawa, editor. </editor> <title> ABCL: An Object-Oriented Concurrent System. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The design notation used in both of these papers is currently known as ofi. Rather than being viewed as a contending programming language, it is hoped that ofi will be used as a design notation for the development of programs in languages like POOL [Ame89], ABCL <ref> [Yon90] </ref>, Beta [KMMN91], Modula-3 [Nel91] or UFO [Sar92]. But if sound development methods are required design notations have to be given semantics. For example, the transformation rules used in [Jon93a] have to be shown to preserve observational equivalence.
References-found: 50

