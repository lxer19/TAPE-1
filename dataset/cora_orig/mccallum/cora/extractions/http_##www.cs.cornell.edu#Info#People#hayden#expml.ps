URL: http://www.cs.cornell.edu/Info/People/hayden/expml.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/hayden/publications.htm
Root-URL: 
Title: Distributed Communication in ML  
Author: Mark Hayden 
Affiliation: Computer Science Department Cornell University  
Abstract: We present our experience in implementing a group communication toolkit in Objective Caml, a dialect of the ML family of programming languages. We compare the toolkit both quantitatively and qualitatively to a predecessor toolkit which was implemented in C. Our experience shows that using the high-level abstraction features of ML gives substantial advantages. Some of these features, such as automatic memory management and message marshalling, allowed us to concentrate on those pieces of the implementation which required careful attention in order to achieve good performance. We conclude with a set of suggested changes to both the ML language and the particular implementation we used. 
Abstract-found: 1
Intro-found: 1
Reference: [Atk95] <author> R. Atkinson. </author> <title> Security architecture for the Internet Protocol. </title> <type> RFC 1825, </type> <month> August </month> <year> 1995. </year>
Reference-contexts: These draw from a large background of research on group communication. point, reliable, FIFO delivery of messages, flow control, and failure detection. With secure sockets <ref> [Atk95] </ref>, applications also get security properties. Similarly, group communication protocols provide a variety of properties. In fact, the properties that can be provided for groups are much richer than for pairs of processes because group-based applications have more structure.
Reference: [AWWV96] <author> J. Armstrong, M. Williams, C. Wikstrom, and R. Virding. </author> <title> Concurrent Programming in Erlang. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: One result of these differences was that Ensemble was able to achieve better performance than the implementation of Horus written in C, whereas the Fox TCP implementation is slower than implementations of TCP in C. Other related work has been done with Erlang <ref> [AWWV96, Hau94] </ref>. Er-lang, a product of Ericsson, is a functional language designed to support distributed telephone switching software. A number of impressive telecommunications products have been built using Erlang and they have found many of same advantages of using functional languages for distributed communication that we have.
Reference: [BHLM94] <author> Edoardo Biagioni, Robert Harper, Peter Lee, and Brian G. Milnes. </author> <title> Signatures for a network protocol stack: A systems application for Standard ML. </title> <booktitle> In Proc. of the ACM Conf. on Lisp and Functional Programming, </booktitle> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Functors are second class objects in ML and must be composed at compile time, which is incompatible with the needs of Ensemble. 1.3 Related work Closely related work has been done in the Fox project <ref> [BHLM94] </ref> which demonstrated the use of ML for systems programming. They developed a complete 4 TCP protocol stack in ML 1 that interfaces very closely with the network. However, the Fox work and Ensemble differ significantly. <p> Two techniques were used to achieve this. The first was a phased approach where closures are created when protocol stacks are initialized, but not during their normal execution. This technique is similar to that described in <ref> [BHLM94] </ref>. The second way was to use higher-order iterators for data structures such as list and array iterators. These are efficient because inlining of the iterator can eliminate closure allocation (although the Ocaml compiler currently does not do this).
Reference: [Bia94] <author> Edoardo Biagioni. </author> <title> A structured TCP in Standard ML. </title> <booktitle> In Proc. of the 1994 ACM Symp. on Communications Architectures & Protocols, </booktitle> <address> London, England, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: The difference between the three systems is that all data structures are explicitly managed in Horus and ISIS, whereas in Ensemble only buffers are. The use of formal module systems has been suggested as an important reason for using ML in layered communication systems <ref> [Bia94] </ref>. Ensemble uses modules for separate compilation and this speeds development. However, we do not make use of module composition (functors) for layer composition because Ensemble composes layers at run time.
Reference: [Bir96] <author> Kenneth P. Birman. </author> <title> Building Secure and Reliable Network Applications. </title> <publisher> Manning Publishing Company and Prentice Hall, </publisher> <month> December </month> <year> 1996. </year>
Reference-contexts: For instance, there are ordering properties on broadcasts (FIFO, Causal, Total), state transfer, network partitioning detection and healing, and client-server management. See Table 1 (a) for a list of many of the properties supported by Ensemble. In addition, there are many different protocols that satisfy these properties <ref> [Bir96] </ref>. One of the goals of Ensemble is to provide flexible support for a large collection of properties. To achieve this goal, Ensemble uses a layered ar 10 using the default Ensemble properties fGmp, Sync, Heal, Migrate, Switch, Frag, Suspect, Flowg. <p> When used with a totally ordered broadcast protocol (Ensemble has several such protocols in its library), virtual synchrony can be used to build fault-tolerant objects through the state-machine approach to replication <ref> [Bir96, Sch90] </ref>. Consider a replicated database in which the processes of a group form a set of distributed servers. The state is replicated across all the members in the group, and deterministic updates are disseminated to the group through total-ordered broadcasts.
Reference: [BJ87] <author> Kenneth P. Birman and Thomas A. Joseph. </author> <title> Exploiting virtual synchrony in distributed systems. </title> <booktitle> In Proc. of the Eleventh ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 123-138, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year>
Reference-contexts: Also, an application can change the desired properties on the fly and Ensemble will automatically switch to a protocol stack that meets the new demands . Group communication systems are often used to build fault-tolerant applications through a set of properties called virtual synchrony <ref> [BJ87] </ref>. Virtual synchrony guarantees that all members in a group see the same progression of membership changes or views. When failures are suspected (usually through timeouts), the remaining members of the group mark the members as faulty and install a new view that does not contain the suspected failed members.
Reference: [Bv94] <author> Kenneth P. Birman and Robbert van Renesse. </author> <title> Reliable Distributed Computing with the Isis Toolkit. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1994. </year>
Reference-contexts: The first, ISIS <ref> [Bv94] </ref>, was a pioneering group communication system that eventually grew into a successful commercial product. The second generation, Horus [vRBM96], was a reimplementation of ISIS based on a more flexible architecture with dynamically configurable protocol layers. Both ISIS and Horus were written in C.
Reference: [C + 86] <author> Robert L. Constable et al. </author> <title> Implementing Mathematics in the NuPRL Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: One of the major reasons for initially choosing ML was that we wished to investigate the use of theorem provers for verifying layered protocol architectures. A subset of ML is straightforward to import into NuPRL <ref> [C + 86] </ref>, a theorem prover developed at Cornell that we are using for verification, and this led us to use ML [Kre97]. In this paper, we do not discuss our work with NuPRL, but focus on the other effects of ML.
Reference: [Har96] <author> The Harlequin Group, </author> <title> Cambridge. The MLWorks User Guide, </title> <month> November </month> <year> 1996. </year>
Reference-contexts: While predicting what operations will cause memory allocation is usually easy in Ocaml programs, it is much more difficult to get a good picture of the overall memory allocation patterns in programs. Other systems, such as Harlequin's MLWorks environment <ref> [Har96] </ref>, provide support for profiling memory usage, 8 addition, processes broadcast messages to a group. so this kind of support is certainly possible. 2.6 Summary Our experience with Ocaml has been in general positive.
Reference: [Hau94] <author> Bogumil Hausman. </author> <title> Turbo Erlang: Approaching the speed of C. </title> <editor> In Evan Tick and Giancarlo Succi, editors, </editor> <booktitle> Implementations of Logic Programming Systems, </booktitle> <pages> pages 119-135. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year> <month> 36 </month>
Reference-contexts: One result of these differences was that Ensemble was able to achieve better performance than the implementation of Horus written in C, whereas the Fox TCP implementation is slower than implementations of TCP in C. Other related work has been done with Erlang <ref> [AWWV96, Hau94] </ref>. Er-lang, a product of Ericsson, is a functional language designed to support distributed telephone switching software. A number of impressive telecommunications products have been built using Erlang and they have found many of same advantages of using functional languages for distributed communication that we have.
Reference: [Hay92] <author> Barry Hayes. </author> <title> Finalization in the garbage collector interface. </title> <editor> In Yves Bekkers and Jacques Cohen, editors, </editor> <booktitle> International Workshop on Memory Management, </booktitle> <volume> volume 637, </volume> <pages> pages 277-298. </pages> <publisher> Springer Verlag LNCS, </publisher> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: This slows execution somewhat, but prevents memory errors. The opposite problem of memory leakage can occur if reference counts are occasionally not decremented to zero, causing segments to never be released. We addressed this problem by using weak pointers <ref> [Hay92] </ref> to detect when the reference count object (which wraps the segment) has no further references. When this happens, the problem is signaled to the user and the segment is recovered to prevent a memory leak (see Figure 6). Both ISIS and Horus had similar problems.
Reference: [Hv97] <author> Mark Hayden and Robbert van Renesse. </author> <title> Optimizing layered communication protocols. </title> <booktitle> In Proc. of the 1997 Symp. on High Performance Distributed Computing, </booktitle> <address> Portland, Oregon, </address> <month> August </month> <year> 1997. </year>
Reference-contexts: The structural changes we made in Ensemble enabled a sequence of optimizations not possible in the original Horus system. These optimizations make Ensemble the lowest latency reliable group communication system currently available. The use of ML facilitated the discovery and implementation of these optimizations, which are described in <ref> [Hv97] </ref> and formalized in [Kre97]. The other major factors that led us to adopt Ensemble were related to its cleaner architecture and increased flexibility. <p> To achieve this goal, Ensemble uses a layered ar 10 using the default Ensemble properties fGmp, Sync, Heal, Migrate, Switch, Frag, Suspect, Flowg. Ensemble provides a facility for translating from abstract properties to concrete protocol stacks. 11 chitecture, in which small protocol layers are composed to create protocol stacks <ref> [Hv97] </ref>. This architecture is similar to the one developed for Horus. An application requests a set of high-level properties and Ensemble constructs an appropriate stack of protocol layers from its growing library of more than 50 protocols. <p> Garbage collection has a minimal impact on performance because Ensemble allocates very little memory on the heap in the normal cases for sending and receiving messages, and none of the normal-case allocation gets promoted to the major heap. With the optimizations described in <ref> [Hv97] </ref>, the overhead for Ensemble drops to 41s. These same optimizations could be applied to Horus to achieve a similar speedup. However, many of the architectural improvements made to Ensemble would have to be replicated in Horus first, which would probably necessitate rewriting most of it. 4.7 Line counts. <p> The optimized version effectively eliminates the latency and message-size overhead of the general-purpose marshaller. This optimization is transparent to the protocols and requires no modification of the layers other than to identify their normal case headers during initialization (see <ref> [Hv97] </ref> for further details).
Reference: [Kre97] <author> Christoph Kreitz. </author> <title> Formal reasoning about communication systems I: Embedding ML into type theory. </title> <type> Technical Report TR97-1637, </type> <institution> Cornell University, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: These optimizations make Ensemble the lowest latency reliable group communication system currently available. The use of ML facilitated the discovery and implementation of these optimizations, which are described in [Hv97] and formalized in <ref> [Kre97] </ref>. The other major factors that led us to adopt Ensemble were related to its cleaner architecture and increased flexibility. <p> A subset of ML is straightforward to import into NuPRL [C + 86], a theorem prover developed at Cornell that we are using for verification, and this led us to use ML <ref> [Kre97] </ref>. In this paper, we do not discuss our work with NuPRL, but focus on the other effects of ML. ML constructs such as exceptions, garbage collection, and higher-order functions are useful but typically have a cost to performance in the language implementation.
Reference: [Ler97] <author> Xavier Leroy. </author> <title> The Objective Caml system release 1.05. </title> <institution> INRIA, France, </institution> <month> May </month> <year> 1997. </year>
Reference-contexts: We then conclude with a summary of our lessons and a list of features that we feel are missing from ML. 1 Fox uses Standard ML of NJ, whereas the implementation of ML we use is Objective Caml. 5 2 Ob jective Caml We used the Objective Caml (Ocaml) system <ref> [Ler97] </ref> which implements its own sub-dialect of the CAML [WL93] dialect of ML. Although this paper is intended to be general, it is important to distinguish between the ML family of programming languages and the particular implementation that we used.
Reference: [Mac93] <author> David MacQueen. </author> <title> Reflections on Standard ML. </title> <editor> In Peter E. Lauer, editor, </editor> <booktitle> Functional Programming, Concurrency, Simulation and Automated Reasoning, </booktitle> <volume> volume 693, </volume> <pages> pages 32-46. </pages> <publisher> Springer Verlag LNCS, </publisher> <year> 1993. </year>
Reference-contexts: Thus the creation of closures only appears outside common execution paths or in ways that can be easily optimized. 2.3 Memory management Ocaml supports garbage collected memory management. Although some ML implementations are perceived to require large amounts of memory <ref> [Mac93] </ref>, the Ocaml system is known for its efficient use of memory and this has not been a problem for us. Ocaml uses a generational garbage collector with a stop-and-copy minor heap and an incremental mark-and-sweep major heap. Our experiences with the garbage collector have been positive, with two exceptions.
Reference: [Maf95] <author> Silvano Maffeis. </author> <title> Adding group communication and fault-tolerance to CORBA. </title> <booktitle> In Proc. of the 1995 USENIX Conference on Object-Oriented Technologies, </booktitle> <address> Monterey, CA, June 1995. </address> <publisher> USENIX. </publisher>
Reference-contexts: As described above in Section 2 Ocaml provides adequate support for interfacing with C. In addition to C, C++, Tcl/Tk, and CORBA <ref> [Maf95] </ref>, which are supported by Horus, Ensemble also supports Smalltalk, Ada, and (of course) ML. 4.3 Supported platforms. Both Ensemble and Horus seek to be largely platform-independent. Horus is supported on a variety of UNIX platforms and a smattering of other operating systems such as Chorus and Mach. <p> Ensemble has considerably more demonstration programs than Horus. The bulk of the C code listed for Ensemble is for C/C++ interfaces, associated testing code, and an interface to the Electra CORBA-based replicated object system <ref> [Maf95] </ref>. No C code is actually needed to run Ensemble because the Ocaml UNIX library provides stubs for all needed system calls. However, Ensemble comes with its own set of UNIX stubs that can optionally be used to improve performance.
Reference: [PHOA93] <author> Larry L. Peterson, Norm Hutchinson, Sean O'Malley, and Mark Abbott. </author> <title> RPC in the x-Kernel: Evaluating new design techniques. </title> <booktitle> In Proc. of the Fourteenth ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 91-101, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Our approach with header formats takes a somewhat non-standard view of how to format messages. In contrast with many other systems <ref> [PHOA93, Pos81] </ref>, the formats of headers for individual layers are not defined at the byte level. In addition, the headers of a stack of protocol layers is not the concatenation of the headers of the individual layers. <p> In such systems, messages can be viewed as a "stack" of bytes and the application and protocols use operations to push and pop bytes onto and off of messages. This design originated with the X-Kernel <ref> [PHOA93] </ref>, although UNIX STREAMS has a similar feature. There are a variety of reasons for this approach, such as the need to adhere to strict, standardized header formats and the expectation that low-level operations are needed to achieve high performance. Unfortunately, such designs have costs.
Reference: [Pos81] <author> Jon Postel. </author> <title> Transmission control protocol. </title> <type> RFC 793, </type> <month> September </month> <year> 1981. </year>
Reference-contexts: Our approach with header formats takes a somewhat non-standard view of how to format messages. In contrast with many other systems <ref> [PHOA93, Pos81] </ref>, the formats of headers for individual layers are not defined at the byte level. In addition, the headers of a stack of protocol layers is not the concatenation of the headers of the individual layers.
Reference: [Sch90] <author> Fred B. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 299-319, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: When used with a totally ordered broadcast protocol (Ensemble has several such protocols in its library), virtual synchrony can be used to build fault-tolerant objects through the state-machine approach to replication <ref> [Bir96, Sch90] </ref>. Consider a replicated database in which the processes of a group form a set of distributed servers. The state is replicated across all the members in the group, and deterministic updates are disseminated to the group through total-ordered broadcasts.
Reference: [TMC + 96] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In 37 Proc. of the 1996 SIGPLAN Conference on Programming Lan--guage Design and Implementation, </booktitle> <year> 1996. </year>
Reference-contexts: Catenation is done by catenating arrays of iovecs. Thus, neither subset nor catenation copy the contents. Some recent work has focused on introducing support in ML for low-level data structures such as untagged word arrays <ref> [TMC + 96] </ref>. Such support is justified in part by the claim that it is needed in order to do real low-level systems work in ML.
Reference: [vRBM96] <author> Robbert van Renesse, Kenneth P. Birman, and Silvano Maffeis. Horus: </author> <title> A flexible group communication system. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 76-83, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: The first, ISIS [Bv94], was a pioneering group communication system that eventually grew into a successful commercial product. The second generation, Horus <ref> [vRBM96] </ref>, was a reimplementation of ISIS based on a more flexible architecture with dynamically configurable protocol layers. Both ISIS and Horus were written in C. Ensemble, the third generation, is a complete reimplementation of Horus in ML.
Reference: [WJNB95] <author> Paul R. Wilson, Mark S. Johnstone, Michael Neely, and David Boles. </author> <title> Dynamic storage allocation: A survey and critical review. </title> <booktitle> In Proc. of the International Workshop on Memory Management, </booktitle> <address> Kinross, Scotland, UK, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: However, this causes a copy for each message, and external fragmentation (unused space outside of objects) is still a problem because the Ocaml garbage collector (as with many non-copying collectors) does a poor job of managing large blocks of varying sizes <ref> [WJNB95] </ref>. 6.2 Using large message buffers Both sorts of fragmentation are avoided in Ensemble by using very large strings for allocating iovecs. These strings are called segments and are typically 256K bytes long. Segments are managed by msgbufs, which consist of a current segment and offset. <p> We are not aware of ML implementations that provide such support (although there are some for C <ref> [WJNB95] </ref>). Instead of adding more powerful general-purpose memory management, it may be sufficient to provide ML libraries for efficient buffer management, combined with support for file and network operations. * Compacting the memory heap for mark-and-sweep garbage collection.
Reference: [WL93] <author> Pierre Weis and Xavier Leroy. </author> <title> Le Language Caml. </title> <address> InterEditions, Paris, </address> <year> 1993. </year>
Reference-contexts: and a list of features that we feel are missing from ML. 1 Fox uses Standard ML of NJ, whereas the implementation of ML we use is Objective Caml. 5 2 Ob jective Caml We used the Objective Caml (Ocaml) system [Ler97] which implements its own sub-dialect of the CAML <ref> [WL93] </ref> dialect of ML. Although this paper is intended to be general, it is important to distinguish between the ML family of programming languages and the particular implementation that we used.
Reference: [X.287] <author> CCITT Recomendation X.208. </author> <title> Specification of Abstract Syntax Notation One (ASN.1), </title> <booktitle> 1987. </booktitle> <pages> 38 </pages>
Reference-contexts: Marshallers typically transparently handle incompatibilities in byte ordering and word size. There are numerous standard marshalling formats such as XDR and ASN.1 <ref> [X.287] </ref>. Ensemble uses the general-purpose marshaller in Ocaml, although it can easily support other marshallers. By representing headers as regular ML data structures, protocols can leverage the same powerful language features, such as pattern matching and type checking, that are used for other data structures.
References-found: 24

