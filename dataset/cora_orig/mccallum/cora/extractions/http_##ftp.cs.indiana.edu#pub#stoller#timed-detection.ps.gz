URL: http://ftp.cs.indiana.edu/pub/stoller/timed-detection.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/stoller.html
Root-URL: http://www.cs.indiana.edu
Title: Detecting Global Predicates in Distributed Systems with Clocks  
Author: Scott D. Stoller 
Keyword: gorithms based on Lamport's happened-before ordering. Sample applications  Index terms: global predicate detection, consistent global states, partially-synchronous systems, distributed debugging, real-time monitoring  
Note: are given to illustrate the benefits of this approach.  
Date: January 13, 1999  
Abstract: This paper proposes a framework for detecting global state predicates in systems of processes with approximately-synchronized real-time clocks. Timestamps from these clocks are used to define two orderings on events: "definitely occurred before" and "possibly occurred before". These orderings lead naturally to definitions of 3 distinct detection modalities, i.e., 3 meanings of "predicate held during a computation", namely: Poss db ! (" definitely held"), and Inst (" definitely held in a specific global state"). This paper defines these modalities and gives efficient algorithms for detecting them. The algorithms are based on algorithms of Garg and Waldecker, Alagar and Venkatesan, Cooper and Marzullo, and Fromentin and Raynal. Complexity analysis shows that under reasonable assumptions, these real-time-clock-based detection algorithms are less expensive than detection al db ! (" possibly held"), Def
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Sridhar Alagar and S. Venkatesan. </author> <title> Techniques to tackle state explosion in global predicate detection. </title> <booktitle> In Proc. International Conference on Parallel and Distributed Systems, </booktitle> <pages> pages 412-417, </pages> <month> December </month> <year> 1994. </year> <note> An expanded version is available from the authors. </note>
Reference-contexts: We obtain algorithms for detecting Poss db ! and Def db ! by adapting algorithms of Garg and Waldecker [13, 14], Alagar and Venkatesan <ref> [1] </ref>, and Cooper and Marzullo [6]. Modalities based on pb ! are quite different, because pb ! (unlike hb db !) is not a partial ordering. In fact, pb ! yields a degenerate case, in which the analogues of Poss hb ! and Def hb ! are equivalent. <p> This principle underlies detection algorithms of Cooper and Marzullo [6], Garg and Waldecker [13, 14], and Alagar and Venkatesan <ref> [1] </ref>. <p> A computation c satisfies Poss ,! iff CGS ,! (c) contains a global state satisfying . Def ,! is defined in terms of paths. A path through a partial order hS; i is a finite or infinite sequence 6 oe of distinct elements of S such that: (i) oe <ref> [1] </ref> is minimal with respect to ; (ii) for all ff 2 [1::joej 1], oe [ff + 1] is an immediate successor 7 of oe [ff]; and (iii) if oe is finite, then oe [joej] is maximal with respect to . <p> Process i sends to the monitor only local states satisfying its local predicate. 5.2 General Algorithm for Poss db We develop an on-line detection algorithm for Poss db ! by adapting Alagar and Venkatesan's algorithm for detecting Poss hb ! in non-terminating (i.e., infinite) computations <ref> [1] </ref>. Their algorithm is based on their procedure for depth-first search of a lattice of CGSs. A depth-first exploration of the lattice of CGSs for an infinite computation would never backtrack and thus would never visit some CGSs near the beginning of the lattice. <p> Then initStates (g 1 ; g 2 ) is given by <ref> [1] </ref>: procedure initStates (g 1 ; g 2 ) var i; S; for i := 1 to N if g 1 (i) 6= g 2 (i) ^ :(9g 2 S : g minstate (succ (g 1 (i)))) then insert (S; minstate (succ (g 1 (i)))) endif rof ; return S (10) <p> A straightforward approach is to maintain a set containing the CGSs that have been visited so far. However, this may be expensive in both space and time. Alagar and Venkatesan <ref> [1] </ref> proposed the following clever alternative.
Reference: [2] <author> Ozalp Babaoglu and Keith Marzullo. </author> <title> Consistent global states of distributed systems: Fundamental concepts and mechanisms. In Sape Mullender, editor, </title> <journal> Distributed Systems, </journal> <volume> chapter 5, </volume> <pages> pages 97-145. </pages> <publisher> Addison Wesley, </publisher> <address> 2nd edition, </address> <year> 1993. </year>
Reference-contexts: For example, this exponential cost was seen in two sample applications considered in [31], namely, a coherence protocol and a spanning-tree algorithm. A third drawback is that, in systems with hidden channels <ref> [2] </ref> (i.e., means of communication other than messages), happened-before does not accurately capture causal relationships, so Poss hb ! and Def hb ! do not accurately capture the meanings of "possibly held" and "definitely held". This paper proposes a framework for predicate detection in systems with approximately-synchronized real-time clocks. <p> information needed to construct interval timestamps can be obtained from standard clock synchronization subsystems, such as NTP [25, 26] or the Distributed Time Service in OSF DCE [27]. 4 Generic Theory of Consistent Global States Predicate detection in asynchronous systems is based on the theory of consistent global states (CGSs) <ref> [2] </ref>. Informally, a global state is consistent if it could have occurred during the computation. It is convenient to define "consistent" in terms of ideals. <p> Recall that an ideal of a partial order hS; OEi is a set I S such that (8x 2 I : 8y 2 S : y OE x ) y 2 I). Ideals of hEv (c); hb !i are called consistent cuts <ref> [2] </ref>. Recall that for any partial order, the set of its ideals ordered by inclusion () forms a lattice [8]. Furthermore, the set of CGSs ordered by forms a lattice that is isomorphic to the lattice of consistent cuts [28, 2]. <p> Ideals of hEv (c); hb !i are called consistent cuts [2]. Recall that for any partial order, the set of its ideals ordered by inclusion () forms a lattice [8]. Furthermore, the set of CGSs ordered by forms a lattice that is isomorphic to the lattice of consistent cuts <ref> [28, 2] </ref>. <p> Theorem 1. For every process-wise-total partial ordering ,! on Ev (c), the partial order hCGS ,! (c); i is a lattice and is isomorphic to the lattice of ideals of hEv (c); ,!i. Proof. This is true for the same reasons as in the standard theory based on happened-before <ref> [28, 2, 8] </ref>. The proof is straightforward. The following corollary underlies the detection algorithms in Sections 5 and 6. Corollary 2. <p> A detection algorithm based on happened-before could be used instead, if the system can be modified to maintain vector clocks (or for some reason maintains them already). However, if the coherence protocol uses timers, then time acts as a hidden channel <ref> [2] </ref> (i.e., a means of communication other than messages), so detection based on happened-before might yield less accurate results.
Reference: [3] <author> Ozalp Babaoglu and Michel Raynal. </author> <title> Specification and verification of behavioral patterns in distributed computations. </title> <booktitle> In Fourth International Working Conference on Dependable Computing for Critical Applications, </booktitle> <year> 1994. </year>
Reference-contexts: Directions for future work include: implementing the detection algorithms described above; developing efficient algorithms for detecting global properties that depend explicitly on time; and investigating clock-based detection of sequences of global states, perhaps along the lines of temporal modalities based on happened-before <ref> [16, 3, 11] </ref>. 2 Related Work Marzullo and Neiger [23] discuss global property detection in partially-synchronous systems in which a fixed bound * on the error between clocks is known.
Reference: [4] <author> Bernadette Charron-Bost, Carole Delporte-Gallet, and Hugues Fauconnier. </author> <title> Local and temporal predicates in distributed systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(1) </volume> <pages> 157-179, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Cooper and Marzullo's definitions of these modalities established an important conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [8, 13, 4, 17, 32, 14, 5, 12] </ref>. In practice, though, Poss hb ! , Def other modalities based on happened-before have significant drawbacks in many cases. First, in many systems, it is difficult to determine the happened-before relation. Happened-before can be determined if each process maintains a vector clock.
Reference: [5] <author> Craig M. Chase and Vijay K. Garg. </author> <title> Detection of global predicates: Techniques and their limitations. </title> <journal> Distributed Computing, </journal> <volume> 11(4) </volume> <pages> 169-189, </pages> <year> 1998. </year> <month> 26 </month>
Reference-contexts: Cooper and Marzullo's definitions of these modalities established an important conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [8, 13, 4, 17, 32, 14, 5, 12] </ref>. In practice, though, Poss hb ! , Def other modalities based on happened-before have significant drawbacks in many cases. First, in many systems, it is difficult to determine the happened-before relation. Happened-before can be determined if each process maintains a vector clock.
Reference: [6] <author> Robert Cooper and Keith Marzullo. </author> <title> Consistent detection of global predicates. </title> <booktitle> In Proc. ACM/ONR Workshop on Parallel and Distributed Debugging, 1991. Appeared as ACM SIGPLAN Notices 26(12) </booktitle> <pages> 167-174, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: Therefore, no process can determine the sequence of global states through which the system passed. This leads to an obvious difficulty for detecting whether a global state predicate (hereafter simply called a "predicate") held. Cooper and Marzullo proposed a solution for asynchronous distributed systems <ref> [6] </ref>. Their solution involves two modalities, which we denote by Poss hb ! ("possibly") and Def hb ! ("definitely"). These modalities are based on logical time [18] as embodied in the happened-before relation hb !, a partial ordering 1 of events that reflects potential causal dependencies. <p> We obtain algorithms for detecting Poss db ! and Def db ! by adapting algorithms of Garg and Waldecker [13, 14], Alagar and Venkatesan [1], and Cooper and Marzullo <ref> [6] </ref>. Modalities based on pb ! are quite different, because pb ! (unlike hb db !) is not a partial ordering. In fact, pb ! yields a degenerate case, in which the analogues of Poss hb ! and Def hb ! are equivalent. <p> This principle underlies detection algorithms of Cooper and Marzullo <ref> [6] </ref>, Garg and Waldecker [13, 14], and Alagar and Venkatesan [1]. <p> Right: Number of CGSs vs. =" and N , for E = 100, with =" from 2 to 50. Note that the vertical scales in these two graphs are very different. 5.3 General Algorithm for Def db The detection algorithm for Def hb ! in <ref> [6, 23] </ref> can be adapted to detect Def db ! by (roughly) replacing each condition of the form e 1 hb ! e 2 with e 1 db ! e 2 . That algorithm divides the lattice 18 into levels. <p> The level of a global state g is the sum of the levels of the constituent local states. Level ` of the lattice of CGSs contains the CGSs with level `. Following <ref> [6, 23] </ref>, we give an algorithm in which the monitor constructs one level of the lattice of CGSs at a time. Constructing one level of the lattice at a time is unnecessary and sometimes delays detection of a property; this construction is used only to simplify the presentation.
Reference: [7] <author> B. A. Davey and H. A. Priestley. </author> <title> Introduction to Lattices and Order. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: Proof. The existence of minimal elements in the lattice of CGSs follows immediately from non-emptiness and the absence of infinite descending chains in <ref> [7, chapter 2] </ref>. We prove by contradiction that the lattice of CGSs has a unique minimal element. Suppose CGSs g 1 and g 2 are minimal and g 1 6= g 2 . Let ^ G denote the meet operation of the lattice of CGSs.
Reference: [8] <author> Claire Diehl, Claude Jard, and Jean-Xavier Rampon. </author> <title> Reachability analysis on distributed executions. </title> <editor> In J.-P. Jouannaud and M.-C. Gaudel, editors, </editor> <booktitle> TAPSOFT '93: Theory and Practice of Software Development, volume 668 of Lecture Notes in Computer Science, </booktitle> <pages> pages 629-643. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Cooper and Marzullo's definitions of these modalities established an important conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [8, 13, 4, 17, 32, 14, 5, 12] </ref>. In practice, though, Poss hb ! , Def other modalities based on happened-before have significant drawbacks in many cases. First, in many systems, it is difficult to determine the happened-before relation. Happened-before can be determined if each process maintains a vector clock. <p> Ideals of hEv (c); hb !i are called consistent cuts [2]. Recall that for any partial order, the set of its ideals ordered by inclusion () forms a lattice <ref> [8] </ref>. Furthermore, the set of CGSs ordered by forms a lattice that is isomorphic to the lattice of consistent cuts [28, 2]. <p> Theorem 1. For every process-wise-total partial ordering ,! on Ev (c), the partial order hCGS ,! (c); i is a lattice and is isomorphic to the lattice of ideals of hEv (c); ,!i. Proof. This is true for the same reasons as in the standard theory based on happened-before <ref> [28, 2, 8] </ref>. The proof is straightforward. The following corollary underlies the detection algorithms in Sections 5 and 6. Corollary 2.
Reference: [9] <author> Eddy Fromentin and Michel Raynal. </author> <title> Inevitable global states: a concept to detect unstable properties of distributed computations in an observer independent way. </title> <booktitle> In Proc. Sixth IEEE Symposium on Parallel and Distributed Processing, </booktitle> <year> 1994. </year>
Reference-contexts: In fact, pb ! yields a degenerate case, in which the analogues of Poss hb ! and Def hb ! are equivalent. We show that this single modality, which we denote by Inst, is closely related to Fromentin and Raynal's concept of Properly hb ! <ref> [9, 10] </ref>, and we adapt for detecting Inst an algorithm of theirs for detecting Properly hb ! . Our detection framework is applicable to a wide range of systems, since it does not require that clocks be synchronized to within a fixed bound. <p> Also, [23] assumes a fixed bound on the error in clock synchronization. Our framework allows that bound to vary over time; this supports tighter bounds hence more accurate monitoring results. An attractive feature of Properly hb ! <ref> [9, 10] </ref> and Inst is that the monitor can report a single global state g satisfying that the system actually passed through. Def does not have this feature. However, Properly hb ! gives useful information only about systems that perform global (i.e., system-wide) barrier synchronization. <p> This does not change the asymptotic time complexity. 10 Fromentin and Raynal call elements of CGS hb ! inevitable global states <ref> [9] </ref>. 20 pb ! (c 1 ); i. Proof. <p> Our algorithm for detecting Inst is based on Fromentin and Raynal's algorithm for detecting Properly in asynchronous systems <ref> [9, 10] </ref>. <p> Theorem 7. Properly db ! is equivalent to Inst. Proof. It suffices to show that a global state g is in CGS pb ! (c) iff it is contained in every maximal path of CGS db ! (c). The proof is based on Theorem IGS of <ref> [9] </ref>, which states that a global state g is contained in every maximal path of hCGS hb ! (c); i iff (8i; j : S (g (i)) ! T (g (j)) _ g (i) = last (c (i))), where last returns the last element of a sequence.
Reference: [10] <author> Eddy Fromentin and Michel Raynal. </author> <title> Characterizing and detecting the set of global states seen by all observers of a distributed computation. </title> <booktitle> In Proc. IEEE 15th International Conference on Distributed Computing Systems (ICDCS), </booktitle> <year> 1995. </year>
Reference-contexts: In fact, pb ! yields a degenerate case, in which the analogues of Poss hb ! and Def hb ! are equivalent. We show that this single modality, which we denote by Inst, is closely related to Fromentin and Raynal's concept of Properly hb ! <ref> [9, 10] </ref>, and we adapt for detecting Inst an algorithm of theirs for detecting Properly hb ! . Our detection framework is applicable to a wide range of systems, since it does not require that clocks be synchronized to within a fixed bound. <p> Also, [23] assumes a fixed bound on the error in clock synchronization. Our framework allows that bound to vary over time; this supports tighter bounds hence more accurate monitoring results. An attractive feature of Properly hb ! <ref> [9, 10] </ref> and Inst is that the monitor can report a single global state g satisfying that the system actually passed through. Def does not have this feature. However, Properly hb ! gives useful information only about systems that perform global (i.e., system-wide) barrier synchronization. <p> Our algorithm for detecting Inst is based on Fromentin and Raynal's algorithm for detecting Properly in asynchronous systems <ref> [9, 10] </ref>.
Reference: [11] <author> Eddy Fromentin, Michel Raynal, Vijay K. Garg, and Alex Tomlinson. </author> <title> On-the-fly testing of regular patterns in distributed computations. </title> <booktitle> In Proc. 23rd International Conference on Parallel Processing, </booktitle> <volume> volume 2, </volume> <pages> pages 73-76, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Directions for future work include: implementing the detection algorithms described above; developing efficient algorithms for detecting global properties that depend explicitly on time; and investigating clock-based detection of sequences of global states, perhaps along the lines of temporal modalities based on happened-before <ref> [16, 3, 11] </ref>. 2 Related Work Marzullo and Neiger [23] discuss global property detection in partially-synchronous systems in which a fixed bound * on the error between clocks is known.
Reference: [12] <author> Vijay Garg, Craig Chase, Richard Kilgore, and J. Roger Mitchell. </author> <title> Efficient detection of channel predicates in distributed systems. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 45(2) </volume> <pages> 134-147, </pages> <month> September </month> <year> 1997. </year>
Reference-contexts: Cooper and Marzullo's definitions of these modalities established an important conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [8, 13, 4, 17, 32, 14, 5, 12] </ref>. In practice, though, Poss hb ! , Def other modalities based on happened-before have significant drawbacks in many cases. First, in many systems, it is difficult to determine the happened-before relation. Happened-before can be determined if each process maintains a vector clock.
Reference: [13] <author> Vijay K. Garg and Brian Waldecker. </author> <title> Detection of weak unstable predicates in distributed programs. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 5(3) </volume> <pages> 299-307, </pages> <year> 1994. </year>
Reference-contexts: Cooper and Marzullo's definitions of these modalities established an important conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [8, 13, 4, 17, 32, 14, 5, 12] </ref>. In practice, though, Poss hb ! , Def other modalities based on happened-before have significant drawbacks in many cases. First, in many systems, it is difficult to determine the happened-before relation. Happened-before can be determined if each process maintains a vector clock. <p> We obtain algorithms for detecting Poss db ! and Def db ! by adapting algorithms of Garg and Waldecker <ref> [13, 14] </ref>, Alagar and Venkatesan [1], and Cooper and Marzullo [6]. Modalities based on pb ! are quite different, because pb ! (unlike hb db !) is not a partial ordering. <p> This principle underlies detection algorithms of Cooper and Marzullo [6], Garg and Waldecker <ref> [13, 14] </ref>, and Alagar and Venkatesan [1]. <p> We consider first algorithms for detecting Poss db ! for a restricted class of predicates and then consider general algorithms for detecting Poss db ! and Def 5.1 Algorithms for Poss db and Def ! for Conjunctive Predicates Garg and Waldecker <ref> [13, 14] </ref> have developed efficient algorithms for detecting Poss hb ! and hb ! for conjunctive predicates . A predicate is conjunctive if it is a conjunction of predicates that each depend on the local state of one process.
Reference: [14] <author> Vijay K. Garg and Brian Waldecker. </author> <title> Detection of strong unstable predicates in distributed programs. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 7(12) </volume> <pages> 1323-1333, </pages> <year> 1996. </year>
Reference-contexts: Cooper and Marzullo's definitions of these modalities established an important conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [8, 13, 4, 17, 32, 14, 5, 12] </ref>. In practice, though, Poss hb ! , Def other modalities based on happened-before have significant drawbacks in many cases. First, in many systems, it is difficult to determine the happened-before relation. Happened-before can be determined if each process maintains a vector clock. <p> We obtain algorithms for detecting Poss db ! and Def db ! by adapting algorithms of Garg and Waldecker <ref> [13, 14] </ref>, Alagar and Venkatesan [1], and Cooper and Marzullo [6]. Modalities based on pb ! are quite different, because pb ! (unlike hb db !) is not a partial ordering. <p> This principle underlies detection algorithms of Cooper and Marzullo [6], Garg and Waldecker <ref> [13, 14] </ref>, and Alagar and Venkatesan [1]. <p> We consider first algorithms for detecting Poss db ! for a restricted class of predicates and then consider general algorithms for detecting Poss db ! and Def 5.1 Algorithms for Poss db and Def ! for Conjunctive Predicates Garg and Waldecker <ref> [13, 14] </ref> have developed efficient algorithms for detecting Poss hb ! and hb ! for conjunctive predicates . A predicate is conjunctive if it is a conjunction of predicates that each depend on the local state of one process. <p> A constant number of such operations are performed for each local state, so the worst-case time complexity of the algorithm in Figure 2 is O (EN log N ). Note that the time complexity is independent of the quality of clock synchronization. The algorithm in <ref> [14] </ref> for detecting Def hb ! for conjunctive can be adapted in a similar way to detect Def db ! for such predicates. <p> CGS, we exploit the fact that for every conjunctive predicate , if a computation satisfies Poss db ! , then PossConjAlg () finds and returns the unique minimal CGS satisfying ; the proof of this is closely analogous to the proof of the corresponding property of Garg and Waldecker's algorithm <ref> [14] </ref>. A corollary is: if CGS db ! (c) is not empty, then PossConjAlg (true) returns the initial CGS (otherwise, PossConjAlg (true) never calls return). Choosing the sequence of sublattices.
Reference: [15] <author> C. Gray and D. Cheriton. Leases: </author> <title> An efficient fault-tolerant mechanism for distributed file system consistency. </title> <booktitle> In Proc. 11th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 202-210, </pages> <year> 1989. </year>
Reference-contexts: in coherence protocols to: * obtain a lock, by broadcasting a request for a lock and, if no conflicting announcement is received within an appropriate time interval, granting oneself the lock. * release a lock, by associating a finite lifetime with the lock; such a lock is called a lease <ref> [15] </ref>. When the lifetime expires, all processes know (without further communication) that the lock has been released. For example, the resource allocation algorithm in [19, Section 5.1] uses timers in both of these ways.
Reference: [16] <author> Michel Hurfin, Noel Plouzeau, and Michel Raynal. </author> <title> Detecting atomic sequences of predicates in distributed computations. </title> <booktitle> In Proc. ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <year> 1993. </year>
Reference-contexts: Directions for future work include: implementing the detection algorithms described above; developing efficient algorithms for detecting global properties that depend explicitly on time; and investigating clock-based detection of sequences of global states, perhaps along the lines of temporal modalities based on happened-before <ref> [16, 3, 11] </ref>. 2 Related Work Marzullo and Neiger [23] discuss global property detection in partially-synchronous systems in which a fixed bound * on the error between clocks is known.
Reference: [17] <author> R. Jegou, R. Medina, and L. Nourine. </author> <title> Linear space algorithm for on-line detection of global predicates. </title> <editor> In J. Desel, editor, </editor> <booktitle> Proc. International Workshop on Structures in Concurrency Theory (STRICT '95). </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Cooper and Marzullo's definitions of these modalities established an important conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [8, 13, 4, 17, 32, 14, 5, 12] </ref>. In practice, though, Poss hb ! , Def other modalities based on happened-before have significant drawbacks in many cases. First, in many systems, it is difficult to determine the happened-before relation. Happened-before can be determined if each process maintains a vector clock.
Reference: [18] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-564, </pages> <year> 1978. </year> <month> 27 </month>
Reference-contexts: Cooper and Marzullo proposed a solution for asynchronous distributed systems [6]. Their solution involves two modalities, which we denote by Poss hb ! ("possibly") and Def hb ! ("definitely"). These modalities are based on logical time <ref> [18] </ref> as embodied in the happened-before relation hb !, a partial ordering 1 of events that reflects potential causal dependencies. Happened-before is not a total order, so it does not uniquely determine the history, but it does restrict the possibilities.
Reference: [19] <author> Leslie Lamport. </author> <title> Using time instead of timeout in fault-tolerant systems. </title> <journal> ACM Trans--actions on Programming Languages and Systems, </journal> <volume> 6(2) </volume> <pages> 256-280, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: When the lifetime expires, all processes know (without further communication) that the lock has been released. For example, the resource allocation algorithm in <ref> [19, Section 5.1] </ref> uses timers in both of these ways. These techniques use timers (instead of messages) for synchronization, so detection based on happened-before is less appropriate.
Reference: [20] <author> Leslie Lamport. </author> <title> The mutual exclusion problem: Part i|a theory of interprocess communication. </title> <journal> Journal of the ACM, </journal> <volume> 33(2) </volume> <pages> 313-326, </pages> <year> 1986. </year>
Reference-contexts: Since Inst, like Properly hb ! , can be detected efficiently for arbitrary predicates, it appears to be a useful modality. The "possibly occurred before" relation pb ! is reminiscent of Lamport's "can affect" relation for concurrent systems <ref> [20, 21] </ref>. Both relations may contain cycles because of overlap: for !, overlap of interval timestamps; for "can affect", overlap of non-atomic events. Our framework assumes events are atomic; this is appropriate for systems with message-based communication.
Reference: [21] <author> Leslie Lamport. </author> <title> On interprocess communication: Part 1. </title> <journal> Distributed Computing, </journal> <volume> 1 </volume> <pages> 76-101, </pages> <year> 1986. </year>
Reference-contexts: Since Inst, like Properly hb ! , can be detected efficiently for arbitrary predicates, it appears to be a useful modality. The "possibly occurred before" relation pb ! is reminiscent of Lamport's "can affect" relation for concurrent systems <ref> [20, 21] </ref>. Both relations may contain cycles because of overlap: for !, overlap of interval timestamps; for "can affect", overlap of non-atomic events. Our framework assumes events are atomic; this is appropriate for systems with message-based communication.
Reference: [22] <author> Barbara Liskov. </author> <title> Practical uses of synchronized clocks in distributed systems. </title> <booktitle> In Proc. Tenth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 1-9. </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: than typical clock synchronization error in a LAN, so this approach should detect most violations of one-copy semantics. 7.2 Concurrency Control for Distributed Transactions Leases can also be used for concurrency control in distributed database systems, to reduce the number of messages needed to commit read-only transactions, as described in <ref> [22, Section 7] </ref>. The idea is that a read-only transaction acquires leases as it uses data objects. If the transaction completes before any of those leases expires, then the coordinator commits the transaction, without further communication.
Reference: [23] <author> Keith Marzullo and Gil Neiger. </author> <title> Detection of global state predicates. </title> <booktitle> In Proc. 5th Int'l. Workshop on Distributed Algorithms (WDAG '91), volume 579 of Lecture Notes in Computer Science, </booktitle> <pages> pages 254-272. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: for future work include: implementing the detection algorithms described above; developing efficient algorithms for detecting global properties that depend explicitly on time; and investigating clock-based detection of sequences of global states, perhaps along the lines of temporal modalities based on happened-before [16, 3, 11]. 2 Related Work Marzullo and Neiger <ref> [23] </ref> discuss global property detection in partially-synchronous systems in which a fixed bound * on the error between clocks is known. <p> Third, incorporating happened-before would have obscured the presentation and complexity analysis of the real-time-based parts of the algorithms, which are the novel parts. Contributions of this paper relative to <ref> [23] </ref> include: detection algorithms based purely on real-time clocks; more efficient detection algorithms; and definition of and algorithm for Inst. [23] does not consider any modality analogous to Inst. Also, [23] assumes a fixed bound on the error in clock synchronization. <p> Third, incorporating happened-before would have obscured the presentation and complexity analysis of the real-time-based parts of the algorithms, which are the novel parts. Contributions of this paper relative to <ref> [23] </ref> include: detection algorithms based purely on real-time clocks; more efficient detection algorithms; and definition of and algorithm for Inst. [23] does not consider any modality analogous to Inst. Also, [23] assumes a fixed bound on the error in clock synchronization. Our framework allows that bound to vary over time; this supports tighter bounds hence more accurate monitoring results. <p> Contributions of this paper relative to <ref> [23] </ref> include: detection algorithms based purely on real-time clocks; more efficient detection algorithms; and definition of and algorithm for Inst. [23] does not consider any modality analogous to Inst. Also, [23] assumes a fixed bound on the error in clock synchronization. Our framework allows that bound to vary over time; this supports tighter bounds hence more accurate monitoring results. <p> Another approach, described in <ref> [23] </ref>, requires a bound on message latency: at each instant, the monitor can use its own local clock and this bound to determine a lower bound on the ending time of the last local state it received from a process. 5.2.1 Complexity To analyze the time complexity, we consider separately the <p> Right: Number of CGSs vs. =" and N , for E = 100, with =" from 2 to 50. Note that the vertical scales in these two graphs are very different. 5.3 General Algorithm for Def db The detection algorithm for Def hb ! in <ref> [6, 23] </ref> can be adapted to detect Def db ! by (roughly) replacing each condition of the form e 1 hb ! e 2 with e 1 db ! e 2 . That algorithm divides the lattice 18 into levels. <p> The level of a global state g is the sum of the levels of the constituent local states. Level ` of the lattice of CGSs contains the CGSs with level `. Following <ref> [6, 23] </ref>, we give an algorithm in which the monitor constructs one level of the lattice of CGSs at a time. Constructing one level of the lattice at a time is unnecessary and sometimes delays detection of a property; this construction is used only to simplify the presentation.
Reference: [24] <author> David L. Mills. </author> <title> Internet time synchronization: the Network Time Protocol. </title> <journal> IEEE Trans. Communications, </journal> <volume> 39(10) </volume> <pages> 1482-1493, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: In most local-area distributed systems, protocols like NTP can efficiently maintain synchronization of clocks to within a few milliseconds [26]. Even in extremely wide-area distributed systems like the Internet, clock synchronization can usually be maintained to within a few tens of milliseconds <ref> [24, 26] </ref>. The detection framework and algorithms proposed here are designed to provide a basis for monitoring and debugging applications in such systems. Some sample applications are described in Section 7, including applications in which timers provide a hidden channel, causing detection based on happened-before to be less appropriate.
Reference: [25] <author> David L. Mills. </author> <title> Network time protocol (version 3) specification, implementation and analysis. </title> <institution> DARPA Network Working Group Report RFC-1305, University of Delaware, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: In either case, the information needed to construct interval timestamps can be obtained from standard clock synchronization subsystems, such as NTP <ref> [25, 26] </ref> or the Distributed Time Service in OSF DCE [27]. 4 Generic Theory of Consistent Global States Predicate detection in asynchronous systems is based on the theory of consistent global states (CGSs) [2]. Informally, a global state is consistent if it could have occurred during the computation.
Reference: [26] <author> David L. Mills. </author> <title> Improved algorithms for synchronizing computer network clocks. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 3(3) </volume> <pages> 245-254, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The above condition on the error in clock synchronization holds in many systems. In most local-area distributed systems, protocols like NTP can efficiently maintain synchronization of clocks to within a few milliseconds <ref> [26] </ref>. Even in extremely wide-area distributed systems like the Internet, clock synchronization can usually be maintained to within a few tens of milliseconds [24, 26]. The detection framework and algorithms proposed here are designed to provide a basis for monitoring and debugging applications in such systems. <p> In most local-area distributed systems, protocols like NTP can efficiently maintain synchronization of clocks to within a few milliseconds [26]. Even in extremely wide-area distributed systems like the Internet, clock synchronization can usually be maintained to within a few tens of milliseconds <ref> [24, 26] </ref>. The detection framework and algorithms proposed here are designed to provide a basis for monitoring and debugging applications in such systems. Some sample applications are described in Section 7, including applications in which timers provide a hidden channel, causing detection based on happened-before to be less appropriate. <p> In either case, the information needed to construct interval timestamps can be obtained from standard clock synchronization subsystems, such as NTP <ref> [25, 26] </ref> or the Distributed Time Service in OSF DCE [27]. 4 Generic Theory of Consistent Global States Predicate detection in asynchronous systems is based on the theory of consistent global states (CGSs) [2]. Informally, a global state is consistent if it could have occurred during the computation.
Reference: [27] <author> OSF. </author> <title> Introduction to OSF DCE. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: In either case, the information needed to construct interval timestamps can be obtained from standard clock synchronization subsystems, such as NTP [25, 26] or the Distributed Time Service in OSF DCE <ref> [27] </ref>. 4 Generic Theory of Consistent Global States Predicate detection in asynchronous systems is based on the theory of consistent global states (CGSs) [2]. Informally, a global state is consistent if it could have occurred during the computation. It is convenient to define "consistent" in terms of ideals.
Reference: [28] <author> Reinhard Schwarz and Friedemann Mattern. </author> <title> Detecting causal relationships in distributed computations: In search of the holy grail. </title> <journal> Distributed Computing, </journal> <volume> 7(3) </volume> <pages> 149-174, </pages> <year> 1994. </year>
Reference-contexts: Ideals of hEv (c); hb !i are called consistent cuts [2]. Recall that for any partial order, the set of its ideals ordered by inclusion () forms a lattice [8]. Furthermore, the set of CGSs ordered by forms a lattice that is isomorphic to the lattice of consistent cuts <ref> [28, 2] </ref>. <p> Theorem 1. For every process-wise-total partial ordering ,! on Ev (c), the partial order hCGS ,! (c); i is a lattice and is isomorphic to the lattice of ideals of hEv (c); ,!i. Proof. This is true for the same reasons as in the standard theory based on happened-before <ref> [28, 2, 8] </ref>. The proof is straightforward. The following corollary underlies the detection algorithms in Sections 5 and 6. Corollary 2.
Reference: [29] <author> Abraham Silberschatz and Peter B. Galvin. </author> <title> Operating System Concepts. </title> <publisher> Addison Wes-ley, </publisher> <address> 4th edition, </address> <year> 1994. </year>
Reference-contexts: Clock-based monitoring is useful even for coherence protocols that provide weaker guarantees than cohrnt . For example, in the Sun Network File System (NFS) <ref> [29, Section 17.6.2] </ref>, file information is cached. Timers are used to limit staleness: if the cached information is needed again after the timer expires, the client asks the server whether the cached information is still valid.
Reference: [30] <author> Scott D. Stoller. </author> <title> Detecting global predicates in distributed systems with clocks. </title> <editor> In Marios Mavronikolas, editor, </editor> <booktitle> Proc. 11th International Workshop on Distributed Algorithms (WDAG '97), volume 1320 of Lecture Notes in Computer Science, </booktitle> <pages> pages 185-199. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Unfortunately, in a distributed system without perfect clock synchronization, it is, in general, fl A preliminary description of this work appeared in <ref> [30] </ref>. y Scott D. Stoller (stoller@cs.indiana.edu, www.cs.indiana.edu/~stoller/) is with the Department of Com puter Science, Indiana University, Bloomington, IN. 1 impossible for a process to determine the order in which events on different processors ac-tually occurred.
Reference: [31] <author> Scott D. Stoller and Yanhong A. Liu. </author> <title> Efficient symbolic detection of global properties in distributed systems. </title> <editor> In Alan J. Hu and Moshe Y. Vardi, editors, </editor> <booktitle> Proc. 10th Int'l. Conference on Computer-Aided Verification (CAV), volume 1427 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1998. </year> <month> 28 </month>
Reference-contexts: The worst case occurs when there is little or no communication and hence few causal dependencies, so that many interleavings must be explored. For example, this exponential cost was seen in two sample applications considered in <ref> [31] </ref>, namely, a coherence protocol and a spanning-tree algorithm.
Reference: [32] <author> Scott D. Stoller and Fred B. Schneider. </author> <title> Faster possibility detection by combining two approaches. </title> <editor> In Jean-Michel Helary and Michel Raynal, editors, </editor> <booktitle> Proc. 9th International Workshop on Distributed Algorithms (WDAG '95), volume 972 of Lecture Notes in Computer Science, </booktitle> <pages> pages 318-332. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: Cooper and Marzullo's definitions of these modalities established an important conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [8, 13, 4, 17, 32, 14, 5, 12] </ref>. In practice, though, Poss hb ! , Def other modalities based on happened-before have significant drawbacks in many cases. First, in many systems, it is difficult to determine the happened-before relation. Happened-before can be determined if each process maintains a vector clock.
Reference: [33] <author> Paulo Verissimo. </author> <title> Real-time communication. In Sape Mullender, editor, </title> <journal> Distributed Systems, </journal> <volume> chapter 17, </volume> <pages> pages 447-490. </pages> <publisher> Addison Wesley, </publisher> <address> 2nd edition, </address> <year> 1993. </year>
Reference-contexts: Both relations may contain cycles because of overlap: for !, overlap of interval timestamps; for "can affect", overlap of non-atomic events. Our framework assumes events are atomic; this is appropriate for systems with message-based communication. Verissimo <ref> [33] </ref> discusses the uncertainty in event orderings caused by the granularity 5 and imperfect synchronization of digital real-time clocks, analyzes the conditions under which this uncertainty is significant for an application, and describes a synchronization technique, suitable for certain applications, that masks this uncertainty. However, [33] does not aim for a <p> Verissimo <ref> [33] </ref> discusses the uncertainty in event orderings caused by the granularity 5 and imperfect synchronization of digital real-time clocks, analyzes the conditions under which this uncertainty is significant for an application, and describes a synchronization technique, suitable for certain applications, that masks this uncertainty. However, [33] does not aim for a general approach to detecting global properties in the presence of this uncertainty. 4 Our algorithms apply directly even to programs that use high-level communication libraries (e.g., a distributed shared memory (DSM) library) for which source code is not available; detecting happened-before in such cases would
References-found: 33

