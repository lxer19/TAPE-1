URL: http://polaris.cs.uiuc.edu/reports/1437.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/tech_reports.html
Root-URL: http://www.cs.uiuc.edu
Title: FALCON: An Environment for the Development of Scientific Libraries and Applications  
Author: L. De Rose K. Gallivan E. Gallopoulos B. Marsolf and D. Padua 
Address: 1308 West Main Street Urbana, Illinois 61801 USA  Rio, 265 00 Patra Greece  
Affiliation: Center for Supercomputing Research and Development University of Illinois at Urbana-Champaign  Laboratory for High-Performance Computer Architectures Department of Computer Engineering and Informatics University of Patras  
Note: To appear in the Proceedings of KBUP'95 First International Workshop on Knowledge-Based System for the (re)Use of Program Libraries. Sophia Antipolis France,  
Pubnum: CSRD Report No. 1437  
Email: E-mail: fderose,gallivan,stratis,marsolf,paduag@csrd.uiuc.edu  
Phone: FAX: +217 244 1351  
Date: November 1995  September 1995  
Abstract-found: 0
Intro-found: 1
Reference: [ App, 1995 ] <institution> Applied Parallel Research, Placerville, Cali-fornia. </institution> <note> FORGE Explorer User's Guide. Version 2.0, </note> <year> 1995. </year>
Reference-contexts: There has been some work on interactive program restructuring and there are some commercially avail 5 able interactive Fortran restructurers, such as FORGE <ref> [ App, 1995 ] </ref> . There are, however, no systems today that perform high-level restructuring and that include capabilities for algebraic, control structure, and library selection transformations. Falcon will contain two types of transformations, namely algebraic restructuring and primitive-set restructuring.
Reference: [ Baras et al., 1992 ] <author> P. Baras, J. Blum, J.C. Paumier, P. Witomski, and F. Rechenmann. EVE: </author> <title> An object-centered knowledge based PDE solver. In E.N. </title> <editor> Houstis, J.R. Rice, and R. Vichnevetsky, editors, </editor> <booktitle> Expert Systems for Scientific Computing, </booktitle> <pages> pages 1-18. </pages> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1992. </year>
Reference-contexts: Systems such as those described in <ref> [ Rechenmann and Rousseau, 1992; Baras et al., 1992 ] </ref> use a knowledge-based approach to synthesize specific solution strategies (methods plus data structures) in response to a scientific problem (tasks plus data entities).
Reference: [ Bik and Wijshoff, 1993 ] <author> A.J.C. Bik and H.A.G. Wijshoff. </author> <title> On Automatic Data Structure Selection and Code Generation for Sparse Computations. </title> <editor> In Utpal Banerjee, David Gelernter, Alex Nicolau, and David Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 57-75. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1993. </year> <booktitle> 6th International Workshop, </booktitle> <address> Portland, Oregon. </address>
Reference-contexts: This structural information is propagated using an algebra of structures which defines how the different structures interact for the various operations. This information is used by the interactive restructurer to replace general methods that operate on regular dense matrices with specialized functions for structured sparse matrices. See <ref> [ Bik and Wijshoff, 1993 ] </ref> for some related work.
Reference: [ Blume and Eigenmann, 1994 ] <author> W. Blume and R. Eigen-mann. </author> <title> The Range Test: A Dependence Test for Symbolic, Non-linear Expressions. </title> <booktitle> In Proceedings of Supercomputing '94, </booktitle> <pages> pages 528-537, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: It also makes use of a number of conventional analysis algorithms, including induction variable recognition [ Gerlek et al., to appear ] to compute upper and lower bounds of these variables, and propagation of the range of values of scalars and of those arrays used as subscripts <ref> [ Blume and Eigenmann, 1994; Cousot and Halbwachs, 1978 ] </ref> . This analysis is performed interprocedurally whenever the modules referenced in the program are available to the system.
Reference: [ Bodin et al., 1993 ] <author> F. Bodin, P. Beckman, D. Gannon, S. Narayana, and S. Yang. </author> <title> Distributed pC++: Basic Ideas for an Object Parallel Language. </title> <booktitle> In OON-SKI'93 Proceedings of the First Annual Object-Oriented Numerics Conference, </booktitle> <pages> pages 1-24, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Approaches that help the programmer of high-performance computers develop and port parallel programs and library routines across machines include tools for automatic language translation (e.g. [ Polychronopoulos et al., August 1989; Padua et al., 1993 ] ); annotation of conventional languages <ref> [ Bodin et al., 1993 ] </ref> ; very high-level languages for the description of mathematical problems ( [ Houstis et al., 1990b ] ), possibly in combination with expert system advice ( [ Houstis et al., 1990a ] ). <p> This enables us to perform complex algebraic transformations on the source program. Our long-term goal is to generate code for a variety of machines, including conventional workstations, vector supercomputers, shared-memory multiprocessors, and multicomputers. The target languages of the system are Fortran 90 and pC++ <ref> [ Bodin et al., 1993 ] </ref> .
Reference: [ Carr and Kennedy, 1992 ] <author> S. Carr and K. Kennedy. </author> <title> Compiler Blockability of Numerical Algorithms. </title> <booktitle> In Proceedings, Supercomputing '92, </booktitle> <pages> pages 114-124, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: These additional operations were generated by utilizing the definition of the transform; they would not have been apparent by just examining the code. This utilization of algebraic information is being performed not only by algorithm developers, but is also being explored by compiler writers <ref> [ Carr and Kennedy, 1992 ] </ref> . The transformations will be based on patterns that the system can recognize in the code and on the replacements for these patterns. The developer will be able to select a segment of code and the system will indicate which patterns match the segment.
Reference: [ Char et al., 1991 ] <author> B.W. Char, K.O. Geddes, G.H. Gonnet, B.L. Leong, M.B. Monagan, and S.M. Watt. </author> <title> Maple V Language Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: MATLAB 1 [ Mat, 1992 ] offers tools (language, libraries of modules, graphics, IO, GUI) that have as primary objective rapid prototyp-ing and is best suited for applications with a significant numerical linear algebra component. Like Math-ematica and Maple <ref> [ Wolfram, 1991; Char et al., 1991 ] </ref> , MATLAB offers a sophisticated external interface that allows it to call C and Fortran subroutines as well as the use of MATLAB as a computational engine. The convenient features of MATLAB, however, frequently come at the cost of low computational performance.
Reference: [ Ching, 1986 ] <author> W.-M. Ching. </author> <title> Program Analysis and Code Generation in an APL/370 Compiler. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 30:6:594-602, </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: We make use of some of the type inferencing techniques developed for SETL and APL <ref> [ Schwartz, 1975; Ching, 1986 ] </ref> and extend them with techniques to analyze array accesses and represent the information gathered in a compact form [ Tu and Padua, 1993 ] .
Reference: [ Cousot and Halbwachs, 1978 ] <author> P. Cousot and N. Halb-wachs. </author> <title> Automatic Discovery of Linear Restraints Among Variables of a Program. </title> <booktitle> In Proceedings of the 5th Anual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-97, </pages> <year> 1978. </year>
Reference-contexts: It also makes use of a number of conventional analysis algorithms, including induction variable recognition [ Gerlek et al., to appear ] to compute upper and lower bounds of these variables, and propagation of the range of values of scalars and of those arrays used as subscripts <ref> [ Blume and Eigenmann, 1994; Cousot and Halbwachs, 1978 ] </ref> . This analysis is performed interprocedurally whenever the modules referenced in the program are available to the system.
Reference: [ Cytron et al., 1991 ] <author> R. Cytron, J. Ferrante, B.K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently Computing Static Single Assignment Form and the Control Dependence Graph. </title> <journal> ACM Transactions on Programming Language and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: During the compilation of the MATLAB program, M-files are inlined into the main program. This approach is appealing because the variable properties can be easily propagated inside the functions. Use-Definition Coverage The MATLAB program is internally represented in Static Single Assignment (SSA) form <ref> [ Cytron et al., 1991 ] </ref> . This is a convenient representation for many of the analysis algorithms that are implemented. In the SSA representation, it is evident which definitions affect (or cover) a particular use of a scalar variable.
Reference: [ DeRose et al., 1994 ] <author> L. DeRose, K. Gallivan, E. Gal-lopoulos, B. Marsolf, and D. Padua. </author> <title> An Environment for the Rapid Prototyping and Development of Numerical Programs and Libraries for Scientific Computation. </title> <editor> In F. Makedon, editor, </editor> <booktitle> Proc. of the DAGS'94 Symposium: Parallel Computation and Problem Solving Environments, </booktitle> <pages> pages 11-25, </pages> <institution> Dartmouth College, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: algorithmic-level in order to obtain good numerical and computational performance; FALCON supports the development and reuse of numerical programs and libraries, and combines the transformation and analysis techniques used in restructuring compilers with the algebraic techniques used by developers to express and manipulate their algorithms in an intuitively useful manner <ref> [ DeRose et al., 1994 ] </ref> . A major effort in this research is devoted to the development of the interactive restructuring system which, through correctness-preserving transformations, will lead to efficient code from the original prototype.
Reference: [ DeRose et al., to appear ] <author> L. DeRose, K. Gallivan, E. Gal-lopoulos, B. Marsolf, and D. Padua. </author> <title> FALCON: A MAT-LAB Interactive Restructuring Compiler. In Languages and Compilers for Parallel Computing. </title> <note> Springer-Verlag, to appear. 8th International Workshop, </note> <institution> Columbus, Ohio. </institution>
Reference-contexts: Other libraries, such as a level-3 BLAS or a sparse library, can be supported. We tested the performance of the of the compiler running a set of MATLAB programs, and compared the execution time of the MATLAB programs with their compiled versions. As was shown in <ref> [ DeRose et al., to appear ] </ref> , programs that require dynamic allocation of matrices inside of a loop had an improvement on the order of 20 on a workstation and were 60 times faster on a vector supercomputer.
Reference: [ Gallivan and Marsolf, 1994 ] <author> K. Gallivan and B. Marsolf. </author> <title> Practical Issues Related to Developing Object-Oriented Numerical Libraries. </title> <booktitle> In OON-SKI'94 Proceedings of the Second Annual Object-Oriented Numerics Conference, </booktitle> <pages> pages 93-106, </pages> <month> April </month> <year> 1994. </year>
Reference: [ Gallivan et al., 1995 ] <author> K. Gallivan, B. Marsolf, A. Bik, and H. Wijshoff. </author> <title> The Generation of Optimized Codes using Nonzero Structure Analysis. </title> <type> Technical Report 1451, </type> <institution> Center for Supercomputing Research and Development, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: Further details on the calculus can be found in <ref> [ Gallivan et al., 1995 ] </ref> . 3 Current Status Presently we have a compiler that can parse MAT-LAB code into the AST and generate Fortran 90 for most operations and built-in functions.
Reference: [ Gallopoulos et al., 1992 ] <author> E. Gallopoulos, E. N. Houstis, and J. R. Rice. </author> <title> Future Research Directions in Problem 10 Solving Environments for Computational Science. Re--port of a Workshop on Research Directions in Integrating Numerical Analysis, Symbolic Computing, Computational Geometry, and Artificial Intelligence for Computational Science. </title> <type> Technical Report 1259, </type> <institution> Center for Supercomputing Research and Development, </institution> <month> Oct. </month> <year> 1992. </year> <title> Workshop held at NSF, </title> <address> Washington, D.C., </address> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: high-level language out 1 MATLAB is a trademark of The MathWorks, Inc. 1 put from programs written in the language of the PSE and subsequently take advantage of mature compiler technology to obtain high performance; and to exploit the environment's high-level knowledge of the problem to enhance the compilation process <ref> [ Gallopoulos et al., 1992 ] </ref> . As is shown in this paper, these suggestions are useful and practical. The prototype environment that we are developing is called FALCON (for Fast Array Language COmputatioN).
Reference: [ Gerlek et al., to appear ] <author> M.P. Gerlek, E. Stoltz, and M. Wolfe. </author> <title> Beyond Induction Variables: Detecting and Classifying Sequences Using a Demand-driven SSA Form. </title> <journal> ACM TOPLAS, </journal> <note> to appear. </note>
Reference-contexts: It also makes use of a number of conventional analysis algorithms, including induction variable recognition <ref> [ Gerlek et al., to appear ] </ref> to compute upper and lower bounds of these variables, and propagation of the range of values of scalars and of those arrays used as subscripts [ Blume and Eigenmann, 1994; Cousot and Halbwachs, 1978 ] .
Reference: [ Houstis et al., 1990a ] <author> E. N. Houstis, T. S. Papatheodorou, and J. R. Rice. </author> <title> Parallel ELLPACK: An expert system for the parallel processing of partial differential equations. </title> <booktitle> In Intelligent Mathematical Software Systems, </booktitle> <pages> pages 63-73. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: translation (e.g. [ Polychronopoulos et al., August 1989; Padua et al., 1993 ] ); annotation of conventional languages [ Bodin et al., 1993 ] ; very high-level languages for the description of mathematical problems ( [ Houstis et al., 1990b ] ), possibly in combination with expert system advice ( <ref> [ Houstis et al., 1990a ] </ref> ). Systems such as those described in [ Rechenmann and Rousseau, 1992; Baras et al., 1992 ] use a knowledge-based approach to synthesize specific solution strategies (methods plus data structures) in response to a scientific problem (tasks plus data entities).
Reference: [ Houstis et al., 1990b ] <author> E.N. Houstis, J.R. Rice, </author> <title> N.P. Chrisochoides, </title> <editor> H.C. Karathanasis, P.N. Papachiou, M.K. Samartizs, E.A. Vavalis, K.Y. Wang, and S. Weer-awarana. </editor> <title> //ELLPACK: A Numerical Simulation Programming Environment for Parallel MIMD Machines. </title> <booktitle> In Proceedings 1990 International Conference on Supercomputing, </booktitle> <pages> pages 96-107, </pages> <year> 1990. </year>
Reference-contexts: develop and port parallel programs and library routines across machines include tools for automatic language translation (e.g. [ Polychronopoulos et al., August 1989; Padua et al., 1993 ] ); annotation of conventional languages [ Bodin et al., 1993 ] ; very high-level languages for the description of mathematical problems ( <ref> [ Houstis et al., 1990b ] </ref> ), possibly in combination with expert system advice ( [ Houstis et al., 1990a ] ).
Reference: [ Mat, 1992 ] <author> The Math Works, Inc. </author> <title> MATLAB, High-Performance Numeric Computation and Visualization Software. User's Guide, </title> <year> 1992. </year>
Reference-contexts: Systems such as those described in [ Rechenmann and Rousseau, 1992; Baras et al., 1992 ] use a knowledge-based approach to synthesize specific solution strategies (methods plus data structures) in response to a scientific problem (tasks plus data entities). MATLAB 1 <ref> [ Mat, 1992 ] </ref> offers tools (language, libraries of modules, graphics, IO, GUI) that have as primary objective rapid prototyp-ing and is best suited for applications with a significant numerical linear algebra component.
Reference: [ Muraoka and Kuck, 1973 ] <author> Y. Muraoka and D.J. Kuck. </author> <title> On the Time Required for a Sequence of Matrix Products. </title> <journal> Communications of the ACM, </journal> <volume> 16(1) </volume> <pages> 22-26, </pages> <month> Jan. </month> <year> 1973. </year>
Reference-contexts: For instance, the multiplication operations are not commutative and, with matrices, commutation may not even be possible due to dimension incompatibilities. Furthermore, the order in which matrix operations are performed can have a significant effect on the number of operations to be performed <ref> [ Muraoka and Kuck, 1973 ] </ref> .
Reference: [ Padua et al., 1993 ] <author> D. Padua, R. Eigenmann, J. Hoe-flinger, P. Petersen, P. Tu, S. Weatherford, and K. Fai-gin. </author> <title> Polaris: A New-Generation Parallelizing Compiler for MPP's. </title> <type> Technical report, </type> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Research and Development, </institution> <month> June </month> <year> 1993. </year> <note> CSRD Report No. 1306. </note>
Reference-contexts: Unfortunately, it is fair to say that there exist no widely accepted tools that satisfy all the above goals. Approaches that help the programmer of high-performance computers develop and port parallel programs and library routines across machines include tools for automatic language translation (e.g. <ref> [ Polychronopoulos et al., August 1989; Padua et al., 1993 ] </ref> ); annotation of conventional languages [ Bodin et al., 1993 ] ; very high-level languages for the description of mathematical problems ( [ Houstis et al., 1990b ] ), possibly in combination with expert system advice ( [ Houstis et <p> The code generator makes use of the information gathered by the program analysis phase to generate a Fortran 90 program or routine. Furthermore, the code generator can also produce an optimized MAT-LAB program. The actual generation of parallel code will be done by a restructuring compiler, such as Po-laris <ref> [ Padua et al., 1993 ] </ref> . Our system facilitates the translation into parallel form by annotating the target Fortran program and by using array operations whenever possible.
Reference: [ Polychronopoulos et al., August 1989 ] <author> C. Poly-chronopoulos, M. Girkar, M.R. Haghighat, C.-L. Lee, B. Leung, and D. Schouten. </author> <title> Parafrase-2: A New Generation Parallelizing Compiler. </title> <booktitle> In Proceedings of 1989 Int'l. Conference on Parallel Processing, </booktitle> <address> St. Charles, IL, </address> <booktitle> volume II, </booktitle> <pages> pages 39-48, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Unfortunately, it is fair to say that there exist no widely accepted tools that satisfy all the above goals. Approaches that help the programmer of high-performance computers develop and port parallel programs and library routines across machines include tools for automatic language translation (e.g. <ref> [ Polychronopoulos et al., August 1989; Padua et al., 1993 ] </ref> ); annotation of conventional languages [ Bodin et al., 1993 ] ; very high-level languages for the description of mathematical problems ( [ Houstis et al., 1990b ] ), possibly in combination with expert system advice ( [ Houstis et
Reference: [ Rechenmann and Rousseau, 1992 ] <author> F. Rechenmann and B. Rousseau. </author> <title> A development shell for knowledge based systems in scientific computing. </title> <editor> In E. N. Houstis, J.R. Rice, and R. Vichnevetsky, editors, </editor> <booktitle> Expert Systems for Scientific Computing, </booktitle> <pages> pages 157-173. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1992. </year>
Reference-contexts: Systems such as those described in <ref> [ Rechenmann and Rousseau, 1992; Baras et al., 1992 ] </ref> use a knowledge-based approach to synthesize specific solution strategies (methods plus data structures) in response to a scientific problem (tasks plus data entities). <p> Some characteristics can be semi-ordered in a lattice through which properties are inherited. For instance, operations on a square matrix will work on a lower triangular matrix, and operations on a lower triangular matrix will also work on a diagonal matrix. However, as shown in <ref> [ Rechenmann and Rousseau, 1992 ] </ref> , the general classification problem is complex and probably is best handled using multiple points of view on the data entities (matrices, etc.) It is also worth noting that some complex algebraic transformations, will require from the system to match code segments according to characteristics
Reference: [ Schwartz, 1975 ] <author> J.T. Schwartz. </author> <title> Automatic Data Structure Choice in a Language of a Very High Level. </title> <journal> Comm. ACM, </journal> <volume> 18 </volume> <pages> 722-728, </pages> <year> 1975. </year>
Reference-contexts: We make use of some of the type inferencing techniques developed for SETL and APL <ref> [ Schwartz, 1975; Ching, 1986 ] </ref> and extend them with techniques to analyze array accesses and represent the information gathered in a compact form [ Tu and Padua, 1993 ] . <p> Type Inference To generate Fortran declarations and to support structure selection, the system infers variable properties. Variable properties are estimated using a forward/backward scheme. For type inference, we use a type algebra similar to the one described in <ref> [ Schwartz, 1975 ] </ref> for SETL. This algebra operates on the type of the MATLAB objects and is implemented using of tables for all operations. Each node of the graph representing the program internally contains attribute fields to store inference information.
Reference: [ Tu and Padua, 1993 ] <author> P. Tu and D. Padua. </author> <title> Automatic Array Privatization. </title> <editor> In U. Banerjee, D. Gelernter, A. Nico-lau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 500-521. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1993. </year> <booktitle> 6th International Workshop, </booktitle> <address> Portland, Oregon. </address>
Reference-contexts: We make use of some of the type inferencing techniques developed for SETL and APL [ Schwartz, 1975; Ching, 1986 ] and extend them with techniques to analyze array accesses and represent the information gathered in a compact form <ref> [ Tu and Padua, 1993 ] </ref> . These are necessary for MAT-LAB, since arrays are often built using Fortran-like loops and assignments that may be distributed across several sections of the code. There are two types of functions in MATLAB: intrinsic (or built-in) functions and M-files. <p> We plan to attack the problem of array memory allocation using the techniques described in <ref> [ Tu and Padua, 1993 ] </ref> . These have proven quite effective in detecting privatizable arrays in Fortran programs and should be at least equally effective in this context. The strategy uses data flow analysis to determine which definitions cover the uses of array elements. <p> The analysis of ranges and induction variables is facilitated by the use of the SSA representation. These algorithms are applied on-demand. That is, only those values needed are estimated. Our experience is that on-demand analysis substantially improves performance over the conventional forward propagation algorithms <ref> [ Tu and Padua, 1993 ] </ref> . Type Inference To generate Fortran declarations and to support structure selection, the system infers variable properties. Variable properties are estimated using a forward/backward scheme.
Reference: [ Wolfram, 1991 ] <author> S. Wolfram. </author> <title> Mathematica: A System for Doing Mathematics by Computer. </title> <publisher> Addison-Wesley, </publisher> <address> Boston, </address> <note> second edition, 1991. 11 </note>
Reference-contexts: MATLAB 1 [ Mat, 1992 ] offers tools (language, libraries of modules, graphics, IO, GUI) that have as primary objective rapid prototyp-ing and is best suited for applications with a significant numerical linear algebra component. Like Math-ematica and Maple <ref> [ Wolfram, 1991; Char et al., 1991 ] </ref> , MATLAB offers a sophisticated external interface that allows it to call C and Fortran subroutines as well as the use of MATLAB as a computational engine. The convenient features of MATLAB, however, frequently come at the cost of low computational performance.
References-found: 26

