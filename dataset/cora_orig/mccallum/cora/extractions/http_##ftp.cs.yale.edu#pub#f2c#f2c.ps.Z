URL: http://ftp.cs.yale.edu/pub/f2c/f2c.ps.Z
Refering-URL: http://ftp.cs.yale.edu/pub/f2c/
Root-URL: http://www.cs.yale.edu
Title: A Fortran-to-C Converter  
Author: S. I. Feldman David M. Gay Mark W. Maimone N. L. Schryer 
Note: Originally issued  
Date: 149  Last updated March 19, 1993.  May 16, 1990.  
Address: Murray Hill, NJ 07974  Morristown, NJ 07960  Pittsburgh, PA 15213  
Affiliation: AT&T Bell Laboratories  Bell Communications Research,  Carnegie-Mellon University,  
Pubnum: Computing Science Technical Report No.  
Abstract-found: 0
Intro-found: 1
Reference: [1] <institution> American National Standard Programming Language FORTRAN, American National Standards Institute, </institution> <address> New York, NY, </address> <year> 1978. </year> <title> ANSI X3.9-1978. </title>
Reference-contexts: 1. INTRODUCTION Automatic conversion of Fortran 77 <ref> [1] </ref> to C [10, 11] is desirable for several reasons. Sometimes it is useful to run a well-tested Fortran program on a machine that has a C compiler but no Fortran compiler. At other times, it is convenient to mix C and Fortran. <p> (10) real r (10) integer i (10) logical m (10) if (m (i (2))) d (3) = d (4)/d (5) result in struct - complex c [10]; doublereal d [10]; real r [10]; integer i [10]; logical m [10]; - named_; #define named_1 named_ . . . if (named_1.m [named_1.i <ref> [1] </ref> - 1]) - named_1.d [2] = named_1.d [3] / named_1.d [4]; - Under the -p option, the above if statement becomes more readable: . . . #define c (named_1.c) #define d (named_1.d) #define r (named_1.r) #define i (named_1.i) #define m (named_1.m) . . . d [2] = d [3] / <p> integer c_ _14 = 14; May 24, 1992 - 14 - /* Main program */ MAIN_ _ () - /* Local variables */ #define d ((doublereal *)&cmname_1) #define i ((integer *)&cmname_1) #define l ((logical *)&cmname_1) #define r ((real *)&cmname_1) extern /* Subroutine */ int sam_ (); sam_ (cmname_1.c, d, &r <ref> [1] </ref>, &i [2], &m [3], "some hollerith", &c_ _14, 14L); - /* MAIN_ _ */ #undef r #undef l #undef i #undef d As this example shows, f 2c turns a Fortran MAIN program into a C function named MAIN_ _.
Reference: [2] <institution> American National Standard for Information Systems Programming Language Fortran, CBEMA, </institution> <year> 1989. </year> <note> Draft S8, Version 112. </note>
Reference-contexts: Finally, Appendix B contains a man page telling how to use f 2c. 2. INTERLANGUAGE CONVENTIONS Much of the material in this section is taken from [6]. Names An f 2c extension inspired by Fortran 90 (until recently called Fortran 8x <ref> [2] </ref>) is that long names are allowed (f 2c truncates names that are longer than 50 characters), and names may contain underscores. To avoid conflict with the names of library routines and with names that f 2c generates, Fortran names may have one or two underscores appended. <p> F 2c recognizes the Fortran 90 synonyms &lt;, &lt;=, ==, &gt;=, &gt;, and &lt;&gt; for the Fortran comparison operators .LT., .LE., .EQ., .GE., .GT., and .NE. Namelist works as in Fortran 90 <ref> [2] </ref>, with a minor restriction on namelist input: subscripts must have the form subscript [ : subscript [ : stride ] ] For example, the Fortran integer m (8) real x (10,10) namelist /xx/ m, x . . . read (*,xx) could read &xx x (1,1) = 2, x (1:3,8:10:2) = <p> i (10) logical m (10) if (m (i (2))) d (3) = d (4)/d (5) result in struct - complex c [10]; doublereal d [10]; real r [10]; integer i [10]; logical m [10]; - named_; #define named_1 named_ . . . if (named_1.m [named_1.i [1] - 1]) - named_1.d <ref> [2] </ref> = named_1.d [3] / named_1.d [4]; - Under the -p option, the above if statement becomes more readable: . . . #define c (named_1.c) #define d (named_1.d) #define r (named_1.r) #define i (named_1.i) #define m (named_1.m) . . . d [2] = d [3] / d [4]; If the above <p> . if (named_1.m [named_1.i [1] - 1]) - named_1.d <ref> [2] </ref> = named_1.d [3] / named_1.d [4]; - Under the -p option, the above if statement becomes more readable: . . . #define c (named_1.c) #define d (named_1.d) #define r (named_1.r) #define i (named_1.i) #define m (named_1.m) . . . d [2] = d [3] / d [4]; If the above common block were involved in a block data subprogram, e.g. block data common /named/ c, d, r, i, l, m complex c (10) double precision d (10) real r (10) integer i (10) logical m (10) data c (1)/(1.0,0e0)/, d (2)/2d0/, <p> (a,b) character*(*) a, b cat = a // b yields . . . static integer c_ _2 = 2; /* Character */ int cat_ (ret_val, ret_val_len, a, b, a_len, b_len) char *ret_val; ftnlen ret_val_len; char *a, *b; ftnlen a_len; ftnlen b_len; - /* System generated locals */ address a_ _1 <ref> [2] </ref>; integer i_ _1 [2]; /* Builtin functions */ /* Subroutine */ int s_cat (); /* Writing concatenation */ i_ _1 [0] = a_len, a_ _1 [0] = a; s_cat (ret_val, a_ _1, i_ _1, &c_ _2, ret_val_len); Note how the return-value length (ret_val_len) and parameter lengths (a_len and b_len) are <p> cat = a // b yields . . . static integer c_ _2 = 2; /* Character */ int cat_ (ret_val, ret_val_len, a, b, a_len, b_len) char *ret_val; ftnlen ret_val_len; char *a, *b; ftnlen a_len; ftnlen b_len; - /* System generated locals */ address a_ _1 <ref> [2] </ref>; integer i_ _1 [2]; /* Builtin functions */ /* Subroutine */ int s_cat (); /* Writing concatenation */ i_ _1 [0] = a_len, a_ _1 [0] = a; s_cat (ret_val, a_ _1, i_ _1, &c_ _2, ret_val_len); Note how the return-value length (ret_val_len) and parameter lengths (a_len and b_len) are used. <p> _14 = 14; May 24, 1992 - 14 - /* Main program */ MAIN_ _ () - /* Local variables */ #define d ((doublereal *)&cmname_1) #define i ((integer *)&cmname_1) #define l ((logical *)&cmname_1) #define r ((real *)&cmname_1) extern /* Subroutine */ int sam_ (); sam_ (cmname_1.c, d, &r [1], &i <ref> [2] </ref>, &m [3], "some hollerith", &c_ _14, 14L); - /* MAIN_ _ */ #undef r #undef l #undef i #undef d As this example shows, f 2c turns a Fortran MAIN program into a C function named MAIN_ _.
Reference: [3] <institution> American National Standard for Information Systems Programming Language C, American National Standards Institute, </institution> <address> New York, NY, </address> <year> 1990. </year> <note> ANSI X3.159-1989. </note>
Reference-contexts: Thus, the call in external f character*7 s integer b (3) . . . call sam (f, b (2), s) is equivalent to that in int f (); char s [7]; long int b <ref> [3] </ref>; . . . May 24, 1992 - 4 - Note that the first element of a C array always has subscript zero, but Fortran arrays begin at 1 by default. <p> This is easily done by using f 2c as a filter: cat *.f | f2c &gt;mystuff.c The -A option lets f 2c use ANSI C constructs <ref> [3] </ref>, which yields more readable C when character variables are initialized. <p> m (10) if (m (i (2))) d (3) = d (4)/d (5) result in struct - complex c [10]; doublereal d [10]; real r [10]; integer i [10]; logical m [10]; - named_; #define named_1 named_ . . . if (named_1.m [named_1.i [1] - 1]) - named_1.d [2] = named_1.d <ref> [3] </ref> / named_1.d [4]; - Under the -p option, the above if statement becomes more readable: . . . #define c (named_1.c) #define d (named_1.d) #define r (named_1.r) #define i (named_1.i) #define m (named_1.m) . . . d [2] = d [3] / d [4]; If the above common block were <p> [named_1.i [1] - 1]) - named_1.d [2] = named_1.d <ref> [3] </ref> / named_1.d [4]; - Under the -p option, the above if statement becomes more readable: . . . #define c (named_1.c) #define d (named_1.d) #define r (named_1.r) #define i (named_1.i) #define m (named_1.m) . . . d [2] = d [3] / d [4]; If the above common block were involved in a block data subprogram, e.g. block data common /named/ c, d, r, i, l, m complex c (10) double precision d (10) real r (10) integer i (10) logical m (10) data c (1)/(1.0,0e0)/, d (2)/2d0/, r (3)/3e0/, i <p> 14; May 24, 1992 - 14 - /* Main program */ MAIN_ _ () - /* Local variables */ #define d ((doublereal *)&cmname_1) #define i ((integer *)&cmname_1) #define l ((logical *)&cmname_1) #define r ((real *)&cmname_1) extern /* Subroutine */ int sam_ (); sam_ (cmname_1.c, d, &r [1], &i [2], &m <ref> [3] </ref>, "some hollerith", &c_ _14, 14L); - /* MAIN_ _ */ #undef r #undef l #undef i #undef d As this example shows, f 2c turns a Fortran MAIN program into a C function named MAIN_ _. <p> The -h option instructs f 2c to try to give character variables and constants the same alignment as integers. Under -h, for example, the Fortran call foo ("a string") call goo (8ha string) is translated to static struct - integer fill; char val [8+1]; char fill2 <ref> [3] </ref>; - c_b1_st = - 0, "a string" -; #define c_b1 c_b1_st.val . . . goo_ (c_b1, 8L); Some systems require that C values of type double be aligned on a double-word boundary.
Reference: [4] <institution> UNIX Time Sharing System Programmer's Manual, AT&T Bell Laboratories, </institution> <year> 1990. </year> <booktitle> Tenth Edition, </booktitle> <volume> Volume 1. </volume>
Reference-contexts: Automatic Fortran to C conversion lets one create a portable C program that exploits Fortran source code. A side benefit of automatic Fortran 77 to C conversion is that it allows such tools as cyntax (1) and lint (1) <ref> [4] </ref> to provide Fortran 77 programs with some of the consistency and portability checks that the Pfort Verifier [13] provided to Fortran 66 programs. The consistency checks detect errors in calling sequences and are thus a boon to debugging. <p> (m (i (2))) d (3) = d (4)/d (5) result in struct - complex c [10]; doublereal d [10]; real r [10]; integer i [10]; logical m [10]; - named_; #define named_1 named_ . . . if (named_1.m [named_1.i [1] - 1]) - named_1.d [2] = named_1.d [3] / named_1.d <ref> [4] </ref>; - Under the -p option, the above if statement becomes more readable: . . . #define c (named_1.c) #define d (named_1.d) #define r (named_1.r) #define i (named_1.i) #define m (named_1.m) . . . d [2] = d [3] / d [4]; If the above common block were involved in a <p> 1]) - named_1.d [2] = named_1.d [3] / named_1.d <ref> [4] </ref>; - Under the -p option, the above if statement becomes more readable: . . . #define c (named_1.c) #define d (named_1.d) #define r (named_1.r) #define i (named_1.i) #define m (named_1.m) . . . d [2] = d [3] / d [4]; If the above common block were involved in a block data subprogram, e.g. block data common /named/ c, d, r, i, l, m complex c (10) double precision d (10) real r (10) integer i (10) logical m (10) data c (1)/(1.0,0e0)/, d (2)/2d0/, r (3)/3e0/, i (4)/4/, * m <p> For example, -W8 is appropriate for C that is to be run on Cray computers, since Crays store 8 characters per word. An example is helpful here: the Fortran data i/'abcd'/ j = i turns into /* Initialized data */ static struct - char e_1 <ref> [4] </ref>; - equiv_3 = - -'a', 'b', 'c', 'd'- -; #define i (*(integer *)&equiv_3) static integer j; j = i; #undef i (Some use of i, e.g. ``j = i'', is necessary or f 2c will see that i is not used and will not initialize it.) If the target machine
Reference: [5] <author> J. J. Dongarra and E. Grosse, </author> <title> ``Distribution of Mathematical Software by Electronic Mail,'' </title> <booktitle> Communications of the ACM 30 #5 (May 1987), </booktitle> <pages> pp. 403-407. </pages>
Reference-contexts: f 2c's translations, and 6 considers portability issues. 7 discusses the generation and use of prototypes, which can be used both by C++ and ANSI C compilers and by f 2c to check consistency of calling sequences. 8 describes our experience with an experimental f 2c service provided by netlib <ref> [5] </ref>, and 9 considers possible extensions. Appendix A lists some vendors who offer conversion of Fortran to C that one might maintain as C. Finally, Appendix B contains a man page telling how to use f 2c. 2. <p> f 2c would issue a more elaborate #define: May 24, 1992 - 12 - #define named_1 (*(struct named_1_ *) &named_) /* Initialized data */ struct - complex e_1; doublereal fill_2 [10]; doublereal e_3; doublereal fill_4 [9]; real e_5; integer fill_6 [10]; integer e_7; integer fill_8 [11]; logical e_9; integer fill_10 <ref> [5] </ref>; - named_ = - (float)1., (float)0., -0-, 2., -0-, (float)3., -0-, 4, -0-, FALSE_ -; In this example, f 2c relies on C's structure initialization rules to supply zeros to the fill_n arrays that take up the space for which no data values were given. (The logical constants TRUE_ and <p> This is slightly annoying, since with appropriate data structures (in an extensively reorganized version of f 2c), one could do this calculation in linear time. 8. EXPERIENCE WITH netlib With the help of Eric Grosse, we arranged for the netlib <ref> [5] </ref> server netlib@research.att.com to provide an experimental Fortran-to-C translation service by electronic mail.
Reference: [6] <author> S. I. Feldman and P. J. Weinberger, </author> <title> ``A Portable Fortran 77 Compiler,'' in Unix Programmer's Manual, Volume II, </title> <publisher> Holt, Rinehart and Winston (1983). </publisher>
Reference-contexts: The consistency checks detect errors in calling sequences and are thus a boon to debugging. This paper describes f 2c, a Fortran 77 to C converter based on Feldman's original f 77 compiler <ref> [6] </ref>. We have used f 2c to convert various large programs and subroutine libraries to C automatically (i.e., with no manual intervention); these include the PORT3 subroutine library (PORT1 is described in [7, 8]), MINOS [12], and Schryer's floating-point test [14]. <p> This meant that f 2c should follow the same calling conventions as f 77 <ref> [6] </ref> and should use f 77's support libraries, libF77 and libI77. May 24, 1992 - 2 - Although we have tried to make f 2c's output reasonably readable, our goal of strict compatibility with f 77 implies some nasty looking conversions. <p> Appendix A lists some vendors who offer conversion of Fortran to C that one might maintain as C. Finally, Appendix B contains a man page telling how to use f 2c. 2. INTERLANGUAGE CONVENTIONS Much of the material in this section is taken from <ref> [6] </ref>. Names An f 2c extension inspired by Fortran 90 (until recently called Fortran 8x [2]) is that long names are allowed (f 2c truncates names that are longer than 50 characters), and names may contain underscores. <p> int x; logical x long int x; long int x; real x real x; float x; double precision x doublereal x; double x; complex x complex x; struct - float r, i; - x; double complex x doublecomplex x; struct - double r, i; - x; character*6 x char x <ref> [6] </ref>; char x [6]; _ _______________________________________________________ By the rules of Fortran, integer, logical, and real data occupy the same amount of memory, and double precision and complex occupy twice this amount; f 2c assumes that the types in the C column above are chosen (in f2c.h) so that these assumptions are <p> x long int x; long int x; real x real x; float x; double precision x doublereal x; double x; complex x complex x; struct - float r, i; - x; double complex x doublecomplex x; struct - double r, i; - x; character*6 x char x <ref> [6] </ref>; char x [6]; _ _______________________________________________________ By the rules of Fortran, integer, logical, and real data occupy the same amount of memory, and double precision and complex occupy twice this amount; f 2c assumes that the types in the C column above are chosen (in f2c.h) so that these assumptions are valid. <p> EXTENSIONS TO FORTRAN 77 Since it is derived from f 77, f 2c supports all of the f 77 extensions described in <ref> [6] </ref>. F 2c's extensions include the following. Type double complex (alias complex*16) is a double-precision version of complex. Specific intrinsic functions for double complex have names that start with z rather than c. <p> This option takes a numeric argument, as in -W8; such an option must be listed either separately or at the end of a string of other options, as in f2c -C++RPW8 *.f 5. TRANSLATION DETAILS F 2c is based on the ancient f 77 Fortran compiler of <ref> [6] </ref>. That compiler produced a C parse-tree, which it converted into input for the second pass of the portable C compiler (PCC) [9]. The compiler has been used for many years and is the direct ancestor of many current Fortran compilers. <p> Regarding the first issue, some vendors (e.g., Sun and MIPS) have changed the calling conventions for their libI77 from the original conventions (those of <ref> [6] </ref>). Other vendors (e.g., MIPS) have changed the libF77 calling conventions (e.g., for complex-valued functions). Thus, having libraries libF77 and libI77 or otherwise having library routines with the names that f 2c expects is insufficient.
Reference: [7] <author> P. A. Fox, A. D. Hall, and N. L. Schryer, </author> <title> ``Algorithm 528: Framework for a Portable Library,'' </title> <journal> ACM Trans. Math. Software 4 (June 1978), </journal> <pages> pp. 177-188. </pages> <month> May 24, </month> <year> 1992 </year> <month> - 23 </month> - 
Reference-contexts: We have used f 2c to convert various large programs and subroutine libraries to C automatically (i.e., with no manual intervention); these include the PORT3 subroutine library (PORT1 is described in <ref> [7, 8] </ref>), MINOS [12], and Schryer's floating-point test [14]. The floating-point test is of particular interest, as it relies heavily on correct evaluation of parenthesized expressions and is bit-level self-testing. <p> Thus, the call in external f character*7 s integer b (3) . . . call sam (f, b (2), s) is equivalent to that in int f (); char s <ref> [7] </ref>; long int b [3]; . . . May 24, 1992 - 4 - Note that the first element of a C array always has subscript zero, but Fortran arrays begin at 1 by default.
Reference: [8] <author> P. A. Fox, A. D. Hall, and N. L. Schryer, </author> <title> ``The PORT Mathematical Subroutine Library,'' </title> <journal> ACM Trans. Math. Software 4 (June 1978), </journal> <pages> pp. 104-126. </pages>
Reference-contexts: We have used f 2c to convert various large programs and subroutine libraries to C automatically (i.e., with no manual intervention); these include the PORT3 subroutine library (PORT1 is described in <ref> [7, 8] </ref>), MINOS [12], and Schryer's floating-point test [14]. The floating-point test is of particular interest, as it relies heavily on correct evaluation of parenthesized expressions and is bit-level self-testing.
Reference: [9] <author> S. C. Johnson, </author> <title> ``A Portable Compiler: </title> <journal> Theory and Practice,'' </journal> <pages> pp. </pages> <booktitle> 97-104 in Conference Record of the Fifth Annual ACM Symposium on Principles of Programming Languages, Association for Computing Machinery (1978). </booktitle>
Reference-contexts: TRANSLATION DETAILS F 2c is based on the ancient f 77 Fortran compiler of [6]. That compiler produced a C parse-tree, which it converted into input for the second pass of the portable C compiler (PCC) <ref> [9] </ref>. The compiler has been used for many years and is the direct ancestor of many current Fortran compilers. Thus, it provided us with a solid base of Fortran knowledge and a nearly complete C representation. <p> i (4)/4/, * m (5)/.false./ end then the struct would begin ``struct named_1_ -'', and f 2c would issue a more elaborate #define: May 24, 1992 - 12 - #define named_1 (*(struct named_1_ *) &named_) /* Initialized data */ struct - complex e_1; doublereal fill_2 [10]; doublereal e_3; doublereal fill_4 <ref> [9] </ref>; real e_5; integer fill_6 [10]; integer e_7; integer fill_8 [11]; logical e_9; integer fill_10 [5]; - named_ = - (float)1., (float)0., -0-, 2., -0-, (float)3., -0-, 4, -0-, FALSE_ -; In this example, f 2c relies on C's structure initialization rules to supply zeros to the fill_n arrays that take
Reference: [10] <author> B. W. Kernighan and D. M. Ritchie, </author> <title> The C Programming Language, </title> <publisher> Prentice-Hall, </publisher> <year> 1978. </year>
Reference-contexts: 1. INTRODUCTION Automatic conversion of Fortran 77 [1] to C <ref> [10, 11] </ref> is desirable for several reasons. Sometimes it is useful to run a well-tested Fortran program on a machine that has a C compiler but no Fortran compiler. At other times, it is convenient to mix C and Fortran. <p> For example, the Fortran declarations common /named/ c, d, r, i, l complex c (10) double precision d (10) real r (10) integer i (10) logical m (10) if (m (i (2))) d (3) = d (4)/d (5) result in struct - complex c <ref> [10] </ref>; doublereal d [10]; real r [10]; integer i [10]; logical m [10]; - named_; #define named_1 named_ . . . if (named_1.m [named_1.i [1] - 1]) - named_1.d [2] = named_1.d [3] / named_1.d [4]; - Under the -p option, the above if statement becomes more readable: . . . <p> For example, the Fortran declarations common /named/ c, d, r, i, l complex c (10) double precision d (10) real r (10) integer i (10) logical m (10) if (m (i (2))) d (3) = d (4)/d (5) result in struct - complex c <ref> [10] </ref>; doublereal d [10]; real r [10]; integer i [10]; logical m [10]; - named_; #define named_1 named_ . . . if (named_1.m [named_1.i [1] - 1]) - named_1.d [2] = named_1.d [3] / named_1.d [4]; - Under the -p option, the above if statement becomes more readable: . . . #define c (named_1.c) <p> For example, the Fortran declarations common /named/ c, d, r, i, l complex c (10) double precision d (10) real r (10) integer i (10) logical m (10) if (m (i (2))) d (3) = d (4)/d (5) result in struct - complex c <ref> [10] </ref>; doublereal d [10]; real r [10]; integer i [10]; logical m [10]; - named_; #define named_1 named_ . . . if (named_1.m [named_1.i [1] - 1]) - named_1.d [2] = named_1.d [3] / named_1.d [4]; - Under the -p option, the above if statement becomes more readable: . . . #define c (named_1.c) #define d (named_1.d) <p> Fortran declarations common /named/ c, d, r, i, l complex c (10) double precision d (10) real r (10) integer i (10) logical m (10) if (m (i (2))) d (3) = d (4)/d (5) result in struct - complex c <ref> [10] </ref>; doublereal d [10]; real r [10]; integer i [10]; logical m [10]; - named_; #define named_1 named_ . . . if (named_1.m [named_1.i [1] - 1]) - named_1.d [2] = named_1.d [3] / named_1.d [4]; - Under the -p option, the above if statement becomes more readable: . . . #define c (named_1.c) #define d (named_1.d) #define r (named_1.r) <p> /named/ c, d, r, i, l complex c (10) double precision d (10) real r (10) integer i (10) logical m (10) if (m (i (2))) d (3) = d (4)/d (5) result in struct - complex c <ref> [10] </ref>; doublereal d [10]; real r [10]; integer i [10]; logical m [10]; - named_; #define named_1 named_ . . . if (named_1.m [named_1.i [1] - 1]) - named_1.d [2] = named_1.d [3] / named_1.d [4]; - Under the -p option, the above if statement becomes more readable: . . . #define c (named_1.c) #define d (named_1.d) #define r (named_1.r) #define i (named_1.i) <p> (1)/(1.0,0e0)/, d (2)/2d0/, r (3)/3e0/, i (4)/4/, * m (5)/.false./ end then the struct would begin ``struct named_1_ -'', and f 2c would issue a more elaborate #define: May 24, 1992 - 12 - #define named_1 (*(struct named_1_ *) &named_) /* Initialized data */ struct - complex e_1; doublereal fill_2 <ref> [10] </ref>; doublereal e_3; doublereal fill_4 [9]; real e_5; integer fill_6 [10]; integer e_7; integer fill_8 [11]; logical e_9; integer fill_10 [5]; - named_ = - (float)1., (float)0., -0-, 2., -0-, (float)3., -0-, 4, -0-, FALSE_ -; In this example, f 2c relies on C's structure initialization rules to supply zeros to <p> end then the struct would begin ``struct named_1_ -'', and f 2c would issue a more elaborate #define: May 24, 1992 - 12 - #define named_1 (*(struct named_1_ *) &named_) /* Initialized data */ struct - complex e_1; doublereal fill_2 <ref> [10] </ref>; doublereal e_3; doublereal fill_4 [9]; real e_5; integer fill_6 [10]; integer e_7; integer fill_8 [11]; logical e_9; integer fill_10 [5]; - named_ = - (float)1., (float)0., -0-, 2., -0-, (float)3., -0-, 4, -0-, FALSE_ -; In this example, f 2c relies on C's structure initialization rules to supply zeros to the fill_n arrays that take up the space for which <p> (10) real r (10) integer i (10) logical m (10) equivalence (c (1),d (1),r (1),i (1),m (1)) data c (1)/(1.,0.)/ data d (2)/2d0/, r (5)/3e0/, i (6)/4/, m (7)/.true./ call sam (c,d (1),r (2),i (3),m (4),14hsome hollerith,14) end The resulting C is . . . struct cmname_1_ - complex c <ref> [10] </ref>; -; #define cmname_1 (*(struct cmname_1_ *) &cmname_) /* Initialized data */ struct - complex e_1; doublereal e_2; real e_3; integer e_4; logical e_5; integer fill_6 [13]; - cmname_ = - (float)1., (float)0., 2., (float)3., 4, TRUE_ -; /* Table of constant values */ static integer c_ _14 = 14; May <p> complex c (10) c (1)=cmplx (1.,0.) call sam (c) end subroutine sam (c) complex c common /cmname/ca complex ca (10) ca (2) = cmplx (1e0,2e0) return end when converted by f2c -ec produces May 24, 1992 - 17 - /* Common Block Declarations */ union - struct - complex c <ref> [10] </ref>; - _1; struct - complex ca [10]; - _2; - cmname_; #define cmname_1 (cmname_._1) #define cmname_2 (cmname_._2) /* Main program */ MAIN_ _ () - extern /* Subroutine */ int sam_ (); cmname_1.c [0].r = (float)1., cmname_1.c [0].i = (float)0.; sam_ (cmname_1.c); - /* MAIN_ _ */ /* Subroutine */ <p> sam (c) end subroutine sam (c) complex c common /cmname/ca complex ca (10) ca (2) = cmplx (1e0,2e0) return end when converted by f2c -ec produces May 24, 1992 - 17 - /* Common Block Declarations */ union - struct - complex c <ref> [10] </ref>; - _1; struct - complex ca [10]; - _2; - cmname_; #define cmname_1 (cmname_._1) #define cmname_2 (cmname_._2) /* Main program */ MAIN_ _ () - extern /* Subroutine */ int sam_ (); cmname_1.c [0].r = (float)1., cmname_1.c [0].i = (float)0.; sam_ (cmname_1.c); - /* MAIN_ _ */ /* Subroutine */ int sam_ (c) complex *c; - cmname_2.ca <p> = (float)1., cmname_1.c [0].i = (float)0.; sam_ (cmname_1.c); - /* MAIN_ _ */ /* Subroutine */ int sam_ (c) complex *c; - cmname_2.ca [1].r = (float)1., cmname_2.ca [1].i = (float)2.; return 0; - /* sam_ */ as well as the file cmname_com.c: #include "f2c.h" union - struct - complex c <ref> [10] </ref>; - _1; struct - complex ca [10]; - _2; - cmname_; The files *_com.c may be compiled into a library against which one can load to satisfy overly fastidious ANSI C compilers. <p> (cmname_1.c); - /* MAIN_ _ */ /* Subroutine */ int sam_ (c) complex *c; - cmname_2.ca [1].r = (float)1., cmname_2.ca [1].i = (float)2.; return 0; - /* sam_ */ as well as the file cmname_com.c: #include "f2c.h" union - struct - complex c <ref> [10] </ref>; - _1; struct - complex ca [10]; - _2; - cmname_; The files *_com.c may be compiled into a library against which one can load to satisfy overly fastidious ANSI C compilers.
Reference: [11] <author> B. W. Kernighan and D. M. Ritchie, </author> <title> The C Programming Language, </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year> <note> Second Edition </note>
Reference-contexts: 1. INTRODUCTION Automatic conversion of Fortran 77 [1] to C <ref> [10, 11] </ref> is desirable for several reasons. Sometimes it is useful to run a well-tested Fortran program on a machine that has a C compiler but no Fortran compiler. At other times, it is convenient to mix C and Fortran. <p> begin ``struct named_1_ -'', and f 2c would issue a more elaborate #define: May 24, 1992 - 12 - #define named_1 (*(struct named_1_ *) &named_) /* Initialized data */ struct - complex e_1; doublereal fill_2 [10]; doublereal e_3; doublereal fill_4 [9]; real e_5; integer fill_6 [10]; integer e_7; integer fill_8 <ref> [11] </ref>; logical e_9; integer fill_10 [5]; - named_ = - (float)1., (float)0., -0-, 2., -0-, (float)3., -0-, 4, -0-, FALSE_ -; In this example, f 2c relies on C's structure initialization rules to supply zeros to the fill_n arrays that take up the space for which no data values were given.
Reference: [12] <author> B. A. Murtagh and M. A. Saunders, </author> <note> ``MINOS 5.1 User's Guide,'' Technical Report SOL 83-20R (1987), </note> <institution> Systems Optimization Laboratory, Stanford University, Stanford, </institution> <address> CA. </address>
Reference-contexts: We have used f 2c to convert various large programs and subroutine libraries to C automatically (i.e., with no manual intervention); these include the PORT3 subroutine library (PORT1 is described in [7, 8]), MINOS <ref> [12] </ref>, and Schryer's floating-point test [14]. The floating-point test is of particular interest, as it relies heavily on correct evaluation of parenthesized expressions and is bit-level self-testing.
Reference: [13] <author> B. G. Ryder, </author> <title> ``The PFORT Verifier,'' </title> <booktitle> Software Practice and Experience 4 (1974), </booktitle> <pages> pp. 359-377. </pages>
Reference-contexts: A side benefit of automatic Fortran 77 to C conversion is that it allows such tools as cyntax (1) and lint (1) [4] to provide Fortran 77 programs with some of the consistency and portability checks that the Pfort Verifier <ref> [13] </ref> provided to Fortran 66 programs. The consistency checks detect errors in calling sequences and are thus a boon to debugging. This paper describes f 2c, a Fortran 77 to C converter based on Feldman's original f 77 compiler [6]. <p> (6)/4/, m (7)/.true./ call sam (c,d (1),r (2),i (3),m (4),14hsome hollerith,14) end The resulting C is . . . struct cmname_1_ - complex c [10]; -; #define cmname_1 (*(struct cmname_1_ *) &cmname_) /* Initialized data */ struct - complex e_1; doublereal e_2; real e_3; integer e_4; logical e_5; integer fill_6 <ref> [13] </ref>; - cmname_ = - (float)1., (float)0., 2., (float)3., 4, TRUE_ -; /* Table of constant values */ static integer c_ _14 = 14; May 24, 1992 - 14 - /* Main program */ MAIN_ _ () - /* Local variables */ #define d ((doublereal *)&cmname_1) #define i ((integer *)&cmname_1) #define
Reference: [14] <author> N. L. Schryer, </author> <title> ``A Test of a Computer's Floating-point Arithmetic Unit,'' in Sources and Development of Mathematical Software, </title> <editor> ed. W. Cowell, </editor> <publisher> Prentice-Hall (1981). </publisher>
Reference-contexts: We have used f 2c to convert various large programs and subroutine libraries to C automatically (i.e., with no manual intervention); these include the PORT3 subroutine library (PORT1 is described in [7, 8]), MINOS [12], and Schryer's floating-point test <ref> [14] </ref>. The floating-point test is of particular interest, as it relies heavily on correct evaluation of parenthesized expressions and is bit-level self-testing. As a debugging aid, we sought bit-level compatibility between objects compiled from the C produced by f 2c and objects produced by our local f 77 compiler.
Reference: [15] <author> B. Stroustrup, </author> <title> The C++ Programming Language, </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Thus, character*15 function g ( . . . ) is equivalent to g_ (result, length, . . .) char *result; ftnlen length; . . . and could be invoked in C by char chars <ref> [15] </ref>; . . . g_ (chars, 15L, . . . ); Subroutines are invoked as if they were int-valued functions whose value specifies which alternate return to use. <p> With both -A and -R specified, the last example becomes cat *.f | f2c -A -R &gt;mystuff.c For use with C++ <ref> [15] </ref>, one would specify -C++ rather than -A; the last example would then become cat *.f | f2c -C++ -R &gt;mystuff.c The -C++ option gives ANSI-style headers and old-style C formatting of character strings and float constants (since some C++ compilers reject the ANSI versions of these constructs).
References-found: 15

