URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS93-03.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Localizing Failures in Distributed Synchronization  
Author: Manhoi Choy and Ambuj K. Singh 
Keyword: Index Terms: Concurrency, Distributed Algorithms, Fault-tolerance, Lower Bounds, Synchronization  
Address: Santa Barbara, California 93106  
Affiliation: Department of Computer Science University of California at Santa Barbara  
Abstract: We investigate the fault-tolerance of distributed algorithms in asynchronous message passing systems with undetectable process failures. We introduce failure locality as a measure of the fault-tolerance of distributed algorithms. This measure captures the general idea of allowing part of a system to continue to function despite the failure of other parts of the system. We concentrate on two problems, the dining philosophers problem and the committee coordination problem, and present algorithms with an optimal failure locality. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Reference manual for the Ada programming language. United States Department of Defense. Springer-Verlag, </institution> <address> New York, </address> <year> 1983. </year>
Reference-contexts: The dining philosophers problem is a generalization of the mutual exclusion problem and can be used to solve many other synchronization problems. The committee coordination problem occurs in languages such as CSP [4] and Ada <ref> [1] </ref> that are based on synchronous message communication. We use failure locality [6] to measure the degree of fault-tolerance. The failure locality of an algorithm denotes the size of the neighborhood that gets affected by a failure. <p> However, the question of the best achievable failure locality remained open. The committee coordination problem consists of a set of interactions (or committees) and a set of processes. The problem initially arose out of rendezvous-based communication in languages like CSP and Ada <ref> [1, 4] </ref> where a subset of processes needs to exchange information in a synchronous manner. A conflict graph can be constructed for this problem by mapping each interaction to a node and placing an edge between interactions that share a common process.
Reference: [2] <author> B. Awerbuch, A. B. Goldberg, M. Luby, and S. A. Plotkin. </author> <title> Network decomposition and locality in distributed computation. </title> <booktitle> In Proceedings of the 30th IEEE Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 364-369, </pages> <year> 1989. </year> <month> 16 </month>
Reference-contexts: A brief discussion appears in Section 6 and an appendix contains the proofs of some theorems used in the main body of the paper. 2 2 Relevant Background Locality of distributed computation has been studied by many authors <ref> [2, 14, 19, 20] </ref>. Linial [14] considered the problem of computing functions that do not require global communication. To compute a function, each process starts with some local data. During the computation, information is exchanged between neighboring processes. Finally, each of the processes terminates and returns a value. <p> To compute a function, each process starts with some local data. During the computation, information is exchanged between neighboring processes. Finally, each of the processes terminates and returns a value. A function is said to be computed locally <ref> [2] </ref> if it can be computed in a time less than the diameter of the network. Some of these functions include finding a maximal independent set [2, 11, 14, 15] or computing nodes and edge colorings of a network [2, 10]. <p> Finally, each of the processes terminates and returns a value. A function is said to be computed locally [2] if it can be computed in a time less than the diameter of the network. Some of these functions include finding a maximal independent set <ref> [2, 11, 14, 15] </ref> or computing nodes and edge colorings of a network [2, 10]. In this paper, we investigate the locality of distributed synchronization problems that do not require processes to terminate and return results. <p> A function is said to be computed locally [2] if it can be computed in a time less than the diameter of the network. Some of these functions include finding a maximal independent set [2, 11, 14, 15] or computing nodes and edge colorings of a network <ref> [2, 10] </ref>. In this paper, we investigate the locality of distributed synchronization problems that do not require processes to terminate and return results. In particular, we concentrate on the dining philosophers problem [8, 16] and the committee coordination problem [5].
Reference: [3] <author> B. Awerbuch and M. Saks. </author> <title> A dining philosophers algorithm with polynomial response time. </title> <booktitle> In Proceedings of the 31st Symposium on Foundations of Computer Science, </booktitle> <pages> pages 65-74, </pages> <year> 1990. </year>
Reference-contexts: Each process is mapped to a node of the conflict graph and each resource is mapped to an edge. Many solutions to the dining philosophers problem appear in the literature <ref> [3, 5, 6, 16, 20] </ref>. Styer and Peterson [20] are perhaps the first to consider the issue of locality for this problem. They measure the locality of an algorithm by the length of the longest waiting chain of processes that may be formed in the system.
Reference: [4] <author> G. N. Buckley and A. Silberschatz. </author> <title> An effective implementation for the generalized input-output construct of CSP. </title> <journal> ACM Trans. Program. Lang. Syst., </journal> <volume> 5(2) </volume> <pages> 223-235, </pages> <month> (April </month> <year> 1982). </year>
Reference-contexts: The dining philosophers problem is a generalization of the mutual exclusion problem and can be used to solve many other synchronization problems. The committee coordination problem occurs in languages such as CSP <ref> [4] </ref> and Ada [1] that are based on synchronous message communication. We use failure locality [6] to measure the degree of fault-tolerance. The failure locality of an algorithm denotes the size of the neighborhood that gets affected by a failure. <p> However, the question of the best achievable failure locality remained open. The committee coordination problem consists of a set of interactions (or committees) and a set of processes. The problem initially arose out of rendezvous-based communication in languages like CSP and Ada <ref> [1, 4] </ref> where a subset of processes needs to exchange information in a synchronous manner. A conflict graph can be constructed for this problem by mapping each interaction to a node and placing an edge between interactions that share a common process. <p> We concentrate on the binary version of the problem in which every interaction has two members. Both the binary and the general versions of the problem have been solved by many researchers <ref> [4, 5, 6, 12, 18, 19] </ref>. Sistla [19] calls a solution to the problem to be real time if its complexity is independent of the size of the communication network.
Reference: [5] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison Wesley Pub. Co., </publisher> <address> Reading, Mass., </address> <year> 1988. </year>
Reference-contexts: In this paper, we investigate the locality of distributed synchronization problems that do not require processes to terminate and return results. In particular, we concentrate on the dining philosophers problem [8, 16] and the committee coordination problem <ref> [5] </ref>. The dining philosophers problem consists of a set of processes and a set of resources that are modeled by a conflict graph. Each process is mapped to a node of the conflict graph and each resource is mapped to an edge. <p> Each process is mapped to a node of the conflict graph and each resource is mapped to an edge. Many solutions to the dining philosophers problem appear in the literature <ref> [3, 5, 6, 16, 20] </ref>. Styer and Peterson [20] are perhaps the first to consider the issue of locality for this problem. They measure the locality of an algorithm by the length of the longest waiting chain of processes that may be formed in the system. <p> We concentrate on the binary version of the problem in which every interaction has two members. Both the binary and the general versions of the problem have been solved by many researchers <ref> [4, 5, 6, 12, 18, 19] </ref>. Sistla [19] calls a solution to the problem to be real time if its complexity is independent of the size of the communication network. <p> Finally, we presented an optimal algorithm for the binary version of the problem, once more based on the idea of a bounded doorway. The general case of the committee coordination problem can be solved by a reduction to the dining philosophers problem <ref> [5] </ref>. If we use the optimal algorithm that is presented here then the resulting solution to the committee coordination problem has a failure locality of two. It is an open question whether a failure locality of one can be achieved for this problem.
Reference: [6] <author> M. Choy and A. K. Singh. </author> <title> Efficient fault tolerant algorithms for resource allocation in distributed systems. </title> <note> 1992, submitted to Journal. A preliminary version appears in the Proceedings of the 21th Annual ACM Symposium on Theory of Computing, </note> <year> 1992, </year> <pages> pages 593-602. </pages>
Reference-contexts: The dining philosophers problem is a generalization of the mutual exclusion problem and can be used to solve many other synchronization problems. The committee coordination problem occurs in languages such as CSP [4] and Ada [1] that are based on synchronous message communication. We use failure locality <ref> [6] </ref> to measure the degree of fault-tolerance. The failure locality of an algorithm denotes the size of the neighborhood that gets affected by a failure. <p> This doorway has the interesting property that when coupled with an algorithm ensuring the absence of global starvation, the doorway ensures the absence of local starvation without adding to the failure locality of the algorithm. This is in contrast to other kind of doorways <ref> [6, 13] </ref> that add to the failure locality of the underlying algorithm. The rest of the paper is organized as follows. In Section 2 we present some of the relevant background. In Section 3, we introduce the idea of bounded doorways. <p> Each process is mapped to a node of the conflict graph and each resource is mapped to an edge. Many solutions to the dining philosophers problem appear in the literature <ref> [3, 5, 6, 16, 20] </ref>. Styer and Peterson [20] are perhaps the first to consider the issue of locality for this problem. They measure the locality of an algorithm by the length of the longest waiting chain of processes that may be formed in the system. <p> The algorithms obtained by Styer and Peterson achieve a failure locality of 3. Recently, we considered the problem of achieving a good failure locality in conjunction with the problem of achieving a good response time and a good message complexity <ref> [6] </ref>. We presented solutions that achieved a failure locality of 4 while maintaining a quadratic (in the degree of the conflict graph) response time and a quadratic message complexity. The paper also contains an algorithm that achieves a failure locality of 3. <p> We concentrate on the binary version of the problem in which every interaction has two members. Both the binary and the general versions of the problem have been solved by many researchers <ref> [4, 5, 6, 12, 18, 19] </ref>. Sistla [19] calls a solution to the problem to be real time if its complexity is independent of the size of the communication network. <p> Recently, we presented solutions to the committee coordination problem with a failure locality of 2 <ref> [6] </ref>. But, once more the question of the optimal failure locality remained open. 3 Bounded Doorways Solutions to problems requiring the absence of local starvation are often composed of two parts [6, 13, 20]. <p> Recently, we presented solutions to the committee coordination problem with a failure locality of 2 [6]. But, once more the question of the optimal failure locality remained open. 3 Bounded Doorways Solutions to problems requiring the absence of local starvation are often composed of two parts <ref> [6, 13, 20] </ref>. The first part satisfies all the requirements of the problem except that it ensures the absence of global starvation (i.e., no deadlocks). <p> In their scheme neighboring processes executes a P operation on a common semaphore (implemented by passing messages) while entering the doorway and a V operation while exiting the doorway. Two other kinds of doorways called single doorway and double doorway were introduced in <ref> [6] </ref> in order to avoid unbounded overtaking. All the above doorways require processes outside the doorway to wait for processes inside the doorway and this increases the failure locality of the composite solution by at least one.
Reference: [7] <author> M. Choy and A. K. Singh. </author> <title> Adaptive algorithms for the mutual exclusion problem. </title> <type> unpublished manuscript. </type>
Reference: [8] <author> E. W. Dijkstra. </author> <title> Hierarchical ordering of sequential processes. </title> <journal> Acta Inf., </journal> <volume> 1 </volume> <pages> 115-138, </pages> <year> 1971. </year>
Reference-contexts: In this paper, we investigate the locality of distributed synchronization problems that do not require processes to terminate and return results. In particular, we concentrate on the dining philosophers problem <ref> [8, 16] </ref> and the committee coordination problem [5]. The dining philosophers problem consists of a set of processes and a set of resources that are modeled by a conflict graph. Each process is mapped to a node of the conflict graph and each resource is mapped to an edge.
Reference: [9] <author> M. J. Fischer, N. A. Lynch, and M. S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> J. ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <year> 1985. </year>
Reference-contexts: Theorem 3 There does not exist a solution to the committee coordination problem that achieves a failure locality of 0. Proof: The proof is by reduction to the well-known result about the impossibility of distributed consensus with one faulty process <ref> [9] </ref>. Assume that there exists an algorithm that achieves a failure locality of 0. In other words, the algorithm supposedly ensures that as long as processes in an interaction are ready and do not fail, the interaction or one of its neighbors commit eventually.
Reference: [10] <author> A. V. Goldberg and S. A. Plotkin. </author> <title> Parallel (ffi + 1) coloring of constant-degree graphs. </title> <journal> Information Processing Let., </journal> <volume> 25 </volume> <pages> 241-245, </pages> <year> 1987. </year>
Reference-contexts: A function is said to be computed locally [2] if it can be computed in a time less than the diameter of the network. Some of these functions include finding a maximal independent set [2, 11, 14, 15] or computing nodes and edge colorings of a network <ref> [2, 10] </ref>. In this paper, we investigate the locality of distributed synchronization problems that do not require processes to terminate and return results. In particular, we concentrate on the dining philosophers problem [8, 16] and the committee coordination problem [5].
Reference: [11] <author> R. M. Karp and A. Wigderson. </author> <title> A fast parallel algorithm for the maximal independent set problem. </title> <booktitle> In Proceedings of the 16th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 331-335, </pages> <year> 1987. </year>
Reference-contexts: Finally, each of the processes terminates and returns a value. A function is said to be computed locally [2] if it can be computed in a time less than the diameter of the network. Some of these functions include finding a maximal independent set <ref> [2, 11, 14, 15] </ref> or computing nodes and edge colorings of a network [2, 10]. In this paper, we investigate the locality of distributed synchronization problems that do not require processes to terminate and return results.
Reference: [12] <author> D. Kumar. </author> <title> An algorithm for N-party synchronization using tokens. </title> <booktitle> In Proceedings of the 10th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 320-327, </pages> <year> 1990. </year>
Reference-contexts: We concentrate on the binary version of the problem in which every interaction has two members. Both the binary and the general versions of the problem have been solved by many researchers <ref> [4, 5, 6, 12, 18, 19] </ref>. Sistla [19] calls a solution to the problem to be real time if its complexity is independent of the size of the communication network.
Reference: [13] <author> L. Lamport. </author> <title> The mutual exclusion problem: Part I and II. </title> <journal> J. ACM, </journal> <volume> 33(2) </volume> <pages> 313-348, </pages> <month> (April </month> <year> 1986). </year>
Reference-contexts: This doorway has the interesting property that when coupled with an algorithm ensuring the absence of global starvation, the doorway ensures the absence of local starvation without adding to the failure locality of the algorithm. This is in contrast to other kind of doorways <ref> [6, 13] </ref> that add to the failure locality of the underlying algorithm. The rest of the paper is organized as follows. In Section 2 we present some of the relevant background. In Section 3, we introduce the idea of bounded doorways. <p> Recently, we presented solutions to the committee coordination problem with a failure locality of 2 [6]. But, once more the question of the optimal failure locality remained open. 3 Bounded Doorways Solutions to problems requiring the absence of local starvation are often composed of two parts <ref> [6, 13, 20] </ref>. The first part satisfies all the requirements of the problem except that it ensures the absence of global starvation (i.e., no deadlocks). <p> Various kinds of doorways have been defined and used in the literature. A basic kind called the first-come-first-served doorway was defined and used by Lamport in <ref> [13] </ref> in the context of the mutual exclusion problem. This doorway consists of a finite sequence of non-waiting statements and enforces a first-come-first-served behavior.
Reference: [14] <author> N. Linial. </author> <title> Distributive algorithms global solutions from local data. </title> <booktitle> In Proceedings 28th IEEE Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 331-335, </pages> <year> 1987. </year>
Reference-contexts: A brief discussion appears in Section 6 and an appendix contains the proofs of some theorems used in the main body of the paper. 2 2 Relevant Background Locality of distributed computation has been studied by many authors <ref> [2, 14, 19, 20] </ref>. Linial [14] considered the problem of computing functions that do not require global communication. To compute a function, each process starts with some local data. During the computation, information is exchanged between neighboring processes. Finally, each of the processes terminates and returns a value. <p> A brief discussion appears in Section 6 and an appendix contains the proofs of some theorems used in the main body of the paper. 2 2 Relevant Background Locality of distributed computation has been studied by many authors [2, 14, 19, 20]. Linial <ref> [14] </ref> considered the problem of computing functions that do not require global communication. To compute a function, each process starts with some local data. During the computation, information is exchanged between neighboring processes. Finally, each of the processes terminates and returns a value. <p> Finally, each of the processes terminates and returns a value. A function is said to be computed locally [2] if it can be computed in a time less than the diameter of the network. Some of these functions include finding a maximal independent set <ref> [2, 11, 14, 15] </ref> or computing nodes and edge colorings of a network [2, 10]. In this paper, we investigate the locality of distributed synchronization problems that do not require processes to terminate and return results.
Reference: [15] <author> M. Luby. </author> <title> A simple parallel algorithm for the maximal independent set problem. </title> <journal> SIAM J. Comput., </journal> <volume> 15 </volume> <pages> 1036-1052, </pages> <year> 1986. </year>
Reference-contexts: Finally, each of the processes terminates and returns a value. A function is said to be computed locally [2] if it can be computed in a time less than the diameter of the network. Some of these functions include finding a maximal independent set <ref> [2, 11, 14, 15] </ref> or computing nodes and edge colorings of a network [2, 10]. In this paper, we investigate the locality of distributed synchronization problems that do not require processes to terminate and return results.
Reference: [16] <author> N. Lynch. </author> <title> Fast allocation of nearby resources in a distributed system. </title> <booktitle> In Conference Proceedings of the 12th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 70-81, </pages> <year> 1980. </year>
Reference-contexts: In this paper, we investigate the locality of distributed synchronization problems that do not require processes to terminate and return results. In particular, we concentrate on the dining philosophers problem <ref> [8, 16] </ref> and the committee coordination problem [5]. The dining philosophers problem consists of a set of processes and a set of resources that are modeled by a conflict graph. Each process is mapped to a node of the conflict graph and each resource is mapped to an edge. <p> Each process is mapped to a node of the conflict graph and each resource is mapped to an edge. Many solutions to the dining philosophers problem appear in the literature <ref> [3, 5, 6, 16, 20] </ref>. Styer and Peterson [20] are perhaps the first to consider the issue of locality for this problem. They measure the locality of an algorithm by the length of the longest waiting chain of processes that may be formed in the system.
Reference: [17] <author> Pnueli, A., and Z. Manna, </author> <title> How to Cook a Temporal Proof System for Your Pet Language, </title> <booktitle> Proceedings of the 9th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1983, </year> <pages> 141-154. 17 </pages>
Reference-contexts: If a negative acknowledgement is received then no exchange is carried out. In either case, ack i is set to true and the next iteration of state transitions begins. 4.4 Proof of Correctness We use the temporal operators 2 and 3 <ref> [17] </ref> in the following proof. Briefly, 2p means that the formula p holds at all states in the history beginning with the current state, and 3p means that the formula p holds at some future state in the history beginning with the current state.
Reference: [18] <author> S. Ramesh. </author> <title> A new and efficient implementation of multiprocess synchronization. </title> <booktitle> In PARLE Parallel Architectures and Languages Europe. Lecture Notes in Computer Sciences 259, </booktitle> <pages> pages 387-401, </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: We concentrate on the binary version of the problem in which every interaction has two members. Both the binary and the general versions of the problem have been solved by many researchers <ref> [4, 5, 6, 12, 18, 19] </ref>. Sistla [19] calls a solution to the problem to be real time if its complexity is independent of the size of the communication network.
Reference: [19] <author> A. P. Sistla. </author> <title> Distributed algorithms for ensuring fair interprocess communications. </title> <booktitle> In Proceedings of the 3rd Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 266-277, </pages> <address> (Vancouver, </address> <month> Aug. </month> <year> 1984). </year>
Reference-contexts: A brief discussion appears in Section 6 and an appendix contains the proofs of some theorems used in the main body of the paper. 2 2 Relevant Background Locality of distributed computation has been studied by many authors <ref> [2, 14, 19, 20] </ref>. Linial [14] considered the problem of computing functions that do not require global communication. To compute a function, each process starts with some local data. During the computation, information is exchanged between neighboring processes. Finally, each of the processes terminates and returns a value. <p> We concentrate on the binary version of the problem in which every interaction has two members. Both the binary and the general versions of the problem have been solved by many researchers <ref> [4, 5, 6, 12, 18, 19] </ref>. Sistla [19] calls a solution to the problem to be real time if its complexity is independent of the size of the communication network. <p> We concentrate on the binary version of the problem in which every interaction has two members. Both the binary and the general versions of the problem have been solved by many researchers [4, 5, 6, 12, 18, 19]. Sistla <ref> [19] </ref> calls a solution to the problem to be real time if its complexity is independent of the size of the communication network. He also investigates the formation of waiting chains and then uses this to derive a lower bound on the response time.

References-found: 19

