URL: ftp://dirleton.csres.utexas.edu/pub/reports/083.ps
Refering-URL: http://www.cli.com/reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: A Verified Implementation of an Applicative Language with Dynamic Storage Allocation  
Author: Arthur D. Flatau 
Address: 1717 West Sixth Street, Suite 290 Austin, Texas 78703-4776  
Affiliation: Computational Logic, Inc.  
Pubnum: Technical Report  
Email: EMAIL: flatau@cli.com  
Phone: TEL: +1 512 322 9951  
Date: 83 January 6, 1993  
Abstract: This work was supported in part at Computational Logic, Inc., by the Defense Advanced Research Projects Agency, ARPA Order 7406. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Defense Advanced Research Projects Agency or the U.S. Government. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Raymond Aubin. </author> <title> Strategies for mechanizing structural induction. </title> <booktitle> In International Joint Conference on Artificial Intelligence, </booktitle> <year> 1977. </year>
Reference-contexts: Milner and Weyhrauch [22] give a machine checked proof of an expression compiler similar to that of McCarthy and Painter. This is part of a larger compiler that includes assignment, conditional, and while statements. Cartwright [8] and Aubin <ref> [1] </ref> also prove versions of the McCarthy-Painter compiler. Boyer and Moore [4] prove mechanically the correctness of a compiler similar to that of McCarthy and Painter. <p> An example is the function CHANGE-ELEMENTS from figure 3.1, the Piton translation of which is in Appendix A. 3.4.1 Compiling Variable References A variable reference is a reference to one of the formal parameters of the function (e.g., the variable LIST is referenced on lines marked [0], <ref> [1] </ref>, [2], [4] and [5] in CHANGE-ELEMENTS). When a function is called, its formals are bound to the results of evaluating the actual parameters. Thus, each formal is bound to a heap address. Variable references push the address that the variable is bound to on the temporary stack. <p> There are two kinds of hypotheses in the correctness theorem. First are syntactic restrictions on the programs that will be trivially satisfied when the compiler is used on actual examples. Second are hypotheses that deal with the resource limits of Piton. The hypotheses labeled <ref> [1] </ref> and [2] state that the expression and functions are all proper (see section 4.3). Hypothesis [3] is another syntactic requirement, namely that all the variable names in the variable alist are literal atoms. <p> There have been two sub-expressions removed in the S-level expression. The first is (CDR (APP X '(*1*TRUE . *1*FALSE))) which occurs on lines [0], <ref> [1] </ref>, and [5]. The second is (CONS T X) on lines [2] and [4]. When the expression is evaluated, the value for (CDR (APP X '(*1*TRUE . *1*FALSE))) will be computed and stored when the execution is at the first occurrence of the expression on line [6]. <p> 4 (S-EVAL-L-EVAL-FLAG-T) (IMPLIES (AND (S-GOOD-STATEP S C) ;<ref> [1] </ref> (GOOD-POSP1 (S-POS S) (S-BODY (S-PROG S))) ;[2] (EQUAL (S-ERR-FLAG (S-EVAL T S C)) 'RUN)) ;[3] (AND (L-EVAL T (S-EXPAND-TEMPS T (S-EXPR S)) (S-PARAMS S) C) (EQUAL (S-ANS (S-EVAL T S C)) (CAR (L-EVAL T (S-EXPAND-TEMPS T (S-EXPR S)) (S-PARAMS S) C))))) Hypothesis [1] ensures that the state S is proper and that the programs of S are analogous to the corresponding programs in the Logic. Hypothesis [2] states that the current expression specified in S is good, that it is not part of a quoted constant. <p> FLAG ;[5] (S-EXPAND-TEMPS FLAG (S-EXPR S)) (S-PARAMS S) C) (S-CHECK-TEMPS-SETP (S-TEMPS S)) ;[6] (NOT (EQUAL FLAG 'LIST))) ;[7] (AND (EQUAL (S-ERR-FLAG (S-EVAL FLAG S C)) 'RUN) : : : )) Finally, LOGIC-&gt;S is shown (under certain conditions) to produce a state S on which the hypotheses of Theorem 5 labeled <ref> [1] </ref>, [3], [4] and [6] hold. Accord ingly, the following theorem can be proved. THEOREM 6 (LOGIC-&gt;S-OK) 68 A Verified Implementation of an Applicative Language with Dynamic Storage Allocation (IMPLIES (AND (L-PROPER-EXPRP T EXPR PROGRAM-NAMES (STRIP-CARS ALIST)) ;[1] (L-PROPER-PROGRAMSP PROGRAM-NAMES) ;[2] (ALL-LITATOMS (STRIP-CARS ALIST)) ;[3] (L-EVAL T EXPR ALIST CLOCK)) ;[4] <p> Hypothesis <ref> [1] </ref> of Theorem 6 states that EXPR is proper; that is all sub-terms end in NIL, any user-defined functions called are named in PROGRAM-NAMES, and all references to variables are named in (STRIP-CARS ALIST). Hypothesis [2] states that BODY of the function named by PROGRAM-NAMES are proper expressions. <p> (P-PROG-SEGMENT L) (P-DATA-SEGMENT L)) (LR-GOOD-PTRPS (P-TEMP-STK L) (P-DATA-SEGMENT L)) ;[7] (ALL-NOT-UNDEF-ADDRS (P-TEMP-STK L)) ;[8] (LR-PROPER-HEAPP (P-DATA-SEGMENT L)) ;[9] (LR-PROPER-REF-COUNTSP (LR-MAX-NODE (P-DATA-SEGMENT L)) ;[10] (P-TEMP-STK L) (P-CTRL-STK L) (P-PROG-SEGMENT L) (P-DATA-SEGMENT L)) (EQUAL (VALUE (AREA-NAME (LR-ALLOC-NODE-JUMP-TABLE-ADDR)) ;[11] (P-DATA-SEGMENT L)) (LR-MAKE-ALLOC-NODE-JUMP-TABLE))) The eleven conjuncts of this definition can be paraphrased as follows. <ref> [1] </ref> compiling L to Piton (via LR-&gt;P) produces a proper P-STATE; [2] The program named by the PC of L is defined in the L program segment; [3] the name of the first program is 'MAIN; [4] the remaining names of programs in the program segment are proper names for user-defined
Reference: [2] <author> H.G. Baker. </author> <title> List-processing in real time on a serial computer. </title> <journal> Communications of the ACM, </journal> <volume> 21(4) </volume> <pages> 185-214, </pages> <month> April </month> <year> 1978. </year>
Reference-contexts: Topor [29] gives a proof of the Schorr-Waite list marking algorithm. Dijkstra et. al. [13] gives a proof of an algorithm that allows the garbage collector and the user's program to run concurrently. Russinoff [27] gives a machine checked proof of an improved version of that algorithm. Baker <ref> [2] </ref> gives an algorithm that allows the garbage collector to run in real-time. He also gives an informal proof of the correctness of the algorithm. There have been three previous large compiler verification efforts. Polak [26] verified a compiler for a substantial subset of Pascal. <p> An example is the function CHANGE-ELEMENTS from figure 3.1, the Piton translation of which is in Appendix A. 3.4.1 Compiling Variable References A variable reference is a reference to one of the formal parameters of the function (e.g., the variable LIST is referenced on lines marked [0], [1], <ref> [2] </ref>, [4] and [5] in CHANGE-ELEMENTS). When a function is called, its formals are bound to the results of evaluating the actual parameters. Thus, each formal is bound to a heap address. Variable references push the address that the variable is bound to on the temporary stack. <p> The constant T is referenced on the lines labeled <ref> [2] </ref> and [5] of CHANGE-ELEMENTS. The constant F is referenced on the lines labeled [3] and [5]. To reference a con stant, the address that represents the constant must be pushed on the temporary stack. <p> To reference a con stant, the address that represents the constant must be pushed on the temporary stack. Since this increases the references to that address, the reference count must be incremented as well. The translation of the constant F on line <ref> [2] </ref> is shown below: (DL L-23 () ; Put reference count address on stack (PUSH-CONSTANT (ADDR (HEAP . 4)))) (DL L-24 () (FETCH)) ; fetch reference count (DL L-25 () (ADD1-NAT)) ; add one to it (DL L-26 () ; Put reference count address on stack (PUSH-CONSTANT (ADDR (HEAP . 4)))) <p> Then if f is a user-defined function, the Piton instruction (CALL U-f) is appended. If f is a predefined Nqthm functions, (CALL f) is appended. The compilation of (CONS F (CHANGE-ELEMENTS (CDR LIST))) on the line marked <ref> [2] </ref> of Figure A is given by the Piton instructions labeled L-23 to L-37. First translate the constant F, which is given by lines labeled L-23 to L-28. <p> There are two kinds of hypotheses in the correctness theorem. First are syntactic restrictions on the programs that will be trivially satisfied when the compiler is used on actual examples. Second are hypotheses that deal with the resource limits of Piton. The hypotheses labeled [1] and <ref> [2] </ref> state that the expression and functions are all proper (see section 4.3). Hypothesis [3] is another syntactic requirement, namely that all the variable names in the variable alist are literal atoms. <p> There have been two sub-expressions removed in the S-level expression. The first is (CDR (APP X '(*1*TRUE . *1*FALSE))) which occurs on lines [0], [1], and [5]. The second is (CONS T X) on lines <ref> [2] </ref> and [4]. When the expression is evaluated, the value for (CDR (APP X '(*1*TRUE . *1*FALSE))) will be computed and stored when the execution is at the first occurrence of the expression on line [6]. <p> Hypothesis <ref> [2] </ref> states that the current expression specified in S is good, that it is not part of a quoted constant. Hypothesis [3] stipulates that the final state produced by S-EVAL is not an error state. Under these hypotheses, L-EVAL returns non-F and produces the same result as S-EVAL. <p> Hypothesis [1] of Theorem 6 states that EXPR is proper; that is all sub-terms end in NIL, any user-defined functions called are named in PROGRAM-NAMES, and all references to variables are named in (STRIP-CARS ALIST). Hypothesis <ref> [2] </ref> states that BODY of the function named by PROGRAM-NAMES are proper expressions. Hypothesis [3] states that all the variables in ALIST are literal atoms. 6.2 The LR layer The semantics of the LR layer are defined operationally by the interpreter LR-EVAL. <p> (P-TEMP-STK L)) ;[8] (LR-PROPER-HEAPP (P-DATA-SEGMENT L)) ;[9] (LR-PROPER-REF-COUNTSP (LR-MAX-NODE (P-DATA-SEGMENT L)) ;[10] (P-TEMP-STK L) (P-CTRL-STK L) (P-PROG-SEGMENT L) (P-DATA-SEGMENT L)) (EQUAL (VALUE (AREA-NAME (LR-ALLOC-NODE-JUMP-TABLE-ADDR)) ;[11] (P-DATA-SEGMENT L)) (LR-MAKE-ALLOC-NODE-JUMP-TABLE))) The eleven conjuncts of this definition can be paraphrased as follows. [1] compiling L to Piton (via LR-&gt;P) produces a proper P-STATE; <ref> [2] </ref> The program named by the PC of L is defined in the L program segment; [3] the name of the first program is 'MAIN; [4] the remaining names of programs in the program segment are proper names for user-defined functions; [5] the program segment is well formed; [6] the control <p> Most mark and sweep garbage collection algorithms are not run until the heap is exhausted. Then the computation stops while free nodes are found. There have been adaptions to mark and sweep schemes that do a little bit of work each time an allocation is done <ref> [2] </ref>. These algorithms are more suitable to real time systems. Many garbage collection algorithms split memory in half. Allocation is done in one half until it has been filled up.
Reference: [3] <author> Bill Bevier. </author> <title> A library for hardware verification. Internal Note 57, Computational Logic, </title> <publisher> Inc., </publisher> <year> 1988. </year>
Reference-contexts: The constant T is referenced on the lines labeled [2] and [5] of CHANGE-ELEMENTS. The constant F is referenced on the lines labeled <ref> [3] </ref> and [5]. To reference a con stant, the address that represents the constant must be pushed on the temporary stack. Since this increases the references to that address, the reference count must be incremented as well. <p> (DL L-26 () ; Put reference count address on stack (PUSH-CONSTANT (ADDR (HEAP . 4)))) (DL L-27 () (DEPOSIT)) ; update reference count (DL L-28 () ; Put T 's address on stack (PUSH-CONSTANT (ADDR (HEAP . 4)))) The translations of the references to the constant T on lines marked <ref> [3] </ref> and [5] of CHANGE-ELEMENTS are given by the instructions labeled L-39 to L-44, L-66 to L-71, respectively. The translation of F on the line marked [5] of CHANGE-ELEMENTS is given by the instructions labeled L-73 to L-78. <p> Second are hypotheses that deal with the resource limits of Piton. The hypotheses labeled [1] and [2] state that the expression and functions are all proper (see section 4.3). Hypothesis <ref> [3] </ref> is another syntactic requirement, namely that all the variable names in the variable alist are literal atoms. <p> Hypothesis [2] states that the current expression specified in S is good, that it is not part of a quoted constant. Hypothesis <ref> [3] </ref> stipulates that the final state produced by S-EVAL is not an error state. Under these hypotheses, L-EVAL returns non-F and produces the same result as S-EVAL. <p> ;[5] (S-EXPAND-TEMPS FLAG (S-EXPR S)) (S-PARAMS S) C) (S-CHECK-TEMPS-SETP (S-TEMPS S)) ;[6] (NOT (EQUAL FLAG 'LIST))) ;[7] (AND (EQUAL (S-ERR-FLAG (S-EVAL FLAG S C)) 'RUN) : : : )) Finally, LOGIC-&gt;S is shown (under certain conditions) to produce a state S on which the hypotheses of Theorem 5 labeled [1], <ref> [3] </ref>, [4] and [6] hold. Accord ingly, the following theorem can be proved. THEOREM 6 (LOGIC-&gt;S-OK) 68 A Verified Implementation of an Applicative Language with Dynamic Storage Allocation (IMPLIES (AND (L-PROPER-EXPRP T EXPR PROGRAM-NAMES (STRIP-CARS ALIST)) ;[1] (L-PROPER-PROGRAMSP PROGRAM-NAMES) ;[2] (ALL-LITATOMS (STRIP-CARS ALIST)) ;[3] (L-EVAL T EXPR ALIST CLOCK)) ;[4] (EQUAL <p> Hypothesis [2] states that BODY of the function named by PROGRAM-NAMES are proper expressions. Hypothesis <ref> [3] </ref> states that all the variables in ALIST are literal atoms. 6.2 The LR layer The semantics of the LR layer are defined operationally by the interpreter LR-EVAL. <p> (P-PROG-SEGMENT L) (P-DATA-SEGMENT L)) (EQUAL (VALUE (AREA-NAME (LR-ALLOC-NODE-JUMP-TABLE-ADDR)) ;[11] (P-DATA-SEGMENT L)) (LR-MAKE-ALLOC-NODE-JUMP-TABLE))) The eleven conjuncts of this definition can be paraphrased as follows. [1] compiling L to Piton (via LR-&gt;P) produces a proper P-STATE; [2] The program named by the PC of L is defined in the L program segment; <ref> [3] </ref> the name of the first program is 'MAIN; [4] the remaining names of programs in the program segment are proper names for user-defined functions; [5] the program segment is well formed; [6] the control stack contains pointers to nodes that are not on the free list; [7] the temporary stack <p> MAX-CTRL MAX-TEMP WORD-SIZE) = (LR-&gt;P (S-&gt;LR (LOGIC-&gt;S EXPR ALIST PNAMES) HEAP-SIZE MAX-CTRL MAX-TEMP WORD-SIZE)) 126 A Verified Implementation of an Applicative Language with Dynamic Storage Allocation Appendix C Nqthm Libraries This chapter lists the events in lists, integers, naturals, and bags libraries of Bevier, Kaufmann and Wilding (see [16] and <ref> [3] </ref>). C.1 Bags Library The list of events in the Bags Library has been omitted in the current version of this report. C.2 Naturals Library The list of events in the Natural Library has been omitted in the current version of this report.
Reference: [4] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Milner and Weyhrauch [22] give a machine checked proof of an expression compiler similar to that of McCarthy and Painter. This is part of a larger compiler that includes assignment, conditional, and while statements. Cartwright [8] and Aubin [1] also prove versions of the McCarthy-Painter compiler. Boyer and Moore <ref> [4] </ref> prove mechanically the correctness of a compiler similar to that of McCarthy and Painter. Their target machine has an unbounded stack, infinite precision, an unbounded number of registers and the operations of the target machine are the same as the expression language. <p> An example is the function CHANGE-ELEMENTS from figure 3.1, the Piton translation of which is in Appendix A. 3.4.1 Compiling Variable References A variable reference is a reference to one of the formal parameters of the function (e.g., the variable LIST is referenced on lines marked [0], [1], [2], <ref> [4] </ref> and [5] in CHANGE-ELEMENTS). When a function is called, its formals are bound to the results of evaluating the actual parameters. Thus, each formal is bound to a heap address. Variable references push the address that the variable is bound to on the temporary stack. <p> Second are hypotheses that deal with the resource limits of Piton. The hypotheses labeled [1] and [2] state that the expression and functions are all proper (see section 4.3). Hypothesis [3] is another syntactic requirement, namely that all the variable names in the variable alist are literal atoms. Hypothesis <ref> [4] </ref> states that all the quoted constants in the expression only use shells that are defined (in the current version of the compiler all the shells are either TRUE, FALSE, a NUMBERP or a CONS). <p> There have been two sub-expressions removed in the S-level expression. The first is (CDR (APP X '(*1*TRUE . *1*FALSE))) which occurs on lines [0], [1], and [5]. The second is (CONS T X) on lines [2] and <ref> [4] </ref>. When the expression is evaluated, the value for (CDR (APP X '(*1*TRUE . *1*FALSE))) will be computed and stored when the execution is at the first occurrence of the expression on line [6]. <p> (S-EXPAND-TEMPS FLAG (S-EXPR S)) (S-PARAMS S) C) (S-CHECK-TEMPS-SETP (S-TEMPS S)) ;[6] (NOT (EQUAL FLAG 'LIST))) ;[7] (AND (EQUAL (S-ERR-FLAG (S-EVAL FLAG S C)) 'RUN) : : : )) Finally, LOGIC-&gt;S is shown (under certain conditions) to produce a state S on which the hypotheses of Theorem 5 labeled [1], [3], <ref> [4] </ref> and [6] hold. Accord ingly, the following theorem can be proved. THEOREM 6 (LOGIC-&gt;S-OK) 68 A Verified Implementation of an Applicative Language with Dynamic Storage Allocation (IMPLIES (AND (L-PROPER-EXPRP T EXPR PROGRAM-NAMES (STRIP-CARS ALIST)) ;[1] (L-PROPER-PROGRAMSP PROGRAM-NAMES) ;[2] (ALL-LITATOMS (STRIP-CARS ALIST)) ;[3] (L-EVAL T EXPR ALIST CLOCK)) ;[4] (EQUAL (S-ANS <p> (P-DATA-SEGMENT L)) (LR-MAKE-ALLOC-NODE-JUMP-TABLE))) The eleven conjuncts of this definition can be paraphrased as follows. [1] compiling L to Piton (via LR-&gt;P) produces a proper P-STATE; [2] The program named by the PC of L is defined in the L program segment; [3] the name of the first program is 'MAIN; <ref> [4] </ref> the remaining names of programs in the program segment are proper names for user-defined functions; [5] the program segment is well formed; [6] the control stack contains pointers to nodes that are not on the free list; [7] the temporary stack contains pointers to nodes that are not on the
Reference: [5] <author> R. S. Boyer and J S. Moore. </author> <title> The addition of bounded quantification and partial functions to a computational logic and its theorem prover. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 4(2) </volume> <pages> 117-172, </pages> <year> 1988. </year>
Reference-contexts: The implementation consists of a compiler for functions in the Logic and some run-time support functions. The specification requires the implementation preserve the semantics of the Logic as defined by the Nqthm function V&C$. V&C$ is described by Boyer and Moore in <ref> [5] </ref>. V&C$ is similar to the Lisp interpreter EVAL, except that instead of producing just a value for an expression, it produces a value and the cost of evaluating the expression. <p> example is the function CHANGE-ELEMENTS from figure 3.1, the Piton translation of which is in Appendix A. 3.4.1 Compiling Variable References A variable reference is a reference to one of the formal parameters of the function (e.g., the variable LIST is referenced on lines marked [0], [1], [2], [4] and <ref> [5] </ref> in CHANGE-ELEMENTS). When a function is called, its formals are bound to the results of evaluating the actual parameters. Thus, each formal is bound to a heap address. Variable references push the address that the variable is bound to on the temporary stack. <p> The constant T is referenced on the lines labeled [2] and <ref> [5] </ref> of CHANGE-ELEMENTS. The constant F is referenced on the lines labeled [3] and [5]. To reference a con stant, the address that represents the constant must be pushed on the temporary stack. Since this increases the references to that address, the reference count must be incremented as well. <p> The constant T is referenced on the lines labeled [2] and <ref> [5] </ref> of CHANGE-ELEMENTS. The constant F is referenced on the lines labeled [3] and [5]. To reference a con stant, the address that represents the constant must be pushed on the temporary stack. Since this increases the references to that address, the reference count must be incremented as well. <p> () ; Put reference count address on stack (PUSH-CONSTANT (ADDR (HEAP . 4)))) (DL L-27 () (DEPOSIT)) ; update reference count (DL L-28 () ; Put T 's address on stack (PUSH-CONSTANT (ADDR (HEAP . 4)))) The translations of the references to the constant T on lines marked [3] and <ref> [5] </ref> of CHANGE-ELEMENTS are given by the instructions labeled L-39 to L-44, L-66 to L-71, respectively. The translation of F on the line marked [5] of CHANGE-ELEMENTS is given by the instructions labeled L-73 to L-78. <p> ; Put T 's address on stack (PUSH-CONSTANT (ADDR (HEAP . 4)))) The translations of the references to the constant T on lines marked [3] and <ref> [5] </ref> of CHANGE-ELEMENTS are given by the instructions labeled L-39 to L-44, L-66 to L-71, respectively. The translation of F on the line marked [5] of CHANGE-ELEMENTS is given by the instructions labeled L-73 to L-78. In the example Piton state of Appendix A the constant '(*1*TRUE . *1*FALSE) is represented by the Piton ad dress (ADDR (HEAP . 16)). <p> Hypothesis [4] states that all the quoted constants in the expression only use shells that are defined (in the current version of the compiler all the shells are either TRUE, FALSE, a NUMBERP or a CONS). Hypothesis <ref> [5] </ref> states that the programs, as well as the bindings in the variable alist ALIST, only use defined shells. Hypothesis [6] states that V&C$ produces a non-FALSE result when applied to the expression EXPR., i.e., the expression has a defined value. <p> The flag field of S-TEMPS is set to T and the value field is set to the result. Consider the expression shown on lines [0] to <ref> [5] </ref> in Figure 5.1 and an equivalent S-level expression with common sub-expressions removed shown on lines [6] 58 A Verified Implementation of an Applicative Language with Dynamic Storage Allocation (IF (CAR (CDR (APP X '(*1*TRUE . *1*FALSE)))) ;[0] (CONS (IF (CDR (CDR (APP X '(*1*TRUE . *1*FALSE)))) ;[1] (CONS T X) <p> There have been two sub-expressions removed in the S-level expression. The first is (CDR (APP X '(*1*TRUE . *1*FALSE))) which occurs on lines [0], [1], and <ref> [5] </ref>. The second is (CONS T X) on lines [2] and [4]. When the expression is evaluated, the value for (CDR (APP X '(*1*TRUE . *1*FALSE))) will be computed and stored when the execution is at the first occurrence of the expression on line [6]. <p> L to Piton (via LR-&gt;P) produces a proper P-STATE; [2] The program named by the PC of L is defined in the L program segment; [3] the name of the first program is 'MAIN; [4] the remaining names of programs in the program segment are proper names for user-defined functions; <ref> [5] </ref> the program segment is well formed; [6] the control stack contains pointers to nodes that are not on the free list; [7] the temporary stack contains pointers to nodes that are not on the free list; [8] all the addresses on the temporary stack are not the undefined node; [9] <p> The induction is similar to that suggested by the definition of S-EVAL, however L must be modified similarly to the way LR-EVAL modifies it. The following theorem is used to relieve the hypothesis labeled <ref> [5] </ref> of Theo rem 7. 3 THEOREM 8 (LR-EVAL-S-EVAL-FLAG-RUN) (IMPLIES (AND (LR-PROPER-P-STATEP (LR-&gt;P (S-&gt;LR1 S L TABLE))) (GOOD-POSP FLAG (S-POS S) (S-BODY (S-PROG S))) (LR-S-SIMILAR-STATESP (S-PARAMS S) (S-TEMPS S) (S-&gt;LR1 S L TABLE) TABLE) (S-GOOD-STATEP S C) (S-ALL-TEMPS-SETP FLAG (IF (EQUAL FLAG 'LIST) (S-EXPR-LIST S) (S-EXPR S)) (TEMP-ALIST-TO-SET (S-TEMPS S))) (S-ALL-PROGS-TEMPS-SETP
Reference: [6] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: Extending the compiler to handle all of the Logic is discussed more fully in section 7.1. 1.5 The Boyer-Moore Logic The source language of the compiler is a subset of the Boyer-Moore Logic which has been discussed in several places, most notably in <ref> [6] </ref> where it is completely and precisely described. Readers not familiar with the Logic should refer to [6]. <p> discussed more fully in section 7.1. 1.5 The Boyer-Moore Logic The source language of the compiler is a subset of the Boyer-Moore Logic which has been discussed in several places, most notably in <ref> [6] </ref> where it is completely and precisely described. Readers not familiar with the Logic should refer to [6]. As in Pure Lisp, all the partial recursive functions can be defined in the Logic. 1.6 Outline of the Presentation This dissertation describes a simple compiler for the Boyer-Moore logic and a proof that the compiler does its job correctly. <p> Below we exhibit a Piton program named DEMO. The program is a list constant in the computational logic of Boyer and Moore <ref> [6] </ref> and is displayed in the traditional Lisp-like notation. Comments are written in the right-hand column, bracketed by the comment delim-iters semi-colon and end-of-line. <p> Hypothesis [5] states that the programs, as well as the bindings in the variable alist ALIST, only use defined shells. Hypothesis <ref> [6] </ref> states that V&C$ produces a non-FALSE result when applied to the expression EXPR., i.e., the expression has a defined value. Hypotheses [7] and [8] are only necessary in the prototype. <p> However, in the Logic LET is an abbreviation that allows users of Nqthm to more easily type formulas in the Logic (see <ref> [6] </ref>). The LET expression is just an abbreviation for: (CONS (FN Y) (FN Y)) Since there is no method for the user to specify to the compiler that certain expressions should only be evaluated once, the compiler should remove common sub-expressions. <p> The flag field of S-TEMPS is set to T and the value field is set to the result. Consider the expression shown on lines [0] to [5] in Figure 5.1 and an equivalent S-level expression with common sub-expressions removed shown on lines <ref> [6] </ref> 58 A Verified Implementation of an Applicative Language with Dynamic Storage Allocation (IF (CAR (CDR (APP X '(*1*TRUE . *1*FALSE)))) ;[0] (CONS (IF (CDR (CDR (APP X '(*1*TRUE . *1*FALSE)))) ;[1] (CONS T X) ;[2] (CONS F Y)) ;[3] (CONS T X)) ;[4] (CDR (APP X '(*1*TRUE . *1*FALSE)))) ;[5] <p> The second is (CONS T X) on lines [2] and [4]. When the expression is evaluated, the value for (CDR (APP X '(*1*TRUE . *1*FALSE))) will be computed and stored when the execution is at the first occurrence of the expression on line <ref> [6] </ref>. Then when the execution reaches the occurrences on lines [7] or [11], the stored value is used (note in any computation that only one of the occurrences on lines [7] or [11] will be executed). <p> (S-EXPR S)) (S-PARAMS S) C) (S-CHECK-TEMPS-SETP (S-TEMPS S)) ;<ref> [6] </ref> (NOT (EQUAL FLAG 'LIST))) ;[7] (AND (EQUAL (S-ERR-FLAG (S-EVAL FLAG S C)) 'RUN) : : : )) Finally, LOGIC-&gt;S is shown (under certain conditions) to produce a state S on which the hypotheses of Theorem 5 labeled [1], [3], [4] and [6] hold. Accord ingly, the following theorem can be proved. <p> proper P-STATE; [2] The program named by the PC of L is defined in the L program segment; [3] the name of the first program is 'MAIN; [4] the remaining names of programs in the program segment are proper names for user-defined functions; [5] the program segment is well formed; <ref> [6] </ref> the control stack contains pointers to nodes that are not on the free list; [7] the temporary stack contains pointers to nodes that are not on the free list; [8] all the addresses on the temporary stack are not the undefined node; [9] the data segment forms a proper heap;
Reference: [7] <author> R.M. Burstall. </author> <title> Proving properties of programs by structural induction. </title> <journal> Computer Journal, </journal> <volume> 12(1) </volume> <pages> 41-48, </pages> <month> February </month> <year> 1969. </year>
Reference-contexts: They prove by hand the correctness of a compiler for a simple expression language. Burstall <ref> [7] </ref> develops a theory for proving properties of programs with structural induction. He uses these techniques to prove the same expression compiler as McCarthy and Painter. Milner and Weyhrauch [22] give a machine checked proof of an expression compiler similar to that of McCarthy and Painter. <p> Hypothesis [5] states that the programs, as well as the bindings in the variable alist ALIST, only use defined shells. Hypothesis [6] states that V&C$ produces a non-FALSE result when applied to the expression EXPR., i.e., the expression has a defined value. Hypotheses <ref> [7] </ref> and [8] are only necessary in the prototype. They ensure that the expression and programs only use the SUBRPs that have been defined, namely CAR, CDR, CONS, FALSE, FALSEP, IF, LISTP, NLISTP, TRUE and TRUEP. Hypotheses [9-17] deal with the resource limitations of Piton. <p> When the expression is evaluated, the value for (CDR (APP X '(*1*TRUE . *1*FALSE))) will be computed and stored when the execution is at the first occurrence of the expression on line [6]. Then when the execution reaches the occurrences on lines <ref> [7] </ref> or [11], the stored value is used (note in any computation that only one of the occurrences on lines [7] or [11] will be executed). If the test expression of the IF at line [7] is not F then we will evaluate (CONS T X) on line [8] and store <p> Then when the execution reaches the occurrences on lines <ref> [7] </ref> or [11], the stored value is used (note in any computation that only one of the occurrences on lines [7] or [11] will be executed). If the test expression of the IF at line [7] is not F then we will evaluate (CONS T X) on line [8] and store the result. <p> Then when the execution reaches the occurrences on lines <ref> [7] </ref> or [11], the stored value is used (note in any computation that only one of the occurrences on lines [7] or [11] will be executed). If the test expression of the IF at line [7] is not F then we will evaluate (CONS T X) on line [8] and store the result. If the test is F then (CONS T X) will not be evaluated when execution reaches line [10]. <p> L program segment; [3] the name of the first program is 'MAIN; [4] the remaining names of programs in the program segment are proper names for user-defined functions; [5] the program segment is well formed; [6] the control stack contains pointers to nodes that are not on the free list; <ref> [7] </ref> the temporary stack contains pointers to nodes that are not on the free list; [8] all the addresses on the temporary stack are not the undefined node; [9] the data segment forms a proper heap; [10] all the reference counts are proper; and [11] the value of the array in
Reference: [8] <author> R. Cartwright. </author> <title> A Practical Formal Semantic Definition and Verification System for Typed LISP. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1976. </year>
Reference-contexts: He uses these techniques to prove the same expression compiler as McCarthy and Painter. Milner and Weyhrauch [22] give a machine checked proof of an expression compiler similar to that of McCarthy and Painter. This is part of a larger compiler that includes assignment, conditional, and while statements. Cartwright <ref> [8] </ref> and Aubin [1] also prove versions of the McCarthy-Painter compiler. Boyer and Moore [4] prove mechanically the correctness of a compiler similar to that of McCarthy and Painter. <p> Hypothesis [5] states that the programs, as well as the bindings in the variable alist ALIST, only use defined shells. Hypothesis [6] states that V&C$ produces a non-FALSE result when applied to the expression EXPR., i.e., the expression has a defined value. Hypotheses [7] and <ref> [8] </ref> are only necessary in the prototype. They ensure that the expression and programs only use the SUBRPs that have been defined, namely CAR, CDR, CONS, FALSE, FALSEP, IF, LISTP, NLISTP, TRUE and TRUEP. Hypotheses [9-17] deal with the resource limitations of Piton. <p> If the test expression of the IF at line [7] is not F then we will evaluate (CONS T X) on line <ref> [8] </ref> and store the result. If the test is F then (CONS T X) will not be evaluated when execution reaches line [10]. <p> names of programs in the program segment are proper names for user-defined functions; [5] the program segment is well formed; [6] the control stack contains pointers to nodes that are not on the free list; [7] the temporary stack contains pointers to nodes that are not on the free list; <ref> [8] </ref> all the addresses on the temporary stack are not the undefined node; [9] the data segment forms a proper heap; [10] all the reference counts are proper; and [11] the value of the array in the global data area named by (AREA-NAME (LR-ALLOC-NODE-JUMP-TABLE-ADDR)) contains the proper table. 1 Some of
Reference: [9] <author> L.M. Chirica and D.F. Martin. </author> <title> An approach to compiler correctness. </title> <booktitle> In Proceedings of the International Conference on Reliable Software, </booktitle> <pages> pages 96-103, </pages> <month> April </month> <year> 1977. </year>
Reference-contexts: The second version contains more optimizations than the first. Morris [24] uses algebraic semantics to specify and partially prove by hand a simple compiler for an Algol like language. Cohn [11] use Edinburgh LCF to prove the correctness of a simple compiling algorithm. Chirica and Martin <ref> [9] </ref> use axiomatic semantics to specify and prove a simple compiler. Lynn [19] uses Hoare-style axiomatic semantics to specify source and target languages of a slightly modified version of London's compiler. He also uses the same technique to prove a slightly modified version of McCarthy and Painter's compiler. <p> With the garbage collector running, this means there is a limit on the number of objects that can be "in use" at one time. The limitation of the size of the heap is represented by hypothesis <ref> [9] </ref> of LOGIC-&gt;P-OK-REALLY. The size of the stacks is also limited, as shown by hypotheses [10] and [13]. The compiler does not provide any input or output operations. <p> [5] the program segment is well formed; [6] the control stack contains pointers to nodes that are not on the free list; [7] the temporary stack contains pointers to nodes that are not on the free list; [8] all the addresses on the temporary stack are not the undefined node; <ref> [9] </ref> the data segment forms a proper heap; [10] all the reference counts are proper; and [11] the value of the array in the global data area named by (AREA-NAME (LR-ALLOC-NODE-JUMP-TABLE-ADDR)) contains the proper table. 1 Some of the interesting aspects of LR-PROPER-P-STATEP will be explained fur ther here.
Reference: [10] <author> Jacques Cohen. </author> <title> Garbage collection of linked data structures. </title> <journal> Computing Surveys, </journal> <pages> pages 341-367, </pages> <year> 1981. </year>
Reference-contexts: The limitation of the size of the heap is represented by hypothesis [9] of LOGIC-&gt;P-OK-REALLY. The size of the stacks is also limited, as shown by hypotheses <ref> [10] </ref> and [13]. The compiler does not provide any input or output operations. <p> If the test expression of the IF at line [7] is not F then we will evaluate (CONS T X) on line [8] and store the result. If the test is F then (CONS T X) will not be evaluated when execution reaches line <ref> [10] </ref>. Therefore, on line [10] we must test to see if (CONS T X) have been evaluated yet, so there is a (TEMP-TEST) form there. 5.2 The Resource Representation Level The next step of compilation translates S-STATEs to an abstract machine that represents the objects in the Logic in terms of <p> If the test expression of the IF at line [7] is not F then we will evaluate (CONS T X) on line [8] and store the result. If the test is F then (CONS T X) will not be evaluated when execution reaches line <ref> [10] </ref>. Therefore, on line [10] we must test to see if (CONS T X) have been evaluated yet, so there is a (TEMP-TEST) form there. 5.2 The Resource Representation Level The next step of compilation translates S-STATEs to an abstract machine that represents the objects in the Logic in terms of Piton's resources (i.e. addresses <p> the control stack contains pointers to nodes that are not on the free list; [7] the temporary stack contains pointers to nodes that are not on the free list; [8] all the addresses on the temporary stack are not the undefined node; [9] the data segment forms a proper heap; <ref> [10] </ref> all the reference counts are proper; and [11] the value of the array in the global data area named by (AREA-NAME (LR-ALLOC-NODE-JUMP-TABLE-ADDR)) contains the proper table. 1 Some of the interesting aspects of LR-PROPER-P-STATEP will be explained fur ther here. <p> Using the correctness theorem requires reasoning about any programs compiled. Other garbage collection schemes can handle circular data structures.Mark and sweep garbage collection schemes can handle circular data structures <ref> [10] </ref>. They do not lend themselves well to any real time systems. Most mark and sweep garbage collection algorithms are not run until the heap is exhausted. Then the computation stops while free nodes are found.
Reference: [11] <author> A. Cohn. </author> <title> High level proof in lcf. </title> <booktitle> In Proceedings of the Fifth Symposium on Automated Deduction, </booktitle> <year> 1979. </year>
Reference-contexts: The second version contains more optimizations than the first. Morris [24] uses algebraic semantics to specify and partially prove by hand a simple compiler for an Algol like language. Cohn <ref> [11] </ref> use Edinburgh LCF to prove the correctness of a simple compiling algorithm. Chirica and Martin [9] use axiomatic semantics to specify and prove a simple compiler. Lynn [19] uses Hoare-style axiomatic semantics to specify source and target languages of a slightly modified version of London's compiler. <p> (APP X '(*1*TRUE . *1*FALSE)))) ;[5] '(IF (CAR ((TEMP-EVAL) (CDR (APP X '(*1*TRUE . *1*FALSE))))) ;[6] (CONS (IF (CDR ((TEMP-FETCH) (CDR (APP X '(*1*TRUE . *1*FALSE))))) ;[7] ((TEMP-EVAL) (CONS T X)) ;[8] (CONS F Y)) ;[9] ((TEMP-TEST) (CONS T X))) ;[10] ((TEMP-FETCH) (CDR (APP X '(*1*TRUE . *1*FALSE))))) ;<ref> [11] </ref> to [11]. There have been two sub-expressions removed in the S-level expression. The first is (CDR (APP X '(*1*TRUE . *1*FALSE))) which occurs on lines [0], [1], and [5]. The second is (CONS T X) on lines [2] and [4]. <p> When the expression is evaluated, the value for (CDR (APP X '(*1*TRUE . *1*FALSE))) will be computed and stored when the execution is at the first occurrence of the expression on line [6]. Then when the execution reaches the occurrences on lines [7] or <ref> [11] </ref>, the stored value is used (note in any computation that only one of the occurrences on lines [7] or [11] will be executed). <p> Then when the execution reaches the occurrences on lines [7] or <ref> [11] </ref>, the stored value is used (note in any computation that only one of the occurrences on lines [7] or [11] will be executed). If the test expression of the IF at line [7] is not F then we will evaluate (CONS T X) on line [8] and store the result. If the test is F then (CONS T X) will not be evaluated when execution reaches line [10]. <p> are not on the free list; [7] the temporary stack contains pointers to nodes that are not on the free list; [8] all the addresses on the temporary stack are not the undefined node; [9] the data segment forms a proper heap; [10] all the reference counts are proper; and <ref> [11] </ref> the value of the array in the global data area named by (AREA-NAME (LR-ALLOC-NODE-JUMP-TABLE-ADDR)) contains the proper table. 1 Some of the interesting aspects of LR-PROPER-P-STATEP will be explained fur ther here.
Reference: [12] <author> Paul Corzon. </author> <title> Deriving correctness properties of compiled code. In Higher Order Logic Theorem Proving and Its Applications, 1992. 139 140 A Verified Implementation of an Applicative Language with Dynamic Storage Allocation </title>
Reference-contexts: Micro-Gypsy allows the following simple types: integers (which have the same range as the target machine), Booleans and characters. These are directly representable in Piton. In addition Micro Gypsy allows arrays containing elements of one of the simple types. Subsequent to the Piton and Micro-Gypsy effort, Curzon <ref> [12] </ref> has proved the correctness of an assembly-level language implementation. However the target machine is an idealization of a real machine with infinite memory. Oliva and Wand [25] give a denotational specification for a restricted subset of Scheme called PreScheme and derive a compiling algorithm for PreScheme.
Reference: [13] <author> E.W. Dijkstra, L. Lamport, A.J. Martin, C.S. Schloten, and E.F.M. Steffens. </author> <title> On-the-fly garbage collection: an exercise in cooperation. </title> <journal> CACM, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1978. </year>
Reference-contexts: The run-time system, which includes dynamic storage allocation, has a mechanically checked proof of correctness. A proof of run-time system that includes a reference count garbage collector is in progress. There have been proofs of garbage collection algorithms in the past (e.g., <ref> [13] </ref> and [27]) but no proofs of actual code that include a garbage collector. 6. This work provides a solid base for a verified implementation of an important subset of Common Lisp. Common Lisp is a relatively widely used "real" programming language. <p> Levy [17] gives an approach to proving the correctness of compilers by using interpretations between theories. There have been many proofs of garbage collection algorithms. Topor [29] gives a proof of the Schorr-Waite list marking algorithm. Dijkstra et. al. <ref> [13] </ref> gives a proof of an algorithm that allows the garbage collector and the user's program to run concurrently. Russinoff [27] gives a machine checked proof of an improved version of that algorithm. Baker [2] gives an algorithm that allows the garbage collector to run in real-time. <p> The limitation of the size of the heap is represented by hypothesis [9] of LOGIC-&gt;P-OK-REALLY. The size of the stacks is also limited, as shown by hypotheses [10] and <ref> [13] </ref>. The compiler does not provide any input or output operations.
Reference: [14] <author> Donald I. Good, Robert L. Akers, Lawrence M. Smith, and William D. Young. </author> <title> Combined report on gypsy 2.05, middle-gypsy and micro-gypsy draft. </title> <type> Technical Report 1-d, </type> <institution> Computational Logic, Inc., </institution> <month> March </month> <year> 1992. </year> <note> supercedes August 2, 1989 edition. </note>
Reference-contexts: Piton provides two stacks which are also implemented in the FM8502 memory. One of the most difficult parts of the Piton proof is verifying the correct implementation of the stacks on FM8502. Young [30] compiles a subset of Gypsy 2.05 <ref> [14] </ref>, called Micro-Gypsy, into Piton. Micro-Gypsy is a von Neumann language similar to a subset of Pascal. The prin cipal difference between Young's work and this one are: 6 A Verified Implementation of an Applicative Language with Dynamic Storage Allocation 1. Micro-Gypsy is a substantially smaller language than the Logic.
Reference: [15] <author> Guy L. Steele Jr. </author> <title> Common LISP: The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: Some proofs of compilers have used languages designed to make such proofs easier. The Logic is a small language, but it is hardly a toy language. It is very similar to a small but useful subset of Common Lisp <ref> [15] </ref>. Since Piton has been implemented on an actual machine, the compiler proof had to deal with the finite resources of that machine. 4. The abstract data-types of the Logic (e.g. CONS) are different from the concrete data-type of Piton (a large array). <p> However, it would be a straightforward task to write a Common Lisp function to construct the proper call to the compiler given an expression and a variable bindings alist. 7.2 Compiling Common Lisp Common Lisp <ref> [15] </ref> is used by a much larger community than the Logic. The Logic is similar to an applicative subset of Common Lisp. Modifying the compiler to compile this subset of Common Lisp should be straightforward. Modifying the correctness proof should not be hard either. <p> This is economical in memory use, but would execute slowly. The verification of a "real" Common Lisp compiler would require solving several hard problems in addition to the ones mentioned above. First, Common Lisp would have to be formalized | that is the Common Lisp manual <ref> [15] </ref> would have to be described in a formal language. Second, the output language of the compiler would have to be described formally | as had been noted, Piton, as it stands now, would not be an adequate target for Common Lisp.
Reference: [16] <author> Matthew Kaufmann. </author> <title> An integer library for nqthm. Internal Note 182, Computational Logic, </title> <publisher> Inc., </publisher> <year> 1990. </year>
Reference-contexts: The way around this problem is to prove that the Logic program being compiled runs without resource errors. All arithmetic is fixnum arithmetic. This is represented by hypothesis <ref> [16] </ref> of the LOGIC-&gt;P-OK-REALLY which ensures that the word size of Piton is large enough to represent the result of every arithmetic expression. As with any programming language implementation, there is a limit on the number of objects that can be constructed. <p> PNAMES HEAP-SIZE MAX-CTRL MAX-TEMP WORD-SIZE) = (LR-&gt;P (S-&gt;LR (LOGIC-&gt;S EXPR ALIST PNAMES) HEAP-SIZE MAX-CTRL MAX-TEMP WORD-SIZE)) 126 A Verified Implementation of an Applicative Language with Dynamic Storage Allocation Appendix C Nqthm Libraries This chapter lists the events in lists, integers, naturals, and bags libraries of Bevier, Kaufmann and Wilding (see <ref> [16] </ref> and [3]). C.1 Bags Library The list of events in the Bags Library has been omitted in the current version of this report. C.2 Naturals Library The list of events in the Natural Library has been omitted in the current version of this report.
Reference: [17] <author> B.H. Levy. </author> <title> An approach to compiler correctness using interpretation between theories. </title> <type> Technical Report 85(8354)-1, </type> <institution> Aerospace Corporation, </institution> <month> April </month> <year> 1985. </year>
Reference-contexts: He also uses the same technique to prove a slightly modified version of McCarthy and Painter's compiler. The former proof was done mostly by hand, the latter with machine assistance. Levy <ref> [17] </ref> gives an approach to proving the correctness of compilers by using interpretations between theories. There have been many proofs of garbage collection algorithms. Topor [29] gives a proof of the Schorr-Waite list marking algorithm.
Reference: [18] <author> R.L. </author> <title> London. Correctness of two compilers for a lisp subset. </title> <type> Technical Report AIM-151, </type> <institution> Stanford Univerity Artificial Intelligence Laboratory, </institution> <month> October </month> <year> 1971. </year>
Reference-contexts: Their target machine has an unbounded stack, infinite precision, an unbounded number of registers and the operations of the target machine are the same as the expression language. Their compiler implements a simple constant folding optimization. Technical Report #83 January 6, 1993 5 London <ref> [18] </ref> proves by hand the correctness of two versions of a compiler for a subset of Lisp. The second version contains more optimizations than the first. Morris [24] uses algebraic semantics to specify and partially prove by hand a simple compiler for an Algol like language.
Reference: [19] <author> Donald Scott Lynn. </author> <title> Interactive compiler proving using hoare proof rules. </title> <type> Technical Report ISI/RR-78-70, </type> <institution> Information Sciences Institute, </institution> <month> January </month> <year> 1978. </year>
Reference-contexts: Morris [24] uses algebraic semantics to specify and partially prove by hand a simple compiler for an Algol like language. Cohn [11] use Edinburgh LCF to prove the correctness of a simple compiling algorithm. Chirica and Martin [9] use axiomatic semantics to specify and prove a simple compiler. Lynn <ref> [19] </ref> uses Hoare-style axiomatic semantics to specify source and target languages of a slightly modified version of London's compiler. He also uses the same technique to prove a slightly modified version of McCarthy and Painter's compiler. The former proof was done mostly by hand, the latter with machine assistance.
Reference: [20] <author> J. McCarthy, P.W. Abrahams, D.J. Edwards, T.P. Hart, and M.I. Levin. </author> <title> LISP 1.5 Programmer's Manual. </title> <publisher> MIT, </publisher> <year> 1962. </year>
Reference: [21] <author> John McCarthy and J. Painter. </author> <title> Correctness of a compiler for arithmetic expressions. </title> <booktitle> In Proceeding of Symposium on Applied Mathematics, </booktitle> <volume> volume 19. </volume> <publisher> American Mathematical Society, </publisher> <year> 1967. </year>
Reference-contexts: It would be quite useful to have a very reliable implementation of the Boyer-Moore theorem prover. 1.3 Related Work The first attempt to prove the correctness of a compiler using an interpreter equiv alence proof seems to be the work of McCarthy and Painter <ref> [21] </ref>. They prove by hand the correctness of a compiler for a simple expression language. Burstall [7] develops a theory for proving properties of programs with structural induction. He uses these techniques to prove the same expression compiler as McCarthy and Painter.
Reference: [22] <author> R. Milner and R. Weyhrauch. </author> <title> Proving Compiler Correctness in a Mechanized Logic, </title> <address> pages 51-70. </address> <publisher> Edinburgh University Press, Edinburgh, </publisher> <address> Scotland, </address> <year> 1972. </year>
Reference-contexts: They prove by hand the correctness of a compiler for a simple expression language. Burstall [7] develops a theory for proving properties of programs with structural induction. He uses these techniques to prove the same expression compiler as McCarthy and Painter. Milner and Weyhrauch <ref> [22] </ref> give a machine checked proof of an expression compiler similar to that of McCarthy and Painter. This is part of a larger compiler that includes assignment, conditional, and while statements. Cartwright [8] and Aubin [1] also prove versions of the McCarthy-Painter compiler.
Reference: [23] <author> J Strother Moore. Piton: </author> <title> A verified assembly level language. </title> <type> Technical Report 22, </type> <institution> Computational Logic, Inc., </institution> <year> 1988. </year>
Reference-contexts: The Boyer-Moore logic (hereafter referred to simply as the Logic) defines an applicative programming language similar to pure Lisp. The compiler produces code in the high-level assembly language Piton <ref> [23] </ref>. The proof has been broken down into steps in anticipation of its eventual extension to handle all of the Logic. The compiler for the full Logic is described and how the mechanically checked proof for the prototype can be extended is explained. <p> He does handle the Pascal predefined procedure NEW to allocate memory dynamically. However, his target machine has direct support for this feature in the form of an instruction that does the allocation. This is not a feature of most microprocessors. Moore <ref> [23] </ref> verifies that an implementation of the language Piton is correctly implemented on the FM8502 microprocessor. The implementation consists of a compiler, an assembler and a linker. Piton is a stack-based, high-level assembly language (see Chapter 2 for more details about the Piton language). <p> Finally, Chapter 7 describes how this work can be extended. 8 A Verified Implementation of an Applicative Language with Dynamic Storage Allocation Chapter 2 Piton Piton is a high-level assembly language developed by J Moore <ref> [23] </ref>. Piton was designed for verified applications and as the target for verified compilers for higher-level languages. An unusual aspect of Piton is that it provides execute-only programs. It is impossible for a correct Piton program to overwrite itself. <p> Piton is formally specified by an interpreter (P) in the Logic. The rest of this chapter is an informal description of Piton, along with a listing of the Piton definition. It is taken with permission and minor editing from the Piton report by J Moore <ref> [23] </ref>. 2.1 An Informal Sketch of Piton Among the features provided by Piton are: * execute-only program space * named read/write global data spaces randomly accessed as one-dimensional arrays * recursive subroutine call and return * provision of named formal parameters and stack-based parameter passing * provision of named temporary variables <p> All references to "the stack" refer to the temporary stack unless otherwise specified. When we say "push" or "pop" without mentioning a particular stack, we mean to push or pop the temporary stack. The formal defintions of the corresponding functions and predicates are given in the Piton manual <ref> [23] </ref>, the interested reader is refered there. (ADD-ADDR)Well Formedness: No additional constraints. Precondition: There is a natural, n, on top of the stack and a data address, a, immediately below it. The result of incrementing a by n is a legal data address. <p> This phenomenon was described by Moore in <ref> [23] </ref> and the layering here was modeled on his.
Reference: [24] <author> F.L. Morris. </author> <title> Advice of structuring compilers and proving them correct. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 144-152, </pages> <month> October </month> <year> 1973. </year>
Reference-contexts: Their compiler implements a simple constant folding optimization. Technical Report #83 January 6, 1993 5 London [18] proves by hand the correctness of two versions of a compiler for a subset of Lisp. The second version contains more optimizations than the first. Morris <ref> [24] </ref> uses algebraic semantics to specify and partially prove by hand a simple compiler for an Algol like language. Cohn [11] use Edinburgh LCF to prove the correctness of a simple compiling algorithm. Chirica and Martin [9] use axiomatic semantics to specify and prove a simple compiler.
Reference: [25] <author> Dino P. Oliva and Mitchell Wand. </author> <title> A verified compiler for pure prescheme. </title> <type> Technical Report NU-CCS-92-5, </type> <institution> Northeastern University College of Computer Science, </institution> <year> 1992. </year>
Reference-contexts: In addition Micro Gypsy allows arrays containing elements of one of the simple types. Subsequent to the Piton and Micro-Gypsy effort, Curzon [12] has proved the correctness of an assembly-level language implementation. However the target machine is an idealization of a real machine with infinite memory. Oliva and Wand <ref> [25] </ref> give a denotational specification for a restricted subset of Scheme called PreScheme and derive a compiling algorithm for PreScheme. The output of the compiler is a byte-code for an abstract machine. The byte-code machine is implemented on a MC68020 (this last step has not been verified).
Reference: [26] <author> W. Polak. </author> <title> Compiler Specification and Verification. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: Baker [2] gives an algorithm that allows the garbage collector to run in real-time. He also gives an informal proof of the correctness of the algorithm. There have been three previous large compiler verification efforts. Polak <ref> [26] </ref> verified a compiler for a substantial subset of Pascal. The semantics of his source language and target language were specified using denotational semantics. Polak verified the lexical analyzer, parser, type checker, and code generator. The target machine of his compiler is a stack machine.
Reference: [27] <author> D. M. Russinoff. </author> <title> A mechnically verified incremental garbage collector. </title> <journal> Formal Aspects of Computing, </journal> <note> to appear. Technical Report #83 January 6, 1993 141 </note>
Reference-contexts: The run-time system, which includes dynamic storage allocation, has a mechanically checked proof of correctness. A proof of run-time system that includes a reference count garbage collector is in progress. There have been proofs of garbage collection algorithms in the past (e.g., [13] and <ref> [27] </ref>) but no proofs of actual code that include a garbage collector. 6. This work provides a solid base for a verified implementation of an important subset of Common Lisp. Common Lisp is a relatively widely used "real" programming language. <p> There have been many proofs of garbage collection algorithms. Topor [29] gives a proof of the Schorr-Waite list marking algorithm. Dijkstra et. al. [13] gives a proof of an algorithm that allows the garbage collector and the user's program to run concurrently. Russinoff <ref> [27] </ref> gives a machine checked proof of an improved version of that algorithm. Baker [2] gives an algorithm that allows the garbage collector to run in real-time. He also gives an informal proof of the correctness of the algorithm. There have been three previous large compiler verification efforts.
Reference: [28] <author> Thomas A. Standish. </author> <title> Data Structure Techniques. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1980. </year>
Reference: [29] <author> R. Topor. </author> <title> The correctness of the schorr-waite list marking algorithm. </title> <type> Technical Report MIP-R-104, </type> <institution> University of Edinburgh, </institution> <month> July </month> <year> 1974. </year>
Reference-contexts: The former proof was done mostly by hand, the latter with machine assistance. Levy [17] gives an approach to proving the correctness of compilers by using interpretations between theories. There have been many proofs of garbage collection algorithms. Topor <ref> [29] </ref> gives a proof of the Schorr-Waite list marking algorithm. Dijkstra et. al. [13] gives a proof of an algorithm that allows the garbage collector and the user's program to run concurrently. Russinoff [27] gives a machine checked proof of an improved version of that algorithm.

References-found: 29

