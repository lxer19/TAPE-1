URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tm.outbox/MIT-LCS-TM-546.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/catatm.html
Root-URL: 
Email: fsatyan,sethg@lcs.mit.edu  
Title: A Spatially and Temporally Coherent Object Space Visibility Algorithm  
Author: Satyan Coorg Seth Teller 
Keyword: Conservative visibility, temporal coherence, spatial coherence, octrees, multi-processing.  
Address: Cambridge, MA 02139  
Affiliation: Synthetic Imagery Group MIT Laboratory for Computer Science  
Abstract: In this paper, we present a new approach to the visibility problem that exploits the presence of large occluders near the viewpoint to identify a superset of visible polygons, without touching most invisible polygons. The salient features of this algorithm are: it is conservative, i.e., it overestimates the set of visible polygons; it exploits spatial coherence by using a hierarchical data structure; it exploits temporal coherence by reusing visibility information computed for previous viewpoints; and it is easily parallelizable.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Airey, J. M., Rohlf, J. H., and Brooks, Jr., F. P. </author> <title> Towards Image Realism with Interactive Update Rates in Complex Virtual Building Environments. </title> <booktitle> ACM Siggraph Special Issue on 1990 Symposium on Interactive 3D Graphics 24, 2 (1990), </booktitle> <pages> 41-50. </pages>
Reference-contexts: The challenge, of course, is to produce a usefully tight upper bound on the visible polygons. This idea of "conservative" visibility has been exploited to design fast architectural walkthrough systems <ref> [1, 20, 8] </ref>. The idea in [20] is that the input scene can be divided into cells, roughly corresponding to rooms in a building, and cell-to-cell/eye-to-cell visibility can be used to bound exact visibility from above.
Reference: [2] <author> Akeley, K. </author> <title> RealityEngine Graphics. </title> <booktitle> Computer Graphics (Proc. Siggraph '93) (1993), </booktitle> <pages> 109-116. </pages>
Reference-contexts: 1 Introduction In computer graphics, identifying visible polygons or eliminating hidden polygons is an important component of efficient scene rendering algorithms. Despite the availability of the z-buffer algorithm in hardware <ref> [2] </ref>, the number of polygons in many geometric models is larger than hardware alone can process at interactive frame rates. One way to address this problem is by developing algorithms that efficiently identify, then render, only the visible portions of the model.
Reference: [3] <author> Baumgart, B. G. </author> <title> A Polyhedron Representation for Computer Vision. </title> <booktitle> In Proc. AFIPS Natl. Comput. Conf. (1975), </booktitle> <volume> vol. 44, </volume> <pages> pp. 589-596. </pages>
Reference-contexts: We assume that the number of vertices in each polygon is bounded by some constant. Our system uses a preprocessing step to merge identical input vertices. This is useful in identifying polygons that share edges; the resulting connectivity information is represented by a winged-edge data structure <ref> [3] </ref>. We assume no a priori knowledge of observer motion. In this paper, we distinguish occluder polygons from occludee objects.
Reference: [4] <author> Bentley, J. </author> <title> Multidimensional binary search trees used for associative searching. </title> <booktitle> Communications of the ACM 18 (1975), </booktitle> <pages> 509-517. </pages>
Reference-contexts: We studied the performance of the algorithm on the following models: the fifth floor of Berkeley's Soda Hall building (Soda); a city from Viewpoint DataLabs (City); and a number of tetrahedra on a plane (Tetra). Though we described the algorithm in terms of octrees, the actual implementation used kD-trees <ref> [4] </ref>, a similar hierarchical data structure. The number of occluders to be maintained dynamically is a program input parameter; we set it at 32 to achieve interactive frame rates, and are experimenting with heuristics for choosing it automatically.
Reference: [5] <author> Blumofe, R. D. </author> <title> Scheduling Multithreaded Computations by Work Stealing. </title> <booktitle> In 35th Annual Symposium on Foundations of Computer Science (Santa Fe, </booktitle> <address> New Mexico, 20-22 Nov. 1994), </address> <publisher> IEEE, </publisher> <pages> pp. 356-368. </pages>
Reference-contexts: However, in practice, this partitioning suffers from significant load imbalance, as the work is unevenly partitioned across the processors. To achieve load balancing, we have implemented a version of the work-stealing scheduling algorithm described in <ref> [5] </ref>, which is particularly well suited to independent subtree traversal. Each tree node is packaged into a single unit of work. Processors are assigned a single unit at a time, moving to another after they have completed processing their unit. Unfinished work resides on per-processor queues.
Reference: [6] <author> Chapman, J., Calvert, T. W., and Dill, J. </author> <title> Exploiting Temporal Coherence in Ray Tracing. </title> <booktitle> In Proceedings of Graphics Interface '90 (May 1990), </booktitle> <pages> pp. 196-204. </pages>
Reference-contexts: Ray tracing and ray casting methods resolve visibility in object space by casting a ray through each pixel. That polygon which first intersects the ray is visible at the pixel. Spatial subdivisions have been used to exploit spatial coherence and accelerate ray tracing <ref> [12, 6] </ref>. Algorithms that exploit temporal coherence in this context have also been described [15, 6]. However, a major drawback of these algorithms is that a large number of rays must be cast to generate each image, making them impractical for current interactive display systems. <p> That polygon which first intersects the ray is visible at the pixel. Spatial subdivisions have been used to exploit spatial coherence and accelerate ray tracing [12, 6]. Algorithms that exploit temporal coherence in this context have also been described <ref> [15, 6] </ref>. However, a major drawback of these algorithms is that a large number of rays must be cast to generate each image, making them impractical for current interactive display systems.
Reference: [7] <author> Coorg, S., and Teller, S. </author> <title> Temporally Coherent Conservative Visibility. </title> <booktitle> To appear in Twelfth Annual ACM Symposium on Computational Geometry (1996). </booktitle>
Reference-contexts: A temporally coherent visibility algorithm for scenes comprised only of convex objects is presented in [14]. The algorithm is complex, as it computes exact visibility, and no implementation is described. A dynamic temporally coherent conservative visibility algorithm, described in <ref> [7] </ref>, identifies relevant visibility events, i.e., changes in visibility that will occur in the near future. One drawback of this algorithm is that it must reconstruct visibility information for the continuous sequence of points between each discrete pair of subsequent viewpoints assumed by the moving observer.
Reference: [8] <author> Funkhouser, T., S equin, C., and Teller, S. </author> <title> Management of Large Amounts of Data in Interactive Building Walkthroughs. </title> <booktitle> In Proc. 1992 Workshop on Interactive 3D Graphics (1992), </booktitle> <pages> pp. 11-20. </pages>
Reference-contexts: The challenge, of course, is to produce a usefully tight upper bound on the visible polygons. This idea of "conservative" visibility has been exploited to design fast architectural walkthrough systems <ref> [1, 20, 8] </ref>. The idea in [20] is that the input scene can be divided into cells, roughly corresponding to rooms in a building, and cell-to-cell/eye-to-cell visibility can be used to bound exact visibility from above. <p> The algorithm culls a significant fraction of invisible polygons, even for scenes like City and Tetra, where the cell/portal technique of <ref> [20, 8] </ref> is less effective due to lack of obvious cell structure, and the presence of non-axial polygons.
Reference: [9] <author> Garlick, B., Baum, D. R., and Winget, J. M. </author> <title> Interactive Viewing of Large Geometric Databases Using Multiprocessor Graphics Workstations. Siggraph '90 Course Notes (Parallel Algorithms and Architectures for 3D Image Generation) (1990). </title>
Reference-contexts: Though this method eliminates most invisible polygons in architectural models, its generalization to models with less apparent cell structure seems difficult. An approach using octree-based spatial subdivision is used in <ref> [9] </ref> to render only those polygons that lie within the viewing frustum. However, this algorithm does not exploit occlusion properties of the model, and can end up drawing many invisible polygons. <p> Second, since the algorithm's complexity depends on the number of nodes whose state has changed, it runs faster when fewer visibility changes occur in the scene for example, when the observer moves slowly, or encounters a model region of relatively low visual complexity. Finally, note that frustum culling <ref> [9] </ref> can be incorporated into the algorithm in a straightforward way. The algorithm achieves this by lazily processing octree nodes. Only octree nodes that intersect the viewing frustum are processed.
Reference: [10] <author> Gigus, Z., Canny, J., and Seidel, R. </author> <title> Efficiently Computing and Representing Aspect Graphs of Polyhedral Objects. </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence 13, </journal> <volume> 6 (1991), </volume> <pages> 542-551. </pages>
Reference-contexts: The well-known aspect graph encodes a representation of exact visibility for every qualitatively distinct region of viewpoints <ref> [17, 11, 10] </ref>. One drawback of this approach is that the visible portion of the scene may have higher complexity than the input scene itself a scene with O (n) polygons can have a visible portion with descriptive complexity O (n 2 ).
Reference: [11] <author> Gigus, Z., and Malik, J. </author> <title> Computing the Aspect Graph for Line Drawings of Polyhedral Objects. </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence 12, </journal> <volume> 2 (1990), </volume> <pages> 113-122. </pages>
Reference-contexts: The well-known aspect graph encodes a representation of exact visibility for every qualitatively distinct region of viewpoints <ref> [17, 11, 10] </ref>. One drawback of this approach is that the visible portion of the scene may have higher complexity than the input scene itself a scene with O (n) polygons can have a visible portion with descriptive complexity O (n 2 ).
Reference: [12] <author> Glassner, A. S. </author> <title> Space Subdivision for Fast Ray Tracing. </title> <journal> IEEE Computer Graphics and Applications 4, </journal> <volume> 10 (1984), </volume> <pages> 15-22. </pages>
Reference-contexts: Ray tracing and ray casting methods resolve visibility in object space by casting a ray through each pixel. That polygon which first intersects the ray is visible at the pixel. Spatial subdivisions have been used to exploit spatial coherence and accelerate ray tracing <ref> [12, 6] </ref>. Algorithms that exploit temporal coherence in this context have also been described [15, 6]. However, a major drawback of these algorithms is that a large number of rays must be cast to generate each image, making them impractical for current interactive display systems.
Reference: [13] <author> Greene, N., Kass, M., and Miller, G. </author> <title> Hierarchical Z-Buffer Visibility. </title> <booktitle> In Computer Graphics Proceedings, Annual Conference Series, </booktitle> <year> 1993 (1993), </year> <pages> pp. 231-240. </pages>
Reference-contexts: An approach using octree-based spatial subdivision is used in [9] to render only those polygons that lie within the viewing frustum. However, this algorithm does not exploit occlusion properties of the model, and can end up drawing many invisible polygons. The hierarchical z-buffer algorithm <ref> [13] </ref> makes some use of temporal coherence by maintaining a list of polygons that are visible from the current viewpoint. For the next viewpoint, the algorithm draws polygons from this list first. The contents of the hierarchical z-buffer can then be used to cull invisible 2 polygons.
Reference: [14] <author> Hubschman, H., and Zucker, S. W. </author> <title> Frame to Frame Coherence and the Hidden Surface Computation: Constraints for a Convex World. </title> <journal> ACM Trans. on Graphics (USA) 1 (Apr. </journal> <year> 1982), </year> <pages> 129-162. </pages>
Reference-contexts: Because of its reliance on image space queries, this algorithm is also susceptible to aliasing artifacts. A temporally coherent visibility algorithm for scenes comprised only of convex objects is presented in <ref> [14] </ref>. The algorithm is complex, as it computes exact visibility, and no implementation is described. A dynamic temporally coherent conservative visibility algorithm, described in [7], identifies relevant visibility events, i.e., changes in visibility that will occur in the near future.
Reference: [15] <author> Jevans, D. A. </author> <title> Object space temporal coherence for ray tracing. </title> <booktitle> In Proceedings of Graphics Interface '92 (May 1992), </booktitle> <pages> pp. 176-183. </pages>
Reference-contexts: That polygon which first intersects the ray is visible at the pixel. Spatial subdivisions have been used to exploit spatial coherence and accelerate ray tracing [12, 6]. Algorithms that exploit temporal coherence in this context have also been described <ref> [15, 6] </ref>. However, a major drawback of these algorithms is that a large number of rays must be cast to generate each image, making them impractical for current interactive display systems.
Reference: [16] <author> Maciel, P. W. C., and Shirley, P. </author> <title> Visual Navigation of Large Environments Using Textured Clusters. </title> <booktitle> In 1995 Symposium on Interactive 3D Graphics (Apr. </booktitle> <year> 1995), </year> <editor> P. Hanrahan and J. Winget, Eds., </editor> <booktitle> ACM SIGGRAPH, </booktitle> <pages> pp. 95-102. </pages> <note> ISBN 0-89791-736-7. </note>
Reference-contexts: However, for many models our algorithm will combine well with techniques that visually approximate remote polygons (e.g. by substituting textures <ref> [16] </ref>). An interesting observation is that the algorithm Visible performs better in terms of both culling efficacy and efficiency when it uses the (more complex) connected occluder visibility test. This is due 13 the same viewpoints as in the previous figure.
Reference: [17] <author> Plantinga, W., and Dyer, C. </author> <title> Visibility, Occlusion, and the Aspect Graph. </title> <booktitle> Int. J. Computer Vision 5, 2 (1990), </booktitle> <pages> 137-160. </pages>
Reference-contexts: The well-known aspect graph encodes a representation of exact visibility for every qualitatively distinct region of viewpoints <ref> [17, 11, 10] </ref>. One drawback of this approach is that the visible portion of the scene may have higher complexity than the input scene itself a scene with O (n) polygons can have a visible portion with descriptive complexity O (n 2 ).
Reference: [18] <author> Preparata, F. P., and Shamos, M. I. </author> <title> Computational Geometry: an Introduction. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Our methods use the notion of supporting and separating planes. Separating planes of two convex polyhedra are planes formed by an edge of one polyhedron and a vertex of the other such that the polyhedra lie on opposite sides of the plane <ref> [18] </ref>. Supporting planes are analogous, except that both polyhedra lie on the same side of the plane. shows the simplest case, when the occlusion is caused by a single occluder.
Reference: [19] <author> Samet, H. </author> <title> Applications of Spatial Data Structures: Computer Graphics, Image Processing, and GIS. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: We first turn to the problem of identifying those polygons visible from a specified viewpoint in the presence of a set of occluders. Our approach organizes all polygons in an octree <ref> [19] </ref>.
Reference: [20] <author> Teller, S., and S equin, C. H. </author> <title> Visibility Preprocessing for Interactive Walkthroughs. </title> <journal> Computer Graphics (Proc. </journal> <volume> Siggraph '91) 25, 4 (1991), </volume> <pages> 61-69. 18 </pages>
Reference-contexts: The challenge, of course, is to produce a usefully tight upper bound on the visible polygons. This idea of "conservative" visibility has been exploited to design fast architectural walkthrough systems <ref> [1, 20, 8] </ref>. The idea in [20] is that the input scene can be divided into cells, roughly corresponding to rooms in a building, and cell-to-cell/eye-to-cell visibility can be used to bound exact visibility from above. <p> The challenge, of course, is to produce a usefully tight upper bound on the visible polygons. This idea of "conservative" visibility has been exploited to design fast architectural walkthrough systems [1, 20, 8]. The idea in <ref> [20] </ref> is that the input scene can be divided into cells, roughly corresponding to rooms in a building, and cell-to-cell/eye-to-cell visibility can be used to bound exact visibility from above. <p> The algorithm culls a significant fraction of invisible polygons, even for scenes like City and Tetra, where the cell/portal technique of <ref> [20, 8] </ref> is less effective due to lack of obvious cell structure, and the presence of non-axial polygons.
References-found: 20

