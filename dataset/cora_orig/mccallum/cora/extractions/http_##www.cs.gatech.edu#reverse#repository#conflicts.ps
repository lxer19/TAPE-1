URL: http://www.cs.gatech.edu/reverse/repository/conflicts.ps
Refering-URL: http://www.cs.gatech.edu/reverse/repos.html
Root-URL: 
Title: Reverse Engineering: Resolving Conflicts between Expected and Actual Software Designs  
Author: Stephen B. Ornburn and Spencer Rugaber 
Address: Atlanta, GA 30332-0280  
Affiliation: College of Computing and Software Research Center Georgia Institute of Technology  
Abstract: A real-time embedded system was the subject of a series of experiments in reverse engineering. These experiments employed a method of reverse engineering, called Synchronized Refinement, that analyzes a program, describing its behavior in the vocabulary of the application domain and its structure in terms of design decisions. The results provide insight into the role of domain knowledge in this type of analysis together with the tools used in the detailed analysis of code. The experiments, which included the re-design of a component and the diagnosis of a critical software failure, showed how the real work of software maintenance is in resolving apparent inconsistencies between the expectations that have been derived from domain knowledge and the facts that have been uncovered by applying reverse engineering tools to the software. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ruven Brooks, </author> <title> "Towards a Theory of the Comprehension of Computer Programs," </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> vol. 18, </volume> <pages> pp. 543-554, </pages> <year> 1983. </year>
Reference-contexts: This backtracking can relate both to the design decisions "undone" as part of the code analysis or to the ones "executed" to derive the expected design. The top-down aspects of this process are similar to the psychological model of code comprehension described by Ruven Brooks <ref> [1] </ref>. While it is important that the reverse engineering process and tools be compatible with the underlying psychological process, considerable elaboration and refinement of the model is required if it is to be tool supported.
Reference: [2] <author> Elliot J. Chikofsky and James H. </author> <title> Cross, II, "Reverse Engineering and Design Recovery: A Taxonomy," </title> <journal> IEEE Software, </journal> <volume> vol. 7, no. 1, </volume> <pages> pp. 13-17, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: For example, synchronization mechanisms can be used to carefully control the order in which tasks execute, thereby compensating for a designer's careless functional decomposition of the original problem. 2.1 Expected vs. actual designs Chikofsky and Cross <ref> [2] </ref> define reverse engineering as "the process of analyzing a subject system to identify the system's components and their interrelationships and create representations of the system in another form or at a higher level of abstraction." Typically, this means constructing a re-engineered architectural design of a system from its source code.
Reference: [3] <author> Philip A. Hausler, Mark G. Pleszkoch, Richard C. Linger, and Alan R. Hevner, </author> <title> "Using Function Abstraction to Understand Program Behavior," </title> <journal> IEEE Software, </journal> <volume> vol. 7, no. 1, </volume> <pages> pp. 55-63, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The analysis of program text, as driven by design decisions, is new. Previous experiments contributing towards the development of this approach have been reported in [4] and [7]. Procedures based on control flow analysis and program slicing are described in a paper by Hausler <ref> [3] </ref>. 2.2 An embedded software system Synchronized Refinement was applied in experiments performed on several software components within a large, real-time software system built and maintained by a major telecommunications company.
Reference: [4] <author> Kit Kamper and Spencer Rugaber, </author> <title> "A Reverse Engineering Methodology for Data Processing Applications," </title> <institution> GIT-SERC-90/02, Software Engineering Research Center, Georgia Institute of Technology, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Synchronized Refinement <ref> [4, 7] </ref>, a method for reverse engineering, is a process by which a re-engineered design is constructed from an existing software system. Synchronized Refinement consists of two parallel activities: the synthesis of functional and nonfunctional behavioral descriptions and the code-level analysis of the program text. <p> The analysis of program text, as driven by design decisions, is new. Previous experiments contributing towards the development of this approach have been reported in <ref> [4] </ref> and [7]. Procedures based on control flow analysis and program slicing are described in a paper by Hausler [3]. 2.2 An embedded software system Synchronized Refinement was applied in experiments performed on several software components within a large, real-time software system built and maintained by a major telecommunications company.
Reference: [5] <author> James M. Neighbors, </author> <title> "Draco: A Method for Engineering Reusable Software Components," Software Reusability: Concepts and Models, </title> <editor> ed. Ted J. Big-gerstaff and Alan J. Perlis, </editor> <volume> vol. 1, </volume> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: We represented the design using pseudocode and, in doing so, availed ourselves of a wide range of language constructs. The enriched vocabulary we used allowed us to clarify relationships between the structure and behavior of the software, and we used context-specific translation rules <ref> [5, 9, 10] </ref> to represent design decisions linking the pseudocode to the implementation. For example, we used this technique to introduce exception handlers at the pseudo-code level. We also used this technique to abstract away the many resource-specific details associated with requesting and releasing resources.
Reference: [6] <author> James L. Peterson and Abraham Silberschatz, </author> <title> Operating Systems Concepts, second edition, </title> <publisher> Addison Wesley, </publisher> <year> 1985. </year>
Reference-contexts: This allowed us to recognize the potential for deadlock, and we then considered how deadlock was prevented. While there were no obvious landmarks in the code, we guessed that the software used a version of the deny-hold-and-wait strategy <ref> [6] </ref>, i.e., if a resource could not be obtained, all resources acquired so far were released and the test was abandoned. From this we were able to produce an improved design showing how a deny-hold-and-wait strategy could be implemented using exception handlers.
Reference: [7] <author> Spencer Rugaber, Stephen B. Ornburn, and Richard J. LeBlanc, Jr., </author> <title> "Recognizing Design Decisions in Programs," </title> <journal> IEEE Software, </journal> <volume> vol. 7, no. 1, </volume> <pages> pp. 46-54, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Synchronized Refinement <ref> [4, 7] </ref>, a method for reverse engineering, is a process by which a re-engineered design is constructed from an existing software system. Synchronized Refinement consists of two parallel activities: the synthesis of functional and nonfunctional behavioral descriptions and the code-level analysis of the program text. <p> The analysis of program text, as driven by design decisions, is new. Previous experiments contributing towards the development of this approach have been reported in [4] and <ref> [7] </ref>. Procedures based on control flow analysis and program slicing are described in a paper by Hausler [3]. 2.2 An embedded software system Synchronized Refinement was applied in experiments performed on several software components within a large, real-time software system built and maintained by a major telecommunications company. <p> The following is a short summary of how we attempted to recognize and undo low-level design decisions. A more detailed description of this aspect of Synchronized Refinement is given in <ref> [7] </ref>. Even if the program does not enhance its own run-time environment, it may simulate advanced programming language features in selected contexts. Thus, we specificly look for advanced language features which have been simulated by combinations of more primitive constructs, i.e., application-level simulations of program control mechanisms.
Reference: [8] <author> W. P. Stevens, G. J. Myers, and L. L. Constantine, </author> <title> "Structured Design," </title> <journal> IBM Systems Journal, </journal> <volume> vol. 13, no. 2, </volume> <pages> pp. 115-139, </pages> <year> 1974. </year>
Reference-contexts: Procedures use this same mechanism to inform their invokers of exceptions, and, to conserve stack space, procedures frequently communicate with their invokers by referencing global variables. Context switches occur when tasks explicitly give 1 This term and related phrases used below are part of Structured Design <ref> [8] </ref>. up control; there is no round-robin scheduling. Syn--chronization, when necessary, is by means of globally-accessible flags.
Reference: [9] <author> David S. Wile, </author> <title> "Program Developments: Formal Explanations of Implementations," </title> <journal> Communications of the ACM, </journal> <volume> vol. 26, no. 11, </volume> <pages> pp. 902-910, </pages> <month> November </month> <year> 1983. </year>
Reference-contexts: We represented the design using pseudocode and, in doing so, availed ourselves of a wide range of language constructs. The enriched vocabulary we used allowed us to clarify relationships between the structure and behavior of the software, and we used context-specific translation rules <ref> [5, 9, 10] </ref> to represent design decisions linking the pseudocode to the implementation. For example, we used this technique to introduce exception handlers at the pseudo-code level. We also used this technique to abstract away the many resource-specific details associated with requesting and releasing resources.
Reference: [10] <author> D. S. Wile, </author> <title> "Local Formalisms: Widening the Spectrum of Wide-Spectrum Languages," Program Specification and Transformation, </title> <editor> L. G. L. T. Meertens, </editor> <publisher> Elsevier North Holland, </publisher> <pages> pp. 165-195, </pages> <year> 1987. </year>
Reference-contexts: We represented the design using pseudocode and, in doing so, availed ourselves of a wide range of language constructs. The enriched vocabulary we used allowed us to clarify relationships between the structure and behavior of the software, and we used context-specific translation rules <ref> [5, 9, 10] </ref> to represent design decisions linking the pseudocode to the implementation. For example, we used this technique to introduce exception handlers at the pseudo-code level. We also used this technique to abstract away the many resource-specific details associated with requesting and releasing resources.
References-found: 10

