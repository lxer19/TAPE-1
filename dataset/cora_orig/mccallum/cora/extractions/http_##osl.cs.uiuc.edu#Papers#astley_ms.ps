URL: http://osl.cs.uiuc.edu/Papers/astley_ms.ps
Refering-URL: http://osl.cs.uiuc.edu/Papers/Vis.html
Root-URL: http://www.cs.uiuc.edu
Note: c flCopyright by Mark Christopher Astley, 1996  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: In Chapter 3 we describe the specification language portion of stagehand for defining visualization. Chapter 4 describes the implementation of stagehand. We conclude in Chapter 5. 1.2 Actors Our goal is to visualize encapsulated, possibly distributed, objects which interact via message passing. Actors <ref> [1] </ref> provide a general and flexible model of concurrency which captures all such systems, thus we base our visualization mechanisms on actor-based computation. Actors are encapsulated, interactive, autonomous components of a computing system that communicate by asynchronous message passing.
Reference: [2] <author> G. Agha, S. Frolund, W. Kim, R. Panwar, A. Patterson, and D. Sturman. </author> <title> Abstraction and modularity mechanisms for concurrent computing. </title> <booktitle> IEEE Parallel and Distributed Technology, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Internal concurrency may be mimicked by creating a new actor to asynchronously process the remainder of the current computation while the original actor begins processing a new message. Actors provide a model of concurrent computation upon which a wide variety of concurrent abstractions can be developed <ref> [2] </ref>. Hence, the visualization mechanisms described in this thesis readily extend to computational models supporting synchronous communication, remote procedure call, migrating processes, and so on. More importantly, actors provide a uniform view of concurrency: every object, including system-level objects, are actors.
Reference: [3] <author> G. Agha, I. Mason, S. Smith, and C. Talcott. </author> <title> Towards a theory of actor computation. </title> <booktitle> In The Third International Conference on Concurrency Theory (CONCUR '92), </booktitle> <pages> pages 565-579, </pages> <address> Stony Brook, NY, </address> <month> August </month> <year> 1992. </year> <title> Springer Verlag. </title> <booktitle> Lecture Notes in Computer Science No. </booktitle> <pages> 630. </pages>
Reference-contexts: Visualization Action: A visualization action corresponds to some rendering or animation activity which updates the current display of an algorithm. Typically, a visualization action is parameterized by the visualization event which invokes it. 1 Formally, actor events are only receive events <ref> [3] </ref>. However, for the sake of clarity we abuse terminology here. 14 Visualization Mechanism: The visualization mechanism specifies the relationship between visualization events and visualization actions.
Reference: [4] <author> G. Agha and D. C. Sturman. </author> <title> A methodology for adapting to patterns of faults. </title> <editor> In G. M. Koob and C. G. Lau, editors, </editor> <title> Foundations of Dependable Computing: Models and Frameworks for Dependable Systems, chapter 1.2. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference-contexts: In particular, broadway provides support for distributed actor programs including asynchronous communication, dynamic actor creation, and scheduling of actors. Basic actor functionality is augmented with support for migration, exception handling <ref> [4] </ref>, synchronization constraints [13], and modular specification of interaction policies [34]. The platform currently runs on Ultrix for DEC MIPS workstations, on Solaris for SUN Sparcstations, and IRIX 5 for SGI workstations. Broadway supports basic actor functionality using a multi-thread scheduler, distributed name service, and platform independent communication service.
Reference: [5] <author> G. A. Agha, I. Mason, S. Smith, and C. Talcott. </author> <title> A foundation for actor computation. </title> <journal> Journal of Functional Programming, </journal> <note> 1996. (to be published). </note>
Reference-contexts: Actor names are first class entities which specify the mail address of an actor and may be communicated within messages 1 Those familiar with the Actor model may notice that become is missing. In recent work <ref> [5] </ref>, become has been replaced by a continuation passing style transform and the specification of a replacement behavior. We assume a similar convention in this thesis. 7 allowing dynamic reconfiguration of the communication topology. The create primitive creates a new actor with a specified behavior. <p> Visualizer for primary backup interactions. 68 visualizer TwoPhaseCommit f begin var VO *view; cubeVO parts <ref> [5] </ref>; coneVO funnel; int cur part; end var begin init // Find the view, init primitives view = FindObjectWithProp ("theView"); for (i=0; i&lt;5; i++) f parts [i].SurfColor color (blue); parts [i].Transform translate (100, (2-i)*50, 0); g funnel.ConeHeight setValue (70.0); funnel.ConeRadius setValue (100.0); end init begin enter // Create rep. for participant
Reference: [6] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Moreover, conventional sequential tools do not readily extend to distributed systems. As a simple example of how complexity in distributed algorithms establishes the need for special analysis tools, consider a distributed protocol such as two-phase commit. Two-phase commit may be expressed algorithmically as follows <ref> [6] </ref> (see Figure 1.1): 1. A coordinator sends the message vote to each component participating in the protocol. 2. Upon receiving vote, each component sends either the message commit or abort to the coordinator. 1 All participants execute the same action. 3.
Reference: [7] <author> K. P. Birman. </author> <title> The process group approach to reliable distributed computing. </title> <journal> Communications of the ACM, </journal> <volume> 36(12) </volume> <pages> 37-53, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: From the perspective of reasoning about programs, this is an undesirable feature since it is not clear how the visualization characterizes the underlying execution. The causal relationships between interacting components in a distributed system are a critical feature for reasoning about distributed interactions <ref> [28, 7] </ref>. In particular, causal relationships indicate a chain of interactions which corresponds to the progress 16 of a distributed algorithm. To capture this feature in the resulting visualization, we require a visualization mechanism which ensures that visualization actions characterize the causality of the underlying execution. <p> A straightforward mechanism for implementing causal delivery is to use vector clocks [23]. Vector clocks are a well known mechanism for implementing causal delivery and several implementation techniques have been suggested in the literature <ref> [28, 33, 7, 24] </ref>. The algorithm we describe here is similar to that described in [23]. In a vector clock protocol, each participant maintains a local Lamport clock [17] as well as a Lamport clock for each participant it has received a message from.
Reference: [8] <author> D. Bowman, A. Ferrari, M. Kelley, B. Schmidt, B. Topol, and V. Sunderam. </author> <title> The conch network concurrent programming system. </title> <type> Technical report, </type> <institution> Emory University, </institution> <address> Atlanta, GA, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Turner and Cai have described a visualization mechanism based on the logical clock traces of interacting processes [38]. Similarly, the PVM [35] distributed computing environment has been extended with PVaniM [36] to support timestamp based visualization. The Conch <ref> [8] </ref> system has been extended in a similar fashion in [37]. All of these environments are based on post-mortem visualization. That is, events are recorded in a log during execution and visualized after the fact.
Reference: [9] <author> M. H. Brown. </author> <title> Exploring algorithms using balsa-ii. </title> <booktitle> IEEE Computer, </booktitle> <month> May </month> <year> 1988. </year>
Reference-contexts: Program visualization, the animated display of various aspects of algorithm execution, has been utilized in an attempt to provide appropriate analysis tools [27, 32]. In particular, program visualization has been applied to such diverse applications as computer science instruction <ref> [9] </ref>, visual debugging [21], program verification and reasoning [27], and educational software [16]. Typical visual environments use pictorial abstractions to represent program components and their interactions, showing the various stages of a program in execution. Note that a visual-based analysis tool provides a multi-component context. <p> Although we are concerned with visualizing parallel and distributed programs, it is still useful to contrast and compare with these sequential systems in order to reveal differences in expressiveness and specification techniques. Representative sequential environments include BALSA <ref> [9] </ref> and its descendent ZEUS [10], and TANGO [31]. Technically, these environments are not restricted to visualizing sequential programs. However, none of the named systems includes explicit mechanisms for dealing with concurrency.
Reference: [10] <author> M. H. Brown. Zeus: </author> <title> A system for algorithm animation and multiview editing. </title> <booktitle> In Proceedings of the IEEE Workshop on Visual Languages, </booktitle> <pages> pages 4-9, </pages> <year> 1991. </year>
Reference-contexts: Although we are concerned with visualizing parallel and distributed programs, it is still useful to contrast and compare with these sequential systems in order to reveal differences in expressiveness and specification techniques. Representative sequential environments include BALSA [9] and its descendent ZEUS <ref> [10] </ref>, and TANGO [31]. Technically, these environments are not restricted to visualizing sequential programs. However, none of the named systems includes explicit mechanisms for dealing with concurrency.
Reference: [11] <author> N. Carriero and D. Gelernter. </author> <title> How to write parallel programs: A guide to the perplexed. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 323-357, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: The concurrent visualization environments we have described above all employ a rather traditional view of process-based concurrent computation. The PAVANE [26] system represents a coherent approach to visualizing concurrent program execution based on a tuple-space environment similar to Linda <ref> [11] </ref>. Moreover, PAVANE has been designed explicitly to aid programmers in reasoning about program execution. In PAVANE, a configuration of tuple-space represents the current state of an algorithm in execution.
Reference: [12] <author> J. D. Foley, A. van Dam, S. K. Feiner, and J. F. Hughes. </author> <title> Computer Graphics: </title> <booktitle> Principles and Practice. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Thus, linguistic constructs are necessary which support both a wide range of modeling attributes as well as mechanisms for arbitrating shared manipulation of models among visualizers. In stagehand, visualization actions manipulate objects in a hierarchical modeling environment <ref> [12] </ref>. Models are rendered in 3D with lighting and animation which may be specified within visualization actions. Visualization actions are specified as blocks of C++ code which are parameterized by identifiers in the triggering event.
Reference: [13] <author> S. Frolund. </author> <title> Inheritance of synchronization constraints in concurrent object-oriented programming languages. </title> <booktitle> In Proceedings of ECOOP 1992. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year> <note> LNCS 615. 70 </note>
Reference-contexts: In particular, broadway provides support for distributed actor programs including asynchronous communication, dynamic actor creation, and scheduling of actors. Basic actor functionality is augmented with support for migration, exception handling [4], synchronization constraints <ref> [13] </ref>, and modular specification of interaction policies [34]. The platform currently runs on Ultrix for DEC MIPS workstations, on Solaris for SUN Sparcstations, and IRIX 5 for SGI workstations. Broadway supports basic actor functionality using a multi-thread scheduler, distributed name service, and platform independent communication service.
Reference: [14] <author> D. Hearn and M. P. Baker. </author> <title> Computer Graphics. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <note> second edition, </note> <year> 1994. </year>
Reference-contexts: The organization of objects into scene hierarchies allows for a natural approach to scene modeling where objects are manipulated by local modeling transformations. In addition, scene hierarchies are easy to transform into displays. In particular, a scene hierarchy is rendered by way of a traversal <ref> [14] </ref>.
Reference: [15] <author> M. T. Heath and J. A. Etheridge. </author> <title> Visualizing the performance of parallel programs. </title> <journal> IEEE Software, </journal> <month> September </month> <year> 1991. </year>
Reference-contexts: The ParaGraph <ref> [15] </ref> and Pablo [25] systems are representative of this work. These approaches tend to emphasize largely application independent performance issues. In this thesis we focus our attention on application-specific program visualization. That is, we are primarily concerned with user-definable abstraction 9 mechanisms which aid in the comprehension of concurrent algorithms.
Reference: [16] <author> K. Kahn. </author> <title> Toontalk T M an animated programming environment for children. </title> <booktitle> In Proceedings of the National Educational Computing Conference (NECC'95), </booktitle> <year> 1995. </year>
Reference-contexts: In particular, program visualization has been applied to such diverse applications as computer science instruction [9], visual debugging [21], program verification and reasoning [27], and educational software <ref> [16] </ref>. Typical visual environments use pictorial abstractions to represent program components and their interactions, showing the various stages of a program in execution. Note that a visual-based analysis tool provides a multi-component context. Moreover, extending such systems with an appropriate specification language allows analysis which filters specific interactions.
Reference: [17] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: We call such a visualization model an event-based approach. By considering patterns of local events, an event-based approach emphasizes coordination patterns and hence captures the salient behavior of distributed systems. Due to asynchrony and distributed state, only a partial order of events is available in a distributed system <ref> [17] </ref>. Thus in order for event-based visualization to be meaningful, some form of consistency must be enforced between the ordering of events and the visualization they trigger. In particular, correctly characterizing the causal relationships of the underlying execution is critical to providing a tool for reasoning about distributed execution [28]. <p> In particular, reasoning about coordination behavior requires preserving the causal relationships among interacting components. Causal order can be determined succinctly in terms of the partial order of events in a distributed system <ref> [17] </ref>. Thus, our environment guarantees consistency by requiring that visualization observe the same partial order of events as that of the algorithm execution. Moreover, visualizing coordination behavior requires flexibility in specifying both the events which trigger visualization as well as the set of components to be visualized. <p> Vector clocks are a well known mechanism for implementing causal delivery and several implementation techniques have been suggested in the literature [28, 33, 7, 24]. The algorithm we describe here is similar to that described in [23]. In a vector clock protocol, each participant maintains a local Lamport clock <ref> [17] </ref> as well as a Lamport clock for each participant it has received a message from. One participant is designated the observer and will use this vector of clock information from other participants to causally receive messages.
Reference: [18] <author> P. Maes. </author> <title> Computational reflection. </title> <type> Technical Report 87-2, </type> <institution> Artificial Intelligence Laboratory, Vrije University, </institution> <year> 1987. </year>
Reference-contexts: We also assume that all actors initially start in the ready state. 8 1.3 Reflection Reflection refers to the ability of an object to manipulate a causally connected description of itself <ref> [18, 29] </ref>. Causal connection implies that changes to the description have an immediate effect on the described object. The reflective capabilities of a language are referred to as the meta-architecture of the language and are embodied by meta-objects which customize specific attributes of their base-object.
Reference: [19] <author> C. R. Manning. Traveler: </author> <title> the actor observatory. </title> <booktitle> In Proceedings of European Conference on Object-Oriented Programming, </booktitle> <month> January </month> <year> 1987. </year> <note> Also appeared in LNCS (276). </note>
Reference-contexts: From a somewhat different tradition than program visualization, event diagrams have been a prevalent mechanism for visualizing actor computation. Augmented Event Diagrams were used 12 by Manning in the Traveler observatory to support the debugging of actor programs <ref> [19] </ref>. In a related fashion, predicate transition nets have been used to visualize actor computation [20]. However, both approaches suffer from two key weaknesses: there are no coordination abstraction mechanisms; and, representations rather than models are generated.
Reference: [20] <author> S. Miriyala, G. Agha, and Y. Sami. </author> <title> Visualizing actor programs using predicate transition nets. </title> <journal> Journal of Visual Languages and Computation, </journal> <volume> 3(2) </volume> <pages> 195-220, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Augmented Event Diagrams were used 12 by Manning in the Traveler observatory to support the debugging of actor programs [19]. In a related fashion, predicate transition nets have been used to visualize actor computation <ref> [20] </ref>. However, both approaches suffer from two key weaknesses: there are no coordination abstraction mechanisms; and, representations rather than models are generated. Event diagrams do not abstract over low-level execution details and tend to be unnecessarily complex.
Reference: [21] <author> S. Mukherjea and J. T. Stasko. </author> <title> Toward visual debugging: Integrating algorithm animation capabilities within a source level debugger. </title> <journal> ACM Transactions on Computer-Human Interaction, </journal> <year> 1993. </year>
Reference-contexts: Program visualization, the animated display of various aspects of algorithm execution, has been utilized in an attempt to provide appropriate analysis tools [27, 32]. In particular, program visualization has been applied to such diverse applications as computer science instruction [9], visual debugging <ref> [21] </ref>, program verification and reasoning [27], and educational software [16]. Typical visual environments use pictorial abstractions to represent program components and their interactions, showing the various stages of a program in execution. Note that a visual-based analysis tool provides a multi-component context.
Reference: [22] <author> J. K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1994. </year> <note> ISBN 0-201-63337-X. </note>
Reference-contexts: Models are created and rendered using the library independent interface where control is passed to the library specific routines when rendering is required. Using this approach, a general purpose front-end, and back-ends for the Tcl/Tk <ref> [22] </ref> and GL graphics libraries have been implemented. 60 Appendix C Examples In this chapter, we provide two fully coded examples of the use of stagehand for specifying visualization.
Reference: [23] <author> Ozalp Babaoglu and K. Marzullo. </author> <title> Consistent global states of distributed systems: Fundamental concepts and mechanisms. </title> <editor> In S. Mullender, editor, </editor> <booktitle> Distributed Systems, chapter 4, </booktitle> <pages> pages 55-96. </pages> <publisher> ACM Press, </publisher> <address> New York, NY, </address> <year> 1994. </year>
Reference-contexts: Thus, when used to visualize concurrent execution, the state--transition approach requires a global snapshot of algorithm state. Unfortunately, in distributed environments global snapshots are costly due to distributed state and asynchrony, and may not correspond to any state entered by the underlying execution <ref> [23] </ref>. Moreover, semantically equivalent execution behavior may yield different state transitions. As a result, the state-transition approach is costly to implement and does not effectively abstract over the relevant behavior in distributed systems. <p> Note that under the casual connection restriction, the resulting visualization always corresponds to a consistent cut <ref> [23] </ref> of the triggering events in the underlying execution. visualization events. diagram displays a total order of actor events for three actors A, B and C. <p> This requires a mechanism for tagging messages with causal information so that the mail queue can be ordered appropriately. A straightforward mechanism for implementing causal delivery is to use vector clocks <ref> [23] </ref>. Vector clocks are a well known mechanism for implementing causal delivery and several implementation techniques have been suggested in the literature [28, 33, 7, 24]. The algorithm we describe here is similar to that described in [23]. <p> A straightforward mechanism for implementing causal delivery is to use vector clocks <ref> [23] </ref>. Vector clocks are a well known mechanism for implementing causal delivery and several implementation techniques have been suggested in the literature [28, 33, 7, 24]. The algorithm we describe here is similar to that described in [23]. In a vector clock protocol, each participant maintains a local Lamport clock [17] as well as a Lamport clock for each participant it has received a message from. One participant is designated the observer and will use this vector of clock information from other participants to causally receive messages.
Reference: [24] <author> M. Raynal, A. Schiper, and S. Toueg. </author> <title> The causal ordering abstraction and a simple way to implement it. </title> <journal> Information Processing Letters, </journal> <volume> 39(6) </volume> <pages> 343-350, </pages> <year> 1991. </year>
Reference-contexts: A straightforward mechanism for implementing causal delivery is to use vector clocks [23]. Vector clocks are a well known mechanism for implementing causal delivery and several implementation techniques have been suggested in the literature <ref> [28, 33, 7, 24] </ref>. The algorithm we describe here is similar to that described in [23]. In a vector clock protocol, each participant maintains a local Lamport clock [17] as well as a Lamport clock for each participant it has received a message from.
Reference: [25] <author> D. A. Reed, R. A. Aydt, T. M. Madhyastha, R. J. Noe, and K. A. Shields. </author> <title> An overview of the pablo performance analysis environment. </title> <type> Technical report, </type> <institution> University of Illinois, Urbana, IL, </institution> <year> 1992. </year>
Reference-contexts: The ParaGraph [15] and Pablo <ref> [25] </ref> systems are representative of this work. These approaches tend to emphasize largely application independent performance issues. In this thesis we focus our attention on application-specific program visualization. That is, we are primarily concerned with user-definable abstraction 9 mechanisms which aid in the comprehension of concurrent algorithms.
Reference: [26] <author> G.-C. Roman and K. C. Cox. </author> <title> A taxonomy of program visualization systems. </title> <booktitle> IEEE Computer, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: That is, visualization may provide abstraction mechanisms which capture high-level behavior whereas typical analysis tools, such as trace-based systems, tend to be biased to representing low-level execution details. Current visualization environments adopt the view that program visualization represents a mapping from computational state to visual representation <ref> [26] </ref>. Constructing this map involves the following three tasks: first, identifying interesting program states; second, defining visual representations corresponding to these states; and finally, defining a mapping mechanism which links program state to visual representation. We call this the state-transition approach. <p> Furthermore, by utilizing a reflective architecture, stagehand constructs are transparently integrated with applications, obviating the need for code annotation. The concurrent visualization environments we have described above all employ a rather traditional view of process-based concurrent computation. The PAVANE <ref> [26] </ref> system represents a coherent approach to visualizing concurrent program execution based on a tuple-space environment similar to Linda [11]. Moreover, PAVANE has been designed explicitly to aid programmers in reasoning about program execution. In PAVANE, a configuration of tuple-space represents the current state of an algorithm in execution.
Reference: [27] <author> G.-C. Roman, K. C. Cox, C. D. Wilcox, and J. Y. Plun. Pavane: </author> <title> A system for declarative visualization of concurrent computations. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 3(2) </volume> <pages> 161-193, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Abstraction mechanisms must therefore exist for varying granularity and filtering interactions. Program visualization, the animated display of various aspects of algorithm execution, has been utilized in an attempt to provide appropriate analysis tools <ref> [27, 32] </ref>. In particular, program visualization has been applied to such diverse applications as computer science instruction [9], visual debugging [21], program verification and reasoning [27], and educational software [16]. <p> Program visualization, the animated display of various aspects of algorithm execution, has been utilized in an attempt to provide appropriate analysis tools [27, 32]. In particular, program visualization has been applied to such diverse applications as computer science instruction [9], visual debugging [21], program verification and reasoning <ref> [27] </ref>, and educational software [16]. Typical visual environments use pictorial abstractions to represent program components and their interactions, showing the various stages of a program in execution. Note that a visual-based analysis tool provides a multi-component context.
Reference: [28] <author> R. Schwarz and F. Mattern. </author> <title> Detecting causal relationships in distributed computations: In search of the holy grail. </title> <journal> Distributed Computing, </journal> <volume> 7 </volume> <pages> 149-174, </pages> <year> 1994. </year>
Reference-contexts: Thus in order for event-based visualization to be meaningful, some form of consistency must be enforced between the ordering of events and the visualization they trigger. In particular, correctly characterizing the causal relationships of the underlying execution is critical to providing a tool for reasoning about distributed execution <ref> [28] </ref>. In this thesis we develop an event-based environment for specifying and implementing visualization of distributed object-based systems. In our environment, visualization is synchronized with causally ordered coordination patterns among objects. <p> From the perspective of reasoning about programs, this is an undesirable feature since it is not clear how the visualization characterizes the underlying execution. The causal relationships between interacting components in a distributed system are a critical feature for reasoning about distributed interactions <ref> [28, 7] </ref>. In particular, causal relationships indicate a chain of interactions which corresponds to the progress 16 of a distributed algorithm. To capture this feature in the resulting visualization, we require a visualization mechanism which ensures that visualization actions characterize the causality of the underlying execution. <p> A straightforward mechanism for implementing causal delivery is to use vector clocks [23]. Vector clocks are a well known mechanism for implementing causal delivery and several implementation techniques have been suggested in the literature <ref> [28, 33, 7, 24] </ref>. The algorithm we describe here is similar to that described in [23]. In a vector clock protocol, each participant maintains a local Lamport clock [17] as well as a Lamport clock for each participant it has received a message from.
Reference: [29] <author> B. C. Smith. </author> <title> Reflection and semantics in a procedural language. </title> <type> Technical Report 272, </type> <institution> Massachusetts Institute of Technology. Laboratory for Computer Science, </institution> <year> 1982. </year> <month> 71 </month>
Reference-contexts: We also assume that all actors initially start in the ready state. 8 1.3 Reflection Reflection refers to the ability of an object to manipulate a causally connected description of itself <ref> [18, 29] </ref>. Causal connection implies that changes to the description have an immediate effect on the described object. The reflective capabilities of a language are referred to as the meta-architecture of the language and are embodied by meta-objects which customize specific attributes of their base-object.
Reference: [30] <author> J. T. Stasko. </author> <title> The path-transition paradigm: A practical methodology for adding anima-tion to program interfaces. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 1(3) </volume> <pages> 213-236, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: BALSA and ZEUS provide perhaps the most complete mechanisms in terms of specifying arbitrary visual layouts. TANGO, on the other hand, contributes a natural and flexible animation facility using the notion of path transitions <ref> [30] </ref>. The emphasis of this thesis is on specification techniques rather than modeling and rendering visualization. Hence stagehand contains a rather basic set of primitives for generating images. Nonetheless, any complete visualization system should include a comprehensive modeling and rendering environment.
Reference: [31] <author> J. T. Stasko. </author> <title> Tango: A framework and system for algorithm animation. </title> <journal> Computer, </journal> <volume> 23(9) </volume> <pages> 27-39, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Although we are concerned with visualizing parallel and distributed programs, it is still useful to contrast and compare with these sequential systems in order to reveal differences in expressiveness and specification techniques. Representative sequential environments include BALSA [9] and its descendent ZEUS [10], and TANGO <ref> [31] </ref>. Technically, these environments are not restricted to visualizing sequential programs. However, none of the named systems includes explicit mechanisms for dealing with concurrency.
Reference: [32] <author> J. T. Stasko and E. Kraemer. </author> <title> A methodology for building application-specific visualizations of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18 </volume> <pages> 258-264, </pages> <year> 1993. </year>
Reference-contexts: Abstraction mechanisms must therefore exist for varying granularity and filtering interactions. Program visualization, the animated display of various aspects of algorithm execution, has been utilized in an attempt to provide appropriate analysis tools <ref> [27, 32] </ref>. In particular, program visualization has been applied to such diverse applications as computer science instruction [9], visual debugging [21], program verification and reasoning [27], and educational software [16]. <p> Note that many important and interesting distributed systems never "terminate". stagehand was designed to be online in the interest of allowing visualization to be added dynamically at run-time. The latter two systems both employ POLKA <ref> [32] </ref> as a visualization front-end. POLKA is a descendent of TANGO intended for animations of programs executing on parallel architectures.
Reference: [33] <author> P. Stephenson. </author> <title> Fast ordered multicasts. </title> <type> Technical Report TR 91-1194, </type> <institution> Cornell University, </institution> <address> Ithaca, NY, </address> <month> February </month> <year> 1991. </year> <type> Ph.D. Thesis. </type>
Reference-contexts: A straightforward mechanism for implementing causal delivery is to use vector clocks [23]. Vector clocks are a well known mechanism for implementing causal delivery and several implementation techniques have been suggested in the literature <ref> [28, 33, 7, 24] </ref>. The algorithm we describe here is similar to that described in [23]. In a vector clock protocol, each participant maintains a local Lamport clock [17] as well as a Lamport clock for each participant it has received a message from.
Reference: [34] <author> D. C. Sturman. </author> <title> Modular Specification of Interaction Policies in Distributed Computing. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: In particular, stagehand implements the event-based model described in Chapter 2 and supports the specification of visualization using the language constructs defined in Chapter 3. In order to test our mechanisms, we chose to extend broadway <ref> [34] </ref>, a prototype environment for building actor-based systems. The accessibility and strict object-oriented design of broadway make it an ideal platform for testing our ideas. In this chapter, we provide a detailed discussion of the implementation mechanisms used in building stagehand. <p> In this chapter, we provide a detailed discussion of the implementation mechanisms used in building stagehand. Section 4.1 provides an overview of the structure of broadway. A more detailed description of the design methodology which inspired broadway is available in <ref> [34] </ref>. In Section 4.2 we describe the overall architecture of stagehand visualizers. In particular, we provide a general description of how visualizers are implemented and how broadway actors are added to visualizers. <p> In particular, broadway provides support for distributed actor programs including asynchronous communication, dynamic actor creation, and scheduling of actors. Basic actor functionality is augmented with support for migration, exception handling [4], synchronization constraints [13], and modular specification of interaction policies <ref> [34] </ref>. The platform currently runs on Ultrix for DEC MIPS workstations, on Solaris for SUN Sparcstations, and IRIX 5 for SGI workstations. Broadway supports basic actor functionality using a multi-thread scheduler, distributed name service, and platform independent communication service. <p> Figure 4.2 illustrates this superstructure. AClass provides an interface for standard actor functionality (send, create, etc.) to all subclasses (i.e. application actor classes). 1 Interested readers should refer to <ref> [34] </ref> for applications of the dynamic form of reflection for the modular specification of interaction policies. 39 report them to the VisManager. The VisManager distributes actor events to the appropriate visualizers. AClass methods are implemented by accessing methods either in one of the immediate super-classes or in Actor.
Reference: [35] <author> V. S. Sunderam. </author> <title> Pvm: A framework for parallel distributed computing. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 2(4) </volume> <pages> 315-339, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: The concept of synchronizing visualization with the causal relationships of the underlying execution has been recognized as critical to understanding concurrent algorithms. Turner and Cai have described a visualization mechanism based on the logical clock traces of interacting processes [38]. Similarly, the PVM <ref> [35] </ref> distributed computing environment has been extended with PVaniM [36] to support timestamp based visualization. The Conch [8] system has been extended in a similar fashion in [37]. All of these environments are based on post-mortem visualization.
Reference: [36] <author> B. Topol, J. T. Stasko, and V. Sunderam. </author> <title> The dual timestamping methodology for visualizing distributed applications. </title> <type> Technical Report GIT-CC-95-21, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <address> Atlanta, GA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Turner and Cai have described a visualization mechanism based on the logical clock traces of interacting processes [38]. Similarly, the PVM [35] distributed computing environment has been extended with PVaniM <ref> [36] </ref> to support timestamp based visualization. The Conch [8] system has been extended in a similar fashion in [37]. All of these environments are based on post-mortem visualization. That is, events are recorded in a log during execution and visualized after the fact.
Reference: [37] <author> B. Topol, J. T. Stasko, and V. Sunderam. </author> <title> Integrating visualization support into distributed computing systems. </title> <booktitle> In 15th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 19-26, </pages> <address> Vancouver, B.C., </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Turner and Cai have described a visualization mechanism based on the logical clock traces of interacting processes [38]. Similarly, the PVM [35] distributed computing environment has been extended with PVaniM [36] to support timestamp based visualization. The Conch [8] system has been extended in a similar fashion in <ref> [37] </ref>. All of these environments are based on post-mortem visualization. That is, events are recorded in a log during execution and visualized after the fact. Thus, a shallow difference between these systems and stagehand is that stagehand allows visualization during system execution. <p> However, the two systems described above provide no mechanisms for abstracting over low-level interactions. Such abstraction must be implemented as part of the visualization mechanism in POLKA. Furthermore, PVaniM utilizes a code annotation approach, the tradeoffs of which we have already discussed; whereas the approach described in <ref> [37] </ref> modifies system level routines to record events.
Reference: [38] <author> S. K. Turner and W. Cai. </author> <title> The `logical clocks' approach to the visualization of parallel programs. </title> <editor> In G. Kotsis and G. Haring, editors, </editor> <booktitle> Performance Measurement and Visualization of Parallel Programs, </booktitle> <pages> pages 45-66. </pages> <publisher> Elsevier, </publisher> <year> 1993. </year> <month> 72 </month>
Reference-contexts: The concept of synchronizing visualization with the causal relationships of the underlying execution has been recognized as critical to understanding concurrent algorithms. Turner and Cai have described a visualization mechanism based on the logical clock traces of interacting processes <ref> [38] </ref>. Similarly, the PVM [35] distributed computing environment has been extended with PVaniM [36] to support timestamp based visualization. The Conch [8] system has been extended in a similar fashion in [37]. All of these environments are based on post-mortem visualization.
References-found: 38

