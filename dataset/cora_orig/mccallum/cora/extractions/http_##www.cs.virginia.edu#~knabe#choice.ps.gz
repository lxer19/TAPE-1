URL: http://www.cs.virginia.edu/~knabe/choice.ps.gz
Refering-URL: http://www.cs.virginia.edu/~knabe/papers.html
Root-URL: http://www.cs.virginia.edu
Email: knabe@ecrc.de  
Title: A Distributed Protocol for Channel-Based Communication with Choice  
Author: Frederick Knabe 
Keyword: Distributed protocols, channels, synchronous communication, choice operator, CSP alternative command.  
Address: Munich, Germany  
Affiliation: European Computer-Industry Research Centre GmbH  
Abstract: Recent attempts at incorporating concurrency into functional languages have identified synchronous communication via shared channels as a promising primitive. An additional useful feature found in many proposals is a nondeterministic choice operator. Similar in nature to the CSP alternative command, this operator allows different possible actions to be guarded by sends or receives. Choice is difficult to implement in a distributed environment because it requires offering many potential communications but closing only one. In this paper we present the first distributed, deadlock-free algorithm for choice. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. J. Accetta, R. V. Baron, W. Bolosky, D. B. Golub, R. F. Rashid, A. T. Jr., and M. W. Young. </author> <title> Mach: A new kernel foundation for UNIX development. </title> <booktitle> In Proceedings of the Summer 1986 USENIX Conference, </booktitle> <pages> pages 93-113, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Fault tolerance The ability to build fault tolerance into a distributed protocol such as ours is in some measure dependent on the facilities supplied by the transport system. Modern operating systems such as Mach <ref> [1] </ref> generally supply sufficient information about unreachable message recipients to enable recovery actions, so we will assume this is a given. It is relatively straightforward how to proceed in our protocol if a message can no longer be sent.
Reference: [2] <author> A. W. Appel and D. B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In J. Maluszy nski and M. Wirsing, editors, </editor> <booktitle> Proceedings of the Third International Symposium on Programming Language Implementation and Logic Programming (PLILP), number 528 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-13, </pages> <address> Passau, Germany, Aug. 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Before fault tolerance can be implemented, though, the semantics of a fault must 11 be incorporated into the already existing semantics for channels with choice. This is still an area of research. 3.6. Implementation We have successfully implemented our protocol in Standard ML of New Jersey <ref> [2] </ref> using Cooper and Morrisett's ML+threads [10] and Knabe's Mach IPC package for ML [15].
Reference: [3] <author> R. Bagrodia. </author> <title> A distributed algorithm to implement the generalized alternative command of CSP. </title> <booktitle> In Proceedings of the 6th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 422-427, </pages> <address> Cambridge, MA, </address> <month> May </month> <year> 1986. </year>
Reference: [4] <author> A. Bernstein. </author> <title> Output guards and nondeterminism in communicating sequential processes. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(2) </volume> <pages> 234-238, </pages> <month> Apr. </month> <year> 1980. </year>
Reference-contexts: the programmer manipulates can be just the internal name of this thread. (In an actual implementation it may be useful to have just one thread of control manage multiple channels.) Our algorithm also relies on the existence of a global ordering for processes, an idea which goes back to Bernstein <ref> [4] </ref>. Each process has a unique id, and any two ids may be compared against one another. This is not an unreasonable assumption, for ids are necessary to route messages unambiguously. We now present the structure of the protocol.
Reference: [5] <author> D. Berry, R. Milner, and D. N. Turner. </author> <title> A semantics for ML concurrency primitives. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1992. </year>
Reference-contexts: When that professor becomes available, she can only choose one of the meetings, while the others continue to wait. Coordinating this is non-trivial, and various solutions have appeared [9, 17, 22, 23]. Several proposals for concurrency primitives <ref> [5, 11, 19, 20, 24] </ref> further extend the CSP model in a direction briefly mentioned in Hoare's original paper. These introduce communication entities known as channels. A process no longer explicitly names other processes in its send and receive operations but instead names a channel.
Reference: [6] <author> R. Bornat. </author> <title> A protocol for generalized occam. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 16(9) </volume> <pages> 783-799, </pages> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: Poly/ML has a distributed extension [18] which provides a form of the choice operator, though it is a much simpler construct than the one we have described. Bornat's protocol for a generalized choice operator in occam <ref> [6] </ref> has the closest similarity to our own work. Processes communicate via channels, but these channels are restricted to one-to-one process connections rather than the any-to-any which we are considering. The underlying communication model is assumed to be synchronous, a restriction we waive (see the next section).
Reference: [7] <author> G. N. Buckley and A. Silberschatz. </author> <title> An effective implementation for the generalized input-output construct of CSP. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 223-235, </pages> <month> Apr. </month> <year> 1983. </year>
Reference-contexts: As others also examined this expanded construct, its effective implementation began to draw interest. Buckley and Silberschatz <ref> [7] </ref> presented an overview of several early attempts, as well as detailing their own algorithm. They also made a notable contribution in outlining four criteria for evaluating different implementation approaches: 1.
Reference: [8] <author> L. Cardelli. </author> <title> Amber. </title> <booktitle> In Combinators and Functional Programming Languages, number 242 in Lecture Notes in Computer Science, </booktitle> <pages> pages 21-47. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1986. </year>
Reference-contexts: This communication model has drawn strong interest because it is both semantically clean and a natural paradigm for functional programming. Early shared memory implementations such as PFL [13] and Amber <ref> [8] </ref> led to Reppy's Concurrent ML [25], which is now being applied to systems programming (e.g. eXene [26], a multi-threaded X window system toolkit).
Reference: [9] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1988. </year> <month> 13 </month>
Reference-contexts: The first two criteria stress locality, while the third ensures progress and the last concerns efficiency. A natural extension of this generalized alternative construct is to allow a synchronization to involve multiple processes, not just two. Chandy and Misra characterized this as the committee coordination problem <ref> [9] </ref>: Professors in a university are assigned to various committees. Occasionally a professor will decide to attend a meeting of any of her committees, and will wait until that is possible. Meetings may begin only if there is full attendance. <p> The crux of this problem is that two or more committees might share a professor. When that professor becomes available, she can only choose one of the meetings, while the others continue to wait. Coordinating this is non-trivial, and various solutions have appeared <ref> [9, 17, 22, 23] </ref>. Several proposals for concurrency primitives [5, 11, 19, 20, 24] further extend the CSP model in a direction briefly mentioned in Hoare's original paper. These introduce communication entities known as channels.
Reference: [10] <author> E. C. Cooper. </author> <title> A thread interface for Standard ML. </title> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: This is still an area of research. 3.6. Implementation We have successfully implemented our protocol in Standard ML of New Jersey [2] using Cooper and Morrisett's ML+threads <ref> [10] </ref> and Knabe's Mach IPC package for ML [15].
Reference: [11] <author> A. Giacalone, P. Mishra, and S. Prasad. </author> <title> Facile: A symmetric integration of concurrent and functional programming. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 18(2) </volume> <pages> 121-160, </pages> <month> Apr. </month> <year> 1989. </year>
Reference-contexts: When that professor becomes available, she can only choose one of the meetings, while the others continue to wait. Coordinating this is non-trivial, and various solutions have appeared [9, 17, 22, 23]. Several proposals for concurrency primitives <ref> [5, 11, 19, 20, 24] </ref> further extend the CSP model in a direction briefly mentioned in Hoare's original paper. These introduce communication entities known as channels. A process no longer explicitly names other processes in its send and receive operations but instead names a channel. <p> This is still an area of research. 3.6. Implementation We have successfully implemented our protocol in Standard ML of New Jersey [2] using Cooper and Morrisett's ML+threads [10] and Knabe's Mach IPC package for ML [15]. We relied on the Facile definition of choice <ref> [11] </ref>, and our (abbreviated) user signature looks like this: signature FACILE = sig type channel type stop datatype request = SEND of channel * data * (unit -&gt; unit) | RECV of channel * (data -&gt; unit) val channel : unit -&gt; channel val spawn : (unit -&gt; stop) -&gt; unit
Reference: [12] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <month> Aug. </month> <year> 1978. </year>
Reference-contexts: 1. Introduction In 1978, C.A.R. Hoare introduced a now-classic paradigm for parallel programming called communicating sequential processes, or CSP <ref> [12] </ref>. CSP presented a new approach to concurrent programming, and its legacy has continued to influence well-founded proposals for concurrent languages, particularly those relying on synchronous message-passing. In CSP, processes are allowed to communicate with one another via synchronous send and receive operations. <p> Starvation Starvation is a much more difficult problem than deadlock. To prevent a process from being starved appears to require a central fair scheduler or much greater communication between channels and processes (more than we consider reasonable). In fact, since problems may be constructed with unbounded nondeterminism (Hoare <ref> [12] </ref> gives an example in the CSP domain), no implementation can be guaranteed to be fair. Our protocol makes a modest effort at preventing starvation, which is enough to support the most common programming paradigms. Consider, for example, a server process which continuously receives from a particular channel.
Reference: [13] <author> S. Holstr om. </author> <title> PFL: A functional language for parallel programming and its implementation. </title> <type> Technical Report 83.03 R, </type> <institution> Department of Computer Science, Chalmers University of Technology, </institution> <year> 1983. </year>
Reference-contexts: When we include the level of indirection introduced by channels, implementing the alternative construct (which we call choice) becomes even more complex. This communication model has drawn strong interest because it is both semantically clean and a natural paradigm for functional programming. Early shared memory implementations such as PFL <ref> [13] </ref> and Amber [8] led to Reppy's Concurrent ML [25], which is now being applied to systems programming (e.g. eXene [26], a multi-threaded X window system toolkit).
Reference: [14] <author> Y.-J. Joung and S. A. Smolka. </author> <title> Coordinating first-order multiparty interactions. </title> <booktitle> In 18th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 209-220, </pages> <address> Orlando, FL, </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: These platforms should prove a strong test of this model's utility. However, a distributed implementation of these communication primitives requires a protocol to manage the complex interactions between channels and processes. To our knowledge, such a protocol has not appeared in the literature. Joung and Smolka's work <ref> [14] </ref> is somewhat related, but their algorithm concerns a fixed pool of processes engaging in statically defined interactions (which are roughly analogous to rendezvous at channels).
Reference: [15] <author> F. Knabe. </author> <title> A Mach IPC facility for SML. </title> <note> Fox note 5, </note> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1991. </year> <note> Internal working paper. </note>
Reference-contexts: This is still an area of research. 3.6. Implementation We have successfully implemented our protocol in Standard ML of New Jersey [2] using Cooper and Morrisett's ML+threads [10] and Knabe's Mach IPC package for ML <ref> [15] </ref>.
Reference: [16] <author> F. Knabe. </author> <title> A distributed protocol for channel-based communication with choice. </title> <type> Technical Report ECRC-92-16, </type> <institution> European Computer-Industry Research Centre, </institution> <address> Arabellastr. 17, W-8000 Munich 81, Germany, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: If the queue is empty, the process must wait for a query to arrive. 2.3. Additional details In the preceding description of the protocol we have glossed over several important details in the interest of clarity. We mention some of these now. (The complete algorithm may be found in <ref> [16] </ref>.) After a process sends out several requests, it must be able to distinguish which incoming query matches which request. To this end the process assigns each request a local id that is sent along to the channel. The channels send back these ids in their queries. <p> If the match is also an isolated request, the channel simply informs the matching process of its mate. This can greatly decrease the number of messages necessary to establish a match. (The complete algorithm in <ref> [16] </ref> includes this modification.) 10 3.4. Cost Establishing a lower bound on the number of messages required to establish communication with our protocol is straightforward. The simplest case occurs with two processes and one channel.
Reference: [17] <author> D. Kumar. </author> <title> An implementation of N-party synchronization using tokens. </title> <booktitle> In Proceedings of the 10th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 320-327, </pages> <address> Paris, France, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: The crux of this problem is that two or more committees might share a professor. When that professor becomes available, she can only choose one of the meetings, while the others continue to wait. Coordinating this is non-trivial, and various solutions have appeared <ref> [9, 17, 22, 23] </ref>. Several proposals for concurrency primitives [5, 11, 19, 20, 24] further extend the CSP model in a direction briefly mentioned in Hoare's original paper. These introduce communication entities known as channels.
Reference: [18] <author> D. C. J. Matthews. </author> <title> A distributed concurrent implementation of Standard ML. </title> <type> LFCS Report Series ECS-LFCS-91-174, </type> <institution> LFCS, University of Edinburgh, </institution> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: To our knowledge, such a protocol has not appeared in the literature. Joung and Smolka's work [14] is somewhat related, but their algorithm concerns a fixed pool of processes engaging in statically defined interactions (which are roughly analogous to rendezvous at channels). Poly/ML has a distributed extension <ref> [18] </ref> which provides a form of the choice operator, though it is a much simpler construct than the one we have described. Bornat's protocol for a generalized choice operator in occam [6] has the closest similarity to our own work.
Reference: [19] <author> R. Milner. </author> <title> A Calculus of Communicating Systems. </title> <booktitle> Number 92 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: When that professor becomes available, she can only choose one of the meetings, while the others continue to wait. Coordinating this is non-trivial, and various solutions have appeared [9, 17, 22, 23]. Several proposals for concurrency primitives <ref> [5, 11, 19, 20, 24] </ref> further extend the CSP model in a direction briefly mentioned in Hoare's original paper. These introduce communication entities known as channels. A process no longer explicitly names other processes in its send and receive operations but instead names a channel.
Reference: [20] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: When that professor becomes available, she can only choose one of the meetings, while the others continue to wait. Coordinating this is non-trivial, and various solutions have appeared [9, 17, 22, 23]. Several proposals for concurrency primitives <ref> [5, 11, 19, 20, 24] </ref> further extend the CSP model in a direction briefly mentioned in Hoare's original paper. These introduce communication entities known as channels. A process no longer explicitly names other processes in its send and receive operations but instead names a channel.
Reference: [21] <author> J. G. Morrisett. </author> <title> Implementing events in ML+threads. Venari Note 5, </title> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1990. </year> <note> Internal working paper. </note>
Reference-contexts: Early shared memory implementations such as PFL [13] and Amber [8] led to Reppy's Concurrent ML [25], which is now being applied to systems programming (e.g. eXene [26], a multi-threaded X window system toolkit). Reppy's primitives have also been implemented by Morrisett <ref> [21] </ref>. 2 The next significant step is to extend the application domain of channels with choice to distributed systems. These platforms should prove a strong test of this model's utility. However, a distributed implementation of these communication primitives requires a protocol to manage the complex interactions between channels and processes.
Reference: [22] <author> M. H. Park and M. Kim. </author> <title> A distributed synchronization scheme for fair multi-process handshakes. </title> <journal> Information Processing Letters, </journal> <volume> 34 </volume> <pages> 131-138, </pages> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: The crux of this problem is that two or more committees might share a professor. When that professor becomes available, she can only choose one of the meetings, while the others continue to wait. Coordinating this is non-trivial, and various solutions have appeared <ref> [9, 17, 22, 23] </ref>. Several proposals for concurrency primitives [5, 11, 19, 20, 24] further extend the CSP model in a direction briefly mentioned in Hoare's original paper. These introduce communication entities known as channels.
Reference: [23] <author> S. Ramesh. </author> <title> A new and efficient implementation of multiprocess synchronization. </title> <booktitle> In Proceedings of PARLE '87 (Parallel Architectures and Languages Eu-rope), number 259 in Lecture Notes in Computer Science, </booktitle> <pages> pages 387-401 (vol.2). </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: The crux of this problem is that two or more committees might share a professor. When that professor becomes available, she can only choose one of the meetings, while the others continue to wait. Coordinating this is non-trivial, and various solutions have appeared <ref> [9, 17, 22, 23] </ref>. Several proposals for concurrency primitives [5, 11, 19, 20, 24] further extend the CSP model in a direction briefly mentioned in Hoare's original paper. These introduce communication entities known as channels.
Reference: [24] <author> J. H. Reppy. </author> <title> Synchronous operations as first-class values. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 250-259, </pages> <month> June </month> <year> 1988. </year> <month> 14 </month>
Reference-contexts: When that professor becomes available, she can only choose one of the meetings, while the others continue to wait. Coordinating this is non-trivial, and various solutions have appeared [9, 17, 22, 23]. Several proposals for concurrency primitives <ref> [5, 11, 19, 20, 24] </ref> further extend the CSP model in a direction briefly mentioned in Hoare's original paper. These introduce communication entities known as channels. A process no longer explicitly names other processes in its send and receive operations but instead names a channel.
Reference: [25] <author> J. H. Reppy. </author> <title> An operational semantics of first-class synchronous operations. </title> <type> Draft., </type> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: This communication model has drawn strong interest because it is both semantically clean and a natural paradigm for functional programming. Early shared memory implementations such as PFL [13] and Amber [8] led to Reppy's Concurrent ML <ref> [25] </ref>, which is now being applied to systems programming (e.g. eXene [26], a multi-threaded X window system toolkit). Reppy's primitives have also been implemented by Morrisett [21]. 2 The next significant step is to extend the application domain of channels with choice to distributed systems.
Reference: [26] <author> J. H. Reppy and E. R. Gansner. eXene: </author> <title> A multi-threaded X window system toolkit. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, NY 14853, </address> <year> 1991. </year> <note> In preparation. 15 </note>
Reference-contexts: This communication model has drawn strong interest because it is both semantically clean and a natural paradigm for functional programming. Early shared memory implementations such as PFL [13] and Amber [8] led to Reppy's Concurrent ML [25], which is now being applied to systems programming (e.g. eXene <ref> [26] </ref>, a multi-threaded X window system toolkit). Reppy's primitives have also been implemented by Morrisett [21]. 2 The next significant step is to extend the application domain of channels with choice to distributed systems. These platforms should prove a strong test of this model's utility.
References-found: 26

