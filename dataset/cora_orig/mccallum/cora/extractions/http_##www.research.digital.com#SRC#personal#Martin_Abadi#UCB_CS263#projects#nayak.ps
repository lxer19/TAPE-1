URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/UCB_CS263/projects/nayak.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/UCB_CS263/projects.html
Root-URL: http://www.research.digital.com
Title: The Semantics of Probabilistic Programs  
Author: Ashwin Nayak 
Date: May 1997  
Abstract: The use of randomness has gained much popularity in the algorithms community, and not without reason: randomised algorithms are often not only more time efficient, but are also much simpler than their deterministic counterparts. Moreover, many problems which are provably either intractable or unsolvable deterministically admit randomized solutions. If formal verification of realistic programs were to be achieved, it would be imperative to include constructs for randomization in programming languages, and to develop appropriate semantics for such languages. A more compelling reason|from the point of view of algorithm design|for exploring the semantics of probabilistic programs is that it might provide another approach to understanding how the use of randomness leads to simplicity and efficiency in algorithms. Much work has been done on the semantics of probabilistic programs since the seminal paper by Kozen [6] in 1981. This report concentrates on the semantics of a simple imperative language equipped with a probabilistic construct. A weakest precondition semantics for this language (in the style of Dijkstra [1]) is presented, and studied with an eye on its ultimate use as a vehicle for proving properties of realistic probabilistic programs, and how closely it reflects reasoning about such programs. Much of the work reported can be attributed to the Probabilistic Systems Group at Oxford University [12]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. W. Dijkstra. </author> <title> A discipline of programming. </title> <publisher> Prentice Hall International, </publisher> <address> Englewood Cliffs, </address> <year> 1976. </year> <month> 8 </month>
Reference-contexts: We also suspect that this is more suitable for analysing the role of randomization in algorithms. The exact object of study is the semantics of a modification (mostly to include a probabilistic primitive) of Dijkstra's language of guarded commands <ref> [1] </ref>. Encouraged by the success of the predicate transformer semantics approach in the domain of non-probabilistic programs, we look at such a semantics for the language mentioned. <p> We conclude by evaluating the `predicate transformer' view of probabilistic programs in Section 5. 3 2 Semantics of an imperative language The syntax for the language we will be looking at is based on Dijkstra's language of guarded commands <ref> [1] </ref>. <p> obvious once further `healthiness conditions' of predicate transformers are proved). 4 3 Extension to probabilistic programs We now add a probabilistic primitive to the language defined in Section 2: prog := j prog P prog where P ranges over real number expressions (possibly involving the state variables) in the range <ref> [0; 1] </ref>. <p> As a step towards defining probabilistic predicates, we can interpret the f0; 1g values as being the probabilities of the events s 2 Q and s 2 wp:prog:Q. One might be tempted to define a probabilistic predicate Q as a function on S taking values in the interval <ref> [0; 1] </ref>, and thus, for a (standard) predicate Q, wp:prog:Q:s would give the probability that starting in the state s, the program terminates in a state satisfying Q. <p> When Q is standard, this reduces to the probability interpretation. There is no reason we should restrict Q to take values in <ref> [0; 1] </ref>, and thus we define a probabilistic predicate as a function from the states to all non-negative reals R . Probabilistic programs are then functions from probabilistic postconditions to weakest probabilistic preconditions. <p> As in the non-probabilistic case, one has to prove some general properties about the wp-semantics given above in order to arrive at Hoare-like rules that help us analyse looping programs. We turn to this next. 4 Healthiness conditions In <ref> [1] </ref>, Dijkstra imposes `healthiness' (well-formedness) conditions on standard predicate transformers, namely: 1. feasibility : for all prog, wp:prog:0 = 0. 2. conjunctivity : for all prog, wp:prog (Q ^ Q 0 ) = wp:prog:Q ^ wp:prog:Q 0 . 3. monotonicity : for all prog, if Q ) Q 0 , then
Reference: [2] <author> R. Fagin, J. Y. Halpern and N. Megiddo. </author> <title> A logic for reasoning about probabilities. </title> <booktitle> Information and Computation 87 (1990), </booktitle> <pages> pp. 78-128. </pages>
Reference-contexts: Randomness is introduced and studied in the `reactive' model of computation in works such as [3]. Logics of probability have also been proposed (see, for example <ref> [2] </ref>). A study of these topics has been left out in favour of a deeper treatment of the other topics mentioned before. 1.3 Organisation of the report The rest of the report is organized as follows. In Section 2, we present a well-studied imperative language and its weakest precondition semantics.
Reference: [3] <author> R. van Glabbeek, S. A. Smolka, B. Steffen and C. M. N. Tofts. </author> <title> Reactive, generative, and stratified models of probabilistic processes. </title> <booktitle> Proceedings of the 5th IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1990, </year> <pages> pp. 130-141. </pages>
Reference-contexts: Rao develops semantics for a probabilistic parallel language in [13] with which once can reason about properties of programs that hold either deterministically, or with probabilistic certainty. Randomness is introduced and studied in the `reactive' model of computation in works such as <ref> [3] </ref>. Logics of probability have also been proposed (see, for example [2]). A study of these topics has been left out in favour of a deeper treatment of the other topics mentioned before. 1.3 Organisation of the report The rest of the report is organized as follows.
Reference: [4] <author> C. A. R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <booktitle> Communications of the ACM 12(10) (1969), </booktitle> <pages> pp. 576-580. </pages>
Reference-contexts: So it would presumably be simpler to analyse the effect of introducing a variation in such a model rather than in another, less familiar model. The report also tries to follow the axiomatic approach brought to fore by Hoare <ref> [4] </ref> (following Floyd) since it most closely reflects the reasoning about programs in practice. We also suspect that this is more suitable for analysing the role of randomization in algorithms.
Reference: [5] <author> C. Jones. </author> <title> Probabilistic nondeterminism. </title> <type> PhD Thesis, </type> <institution> Monograph ECS-LFCS-90-105, Edinburgh University, </institution> <year> 1990. </year>
Reference-contexts: He shows that these semantics are, in fact, equivalent. Following the trend set in [7], there has been much work related to this approach by He, who takes a `relational' view of programs, and by Jones <ref> [5] </ref>, who shows how one can derive Kozen's semantics via a more general method of injecting probability into a semantic domain. These are finally unified in the work of Morgan et al. in [10] where non-determinism is introduced into the model of Kozen and Jones.
Reference: [6] <author> D. Kozen. </author> <title> Semantics of probabilistic programs. </title> <journal> Journal of Computer and System Sciences 22 (1981), </journal> <pages> pp. 328-350. </pages>
Reference-contexts: Encouraged by the success of the predicate transformer semantics approach in the domain of non-probabilistic programs, we look at such a semantics for the language mentioned. The predicate transformer view was first proposed by Kozen <ref> [6, 7] </ref> as one of two possible ways of looking at probabilistic programs: either as a function on the `actual' inputs adjoined with an infinite stream of random ones, or as a transformation on distributions on the inputs. He shows that these semantics are, in fact, equivalent.
Reference: [7] <author> D. Kozen. </author> <title> A probabilistic PDL. </title> <booktitle> Proceedings of the 15th ACM Symposium on Theory of Computing, </booktitle> <year> 1983, </year> <pages> pp. 291-297. </pages>
Reference-contexts: Encouraged by the success of the predicate transformer semantics approach in the domain of non-probabilistic programs, we look at such a semantics for the language mentioned. The predicate transformer view was first proposed by Kozen <ref> [6, 7] </ref> as one of two possible ways of looking at probabilistic programs: either as a function on the `actual' inputs adjoined with an infinite stream of random ones, or as a transformation on distributions on the inputs. He shows that these semantics are, in fact, equivalent. <p> He shows that these semantics are, in fact, equivalent. Following the trend set in <ref> [7] </ref>, there has been much work related to this approach by He, who takes a `relational' view of programs, and by Jones [5], who shows how one can derive Kozen's semantics via a more general method of injecting probability into a semantic domain.
Reference: [8] <author> C. Morgan, A. McIver, K. Seidel and J. W. Sanders. </author> <title> Probabilistic predicate transformers. </title> <type> Technical Report PRG-TR-4-95, </type> <institution> Programming Research Group, Oxford University, </institution> <year> 1995. </year>
Reference: [9] <author> C. Morgan. </author> <title> Proof rules for probabilistic loops. </title> <type> Technical Report PRG-TR-25-95, </type> <institution> Programming Research Group, Oxford University, </institution> <year> 1995. </year>
Reference: [10] <author> C. Morgan, A. McIver and K. Seidel. </author> <title> Probabilistic predicate transformers. </title> <booktitle> ACM Transactions on Programming Languages and Systems 18(3) (1996), </booktitle> <pages> pp. 325-353. </pages>
Reference-contexts: These are finally unified in the work of Morgan et al. in <ref> [10] </ref> where non-determinism is introduced into the model of Kozen and Jones. We study this end product while deliberately ignoring explicit non-determinism.
Reference: [11] <author> R. Motwani and P. Raghavan. </author> <title> Randomized algorithms. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1995. </year>
Reference-contexts: 1 Introduction 1.1 Motivation Recent times have seen an increased use of randomized algorithms in a host of areas <ref> [11] </ref>. The reasons for their immense popularity are not hard to understand: they are much simpler and fl Project Report, CS 263: Design of Programming Languages, Spring 1997. y Computer Science Division, UC Berkeley. Email: ashwin@cs.berkeley.edu. 1 more often than not, more time efficient than their deterministic counterparts.
Reference: [12] <institution> Probabilistic Systems Group. Oxford University. </institution> <note> http://www.comlab.ox.ac.uk/oucl/groups/probs/project.html </note>
Reference-contexts: below. wp:abort:Q := 0 wp:skip:Q := Q wp:(x := E):Q := Q [x := E] wp:(prog; prog 0 ):Q := wp:prog:(wp:prog 0 :Q) wp:(prog if B else prog 0 ):Q := [B] fi wp:prog:Q + [:B] fi wp:prog 0 :Q 1 We borrow the notation f:x of Morgan et al. <ref> [12] </ref> for function application f (x). 5 wp:(X C):Q := wp:LFP (X C):Q wp:(prog P prog 0 ):Q := P fi wp:prog:Q + (1 P ) fi wp:prog 0 :Q Here, 0 stands for the constant function taking the value 0 everywhere, [] maps the Boolean values true and false to
Reference: [13] <author> J. R. Rao. </author> <title> Reasoning about probabilistic parallel programs. </title> <booktitle> ACM Transactions on Programming Languages and Systems 16(3) (1994), </booktitle> <pages> pp. 798-842. </pages>
Reference-contexts: It should be noted that by spelling out the scope of the report as above, we are disregarding a big body of work on related topics which are also relevant to the goals of the project. Rao develops semantics for a probabilistic parallel language in <ref> [13] </ref> with which once can reason about properties of programs that hold either deterministically, or with probabilistic certainty. Randomness is introduced and studied in the `reactive' model of computation in works such as [3]. Logics of probability have also been proposed (see, for example [2]).
Reference: [14] <author> K. Seidel, C. Morgan and A. McIver. </author> <title> An introduction to probabilistic predicate transformers. </title> <type> Technical Report PRG-TR-6-96, </type> <institution> Programming Research Group, Oxford University, </institution> <year> 1996. </year> <month> 9 </month>
References-found: 14

