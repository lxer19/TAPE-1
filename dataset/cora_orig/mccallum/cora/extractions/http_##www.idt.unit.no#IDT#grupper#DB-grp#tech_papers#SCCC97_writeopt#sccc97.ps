URL: http://www.idt.unit.no/IDT/grupper/DB-grp/tech_papers/SCCC97_writeopt/sccc97.ps
Refering-URL: http://www.idt.unit.no/IDT/grupper/DB-grp/tech_papers/tech_papers.html
Root-URL: 
Email: fnoervaag, kjellbg@idi.ntnu.no  
Title: Write Optimized Object-Oriented Database Systems  
Author: Kjetil Nrvag and Kjell Bratbergsengen 
Address: 7034 Trondheim, Norway  
Affiliation: Department of Computer and Information Science Norwegian University of Science and Technology  
Abstract: In a database system, read operations are much more common than write operations, and consequently, database systems have been read optimized. As the size of main memory increases, more of the database read requests will be satisfied from the buffer system, and the amount of disk write operations relative to disk read operations will increase. This calls for a focus on write optimized database systems. In this paper, we present solutions to this problem. We describe in detail the data structures and algorithms needed to realize a write optimized object-oriented database system in the context of Vagabond, an OODB currently being implemented at our department. In Vagabond, focus has been to provide support for applications which have earlier used file systems because of the limited data bandwidth in current database systems, typical examples are super computing applications and geographical information systems 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. M. Astrahan et.al. </author> <title> System R: Relational Approach to Database Management. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1(2), </volume> <year> 1976. </year>
Reference-contexts: Media failure in a log-only system, can be handled by the use of mirroring (RAID 1), RAID with parity blocks, or logging to another node. 8. Related Work No-overwrite strategies have been used in shadow-paging recovery strategies earlier, e.g., in System R <ref> [1, 3] </ref>, but with the limited buffer size at that time, the performance was not satisfactory. Postgres [15] also employed a no-overwrite strategy, but had also its performance problems, for several reasons, the most important being the buffer force strategy used.
Reference: [2] <author> M. J. Carey, D. J. DeWitt, M. Franklin, N. E. Hall, M. L. McAuliffe, J. F. Naughton, D. T. Schuh, M. H. Solomon, C. Tan, O. G. Tsatalos, S. J. White, and M. J. Zwilling. </author> <title> Shoring Up Persistent Applications. </title> <booktitle> In Proceedings of the 1994 ACM SIGMOD Conference, </booktitle> <address> Minneapolis, MN, </address> <year> 1994. </year>
Reference-contexts: Objects to be stored on a server group are declustered on the servers in the group according to some declustering strategy, e.g., hashing. Similar to another recent project, Shore <ref> [2] </ref>, our architecture is a peer-to-peer architecture. Clients in the system are connected to one server running on the same machine. This make it possible for several clients running on the same machine to utilize a common cache. This server is the gateway to the database system.
Reference: [3] <author> J. Gray, P. McJones, M. Blasgen, B. Lindsay, R. Lorie, T. Price, F. Putzolu, and I. Traiger. </author> <title> The Recovery Manager of the System R Database Manager. </title> <journal> ACM Computing Surveys, </journal> <volume> 13(2), </volume> <year> 1981. </year>
Reference-contexts: Media failure in a log-only system, can be handled by the use of mirroring (RAID 1), RAID with parity blocks, or logging to another node. 8. Related Work No-overwrite strategies have been used in shadow-paging recovery strategies earlier, e.g., in System R <ref> [1, 3] </ref>, but with the limited buffer size at that time, the performance was not satisfactory. Postgres [15] also employed a no-overwrite strategy, but had also its performance problems, for several reasons, the most important being the buffer force strategy used.
Reference: [4] <author> A. Guttman. R-Trees: </author> <title> A Dynamic Index Structure for Spatial Searching. </title> <booktitle> In ACM SIGMOD, </booktitle> <month> June </month> <year> 1984. </year>
Reference-contexts: In Vagabond, these indexes are all realized as objects. For temporal queries, it is useful to be able to search and retrieve by time as well as OID. A multidimensional index can be used here, e.g., time-split B-trees [9] or R-trees <ref> [4] </ref>. 6. Physical Storage Structures The log is stored on a volume. One volume is a configuration of one or more storage devices. The storage devices are typically disk partitions, cf. Figure 1.
Reference: [5] <author> D. Hulse and A. Dearle. </author> <title> A Log-Structured Persistent Store. </title> <booktitle> In Proceedings of the 19th Australasian Computer Science Conference, </booktitle> <year> 1996. </year>
Reference-contexts: If we want to keep the old version, e.g., in a temporal database system, we use an index that can index more than one version of an object. 2.2. Log-Only Object Storage There are two alternative ways to design an OODB based on LFS techniques: 1. Page based <ref> [5, 14] </ref>, and 2. Object based. Page Based Designs. In these designs, we look at the log as one large persistent address space. When objects are created, they are allocated space from this address space. These pages are written to the log, as illustrated on Figure 2. <p> LFS has also been used as a basis for a high performance RAID [13], and for tertiary storage management [7]. LFS has been used as the basis for two other object managers: the Texas persistent store [14], and as a part of the Grasshopper operating system <ref> [5] </ref>. Both object stores are page based. To our knowledge, there have been no publications on other object based log-only OODB, based on LFS principles. 9.
Reference: [6] <author> J. E. Johnson and W. A. Laing. </author> <title> Overview of the Spiralog File System. </title> <journal> Digital Technical Journal, </journal> <volume> 8(2), </volume> <year> 1996. </year>
Reference-contexts: Postgres [15] also employed a no-overwrite strategy, but had also its performance problems, for several reasons, the most important being the buffer force strategy used. Log structured file systems was introduced by Rosen-blum and Ousterhout [11], an idea which has been further developed through the BSD-LFS [12] and Spiralog <ref> [6, 17] </ref> file systems. LFS has also been used as a basis for a high performance RAID [13], and for tertiary storage management [7].
Reference: [7] <author> J. T. Kohl and C. S. M. Stonebraker. HighLight: </author> <title> Using a Log-structured File System for Tertiary Storage Management. </title> <booktitle> In Proceedings of the USENIX Winter 1993 Conference, </booktitle> <year> 1993. </year>
Reference-contexts: Log structured file systems was introduced by Rosen-blum and Ousterhout [11], an idea which has been further developed through the BSD-LFS [12] and Spiralog [6, 17] file systems. LFS has also been used as a basis for a high performance RAID [13], and for tertiary storage management <ref> [7] </ref>. LFS has been used as the basis for two other object managers: the Texas persistent store [14], and as a part of the Grasshopper operating system [5]. Both object stores are page based.
Reference: [8] <author> D. E. Langworthy and S. B. Zdonik. </author> <title> Extensibility and Asynchrony in the Brown-Object Storage System. </title> <editor> In V. Kumar, editor, </editor> <title> Performance of Concurrency Control Mechanisms in Centralized Database Systems. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: However, this is no problem with the log-only approach, objects can change size with no fragmentation problems. Versioning/timestamping can be exploited by cache coherence algorithms in client-server environments, as is done in BOSS <ref> [8] </ref>. Similar techniques can also be used in peer-to-peer parallel database systems. It can also help in nomadic computing. By the use of timestamped data, it is easier to update partitioned databases after reconnect. The log-only approach is particularly attractive in application areas with large objects, e.g., super computing applications.
Reference: [9] <author> D. Lomet and B. Salzberg. </author> <title> Access Methods for Multiversion Data. </title> <booktitle> In Proceedings of the 1989 ACM SIGMOD, </booktitle> <year> 1989. </year>
Reference-contexts: In that case, both current and recent data will be accessed. From research in multiversion access methods the recent years, we know that it is possible to make such a structure efficient, e.g., by using a time-split B-tree <ref> [9] </ref>. <p> In Vagabond, these indexes are all realized as objects. For temporal queries, it is useful to be able to search and retrieve by time as well as OID. A multidimensional index can be used here, e.g., time-split B-trees <ref> [9] </ref> or R-trees [4]. 6. Physical Storage Structures The log is stored on a volume. One volume is a configuration of one or more storage devices. The storage devices are typically disk partitions, cf. Figure 1.
Reference: [10] <author> J. N. Matthews, D. Roselli, A. Costello, R. Wang, and T. An-derson. </author> <title> Improving the Performance of Log Structured File Systems With Adaptive Methods. </title> <booktitle> In Proceedings of the Sixteenth ACM Symposium on Operating System Principles (to appear), </booktitle> <year> 1997. </year>
Reference-contexts: It is also beneficial to cluster together objects that are expected to have the same lifetime, to avoid having to move the objects many times, and cluster together related objects. There is ongoing work in this area in the context of LFS <ref> [10] </ref>, and some of the results should be applicable here as well. However, the clustering constraints give us some additional problems, which is not as important in a file system. 7.7.
Reference: [11] <author> M. Rosenblum and J. K. Ousterhout. </author> <title> The Design and Implementation of a Log-Structured File System. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Operating System Principles, </booktitle> <year> 1991. </year>
Reference-contexts: In the rest of the paper, we will show how we can increase write throughput in an object-oriented database system (OODB). This is done by employing techniques from write-optimized file systems, mainly log-structured file systems (LFS) <ref> [11] </ref>. Some important differences between common file system requirements and database requirements complicates this work. The most important is data granularity. Objects are much more lightweight than files. The overhead acceptable for finding a file in a file system, is not acceptable to find an object. <p> Our solution to this problem, is to eliminate the database completely, and use a log-only approach. The log is written contiguously to the disk, in a no-overwrite way, in large blocks. This is similar to the approach used in log structured file systems (LFS) <ref> [11] </ref>. We will now explain briefly how data are written to the log, and delve into more details regarding algorithms and data structures in the following sections. 2.1. Log Writing With a log-only approach, data as well as metadata are written contiguously to the log. <p> Postgres [15] also employed a no-overwrite strategy, but had also its performance problems, for several reasons, the most important being the buffer force strategy used. Log structured file systems was introduced by Rosen-blum and Ousterhout <ref> [11] </ref>, an idea which has been further developed through the BSD-LFS [12] and Spiralog [6, 17] file systems. LFS has also been used as a basis for a high performance RAID [13], and for tertiary storage management [7].
Reference: [12] <author> M. Selzer, K. Bostic, M. K. McKusick, and C. Staelin. </author> <title> An Implementation of a Log-Structured File System for UNIX. </title> <booktitle> In Proceedings of the USENIX Winter 1993 Conference, </booktitle> <year> 1993. </year>
Reference-contexts: Postgres [15] also employed a no-overwrite strategy, but had also its performance problems, for several reasons, the most important being the buffer force strategy used. Log structured file systems was introduced by Rosen-blum and Ousterhout [11], an idea which has been further developed through the BSD-LFS <ref> [12] </ref> and Spiralog [6, 17] file systems. LFS has also been used as a basis for a high performance RAID [13], and for tertiary storage management [7].
Reference: [13] <author> K. W. Shirriff. Sawmill: </author> <title> A Logging File System for High-Performance RAID Disk Array. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, </institution> <year> 1995. </year>
Reference-contexts: While in normal systems, sequential write is only about 3-5 times faster than random write, in RAID, sequential write is probably 20 times faster than random write [16]. The advantages of combining LFS and RAID have already been shown in the Sawmill system <ref> [13] </ref>. Each write of an object to the log creates a new version, which is timestamped. Realizing a temporal database system is easy with our approach. <p> Log structured file systems was introduced by Rosen-blum and Ousterhout [11], an idea which has been further developed through the BSD-LFS [12] and Spiralog [6, 17] file systems. LFS has also been used as a basis for a high performance RAID <ref> [13] </ref>, and for tertiary storage management [7]. LFS has been used as the basis for two other object managers: the Texas persistent store [14], and as a part of the Grasshopper operating system [5]. Both object stores are page based.
Reference: [14] <author> V. Singhal, S. Kakkad, and P. Wilson. </author> <title> Texas: An Efficient, Portable Persistent Store. </title> <booktitle> In Proceedings of the Fifth International Workshop on Persistent Object Systems, </booktitle> <year> 1992. </year>
Reference-contexts: If we want to keep the old version, e.g., in a temporal database system, we use an index that can index more than one version of an object. 2.2. Log-Only Object Storage There are two alternative ways to design an OODB based on LFS techniques: 1. Page based <ref> [5, 14] </ref>, and 2. Object based. Page Based Designs. In these designs, we look at the log as one large persistent address space. When objects are created, they are allocated space from this address space. These pages are written to the log, as illustrated on Figure 2. <p> LFS has also been used as a basis for a high performance RAID [13], and for tertiary storage management [7]. LFS has been used as the basis for two other object managers: the Texas persistent store <ref> [14] </ref>, and as a part of the Grasshopper operating system [5]. Both object stores are page based. To our knowledge, there have been no publications on other object based log-only OODB, based on LFS principles. 9.
Reference: [15] <author> M. Stonebraker. </author> <title> The Design of the POSTGRES Storage System. </title> <booktitle> In Proceedings of the 13th Conference on Very Large Databases, </booktitle> <year> 1987. </year>
Reference-contexts: The problem with this approach, is that every time a new version is created, we have to update two indexes. A second alternative is to have one index structure for current ODs, and linking old versions to new versions. This has similarities with approach used in Postgres <ref> [15] </ref>. In Post-gres, a link exists from one version of a tuple, to the previous version. <p> Related Work No-overwrite strategies have been used in shadow-paging recovery strategies earlier, e.g., in System R [1, 3], but with the limited buffer size at that time, the performance was not satisfactory. Postgres <ref> [15] </ref> also employed a no-overwrite strategy, but had also its performance problems, for several reasons, the most important being the buffer force strategy used.
Reference: [16] <author> M. Stonebraker. </author> <title> Readings in Database Systems (2nd edition). </title> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference-contexts: In addition, sequential write becomes more important. While in normal systems, sequential write is only about 3-5 times faster than random write, in RAID, sequential write is probably 20 times faster than random write <ref> [16] </ref>. The advantages of combining LFS and RAID have already been shown in the Sawmill system [13]. Each write of an object to the log creates a new version, which is timestamped. Realizing a temporal database system is easy with our approach.
Reference: [17] <author> C. Whitaker, J. S. Bayley, and R. D. W. Widdowson. </author> <title> Design of the Server for the Spiralog File System. </title> <journal> Digital Technical Journal, </journal> <volume> 8(2), </volume> <year> 1996. </year>
Reference-contexts: Postgres [15] also employed a no-overwrite strategy, but had also its performance problems, for several reasons, the most important being the buffer force strategy used. Log structured file systems was introduced by Rosen-blum and Ousterhout [11], an idea which has been further developed through the BSD-LFS [12] and Spiralog <ref> [6, 17] </ref> file systems. LFS has also been used as a basis for a high performance RAID [13], and for tertiary storage management [7].
References-found: 17

