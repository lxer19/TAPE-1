URL: http://www.cs.wustl.edu/~schmidt/SPIE-95.ps.gz
Refering-URL: http://www.cs.wustl.edu/~irfan/resume/publications.html
Root-URL: 
Title: An Object-Oriented Framework for High-Performance Electronic Medical Imaging  
Author: Douglas C. Schmidt Tim Harrison Irfan Pyarali 
Address: St. Louis, Missouri, 63130 1  Dallas, Texas, 75240  
Affiliation: Department of Computer Science Washington University,  Kodak Health Imaging Systems  
Abstract: This paper will appear in the Software Technology Applied to Imaging and Multimedia Applications mini-conference at the Symposium on Electronic Imaging in the International Symposia Photonics West 1996, SPIE, San Jose, California USA, January 27 - February 2, 1996. Abstract This paper describes the design and performance of an object-oriented communication framework being developed by Kodak Health Imaging Systems and the Electronic Radiology Laboratory at Washington University School of Medicine. The framework is designed to meet the demands of Project Spectrum, which is a large-scale distributed electronic medical imaging system. A novel aspect of this framework is its seamless integration of flexible high-level CORBA distributed object computing middleware with efficient low-level socket network programming mechanisms. In the paper, we outline the design goals and software architecture of our framework, illustrate the performance of the framework over ATM, and describe how we resolved design challenges we faced when developing an object-oriented communication framework for distributed medical imaging. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Blaine, M. Boyd, and S. Crider, </author> <title> Project Spectrum: Scal able Bandwidth for the BJC Health System, </title> <journal> HIMSS, Health Care Communications, </journal> <pages> pp. 71-81, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction The demand for distributed electronic medical imaging systems (EMISs) is driven by technological advances and economic necessity <ref> [1] </ref>. Recent advances in high-speed networks and hierarchical storage management provide the technological infrastructure needed to build large-scale distributed, performance-sensitive EMISs. Consolidating independent hospitals into integrated health care delivery systems to control costs provides the economic incentive for such systems.
Reference: [2] <author> Object Management Group, </author> <title> The Common Object Request Bro ker: Architecture and Specification, </title> <editor> 2.0 (draft) ed., </editor> <month> May </month> <year> 1995. </year>
Reference-contexts: EMIS requirements for flexibility motivate 1 This research is supported in part by Kodak Health Imaging Systems and the Electronic Radiology Laboratory at Washington University, St. Louis. the use of distributed object computing middleware such as CORBA <ref> [2] </ref> in the communication infrastructure. CORBA automates common network programming tasks (such as object selection, location, and activation, as well as parameter marshalling and framing), thereby enhancing application flexibility. <p> We used the following CORBA mechanisms extensively to implement the Blob Streaming framework: * Strongly-typed interfaces: In CORBA, all interfaces are defined using the CORBA interface definition language (IDL) <ref> [2] </ref>. A CORBA IDL compiler generates stubs and skeletons that translate IDL interface definitions into C++ classes.
Reference: [3] <author> D. C. Schmidt, T. H. Harrison, and E. Al-Shaer, </author> <title> Object Oriented Components for High-speed Network Programming, </title> <booktitle> in Proceedings of the Conference on Object-Oriented Technologies, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: Louis. the use of distributed object computing middleware such as CORBA [2] in the communication infrastructure. CORBA automates common network programming tasks (such as object selection, location, and activation, as well as parameter marshalling and framing), thereby enhancing application flexibility. However, empirical studies <ref> [3] </ref> reveal that for bulk data transfer, the performance overhead of widely used CORBA implementations on high-speed ATM networks is 25% to 40% below that achievable using lower-level transport layer interfaces such as sockets or TLI. <p> Distributed object computing middleware (such as CORBA) provides much of the flexibility required by an EMIS. However, current implementations of CORBA attain only one-half to two-thirds of the performance achievable by using lower-level mechanisms (like sockets) directly <ref> [3] </ref>. Achieving EMIS performance requirements is crucial because medical imaging is particularly bandwidth-intensive and delay-sensitive. Below, we outline our approach to this problem. We address the performance problems of CORBA by integrating it with sockets. Our approach uses CORBA for control messages and sockets for bulk data transfer. <p> Thus, for many types of inter-process communication, CORBA offers a powerful solution. A disadvantage of CORBA is that current implementations incur significant performance overhead when used to transfer large amounts of data <ref> [3] </ref>. To avoid this overhead, Blob Streaming uses CORBA only as a signaling mechanism to negotiate TCP/IP connections for large transfers. This negotiation is a short-duration operation that exchanges a small amount of typed data and is therefore well-suited for CORBA. <p> This throughput preservation problem is exacerbated by contemporary implementations of distributed object computing middleware like CORBA, which copy data multiple times during fragmentation/reassembly, marshalling, and demarshalling. Furthermore, the latency associated with the request-response protocol implemented by ttcp significantly reduced performance. An earlier implementation of ttcp <ref> [3] </ref> attained 90 Mbps over the same 2 Subsequent code profiling revealed that the Blob Streaming receiver was performing an unnecessary data copy. With this copy removed, the performance of Blob Streaming should be comparable to the C and ACE C++ wrapper versions.
Reference: [4] <author> P. Druschel, M. B. Abbott, M. Pagels, and L. L. Peterson, </author> <title> Network subsystem design, </title> <journal> IEEE Network (Special Issue on End-System Support for High Speed Networks), </journal> <volume> vol. 7, </volume> <month> July </month> <year> 1993. </year>
Reference-contexts: Software designs that improve abstraction (such as encapsulation and layering) often reduce performance. For instance, excessive function call layering reduces locality of reference and foils CPU instruction and data caching strategies. This can result in high bus and memory overhead, which is relatively expensive on modern RISC workstations <ref> [4] </ref>. This section outlines and evaluates the primary features and design goals implemented in the Blob Streaming framework. Section 3 explores how we resolved key design challenges that arose during our development. 2.2.1 Enhance framework abstraction Developing an enterprise-wide distributed EMIS is difficult.
Reference: [5] <author> D. D. Clark and D. L. Tennenhouse, </author> <title> Architectural Consid erations for a New Generation of Protocols, </title> <booktitle> in Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), </booktitle> <address> (Philadelphia, PA), </address> <pages> pp. 200-208, </pages> <publisher> ACM, </publisher> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: Applications need not wait for an entire Blob to transfer before processing the data (e.g., compressing it as it is sent on the network and decompressing while being received). This technique is a form of Integrated Layer Processing (ILP) <ref> [5] </ref>, which has been used in high-speed communication protocol stacks. ILP optimizations significantly improve performance by overlapping communication and computation, as well as reducing memory bus traffic. * Abstracting away from Blob storage: Blobs reside in Blob Stores. <p> This problem occurs when only a portion of the available bandwidth is actually delivered to applications. The throughput preservation problem stems from operating system and protocol processing overhead (such as data movement, context switching, and synchronization <ref> [5] </ref>). This throughput preservation problem is exacerbated by contemporary implementations of distributed object computing middleware like CORBA, which copy data multiple times during fragmentation/reassembly, marshalling, and demarshalling. Furthermore, the latency associated with the request-response protocol implemented by ttcp significantly reduced performance.
Reference: [6] <author> H. Custer, </author> <title> Inside Windows NT. </title> <address> Redmond, Washington: Mi crosoft Press, </address> <year> 1993. </year>
Reference-contexts: This, in turn, makes applications using the Blob Streaming interface portable across platforms without changing application communication software. The Blob Streaming framework has been ported to a variety of UNIX platforms, as well as Win32 platforms <ref> [6] </ref>. The primary advantage of decoupling application software from OS-specific mechanisms is cross-platform portability. The primary disadvantage is that performance and functionality may be compromised to provide a generic OS interface. <p> For example, the current version of Blob Streaming does not take advantage of native Windows NT mechanisms for overlapped I/O [7]. * Abstracting from concurrency policies: On multi-threaded operating systems like Solaris 5.x [8] or Windows NT <ref> [6] </ref>, applications can use threads to simplify programming and take advantage of parallelism. Often, a multi-threaded application can use synchronous interfaces for long-duration operations (such as large image transfers) since it will not 3 block other threads.
Reference: [7] <author> D. C. Schmidt and P. Stephenson, </author> <title> Experiences Using De sign Patterns to Evolve System Software Across Diverse OS Platforms, </title> <booktitle> in Proceedings of the 9 th European Conference on Object-Oriented Programming, </booktitle> <address> (Aarhus, Denmark), </address> <publisher> ACM, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: The primary disadvantage is that performance and functionality may be compromised to provide a generic OS interface. For example, the current version of Blob Streaming does not take advantage of native Windows NT mechanisms for overlapped I/O <ref> [7] </ref>. * Abstracting from concurrency policies: On multi-threaded operating systems like Solaris 5.x [8] or Windows NT [6], applications can use threads to simplify programming and take advantage of parallelism.
Reference: [8] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalin giah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: For example, the current version of Blob Streaming does not take advantage of native Windows NT mechanisms for overlapped I/O [7]. * Abstracting from concurrency policies: On multi-threaded operating systems like Solaris 5.x <ref> [8] </ref> or Windows NT [6], applications can use threads to simplify programming and take advantage of parallelism. Often, a multi-threaded application can use synchronous interfaces for long-duration operations (such as large image transfers) since it will not 3 block other threads.
Reference: [9] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Frameworks such as X Windows and CORBA handle their respective events from their own event loops. In order for applications to use these tools efficiently, the multiple event loops must be integrated. We solved this problem by using ACE's Reactor <ref> [9] </ref> as the central event demultiplexor. The Reactor is an object-oriented interface to lower-level OS event demultiplexing operations (such as select, poll, and WaitForMultipleObjects) that react to descriptor events, timer events, and signal events.
Reference: [10] <author> D. C. Schmidt, ASX: </author> <title> an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: However, low-level network programming interfaces like sockets are hard to program because they have complex interfaces and are error prone. Our solution to this problem was to use C++ wrappers from the ACE toolkit <ref> [10] </ref> to encapsulate the C interfaces. ACE provides a rich set of efficient, reusable C++ wrappers, class categories, and frameworks that perform common communication software tasks (such as event demultiplexing, event handler dispatching, connection establishment, message routing, dynamic configuration of application services, and concurrency control). <p> It uses C socket calls to transfer and receive the data and control messages via TCP/IP. * ACE C++ version this version replaces all C socket calls in the applications with the C++ wrappers for sockets provided by the ACE network programming components <ref> [10] </ref>. ACE encapsulates sockets with typesafe, portable, and efficient C++ interfaces. * CORBA version the Orbix implementation of CORBA was used: version 1.3 of Orbix from IONA Technologies.
Reference: [11] <author> D. Ritchie, </author> <title> A Stream Input-Output System, </title> <journal> AT&T Bell Labs Technical Journal, </journal> <volume> vol. 63, </volume> <pages> pp. 311-324, </pages> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: The LattisCell 10114 is a 16 Port, OC3 155Mbs/port switch. Each SPARCstation 20 contains two 70 Mhz Super SPARC CPUs with a 1 Megabyte cache per-CPU. The SunOS 5.4 TCP/IP protocol stack is implemented using an optimized version of the STREAMS communication framework <ref> [11] </ref>. Each SPARCstation has 128 Mbytes of 6 RAM and an ENI-155s-MF ATM adaptor card, which supports 155 Megabits per-sec (Mbps) SONET multimode fiber. The Maximum Transmission Unit (MTU) on the ENI ATM adaptor is 9,180 bytes. Each ENI card has 512 Kbytes of on-board memory.
Reference: [12] <author> D. C. Schmidt and T. Suda, </author> <title> Transport System Architecture Services for High-Performance Communications Systems, </title> <journal> IEEE Journal on Selected Areas in Communication, </journal> <volume> vol. 11, </volume> <pages> pp. 489-506, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: In particular, 60 Mbps represents only 40 percent of the 155 Mbps ATM link. This disparity between network channel speed and end-to-end application throughput is known as the throughput preservation problem <ref> [12] </ref>. This problem occurs when only a portion of the available bandwidth is actually delivered to applications. The throughput preservation problem stems from operating system and protocol processing overhead (such as data movement, context switching, and synchronization [5]).
Reference: [13] <author> K. Modeklev, E. Klovning, and O. Kure, </author> <title> TCP/IP Behavior in a High-Speed Local ATM Network Environment, </title> <booktitle> in Proceedings of the 19 th Conference on Local Computer Networks, </booktitle> <address> (Minneapolis, MN), </address> <pages> pp. 176-185, </pages> <publisher> IEEE, </publisher> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: ATM testbed by using a flooding traffic generation model that did not use an end-to-end acknowledgment scheme. Finally, Figure 3 illustrates the impact of socket queue size on throughput. Larger socket queues increase the TCP window size <ref> [13] </ref>, which allows the transmission of multiple TCP segments back-to-back. Increasing the socket queue from 8 K to 64 K doubled performance from 28 Mbps to 60 Mbps. These results demonstrate the importance of having hooks to manipulate underlying OS mechanisms (such as transport layer and socket layer options).
Reference: [14] <author> M. DoVan, L. Humphrey, G. Cox, and C. Ravin, </author> <title> Initial Expe rience with Asynchronous Transfer Mode for Use in a Medical Imaging Network, </title> <journal> Journal of Digital Imaging, </journal> <volume> vol. 8, </volume> <pages> pp. 43-48, </pages> <month> February </month> <year> 1995. </year> <month> 9 </month>
Reference-contexts: This overhead is often masked on low-speed networks like Ethernet and Token Ring. On high-speed networks like ATM or FDDI, however, this overhead becomes a significant factor limiting communication performance <ref> [14] </ref>. The Blob Streaming framework described in this paper provides more efficient data transfer than using CORBA as the sole bulk data transport mechanism. Blob Streaming uses CORBA as a control mechanism to negotiate endpoints of TCP/IP communication in a location-independent manner.
References-found: 14

