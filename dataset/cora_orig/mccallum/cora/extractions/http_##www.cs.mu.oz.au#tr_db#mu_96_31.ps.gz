URL: http://www.cs.mu.oz.au/tr_db/mu_96_31.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: Logic Programming and Software Engineering Implications for Software Design  Abstractions help in developing complex software  
Author: Leon Sterling and mit Yalinalp 
Note: 1  
Address: Cleveland, OH, 44106, U.S.A.  
Affiliation: Department of Computer Engineering and Science Case Western Reserve University  
Abstract: Logic programming is a programming paradigm with potential to contribute to software engineering. This paper is concerned with one dimension of that potential, the impact that experience with developing logic programs can have on software design. We present a logic programming perspective on programming patterns, systematic program development, design for provability, and the paradigm of meta-programming. The essential challenge of software engineering is how to build and maintain complex software. The challenge has continued unabated over many years. Computer use is increasing, and with increased computer use has come increased user knowledge, and rising expectations of software reliability and usability. Opinions vary as to whether current software engineering practice can meet expectations. Harel (1992) sounded an optimistic tune. While acknowledging earlier cautionary writing of Brooks (1987) and Parnas (1985) that there is no `silver bullet' for the problems software developers face, Harel claims that computer science is advancing and software production can become more reliable. The history of computer science has shown that progress in software development has come through better abstractions. Logic programming (Kowalski, 1979) is an abstraction introduced in the 1970s. It has taken time for its value to be appreciated in software engineering. It is the purpose of this paper, and more generally this special issue, to argue that logic programming has something to offer. The key abstraction introduced in logic programming is the logical variable and the use of unification as a uniform means of computation. Unification abstracts away many data manipulation details, making programs more concise, and easy to read and write. This will be explicitly pointed out in later sections. Non-determinism is also present, which abstracts away implementation details of specific search techniques in some applications. This paper discusses in detail one dimension of the potential of logic programming to contribute to software engineering - the impact that experience with developing logic programs can have on software design. The key innovation of the paper is explicitly identifying patterns that have emerged within logic programming, and pointing out their relationship to the current interest in programming patterns (Gamma et al., 1995). Another 
Abstract-found: 1
Intro-found: 1
Reference: <author> Abelson, H. and Sussman, G.J. </author> <title> Structure and Interpretation of Computer Programs, </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Meta-Programming ... the establishment of new descriptive languages ... is particularly important in computer programming, because in programming not only can we formulate new languages but we can also implement these languages by constructing evaluators. <ref> (Abelson & Sussman, 1985) </ref> 5 .1 What is Meta-Programming? The paradigm of meta-programming has emerged as a mature entity within logic programming since the pioneering work of Bowen and Kowalski (1982). Prolog, as a logic programming language, supports the paradigm.
Reference: <editor> Abramson H. and Rogers, M. (eds.), </editor> <booktitle> Meta-Programming in Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Manipulating programs is easy, and rapid prototyping of new metalinguistic abstractions is a normal style of development. It is worth exploring definitions of meta-programming. The commonly accepted definition of meta-programming, given for example in (Sterling and Shapiro, 1994) and in the foreword to <ref> (Abramson and Rogers, 1989) </ref> is the writing of programs that treat other programs as data. This definition is an accurate description, however, it does not convey the essence of program development using meta-programming.
Reference: <author> Bowen, K.A. and Kowalski, R. </author> <title> Amalgamating Language and Metalanguage in Logic Programming, in Logic Programming, </title> <editor> (eds. Clark, K.L. and Tarnlund, S.-A.), </editor> <publisher> Academic Press, </publisher> <year> 1982. </year>

Reference: <author> Foster, I. and Taylor, S. Strand: </author> <title> New Concepts in Parallel Processing, </title> <publisher> Prentice Hall, </publisher> <editor> 1989 Fuchs, N. and Fromherz, M. </editor> <title> Schema-based Transformations of Logic Programs, </title> <booktitle> Proc. 5th International Workshop on Logic Program Synthesis and Transformation, </booktitle> <editor> Proietti, M. </editor> <publisher> (ed.), </publisher> <pages> pp. 111-125, </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: This learning approach should be stressed during teaching. They show that the skeletons and techniques for Prolog can be extended to constraint logic programming languages, notably CLP (R) (Jaffar et al., 1992), concurrent logic programming languages such as Flat Concurrent Prolog (Shapiro, 1987) and Strand <ref> (Foster and Taylor, 1989) </ref>, and higher order logic program languages, in particular l-Prolog (Nadathur and Miller, 1988). Applying these ideas to functional programming languages is currently being studied. Recently, Gegg-Harrison (1995) and Naish (1996) presented skeletons and techniques in terms of higher order predicates.
Reference: <author> Gamma, E., Helm, R., Johnson, R. and Vlissides, J. </author> <title> Design Patterns, </title> <publisher> Addison-Wesley, </publisher> <year> 1995 </year> <month> Gegg-Harrison, </month> <title> T. Learning Prolog in a Schema-Based Environment, </title> <journal> Instructional Science, </journal> <volume> 20 </volume> <pages> 173-192, </pages> <year> 1991. </year>
Reference-contexts: The key innovation of the paper is explicitly identifying patterns that have emerged within logic programming, and pointing out their relationship to the current interest in programming patterns <ref> (Gamma et al., 1995) </ref>. Another 1 Current Address: Department of Computer Science, University of Melbourne, Parkville, Vic. 3052, Australia, email: leon@cs.mu.oz.au 2 Current Address: Sybase Corporation, CA, U SA, email:umit@sybase.com discussion of the potential of logic programming to contribute to software engineering can be found in (Ciancarini and Levi, 1992). <p> OKeefes text (1990) also discusses Prolog programming patterns in terms of schemas, albeit different ones to Gegg-Harrison. Again our preference is for concrete programs. Fuchs and colleagues also present schemas for program transformation (Fuchs and Fromherz, 1991). 2 .5 Other paradigms The design patterns espoused in the book by <ref> (Gamma et al., 1995) </ref> are closer to skeletons than techniques, especially in their higher order characterization. In particular, the template pattern described in the book is reminiscent of a shell as discussed in Section 2.1. The strategy pattern is also similar to a shell.

Reference: <author> Lakhotia, A. </author> <title> Incorporating Programming Techniques into Prolog Programs, </title> <booktitle> in Proc. 1989 North American Conference on Logic Programming, </booktitle> <editor> (eds. Lusk, E. and Overbeek, </editor> <booktitle> R.), </booktitle> <pages> pp. 426-440, </pages> <publisher> MIT Press, 1989 Lakhotia, </publisher> <editor> A., Sterling, L. and Bojantchev, D. </editor> <title> Development of a Prolog Tracer by Stepwise Enhancement, </title> <booktitle> Proc. Third International Conference on Practical Applications of Prolog, Paris, </booktitle> <pages> pp. 371-393, </pages> <note> 1995 Naish, </note> <author> L. </author> <title> Higher Order Logic Programming in Prolog, </title> <type> Draft Computer Science Technical Report, </type> <institution> University of Melbourne, </institution> <year> 1996. </year>
Reference: <author> Nadathur, G. and Miller, D. </author> <title> An overview of l-Prolog, </title> <booktitle> in Proc. 5th International Conference and Symposium on Logic Programming, </booktitle> <editor> Kowalski, R. and Bowen, K. </editor> <booktitle> (eds.), </booktitle> <pages> pp. 810-827, </pages> <publisher> MIT Press, </publisher> <year> 1988 </year> <month> OKeefe, </month> <title> R. The Craft of Prolog, </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: They show that the skeletons and techniques for Prolog can be extended to constraint logic programming languages, notably CLP (R) (Jaffar et al., 1992), concurrent logic programming languages such as Flat Concurrent Prolog (Shapiro, 1987) and Strand (Foster and Taylor, 1989), and higher order logic program languages, in particular l-Prolog <ref> (Nadathur and Miller, 1988) </ref>. Applying these ideas to functional programming languages is currently being studied. Recently, Gegg-Harrison (1995) and Naish (1996) presented skeletons and techniques in terms of higher order predicates. The approach has some elegant predictive power, but is probably only accessible to more advanced students.

Reference: <author> Sterling, L., Ciancarini, P. and Turnidge, T. </author> <title> On the Animation of non executable Specifications by Prolog, </title> <journal> International Journal on Software Engineering and Knowledge Engineering, </journal> <note> 6(1), 1996 Sterling, L.S. </note> <author> and Sitt Sen, </author> <title> Chok A Tool to Support Stepwise Enhancement in Prolog, </title> <booktitle> Workshop on Logic Programming Environments, </booktitle> <pages> pp. 21-26, </pages> <address> Vancouver, </address> <month> October, </month> <note> 1993 Sterling, L.S. </note> <author> and Shapiro, E.Y. </author> <title> The Art of Prolog, 2nd edition, </title> <publisher> MIT Press, </publisher> <year> 1994. </year> <editor> Yalinalp, L.. </editor> <title> Meta-Programming for Knowledge-Based Systems in Prolog, </title> <type> Ph.D. Thesis, </type> <institution> Case Western Reserve University, </institution> <year> 1991. </year>
Reference-contexts: There has certainly been increased visibility in the form of this special issue, and the special issue of International Journal of Software Engineering and Knowledge Engineering <ref> (Ciancarini and Sterling, 1996) </ref> arising out of the workshop on Application of Logic Programming to Software Engineering following the Eleventh International Conference on Logic Programming held in Italy in 1994. <p> We also were forced to clarify the main data structure that would be needed in the design. Proofs of correctness have been sketched for several other examples. The largest are an objectoriented database language, and a translator from Z to Prolog <ref> (Sterling et al., 1996) </ref>. In both these cases, thinking of the need to prove the program correct improved the code. 5 .
References-found: 8

