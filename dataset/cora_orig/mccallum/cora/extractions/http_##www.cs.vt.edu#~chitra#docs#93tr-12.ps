URL: http://www.cs.vt.edu/~chitra/docs/93tr-12.ps
Refering-URL: http://www.cs.vt.edu/~chitra/PublicationList.html
Root-URL: http://www.cs.vt.edu
Email: fmathur,abramsg@vtopus.cs.vt.edu  
Title: Toward a Machine Assisted Software Performance Diagnosis Methodology  
Author: Anup Mathur and Marc Abrams 
Date: April 7, 1993  
Address: VA 24061-0106  
Affiliation: Department of Computer Science Virginia Polytechnic Institute and State University Blacksburg,  
Pubnum: TR 93-12  
Abstract: This paper discusses a methodology for diagnosing performance problems for parallel and distributed programs. The methodology is based on the formulation and testing of hypotheses about the cause of performance bottlenecks. The process is illustrated with a case study of an actual problem arising in a parallel discrete event simulation program in which granularity is a primary bottleneck and barrier implementation is a secondary bottleneck. The paper also describes the evolution of Chitra, a software performance measurement and analysis tool whose objective is to automate certain steps in software performance diagnosis. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abrams, M., Doraswamy, N., and Mathur, A., "Chitra: </author> <title> Visual Analysis of Parallel and Distributed Programs in the Time, Event, and Frequency Domains," </title> <journal> IEEE Trans. Parallel Distributed Syst., </journal> <volume> vol. 3, no. 6,672-685, </volume> <month> November </month> <year> 1992. </year>
Reference-contexts: In this paper we introduce a methodology for performance diagnosis (Section 2) in association with a performance measurement and analysis tool called Chitra (see Section 3) <ref> [1] </ref>. 1 The task of performance measurement requires data to be collected from instrumented source code. The data is then used by a performance measurement or analysis tool. <p> In fact, Chitra analyzes categorical time series data, and therefore could be used with non-software applications. Application of Chitra The evolution of Chitra has proceeded hand-in-hand with its application to actual software problems. Published case studies using Chitra include: the dining philosophers problem <ref> [1] </ref>, a commercial implementation of the TCP/IP protocol for the MS-DOS [1], and a parallel discrete event simulation algorithm called bounded lag [4] (this analysis is presented in Section 2.3 as a 4 case study.) Other applications being analyzed include: numerical Algorithms (e.g Gaussian elimination, Matrix multiplication), MPEG player software that <p> Application of Chitra The evolution of Chitra has proceeded hand-in-hand with its application to actual software problems. Published case studies using Chitra include: the dining philosophers problem <ref> [1] </ref>, a commercial implementation of the TCP/IP protocol for the MS-DOS [1], and a parallel discrete event simulation algorithm called bounded lag [4] (this analysis is presented in Section 2.3 as a 4 case study.) Other applications being analyzed include: numerical Algorithms (e.g Gaussian elimination, Matrix multiplication), MPEG player software that retrieves compressed video files from disk [20], the Network Multimedia File <p> The analysis of Chitra91 and Chitra92 assumes that the program under analysis reaches steady state. Planned for the third generation tool Chitra93 are alternative models of program behavior described in Section 3.3. 3.1 Chitra91 Chitra91 is a prototype and is described in <ref> [1] </ref>. The input to Chitra91 is an textual trace file that contains the PES [15]. The trace, once loaded, can then be displayed by the Chitra91 for visual inspection and visual editing by the user. Visual editing is the user directed transformation of the PES. <p> Visual editing is the user directed transformation of the PES. Visual editing reduces the size of the state space and helps the user build an accurate 15 model of the PES. Chitra91 supports four transforms for visual editing of the PES, defined in <ref> [1] </ref>. Clipping is useful in eliminating the initial and final transient portions of the PES. Aggregation is useful in capturing deterministic patterns in a PES. Chitra91 aggregates the states that form a deterministic pattern into one aggregate state. <p> By supporting such features Chitra93 will contribute towards 17 the automatization of the performance diagnosis methodology described in Section 2. 4 Conclusions Chitra described in <ref> [1] </ref> constructs an empirical model of program behavior. We now have the second generation tool Chitra92 which serves as the production quality version (for instructions to obtain Chitra92 by ftp send e-mail to chitra@vtopus.cs.vt.edu). The third generation tool Chitra93 is under development.
Reference: [2] <author> Sanjeevan, V., </author> <title> "The Cost of Terminating Parallel Discrete-Event Simulations," M.S. </title> <type> thesis, </type> <institution> Dept. of Computer Science, Virginia Tech, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: As a part of an experimental study <ref> [2] </ref>, the above algorithm was used to simulate a n fi n toroidal network (n being an integer). Each node in the network simulates a server with an infinite capacity input queue. A server is modeled by a Logical Process (LP ). <p> It is based on the the conjecture <ref> [2] </ref> that the duration of the barrier is much longer than the time spent by the program to process events. Metric Chosen We chose the total time spent by a thread while blocked at the barriers as the metric.
Reference: [3] <author> Bershad, B.N., Lazowska, E.D., and Levy, H.M, </author> <title> "PRESTO: A system for Object-Oriented Parallel Programming," </title> <type> Technical Report 87-09-01., </type> <institution> Department of Computer Science, University of Washington, </institution> <address> Seattle, Washington, </address> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: A server is modeled by a Logical Process (LP ). All LP 's asynchronously execute the simulation algorithm in parallel. The experiment was done using the Sequent Symmetry S81 shared-memory multiprocessor, running Dynix V3.0.18 and the Presto 0.4 thread package <ref> [3] </ref>. Each Presto [3] thread executed the code for an LP . The parameters for this experiment are the number of threads, denoted P , and the number of nodes in the torus network (n 2 ) denoted by N . <p> A server is modeled by a Logical Process (LP ). All LP 's asynchronously execute the simulation algorithm in parallel. The experiment was done using the Sequent Symmetry S81 shared-memory multiprocessor, running Dynix V3.0.18 and the Presto 0.4 thread package <ref> [3] </ref>. Each Presto [3] thread executed the code for an LP . The parameters for this experiment are the number of threads, denoted P , and the number of nodes in the torus network (n 2 ) denoted by N . <p> Our hypothesis is therefore confirmed. 2.3.3 Hypothesis 1 The barrier code being used in our case study is an example provided with the Presto thread package <ref> [3] </ref>. The barrier is implemented by a Master-Slave mechanism based on the use of monitors. Presto offers a C++ class called Monitor that implements a monitor object. Our 9 10 next hypothesis is of the strong type. <p> Code Alteration The simulation code is altered so that multiple nodes of the toroidal network map to a single Presto <ref> [3] </ref> thread.
Reference: [4] <author> Lubachevsky, B., </author> <title> "Efficient distributed event-driven simulations of multiple loop networks," </title> <journal> Comm. ACM., </journal> <volume> vol. 32, no. 1,111-123, </volume> <month> Jan. </month> <year> 1989. </year>
Reference-contexts: Application of Chitra The evolution of Chitra has proceeded hand-in-hand with its application to actual software problems. Published case studies using Chitra include: the dining philosophers problem [1], a commercial implementation of the TCP/IP protocol for the MS-DOS [1], and a parallel discrete event simulation algorithm called bounded lag <ref> [4] </ref> (this analysis is presented in Section 2.3 as a 4 case study.) Other applications being analyzed include: numerical Algorithms (e.g Gaussian elimination, Matrix multiplication), MPEG player software that retrieves compressed video files from disk [20], the Network Multimedia File System (NMFS) communication protocol [19], and a CICS-based transaction system on <p> The program should therefore be re-instrumented and steps 2,3, and 4 repeated. If the two periodograms match closely the instrumentation is acceptable. 2.3 Case Study 2.3.1 Problem Definition The implementation of a parallel simulation algorithm for asynchronous multiple loop networks using Lubachevsky's bounded lag discrete event simulation protocol <ref> [4] </ref> is the basis of this case study. As a part of an experimental study [2], the above algorithm was used to simulate a n fi n toroidal network (n being an integer). Each node in the network simulates a server with an infinite capacity input queue.
Reference: [5] <author> Lubachevsky, B., </author> <title> "Synchronization Barrier and Related Tools for Shared Memory Parallel Programming," </title> <journal> International Journal of Parallel Programming, </journal> <volume> vol. 19, no. 3,226-250, </volume> <month> July. </month> <year> 1990. </year>
Reference-contexts: The reformulated version of this strong hypothesis must examine the following assertion: The barrier code which implements an algorithm with complexity (N ) must be replaced by a sub-linear algorithm. In particular the O (logN ) barrier algorithm given in <ref> [5] </ref> should be employed.
Reference: [6] <author> Darroch, J.N., and Seneta, E., </author> <title> "On Quasi-Stationary distributions in absorbing discrete-time finite Markov chains," </title> <journal> J. Appl. Prob., </journal> <volume> 2, </volume> <pages> 88-100, </pages> <year> 1965. </year>
Reference-contexts: Chitra91 and Chitra92 make this assumption. This simplifying assumption is usually violated, since most programs are transient and never reach steady state. We are considering a class of models called quasi-stationary <ref> [6] </ref> models to describe such behavior. * A rule based scheme is being devised to replace deterministic subsequences in a PES by an aggregate state in the PES. * New views and metrics are being explored to measure the perturbation in program behavior due to instrumentation.
Reference: [7] <author> Martonosi, M., Gupta, A., and Anderson, T., "MemSpy: </author> <title> Analyzing Memory System Bottlenecks in Programs," </title> <journal> Performance Evaluation Review, </journal> <volume> vol. 20, no. 1, </volume> <pages> 1-12, </pages> <year> 1992. </year>
Reference-contexts: Small scale reasons include data structures that causes cache misses and misuse of synchronization primitives. In literature reasons for performance anomalies are called performance bottlenecks. We shall use this name to describe them in the rest of this paper. While several performance tools have become available <ref> [7, 9, 11, 13, 17] </ref>, the general approach to the task of diagnosing performance problems in parallel and distributed programs still remains ad hoc. <p> A PES records the state of a system as a function of time. Examples of "state" are the memory addresses referenced, the control point of processes, the values of data structures, or a combination of these. Current literature includes several examples of memory-oriented performance tuning <ref> [7, 17] </ref>, code-oriented performance tuning [13], and performance tuning of interconnection networks [18]. Chitra subsumes the function of such tools because of its ability to analyze an arbitrary state representation. Chitra contains a module that generates an empirical model from a set of PES's.
Reference: [8] <author> Lehr, T., Segall, Z., Vrsalovic, D.F., Caplan, E., Chung, A.L., and Fineman, </author> <title> C.E,"Visualizing performance debugging," </title> <journal> IEEE Computer, </journal> <volume> vol. 22, no. 10, </volume> <pages> 38-52, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: The data is then used by a performance measurement or analysis tool. Today's performance tools, such as execution profilers [13] or performance visualization systems <ref> [11, 8] </ref> only illustrate what is happening in particular program runs. Chitra, in contrast, generates a parameterized empirical model fitting all observed data. <p> This is even more so in the case of parallel and distributed software. Whereas several tools have been developed to measure and model parallel and distributed program behavior, there has been little effort directed toward understanding the process of performance debugging. Lehr et al <ref> [8] </ref> describe performance debugging as an iterative task that alternates between measuring and modifying the performance of successive computation prototypes. Several tools in literature [8, 9] have recognized performance debugging as a task. <p> Lehr et al [8] describe performance debugging as an iterative task that alternates between measuring and modifying the performance of successive computation prototypes. Several tools in literature <ref> [8, 9] </ref> have recognized performance debugging as a task. ChaosMON [9], for instance, builds an abstract high level model of an application program that helps the user to determine what to monitor. While PIE, and ChaosMON [8, 9] are steps in the right direction, we claim that a comprehensive methodology is <p> Several tools in literature <ref> [8, 9] </ref> have recognized performance debugging as a task. ChaosMON [9], for instance, builds an abstract high level model of an application program that helps the user to determine what to monitor. While PIE, and ChaosMON [8, 9] are steps in the right direction, we claim that a comprehensive methodology is required to address the various steps and issues involved in the task of performance diagnosis.
Reference: [9] <author> Kilpatrick, C., and Schwan, </author> <title> K, "ChaosMON-Application-Specific Monitoring and Display of Performance Information for Parallel and Distributed Systems," </title> <journal> Performance Evaluation Review, </journal> <volume> vol. 26, no. 12, </volume> <pages> 57-67, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: Small scale reasons include data structures that causes cache misses and misuse of synchronization primitives. In literature reasons for performance anomalies are called performance bottlenecks. We shall use this name to describe them in the rest of this paper. While several performance tools have become available <ref> [7, 9, 11, 13, 17] </ref>, the general approach to the task of diagnosing performance problems in parallel and distributed programs still remains ad hoc. <p> Lehr et al [8] describe performance debugging as an iterative task that alternates between measuring and modifying the performance of successive computation prototypes. Several tools in literature <ref> [8, 9] </ref> have recognized performance debugging as a task. ChaosMON [9], for instance, builds an abstract high level model of an application program that helps the user to determine what to monitor. While PIE, and ChaosMON [8, 9] are steps in the right direction, we claim that a comprehensive methodology is <p> Lehr et al [8] describe performance debugging as an iterative task that alternates between measuring and modifying the performance of successive computation prototypes. Several tools in literature [8, 9] have recognized performance debugging as a task. ChaosMON <ref> [9] </ref>, for instance, builds an abstract high level model of an application program that helps the user to determine what to monitor. <p> Several tools in literature <ref> [8, 9] </ref> have recognized performance debugging as a task. ChaosMON [9], for instance, builds an abstract high level model of an application program that helps the user to determine what to monitor. While PIE, and ChaosMON [8, 9] are steps in the right direction, we claim that a comprehensive methodology is required to address the various steps and issues involved in the task of performance diagnosis.
Reference: [10] <author> Maloney, </author> <title> A.D., "JED: Just an Event Display," Performance Instrumentation and Visualization, </title> <editor> ed. M.Simmons and R.Koskela, </editor> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: An important issue pertinent to our methodology is the perturbation in program behavior generated by the insertion of instrumentation to collect performance data. Due to their nondeterministic behavior this problem is of even greater significance for parallel and distributed programs. Maloney <ref> [10] </ref> likens this situation to the Hiesenberg's uncertainity principle in Physics. Most tools in the literature take one of the following two routes: 1. Instrument the program being analyzed and then alter the performance data collected to compensate for the change in program behavior. <p> Instrument the program being analyzed and then alter the performance data collected to compensate for the change in program behavior. To do this we must be able to predict how the instrumentation perturbed the behavior of the program. Maloney et al <ref> [10] </ref> discuss the construction of models for performance perturbation analysis to support this. 2. Instrument the program so that its normal behavior is not significantly altered. To do this we must designate what normal behavior is and what constitutes a significant deviation from it.
Reference: [11] <author> Reed, D.A., Aydt, R.A., Madhyastha, T.M., Noe, R.J., Shields, K.A., and Schwartz, B.W., </author> <title> "The Pablo Performance Analysis Environment," </title> <type> Technical Report, </type> <institution> Department of Computer Science, University of Illinois, Urbana, Illinois, </institution> <month> Spring </month> <year> 1993. </year>
Reference-contexts: Small scale reasons include data structures that causes cache misses and misuse of synchronization primitives. In literature reasons for performance anomalies are called performance bottlenecks. We shall use this name to describe them in the rest of this paper. While several performance tools have become available <ref> [7, 9, 11, 13, 17] </ref>, the general approach to the task of diagnosing performance problems in parallel and distributed programs still remains ad hoc. <p> The data is then used by a performance measurement or analysis tool. Today's performance tools, such as execution profilers [13] or performance visualization systems <ref> [11, 8] </ref> only illustrate what is happening in particular program runs. Chitra, in contrast, generates a parameterized empirical model fitting all observed data. <p> One trend in visualization research today is just to increase the data bandwidth passed to a 1 Chitra is a Sanskrit word for beautiful or pleasing pictures and drawings. 3 human user, for example using sound or virtual reality <ref> [11, 12] </ref>. However human users have only five senses, which limits their capacity to absorb and interpret data. In contrast parallel computers continue to grow in the number of processors, and hence the volume of trace data available for performance analysis. <p> Section 1 lists applications which have been or are being analyzed. Some other directions which have been targeted for future exploration and research are: * Enhance Chitra by providing automatic instrumentation of source code as in Pablo <ref> [11] </ref> and Mtool [17]. A related goal is to develop and provide machine assisted instrumentation reuse techniques. The methodology described in Section 2 is based on the formulation and testing of hypotheses H 0 ; H 1 ; :::; H f .
Reference: [12] <author> Francioni, J.M., Albright, L., and Jackson, J.A, </author> <title> "Debugging Parallel Programs Using Sound," </title> <journal> Performance Evaluation Review, </journal> <volume> vol. 26, no. 12, </volume> <pages> 68-75, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: One trend in visualization research today is just to increase the data bandwidth passed to a 1 Chitra is a Sanskrit word for beautiful or pleasing pictures and drawings. 3 human user, for example using sound or virtual reality <ref> [11, 12] </ref>. However human users have only five senses, which limits their capacity to absorb and interpret data. In contrast parallel computers continue to grow in the number of processors, and hence the volume of trace data available for performance analysis.
Reference: [13] <author> Graham, S.L., Kessler, P.B., and McKusick, </author> <title> M.K., "An Execution Profiler for Modular Programs," </title> <journal> Software Practice and Experience, </journal> <volume> vol. 13, </volume> <pages> 671-685, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: Small scale reasons include data structures that causes cache misses and misuse of synchronization primitives. In literature reasons for performance anomalies are called performance bottlenecks. We shall use this name to describe them in the rest of this paper. While several performance tools have become available <ref> [7, 9, 11, 13, 17] </ref>, the general approach to the task of diagnosing performance problems in parallel and distributed programs still remains ad hoc. <p> The data is then used by a performance measurement or analysis tool. Today's performance tools, such as execution profilers <ref> [13] </ref> or performance visualization systems [11, 8] only illustrate what is happening in particular program runs. Chitra, in contrast, generates a parameterized empirical model fitting all observed data. <p> Examples of "state" are the memory addresses referenced, the control point of processes, the values of data structures, or a combination of these. Current literature includes several examples of memory-oriented performance tuning [7, 17], code-oriented performance tuning <ref> [13] </ref>, and performance tuning of interconnection networks [18]. Chitra subsumes the function of such tools because of its ability to analyze an arbitrary state representation. Chitra contains a module that generates an empirical model from a set of PES's.
Reference: [14] <author> Landry, K.D., Cline, G., and Arthur, J.D., </author> <title> "A Distributed Parallel Processing Environment Based upon the Linda Paradigm: A Research Prospectus," </title> <institution> TR-Number TR-92-18, Dept. of Computer Science, Virginia Tech, Blacksburg, Virginia,1992. </institution>
Reference: [15] <author> Doraswamy, N., "Chitra: </author> <title> A Visualization System to Analyze the Dynamics of Parallel Programs," M.S. </title> <type> thesis, </type> <institution> Dept. of Computer Science, Virginia Tech, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Planned for the third generation tool Chitra93 are alternative models of program behavior described in Section 3.3. 3.1 Chitra91 Chitra91 is a prototype and is described in [1]. The input to Chitra91 is an textual trace file that contains the PES <ref> [15] </ref>. The trace, once loaded, can then be displayed by the Chitra91 for visual inspection and visual editing by the user. Visual editing is the user directed transformation of the PES.
Reference: [16] <author> Ganugapati, K., </author> <title> "The Design and Implementation of Chitra92, a System to Empirically Model Concurrent Software Performance," M.S. </title> <type> thesis, </type> <institution> Dept. of Computer Science, Virginia Tech, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: It also allows multiple views of the same PES at a time. Chitra92 serves as the public release version of our tool. The following features make Chitra92 <ref> [16] </ref> a suitable vehicle for many future years of development: * Modularity: The architecture of Chitra92 facilitates the extension of Chitra to include alternate modeling techniques, transforms, and views.
Reference: [17] <author> Goldberg, A.J., and Hennessey, J.L., </author> <title> "Mtool: An Integrated System for Performance Debugging Shared Memory Multiprocessor Applications," </title> <journal> IEEE Trans. Parallel Distributed Syst., </journal> <volume> vol. 4, no. 1,28-40, </volume> <month> January </month> <year> 1993. </year> <month> 19 </month>
Reference-contexts: Small scale reasons include data structures that causes cache misses and misuse of synchronization primitives. In literature reasons for performance anomalies are called performance bottlenecks. We shall use this name to describe them in the rest of this paper. While several performance tools have become available <ref> [7, 9, 11, 13, 17] </ref>, the general approach to the task of diagnosing performance problems in parallel and distributed programs still remains ad hoc. <p> A PES records the state of a system as a function of time. Examples of "state" are the memory addresses referenced, the control point of processes, the values of data structures, or a combination of these. Current literature includes several examples of memory-oriented performance tuning <ref> [7, 17] </ref>, code-oriented performance tuning [13], and performance tuning of interconnection networks [18]. Chitra subsumes the function of such tools because of its ability to analyze an arbitrary state representation. Chitra contains a module that generates an empirical model from a set of PES's. <p> Section 1 lists applications which have been or are being analyzed. Some other directions which have been targeted for future exploration and research are: * Enhance Chitra by providing automatic instrumentation of source code as in Pablo [11] and Mtool <ref> [17] </ref>. A related goal is to develop and provide machine assisted instrumentation reuse techniques. The methodology described in Section 2 is based on the formulation and testing of hypotheses H 0 ; H 1 ; :::; H f .
Reference: [18] <author> Ahluwalia, A.K., and Singhal, M., </author> <title> "Performance Analysis of the Communication Architecture of the Connection Machine," </title> <journal> IEEE Trans. Parallel Distributed Syst., </journal> <volume> vol. 3, no. 6,728-738, </volume> <month> November </month> <year> 1992. </year>
Reference-contexts: Examples of "state" are the memory addresses referenced, the control point of processes, the values of data structures, or a combination of these. Current literature includes several examples of memory-oriented performance tuning [7, 17], code-oriented performance tuning [13], and performance tuning of interconnection networks <ref> [18] </ref>. Chitra subsumes the function of such tools because of its ability to analyze an arbitrary state representation. Chitra contains a module that generates an empirical model from a set of PES's.
Reference: [19] <author> Patel, S., Abdulla, G., Abrams, M., and Fox, E., "NMFS: </author> <title> Network Multimedia File System Protocol," </title> <booktitle> Proceedings of the Third International Workshop on Network and Operating System Support for Digital Audio and Video., </booktitle> <pages> 328-334, </pages> <address> November 1992 San Diego, California </address>
Reference-contexts: event simulation algorithm called bounded lag [4] (this analysis is presented in Section 2.3 as a 4 case study.) Other applications being analyzed include: numerical Algorithms (e.g Gaussian elimination, Matrix multiplication), MPEG player software that retrieves compressed video files from disk [20], the Network Multimedia File System (NMFS) communication protocol <ref> [19] </ref>, and a CICS-based transaction system on a IBM-3090. The rest of this paper is organized as follows: Section 2 discusses the development of a methodology for performance diagnosis. Section 3 discusses the evolution of the performance measurement and analysis tool Chitra.
Reference: [20] <author> Rowe, L.A., and Smith, </author> <title> B.C., "A Continuous Media Player," </title> <booktitle> Proceedings of the Third International Workshop on Network and Operating System Support for Digital Audio and Video., </booktitle> <pages> 334-344, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: protocol for the MS-DOS [1], and a parallel discrete event simulation algorithm called bounded lag [4] (this analysis is presented in Section 2.3 as a 4 case study.) Other applications being analyzed include: numerical Algorithms (e.g Gaussian elimination, Matrix multiplication), MPEG player software that retrieves compressed video files from disk <ref> [20] </ref>, the Network Multimedia File System (NMFS) communication protocol [19], and a CICS-based transaction system on a IBM-3090. The rest of this paper is organized as follows: Section 2 discusses the development of a methodology for performance diagnosis.
Reference: [21] <author> Chandy, K.M., and Taylor, S., </author> <title> "AN INTRODUCTION TO PARALLEL PROGRAMMING," </title> <publisher> Jones and Bartlett Publishers., </publisher> <address> Boston, </address> <year> 1992. </year>
Reference-contexts: The reasons for performance anomalies can be many. Large scale reasons include partitioning, process to processor mapping, and granularity <ref> [21] </ref>. Small scale reasons include data structures that causes cache misses and misuse of synchronization primitives. In literature reasons for performance anomalies are called performance bottlenecks. We shall use this name to describe them in the rest of this paper.
Reference: [22] <author> Biggs, D., De Ville, B., and Suen, E., </author> <title> "A method for choosing multiway partitions for classification and decision trees," </title> <journal> Journal of Applied Statistics., </journal> <volume> vol. 18, no. 1, </volume> <pages> 49-62, </pages> <year> 1991. </year>
Reference-contexts: The following new models are being explored: * Construction of a model of program behavior based on decision tree analysis <ref> [22] </ref>. * Most stochastic analysis of program behavior assumes that program execution reaches a steady state. Chitra91 and Chitra92 make this assumption. This simplifying assumption is usually violated, since most programs are transient and never reach steady state.
References-found: 22

