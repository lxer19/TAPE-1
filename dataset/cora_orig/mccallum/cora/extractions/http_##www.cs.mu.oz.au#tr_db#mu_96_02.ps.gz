URL: http://www.cs.mu.oz.au/tr_db/mu_96_02.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: (lee@cs.mu.OZ.AU, http://www.cs.mu.oz.au/~lee)  
Title: Higher-order logic programming in Prolog  
Author: Lee Naish 
Address: Parkville, Victoria 3052 Australia  
Affiliation: Department of Computer Science University of Melbourne  
Pubnum: Technical Report 96/2  
Abstract: This is yet another paper which tells logic programmers what functional programmers have known and practiced for a long time: "higher order" programming is the way to go. How is this paper different from some of the others? First, we point out that call/N is not the way to go, despite its recent popularity as the primitive to use for higher order logic programming. Second, we use standard Prolog rather than a new language. Third, we compare higher order programming with the skeletons and techniques approach. Fourth, we present solutions to some (slightly) more challenging programming tasks. The interaction between higher order programming and some of the unique features of logic programming is illustrated and some important programming techniques are discussed. Finally, we examine the efficiency issue. Keywords: call, apply, functions, skeletons and techniques, programming methodology, programming pearls 
Abstract-found: 1
Intro-found: 1
Reference: [BW88] <author> Richard Bird and Philip Wadler. </author> <title> Introduction to Functional Programming. </title> <publisher> Pren-tice Hall, </publisher> <address> Hempel Hemsted, UK, </address> <year> 1988. </year>
Reference-contexts: The final aim is to compare the higher order style with the "skeletons and techniques" approach to program development, one of the many approaches based on program patterns, schemata and cliches. We assume familiarity with a modern functional programming language such as Haskell, Miranda 1 or Gofer <ref> [BW88] </ref>. The paper is structured as follows. After briefly discuss typical logic programming and functional programming styles we show how "higher order" predicates can be coded using the call/N primitive. Next we demonstrate that greater flexibility can be achieved using apply/3 and discuss the implementation of both primitives.
Reference: [CKW93] <author> W. Chen, M. Kifer, and D.S. Warren. HiLog: </author> <title> A foundation for higher order logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 15(3) </volume> <pages> 187-230, </pages> <year> 1993. </year>
Reference-contexts: Over the years many people have also toyed with this style of programming in Prolog but to say it has not caught on would be a gross understatement. Higher order programming has been has been advocated more in newer logic programming languages such as HiLog <ref> [CKW93] </ref>, Lambda Prolog [NM88][GH95], Mercury [SHC95] and the many combined logic and functional languages (see [Han94]). Some advocates of these languages are apparently unaware of the techniques available to Prolog programmers, despite the efforts of Richard O'Keefe and others.
Reference: [CRS91] <author> Anthony S.K. Cheng, Peter J. Robinson, and John Staples. </author> <title> Higher level meta programming in Qu-Prolog 3.0. </title> <editor> In Koichi Furukawa, editor, </editor> <booktitle> Proceedings of the 15 Eighth International Conference on Logic Programming, </booktitle> <pages> pages 285-300, </pages> <address> Paris, France, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: However, it does have a significant impact on all source level tools and meta programming, since the structure of terms is made more complex. Lambda terms are supported in Qu-Prolog <ref> [CRS91] </ref> because they make terms more expressive, not for higher order programming. Semantics and implementation are also significantly affected due to the possibility of unifying two lambda terms. 9.2 Type checking All too often when developing complex higher order Prolog code the result of a query is simply: fail.
Reference: [GH95] <author> T.S. Gegg-Harrison. </author> <title> Representing logic program schemata in Prolog. </title> <editor> In Leon Sterling, editor, </editor> <booktitle> Proceedings of the Twelfth International Conference on Logic Programming, </booktitle> <pages> pages 467-481, </pages> <address> Kanagawa, Japan, </address> <month> June </month> <year> 1995. </year>
Reference: [Han94] <author> M. Hanus. </author> <title> The integration of functions into logic programming: From theory to practice. </title> <journal> Journal of Logic Programming, </journal> 19&20:583-628, 1994. 
Reference-contexts: Higher order programming has been has been advocated more in newer logic programming languages such as HiLog [CKW93], Lambda Prolog [NM88][GH95], Mercury [SHC95] and the many combined logic and functional languages (see <ref> [Han94] </ref>). Some advocates of these languages are apparently unaware of the techniques available to Prolog programmers, despite the efforts of Richard O'Keefe and others. One aim of this paper is to illustrate higher order programming techniques in Prolog.
Reference: [KSJ93] <author> M. Kirschenbaum, L. Sterling, and A. Jain. </author> <title> Relating logic programs via program maps. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <volume> 8 </volume> <pages> 229-245, </pages> <year> 1993. </year>
Reference-contexts: way. % definition/traversal of a list list ([]). list (A.As) :- list (As). % length of a list length ([], 0). length (A.As, L) :- length (As, L1), L is L1 + 1. % sum of a list of numbers sum ([], 0). sum (As, S1), Under certain syntactic conditions <ref> [KSJ93] </ref>, separate enhancements of the same procedure can be safely combined. For example, the enhancements associated with length and sum can be combined to create a procedure which computes both the sum and length of a list in one pass.
Reference: [Llo87] <author> John W. Lloyd. </author> <title> Foundations of logic programming (second, extended edition). Springer series in symbolic computation. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: Our final example is a different style of meta interpreter. The structure of solve_a is based on proof trees. The more traditional way to describe the Prolog proof procedure is with SLD trees <ref> [Llo87] </ref>. Each node contains a goal. The children of a node are found by resolving the selected literal in the goal with matching program clauses. Prolog uses a depth first search for a path from the root of the SLD tree to a leaf node with an empty goal. <p> By insisting that syntactic and semantic equality are equivalent, the Clark equality axioms (see <ref> [Llo87] </ref>) prevent a high level interpretation. Instead we must think at a lower level and interpret plus as a representation of the addition relation. The more abstract view of programs requires a different approach to semantics and restrictions on programs so predicates such as surprise cannot be used.
Reference: [Nai91] <author> Lee Naish. </author> <title> Adding equations to NU-Prolog. </title> <booktitle> In Proceedings of The Third International Symposium on Programming Language Implementation and Logic Programming, number 528 in Lecture notes in computer science, </booktitle> <pages> pages 15-26, </pages> <address> Passau, Germany, </address> <month> August, </month> <title> 1991. </title> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The versions of the higher order predicates which use apply/3 behave in the same way as their functional counterparts. We believe that apply/3 should be a standard part of Prolog. In retrospect, this is indicated by the implementation of NUE-Prolog <ref> [Nai91] </ref>, a logic and functional language implemented by translating functions into Prolog via the "flattening" transformation. Higher order functions in NUE-Prolog are implemented using a specially coded version of apply/3 which only works with functions.
Reference: [NM88] <author> G. Nadathur and D. Miller. </author> <title> An overview of Prolog. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Proceedings of the Fifth International Conference/Symposium on Logic Programming, </booktitle> <pages> pages 810-827, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference: [O'K90] <author> Richard A. O'Keefe. </author> <title> The Craft of Prolog. Logic Programming. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: It is assumed that the object program clauses are represented by non-ground facts of the lclause/2 predicate, which is like clause/2 except the second argument is a list of subgoals rather than the normal "defaulty" data structure <ref> [O'K90] </ref>. Solve_a (F,A,R) finds a matching clause using lclause/2 and is called recursively on each subgoal in the body producing a list of results Rs.
Reference: [Sah93] <author> Dan Sahlin. Mixtus: </author> <title> An automatic partial avaluator for full Prolog. </title> <journal> New Generation Computing, </journal> <volume> 12(1) </volume> <pages> 7-51, </pages> <year> 1993. </year>
Reference-contexts: The second disadvantage is efficiency. The overheads of executing higher order code can be significant, especially if the primitives such as apply are implemented poorly. Fortunately, currently available partial evaluators for Prolog do an excellent job at eliminating the overheads. The sample session below shows how Mixtus <ref> [Sah93] </ref> optimises the version of sum_len which used foldr and apply_pair. Since Mixtus does not understand apply/3 or call/N a simple version of call/N which used =.. was supplied.
Reference: [SHC95] <author> Zoltan Somogyi, Fergus J. Henderson, and Thomas Conway. </author> <title> Mercury: an efficient purely declarative logic programming language. </title> <booktitle> In Proceedings of the Australian Computer Science Conference, </booktitle> <pages> pages 499-512, </pages> <address> Glenelg, Australia, </address> <month> February </month> <year> 1995. </year>
Reference-contexts: Higher order programming has been has been advocated more in newer logic programming languages such as HiLog [CKW93], Lambda Prolog [NM88][GH95], Mercury <ref> [SHC95] </ref> and the many combined logic and functional languages (see [Han94]). Some advocates of these languages are apparently unaware of the techniques available to Prolog programmers, despite the efforts of Richard O'Keefe and others. One aim of this paper is to illustrate higher order programming techniques in Prolog. <p> For example, A = append (Xs), call (A, Ys, [1,2]) is equivalent to the code above. Several Prolog systems support call/N as library predicates (up to some maximum N) or built in, and some newer logic programming languages such as Mercury <ref> [SHC95] </ref> have used call/N as the basis for their higher order features.
Reference: [SK93] <author> L. Sterling and M. Kirschenbaum. </author> <title> Applying techniques to skeletons. </title> <editor> In Jean-Marie Jacquet, editor, </editor> <booktitle> Constructing logic programs, </booktitle> <pages> pages 127-140. </pages> <publisher> Wiley, </publisher> <address> Chich-ester, England, </address> <year> 1993. </year>
Reference-contexts: B) :- applyp (A, B). % like call/4 but handles closures properly apply4 (F, A1, A2, R) :- apply (F, A1, FA1), apply (FA1, A2, R). 7 7 Skeletons and techniques The "skeletons and techniques" view of Prolog programming has been proposed as a method of developing and understanding code <ref> [SK93] </ref>. We will describe this view then discuss how the higher order style of programming has leads to similar advantages in an (arguably) more elegant way. <p> - Y) :- apply4 (F1, A, X0, X), apply4 (F2, A, Y0, Y). foldr_2a (F1, B1, F2, B2, As, R1, R2) :- foldr (apply_pair (F1, F2), B1-B2, As, R1-R2), One reason why the transformation approach is undesirable in general is that is can produce the wrong result for nondeterministic skeletons <ref> [SK93] </ref>. Consider the following example which traverses paths of a graph (later we use a more general version of this predicate). connected (A, A). connected (A0, A) :- edge (A0, A1), connected (A1, A).
Reference: [SS86] <author> Leon Sterling and Ehud Shapiro. </author> <title> The art of Prolog: </title> <booktitle> advanced programming techniques. Logic Programming series. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: If lclause, map and apply have appropriate control information solve_a will work with coroutining systems as well as those which use left to right execution. The extra arguments F and R allow us to implement various structural enhancements to the basic meta interpreter <ref> [SS86] </ref>.
Reference: [SW95] <author> K. Sagonas and D.S. Warren. </author> <title> Efficient execution of HiLog in WAM-based Prolog implementations. </title> <editor> In Leon Sterling, editor, </editor> <booktitle> Proceedings of the Twelfth International Conference on Logic Programming, </booktitle> <pages> pages 349-363, </pages> <address> Kanagawa, Japan, </address> <month> June </month> <year> 1995. </year>
Reference: [Tra94] <author> T. Traill. </author> <title> Transformation of logic programming. </title> <type> Honours thesis, </type> <institution> Department of Computer Science, University of Melbourne, Australia, </institution> <month> November </month> <year> 1994. </year> <month> 16 </month>
Reference: [TS84] <author> Hisao Tamaki and Taisuke Sato. </author> <title> Unfold/fold transformation of logic programs. </title> <editor> In Sten -Ake Tarnlund, editor, </editor> <booktitle> Proceedings of the Second International Logic Programming Conference, </booktitle> <pages> pages 127-138, </pages> <institution> Uppsala, Sweden, </institution> <month> July </month> <year> 1984. </year>
Reference-contexts: There are several ways to arrive at a version of sum_len which uses a single traversal of the list. Use program transformation: The first method is to start with a version which uses two traversals (just calling sum and length separately) and transform it using fold and unfold <ref> [TS84] </ref> et cetera. The transformations must combine two calls to foldr which use the same list argument. This is rather complicated and requires some knowledge of the properties of plus but can be done.
Reference: [TZ86] <author> James Thom and Justin Zobel. </author> <title> NU-Prolog reference manual, version 1.0. </title> <type> Technical Report 86/10, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <year> 1986. </year>
Reference-contexts: The compiler can recognise call/N for unbounded N and at runtime no additional space needs to be used. In a WAM [War83] based system it is sufficient to load the argument registers then jump to the start of the procedure being called. NU-Prolog <ref> [TZ86] </ref> supports call/N in this way. It is possible to achieve similar efficiency to the builtin implementation using pure Prolog by specialising the definition of call/N to a particular program.
Reference: [War82] <author> David H.D. Warren. </author> <title> Higher-order extensions to prolog: are they needed? In J.E. </title> <editor> Hayes, Donald Michie, and Y-H. Pao, editors, </editor> <booktitle> Machine Intelligence 10, </booktitle> <pages> pages 441-454. </pages> <publisher> Ellis Horwood Ltd., </publisher> <address> Chicester, England, </address> <year> 1982. </year>
Reference-contexts: The relative inflexibility of the code we have presented stems from the fact that exactly the right number of arguments must be given for call/N to work correctly. By using a different primitive, apply/3 <ref> [War82] </ref>, we can achieve flexibility of modern higher order functional languages. We can think of apply (F,X,FX) as taking a function F and argument X and returning the result FX. In the case where FX is a first order term, apply/3 and call/3 behave identically.
Reference: [War83] <author> David H.D. Warren. </author> <title> An abstract Prolog instruction set. Tecnical Note 309, </title> <booktitle> SRI International, </booktitle> <address> Menlo Park, California, </address> <month> October </month> <year> 1983. </year> <month> 17 </month>
Reference-contexts: A significantly more efficient alternative is to build call/N into the Prolog system. The compiler can recognise call/N for unbounded N and at runtime no additional space needs to be used. In a WAM <ref> [War83] </ref> based system it is sufficient to load the argument registers then jump to the start of the procedure being called. NU-Prolog [TZ86] supports call/N in this way.
References-found: 20

