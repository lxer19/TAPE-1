URL: http://www.cs.virginia.edu/~chapin/ws/ws.ps
Refering-URL: http://www.cs.virginia.edu/~chapin/
Root-URL: http://www.cs.virginia.edu
Title: WARMStones: Benchmarking Wide-Area Resource Management Schedulers  
Author: Steve J. Chapin 
Note: DRAFT White Paper  
Affiliation: University of Virginia  
Abstract: Researchers have proposed hundreds of algorithms for solutions to the distributed scheduling, or matching, problem. However, few of these algorithms have been implemented, and the primary analysis has either been purely theoretical or with limited simulation. There has been little or no performance analysis of these algorithms under realistic workloads. The result is that it is impossible to compare algorithms and to determine which work well in practice. We propose to build a benchmarking system for matching algorithms with the following properties: (1) the system will use real, existing high-performance computing applications as a basis for the benchmark suite, (2) we will provide a scheduler implementation toolkit, allowing researchers to implement their algorithms in isolation from dependencies on particular scheduling support systems, and (3) we will simulate the execution of the matching algorithm on a variety of heterogeneous distributed system architectures. The result will be that we can assess the strengths and weaknesses of individual scheduling algorithms in a uniform manner, thus allowing comparison of algorithm performance under realistic workloads.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Beadle, C. Pommerell, and M. Annaratone, K9: </author> <title> A Simulator of Distributed-Memory Parallel Processors, </title> <booktitle> IEEE/ACM Supercomputing 89, </booktitle> <month> November </month> <year> 1989. </year>
Reference-contexts: the relative cost of computing a schedule, and we do not expect the difference in absolute cost of generating the schedule between a compiled and an interpreted scheduler to be of importance. 3.3 System Representation Earlier simulation projects, in both parallel and distributed systems, have developed machine/system representations (e.g., K9 <ref> [1] </ref>, Osculant [13], PP-MESS-SIM [14], and Vint [10]). Scheduling systems also typically include abstract system representation, but not necessarily to the level of detail necessary for our purposes [5][11][17].
Reference: [2] <author> F. Berman and R. Wolski, </author> <title> Scheduling from the Perspective of the Application, </title> <booktitle> Proceedings of the 5 th International Symposium on High-Performance Distributed Computing, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: We will start with the MESSIAHS system description vector and extend it as necessary. For example, we are currently working with the Application Level Schedulers ( AppLeS <ref> [2] </ref>) group at UCSD to develop a complete basis of scheduling information. To facilitate comparisons of scheduling algorithms, we will generate a default set of system configurations ranging from a single-CPU workstation to a metasystem composed of hundreds or thousands of machines.
Reference: [3] <author> T. L. Casavant and J. G. Kuhl, </author> <title> A Taxonomy of Scheduling in General-Purpose Distributed Computing Systems, </title> <journal> IEEE Transactions on Software Engineering , 14(11), </journal> <month> Nov., </month> <year> 1988, </year> <pages> pp. 15781588. </pages>
Reference: [4] <author> S. J. Chapin, </author> <title> Distributed and Multiprocessor Scheduling, </title> <journal> ACM Computing Surveys, </journal> <volume> 28(1), </volume> <month> March, </month> <year> 1996, </year> <pages> pp. 233235. </pages>
Reference: [5] <author> S. J. Chapin, </author> <title> Distributed Scheduling Support in the Presence of Autonomy, </title> <booktitle> Proceedings of the 4 th Heterogeneous Computing Workshop, IPPS, </booktitle> <year> 1995, </year> <pages> pp. 2229. </pages>
Reference: [6] <author> S. J. Chapin and E. H. Spafford, </author> <title> Support for Implementing Scheduling Algorithms Using MESSIAHS, </title> <journal> Scientific Programming, </journal> <volume> vol. 3, </volume> <year> 1994, </year> <pages> pp. 325340. </pages>
Reference-contexts: Only a few systems [5][8][9] are flexible enough to allow the general expression of multiple policiesMESSIAHS was the first of these. MESSIAHS provides two interfaces for scheduler implementation: an interpreted language for rapid prototyping (the MESSIAHS Interface Language, or MIL), and a library of C functions for higher efficiency <ref> [6] </ref>. We will use the knowledge gained in the earlier MESSIAHS work as a basis for developing our scheduler implementation toolkit. Because we are primarily interested in the quality of the schedule generated by many policies, we anticipate using an interpreted toolkit.
Reference: [7] <author> A. Chien, Karamcheti, and Plevyak, </author> <title> The Concert System: Compiler and Runtime Support for Fine-Grained Concurrent ObjectOriented Languages, </title> <institution> University of Illinois at Urbana-Champaign DCS Tech Report R-93-1815, </institution> <year> 1993. </year>
Reference: [8] <author> I. Foster and C. Kesselman, Globus: </author> <title> A Metacomputing Infrastructure Toolkit, </title> <journal> International Journal of Supercomputer Applications, </journal> <note> to appear. </note>
Reference: [9] <author> A. Grimshaw, W. Wulf, </author> <title> and the Legion Team, The Legion Vision of a Worldwide Virtual Computer, </title> <journal> Communications of the ACM, </journal> <volume> 40(1), </volume> <month> January </month> <year> 1997. </year>
Reference-contexts: We will develop a standard task representation based on well-understood concepts from the area of compilers and runtime systems. We plan to use a flow graph representation such as that found in Legion <ref> [9] </ref>, where nodes represent computation and arcs represent communication and data and control-flow dependencies. a benchmark suite of applications that span the computing space of heterogeneous systems, including scientific applications multimedia applications soft real-time applications database and data mining applications The important property of these applications is that they be chosen <p> Module Development We will now describe each module in greater detail, and examine related work from which we can build. 3.1 Task Representation and Benchmark Suite There has already been extensive work in program representation in the areas of compiler implementation <ref> [9] </ref>, runtime system development [7][9], and partitioning and scheduling algorithms [15]. In most cases, programs are represented as described earlier, with weighted nodes (computation) and edges (dependencies).
Reference: [10] <author> P. Huang, D. Estrin, and J. Heidemann, </author> <title> Enabling Large-scale Simulations: Selective Abstraction Approach to the Study of Multicast Protocols, </title> <booktitle> Submitted to the 6 th International Symposium on Modeling, Analysis and Simulation of Computer Telecommunications Systems (MASCOTS 98). </booktitle> <address> http://netweb.usc.edu/huang/publication/mascots.ps. </address>
Reference-contexts: and we do not expect the difference in absolute cost of generating the schedule between a compiled and an interpreted scheduler to be of importance. 3.3 System Representation Earlier simulation projects, in both parallel and distributed systems, have developed machine/system representations (e.g., K9 [1], Osculant [13], PP-MESS-SIM [14], and Vint <ref> [10] </ref>). Scheduling systems also typically include abstract system representation, but not necessarily to the level of detail necessary for our purposes [5][11][17]. Therefore, we will devise a system description template that allows us to express system architecture, operating system, installed software, and connectivity, among other characteristics.
Reference: [11] <author> P. Kreuger and R. Chawla, </author> <title> The Stealth Distributed Scheduler, </title> <booktitle> Proceedings of the 11 th International Conference on Distributed Computing Systems, </booktitle> <year> 1991, </year> <pages> pp. 336343. </pages>
Reference: [12] <author> M. Litzkow, M. Livny, and M. W. </author> <title> Mutka, CondorA Hunter of Idle Workstations, </title> <booktitle> ICDCS 88, </booktitle> <pages> pp. 104111. </pages>
Reference: [13] <institution> Osculant home page: </institution> <note> http://beta.ee.ufl.edu/Projects/Osculant/index.html. </note>
Reference-contexts: cost of computing a schedule, and we do not expect the difference in absolute cost of generating the schedule between a compiled and an interpreted scheduler to be of importance. 3.3 System Representation Earlier simulation projects, in both parallel and distributed systems, have developed machine/system representations (e.g., K9 [1], Osculant <ref> [13] </ref>, PP-MESS-SIM [14], and Vint [10]). Scheduling systems also typically include abstract system representation, but not necessarily to the level of detail necessary for our purposes [5][11][17].
Reference: [14] <author> J. Rexford, W. Feng, J. Dolter, and K. Shin, </author> <title> PP-MESS-SIM: A Flexible and Extensible Simlator for Evaluationg Multicomputer Networks, </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <month> January </month> <year> 1997, </year> <pages> pp. 2540. </pages>
Reference-contexts: computing a schedule, and we do not expect the difference in absolute cost of generating the schedule between a compiled and an interpreted scheduler to be of importance. 3.3 System Representation Earlier simulation projects, in both parallel and distributed systems, have developed machine/system representations (e.g., K9 [1], Osculant [13], PP-MESS-SIM <ref> [14] </ref>, and Vint [10]). Scheduling systems also typically include abstract system representation, but not necessarily to the level of detail necessary for our purposes [5][11][17]. Therefore, we will devise a system description template that allows us to express system architecture, operating system, installed software, and connectivity, among other characteristics.
Reference: [15] <author> V. Sarkar, </author> <title> Partitioning and Scheduling Parallel Programs for Multiprocessors, </title> <publisher> The MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Development We will now describe each module in greater detail, and examine related work from which we can build. 3.1 Task Representation and Benchmark Suite There has already been extensive work in program representation in the areas of compiler implementation [9], runtime system development [7][9], and partitioning and scheduling algorithms <ref> [15] </ref>. In most cases, programs are represented as described earlier, with weighted nodes (computation) and edges (dependencies). We will start with the Legion graph representation, and augment it so that nodes can contain estimates of execution time on a variety of architectures and operating systems.
Reference: [16] <author> M. Singhal and N. G. Shivaratri, </author> <title> Advanced Concepts in Operating Systems , McGraw Hill, </title> <note> 1994, ISBN 0-07-13668-1. </note>
Reference-contexts: This will include facilities for obtaining state information for the underlying system and the task suite to be scheduled, as well as expressing various portions of a scheduling policy (the transfer, location, selection, and information policies <ref> [16] </ref>). This will be flexible enough to implement all classes of scheduling algorithms from the existing literature, and will be extensible so as to accommodate future algorithms.
Reference: [17] <author> S. Zhou, X. Zheng, J. Wang, and P. Delisle, </author> <title> Utopia: A Load Sharing Facility for Large, </title> <booktitle> Heterogeneous Distributed Computer Systems, SoftwarePractice & Experience , 23(12), </booktitle> <year> 1993, </year> <pages> pp. 13051336. </pages>
References-found: 17

