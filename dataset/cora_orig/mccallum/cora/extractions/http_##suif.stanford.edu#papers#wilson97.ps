URL: http://suif.stanford.edu/papers/wilson97.ps
Refering-URL: http://suif.stanford.edu/papers/papers.html
Root-URL: 
Title: EFFICIENT, CONTEXT-SENSITIVE POINTER ANALYSIS FOR C PROGRAMS  
Author: Robert Paul Wilson 
Degree: A DISSERTATION SUBMITTED TO THE DEPARTMENT OF ELECTRICAL ENGINEERING AND THE COMMITTEE ON GRADUATE STUDIES OF STANFORD UNIVERSITY IN PARTIAL FULFILLMENT OF THE REQUIREMENTS FOR THE DEGREE OF DOCTOR OF PHILOSOPHY By  
Date: December 1997  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Bowen Alpern, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Detecting equality of variables in programs. </title> <booktitle> In Proceedings of the 15th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 111, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: That restriction is only for additional assigned locations. If another context has fewer assigned locations, the PTF may still be applicable. 2.7.2 Static Single Assignment Form Our representation uses the static single assignment (SSA) form of a procedure <ref> [1, 11, 34] </ref>. In SSA form, each variable can be assigned at only one point in the procedure. That implies that for each use of a value there is a unique assignment.
Reference: [2] <author> S. P. Amarasinghe, J. M. Anderson, C. S. Wilson, S.-W. Liao, B. M. Murphy, R. S. French, M. S. Lam, and M. W. Hall. </author> <title> Multiprocessors from a software perspective. </title> <booktitle> IEEE Micro, </booktitle> <pages> pages 5261, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: This is true for both ILP and higher levels of parallelism. Fortran compilers routinely use techniques such as software pipelining to take advantage of ILP. Likewise, automatic parallelization technology for Fortran programs has progressed to the point where it can be used to obtain large speedups on multiprocessors <ref> [2] </ref>. To do the same for C programs will require pointer analysis. Arrays are the primary data structures in numeric programs, and C programs often use pointers to access arrays. Pointer analysis is necessary to enable the array dependence analysis that is the key to exposing parallelism. <p> The SUIF compiler includes an automatic parallelizer for Fortran programs, and that parallelizer has been extended to handle some numeric programs written in C <ref> [2] </ref>. The SUIF parallelizer uses array data dependence analysis to determine whether the different iterations of a loop may access the same array elements and whether a loop is parallelizable. For C programs, where arrays are typically accessed via pointers, data dependence analysis requires pointer aliasing information.
Reference: [3] <author> Lars Ole Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: A CLASSIFICATION OF POINTER ANALYSES 175 sets such that each set can point to only one other set. The sets are unified as necessary to preserve that property. Earlier work by Andersen did not include that restriction <ref> [3] </ref>. In Andersen's analysis, each variable is treated separately and may point to an arbitrary number of other variables. That causes Andersen's analysis to run much more slowly than Steensgaard's for large input programs.
Reference: [4] <author> Michael Burke, Paul Carini, Jong-Deok Choi, and Michael Hind. </author> <title> Flow-insensitive interprocedural alias analysis in the presence of pointers. </title> <editor> In K. Pingali, U. Banerjee, D. Gelernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 892, </volume> <pages> pages 234250. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <title> Proceedings from the 7th International Workshop on Languages and Compilers for Parallel Computing. </title> <note> Extended version published as Research Report RC-19546, </note> <institution> IBM T. J. Watson Research Center, Septem-ber, </institution> <year> 1994. </year>
Reference-contexts: Software engineering techniques such as program slicing need pointer analysis as well. 1.2 Background Pointer analysis algorithms can use a variety of basic analysis techniques. Simple intrapro-cedural analyses run quickly but only provide crude estimations of pointer values. For that reason, most pointer analyses are interprocedural. Flow-insensitive analyses <ref> [4, 37, 42, 43] </ref> are efficient because they do not take into account the control flow within procedures. We focus on flow-sensitive analyses because of their potential for better accuracy. <p> However, because they do not take in-traprocedural control flow into account, flow-insensitive analyses are fundamentally less accurate than flow-sensitive ones. Burke et al. have developed a flow-insensitive pointer analysis that uses a fairly traditional interprocedural data-flow approach <ref> [4] </ref>. They alternately iterate over the program call graph and the flow graphs for individual procedures until the solution converges. They do not include any experimental results, so it is not clear how well their algorithm works. More recently, several flow-insensitive analyses based on constraint solving have been developed.
Reference: [5] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the ACM SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The most straightforward approach to interprocedural analysis is to simply extend traditional intraprocedural techniques to analyze an entire program at once. This approach has been used for pointer analysis as well as for other kinds of problems <ref> [5, 12] </ref>. The essential idea is to combine the control flow graphs for the individual procedures into a single graph for the entire program. This program flow graph contains new edges to represent procedure calls and returns. <p> REPRESENTATION OF POINTER INFORMATION Naming by Allocation Context Our first heuristic is grouping heap storage by allocation context. This approach has been widely used in other pointer analysis algorithms <ref> [5, 21, 35] </ref> and it also works well for our analysis. In most of the previous work, the allocation context is identified by the statement that calls the allocation routine. <p> The values for overlapping location sets must then be combined when using the points-to information. The basic design of our points-to representation is derived from the sparse representation described by Chase et al. <ref> [5] </ref>. Our design is asymptotically less efficient, but it is slightly easier to implement and includes the ability to handle overlapping location sets. <p> They report that their analysis is often much more accurate than Steensgaard's approach and much faster than Andersen's algorithm. However, in practice their analysis is still about an order of magnitude slower than Steensgaard's. 7.1.3 Flow-Sensitive Analyses Many different flow-sensitive pointer analyses have been developed in the last decade <ref> [5, 6, 14, 21, 25, 28, 35] </ref>. The earlier analyses typically handled interprocedural analysis by simply combining the control flow graphs of individual procedures. Thus, they suffered from the unrealizable paths problem [25]. The more recent analyses address context sensitivity in various ways. <p> A totally different approach is a storeless analysis that uses some other mechanism to ensure that the solution is finite. For a store-based analysis, the abstract store may be represented by points-to functions [14] or by directed graphs <ref> [5, 19, 21, 22, 28] </ref>. These representations are equivalent. An alternative is to identify aliases in the abstract store by pairs of access paths [6]. Alias pairs provide similar information to points-to functions, with only a few minor differences [30].
Reference: [6] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interpro-cedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Proceedings of 191 192 BIBLIOGRAPHY the 20th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232245, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Flow-insensitive analyses [4, 37, 42, 43] are efficient because they do not take into account the control flow within procedures. We focus on flow-sensitive analyses because of their potential for better accuracy. Some previous analyses are also context-sensitive: to varying degrees, they avoid combining information from different calling contexts <ref> [6, 14, 25, 35] </ref>. Section 1.4 discusses context sensitivity in more detail. Another area where pointer analyses differ widely is their treatment of recursive data 4 CHAPTER 1. INTRODUCTION structures. Because the amount of heap storage used in recursive data structures in unbounded, some finite approximation is essential. <p> In this work, we are only concerned with interprocedural context sensitivity. Within each procedure, our analysis computes the meet-over-all-paths solution by combining information at the join nodes in the flow graph. Choi et al. have proposed keeping track of the intraprocedural path from which information originates <ref> [6] </ref>, but the costs and benefits of that are unclear. For interprocedural context sensitivity, the issue is distinguishing information that propagates from different calling contexts of a procedure. 1.4. CONTEXT-SENSITIVE INTERPROCEDURAL ANALYSIS 13 1.4.1 Unrealizable Paths Interprocedural context sensitivity is important because without it information propagates along unrealizable paths [25]. <p> This approach has been used recently for several pointer analysis algorithms. Landi and Ryder tag values with information about aliases that hold in the calling contexts [25]. Choi et al. use tags that include both a set of aliases and the most recent call site <ref> [6] </ref>. Tagging flow values addresses the problem of accuracy but it makes the analysis even slower. The state within a procedure will include values with tags from all the different calling contexts. That may significantly increase the number of values to be propagated and evaluated. <p> This approach has been widely used in other pointer analysis algorithms [5, 21, 35] and it also works well for our analysis. In most of the previous work, the allocation context is identified by the statement that calls the allocation routine. Following the work of Choi et al. <ref> [6] </ref>, we extend the allocation context to include not just the static allocation site but also a path through the call multigraph. That extension handles cases where the source program includes wrapper functions around the standard allocation routines. <p> They report that their analysis is often much more accurate than Steensgaard's approach and much faster than Andersen's algorithm. However, in practice their analysis is still about an order of magnitude slower than Steensgaard's. 7.1.3 Flow-Sensitive Analyses Many different flow-sensitive pointer analyses have been developed in the last decade <ref> [5, 6, 14, 21, 25, 28, 35] </ref>. The earlier analyses typically handled interprocedural analysis by simply combining the control flow graphs of individual procedures. Thus, they suffered from the unrealizable paths problem [25]. The more recent analyses address context sensitivity in various ways. <p> A CLASSIFICATION OF POINTER ANALYSES 177 for every data-flow value. Choi et al. also developed an alias analysis that uses tags to distinguish values that apply to different calling contexts <ref> [6] </ref>. Their tags consist of both the static call site and a set of source aliases. The source aliases are similar to the reaching aliases used by Landi and Ryder. Choi et al. claim that their algorithm has better worst-case time complexity than Landi and Ryder's algorithm. <p> For a store-based analysis, the abstract store may be represented by points-to functions [14] or by directed graphs [5, 19, 21, 22, 28]. These representations are equivalent. An alternative is to identify aliases in the abstract store by pairs of access paths <ref> [6] </ref>. Alias pairs provide similar information to points-to functions, with only a few minor differences [30]. Even though we represent the abstract store with points-to functions, alias information can be derived by comparing the sets of possible pointer values.
Reference: [7] <author> Patrick Cousot and Radhia Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Proceedings of the 4th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238252, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: The analysis can then detect that p0 represents a previous instance of itself shifted by h4; 0i, and it can widen the location sets to force the solution to converge. 2.6 The Lattice of Points-to Functions Data-flow frameworks [23] and abstract interpretation <ref> [7, 8] </ref> both use lattices to describe the values computed by an analysis and the ways in which those values evolve during the analysis. In this section, we describe the meet semilattice of points-to functions used by our analysis. <p> To ensure that our analysis will terminate, we need to include a widening operation at certain join nodes. A widening accelerates the convergence of an infinite series of values so that it will reach a fixpoint in a finite number of iterations <ref> [7] </ref>. Our lattice has infinite descending chains because of the unlimited possibilities for location sets.
Reference: [8] <author> Patrick Cousot and Radhia Cousot. </author> <title> Systematic design of program analysis frameworks. </title> <booktitle> In Proceedings of the 6th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 269282, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: The analysis can then detect that p0 represents a previous instance of itself shifted by h4; 0i, and it can widen the location sets to force the solution to converge. 2.6 The Lattice of Points-to Functions Data-flow frameworks [23] and abstract interpretation <ref> [7, 8] </ref> both use lattices to describe the values computed by an analysis and the ways in which those values evolve during the analysis. In this section, we describe the meet semilattice of points-to functions used by our analysis.
Reference: [9] <author> Ron Cytron and Jeanne Ferrante. </author> <title> Efficiently computing -nodes on-the-fly. </title> <booktitle> In Proceedings of the 6th Annual Workshop on Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: A number of algorithms have been proposed to determine how to place the minimal number of -functions to transform a procedure to SSA form <ref> [9, 33, 34, 41] </ref>. One relatively simple approach is based on iterated dominance frontiers [10, 11]. For an assignment to a 2.7.
Reference: [10] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> An efficient method of computing static single assignment form. </title> <booktitle> In Proceedings of the 16th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 2535, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: A number of algorithms have been proposed to determine how to place the minimal number of -functions to transform a procedure to SSA form [9, 33, 34, 41]. One relatively simple approach is based on iterated dominance frontiers <ref> [10, 11] </ref>. For an assignment to a 2.7. SPARSE POINTS-TO REPRESENTATION 75 variable v in a control flow graph node n, -functions for v must be placed at every node in the iterated dominance frontier of n. Once the -functions have been placed, it is easy to rename the variables.
Reference: [11] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently computing static single assignment form and control dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4):452490, </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: That restriction is only for additional assigned locations. If another context has fewer assigned locations, the PTF may still be applicable. 2.7.2 Static Single Assignment Form Our representation uses the static single assignment (SSA) form of a procedure <ref> [1, 11, 34] </ref>. In SSA form, each variable can be assigned at only one point in the procedure. That implies that for each use of a value there is a unique assignment. <p> A number of algorithms have been proposed to determine how to place the minimal number of -functions to transform a procedure to SSA form [9, 33, 34, 41]. One relatively simple approach is based on iterated dominance frontiers <ref> [10, 11] </ref>. For an assignment to a 2.7. SPARSE POINTS-TO REPRESENTATION 75 variable v in a control flow graph node n, -functions for v must be placed at every node in the iterated dominance frontier of n. Once the -functions have been placed, it is easy to rename the variables.
Reference: [12] <author> Alain Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In Proceedings of the ACM SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 230241, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Some other analyses target numeric programs and focus on single-level pointers [29]. At the high end, some analyses distinguish individual elements of recursive data structures and identify the overall data structure shapes, e.g., lists, trees and DAGs <ref> [12, 16, 36] </ref>. These shape analyses provide detailed pointer information at the expense of analysis time. We take an intermediate approach. <p> The most straightforward approach to interprocedural analysis is to simply extend traditional intraprocedural techniques to analyze an entire program at once. This approach has been used for pointer analysis as well as for other kinds of problems <ref> [5, 12] </ref>. The essential idea is to combine the control flow graphs for the individual procedures into a single graph for the entire program. This program flow graph contains new edges to represent procedure calls and returns. <p> INTRODUCTION structures. Deutsch defined the basis of a recursive data type as the minimal set B of access paths that lead from that type back to itself such that B fl includes all such paths <ref> [12] </ref>. Likewise, we define the basis set for a procedure in a recursive cycle as the minimal set of call paths that lead from that procedure back to itself. <p> More sophisticated solutions are certainly possible. 2.5. BOUNDING THE ABSTRACT STORES 63 2.5 Bounding the Abstract Stores To ensure that our analysis terminates, we must guarantee that each PTF has a finite abstract store. Previous analyses have relied on type information to detect recursive data structures and guarantee termination <ref> [12, 13] </ref>. For example, Deutsch identifies storage using symbolic access paths with finite approximations for the bases of recursive data structures [12]. Relying on type information does not work for some C programs. Instead, we have developed an alternative approach. There are two problems that we must address. <p> Previous analyses have relied on type information to detect recursive data structures and guarantee termination [12, 13]. For example, Deutsch identifies storage using symbolic access paths with finite approximations for the bases of recursive data structures <ref> [12] </ref>. Relying on type information does not work for some C programs. Instead, we have developed an alternative approach. There are two problems that we must address. <p> Some of the flow-sensitive pointer analyses cited in the previous section included some aspects of shape analysis. Hendren and Nicolau developed one of the first analyses that specifically addressed the problem of shape analysis [20]. Deutsch developed a general analysis based on symbolic access paths <ref> [12] </ref>. His work contains the basic framework for a number of different analyses. It is parameterized by a numeric lattice, so that the complexity and precision of the analysis can be tailored to the requirements of a particular application. <p> To explain how our points-to functions relate to other representations, it is helpful to classify analyses into two broad categories <ref> [12] </ref>. Store-based analyses like ours use an abstract store to model the real program memory. The essential feature of an store-based analysis is a finite set of names for memory locations. <p> The traditional technique of k-limiting [22] bounds the lengths of the access paths to some fixed constant. A more powerful solution is to use access paths containing symbolic values <ref> [12] </ref>. Storeless analyses work better than abstract stores when trying to distinguish elements of recursive data structures, especially if they do not rely on k-limiting. Since our algorithm is not designed to distinguish elements within a recursive data structure, a store-based approach is sufficient. 180 CHAPTER 7. <p> the alternative forms of parameterization and compares them to our solution. 7.3.1 Nonvisible Variables in Storeless Analyses In the context of storeless analyses that compute alias pairs, a number of people have noted that a procedure operates uniformly upon objects that are not visible within the scope of that procedure <ref> [12, 25, 31] </ref>. Special nonvisible variables can then be used to represent those objects. These nonvisible variables can represent different objects in different calling contexts and are thus a form of parameter. <p> Instead of our approach that keeps the number of blocks finite, the access paths themselves can be abstracted to a finite approximation. Deutsch has defined a finite abstraction of access paths that is more expressive than simple abstractions based on k-limiting <ref> [12] </ref>. As described earlier, he defines the basis of a recursive data type as the minimal set B of access paths that lead from that type back to itself such that B fl includes all such paths.
Reference: [13] <author> Maryam Emami. </author> <title> A practical interprocedural alias analysis for an optimizing / paral-lelizing c compiler. </title> <type> Master's thesis, </type> <institution> School of Computer Science, McGill University, </institution> <month> August </month> <year> 1993. </year> <note> BIBLIOGRAPHY 193 </note>
Reference-contexts: More sophisticated solutions are certainly possible. 2.5. BOUNDING THE ABSTRACT STORES 63 2.5 Bounding the Abstract Stores To ensure that our analysis terminates, we must guarantee that each PTF has a finite abstract store. Previous analyses have relied on type information to detect recursive data structures and guarantee termination <ref> [12, 13] </ref>. For example, Deutsch identifies storage using symbolic access paths with finite approximations for the bases of recursive data structures [12]. Relying on type information does not work for some C programs. Instead, we have developed an alternative approach. There are two problems that we must address. <p> They could use the unparame-terized values with no loss of accuracy. According to Emami, their motivation for using parameters was to allow the same results to be used in multiple calling contexts, just as we use PTFs <ref> [13] </ref>. Recently in fact, Gagnon and Hendren modified Emami's algorithm to construct the invocation graphs lazily, reusing existing results whenever they are applicable [15]. They were often able to significantly reduce the sizes of the invocation graphs with that approach. <p> They refer to them as invisible variables <ref> [13, 14] </ref>. They do not need parameters for heap storage because they analyze only stack locations. As in Landi and Ryder's algorithm, they do not parameterize references to global variables.
Reference: [14] <author> Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. </author> <title> Context-sensitive interpro-cedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the ACM SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242256, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: On the other hand, many previous analyses provide more accurate, flow-sensitive results but can only handle small benchmark programs. The largest program analyzed by Landi et al. contained only 4,663 lines of code [26], and the largest program analyzed by Emami et al. was only 2,279 lines <ref> [14] </ref>. One reason for this limitation of the more accurate analyses is that they are too slow; another reason is that they rely on strong typing and do not apply to C programs where type information is unreliable. <p> Flow-insensitive analyses [4, 37, 42, 43] are efficient because they do not take into account the control flow within procedures. We focus on flow-sensitive analyses because of their potential for better accuracy. Some previous analyses are also context-sensitive: to varying degrees, they avoid combining information from different calling contexts <ref> [6, 14, 25, 35] </ref>. Section 1.4 discusses context sensitivity in more detail. Another area where pointer analyses differ widely is their treatment of recursive data 4 CHAPTER 1. INTRODUCTION structures. Because the amount of heap storage used in recursive data structures in unbounded, some finite approximation is essential. <p> INTRODUCTION structures. Because the amount of heap storage used in recursive data structures in unbounded, some finite approximation is essential. At the low end of the spectrum, an analysis can treat the entire heap as a single monolithic entity <ref> [14] </ref>. Some other analyses target numeric programs and focus on single-level pointers [29]. At the high end, some analyses distinguish individual elements of recursive data structures and identify the overall data structure shapes, e.g., lists, trees and DAGs [12, 16, 36]. <p> The edges from node p to nodes x and y indicate that p may contain a pointer to either x or y. Points-to functions and directed graphs are equivalent and we use them interchangeably. Some analyses distinguish definite information from possible information <ref> [14, 27] </ref>. For example, besides recording the values that a pointer may contain, the abstract store can also keep track of pointers that must have certain values. At the end of the code in Figure 1.2, for example, q must point to y. <p> For example, when a location is dereferenced, we can assume that it always contains a pointer value, since otherwise the program would be erroneous. Thus, when evaluating dereferences using this assumption, may-point-to information is just as good as must-point-to information. Must-point-to analysis does provide better accuracy in other situations <ref> [14] </ref>, but we only consider may-point-to analysis in this work. Many applications of pointer analysis require information about aliasing rather than points-to information. Given the points-to values for a pair of memory references, it is straightforward to determine if they may be aliased. <p> There is some issue as to whether this computation of aliases is efficient. Computing each set intersection requires O (N 2 ) time where N is the number of possible pointer values. Most pointers have a small number of potential values <ref> [14] </ref> so this is unlikely to be significant for typical programs. 1.3. CHALLENGES OF POINTER ANALYSIS 7 1.3 Challenges of Pointer Analysis Pointer analysis is a challenging problem for a number of reasons. Some of them are inherent to the problem and some arise only when analyzing C programs. <p> The only fundamental cause for approximation in the call paths is recursion. For a nonrecursive program, an analysis can explicitly enumerate all the call paths leading up to each procedure. Emami et al. take that approach in their pointer analysis <ref> [14] </ref>. They define an invocation graph that contains a separate node for every calling context of each nonrecursive procedure. For recursive programs, some approximation is essential. <p> The restriction that we make is the same one used in Emami et al.'s invocation graphs <ref> [14] </ref>. At no point do we allow more than one PTF for the same recursive procedure on the call stack of the analysis. <p> This allows users to select the version that works best for a particular program. To compare our analysis with the one developed by Emami et al. <ref> [14] </ref>, the last two columns of Table 6.2 show the number of procedures in each program and the number of nodes in their invocation graphs. We do not count library routines in either column. <p> Presumably each pointer used in an indirect reference has at least one value; if we count only one value for a particular reference, the results are as good as they can get. Some previous work on pointer analysis has used similar metrics to evaluate accuracy <ref> [14, 35] </ref>. Because the results of our analysis are expressed in terms of extended parameters, counting pointer values is not entirely straightforward. We cannot simply count the extended parameters referenced by a pointer. <p> They report that their analysis is often much more accurate than Steensgaard's approach and much faster than Andersen's algorithm. However, in practice their analysis is still about an order of magnitude slower than Steensgaard's. 7.1.3 Flow-Sensitive Analyses Many different flow-sensitive pointer analyses have been developed in the last decade <ref> [5, 6, 14, 21, 25, 28, 35] </ref>. The earlier analyses typically handled interprocedural analysis by simply combining the control flow graphs of individual procedures. Thus, they suffered from the unrealizable paths problem [25]. The more recent analyses address context sensitivity in various ways. <p> Invocation Graphs Another way to improve context sensitivity is to compute separate results for every calling context, whether the various calling contexts of a procedure have different inputs or not. Emami et al. build an invocation graph that contains a separate node for every calling context of every procedure <ref> [14] </ref>. As in our analysis, they combine calling contexts that differ only in the number of iterations around recursive cycles. Their analysis then computes a separate result for each invocation graph node. Emami et al.'s analysis has some important differences from ours. <p> The essential feature of an store-based analysis is a finite set of names for memory locations. A totally different approach is a storeless analysis that uses some other mechanism to ensure that the solution is finite. For a store-based analysis, the abstract store may be represented by points-to functions <ref> [14] </ref> or by directed graphs [5, 19, 21, 22, 28]. These representations are equivalent. An alternative is to identify aliases in the abstract store by pairs of access paths [6]. Alias pairs provide similar information to points-to functions, with only a few minor differences [30]. <p> They refer to them as invisible variables <ref> [13, 14] </ref>. They do not need parameters for heap storage because they analyze only stack locations. As in Landi and Ryder's algorithm, they do not parameterize references to global variables.
Reference: [15] <author> Etienne Gagnon. </author> <title> Fast-forward and lazy points-to analysis. report for Advanced Compilers course at McGill University. </title>
Reference-contexts: ANALYZING ACROSS PROCEDURES change. It is not sufficient to simply compare a calling context against the domain specification of a recursive PTF. Besides the items recorded in the domain specification, a recursive PTF is also affected by the summaries used for recursive calls <ref> [15] </ref>. The contents of those summaries may change across iterations. Since we do not record the complete contents of those summaries in the domain specifications (nor would that be a good solution), we must revisit all the PTFs in a cycle even when the calling contexts match their domains. <p> According to Emami, their motivation for using parameters was to allow the same results to be used in multiple calling contexts, just as we use PTFs [13]. Recently in fact, Gagnon and Hendren modified Emami's algorithm to construct the invocation graphs lazily, reusing existing results whenever they are applicable <ref> [15] </ref>. They were often able to significantly reduce the sizes of the invocation graphs with that approach.
Reference: [16] <author> Rakesh Ghiya and Laurie J. Hendren. </author> <title> Is it a tree, a DAG, or a cyclic graph? a shape analysis for heap-directed pointers in C. </title> <booktitle> In Proceedings of the 23th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 115, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Some other analyses target numeric programs and focus on single-level pointers [29]. At the high end, some analyses distinguish individual elements of recursive data structures and identify the overall data structure shapes, e.g., lists, trees and DAGs <ref> [12, 16, 36] </ref>. These shape analyses provide detailed pointer information at the expense of analysis time. We take an intermediate approach. <p> They attempt to analyze only pointers to stack-allocated variables. The heap is treated as a single monolithic entity, with the intent that a separate analysis <ref> [16] </ref> will be used to identify heap data structures. For many programs, stack-allocated variables 178 CHAPTER 7. RELATED WORK are rarely aliased, so that analyzing them is not nearly as challenging as analyzing pointers to the heap. <p> Most recently, Sagiv et al. have published a shape analysis that focuses on handling destructive (strong) updates [36]. Ghiya and Hendren have recently published a shape analysis designed to complement Emami et al.'s pointer analysis <ref> [16] </ref>. Because their analysis uses invocation graphs, it is context-sensitive. Other 7.2. REPRESENTATIONS OF POINTER INFORMATION 179 shape analysis algorithms could potentially be extended to provide some context sensitivity by tagging the flow values, but none of them appear to have implemented that extension.
Reference: [17] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Arithmetic expressions may, for example, include values that can be known only at run time. The ability to have a pointer pointing into the middle of an object in memory is troublesome, particularly when combined with pointer arithmetic. In some other languages like Java <ref> [17] </ref>, pointers may reference only the beginning of an object. Two pointers must either reference the same object or reference completely different objects. For C programs, we must also consider the case where the two pointers reference different locations within a contiguous block of memory.
Reference: [18] <author> M. W. Hall. </author> <title> Managing Interprocedural Optimization. </title> <type> PhD thesis, </type> <institution> Rice University, Dept. of Computer Science, Houston, TX, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: Some other analyses are polyvariant, computing different results for a procedure under certain conditions. This is related to the technique of procedure cloning <ref> [18] </ref>. The decision to clone a procedure is, however, independent from 18 CHAPTER 1. INTRODUCTION the decision to compute multiple results within an analysis.
Reference: [19] <author> W. Ludwell Harrison III. </author> <title> The interprocedural analysis and automatic parallelization of Scheme programs. Lisp and Symbolic Computation, </title> <address> 2(3):176396, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: A totally different approach is a storeless analysis that uses some other mechanism to ensure that the solution is finite. For a store-based analysis, the abstract store may be represented by points-to functions [14] or by directed graphs <ref> [5, 19, 21, 22, 28] </ref>. These representations are equivalent. An alternative is to identify aliases in the abstract store by pairs of access paths [6]. Alias pairs provide similar information to points-to functions, with only a few minor differences [30].
Reference: [20] <author> Laurie J. Hendren and Alexandru Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1):3547, </volume> <month> January </month> <year> 1990. </year>
Reference-contexts: Some of the flow-sensitive pointer analyses cited in the previous section included some aspects of shape analysis. Hendren and Nicolau developed one of the first analyses that specifically addressed the problem of shape analysis <ref> [20] </ref>. Deutsch developed a general analysis based on symbolic access paths [12]. His work contains the basic framework for a number of different analyses. It is parameterized by a numeric lattice, so that the complexity and precision of the analysis can be tailored to the requirements of a particular application.
Reference: [21] <author> Susan Horwitz, Phil Pfeiffer, and Thomas Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of the ACM SIGPLAN'89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 2840, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: REPRESENTATION OF POINTER INFORMATION Naming by Allocation Context Our first heuristic is grouping heap storage by allocation context. This approach has been widely used in other pointer analysis algorithms <ref> [5, 21, 35] </ref> and it also works well for our analysis. In most of the previous work, the allocation context is identified by the statement that calls the allocation routine. <p> They report that their analysis is often much more accurate than Steensgaard's approach and much faster than Andersen's algorithm. However, in practice their analysis is still about an order of magnitude slower than Steensgaard's. 7.1.3 Flow-Sensitive Analyses Many different flow-sensitive pointer analyses have been developed in the last decade <ref> [5, 6, 14, 21, 25, 28, 35] </ref>. The earlier analyses typically handled interprocedural analysis by simply combining the control flow graphs of individual procedures. Thus, they suffered from the unrealizable paths problem [25]. The more recent analyses address context sensitivity in various ways. <p> A totally different approach is a storeless analysis that uses some other mechanism to ensure that the solution is finite. For a store-based analysis, the abstract store may be represented by points-to functions [14] or by directed graphs <ref> [5, 19, 21, 22, 28] </ref>. These representations are equivalent. An alternative is to identify aliases in the abstract store by pairs of access paths [6]. Alias pairs provide similar information to points-to functions, with only a few minor differences [30].
Reference: [22] <author> N. Jones and S. Muchnick. </author> <title> Flow analysis and optimization of Lisp-like structures. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 102131. </pages> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: Our algorithm uses heuristics to identify the elements of a data structure that it should combine. Two kinds of heuristics have been used to combine elements of recursive data structures. First, some analyses impose a fixed limit on the length of an access path. This is known as k-limiting <ref> [22] </ref>. The second approach is to group together all the heap storage allocated in the same context. Our analysis uses this second approach of grouping storage by its allocation context. <p> A totally different approach is a storeless analysis that uses some other mechanism to ensure that the solution is finite. For a store-based analysis, the abstract store may be represented by points-to functions [14] or by directed graphs <ref> [5, 19, 21, 22, 28] </ref>. These representations are equivalent. An alternative is to identify aliases in the abstract store by pairs of access paths [6]. Alias pairs provide similar information to points-to functions, with only a few minor differences [30]. <p> Storeless analyses can also use alias pairs [25], but without a finite set of names for memory locations, they must rely on some other mechanism to bound the size of the solution. The traditional technique of k-limiting <ref> [22] </ref> bounds the lengths of the access paths to some fixed constant. A more powerful solution is to use access paths containing symbolic values [12]. Storeless analyses work better than abstract stores when trying to distinguish elements of recursive data structures, especially if they do not rely on k-limiting.
Reference: [23] <author> J. B. Kam and J. D. Ullman. </author> <title> Monotone data flow analysis frameworks. </title> <journal> Acta Infor-matica, </journal> <note> 7(3):305318, 1977. 194 BIBLIOGRAPHY </note>
Reference-contexts: Including the location sets, the new entry is hp0; 4; 0i. The analysis can then detect that p0 represents a previous instance of itself shifted by h4; 0i, and it can widen the location sets to force the solution to converge. 2.6 The Lattice of Points-to Functions Data-flow frameworks <ref> [23] </ref> and abstract interpretation [7, 8] both use lattices to describe the values computed by an analysis and the ways in which those values evolve during the analysis. In this section, we describe the meet semilattice of points-to functions used by our analysis.
Reference: [24] <author> William Landi. </author> <title> Undecidability of static analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(4):323337, </volume> <month> December </month> <year> 1992. </year>
Reference-contexts: One serious implication of this solution is that inaccuracies often propagate widely. If the aliases and function pointer values are inaccurate, the evaluation of indirect assignments and indirect calls will lead to even more inaccurate results and so on. Because pointer analysis is an undecidable problem <ref> [24] </ref>, some imprecision is inevitable. Even relatively small inaccuracies often propagate and cause much larger inaccuracies. 1.3.2 Interprocedural Analysis Because inaccuracies in aliases and function pointer values propagate so quickly, interpro-cedural analysis is essential for accurate results.
Reference: [25] <author> William Landi and Barbara G. Ryder. </author> <title> A safe approximate algorithm for interpro-cedural pointer aliasing. </title> <booktitle> In Proceedings of the ACM SIGPLAN'92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Flow-insensitive analyses [4, 37, 42, 43] are efficient because they do not take into account the control flow within procedures. We focus on flow-sensitive analyses because of their potential for better accuracy. Some previous analyses are also context-sensitive: to varying degrees, they avoid combining information from different calling contexts <ref> [6, 14, 25, 35] </ref>. Section 1.4 discusses context sensitivity in more detail. Another area where pointer analyses differ widely is their treatment of recursive data 4 CHAPTER 1. INTRODUCTION structures. Because the amount of heap storage used in recursive data structures in unbounded, some finite approximation is essential. <p> For interprocedural context sensitivity, the issue is distinguishing information that propagates from different calling contexts of a procedure. 1.4. CONTEXT-SENSITIVE INTERPROCEDURAL ANALYSIS 13 1.4.1 Unrealizable Paths Interprocedural context sensitivity is important because without it information propagates along unrealizable paths <ref> [25] </ref>. An unrealizable path is one that cannot occur in a real execution of the program. In this case, a path is unrealizable if a procedure is entered from one call site and then returns to a different call site. <p> In general the degree of context sensitivity depends on how the calling contexts are identified in the tag values. This approach has been used recently for several pointer analysis algorithms. Landi and Ryder tag values with information about aliases that hold in the calling contexts <ref> [25] </ref>. Choi et al. use tags that include both a set of aliases and the most recent call site [6]. Tagging flow values addresses the problem of accuracy but it makes the analysis even slower. <p> They report that their analysis is often much more accurate than Steensgaard's approach and much faster than Andersen's algorithm. However, in practice their analysis is still about an order of magnitude slower than Steensgaard's. 7.1.3 Flow-Sensitive Analyses Many different flow-sensitive pointer analyses have been developed in the last decade <ref> [5, 6, 14, 21, 25, 28, 35] </ref>. The earlier analyses typically handled interprocedural analysis by simply combining the control flow graphs of individual procedures. Thus, they suffered from the unrealizable paths problem [25]. The more recent analyses address context sensitivity in various ways. <p> The earlier analyses typically handled interprocedural analysis by simply combining the control flow graphs of individual procedures. Thus, they suffered from the unrealizable paths problem <ref> [25] </ref>. The more recent analyses address context sensitivity in various ways. Tagging Values with Context Information Landi and Ryder tag the data-flow values with reaching aliases 1 to distinguish values from different calling contexts [25]. <p> Thus, they suffered from the unrealizable paths problem <ref> [25] </ref>. The more recent analyses address context sensitivity in various ways. Tagging Values with Context Information Landi and Ryder tag the data-flow values with reaching aliases 1 to distinguish values from different calling contexts [25]. If a particular alias occurs only when certain other aliases hold in the calling context, those other aliases constitute the reaching alias set for that particular alias. However, Landi and Ryder did not actually use that general form of reaching 1 The tag values were originally called assumed aliases. <p> Alias pairs provide similar information to points-to functions, with only a few minor differences [30]. Even though we represent the abstract store with points-to functions, alias information can be derived by comparing the sets of possible pointer values. Storeless analyses can also use alias pairs <ref> [25] </ref>, but without a finite set of names for memory locations, they must rely on some other mechanism to bound the size of the solution. The traditional technique of k-limiting [22] bounds the lengths of the access paths to some fixed constant. <p> the alternative forms of parameterization and compares them to our solution. 7.3.1 Nonvisible Variables in Storeless Analyses In the context of storeless analyses that compute alias pairs, a number of people have noted that a procedure operates uniformly upon objects that are not visible within the scope of that procedure <ref> [12, 25, 31] </ref>. Special nonvisible variables can then be used to represent those objects. These nonvisible variables can represent different objects in different calling contexts and are thus a form of parameter.
Reference: [26] <author> William Landi, Barbara G. Ryder, and Sean Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of the ACM SIGPLAN'93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 5667, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: On the other hand, many previous analyses provide more accurate, flow-sensitive results but can only handle small benchmark programs. The largest program analyzed by Landi et al. contained only 4,663 lines of code <ref> [26] </ref>, and the largest program analyzed by Emami et al. was only 2,279 lines [14]. <p> However, Landi and Ryder did not actually use that general form of reaching 1 The tag values were originally called assumed aliases. They were later renamed to reaching aliases <ref> [26] </ref>. 176 CHAPTER 7. RELATED WORK aliases. Instead, they limit each reaching alias set to contain at most one alias. If an alias is dependent on multiple reaching aliases, they arbitrarily select one to use as the tag value. <p> Their experimental results for a number of small programs, ranging from 188 to 4,663 lines of code, show that the analysis runs in anywhere from a fraction of a second to slightly less than a minute and a half <ref> [26] </ref>. Landi and Ryder's algorithm is different from ours in several ways. They compute and record only the reaching aliases that occur in the program, but they do not attempt to determine which of those reaching aliases are relevant.
Reference: [27] <author> William A. Landi. </author> <title> Interprocedural Aliasing in the Presence of Pointers. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: The edges from node p to nodes x and y indicate that p may contain a pointer to either x or y. Points-to functions and directed graphs are equivalent and we use them interchangeably. Some analyses distinguish definite information from possible information <ref> [14, 27] </ref>. For example, besides recording the values that a pointer may contain, the abstract store can also keep track of pointers that must have certain values. At the end of the code in Figure 1.2, for example, q must point to y.
Reference: [28] <author> James R. Larus and Paul N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of the ACM SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 2134, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: They report that their analysis is often much more accurate than Steensgaard's approach and much faster than Andersen's algorithm. However, in practice their analysis is still about an order of magnitude slower than Steensgaard's. 7.1.3 Flow-Sensitive Analyses Many different flow-sensitive pointer analyses have been developed in the last decade <ref> [5, 6, 14, 21, 25, 28, 35] </ref>. The earlier analyses typically handled interprocedural analysis by simply combining the control flow graphs of individual procedures. Thus, they suffered from the unrealizable paths problem [25]. The more recent analyses address context sensitivity in various ways. <p> A totally different approach is a storeless analysis that uses some other mechanism to ensure that the solution is finite. For a store-based analysis, the abstract store may be represented by points-to functions [14] or by directed graphs <ref> [5, 19, 21, 22, 28] </ref>. These representations are equivalent. An alternative is to identify aliases in the abstract store by pairs of access paths [6]. Alias pairs provide similar information to points-to functions, with only a few minor differences [30].
Reference: [29] <author> Jon Loeliger, Robert Metzger, Mark Seligman, and Sean Stroud. </author> <title> Pointer target trackingan empirical study. </title> <booktitle> In Proceedings of Supercomputing '91, </booktitle> <pages> pages 1421. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> November </month> <year> 1991. </year>
Reference-contexts: Because the amount of heap storage used in recursive data structures in unbounded, some finite approximation is essential. At the low end of the spectrum, an analysis can treat the entire heap as a single monolithic entity [14]. Some other analyses target numeric programs and focus on single-level pointers <ref> [29] </ref>. At the high end, some analyses distinguish individual elements of recursive data structures and identify the overall data structure shapes, e.g., lists, trees and DAGs [12, 16, 36]. These shape analyses provide detailed pointer information at the expense of analysis time. We take an intermediate approach. <p> RELATED WORK (published algorithms labeled by first author) * Single-level pointers only. This works well for numeric programs where pointers are used only to reference arrays. Data structures with more than one level of pointer references cannot be accurately analyzed. The Convex compiler uses this approach <ref> [29] </ref>. * Combining the elements within a single data structure. The analysis typically combines elements based on their allocation contexts (as in our algorithm), by limiting the length of access paths to some fixed constant (k-limiting), or by some combination of these two techniques. <p> Loeliger et al. have described the pointer analysis used in the Convex compiler <ref> [29] </ref>. They support both a simple intraprocedural analysis, as described above, and an interpro-cedural version. Their analysis is targeted toward numeric programs and handles only single-level pointers. They do not attempt to analyze pointer dereferences or arrays of pointers.
Reference: [30] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. D. Choi, M. G. Burke, and P. Carini. </author> <title> Pointer-induced aliasing: A clarification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(9):6770, </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: These representations are equivalent. An alternative is to identify aliases in the abstract store by pairs of access paths [6]. Alias pairs provide similar information to points-to functions, with only a few minor differences <ref> [30] </ref>. Even though we represent the abstract store with points-to functions, alias information can be derived by comparing the sets of possible pointer values.
Reference: [31] <author> T. J. Marlowe and B. G. Ryder. </author> <title> Hybrid incremental alias algorithms. </title> <type> Technical Report LCSR-TR-129, </type> <institution> Rutgers University, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: the alternative forms of parameterization and compares them to our solution. 7.3.1 Nonvisible Variables in Storeless Analyses In the context of storeless analyses that compute alias pairs, a number of people have noted that a procedure operates uniformly upon objects that are not visible within the scope of that procedure <ref> [12, 25, 31] </ref>. Special nonvisible variables can then be used to represent those objects. These nonvisible variables can represent different objects in different calling contexts and are thus a form of parameter.
Reference: [32] <author> J. Palsberg and M. I. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proceedings of the OOPSLA'91 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 146161, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: For example, Sharir and Pnueli described the abstraction of call strings [38]. Shivers defined the simple nCFA approach that distinguishes contexts based on the n most recent call sites [39], and others have used that same approach <ref> [32, 44] </ref>. The only fundamental cause for approximation in the call paths is recursion. For a nonrecursive program, an analysis can explicitly enumerate all the call paths leading up to each procedure. Emami et al. take that approach in their pointer analysis [14].
Reference: [33] <author> J. H. Reif and R. E. Tarjan. </author> <title> Symbolic program analysis in almost linear time. </title> <journal> SIAM Journal of Computing, </journal> <volume> 11(1):8193, </volume> <month> February </month> <year> 1982. </year> <note> BIBLIOGRAPHY 195 </note>
Reference-contexts: A number of algorithms have been proposed to determine how to place the minimal number of -functions to transform a procedure to SSA form <ref> [9, 33, 34, 41] </ref>. One relatively simple approach is based on iterated dominance frontiers [10, 11]. For an assignment to a 2.7.
Reference: [34] <author> Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Global value numbers and redundant computations. </title> <booktitle> In Proceedings of the 15th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1227, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: That restriction is only for additional assigned locations. If another context has fewer assigned locations, the PTF may still be applicable. 2.7.2 Static Single Assignment Form Our representation uses the static single assignment (SSA) form of a procedure <ref> [1, 11, 34] </ref>. In SSA form, each variable can be assigned at only one point in the procedure. That implies that for each use of a value there is a unique assignment. <p> A number of algorithms have been proposed to determine how to place the minimal number of -functions to transform a procedure to SSA form <ref> [9, 33, 34, 41] </ref>. One relatively simple approach is based on iterated dominance frontiers [10, 11]. For an assignment to a 2.7.
Reference: [35] <author> Erik Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of the ACM SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1322, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Flow-insensitive analyses [4, 37, 42, 43] are efficient because they do not take into account the control flow within procedures. We focus on flow-sensitive analyses because of their potential for better accuracy. Some previous analyses are also context-sensitive: to varying degrees, they avoid combining information from different calling contexts <ref> [6, 14, 25, 35] </ref>. Section 1.4 discusses context sensitivity in more detail. Another area where pointer analyses differ widely is their treatment of recursive data 4 CHAPTER 1. INTRODUCTION structures. Because the amount of heap storage used in recursive data structures in unbounded, some finite approximation is essential. <p> REPRESENTATION OF POINTER INFORMATION Naming by Allocation Context Our first heuristic is grouping heap storage by allocation context. This approach has been widely used in other pointer analysis algorithms <ref> [5, 21, 35] </ref> and it also works well for our analysis. In most of the previous work, the allocation context is identified by the statement that calls the allocation routine. <p> Presumably each pointer used in an indirect reference has at least one value; if we count only one value for a particular reference, the results are as good as they can get. Some previous work on pointer analysis has used similar metrics to evaluate accuracy <ref> [14, 35] </ref>. Because the results of our analysis are expressed in terms of extended parameters, counting pointer values is not entirely straightforward. We cannot simply count the extended parameters referenced by a pointer. <p> At least for these programs, context sensitivity has little benefit when analyzing pointers to variables. This is consistent with Ruf's study evaluating the effects of context sensitivity <ref> [35] </ref>. However, there are undoubtedly programs for which context sensitivity affects pointers to variables, and we have not examined enough benchmarks to determine how 156 CHAPTER 6. EXPERIMENTAL EVALUATION often it is valuable. <p> They report that their analysis is often much more accurate than Steensgaard's approach and much faster than Andersen's algorithm. However, in practice their analysis is still about an order of magnitude slower than Steensgaard's. 7.1.3 Flow-Sensitive Analyses Many different flow-sensitive pointer analyses have been developed in the last decade <ref> [5, 6, 14, 21, 25, 28, 35] </ref>. The earlier analyses typically handled interprocedural analysis by simply combining the control flow graphs of individual procedures. Thus, they suffered from the unrealizable paths problem [25]. The more recent analyses address context sensitivity in various ways. <p> One way to make the analysis more context-sensitive is to include in the tags the complete set of context information that is relevant to the analysis. Ruf used that approach to evaluate the benefits of context sensitivity <ref> [35] </ref>. For example, instead of propagating a single, representative reaching alias as in Landi and Ryder's analysis, Ruf tags the flow values with the complete set of reaching aliases.
Reference: [36] <author> Mooly Sagiv, Thomas Reps, and Reinhard Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <booktitle> In Proceedings of the 23th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1631, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Some other analyses target numeric programs and focus on single-level pointers [29]. At the high end, some analyses distinguish individual elements of recursive data structures and identify the overall data structure shapes, e.g., lists, trees and DAGs <ref> [12, 16, 36] </ref>. These shape analyses provide detailed pointer information at the expense of analysis time. We take an intermediate approach. <p> It is parameterized by a numeric lattice, so that the complexity and precision of the analysis can be tailored to the requirements of a particular application. Most recently, Sagiv et al. have published a shape analysis that focuses on handling destructive (strong) updates <ref> [36] </ref>. Ghiya and Hendren have recently published a shape analysis designed to complement Emami et al.'s pointer analysis [16]. Because their analysis uses invocation graphs, it is context-sensitive. Other 7.2.
Reference: [37] <author> Marc Shapiro and Susan Horwitz. </author> <title> Fast and accurate flow-insensitive points-to analysis. </title> <booktitle> In Proceedings of the 24th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: Software engineering techniques such as program slicing need pointer analysis as well. 1.2 Background Pointer analysis algorithms can use a variety of basic analysis techniques. Simple intrapro-cedural analyses run quickly but only provide crude estimations of pointer values. For that reason, most pointer analyses are interprocedural. Flow-insensitive analyses <ref> [4, 37, 42, 43] </ref> are efficient because they do not take into account the control flow within procedures. We focus on flow-sensitive analyses because of their potential for better accuracy. <p> That causes Andersen's analysis to run much more slowly than Steensgaard's for large input programs. Shapiro and Horwitz have developed an algorithm that improves upon the accuracy of Steensgaard's approach without incurring the cost of Andersen's algorithm <ref> [37] </ref>. They arbitrarily divide the program variables into categories. Their analysis is very similar to Steensgaard's except that instead of unifying sets of variables whenever they are potentially pointed to by the same set, Shapiro and Horwitz unify only the variables that are in the same category.
Reference: [38] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 189236. </pages> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: The second is to identify contexts using the data-flow values computed for the call sites. 1.4. CONTEXT-SENSITIVE INTERPROCEDURAL ANALYSIS 15 Approximating Call Paths There are many possible ways to approximate a complete path through the call multigraph. For example, Sharir and Pnueli described the abstraction of call strings <ref> [38] </ref>. Shivers defined the simple nCFA approach that distinguishes contexts based on the n most recent call sites [39], and others have used that same approach [32, 44]. The only fundamental cause for approximation in the call paths is recursion.
Reference: [39] <author> Olin Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, Pittsburgh, Pennsylvania 15213, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: For example, Sharir and Pnueli described the abstraction of call strings [38]. Shivers defined the simple nCFA approach that distinguishes contexts based on the n most recent call sites <ref> [39] </ref>, and others have used that same approach [32, 44]. The only fundamental cause for approximation in the call paths is recursion. For a nonrecursive program, an analysis can explicitly enumerate all the call paths leading up to each procedure.
Reference: [40] <author> T. C. Spillman. </author> <title> Exposing side-effects in a PL/I optimizing compiler. </title> <booktitle> In Proceedings of the IFIP Conference, </booktitle> <pages> pages 376381, </pages> <year> 1971. </year>
Reference-contexts: Chapter 7 Related Work Pointer analysis has been a topic of research for many years, and our work draws heavily upon the contributions of previous work. Early efforts were constrained by limited computational resources and could not afford very accurate analyses <ref> [40, 46] </ref>. As computers have become faster and memories have grown bigger, more accurate pointer analyses have become possible. Simultaneously, techniques for pointer analysis have improved, so that recent work has made much progress in improving the accuracy and efficiency of pointer analysis algorithms.
Reference: [41] <author> Vugranam C. Sreedhar and Guang R. Gao. </author> <title> A linear time algorithm for placing - nodes. </title> <booktitle> Proceedings of the 22th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: A number of algorithms have been proposed to determine how to place the minimal number of -functions to transform a procedure to SSA form <ref> [9, 33, 34, 41] </ref>. One relatively simple approach is based on iterated dominance frontiers [10, 11]. For an assignment to a 2.7.
Reference: [42] <author> Bjarne Steensgaard. </author> <title> Points-to analysis by type inference of programs with structures and unions. </title> <booktitle> In Proceedings of the 1996 International Conference on Compiler Construction, </booktitle> <pages> pages 136150, </pages> <month> April </month> <year> 1996. </year> <note> 196 BIBLIOGRAPHY </note>
Reference-contexts: Software engineering techniques such as program slicing need pointer analysis as well. 1.2 Background Pointer analysis algorithms can use a variety of basic analysis techniques. Simple intrapro-cedural analyses run quickly but only provide crude estimations of pointer values. For that reason, most pointer analyses are interprocedural. Flow-insensitive analyses <ref> [4, 37, 42, 43] </ref> are efficient because they do not take into account the control flow within procedures. We focus on flow-sensitive analyses because of their potential for better accuracy. <p> They do not include any experimental results, so it is not clear how well their algorithm works. More recently, several flow-insensitive analyses based on constraint solving have been developed. Steensgaard has published two different algorithms <ref> [42, 43] </ref>. The main difference between these two analyses is that the first one does not distinguish the fields within a structure. The second analysis distinguishes fields of structures, but only when those structures are not contained within arrays. The basic approach of both analyses is the same.
Reference: [43] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Proceedings of the 23th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32 41, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Thus, pointer analysis has tremendous potential. Although previous work on pointer analysis has made much progress, the solutions have either been too inaccurate or been unable to analyze large C programs. For example, Steensgaard has analyzed large programs of up to 75,000 lines <ref> [43] </ref>, but his analysis is flow-insensitive, i.e., it cannot distinguish different paths of control within a program. On the other hand, many previous analyses provide more accurate, flow-sensitive results but can only handle small benchmark programs. <p> Software engineering techniques such as program slicing need pointer analysis as well. 1.2 Background Pointer analysis algorithms can use a variety of basic analysis techniques. Simple intrapro-cedural analyses run quickly but only provide crude estimations of pointer values. For that reason, most pointer analyses are interprocedural. Flow-insensitive analyses <ref> [4, 37, 42, 43] </ref> are efficient because they do not take into account the control flow within procedures. We focus on flow-sensitive analyses because of their potential for better accuracy. <p> They do not include any experimental results, so it is not clear how well their algorithm works. More recently, several flow-insensitive analyses based on constraint solving have been developed. Steensgaard has published two different algorithms <ref> [42, 43] </ref>. The main difference between these two analyses is that the first one does not distinguish the fields within a structure. The second analysis distinguishes fields of structures, but only when those structures are not contained within arrays. The basic approach of both analyses is the same.
Reference: [44] <author> J. Vitek, N. Horspool, and J. S. Uhl. </author> <title> Compile-time analysis of object-oriented programs. </title> <booktitle> In Proceedings of the 1992 International Conference on Compiler Construction, </booktitle> <pages> pages 237250, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: For example, Sharir and Pnueli described the abstraction of call strings [38]. Shivers defined the simple nCFA approach that distinguishes contexts based on the n most recent call sites [39], and others have used that same approach <ref> [32, 44] </ref>. The only fundamental cause for approximation in the call paths is recursion. For a nonrecursive program, an analysis can explicitly enumerate all the call paths leading up to each procedure. Emami et al. take that approach in their pointer analysis [14].
Reference: [45] <author> David W. Wall. </author> <title> Limits of instruction-level parallelism. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 176188, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Superscalar processors use hardware instruction scheduling to detect parallelism within a small window of instructions at run time. The size of that window is limited by hardware constraints, and studies have shown that limited parallelism is available within small windows of instructions <ref> [45] </ref>. With the help of pointer analysis, the compiler can find parallelism spread across much larger sections of a program and can perform high-level program transformations to expose that parallelism. For nonnumeric programs, instruction scheduling and register allocation are key optimizations for ILP.
Reference: [46] <author> William E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables, and label variables. </title> <booktitle> In Proceedings of the 7th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 8394, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Chapter 7 Related Work Pointer analysis has been a topic of research for many years, and our work draws heavily upon the contributions of previous work. Early efforts were constrained by limited computational resources and could not afford very accurate analyses <ref> [40, 46] </ref>. As computers have become faster and memories have grown bigger, more accurate pointer analyses have become possible. Simultaneously, techniques for pointer analysis have improved, so that recent work has made much progress in improving the accuracy and efficiency of pointer analysis algorithms.
Reference: [47] <author> Robert P. Wilson et al. </author> <title> SUIF: An infrastructure for research on parallelizing and optimizing compilers. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(12):3137, </volume> <month> December </month> <year> 1994. </year>
Reference-contexts: After reaching the maximum for a particular procedure, instead of creating new PTFs, existing PTFs could be generalized in the same way as in the monovariant version. 144 CHAPTER 5. ANALYSIS OF THE ALGORITHM Chapter 6 Experimental Evaluation We have implemented our pointer analysis in the SUIF compiler system <ref> [47] </ref> and have experimentally evaluated it on a number of benchmark programs. Section 6.1 describes these benchmarks. We have measured the time required to perform the analysis (Section 6.2) as well as several statistics to evaluate the accuracy of the results (Sections 6.3 and 6.4).
Reference: [48] <author> Robert P. Wilson and Monica S. Lam. </author> <title> Efficient context-sensitive pointer analysis for C programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 112, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Extended parameters need not be subject to the constraints placed on nonlocal blocks (e.g., extended parameters can be aliased). Hence, they can provide more accurate results. 1 In previous work <ref> [48] </ref>, we referred to nonlocal blocks as extended parameters. The extended parameters described here are a new concept; they were not used in the earlier work. 48 CHAPTER 2. <p> Calls to the procedure from outside the recursive cycle would then select the PTF on the basis of either one of the domain specifications (whichever matches most closely). We implemented this alternate solution in an earlier version of our analysis <ref> [48] </ref>. We abandoned it for two reasons. It does not address the problem of losing context sensitivity due to overly conservative PTF summaries in recursive cycles (the second problem described above), and it complicates the implementation of the analysis.
References-found: 48

