URL: ftp://ftp.cs.utexas.edu/pub/predator/villarreal-thesis.ps
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: http://www.cs.utexas.edu
Title: by  
Author: Emilia Elizabeth Villarreal 
Date: 1994  
Note: Copyright  
Abstract-found: 0
Intro-found: 1
Reference: [Ara88] <author> G. Arango. </author> <title> Domain Engineering for Software Reuse. </title> <type> PhD thesis, </type> <institution> University of California Irvine, </institution> <year> 1988. </year>
Reference: [Ara89] <author> G. Arango. </author> <title> Domain analysis from art form to engineering discipline. </title> <booktitle> Software Engineering Notes, </booktitle> <pages> pages 152-159, </pages> <month> May </month> <year> 1989. </year>
Reference: [ASU86] <author> A. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison Wesley Publishing Company, Inc., </publisher> <year> 1986. </year>
Reference-contexts: Of particular interest to us are the syntax-directed translation method for language specification and compiler generators. A syntax-directed translation is a context-free grammar whose rules are augmented with associated attributes <ref> [ASU86] </ref>. These attributes may be anything: numbers, strings, structures, etc. Also associated with each rule of the grammer is a set of semantic function calls which may implement any function desired, including compiler utilities. <p> A syntax-directed translation <ref> [ASU86] </ref> is a context-free grammar whose symbols are extended with associated attributes. Attributes may be just about anything| strings, numbers, etc. A rule of the grammar has an associated set of semantic rules which assign to attributes values computed by function calls.
Reference: [Bat87a] <author> D. Batory. </author> <title> Extensible cost models and query optimization in Genesis. </title> <booktitle> Database Engineering, </booktitle> <pages> pages 206-212, </pages> <month> November </month> <year> 1987. </year>
Reference: [Bat87b] <author> D. Batory. </author> <title> Principles of database management system extensibility. </title> <booktitle> Database Engineering, </booktitle> <pages> pages 100-106, </pages> <month> June </month> <year> 1987. </year>
Reference: [Bat88] <author> D. Batory. </author> <title> Building blocks of database management systems. </title> <type> Technical Report TR-87-23, </type> <institution> The University of Texas at Austin, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: We are aware of only two DBMS generators|Exodus [CDV87] and Genesis <ref> [BBG + 90, Bat88, BLW88] </ref>. The Exodus toolkit includes components which are a mix of generic solutions, generators, libraries, and tools. There is no generator for query languages; instead, a programming language E is supplied for use in the implementation of query languages.
Reference: [BBG + 90] <author> D. Batory, J. Barnett, J. Garza, K. Smith, K. Tsukuda, B. Twichell, and T. Wise. </author> <title> Genesis: An extensible database management system. </title> <editor> In S. Zdonik and D. Maier, editors, </editor> <booktitle> Readings in Object Oriented Database Systems, chapter 7.4. </booktitle> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year>
Reference-contexts: We are aware of only two DBMS generators|Exodus [CDV87] and Genesis <ref> [BBG + 90, Bat88, BLW88] </ref>. The Exodus toolkit includes components which are a mix of generic solutions, generators, libraries, and tools. There is no generator for query languages; instead, a programming language E is supplied for use in the implementation of query languages.
Reference: [BG89] <author> L. Becker and R. Guting. </author> <title> Rule-based optimization and query processing in an extensible geometric database system. </title> <type> Technical Report CS Technical Report 312, </type> <institution> Universitat Dortmund, </institution> <month> August </month> <year> 1989. </year>
Reference: [BLW88] <author> D. Batory, T. Leung, and T. Wise. </author> <title> Implementation concepts for an extensible data model and data language. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(3) </volume> <pages> 231-262, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: We are aware of only two DBMS generators|Exodus [CDV87] and Genesis <ref> [BBG + 90, Bat88, BLW88] </ref>. The Exodus toolkit includes components which are a mix of generic solutions, generators, libraries, and tools. There is no generator for query languages; instead, a programming language E is supplied for use in the implementation of query languages.
Reference: [Car87] <author> M. Carey, </author> <title> editor. </title> <journal> IEEE Database Engineering Special Issue on Extensible Database Systems. IEEE Computer Society, </journal> <month> June </month> <year> 1987. </year> <month> 194 </month>
Reference: [CDG + 90] <author> M. Carey, D. DeWitt, G. Graefe, D. Haight, J. Richardson, D. Schuh, E. Shekita, and S. Vandenberg. </author> <title> The EXODUS extensible DBMS project: An overview. </title> <editor> In S. Zdonik and D. Maier, editors, </editor> <booktitle> Readings in Object Oriented Database Systems, chapter 7.3. </booktitle> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year>
Reference: [CDV87] <author> M. Carey, D. DeWitt, and S. Vandenberg. </author> <title> A data model and query language for EXODUS. </title> <type> Technical Report CS Technical Report 734, </type> <institution> University of Wisconsin, </institution> <month> December </month> <year> 1987. </year>
Reference-contexts: Those of interest here include efforts to support extensible data languages. Two basic approaches are taken in designing extensible databases: the fixed data language approach, [Gut89, SK91, MD90, HFLP89], and the toolkit approach, <ref> [CDV87] </ref>. 2 In the fixed data language approach, the extensible database includes a fixed data language but provides a methodology and (sometimes) tools to allow the user to augment it with new data types and new operations on them. <p> We are aware of only two DBMS generators|Exodus <ref> [CDV87] </ref> and Genesis [BBG + 90, Bat88, BLW88]. The Exodus toolkit includes components which are a mix of generic solutions, generators, libraries, and tools. There is no generator for query languages; instead, a programming language E is supplied for use in the implementation of query languages.
Reference: [CHHP91] <author> J. Cordy, C. Halpern-Hamu, and E. Promislow. TXL: </author> <title> A rapid proto-typing system for programming language dialects. </title> <booktitle> Computer Languages, </booktitle> <pages> pages 97-107, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Embedding Quel in C, called EQuel [SWKH76], was achieved by preprocessing the EQuel program into a C program. The preprocessing approach can be as simple or ambitious as desired. Some preprocessors are capable of only simple syntactic substitution; others are capable of code migration <ref> [CHHP91] </ref>. The other approach, compiler extension, makes the code of the compiler available to the user. Languages which can be extended in this way include Lisp and its variants, such as Scheme and Clos, and Icon, an extension of Snobol. <p> Embedding the data language Quel in C, called EQuel [SWKH76], was achieved by preprocessing the EQuel program, converting it into a C program. One quite general preprocessor is TXL <ref> [CHHP91] </ref>, a project at Queens University at Kingston. TXL can be used to extend any imperative language for which a compiler and a complete syntactic description of the base language are available.
Reference: [Dat84] <author> C. J. Date. </author> <title> A critique of the SQL database language. </title> <booktitle> SIGMOD Record, </booktitle> <pages> pages 8-54, </pages> <month> September </month> <year> 1984. </year>
Reference-contexts: This language is of interest today for two reasons: because it addresses unresolved shortcomings of SQL; and because its non-traditional data model marks a significant departure from conventional relational data languages. Overall, quite a few extensions were made to SQL. Some address shortcomings of SQL identified by Date <ref> [Dat84] </ref>. For example, Date suggested that a cleaner language design would allow a query expression to appear wherever a relation name was allowed to appear in the original language; this followed quite naturally from generalizing the data model.
Reference: [Dat87] <author> C. J. Date. </author> <title> A Guide to Ingres, chapter 4. </title> <publisher> Addison Wesley Publishing Company, Inc., </publisher> <year> 1987. </year>
Reference-contexts: Introduction Languages have a history of development. Families of functionally and syntactically similar languages are prevalent today. The family or domain of non-object-oriented imperative programming languages (e.g., C [KR78], Pascal [JW78], Algol [ISO72]) is one example; another is the domain of relational data languages (e.g., SQL [vdL89], Quel <ref> [Dat87] </ref>, TQuel [Sno87]). In the domain of data languages, there is a seemingly endless procession of new languages that are being proposed to meet the changing needs of the DBMS community. In particular, there are numerous proposals for object-oriented data languages: GEM [Zan83], Opal [Ser86], ORION [KBB + 87], etc. <p> Furthermore, we will show in our discussions of the modeled languages that Rosetta is able to model quite diverse languages. Five languages were modeled: SQL [vdL89], SQL/NF [RKS89, RKB88], TSQL2 [Sno94], Quel <ref> [Dat87] </ref>, and TQuel [Sno87]. Each presented its own challenges; we resolved them in a variety of ways: by modeling tricks, by defining new backplane functions, or by generalizing existing backplane functions. We classify languages into families. A language family contains a parent language and languages derived from it.
Reference: [Dev92] <author> P. Devanbu. </author> <title> Genoa|a customizable, language- and front-end independent code analyzer. </title> <booktitle> In Proceedings of the Fourteenth International Conference on Software Engineering, </booktitle> <pages> pages 307-319, </pages> <year> 1992. </year>
Reference-contexts: One attractive feature of these DBMSs is dynamic extension. Rosetta does not offer dynamic extension; languages are extended by generating a new compiler from extended specifications. 5.2 Other Tool Generators The Genoa generator of code analyzer tools <ref> [Dev92, DRW94] </ref> takes a similar approach to Rosetta. Genoa is a language independent generator for code analyzer tools. It uses an independent lexical analyzer and parser (produced, for example, by lex and yacc) to produce a parse tree for a program of the language.
Reference: [DRW94] <author> P. Devanbu, D. Rosenblum, and A. Wolf. </author> <title> Automated construction of testing and analysis tools. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Software Engineering, </booktitle> <year> 1994. </year>
Reference-contexts: One attractive feature of these DBMSs is dynamic extension. Rosetta does not offer dynamic extension; languages are extended by generating a new compiler from extended specifications. 5.2 Other Tool Generators The Genoa generator of code analyzer tools <ref> [Dev92, DRW94] </ref> takes a similar approach to Rosetta. Genoa is a language independent generator for code analyzer tools. It uses an independent lexical analyzer and parser (produced, for example, by lex and yacc) to produce a parse tree for a program of the language.
Reference: [DS86] <author> U. Dayal and J. Smith. </author> <title> PROBE: A knowledge-oriented database management system. </title> <editor> In M. Brodie and J. Mylopoulos, editors, </editor> <booktitle> On Knowledge Base Management Systems, chapter 19. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference: [DS91] <author> C. Donnelly and R. Stallman. </author> <title> BISON The YACC-Compatible Parser Generator, </title> <month> December </month> <year> 1991. </year> <note> on-line documentation for Bison Version 1.16. </note>
Reference-contexts: These attributes may be anything: numbers, strings, structures, etc. Also associated with each rule of the grammer is a set of semantic function calls which may implement any function desired, including compiler utilities. Work in compiler generators includes both simple parser and lexical analyzer generators <ref> [LS86, Joh86, DS91] </ref> and expert systems which control other compiler generation tools [GHL + 92]. A parser generator requires a specification of the language syntax, while a lexical analyzer requires a specification of the tokens of the language. <p> The input to Rosetta (see Figure 3.1) is a Rosetta language specification and the set of backplane function definitions. The generator type-checks the specification using the backplane function definitions and maps the specification to bison <ref> [DS91] </ref> and flex [LS86] files. These files specify a lexical analyzer and parser and, together with C files which define compiler structures and compiler utilities, comprise the generated compiler for the customized data language.
Reference: [Gar90] <author> D. Garlan. </author> <title> The role of formal reusable frameworks. </title> <booktitle> In Proceedings of the ACM SIGSOFT International Workshop on Formal Methods in Software Development, </booktitle> <pages> pages 42-44, </pages> <month> May </month> <year> 1990. </year>
Reference: [GCK + 89] <author> G. Gardarin, J-P. Cheiney, G. Kiernan, D. Pastre, and H. Stora. </author> <title> Managing complex objects in an extensible relational DBMS. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 55-65, </pages> <year> 1989. </year> <month> 195 </month>
Reference: [GD87] <author> G. Graefe and D. DeWitt. </author> <title> The EXODUS optimizer generator. </title> <booktitle> In ACM SIGMOD, </booktitle> <pages> pages 160-172, </pages> <year> 1987. </year>
Reference: [GG86] <author> R. Griswold and M. Griswold. </author> <title> The Implementation of the Icon Programming Language. </title> <publisher> Princeton University Press, </publisher> <year> 1986. </year>
Reference-contexts: Scheme provides for adding new syntax with an extend-syntax function which 121 maps syntactic extensions into core syntactic forms. CLOS (Common Lisp Object System) also allows the user to modify some built-in methods for metaclasses and to define new metaclasses. This approach to extensibility is also used in Icon <ref> [GG86] </ref>, a descendent of SNOBOL. Functions implementing the extension are written and registered (by editing the appropriate compiler tables), then the entire compiler is re-compiled.
Reference: [GHL + 92] <author> R. Gray, V. Heuring, S. Levi, A. Sloane, and W. Waite. Eli: </author> <title> A complete, flexible compiler construction system. </title> <journal> Communications of the ACM, </journal> <pages> pages 121-131, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: Also associated with each rule of the grammer is a set of semantic function calls which may implement any function desired, including compiler utilities. Work in compiler generators includes both simple parser and lexical analyzer generators [LS86, Joh86, DS91] and expert systems which control other compiler generation tools <ref> [GHL + 92] </ref>. A parser generator requires a specification of the language syntax, while a lexical analyzer requires a specification of the tokens of the language. <p> Input to the generators is hand-crafted anew for each compiler. The second approach of interest is the construction of an expert system which controls off-the-shelf tools <ref> [GHL + 92] </ref>. Such an expert system initiates the tools in the proper order, passing to each its associated input files and connecting the output of one to the input of another. <p> But Rosetta is more than a preprocessor for lex and yacc and its framework is more expressive. A data language specification expressed in Rosetta's functional semantic model captures both syntax and semantics. Furthermore, Rosetta automates code reuse and encapsulates reusable components. Another compiler generator, the Eli compiler-compiler <ref> [GHL + 92] </ref>, a project at the University of Colorado, Boulder, consists of an expert system controlling off-the-shelf tools including lex, yacc, LIDO 2 , and other tools.
Reference: [Gog89] <author> J. Goguen. </author> <title> Principles of parameterized programming. </title> <editor> In T. Biggerstaff and A. Perlis, editors, </editor> <booktitle> Software Reusability, </booktitle> <volume> vol. 1, chapter 7. </volume> <publisher> Addison Wesley Publishing Company, Inc., </publisher> <address> 1989. </address> <publisher> ACM Press Frontier Series; NY, </publisher> <address> NY. </address>
Reference: [Gut89] <author> R. Guting. </author> <title> Gral: An extensible relational database system for geometric applications. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 33-44, </pages> <year> 1989. </year>
Reference-contexts: We discuss each briefly in turn. 1.1.1 Extensible Databases Several projects have addressed how to build extensible databases. Those of interest here include efforts to support extensible data languages. Two basic approaches are taken in designing extensible databases: the fixed data language approach, <ref> [Gut89, SK91, MD90, HFLP89] </ref>, and the toolkit approach, [CDV87]. 2 In the fixed data language approach, the extensible database includes a fixed data language but provides a methodology and (sometimes) tools to allow the user to augment it with new data types and new operations on them. <p> Addition of descriptive and executable operators is similar: first they are implemented, then they are registered with an operator manager module which adds definitional information to a system table. Gral <ref> [Gut89] </ref> has its own query language based on an extended relational algebra|a many-sorted algebra|which is basically relational algebra extended with types. Gral differentiates between declarative conceptual operations and concrete operations. Extensions may be made to both.
Reference: [HCF + 88] <author> L.M. Haas, W.F. Cody, J.C. Freytag, G. Lapis, B.G. Lindsay, G.M. Lohman, K. Ono, and H. Pirahesh. </author> <title> An extensible processor for an extended relational query language. </title> <type> Technical Report RJ 6182 (60892), </type> <institution> IBM Almaden Research Center, </institution> <month> April </month> <year> 1988. </year>
Reference: [Hen77a] <author> G. Hendrix. </author> <booktitle> Human engineering for applied natural language processing. In International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 183-191, </pages> <year> 1977. </year>
Reference: [Hen77b] <author> G. Hendrix. LIFER: </author> <title> A natural language interface facility. </title> <journal> SIGART Newsletter, </journal> <pages> pages 25-26, </pages> <month> February </month> <year> 1977. </year>
Reference: [Hen77c] <author> G. Hendrix. </author> <title> The LIFER manual|a guide to building practical natural language interfaces. </title> <type> Technical Report Technical Note 138, </type> <institution> SRI International, </institution> <address> Menlo Park, CA, </address> <year> 1977. </year>
Reference-contexts: Furthermore, our focus is on data languages, and none of these approaches is targeted for that field. 1.1.4 Natural Language Processing Finally, work in natural language processing aims at facilitating the addition of natural language interfaces to existing software systems <ref> [Hen77c, HSSS78] </ref>. The approach taken is similar to that of Rosetta: an interface specification is a grammar whose rules are augmented with expressions implementing a response. <p> Rosetta provides a functional language model and maps language constructs to backplane functions, simplifying the code generation/assembly phase. Furthermore, we have 2 LIDO is an attribute grammar tool. 123 standardized attributes for nodes, eliminating the use of an attribute grammar for specification. 5.5 AI/NLP LIFER <ref> [Hen77c] </ref> is a general package of tools which facilitates the rapid addition of natural language interfaces to existing software systems. It has two major components|a set of interactive functions for language specification and a parser.
Reference: [HFLP89] <author> L. Haas, J. Freytag, G. Lohman, and H. Pirahesh. </author> <title> Extensible query processing in Starburst. </title> <booktitle> In ACM SIGMOD, </booktitle> <pages> pages 377-388, </pages> <month> May </month> <year> 1989. </year> <title> also, </title> <type> IBM Almaden Tech Report RJ 6610 (63921) 12/21/88. </type>
Reference-contexts: We discuss each briefly in turn. 1.1.1 Extensible Databases Several projects have addressed how to build extensible databases. Those of interest here include efforts to support extensible data languages. Two basic approaches are taken in designing extensible databases: the fixed data language approach, <ref> [Gut89, SK91, MD90, HFLP89] </ref>, and the toolkit approach, [CDV87]. 2 In the fixed data language approach, the extensible database includes a fixed data language but provides a methodology and (sometimes) tools to allow the user to augment it with new data types and new operations on them. <p> To add a new class, the DBI produces an adapter, a function which implements the class in terms of lower-level DBMS primitives. Since the data model is object-oriented while the underlying DBMS is relational, when a new class is added the adapter must reconcile the two views. Starburst <ref> [HFLP89] </ref>, was designed with the goal of total extensibility. Its query language, Hydrogen, is a generalized and extensible variant of SQL. New functions can be added to it, including new aggregate and relational functions.
Reference: [HSSS78] <author> G. Hendrix, E. Sacerdoti, D. Sagalowicz, and J. Slocum. </author> <title> Developing a natural language interface to complex data. </title> <journal> ACM Transactions on Database Systems, </journal> <pages> pages 105-147, </pages> <month> June </month> <year> 1978. </year> <month> 196 </month>
Reference-contexts: Furthermore, our focus is on data languages, and none of these approaches is targeted for that field. 1.1.4 Natural Language Processing Finally, work in natural language processing aims at facilitating the addition of natural language interfaces to existing software systems <ref> [Hen77c, HSSS78] </ref>. The approach taken is similar to that of Rosetta: an interface specification is a grammar whose rules are augmented with expressions implementing a response. <p> LIFER also provides for other extensions: synonyms, paraphrases, and elliptical inputs. LIFER was used to build a natural language interface for LADDER <ref> [HSSS78] </ref>, a front-end to a distributed database. LADDER is comprised of three components: INLAND, IDA, and FAM 3 . <p> INLAND, the module produced with LIFER, cannot handle joins. Nor does it translate input natural language queries to the data language of the underlying DBMS. In <ref> [HSSS78] </ref>, Hendrix, et.al. state that joins are handled by handing off a predicate to the IDA module. While LADDER does have join capability, the IDA splits the predicate into a sequence of single file queries, and it composes the records obtained to produce the result.
Reference: [HSW75] <author> G. Held, M. Stonebraker, and E. Wong. </author> <title> Ingres|a relational database system. </title> <booktitle> In National Computer Conference, </booktitle> <pages> pages 409-416, </pages> <year> 1975. </year>
Reference-contexts: However, Quel is of interest in its own right, as there are significant functional and syntactic differences between SQL and Quel. Quel was developed at the University of California at Berkeley as the data language of the database management system INGRES, <ref> [HSW75] </ref>.
Reference: [ISO72] <author> ISO. </author> <title> ISO Recommendation R1538, </title> <booktitle> Programming Language ALGOL, first edition, </booktitle> <month> March </month> <year> 1972. </year>
Reference-contexts: Introduction Languages have a history of development. Families of functionally and syntactically similar languages are prevalent today. The family or domain of non-object-oriented imperative programming languages (e.g., C [KR78], Pascal [JW78], Algol <ref> [ISO72] </ref>) is one example; another is the domain of relational data languages (e.g., SQL [vdL89], Quel [Dat87], TQuel [Sno87]). In the domain of data languages, there is a seemingly endless procession of new languages that are being proposed to meet the changing needs of the DBMS community.
Reference: [Jen94] <author> C. Jensen. </author> <title> A consensus glossary of temporal database concepts. </title> <booktitle> SIG-MOD Record, </booktitle> <pages> pages 52-64, </pages> <month> March </month> <year> 1994. </year>
Reference: [Joh86] <author> S. Johnson. </author> <title> Yacc: Yet another compiler compiler. In UNIX Programmer's Manual: </title> <type> Supplementary Documents 1. </type> <institution> University of California, Berkeley, </institution> <year> 1986. </year>
Reference-contexts: These attributes may be anything: numbers, strings, structures, etc. Also associated with each rule of the grammer is a set of semantic function calls which may implement any function desired, including compiler utilities. Work in compiler generators includes both simple parser and lexical analyzer generators <ref> [LS86, Joh86, DS91] </ref> and expert systems which control other compiler generation tools [GHL + 92]. A parser generator requires a specification of the language syntax, while a lexical analyzer requires a specification of the tokens of the language. <p> Furthermore, Rosetta rules have implicit attributes which constitute the nodes of the automatically constructed parse tree. 122 5.4.2 Compiler Generators. Early work in compiler generation immediately brings to mind lex [LS86], which generates a lexical analyzer, and yacc <ref> [Joh86] </ref>, which generates a parser. A lex input file consists of regular expressions to be matched and associated actions (written in C) to be executed when a matching string is found. The regular expressions match tokens of the language and the actions can specify manipulations to be performed on them.
Reference: [JW78] <author> K. Jensen and N. Wirth. </author> <title> Pascal: User Manual and Report. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1978. </year>
Reference-contexts: Introduction Languages have a history of development. Families of functionally and syntactically similar languages are prevalent today. The family or domain of non-object-oriented imperative programming languages (e.g., C [KR78], Pascal <ref> [JW78] </ref>, Algol [ISO72]) is one example; another is the domain of relational data languages (e.g., SQL [vdL89], Quel [Dat87], TQuel [Sno87]). In the domain of data languages, there is a seemingly endless procession of new languages that are being proposed to meet the changing needs of the DBMS community.
Reference: [KBB + 87] <author> W. Kim, N. Ballou, J. Banerjee, H. Chou, J. Garza, and D. Woelk. </author> <title> Features of the ORION object-oriented database system. </title> <type> Technical Report ACA-ST-308-87, </type> <institution> Microelectronics and Computer Technology Corporation, </institution> <month> September </month> <year> 1987. </year>
Reference-contexts: In the domain of data languages, there is a seemingly endless procession of new languages that are being proposed to meet the changing needs of the DBMS community. In particular, there are numerous proposals for object-oriented data languages: GEM [Zan83], Opal [Ser86], ORION <ref> [KBB + 87] </ref>, etc. Until a standard is established for object-oriented data languages, multiple competing languages will persist and, indeed, proliferate. Few are wholly new; most offer extensions to previously defined languages such as SQL or Quel. Many languages never go beyond the proposal stage; even fewer are ever implemented.
Reference: [KR78] <author> B. Kernighan and D. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall Inc., </publisher> <year> 1978. </year>
Reference-contexts: Introduction Languages have a history of development. Families of functionally and syntactically similar languages are prevalent today. The family or domain of non-object-oriented imperative programming languages (e.g., C <ref> [KR78] </ref>, Pascal [JW78], Algol [ISO72]) is one example; another is the domain of relational data languages (e.g., SQL [vdL89], Quel [Dat87], TQuel [Sno87]).
Reference: [KS86] <author> H. Korth and A. Silberschatz. </author> <title> Database System Concepts. </title> <publisher> McGraw-Hill Book Company, </publisher> <year> 1986. </year>
Reference: [LLPS91] <author> G. Lohman, B. Lindsay, H. Pirahesh, and K. Schiefer. </author> <title> Extensions to Starburst: Objects, types, functions, and rules. </title> <journal> Communications of the ACM, </journal> <pages> pages 94-109, </pages> <month> October </month> <year> 1991. </year>
Reference: [LMP87] <author> B. Lindsay, J. McPherson, and H. Pirahesh. </author> <title> A data management extension architecture. </title> <booktitle> In ACM SIGMOD, </booktitle> <pages> pages 220-226, </pages> <month> May </month> <year> 1987. </year>
Reference: [LR89] <author> J. Lingat and C. Rolland. PROQUEL: </author> <title> a PROgramming QUEry Language. </title> <booktitle> In Proceedings of the Second International Workshop on Database Programming Languages, </booktitle> <pages> pages 281-295, </pages> <year> 1989. </year>
Reference: [LS86] <author> M. Lesk and E. Schmidt. </author> <title> Lex|a lexical analyzer generator. In UNIX Programmer's Manual: </title> <type> Supplementary Documents 1. </type> <institution> University of Cal-ifornia, Berkeley, </institution> <year> 1986. </year> <month> 197 </month>
Reference-contexts: These attributes may be anything: numbers, strings, structures, etc. Also associated with each rule of the grammer is a set of semantic function calls which may implement any function desired, including compiler utilities. Work in compiler generators includes both simple parser and lexical analyzer generators <ref> [LS86, Joh86, DS91] </ref> and expert systems which control other compiler generation tools [GHL + 92]. A parser generator requires a specification of the language syntax, while a lexical analyzer requires a specification of the tokens of the language. <p> The input to Rosetta (see Figure 3.1) is a Rosetta language specification and the set of backplane function definitions. The generator type-checks the specification using the backplane function definitions and maps the specification to bison [DS91] and flex <ref> [LS86] </ref> files. These files specify a lexical analyzer and parser and, together with C files which define compiler structures and compiler utilities, comprise the generated compiler for the customized data language. <p> A Rosetta specification is essentially a syntax-directed translation which is augmented with global variables. Furthermore, Rosetta rules have implicit attributes which constitute the nodes of the automatically constructed parse tree. 122 5.4.2 Compiler Generators. Early work in compiler generation immediately brings to mind lex <ref> [LS86] </ref>, which generates a lexical analyzer, and yacc [Joh86], which generates a parser. A lex input file consists of regular expressions to be matched and associated actions (written in C) to be executed when a matching string is found.
Reference: [Man88] <author> N. Mano. </author> <title> Modeling of data-processing software for generating and reusing their programs. </title> <booktitle> In Proceedings of the Tenth International Conference on Software Engineering, </booktitle> <pages> pages 231-240, </pages> <month> April </month> <year> 1988. </year>
Reference: [MD90] <author> F. Manola and U. Dayal. PDM: </author> <title> An object-oriented data model. </title> <editor> In S. Zdonik and D. Maier, editors, </editor> <booktitle> Readings in Object Oriented Database Systems, chapter 3.4. </booktitle> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year>
Reference-contexts: We discuss each briefly in turn. 1.1.1 Extensible Databases Several projects have addressed how to build extensible databases. Those of interest here include efforts to support extensible data languages. Two basic approaches are taken in designing extensible databases: the fixed data language approach, <ref> [Gut89, SK91, MD90, HFLP89] </ref>, and the toolkit approach, [CDV87]. 2 In the fixed data language approach, the extensible database includes a fixed data language but provides a methodology and (sometimes) tools to allow the user to augment it with new data types and new operations on them. <p> Postgres [SK91] also has a fixed data language, called PostQuel, with dynamic definition of functions and data types, including new base types. Postgres closely follows the general table-driven approach described earlier (and, indeed, popularized it). In Probe <ref> [MD90] </ref>, the general approach as outlined above is used. To add a new class, the DBI produces an adapter, a function which implements the class in terms of lower-level DBMS primitives.
Reference: [Nei84] <author> J. Neighbors. </author> <title> The Draco approach to constructing software from reusable components. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 564-574, </pages> <month> September </month> <year> 1984. </year>
Reference: [PDA91] <author> R. Prieto-Diaz and G. Arango. </author> <title> Domain Analysis and Software Systems Modeling. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: The goal of domain analysis is to design an implementation-independent backplane; that is, a backplane that can be re-used to build multiple systems. Domain analysis generally requires a considerable amount of hard work <ref> [PDA91] </ref>. Domain modeling and backplane design is a process of iterative refinement. We say that a backplane B models language L if each statement in L maps to a composition of functions in B.
Reference: [RKB88] <author> M. Roth, H. Korth, and D. Batory. SQL/NF: </author> <title> A query language for :1NF relational databases. </title> <journal> Information Systems, </journal> <volume> 12(1) </volume> <pages> 99-114, </pages> <year> 1988. </year>
Reference-contexts: Furthermore, we will show in our discussions of the modeled languages that Rosetta is able to model quite diverse languages. Five languages were modeled: SQL [vdL89], SQL/NF <ref> [RKS89, RKB88] </ref>, TSQL2 [Sno94], Quel [Dat87], and TQuel [Sno87]. Each presented its own challenges; we resolved them in a variety of ways: by modeling tricks, by defining new backplane functions, or by generalizing existing backplane functions. We classify languages into families. <p> None of these omissions detract significantly from the expressiveness of the language; all could easily be added. 4.2.2 SQL/NF The first extension of SQL we consider is SQL/NF, a language developed at The University of Texas at Austin by Roth, et. al. <ref> [RKS89, RKB88] </ref>. SQL/NF was designed expressly to support applications beyond traditional data processing. This language is of interest today for two reasons: because it addresses unresolved shortcomings of SQL; and because its non-traditional data model marks a significant departure from conventional relational data languages.
Reference: [RKS85] <author> M. Roth, H. Korth, and A. Silberschatz. </author> <title> Null values in :1NF relational databases. </title> <type> Technical Report TR-85-32, </type> <institution> The University of Texas at Austin, </institution> <month> December </month> <year> 1985. </year>
Reference: [RKS88] <author> M. Roth, H. Korth, and A. Silberschatz. </author> <title> Extended algebra and calculus for nested relational databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(4) </volume> <pages> 389-417, </pages> <month> December </month> <year> 1988. </year>
Reference: [RKS89] <author> M. A. Roth, H. F. Korth, and A. Silberschatz. </author> <title> Null values in nested relational databases. </title> <journal> Acta Informatica, </journal> <volume> 26(7) </volume> <pages> 615-642, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Furthermore, we will show in our discussions of the modeled languages that Rosetta is able to model quite diverse languages. Five languages were modeled: SQL [vdL89], SQL/NF <ref> [RKS89, RKB88] </ref>, TSQL2 [Sno94], Quel [Dat87], and TQuel [Sno87]. Each presented its own challenges; we resolved them in a variety of ways: by modeling tricks, by defining new backplane functions, or by generalizing existing backplane functions. We classify languages into families. <p> None of these omissions detract significantly from the expressiveness of the language; all could easily be added. 4.2.2 SQL/NF The first extension of SQL we consider is SQL/NF, a language developed at The University of Texas at Austin by Roth, et. al. <ref> [RKS89, RKB88] </ref>. SQL/NF was designed expressly to support applications beyond traditional data processing. This language is of interest today for two reasons: because it addresses unresolved shortcomings of SQL; and because its non-traditional data model marks a significant departure from conventional relational data languages.
Reference: [RS87] <author> L. Rowe and M. Stonebraker. </author> <title> The Postgres data model. </title> <booktitle> In Proceedings of the Thirteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 83-96, </pages> <year> 1987. </year>
Reference: [Ser86] <institution> Servio Logic Development Corporation, Beaverton, Oregon. </institution> <note> Programming in OPAL, </note> <year> 1986. </year>
Reference-contexts: In the domain of data languages, there is a seemingly endless procession of new languages that are being proposed to meet the changing needs of the DBMS community. In particular, there are numerous proposals for object-oriented data languages: GEM [Zan83], Opal <ref> [Ser86] </ref>, ORION [KBB + 87], etc. Until a standard is established for object-oriented data languages, multiple competing languages will persist and, indeed, proliferate. Few are wholly new; most offer extensions to previously defined languages such as SQL or Quel.
Reference: [SHP88] <author> M. Stonebraker, E. Hanson, and S. Potamianos. </author> <title> The Postgres rule manager. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(7) </volume> <pages> 897-907, </pages> <month> July </month> <year> 1988. </year>
Reference: [SK91] <author> M. Stonebraker and G. Kemnitz. </author> <title> The Postgres next-generation database management system. </title> <journal> Communications of the ACM, </journal> <pages> pages 78-93, </pages> <month> Octo-ber </month> <year> 1991. </year> <month> 198 </month>
Reference-contexts: We discuss each briefly in turn. 1.1.1 Extensible Databases Several projects have addressed how to build extensible databases. Those of interest here include efforts to support extensible data languages. Two basic approaches are taken in designing extensible databases: the fixed data language approach, <ref> [Gut89, SK91, MD90, HFLP89] </ref>, and the toolkit approach, [CDV87]. 2 In the fixed data language approach, the extensible database includes a fixed data language but provides a methodology and (sometimes) tools to allow the user to augment it with new data types and new operations on them. <p> Postgres <ref> [SK91] </ref> also has a fixed data language, called PostQuel, with dynamic definition of functions and data types, including new base types. Postgres closely follows the general table-driven approach described earlier (and, indeed, popularized it). In Probe [MD90], the general approach as outlined above is used.
Reference: [Sno87] <author> R. Snodgrass. </author> <title> The temporal query language TQuel. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2) </volume> <pages> 247-298, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Introduction Languages have a history of development. Families of functionally and syntactically similar languages are prevalent today. The family or domain of non-object-oriented imperative programming languages (e.g., C [KR78], Pascal [JW78], Algol [ISO72]) is one example; another is the domain of relational data languages (e.g., SQL [vdL89], Quel [Dat87], TQuel <ref> [Sno87] </ref>). In the domain of data languages, there is a seemingly endless procession of new languages that are being proposed to meet the changing needs of the DBMS community. In particular, there are numerous proposals for object-oriented data languages: GEM [Zan83], Opal [Ser86], ORION [KBB + 87], etc. <p> Furthermore, we will show in our discussions of the modeled languages that Rosetta is able to model quite diverse languages. Five languages were modeled: SQL [vdL89], SQL/NF [RKS89, RKB88], TSQL2 [Sno94], Quel [Dat87], and TQuel <ref> [Sno87] </ref>. Each presented its own challenges; we resolved them in a variety of ways: by modeling tricks, by defining new backplane functions, or by generalizing existing backplane functions. We classify languages into families. A language family contains a parent language and languages derived from it. <p> required to develop our model of Quel was approximately four weeks, including both the time needed to understand the syntactic and semantic differences between SQL and Quel and to develop the model. 4.3.2 TQuel Our second data point in the Quel family, and the last language we consider, is TQuel <ref> [Sno87] </ref>, a temporal data language developed by Richard Snodgrass at the University of North Carolina at Chapel Hill, NC. We chose TQuel as one of our data points because it is an extension of Quel which augments the standard relational operators with temporal constructs. <p> Our model of TQuel DML statements is based on the language definition in <ref> [Sno87] </ref>. All of the TQuel DML statements are included in the model: the RETRIEVE statement for data retrieval, with all its options, as well as the data modification statements APPEND TO (insert), DELETE, and REPLACE (update).
Reference: [Sno94] <author> R. Snodgrass. </author> <title> TSQL2 language specification. </title> <booktitle> SIGMOD Record, </booktitle> <pages> pages 65-86, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Furthermore, we will show in our discussions of the modeled languages that Rosetta is able to model quite diverse languages. Five languages were modeled: SQL [vdL89], SQL/NF [RKS89, RKB88], TSQL2 <ref> [Sno94] </ref>, Quel [Dat87], and TQuel [Sno87]. Each presented its own challenges; we resolved them in a variety of ways: by modeling tricks, by defining new backplane functions, or by generalizing existing backplane functions. We classify languages into families. A language family contains a parent language and languages derived from it. <p> Although fundamental changes were made to the data model, because the specification is so high-level the changes required consisted of adding new backplane functions or generalizing existing ones. 69 4.2.3 TSQL2 For our third data point, we selected TSQL2, a temporal data language <ref> [Sno94] </ref>. We developed our model for this language while the specification was still under discussion.
Reference: [SR86] <author> M. Stonebraker and L. Rowe. </author> <title> The design of Postgres. </title> <booktitle> In ACM SIGMOD, </booktitle> <pages> pages 340-355, </pages> <year> 1986. </year>
Reference: [SS87] <author> A. Segev and A. Shoshani. </author> <title> Logical modeling of temporal data. </title> <booktitle> In ACM SIGMOD, </booktitle> <pages> pages 454-466, </pages> <month> May </month> <year> 1987. </year>
Reference: [Sto86a] <author> M. Stonebraker. </author> <title> Inclusion of new types in relational database systems. </title> <booktitle> In Proceedings Second International Conference on Database Engineering, </booktitle> <month> February </month> <year> 1986. </year>
Reference: [Sto86b] <author> M. Stonebraker. </author> <title> Object management in Postgres using procedures. </title> <booktitle> In Proceedings of the 1986 International Workshop on Object-Oriented Database Systems, </booktitle> <month> September </month> <year> 1986. </year>
Reference: [Sto87] <author> M. Stonebraker. </author> <title> The design of the Postgres storage system. </title> <booktitle> In Proceedings of the Thirteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 289-300, </pages> <year> 1987. </year>
Reference: [SWKH76] <author> M. Stonebraker, E. Wong, P. Kreps, and G. </author> <title> Held. The design and implementation of Ingres. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1(3) </volume> <pages> 189-222, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: There are preprocessors for many languages, e.g., C, Fortran, and PL/1, and there are preprocessors which can be used for multiple languages, e.g., M4. Embedding Quel in C, called EQuel <ref> [SWKH76] </ref>, was achieved by preprocessing the EQuel program into a C program. The preprocessing approach can be as simple or ambitious as desired. Some preprocessors are capable of only simple syntactic substitution; others are capable of code migration [CHHP91]. <p> We modeled Quel and one other member of the Quel family|TQuel, a temporal data language. 4.3.1 Quel Our interest in Quel stems from both its popularity and its historical interest: Quel was one of the earliest relational data languages <ref> [SWKH76] </ref>. Like SQL, Quel is a traditional relational data language. However, Quel is of interest in its own right, as there are significant functional and syntactic differences between SQL and Quel. <p> Many languages have preprocessors, e.g., C, Fortran, PL/1, and there are preprocessors which can be used for multiple languages, e.g., M4. Embedding the data language Quel in C, called EQuel <ref> [SWKH76] </ref>, was achieved by preprocessing the EQuel program, converting it into a C program. One quite general preprocessor is TXL [CHHP91], a project at Queens University at Kingston.
Reference: [Ull82] <author> J. Ullman. </author> <title> Principles of Database Systems, </title> <type> chapter 8. </type> <institution> Computer Science Press, Inc., </institution> <note> second edition, 1982. chapter 6 on Relational Query Languages. </note>
Reference: [Ull88] <author> J. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <pages> pages 271-288. </pages> <publisher> Computer Science Press, Inc., </publisher> <year> 1988. </year> <title> subchapters 2.7 on Object-Oriented Data Model and 5.6-5.7 on OPAL. </title>
Reference: [vdL89] <author> R. van der Lans. </author> <title> The SQL Standard. </title> <publisher> Prentice Hall International, </publisher> <year> 1989. </year>
Reference-contexts: Introduction Languages have a history of development. Families of functionally and syntactically similar languages are prevalent today. The family or domain of non-object-oriented imperative programming languages (e.g., C [KR78], Pascal [JW78], Algol [ISO72]) is one example; another is the domain of relational data languages (e.g., SQL <ref> [vdL89] </ref>, Quel [Dat87], TQuel [Sno87]). In the domain of data languages, there is a seemingly endless procession of new languages that are being proposed to meet the changing needs of the DBMS community. <p> Furthermore, we will show in our discussions of the modeled languages that Rosetta is able to model quite diverse languages. Five languages were modeled: SQL <ref> [vdL89] </ref>, SQL/NF [RKS89, RKB88], TSQL2 [Sno94], Quel [Dat87], and TQuel [Sno87]. Each presented its own challenges; we resolved them in a variety of ways: by modeling tricks, by defining new backplane functions, or by generalizing existing backplane functions. We classify languages into families. <p> The latter two were chosen because they both make significant but diverse extensions to SQL. 4.2.1 SQL The first language we consider in the SQL family is SQL itself. Our model of SQL is based on the 1987 ISO standard, <ref> [vdL89] </ref>. It includes the data retrieval statement, SELECT; the set operation statements, UNION, INTERSECT, and EXCEPT; and the data modification statements, INSERT, DELETE, and UPDATE.
Reference: [Zan83] <author> C. Zaniolo. </author> <title> The database language GEM. </title> <booktitle> In ACM SIGMOD, </booktitle> <pages> pages 207-218, </pages> <year> 1983. </year>
Reference-contexts: In the domain of data languages, there is a seemingly endless procession of new languages that are being proposed to meet the changing needs of the DBMS community. In particular, there are numerous proposals for object-oriented data languages: GEM <ref> [Zan83] </ref>, Opal [Ser86], ORION [KBB + 87], etc. Until a standard is established for object-oriented data languages, multiple competing languages will persist and, indeed, proliferate. Few are wholly new; most offer extensions to previously defined languages such as SQL or Quel.
References-found: 68

