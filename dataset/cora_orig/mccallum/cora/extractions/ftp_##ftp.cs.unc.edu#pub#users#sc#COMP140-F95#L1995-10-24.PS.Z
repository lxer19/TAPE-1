URL: ftp://ftp.cs.unc.edu/pub/users/sc/COMP140-F95/L1995-10-24.PS.Z
Refering-URL: http://www.cs.unc.edu/~sc/teaching/COMP140-F1995/lectures.html
Root-URL: http://www.cs.unc.edu
Title: COMP 140: Introduction to Translator Systems Code Generation (Lecture 1) 1 Code generation general-purpose registers
Author: Siddhartha Chatterjee 
Keyword: 2 MIPS processor architecture 2.1 CPU registers  
Note: The  2.  
Date: 24 October 1995  
Abstract: Code generation is the most idiosyncratic portion of the compiler. While there is some general theory on this subject, much of the quality of a good code generator depends on paying attention to the engineering details and being familiar with the architecture for which one is generating code. The target language of our code generator will be the assembly language of the MIPS R2000/R3000 architecture. We therefore begin this portion of the material by studying the details of the architecture. The MIPS processors consist of multiple processors implemented on a single chip. For our purposes, we will disregard the system coprocessors and floating point units, and concentrate only on the 32-bit RISC CPU. The CPU provides 32 general-purpose 32-bit registers, a 32-bit program counter (PC), and two 32-bit registers called HI and LO that hold the results of integer multiplication and division opeations. 1. Register r0 is hardwired to the value zero. If r0 is specified as the target of any computational instruc tion, the result is discarded. When used as a source register, it provides the constant zero. The software conventions we use will give symbolic names to these registers and will reserve certain registers for specific purposes. The following list shows these symbolic names and special uses. Number Name Usage Who saves 0 zero the constant zero No one 1 at reserved for assembler No one 2 v0 function results No one 3 v1 function results No one 4 a0 argument 1 Caller 5 a1 argument 2 Caller 6 a2 argument 3 Caller 
Abstract-found: 1
Intro-found: 1
References-found: 0

