URL: ftp://rep1.iei.pi.cnr.it/pub/asirelli/ICworkshop.ps
Refering-URL: http://karna.cs.umd.edu:3264/people/godfrey/cites.html
Root-URL: 
Email: fasirelli, plagenzag@iei.pi.cnr.it inverard@univaq.it  
Title: Integrity Constraints as Views in Deductive Databases  
Author: Patrizia Asirelli Paola Inverardi Giuseppe Plagenza 
Address: via Santa Maria 46, I-56126 Pisa, Italy  via Vetoio, 67010 Coppito (L'Aquila), Italy  
Affiliation: Istituto di Elaborazione dell'Informazione, Consiglio Nazionale delle Ricerche  Dipartimento di Matematica Pura ed Applicata, Universita' di L'Aquila  
Abstract: In this paper we present a refutation procedure to compute goals in a deductive database according to particular views of it. Views are defined by a set of constraints rules. The declarative semantics of the constrained database is defined and the given refutation procedure is proved correct and complete for positive range-restricted databases. The extension of the procedure to deal with negation is also outlined.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abiteboul S., R. Hull and V. Vianu. </author> <title> "Foundations of Databases", </title> <publisher> Addison Wesley Pubs.Co., </publisher> <year> 1995 </year>
Reference-contexts: Note that this interpretation of logic-based databases is only slightly different from the Datalog oriented ones <ref> [1, 18] </ref> and our results can be easily adopted in that context.
Reference: [2] <author> Aquilino D., P. Asirelli, C. Renso and F. Turini. </author> <title> An Operator for Com posing Deductive Databases with Theories of Constraints. </title> <booktitle> Proceedings of LPNMR'95. </booktitle>
Reference-contexts: The various approaches to Integrity Constraint Checking proposed in the literature so far, can in fact be also characterized according to the strategy the integrity checking methods are based on. Referring to this aspect, we introduce the distinction between interpretative (notably [12, 17]) and compilative (no-tably <ref> [2, 3, 6] </ref>) approaches. In this respect our method, that integrates query answering with integrity checking, can be seen as an interpretative version of the modified-program approach described in [3] and of the integrity constraint operators among theories of [2]. <p> In this respect our method, that integrates query answering with integrity checking, can be seen as an interpretative version of the modified-program approach described in [3] and of the integrity constraint operators among theories of <ref> [2] </ref>. This use of constraints as a means to restrict the set of possible answers to a query on a database also appears in [6]. However, that method differs from 3 ours since it adopts a compilative approach. Another minor difference concerns the syntax of constraints: their method uses denials.
Reference: [3] <author> Asirelli P., M. De Santis, and M. Martelli. </author> <title> Integrity Constraints in Logic Databases. </title> <journal> Journal of Logic Programming, </journal> <volume> 3 </volume> <pages> 221-232, </pages> <year> 1985. </year>
Reference-contexts: Some authors denote integrity constraints formulae as denials A 1 ; : : : ; A n (see [12, 17]), whereas some uses formulae as A ! B 1 ; : : : ; B n (see <ref> [3, 10] </ref>). * The intuitive semantics of a denial A 1 ; : : :; A n is that, for every ground instance of A 1 ^ : : : ^ A n , say (A 1 ^ : : : ^ A n ), there must exist at least one <p> All proposed methods, as Kowalski summarizes [10], have tried to give a different formal characterization to the above informal semantics of integrity constraints. These include a: * theoremhood view (see <ref> [12, 3] </ref>), * consistency view (see [17]), * epistemic (see [15]) or metalevel view (see [17]). Besides, the different integrity checking methods have followed different strategies. <p> The various approaches to Integrity Constraint Checking proposed in the literature so far, can in fact be also characterized according to the strategy the integrity checking methods are based on. Referring to this aspect, we introduce the distinction between interpretative (notably [12, 17]) and compilative (no-tably <ref> [2, 3, 6] </ref>) approaches. In this respect our method, that integrates query answering with integrity checking, can be seen as an interpretative version of the modified-program approach described in [3] and of the integrity constraint operators among theories of [2]. <p> Referring to this aspect, we introduce the distinction between interpretative (notably [12, 17]) and compilative (no-tably [2, 3, 6]) approaches. In this respect our method, that integrates query answering with integrity checking, can be seen as an interpretative version of the modified-program approach described in <ref> [3] </ref> and of the integrity constraint operators among theories of [2]. This use of constraints as a means to restrict the set of possible answers to a query on a database also appears in [6]. However, that method differs from 3 ours since it adopts a compilative approach. <p> 7 the least fixpoint of the operator IC D , properly augmented so as to be also a model of the Equality Theory. 4 Concluding Remarks The proposed method is mainly the result of re-considering, in the interpretative perspective, the Modified Program approach to selectively answer queries, as defined in <ref> [3] </ref>. The method has been extended ([14]) to deal with constraints that have more atoms in the head. It is worth stressing again that constraints are used to cut out solutions, i.e. as further conditions that have to be satisfied.
Reference: [4] <author> Asirelli P., P. Inverardi and G. Plagenza. </author> <title> Correctness and Completeness of the SRP IC Refutation Procedure: </title> <note> Revised Version. Internal report IEI-CNR B4-05, </note> <month> Jan 95. </month>
Reference: [5] <author> Fitting M. </author> <title> A Kripke-Kleene Semantics for Logic programs, </title> <journal> in The Journal of Logic Programming, 1985, </journal> <volume> Vol. 2, Num. 4, </volume> <pages> pp. 295-312. </pages>
Reference-contexts: In fact, the totality requirement for models of general programs has been proved too strong, since it does not cover the whole class of general programs (see [16, 19]). The simplest example is the program p :p, which has no total models. In <ref> [5] </ref> Fitting associates to each general program a monotone operator on a space of three-valued logic interpretations, or better partial interpretations. This space is not a complete lattice, and the operators are not, in general, continuous. <p> This approach allows for a natural treatment of negation. Hence, we can use the same technique described in <ref> [5] </ref> to generalize the mapping T IC D in appendix B, thus obtaining a new mapping IC D whose least fixpoint can be chosen as the kernel of the three-valued counterpart of the Least Constrained Model.
Reference: [6] <author> Gaasterland, T., P. Godfrey, J. Minker and L. Novik. </author> <title> A Cooperative An swering System, </title> <booktitle> Proceedings of the Logic Programming and Automated Reasoning Conference, edited by Andrei Voronkov, Lecture Notes in Artificial Intelligence 624, </booktitle> <publisher> Springer-Verlag, </publisher> <address> St. Petersburg, Russia, </address> <pages> pages 478-480, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: In fact, if views on one side can be considered as adding new query capabilities (adding new relations) as in the case of the Datalog family, here we also consider their aspect of hiding some knowledge as in <ref> [6] </ref>. 2. Prototyping applications. In fact we believe that this is one important role that deductive databases can play. In this case it is important to be able to modify the knowledge as fast as possible with no long recompilation and general proof of consistency. <p> The various approaches to Integrity Constraint Checking proposed in the literature so far, can in fact be also characterized according to the strategy the integrity checking methods are based on. Referring to this aspect, we introduce the distinction between interpretative (notably [12, 17]) and compilative (no-tably <ref> [2, 3, 6] </ref>) approaches. In this respect our method, that integrates query answering with integrity checking, can be seen as an interpretative version of the modified-program approach described in [3] and of the integrity constraint operators among theories of [2]. <p> This use of constraints as a means to restrict the set of possible answers to a query on a database also appears in <ref> [6] </ref>. However, that method differs from 3 ours since it adopts a compilative approach. Another minor difference concerns the syntax of constraints: their method uses denials. This detailed abstract is structured as follows. In the next section an informal introduction of the method is presented by means of simple examples.
Reference: [7] <editor> Gallaire, H., J. Minker and J.M. Nicolas. </editor> <booktitle> Advances in Database Theory (vol. II), Proceedings of the Workshop on Logical Bases for Databases, </booktitle> <address> Toulouse, </address> <year> 1982 </year>
Reference: [8] <author> Jaffar, J. and J.M. Maher. </author> <title> Constraint Logic Programming: a Survey. </title> <journal> Jour nal of Logic Programming, </journal> <volume> 19 </volume> <pages> 503-581, </pages> <year> 1994. </year>
Reference: [9] <author> Kowalski, R.A. </author> <title> Logic for Problem Solving. </title> <publisher> Elsevier, </publisher> <address> New York, </address> <year> 1979 </year>
Reference: [10] <author> Kowalski, R.A. </author> <title> Using Meta-logic to Reconcile Reactive with Rational Agents, </title> <booktitle> in Meta-logics and Logic Programming, K.R. </booktitle> <editor> Apt and F.Turini [eds.], </editor> <publisher> MIT Press, </publisher> <year> 1995 </year>
Reference-contexts: Some authors denote integrity constraints formulae as denials A 1 ; : : : ; A n (see [12, 17]), whereas some uses formulae as A ! B 1 ; : : : ; B n (see <ref> [3, 10] </ref>). * The intuitive semantics of a denial A 1 ; : : :; A n is that, for every ground instance of A 1 ^ : : : ^ A n , say (A 1 ^ : : : ^ A n ), there must exist at least one <p> All proposed methods, as Kowalski summarizes <ref> [10] </ref>, have tried to give a different formal characterization to the above informal semantics of integrity constraints. These include a: * theoremhood view (see [12, 3]), * consistency view (see [17]), * epistemic (see [15]) or metalevel view (see [17]). Besides, the different integrity checking methods have followed different strategies.
Reference: [11] <author> Kowalski R. and F. Sadri. </author> <title> Logic Programs with Exceptions. </title> <booktitle> Proc. of the 7th Int. Conf on Logic Programming, </booktitle> <editor> DHD Warren and P. Szeredi (Eds), </editor> <address> Israel, June 1990. </address> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass. </address>
Reference-contexts: This means that IC are here dealt with in a more general way. They can be used for secrecy maintenance or for showing only the information that satisfy certain characteristics and, furthermore, to define some exceptions to database rules thus implementing Default Reasoning like in <ref> [11] </ref>. Moreover, due to its interpretative nature, our aproach permits both the database and the set of view constraints to dinamically change without affecting the resolution performance, since no recompilation due to modifications is necessary.
Reference: [12] <author> Lloyd, J.W. and R.W. Topor, </author> <title> "A Basis for Deductive Database Systems", </title> <journal> Journal of Logic Programming 2, </journal> <volume> 2 (1985), </volume> <pages> 93-109. </pages>
Reference-contexts: CHRX-CT94-0531 and "The Exploratory Activity EC-US" n. 033 Integrity constraints formulae and verification methods in this area have been proposed by different authors. Some authors denote integrity constraints formulae as denials A 1 ; : : : ; A n (see <ref> [12, 17] </ref>), whereas some uses formulae as A ! B 1 ; : : : ; B n (see [3, 10]). * The intuitive semantics of a denial A 1 ; : : :; A n is that, for every ground instance of A 1 ^ : : : ^ A <p> All proposed methods, as Kowalski summarizes [10], have tried to give a different formal characterization to the above informal semantics of integrity constraints. These include a: * theoremhood view (see <ref> [12, 3] </ref>), * consistency view (see [17]), * epistemic (see [15]) or metalevel view (see [17]). Besides, the different integrity checking methods have followed different strategies. <p> The various approaches to Integrity Constraint Checking proposed in the literature so far, can in fact be also characterized according to the strategy the integrity checking methods are based on. Referring to this aspect, we introduce the distinction between interpretative (notably <ref> [12, 17] </ref>) and compilative (no-tably [2, 3, 6]) approaches. In this respect our method, that integrates query answering with integrity checking, can be seen as an interpretative version of the modified-program approach described in [3] and of the integrity constraint operators among theories of [2].
Reference: [13] <author> Lloyd J.W. </author> <title> Foundations of logic programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. 9 </note>
Reference: [14] <author> Pizzala G. Uso Interpretativo di Vincoli d'Integrita. </author> <booktitle> Thesis of the Univer sity of Pisa, </booktitle> <month> March </month> <year> 1992. </year>
Reference: [15] <author> Reiter, R. </author> <title> On asking what a database knows. </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Com putational Logic, </booktitle> <pages> pages 96-113. </pages> <publisher> Springer Verlag, Esprit Basic Research Series, </publisher> <year> 1990 </year>
Reference-contexts: All proposed methods, as Kowalski summarizes [10], have tried to give a different formal characterization to the above informal semantics of integrity constraints. These include a: * theoremhood view (see [12, 3]), * consistency view (see [17]), * epistemic (see <ref> [15] </ref>) or metalevel view (see [17]). Besides, the different integrity checking methods have followed different strategies. In fact, they can: i) assume the database is consistent, check at update time that the update preserves consistency and accept it or reject it.
Reference: [16] <author> Sacca D. and C. Zaniolo. </author> <title> Stable Models and Non-Determinism for Logic Programs with Negation, </title> <booktitle> in Proceedings of the ACM SIGMOD-SIGACT Symposium on Principles of Database Systems, </booktitle> <year> 1990, </year> <pages> pp. 205-217. </pages>
Reference-contexts: In fact, the totality requirement for models of general programs has been proved too strong, since it does not cover the whole class of general programs (see <ref> [16, 19] </ref>). The simplest example is the program p :p, which has no total models. In [5] Fitting associates to each general program a monotone operator on a space of three-valued logic interpretations, or better partial interpretations.
Reference: [17] <author> Sadri F. and R. Kowalski. </author> <title> A Theorem-Proving Approach to Database Integrity. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundation of Deductive Databases and Logic Programming, </booktitle> <pages> pages 313-362. </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1987. </year>
Reference-contexts: CHRX-CT94-0531 and "The Exploratory Activity EC-US" n. 033 Integrity constraints formulae and verification methods in this area have been proposed by different authors. Some authors denote integrity constraints formulae as denials A 1 ; : : : ; A n (see <ref> [12, 17] </ref>), whereas some uses formulae as A ! B 1 ; : : : ; B n (see [3, 10]). * The intuitive semantics of a denial A 1 ; : : :; A n is that, for every ground instance of A 1 ^ : : : ^ A <p> All proposed methods, as Kowalski summarizes [10], have tried to give a different formal characterization to the above informal semantics of integrity constraints. These include a: * theoremhood view (see [12, 3]), * consistency view (see <ref> [17] </ref>), * epistemic (see [15]) or metalevel view (see [17]). Besides, the different integrity checking methods have followed different strategies. In fact, they can: i) assume the database is consistent, check at update time that the update preserves consistency and accept it or reject it. <p> All proposed methods, as Kowalski summarizes [10], have tried to give a different formal characterization to the above informal semantics of integrity constraints. These include a: * theoremhood view (see [12, 3]), * consistency view (see <ref> [17] </ref>), * epistemic (see [15]) or metalevel view (see [17]). Besides, the different integrity checking methods have followed different strategies. In fact, they can: i) assume the database is consistent, check at update time that the update preserves consistency and accept it or reject it. <p> The various approaches to Integrity Constraint Checking proposed in the literature so far, can in fact be also characterized according to the strategy the integrity checking methods are based on. Referring to this aspect, we introduce the distinction between interpretative (notably <ref> [12, 17] </ref>) and compilative (no-tably [2, 3, 6]) approaches. In this respect our method, that integrates query answering with integrity checking, can be seen as an interpretative version of the modified-program approach described in [3] and of the integrity constraint operators among theories of [2].
Reference: [18] <author> Ullman J.D. </author> <booktitle> Principles of Databases and Knowledge Base Systems, </booktitle> <volume> Vol 1-2, </volume> <publisher> Computer Science Press, </publisher> <year> 1989 </year>
Reference-contexts: Note that this interpretation of logic-based databases is only slightly different from the Datalog oriented ones <ref> [1, 18] </ref> and our results can be easily adopted in that context.
Reference: [19] <author> Van Gelder A., K.A. Ross and J.S. Schlipf. </author> <title> Unfounded Sets and the Well Founded Semantics for General Logic Programs, </title> <booktitle> in Proceedings of the ACM SIGMOD-SIGACT Symposium on Principles of Database Systems, </booktitle> <year> 1988, </year> <pages> pp. 221-230. </pages>
Reference-contexts: In fact, the totality requirement for models of general programs has been proved too strong, since it does not cover the whole class of general programs (see <ref> [16, 19] </ref>). The simplest example is the program p :p, which has no total models. In [5] Fitting associates to each general program a monotone operator on a space of three-valued logic interpretations, or better partial interpretations.
References-found: 19

