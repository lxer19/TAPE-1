URL: ftp://ftp.cs.clemson.edu/techreports/95-112.ps.Z
Refering-URL: http://www.cs.clemson.edu/html/research/techrpt.shtml
Root-URL: http://www.cs.clemson.edu
Email: fmazin,guptag@cs.clemson.edu  
Title: GURU A retargetable cfg-based program reorganizer  
Author: Mazin Ramadan and Devidas Gupta 
Address: Clemson, SC 29634  
Affiliation: Department of Computer Science Clemson University  
Abstract: We present a program reorganization framework that permits the design, development, implementation and evaluation of cache optimizations for program reorganization. The framework is supported by Guru, a program reorganization tool. Reorganization techniques can be implemented and interfaced to Guru in a high-level programming language or a script language. The framework is language independent and can be ported to different architectures. We also present results from experimentation using Guru. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Some of the tools available for program profiling and address tracing are also discussed. 2.1 Program Representation A basic block is a sequence of consecutive statements in which flow of control enters at the beginning and leaves at the end without halt or possibility of branching except at the end <ref> [1] </ref>. A control flow graph (CFG) is a directed graph, where each vertex in the graph represents a basic block of instructions and each edge 2 Vidya: pronounced veed-yaa; meaning knowledge. Vidya provides knowledge on reorganization to Guru. 3 Shishya: pronounced sheesh-yaa; meaning protege.
Reference: [2] <author> Thomas Ball and James R. Larus. </author> <title> Optimally profiling and tracing programs. </title> <type> Technical Report 1301, </type> <institution> Computer Sciences Department, University of Wisconsin-Madison, Madison, WI 53706, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: Vidya provides knowledge on reorganization to Guru. 3 Shishya: pronounced sheesh-yaa; meaning protege. Shishya provides a subset of program manipulation routines. 2 represents the transfer of control from one basic block to another <ref> [2] </ref>. A CFG has one BEGIN vertex and one END vertex. A vertex is a BEGIN vertex if and only if all edges incident to the vertex are outgoing edges. <p> Similarly, a vertex is an END vertex if and only if all edges incident to the vertex are incoming edges. 2.2 Program Profiling Profiling is a weight assignment to the CFG edges and/or vertices <ref> [2] </ref>. Weights on the vertices represent the execution frequency of basic blocks. Similarly, weights on the edges represent the frequency of control transfer between blocks. There are two types of profiling, dynamic and static. Dynamic profiling is obtained by instrumenting programs with counters. <p> To obtain the edge frequencies, counters must be inserted at every edge. The vertex frequency of a block can be obtained from the edge frequencies by adding the frequencies of all edges incident on the block. Insertion of counters increases the execution time of programs. Ball and Larus <ref> [2] </ref> present a technique to reduce the number of profiling counters by a factor of two. Machine hardware can also be used to obtain fast profiling. Conte, Patel et al.[5] present a technique that uses branch history hardware to achieve a fast profiling technique.
Reference: [3] <author> Thomas Ball and James R. Larus. </author> <title> Branch prediction for free. </title> <booktitle> Proceedings of the ACM SIGPLAN'93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 300-313, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Smith [13] showed that rules based on opcodes and the sign of displacement had a misprediction rate of about 30% compared to a 50% misprediction rate for naive prediction. Ball and Larus <ref> [3] </ref> present a technique based on the structure of the program and the instructions surrounding the conditional branches which results in a misprediction rate of 20%.
Reference: [4] <author> C. Comar, E. Schonberg, and F. Gasperoni. </author> <title> The gnat project: A gnu ada 9x compiler. </title> <type> Technical report, </type> <address> New York University, New York, </address> <year> 1995. </year>
Reference-contexts: The framework is based on our reorganizing tool, Guru. 3.1 Overview of the Guru-centered reorganizing framework code generated by the Gnu [7] family of compilers, such as gcc, gnat <ref> [4] </ref> and g++. The input program is transformed into a control flow graph and displayed using xvcg [12]. The framework includes three tools, Guru the reorganizing tool, Vidya a script interface to Guru and Shishya a programming language interface to Guru.
Reference: [5] <author> Thomas M. Conte, Burzin A. Patel, and J. Stan Cox. </author> <title> Using branch handling hardware to support profile-driven optimization. </title> <booktitle> Proceedings of the 27th Annual International Symposium on Mocroarchitecture, </booktitle> <pages> pages 12-21, </pages> <month> November </month> <year> 1994. </year>
Reference: [6] <author> Intel Corporation. </author> <title> Pentium processor data book. </title> <year> 1993. </year>
Reference-contexts: We present the internal representation of the source assembly program, the format for the output graphs, the Shishya subsystem and the reorganization support provided. The Guru framework is currently available on the Linux platform with gcc support. The framework supports the Pentium/i486 <ref> [6] </ref> architecture. 4.1 Source program representation hierarchical link list that begins with a list of files comprising the program. As depicted in figure 3 each file has a list of procedures.
Reference: [7] <institution> Free Software Foundation Inc. Gnu info tree. </institution> <note> http://www.ai.mit.edu/!info/dir/!!first, June 1994. </note>
Reference-contexts: ATOM does not provide support for program reorganization. 3 The GURU reorganizing framework We now present our reorganizing framework for designing, developing and evaluating cache optimizations. The framework is based on our reorganizing tool, Guru. 3.1 Overview of the Guru-centered reorganizing framework code generated by the Gnu <ref> [7] </ref> family of compilers, such as gcc, gnat [4] and g++. The input program is transformed into a control flow graph and displayed using xvcg [12]. The framework includes three tools, Guru the reorganizing tool, Vidya a script interface to Guru and Shishya a programming language interface to Guru. <p> The behavior of the program may depend on the source language. Guru provides a retargetable environment with reorganization capabilities that port to different architectures, different operating systems and different languages. The portability of Guru is constrained by the support provided by gnu <ref> [7] </ref> for a particular environment. We now detail some of the portability features of Guru. 3.6.1 Multiplatform support of the reorganizing framework and target programs The reorganization framework can be supported on various platforms. Guru is written in C.
Reference: [8] <author> James R. Larus and Thomas Ball. </author> <title> Rewriting executable files to measure program behavior. </title> <journal> Software, Practice and Experience, </journal> <volume> 24(2) </volume> <pages> 197-281, </pages> <month> February </month> <year> 1994. </year> <month> 13 </month>
Reference-contexts: Guru provides the researcher with a flexible tool that can be used to profile and reorganize programs, allowing the researcher to focus on the optimizations rather than the means to optimize. There are tools available to instrument and profile programs <ref> [8, 11, 14, 15, 16] </ref>, and obtain information that might aid cache optimizations. But the tools lack a supporting environment that facilitates the design, implementation and evaluation of optimization techniques using the profiled information. Cache optimizations are often architecture dependent. <p> Some of the tools perform a multitude of tasks while others have a limited scope. Profiling tools like Pixie [14], Epoxie [16], 3 and QPT <ref> [8] </ref> profile basic blocks and provide the block execution counts. Program execution can be traced resulting in address traces of either data or instruction addresses, or both. These address traces can be mapped back to the program to generate a trace of the program execution path.
Reference: [9] <author> Edward McLellan. </author> <title> The alpha axp architecture and 21064 processor. </title> <booktitle> IEEE MICRO, </booktitle> <pages> pages 36-46, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Providing a GUI interface for the framework * Design and implementation of the vidya interpreter * Providing data flow analysis capabilities * Providing a Sanity Checker to ensure that program reorganization preserves the semantics of the original program 11 * Porting the framework to other architectures such as DEC Alpha <ref> [9] </ref>, SPARC and PowerPC [10] * Providing support for compilers other than gcc 5 Experimentation Table 1 lists some of the measurements reported by Guru for a suite of 3 programs in two different source languages.
Reference: [10] <author> George Paap and Ed Silha. </author> <title> Powerpc: A performance architecture. </title> <booktitle> IEEE COMPCON Spring 1993, </booktitle> <pages> pages 104-108, </pages> <year> 1993. </year>
Reference-contexts: for the framework * Design and implementation of the vidya interpreter * Providing data flow analysis capabilities * Providing a Sanity Checker to ensure that program reorganization preserves the semantics of the original program 11 * Porting the framework to other architectures such as DEC Alpha [9], SPARC and PowerPC <ref> [10] </ref> * Providing support for compilers other than gcc 5 Experimentation Table 1 lists some of the measurements reported by Guru for a suite of 3 programs in two different source languages. Figure 5 shows a snapshot of the xvcg display for the annotated CFG produced while profiling Guru.
Reference: [11] <author> Jim Pierce and Trevor Mudge. </author> <title> Idtrace a tracing tool for i486 simulation. </title> <type> Technical report, </type> <institution> Department of Electrical Engineering and Computer Science, The University of Michigan, Ann Arbor, Michigan, </institution> <year> 1994. </year>
Reference-contexts: Guru provides the researcher with a flexible tool that can be used to profile and reorganize programs, allowing the researcher to focus on the optimizations rather than the means to optimize. There are tools available to instrument and profile programs <ref> [8, 11, 14, 15, 16] </ref>, and obtain information that might aid cache optimizations. But the tools lack a supporting environment that facilitates the design, implementation and evaluation of optimization techniques using the profiled information. Cache optimizations are often architecture dependent. <p> Program execution can be traced resulting in address traces of either data or instruction addresses, or both. These address traces can be mapped back to the program to generate a trace of the program execution path. Pixie and QPT can generate address traces. IDtrace <ref> [11] </ref> is a specialized tracing tool for the ix86 instruction set and produces full execution traces, profiles and memory references which can then be analyzed and used to study program behavior. Systems are available for building customized tools.
Reference: [12] <author> G. Sander. </author> <title> Graph layout throgh the vcg tool. </title> <booktitle> Proceedings of the DIMACS International Workshop GD'94, </booktitle> <pages> pages 194-205, </pages> <year> 1995. </year>
Reference-contexts: The framework is based on our reorganizing tool, Guru. 3.1 Overview of the Guru-centered reorganizing framework code generated by the Gnu [7] family of compilers, such as gcc, gnat [4] and g++. The input program is transformed into a control flow graph and displayed using xvcg <ref> [12] </ref>. The framework includes three tools, Guru the reorganizing tool, Vidya a script interface to Guru and Shishya a programming language interface to Guru. Vidya and Shishya are complementary tools and either of them can be used to educate Guru on the reorganization technique.
Reference: [13] <author> James E. Smith. </author> <title> A study of branch prediction strategies. </title> <booktitle> Proceedings of the 8th Annual International Symposium on Compuetr Architecture, </booktitle> <year> 1981. </year>
Reference-contexts: Static profiling techniques use a common set of rules to estimate the probability of the direction of a conditional branch. The rules are heuristics derived from the structure of the program and/or statistics obtained from a suite of programs. Smith <ref> [13] </ref> showed that rules based on opcodes and the sign of displacement had a misprediction rate of about 30% compared to a 50% misprediction rate for naive prediction.
Reference: [14] <author> M. Smith. </author> <title> Tracing with pixie. </title> <type> Technical report, </type> <institution> Center for Integrated Systems, Stanford University, Stanford, </institution> <address> CA, </address> <year> 1986. </year>
Reference-contexts: Guru provides the researcher with a flexible tool that can be used to profile and reorganize programs, allowing the researcher to focus on the optimizations rather than the means to optimize. There are tools available to instrument and profile programs <ref> [8, 11, 14, 15, 16] </ref>, and obtain information that might aid cache optimizations. But the tools lack a supporting environment that facilitates the design, implementation and evaluation of optimization techniques using the profiled information. Cache optimizations are often architecture dependent. <p> Some of the tools perform a multitude of tasks while others have a limited scope. Profiling tools like Pixie <ref> [14] </ref>, Epoxie [16], 3 and QPT [8] profile basic blocks and provide the block execution counts. Program execution can be traced resulting in address traces of either data or instruction addresses, or both.
Reference: [15] <author> Amitabh Srivastava and Alan Eustace. </author> <title> Atom: A system for building customized program analysis tools. </title> <booktitle> Proceedings of the ACM SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 196-205, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Guru provides the researcher with a flexible tool that can be used to profile and reorganize programs, allowing the researcher to focus on the optimizations rather than the means to optimize. There are tools available to instrument and profile programs <ref> [8, 11, 14, 15, 16] </ref>, and obtain information that might aid cache optimizations. But the tools lack a supporting environment that facilitates the design, implementation and evaluation of optimization techniques using the profiled information. Cache optimizations are often architecture dependent. <p> Pixie and QPT can generate address traces. IDtrace [11] is a specialized tracing tool for the ix86 instruction set and produces full execution traces, profiles and memory references which can then be analyzed and used to study program behavior. Systems are available for building customized tools. ATOM <ref> [15] </ref> is a system that uses OM link-time technology to customize and build profilers. ATOM is a general purpose tool builder and requires the researcher to supply the profiling routines which are then inserted at appropriate points in the target programs.
Reference: [16] <author> David W. Wall. </author> <title> Systems for late code modification. </title> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Guru provides the researcher with a flexible tool that can be used to profile and reorganize programs, allowing the researcher to focus on the optimizations rather than the means to optimize. There are tools available to instrument and profile programs <ref> [8, 11, 14, 15, 16] </ref>, and obtain information that might aid cache optimizations. But the tools lack a supporting environment that facilitates the design, implementation and evaluation of optimization techniques using the profiled information. Cache optimizations are often architecture dependent. <p> Some of the tools perform a multitude of tasks while others have a limited scope. Profiling tools like Pixie [14], Epoxie <ref> [16] </ref>, 3 and QPT [8] profile basic blocks and provide the block execution counts. Program execution can be traced resulting in address traces of either data or instruction addresses, or both. These address traces can be mapped back to the program to generate a trace of the program execution path.
Reference: [17] <author> Cliff Young and Michael D. Smith. </author> <title> Improving the accuracy of static branch prediction using branch correlation. </title> <booktitle> Proceedings of the 6th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 232-241, </pages> <month> October </month> <year> 1994. </year> <month> 14 </month>
Reference-contexts: Ball and Larus [3] present a technique based on the structure of the program and the instructions surrounding the conditional branches which results in a misprediction rate of 20%. Branch correlation was used by Young and Smith <ref> [17] </ref> to predict taken branches. 2.3 Tools for Profiling and Trace Generation A variety of tools are available for developing and evaluating cache optimization algorithms. Some of the tools perform a multitude of tasks while others have a limited scope.
References-found: 17

