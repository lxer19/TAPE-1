URL: http://www.ags.uni-sb.de/~melis/Pub/SR-96-10.ps
Refering-URL: http://jswww.cs.uni-sb.de/~melis/
Root-URL: 
Email: UCKEN  
Title: F A  
Author: CHBEREICH SEKI 
Web: GERMANYWWW: http://jswww.cs.uni-sb.de/pub/www/  
Address: SAARBR  
Affiliation: UNIVERSIT AT SAARLANDES  INF ORMA TIK  Rep  
Abstract: rt Island Planning and Refinement Erica Melis SEKI Report SR-96-10 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Autexier. </author> <title> Heuristiken zum Beweisen von Gleichungen. </title> <type> Master's thesis, </type> <institution> FB Informatik, Universitat des Saarlandes, </institution> <year> 1996. </year>
Reference-contexts: In ABSFOL [12] the mapping back is supported for user-provided abstractions. Hutter and Au-texier proposed concrete abstractions for equational theorem proving such as maximal symbols multiset used in our example above, path to common skelton parts, rewriting abstraction in <ref> [18, 1, 17] </ref> for particular problems in theorem proving. In planning, declarative control-rules for choosing goals, operators, and bindings are used in Prodigy [27] and such a control is also described in [2]. 12
Reference: [2] <author> A. Barrett, K. Golden, J.S. Penberthy, and D. Weld. </author> <note> USPOP User's Manual, Version 2.0. </note> <institution> Dept.of Computer Science and Engineering, University of Washington, </institution> <year> 1993. </year> <note> Technical Report 93-09-06. </note>
Reference-contexts: In planning, declarative control-rules for choosing goals, operators, and bindings are used in Prodigy [27] and such a control is also described in <ref> [2] </ref>. 12
Reference: [3] <author> A. Bundy. </author> <title> The use of explicit plans to guide inductive proofs. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proc. 9th International Conference on Automated Deduction (CADE), volume 310 of Lecture Notes in Computer Science, </booktitle> <pages> pages 111-120, </pages> <address> Argonne, 1988. </address> <publisher> Springer. </publisher>
Reference-contexts: Planning strategies employed so far in the proof planners CL A M [6] and omega [15] respectively, are forward and backward state-space refinement, HTN-like planning, and precondition abstraction. HTN-like operators can be expanded to subplans. E.g., the method induction-strategy in the proof planner CL A M <ref> [3] </ref> and the diagonal-method in omega are operators expanding to sub-plans. In omega, a fixed precondition abstraction of operators is possible that postpones the achievement of a particular precondition to a hierarchically lower planning level.
Reference: [4] <author> A. Bundy, Stevens A, F. Van Harmelen, A. Ireland, and A. Smaill. </author> <title> A heuristic for guiding inductive proofs. </title> <journal> Artificial Intelligence, </journal> <volume> 63 </volume> <pages> 185-253, </pages> <year> 1993. </year>
Reference-contexts: The latter also serves to structure plans. The search-space-problem applies to proof planning as well. As a result, rippling aspecific meta-level control is used in CL A M [6] for planning inductive proofs <ref> [4, 16] </ref> but this does not solve search problems in general proof planning. One step towards solving the structured-plan-problem in proof planning is the definition of operators that provide a sequence of calculus-level proof steps 1 when executed. In this way, proof plans are abstract representations of calculus-level proofs. <p> The corresponding context is constructed from the remaining parts of the formula in (2) the corresponding context is f. The notions skeleton and context were coined by Hutter and Bundy for rippling in <ref> [16, 4] </ref>. 10 The antecendent is abstracted away. 6 level by mapping back the operator, its preconditions, and its postconditions.
Reference: [5] <author> A. Bundy, F. Giunchiglia, R. Sebastiani, and T. Walsh. </author> <title> Computing abstraction hierarchies by numerial simulation. </title> <booktitle> In Proceedings of the 13th National Conference on AI, </booktitle> <pages> pages 523-529. </pages> <publisher> AAAI, </publisher> <year> 1996. </year>
Reference-contexts: For a discussion see, for instance [10, 22]. Another problem we face in some domains is the need for structured plans that are intelligible for the user. In order to restrict the search space, planning in abstraction spaces by precondition-abstraction, for instance in <ref> [29, 23, 5] </ref>, and hierarchical task network planning (HTN) [30, 8] have been suggested. The latter also serves to structure plans. The search-space-problem applies to proof planning as well.
Reference: [6] <author> A. Bundy, F. van Harmelen, J. Hesketh, and A. Smaill. </author> <title> Experiments with proof plans for induction. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 7 </volume> <pages> 303-324, </pages> <year> 1991. </year>
Reference-contexts: The latter also serves to structure plans. The search-space-problem applies to proof planning as well. As a result, rippling aspecific meta-level control is used in CL A M <ref> [6] </ref> for planning inductive proofs [4, 16] but this does not solve search problems in general proof planning. One step towards solving the structured-plan-problem in proof planning is the definition of operators that provide a sequence of calculus-level proof steps 1 when executed. <p> Planning strategies employed so far in the proof planners CL A M <ref> [6] </ref> and omega [15] respectively, are forward and backward state-space refinement, HTN-like planning, and precondition abstraction. HTN-like operators can be expanded to subplans. E.g., the method induction-strategy in the proof planner CL A M [3] and the diagonal-method in omega are operators expanding to sub-plans.
Reference: [7] <author> J. Cleve and D. Hutter. </author> <title> A methodology for equational reasoning. </title> <editor> In J.F. Nunamaker and R.H. Sprague, editors, </editor> <booktitle> Hawaii International Conference on System Sciences. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: RHS differ in the (position of a) context only, then prefer an abstraction to the position of the context relative to the skeleton. * If the current goal is an equational formula and the LHS and RHS differ in the number of function occurrences, then prefer the # function-occurrence abstraction <ref> [7] </ref>.
Reference: [8] <author> K.W. Currie and A. Tate. O-plan: </author> <title> The open planning architecture. </title> <journal> Artificial Intelligence, </journal> <volume> 52(1), </volume> <year> 1991. </year>
Reference-contexts: Another problem we face in some domains is the need for structured plans that are intelligible for the user. In order to restrict the search space, planning in abstraction spaces by precondition-abstraction, for instance in [29, 23, 5], and hierarchical task network planning (HTN) <ref> [30, 8] </ref> have been suggested. The latter also serves to structure plans. The search-space-problem applies to proof planning as well.
Reference: [9] <author> P. Deussen. </author> <title> Halbgruppen und Automaten, </title> <booktitle> volume 99 of Heidelberger Taschenbucher. </booktitle> <publisher> Springer, </publisher> <year> 1971. </year>
Reference-contexts: Note that it is not essential to understand the mathematics behind the example. 3.1 Example Suppose we plan a proof of theorem 7.5.7 from Deussen's book "Halbgruppen und Automaten" <ref> [9] </ref> that states that the mapping from an F-semimodul T 1 4 Planning Algorithm PLAN ()/* Returns refinements of */ Parameters: sol procedure for picking solution candidates 1. Termination Check: If sol () returns a solution, return it and terminate. If it returns fail, fail. Otherwise continue. 2.
Reference: [10] <author> M. Drummond. </author> <title> On precondition achievement and the computational economics of automatic planning. </title> <booktitle> In Current Trends in AI Planning, </booktitle> <pages> pages 6-13. </pages> <publisher> IOS Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Refinement planning as unguided search is notoriously hard because of the combinatorial search involved. For realistic planning problems the intractable search space prevents many current refinement planning techniques from being successful. For a discussion see, for instance <ref> [10, 22] </ref>. Another problem we face in some domains is the need for structured plans that are intelligible for the user.
Reference: [11] <author> E. Fink and M. Veloso. </author> <title> Formalizing the Prodigy planning algorithm. </title> <editor> In M. Ghallab and A. Milani, editors, </editor> <booktitle> New Directions in Planning, </booktitle> <pages> pages 261-272. </pages> <publisher> IOS Press, </publisher> <address> Amsterdam, Oxford, </address> <year> 1996. </year> <note> Extended version as technical report CMU-CS-94-123, </note> <year> 1994. </year>
Reference-contexts: For proof planning we have presented exemplary control knowledge. Work on combining different strategies within one planning framework has been published by Kambhampati et al. [19, 20, 21] and for Prodigy in <ref> [11] </ref>. There is a variety of ideas about abstraction. Problem abstraction to guide problem solving has, for instance, been addressed in [23, 13, 31]. More specifically in theorem proving a classical paper is Plaisted's [28]. In ABSFOL [12] the mapping back is supported for user-provided abstractions.
Reference: [12] <author> F. Giunchiglia and A. Villafiorita. ABSFOL: </author> <title> a Proof Checker with Abstraction. </title> <editor> In , editor, </editor> <booktitle> Proceedings of the 13th International Conference on Automated Deduction (CADE-13), </booktitle> <month> pages -, </month> <year> 1996. </year>
Reference-contexts: There is a variety of ideas about abstraction. Problem abstraction to guide problem solving has, for instance, been addressed in [23, 13, 31]. More specifically in theorem proving a classical paper is Plaisted's [28]. In ABSFOL <ref> [12] </ref> the mapping back is supported for user-provided abstractions. Hutter and Au-texier proposed concrete abstractions for equational theorem proving such as maximal symbols multiset used in our example above, path to common skelton parts, rewriting abstraction in [18, 1, 17] for particular problems in theorem proving.
Reference: [13] <author> F. Giunchiglia and T. Walsh. </author> <title> A theory of abstraction. </title> <journal> Artificial Intelligence, </journal> <volume> 57 </volume> <pages> 323-390, </pages> <year> 1992. </year> <month> 13 </month>
Reference-contexts: Work on combining different strategies within one planning framework has been published by Kambhampati et al. [19, 20, 21] and for Prodigy in [11]. There is a variety of ideas about abstraction. Problem abstraction to guide problem solving has, for instance, been addressed in <ref> [23, 13, 31] </ref>. More specifically in theorem proving a classical paper is Plaisted's [28]. In ABSFOL [12] the mapping back is supported for user-provided abstractions.
Reference: [14] <author> M. Gordon, R. Milner, </author> <title> and C.P. Wadsworth. Edinburgh LCF: A Mechanized Logic of Computation. </title> <booktitle> Lecture Notes in Computer Science 78. </booktitle> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1979. </year>
Reference-contexts: For more details about the state of the art see [26]. For proof planning two roads join, (1) the use of tactics and (2) meta-level control. As opposed to traditional automated theorem that applies calculus-level inference rules, i.e. low level inferences, proof planning relies on tactics <ref> [14] </ref>. Tactics are procedures that produce a (not necessarily fixed) sequence of calculus-level inferences when executed. Operators, are defined as specifications of tactics by pre- and postconditions.
Reference: [15] <author> X. Huang, M. Kerber, M. Kohlhase, and J. Richts. </author> <title> Methods the basic units for planning and verifying proofs. </title> <booktitle> In Proceedings of Jahrestagung fur Kunstliche Intelligenz KI-94, Saarbrucken, 1994. </booktitle> <publisher> Springer. </publisher>
Reference-contexts: Planning strategies employed so far in the proof planners CL A M [6] and omega <ref> [15] </ref> respectively, are forward and backward state-space refinement, HTN-like planning, and precondition abstraction. HTN-like operators can be expanded to subplans. E.g., the method induction-strategy in the proof planner CL A M [3] and the diagonal-method in omega are operators expanding to sub-plans.
Reference: [16] <author> D. Hutter. </author> <title> Guiding inductive proofs. In M.E. </title> <editor> Stickel, editor, </editor> <booktitle> Proc. of 10th International Conference on Automated Deduction (CADE), volume Lecture Notes in Artificial Intelligence 449. </booktitle> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: The latter also serves to structure plans. The search-space-problem applies to proof planning as well. As a result, rippling aspecific meta-level control is used in CL A M [6] for planning inductive proofs <ref> [4, 16] </ref> but this does not solve search problems in general proof planning. One step towards solving the structured-plan-problem in proof planning is the definition of operators that provide a sequence of calculus-level proof steps 1 when executed. In this way, proof plans are abstract representations of calculus-level proofs. <p> The corresponding context is constructed from the remaining parts of the formula in (2) the corresponding context is f. The notions skeleton and context were coined by Hutter and Bundy for rippling in <ref> [16, 4] </ref>. 10 The antecendent is abstracted away. 6 level by mapping back the operator, its preconditions, and its postconditions. <p> Table 2: Backward Island Planning rules for picking a goal and choosing an appropriate abstraction are needed and indicated by |. 12 rippling-in and rippling-out are notations from rippling <ref> [16] </ref> 8 Island planning is a refinement operation because the (abstract) steps and their constraints are introduced into the partial plan and restrict the solution candidates.
Reference: [17] <author> D. Hutter. </author> <title> Equalising terms by difference reduction techniques. </title> <institution> RP -, Univ. of Edinburgh, Department of AI, Edinburgh, </institution> <year> 1996. </year>
Reference-contexts: of the goal and the distinguished assumption differ in their multisets S 1 and S 2 of (maximal) symbols, then try to apply equations (or an equivalence or implication) that introduce a (large) subset of S 1 S 2 or removes a (large) subset of S 2 S 1 " <ref> [17] </ref>. This motivates the choice of the step ApplyEquation (5) in the progression from (8) that gives F 0 = f ( 1 (Y )): (9) 2 is a maximal symbol defined by and 1 in (5). <p> Choose-abstraction control knowledge. * If the current goal is an equational formula and the LHS and RHS differ in the occurring function symbols, then prefer the abstraction to maximal symbol multisets 13 described in <ref> [17] </ref>. 13 used in the subproblem refinements above 11 * If the current goal is an equational formula and the LHS and RHS differ in the (position of a) context only, then prefer an abstraction to the position of the context relative to the skeleton. * If the current goal is <p> In ABSFOL [12] the mapping back is supported for user-provided abstractions. Hutter and Au-texier proposed concrete abstractions for equational theorem proving such as maximal symbols multiset used in our example above, path to common skelton parts, rewriting abstraction in <ref> [18, 1, 17] </ref> for particular problems in theorem proving. In planning, declarative control-rules for choosing goals, operators, and bindings are used in Prodigy [27] and such a control is also described in [2]. 12
Reference: [18] <author> D. Hutter. </author> <title> Using rippling for equational reasoning. </title> <booktitle> In KI-96: Advances in Artificial Intelligence. 20th Annual German Conference on Artificial Intelligence, volume 1137 of LNAI, </booktitle> <pages> pages 121-133. </pages> <publisher> Springer, </publisher> <year> 1996. </year>
Reference-contexts: I.e., proof planning is classical planning which means planning in a static and deterministic environment with complete information. * Structured plans are clearly preferred by humans, see e.g. [25]. Difference reduction techniques proved to be useful for planning inductive and equational proofs <ref> [18] </ref> because you can define measures of the difference between induction hypothesis/induction conclusion and LHS/RHS, respectively and therefore measure the progress of reducing the difference. <p> In ABSFOL [12] the mapping back is supported for user-provided abstractions. Hutter and Au-texier proposed concrete abstractions for equational theorem proving such as maximal symbols multiset used in our example above, path to common skelton parts, rewriting abstraction in <ref> [18, 1, 17] </ref> for particular problems in theorem proving. In planning, declarative control-rules for choosing goals, operators, and bindings are used in Prodigy [27] and such a control is also described in [2]. 12
Reference: [19] <author> S. Kambhampati. </author> <title> A comparative analysis of partial-order planning and task reduction planning. </title> <journal> ACM SIGART Bulletin, Special Section on Evaluating Plans, Planners, and Planning Agents, </journal> <volume> 6(1) </volume> <pages> 16-25, </pages> <year> 1995. </year>
Reference-contexts: Structured proof plan construction can be supported by defining subproblems. We think that these ideas are more widely applicable in planning. The paper is organized as follows. First, we define some basic notions by extending Kambhampati's framework <ref> [21, 19] </ref> for unifying several planning strategies that may serve to integrate our island planning and refinement. We briefly review proof planning. Then a motivating example leads to island planning and refinement as well as subproblem refinement. These strategies are introduced as refinement operations. <p> That is, for any t 1 ; t 2 2 T sub , if t 1 t t 2 , then t 2 T sub . Aux is a set of auxiliary constraints. Kambhampati <ref> [19] </ref> includes the following auxiliary constraints in order to unify state-space and plan-space refinement on one representation of partial plans: * Interval preservation constraints specified by triples (t; p; t 0 ) * Point truth constraints specified by pairs (p; t) * Contiguity constraints specified by the relation t i fl <p> Hence we need control knowledge on when to choose which planning strategy in addition to the control knowledge used within planning strategies. For proof planning we have presented exemplary control knowledge. Work on combining different strategies within one planning framework has been published by Kambhampati et al. <ref> [19, 20, 21] </ref> and for Prodigy in [11]. There is a variety of ideas about abstraction. Problem abstraction to guide problem solving has, for instance, been addressed in [23, 13, 31]. More specifically in theorem proving a classical paper is Plaisted's [28].
Reference: [20] <author> S. Kambhampati, C. Knoblock, and Q. Yang. </author> <title> Planning as refinement search: A unified framework for evaluating design tradeoffs in partial-order planning. </title> <journal> Artificial Intelligence, special issue on Planning and Scheduling, </journal> <volume> 76: </volume> <year> 1995. </year>
Reference-contexts: Hence we need control knowledge on when to choose which planning strategy in addition to the control knowledge used within planning strategies. For proof planning we have presented exemplary control knowledge. Work on combining different strategies within one planning framework has been published by Kambhampati et al. <ref> [19, 20, 21] </ref> and for Prodigy in [11]. There is a variety of ideas about abstraction. Problem abstraction to guide problem solving has, for instance, been addressed in [23, 13, 31]. More specifically in theorem proving a classical paper is Plaisted's [28].
Reference: [21] <author> S. Kambhampati and B. Srivastava. </author> <title> Universal classical planner: An algorithm for unifying state-space and plan-space planning. </title> <editor> In M. Ghallab and A. Milani, editors, </editor> <booktitle> New Directions in AI Planning, </booktitle> <pages> pages 61-78. </pages> <publisher> IOS Press, </publisher> <address> Amsterdam, Oxford, </address> <year> 1996. </year>
Reference-contexts: Structured proof plan construction can be supported by defining subproblems. We think that these ideas are more widely applicable in planning. The paper is organized as follows. First, we define some basic notions by extending Kambhampati's framework <ref> [21, 19] </ref> for unifying several planning strategies that may serve to integrate our island planning and refinement. We briefly review proof planning. Then a motivating example leads to island planning and refinement as well as subproblem refinement. These strategies are introduced as refinement operations. <p> Semantically, a refinement operation maps a partial plan to a set of partial plans f i g such that hhii hh i ii for all i . Kambhampati and Srivastava <ref> [21] </ref> define refinement operations for (forward and backward) state-space and plan-space refinement. They say that the control for choosing a refinement strategy has to be designed in the near future. <p> E.g., if e is (x 2 T ! x 2 = a), then ApplyEquality (e) applies (x 2 = a) and leaves (x 2 T ) as a precondition to be satisfied in a lower hierarchical level. 3 Island Planning and Refinement Similar to <ref> [21] </ref>, we combine several planning (refinement) strategies in a general planning algorithm. Table 1 shows the top-level control of the planner. The new strategies island planning, island refinement, and subproblem refinement are described in later subsections. The selected strategy is applied to the partial plan to generate refinements. <p> Hence we need control knowledge on when to choose which planning strategy in addition to the control knowledge used within planning strategies. For proof planning we have presented exemplary control knowledge. Work on combining different strategies within one planning framework has been published by Kambhampati et al. <ref> [19, 20, 21] </ref> and for Prodigy in [11]. There is a variety of ideas about abstraction. Problem abstraction to guide problem solving has, for instance, been addressed in [23, 13, 31]. More specifically in theorem proving a classical paper is Plaisted's [28].
Reference: [22] <author> H. Kautz and B. Selman. </author> <title> Pushing the envelope: Planning, propositional logic, and stochastic search. </title> <booktitle> In Proceedings of the AAAI-96, </booktitle> <pages> pages 1194-1201. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Refinement planning as unguided search is notoriously hard because of the combinatorial search involved. For realistic planning problems the intractable search space prevents many current refinement planning techniques from being successful. For a discussion see, for instance <ref> [10, 22] </ref>. Another problem we face in some domains is the need for structured plans that are intelligible for the user.
Reference: [23] <author> C. A. Knoblock. </author> <title> Automatically generating abstractions for planning. </title> <journal> Artificial Intelligence, </journal> <volume> 68 </volume> <pages> 243-302, </pages> <year> 1994. </year>
Reference-contexts: For a discussion see, for instance [10, 22]. Another problem we face in some domains is the need for structured plans that are intelligible for the user. In order to restrict the search space, planning in abstraction spaces by precondition-abstraction, for instance in <ref> [29, 23, 5] </ref>, and hierarchical task network planning (HTN) [30, 8] have been suggested. The latter also serves to structure plans. The search-space-problem applies to proof planning as well. <p> Work on combining different strategies within one planning framework has been published by Kambhampati et al. [19, 20, 21] and for Prodigy in [11]. There is a variety of ideas about abstraction. Problem abstraction to guide problem solving has, for instance, been addressed in <ref> [23, 13, 31] </ref>. More specifically in theorem proving a classical paper is Plaisted's [28]. In ABSFOL [12] the mapping back is supported for user-provided abstractions.
Reference: [24] <author> G. Kreisel. </author> <title> Mathematical logic. </title> <editor> In T. Saaty, editor, </editor> <booktitle> Lectures on Modern Mathematics, </booktitle> <volume> volume 3, </volume> <pages> pages 95-195. </pages> <editor> J. </editor> <publisher> Wiley & Sons, </publisher> <year> 1965. </year>
Reference-contexts: For an analysis see <ref> [24] </ref> 3 * Often, infinitely many potential bindings have to be considered. Therefore, the control of bindings and an elaborate handling of B is needed. * The knowledge about the mathematical world is complete and certain.
Reference: [25] <author> U. Leron. </author> <title> Structuring mathematical proofs. </title> <journal> The American Mathematical Monthly, </journal> <volume> 90 </volume> <pages> 174-185, </pages> <year> 1983. </year>
Reference-contexts: I.e., proof planning is classical planning which means planning in a static and deterministic environment with complete information. * Structured plans are clearly preferred by humans, see e.g. <ref> [25] </ref>. Difference reduction techniques proved to be useful for planning inductive and equational proofs [18] because you can define measures of the difference between induction hypothesis/induction conclusion and LHS/RHS, respectively and therefore measure the progress of reducing the difference.
Reference: [26] <author> E. Melis and A. Bundy. </author> <title> Planning and proof planning. </title> <editor> In S. Biundo, editor, </editor> <booktitle> ECAI-96 Workshop on Cross-Fertilization in Planning, </booktitle> <pages> pages 37-40, </pages> <address> Budapest, </address> <year> 1996. </year> <month> 14 </month>
Reference-contexts: A motivation for proof planning is the fact that mathematicians tend to plan proofs. We give some essentials of proof planning only. For more details about the state of the art see <ref> [26] </ref>. For proof planning two roads join, (1) the use of tactics and (2) meta-level control. As opposed to traditional automated theorem that applies calculus-level inference rules, i.e. low level inferences, proof planning relies on tactics [14].
Reference: [27] <author> S. Minton, C. Knoblock, D. Koukka, Y. Gil, R. Joseph, and J. Carbonell. </author> <title> PRODIGY 2.0: The Manual and Tutorial. </title> <institution> School of Computer Science, Carnegie Mellon University, Pittsburgh, </institution> <year> 1989. </year> <month> CMU-CS-89-146. </month>
Reference-contexts: They can be encoded into compiled procedures or as declarative control-rules. Depending on the strictness of a heuristic, different types of control-rules can be designed: choose, don't-choose, and prefer rules <ref> [27] </ref>. For applying the state-space refinement strategies other kinds of control knowledge can be used, as practiced, e.g., in Prodigy [27]. <p> Depending on the strictness of a heuristic, different types of control-rules can be designed: choose, don't-choose, and prefer rules <ref> [27] </ref>. For applying the state-space refinement strategies other kinds of control knowledge can be used, as practiced, e.g., in Prodigy [27]. <p> In planning, declarative control-rules for choosing goals, operators, and bindings are used in Prodigy <ref> [27] </ref> and such a control is also described in [2]. 12
Reference: [28] <author> D. Plaisted. </author> <title> Theorem proving with abstraction. </title> <journal> Artificial Intelligence, </journal> <volume> 16 </volume> <pages> 47-108, </pages> <year> 1981. </year>
Reference-contexts: There is a variety of ideas about abstraction. Problem abstraction to guide problem solving has, for instance, been addressed in [23, 13, 31]. More specifically in theorem proving a classical paper is Plaisted's <ref> [28] </ref>. In ABSFOL [12] the mapping back is supported for user-provided abstractions. Hutter and Au-texier proposed concrete abstractions for equational theorem proving such as maximal symbols multiset used in our example above, path to common skelton parts, rewriting abstraction in [18, 1, 17] for particular problems in theorem proving.
Reference: [29] <author> E.D. Sacerdoti. </author> <title> Planning in a hierarchy of abstraction spaces. </title> <journal> Artificial Intelligence, </journal> <volume> 5 </volume> <pages> 115-135, </pages> <year> 1974. </year>
Reference-contexts: For a discussion see, for instance [10, 22]. Another problem we face in some domains is the need for structured plans that are intelligible for the user. In order to restrict the search space, planning in abstraction spaces by precondition-abstraction, for instance in <ref> [29, 23, 5] </ref>, and hierarchical task network planning (HTN) [30, 8] have been suggested. The latter also serves to structure plans. The search-space-problem applies to proof planning as well.
Reference: [30] <author> A. Tate. </author> <title> Generating project networks. </title> <booktitle> In Proceedings of the Fifth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 888-893. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1977. </year>
Reference-contexts: Another problem we face in some domains is the need for structured plans that are intelligible for the user. In order to restrict the search space, planning in abstraction spaces by precondition-abstraction, for instance in [29, 23, 5], and hierarchical task network planning (HTN) <ref> [30, 8] </ref> have been suggested. The latter also serves to structure plans. The search-space-problem applies to proof planning as well.
Reference: [31] <author> R. Washington and B. Hayes-Roth. </author> <title> Incremental abstraction planning for limited-time situations. </title> <editor> In M. Ghallab and A. Milani, editors, </editor> <booktitle> New Directions in Planning, </booktitle> <pages> pages 91-102. </pages> <publisher> IOS Press, </publisher> <address> Amsterdam, Oxford, </address> <year> 1996. </year> <month> 15 </month>
Reference-contexts: Work on combining different strategies within one planning framework has been published by Kambhampati et al. [19, 20, 21] and for Prodigy in [11]. There is a variety of ideas about abstraction. Problem abstraction to guide problem solving has, for instance, been addressed in <ref> [23, 13, 31] </ref>. More specifically in theorem proving a classical paper is Plaisted's [28]. In ABSFOL [12] the mapping back is supported for user-provided abstractions.
References-found: 31

