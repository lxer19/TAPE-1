URL: http://www.win.tue.nl/win/cs/csr/csr93/93.05.ps
Refering-URL: http://www.win.tue.nl/win/cs/csr/csr93.html
Root-URL: http://www.win.tue.nl
Email: e-mail: chrisv@win.tue.nl, josb@win.tue.nl  
Title: A congruence theorem for structured operational semantics with predicates  
Author: J.C.M. Baeten and C. Verhoef 
Address: P.O. Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Department of Mathematics and Computing Science Eindhoven University of Technology  
Abstract: We proposed a syntactical format, the path format, for structured operational semantics in which predicates may occur. We proved that strong bisim-ulation is a congruence for all the operators that can be defined within the path format. To show that this format is useful we provided many examples that we took from the literature about CCS, CSP, and ACP; they do satisfy the path format but no formats proposed by others. The examples include concepts like termination, convergence, divergence, weak bisimulation, a zero object, side conditions, functions, real time, discrete time, sequencing, negative premises, negative conclusions, and priorities (or a combination of these notions). Key Words & Phrases: structured operational semantics, term deduction system, transition system specification, structured state system, labelled transition system, strong bisimulation, congruence theorem, predicate. 1980 Mathematics Subject Classification (1985 Revision): 68Q05, 68Q55. CR Categories: D.3.1, F.1.1, F.3.2, F.4.3. Note: Partial support received from the European Communities under CONCUR 2, BRA 7166. 
Abstract-found: 1
Intro-found: 1
Reference: [ 1 ] <author> L. Aceto, M. Hennessy, </author> <title> Termination, deadlock and divergence, </title> <journal> JACM 39(1) </journal> <pages> 147-187, </pages> <year> 1992. </year>
Reference-contexts: They touch upon concepts like termination, convergence, divergence, weak bisimulation, a zero object, side conditions, functions, real time, discrete time, sequencing, negative premises, negative conclusions, and priorities (or a combination of these notions). The first example concerns an operational semantics that originates from Aceto and Hen-nessy <ref> [ 1 ] </ref> . It is an operational semantics of a CCS like process algebra extended with a successful termination predicate and a convergence predicate. Their approach is to first inductively define the termination predicate p , which is a postfix denoted predicate. <p> Their approach is to first inductively define the termination predicate p , which is a postfix denoted predicate. In table 2 we enumerate the rules as they essentially appear in <ref> [ 1 ] </ref> . In fact, Baeten and Van Glabbeek [ 6 ] have the same approach to successful termination. <p> However it is easy to define this predicate; we refer to [ 17 ] for an explicit operational semantics of the divergence predicate in path format. For more details on the process algebra of Aceto and Hennessy we refer to <ref> [ 1 ] </ref> . x !x 0 x !x 0 x !x 0 x ; y !y 0 x !x 0 x !x 0 x !x 0 ; y !y 0 o x !x 0 ; =2 H t [recx. t=x] recx. t Table 5. <p> We leave as an open problem whether a similar trick can also be applied for the CCS like process algebra of Aceto and Hennessy. We have not succeeded in coding the weak termination and convergence predicates of Aceto and Hennessy <ref> [ 1 ] </ref> in the path format. This seems to involve essential use of negative premises.
Reference: [ 2 ] <author> J. C. M. Baeten, J. A. Bergstra, </author> <title> Discrete Time Process Algebra, </title> <type> Report P9208b, </type> <institution> Programming Research Group, University of Amsterdam, </institution> <year> 1992. </year>
Reference-contexts: The next example is also an operational semantics with negative premises. It is a semantics of BPA with discrete time from Baeten and Bergstra <ref> [ 2 ] </ref> . In table 10 ` oe !' is just an extra relation: oe is not in their language. The extra rules are the ones with negative conclusions. Again it is easy to see that the rules are well-founded and in path format, so bisimulation is a congruence.
Reference: [ 3 ] <author> J. C. M. Baeten, J. A. Bergstra, </author> <title> Process algebra with a zero object, </title> <editor> in: J. C. M. Baeten and J. W. Klop, editors, </editor> <booktitle> Proceedings CONCUR 90, </booktitle> <address> Amsterdam, </address> <publisher> LNCS 458, </publisher> <pages> pp. 83-98, </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Operational rules for the silent step. The next example is an operational semantics of the language BPA 0 that originates from Baeten and Bergstra <ref> [ 3 ] </ref> . The theory BPA 0 is the language BPA (that we already saw above) with a zero object denoted by 0. <p> They have for this constant the following laws x + 0 = x; x0 = 0; 0x = 0: Baeten and Bergstra explicitly state in their paper: "We cannot define action rules in the format of Groote and Vaandrager [ 16 ] or Groote [ 15 ] " (see <ref> [ 3 ] </ref> , loc. cit. p. 87). The problems arise with the rules for the sequential composition: if x a !x 0 then we will only have xy a if y 6= 0.
Reference: [ 4 ] <author> J. C. M. Baeten, J. A. Bergstra, J. W. Klop, </author> <title> On the consistency of Koomen's fair abstraction rule, </title> <journal> TCS 51(1/2), </journal> <pages> pp. 129-176, </pages> <year> 1987. </year>
Reference-contexts: The subscript o stands for the silent move of Milner [ 20 ] . The operational semantics is given by the rules of tables 1 and 6. Van Glabbeek [ 14 ] observes that his model is isomorphic to the graph model of Baeten, Bergstra and Klop <ref> [ 4 ] </ref> .
Reference: [ 5 ] <author> J. C. M. Baeten, J. A. Bergstra, J. W. Klop, </author> <title> Syntax and defining equations for an interrupt mechanism in process algebra, </title> <journal> Fundamenta Informaticae IX, </journal> <pages> pp. 127-168, </pages> <year> 1986. </year>
Reference-contexts: BPA with discrete time. Finally, we give an operational semantics of BPA with the priority operator of Baeten, Bergstra, and Klop <ref> [ 5 ] </ref> . We want to stress that this example is not meant for practical purpose. The reason for giving it is to show that it can be done within our format. For practical use it is better to extend our format with negative premises.
Reference: [ 6 ] <author> J. C. M. Baeten, R. J. van Glabbeek, </author> <title> Merge and termination in process algebra, </title> <editor> in: K. V. Nori, editor, </editor> <booktitle> Proceedings 7th Conference on Foundations of Software Technology and Theoretical Computer Science, Pune, India, </booktitle> <volume> LNCS 287, </volume> <pages> pp. 153-172, </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Their approach is to first inductively define the termination predicate p , which is a postfix denoted predicate. In table 2 we enumerate the rules as they essentially appear in [ 1 ] . In fact, Baeten and Van Glabbeek <ref> [ 6 ] </ref> have the same approach to successful termination. We treat recursion in the same way as Groote and Vaan-drager [ 16 ] by adding process names recx. t to the signature for each t 2 O () to obtain that the recursion rules fit our format.
Reference: [ 7 ] <author> J. C. M. Baeten and F. W. Vaandrager, </author> <title> An algebra for process creation, </title> <journal> Acta Informatica 29, </journal> <pages> pp. 303-334, </pages> <year> 1992. </year>
Reference-contexts: We claim that this function is, in fact, a mixfix predicate and that the resulting operational semantics is well-founded and in path format. We promised in the introduction to return to the operational semantics with negative premises that Baeten and Vaandrager <ref> [ 7 ] </ref> give for BPA. We recall that they extend the signature of BPA with an auxiliary constant ffi and that they have ffix = x. They have this property because they model the sequential composition as a sequencing operator.
Reference: [ 8 ] <author> J. C. M. Baeten, W. P. Weijland, </author> <title> Process algebra, </title> <booktitle> Cambridge Tracts in Theoretical Com--puter Science 18, </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: Also here we have to show that x a 6! if and only if there is no x 0 with x a and not x ! . As a final remark we want to mention that all the positive transition systems appearing in the book of Baeten and Weijland <ref> [ 8 ] </ref> are in path format.
Reference: [ 9 ] <author> J. A. Bergstra, J. W. Klop, </author> <title> Algebra of communicating processes with abstraction, </title> <journal> TCS 37, </journal> <pages> 77-121, </pages> <year> 1985. </year>
Reference-contexts: This seems to involve essential use of negative premises. This next example is an operational semantics of Van Glabbeek [ 14 ] for BPA o , which is a fragment of the theory ACP o that originates from Bergstra and Klop <ref> [ 9 ] </ref> . The subscript o stands for the silent move of Milner [ 20 ] . The operational semantics is given by the rules of tables 1 and 6.
Reference: [ 10 ] <author> J. A. Bergstra, J. W. Klop, </author> <title> Fixed point semantics in process algebras, </title> <type> MC report IW 206, </type> <institution> Mathematical Centre, </institution> <address> Amsterdam, </address> <year> 1982. </year> <note> Revised version: </note> <author> J. A. Bergstra, J. W. Klop, </author> <title> A convergence theorem in process algebra, in Ten years of concurrency semantics: selected papers of the Amsterdam Concurrency Group, </title> <editor> editors J. W. de Bakker, J. J. M. M. Rutten, </editor> <publisher> World Scientific, </publisher> <pages> pp. 164-195, </pages> <year> 1992. </year>
Reference: [ 11 ] <author> B. Bloom, S. Istrail, and A. R. Meyer, </author> <title> Bisimulation can't be traced: preliminary report, </title> <booktitle> In: Proceedings 15th ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, California, </address> <pages> pp. 229-239, </pages> <year> 1988. </year>
Reference-contexts: However, it would be a better idea to incorporate recursion whitin our format as is done for the GSOS format <ref> [ 11 ] </ref> and De Simone's format [ 25 ] . nil p p p p p p p p p p p t [recx. t=x] p recx. t p Table 2. <p> For instance, which negative premises can be written as predicates? Another possibility to generalizing the path format is to incorporate recursion within it as is done for the GSOS format <ref> [ 11 ] </ref> and De Simone's format [ 25 ] . Finally, we conclude that the path format is a very practical format that can be used with a lot of ease in a wide range of applications.
Reference: [ 12 ] <author> W. J. Fokkink, </author> <type> personal communication, </type> <month> January </month> <year> 1993. </year>
Reference-contexts: It is an open question if the requirement of well-foundedness is really necessary. However, we heard from Fokkink <ref> [ 12 ] </ref> that the requirement is probably not necessary for the tyft/tyxt format and that his results easily generalize to our setting. Definition (5.2) Let T = (; D) be a term deduction system and let F be a set of formulas. <p> Property (ii ) says that if we can prove in the xenosystem that an old term u is related with a term v by means of an old relation R that v cannot be a xenoterm. A simple example due to Fokkink <ref> [ 12 ] </ref> shows that for this property the well-foundedness cannot be missed. Suppose that we have a signature that consists of a single constant a. We have two rules: xRx; aSx Clearly, this system is not well-founded.
Reference: [ 13 ] <author> K. Futatsugi, J.A. Goguen, J.-P. Jouannaud, J. Meseguer, </author> <booktitle> Principles of OBJ2, in Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <editor> editor B. </editor> <booktitle> Reid, </booktitle> <pages> pp. 52-66, </pages> <publisher> ACM, </publisher> <year> 1985. </year>
Reference-contexts: Since this is the case, we can see the side condition jQj T &lt; t as a mixfix (or distfix) predicate: j j T &lt; t (see <ref> [ 13 ] </ref> for the fix terminology). The only problem left is to define the maximal delay function in these terms.
Reference: [ 14 ] <author> R. J. van Glabbeek, </author> <title> Bounded nondeterminism and the approximation induction principle in process algebra, </title> <booktitle> In: Proceedings STACS 87 (F. </booktitle> <editor> J. Brandenburg, G. Vidal-Naquet, M. Wirsing, eds.), </editor> <publisher> LNCS 247, Springer Verlag, </publisher> <pages> pp. 336-347, </pages> <year> 1987. </year>
Reference-contexts: We have not succeeded in coding the weak termination and convergence predicates of Aceto and Hennessy [ 1 ] in the path format. This seems to involve essential use of negative premises. This next example is an operational semantics of Van Glabbeek <ref> [ 14 ] </ref> for BPA o , which is a fragment of the theory ACP o that originates from Bergstra and Klop [ 9 ] . The subscript o stands for the silent move of Milner [ 20 ] . <p> The subscript o stands for the silent move of Milner [ 20 ] . The operational semantics is given by the rules of tables 1 and 6. Van Glabbeek <ref> [ 14 ] </ref> observes that his model is isomorphic to the graph model of Baeten, Bergstra and Klop [ 4 ] .
Reference: [ 15 ] <author> J. F. Groote, </author> <title> Transition system specifications with negative premises, </title> <type> Report CS-R9850, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <year> 1989. </year> <note> An extended abstract appeared in: see [ 3 ] pp. 332-341. </note>
Reference-contexts: They have for this constant the following laws x + 0 = x; x0 = 0; 0x = 0: Baeten and Bergstra explicitly state in their paper: "We cannot define action rules in the format of Groote and Vaandrager [ 16 ] or Groote <ref> [ 15 ] </ref> " (see [ 3 ] , loc. cit. p. 87). The problems arise with the rules for the sequential composition: if x a !x 0 then we will only have xy a if y 6= 0. <p> This is a lot of work and is merely done to obtain that the transition system specifications are in ntyft format such that he gets the congruenceness for "free" with a theorem of Groote <ref> [ 15 ] </ref> . We claim that it is not necessary: the operational semantics that Klusener actually wants to discuss are well-founded and in path format. This result can be obtained in the same way as we sketched this for the above example of Moller and Tofts. <p> We strongly conjecture that we can prove a similar reduction/congruence theorem for the situation with negative premises by applying the congruence theorem of Groote <ref> [ 15 ] </ref> (that treats the situation with negative premises). First, we will define the notions necessary to state the main result and then we will prove it. Definition (5.1) Let T = (; D) be a term deduction system with D = D (T p ; T r ). <p> semantics that we took from the literature we showed that our format is rather practical: many operational semantics satisfy our format, whereas they do not satisfy formats proposed by others, as for instance the tyft/tyxt format proposed by Groote and Vaandrager [ 16 ] or the ntyft/ntyxt format of Groote <ref> [ 15 ] </ref> . The examples that we discussed treat concepts like termination, convergence, divergence, a zero object, side conditions, functions, real time, discrete time, sequencing, negative premises, negative conclusions, and priorities (or a combination of these notions). Future work is mainly concerned with negative rules.
Reference: [ 16 ] <author> J. F. Groote and F. W. Vaandrager, </author> <title> Structured operational semantics and bisimulation as a congruence, </title> <booktitle> Information and Computation 100(2), </booktitle> <pages> pp. 202-260, </pages> <year> 1992. </year>
Reference-contexts: In table 2 we enumerate the rules as they essentially appear in [ 1 ] . In fact, Baeten and Van Glabbeek [ 6 ] have the same approach to successful termination. We treat recursion in the same way as Groote and Vaan-drager <ref> [ 16 ] </ref> by adding process names recx. t to the signature for each t 2 O () to obtain that the recursion rules fit our format. <p> They have for this constant the following laws x + 0 = x; x0 = 0; 0x = 0: Baeten and Bergstra explicitly state in their paper: "We cannot define action rules in the format of Groote and Vaandrager <ref> [ 16 ] </ref> or Groote [ 15 ] " (see [ 3 ] , loc. cit. p. 87). The problems arise with the rules for the sequential composition: if x a !x 0 then we will only have xy a if y 6= 0. <p> The 6= 0 predicate and rules for sequential composition. Often we see that the rules of an operational semantics have so-called side conditions. For instance, the following rule from Groote and Vaandrager <ref> [ 16 ] </ref> has a side condition: a !"; a 6= : This side condition is an abbreviation for the list containing for all a 2 A a rule a a !". Thus, it is in fact a harmless side condition, since the rules can be replaced by an enumaration. <p> We want to stress that this example is not meant for practical purpose. The reason for giving it is to show that it can be done within our format. For practical use it is better to extend our format with negative premises. Groote and Vaandrager <ref> [ 16 ] </ref> gave with a single rule a more intuitive operational definition of the priority operator using negative premises in the presence of deadlock and the empty process. Our operational semantics of BPA with the priority operator is built up from the rules in tables 1 and 11. <p> A proof is closed if it contains only closed formulas. Lemma (3.3) If a closed formula is provable from a term deduction system then it is provable by a closed proof. Proof. Easy. Confer lemma 3.3 of Groote and Vaandrager <ref> [ 16 ] </ref> . 4. Structured state systems and bisimulation In this section we define the notions of a structured state system and bisimulation. A structured state system is a generalization of the notion of a labelled transition system. <p> The congruence theorem This section is devoted to the congruence theorem. We expect that our congruence theorem can be proved by simply adapting the proof of the congruence theorem of Groote and Vaan-drager <ref> [ 16 ] </ref> to the present situation. However, we prove a stronger result than just a congruence theorem since we moreover show that every term deduction system in path format can be reduced to a transition system specification in tyft/tyxt format and then apply the theorem of Groote and Vaandrager. <p> The names tyft and tyxt are taken from Groote and Vaandrager <ref> [ 16 ] </ref> . If a deduction rule d 2 D has one of the above forms we say that this rule is in path format, which stands for "predicates and tyft/tyxt hybrid format". A term deduction system is in path format if all its rules are. <p> A term deduction system is called well-founded if all its deduction rules are well-founded. Lemma (5.3) For every well-founded term deduction system in path format there is an equivalent pure well-founded term deduction system in path format. Proof. Essentially the proof of Lemma 5.9 in Groote and Vaandrager <ref> [ 16 ] </ref> . Theorem (5.4) Let T = (; D) be a well-founded term deduction system in path format then strong bisimulation is a congruence for all function symbols occurring in . Proof. Groote and Vaandrager [ 16 ] proved this theorem in the case that the set of predicate <p> Proof. Essentially the proof of Lemma 5.9 in Groote and Vaandrager <ref> [ 16 ] </ref> . Theorem (5.4) Let T = (; D) be a well-founded term deduction system in path format then strong bisimulation is a congruence for all function symbols occurring in . Proof. Groote and Vaandrager [ 16 ] proved this theorem in the case that the set of predicate symbols is empty, that is, if the term deduction system is in tyft/tyxt format. <p> With (vii ) we find u i 0 v i for all 1 i n. Since the term deduction system T 0 is well-founded and in tyft/tyxt format we can apply the congruence theorem of Groote and Vaandrager <ref> [ 16 ] </ref> so f (u 1 ; : : : ; u n ) 0 f (v 1 ; : : : ; v n ). <p> For a number of operational semantics that we took from the literature we showed that our format is rather practical: many operational semantics satisfy our format, whereas they do not satisfy formats proposed by others, as for instance the tyft/tyxt format proposed by Groote and Vaandrager <ref> [ 16 ] </ref> or the ntyft/ntyxt format of Groote [ 15 ] . The examples that we discussed treat concepts like termination, convergence, divergence, a zero object, side conditions, functions, real time, discrete time, sequencing, negative premises, negative conclusions, and priorities (or a combination of these notions).
Reference: [ 17 ] <author> A. Ingolfsdottir, B. Thomsen, </author> <title> Semantic Models for CCS with Values, </title> <booktitle> in: Proceedings Chalmers Workshop on Concurrency, </booktitle> <year> 1991, </year> <pages> pp. 215-242, </pages> <note> Report PMG-R63, </note> <institution> Chalmers University of Technology and University of Goteborg, </institution> <year> 1992. </year>
Reference-contexts: Aceto and Hennessy also have a divergence predicate, which is the complement of the convergence predicate. We omitted this predicate since they do not need it to define their operational semantics. However it is easy to define this predicate; we refer to <ref> [ 17 ] </ref> for an explicit operational semantics of the divergence predicate in path format.
Reference: [ 18 ] <author> A. S. Klusener, </author> <title> Completeness in real time process algebra, </title> <type> Technical Report CS-R9106, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <year> 1991. </year> <note> An extended abstract appeared in J. </note> <editor> C. M. Baeten and J. F. Groote, editors, </editor> <booktitle> Proceedings CONCUR 91, </booktitle> <address> Amsterdam, </address> <publisher> LNCS 527, </publisher> <pages> pp. 376-392, </pages> <year> 1991. </year>
Reference-contexts: The rephrased operational semantics of Moller and Tofts is well-founded and in path format, so strong bisimulation is a congruence. We will briefly mention some related examples in the area of real time process algebra. Klusener <ref> [ 18 ] </ref> gives on the one hand some clear operational semantics for several real time process algebras but on the other hand he introduces non-intuitive operational semantics for the same real time process algebras using negative premises. <p> In our setting we moreover demand that bisimilar processes must have the same maximal delay. So we have "maximal delay" bisimulation. Moller and Tofts state in their proposition 3.3 that our maximal delay bisimulation coincides with their notion of bisimulation. The same phenomenon occurs in Klusener <ref> [ 18 ] </ref> with our UL-bisimulation, Klusener's U-bisimulation, and ordinary bisimulation (U means ultimate delay and L means latest possible action). Also for the examples with negative premises that we gave in section 2 we have to prove that bisimulation is the same as our "negative" bisimulation.
Reference: [ 19 ] <author> C. P. J. Koymans and J. L. M. Vrancken, </author> <title> Extending process algebra with the empty process ", Logic Group Preprint Series Nr. </title> <type> 1, </type> <institution> CIF, Utrecht University, </institution> <year> 1985. </year>
Reference: [ 20 ] <author> R. Milner, </author> <title> A calculus of communicating systems, </title> <publisher> LNCS 92, Springer Verlag, </publisher> <year> 1980. </year>
Reference-contexts: This next example is an operational semantics of Van Glabbeek [ 14 ] for BPA o , which is a fragment of the theory ACP o that originates from Bergstra and Klop [ 9 ] . The subscript o stands for the silent move of Milner <ref> [ 20 ] </ref> . The operational semantics is given by the rules of tables 1 and 6. Van Glabbeek [ 14 ] observes that his model is isomorphic to the graph model of Baeten, Bergstra and Klop [ 4 ] . <p> Van Glabbeek [ 14 ] observes that his model is isomorphic to the graph model of Baeten, Bergstra and Klop [ 4 ] . This means that two terms are strongly bisimilar [ 22 ] in his model if and only if they are rooted weakly bisimilar <ref> [ 20 ] </ref> in the graph model, so since all the rules of tables 1 and 6 are well-founded and in path format we know that strong bisimulation is a congruence and thus, rooted weak bisimulation on the graph model is also a congruence.
Reference: [ 21 ] <author> F. Moller and C. Tofts, </author> <title> A Temporal Calculus of Communicating Systems, </title> <booktitle> in: </booktitle> <pages> see [ 3 ] , pp. 401-415. </pages>
Reference-contexts: Often, though, side conditions are not so harmless. This is the case if a side condition contains a process term. An example of such a rule can be found in a paper of Moller and Tofts <ref> [ 21 ] </ref> on temporal CCS: P !P 0 t ; jQj T &lt; t: (1) Here jj T is called the maximal delay, which is a function and not a predicate.
Reference: [ 22 ] <author> D. M. R. Park, </author> <title> Concurrency and automata on infinite sequences, </title> <editor> In P. Duessen (ed.) </editor> <booktitle> 5th GI Conference, </booktitle> <volume> LNCS 104, </volume> <pages> pp. 167-183, </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: The operational semantics is given by the rules of tables 1 and 6. Van Glabbeek [ 14 ] observes that his model is isomorphic to the graph model of Baeten, Bergstra and Klop [ 4 ] . This means that two terms are strongly bisimilar <ref> [ 22 ] </ref> in his model if and only if they are rooted weakly bisimilar [ 20 ] in the graph model, so since all the rules of tables 1 and 6 are well-founded and in path format we know that strong bisimulation is a congruence and thus, rooted weak bisimulation <p> To see this take an empty set of predicates and take for the set of relations the labelled transition relation. Next, we will define the notion of strong bisimulation on a structured state system, which is based on Park <ref> [ 22 ] </ref> . Definition (4.3) Let G = (S; S p ; S r ) be a structured state system. A relation B S fi S is called a (strong) bisimulation if for all s; t 2 S with sBt the following conditions hold.
Reference: [ 23 ] <author> G. D. Plotkin, </author> <title> A structural approach to operational semantics, </title> <type> Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1981. </year>
Reference: [ 24 ] <author> S. Schneider, </author> <title> An Operational Semantics for Timed CSP, </title> <note> in: see [ 17 ] pp. 428-456. To appear in Information and Computation. </note>
Reference-contexts: This result can be obtained in the same way as we sketched this for the above example of Moller and Tofts. The last temporal example is an operational semantics for timed CSP of Schneider <ref> [ 24 ] </ref> . His operational semantics also consists of a function and ordinary transitions. We claim that this function is, in fact, a mixfix predicate and that the resulting operational semantics is well-founded and in path format.
Reference: [ 25 ] <author> R. de Simone, </author> <title> Higher-level synchronising devices in Meije-SCCS, </title> <journal> TCS 37, </journal> <pages> pp. 245-267, </pages> <year> 1985. </year>
Reference-contexts: However, it would be a better idea to incorporate recursion whitin our format as is done for the GSOS format [ 11 ] and De Simone's format <ref> [ 25 ] </ref> . nil p p p p p p p p p p p t [recx. t=x] p recx. t p Table 2. <p> For instance, which negative premises can be written as predicates? Another possibility to generalizing the path format is to incorporate recursion within it as is done for the GSOS format [ 11 ] and De Simone's format <ref> [ 25 ] </ref> . Finally, we conclude that the path format is a very practical format that can be used with a lot of ease in a wide range of applications.
Reference: [ 26 ] <author> Wang Yi, </author> <title> Towards a Theory of Testing for CCS with Probability, </title> <booktitle> in: </booktitle> <pages> see [ 17 ] pp. 476-492. </pages>
Reference-contexts: But we can also think of the combination of a transition relation with a totally different relation, such as Wang's syntactical inequality relation P 6= Q that he uses in an operational semantics for probabilistic CCS ( q.v. <ref> [ 26 ] </ref>) . Before we give the definition of a term deduction system we will list some preliminaries for completeness sake. We assume that we have an infinite set V of variables with typical elements x; y; z; : : :.
References-found: 26

