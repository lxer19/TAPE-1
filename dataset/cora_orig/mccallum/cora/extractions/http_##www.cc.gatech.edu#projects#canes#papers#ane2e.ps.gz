URL: http://www.cc.gatech.edu/projects/canes/papers/ane2e.ps.gz
Refering-URL: http://www.cs.gatech.edu/projects/canes/pubs.html
Root-URL: 
Email: fbobby,calvert,ewzg@cc.gatech.edu  
Title: Active Networking and the End-to-End Argument  
Author: Samrat Bhattacharjee, Kenneth L. Calvert, Ellen W. Zegura 
Address: Atlanta, GA 30332-0280  
Affiliation: Networking and Telecommunications Group College of Computing Georgia Institute of Technology,  
Abstract: Active networking is the placement of user-controllable computing functionality in the switching nodes of a network. The end-to-end argument states that functions should be placed "in" the network only if they can be cost-effectively implemented there. We argue that active networking is a natural consequence of the end-to-end argument, because certain functions can be most effectively implemented with information that is only available inside the network. We propose a performance model for quantifying the benefit of implementing a particular functionality solely in the end system versus implementing it through a combination of end system and network support. We show how the model applies to specific services, including congestion control and reliable multicast. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Saltzer, D. P. Reed, and D. Clark, </author> <title> "End-to-end arguments in system design," </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> vol. 2, no. 4, </volume> <year> 1984. </year>
Reference-contexts: 1 Introduction Discussions of the implementation of various functions in a communication network often invoke the end-to-end argument, an architectural principle that guides the placement of functions within a distributed system <ref> [1] </ref>. The end-to-end argument is often construed to preclude the implementation of any kind of higher-level function within a network. As such, it might seem that active networks are the antithesis of the end-to-end argument. <p> Finally, Section 6 offers some concluding remarks. 2 The End-to-End Argument Revisited The end-to-end argument "provides a rationale for moving a function upward in a layered system closer to the application that uses the function" <ref> [1] </ref>. According to the argument, a computer network, as part of the "lower layers" of a distributed system, should avoid attempting to provide functions that can be better implemented in the end systems, especially if some applications might not benefit from such functions at all. <p> In the second option, the service is achieved through a combination of implementation at the end-systems and in the network. The equations that we develop are implied, to an extent, by the text in the Saltzer paper <ref> [1] </ref>. We demonstrate the model using the reliable file transfer example from Saltzer. 3.1 Model Development To be clear, we first state the assumptions that are made by our model.
Reference: [2] <author> D. Tennenhouse, J. Smith, and G. M. W. Sincoskie, D. Wetherall, </author> <title> "A survey of active network research," </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 35, no. 1, </volume> <year> 1997. </year>
Reference-contexts: For the purposes of this discussion, "active networking" refers to the placement of user-controllable com fl This work was supported in part by NSF Careers Award MIP-9502669. puting and other resources in the communication network, where they can be utilized by applications that need those capabilities <ref> [2] </ref>. An active network supports a user-network interface allowing the nodes of the network to be programmed by the application (user) to provide a desired functionality, such as routing.
Reference: [3] <author> D. L. Tennenhouse and D. J. Wetherall, </author> <title> "Towards an active network architecture," </title> <booktitle> in Multimedia Computing and Networking '96, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: An active network supports a user-network interface allowing the nodes of the network to be programmed by the application (user) to provide a desired functionality, such as routing. This programming might be done on a per-packet basis (as in the capsule approach of Tennenhouse and Wether-all <ref> [3] </ref>) or through an out-of-band signaling mechanism (e.g. injection of user-specific programming into the switch, as in Switchware [4]). The level of programmability might range from a Turing-complete programming language to a set of predefined, user-selectable functions whose behavior can be controlled through parameters.
Reference: [4] <author> J. Smith, "Switchware: </author> <title> Accelerating network evolution," </title> <type> Tech. Rep. </type> <institution> MS-CIS-96-38, CIS Dept., University of Pennsylvania, </institution> <year> 1996. </year>
Reference-contexts: This programming might be done on a per-packet basis (as in the capsule approach of Tennenhouse and Wether-all [3]) or through an out-of-band signaling mechanism (e.g. injection of user-specific programming into the switch, as in Switchware <ref> [4] </ref>). The level of programmability might range from a Turing-complete programming language to a set of predefined, user-selectable functions whose behavior can be controlled through parameters. The important point is that with active networks, the network service can be tailored to the user's requirements.
Reference: [5] <author> T. Pusateri, </author> <title> "Distance Vector Multicast Routing Protocol," </title> <type> Internet Draft, </type> <institution> Internet Engineering Task Force, </institution> <year> 1997. </year> <title> Work in progress. </title>
Reference-contexts: The "traditional" IP multicast service hides from its users the details of the routing topology and the number and location of receivers <ref> [5] </ref>. For unreliable multicast, this approach makes sense and allows scaling to larger applications; however, there are inherent problems in using this model when it is desired to deliver data to all receivers reliably.
Reference: [6] <author> J. C. Lin and S. Paul, "RMTP: </author> <title> a reliable multicast transport protocol," </title> <booktitle> in Proceedings of Infocom, </booktitle> <month> Mar. </month> <year> 1996. </year>
Reference-contexts: Traditional point-to-point reliable transfer protocols do not generalize well to point-to-multipoint, because they require the sender to maintain per-receiver state to keep track of who has received each data unit; this limits scalability for obvious reasons. This has led to various proposals for diluting the amount of state required <ref> [6, 7] </ref>. For example, NACK-based protocols reduce the amount of Sender state required, but introduce the NACK-implosion problem, and result in unnecessary retransmissions being sent to some or all receivers.
Reference: [7] <author> C. Papadopoulos, G. Parulkar, and G. Varghese, </author> <title> "An error control scheme for large-scale multicast applications." </title> <note> Available at http://dworkin.wustl.edu/ chris-tos/PostScriptDocs/current.ps.Z. </note>
Reference-contexts: Traditional point-to-point reliable transfer protocols do not generalize well to point-to-multipoint, because they require the sender to maintain per-receiver state to keep track of who has received each data unit; this limits scalability for obvious reasons. This has led to various proposals for diluting the amount of state required <ref> [6, 7] </ref>. For example, NACK-based protocols reduce the amount of Sender state required, but introduce the NACK-implosion problem, and result in unnecessary retransmissions being sent to some or all receivers. <p> The router at the root of this tree, where the loss occurred, is referred to as the loss node. In both Design X and Design 1 Papadopoulos et al <ref> [7] </ref> have recently proposed an extension to router functionality to support reliable multicast. Their proposal stops short of placing the retransmission function in the router nodes themselves, but rather offers a service requiring less state, and allowing end nodes to handle the retransmission functions more efficiently.
Reference: [8] <author> S. Floyd, V. Jacobson, C.-G. Liu, S. McCanne, and L. Zhang, </author> <title> "Reliable Multicast Framework for Lightweight Sessions and Application Level Framing," </title> <booktitle> in SIGCOMM, </booktitle> <address> (Cambridge, Massachusetts), </address> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: A common approach is to spread the responsibility for multicast retransmission among the Receivers, by constructing an explicit "tree" of receivers on top of the network-level multicast service (e.g., <ref> [8] </ref>) In effect, this subdivides the multicast group into smaller groups according to the parent-child relationships in this tree. For such grouping to be efficient, out-of-band information about the network topology is required so that nodes that are "near" each other in the underlying topology are grouped together.
Reference: [9] <author> M. Yajnik, J. Kurose, and D. Towsley, </author> <title> "Correlation in the MBone multicast network," </title> <booktitle> in IEEE Global Internet Conference, </booktitle> <address> (London), </address> <month> November </month> <year> 1996. </year>
Reference-contexts: We do note that recent studies of MBONE traffic show that the likelihood of any particular multicast packet being delivered correctly to all receivers is surprisingly small, on the order of 20% <ref> [9] </ref>. 4.2 Loss Recovery Approaches When a multicast packet is lost in the network, we refer to that portion of the multicast routing tree that does not receive the packet as the loss tree. <p> * losses are uniformly distributed along the path connecting the exit node from the Sender's stub domain and the entry node of the affected Receiver's stub domain (a recent study found that losses in this part of the path account for a substantial majority of the losses in the MBONE <ref> [9] </ref>); * all stub domains are topologically similar and have exactly one connection to the transit domain; * the Sender's stub domain contains no other Re ceivers; * in Design C, if the first node upstream of a loss does not have a copy of the requested packet, the request goes
Reference: [10] <author> S. Bhattacharjee, K. L. Calvert, and E. W. Zegura, </author> <title> "An Architecture for Active Networking," </title> <booktitle> in Proceedings of High Performance Networking 97, </booktitle> <year> 1997. </year>
Reference-contexts: increase in T N is approximately (m 1)=2, as long as m is small enough to guarantee that some node has a copy before the request reaches the Sender. 5 Example: Congestion Control Another application that can potentially benefit from a combination of end-system and network processing is congestion control <ref> [10] </ref>. We claim that the best-effort service provided to adaptive applications can be enhanced by allowing applications some control over the way their packets are processed in network switches when they encounter congestion. <p> Thus, the GOP level discard mechanism is the application-specific case in which information about both priority and dependencies amongst application specific data units is available to the network. Detailed descriptions of the mechanisms and the experiments can be found in <ref> [10] </ref>. The experimental topology is shown in Figure 2. The bandwidth on the links between the source and the router, and between the congestion generator and the router, are large enough so that these links are never congested.
References-found: 10

