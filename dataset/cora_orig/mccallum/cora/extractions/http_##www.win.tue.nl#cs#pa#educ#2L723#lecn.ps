URL: http://www.win.tue.nl/cs/pa/educ/2L723/lecn.ps
Refering-URL: http://www.win.tue.nl/cs/pa/educ/2L723/
Root-URL: http://www.win.tue.nl
Email: Email: johanl@win.tue.nl  
Phone: Telephone: +31 40 475147 Telefax: +31 40 436685  
Title: Implementation of Parallel Programs lecture notes  
Author: Johan J. Lukkien 
Date: April 9, 1997  
Address: P.O. Box 513 5600 MB Eindhoven, The Netherlands  
Affiliation: Eindhoven University of Technology Department of Mathematics and Computing Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Johan J. Lukkien, </author> <title> The Transputer Pascal System, </title> <booktitle> Course Notes 2485, </booktitle> <institution> Eindhoven University of Technology, Eindhoven, </institution> <year> 1995. </year>
Reference-contexts: measurements; second, we distribute the program over the network; third, we show how we can make the program coarser-grained such as to increase its efficiency; and finally we show how communications can be made coarser grained. 2 The programming environment 2.1 The network The department's transputer networks are described in <ref> [1] </ref> to which we refer for a more detailed description. For now we restrict ourselves to the most vital information. A transputer is a chip containing a processor, a floating-point co-processor, some memory (4K) and, most importantly, 4 bidirectional links. <p> In the last line we see how a program, running in the transputer, can break the connection with the workstation. For details on how to compile a program for the network and how to execute it we refer again to <ref> [1] </ref> (in particular, the tutorial in chapter 1). 2.3 Timing In the sections to follow we show in detail how the performance of a parallel program is analysed. To that end it is necessary to run the program many times for different values of the input parameters. <p> i_chan ; N, n, va, vb, vc: int ; begin monitor ; write (output, 'Windowsize (N) = '); readln (input, N) ; if (1 &gt; N) or (N &gt; MaxN) then begin writeln (output, 'Wrong windowsize, sorry') ; write (command, STOPIT) end else begin start system - fork ocf1 (a <ref> [1] </ref>, b [1], c [2]) ; for n := 2 to N do fork ocf (a [n], b [n-1], c [n], a [n-1], b [n], c [n+1]) ; writeln (output, 'Type input now') act as environment - ; cobegin read A values - while true do begin readln (input, va) ; <p> N, n, va, vb, vc: int ; begin monitor ; write (output, 'Windowsize (N) = '); readln (input, N) ; if (1 &gt; N) or (N &gt; MaxN) then begin writeln (output, 'Wrong windowsize, sorry') ; write (command, STOPIT) end else begin start system - fork ocf1 (a <ref> [1] </ref>, b [1], c [2]) ; for n := 2 to N do fork ocf (a [n], b [n-1], c [n], a [n-1], b [n], c [n+1]) ; writeln (output, 'Type input now') act as environment - ; cobegin read A values - while true do begin readln (input, va) ; write (a <p> i, j, k: int ; Indat, Outdat: Data ; begin monitor ; write (output, 'Windowsize (N) = '); readln (input, N) ; if (1 &gt; N) or (N &gt; MaxN) then begin writeln (output, 'Wrong windowsize, sorry') ; write (command, STOPIT) end else begin start system - fork ocf1 (a <ref> [1] </ref>, b [1], c [2]) ; for n := 2 to N do fork ocf (a [n], b [n-1], c [n], a [n-1], b [n], c [n+1]) act as environment - ; ReadData (Indat); Outdat.l := Indat.l ; t0 := time ; cobegin with Indat do for i := 0 to <p> k: int ; Indat, Outdat: Data ; begin monitor ; write (output, 'Windowsize (N) = '); readln (input, N) ; if (1 &gt; N) or (N &gt; MaxN) then begin writeln (output, 'Wrong windowsize, sorry') ; write (command, STOPIT) end else begin start system - fork ocf1 (a <ref> [1] </ref>, b [1], c [2]) ; for n := 2 to N do fork ocf (a [n], b [n-1], c [n], a [n-1], b [n], c [n+1]) act as environment - ; ReadData (Indat); Outdat.l := Indat.l ; t0 := time ; cobegin with Indat do for i := 0 to l-1 do <p> begin q := N div P ; if q = 1 then if ringid = P then ocf1 (linkin [prev], linkout [prev], linkout [prev]) else ocf ( linkin [prev], linkin [next], linkin [next] , linkout [next], linkout [prev], linkout [prev]) else begin if ringid = P then fork ocf1 (a <ref> [1] </ref>, b [1], c [2]) else fork ocf ( a [1], linkin [next], linkin [next] , linkout [next], b [1], c [2]) ; for n := 2 to q-1 do fork ocf (a [n], b [n-1],c [n], a [n-1], b [n], c [n+1]) ; ocf ( linkin [prev], b [q-1], c <p> := N div P ; if q = 1 then if ringid = P then ocf1 (linkin [prev], linkout [prev], linkout [prev]) else ocf ( linkin [prev], linkin [next], linkin [next] , linkout [next], linkout [prev], linkout [prev]) else begin if ringid = P then fork ocf1 (a <ref> [1] </ref>, b [1], c [2]) else fork ocf ( a [1], linkin [next], linkin [next] , linkout [next], b [1], c [2]) ; for n := 2 to q-1 do fork ocf (a [n], b [n-1],c [n], a [n-1], b [n], c [n+1]) ; ocf ( linkin [prev], b [q-1], c [q] , <p> 1 then if ringid = P then ocf1 (linkin [prev], linkout [prev], linkout [prev]) else ocf ( linkin [prev], linkin [next], linkin [next] , linkout [next], linkout [prev], linkout [prev]) else begin if ringid = P then fork ocf1 (a <ref> [1] </ref>, b [1], c [2]) else fork ocf ( a [1], linkin [next], linkin [next] , linkout [next], b [1], c [2]) ; for n := 2 to q-1 do fork ocf (a [n], b [n-1],c [n], a [n-1], b [n], c [n+1]) ; ocf ( linkin [prev], b [q-1], c [q] , a [q-1], linkout [prev], linkout [prev]) end end <p> [prev], linkout [prev], linkout [prev]) else ocf ( linkin [prev], linkin [next], linkin [next] , linkout [next], linkout [prev], linkout [prev]) else begin if ringid = P then fork ocf1 (a <ref> [1] </ref>, b [1], c [2]) else fork ocf ( a [1], linkin [next], linkin [next] , linkout [next], b [1], c [2]) ; for n := 2 to q-1 do fork ocf (a [n], b [n-1],c [n], a [n-1], b [n], c [n+1]) ; ocf ( linkin [prev], b [q-1], c [q] , a [q-1], linkout [prev], linkout [prev]) end end end Implementation of parallel programs 14 program OCF_Host #include
Reference: [2] <author> M. </author> <title> Rem, </title> <booktitle> Lecture Notes in Parallel Program, Course Notes 2519, </booktitle> <institution> Eindhoven University of Technology, Eindhoven, </institution> <year> 1994. </year>
Reference-contexts: We assume the material presented in the course "design of parallel programs" (2L700) to be familiar to the reader. Whenever appropriate we refer to the lecture notes of this course (<ref> [2] </ref>). As discussed in [2], the parallel programs that we designed can be executed by a processor network but also, more directly, by a VLSI chip. VLSI implementations have been highlighted a number of times in 2L700. In 2L723 we look at implementations on a processor network. <p> It is reasonable to assume that if these processes are taken together into one sequential process the execution time decreases, because there is fewer overhead. A similar remark holds for taking communications together into one big chunk. A third improvement is obtained by avoiding idle time (see <ref> [2] </ref>, p153). A third performance consideration is scalability. Parallelism is often introduced in order to deal with large computational problems within reasonable time. To that end it is necessary that it is possible to scale the network with the size of the problem. <p> The performance considerations form the background of the following discussions. As example we choose the Occurrence Count First problem (OCF) from section 4.1 of <ref> [2] </ref>. We show how the formal program text is adapted such that it can be run on a transputer system. To that end the program is rewritten in transputer Pascal (a modified version of Pascal). First we discuss Pascal and the transputer system briefly. <p> As an example, the cost of accessing i and j in the second case is four times as high as in the first case for an array of length 4096. 3 A single processor program 3.1 The program We refer to <ref> [2] </ref>, section 4.1, for the text of the OCF program. The corresponding Pascal text is given in figure 3. We do not give a separate text for ocfN; we will see to it that the environment accepts the superfluous C outputs instead. <p> va, vb, vc: int ; begin monitor ; write (output, 'Windowsize (N) = '); readln (input, N) ; if (1 &gt; N) or (N &gt; MaxN) then begin writeln (output, 'Wrong windowsize, sorry') ; write (command, STOPIT) end else begin start system - fork ocf1 (a [1], b [1], c <ref> [2] </ref>) ; for n := 2 to N do fork ocf (a [n], b [n-1], c [n], a [n-1], b [n], c [n+1]) ; writeln (output, 'Type input now') act as environment - ; cobegin read A values - while true do begin readln (input, va) ; write (a [N], va) <p> We expect that T (N ) is a linear function of N since each process performs a constant amount of work. However, T (N ) also includes the time of the environment but we may assume that this part is independent of N . From <ref> [2] </ref> we recall the following sequence functions. oe (a j ; i) = 2i + N j According to the sequence function, each complete cycle takes two time slots. <p> ; Indat, Outdat: Data ; begin monitor ; write (output, 'Windowsize (N) = '); readln (input, N) ; if (1 &gt; N) or (N &gt; MaxN) then begin writeln (output, 'Wrong windowsize, sorry') ; write (command, STOPIT) end else begin start system - fork ocf1 (a [1], b [1], c <ref> [2] </ref>) ; for n := 2 to N do fork ocf (a [n], b [n-1], c [n], a [n-1], b [n], c [n+1]) act as environment - ; ReadData (Indat); Outdat.l := Indat.l ; t0 := time ; cobegin with Indat do for i := 0 to l-1 do write (a <p> div P ; if q = 1 then if ringid = P then ocf1 (linkin [prev], linkout [prev], linkout [prev]) else ocf ( linkin [prev], linkin [next], linkin [next] , linkout [next], linkout [prev], linkout [prev]) else begin if ringid = P then fork ocf1 (a [1], b [1], c <ref> [2] </ref>) else fork ocf ( a [1], linkin [next], linkin [next] , linkout [next], b [1], c [2]) ; for n := 2 to q-1 do fork ocf (a [n], b [n-1],c [n], a [n-1], b [n], c [n+1]) ; ocf ( linkin [prev], b [q-1], c [q] , a [q-1], <p> [prev], linkout [prev]) else ocf ( linkin [prev], linkin [next], linkin [next] , linkout [next], linkout [prev], linkout [prev]) else begin if ringid = P then fork ocf1 (a [1], b [1], c <ref> [2] </ref>) else fork ocf ( a [1], linkin [next], linkin [next] , linkout [next], b [1], c [2]) ; for n := 2 to q-1 do fork ocf (a [n], b [n-1],c [n], a [n-1], b [n], c [n+1]) ; ocf ( linkin [prev], b [q-1], c [q] , a [q-1], linkout [prev], linkout [prev]) end end end Implementation of parallel programs 14 program OCF_Host #include &lt;linkfilemonitor&gt; #include <p> Our next step is to combine the q processes that each processor executes into one process. In this way we reduce the overhead and we specialize the program to match the network that we use. From section 4.1 of <ref> [2] </ref>, we recall the generalization of the i/o relation. b n (i) = (j : 0 j &lt; n : [A (i j) = A (i n + 1)]); i n 1 Our idea is to have one process perform the computation pertaining to q of the processes we had before. <p> &lt; q : [A (i j) = A (i qn + 1)]) + = fdefinition, i qn 1 ) i q q (n 1) 1g (j : 0 j &lt; q : [A (i j) = A (i qn + 1)]) + b n1 (i q) Following the derivation in <ref> [2] </ref> closely, we introduce ports a n and c n with a n (i) = A (i); i 0 which gives us as the i/o relation for b n , b n (i) = (j : 0 j &lt; q : [a n (i j) = c n (i q)]) + <p> It is easy to see that when ff takes a time proportional to q, the time increases proportionally to 2q. The time spent waiting for results to arrive is called idle time. In the linear systems we have encountered it occurs when each communication phase involves both neighbors. In <ref> [2] </ref> these are called stacks and mixed pipelines. The behavior corresponding to a true pipeline does not result in idle time.
References-found: 2

