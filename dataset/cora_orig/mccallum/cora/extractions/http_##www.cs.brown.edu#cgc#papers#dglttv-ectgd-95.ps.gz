URL: http://www.cs.brown.edu/cgc/papers/dglttv-ectgd-95.ps.gz
Refering-URL: http://www.cs.brown.edu/people/rt/papers/recent-papers/recent-papers.html
Root-URL: http://www.cs.brown.edu
Email: dibattista@iasi.rm.cnr.it  rt@cs.brown.edu  ag@cs.brown.edu  tassinar@dis.uniroma1.it  liotta@dis.uniroma1.it  vargiu@dis.uniroma1.it  
Title: An Experimental Comparison of Three Graph Drawing Algorithms (Extended Abstract)  
Author: Giuseppe Di Battista Roberto Tamassia D. I. F. A. Ashim Garg Emanuele Tassinari Giuseppe Liotta Francesco Vargiu 
Note: Research supported in part by the US National Science Foundation, by the US Army Research Office, by the US Office of Naval Research and the Advanced Research Projects Agency, by the NATO Scientific Affairs Division, by the "Progetto Finalizzato  Parallelo (Sottoprogetto 6, Infokit)" and Grant 94.23.CT07 of the Italian National Research Council (CNR), and by the ESPRIT II Basic Research Actions Program of the European Community (project ALgorithms and Complexity).  
Address: 85100 Potenza Italy  Providence, RI 02912-1910 USA  00198 Roma Italy  
Affiliation: Univ. della Basilicata  Dept. of Computer Science Brown University  Dip. Informatica e Sistemistica Univ. di Roma "La Sapienza"  Sistemi Informatici e Calcolo  
Abstract: In this paper we present an extensive experimental study comparing three general-purpose graph drawing algorithms. The three algorithms take as input general graphs (with no restrictions whatsoever on the connectivity, planarity, etc.) and construct orthogonal grid drawings, which are widely used in software and database visualization applications. The test data (available by anonymous ftp) are 11,582 graphs, ranging from 10 to 100 vertices, which have been generated from a core set of 112 graphs used in "real-life" software engineering and database applications. The experiments provide a detailed quantitative evaluation of the performance of the three algorithms, and show that they exhibit trade-offs between "aesthetic" properties (e.g., crossings, bends, edge length) and running time. The observed practical behavior of the algorithms is consistent with their theoretical properties. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Batini, S. Ceri, and S. B. Navathe. </author> <title> Conceptual Database Design, an Entity-Relationship Approach. </title> <publisher> Benjamin Cummings, </publisher> <year> 1992. </year>
Reference-contexts: from Database Informatica) and large government organization (including the Italian Internal Revenue Service and the Italian National Advisory Council for Computer Applications in the Government (Autorita per l'Informatica nella Pubblica Ammin istrazione)). * 33% of the graphs were taken from well-known reference books in software engineering [19] and database design <ref> [1] </ref>, and from journal articles on software visualization in the recent issues of Information Systems and the IEEE Transactions on Software Engineering. * 13% of the graphs were extracted from theses in software and database visualization written by stu dents at the University of Rome "La Sapienza".
Reference: [2] <author> C. Batini, L. Furlani, and E. Nardelli. </author> <title> What is a good diagram? A pragmatic approach. </title> <booktitle> In Proc. 4th Internat. Conf. on the Entity Relationship Approach, </booktitle> <year> 1985. </year>
Reference-contexts: Note that at least 50 graph for each vertex cardinality between 10 and 100 have been generated. The 11; 582 test graphs are available by anonymous ftp from infokit.dis.uniroma1.it:public. Sparsity and "near-planarity" are typical properties of graphs used in software engineering and database applications <ref> [2] </ref>. As expected, the test graphs turn out to be sparse (the average vertex degree is about 2.7, see Fig. 4.b) and with low crossing number (the average crossing number is no more than about 0.7 times the number of vertices, see Fig. 6.b).
Reference: [3] <author> C. Batini, E. Nardelli, and R. Tamassia. </author> <title> A layout algorithm for data-flow diagrams. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> SE-12(4):538-546, </volume> <year> 1986. </year>
Reference-contexts: practical performance of the recent algorithm by Papakostas and Tollis [37], and of separator-based methods [15, 31, 49] that were originally developed for VLSI layout. multigraph general multigraphs accepted as input MakeConnected connectivity testing and augmentation connected connected graph MakeBiconnected biconnectivity testing and augmentation biconnected biconnected graph MakePlanar planarization phase <ref> [3, 36] </ref> connectedplanar crossing are now replaced by dummy vertices Make4planar expansion of vertices with degree greater than 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum de gree 4 Step3giotto orthogonalization phase [42] step1TaTo89 construction of a visibility repre sentation <p> now maximum de gree 4 Step3giotto orthogonalization phase [42] step1TaTo89 construction of a visibility repre sentation [39, 44, 51]) step2TaTo89 fast orthogonalization [45] step4TaTo89 bend-stretching transformations, which remove bends by local layout modifications [45] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto compaction phase <ref> [3] </ref> BiedlKant orthogonal drawing algorithm [5] manhattan the final output is an orthogonal grid drawing Table 1: Algorithmic components and intermediate representations used by algorithms Bend-Stretch, Column, and GIOTTO in the automatic graph drawing facility of Diagram Server. 4 Experimental Setting 4.1 Quality Measures Analyzed The following quality measures of a
Reference: [4] <author> M. Beccaria, P. Bertolazzi, G. Di Battista, and G. Li-otta. </author> <title> A tailorable and extensible automatic layout facility. </title> <booktitle> In Proc. IEEE Workshop on Visual Languages (VL'91), </booktitle> <pages> pages 68-73, </pages> <year> 1991. </year>
Reference-contexts: The clients can specify the visual appearance of symbols and connections, the graphic standard, the aesthetic requirements that diagrams should satisfy, and the whole interface configuration. Automatic graph drawing: Diagram Server has an automatic graph drawing facility <ref> [4] </ref> that is based on a large modular library of graph drawing algorithms and on a tool that, given the requirements of an application, selects the suitable algorithms for such requirements.
Reference: [5] <author> T. Biedl and G. Kant. </author> <title> A better heuristic for orthogonal graph drawings. </title> <booktitle> In Proc. 2nd Annu. European Sympos. Algorithms (ESA '94), volume 855 of Lecture Notes in Computer Science, </booktitle> <pages> pages 24-35. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Algorithm Column, is an extension of the orthogonal drawing algorithm by Biedl and Kant <ref> [5] </ref> to graphs of arbitrary vertex degree. <p> Step3giotto orthogonalization phase [42] step1TaTo89 construction of a visibility repre sentation [39, 44, 51]) step2TaTo89 fast orthogonalization [45] step4TaTo89 bend-stretching transformations, which remove bends by local layout modifications [45] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto compaction phase [3] BiedlKant orthogonal drawing algorithm <ref> [5] </ref> manhattan the final output is an orthogonal grid drawing Table 1: Algorithmic components and intermediate representations used by algorithms Bend-Stretch, Column, and GIOTTO in the automatic graph drawing facility of Diagram Server. 4 Experimental Setting 4.1 Quality Measures Analyzed The following quality measures of a drawing of a graph have <p> TotalBends: The experimental results sharply fit the theoretical results. Namely, GIOTTO has the minimum number of bends; Bend-Stretch and Column have a number of bends that, also for the constants, is essentially the one predicted by the theoretical analysis <ref> [45, 5] </ref>. Observe that the performance of Bend-Stretch on TotalBends deeply affects also the performance of such algorithm on Area. MaxEdgeBends: Column has the best behavior.
Reference: [6] <author> N. Chiba, K. Onoguchi, and T. Nishizeki. </author> <title> Drawing planar graphs nicely. </title> <journal> Acta Inform., </journal> <volume> 22 </volume> <pages> 187-201, </pages> <year> 1985. </year>
Reference-contexts: However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. The performance of four planar straight-line drawing algorithms <ref> [6, 7, 10, 38, 48] </ref> is compared in [23]. These algorithms have been implemented and tested on 10,000 randomly generated maximal planar graphs. The standard deviations in angle size, edge length, and face area are used to compare the quality of the planar straight-line drawings produced. <p> Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [21] presents a comparative study of twelve graph drawings algorithms, including <ref> [6, 10, 18, 26, 41, 42, 50, 52] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planariza-tion) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
Reference: [7] <author> M. Chrobak and T. H. Payne. </author> <title> A linear time algorithm for drawing a planar graph on a grid. </title> <type> Technical Report UCR-CS-90-2, </type> <institution> Dept. of Math. and Comput. Sci., Univ. California Riverside, </institution> <year> 1990. </year>
Reference-contexts: However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. The performance of four planar straight-line drawing algorithms <ref> [6, 7, 10, 38, 48] </ref> is compared in [23]. These algorithms have been implemented and tested on 10,000 randomly generated maximal planar graphs. The standard deviations in angle size, edge length, and face area are used to compare the quality of the planar straight-line drawings produced.
Reference: [8] <author> R. F. Cohen, P. Eades, T. Lin, and F. Ruskey. </author> <title> Three-dimensional graph drawing. </title> <editor> In R. Tamassia and I. G. Tollis, editors, </editor> <booktitle> Graph Drawing (Proc. GD '94), volume 894 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-11. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: For recent results, see <ref> [8] </ref>. * Extensive experiments on algorithms for constructing other types of drawings (e.g., straight-line, polyline, upward) should be conducted.
Reference: [9] <author> R. Davidson and D. Harel. </author> <title> Drawing graphs nicely using simulated aneealing. </title> <type> Technical report, </type> <institution> Department of Applied Mathematics and Computer Science, The Weizmann Institute of Science, Rehovot, </institution> <year> 1989. </year>
Reference-contexts: Most papers in this area show sample outputs, and some also provide limited experimental results on small (with fewer than 100 graphs) test suites (see, e.g., <ref> [9, 18, 20, 24, 25, 28] </ref> and the experimental papers in [46]). However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain.
Reference: [10] <author> H. de Fraysseix, J. Pach, and R. Pollack. </author> <title> Small sets supporting Fary embeddings of planar graphs. </title> <booktitle> In Proc. 20th Annu. ACM Sympos. Theory Comput., </booktitle> <pages> pages 426-433, </pages> <year> 1988. </year>
Reference-contexts: However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. The performance of four planar straight-line drawing algorithms <ref> [6, 7, 10, 38, 48] </ref> is compared in [23]. These algorithms have been implemented and tested on 10,000 randomly generated maximal planar graphs. The standard deviations in angle size, edge length, and face area are used to compare the quality of the planar straight-line drawings produced. <p> Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [21] presents a comparative study of twelve graph drawings algorithms, including <ref> [6, 10, 18, 26, 41, 42, 50, 52] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planariza-tion) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
Reference: [11] <author> H. de Fraysseix and P. Rosenstiehl. </author> <title> Structures combi-natoires pour des traces automatiques de reseaux. </title> <booktitle> In Proc. 3rd European Conf. on CAD/CAM and Computer Graphics (Paris), </booktitle> <pages> pages 332-337. </pages> <address> Hermes, </address> <year> 1984. </year>
Reference-contexts: In addition to the three algorithms we have implemented and compared ( Bend-Stretch, Column, and GIOTTO), several other orthogonal drawing algorithms (mostly for planar graphs) have been reported in the literature. Because of the techniques used, we expect the behavior of the algorithms in <ref> [14, 16, 17, 11, 27, 33, 34, 35, 32, 40] </ref> to be similar to that of one of Bend-Stretch, Column, or GIOTTO.
Reference: [12] <author> G. Di Battista, P. Eades, R. Tamassia, and I. G. Tollis. </author> <title> Algorithms for drawing graphs: an annotated bibliography. </title> <journal> Comput. Geom. Theory Appl., </journal> <volume> 4 </volume> <pages> 235-282, </pages> <year> 1994. </year>
Reference-contexts: Because of the direct applications of graph drawing to advanced graphic user interfaces and visualization systems, and thanks to the many theoretical challenges posed by the interplay of graph theory and geometry, an extensive literature on the subject <ref> [12, 46] </ref> has grown in the last decade. Various graphic standards have been proposed for the representation of graphs in the plane. <p> It is widely accepted (see, e.g., <ref> [12] </ref> ) that small values of the above measures are related to to perceived aesthetic appeal and visual effectiveness of the drawing. (a) (c) and (c) GIOTTO. 4.2 Generation of the Test Graphs Since we are interested in evaluating the performance of graph drawing algorithms in practical applications, we have disregarded
Reference: [13] <author> G. Di Battista, A. Giammarco, G. Santucci, and R. Tamassia. </author> <title> The architecture of diagram server. </title> <booktitle> In Proc. IEEE Workshop on Visual Languages (VL'90), </booktitle> <pages> pages 60-65, </pages> <year> 1990. </year>
Reference-contexts: In Section 5, we summarize our experimental results in nine charts and perform a comparative analysis of the performance of the algorithms. Finally, open problems are addressed in Section 6. 2 Diagram Server Our experimental study was conducted using Diagram Server <ref> [13] </ref>, a network server for client-applications that use diagrams (drawings of graphs). Diagram Server offers to its clients an extensive set of facilities to represent and manage diagrams through a multiwindow-ing environment. One of the most important facilities is a library of sophisticated automatic graph drawing algorithms.
Reference: [14] <author> G. Di Battista, G. Liotta, and F. Vargiu. </author> <title> Spiral-ity of orthogonal representations and optimal drawings of series-parallel graphs and 3-planar graphs. </title> <booktitle> In Proc. Workshop Algorithms Data Struct., volume 709 of Lecture Notes in Computer Science, </booktitle> <pages> pages 151-162. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In addition to the three algorithms we have implemented and compared ( Bend-Stretch, Column, and GIOTTO), several other orthogonal drawing algorithms (mostly for planar graphs) have been reported in the literature. Because of the techniques used, we expect the behavior of the algorithms in <ref> [14, 16, 17, 11, 27, 33, 34, 35, 32, 40] </ref> to be similar to that of one of Bend-Stretch, Column, or GIOTTO.
Reference: [15] <author> D. Dolev, F. T. Leighton, and H. Trickey. </author> <title> Planar embedding of planar graphs. </title> <editor> In F. P. Preparata, editor, </editor> <booktitle> Advances in Computing Research, </booktitle> <volume> volume 2, </volume> <pages> pages 147-161. </pages> <publisher> JAI Press, </publisher> <address> Greenwich, Conn., </address> <year> 1985. </year>
Reference-contexts: It would be interesting to perform further experiments on the practical performance of the recent algorithm by Papakostas and Tollis [37], and of separator-based methods <ref> [15, 31, 49] </ref> that were originally developed for VLSI layout. multigraph general multigraphs accepted as input MakeConnected connectivity testing and augmentation connected connected graph MakeBiconnected biconnectivity testing and augmentation biconnected biconnected graph MakePlanar planarization phase [3, 36] connectedplanar crossing are now replaced by dummy vertices Make4planar expansion of vertices with degree <p> The theoretical analysis shows that the drawings produced by such algorithm have at most 0:8N 2 area, that is about the practical behavior shown by Bend-Stretch. * It would be interesting to perform further experiments on the practical performance of separator-based methods <ref> [15, 31, 49] </ref> that were originally de veloped for VLSI layout. (a) (c) (b) Average number of crossings versus number of vertices. (c) Average deviation from the screen ratio versus number of vertices. * The behavior of Bend-Stretch could be improved by using, instead of the classical algorithms of [39, 44,
Reference: [16] <author> S. Even and G. Granot. </author> <title> Rectilinear planar drawings with few bends in each edge. </title> <type> Technical Report 797, </type> <institution> Computer Science Dept., Technion", </institution> <year> 1994. </year>
Reference-contexts: In addition to the three algorithms we have implemented and compared ( Bend-Stretch, Column, and GIOTTO), several other orthogonal drawing algorithms (mostly for planar graphs) have been reported in the literature. Because of the techniques used, we expect the behavior of the algorithms in <ref> [14, 16, 17, 11, 27, 33, 34, 35, 32, 40] </ref> to be similar to that of one of Bend-Stretch, Column, or GIOTTO.
Reference: [17] <author> S. Even and G. Granot. </author> <title> Grid layouts of block diagrams | bounding the number of bends in each connection. </title> <editor> In R. Tamassia and I. G. Tollis, editors, </editor> <booktitle> Graph Drawing (Proc. GD '94), volume 894 of Lecture Notes in Com--puter Science, </booktitle> <pages> pages 64-75. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: In addition to the three algorithms we have implemented and compared ( Bend-Stretch, Column, and GIOTTO), several other orthogonal drawing algorithms (mostly for planar graphs) have been reported in the literature. Because of the techniques used, we expect the behavior of the algorithms in <ref> [14, 16, 17, 11, 27, 33, 34, 35, 32, 40] </ref> to be similar to that of one of Bend-Stretch, Column, or GIOTTO.
Reference: [18] <author> T. Fruchterman and E. Reingold. </author> <title> Graph drawing by force-directed placement. </title> <journal> Softw. - Pract. Exp., </journal> <volume> 21(11) </volume> <pages> 1129-1164, </pages> <year> 1991. </year>
Reference-contexts: Most papers in this area show sample outputs, and some also provide limited experimental results on small (with fewer than 100 graphs) test suites (see, e.g., <ref> [9, 18, 20, 24, 25, 28] </ref> and the experimental papers in [46]). However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. <p> Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [21] presents a comparative study of twelve graph drawings algorithms, including <ref> [6, 10, 18, 26, 41, 42, 50, 52] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planariza-tion) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
Reference: [19] <author> G. Gane and T. Sarson. </author> <title> Structured Systems Analysis. </title> <publisher> Prentice Hall, </publisher> <year> 1979. </year>
Reference-contexts: Italian software companies (especially from Database Informatica) and large government organization (including the Italian Internal Revenue Service and the Italian National Advisory Council for Computer Applications in the Government (Autorita per l'Informatica nella Pubblica Ammin istrazione)). * 33% of the graphs were taken from well-known reference books in software engineering <ref> [19] </ref> and database design [1], and from journal articles on software visualization in the recent issues of Information Systems and the IEEE Transactions on Software Engineering. * 13% of the graphs were extracted from theses in software and database visualization written by stu dents at the University of Rome "La Sapienza".
Reference: [20] <author> E. R. Gansner, S. C. North, and K. P. Vo. </author> <title> DAG A program that draws directed graphs. </title> <journal> Softw. - Pract. Exp., </journal> <volume> 18(11) </volume> <pages> 1047-1062, </pages> <year> 1988. </year>
Reference-contexts: Most papers in this area show sample outputs, and some also provide limited experimental results on small (with fewer than 100 graphs) test suites (see, e.g., <ref> [9, 18, 20, 24, 25, 28] </ref> and the experimental papers in [46]). However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain.
Reference: [21] <author> M. Himsolt. </author> <title> Comparing and evaluating layout algorithms within graphed. </title> <type> Manuscript, </type> <institution> Fakultat fur Math-ematik und Informatik, Univ. Passau, </institution> <year> 1994. </year>
Reference-contexts: Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt <ref> [21] </ref> presents a comparative study of twelve graph drawings algorithms, including [6, 10, 18, 26, 41, 42, 50, 52]. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planariza-tion) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
Reference: [22] <author> M. Himsolt. GraphEd: </author> <title> a graphical platform for the implementation of graph algorithms. </title> <editor> In R. Tamassia and I. G. Tollis, editors, </editor> <booktitle> Graph Drawing (Proc. GD '94), volume 894 of Lecture Notes in Computer Science, </booktitle> <pages> pages 182-193. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Only three algorithms draw general graphs, while the others are specialized for trees, planar graphs, Petri nets, and graph grammars. The experiments are conducted with the graph drawing system GraphEd <ref> [22] </ref>. Many examples of drawings constructed by the algorithms are shown, and various objective and subjective evaluations on the aesthetic quality of the drawings produced are given.
Reference: [23] <author> S. Jones, P. Eades, A. Moran, N. Ward, G. Delott, and R. Tamassia. </author> <title> A note on planar graph drawing algorithms. </title> <type> Technical Report 216, </type> <institution> Department of Computer Science, University of Queensland, </institution> <year> 1991. </year>
Reference-contexts: However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. The performance of four planar straight-line drawing algorithms [6, 7, 10, 38, 48] is compared in <ref> [23] </ref>. These algorithms have been implemented and tested on 10,000 randomly generated maximal planar graphs. The standard deviations in angle size, edge length, and face area are used to compare the quality of the planar straight-line drawings produced.
Reference: [24] <author> M. Juenger and P. Mutzel. </author> <title> Maximum planar subgraphs and nice embeddings: Practical layout tools. </title> <journal> Algorith-mica, </journal> <note> to appear. </note>
Reference-contexts: Most papers in this area show sample outputs, and some also provide limited experimental results on small (with fewer than 100 graphs) test suites (see, e.g., <ref> [9, 18, 20, 24, 25, 28] </ref> and the experimental papers in [46]). However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. <p> Can a more sophisticated heuristics (for example based on the work of Juenger and Mutzel <ref> [24] </ref> on the computation of the maximum planar subgraph) dramatically improve the behavior of such algorithms? (a) (c) number of vertices. (b) Average maximum number of bends on any edge versus number of vertices. (c) Average standard deviation of the number of bends on the edges versus number of vertices. *
Reference: [25] <author> T. Kamada. </author> <title> Visualizing Abstract Objects and Relations. </title> <booktitle> World Scientific Series in Computer Science, </booktitle> <year> 1989. </year>
Reference-contexts: Most papers in this area show sample outputs, and some also provide limited experimental results on small (with fewer than 100 graphs) test suites (see, e.g., <ref> [9, 18, 20, 24, 25, 28] </ref> and the experimental papers in [46]). However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain.
Reference: [26] <author> T. Kamada and S. Kawai. </author> <title> An algorithm for drawing general undirected graphs. </title> <journal> Inform. Process. Lett., </journal> <volume> 31 </volume> <pages> 7-15, </pages> <year> 1989. </year>
Reference-contexts: Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [21] presents a comparative study of twelve graph drawings algorithms, including <ref> [6, 10, 18, 26, 41, 42, 50, 52] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planariza-tion) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
Reference: [27] <author> G. Kant. </author> <title> Drawing planar graphs using the lmc-ordering. </title> <booktitle> In Proc. 33th Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 101-110, </pages> <year> 1992. </year>
Reference-contexts: In addition to the three algorithms we have implemented and compared ( Bend-Stretch, Column, and GIOTTO), several other orthogonal drawing algorithms (mostly for planar graphs) have been reported in the literature. Because of the techniques used, we expect the behavior of the algorithms in <ref> [14, 16, 17, 11, 27, 33, 34, 35, 32, 40] </ref> to be similar to that of one of Bend-Stretch, Column, or GIOTTO.
Reference: [28] <author> G. Kant. </author> <title> Algorithms for Drawing Planar Graphs. </title> <type> PhD thesis, </type> <institution> Dept. Comput. Sci., Univ. </institution> <address> Utrecht, Utrecht, Netherlands, </address> <year> 1993. </year>
Reference-contexts: Most papers in this area show sample outputs, and some also provide limited experimental results on small (with fewer than 100 graphs) test suites (see, e.g., <ref> [9, 18, 20, 24, 25, 28] </ref> and the experimental papers in [46]). However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. <p> The second phase, orthogonalization, computes an orthogonal shape for the drawing. The third phase, compaction, produces the final drawing. This approach allows homogeneous treatment of a wide range of diagrammatic representations, aesthetics and constraints (see, e.g., <ref> [28, 43, 47] </ref>) and has been successfully used in industrial tools. The main difference between the two algorithms is in the orthogonalization phase: Algorithm GIOTTO uses a network-flow method that guarantees the minimum number of bends but has quadratic time-complexity [42].
Reference: [29] <author> G. Kant. </author> <title> A more compact visibility representation. </title> <booktitle> In Proc. 19th Internat. Workshop Graph-Theoret. </booktitle> <institution> Concepts Comput. Sci. (WG'93), </institution> <year> 1993. </year>
Reference-contexts: de veloped for VLSI layout. (a) (c) (b) Average number of crossings versus number of vertices. (c) Average deviation from the screen ratio versus number of vertices. * The behavior of Bend-Stretch could be improved by using, instead of the classical algorithms of [39, 44, 51], the algorithm by Kant <ref> [29] </ref> for constructing compact visibility representations. * The performance of GIOTTO and Bend-Stretch is affected by the number of crossings introduced by the planarization phase.
Reference: [30] <author> G. Kant and H. L. Bodlaender. </author> <title> Planar graph augmentation problems. </title> <booktitle> In Proc. 2nd Workshop Algorithms Data Struct., volume 519 of Lecture Notes in Computer Science, </booktitle> <pages> pages 286-298. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: How much will it improve if we use a more sophisticated biconnec-tivity augmentation technique that preserves pla narity (e.g., <ref> [30] </ref>)? * The computational bottleneck of the GIOTTO algorithm is the bend minimization step (Step3giotto), which has quadratic time complexity [42].
Reference: [31] <author> C. E. Leiserson. </author> <title> Area-efficient graph layouts (for VLSI). </title> <booktitle> In Proc. 21st Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 270-281, </pages> <year> 1980. </year>
Reference-contexts: It would be interesting to perform further experiments on the practical performance of the recent algorithm by Papakostas and Tollis [37], and of separator-based methods <ref> [15, 31, 49] </ref> that were originally developed for VLSI layout. multigraph general multigraphs accepted as input MakeConnected connectivity testing and augmentation connected connected graph MakeBiconnected biconnectivity testing and augmentation biconnected biconnected graph MakePlanar planarization phase [3, 36] connectedplanar crossing are now replaced by dummy vertices Make4planar expansion of vertices with degree <p> The theoretical analysis shows that the drawings produced by such algorithm have at most 0:8N 2 area, that is about the practical behavior shown by Bend-Stretch. * It would be interesting to perform further experiments on the practical performance of separator-based methods <ref> [15, 31, 49] </ref> that were originally de veloped for VLSI layout. (a) (c) (b) Average number of crossings versus number of vertices. (c) Average deviation from the screen ratio versus number of vertices. * The behavior of Bend-Stretch could be improved by using, instead of the classical algorithms of [39, 44,
Reference: [32] <author> Y. Liu, P. Marchioro, and R. Petreschi. </author> <title> A single bend embedding algorithm for cubic graphs. </title> <type> Manuscript, </type> <year> 1994. </year>
Reference-contexts: In addition to the three algorithms we have implemented and compared ( Bend-Stretch, Column, and GIOTTO), several other orthogonal drawing algorithms (mostly for planar graphs) have been reported in the literature. Because of the techniques used, we expect the behavior of the algorithms in <ref> [14, 16, 17, 11, 27, 33, 34, 35, 32, 40] </ref> to be similar to that of one of Bend-Stretch, Column, or GIOTTO.
Reference: [33] <author> Y. Liu, P. Marchioro, R. Petreschi, and B. Simeone. </author> <title> Theoretical results on at most 1-bend embeddability of graphs. </title> <type> Technical report, </type> <institution> Dipartimento di Statistica, Univ. di Roma "La Sapienza", </institution> <year> 1990. </year>
Reference-contexts: In addition to the three algorithms we have implemented and compared ( Bend-Stretch, Column, and GIOTTO), several other orthogonal drawing algorithms (mostly for planar graphs) have been reported in the literature. Because of the techniques used, we expect the behavior of the algorithms in <ref> [14, 16, 17, 11, 27, 33, 34, 35, 32, 40] </ref> to be similar to that of one of Bend-Stretch, Column, or GIOTTO.
Reference: [34] <author> Y. Liu, A. Morgana, and B. Simeone. </author> <title> General theoretical results on rectilinear embeddability of graphs. </title> <journal> Acta Math. Appl. Sinica, </journal> <volume> 7 </volume> <pages> 187-192, </pages> <year> 1991. </year>
Reference-contexts: In addition to the three algorithms we have implemented and compared ( Bend-Stretch, Column, and GIOTTO), several other orthogonal drawing algorithms (mostly for planar graphs) have been reported in the literature. Because of the techniques used, we expect the behavior of the algorithms in <ref> [14, 16, 17, 11, 27, 33, 34, 35, 32, 40] </ref> to be similar to that of one of Bend-Stretch, Column, or GIOTTO.
Reference: [35] <author> Y. Liu, A. Morgana, and B. Simeone. </author> <title> A linear algorithm for 3-bend embeddings of planar graphs in the grid. </title> <type> Manuscript, </type> <year> 1993. </year>
Reference-contexts: In addition to the three algorithms we have implemented and compared ( Bend-Stretch, Column, and GIOTTO), several other orthogonal drawing algorithms (mostly for planar graphs) have been reported in the literature. Because of the techniques used, we expect the behavior of the algorithms in <ref> [14, 16, 17, 11, 27, 33, 34, 35, 32, 40] </ref> to be similar to that of one of Bend-Stretch, Column, or GIOTTO.
Reference: [36] <author> E. Nardelli and M. Talamo. </author> <title> A fast algorithm for pla-narization of sparse diagrams. </title> <type> Technical Report R.105, </type> <institution> IASI-CNR, Rome, </institution> <year> 1984. </year>
Reference-contexts: practical performance of the recent algorithm by Papakostas and Tollis [37], and of separator-based methods [15, 31, 49] that were originally developed for VLSI layout. multigraph general multigraphs accepted as input MakeConnected connectivity testing and augmentation connected connected graph MakeBiconnected biconnectivity testing and augmentation biconnected biconnected graph MakePlanar planarization phase <ref> [3, 36] </ref> connectedplanar crossing are now replaced by dummy vertices Make4planar expansion of vertices with degree greater than 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum de gree 4 Step3giotto orthogonalization phase [42] step1TaTo89 construction of a visibility repre sentation
Reference: [37] <author> A. Papakostas and I. G. Tollis. </author> <title> Improved algorithms and bounds for orthogonal drawings. </title> <editor> In R. Tamas-sia and I. G. Tollis, editors, </editor> <booktitle> Graph Drawing (Proc. GD '94), volume 894 of Lecture Notes in Computer Science, </booktitle> <pages> pages 40-51. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: It would be interesting to perform further experiments on the practical performance of the recent algorithm by Papakostas and Tollis <ref> [37] </ref>, and of separator-based methods [15, 31, 49] that were originally developed for VLSI layout. multigraph general multigraphs accepted as input MakeConnected connectivity testing and augmentation connected connected graph MakeBiconnected biconnectivity testing and augmentation biconnected biconnected graph MakePlanar planarization phase [3, 36] connectedplanar crossing are now replaced by dummy vertices Make4planar <p> N = 30, and 3 seconds for 90 N 100. 6 Open Problems The experiments performed are an interesting source of both theoretical and practical open problems: * It would be interesting to compare the three above algorithms with a very recent algorithm for orthogonal drawings by Papakostas and Tollis <ref> [37] </ref>.
Reference: [38] <author> R. </author> <title> Read. New methods for drawing a planar graph given the cyclic order of the edges at each vertex. </title> <journal> Con-gressus Numerantium, </journal> <volume> 56 </volume> <pages> 31-44, </pages> <year> 1987. </year>
Reference-contexts: However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. The performance of four planar straight-line drawing algorithms <ref> [6, 7, 10, 38, 48] </ref> is compared in [23]. These algorithms have been implemented and tested on 10,000 randomly generated maximal planar graphs. The standard deviations in angle size, edge length, and face area are used to compare the quality of the planar straight-line drawings produced.
Reference: [39] <author> P. Rosenstiehl and R. E. Tarjan. </author> <title> Rectilinear planar layouts and bipolar orientations of planar graphs. </title> <journal> Discrete Comput. Geom., </journal> <volume> 1(4) </volume> <pages> 343-353, </pages> <year> 1986. </year>
Reference-contexts: 36] connectedplanar crossing are now replaced by dummy vertices Make4planar expansion of vertices with degree greater than 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum de gree 4 Step3giotto orthogonalization phase [42] step1TaTo89 construction of a visibility repre sentation <ref> [39, 44, 51] </ref>) step2TaTo89 fast orthogonalization [45] step4TaTo89 bend-stretching transformations, which remove bends by local layout modifications [45] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto compaction phase [3] BiedlKant orthogonal drawing algorithm [5] manhattan the final output is an orthogonal grid drawing Table 1: <p> methods [15, 31, 49] that were originally de veloped for VLSI layout. (a) (c) (b) Average number of crossings versus number of vertices. (c) Average deviation from the screen ratio versus number of vertices. * The behavior of Bend-Stretch could be improved by using, instead of the classical algorithms of <ref> [39, 44, 51] </ref>, the algorithm by Kant [29] for constructing compact visibility representations. * The performance of GIOTTO and Bend-Stretch is affected by the number of crossings introduced by the planarization phase.
Reference: [40] <author> J. A. Storer. </author> <title> On minimal node-cost planar embeddings. </title> <journal> Networks, </journal> <volume> 14 </volume> <pages> 181-212, </pages> <year> 1984. </year>
Reference-contexts: In addition to the three algorithms we have implemented and compared ( Bend-Stretch, Column, and GIOTTO), several other orthogonal drawing algorithms (mostly for planar graphs) have been reported in the literature. Because of the techniques used, we expect the behavior of the algorithms in <ref> [14, 16, 17, 11, 27, 33, 34, 35, 32, 40] </ref> to be similar to that of one of Bend-Stretch, Column, or GIOTTO.
Reference: [41] <author> K. Sugiyama, S. Tagawa, and M. </author> <title> Toda. Methods for visual understanding of hierarchical systems. </title> <journal> IEEE Trans. Syst. Man Cybern., </journal> <volume> SMC-11(2):109-125, </volume> <year> 1981. </year>
Reference-contexts: Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [21] presents a comparative study of twelve graph drawings algorithms, including <ref> [6, 10, 18, 26, 41, 42, 50, 52] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planariza-tion) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
Reference: [42] <author> R. Tamassia. </author> <title> On embedding a graph in the grid with the minimum number of bends. </title> <journal> SIAM J. Comput., </journal> <volume> 16(3) </volume> <pages> 421-444, </pages> <year> 1987. </year>
Reference-contexts: Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [21] presents a comparative study of twelve graph drawings algorithms, including <ref> [6, 10, 18, 26, 41, 42, 50, 52] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planariza-tion) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline). <p> The main difference between the two algorithms is in the orthogonalization phase: Algorithm GIOTTO uses a network-flow method that guarantees the minimum number of bends but has quadratic time-complexity <ref> [42] </ref>. Algorithm Bend-Stretch adopts the "bend-stretching" heuristic [45] that only guarantees a constant number of bends on each edge but runs in linear time. <p> augmentation biconnected biconnected graph MakePlanar planarization phase [3, 36] connectedplanar crossing are now replaced by dummy vertices Make4planar expansion of vertices with degree greater than 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum de gree 4 Step3giotto orthogonalization phase <ref> [42] </ref> step1TaTo89 construction of a visibility repre sentation [39, 44, 51]) step2TaTo89 fast orthogonalization [45] step4TaTo89 bend-stretching transformations, which remove bends by local layout modifications [45] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto compaction phase [3] BiedlKant orthogonal drawing algorithm [5] manhattan the final <p> How much will it improve if we use a more sophisticated biconnec-tivity augmentation technique that preserves pla narity (e.g., [30])? * The computational bottleneck of the GIOTTO algorithm is the bend minimization step (Step3giotto), which has quadratic time complexity <ref> [42] </ref>.
Reference: [43] <author> R. Tamassia, G. Di Battista, and C. Batini. </author> <title> Automatic graph drawing and readability of diagrams. </title> <journal> IEEE Trans. Syst. Man Cybern., </journal> <volume> SMC-18(1):61-79, </volume> <year> 1988. </year>
Reference-contexts: The second phase, orthogonalization, computes an orthogonal shape for the drawing. The third phase, compaction, produces the final drawing. This approach allows homogeneous treatment of a wide range of diagrammatic representations, aesthetics and constraints (see, e.g., <ref> [28, 43, 47] </ref>) and has been successfully used in industrial tools. The main difference between the two algorithms is in the orthogonalization phase: Algorithm GIOTTO uses a network-flow method that guarantees the minimum number of bends but has quadratic time-complexity [42].
Reference: [44] <author> R. Tamassia and I. G. Tollis. </author> <title> A unified approach to visibility representations of planar graphs. </title> <journal> Discrete Com-put. Geom., </journal> <volume> 1(4) </volume> <pages> 321-341, </pages> <year> 1986. </year>
Reference-contexts: 36] connectedplanar crossing are now replaced by dummy vertices Make4planar expansion of vertices with degree greater than 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum de gree 4 Step3giotto orthogonalization phase [42] step1TaTo89 construction of a visibility repre sentation <ref> [39, 44, 51] </ref>) step2TaTo89 fast orthogonalization [45] step4TaTo89 bend-stretching transformations, which remove bends by local layout modifications [45] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto compaction phase [3] BiedlKant orthogonal drawing algorithm [5] manhattan the final output is an orthogonal grid drawing Table 1: <p> methods [15, 31, 49] that were originally de veloped for VLSI layout. (a) (c) (b) Average number of crossings versus number of vertices. (c) Average deviation from the screen ratio versus number of vertices. * The behavior of Bend-Stretch could be improved by using, instead of the classical algorithms of <ref> [39, 44, 51] </ref>, the algorithm by Kant [29] for constructing compact visibility representations. * The performance of GIOTTO and Bend-Stretch is affected by the number of crossings introduced by the planarization phase.
Reference: [45] <author> R. Tamassia and I. G. Tollis. </author> <title> Planar grid embedding in linear time. </title> <journal> IEEE Trans. on Circuits and Systems, </journal> <volume> CAS-36(9):1230-1234, </volume> <year> 1989. </year>
Reference-contexts: The main difference between the two algorithms is in the orthogonalization phase: Algorithm GIOTTO uses a network-flow method that guarantees the minimum number of bends but has quadratic time-complexity [42]. Algorithm Bend-Stretch adopts the "bend-stretching" heuristic <ref> [45] </ref> that only guarantees a constant number of bends on each edge but runs in linear time. <p> by dummy vertices Make4planar expansion of vertices with degree greater than 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum de gree 4 Step3giotto orthogonalization phase [42] step1TaTo89 construction of a visibility repre sentation [39, 44, 51]) step2TaTo89 fast orthogonalization <ref> [45] </ref> step4TaTo89 bend-stretching transformations, which remove bends by local layout modifications [45] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto compaction phase [3] BiedlKant orthogonal drawing algorithm [5] manhattan the final output is an orthogonal grid drawing Table 1: Algorithmic components and intermediate representations used <p> 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum de gree 4 Step3giotto orthogonalization phase [42] step1TaTo89 construction of a visibility repre sentation [39, 44, 51]) step2TaTo89 fast orthogonalization <ref> [45] </ref> step4TaTo89 bend-stretching transformations, which remove bends by local layout modifications [45] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto compaction phase [3] BiedlKant orthogonal drawing algorithm [5] manhattan the final output is an orthogonal grid drawing Table 1: Algorithmic components and intermediate representations used by algorithms Bend-Stretch, Column, and GIOTTO in the automatic graph drawing <p> TotalBends: The experimental results sharply fit the theoretical results. Namely, GIOTTO has the minimum number of bends; Bend-Stretch and Column have a number of bends that, also for the constants, is essentially the one predicted by the theoretical analysis <ref> [45, 5] </ref>. Observe that the performance of Bend-Stretch on TotalBends deeply affects also the performance of such algorithm on Area. MaxEdgeBends: Column has the best behavior.
Reference: [46] <editor> R. Tamassia and I. G. Tollis, editors. </editor> <booktitle> Graph Drawing (Proc. GD '94), volume 894 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Because of the direct applications of graph drawing to advanced graphic user interfaces and visualization systems, and thanks to the many theoretical challenges posed by the interplay of graph theory and geometry, an extensive literature on the subject <ref> [12, 46] </ref> has grown in the last decade. Various graphic standards have been proposed for the representation of graphs in the plane. <p> Most papers in this area show sample outputs, and some also provide limited experimental results on small (with fewer than 100 graphs) test suites (see, e.g., [9, 18, 20, 24, 25, 28] and the experimental papers in <ref> [46] </ref>). However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. The performance of four planar straight-line drawing algorithms [6, 7, 10, 38, 48] is compared in [23].
Reference: [47] <author> H. Trickey. </author> <title> Drag: A graph drawing system. </title> <booktitle> In Proc. In-ternat. Conf. on Electronic Publishing, </booktitle> <pages> pages 171-182. </pages> <publisher> Cambridge University Press, </publisher> <year> 1988. </year>
Reference-contexts: The second phase, orthogonalization, computes an orthogonal shape for the drawing. The third phase, compaction, produces the final drawing. This approach allows homogeneous treatment of a wide range of diagrammatic representations, aesthetics and constraints (see, e.g., <ref> [28, 43, 47] </ref>) and has been successfully used in industrial tools. The main difference between the two algorithms is in the orthogonalization phase: Algorithm GIOTTO uses a network-flow method that guarantees the minimum number of bends but has quadratic time-complexity [42].
Reference: [48] <author> W. T. Tutte. </author> <title> How to draw a graph. </title> <journal> Proceedings London Mathematical Society, </journal> <volume> 3(13) </volume> <pages> 743-768, </pages> <year> 1963. </year>
Reference-contexts: However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. The performance of four planar straight-line drawing algorithms <ref> [6, 7, 10, 38, 48] </ref> is compared in [23]. These algorithms have been implemented and tested on 10,000 randomly generated maximal planar graphs. The standard deviations in angle size, edge length, and face area are used to compare the quality of the planar straight-line drawings produced.
Reference: [49] <author> L. Valiant. </author> <title> Universality considerations in VLSI circuits. </title> <journal> IEEE Trans. Comput., </journal> <volume> C-30(2):135-140, </volume> <year> 1981. </year>
Reference-contexts: It would be interesting to perform further experiments on the practical performance of the recent algorithm by Papakostas and Tollis [37], and of separator-based methods <ref> [15, 31, 49] </ref> that were originally developed for VLSI layout. multigraph general multigraphs accepted as input MakeConnected connectivity testing and augmentation connected connected graph MakeBiconnected biconnectivity testing and augmentation biconnected biconnected graph MakePlanar planarization phase [3, 36] connectedplanar crossing are now replaced by dummy vertices Make4planar expansion of vertices with degree <p> The theoretical analysis shows that the drawings produced by such algorithm have at most 0:8N 2 area, that is about the practical behavior shown by Bend-Stretch. * It would be interesting to perform further experiments on the practical performance of separator-based methods <ref> [15, 31, 49] </ref> that were originally de veloped for VLSI layout. (a) (c) (b) Average number of crossings versus number of vertices. (c) Average deviation from the screen ratio versus number of vertices. * The behavior of Bend-Stretch could be improved by using, instead of the classical algorithms of [39, 44,
Reference: [50] <author> J. Q. Walker II. </author> <title> A node-positioning algorithm for general trees. </title> <journal> Softw. - Pract. Exp., </journal> <volume> 20(7) </volume> <pages> 685-705, </pages> <year> 1990. </year>
Reference-contexts: Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [21] presents a comparative study of twelve graph drawings algorithms, including <ref> [6, 10, 18, 26, 41, 42, 50, 52] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planariza-tion) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
Reference: [51] <author> S. K. Wismath. </author> <title> Characterizing bar line-of-sight graphs. </title> <booktitle> In Proc. 1st Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 147-152, </pages> <year> 1985. </year>
Reference-contexts: 36] connectedplanar crossing are now replaced by dummy vertices Make4planar expansion of vertices with degree greater than 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum de gree 4 Step3giotto orthogonalization phase [42] step1TaTo89 construction of a visibility repre sentation <ref> [39, 44, 51] </ref>) step2TaTo89 fast orthogonalization [45] step4TaTo89 bend-stretching transformations, which remove bends by local layout modifications [45] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto compaction phase [3] BiedlKant orthogonal drawing algorithm [5] manhattan the final output is an orthogonal grid drawing Table 1: <p> methods [15, 31, 49] that were originally de veloped for VLSI layout. (a) (c) (b) Average number of crossings versus number of vertices. (c) Average deviation from the screen ratio versus number of vertices. * The behavior of Bend-Stretch could be improved by using, instead of the classical algorithms of <ref> [39, 44, 51] </ref>, the algorithm by Kant [29] for constructing compact visibility representations. * The performance of GIOTTO and Bend-Stretch is affected by the number of crossings introduced by the planarization phase.
Reference: [52] <author> D. Woods. </author> <title> Drawing Planar Graphs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1982. </year> <note> Technical Report STAN-CS-82-943. </note>
Reference-contexts: Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [21] presents a comparative study of twelve graph drawings algorithms, including <ref> [6, 10, 18, 26, 41, 42, 50, 52] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planariza-tion) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
References-found: 52

