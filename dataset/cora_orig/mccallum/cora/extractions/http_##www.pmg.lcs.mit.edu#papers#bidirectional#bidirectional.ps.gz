URL: http://www.pmg.lcs.mit.edu/papers/bidirectional/bidirectional.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/papers/bidirectional/
Root-URL: 
Email: andru@lcs.mit.edu  
Title: on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA) Bidirectional Object Layout for Separate Compilation  
Author: Andrew C. Myers 
Address: 545 Technology Square Cambridge, MA 02139, USA  
Affiliation: MIT Laboratory for Computer Science  
Note: Proceedings of the 1995 ACM Conference  
Abstract: Existing schemes for object layout and dispatch in the presence of multiple inheritance and separate compilation waste space and are slower than systems with single inheritance. This paper describes the bidirectional object layout, a new scheme for object layout that produces smaller objects and faster method invocations than existing schemes by automatically optimizing particular uses of multiple inheritance. The bidirectional object layout is used for the programming language Theta, and is applicable to languages like C++. This paper also demonstrates how to efficiently implement method dispatch when method signatures are allowed to change in subclasses. Most current statically compiled languages require identical signatures for efficiency. 
Abstract-found: 1
Intro-found: 1
Reference: [AR92] <author> Pascal Andr e and Jean-Claude Royer. </author> <title> Optimizing method search with lookup caches and incremental coloring. </title> <booktitle> In OOPSLA '92 Proceedings, </booktitle> <pages> pages 110-126, </pages> <address> Vancouver, BC, Canada, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Second, in a large system, the complex (usually coloring-based) algorithms can require a lot of time; times on the order of an hour have been reported for the Smalltalk-80 hierarchy <ref> [AR92] </ref>. For many systems, these techniques are impractical, and a scheme based on fast local rules is preferable. Rose [Ros88] investigates how to perform the method dispatch operation and settles on fat dispatch tables, where method code is placed directly in the dispatch vector.
Reference: [Car84] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. In Semantics of Data Types, </title> <publisher> LNCS 173, </publisher> <pages> pages 51-68. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: A separate contribution of this paper is an efficient implementation of method signature refinement: a type may compatibly modify the argument and return types of a method derived from its supertypes, in accordance with the usual subtyping rules <ref> [Car84] </ref>. This feature is regrettably missing from other statically compiled languages like C++ or Modula-3 [Nel91]. The technique described here allows a class to refine superclass method signatures yet retain fast method dispatch. <p> The second, generic version accesses all instance variables through the dynamic field offset code of superclass method. This second version is particularly appropriate for mix-in classes. 5 Method Signature Refinement The most general subtype rules allow subtypes to widen argument types and narrow result types <ref> [Car84] </ref>. This process is sometimes called method signature refinement. Because implementing these rules efficiently is 12 difficult, separately-compiled languages like C++ and Modula-3 have a more restrictive subtype rule: they require that argument and return types stay the same in subtype methods.
Reference: [CDN93] <author> Michael J. Carey, David J. DeWitt, and Jef-frey F. Naughton. </author> <title> The OO7 benchmark. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 12-21, </pages> <address> Wash-ington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Considering the two largest libraries, one implementing the OO7 database benchmark <ref> [CDN93] </ref>, and another implementing the Labbase database [RSG95], there are a total of 51 abstract types and 45 classes. Table 1 shows the number of words of per-object dispatch overhead incurred by these classes with the bidirectional layout and with a standard C++ layout.
Reference: [Cha92] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> PhD thesis, </type> <institution> Stanford University Department of Computer Science, Stanford, </institution> <address> CA, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: In addition, fat entries may hurt cache performance. The implementation techniques for multiple inheritance described in Section 4 involve compiling different versions of method code for different inheriting contexts, a technique similar to the production of specialized code in SELF <ref> [CUL89, Cha92] </ref> though the technique is used there to solve a more general problem, since SELF is not statically typed. In the SELF implementation, different versions of the code are produced for every inheriting class, so code sharing is minimal and code duplication can become a problem.
Reference: [CUL89] <author> Craig Chambers, David Ungar, and Elgin Lee. </author> <title> An efficient implementation of SELF, a dynamically-typed object-oriented language based on prototypes. </title> <booktitle> In OOPSLA '89 Conference Proceedings, </booktitle> <pages> pages 49-70, </pages> <address> New Orleans, LA, </address> <month> October </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: In addition, fat entries may hurt cache performance. The implementation techniques for multiple inheritance described in Section 4 involve compiling different versions of method code for different inheriting contexts, a technique similar to the production of specialized code in SELF <ref> [CUL89, Cha92] </ref> though the technique is used there to solve a more general problem, since SELF is not statically typed. In the SELF implementation, different versions of the code are produced for every inheriting class, so code sharing is minimal and code duplication can become a problem.
Reference: [DGLM95] <author> Mark Day, Robert Gruber, Barbara Liskov, and Andrew C. Myers. </author> <title> Subtypes vs. where clauses: Constraining parametric polymorphism. </title> <booktitle> In OOPSLA '95 Proceedings, </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: This feature is regrettably missing from other statically compiled languages like C++ or Modula-3 [Nel91]. The technique described here allows a class to refine superclass method signatures yet retain fast method dispatch. The bidirectional object layout has been implemented for the programming language Theta <ref> [DGLM95, LCD + 94, Mye94] </ref>, a separately-compiled, statically-typed language which separates subtyping and inheritance. Theta allows a class to have any number of explicitly declared abstract supertypes, but only a sin 1 gle concrete superclass.
Reference: [DMSV89] <author> R. Dixon, T. McKee, P. Schweitzer, and M. Vaughan. </author> <title> A fast method dispatcher for compiled languages with multiple inheritance. </title> <booktitle> In OOPSLA '89 Conference Proceedings, </booktitle> <pages> pages 211-214, </pages> <address> New Orleans, LA, </address> <month> October </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Existing schemes for object memory layout and method dispatch in statically typed languages with multiple inheritance assume the use of multiple inheritance in its full generality. These schemes incur high per-object space overhead [Str87], extra dispatch cost, or a global type analysis phase <ref> [DMSV89] </ref>. fl Web site: http://www.pmg.lcs.mit.edu/andru/. This research was supported in part by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research under contract N00014-91-J-4136 and in part by the National Science Foundation under grant CCR-8822158. <p> Almost all the optimizations defined here can be applied to C++ compilers in a straightforward manner. Much work on object layout has focused on assigning non-conflicting indices so each class has a single dispatch vector <ref> [DMSV89] </ref>. The resulting dispatch vectors may be sparse and contain multiple holes, so compressing them is a major concern [PW90, Dri93]. There are two important problems with these techniques: first, they are not compatible with separate compilation.
Reference: [Dri93] <author> Karel Driesen. </author> <title> Selector table indexing & sparse arrays. </title> <booktitle> In OOPSLA '93 Proceedings, </booktitle> <pages> pages 259-270, </pages> <address> Washington, DC, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: Much work on object layout has focused on assigning non-conflicting indices so each class has a single dispatch vector [DMSV89]. The resulting dispatch vectors may be sparse and contain multiple holes, so compressing them is a major concern <ref> [PW90, Dri93] </ref>. There are two important problems with these techniques: first, they are not compatible with separate compilation. Adding a new class or classes to the system can require recomputing method indices for other portions of the system, since the entire type hierarchy must be analyzed to select method indices.
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: These problems are addressed by the bidirectional object layout, a new scheme suitable for separately-compiled languages with multiple inheritance. The primary advantage of this object layout is that it supports faster method dispatch than current C++ implementations <ref> [ES90] </ref>, while reducing the amount of per-object dispatch information. This paper presents precise rules for constructing bidirectional layouts and explains the dispatch code needed for typical RISC architectures.
Reference: [LCD + 94] <author> Barbara Liskov, Dorothy Curtis, Mark Day, San-jay Ghemawat, Robert Gruber, Paul Johnson, and Andrew C. Myers. </author> <title> Theta Reference Manual. Programming Methodology Group Memo 88, </title> <institution> MIT Lab for Computer Science, </institution> <address> Cambridge, MA, </address> <month> February </month> <year> 1994. </year> <note> Also available at http://www.pmg.lcs.mit.edu/ papers/thetaref/. </note>
Reference-contexts: This feature is regrettably missing from other statically compiled languages like C++ or Modula-3 [Nel91]. The technique described here allows a class to refine superclass method signatures yet retain fast method dispatch. The bidirectional object layout has been implemented for the programming language Theta <ref> [DGLM95, LCD + 94, Mye94] </ref>, a separately-compiled, statically-typed language which separates subtyping and inheritance. Theta allows a class to have any number of explicitly declared abstract supertypes, but only a sin 1 gle concrete superclass.
Reference: [LCV88] <author> Mark Linton, Paul Calder, and John Vlissides. InterViews: </author> <title> A C++ Graphical Interface Toolkit. </title> <type> Technical Report 358, </type> <institution> Stanford Computer Systems Laboratory, </institution> <month> July </month> <year> 1988. </year>
Reference-contexts: However, per-class space usage is less important than per-object space usage, since the total number of objects in any significant program is likely to be much larger than the total number of classes in use. 6.2 InterViews Library An example of larger-scale object-oriented programming is the InterViews 3.1 toolkit <ref> [LCV88] </ref>, written in C++ with multiple inheritance. Including component libraries, it comprises about 426 public classes.
Reference: [Mye94] <author> Andrew C. Myers. </author> <title> Fast Object Operations in a Persistent Programming System. </title> <type> Technical Report MIT/LCS/TR-599, </type> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, MA, </address> <month> January </month> <year> 1994. </year> <type> Master's thesis. </type>
Reference-contexts: This feature is regrettably missing from other statically compiled languages like C++ or Modula-3 [Nel91]. The technique described here allows a class to refine superclass method signatures yet retain fast method dispatch. The bidirectional object layout has been implemented for the programming language Theta <ref> [DGLM95, LCD + 94, Mye94] </ref>, a separately-compiled, statically-typed language which separates subtyping and inheritance. Theta allows a class to have any number of explicitly declared abstract supertypes, but only a sin 1 gle concrete superclass. <p> This result is a significant improvement on existing techniques. Negative method indices allow smaller headers. Without them, reasonable merge schemes can be defined <ref> [Mye94] </ref>, but the size of headers in a type/class lattice is two words rather than one.
Reference: [Nel91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: This feature is regrettably missing from other statically compiled languages like C++ or Modula-3 <ref> [Nel91] </ref>. The technique described here allows a class to refine superclass method signatures yet retain fast method dispatch. The bidirectional object layout has been implemented for the programming language Theta [DGLM95, LCD + 94, Mye94], a separately-compiled, statically-typed language which separates subtyping and inheritance.
Reference: [PW90] <author> William Pugh and Grant Weddell. </author> <title> Two-directional record layout for multiple inheritance. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 85-91, </pages> <address> White Plains, NY, </address> <month> June </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(6), </note> <month> June, </month> <year> 1990. </year>
Reference-contexts: Much work on object layout has focused on assigning non-conflicting indices so each class has a single dispatch vector [DMSV89]. The resulting dispatch vectors may be sparse and contain multiple holes, so compressing them is a major concern <ref> [PW90, Dri93] </ref>. There are two important problems with these techniques: first, they are not compatible with separate compilation. Adding a new class or classes to the system can require recomputing method indices for other portions of the system, since the entire type hierarchy must be analyzed to select method indices.
Reference: [Ros88] <author> John R. Rose. </author> <title> Fast dispatch mechanisms for stock hardware. </title> <booktitle> In OOPSLA '88 Conference Proceedings, </booktitle> <pages> pages 27-35, </pages> <address> San Diego, CA, </address> <month> October </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(11), </note> <month> November, </month> <year> 1988. </year>
Reference-contexts: Each dispatch vector is itself an array of pointers to method code, indexed by small integers that are the method indices. The dispatch vector supports selector-table indexed (STI) dispatching <ref> [Ros88] </ref>. Each dispatch vector of 2 an object specifies a different mapping from indices to methods. The last (bottom) dispatch vector, which is always present, is the class dispatch vector. It contains all the methods that can be called on the object. <p> Second, in a large system, the complex (usually coloring-based) algorithms can require a lot of time; times on the order of an hour have been reported for the Smalltalk-80 hierarchy [AR92]. For many systems, these techniques are impractical, and a scheme based on fast local rules is preferable. Rose <ref> [Ros88] </ref> investigates how to perform the method dispatch operation and settles on fat dispatch tables, where method code is placed directly in the dispatch vector.
Reference: [RSG95] <author> S. Rozen, L. Stein, and N. Goodman. Labbase: </author> <title> A database to manage laboratory data in a large-scale genome-mapping project. </title> <journal> IEEE Computers in Medicine and Biology, </journal> <note> 1995. To appear. </note>
Reference-contexts: Considering the two largest libraries, one implementing the OO7 database benchmark [CDN93], and another implementing the Labbase database <ref> [RSG95] </ref>, there are a total of 51 abstract types and 45 classes. Table 1 shows the number of words of per-object dispatch overhead incurred by these classes with the bidirectional layout and with a standard C++ layout.
Reference: [Str87] <author> Bjarne Stroustrup. </author> <title> Multiple inheritance for C++. </title> <booktitle> In Proceedings of the Spring '87 Euro-pean Unix Systems Users's Group Conference, </booktitle> <address> Helsinki, </address> <month> May </month> <year> 1987. </year> <month> 16 </month>
Reference-contexts: 1 Introduction Existing schemes for object memory layout and method dispatch in statically typed languages with multiple inheritance assume the use of multiple inheritance in its full generality. These schemes incur high per-object space overhead <ref> [Str87] </ref>, extra dispatch cost, or a global type analysis phase [DMSV89]. fl Web site: http://www.pmg.lcs.mit.edu/andru/. <p> Note that the supertype relation must be explicitly declared rather than being implicitly inferred from method signatures. 2 Bidirectional Layout The bidirectional layout differs from the layouts used by many C++ implementations <ref> [Str87] </ref>, though there are similarities. An object has a fixed memory layout, defined by its class. <p> In a separate-compilation environment where densely-packed method indices are compiled into the code, a three-word dispatch header is minimal for these classes. 14 7 Related Work The bidirectional layout can be seen as a way of tuning the basic C++ object layout approach <ref> [Str87] </ref> to work well with current architectures and programming practice. Almost all the optimizations defined here can be applied to C++ compilers in a straightforward manner. Much work on object layout has focused on assigning non-conflicting indices so each class has a single dispatch vector [DMSV89].
References-found: 17

