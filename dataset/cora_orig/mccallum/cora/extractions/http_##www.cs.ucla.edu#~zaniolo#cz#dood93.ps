URL: http://www.cs.ucla.edu/~zaniolo/cz/dood93.ps
Refering-URL: http://www.cs.ucla.edu/~zaniolo/cz/ZanioloPapers.html
Root-URL: http://www.cs.ucla.edu
Email: zaniolo@cs.ucla.edu  natraj@mcc.com and kayliang@mcc.com  
Title: DOOD'93 Negation and Aggregates in Recursive Rules: the LDL++ Approach  
Author: Carlo Zaniolo Natraj Arni and Kayliang Ong 
Address: Los Angeles, California 90024  Austin, Texas 78759  
Affiliation: Computer Science Department, University of California  Microelectronics and Computer Technology Corporation  
Abstract: The problem of allowing non-monotonic constructs, such as negation and aggregates, in recursive programs represents a difficult challenge faced by current research in deductive databases. In this paper, we present a solution that combines generality with efficiency, as demonstrated by its implementation in the new LDL++ system. A novel and general treatment of set aggregates, allowing for user-defined aggregates, is also presented.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, J.E. Hopcropt, and J.D. </author> <title> Ullmann. The Design and analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference: [2] <author> N. Arni, K. Ong, S. Tsur and C. Zaniolo. </author> <title> The LDL++ System: Rationale, </title> <journal> Technology and Applications. </journal> <note> Submitted for publication. </note>
Reference-contexts: Here we propose a semantics that is simple, general and conducive to efficient implementation, as demonstrated by the LDL++ system <ref> [2] </ref>. Our approach builds on the choice construct, where formal logic-based semantics, usability in programming and computational efficiency have successfully converged| a second example of such a convergence after stratification. The idea of choice was introduced in [11] to express non-determinism in a declarative fashion.
Reference: [3] <editor> Chimenti, D. et al., </editor> <title> "The LDL System Prototype," </title> <journal> IEEE Journal on Data and Knowledge Engineering, </journal> <volume> vol. 2, no. 1, </volume> <pages> pp. 76-90, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: This concept is significant since it removes several of the limitations and problems of Prolog's negation-by-failure, and it is conducive to efficient implementation, as demonstrated by systems such as Glue-Nail, LDL and CORAL <ref> [15, 22, 3] </ref>.
Reference: [4] <author> M.P. Consens and A.O. Mendelzon. </author> <title> Low complexity aggregation in graphlog and datalog. </title> <booktitle> In Proceedings of the third International Conference on Database Theory, </booktitle> <year> 1990. </year>
Reference: [5] <author> S. Ganguly, S. Greco, and C. Zaniolo. </author> <title> Minimum and Maximum Predicates in Logic Programming. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 154-113, </pages> <year> 1991. </year>
Reference-contexts: However, as experience was gained with real-life applications [23], it became clear that stratification is too restrictive and there remain many important applications where negation and set aggregates are needed: such applications, range from processing Bill of Materials to finding the shortest path in a graph <ref> [5, 6] </ref>. Therefore, during the last five years, a substantial research effort has been devoted to solving the non-stratification issue. <p> In this paper, we take a different approach| the synthesis of our experience with concrete LDL applications [23], and classical optimization problems <ref> [5, 6] </ref>. We focus on syntactically decidable subclasses of non-monotonic recursive programs which capture the expressive power of inflationary fixpoint semantics [14]. Therefore, we introduce a special class of locally stratified programs that is easy for a compiler to recognize and implement using the fixpoint-based computation of deductive DBs.
Reference: [6] <author> S. Ganguly, S. Greco, and C. Zaniolo. </author> <title> Propagation of Extrema Predicates into Recursive Logic Programs. In Unpublished Manuscript, </title> <year> 1992. </year>
Reference-contexts: However, as experience was gained with real-life applications [23], it became clear that stratification is too restrictive and there remain many important applications where negation and set aggregates are needed: such applications, range from processing Bill of Materials to finding the shortest path in a graph <ref> [5, 6] </ref>. Therefore, during the last five years, a substantial research effort has been devoted to solving the non-stratification issue. <p> In this paper, we take a different approach| the synthesis of our experience with concrete LDL applications [23], and classical optimization problems <ref> [5, 6] </ref>. We focus on syntactically decidable subclasses of non-monotonic recursive programs which capture the expressive power of inflationary fixpoint semantics [14]. Therefore, we introduce a special class of locally stratified programs that is easy for a compiler to recognize and implement using the fixpoint-based computation of deductive DBs.
Reference: [7] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics of logic programming. </title> <booktitle> In Proceedings of the Fifth Intern. Conference on Logic Programming, </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: Therefore, during the last five years, a substantial research effort has been devoted to solving the non-stratification issue. This endeavor has produced significant progress on the theoretical front, with the introduction of concepts such as locally stratified programs [16], well-founded models [12], and stable models <ref> [7] </ref>, but it has not yet begotten a solution that is both general and efficient.
Reference: [8] <author> F. Giannotti, D. Pedreschi, D. Sacca, and C. Zaniolo. </author> <title> Nondeterminism in deductive databases. </title> <booktitle> In Proc. 2nd Int. Conf. on Deductive and Object-Oriented Databases, </booktitle> <year> 1991. </year>
Reference-contexts: These problems were solved by using, instead, a semantics based on the use of negation and stable models <ref> [8] </ref>. <p> The criteria for restricting the usage of aggregates in recursion follow directly from these definitions. There is no restriction in using choice, since positive programs with choice goal always have a stable model <ref> [8] </ref>. Thus, to determine the semantic well-formedness of recursive programs, we only need to be concerned with the negation introduced by rule a 5 above: the original program is XY-stratified with respect to aggregates, iff the program obtained by re-writing the aggregates as described above is semantically well-formed. <p> But in LDL++ the semantics of these constructs, which are seemingly different in terms of syntax, and operational meaning, have been all reduced to the same semantic basis|i.e., negation. Choice is formally defined using negation in <ref> [8] </ref>, and set aggregates were defined in this paper using choice and negation. This latter definition solves several problems left open by previous approaches [10, 19, 13].
Reference: [9] <author> S. Greco, C. Zaniolo, and S. Ganguly. </author> <title> Greedy by Choice. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 105-163, </pages> <year> 1992. </year>
Reference: [10] <author> D.B. Kemp and P.J. Stackey. </author> <title> Semantics of Logic Programs with Aggregates. </title> <booktitle> In Proceedings 1991 Int. Logic Programming Symposium, </booktitle> <pages> pages 338-401, </pages> <year> 1991. </year>
Reference-contexts: the definition of min is single (min; X; X): multi (min; Y1; Z1; Z) if (Y1 &lt; Z1 then Z = Y1 else Z = Z1): Therefore, we now need to provide a formal semantics for such extensible aggregates: whereas previous approaches have focused on a fixed set of primitives <ref> [10, 19, 13] </ref>. Here we propose a semantics that is simple, general and conducive to efficient implementation, as demonstrated by the LDL++ system [2]. <p> Choice is formally defined using negation in [8], and set aggregates were defined in this paper using choice and negation. This latter definition solves several problems left open by previous approaches <ref> [10, 19, 13] </ref>.
Reference: [11] <author> R. Krishnamurthy and S. Naqvi. </author> <title> "Non-deterministic choice in Datalog," </title> <booktitle> In Proceedings 3rd Int.Conference on Data and Knowledge Bases, </booktitle> <year> 1988. </year>
Reference-contexts: Our approach builds on the choice construct, where formal logic-based semantics, usability in programming and computational efficiency have successfully converged| a second example of such a convergence after stratification. The idea of choice was introduced in <ref> [11] </ref> to express non-determinism in a declarative fashion. <p> In LDL, this very powerful construct was disallowed in recursion, inasmuch as the functional-dependency based semantics proposed in <ref> [11] </ref> suffers from technical problems such as a lack of justifiability property and its unsuitability to efficient implementation due to its static nature [21]. These problems were solved by using, instead, a semantics based on the use of negation and stable models [8].
Reference: [12] <author> A. Van Gelder, K.A. Ross, and J.S. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> Journal of ACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: Therefore, during the last five years, a substantial research effort has been devoted to solving the non-stratification issue. This endeavor has produced significant progress on the theoretical front, with the introduction of concepts such as locally stratified programs [16], well-founded models <ref> [12] </ref>, and stable models [7], but it has not yet begotten a solution that is both general and efficient.
Reference: [13] <author> A. Van Gelder. </author> <title> The Well-Founded Semantics of Aggregation. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 127-138, </pages> <year> 1992. </year>
Reference-contexts: Therefore, if p 0 is the k-th predicate name in the primed sorting, let T k denote the immediate consequence operator <ref> [13, 18] </ref> for the recursive rules in Q defining p. The composite consequence operator Q , will be defined as follows: Q (I) = T n (T n1 :::(T 1 (I)):::)) where I denotes subset of Q's Herbrand Base B Q , and n 1. <p> the definition of min is single (min; X; X): multi (min; Y1; Z1; Z) if (Y1 &lt; Z1 then Z = Y1 else Z = Z1): Therefore, we now need to provide a formal semantics for such extensible aggregates: whereas previous approaches have focused on a fixed set of primitives <ref> [10, 19, 13] </ref>. Here we propose a semantics that is simple, general and conducive to efficient implementation, as demonstrated by the LDL++ system [2]. <p> Choice is formally defined using negation in [8], and set aggregates were defined in this paper using choice and negation. This latter definition solves several problems left open by previous approaches <ref> [10, 19, 13] </ref>.
Reference: [14] <author> P.G. Kolaitis and C.H. Papadimitriou, </author> <title> Why not negation by fixpoint?, </title> <journal> JCSS, </journal> <volume> 43(1), </volume> <pages> 125-144, </pages> <year> 1991. </year>
Reference-contexts: In this paper, we take a different approach| the synthesis of our experience with concrete LDL applications [23], and classical optimization problems [5, 6]. We focus on syntactically decidable subclasses of non-monotonic recursive programs which capture the expressive power of inflationary fixpoint semantics <ref> [14] </ref>. Therefore, we introduce a special class of locally stratified programs that is easy for a compiler to recognize and implement using the fixpoint-based computation of deductive DBs. This class, called XY-stratified programs is first introduced in Section 2, which focuses on programs with negated goals in recursive rules. <p> In particular, Nail-Glue provides a procedural shell that minimizes the "impedance-mismatch" problem between the procedural language and the logic-based one [15]. A more radical suggestion proposed is to abandon the minimal-model and least-fixpoint semantics of programs in favor of an operational semantics based on the concept of inflationary fixpoint <ref> [14] </ref>. <p> The approach proposed in this paper combines the advantages of inflationary fixpoint and those of declarative logic. In fact, XY-stratified Datalog programs always compute in polynomial time and every problem of polynomial data complexity can be expressed using XY-stratified programs (assuming ordered domains <ref> [14] </ref> or using choice). Also, equivalence-preserving compilation methods, such as the magic-set method, remain applicable. On the other hand, the formal logic-based semantics enhances the uses of the language as a formal methods tools|as demonstrated e.g., by its recent use in formalizing updates and rules in active databases [25].
Reference: [15] <author> Phipps, G., M.A., Derr and K. A. Ross, </author> <title> "Glue-Nail: a Deductive Database System," </title> <booktitle> Proc. 1991 ACM-SIGMOD Conference on Management of Data, </booktitle> <pages> pp. </pages> <month> 308-317 </month> <year> (1991). </year>
Reference-contexts: This concept is significant since it removes several of the limitations and problems of Prolog's negation-by-failure, and it is conducive to efficient implementation, as demonstrated by systems such as Glue-Nail, LDL and CORAL <ref> [15, 22, 3] </ref>. <p> An obvious remedy is that of escaping to a procedural language for operations that cannot be performed efficiently in a logic-based language. In particular, Nail-Glue provides a procedural shell that minimizes the "impedance-mismatch" problem between the procedural language and the logic-based one <ref> [15] </ref>. A more radical suggestion proposed is to abandon the minimal-model and least-fixpoint semantics of programs in favor of an operational semantics based on the concept of inflationary fixpoint [14].
Reference: [16] <author> T. Przymusinski. </author> <title> On the declarative and procedural semantics of stratified deductive databases. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216. </pages> <address> Morgan-Kaufman, Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction The area of non-monotonic reasoning has benefited significantly from research in deductive databases, as demonstrated by the introduction of the concept of stratified negation and stratified set aggregates <ref> [16] </ref>. This concept is significant since it removes several of the limitations and problems of Prolog's negation-by-failure, and it is conducive to efficient implementation, as demonstrated by systems such as Glue-Nail, LDL and CORAL [15, 22, 3]. <p> Therefore, during the last five years, a substantial research effort has been devoted to solving the non-stratification issue. This endeavor has produced significant progress on the theoretical front, with the introduction of concepts such as locally stratified programs <ref> [16] </ref>, well-founded models [12], and stable models [7], but it has not yet begotten a solution that is both general and efficient. <p> We assume our reader to be familiar with the basic concepts pertaining to Datalog and logic rules, including the concept of locally stratified programs and the iterated fixpoint procedure to compute the perfect model of these programs <ref> [16, 18] </ref>. <p> Furthermore, this type of program can be implemented efficiently using a modified fixpoint computation. It is well-known that the perfect model of such a program is characterized by a transfinite computation called iterated fixpoint <ref> [16] </ref>. This proceeds as follows: 1 In this paper we are using function symbols (interpreted and non-interpreted) to express more realistic applications. However, function symbols are not required for a formal treatment: an ordered domain of adequate size and a successor relationship is all it is needed.
Reference: [17] <author> A. Przymusinska and T. Przymusinski. </author> <title> Weakly Perfect Model Semantics for Logic Programs. </title> <booktitle> In Proceedings of the Fifth Intern. Conference on Logic Programming, </booktitle> <pages> pages 1106-1122, </pages> <year> 1988. </year>
Reference: [18] <author> S. A. Naqvi, S. </author> <title> Tsur "A Logical Language for Data and Knowledge Bases", </title> <editor> W. H. </editor> <publisher> Freeman, </publisher> <year> 1989. </year>
Reference-contexts: We assume our reader to be familiar with the basic concepts pertaining to Datalog and logic rules, including the concept of locally stratified programs and the iterated fixpoint procedure to compute the perfect model of these programs <ref> [16, 18] </ref>. <p> Therefore, if p 0 is the k-th predicate name in the primed sorting, let T k denote the immediate consequence operator <ref> [13, 18] </ref> for the recursive rules in Q defining p. The composite consequence operator Q , will be defined as follows: Q (I) = T n (T n1 :::(T 1 (I)):::)) where I denotes subset of Q's Herbrand Base B Q , and n 1.
Reference: [19] <author> K.A. Ross, and Y. Sagiv. </author> <title> Monotonic Aggregation in Deductive Databases. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 127-138, </pages> <year> 1992. </year>
Reference-contexts: the definition of min is single (min; X; X): multi (min; Y1; Z1; Z) if (Y1 &lt; Z1 then Z = Y1 else Z = Z1): Therefore, we now need to provide a formal semantics for such extensible aggregates: whereas previous approaches have focused on a fixed set of primitives <ref> [10, 19, 13] </ref>. Here we propose a semantics that is simple, general and conducive to efficient implementation, as demonstrated by the LDL++ system [2]. <p> Choice is formally defined using negation in [8], and set aggregates were defined in this paper using choice and negation. This latter definition solves several problems left open by previous approaches <ref> [10, 19, 13] </ref>.
Reference: [20] <author> K.A. Ross, </author> <title> Modular Stratification and Magic Sets for Datalog Programs, </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 160-171, </pages> <year> 1990. </year>
Reference-contexts: Furthermore, no simple syntactic check exists for deciding whether a program has a well-founded model or a stable model; when such models exist their computation can be very expensive. Notions such as modularly stratified programs, represent a first step toward efficient execution <ref> [20] </ref> but leave other issues unresolved|such as compile-time decidability, and uniform treatment of negation and set aggregates. In this paper, we take a different approach| the synthesis of our experience with concrete LDL applications [23], and classical optimization problems [5, 6].
Reference: [21] <author> D. Sacca and C. Zaniolo. </author> <title> Stable models and non-determinism in logic programs with negation. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 205-217, </pages> <year> 1990. </year>
Reference-contexts: In LDL, this very powerful construct was disallowed in recursion, inasmuch as the functional-dependency based semantics proposed in [11] suffers from technical problems such as a lack of justifiability property and its unsuitability to efficient implementation due to its static nature <ref> [21] </ref>. These problems were solved by using, instead, a semantics based on the use of negation and stable models [8]. <p> (St; Ad): chosen (St; Ad) major (St; Area); faculty (Ad; Area); :diffChoice (St; Ad): diffChoice (St; Ad) chosen (St; Ad ); Ad 6= Ad : Programs so rewritten always have one or more stable model, and in each such a model the chosen atoms obey the FD: St ! Ad <ref> [21] </ref>. The new semantics agrees with the original semantics for non-recursive programs, but solves the problems of the old semantics in programs where choice occurs in a recursive predicate.
Reference: [22] <author> Ramakrishan, R., Srivastava, D. and Sudarshan, S., </author> <title> "CORAL: A Deductive Database Programming Language," </title> <booktitle> Proc. VLDB`92 Int. Conf, </booktitle> <pages> pp. 238-250, </pages> <year> 1992. </year>
Reference-contexts: This concept is significant since it removes several of the limitations and problems of Prolog's negation-by-failure, and it is conducive to efficient implementation, as demonstrated by systems such as Glue-Nail, LDL and CORAL <ref> [15, 22, 3] </ref>.
Reference: [23] <author> Tsur S., </author> <title> `Deductive Databases in Action,' </title> <booktitle> Proc. 10th, ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pp. 205-218, </pages> <year> 1990. </year>
Reference-contexts: This concept is significant since it removes several of the limitations and problems of Prolog's negation-by-failure, and it is conducive to efficient implementation, as demonstrated by systems such as Glue-Nail, LDL and CORAL [15, 22, 3]. However, as experience was gained with real-life applications <ref> [23] </ref>, it became clear that stratification is too restrictive and there remain many important applications where negation and set aggregates are needed: such applications, range from processing Bill of Materials to finding the shortest path in a graph [5, 6]. <p> Notions such as modularly stratified programs, represent a first step toward efficient execution [20] but leave other issues unresolved|such as compile-time decidability, and uniform treatment of negation and set aggregates. In this paper, we take a different approach| the synthesis of our experience with concrete LDL applications <ref> [23] </ref>, and classical optimization problems [5, 6]. We focus on syntactically decidable subclasses of non-monotonic recursive programs which capture the expressive power of inflationary fixpoint semantics [14].
Reference: [24] <author> Zaniolo, C., </author> <title> Intelligent Databases: Old Challenges and New Opportunities, </title> <journal> Journal of Intelligent Information Systems, </journal> <volume> 1, </volume> <month> 271-292 </month> <year> (1992). </year>
Reference-contexts: This endeavor has produced significant progress on the theoretical front, with the introduction of concepts such as locally stratified programs [16], well-founded models [12], and stable models [7], but it has not yet begotten a solution that is both general and efficient. Indeed our experience with deductive database applications <ref> [24] </ref>, suggests that a practical solution must satisfy three difficult requirements, inasmuch as it must 1 * have a formal logic-based semantics * have a simple and intuitive constructive semantics * be amenable to efficient implementation.
Reference: [25] <author> Zaniolo, C., </author> <title> A Unified Semantics for Deductive Databases and Active Databases, Procs. </title> <booktitle> Workshop on Rules in Database Systems, </booktitle> <address> Edinburgh, U.K., </address> <year> 1993. </year>
Reference-contexts: Also, equivalence-preserving compilation methods, such as the magic-set method, remain applicable. On the other hand, the formal logic-based semantics enhances the uses of the language as a formal methods tools|as demonstrated e.g., by its recent use in formalizing updates and rules in active databases <ref> [25] </ref>. In terms of technology evolution, it is interesting to underscore the similarities and differences between LDL and LDL++. The basic non-monotonic constructs (i.e., negation, conditionals, aggregates and choice) have remained the same and there is upward compatibility from the older system to the new system.
References-found: 25

