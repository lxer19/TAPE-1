URL: http://www.cs.uni-bonn.de/~idea/PROP/IDEA_PROPEval.ps.gz
Refering-URL: http://www.cs.uni-bonn.de/~idea/PROP/publications.html
Root-URL: http://cs.uni-bonn.de
Title: Intelligent Database Environment for Advanced Applications IDEA Propagation Rule Compiler: Evaluation  
Author: Rainer Manthey 
Note: ESPRIT Project 6333 Page 1  
Pubnum: 23.3.1997 IDEA.DE.22.O.009  
Abstract-found: 0
Intro-found: 1
Reference: 1. <editor> A term is either (a) a variable, </editor> <title> (b) a constant, or (c) an attribute term of the form X.(c.a) where X is a variable, c a class name and a an attribute name. </title>
Reference: 2. <editor> An atomic formula is either (a) a class formula c(X), </editor> <title> (b) a membership formula X in c, (c) a membership formula t in X.(c.a), (d) an equality formula X.(c.a)=t, or (e) a constraint formula c.cs(X) where X is a variable, c a class name, a an attribute name, cs a constraint name, and t is either a variable or a constant. </title>
Reference: 3. <editor> A literal is an atomic formula A or a negated atomic formula not A. </editor> <title> (Note that not c(X) is not allowed.) </title>
Reference: 4. <institution> A complex formula is a conjunction of literals L 1 ; : : : ; L n with n 0. </institution>

Reference: 1. <author> Let c be an extensional class of S. </author> <title> Then for each direct extensional subclass c 0 of c, the rule c(X) c 0 (X) ESPRIT Project 6333 Page 11 Intelligent Database Environment for Advanced Applications IDEA </title>
Reference: 2. <author> Let c be a derived class of S. </author> <title> Then each population rule defining c is in E S </title> . 
Reference: 3. <editor> Let c be an extensional class of S and a an extensional attribute of c. </editor> <title> Then for each direct extensional subclass c 0 of c, the rule Self.(c.a)=X c 0 (Self), Self.(c 0 .a)=X is in E S </title> . 
Reference: 4. <editor> Let c be a derived class of S and a an inherited extensional attribute of c. </editor> <title> Then for the direct superclass c 0 of c from which c inherits the attribute a, the rule Self.(c.a)=X Self in c, c 0 (Self), Self.(c 0 .a)=X is in E S </title> . 

Reference: 6. <author> Let c be a class of S and cs a targeted constraint of c. </author> <title> Then for each constraint rule c.cs(Self) W , the rule c.cs(Self) c(Self), not Self in c 1 , : : : , not Self in c n , W ESPRIT Project 6333 Page 12 Intelligent Database Environment for Advanced Applications IDEA is in E S where c 1 , . . . , c n are the direct subclasses of c. In addition, for each direct subclass c 0 of c, the rule c.cs(Self) c 0 (Self), c 0 .cs(Self) is in E S </title> . 

Reference: 1. <editor> For each object class c in S, </editor> <title> the delta classes i_c and r_c defined by define object class i_c attributes object : c end define object class r_c attributes object : c end are in C S </title> . 
Reference: 2. <editor> For each attribute a of an object class c, </editor> <title> the delta class m_c_a defined by define object class m_c_a attributes object : c end is in C S </title> . 
Reference: 3. <author> For each constraint cs of an object class c, </author> <title> the delta class i_c_cs defined by define object class i_c_cs attributes object : c end is in C S </title> . 

Reference: 1. <institution> Let A be an atomic formula of the form c(X) or X in c. Then A + :j i_c(i c(X),(object:X)) A :j r_c(r c(X),(object:X)) </institution>
Reference: 2. <institution> Let A be an atomic formula of the form t in X.(c.a) or X.(c.a)=t. Then A + :j m_c_a(m c a(X),(object:X)) A :j A </institution> + 
Reference: 3. <institution> Let A be a constraint formula of the form c.cs(X). Then A + :j i_c_cs(i c cs(X),(object:X)) A :j </institution> ? 

Reference: 1. <institution> For each deductive rule (A W ) 2 E S and each L 2 W , the deductive propagation rules A + L + , new(W ), old(not A) </institution>
References-found: 16

