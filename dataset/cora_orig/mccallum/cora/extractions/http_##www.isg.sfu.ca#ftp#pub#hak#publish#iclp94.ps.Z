URL: http://www.isg.sfu.ca/ftp/pub/hak/publish/iclp94.ps.Z
Refering-URL: http://www.isg.sfu.ca/life/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: marcel@cwi.nl  deby@cs.utwente.nl  hak@cs.sfu.ca  
Title: A Database Interface for Complex Objects to make a confused heap of incoherent parts but
Author: Marcel Holsheimer Rolf A. de By Hassan At-Kaci EPHRAIM CHAMBERS, Cyclopaedia 
Note: The difficulty lay in the form and economy of it, so to dispose such a multitude of materials as not  Work done at University of Twente. Work done at Digital's Paris Research Laboratory.  
Address: Postbus 4079 1009 AB Amsterdam The Netherlands  P.O. Box 217 7500 AE Enschede The Netherlands  V5A 1S6, Canada  
Affiliation: Centrum voor Wiskunde en Informatica (CWI)  Computer Science Department University of Twente  School of Computing Science Simon Fraser University Burnaby, British Columbia  
Abstract: We describe a formal design for a logical query language using -terms as data structures to interact effectively and efficiently with a relational database. The structure of -terms provides an adequate representation for so-called complex objects. They generalize conventional terms used in logic programming: they are sorted attributed structures, ordered thanks to a subsort ordering. Unification of -terms is an effective means for integrating multiple inheritance and partial information into a deduction process. We define a compact database representation for -terms, representing part of the subsorting relation in the database as well. We describe a retrieval algorithm based on an abstract interpretation of the -term unification process and prove its formal correctness. This algorithm is efficient in that it incrementally retrieves only additional facts that are actually needed by a query, and never retrieves the same fact twice. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Hassan At-Kaci. </author> <title> An algebraic semantics approach to the effective resolution of type equations. </title> <booktitle> Theoretical Computer Science, </booktitle> <month> 45:293--351 </month> <year> (1986). </year>
Reference-contexts: This resulted in logical query languages like LDL [14] and NAIL! [13]. So-called complex objects have recently been studied for use in database systems [7, 8]. Much of what has been proposed in those studies is derived from earlier work extending first-order terms to -terms <ref> [1] </ref>. The latter notion has had a more direct application in programming language design [4, 2, 6] than in database systems. <p> Note that this is natural since they are both least elements. However, the empty set is also the least element of coc ( ), and hence we can identify all three: ? = f?g = . The following is a particular case of a more general result in <ref> [1] </ref>. Theorem 1 The poset hcoc ( ); i is a lattice. 4 Proof Greatest lower bounds are constructed as follows.
Reference: 2. <author> Hassan At-Kaci. </author> <title> An introduction to LIFE---programming with logic, inheritance, functions, and equations. </title> <editor> In Dale Miller, editor, </editor> <booktitle> Proceedings of the International Symposium on Logic Programming (Vancouver, </booktitle> <address> BC), pages 52--68, Cambridge, MA (October 1993). </address> <publisher> MIT Press. </publisher>
Reference-contexts: So-called complex objects have recently been studied for use in database systems [7, 8]. Much of what has been proposed in those studies is derived from earlier work extending first-order terms to -terms [1]. The latter notion has had a more direct application in programming language design <ref> [4, 2, 6] </ref> than in database systems. <p> We propose a formal design for an effective coupling of such a language with a relational database. For the purpose of our presentation and experimentation, we use the specific language LIFE <ref> [2] </ref>, but this implies no loss of generality. <p> particular background is required to understand the technical contents of this paper other than elementary discrete algebra, shreds of logic programming, and basic notions of relational and deductive databases. 2 The facts of LIFE LIFE (Logic, Inheritance, Functions, Equations) is a logic programming language extending Prolog terms as described in <ref> [2, 4, 6] </ref>. The user can specify inclusion relationships between functor symbols, thus enabling the direct representation and use of taxonomic information. Thus, functors are called sorts and no longer differentiated from values.
Reference: 3. <author> Hassan At-Kaci, Bruno Dumant, Richard Meyer, and Peter Van Roy. </author> <title> The Wild LIFE handbook. </title> <type> PRL Research Report (forthcoming), </type> <institution> Digital Equipment Corporation, Paris Research Laboratory, </institution> <address> Rueil-Malmaison, France (1994). </address>
Reference-contexts: Hence, the retrieval algorithm holds for languages using Prolog terms as objects as well. Part of the system described in this paper has been implemented: the LIFE -WISDOM system (LIFE With Inheritance Supported Data Object Management) implements a database interface for an implementation of LIFE called Wild LIFE <ref> [3] </ref>, to an ORACLE relational database [12]. The current system implements both database retrieval and updates, but only for single inheritance and facts consisting of least sorts. As for the future, we want to extend this approach to goals with variables.
Reference: 4. <author> Hassan At-Kaci and Roger Nasr. </author> <title> LOGIN: A logic programming language with built-in inheritance. </title> <journal> Journal of Logic Programming, </journal> <month> 3:185--215 </month> <year> (1986). </year>
Reference-contexts: So-called complex objects have recently been studied for use in database systems [7, 8]. Much of what has been proposed in those studies is derived from earlier work extending first-order terms to -terms [1]. The latter notion has had a more direct application in programming language design <ref> [4, 2, 6] </ref> than in database systems. <p> particular background is required to understand the technical contents of this paper other than elementary discrete algebra, shreds of logic programming, and basic notions of relational and deductive databases. 2 The facts of LIFE LIFE (Logic, Inheritance, Functions, Equations) is a logic programming language extending Prolog terms as described in <ref> [2, 4, 6] </ref>. The user can specify inclusion relationships between functor symbols, thus enabling the direct representation and use of taxonomic information. Thus, functors are called sorts and no longer differentiated from values.
Reference: 5. <author> Hassan At-Kaci, Roger Nasr, and Jungyun Seo. </author> <title> Implementing a knowledge-based library information system with typed Horn logic. </title> <booktitle> Information Processing & Management, </booktitle> <month> 26(2):249--268 </month> <year> (1990). </year>
Reference-contexts: Still, the functionality and naturalness of deductive queries over -terms is a strong motivation for providing a logic programming language using -terms with an effective means to access large volumes of data and knowledge stored in a database (see <ref> [5] </ref> for a convincing example). We propose a formal design for an effective coupling of such a language with a relational database. For the purpose of our presentation and experimentation, we use the specific language LIFE [2], but this implies no loss of generality.
Reference: 6. <author> Hassan At-Kaci and Andreas Podelski. </author> <title> Towards a meaning of LIFE. </title> <journal> Journal of Logic Programming, </journal> <note> 16(3-4):195--234 (July-August 1993). </note>
Reference-contexts: So-called complex objects have recently been studied for use in database systems [7, 8]. Much of what has been proposed in those studies is derived from earlier work extending first-order terms to -terms [1]. The latter notion has had a more direct application in programming language design <ref> [4, 2, 6] </ref> than in database systems. <p> particular background is required to understand the technical contents of this paper other than elementary discrete algebra, shreds of logic programming, and basic notions of relational and deductive databases. 2 The facts of LIFE LIFE (Logic, Inheritance, Functions, Equations) is a logic programming language extending Prolog terms as described in <ref> [2, 4, 6] </ref>. The user can specify inclusion relationships between functor symbols, thus enabling the direct representation and use of taxonomic information. Thus, functors are called sorts and no longer differentiated from values.
Reference: 7. <author> Francois Bancilhon and Setrag Khoshafian. </author> <title> A calculus for complex objects. </title> <journal> Journal of Computer and System Sciences, </journal> <month> 38(2):326--340 (April </month> <year> 1989). </year>
Reference-contexts: In the database community, it was felt that the logic programming paradigm offers interesting opportunities as a database query language. This resulted in logical query languages like LDL [14] and NAIL! [13]. So-called complex objects have recently been studied for use in database systems <ref> [7, 8] </ref>. Much of what has been proposed in those studies is derived from earlier work extending first-order terms to -terms [1]. The latter notion has had a more direct application in programming language design [4, 2, 6] than in database systems. <p> Indeed, although we formulate it using -terms, our design is directly applicable to any logical query language with complex objects represented as Prolog terms or as data structures a la <ref> [7, 8] </ref>, since all these models turn out to be special cases of -terms. We present the theoretical view of our proposed database support of that language and discuss the results. Our theoretical design was put into practice as the basis of an experimental implementation [12].
Reference: 8. <author> O. Peter Buneman, Susan D. Davidson, and Aaron Watters. </author> <title> A semantics for complex objects and approximate answers. </title> <journal> Journal of Computer and System Sciences, </journal> <month> 43(1):170--218 (August </month> <year> 1991). </year>
Reference-contexts: In the database community, it was felt that the logic programming paradigm offers interesting opportunities as a database query language. This resulted in logical query languages like LDL [14] and NAIL! [13]. So-called complex objects have recently been studied for use in database systems <ref> [7, 8] </ref>. Much of what has been proposed in those studies is derived from earlier work extending first-order terms to -terms [1]. The latter notion has had a more direct application in programming language design [4, 2, 6] than in database systems. <p> Indeed, although we formulate it using -terms, our design is directly applicable to any logical query language with complex objects represented as Prolog terms or as data structures a la <ref> [7, 8] </ref>, since all these models turn out to be special cases of -terms. We present the theoretical view of our proposed database support of that language and discuss the results. Our theoretical design was put into practice as the basis of an experimental implementation [12].
Reference: 9. <author> Stefano Ceri, Georg Gottlob, and Letizia Tanca. </author> <title> Logic Programming and Databases. </title> <publisher> Springer Verlag, </publisher> <address> Berlin, Germany (1990). </address>
Reference-contexts: The interest from a logic programming perspective came when the need was felt for manipulating large sets of facts. Usually Prolog was coupled with a relational database. In <ref> [9] </ref>, Ceri et al. provide an excellent overview of work in this area. In the database community, it was felt that the logic programming paradigm offers interesting opportunities as a database query language. This resulted in logical query languages like LDL [14] and NAIL! [13].
Reference: 10. <author> Stefano Ceri, Georg Gottlob, and Gio Wiederhold. </author> <title> Interfacing relational databases and Prolog efficiently. </title> <editor> In Larry Kerschberg, editor, </editor> <booktitle> Proceedings of the 2nd International Conference on Expert Database Systems, pages 141--153, </booktitle> <address> Menlo Park, CA (1987). Benjamin-Cummings. </address>
Reference-contexts: This is also known as the caching of queries, as described by Ceri et al. in <ref> [10] </ref>. However, storing all these candidates is expensive, and therefore we will shortly mention a few optimizations. <p> This occurs when the current query is subsumed by a previous query, as described in <ref> [10] </ref>. The subsumption of queries is defined by the subsort relation on candidates. <p> The loading algorithm is quite efficient in that it loads only objects actually needed by the LIFE system, and never loads the same object twice, thus improving results in <ref> [10] </ref>. In addition, our design also improves on previous work by providing for free the ability, intrinsic to -terms, to store and query partial information.
Reference: 11. <author> Patrick Cousot and Radhia Cousot. </author> <title> Abstract interpretation and application to logic programs. </title> <journal> Journal of Logic Pogramming, </journal> <month> 13(2-3):103--179 </month> <year> (1992). </year>
Reference-contexts: So, we need another technique to compute Q [g], independent of the contents of Q. We use an abstract interpretation <ref> [11] </ref> of the inference process, where we use qualifiers instead of facts. In this abstraction, unification of facts in Q with goal g is an operation on the qualifier and the goal, resulting in a term---called the candidate---which approximates the subset of Q of all facts unifiable with g.
Reference: 12. <author> Marcel Holsheimer. LIFE--WISDOM, </author> <title> a database interface for the LIFE system. </title> <type> Master's thesis, </type> <institution> Computer Science, University of Twente, Enschede, </institution> <address> The Netherlands (September 1992). </address>
Reference-contexts: We present the theoretical view of our proposed database support of that language and discuss the results. Our theoretical design was put into practice as the basis of an experimental implementation <ref> [12] </ref>. Although our experiment may be categorized as providing database support to a logic programming language, it goes beyond previous research in that it considers a language with sorts and attributed terms, which can be arbitrarily nested, and provide multiple inheritance. <p> Part of the system described in this paper has been implemented: the LIFE -WISDOM system (LIFE With Inheritance Supported Data Object Management) implements a database interface for an implementation of LIFE called Wild LIFE [3], to an ORACLE relational database <ref> [12] </ref>. The current system implements both database retrieval and updates, but only for single inheritance and facts consisting of least sorts. As for the future, we want to extend this approach to goals with variables.
Reference: 13. <author> Katherine Morris, Jeffrey D. Ullman, and Allen Van Gelder. </author> <title> Design overview of the Nail! system. </title> <editor> In Ehud Shapiro, editor, </editor> <booktitle> Proceedings of the 3rd International Conference on Logic Programming, pages 544--568, </booktitle> <address> Berlin, Germany (1986). </address> <publisher> LNCS 225, Springer-Verlag. </publisher>
Reference-contexts: In [9], Ceri et al. provide an excellent overview of work in this area. In the database community, it was felt that the logic programming paradigm offers interesting opportunities as a database query language. This resulted in logical query languages like LDL [14] and NAIL! <ref> [13] </ref>. So-called complex objects have recently been studied for use in database systems [7, 8]. Much of what has been proposed in those studies is derived from earlier work extending first-order terms to -terms [1].
Reference: 14. <author> Shamim Naqvi and Shalom Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD (1989). </address>
Reference-contexts: In [9], Ceri et al. provide an excellent overview of work in this area. In the database community, it was felt that the logic programming paradigm offers interesting opportunities as a database query language. This resulted in logical query languages like LDL <ref> [14] </ref> and NAIL! [13]. So-called complex objects have recently been studied for use in database systems [7, 8]. Much of what has been proposed in those studies is derived from earlier work extending first-order terms to -terms [1].
Reference: 15. <author> Yannis Vassiliou, James Clifford, and Matthias Jarke. </author> <title> How does an expert system get its data? In Proceedings of the International Conference on Very Large Databases, </title> <note> pages 70--72 (1983). Extended abstract. </note>
Reference-contexts: In Section 3, we propose to group facts into what we call qualified segments, such that the subsort relationships involving symbols in these facts are implicitly represented. We also compress segments before storage in the database. Secondly, for the retrieval of facts, we use a tight coupling <ref> [15, 16] </ref>, where facts are loaded when needed by the LIFE system. In Section 4, we describe an abstraction of the unification process, where qualified segments in the database are approximated by a set of generalizations, called qualifier.
Reference: 16. <author> Yannis Vassiliou and Matthias Jarke. </author> <title> Databases and expert systems: Opportunities and architectures for integration. In New Applications of Databases, </title> <address> pages 185--201, London, UK (1984). </address> <publisher> Academic Press. </publisher>
Reference-contexts: In Section 3, we propose to group facts into what we call qualified segments, such that the subsort relationships involving symbols in these facts are implicitly represented. We also compress segments before storage in the database. Secondly, for the retrieval of facts, we use a tight coupling <ref> [15, 16] </ref>, where facts are loaded when needed by the LIFE system. In Section 4, we describe an abstraction of the unification process, where qualified segments in the database are approximated by a set of generalizations, called qualifier.
References-found: 16

