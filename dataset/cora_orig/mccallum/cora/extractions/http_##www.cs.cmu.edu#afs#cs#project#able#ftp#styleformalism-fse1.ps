URL: http://www.cs.cmu.edu/afs/cs/project/able/ftp/styleformalism-fse1.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs/project/able/www/paper_abstracts/styleformalism-fse1.html
Root-URL: 
Title: Using Style to Understand Descriptions of Software Architecture  
Author: Gregory Abowd Robert Allen David Garlan 
Address: Pittsburgh, PA 15213  
Affiliation: Computer Science Department Carnegie Mellon University  
Abstract: The software architecture of most systems is described informally and diagrammatically. In order for these descriptions to be meaningful at all, figures are understood by interpreting the boxes and lines in specific, conventionalized ways[5]. The imprecision of these interpretations has a number of limitations. In this paper we consider these conventionalized interpretations as architectural styles and provide a formal framework for their uniform definition. In addition to providing a template for precisely defining new architectural styles, this framework allows for the proof that the notational constraints on a style are sufficient to guarantee the meanings of all described systems and provides a unified semantic base through which different stylistic interpretations can be compared. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Allen, R., and Garlan, D. </author> <title> A formal approach to software architectures. </title> <note> In Proceedings of IFIP'92 (September 1992), </note> <editor> J. van Leeuwen, Ed., </editor> <publisher> Elsevier Science Publishers B.V. </publisher>
Reference-contexts: In general, this is perhaps the hardest part of the process, since to do this properly we must come to grips with the intuition behind the use of the style. In the case of PF, an appropriate formal description of the semantic domain 3 already exists <ref> [1, 2] </ref>. Here we will use only those aspects of the model that are necessary to illustrate the basic ideas. The PF style interprets components as filters, which are typed stream transducers.
Reference: [2] <author> Allen, R., and Garlan, D. </author> <title> Towards formalized software architectures. </title> <type> Tech. Rep. </type> <institution> CMU-CS-92-163, Carnegie Mellon University, School of Computer Science, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: In general, this is perhaps the hardest part of the process, since to do this properly we must come to grips with the intuition behind the use of the style. In the case of PF, an appropriate formal description of the semantic domain 3 already exists <ref> [1, 2] </ref>. Here we will use only those aspects of the model that are necessary to illustrate the basic ideas. The PF style interprets components as filters, which are typed stream transducers. <p> One step in this behavior is either a computation step for one filter or a transmission step for one pipe, all else remaining unchanged. Details of this behavioral specification have been omitted here but can be found in <ref> [2] </ref>. 4.2 Concrete Syntax The second part of a style definition is the creation of a style-specific concrete syntax. While the details of such syntax are important, in this paper we are more concerned with understanding the relationship between these descriptions and their associated meanings. <p> Formally, we represent these languages as subsets of the respective description languages introduced in Section 3. FilterDescriptions : ff COMPDESC PipeDescriptions : ff CONNDESC For concreteness, Figure 1 illustrates the definition of a filter that capitalizes its character input stream using one notation developed for this style <ref> [2] </ref>. 4.3 Meaning Functions The third part of a style description is to define the meaning of the syntactic constructs in terms of the semantic model. <p> For example, Allen and Garlan showed formally that in the pipe and filter style it is semantically meaningful to decompose a component (filter) into a configuration of pipes and filters <ref> [2] </ref>. In their treatment, the decomposition is meaningful when the behavior of the unbound ports of the associated configuration matches the behavior of ports of an equivalent filter.
Reference: [3] <institution> Proceedings of the Workshop on Domain-Specific Software Architectures (Hidden Valley, </institution> <address> PA, </address> <month> July </month> <year> 1990), </year> <institution> Software Engineering Institute. </institution>
Reference-contexts: Third, it makes possible a unified semantic base through which different stylistic interpretations can be compared. These benefits address a real problem for the growing number of industrial research and development efforts that are creating domain-specific architectural styles | or "reference architectures" | for specific product families <ref> [3, 4, 10] </ref>.
Reference: [4] <author> Earl, A. </author> <title> A reference model for computer assisted software engineering environment frameworks. </title> <type> Tech. Rep. </type> <institution> HPL-SEG-TN-90-11, Hewlett Packard Laboratories, Bristol, </institution> <address> England, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Third, it makes possible a unified semantic base through which different stylistic interpretations can be compared. These benefits address a real problem for the growing number of industrial research and development efforts that are creating domain-specific architectural styles | or "reference architectures" | for specific product families <ref> [3, 4, 10] </ref>.
Reference: [5] <author> Freeman, P., and A.I.Wasserman. </author> <title> Tutorial on Software Design Techniques. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1976. </year> <month> 10 </month>
Reference: [6] <author> Garlan, D., and Notkin, D. </author> <title> Formalizing design spaces: Implicit invocation mechanisms. </title> <booktitle> In VDM'91: Formal Software Development Methods (Noordwijk-erhout, </booktitle> <address> The Netherlands, October 1991), </address> <publisher> Springer-Verlag, LNCS 551, </publisher> <pages> pp. 31-44. </pages>
Reference-contexts: Event systems are increasingly important as a flexible tool integration technique, since they allow the implicit invocation of tools when some other tool announces an event <ref> [6, 11] </ref>. For the purposes of this paper we will treat each compo nent in an event system as a collection of methods sharing a state. A component responds to an incoming method by transforming its internal state and announcing some events. <p> FanOut PFGraph connect ~ 2 COMPNAME COMPNAME Garlan and Notkin have used the event system model to investigate the differences between various implementations of an implicit invocation mechanism <ref> [6] </ref>. Their examples concentrate on restrictions to the kinds of events that objects can announce and the form of the event to method binding that a distributor allows.
Reference: [7] <author> Garlan, D., and Scott, C. </author> <title> Adding implicit invocation to traditional programming languages. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Software Engineering (Baltimore, </booktitle> <address> MD, </address> <month> May </month> <year> 1993). </year>
Reference-contexts: ObjectDescriptions : ff COMPDESC DistributorDescriptions : ff CONNDESC For example, Figure 2 illustrates a concrete syntax for the communication description extension that allows an Ada package interface to specify events announced by that package and the method to be invoked when an event is announced by some other package <ref> [7] </ref>. 5.3 Meaning Functions The definition of meaning functions for ES proceeds exactly as for PF. The meaning function for ES components, written M ES Comp , associates the syntactic elements of Component with equivalence classes of objects. Equivalence between objects is denoted by obj .
Reference: [8] <author> Garlan, D., and Shaw, M. </author> <title> An introduction to software architecture. </title> <booktitle> In Advances in Software Engineering and Knowledge Engineering, </booktitle> <address> Volume I (New Jersey, </address> <year> 1993), </year> <editor> V. Ambriola and G. Tortora, Eds., </editor> <publisher> World Scientific Publishing Company. </publisher>
Reference-contexts: At the software architectural level of abstraction, a system is typically described as a collection of interacting components. Components perform the primary computations of the system. Interactions between components include high level communication abstractions such as pipes, procedure calls, message passing, and event broadcast <ref> [8] </ref>. The software architecture of most systems is usually described informally and diagrammatically using boxes to represent components and lines to represent connections between components. In order for these descriptions to be meaningful at all, figures are typically understood by interpreting the boxes and lines in specific, conventionalized ways.
Reference: [9] <author> Luckham, D. C., and Vera, J. </author> <title> Event-based concepts and language for system architecture. </title> <note> Working draft, </note> <month> October </month> <year> 1992. </year>
Reference-contexts: For example, interfaces to components can be described solely in terms of their procedure signatures, and connectors can be restricted to procedure call. Other execution models include tasks with IPC and event-based systems <ref> [9] </ref>. When so constrained, descriptions can be mapped directly to module facilities of a programming language or other executable implementations, and can thereby be given precise meanings. This approach, however, has a number of problems.
Reference: [10] <author> Mettala, E., and Graham, M. H. </author> <title> The domain-specific software architecture program. </title> <type> Tech. Rep. </type> <institution> CMU/SEI-92-SR-9, Carnegie Mellon Software Engineering Institute, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: Third, it makes possible a unified semantic base through which different stylistic interpretations can be compared. These benefits address a real problem for the growing number of industrial research and development efforts that are creating domain-specific architectural styles | or "reference architectures" | for specific product families <ref> [3, 4, 10] </ref>.
Reference: [11] <author> Reiss, S. </author> <title> Connecting tools using message passing in the Field Environment. </title> <booktitle> IEEE Software 7, </booktitle> <month> 4 (July </month> <year> 1990), </year> <pages> 57-66. </pages>
Reference-contexts: Event systems are increasingly important as a flexible tool integration technique, since they allow the implicit invocation of tools when some other tool announces an event <ref> [6, 11] </ref>. For the purposes of this paper we will treat each compo nent in an event system as a collection of methods sharing a state. A component responds to an incoming method by transforming its internal state and announcing some events.
Reference: [12] <author> Spivey, J. </author> <title> The Z Notation: A Reference Manual. </title> <publisher> Pren-tice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Finally, in Section 6 we show how these semantic underpinnings support the analysis and comparison of styles. We use the Z specification language to express the formal model in this paper <ref> [12] </ref>. Appendix A summaries the Z notation that we use in this paper. 2 What's in a Style? In order to provide a precise meaning for architectural descriptions it is important to distinguish the abstract syntactic domain of architectural descriptions from the semantic domain of architectural meanings.
Reference: [13] <author> Sullivan, K. J., and Notkin, D. </author> <title> Reconciling environment integration and software evolution. </title> <journal> ACM Transactions on Software Engineering and Methodology 1, </journal> <month> 3 (July </month> <year> 1992), </year> <pages> 229-268. </pages>
Reference-contexts: change in the system results when either a single object performs one of its pending invoked methods or when an announced event is distributed as method invocations to the relevant objects. 5.2 Concrete Syntax A concrete syntax for events systems can be developed as an extension of regular programming languages <ref> [13] </ref>.
References-found: 13

