URL: ftp://ftp.cm.deakin.edu.au/pub/TR/Computing/TR-C94-29.ps.gz
Refering-URL: http://gollum.cm.deakin.edu.au/techreports.html
Root-URL: 
Email: Email: wanlei@deakin.edu.au  
Title: A Generic Recursive Algorithm for Fault-Tolerant Computing  
Author: Wanlei Zhou 
Keyword: Key Words: Fault-tolerant computing, multiprocessor systems, performance evaluation.  
Note: TR C94/29  
Address: Geelong, VIC 3217, Australia  
Affiliation: School of Computing and Mathematics Deakin University  
Abstract: This paper presents a generic recursive algorithm for fault-tolerant computing. The algorithm uses recursive majority voting to achieve fault tolerance on a multiprocessor system. Both space and time redundancy are employed dynamically in the algorithm. By defining different parameters, the algorithm can be applied to different situations. The correctness and performance analysis of the algorithm are also described. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Agrawal. </author> <title> A novel fault tolerant distributed system architecture. </title> <booktitle> Proceedings of the IEEE International Conference on Computer Design: VLSI in Computers, </booktitle> <pages> pages 760-763, </pages> <year> 1985. </year>
Reference-contexts: The correct result is output as long as there is an agreement of two signatures among all the used CUs and the next iteration always uses one new CU. This is an algorithm proposed by Agrawal <ref> [1] </ref> [2] and improved by Zhou [9]. We name this algorithm as Algorithm A. More variations can be achieved by setting up different initial values of a. In that case, the above generic algorithm will behave differently. For example, let a = 2 (it is the minimum value allowed).
Reference: [2] <author> P. Agrawal. RAFT: </author> <title> A recursive algorithm for fault tolerance. </title> <booktitle> Proceedings of the IEEE International Conference on Parallel Processing, </booktitle> <pages> pages 814-821, </pages> <year> 1985. </year>
Reference-contexts: The correct result is output as long as there is an agreement of two signatures among all the used CUs and the next iteration always uses one new CU. This is an algorithm proposed by Agrawal [1] <ref> [2] </ref> and improved by Zhou [9]. We name this algorithm as Algorithm A. More variations can be achieved by setting up different initial values of a. In that case, the above generic algorithm will behave differently. For example, let a = 2 (it is the minimum value allowed).
Reference: [3] <author> Y. Chen, W. Bucken, and K. </author> <title> Echtle. Efficient algorithms for system diagnosis with both processor and comparator faults. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 4(4) </volume> <pages> 371-381, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: We do not care here how these CUs are interconnected. User jobs are scheduled to CUs, and results and signatures (required by the voting process or comparators <ref> [3] </ref>) are obtained from these CUs. A signature may be obtained by using many techniques, such as data compression [4] from the result. The main requirement for a signature is that it should reflect the different errors in the results. We allow CUs to have Byzantine failures [7]. <p> The LF set collects the faulty-like CUs with 2 respect to job T and can be used for diagnosis <ref> [3] </ref>. For the convenience of describing the algorithm, we use the following function to determine the maximum equal signatures from the CU set V . Its implementation is feasible. void MaxEqual (V, t, q, m) /* where V: Input parameter.
Reference: [4] <author> E. Griffin. </author> <title> System Reliability. </title> <publisher> North Oxford Academic Press, </publisher> <year> 1986. </year>
Reference-contexts: We do not care here how these CUs are interconnected. User jobs are scheduled to CUs, and results and signatures (required by the voting process or comparators [3]) are obtained from these CUs. A signature may be obtained by using many techniques, such as data compression <ref> [4] </ref> from the result. The main requirement for a signature is that it should reflect the different errors in the results. We allow CUs to have Byzantine failures [7]. That is, a CU of the parallel system can exhibit arbitrary and malicious behaviour perhaps involving collusion with other faulty CUs.
Reference: [5] <author> M. Lee and G. Frieder. </author> <title> Massively fault-tolerant celluar array. </title> <booktitle> Proceedings of the 1986 International Conference on Parallel Processing, </booktitle> <pages> pages 343-350, </pages> <year> 1986. </year>
Reference-contexts: With the increased complexity of computing units as well as the increased complexity of software used for such systems, the number of possible ways in which error conditions can occur in a computing unit may increase <ref> [5] </ref>. The system will still work if some of its computing units fail. In this case, we have to ensure that we can still obtain correct result even if there exist faulty CUs in the system.
Reference: [6] <author> M. H. MacDougall. </author> <title> Simulating Computer Systems: Techniques and Tools. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, USA, </address> <year> 1987. </year>
Reference-contexts: At first we describe our assumptions used in the simulation. Then we present the performance metrics and simulation results. Finally, the simulation results are analysed. 7 4.1 Descriptions and Assumptions Our simulation tool is based on MacDougall's smpl <ref> [6] </ref>. Some modifications are made in roder to suite the non-queueing system characteristics of the algorithms. In order to make the simulation models more realistic, jobs entering the system are divided into two classes.
Reference: [7] <author> F. B. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 299-319, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: A signature may be obtained by using many techniques, such as data compression [4] from the result. The main requirement for a signature is that it should reflect the different errors in the results. We allow CUs to have Byzantine failures <ref> [7] </ref>. That is, a CU of the parallel system can exhibit arbitrary and malicious behaviour perhaps involving collusion with other faulty CUs. We ignore the possible failures of the interconnection network.
Reference: [8] <author> N.-F. Tzeng. </author> <title> Reconfiguration and analysis of a fault-tolerant circular butterfly parallel system. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 4(8) </volume> <pages> 855-863, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: One fundamental consideration in designing and using a multiprocessor system is its reliability, and system reliability clearly becomes more important with the ever increasing dependency being placed on such a system. As the number of CUs in a system grows, its reliability tends to drop 1 rapidly <ref> [8] </ref>, unless a proper fault-tolerant technique is incorporated in the system or a proper fault--tolerant algorithm is used in the computing. This paper presents a generic recursive algorithm for fault-tolerant computing on a multiprocessor system. The algorithm uses recursive majority voting to achieve fault tolerance on a multiprocessor system.
Reference: [9] <author> W. Zhou. </author> <title> Fault tolerant computing: An improved recursive algorithm. </title> <booktitle> In Proceedings of the 5th Distributed Memory Computing Conference, </booktitle> <pages> pages 851-856, </pages> <address> South Carolina, USA, </address> <month> April </month> <year> 1990. </year> <month> 12 </month>
Reference-contexts: The correct result is output as long as there is an agreement of two signatures among all the used CUs and the next iteration always uses one new CU. This is an algorithm proposed by Agrawal [1] [2] and improved by Zhou <ref> [9] </ref>. We name this algorithm as Algorithm A. More variations can be achieved by setting up different initial values of a. In that case, the above generic algorithm will behave differently. For example, let a = 2 (it is the minimum value allowed).
References-found: 9

