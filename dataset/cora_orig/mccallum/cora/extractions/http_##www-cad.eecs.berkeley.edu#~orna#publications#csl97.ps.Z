URL: http://www-cad.eecs.berkeley.edu/~orna/publications/csl97.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~orna/pub.html
Root-URL: 
Email: Email: orna@eecs.berkeley.edu  Email: k@research.bell-labs.com  Email: mihalis@research.bell-labs.com  
Title: Existence of Reduction Hierarchies  
Author: Orna Kupferman Robert P. Kurshan Mihalis Yannakakis 
Address: Berkeley, CA 94720-1770, U.S.A.  Address: 700 Mountain Avenue, Murray Hill, NJ 07974, U.S.A.  Address: 700 Mountain Avenue, Murray Hill, NJ 07974, U.S.A.  
Note: L(P 1 L(P 2 L(P n L(T Address:  
Date: July 30, 1997  
Affiliation: UC Berkeley  Bell Laboratories  Bell Laboratories  EECS Department,  
Abstract: In the automata-theoretic approach to verification, we model programs and specifications by automata on infinite words. Correctness of a program with respect to a specification can then be reduced to the language-containment problem. In a concurrent setting, the program is typically a parallel composition of many coordinating processes, and the language-containment problem that corresponds to verification is where P 1 ; P 2 ; : : :; P n are automata that model the underlying coordinating processes, and T is the task they should perform. In 1994, Kurshan suggested the heuristic of Reduction Hierarchies for circumventing the exponential blow-up introduced by conventional methods that solve the problem (y). In the reduction-hierarchy heuristic, we solve the problem (y) by solving a sequence of easier problems, which involve only automata of tractable sizes. Complexity-theoretic conjectures (NP 6= PSPACE) imply that there are settings in which the heuristic cannot circumvent the exponential blow-up. In this paper, we demonstrate the strength of the heuristic, study its properties, characterize settings in which it performs effectively, and suggest a method for searching for reduction hierarchies. In particular, we prove, independently of the NP 6= PSPACE question, that reduction hierarchies of tractable sizes do not always exist. 
Abstract-found: 1
Intro-found: 1
Reference: [Ajt87] <author> M. Ajtai. </author> <title> Recursive construction for 3-regular expanders. </title> <booktitle> In Proceedings of the 28th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 295-304, </pages> <year> 1987. </year>
Reference-contexts: It is well known that such expander graphs exist for degree d = 3 or more (the expansion rate c is a constant that depends on the degree) that satisfy properties 2-4, see eg. <ref> [Ajt87] </ref>. The 9 usual definition of expander graphs does not require Hamiltonicity or an odd number of nodes (properties 1 and 5), but these are easy to achieve by simple modifications. Let the alphabet be R, the set of H's edges.
Reference: [And95] <author> H.R. Andersen. </author> <title> Partial model checking. </title> <booktitle> In Proc. 10th IEEE Symposium on Logic in Computer Science, </booktitle> <address> San Diego, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: This idea, of relaxing the languages of the intermediate automata while keeping their size small, is the heart of the heuristic of reduction hierarchies. In a related work <ref> [And95] </ref>, Andersen suggests the method of partial model checking , which can be viewed as a restricted version of reduction hierarchies. There, one checks that a concurrent system satisfies a -calculus formula by gradually removing components of the system while transforming the formula accordingly, trying to keep it small.
Reference: [BS90] <author> R.B. Boppana and M. Sipser. </author> <title> The complexity of finite functions. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 759-804, </pages> <year> 1990. </year>
Reference-contexts: research in circuit complexity, there is a huge gap between what we suspect to be true regarding the size of the Boolean circuits and formulas that are needed to express NP-complete problems (namely exponential size) and what can be currently proved (essentially, only linear size for circuits, quadratic for formulas) <ref> [BS90] </ref>.
Reference: [CDK93] <author> E. M. Clarke, I. A. Draghicescu, and R. P. Kurshan. </author> <title> A unified approach for showing language containment and equivalence between various types of !-automata. </title> <journal> Information Processing Letters 46, </journal> <pages> pages 301-308, </pages> <year> (1993). </year>
Reference-contexts: Thus, the whole hierarchy is of size polynomial in n. As the containment problem L (v) L (v 1 ) " L (v 2 ) for Streett automata v; v 1 , and v 2 is in NLOGSPACE <ref> [CDK93] </ref> (and therefore also in PTIME), we could solve the emptiness problem by guessing a polynomial hierarchy and checking it in polynomial time.
Reference: [CG87] <author> E.M. Clarke and O. Grumberg. </author> <title> Avoiding the state explosion problem in temporal logic model-checking algorithms. </title> <booktitle> In Proc. 6th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 294-303, </pages> <address> Vancouver, British Columbia, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: Indeed, the language-containment problem (y) is PSPACE-complete already for a fixed-size T [Koz77]. Coping with this state-explosion problem is one of the most important issues in computer-aided verification and is the subject of much active research (cf. <ref> [CG87] </ref>). In [Kur94a], Kurshan suggested the heuristic of Reduction Hierarchies for coping with this problem. Consider the language-containment problem (y).
Reference: [Koz77] <author> D. Kozen. </author> <title> Lower bounds for natural proof systems. </title> <booktitle> In Proc. 18th IEEE Symposium on Foundation of Computer Science, </booktitle> <pages> pages 254-266, </pages> <year> 1977. </year> <month> 13 </month>
Reference-contexts: Such methods are doomed to fail in the worst case, as the size of P is very big (exponential in n). Indeed, the language-containment problem (y) is PSPACE-complete already for a fixed-size T <ref> [Koz77] </ref>. Coping with this state-explosion problem is one of the most important issues in computer-aided verification and is the subject of much active research (cf. [CG87]). In [Kur94a], Kurshan suggested the heuristic of Reduction Hierarchies for coping with this problem. Consider the language-containment problem (y). <p> a reduction hierarchy? We will try to answer these questions, and we start with tree reduction hierarchies. 3 Properties of Tree Reduction Hierarchies As discussed in [Kur94a], since the emptiness problem L (P 1 ) " L (P 2 ) " " L (P n ) = ; is PSPACE-hard <ref> [Koz77] </ref>, polynomial tree reduction hierarchies do not always exist, assuming NP 6= PSPACE. To see this, assume, by way of contradiction, that for any P 1 ; : : :; P n with an empty intersection, we can find a polynomial tree reduction hierarchy. <p> A technical point in the above argument is that in the definition of the reduction hierarchy we required the P i 's to be of constant size, whereas the automata P i in the PSPACE-hardness proof of <ref> [Koz77] </ref> are not of constant size. However, we can show that the PSPACE-hardness holds even for constant size (in fact, 2-state) automata. Consider a tree reduction hierarchy G = hV; Ei for L rooted at t.
Reference: [Kur94a] <author> R. P. Kurshan. </author> <title> The complexity of verification. </title> <booktitle> In Proc. 26th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 365-371, </pages> <address> Montreal, </address> <year> 1994. </year>
Reference-contexts: Indeed, the language-containment problem (y) is PSPACE-complete already for a fixed-size T [Koz77]. Coping with this state-explosion problem is one of the most important issues in computer-aided verification and is the subject of much active research (cf. [CG87]). In <ref> [Kur94a] </ref>, Kurshan suggested the heuristic of Reduction Hierarchies for coping with this problem. Consider the language-containment problem (y). <p> So, reduction hierarchies can be very efficient. Do reduction hierarchy always exist? When are they likely to exist? How can one find a reduction hierarchy? We will try to answer these questions, and we start with tree reduction hierarchies. 3 Properties of Tree Reduction Hierarchies As discussed in <ref> [Kur94a] </ref>, since the emptiness problem L (P 1 ) " L (P 2 ) " " L (P n ) = ; is PSPACE-hard [Koz77], polynomial tree reduction hierarchies do not always exist, assuming NP 6= PSPACE.
Reference: [Kur94b] <author> R.P. Kurshan. </author> <title> Computer Aided Verification of Coordinating Processes. </title> <publisher> Princeton Univ. Press, </publisher> <year> 1994. </year>
Reference-contexts: According to this view, each process corresponds to a language over the alphabet 2 AP and can be associated with an automaton. In the verification tool COSPAN, processes are associated with a particular subclass of deterministic Streett automata <ref> [Kur94b] </ref>. The alphabet of the automata in COSPAN consists of atoms of a Boolean algebra. <p> to check (y) is to construct an automaton P such that L (P ) = L (P 1 ) " L (P 2 ) " " L (P n ) " L (T ) and then check that L (P ) = ;, with complexity which is exponential in n <ref> [Kur94b] </ref>. The motivation for constructing a reduction hierarchy is to reduce the complexity of checking (y) to fi jV j. Clearly, if we succeed in constructing a reduction hierarchy for the problem (y), then (y) indeed holds. <p> Indeed, we do not restrict the problem (y) to automata with a fixed-size alphabet. Recall that in COSPAN, the 6 alphabet of the automata consists of atoms of a Boolean algebra. These atoms correspond to assignments to the program's variables, thus their number grows with n <ref> [Kur94b] </ref>. So, reduction hierarchies can be very efficient.
Reference: [VW94] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 1-37, </pages> <month> November </month> <year> 1994. </year> <month> 14 </month>
Reference-contexts: The language L (T ) consists of all the behaviors allowed to P . For almost all interesting tasks T , we can recognize L (T ) by an automaton. In particular, we can translate linear-time temporal-logic formulas to automata <ref> [VW94] </ref>. Then, P is correct with respect to T iff the behavior of each of the computations of P is allowed, thus L (P ) L (T ).
References-found: 9

