URL: http://www.cs.washington.edu/research/projects/lis/www/papers/postscript/chou-iccad95.ps
Refering-URL: http://www.cs.washington.edu/research/projects/lis/www/papers/
Root-URL: 
Email: fchou,ortega,gaetanog@cs.washington.edu  
Title: Interface Co-Synthesis Techniques for Embedded Systems  
Author: Pai Chou, Ross B. Ortega, Gaetano Borriello 
Address: Box 352350  Seattle, WA 98195-2350  
Affiliation: Department of Computer Science Engineering,  University of Washington,  
Abstract: A key aspect of the synthesis of embedded systems is the automatic integration of system components. This entails the derivation of both the hardware and software interfaces that will bind these elements together and permit them to communicate correctly and efficiently. Without the automatic synthesis of these interfaces, designers are not able to fully simulate and evaluate their systems. Frequently, they are discouraged from exploring the design space of different hardware/software partitions because practical concerns mandate minimizing changes late in the design cycle, thus leading to more costly implementations than necessary. This paper presents a set of techniques that form the basis of a comprehensive solution to the synthesis of hardware/software interfaces. Software drivers and glue logic are generated to connect processors to peripheral devices, hardware co-processors, or communication interfaces while meeting bandwidth and performance requirements. We use as examples a set of devices that communicate over an infrared local communications network (highlighting a video wrist-watch display) to explain our techniques and the need for design space exploration tools for embedded systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Chou, R. Ortega, and G. Borriello. </author> <booktitle> Synthesis of the hardware/software interface in microcontroller-based systems. In Proc. </booktitle> <address> ICCAD, pp.488-495, </address> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: Finally, the algorithm generates the device drivers by binding device ports in the SEQs to the I/O resources of the processors. In the next section, we summarize the port allocation algorithm (described in detail in <ref> [1] </ref>) and present a preprocessing step called port-width partitioning. Memory-mapped I/O and sequencer synthesis are described in sections 4 and 5. 3 Interface Synthesis using I/O Ports The I/O port allocation algorithm assigns processor I/O ports for communication with peripheral devices. Interface synthesis using I/O ports has been described in [1] <p> <ref> [1] </ref>) and present a preprocessing step called port-width partitioning. Memory-mapped I/O and sequencer synthesis are described in sections 4 and 5. 3 Interface Synthesis using I/O Ports The I/O port allocation algorithm assigns processor I/O ports for communication with peripheral devices. Interface synthesis using I/O ports has been described in [1] with an O (n 2 ) greedy sharing heuristic, where n is the number of device ports. The algorithm assumes that oversized device ports, if any, have been partitioned manually. <p> First, it ensures that every device port except the guards can share the memory bus by applying forced sharing <ref> [1] </ref> if necessary. Second, all guarded device ports are assigned bits in the processor's data port or the remaining bits in the ad dress port.
Reference: [2] <author> P. Chou, R. B. Ortega, and G. Borriello. </author> <booktitle> The Chinook Hardware/Software Co-Synthesis System. In Proc. </booktitle> <address> ISSS, </address> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: These ideas have been validated with practical examples used throughout the paper, including several embedded systems that interact over an IR network. The techniques and algorithms presented in this paper are part of the Chinook co-synthesis tool for embedded systems under development at the University of Washing-ton <ref> [2] </ref>. Future work includes development of interfacing techniques that permit sharing of communication resources between processors and interprocessor communication and synchronization mechanisms that will permit exploration of software/software partitions.
Reference: [3] <author> P. Chou, E. A. Walkup, and G. Borriello. </author> <title> Scheduling for Reactive Real-Time Systems. </title> <booktitle> In IEEE Micro, </booktitle> <volume> 14(4) </volume> <pages> 37-47, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: The SEQs can be viewed as a textual representation of the waveforms the processor will generate. SEQs are derived from the timing diagrams for the device's interfaces and are customized to the capabilities of the processor in question <ref> [3] </ref>. SEQs are basic-block primitives. All control constructs such as loops and conditionals are expressed in higher-level device drivers. Another difference between SEQs and drivers is that only SEQs may directly access device ports whereas drivers must access them via calls to SEQs.
Reference: [4] <author> T. Cormen, C. Leiserson, and R. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: A binary encoding technique of the device-select field encodes n devices with dlog ne bits. This technique frees (ndlog ne) bits from one-hot encoding by using a single dlog ne input decoder to implement n address comparators. If the two approaches above fail, then the algorithm attempts Huffman encoding <ref> [4] </ref> of the device-select field. Huffman encoding uniquely identifies each device with a variable number of address bits. It exploits situations where the devices require different numbers of bits in the device-control field. A device requiring more device-control bits is addressed by a shorter device-select pattern, and vice versa.
Reference: [5] <author> R. Ernst, J. Henkel, and T. Benner. </author> <title> Hardware-software cosyn-thesis for microcontrollers. </title> <journal> IEEE Design & Test of Computers, </journal> <volume> 10(4) </volume> <pages> 64-75, </pages> <month> Dec. </month> <year> 1993. </year>
Reference: [6] <author> R. Gupta and G. De Micheli. </author> <title> Hardware-software cosynthesis for digital systems. </title> <journal> Computers and Electrical Engineering, </journal> <volume> 10(3) </volume> <pages> 29-41, </pages> <month> Sept. </month> <year> 1993. </year>
Reference: [7] <author> S. Narayan and D. D. Gajski. </author> <title> Interfacing system components by generation of interface processes. </title> <booktitle> In Proc. 32nd DAC, </booktitle> <month> June </month> <year> 1995. </year>
Reference: [8] <author> M. Srivastava, B. C. Richards, and R. W. Brodersen. </author> <title> System level hardware module generation. </title> <journal> IEEE Transactions on VLSI Systems, </journal> <volume> 3(1), </volume> <month> March </month> <year> 1995. </year>
Reference: [9] <author> J. S. Sun and R. W. Brodersen. </author> <title> Design of system interface modules. </title> <booktitle> In Proc. </booktitle> <address> ICCAD, pp.478-481, </address> <month> Nov. </month> <year> 1992. </year>
Reference: [10] <author> M. Weiser. </author> <title> Some computer science issues in ubiquitous computing. </title> <journal> CACM, </journal> <volume> 36(7) </volume> <pages> 74-84, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: The most common activity in this type of exploration is integration of the components, i.e., generating the interfaces between them. As an example, consider the class of devices that can be used with an infrared local-area network <ref> [10] </ref>. The types of possible devices range from transceivers connected to a workstation or a laptop all the way to simple identification tags for tracking people and objects. Each device must implement the same communication protocol but within very different cost constraints.
References-found: 10

