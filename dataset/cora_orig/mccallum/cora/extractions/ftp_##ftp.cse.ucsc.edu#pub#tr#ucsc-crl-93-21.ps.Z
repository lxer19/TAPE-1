URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-93-21.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Email: max@cse.ucsc.edu  
Title: Debugging Optimized Code Without Being Misled  
Author: Max Copperman 
Address: Santa Cruz, CA 95064  
Affiliation: Board of Studies in Computer and Information Sciences University of California, Santa Cruz  
Date: June 11, 1993  
Pubnum: UCSC-CRL-93-21  
Abstract-found: 0
Intro-found: 1
Reference: [AG93a] <author> A. Adl-Tabatabai, T. Gross, </author> <title> "Evicted Variables and the Interaction of Global Register Allocation and Symbolic Debugging," </title> <booktitle> Proceedings of the POPL`93, The Twentieth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: Although the symbol table formats are general, the information stored in them is usually derived from live range information computed for use by the optimizer. This is not optimal for use by the debugger, for reasons described in Section 26. Adl-Tabatabai and Gross <ref> [AG93a] </ref> show how data-flow analysis can be used to determine optimal variable location range information. Wismuller [BW93] also approaches the problem using data-flow analysis. How this problem interacts with my solution to the next problem is discussed in Section 26. <p> If the dead store into a has been eliminated, the value in the location associated with a may mislead the user. This problem is addressed for local optimizations only (specifically, register promotion combined with local instruction scheduling) by Coutant et al [CMR88], Adl-Tabatabai and Gross <ref> [AG93a] </ref>, and Streepy [Str91] and Brooks et al [BHS92]. <p> The two models can be combined to provide additional debugging capabilities without losing existing capabilities. "Evicted Variables and the Interaction of Global Register Allocation and Symbolic Debugging : : : " Adl-Tabatabai and Gross [AG92], <ref> [AG93a] </ref>, [AG93b] address the data location problem. This problem has been addressed by others [CMR88], [Wan91], [Str91], [BHS92], but typically by providing live-range information to the debugger. <p> If a debugger does not supply the value of a variable outside of its live ranges, there will be points at which the variable is in some storage location but the debugger will not display it to the user. Adl-Tabatabai and Gross [AG92], <ref> [AG93a] </ref>, [AG93b] show how data-flow analysis can be used to determine the residency of variables.
Reference: [AG93b] <author> A. Adl-Tabatabai, T. Gross, </author> <title> "Detection and Recovery of Endangered Variables Caused by Instruction Scheduling," </title> <booktitle> To appear in the Proceedings of the PLDI`93, ACM SIGPLAN/93 Conference on Programming Language Design and Implementation, </booktitle> <address> Albuquerque, New Mexico, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: The two models can be combined to provide additional debugging capabilities without losing existing capabilities. "Evicted Variables and the Interaction of Global Register Allocation and Symbolic Debugging : : : " Adl-Tabatabai and Gross [AG92], [AG93a], <ref> [AG93b] </ref> address the data location problem. This problem has been addressed by others [CMR88], [Wan91], [Str91], [BHS92], but typically by providing live-range information to the debugger. <p> If a debugger does not supply the value of a variable outside of its live ranges, there will be points at which the variable is in some storage location but the debugger will not display it to the user. Adl-Tabatabai and Gross [AG92], [AG93a], <ref> [AG93b] </ref> show how data-flow analysis can be used to determine the residency of variables.
Reference: [AG92] <author> A. Adl-Tabatabai, T. Gross, </author> <title> "The Effects of Register Allocation and Instruction Scheduling of Symbolic Debugging," </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop , Dallas, </booktitle> <address> Texas, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: In Section 15 I present a breakpoint model that does not require such a departure. The two models can be combined to provide additional debugging capabilities without losing existing capabilities. "Evicted Variables and the Interaction of Global Register Allocation and Symbolic Debugging : : : " Adl-Tabatabai and Gross <ref> [AG92] </ref>, [AG93a], [AG93b] address the data location problem. This problem has been addressed by others [CMR88], [Wan91], [Str91], [BHS92], but typically by providing live-range information to the debugger. <p> Currency and Residency 26 Currency and Residency The work on currency determination makes a simplifying assumption that a variable resides in a single location throughout its lifetime. V is resident <ref> [AG92] </ref> at some point P if and only if there is a storage location (which could be a register) that holds V at P , otherwise V is nonresident at P . V must be resident throughout its live ranges (else the compiler is in error). <p> If a debugger does not supply the value of a variable outside of its live ranges, there will be points at which the variable is in some storage location but the debugger will not display it to the user. Adl-Tabatabai and Gross <ref> [AG92] </ref>, [AG93a], [AG93b] show how data-flow analysis can be used to determine the residency of variables.
Reference: [ASU86] <author> A. V. Aho, R. Sethi, J. D. Ullman, </author> <booktitle> "Compilers Principles, Techniques, and Tools," </booktitle> <publisher> Addison-Wesley, </publisher> <address> Menlo Park, CA, </address> <year> 1986. </year>
Reference-contexts: If a flow graph is traversed in the right order, on average 5 iterations are sufficient for convergence for a standard reaching definitions algorithm <ref> [ASU86] </ref>, replacing factors of nm with a factor of 5. While this algorithm differs from a standard reaching definitions algorithm, we expect that some small constant number of iterations will be sufficient for convergence, removing a factor of nm from the running time.
Reference: [AU77] <author> A. V. Aho, J. D. Ullman, </author> <title> "Principles of Compiler Design," </title> <publisher> Addison-Wesley, </publisher> <address> Menlo Park, CA, </address> <year> 1977. </year>
Reference: [Bal69] <author> R. M. Balzer, </author> <title> "EXDAMS EXtendable Debugging and Monitoring System," </title> <booktitle> Proceedings of AFIPS Spring Joint Computer Conference, </booktitle> <volume> Vol 34 pp. </volume> <pages> 125-134, </pages> <year> 1969. </year>
Reference-contexts: At that point, z had the value 3.141 (set at line 370) and y had the value 17; y was set at line 506 to y+bar (w).'. This was called flowback analysis by Balzer <ref> [Bal69] </ref>, and has been investigated by others ([MC91], [Kor88]); reaching sets may be adaptable to this purpose.
Reference: [BHS92] <author> G. Brooks, G. J. Hansen, and S. Simmons, </author> <title> "A New Approach to Debugging Optimized Code," </title> <booktitle> Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, SIGPLAN Notices, </booktitle> <volume> Vol. 27, No. 7, </volume> <pages> pp. 1-11, </pages> <address> San Francisco, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: It is also addressed in some of the more modern symbol table formats. Examples include the symbol table put out by the MIPS compiler for use by dbx and the symbol table put out by the Convex compiler for use by the Convex debugger Cxdb [Str91], <ref> [BHS92] </ref>. 5.3 Breakpoint Location Determination When the user requests a breakpoint at a source line L, the debugger must be able to set the breakpoint at an appropriate address. In the absence of optimization, the line table is sufficient. <p> This problem is addressed is Section 15. It is also addressed by Zellweger [Zel84], Coutant et al [CMR88], Zurawski and Johnson [ZJ90], Streepy [Str91] and Brooks et al <ref> [BHS92] </ref>, and Wismuller [BW93]. Different approaches allow different debugger capabilities. None of the approaches in the literature, including mine, provide a complete solution. 5.4 Execution Context Reporting When the debugger gains control of a halted program, it provides the user with information about where the program halted. <p> Worse, the user may be led to believe that code has been executed when it has not, or vice-versa. Simple code motion is enough to cause the latter problem. Loop transformations can compound the problem. This problem is addressed to some extent by Streepy [Str91] and Brooks et al <ref> [BHS92] </ref>. The user can request more context in the form of a call-stack trace. 4 Two optimizations, inlining and the stack-frame pointer optimization discussed in Part II of this work, can cause a call-stack trace to be inaccurate and misleading. <p> This problem is addressed for local optimizations only (specifically, register promotion combined with local instruction scheduling) by Coutant et al [CMR88], Adl-Tabatabai and Gross [AG93a], and Streepy [Str91] and Brooks et al <ref> [BHS92] </ref>. <p> Subsequently, parallelizing transformations can be performed. Finally, the large storage requirements of single assignment code are reduced by reclaiming names that are not useful for parallelization or debugging. "A New Approach to Debugging Optimized Code : : : " At Convex, Streepy [Str91] and Brooks et al <ref> [BHS92] </ref> break with the by now conventional view that the debugger should hide the effects of optimization. Their view is that the debugger should aid the user in understanding what is actually happening in the presence of aggressive optimization and parallelization. <p> This problem has been addressed by others [CMR88], [Wan91], [Str91], <ref> [BHS92] </ref>, but typically by providing live-range information to the debugger. <p> It is inappropriate to associate every instruction generated from a statement with that statement for the purposes of setting breakpoints, because if the instructions are not contiguous, many breakpoints may be reached for a single statement. In contrast, Streepy [Str91] and Brooks et al <ref> [BHS92] </ref> describe a source-code/breakpoint-location mapping that allows breakpoints to be set at various levels of granularity, including expressions, basic blocks, and subroutines. <p> It is increasingly common for a compiler to provide live-range and variable location information to a debugger [CMR88], [Wan91], [Str91], <ref> [BHS92] </ref>. If a debugger does not supply the value of a variable outside of its live ranges, there will be points at which the variable is in some storage location but the debugger will not display it to the user.
Reference: [BK92] <author> J. Brown, R. Klamann, </author> <title> "The Application of Code Instrumentation Technology in the Los Alamos Debugger", </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop `92, </booktitle> <address> Dallas, Texas, </address> <month> October </month> <year> 1992. </year> <month> October </month> <year> 1992. </year>
Reference-contexts: The debugger can use invisible breakpoints [Zel84] or program patching [CT93], <ref> [BK92] </ref>, [CH91], [Kes90] to collect the information. An invisible breakpoint is a breakpoint at which the debugger halts the executing program, takes some action, and continues execution without ever giving control to the user.
Reference: [Bro91] <author> J. S. Brown, </author> <title> "The Los Alamos Debugger ldb", </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop `91, </booktitle> <address> Albuquerque, New Mexico, </address> <month> November </month> <year> 1991. </year>
Reference: [BW92] <author> T. Bemmerl, R. Wismuller, </author> <title> "Quellcode-Debugging von global optimierten Pro-grammen", </title> <booktitle> GI-ITG Workshop "Parallelrechner und Programmiersprachen", </booktitle> <address> Schloss Dagstuhl, Germany, </address> <month> Feb. </month> <pages> 26-28, </pages> <note> 1992 (in German) </note>
Reference-contexts: This is discussed further in Section 26 and is addressed by Wismuller [BW93]. "Source-Level Debugging of Optimized Programs Using Data Flow Analysis : : : " Wismuller is currently investigating data location, currency determination and expected value recovery (with Bemmerl <ref> [BW92] </ref>, and with Berger [BW93]). His approach is similar 22 6. A Survey of Related Work to my approach to currency determination. The scope of his work is quite ambitious. <p> Note that in general a debugger cannot distinguish situation 2 from situation 4. An approach taken by Bemmerl and Wismuller <ref> [BW92] </ref> is to use a more flexible mapping between source statements and breakpoints. They attempt to map a source statement to a breakpoint location in such a way that the breakpoint is reached if and only if it would be reached in unoptimized code. There is a further problem.
Reference: [BW93] <author> L. Berger, R. Wismuller, </author> <title> "Source-Level Debugging of Optimized Programs Using Data Flow Analysis", </title> <note> unpublished draft from the Department of Computer Science, </note> <institution> Munich Institute of Technology, Germany, </institution> <year> 1993. </year>
Reference-contexts: This problem is addressed is Section 15. It is also addressed by Zellweger [Zel84], Coutant et al [CMR88], Zurawski and Johnson [ZJ90], Streepy [Str91] and Brooks et al [BHS92], and Wismuller <ref> [BW93] </ref>. Different approaches allow different debugger capabilities. None of the approaches in the literature, including mine, provide a complete solution. 5.4 Execution Context Reporting When the debugger gains control of a halted program, it provides the user with information about where the program halted. <p> This is not optimal for use by the debugger, for reasons described in Section 26. Adl-Tabatabai and Gross [AG93a] show how data-flow analysis can be used to determine optimal variable location range information. Wismuller <ref> [BW93] </ref> also approaches the problem using data-flow analysis. How this problem interacts with my solution to the next problem is discussed in Section 26. Data Currency Determination Even if a data object's location is correctly determined, that location may not have the value the user expects. <p> This problem is addressed for local optimizations only (specifically, register promotion combined with local instruction scheduling) by Coutant et al [CMR88], Adl-Tabatabai and Gross [AG93a], and Streepy [Str91] and Brooks et al [BHS92]. It is also addressed for local and global optimization by Hennessy [Hen82], Wismuller and others <ref> [BW93] </ref>, and by Part III of this work. 5.6 Data Modification The user may want to modify a data object's value while in the debugger and continue execution of the program using the modified value to modify the program's behavior. Optimization can defeat the process. Consider: 5. <p> Adl-Tabatabai and Gross show how data-flow analysis can be used to determine the actual availability of a variable. This is discussed further in Section 26 and is addressed by Wismuller <ref> [BW93] </ref>. "Source-Level Debugging of Optimized Programs Using Data Flow Analysis : : : " Wismuller is currently investigating data location, currency determination and expected value recovery (with Bemmerl [BW92], and with Berger [BW93]). His approach is similar 22 6. A Survey of Related Work to my approach to currency determination. <p> This is discussed further in Section 26 and is addressed by Wismuller <ref> [BW93] </ref>. "Source-Level Debugging of Optimized Programs Using Data Flow Analysis : : : " Wismuller is currently investigating data location, currency determination and expected value recovery (with Bemmerl [BW92], and with Berger [BW93]). His approach is similar 22 6. A Survey of Related Work to my approach to currency determination. The scope of his work is quite ambitious. <p> At that point, it would be possible for the debugger to find the nearest ancestors and descendants of N outside of R and provide a list of breakpoints where the user can be given accurate information. Wismuller <ref> [BW93] </ref> is working on a more general breakpoint model. His work may address (or finesse) this problem. 98 22. Design Issues 22 Design Issues The material in this section is an architectural design to guide in the implementation of the presented method of currency determination.
Reference: [CH91] <author> B. Chase, R. Hood, </author> <title> "Debugging with Lightweight Instrumentation", </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop `91, </booktitle> <address> Albuquerque, New Mexico, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: The debugger can use invisible breakpoints [Zel84] or program patching [CT93], [BK92], <ref> [CH91] </ref>, [Kes90] to collect the information. An invisible breakpoint is a breakpoint at which the debugger halts the executing program, takes some action, and continues execution without ever giving control to the user.
Reference: [Coh91] <author> R. Cohn, </author> <title> "Source Level Debugging of Automatically Parallelized Code," </title> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <month> May </month> <year> 1991, </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 26, No. 12, </volume> <pages> pp. </pages> <month> 132-143 December </month> <year> 1991. </year>
Reference-contexts: an interactive debugging session, the region of code that is to be debugged ([FM80], [ZJ90]), and * to have the compiler provide information about the optimizations that it has performed and to have the debugger use that information to provide appropriate behav ior ([WS78], [Hen82], [Zel84], [CMR88], [ZJ90], [Gup90], [PS91], <ref> [Coh91] </ref>, [CM91b], A larger problem is lowering the cost of debugging production quality software. <p> They are always able to provide expected behavior by a combination of compiler-generated information, incremental compilation, and restricting points at which a debugger can take control of a program. "Source Level Debugging of Automatically Parallelized Code" Cohn <ref> [Coh91] </ref> describes a method for providing a sequential view of programs that have been automatically parallelized for distributed memory MIMD machines by transformations that can be decomposed into thread splitting and sequential optimizations.
Reference: [CM93] <author> M. Copperman, C. E. McDowell, </author> <title> "A Further Note on Hennessy's "Symbolic Debugging of Optimized Code", </title> <journal> ACM Transactions on Programming Languages and Systems Vol. </journal> <volume> 15, No. 2, </volume> <pages> pp. 357-365, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: work has appeared twice. "A note on Hennessy's Symbolic Debugging of Optimized Code", by Wall, Srivastava, and Templin [WST85] corrects an error in the algorithm used to determine the currency of variables, using Hennessy's data structures. "A further note on Hennessy's Symbolic Debugging of Optimized Code", by Copperman and McDowell <ref> [CM93] </ref> points out that his technique assumes that after optimization, programs have only one store to a variable within any basic block. This was a reasonable assumption in 1982 but is a restrictive assumption today. 5 This approach, when successful, has subsequently been termed providing expected behavior. 6.
Reference: [CM91b] <author> M. Copperman, C. E. McDowell, </author> <title> "Debugging Optimized Code Without Surprises," </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop , Albuquerque, </booktitle> <address> New Mexico, </address> <month> November </month> <year> 1991. </year> <note> 142 References </note>
Reference-contexts: interactive debugging session, the region of code that is to be debugged ([FM80], [ZJ90]), and * to have the compiler provide information about the optimizations that it has performed and to have the debugger use that information to provide appropriate behav ior ([WS78], [Hen82], [Zel84], [CMR88], [ZJ90], [Gup90], [PS91], [Coh91], <ref> [CM91b] </ref>, A larger problem is lowering the cost of debugging production quality software.
Reference: [Cop92] <author> M. Copperman, </author> <title> "Debugging Optimized Code: Currency Determination with DataFlow," </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop , Dallas, </booktitle> <address> Texas, </address> <month> October </month> <year> 1992. </year>
Reference: [Cop92] <author> M. Copperman, </author> <title> "Debugging Optimized Code Without Being Misled," </title> <type> UCSC Technical Report UCSC-CRL-92-01, </type> <month> January </month> <year> 1992. </year> <note> Submitted for publication to ACM Transactions on Programming Languages and Systems. </note>
Reference: [Cop90] <author> M. Copperman, </author> <title> "Source-Level Debugging of Optimized Code: Detecting Unexpected Data Values," </title> <institution> University of California, Santa Cruz technical report UCSC-CRL-90-23, </institution> <month> May </month> <year> 1990. </year>
Reference: [CT93] <author> M. </author> <type> Copperman, </type> <institution> J. Thomas "Poor Man's Watchpoints," University of California, Santa Cruz technical report UCSC-CRL-93-12, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: The debugger can use invisible breakpoints [Zel84] or program patching <ref> [CT93] </ref>, [BK92], [CH91], [Kes90] to collect the information. An invisible breakpoint is a breakpoint at which the debugger halts the executing program, takes some action, and continues execution without ever giving control to the user.
Reference: [Cor91] <author> Steve Correll, </author> <title> personal communication, </title> <booktitle> Borland International, </booktitle> <address> Scotts Valley, CA, </address> <month> April </month> <year> 1991 </year>
Reference-contexts: However, in some architectures, such as Mips, the stack pointer is not used in this manner, and this approach is taken <ref> [Cor91] </ref>. 44 12.
Reference: [CMR88] <author> D. Coutant, S. Meloy, M. </author> <title> Ruscetta "DOC: a Practical Approach to Source-Level Debugging of Globally Optimized Code," </title> <booktitle> Proceedings of the SIGPLAN `88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 125-134, </pages> <year> 1988. </year>
Reference-contexts: recompile, without optimization, during an interactive debugging session, the region of code that is to be debugged ([FM80], [ZJ90]), and * to have the compiler provide information about the optimizations that it has performed and to have the debugger use that information to provide appropriate behav ior ([WS78], [Hen82], [Zel84], <ref> [CMR88] </ref>, [ZJ90], [Gup90], [PS91], [Coh91], [CM91b], A larger problem is lowering the cost of debugging production quality software. <p> This problem is addressed is Section 15. It is also addressed by Zellweger [Zel84], Coutant et al <ref> [CMR88] </ref>, Zurawski and Johnson [ZJ90], Streepy [Str91] and Brooks et al [BHS92], and Wismuller [BW93]. Different approaches allow different debugger capabilities. <p> symbol table formats, including Microtec Research, Inc.'s format for their Xray debugger [Wan91], the DWARF Debugging Information Format [Sil92], the symbol table put out by a prototype modification of Hewlett Packard's C compiler for the HP9000 series 800 for use by a prototype modification of the debugger for that machine <ref> [CMR88] </ref>, and the symbol table put out by the Convex compiler for use by Cxdb [Str91]. Although the symbol table formats are general, the information stored in them is usually derived from live range information computed for use by the optimizer. <p> If the dead store into a has been eliminated, the value in the location associated with a may mislead the user. This problem is addressed for local optimizations only (specifically, register promotion combined with local instruction scheduling) by Coutant et al <ref> [CMR88] </ref>, Adl-Tabatabai and Gross [AG93a], and Streepy [Str91] and Brooks et al [BHS92]. <p> Zellweger has successfully implemented her algorithms in the Cedar programming environment at Xerox PARC. "DOC: a Practical Approach to Source-Level Debugging of Globally Optimized Code" At Hewlett Packard, Coutant, Meloy, and Ruscetta <ref> [CMR88] </ref> modified a compiler and debugger to produce a prototype called DOC that can debug the optimized code the compiler produces. The debugger was designed to handle global register allocation, induction variable elimination, constant and copy propagation, and delay slot scheduling. <p> To this end, they describe an enriched compiler-debugger interface and a debugger user interface that can visually display the effects of optimization. Their debugger CXdb incorporates capabilities first published in Coutant et al <ref> [CMR88] </ref>, handling induction variable elimination and providing live range and variable location information (although in a different format). From a research perspective, their contribution is a finer granularity in the mapping from source entities to machine code addresses. <p> The two models can be combined to provide additional debugging capabilities without losing existing capabilities. "Evicted Variables and the Interaction of Global Register Allocation and Symbolic Debugging : : : " Adl-Tabatabai and Gross [AG92], [AG93a], [AG93b] address the data location problem. This problem has been addressed by others <ref> [CMR88] </ref>, [Wan91], [Str91], [BHS92], but typically by providing live-range information to the debugger. <p> Only those effects of optimization that affect the validity of the user's inferences need to be reported by the debugger. As noted by Coutant et al <ref> [CMR88] </ref>, much of the optimization performed upon a program is irrelevant to the user. It is only optimization that affects user-visible entities, such as source code variables and statement flow-of-control, that the user needs to be informed about. <p> It is increasingly common for a compiler to provide live-range and variable location information to a debugger <ref> [CMR88] </ref>, [Wan91], [Str91], [BHS92]. If a debugger does not supply the value of a variable outside of its live ranges, there will be points at which the variable is in some storage location but the debugger will not display it to the user.
Reference: [FM80] <author> P. H. Feiler, R. Medina-Mora, </author> <title> "An Incremental Programming Environment," </title> <institution> Carnegie Mellon University Computer Science Department Report, </institution> <month> April </month> <year> 1980. </year>
Reference: [Fri83] <author> P. Fritzon, </author> <title> "A Systematic Approach to Advanced Debugging through Incremental Compilation", </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging, </booktitle> <address> Pacific Grove, California, </address> <month> March </month> <year> 1983, </year> <journal> also published as SIGPLAN Notices, </journal> <volume> Vol. 18, No. 8, </volume> <pages> pp. </pages> <month> 130-139 Aug. </month> <year> 1983. </year>
Reference-contexts: While their proposed solution was not correct, it contained the genesis of Zellweger's complete and correct algorithm [Zel84], and appears to have contained the genesis of her invisible breakpoints and path determiners. "A Systematic Approach to Advanced Debugging through Incremental Compilation" Fritzson <ref> [Fri83] </ref> investigated using incremental compilation to supply advanced debugging features. He was not focussed on debugging optimized code, but his system has the advantages and disadvantages of any incremental compilation system with regard to debugging optimized code.
Reference: [Gup90] <author> R. Gupta, </author> <title> "Debugging Code Reorganized by a Trace Scheduling Compiler," </title> <journal> Structured Programming, </journal> <volume> Vol. 11, No. 3, pp.1-10, </volume> <month> July </month> <year> 1990. </year>
Reference-contexts: Optimization May Change the Behavior of a Program int i; char b [10], c; void walk_on_c () - c = getchar (); for (i=0; i&lt;=10; i++) - - program misbehaves - * to restrict the capabilities of the debugger to those that do not exhibit the problem ([WS78], <ref> [Gup90] </ref>, [ZJ90]), * to recompile, without optimization, during an interactive debugging session, the region of code that is to be debugged ([FM80], [ZJ90]), and * to have the compiler provide information about the optimizations that it has performed and to have the debugger use that information to provide appropriate behav ior <p> optimization, during an interactive debugging session, the region of code that is to be debugged ([FM80], [ZJ90]), and * to have the compiler provide information about the optimizations that it has performed and to have the debugger use that information to provide appropriate behav ior ([WS78], [Hen82], [Zel84], [CMR88], [ZJ90], <ref> [Gup90] </ref>, [PS91], [Coh91], [CM91b], A larger problem is lowering the cost of debugging production quality software. <p> From my limited acquaintance with his work, it appears that he has concentrated on breakpoint mapping and formalizing the effects of optimization in a composable set of rewrite rules. "Debugging Code Reorganized by a Trace Scheduling Compiler" Gupta <ref> [Gup90] </ref> investigated debugging code that has been automatically parallelized by a trace scheduling compiler. To allow the compiler freedom to exploit any parallelism present in the program, "the power of the debugger is compromised". Monitoring commands must be compiled into the program.
Reference: [Hen82] <author> J. Hennessy, </author> <title> "Symbolic Debugging of Optimized Code," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 4, No. 3, </volume> <pages> pp. 323-344, </pages> <year> 1982. </year>
Reference-contexts: * to recompile, without optimization, during an interactive debugging session, the region of code that is to be debugged ([FM80], [ZJ90]), and * to have the compiler provide information about the optimizations that it has performed and to have the debugger use that information to provide appropriate behav ior ([WS78], <ref> [Hen82] </ref>, [Zel84], [CMR88], [ZJ90], [Gup90], [PS91], [Coh91], [CM91b], A larger problem is lowering the cost of debugging production quality software. <p> This problem is addressed for local optimizations only (specifically, register promotion combined with local instruction scheduling) by Coutant et al [CMR88], Adl-Tabatabai and Gross [AG93a], and Streepy [Str91] and Brooks et al [BHS92]. It is also addressed for local and global optimization by Hennessy <ref> [Hen82] </ref>, Wismuller and others [BW93], and by Part III of this work. 5.6 Data Modification The user may want to modify a data object's value while in the debugger and continue execution of the program using the modified value to modify the program's behavior. Optimization can defeat the process. <p> It contains a discussion of information needed from the compiler to implement a debugger that provides messages about the effect of optimizations on source code|what has since been termed truthful behavior. "Symbolic Debugging of Optimized Code" Hennessy published the first journal paper <ref> [Hen82] </ref> on the topic, and it has been influential. His paper is concerned with currency determination and expected value recovery. When a variable is not current, expected value recovery is the act of computing the value the variable would have had if it were current. <p> The user, looking at the original source code, may be confused by the fact that the displayed value is not constant, or may believe wrongly that the value being assigned to y is expression. At such a breakpoint, x is called noncurrent <ref> [Hen82] </ref>, and determining whether optimization has caused a variable's value to be misleading is called currency determination. Some solution to the problem of currency determination is necessary for providing expected or truthful behavior. Optimization may also introduce confusion over where execution is suspended in the program being debugged. <p> In unoptimized code, at each breakpoint the expected value of every variable is identical to its actual value. In optimized code, as we have seen, the actual value of a variable at some point may differ from its expected value at that point. Hennessy <ref> [Hen82] </ref> introduced the terms current, noncurrent, and endangered to describe the relationship between a variable's actual value and its expected value at a breakpoint. This relationship is described on the basis of a static analysis, one that has no information about how the breakpoint was reached.
Reference: [Hen90] <author> Hennessy, J., </author> <title> Center for Integrated Systems, Stanford University, Stanford, CA, personal communication regarding "Symbolic Debugging of Optimized Code," </title> <year> 1991. </year>
Reference: [Mel90] <author> Meloy, S., </author> <title> Hewlett-Packard, </title> <type> 3345 Mount Pleasant Rd., </type> <institution> Lincoln, CA, </institution> <type> personal communication regarding DOC, </type> <year> 1990. </year>
Reference: [Kes90] <author> P. Kessler, </author> <title> "Fast Breakpoints: </title> <booktitle> Design and Implementation", Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: The debugger can use invisible breakpoints [Zel84] or program patching [CT93], [BK92], [CH91], <ref> [Kes90] </ref> to collect the information. An invisible breakpoint is a breakpoint at which the debugger halts the executing program, takes some action, and continues execution without ever giving control to the user.
Reference: [Kor88] <author> B. Korel, </author> <title> "PELAS Program Error-Locating Assistant System," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 14, No. 9, </volume> <pages> pp. 1253-1260, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: At that point, z had the value 3.141 (set at line 370) and y had the value 17; y was set at line 506 to y+bar (w).'. This was called flowback analysis by Balzer [Bal69], and has been investigated by others ([MC91], <ref> [Kor88] </ref>); reaching sets may be adaptable to this purpose. Another research direction is dynamic currency determination, which is how a debugger can collect the minimal execution history information needed to determine whether an endangered variable is current or noncurrent when execution is suspended at a breakpoint.
Reference: [MC88] <author> B. Miller, J. Choi, </author> <title> "A Mechanism for Efficient Debugging of Parallel Programs," </title> <booktitle> Proceedings of the SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. 125-134, </pages> <address> Madison, Wisconsin, </address> <year> 1988. </year>
Reference: [MC91] <author> B. Miller, J. Choi, </author> <title> "Techniques for Debugging Parallel Programs with Flowback Analysis," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, No. 4, </volume> <pages> pp. 491-530, </pages> <year> 1991. </year>
Reference: [Pic90] <author> D. Pickens, MetaWare Incorporated, </author> <title> Santa Cruz, CA, personal communication regarding the MetaWare High C compiler. </title> <type> References 143 </type>
Reference: [PS91] <author> P. P. Pineo, M. L. Soffa, </author> <title> "Debugging Parallelized Code Using Code Liberation Techniques," </title> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <month> May </month> <year> 1991, </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 26, No. 12, </volume> <pages> pp. </pages> <month> 108-119 December </month> <year> 1991. </year>
Reference-contexts: during an interactive debugging session, the region of code that is to be debugged ([FM80], [ZJ90]), and * to have the compiler provide information about the optimizations that it has performed and to have the debugger use that information to provide appropriate behav ior ([WS78], [Hen82], [Zel84], [CMR88], [ZJ90], [Gup90], <ref> [PS91] </ref>, [Coh91], [CM91b], A larger problem is lowering the cost of debugging production quality software. <p> A Survey of Related Work 21 to minimize the cost of achieving a debuggable state (the worst case involves re-executing the program with synchronization code). "Debugging Parallelized Code Using Code Liberation Techniques" Pineo <ref> [PS91] </ref> describes a different method for providing a sequential view of automatically parallelized programs. Global renaming is used to convert the sequential program to single assignment form. Subsequently, parallelizing transformations can be performed.
Reference: [PS88] <author> L. L. Pollock, M. L. Soffa, </author> <title> "High Level Debugging with the Aid of an Incremental Optimizer," </title> <booktitle> Hawaii International Conference on System Sciences, </booktitle> <month> January </month> <year> 1988. </year>
Reference-contexts: If the user sets a to 1, it will not cause print to be called. This problem has not been addressed. It is generally considered too difficult, but the data structure developed by Pollock and Soffa for incremental global optimization <ref> [PS88] </ref>, [PS92] should be applicable. 5.7 Code Modification The user may want to modify existing code or execute arbitrary code while in the debugger. Debuggers are far from uniform in the manner in which they provide this sort of facility. Some do not allow it at all. <p> His incremental compiler was based on the portable C compiler, thus optimizations were local to a statement. This allowed him to incrementally recompile at statement granularity without needing an optimization history like that of Pollock and Soffa <ref> [PS88] </ref>, [PS92]. "Interactive Debug Requirements" Seidner and Tindall published IBM's market requirements statement for an interactive debugger [ST83]. It catalogs what a good debugger (as seen from 1983) should not be without, with a good rationale for each suggested feature. <p> This will occur if both statements have been moved. 20 6. A Survey of Related Work "Incremental Global Reoptimization of Programs : : : " In two articles <ref> [PS88] </ref>, [PS92], Pollock and Soffa explore the potential of incremental optimization. The earlier paper focusses on incrementally reoptimizing when an optimization has made it impossible to satisfy a debugging request. The later paper focusses on incrementally reoptimizing when a program is edited.
Reference: [PS92] <author> L. L. Pollock, M. L. Soffa, </author> <title> "Incremental Global Reoptimization of Programs," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 14, No. 2, </volume> <pages> pp. 173-200, </pages> <year> 1992. </year>
Reference-contexts: If the user sets a to 1, it will not cause print to be called. This problem has not been addressed. It is generally considered too difficult, but the data structure developed by Pollock and Soffa for incremental global optimization [PS88], <ref> [PS92] </ref> should be applicable. 5.7 Code Modification The user may want to modify existing code or execute arbitrary code while in the debugger. Debuggers are far from uniform in the manner in which they provide this sort of facility. Some do not allow it at all. <p> His incremental compiler was based on the portable C compiler, thus optimizations were local to a statement. This allowed him to incrementally recompile at statement granularity without needing an optimization history like that of Pollock and Soffa [PS88], <ref> [PS92] </ref>. "Interactive Debug Requirements" Seidner and Tindall published IBM's market requirements statement for an interactive debugger [ST83]. It catalogs what a good debugger (as seen from 1983) should not be without, with a good rationale for each suggested feature. <p> This will occur if both statements have been moved. 20 6. A Survey of Related Work "Incremental Global Reoptimization of Programs : : : " In two articles [PS88], <ref> [PS92] </ref>, Pollock and Soffa explore the potential of incremental optimization. The earlier paper focusses on incrementally reoptimizing when an optimization has made it impossible to satisfy a debugging request. The later paper focusses on incrementally reoptimizing when a program is edited.
Reference: [ST83] <author> R. Seidner, N. Tindall, </author> <title> "Interactive Debug Requirements", </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging, </booktitle> <address> Pacific Grove, California, </address> <month> March </month> <year> 1983, </year> <journal> also published as SIGPLAN Notices, </journal> <volume> Vol. 18, No. 8, </volume> <pages> pp. </pages> <month> 130-139 Aug. </month> <year> 1983. </year>
Reference-contexts: This allowed him to incrementally recompile at statement granularity without needing an optimization history like that of Pollock and Soffa [PS88], [PS92]. "Interactive Debug Requirements" Seidner and Tindall published IBM's market requirements statement for an interactive debugger <ref> [ST83] </ref>. It catalogs what a good debugger (as seen from 1983) should not be without, with a good rationale for each suggested feature. It is interesting how many debuggers today are without some of these features. Source-level debugging of optimized code was considered a requirement for an interactive debugger. <p> I have not seen any other approaches that might apply to this problem. "A Unified Approach to the Debugging of Optimised Programs : : : " Shu [Shu89], [Shu91], [Shu92], <ref> [ST83] </ref>, did his dissertation on debugging optimized code. I cite his work for completeness, but I only recently became aware of it and am not familiar with the content.
Reference: [Shu89] <author> W. S. Shu, </author> <title> "A Unified Approach to the Debugging of Optimized Programs", </title> <type> Ph.D. </type> <institution> Disssertation, Department of Computer Science, University of Nottingham, </institution> <address> England, UK, </address> <year> 1989. </year>
Reference-contexts: I have not seen any other approaches that might apply to this problem. "A Unified Approach to the Debugging of Optimised Programs : : : " Shu <ref> [Shu89] </ref>, [Shu91], [Shu92], [ST83], did his dissertation on debugging optimized code. I cite his work for completeness, but I only recently became aware of it and am not familiar with the content.
Reference: [Shu91] <author> W. S. Shu, </author> <title> "A Formal Characterisation of the Effects of Optimization on Debugging", </title> <type> Technical Report TR003-WSS-91, </type> <institution> Department of Computer Science, University of Yaounde, Cameroon, </institution> <year> 1991. </year>
Reference-contexts: I have not seen any other approaches that might apply to this problem. "A Unified Approach to the Debugging of Optimised Programs : : : " Shu [Shu89], <ref> [Shu91] </ref>, [Shu92], [ST83], did his dissertation on debugging optimized code. I cite his work for completeness, but I only recently became aware of it and am not familiar with the content.
Reference: [Shu92] <author> W. S. Shu, </author> <title> "A New Basis for Debugging : : : from Optimized Programs", </title> <booktitle> First International Conference on Research in Computer Science, </booktitle> <address> Yaounde, </address> <note> Cameroon (published by INRIA, France) 1992. </note>
Reference-contexts: I have not seen any other approaches that might apply to this problem. "A Unified Approach to the Debugging of Optimised Programs : : : " Shu [Shu89], [Shu91], <ref> [Shu92] </ref>, [ST83], did his dissertation on debugging optimized code. I cite his work for completeness, but I only recently became aware of it and am not familiar with the content.
Reference: [ST83] <author> W. S. Shu, </author> <title> "Adapting A Debugger for Optimized Programs", </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 28, No. 4, </volume> <pages> pp. </pages> <month> 39-44 April </month> <year> 1993. </year>
Reference-contexts: This allowed him to incrementally recompile at statement granularity without needing an optimization history like that of Pollock and Soffa [PS88], [PS92]. "Interactive Debug Requirements" Seidner and Tindall published IBM's market requirements statement for an interactive debugger <ref> [ST83] </ref>. It catalogs what a good debugger (as seen from 1983) should not be without, with a good rationale for each suggested feature. It is interesting how many debuggers today are without some of these features. Source-level debugging of optimized code was considered a requirement for an interactive debugger. <p> I have not seen any other approaches that might apply to this problem. "A Unified Approach to the Debugging of Optimised Programs : : : " Shu [Shu89], [Shu91], [Shu92], <ref> [ST83] </ref>, did his dissertation on debugging optimized code. I cite his work for completeness, but I only recently became aware of it and am not familiar with the content.
Reference: [Sil92] <author> J. Silverstein, ed., </author> <title> "DWARF Debugging Information Format," Proposed Standard, </title> <booktitle> UNIX International Programming Languages Special Interest Group, </booktitle> <month> April </month> <year> 1992, </year> <type> personal communication regarding DWARF. </type>
Reference-contexts: This problem is addressed by a number of modern symbol table formats, including Microtec Research, Inc.'s format for their Xray debugger [Wan91], the DWARF Debugging Information Format <ref> [Sil92] </ref>, the symbol table put out by a prototype modification of Hewlett Packard's C compiler for the HP9000 series 800 for use by a prototype modification of the debugger for that machine [CMR88], and the symbol table put out by the Convex compiler for use by Cxdb [Str91].
Reference: [Str91] <author> L. Streepy, </author> <title> "CXdb A New View On Optimization," </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop , Albuquerque, </booktitle> <month> November </month> <year> 1991. </year>
Reference-contexts: It is also addressed in some of the more modern symbol table formats. Examples include the symbol table put out by the MIPS compiler for use by dbx and the symbol table put out by the Convex compiler for use by the Convex debugger Cxdb <ref> [Str91] </ref>, [BHS92]. 5.3 Breakpoint Location Determination When the user requests a breakpoint at a source line L, the debugger must be able to set the breakpoint at an appropriate address. In the absence of optimization, the line table is sufficient. <p> This problem is addressed is Section 15. It is also addressed by Zellweger [Zel84], Coutant et al [CMR88], Zurawski and Johnson [ZJ90], Streepy <ref> [Str91] </ref> and Brooks et al [BHS92], and Wismuller [BW93]. Different approaches allow different debugger capabilities. <p> Worse, the user may be led to believe that code has been executed when it has not, or vice-versa. Simple code motion is enough to cause the latter problem. Loop transformations can compound the problem. This problem is addressed to some extent by Streepy <ref> [Str91] </ref> and Brooks et al [BHS92]. The user can request more context in the form of a call-stack trace. 4 Two optimizations, inlining and the stack-frame pointer optimization discussed in Part II of this work, can cause a call-stack trace to be inaccurate and misleading. <p> Debugging Information Format [Sil92], the symbol table put out by a prototype modification of Hewlett Packard's C compiler for the HP9000 series 800 for use by a prototype modification of the debugger for that machine [CMR88], and the symbol table put out by the Convex compiler for use by Cxdb <ref> [Str91] </ref>. Although the symbol table formats are general, the information stored in them is usually derived from live range information computed for use by the optimizer. This is not optimal for use by the debugger, for reasons described in Section 26. <p> If the dead store into a has been eliminated, the value in the location associated with a may mislead the user. This problem is addressed for local optimizations only (specifically, register promotion combined with local instruction scheduling) by Coutant et al [CMR88], Adl-Tabatabai and Gross [AG93a], and Streepy <ref> [Str91] </ref> and Brooks et al [BHS92]. <p> Subsequently, parallelizing transformations can be performed. Finally, the large storage requirements of single assignment code are reduced by reclaiming names that are not useful for parallelization or debugging. "A New Approach to Debugging Optimized Code : : : " At Convex, Streepy <ref> [Str91] </ref> and Brooks et al [BHS92] break with the by now conventional view that the debugger should hide the effects of optimization. Their view is that the debugger should aid the user in understanding what is actually happening in the presence of aggressive optimization and parallelization. <p> This problem has been addressed by others [CMR88], [Wan91], <ref> [Str91] </ref>, [BHS92], but typically by providing live-range information to the debugger. <p> It is inappropriate to associate every instruction generated from a statement with that statement for the purposes of setting breakpoints, because if the instructions are not contiguous, many breakpoints may be reached for a single statement. In contrast, Streepy <ref> [Str91] </ref> and Brooks et al [BHS92] describe a source-code/breakpoint-location mapping that allows breakpoints to be set at various levels of granularity, including expressions, basic blocks, and subroutines. <p> The address of this instruction is a breakpoint location for S. 19 Where no confusion will result, the representative instruction itself may be referred to as the breakpoint location. The mapping described herein is not in conflict with that described by Streepy <ref> [Str91] </ref>; each enables debugger capabilities missing from the other. This paper does not concern itself further with breakpoints for language entities other than statements, except to state that the results hold in the presence of such breakpoints. <p> Choosing the store as the breakpoint location for variable modifications is crucial to the correctness of the work presented in the remainder of the paper. Additional breakpoints, such as those described by Streepy <ref> [Str91] </ref>, could easily be incorporated into this model. The proposed breakpoint model supports both syntactic and semantic breakpoints. This does not increase the number of breakpoint locations, but it affects the mapping between source-level specifications of breakpoints and breakpoint locations. <p> It is increasingly common for a compiler to provide live-range and variable location information to a debugger [CMR88], [Wan91], <ref> [Str91] </ref>, [BHS92]. If a debugger does not supply the value of a variable outside of its live ranges, there will be points at which the variable is in some storage location but the debugger will not display it to the user.
Reference: [WST85] <author> D. Wall, A. Srivastava, R. Templin, </author> <title> "A note on Hennessy's Symbolic Debugging of Optimized Code," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 7, No. 1, </volume> <pages> pp. 176-181, </pages> <month> Jan. </month> <year> 1985. </year>
Reference-contexts: He also considers limited global optimization, with weaker results. Technical correspondence about Hennessy`s work has appeared twice. "A note on Hennessy's Symbolic Debugging of Optimized Code", by Wall, Srivastava, and Templin <ref> [WST85] </ref> corrects an error in the algorithm used to determine the currency of variables, using Hennessy's data structures. "A further note on Hennessy's Symbolic Debugging of Optimized Code", by Copperman and McDowell [CM93] points out that his technique assumes that after optimization, programs have only one store to a variable within
Reference: [Wan91] <author> Wang, F., </author> <title> Microtec Research, </title> <publisher> Inc., </publisher> <address> Santa Clara, CA, </address> <month> January </month> <year> 1992, </year> <title> personal communication regarding Microtec Research, Inc.'s Xray Debugger. </title>
Reference-contexts: This problem is addressed by a number of modern symbol table formats, including Microtec Research, Inc.'s format for their Xray debugger <ref> [Wan91] </ref>, the DWARF Debugging Information Format [Sil92], the symbol table put out by a prototype modification of Hewlett Packard's C compiler for the HP9000 series 800 for use by a prototype modification of the debugger for that machine [CMR88], and the symbol table put out by the Convex compiler for use <p> This problem has been addressed by others [CMR88], <ref> [Wan91] </ref>, [Str91], [BHS92], but typically by providing live-range information to the debugger. <p> It is increasingly common for a compiler to provide live-range and variable location information to a debugger [CMR88], <ref> [Wan91] </ref>, [Str91], [BHS92]. If a debugger does not supply the value of a variable outside of its live ranges, there will be points at which the variable is in some storage location but the debugger will not display it to the user.
Reference: [Wis93] <institution> Wismueller, R., Institut fur Informatik, Technische Universitat Munchen, Munich, Germany, </institution> <type> personal communication regarding current research, </type> <month> February </month> <year> 1993. </year>
Reference-contexts: His approach is similar 22 6. A Survey of Related Work to my approach to currency determination. The scope of his work is quite ambitious. As of this writing <ref> [Wis93] </ref> his breakpoint model is more general than that presented in Section 15, he incorporates recovery into his currency determination technique, and he addresses the data location problem. He does not address optimizations that modify the shape of the flow graph. <p> If the unoptimized code is run on the same inputs, one of the right-hand paths will be taken, so optimization does not affect the value that a will have at the semantic breakpoint for bkpt: a is current at bkpt. Bemmerl and Wismuller's current approach <ref> [Wis93] </ref> would claim that a is endangered at bkpt. Suppose we allowed semantic breakpoint locations using my approach to currency determination. Let S be the semantic breakpoint location for bkpt. PRS a S = f (a = x; a = x); (a = y; a = y)g.
Reference: [WS78] <author> H. S. Warren, Jr., H. P. Schlaeppi, </author> <title> "Design of the FDS interactive debugging system," </title> <institution> IBM Research Report RC7214, IBM Yorktown Heights, </institution> <month> July </month> <year> 1978. </year>
Reference-contexts: Summaries of published papers are presented in approximately chronological order. Discussions of each paper are headed by the title of the paper. "Design of the FDS interactive debugging system" In July of 1978, Warren and Schlaeppi produced an IBM research report <ref> [WS78] </ref> the intended debugging system for the Research Division's Firmware Development System (FDS).
Reference: [Ze83a] <author> P. Zellweger, </author> <title> "Interactive Source-Level Debugging of Optimized Programs," </title> <institution> Research Report CSL-83-1, Xerox Palo Alto Research Center, </institution> <address> Palo Alto, CA, </address> <month> Jan. </month> <year> 1983. </year>
Reference: [Ze83b] <author> P. Zellweger, </author> <title> "An Interactive High-Level Debugger for Control-Flow Optimized Programs," </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 18, No. 8, </volume> <pages> pp. </pages> <month> 159-172 Aug. </month> <year> 1983. </year> <note> 144 References </note>
Reference: [Zel84] <author> P. Zellweger, </author> <title> "Interactive Source-Level Debugging of Optimized Programs," </title> <institution> Research Report CSL-84-5, Xerox Palo Alto Research Center, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1984. </year>
Reference-contexts: to recompile, without optimization, during an interactive debugging session, the region of code that is to be debugged ([FM80], [ZJ90]), and * to have the compiler provide information about the optimizations that it has performed and to have the debugger use that information to provide appropriate behav ior ([WS78], [Hen82], <ref> [Zel84] </ref>, [CMR88], [ZJ90], [Gup90], [PS91], [Coh91], [CM91b], A larger problem is lowering the cost of debugging production quality software. <p> Zellweger <ref> [Zel84] </ref> introduced terms for two methods of removing or ameliorating the confusion introduced into the debugging process by optimization. <p> This problem is addressed is Section 15. It is also addressed by Zellweger <ref> [Zel84] </ref>, Coutant et al [CMR88], Zurawski and Johnson [ZJ90], Streepy [Str91] and Brooks et al [BHS92], and Wismuller [BW93]. Different approaches allow different debugger capabilities. <p> The user can request more context in the form of a call-stack trace. 4 Two optimizations, inlining and the stack-frame pointer optimization discussed in Part II of this work, can cause a call-stack trace to be inaccurate and misleading. Zellweger <ref> [Zel84] </ref> shows how to provide expected behavior in the presence of inlining, and Part II shows how to provide expected behavior in the presence of the stack-frame pointer optimization. 5.5 Data Value Reporting Source-level debuggers commonly use symbol table entries to associate source code data objects with memory locations. <p> It describes a problem with determining breakpoint locations in the presence of cross-jumping. While their proposed solution was not correct, it contained the genesis of Zellweger's complete and correct algorithm <ref> [Zel84] </ref>, and appears to have contained the genesis of her invisible breakpoints and path determiners. "A Systematic Approach to Advanced Debugging through Incremental Compilation" Fritzson [Fri83] investigated using incremental compilation to supply advanced debugging features. <p> Source-level debugging of optimized code was considered a requirement for an interactive debugger. The paper lists the problems optimization causes for a debugger and the behavior that solutions to the problems should support. "An Interactive High-Level Debugger for Control-Flow Optimized Programs" Zellweger <ref> [Zel84] </ref> produced the first dissertation on debugging optimized code. The first part of her thesis provides a coherent discussion of terminology for debugging optimized code and the related issues. Terminology she introduced includes: 18 6. <p> Subsequently, only providing an accurate call-stack trace is discussed. In particular, I do not further discuss the display of local variables. This problem has not been discussed in the literature. Zellweger <ref> [Zel84] </ref> provides a solution to the problem of providing an accurate call-stack trace in the presence of procedure integration (inlining). <p> The debugger can use invisible breakpoints <ref> [Zel84] </ref> or program patching [CT93], [BK92], [CH91], [Kes90] to collect the information. An invisible breakpoint is a breakpoint at which the debugger halts the executing program, takes some action, and continues execution without ever giving control to the user. <p> In today's most common software production environments, using the debugger involves explicitly invoking the debugger before running the to-be-debugged program|all debugging is expected debugging activity <ref> [Zel84] </ref>. In a growing number of software production environments, the debugger is always available and the program need not be restarted to be debugged. In such an environment, unexpected debugging activity is possible|for example, a program trap or user interrupt may invoke the debugger on a running program. <p> Optimized to set the breakpoint where it ended up, so the values the debugger displays are the actual values used in the expression. Zellweger <ref> [Zel84] </ref> introduced the terms syntactic and semantic breakpoints. If no code motion or elimination has occurred, these are identical. <p> The choice of a breakpoint location for a statement S affects the correspondence between the actual debugging context and the expected debugging context considerably. Zellweger <ref> [Zel84] </ref> has a discussion of possible semantic breakpoint locations for statements whose generated code is discontiguous.
Reference: [ZJ90] <author> L. W. Zurawski, R. E. Johnson, </author> <title> "Debugging Optimized Code With Expected Behavior," </title> <institution> Unpublished draft from University of Illinois at Urbana-Champaign Department of Computer Science, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: the behavior of a program, it is necessary, upon occasion, to either debug optimized code or never optimize the code. 2.1 Approaches to the Problem General approaches to the problem have been: * to restrict the optimizations performed by the compiler to those that do not provoke the problem ([WS78], <ref> [ZJ90] </ref>), 8 2. <p> Optimization May Change the Behavior of a Program int i; char b [10], c; void walk_on_c () - c = getchar (); for (i=0; i&lt;=10; i++) - - program misbehaves - * to restrict the capabilities of the debugger to those that do not exhibit the problem ([WS78], [Gup90], <ref> [ZJ90] </ref>), * to recompile, without optimization, during an interactive debugging session, the region of code that is to be debugged ([FM80], [ZJ90]), and * to have the compiler provide information about the optimizations that it has performed and to have the debugger use that information to provide appropriate behav ior ([WS78], <p> getchar (); for (i=0; i&lt;=10; i++) - - program misbehaves - * to restrict the capabilities of the debugger to those that do not exhibit the problem ([WS78], [Gup90], <ref> [ZJ90] </ref>), * to recompile, without optimization, during an interactive debugging session, the region of code that is to be debugged ([FM80], [ZJ90]), and * to have the compiler provide information about the optimizations that it has performed and to have the debugger use that information to provide appropriate behav ior ([WS78], [Hen82], [Zel84], [CMR88], [ZJ90], [Gup90], [PS91], [Coh91], [CM91b], A larger problem is lowering the cost of debugging production quality software. <p> without optimization, during an interactive debugging session, the region of code that is to be debugged ([FM80], <ref> [ZJ90] </ref>), and * to have the compiler provide information about the optimizations that it has performed and to have the debugger use that information to provide appropriate behav ior ([WS78], [Hen82], [Zel84], [CMR88], [ZJ90], [Gup90], [PS91], [Coh91], [CM91b], A larger problem is lowering the cost of debugging production quality software. <p> This problem is addressed is Section 15. It is also addressed by Zellweger [Zel84], Coutant et al [CMR88], Zurawski and Johnson <ref> [ZJ90] </ref>, Streepy [Str91] and Brooks et al [BHS92], and Wismuller [BW93]. Different approaches allow different debugger capabilities. <p> can then enable and disable any of these, and monitor those variables or expressions, at those points in the program (which might be specific loop iterations) that were selected for monitoring at compile time. "Debugging Optimized Code With Expected Behavior" At the University of Illinois at Urbana-Champaign, Zurawski and Johnson <ref> [ZJ90] </ref> modified the standard Smalltalk debugger and an optimizing compiler for Typed Smalltalk.
References-found: 50

