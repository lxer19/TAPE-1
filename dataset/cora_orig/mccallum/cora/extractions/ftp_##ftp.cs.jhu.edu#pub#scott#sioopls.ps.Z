URL: ftp://ftp.cs.jhu.edu/pub/scott/sioopls.ps.Z
Refering-URL: http://www.cs.jhu.edu/labs/pll/home.html
Root-URL: http://www.cs.jhu.edu
Title: A Simple Interpretation of OOP in a Language with State a translation of the object-based
Author: Jonathan Eifrig Scott Smith Valery Trifonov Amy Zwarico 
Note: The semantics is given by  
Date: May 22, 1993  
Affiliation: Department of Computer Science The Johns Hopkins University  
Abstract: Giving a complete semantics to strongly typed object-oriented programming is a well-known research problem. Recent work has made significant strides toward solving this problem. However, in most of this work a purely functional, call-by-name view of objects is taken. In this paper we give meaning to a call-by-value, typed object language with updatable instance variables, and prove the type system given is sound; i.e., well-typed programs do not experience "message not understood" errors. 
Abstract-found: 1
Intro-found: 1
Reference: [BM92] <author> K. Bruce and J. Mitchell. </author> <title> PER models of subtyping, recursive types and higher-order polymorphism. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 316-327, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Giving full and faithful meaning to typed object-oriented programming languages is a well-known research problem. There has been considerable recent activity in defining powerful type systems for OOP <ref> [CHC90, CCH + 89, BM92, Bru93, Mit90, PT93] </ref>. These approaches have a natural model in F ! and admit a very powerful type theory utilizing F-bounded quantification. One major shortcoming of all these approaches is they take a functional view of objects.
Reference: [Bru93] <author> K. Bruce. </author> <title> Safe type checking in a statically-typed object-oriented programming language. </title> <booktitle> In Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 285-298, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Giving full and faithful meaning to typed object-oriented programming languages is a well-known research problem. There has been considerable recent activity in defining powerful type systems for OOP <ref> [CHC90, CCH + 89, BM92, Bru93, Mit90, PT93] </ref>. These approaches have a natural model in F ! and admit a very powerful type theory utilizing F-bounded quantification. One major shortcoming of all these approaches is they take a functional view of objects. <p> Observe that the align and align2 methods may be typed in our language even though they may take objects of their own class as arguments. Simulating this program in a functional interpretation of OOP such as <ref> [Bru93, PT93] </ref> requires an explicit threading of state in some fashion. In particular, align2 modifies the state of its argument object while executing.
Reference: [Car84] <author> L. Cardelli. </author> <title> A semantics of multiple inheritance. In Semantics of Data Types, </title> <booktitle> volume 173 of Lecture notes in Computer Science, </booktitle> <pages> pages 51-67. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: In order to make the state problem tractable, we have elected to use a simpler typing scheme based on an approach requiring inheritance to conform with subtyping. Subtyping in SOOP is the standard record subsumption model following Cardelli <ref> [Car84] </ref>. Since many real-world OOP languages enforce this criterion, it is not wholly unreasonable, and may ultimately prove the most tractable approach if the type-checking and type-inference problems of F-bounded polymorphism prove intractable [Pie92]. <p> LOOP types and contexts are partially ordered by the subtyping relation , axiomatized by the rules in Figure 1. PCF types are ordered in the usual way <ref> [Car84] </ref>. Two instance contexts I 1 and I 2 are ordered, I 1 I 2 , only if every instance variable name occurring in I 2 occurs in I 1 with the same type, although I 1 may map additional names as well. <p> ; l m : t m jg j t 0 Ref j t 0 SAR As in LOOP there is a subtyping relation on types of SOOP|it is the least reflexive transitive relation generated by the rules in Figure 3; these include the standard rules for record and function types <ref> [Car84] </ref>. Non-trivial subtyping between reference types is unsound; however the discipline of once-assigning values to SAR cells allows us to treat the SAR type constructor as covariant without losing soundness. This covariance is crucial for the type-checking of the translation of LOOP class extensions into SOOP.
Reference: [CCH + 89] <author> P. Canning, W. Cook, W. Hill, J. Mitchell, and W. Olthoff. </author> <title> F-bounded polymorphism for object-oriented progrmming. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Giving full and faithful meaning to typed object-oriented programming languages is a well-known research problem. There has been considerable recent activity in defining powerful type systems for OOP <ref> [CHC90, CCH + 89, BM92, Bru93, Mit90, PT93] </ref>. These approaches have a natural model in F ! and admit a very powerful type theory utilizing F-bounded quantification. One major shortcoming of all these approaches is they take a functional view of objects.
Reference: [CF91] <author> E. Crank and M. Felleisen. </author> <title> Parameter-passing and the lambda calculus. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: In purely functional languages this encoding produces perfectly adequate results, but the situation changes with the introduction of effects and the natural for them (though not intrinsic <ref> [CF91] </ref>) call-by-value semantics. As pointed out in [Wan89, CHC90, PT93] the fixed point combinator is then only well-defined on functionals, and classes do not correspond to functionals. <p> ` e : t Ref (Select) ` e : fjl : t jg (Record) ` e i : t i for all i 2 f1; : : : ; mg 4.1 Operational Interpreter for SOOP We give semantics of SOOP in the general framework of [FH92, MT91] developed further in <ref> [CF91, WF91] </ref>. The operational interpreter of the language is specified by binary relations between SOOP terms in memory environments, which represent the notion of computation.
Reference: [CHC90] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Giving full and faithful meaning to typed object-oriented programming languages is a well-known research problem. There has been considerable recent activity in defining powerful type systems for OOP <ref> [CHC90, CCH + 89, BM92, Bru93, Mit90, PT93] </ref>. These approaches have a natural model in F ! and admit a very powerful type theory utilizing F-bounded quantification. One major shortcoming of all these approaches is they take a functional view of objects. <p> A class can be extended by the addition of new instance variables and methods, but overriding an existing method can only be done with a new method body whose type is a subtype of the one overridden. This restriction, critiqued in <ref> [CHC90] </ref>, is necessary in our simple interpretation; if methods could be overridden with new methods of arbitrary types, the correctness of the other methods of the class (which may make use of the now-overridden method name) could not be guaranteed. <p> In purely functional languages this encoding produces perfectly adequate results, but the situation changes with the introduction of effects and the natural for them (though not intrinsic [CF91]) call-by-value semantics. As pointed out in <ref> [Wan89, CHC90, PT93] </ref> the fixed point combinator is then only well-defined on functionals, and classes do not correspond to functionals.
Reference: [CP89] <author> W. Cook and J. Parlsberg. </author> <title> A denotational semantics of inheritence and its correctness. </title> <booktitle> In OOPSLA '89 Proceedings, </booktitle> <pages> pages 433-443, </pages> <year> 1989. </year>
Reference-contexts: This new construct is not strictly necessary, but we argue why it is more useful to have it than to suffer the consequences of its absence. The translation of expressions is similar to other interpretations of records as objects developed for untyped OOP <ref> [CP89, Red88] </ref>. The main difference is use of the single assignment reference in fl Partially supported by NSF grant CCR-9109070 y Authors' email addresses: eifrig@cs.jhu.edu, scott@cs.jhu.edu, trifonov@cs.jhu.edu, amy@cs.jhu.edu 1 place of the Y -combinator to avoid copying of code. <p> The only significant departure from standard notions is the single-assignment reference (SAR) cell, which allows for a natural and type-sound interpretation of objects in the presence of effects. In standard encodings of object-oriented languages <ref> [CP89, Red88] </ref> an object is formed by taking a fixed point of a function that represents its class, referred to below as the "class function." This results in a recursive record, and the methods of the object|fields of the record|gain access to its "self" by unrolling the fixed point expression. <p> ()) jgjg in let p1 = (let s be SAR to Point2 s).meth in let p2 = (let s be SAR to Point2 s).meth in p1.align2 p2 6 Conclusions We give an operational interpretation of an object-oriented language with mutable instance variables, similar in flavor to the "wrapper semantics" of <ref> [CP89, Hen91] </ref>, but in a strongly typed framework. This requires the solution of two basic semantic problems: avoiding the reallocation of instance variable cells resulting from an object's self-reference (in the fixed point encoding), and the type-correct extension of classes (based on the subtyping relation between object types).
Reference: [FH92] <author> M. Felleisen and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 102 </volume> <pages> 235-271, </pages> <year> 1992. </year>
Reference-contexts: e : t SAR (Deref) ` e : t Ref (Select) ` e : fjl : t jg (Record) ` e i : t i for all i 2 f1; : : : ; mg 4.1 Operational Interpreter for SOOP We give semantics of SOOP in the general framework of <ref> [FH92, MT91] </ref> developed further in [CF91, WF91]. The operational interpreter of the language is specified by binary relations between SOOP terms in memory environments, which represent the notion of computation.
Reference: [GJ90] <author> J. Graver and R. Johnson. </author> <title> A type system for Smalltalk. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <year> 1990. </year>
Reference-contexts: One measure of the complexity of that type system is that it cannot be given meaning in second-order logic, whereas the language we study has a semantics expressible in Peano Arithmetic. Some other type-safe systems have been designed that are not based on F-bounded polymor-phism <ref> [GJ90, SCB + 86] </ref>, but these require method bodies to be re-type checked when subclasses are defined. In a language supporting first-class class definitions, in which classes may be extended dynamically, this re-checking needs to be performed during program execution and type-checking of programs becomes essentially a run-time task.
Reference: [Hen91] <author> A. V. Hense. </author> <title> Wrapper semantics of an object-oriented programming language with state. </title> <booktitle> In Proceedings of the International Conference on Theoretical Aspects of Computer Software, volume 526 of Lecture notes in Computer Science, </booktitle> <pages> pages 548-567. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: However, creating cells in the record fields above would cause new cells to be allocated at each unrolling of the fixed point, i.e. at each access of m to "self." Two approaches to solving this problem are discussed in <ref> [Hen91] </ref>; the one for which the author gives a denotational semantics is based on the interpretation of the fixed points of class functions as state transformers. <p> ()) jgjg in let p1 = (let s be SAR to Point2 s).meth in let p2 = (let s be SAR to Point2 s).meth in p1.align2 p2 6 Conclusions We give an operational interpretation of an object-oriented language with mutable instance variables, similar in flavor to the "wrapper semantics" of <ref> [CP89, Hen91] </ref>, but in a strongly typed framework. This requires the solution of two basic semantic problems: avoiding the reallocation of instance variable cells resulting from an object's self-reference (in the fixed point encoding), and the type-correct extension of classes (based on the subtyping relation between object types).
Reference: [Lan64] <author> P. J. Landin. </author> <title> The mechanical evaluation of expressions. </title> <journal> Computer Journal, </journal> <volume> 6 </volume> <pages> 308-320, </pages> <year> 1964. </year>
Reference-contexts: Our solution is to define a fixed point combinator in terms of mutable cells, in the spirit of Landin's suggestion <ref> [Lan64] </ref>. Operationally it is equivalent to Y r = f: let r = ref null in (set (r; f (r)); ! r) where null is a "dummy" initial value, and set (r; v) and ! r are the assignment to and dereferencing of the mutable cell r.
Reference: [Mit90] <author> J. Mitchell. </author> <title> Towards a typed foundation for method specialization and inheritence. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1990. </year>
Reference-contexts: 1 Introduction Giving full and faithful meaning to typed object-oriented programming languages is a well-known research problem. There has been considerable recent activity in defining powerful type systems for OOP <ref> [CHC90, CCH + 89, BM92, Bru93, Mit90, PT93] </ref>. These approaches have a natural model in F ! and admit a very powerful type theory utilizing F-bounded quantification. One major shortcoming of all these approaches is they take a functional view of objects.
Reference: [MT91] <author> I. A. Mason and C. L. Talcott. </author> <title> Equivalence in functional languages with effects. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 287-327, </pages> <year> 1991. </year>
Reference-contexts: e : t SAR (Deref) ` e : t Ref (Select) ` e : fjl : t jg (Record) ` e i : t i for all i 2 f1; : : : ; mg 4.1 Operational Interpreter for SOOP We give semantics of SOOP in the general framework of <ref> [FH92, MT91] </ref> developed further in [CF91, WF91]. The operational interpreter of the language is specified by binary relations between SOOP terms in memory environments, which represent the notion of computation.
Reference: [Pie92] <author> B. Pierce. </author> <title> Bounded quantification is undecidible. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 305-315, </pages> <year> 1992. </year>
Reference-contexts: Subtyping in SOOP is the standard record subsumption model following Cardelli [Car84]. Since many real-world OOP languages enforce this criterion, it is not wholly unreasonable, and may ultimately prove the most tractable approach if the type-checking and type-inference problems of F-bounded polymorphism prove intractable <ref> [Pie92] </ref>. We define a translation of any typed LOOP program into a typed SOOP program, and together with a proof of the type soundness of SOOP this gives us type soundness and lack of run-time type errors for LOOP.
Reference: [PT93] <author> B. Pierce and D. N. Turner. </author> <title> Object-oriented programming without recursive types. </title> <booktitle> In Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 299-312, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Giving full and faithful meaning to typed object-oriented programming languages is a well-known research problem. There has been considerable recent activity in defining powerful type systems for OOP <ref> [CHC90, CCH + 89, BM92, Bru93, Mit90, PT93] </ref>. These approaches have a natural model in F ! and admit a very powerful type theory utilizing F-bounded quantification. One major shortcoming of all these approaches is they take a functional view of objects. <p> Observe that the align and align2 methods may be typed in our language even though they may take objects of their own class as arguments. Simulating this program in a functional interpretation of OOP such as <ref> [Bru93, PT93] </ref> requires an explicit threading of state in some fashion. In particular, align2 modifies the state of its argument object while executing. <p> In purely functional languages this encoding produces perfectly adequate results, but the situation changes with the introduction of effects and the natural for them (though not intrinsic [CF91]) call-by-value semantics. As pointed out in <ref> [Wan89, CHC90, PT93] </ref> the fixed point combinator is then only well-defined on functionals, and classes do not correspond to functionals.
Reference: [Red88] <author> U. S. Reddy. </author> <title> Objects as closures: Abstract semantics of object-oriented languages. </title> <booktitle> In Proceeding of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 289-297, </pages> <year> 1988. </year>
Reference-contexts: This new construct is not strictly necessary, but we argue why it is more useful to have it than to suffer the consequences of its absence. The translation of expressions is similar to other interpretations of records as objects developed for untyped OOP <ref> [CP89, Red88] </ref>. The main difference is use of the single assignment reference in fl Partially supported by NSF grant CCR-9109070 y Authors' email addresses: eifrig@cs.jhu.edu, scott@cs.jhu.edu, trifonov@cs.jhu.edu, amy@cs.jhu.edu 1 place of the Y -combinator to avoid copying of code. <p> The only significant departure from standard notions is the single-assignment reference (SAR) cell, which allows for a natural and type-sound interpretation of objects in the presence of effects. In standard encodings of object-oriented languages <ref> [CP89, Red88] </ref> an object is formed by taking a fixed point of a function that represents its class, referred to below as the "class function." This results in a recursive record, and the methods of the object|fields of the record|gain access to its "self" by unrolling the fixed point expression.
Reference: [SCB + 86] <author> C. Schaffert, T. Cooper, B. Bullis, M. Kilian, and C. Wilpolt. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In Proceedings of OOPSLA Conference, </booktitle> <pages> pages 9-16, </pages> <year> 1986. </year>
Reference-contexts: One measure of the complexity of that type system is that it cannot be given meaning in second-order logic, whereas the language we study has a semantics expressible in Peano Arithmetic. Some other type-safe systems have been designed that are not based on F-bounded polymor-phism <ref> [GJ90, SCB + 86] </ref>, but these require method bodies to be re-type checked when subclasses are defined. In a language supporting first-class class definitions, in which classes may be extended dynamically, this re-checking needs to be performed during program execution and type-checking of programs becomes essentially a run-time task.
Reference: [Wad92] <author> P. Wadler. </author> <title> The essence of functional programming. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <year> 1992. </year>
Reference-contexts: This property of the SOOP operational interpreter is similar to the detection of "black holes" by some interpreters for lazy languages <ref> [Wad92] </ref>. 3.1 SOOP Syntax Let x range over the countable set of variables Var and l range over the countable set of labels Lab.
Reference: [Wan89] <author> Mitchell Wand. </author> <title> Type inference for record concatenation and multiple inheritance. </title> <booktitle> In Proceedings of the Fourth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 92-97. </pages> <publisher> IEEE, </publisher> <year> 1989. </year>
Reference-contexts: In purely functional languages this encoding produces perfectly adequate results, but the situation changes with the introduction of effects and the natural for them (though not intrinsic [CF91]) call-by-value semantics. As pointed out in <ref> [Wan89, CHC90, PT93] </ref> the fixed point combinator is then only well-defined on functionals, and classes do not correspond to functionals.
Reference: [WF91] <author> A. Wright and M. Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report TR91-160, </type> <institution> Rice University Department of Computer Science, </institution> <year> 1991. </year> <note> (revised June 1992). </note>
Reference-contexts: ` e : t Ref (Select) ` e : fjl : t jg (Record) ` e i : t i for all i 2 f1; : : : ; mg 4.1 Operational Interpreter for SOOP We give semantics of SOOP in the general framework of [FH92, MT91] developed further in <ref> [CF91, WF91] </ref>. The operational interpreter of the language is specified by binary relations between SOOP terms in memory environments, which represent the notion of computation. <p> The operational interpreter of the language is specified by binary relations between SOOP terms in memory environments, which represent the notion of computation. As in <ref> [WF91] </ref> the memory is not treated as a syntactic context but instead as a function defined on variables, because the let x be SAR to e construct cannot be represented as a pair of independent allocation and assignment without loss of type soundness, and therefore a memory context may need more
References-found: 20

