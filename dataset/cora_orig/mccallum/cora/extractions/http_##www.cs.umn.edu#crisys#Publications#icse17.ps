URL: http://www.cs.umn.edu/crisys/Publications/icse17.ps
Refering-URL: http://www.cs.umn.edu/crisys/pubs.htm
Root-URL: http://www.cs.umn.edu
Title: Completeness and Consistency Analysis of State-Based Requirements  
Author: Mats P.E. Heimdahl Nancy G. Leveson 
Affiliation: Michigan State University  University of Washington  
Abstract: This paper describes methods for automatically analyzing formal, state-based requirements specifications for completeness and consistency. The approach uses a low-level functional formalism, simplifying the analysis process. State space explosion problems are eliminated by applying the analysis at a high level of abstraction; i.e, instead of generating a reachability graph for analysis, the analysis is performed directly on the model. The method scales up to large systems by decomposing the specification into smaller, analyzable parts and then using functional composition rules to ensure that verified properties hold for the entire specification. The analysis algorithms and tools have been validated on TCAS II, a complex, airborne, collision-avoidance system required on all commercial aircraft with more than 30 passengers that fly in U.S. airspace.
Abstract-found: 1
Intro-found: 1
Reference: [AG91] <author> J. Atlee and J. Gannon. </author> <title> State-based model checking of event-driven system requirements. </title> <booktitle> In Proceedings of the ACM SIGSOFT '91 Conference on Software for Critical Systems. Software Engineering Notes. </booktitle> <volume> Volume 16 Number 5, </volume> <year> 1991. </year>
Reference-contexts: Reachability analysis relies on generation of a global reachability graph, quickly running into state-space explosion problems. Model checking is conceptually simple and can be applied to a wide variety of languages and application areas <ref> [CBES85, CES86, AG91] </ref>. However, since model checking relies on a global reachability graph, it also suffers from state-space explosion problems. Model checking has been applied to large models [BCM + 90], but only for systems with simple, repetitive elements|more commonly found in hardware than in software.
Reference: [BCM + 90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: Model checking is conceptually simple and can be applied to a wide variety of languages and application areas [CBES85, CES86, AG91]. However, since model checking relies on a global reachability graph, it also suffers from state-space explosion problems. Model checking has been applied to large models <ref> [BCM + 90] </ref>, but only for systems with simple, repetitive elements|more commonly found in hardware than in software. Model checkers are currently unable to handle a specification as complex as our TCAS II requirements specification.
Reference: [BGFG86] <author> G. R. Bruns, S. L. Gerhart, I. Forman, and M. Graf. </author> <title> Design technology assessment: The statecharts approach. </title> <type> Technical Report STP-107-86, </type> <institution> MCC, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: The guarding condition defines what must be true before the transition can be taken and is specified using AND/OR tables, described below. Output actions identify events that are generated when the transition is taken. AND/OR Tables. Statecharts use predicate calculus to describe the guarding conditions on the transitions <ref> [BGFG86, Har87] </ref>. Our TCAS external reviewers (including avionics engineers, component engineers, airline representatives, and pilots), however, did not find this notation natural or reviewable.
Reference: [Bry86] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: Our analysis tools use Binary Decision Diagrams (BDDs) <ref> [Bry86] </ref> for the manipulation of the conditions. BDDs are data structures used to represent boolean functions in a canonical form. With BDDs Boolean formula manipulation can be performed in time linear to the size of the BDD structure.
Reference: [CBES85] <author> E. M. Clarke, M. C. Browne, E. A. Emerson, and A. P. Sistla. </author> <title> Using temporal logic for automatic verification of finite state systems. </title> <editor> In K.R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, </booktitle> <pages> pages 3-26. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: Reachability analysis relies on generation of a global reachability graph, quickly running into state-space explosion problems. Model checking is conceptually simple and can be applied to a wide variety of languages and application areas <ref> [CBES85, CES86, AG91] </ref>. However, since model checking relies on a global reachability graph, it also suffers from state-space explosion problems. Model checking has been applied to large models [BCM + 90], but only for systems with simple, repetitive elements|more commonly found in hardware than in software.
Reference: [CES86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic. </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Reachability analysis relies on generation of a global reachability graph, quickly running into state-space explosion problems. Model checking is conceptually simple and can be applied to a wide variety of languages and application areas <ref> [CBES85, CES86, AG91] </ref>. However, since model checking relies on a global reachability graph, it also suffers from state-space explosion problems. Model checking has been applied to large models [BCM + 90], but only for systems with simple, repetitive elements|more commonly found in hardware than in software.
Reference: [GHP92] <author> Patrice Godefroid, Gerhard J. Holzmann, and Dieder Pirottin. </author> <title> State space caching revisited. </title> <booktitle> In Proceedings of the Fourth Workshop on Computer-Aided Verification, </booktitle> <pages> pages 175-186, </pages> <year> 1992. </year>
Reference-contexts: Also, formal proofs are notoriously difficult to perform and there is reason to doubt that they will scale up to complex systems. Reachability analysis of the global state space has been successfully used in the analysis of communication protocol specifications <ref> [Hol85, Hol87, GHP92] </ref>. Reachability analysis relies on generation of a global reachability graph, quickly running into state-space explosion problems. Model checking is conceptually simple and can be applied to a wide variety of languages and application areas [CBES85, CES86, AG91].
Reference: [Har87] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: Examples of the application of the automated analysis to TCAS II are provided. 2 The RSML Language RSML is in many aspects similar to Statecharts by David Harel <ref> [HP85, Har87] </ref>. Stat-echarts are finite state machines augmented with hierarchy, parallelism, and modularity. 2 RSML borrows the notions of superstates, AND decomposition, broadcast communication, statecharts arrays, and conditional connectives from Statecharts. <p> The guarding condition defines what must be true before the transition can be taken and is specified using AND/OR tables, described below. Output actions identify events that are generated when the transition is taken. AND/OR Tables. Statecharts use predicate calculus to describe the guarding conditions on the transitions <ref> [BGFG86, Har87] </ref>. Our TCAS external reviewers (including avionics engineers, component engineers, airline representatives, and pilots), however, did not find this notation natural or reviewable. <p> A column evaluates to true if all of its elements are true. A dot denotes "don't care." 3 A Functional Framework The hierarchical and parallel structure of the finite state machines used in RSML has been formally described by David Harel in his work on HiGraphs and Statecharts <ref> [HP85, Har87, Har88] </ref>. The definitions of the structure of the state machines used in RSML are identical to Statecharts. The dynamic behavior of RSML, however, is defined in a significantly different 4 Transition (s): ESL-4 ! ESL-2 Location: Own-Aircraft .
Reference: [Har88] <author> D. Harel. </author> <title> On visual formalisms. </title> <journal> Communications of the ACM, </journal> <volume> 31(5) </volume> <pages> 514-530, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: A column evaluates to true if all of its elements are true. A dot denotes "don't care." 3 A Functional Framework The hierarchical and parallel structure of the finite state machines used in RSML has been formally described by David Harel in his work on HiGraphs and Statecharts <ref> [HP85, Har87, Har88] </ref>. The definitions of the structure of the state machines used in RSML are identical to Statecharts. The dynamic behavior of RSML, however, is defined in a significantly different 4 Transition (s): ESL-4 ! ESL-2 Location: Own-Aircraft .
Reference: [Hei94] <author> Mats P. E. Heimdahl. </author> <title> Static Analysis of State Based Requirements: Analysis for Internal Completeness. </title> <type> PhD thesis, </type> <institution> University of California, Irvine, </institution> <year> 1994. </year>
Reference-contexts: In Statecharts, an action and the event causing the action are considered to occur at the same instant in time, potentially allowing a reversal of their causal ordering. RSML enforces a more rigorous causal ordering of event action pairs <ref> [LHHR94, Hei94] </ref>. The rest of this section gives a short introduction to RSML and outlines how the formal semantics can be described as functions and compositions of functions. For a complete description of the RSML notation and semantics the reader is referred to [LHHR94, Hei94]. Superstates. <p> rigorous causal ordering of event action pairs <ref> [LHHR94, Hei94] </ref>. The rest of this section gives a short introduction to RSML and outlines how the formal semantics can be described as functions and compositions of functions. For a complete description of the RSML notation and semantics the reader is referred to [LHHR94, Hei94]. Superstates. In Statecharts (and RSML), states may be grouped into superstates (see Fig. 1). Such groupings reduce the number of transitions by allowing transitions to and from the superstate rather than requiring explicit transitions to and from all of the grouped states (substates). <p> Thus, the complete behavior of a model, including parallelism and event propagation, can be modeled with functional composition. A formal definition of the complete set of rules for composition can be found in <ref> [Hei94] </ref>. 4 Analysis Approach If the relation F defining the dynamic behavior of the model is a function, then completeness, consistency, and determinism are assured. <p> Fortunately, the number of parallel transitions in real systems seems to be fairly limited, and this straight forward approach has been shown to be adequate to analyze a major part of a large real life system (TCAS II) for determinism <ref> [Hei94] </ref>. 4.1 Summary The algorithms outlined above all have high worst-case complexity. For example, checking the union compositions is exponential with respect to the size of the guarding conditions, and checking determinism is O (n 2 ) with respect to the number of parallel transitions.
Reference: [Hol85] <author> Gerhard J. Holzmann. </author> <title> Tracing protocols. </title> <journal> AT& T Technical Journal, </journal> <volume> 64(10), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: Also, formal proofs are notoriously difficult to perform and there is reason to doubt that they will scale up to complex systems. Reachability analysis of the global state space has been successfully used in the analysis of communication protocol specifications <ref> [Hol85, Hol87, GHP92] </ref>. Reachability analysis relies on generation of a global reachability graph, quickly running into state-space explosion problems. Model checking is conceptually simple and can be applied to a wide variety of languages and application areas [CBES85, CES86, AG91].
Reference: [Hol87] <author> Gerhard J. Holzmann. </author> <title> Automated protocol validation in Argos: Assertion proving and scatter searching. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(6) </volume> <pages> 683-696, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Also, formal proofs are notoriously difficult to perform and there is reason to doubt that they will scale up to complex systems. Reachability analysis of the global state space has been successfully used in the analysis of communication protocol specifications <ref> [Hol85, Hol87, GHP92] </ref>. Reachability analysis relies on generation of a global reachability graph, quickly running into state-space explosion problems. Model checking is conceptually simple and can be applied to a wide variety of languages and application areas [CBES85, CES86, AG91].
Reference: [HP85] <author> D. Harel and A. Pnueli. </author> <title> On the development of reactive systems. </title> <editor> In K.R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, </booktitle> <pages> pages 477-498. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <month> 20 </month>
Reference-contexts: RSM, the underlying formal model on which the analysis criteria were defined, has few of the desirable characteristics of a requirements specification language. To solve this problem, a higher-level language (RSML), using some of the features of Statecharts <ref> [HP85] </ref>, was developed. To ensure that the formal RSML specification language and the associated analysis algorithms and tools were appropriate for large and realistic systems, a testbed specification was developed for TCAS II [LHHR]. <p> Examples of the application of the automated analysis to TCAS II are provided. 2 The RSML Language RSML is in many aspects similar to Statecharts by David Harel <ref> [HP85, Har87] </ref>. Stat-echarts are finite state machines augmented with hierarchy, parallelism, and modularity. 2 RSML borrows the notions of superstates, AND decomposition, broadcast communication, statecharts arrays, and conditional connectives from Statecharts. <p> A column evaluates to true if all of its elements are true. A dot denotes "don't care." 3 A Functional Framework The hierarchical and parallel structure of the finite state machines used in RSML has been formally described by David Harel in his work on HiGraphs and Statecharts <ref> [HP85, Har87, Har88] </ref>. The definitions of the structure of the state machines used in RSML are identical to Statecharts. The dynamic behavior of RSML, however, is defined in a significantly different 4 Transition (s): ESL-4 ! ESL-2 Location: Own-Aircraft .
Reference: [JLHM91] <author> M. S. Jaffe, N. G. Leveson, M. P. E. Heimdahl, and B. Melhart. </author> <title> Software requirements analysis for real-time process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(3), </volume> <month> March </month> <year> 1991. </year>
Reference-contexts: Completeness in this context is defined as a complete set of requirements, i.e., there is a behavior specified for every possible input and input sequence. Previously, we defined formal criteria for requirements completeness and safety using a simple Mealy-machine model called RSM (Requirements State Machine) <ref> [JLHM91] </ref>. To be useful, these criteria need to be translated into analysis procedures that can be applied to real specification languages. In addition, the analysis needs to be efficient enough to scale-up and be applicable to real system descriptions. <p> However, in critical systems it is undesirable to leave behavior underspecified. In <ref> [JLHM91] </ref> we define requirements completeness as the specification being sufficient to distinguish the behavior of the desired software from that of any other, undesired program that might be designed. Nondeterministic specifications often hide dangerous incompleteness in this sense. <p> As was mentioned in section 3 we view nondeterminism as conflicting requirements that should be eliminated. This is the basis of our previous definition of the criteria for a complete specification <ref> [JLHM91] </ref> which we believe are important in critical systems. In this case, the nondeterminism could have a negative effect on safety. 16 Transition (s): ESL-4 ! ESL-5 Location: Own-Aircraft .
Reference: [LHHR] <author> N. G. Leveson, M. Heimdahl, H. Hildreth, and J. Reese. </author> <title> TCAS II requirements specification. </title>
Reference-contexts: To solve this problem, a higher-level language (RSML), using some of the features of Statecharts [HP85], was developed. To ensure that the formal RSML specification language and the associated analysis algorithms and tools were appropriate for large and realistic systems, a testbed specification was developed for TCAS II <ref> [LHHR] </ref>. The testbed is currently being used to develop and validate various types of analysis algorithms and tools on the underlying formal model. <p> Although the TCAS specification effort was originally planned to be experimental only, the government/industry groups responsible for TCAS II liked RSML so much that the specification was adopted as the official FAA TCAS II Requirements Specification <ref> [LHHR] </ref>. As a result, our initial specification was subjected to an extensive (and expensive) independent verification and validation (IV&V) effort. We have applied the analysis techniques described in this paper to major parts of the TCAS II requirements specification.
Reference: [LHHR94] <author> N. G. Leveson, M.P.E. Heimdahl, H. Hildreth, and J.D. Reese. </author> <title> Requirements specification for process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <note> (To Appear), </note> <year> 1994. </year>
Reference-contexts: Although the approach outlined here could be applied to many state-based languages, we demonstrate it using a requirements specification language called RSML (Requirements State Machine Language), which was developed by the Irvine Safety Research Group using a real aircraft collision-avoidance system called TCAS II as a testbed <ref> [LHHR94] </ref>. RSM, the underlying formal model on which the analysis criteria were defined, has few of the desirable characteristics of a requirements specification language. To solve this problem, a higher-level language (RSML), using some of the features of Statecharts [HP85], was developed. <p> In Statecharts, an action and the event causing the action are considered to occur at the same instant in time, potentially allowing a reversal of their causal ordering. RSML enforces a more rigorous causal ordering of event action pairs <ref> [LHHR94, Hei94] </ref>. The rest of this section gives a short introduction to RSML and outlines how the formal semantics can be described as functions and compositions of functions. For a complete description of the RSML notation and semantics the reader is referred to [LHHR94, Hei94]. Superstates. <p> rigorous causal ordering of event action pairs <ref> [LHHR94, Hei94] </ref>. The rest of this section gives a short introduction to RSML and outlines how the formal semantics can be described as functions and compositions of functions. For a complete description of the RSML notation and semantics the reader is referred to [LHHR94, Hei94]. Superstates. In Statecharts (and RSML), states may be grouped into superstates (see Fig. 1). Such groupings reduce the number of transitions by allowing transitions to and from the superstate rather than requiring explicit transitions to and from all of the grouped states (substates). <p> Although the syntax of parallel states is the same in both Statecharts and RSML, the semantic definition has been changed to address the issue of causal ordering mentioned above (see <ref> [LHHR94] </ref> for a complete comparison). Transition Definitions. Transition definitions in RSML contain five parts: (1) the identification (the source and destination of the transition), (2) the location, (3) the triggering event, (4) the guarding condition, and (5) the output action.
Reference: [PS89] <author> A. Pnueli and M. Shalev. </author> <title> What is in a step? In J. </title> <editor> Klop, J. Meijer, and J. Rutten, editors, J.W. De Baker, </editor> <booktitle> Liber Amicorum, </booktitle> <pages> pages 373-400. </pages> <address> CWI Am-sterdam, </address> <year> 1989. </year>
Reference-contexts: The semantics of Statecharts is defined with an operational model. An algorithm defines how the next state is calculated from the current state and external input <ref> [PS89] </ref>. On the other hand, the definition of RSML uses mathematical functions and functional composition to define the semantics. This approach introduces compositionality in the language and simplifies the algorithms used to check for completeness and consistency.
Reference: [RR90] <author> H. Richel and A. P. Ravn. </author> <title> Requirements capture for computer based systems. </title> <type> Technical Report ID/DTH HR 2/2, </type> <institution> Technical University of Denmark, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: In addition, the analysis needs to be efficient enough to scale-up and be applicable to real system descriptions. Other approaches to requirements analysis include methods based on process algebras, e.g., ProCoS <ref> [RR90, RR91] </ref>, reachability analysis, and model checking. Process algebras fl To Appear in the Proceedings of the 17th International Conference on Software Engineering, Seattle, April 1995. 1 are powerful tools suitable for formal proofs.
Reference: [RR91] <author> A. P. Ravn and H. Richel. </author> <title> Requirements capture for embedded real-time systems. </title> <booktitle> In IMACS Symposium MCTS, </booktitle> <year> 1991. </year> <month> 21 </month>
Reference-contexts: In addition, the analysis needs to be efficient enough to scale-up and be applicable to real system descriptions. Other approaches to requirements analysis include methods based on process algebras, e.g., ProCoS <ref> [RR90, RR91] </ref>, reachability analysis, and model checking. Process algebras fl To Appear in the Proceedings of the 17th International Conference on Software Engineering, Seattle, April 1995. 1 are powerful tools suitable for formal proofs.
References-found: 19

