URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3274/3274.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: frich,sshong,manasg@cs.umd.edu  
Phone: (301) 405-2710  
Title: Guaranteeing End-to-End Timing Constraints by Calibrating Intermediate Processes  
Author: Richard Gerber, Seongsoo Hong and Manas Saksena 
Date: 1994  
Address: College Park, MD 20742  
Affiliation: Department of Computer Science University of Maryland  
Note: To appear in 1994 IEEE Real-Time Systems Symposium.  May  This research is supported in part by ONR grant N00014-94-10228, NSF grant CCR-9209333, an NSF Young Investigator Award CCR-9357850 and ONR/ARPA contract N00014-91-C-0195.  
Abstract: University of Maryland Technical Report UMD CS-TR-3274, UMIACS-TR-94-58 Abstract This paper presents a comprehensive design methodology for guaranteeing end-to-end requirements of real-time systems. Applications are structured as a set of process components connected by asynchronous channels, in which the endpoints are the system's external inputs and outputs. Timing constraints are then postulated between these inputs and outputs; they express properties such as end-to-end propagation delay, temporal input-sampling correlation, and allowable separation times between updated output values. The automated design method works as follows: First the end-to-end requirements are transformed into a set of intermediate rate constraints on the tasks, and new tasks are created to correlate related inputs. The intermediate constraints are then solved by an optimization algorithm, whose objective is to minimize CPU utilization. If the algorithm fails, a restructuring tool attempts to eliminate bottlenecks by transforming the application, which is then re-submitted into the assignment algorithm. The final result is a schedulable set of fully periodic tasks, which collaboratively maintain the end-to-end constraints. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison Wesley Publishing Company, </publisher> <year> 1986. </year>
Reference-contexts: Since t 0 p only serves t c2 , we can eliminate all operations that only contribute to the output for t c1 . This is done by a compiler technique called dead code elimination <ref> [1] </ref>. The same specialization is done for t p . 6 Step 4: Buffer Allocation Buffer allocation is the final step of our approach, and hence applied to the feasible task graph whose timing characteristics are completely derived.
Reference: [2] <author> R. Alur, C. Courcoubetis, and D. Dill. </author> <title> Model-Checking for Real-Time Systems. </title> <booktitle> In Proc. of IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1990. </year>
Reference: [3] <author> N. C. Audsley, A. Burns, M. F. Richardson, and A. J. Wellings. </author> <title> Hard Real-Time Scheduling: The Deadline Monotonic Approach. </title> <booktitle> In Proceedings Eighth IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 133-137, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: However, for the sake of simplicity we may assume an underlying static priority architecture. Static priority scheduling has been shown to be applicable to a number of variants of the periodic tasking model, such as 6 pre-period deadlines <ref> [3] </ref>, precedence constrained sub-tasks [9], offsets [13] etc. A good overview to static priority scheduling may be found in [6]. Thus we focus our efforts on the correctness and feasibility problems. <p> This is easily achieved by setting the offset of the consumer task equal to the offset of the producer task. Normally, this priority assumption is fine, since the deadline of the consumer task is higher than the producer, and should be assigned lower priority <ref> [3] </ref>. However, this is not desirable if the consumer task already has an offset requirement (e.g., due to separation constraints). In this case, the consumer task may have a smaller window of execution, and thus, a lower priority for it may not be the correct choice.
Reference: [4] <author> N. C. Audsley, A. Burns, M. F. Richardson, and A. J. Wellings. </author> <title> Data consistency in hard real-time systems. </title> <type> Technical Report YCS 203 (1993), </type> <institution> Department of Computer Science, University of York, </institution> <address> England, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Related Work. This research was, in large part, inspired by the real-time transaction model proposed by Burns et. al. in <ref> [4] </ref>. While the model was formulated to express database applications, it can easily incorporate variants of our freshness and correlation constraints. In the analogue to freshness, a persistent object has "absolute consistency within t" when it corresponds to real-world samples taken within maximum drift of t.
Reference: [5] <author> G. Berry, Sabie Moisan, and Jean-Paul Rigault. ESTEREL: </author> <title> Towards a synchronous and semantically sound high level language for real time applications. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 30-37. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1983. </year>
Reference-contexts: Moreover, we note that our timing constraints define a system driven by time and output requirements. This is in contrast to reactive paradigms such ESTEREL <ref> [5] </ref>, which are input-driven. Analogous to the "conceptual infinite buffering" assumptions, the rate assignment algorithm assumes that the external inputs are always fresh and available. The derived input-sampling rates then determine the true requirements on input-availability.
Reference: [6] <author> Alan Burns. </author> <title> Preemptive priority based scheduling: An appropriate engineering approach. In Sang Son, editor, </title> <booktitle> Principles of Real-Time Systems. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1994. </year> <month> 21 </month>
Reference-contexts: Static priority scheduling has been shown to be applicable to a number of variants of the periodic tasking model, such as 6 pre-period deadlines [3], precedence constrained sub-tasks [9], offsets [13] etc. A good overview to static priority scheduling may be found in <ref> [6] </ref>. Thus we focus our efforts on the correctness and feasibility problems. This is done in a four-step process, as shown in Figure 2: First the rate-based, intermediate constraints are derived, which may require creating new tasks to get tightly correlated inputs into the system.
Reference: [7] <author> G. B. Dantzig and B. C. Eaves. </author> <title> Fourier-Motzkin Elimination and its Dual. </title> <journal> Journal of Com--binatorial Theory (A), </journal> <volume> 14 </volume> <pages> 288-297, </pages> <year> 1973. </year>
Reference-contexts: An outline of our solution strategy is presented in offsets and deadlines are presented in the following subsections. 4.1 Elimination of Offset and Deadline Variables We use an extension of Fourier-Motzkin variable elimination <ref> [7] </ref> to simplify our system of constraints. The Fourier Motzkin variable elimination is a linear programming technique which eliminates a variable from a set of linear constraints.
Reference: [8] <author> R. Gerber and S. Hong. </author> <title> Semantics-based compiler transformations for enhanced schedulability. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 232-242. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1993. </year>
Reference-contexts: Also, we can harness finer-grained compiler transformations such as program slicing to help transform tasks into read-compute-write-compute phases, which will even further enhance schedulability. We have used this approach in a real-time compiler tool <ref> [8] </ref>, and there is reason to believe that its use would be even more effective here. Finally, perhaps the greatest challenge lies in incorporating scheduling decisions into the constraint solver. We believe such policy-specific strategies can be used to significantly help in pruning the search space.
Reference: [9] <author> M. G. Harbour, M. H. Klein, and J. P. Lehoczky. </author> <title> Fixed Priority Scheduling of Periodic Tasks with Varying Execution Priority. </title> <booktitle> In Proceedings, IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 116-128, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: However, for the sake of simplicity we may assume an underlying static priority architecture. Static priority scheduling has been shown to be applicable to a number of variants of the periodic tasking model, such as 6 pre-period deadlines [3], precedence constrained sub-tasks <ref> [9] </ref>, offsets [13] etc. A good overview to static priority scheduling may be found in [6]. Thus we focus our efforts on the correctness and feasibility problems.
Reference: [10] <author> F. Jahanian and A.K. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(9):890-904, </volume> <month> September </month> <year> 1986. </year>
Reference-contexts: Schedulability: There is a scheduling algorithm which can efficiently maintain the intermediate constraints C, and preserve feasibility. In the problem we are addressing, the three issues cannot be decoupled. Correctness, for example, is often treated as verification problem using a logic such as RTL <ref> [10] </ref>.
Reference: [11] <author> Kevin Jeffay. </author> <title> The real-time producer/consumer paradigm: A paradigm for the construction of efficient, predictable real-time systems. </title> <booktitle> In ACM/SIGAPP Symposium on Applied Computing, </booktitle> <pages> pages 796-804. </pages> <publisher> ACM Press, </publisher> <month> February </month> <year> 1983. </year>
Reference-contexts: We also present a period assignment problem which is optimal though quite expensive in the worst case. 3 This work was also influenced by Jeffay's "real-time producer/consumer model" <ref> [11] </ref>, which possesses a task-graph structure similar to ours.
Reference: [12] <author> M. Klein, J. Lehoczky, and R. Rajkumar. </author> <title> Rate-monotonic analysis for real-time industrial computing. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 24-33, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Klein et. al. surveys the current engineering practice used in developing industrial real-time systems <ref> [12] </ref>. As is stressed, the intermediate constraints should be primarily a function of the end-to-end constraints, but should, if possible, take into account a sound real-time scheduling techniques. At this point, however, the "state-of-the-art" is the practice of trial and error, as guided by engineering experience.
Reference: [13] <author> K. W. Tindell. </author> <title> Using offset information to analyse static priority pre-emptively scheduled task sets. </title> <type> Technical Report YCS 182 (1992), </type> <institution> Department of Computer Science, University of York, </institution> <address> England, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: However, for the sake of simplicity we may assume an underlying static priority architecture. Static priority scheduling has been shown to be applicable to a number of variants of the periodic tasking model, such as 6 pre-period deadlines [3], precedence constrained sub-tasks [9], offsets <ref> [13] </ref> etc. A good overview to static priority scheduling may be found in [6]. Thus we focus our efforts on the correctness and feasibility problems. <p> While the variable elimination method ensures that a feasible solution exists, we need to find a solution which maximizes schedulability. However, this is not easily achievable since no simple analytic solutions exist when tasks have both offsets and deadlines <ref> [13] </ref>. The variable elimination method allows us to select values for the variables in the reverse order in which they are eliminated. Suppose we eliminate variables [x 1 ; x 2 ; : : :; x n ] from a system of constraints in this order.
Reference: [14] <author> Jia Xu and David Parnas. </author> <title> Scheduling processes with release times, deadlines, precedence and exclusion relations. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 360-369, </pages> <month> March </month> <year> 1990. </year> <month> 22 </month>
Reference-contexts: The periods, deadlines and offsets make up constraint set C. The problem of scheduling a set of periodic real-time tasks on a single processor CPU has been studied for many years. Such a tasking model can be used to construct static calendar based schedules (e.g., <ref> [14] </ref>), or analyzed under a static preemptive priority scheme for schedulability. Our discussion for most part is independent of the underlying scheduling scheme. However, for the sake of simplicity we may assume an underlying static priority architecture.
References-found: 14

