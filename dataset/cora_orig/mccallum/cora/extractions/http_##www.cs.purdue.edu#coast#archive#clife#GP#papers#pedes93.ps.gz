URL: http://www.cs.purdue.edu/coast/archive/clife/GP/papers/pedes93.ps.gz
Refering-URL: http://www.cs.purdue.edu/coast/archive/clife/GP/papers/
Root-URL: http://www.cs.purdue.edu
Title: Genetic Programming for Pedestrians  
Author: Wolfgang Banzhaf 
Address: Germany  
Affiliation: Systems Analysis Research Group, LSXI Department of Computer Science University of Dortmund  
Abstract: We propose an extension to the Genetic Programming paradigm which allows users of traditional Genetic Algorithms to evolve computer programs. To this end, we have to introduce mechanisms like transscription, editing and repairing into Genetic Programming. We demonstrate the feasibility of the approach by using it to develop programs for the prediction of sequences of integer numbers.
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> Langton, C.G., (ed.), </editor> <booktitle> Artificial Life, Santa Fe Institute Studies on the Sciences of Complexity, Proc. Vol. VI, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989 </year>
Reference-contexts: The area develops into two different directions: One is the study of artificial ecologies, where computer programs compete for access to resources inside the computer, like CPU-time or memory space. This area has also been dubbed "Artificial Life" <ref> [1, 2] </ref> and leads to rich emergent phenomena, like parasitism, symbiosis, arms races between different software species. The other direction is the study of systems which evolve according to user defined behavior. This area is generally known as genetic or evolutionary programming [3, 4].
Reference: [2] <author> Ray, </author> <title> T.S. Is it alive or is it GA? Proc. </title> <booktitle> 3rd Int. Conf. on Genetic Algorithms, </booktitle> <address> San Diego, </address> <year> 1991, </year> <editor> Belew, R.K. and Booker, L.B. (Eds.), </editor> <publisher> Morgan Kauffman, </publisher> <address> San Mateo, </address> <year> 1991, </year> <note> p. 527 </note>
Reference-contexts: The area develops into two different directions: One is the study of artificial ecologies, where computer programs compete for access to resources inside the computer, like CPU-time or memory space. This area has also been dubbed "Artificial Life" <ref> [1, 2] </ref> and leads to rich emergent phenomena, like parasitism, symbiosis, arms races between different software species. The other direction is the study of systems which evolve according to user defined behavior. This area is generally known as genetic or evolutionary programming [3, 4].
Reference: [3] <editor> Koza, J.R., </editor> <booktitle> Genetic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1992 </year>
Reference-contexts: The other direction is the study of systems which evolve according to user defined behavior. This area is generally known as genetic or evolutionary programming <ref> [3, 4] </ref>. In the latter approach, one applies a sort of symbolic GA with the symbols being chosen from a set of functions and terminals. From the set of accessible functions and terminals computer programs can be composed by forming S-expressions. <p> Operations actually used in our simulations will be listed below. The most important part of the algorithm, however, is the mapping from 2 genoype (binary string) to phenotype (working program) which requires a string to produce a grammatically correct program. Koza <ref> [3] </ref> achieves correct programs by staying in the symbolic realm of s-expression which are manipulated to yield new s-expressions. At the outset he generates valid s-expressions. In our case, a different procedure has to be applied, since initial random binary strings usually can not be considered to be working programs. <p> We have used 5-bit codings of a selected number of symbolic items constituting either terminals or functions. As in Koza <ref> [3] </ref>, the problem domain dictates the choice of functions and terminals. 2.2 The Problem Domain As an exemplification of the algorithm we have chosen the problem of predicting sequences of integer numbers.
Reference: [4] <editor> Fogel, D.B, Atmar, W. (Eds.), </editor> <booktitle> Proc. 1st annual Conference on Evolutionary Programming, </booktitle> <address> San Diego, </address> <year> 1992 </year>
Reference-contexts: The other direction is the study of systems which evolve according to user defined behavior. This area is generally known as genetic or evolutionary programming <ref> [3, 4] </ref>. In the latter approach, one applies a sort of symbolic GA with the symbols being chosen from a set of functions and terminals. From the set of accessible functions and terminals computer programs can be composed by forming S-expressions.
Reference: [5] <author> Lewin, B., </author> <title> Genes, </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1987 </year> <month> 10 </month>
Reference-contexts: Variation of selected binary strings results in better and better programs. In adopting this method 1. we are able to draw from the rich experience which has accumulated over the years in GAs in general, and 2. we encounter the necessity to introduce various mechanisms also found in nature <ref> [5] </ref> for guaranteeing that the system works. Examples of those mechanisms are editing, repairing and compiling of sequences in different stages of the process, besides the transscription already mentioned. 2 The Algorithm iteratively selected via a feed-back mechanism.
Reference: [6] <author> Holland, J.H., </author> <title> Adaptation in natural and artificial systems, </title> <publisher> University of Michigan Press, </publisher> <address> Ann Arbor, </address> <year> 1975 </year>
Reference-contexts: A selection process determines which binary sequences are to be retained and reproduced for a new generation and which sequences are to be discarded (see Figure 1). We make use of well known genetic mechanisms like point mutation or crossover on binary strings <ref> [6, 7] </ref>. Operations actually used in our simulations will be listed below. The most important part of the algorithm, however, is the mapping from 2 genoype (binary string) to phenotype (working program) which requires a string to produce a grammatically correct program.
Reference: [7] <author> Goldberg, D.E., </author> <title> Genetic Algorithms in Search, Optimization & machine Learning, </title> <address> Adison-Wesley, New York, </address> <year> 1989 </year>
Reference-contexts: A selection process determines which binary sequences are to be retained and reproduced for a new generation and which sequences are to be discarded (see Figure 1). We make use of well known genetic mechanisms like point mutation or crossover on binary strings <ref> [6, 7] </ref>. Operations actually used in our simulations will be listed below. The most important part of the algorithm, however, is the mapping from 2 genoype (binary string) to phenotype (working program) which requires a string to produce a grammatically correct program.
Reference: [8] <author> Koza, J.R., </author> <title> Hierarchical Genetic Algorithms operating on populations of computer programs, </title> <booktitle> Proc. 11th IJCAI, 1989, </booktitle> <publisher> Morgan Kauffman, </publisher> <address> San Mateo, CA, </address> <year> 1989 </year>
Reference-contexts: Based on the information derived from few given sequence instances, the system should be able to produce the correct algorithm that enables it to predict the sequence to arbritrary length (Koza discussed in Ref. <ref> [8] </ref> a similar application).
References-found: 8

