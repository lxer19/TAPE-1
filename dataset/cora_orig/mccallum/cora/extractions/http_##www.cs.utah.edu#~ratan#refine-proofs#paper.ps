URL: http://www.cs.utah.edu/~ratan/refine-proofs/paper.ps
Refering-URL: http://www.cs.utah.edu/~ratan/refine-proofs/
Root-URL: 
Email: fratan,ganeshg@cs.utah.edu  
Title: Deriving Efficient Cache Coherence Protocols through Refinement  
Author: Ratan Nalumasu Ganesh Gopalakrishnan 
Keyword: Refinement, DSM protocols, Communication protocols.  
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science University of Utah,  
Abstract: We address the problem of developing efficient cache coherence protocols for use in distributed systems implementing distributed shared memory (DSM) using message passing. A serious drawback of traditional approaches to this problem is that the users are required to state the desired coherence protocol at the level of asynchronous message interactions involving request, acknowledge, and negative acknowledge messages, and handle unexpected messages by introducing intermediate states. Proofs of correctness of protocols described in terms of low level asynchronous messages are very involved. Often the proofs hold only for specific configurations and buffer allocations. We propose a method in which the users state the desired protocol directly in terms of the desired high-level effect, namely synchronization and coordination, using the synchronous rendezvous construct. These descriptions are much easier to understand and computationally more efficient to verify than asynchronous protocols due to their small state spaces. The rendezvous protocol can also be synthesized into efficient asynchronous protocols. In this paper, we present our protocol refinement procedure, prove its soundness, and provide examples of its efficiency. Our synthesis procedure applies to large classes of DSM protocols. 
Abstract-found: 1
Intro-found: 1
Reference: [BS83] <author> G. N. Buckley and A. Silberschatz. </author> <title> An effective implementation for the generalized input-output construct of CSP. </title> <journal> ACM TOPLAS, </journal> <volume> 5(2) </volume> <pages> 223-235, </pages> <month> April </month> <year> 1983. </year>
Reference-contexts: In contrast, in our approach, user writes the rendezvous protocol using only the rendezvous primitive, verifies the protocol at this level with great efficiency and compiles it into an efficient asynchronous protocol or object code. Our work closely resembles that of Buckley and Silberschatz <ref> [BS83] </ref>. Buckley and Silber-schatz consider the problem of implementing rendezvous using message when the processes use generalized input/output guard. However, since the focus of their problem is for implementation in software, efficiency is not a primary concern. Their solution is too expensive for DSM protocol implementations.
Reference: [CKK96] <author> John B. Carter, Chen-Chi Kuo, and Ravindra Kuramkote. </author> <title> A comparison of software and hardware synchronization mechanisms for distributed shared memory multiprocessors. </title> <type> Technical Report UUCS-96-011, </type> <institution> University of Utah, </institution> <address> Salt Lake City, UT, USA, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: In this paper, we address the problem of producing correct and efficient cache coherence protocols used in distributed shared memory (DSM) parallel computing systems. DSM systems have been widely researched in the academia as the next logical step in parallel processing <ref> [CKK96, LLG + 92, Kea94] </ref>. High-end workstation manufacturers also have introduced DSM systems lately [Cra93] thus providing added confirmation to the growing importance of DSM. A central problem in DSM systems is the design and implementation of distributed coherence protocols for shared cache lines using message passing [HP96]. <p> We empirically show that the rendezvous protocols are, several orders of magnitude more efficient to model-check than their corresponding detailed implementations. In addition, we also show that in the context of a state of the art DSM machine project called the Avalanche <ref> [CKK96] </ref>, our procedure can automatically produce protocol implementations that are comparable in quality to hand-designed asynchronous protocols, where quality is measured in terms of (1) the number of request, acknowledge, and negative acknowledge (nack) messages needed for carrying out the rendezvous specified in the given specification, and (2) the buffering requirements <p> This assumption is justified in many machines, e.g., 1 The home for different cache lines can be different. We will derive protocols focusing on one cache line, as is usually done. 3 DASH [LLG + 92], and Avalanche <ref> [CKK96] </ref>. We also assume that the network has infinite buffer-ing, in the sense that the network can always accept new messages to be delivered. Without this assumption, the asynchronous protocol generated may deadlock. Unfortunately, this assumption is not satisfied in some networks.
Reference: [Cra93] <author> Cray Research, Inc. </author> <title> CRAY T3D System Architecture Overview, </title> <address> hr-04033 edition, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: DSM systems have been widely researched in the academia as the next logical step in parallel processing [CKK96, LLG + 92, Kea94]. High-end workstation manufacturers also have introduced DSM systems lately <ref> [Cra93] </ref> thus providing added confirmation to the growing importance of DSM. A central problem in DSM systems is the design and implementation of distributed coherence protocols for shared cache lines using message passing [HP96].
Reference: [CRL96] <author> Satish Chandra, Brad Richards, and James R. Larus. Teapot: </author> <title> Language support for writing memory coherency protocols. </title> <booktitle> In SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: Section 7 presents a discussion on buffering requirements of the refined protocol and its impact on the forward progress made by the asynchronous protocol. Finally, Section 8 concludes the paper. 2 Related Work Chandra et al <ref> [CRL96] </ref> use a model based on continuations to help reduce the complexity of specifying the coherency protocols. The specification can then be model checked and compiled into an efficient object code.
Reference: [DDHY92] <author> D. Dill, A.J. Drexler, A.J. Hu, and C.H. Yang. </author> <title> Protocol verification as a hardware design aid. </title> <booktitle> In IEEE International Conference on Computer Design (ICCD): VLSI In Computers and Processors, </booktitle> <pages> pages 522-525, </pages> <year> 1992. </year>
Reference: [EM95] <author> Asgeir Th. Eiriksson and Ken McMillan. </author> <title> Using formal verification/analysis methods on the critical path in system design: A case study. </title> <booktitle> In Proceedings of the 7th International Conference on Computer-Aided Verification, </booktitle> <pages> pages 367-380, </pages> <address> 1995. </address> <publisher> Springer LNCS 939. </publisher>
Reference: [Gri90] <author> E. </author> <title> Pascal Gribo mont. From synchronous to asynchronous communication. </title> <editor> In C. Rat-tay, editor, </editor> <booktitle> Specification and Verification of Concurrent Systems, </booktitle> <pages> pages 368-383. </pages> <institution> Springer-Verilog, University of Stirling, </institution> <address> Scotland, </address> <year> 1990. </year> <note> Workshops in Computing. </note>
Reference-contexts: Their solution is too expensive for DSM protocol implementations. In contrast, we focus on a star configuration of processes with suitable syntactic restrictions on the high-level specification language, so that an efficient asynchronous 2 protocol can be automatically generated. Gribo mont <ref> [Gri90] </ref> explored the protocols where the rendezvous communication can be simply replaced by asynchronous communication without affecting the processes in any other way. In contrast, we show how to change the processes when the rendezvous communication is replaced by asynchronous communication.
Reference: [Hoa78] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> CACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <year> 1978. </year>
Reference-contexts: Instead, what gets written down as the "highest level" specification is a detailed protocol implementation which was arrived at through ad hoc reasoning of the situations that can arise. In this paper, we choose CSP <ref> [Hoa78] </ref> as our specification language to allow the designers to capture their initial atomic-transaction view. The atomic-transaction protocol is then subjected to syntax-directed translation rules to modify the rendezvous communication primitives of CSP into asynchronous communication primitives yielding an efficient detailed implementation. <p> As we shall see in Section 4, asynchronous protocol has two acknowledge messages: ack and nack. Guaranteeing that the network always accepts these two acknowledge messages is beyond the scope of this paper. 3.3 Methodology We use rendezvous communication primitives of CSP <ref> [Hoa78] </ref> to specify the home node and the remote nodes to simplify the DSM protocol design.
Reference: [Hol91] <author> Gerard Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Efficiency As can be expected, verifying of the rendezvous protocols is much simpler than verifying the asynchronous protocol. We verified the rendezvous and asynchronous versions of the migratory protocol above and invalidate, another DSM protocol used in Avalanche, using the SPIN <ref> [Hol91] </ref> model checker. The number of states visited by SPIN on these two protocols is shown in to the verification of asynchronous protocol. As can be seen, verifying of the rendezvous protocol generates far fewer states and takes much less run time than verifying the asynchronous protocol.
Reference: [HP96] <author> John L. Hennessy and David A. Patterson. </author> <title> Computer Architecture: A Quantitative Apporach. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year> <note> Second Edition, Appendix E. </note>
Reference-contexts: High-end workstation manufacturers also have introduced DSM systems lately [Cra93] thus providing added confirmation to the growing importance of DSM. A central problem in DSM systems is the design and implementation of distributed coherence protocols for shared cache lines using message passing <ref> [HP96] </ref>. The present-day approach to this problem consists of specifying the detailed interactions possible between computing nodes in terms of low-level requests, acknowledges, negative acknowledges, and dealing with "unexpected" messages. <p> Without this assumption, the asynchronous protocol generated may deadlock. Unfortunately, this assumption is not satisfied in some networks. A solution to this problem that is orthogonal to the refinement process is given by Hennessy and Patterson <ref> [HP96] </ref>. They divide the messages into two categories: request and acknowledge. A request message may cause the recipient to generate more messages in order to complete the transactions, while an acknowledge message does not.
Reference: [Kea94] <author> J. Kuskin and D. Ofelt et al. </author> <title> The Stanford FLASH multiprocessor. </title> <booktitle> In Proceedings of the 21st Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 302-313, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: In this paper, we address the problem of producing correct and efficient cache coherence protocols used in distributed shared memory (DSM) parallel computing systems. DSM systems have been widely researched in the academia as the next logical step in parallel processing <ref> [CKK96, LLG + 92, Kea94] </ref>. High-end workstation manufacturers also have introduced DSM systems lately [Cra93] thus providing added confirmation to the growing importance of DSM. A central problem in DSM systems is the design and implementation of distributed coherence protocols for shared cache lines using message passing [HP96].
Reference: [Lip75] <author> Richard J. Lipton. </author> <title> Reduction: A method of proving properties of parallel programs. </title> <journal> CACM, </journal> <volume> 18(12) </volume> <pages> 717-721, </pages> <month> December </month> <year> 1975. </year>
Reference-contexts: In contrast, we show how to change the processes when the rendezvous communication is replaced by asynchronous communication. Lamport and Schneider [LS89] have explored the theoretical foundations of comparing atomic transactions (e.g., rendezvous communication) and split transactions (e.g., asynchronous communication), based on left and right movers <ref> [Lip75] </ref>, but have not considered specific refinement rules such as we do. 3 Cache Coherency in Distributed Systems In directory based cache coherent multiprocessor systems, the coherency of each line of shared memory is managed by a CPU node, called home node, or simply home 1 .
Reference: [LLG + 92] <author> D. Lenoski, J. Laudon, K. Gharachorloo, W.-D. Weber, A. Gupta, J. Hennessy, M. Horowitz, and M. S. Lam. </author> <title> The Stanford DASH multiprocessor. </title> <journal> IEEE COMPUTER, </journal> <volume> 25(3) </volume> <pages> 63-79, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: In this paper, we address the problem of producing correct and efficient cache coherence protocols used in distributed shared memory (DSM) parallel computing systems. DSM systems have been widely researched in the academia as the next logical step in parallel processing <ref> [CKK96, LLG + 92, Kea94] </ref>. High-end workstation manufacturers also have introduced DSM systems lately [Cra93] thus providing added confirmation to the growing importance of DSM. A central problem in DSM systems is the design and implementation of distributed coherence protocols for shared cache lines using message passing [HP96]. <p> This assumption is justified in many machines, e.g., 1 The home for different cache lines can be different. We will derive protocols focusing on one cache line, as is usually done. 3 DASH <ref> [LLG + 92] </ref>, and Avalanche [CKK96]. We also assume that the network has infinite buffer-ing, in the sense that the network can always accept new messages to be delivered. Without this assumption, the asynchronous protocol generated may deadlock. Unfortunately, this assumption is not satisfied in some networks.
Reference: [LS89] <author> Leslie Lamport and Fred B. Schneider. </author> <note> Pretending atomicity. In Research Report 44, </note> <institution> Digital Equipment Corporation Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Gribo mont [Gri90] explored the protocols where the rendezvous communication can be simply replaced by asynchronous communication without affecting the processes in any other way. In contrast, we show how to change the processes when the rendezvous communication is replaced by asynchronous communication. Lamport and Schneider <ref> [LS89] </ref> have explored the theoretical foundations of comparing atomic transactions (e.g., rendezvous communication) and split transactions (e.g., asynchronous communication), based on left and right movers [Lip75], but have not considered specific refinement rules such as we do. 3 Cache Coherency in Distributed Systems In directory based cache coherent multiprocessor systems, the
Reference: [MP92] <author> Zohar Manna and Amir Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <address> Springer-Verlog, </address> <year> 1992. </year>
Reference-contexts: Incidentally, assuring forward progress for each individual remote node corresponds to strong fairness, and assuring forward progress for at least one remote node corresponds to weak fairness <ref> [MP92] </ref>. 4 The Refinement Procedures We systematically refine the communication actions in h and r i by inspecting the syntactic structure of the processes.
Reference: [Nal97] <author> Ratan Nalumasu. </author> <title> A correctness proof of refinement rules using PVS, </title> <note> 1997. See http://www.cs.utah.edu/~ratan/refine-proofs. </note>
Reference-contexts: Using the higher-order functions available in PVS, we showed that ! a as defined by Tables 1 and 2, along with the above abs function satisfies Equation 1. The PVS theory files and proofs can be obtained from <ref> [Nal97] </ref>. 9 5.2 Proof of forward progress To see that at least one of the remote nodes makes forward progress, we observe that when the home node h makes forward progress, one of the remote nodes also makes forward progress.
Reference: [ORR + 96] <author> S. Owre, S. Rajan, J. M. Rushby, N. Shankar, and M. Srivas. PVS: </author> <title> Combining specification, proof checking and model checking. </title> <booktitle> In CAV, </booktitle> <pages> pages 411-414, </pages> <address> New Brunswick, NJ, USA, </address> <year> 1996. </year>
Reference-contexts: Section 4 presents our syntax-directed translation rules, along with an important optimization called request/reply. Section 5 presents an informal argument that the refinement rules we present always produce correct result, and also points to a formal proof of correctness done using PVS <ref> [ORR + 96] </ref>. Section 6 presents an example protocol developed using the refinement rules, and the efficiency of model-checking the rendezvous protocol compared to the efficiency of model-checking the asynchronous protocol. <p> As can be seen from this case analysis, an ack is generated only in case 2, and in this case the rendezvous is allowed by the rendezvous protocol. 5.1 PVS proof of correctness The above informal argument is formalized with the help of PVS <ref> [ORR + 96] </ref> and proved that the refinement rules are safety preserving; i.e., we showed that if the a transition is taken in the refined protocol, then it is allowed in the original rendezvous protocol.
Reference: [PD96] <author> Seungjoon Park and David L. Dill. </author> <title> Protocol verification by aggregation of distributed transactions. </title> <booktitle> In CAV, </booktitle> <pages> pages 300-309, </pages> <address> New Brunswick, NJ, USA, </address> <month> July </month> <year> 1996. </year> <month> 14 </month>
Reference-contexts: Difficulty of designing these protocols is compounded by the 1 fact that verifying such low-level descriptions invites state explosion (when done using model--checking [EM95,DDHY92]) or tedious (when done using theorem-proving <ref> [PD96] </ref>) even for simple configurations. Often these low-level descriptions are model-checked for specific resource allocations (e.g. buffer sizes); it is often not known what would happen when these allocations are changed. Protocol refinement can help alleviate this situation considerably.
References-found: 18

