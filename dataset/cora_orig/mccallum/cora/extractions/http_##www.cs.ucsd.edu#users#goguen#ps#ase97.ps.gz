URL: http://www.cs.ucsd.edu/users/goguen/ps/ase97.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/goguen/new.html
Root-URL: http://www.cs.ucsd.edu
Email: asatog@cs.ucsd.edu  
Title: Distributed Cooperative Formal Methods Tools  
Author: Joseph Goguen, Kai Lin, Akira Mori, Grigore Rosu, and Akiyoshi Sato fgoguen, klin, amori, grosu, 
Address: 9500 Gilman Drive, La Jolla, CA 92093-0114, USA  
Affiliation: Dept. Computer Science Engineering, University of California at San Diego  
Abstract: This paper describes some tools to support formal methods, and conversely some formal methods for developing such tools. We focus on distributed cooperative proving over the web. Our tools include a proof editor/assistant, servers for remote proof execution, a distributed truth protocol, an editor generator, and a new method for interface design called algebraic semiotics, which combines semiotics with algebraic specification. Some examples are given. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Fauconnier and M. Turner. </author> <title> Conceptual projection and middle spaces. </title> <type> Technical Report 9401, </type> <institution> University of Cali-fornia at San Diego, 1994. Dept. of Cognitive Science. </institution>
Reference-contexts: The set of semiotic morphisms between two fixed sign systems is ordered in various ways by how much structure is preserved; see [6] for details. The specification of interfaces as semiotic morphisms is used by WEG in generating editor interfaces. Fauconnier and Turner <ref> [1] </ref> study the blending of (what they call) conceptual spaces, and suggest blending is a fundamental cognitive operation, with applications to metaphors, grammar, and much more.
Reference: [2] <author> S. </author> <title> Field. </title> <booktitle> Screenplay: The Foundations of Screenwriting. Dell, 1982. Third edition. </booktitle>
Reference-contexts: Aristotle said Drama is conflict. Perhaps proofs can be made more understandable and interesting, by restoring the conflicts that motivate difficult proof steps, in sub-ProofWebs recording failured subproofs, and in links to interactive applets and other verbal and graphical explanations. Syd Field's screenwriting books <ref> [2] </ref> suggest a precise but naive structure: Hollywood plots should have three acts, for setup, conflict, and resolution, of 30, 60, 30 minutes, with plot points to move action from one act to the next. Proofs that are structured this way might be easier to understand. 5 4.1.
Reference: [3] <author> J. Goguen. </author> <title> The logic of inexact concepts. </title> <journal> Synthese, </journal> <volume> 19:325 373, </volume> <year> 196869. </year>
Reference-contexts: boolean expressions for most proof rules take the conjunction of their leaf nodes, but the rules for 2 disjunction elimination and contradiction are exceptions.) This extends in a natural way to fuzzy truth values (in the unit interval, using maximum for alternative proofs, and multiplication for proof chains, as in <ref> [3] </ref>), to take account of informal and semi-formal subproof; clearly this is more realistic for practical software development.
Reference: [4] <author> J. Goguen. </author> <title> Principles of parameterized programming. </title> <editor> In T. Biggerstaff and A. Perlis, editors, </editor> <booktitle> Software Reusability, Volume I: Concepts and Models, </booktitle> <pages> pages 159225. </pages> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: It seems almost amazing that OBJ provides not only a simple, elegant way to specify sign systems, but also directly supports both blends and semiotic morphisms, through its facilities for parameterized programming <ref> [4] </ref>. 5. Current Status and Further Research We have used algebraic ADTs in several ways: to specify and verify object oriented systems (though this is not illustrated here see [9]), to define logics, and to define sign systems and their morphisms, particularly in specifying website structure and guiding interface design.
Reference: [5] <author> J. Goguen. </author> <title> Formality and informality in requirements engineering. </title> <booktitle> In Proceedings, International Conference on Requirements Engineering, </booktitle> <pages> pages 102108. </pages> <publisher> IEEE Computer Society, </publisher> <month> April </month> <year> 1996. </year>
Reference-contexts: 1. Introduction Formal methods have been used to prove correctness of software, but this task is known to be difficult, for various reasons <ref> [5, 13] </ref>. New technologies the internet, the web, multimedia, applets, etc. offer exciting opportunities to reduce this difficulty that have not yet been much explored. We seek to build industrial strength formal method tools for distributed work by ordinary software engineers over the web, especially for concurrent systems. <p> See [9] for details. 3. Website Editing Maintenance, the process of modifying software to meet user expectations in the face of evolving platforms, working conditions, business environments, etc., consumes far more effort than initial construction; the effects of evolution on formal methods are similar, but even worse <ref> [5, 13] </ref>. Web-sites with complex interaction (buttons, popups, etc.) and complex links are difficult to build and even more difficult to maintain; formal methods websites will thus operate under a severe double handicap. A website editor can greatly reduce this effort.
Reference: [6] <author> J. Goguen. </author> <title> Semiotic morphisms. </title> <type> Technical Report CS97 553, UCSD, </type> <institution> Dept. Computer Science & Eng., </institution> <year> 1997. </year> <note> Early version in Proc., Conf. Intelligent Systems: A Semiotic Perspective, Vol. </note> <editor> II, ed. J. Albus, A. Meystel and R. </editor> <address> Quintero, </address> <institution> Nat. Inst. Science & Technology (Gaithersberg MD, </institution> <year> 2023 </year> <month> October </month> <year> 1996), </year> <pages> pages 2631. </pages>
Reference-contexts: This is a major motivation for algebraic semiotics, which uses algebraic specification to study complex signs and the quality of their representations <ref> [6] </ref>. Semiotic representations are useful not only in interface design, but also in automating tool development, e.g., in WEG. Constructing non-trivial proofs usually requires exploring many misconceptions and errors, some of which may be very subtle. <p> Sign Systems and Semiotic Morphisms ProofWebs, tatami pages, and status windows are signs. An insight of Saussure [14] that every sign should be considered part of a system of interrelated signs. The material in this section, taken from <ref> [6] </ref>, gives a rigorous foundation for discussing the structure of such representations. <p> The set of semiotic morphisms between two fixed sign systems is ordered in various ways by how much structure is preserved; see <ref> [6] </ref> for details. The specification of interfaces as semiotic morphisms is used by WEG in generating editor interfaces. Fauconnier and Turner [1] study the blending of (what they call) conceptual spaces, and suggest blending is a fundamental cognitive operation, with applications to metaphors, grammar, and much more. <p> Many examples of blending can be found in interface design as well; e.g., the status window is a blend of structures for truth status and subproof ownership. The meaning of the word proofweb is a blend of the meanings of its constituent words. <ref> [6] </ref> gives a rigorous approach to blending through the category of sign systems with semiotic morphisms; this is an ordered category because of the ordering on morphisms. Category theory suggests that a blend should be a pushout; however, special kinds of ordered category and pushout are needed. 4.2. <p> The formal notions of 2-doag and fan have helped in specifying and verifying the tatami protocol. Many aspects of this research are novel, including the tatami conventions, with its idea of proof as narrative, the tatami protocol, and the editor generator; semiotic morphisms appear to be especially novel <ref> [6, 10] </ref>. These developments also help support the automation of tools for distributed cooperative formal methods. Several ProofWebs have been put on our website by hand, with applets, tutorials, and executable proofs, using BARISTA to access an OBJ server at UCSD.
Reference: [7] <author> J. Goguen. </author> <title> Theorem Proving and Algebra. MIT, </title> <note> to appear. </note>
Reference-contexts: Auxiliary information (e.g., explanations) can be provided directly or by reference to a file. The following describes some of the proof rules: Induction is very general; an induction variable, its sort, and possibly some new operations and equations should be supplied <ref> [7] </ref>. For example, applying Peano induction to the proof task H |=[S] (all x) plus (sum (x),sum (x)) = times (x,s (x)) yields the update shown in Figure 4. <p> The specification of logical systems as sets of conditional equations is well known and also omitted; e.g., see <ref> [7] </ref>. 4. Semiotics, Narratology and Design Since we aim to help ordinary software engineers, it is important to make specifications and proofs as understandable as possible. This requires better user interfaces than are currently available. <p> its result sort is s (constants c : ! s are also allowed); 6. a priority (partial) ordering on each C n ; 7. some relations and functions on signs; and 8. a set A of axioms, constraining possible signs. 2 A sign system is really an abstract data type <ref> [8, 7] </ref> enriched with levels and priority; we exploit this by specifying sign systems in OBJ3 in Appendix A. We now consider the movement (mapping, translation, interpretation, representation) of signs in one system to signs in another.
Reference: [8] <author> J. Goguen and G. Malcolm. </author> <title> Algebraic Semantics of Imperative Programs. </title> <publisher> MIT, </publisher> <year> 1996. </year>
Reference-contexts: its result sort is s (constants c : ! s are also allowed); 6. a priority (partial) ordering on each C n ; 7. some relations and functions on signs; and 8. a set A of axioms, constraining possible signs. 2 A sign system is really an abstract data type <ref> [8, 7] </ref> enriched with levels and priority; we exploit this by specifying sign systems in OBJ3 in Appendix A. We now consider the movement (mapping, translation, interpretation, representation) of signs in one system to signs in another.
Reference: [9] <author> J. Goguen and G. Malcolm. </author> <title> A hidden agenda. </title> <type> Technical Report CS97538, UCSD, </type> <institution> Dept. Computer Science & Eng., </institution> <month> May </month> <year> 1997. </year> <note> Early version in Proc., Conf. Intelligent Systems: </note>
Reference-contexts: Hidden logic uses behavioral abstraction, or more precisely, behavioral satisfaction: hidden specifications characterize how systems behave, not how they are implemented; they provide a notion of behavioral type. Coinduction is new proof technique that is very effective for proving behavioral properties, e.g., behavioral refinement. See <ref> [9] </ref> for details. 3. Website Editing Maintenance, the process of modifying software to meet user expectations in the face of evolving platforms, working conditions, business environments, etc., consumes far more effort than initial construction; the effects of evolution on formal methods are similar, but even worse [5, 13]. <p> --Body-- [[TatPg]]((Name := ) (Goal := )(Spec := )) ) TatPg (TAT) :: &lt;Name := &gt;&lt;Tpl>([-Rule-]* --ExPg--.htm (Obj := [[Alg]].obj)) ExPg (EXP) :: &lt;Name := &gt; &lt;Tpl&gt;((Name := )(Goal := )(Spec := )) - We omit the agent action specifications, but note that they follow the style of hidden algebra <ref> [9] </ref>. The specification of logical systems as sets of conditional equations is well known and also omitted; e.g., see [7]. 4. Semiotics, Narratology and Design Since we aim to help ordinary software engineers, it is important to make specifications and proofs as understandable as possible. <p> Current Status and Further Research We have used algebraic ADTs in several ways: to specify and verify object oriented systems (though this is not illustrated here see <ref> [9] </ref>), to define logics, and to define sign systems and their morphisms, particularly in specifying website structure and guiding interface design. The formal notions of 2-doag and fan have helped in specifying and verifying the tatami protocol.
References-found: 9

