URL: http://choices.cs.uiuc.edu/sane/patlint.ps.gz
Refering-URL: http://choices.cs.uiuc.edu/sane/home.html
Root-URL: http://www.cs.uiuc.edu
Email: email: fsefika,sane,royg@cs.uiuc.edu  
Title: Monitoring Compliance of a Software System With Its High-Level Design Models  
Author: Mohlalefi Sefika Aamod Sane Roy H. Campbell 
Web: www: http://choices.cs.uiuc.edu  
Address: 1304 W. Springfield Avenue, Urbana, IL 61801  
Affiliation: University of Illinois at Urbana-Champaign Department of Computer Science  
Note: To appear in ICSE-96  
Abstract: As a complex software system evolves, its implementation tends to diverge from the intended or documented design models. Such undesirable deviation makes the system hard to understand, modify, and maintain. This paper presents a hybrid computer-assisted approach for confirming that the implementation of a system maintains its expected design models and rules. Our approach closely integrates logic-based static analysis and dynamic visualization, providing multiple code views and perspectives. We show that the hybrid technique helps determine design-implementation congruence at various levels of abstraction: concrete rules like coding guidelines, architectural models like design patterns[7] or connectors[26], and subjective design principles like low coupling and high cohesion. The utility of our approach has been demonstrated in the development of Choices, a new multimedia operating system which inherits many design decisions and guidelines learned from experience in the construction and maintenance of its predecessor, Choices. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. J. Biggestaff, B. G. Mitbander, and D. Webster. </author> <title> The Concept Assignment Problem in Program Understanding. </title> <booktitle> In Proceedings of Working Conference on Reverse Engineering, </booktitle> <address> Baltimore, MD, USA, </address> <year> 1993. </year>
Reference-contexts: Most of the individual features of Pattern-Lint have appeared in isolated reverse engineering tools: architectural styles [10], dynamic analysis [17, 21], program databases [4], and program concept recognition <ref> [1, 9] </ref>. Pattern-Lint seems to be the first tool to combine all these abilities in design conformance checking. Pattern-Lint also extends the application of these ideas by incorporating diverse design principles, celebrating the synergy of static and dynamic visualization, the use of scalable affinity diagrams, and a customizable architecture.
Reference: [2] <author> R. H. Campbell, N. Islam, D. Raila, and P. Madany. </author> <title> Designing and Implementing Choices: An Object-Oriented System in C++. </title> <journal> Communications of the ACM, </journal> <pages> pages 117-126, </pages> <month> September </month> <year> 1993. </year> <month> 9 </month>
Reference-contexts: Our compliance checker, called Pattern-Lint 1 , uses models from various works [7, 8, 26, 14, 6], and our experience in designing Choices <ref> [2] </ref>, one of the earliest object-oriented operating systems. We are using Pattern-Lint to implement Choices [3], a successor of Choices targeted to support multimedia applications. Pattern-Lint helps reuse and refine structures from Choices in Choices. The tool aids in monitoring implementation compliance from the very beginning. <p> Indeed, the explicit subsystem clusters in the animation correspond directly to the documented subframeworks of Choices <ref> [2] </ref>. <p> Ideally, the derived framework should remain substitutable in place of the original one, so that the rest of the system is not impacted negatively by framework refinement. A simple way to promote substitutability is to always refine frameworks only by adding new components, and never removing any existing component <ref> [2] </ref>. While component addition does not guarantee substitutability (which is a complex behavioral notion), component removal almost always violates it. In our example, suppose that the default PagingPol-icy implements FIFO (first-in/first-out) paging. One may legally refine this framework by adding a LRU (least recently used) paging policy class.
Reference: [3] <author> R. H. Campbell and S. Tan. </author> <title> Choices: An Object-Oriented Multimedia Operating System. </title> <booktitle> In Fifth Workshop on Hot Topics in Operating Systems, </booktitle> <address> Orcas Island, Washington, </address> <month> May </month> <year> 1995. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: Our compliance checker, called Pattern-Lint 1 , uses models from various works [7, 8, 26, 14, 6], and our experience in designing Choices [2], one of the earliest object-oriented operating systems. We are using Pattern-Lint to implement Choices <ref> [3] </ref>, a successor of Choices targeted to support multimedia applications. Pattern-Lint helps reuse and refine structures from Choices in Choices. The tool aids in monitoring implementation compliance from the very beginning.
Reference: [4] <author> Y. F. Chen, M. Y. Nashimoto, and C. V. Ramamoorthy. </author> <title> The C Information Abstractor System. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> Vol. 16, NO. 3,, </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: Most of the individual features of Pattern-Lint have appeared in isolated reverse engineering tools: architectural styles [10], dynamic analysis [17, 21], program databases <ref> [4] </ref>, and program concept recognition [1, 9]. Pattern-Lint seems to be the first tool to combine all these abilities in design conformance checking.
Reference: [5] <author> A. L. Couch. </author> <title> Categories and Context in Scalable Execution Visualization. </title> <journal> The Journal of Parallel and Distributed Computing 18, </journal> <pages> pages 195-204, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Putting it all together Correlating the static and dynamic call diagrams indicates that the undesirable couplings from 4 The affinity diagram is scalable because its format, meaning, clarity, and size are independentof the number of dynamic instances of the classes involved <ref> [5] </ref>. the static diagram presumably model unusual or uncommon situations, and that they might unnecessarily entangle the subsystems. The data sharing graph reveals that the unwanted connections may have been introduced as method calls. Upon examining the source code, we discovered that FileCache and PageCache were originally the same component.
Reference: [6] <author> L. P. Deutsch. </author> <title> Design Reuse and Frameworks in the Smalltalk-80 Programming System. </title> <editor> In T. J. Biggerstaff and A. J. Perlis, editors, </editor> <booktitle> Software Reusability, </booktitle> <volume> volume II, </volume> <pages> pages 55-71. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: Our compliance checker, called Pattern-Lint 1 , uses models from various works <ref> [7, 8, 26, 14, 6] </ref>, and our experience in designing Choices [2], one of the earliest object-oriented operating systems. We are using Pattern-Lint to implement Choices [3], a successor of Choices targeted to support multimedia applications. Pattern-Lint helps reuse and refine structures from Choices in Choices. <p> In Choices, when such cycles were accidentally established across subsystems, the resulting interdependencies seriously impaired portability and comprehensibility [23]. In Choices, we are using Pattern-Lint to ensure that no base class holds references to instances of its derived classes. Substitutability via refinement by addition: Frameworks <ref> [6] </ref> are groups of collaborating classes that typically implement subsystems in object-oriented programs. For example, a PageCache and its associated Paging-Policy form a simple framework that implements demand paging in Choices. To add new capabilities to the system, frameworks are refined to derive other frameworks.
Reference: [7] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns, Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: Such guidelines are diverse in nature, ranging from environment-specific programming conventions, to rules-of-thumb like the information hiding principle, to domain-independent design idioms. Recently, research in software architecture has focused on identifying and cataloging reusable design models and rules, including object-oriented patterns <ref> [7] </ref>, architectural styles [8], and software fl Supported by Lesotho AFGRAAD Fellowship. y Supported by CNRI contract CNRI GIGABIT/UILL. connectors [26]. Unfortunately, system design improvements are often vitiated by the tendency of implementations to diverge from their intended or documented design models. <p> We show that the combined scheme improves compliance checking for well-defined rules as well as subjective guidelines. * We check for conformance to a wide variety of design principles: concrete rules like coding styles [14], ar 1 chitectural rules like design patterns <ref> [7] </ref> or styles [8], and heuristic guidelines like high cohesion and low coupling [20]. * We provide a design rule-base that is reusable across a wide variety of software systems, because the rule-base captures codified architectural styles, connectors, and design patterns that are well-known recurrent de signs. <p> Our compliance checker, called Pattern-Lint 1 , uses models from various works <ref> [7, 8, 26, 14, 6] </ref>, and our experience in designing Choices [2], one of the earliest object-oriented operating systems. We are using Pattern-Lint to implement Choices [3], a successor of Choices targeted to support multimedia applications. Pattern-Lint helps reuse and refine structures from Choices in Choices. <p> Our framework abstracts the interaction protocol in a DiskController, which centralizes the protocol, and simplifies coordination between multiple CPU's and disks. The arrangement of Figure 1, in which a central component provides a localized home for the interaction semantics of several colleagues, is the structure of the MEDIATOR pattern <ref> [7] </ref>. The pattern reifies and encapsulates the collaboration protocol among several objects into a central hub: the mediator object 2 . This centralizes and objectifies the interaction protocol which would otherwise be scattered and distributed across collaborating objects, and hence difficult to locate, understand, and change. <p> This centralizes and objectifies the interaction protocol which would otherwise be scattered and distributed across collaborating objects, and hence difficult to locate, understand, and change. The pattern also decouples the collaborating colleagues and manages dependencies. Further discussion can be found in <ref> [7] </ref>. Conformance: Mediator Implementation The reason for our choice of the MEDIATOR design model in device management is clear. <p> Low Level Rules Low level rules (the guidelines of Section 4) govern details closer to implementation than design. These rules are specified using ER diagrams or grammars and mechanically converted to their Prolog equivalents. Architectural Rules These rules include patterns <ref> [7] </ref>, software interconnection models [26], and architectural styles [8]. The rules capture recurring designs, so they are described only once, and reused across a wide variety of software systems. <p> Combining and correlating these two types of knowledge helps reduce the risk of both false positives and false negatives. test driver for MEDIATOR. This pattern is open to slight implementation variations <ref> [7] </ref>, so we need several sets of 6 rules to cater for each expected variation. The rules in the positive evidence rule checks that (1) each colleague does interact with the mediator, and (2) there are indeed bidirectional control and data dependencies among the mediated colleagues. <p> We improve on these systems by systematic provision of numerous static and dynamic visual perspectives, and by considering a wide range of design commitments, from concrete implementation-level rules to configuration-level principles like subsystem cohesion and coupling. In particular, our work also concerns the conformance checking for standardized architectural models <ref> [26, 7, 8] </ref>: recurring design abstractions that are increasingly popular in the construction of complex systems. Most of the individual features of Pattern-Lint have appeared in isolated reverse engineering tools: architectural styles [10], dynamic analysis [17, 21], program databases [4], and program concept recognition [1, 9]. <p> There have been two standard approaches to address this problem: reverse engineering [10] the implementation to repair it typically after the fact, and structuring the design using standardized design constructs <ref> [7, 8] </ref> with fairly well-understood corresponding implementations.
Reference: [8] <author> D. Garlan, R. Allen, and J. Ockerbloom. </author> <title> Exploiting Style in Architectural Design Environments. </title> <booktitle> In Proceedings of the 2nd ACM SIGSOFT, </booktitle> <pages> pages 175-188, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: Such guidelines are diverse in nature, ranging from environment-specific programming conventions, to rules-of-thumb like the information hiding principle, to domain-independent design idioms. Recently, research in software architecture has focused on identifying and cataloging reusable design models and rules, including object-oriented patterns [7], architectural styles <ref> [8] </ref>, and software fl Supported by Lesotho AFGRAAD Fellowship. y Supported by CNRI contract CNRI GIGABIT/UILL. connectors [26]. Unfortunately, system design improvements are often vitiated by the tendency of implementations to diverge from their intended or documented design models. <p> We show that the combined scheme improves compliance checking for well-defined rules as well as subjective guidelines. * We check for conformance to a wide variety of design principles: concrete rules like coding styles [14], ar 1 chitectural rules like design patterns [7] or styles <ref> [8] </ref>, and heuristic guidelines like high cohesion and low coupling [20]. * We provide a design rule-base that is reusable across a wide variety of software systems, because the rule-base captures codified architectural styles, connectors, and design patterns that are well-known recurrent de signs. <p> Our compliance checker, called Pattern-Lint 1 , uses models from various works <ref> [7, 8, 26, 14, 6] </ref>, and our experience in designing Choices [2], one of the earliest object-oriented operating systems. We are using Pattern-Lint to implement Choices [3], a successor of Choices targeted to support multimedia applications. Pattern-Lint helps reuse and refine structures from Choices in Choices. <p> Low Level Rules Low level rules (the guidelines of Section 4) govern details closer to implementation than design. These rules are specified using ER diagrams or grammars and mechanically converted to their Prolog equivalents. Architectural Rules These rules include patterns [7], software interconnection models [26], and architectural styles <ref> [8] </ref>. The rules capture recurring designs, so they are described only once, and reused across a wide variety of software systems. <p> We improve on these systems by systematic provision of numerous static and dynamic visual perspectives, and by considering a wide range of design commitments, from concrete implementation-level rules to configuration-level principles like subsystem cohesion and coupling. In particular, our work also concerns the conformance checking for standardized architectural models <ref> [26, 7, 8] </ref>: recurring design abstractions that are increasingly popular in the construction of complex systems. Most of the individual features of Pattern-Lint have appeared in isolated reverse engineering tools: architectural styles [10], dynamic analysis [17, 21], program databases [4], and program concept recognition [1, 9]. <p> There have been two standard approaches to address this problem: reverse engineering [10] the implementation to repair it typically after the fact, and structuring the design using standardized design constructs <ref> [7, 8] </ref> with fairly well-understood corresponding implementations.
Reference: [9] <author> M. Harandi and J. Q. Ning. </author> <title> Knowledge-based Program Analysis. </title> <journal> IEEE Software, </journal> <month> January </month> <year> 1990. </year>
Reference-contexts: Most of the individual features of Pattern-Lint have appeared in isolated reverse engineering tools: architectural styles [10], dynamic analysis [17, 21], program databases [4], and program concept recognition <ref> [1, 9] </ref>. Pattern-Lint seems to be the first tool to combine all these abilities in design conformance checking. Pattern-Lint also extends the application of these ideas by incorporating diverse design principles, celebrating the synergy of static and dynamic visualization, the use of scalable affinity diagrams, and a customizable architecture.
Reference: [10] <author> D. R. Harris, H. B. Reubenstein, and A. S. Yeh. </author> <title> Reverse Engineering to the Architectural Level. </title> <booktitle> In Proceedings of the 17th International Conference on Software Engineering, </booktitle> <address> Seattle, Washington, USA, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: In particular, our work also concerns the conformance checking for standardized architectural models [26, 7, 8]: recurring design abstractions that are increasingly popular in the construction of complex systems. Most of the individual features of Pattern-Lint have appeared in isolated reverse engineering tools: architectural styles <ref> [10] </ref>, dynamic analysis [17, 21], program databases [4], and program concept recognition [1, 9]. Pattern-Lint seems to be the first tool to combine all these abilities in design conformance checking. <p> There have been two standard approaches to address this problem: reverse engineering <ref> [10] </ref> the implementation to repair it typically after the fact, and structuring the design using standardized design constructs [7, 8] with fairly well-understood corresponding implementations.
Reference: [11] <author> Panos Kougiouris. </author> <title> A Device Management Framework for an Object-oriented Operating System. </title> <type> Technical report, </type> <institution> The University of Illinois at Urbana-Champaign, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: Section 6 reports on related work. Section 7 proposes future directions and concludes the paper. 2 Example: Static Abstractions and Dy namic Visualization In this section, we discuss how Pattern-Lint was used to re-design a portion of the device management framework in Choices <ref> [11] </ref>. We briefly discuss the pattern underlying the framework's design.
Reference: [12] <author> D. Lange and Y. Nakamura. </author> <title> Interactive Visualization of Design Patterns Can Help in Framework Understanding. </title> <booktitle> In OOPSLA, </booktitle> <pages> pages 342-357, </pages> <year> 1995. </year>
Reference-contexts: Our animated class interaction views were influenced by De Pauw et al.[19]. We extend their techniques with affinity diagrams that not only reveal clusters of frequently communicating classes, but also highlight key elements of the clusters and expose inter/intra-cluster dependencies. Finally, Lange and Nakamura <ref> [12] </ref> use patterns as a guide to manually select objects for visualization. In contrast, we have formalized the notion of patterns based on positive evidence and violations (expressed here as Prolog rules).
Reference: [13] <author> D. Luckham, F. von Henke, B. Krieg-Bruckner, and O. Owe. Anna, </author> <title> A Language for Annotating Ada Programs: Reference Manual, </title> <booktitle> vol. 260 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Frequent compliance checking helps catch design turnovers before they become irreversible. Surprisingly, there seem to be few preventive tools whose specific purpose is to help assure that the implementation of an evolving system abides by its imposed design principles. Those that we know (e.g., <ref> [16, 15, 13] </ref>) appear to focus exclusively on either static or dynamic analysis, lacking multiple views and perspectives. We improve on these approaches in several ways: * We integrate static analysis and dynamic visualization. <p> Nonetheless, the analysis for heuristic guidelines is rather human-dependent, and the certainty of compli ance is much less. 6 Related work Other systems for monitoring an implementation's faithfulness to its design models appear to have focused on either static or dynamic verification, but not both <ref> [16, 15, 24, 13] </ref>. We improve on these systems by systematic provision of numerous static and dynamic visual perspectives, and by considering a wide range of design commitments, from concrete implementation-level rules to configuration-level principles like subsystem cohesion and coupling.
Reference: [14] <author> S. Meyers. </author> <title> Effective C++: 50 Ways to improve Your Programs and Designs. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: We show that the combined scheme improves compliance checking for well-defined rules as well as subjective guidelines. * We check for conformance to a wide variety of design principles: concrete rules like coding styles <ref> [14] </ref>, ar 1 chitectural rules like design patterns [7] or styles [8], and heuristic guidelines like high cohesion and low coupling [20]. * We provide a design rule-base that is reusable across a wide variety of software systems, because the rule-base captures codified architectural styles, connectors, and design patterns that are <p> Our compliance checker, called Pattern-Lint 1 , uses models from various works <ref> [7, 8, 26, 14, 6] </ref>, and our experience in designing Choices [2], one of the earliest object-oriented operating systems. We are using Pattern-Lint to implement Choices [3], a successor of Choices targeted to support multimedia applications. Pattern-Lint helps reuse and refine structures from Choices in Choices.
Reference: [15] <author> S. Meyers, C. K. Duby, and S. P. Reiss. </author> <title> Constraining the Structure and Style of Object-Oriented Programs. </title> <type> Technical Report CS-93-12, </type> <institution> Brown University, </institution> <year> 1993. </year>
Reference-contexts: Frequent compliance checking helps catch design turnovers before they become irreversible. Surprisingly, there seem to be few preventive tools whose specific purpose is to help assure that the implementation of an evolving system abides by its imposed design principles. Those that we know (e.g., <ref> [16, 15, 13] </ref>) appear to focus exclusively on either static or dynamic analysis, lacking multiple views and perspectives. We improve on these approaches in several ways: * We integrate static analysis and dynamic visualization. <p> Nonetheless, the analysis for heuristic guidelines is rather human-dependent, and the certainty of compli ance is much less. 6 Related work Other systems for monitoring an implementation's faithfulness to its design models appear to have focused on either static or dynamic verification, but not both <ref> [16, 15, 24, 13] </ref>. We improve on these systems by systematic provision of numerous static and dynamic visual perspectives, and by considering a wide range of design commitments, from concrete implementation-level rules to configuration-level principles like subsystem cohesion and coupling.
Reference: [16] <author> G. C. Murphy, D. Notkin, and K. Sullivan. </author> <title> Software Reflex-ion Models: Bridging the Gap Between Source and High-Level Models. </title> <booktitle> In Proceedings of the Third ACM Symposium on the Foundations of Software Engineering, </booktitle> <year> 1995. </year>
Reference-contexts: Frequent compliance checking helps catch design turnovers before they become irreversible. Surprisingly, there seem to be few preventive tools whose specific purpose is to help assure that the implementation of an evolving system abides by its imposed design principles. Those that we know (e.g., <ref> [16, 15, 13] </ref>) appear to focus exclusively on either static or dynamic analysis, lacking multiple views and perspectives. We improve on these approaches in several ways: * We integrate static analysis and dynamic visualization. <p> Nonetheless, the analysis for heuristic guidelines is rather human-dependent, and the certainty of compli ance is much less. 6 Related work Other systems for monitoring an implementation's faithfulness to its design models appear to have focused on either static or dynamic verification, but not both <ref> [16, 15, 24, 13] </ref>. We improve on these systems by systematic provision of numerous static and dynamic visual perspectives, and by considering a wide range of design commitments, from concrete implementation-level rules to configuration-level principles like subsystem cohesion and coupling.
Reference: [17] <author> D. P. Olshefski and A. </author> <title> Code. A Prototype System For Static and Dynamic Program Understanding. </title> <booktitle> In Proceedings of the Working Conference in Reverse Engineering, </booktitle> <address> Baltimore, MD, USA, </address> <year> 1993. </year>
Reference-contexts: In particular, our work also concerns the conformance checking for standardized architectural models [26, 7, 8]: recurring design abstractions that are increasingly popular in the construction of complex systems. Most of the individual features of Pattern-Lint have appeared in isolated reverse engineering tools: architectural styles [10], dynamic analysis <ref> [17, 21] </ref>, program databases [4], and program concept recognition [1, 9]. Pattern-Lint seems to be the first tool to combine all these abilities in design conformance checking.
Reference: [18] <author> J. K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: Another approach for improving design-implementation congruence provides improved notations to represent designs [22]. In limited domains such as interface generators <ref> [18] </ref>, low-level implementations can automatically be generated, assuring design conformance. In using architectural catalogs, Pattern-Lint supports this move toward improved notations. Our animated class interaction views were influenced by De Pauw et al.[19].
Reference: [19] <author> W. De Pauw, R. Helm, D. Kimelman, and J. Vlissides. </author> <title> Visualizing the Behavior of Object-Oriented Systems. </title> <booktitle> In OOP-SLA, </booktitle> <pages> pages 326-337, </pages> <month> October </month> <year> 1993. </year>
Reference: [20] <author> R. S. Pressman. </author> <title> Software Engineering: A Practitioner's Approach. </title> <publisher> McGraw-Hill, Inc, </publisher> <year> 1992. </year>
Reference-contexts: scheme improves compliance checking for well-defined rules as well as subjective guidelines. * We check for conformance to a wide variety of design principles: concrete rules like coding styles [14], ar 1 chitectural rules like design patterns [7] or styles [8], and heuristic guidelines like high cohesion and low coupling <ref> [20] </ref>. * We provide a design rule-base that is reusable across a wide variety of software systems, because the rule-base captures codified architectural styles, connectors, and design patterns that are well-known recurrent de signs. <p> Thus, it is desirable that the subsystems be as self-contained and independent of one another as possible, so that modifying a subsystem has minimal unanticipated side-effects on its neighbors. In the abstract, this requirement is easier to fulfill in systems with low coupling and high cohesion <ref> [20] </ref>. Static analysis: method calls Figure 4 displays a weighted inter-class call graph within and across three Choices subsystems: virtual memory, file system, and naming service.
Reference: [21] <author> Herbert Ritsch and Harry M. Sneed. </author> <title> Reverse Engineering Via Dynamic Program Analysis. </title> <booktitle> In Proceedings of Working Conference on Reverse Engineering, </booktitle> <address> Los alamitos, CA, USA, </address> <year> 1993. </year>
Reference-contexts: In particular, our work also concerns the conformance checking for standardized architectural models [26, 7, 8]: recurring design abstractions that are increasingly popular in the construction of complex systems. Most of the individual features of Pattern-Lint have appeared in isolated reverse engineering tools: architectural styles [10], dynamic analysis <ref> [17, 21] </ref>, program databases [4], and program concept recognition [1, 9]. Pattern-Lint seems to be the first tool to combine all these abilities in design conformance checking.
Reference: [22] <author> J. Rumbaugh, M. Blaha, W. Premerlani, and F. Eddy. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> Eaglewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: The Design: A Mediator Figure 1 depicts in OMT <ref> [22] </ref> notation a fragment of the device management framework in Choices. The framework allows CPU's and Devices to interact. In the figure, the classes CPU and Disk model the corresponding hardware resources. The Disk class has several subclasses, of which we show BufferingDisk, Con-tiguousDisk, and DetailedDisk. <p> Pattern-Lint also extends the application of these ideas by incorporating diverse design principles, celebrating the synergy of static and dynamic visualization, the use of scalable affinity diagrams, and a customizable architecture. Another approach for improving design-implementation congruence provides improved notations to represent designs <ref> [22] </ref>. In limited domains such as interface generators [18], low-level implementations can automatically be generated, assuring design conformance. In using architectural catalogs, Pattern-Lint supports this move toward improved notations. Our animated class interaction views were influenced by De Pauw et al.[19].
Reference: [23] <author> A. Sane and R. H. Campbell. Detachable Inspector: </author> <title> A Structural Pattern for Designing Transparently Layered Services. In Pattern Languages of Programs (To appear), </title> <year> 1995. </year>
Reference-contexts: Except for special situations (e.g., if it is known that the base and derived classes will not be changed), Inheritance/Reference cycles that introduce hidden associations are highly undesirable. In Choices, when such cycles were accidentally established across subsystems, the resulting interdependencies seriously impaired portability and comprehensibility <ref> [23] </ref>. In Choices, we are using Pattern-Lint to ensure that no base class holds references to instances of its derived classes. Substitutability via refinement by addition: Frameworks [6] are groups of collaborating classes that typically implement subsystems in object-oriented programs.
Reference: [24] <author> R. Schwanke. </author> <title> An Intelligent Tool for Reengineering Software Modularity. </title> <booktitle> In Proceedings of the 13th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: In contrast, this experiment demonstrates compliance verification for a highly abstract and subjective design principle: high cohesion and low coupling. Lacking a standard measure of cohesion and coupling, the design principle is best treated heuristically, rather than by a set of formal rules <ref> [24] </ref>. Motivation We are interested in application-specific customization of subsystems in Choices. Thus, it is desirable that the subsystems be as self-contained and independent of one another as possible, so that modifying a subsystem has minimal unanticipated side-effects on its neighbors. <p> Nonetheless, the analysis for heuristic guidelines is rather human-dependent, and the certainty of compli ance is much less. 6 Related work Other systems for monitoring an implementation's faithfulness to its design models appear to have focused on either static or dynamic verification, but not both <ref> [16, 15, 24, 13] </ref>. We improve on these systems by systematic provision of numerous static and dynamic visual perspectives, and by considering a wide range of design commitments, from concrete implementation-level rules to configuration-level principles like subsystem cohesion and coupling.
Reference: [25] <author> M. Sefika and R. H. Campbell. </author> <title> An Open Visual Model For Object-Oriented Operating Systems. </title> <booktitle> In Fourth International Workshop on Object Orientation in Operating Systems, Lund, </booktitle> <address> Sweden, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: The findings and suspicions gathered from static analysis served as a requirements specification for the run-time information to visualize. To graphically analyze system dynamics, Pattern-Lint relies on OS View <ref> [25] </ref>, the visualization and manipulation system for Choices. the thickness of the line connecting two classes corresponds to their relative interaction frequency. This animation was fairly consistent across many application workloads. <p> By selecting edges or nodes, the user can automatically instrument the code in several ways. In addition, at runtime, a user can directly manipulate instruments <ref> [25] </ref>. For instance, the viewer can turn selected instruments on or off to improve the clarity of an affinity diagram like Figure 6. Similarly, the rate of data production (and hence system perturbation) can interactively be controlled.
Reference: [26] <author> M. Shaw, R. DeLine, and G. Zelensnik. </author> <title> Abstractions and Implementations for Architectural Connections. </title> <type> Technical Report CMU-CS-95-136, CMU, </type> <month> March </month> <year> 1995. </year> <month> 10 </month>
Reference-contexts: Recently, research in software architecture has focused on identifying and cataloging reusable design models and rules, including object-oriented patterns [7], architectural styles [8], and software fl Supported by Lesotho AFGRAAD Fellowship. y Supported by CNRI contract CNRI GIGABIT/UILL. connectors <ref> [26] </ref>. Unfortunately, system design improvements are often vitiated by the tendency of implementations to diverge from their intended or documented design models. This suggests that the use of codified design principles must be supplemented by checks to ensure that the actual implementation adheres to its design constraints and guidelines. <p> Our compliance checker, called Pattern-Lint 1 , uses models from various works <ref> [7, 8, 26, 14, 6] </ref>, and our experience in designing Choices [2], one of the earliest object-oriented operating systems. We are using Pattern-Lint to implement Choices [3], a successor of Choices targeted to support multimedia applications. Pattern-Lint helps reuse and refine structures from Choices in Choices. <p> In that case, some of the supposedly mediated colleagues interact directly, thereby adding unexpected interactions not visible by examining DiskController. Such obscure interactions would invalidate any correctness analyses based on examining the me 2 A mediator object is in effect a first class connector <ref> [26] </ref> 2 design model from the browser and queries the expected class roles. Rules for conformance checking come from a pattern recognition knowledge base that is reused and shared by all users. diator alone. <p> Low Level Rules Low level rules (the guidelines of Section 4) govern details closer to implementation than design. These rules are specified using ER diagrams or grammars and mechanically converted to their Prolog equivalents. Architectural Rules These rules include patterns [7], software interconnection models <ref> [26] </ref>, and architectural styles [8]. The rules capture recurring designs, so they are described only once, and reused across a wide variety of software systems. <p> We improve on these systems by systematic provision of numerous static and dynamic visual perspectives, and by considering a wide range of design commitments, from concrete implementation-level rules to configuration-level principles like subsystem cohesion and coupling. In particular, our work also concerns the conformance checking for standardized architectural models <ref> [26, 7, 8] </ref>: recurring design abstractions that are increasingly popular in the construction of complex systems. Most of the individual features of Pattern-Lint have appeared in isolated reverse engineering tools: architectural styles [10], dynamic analysis [17, 21], program databases [4], and program concept recognition [1, 9].
References-found: 26

