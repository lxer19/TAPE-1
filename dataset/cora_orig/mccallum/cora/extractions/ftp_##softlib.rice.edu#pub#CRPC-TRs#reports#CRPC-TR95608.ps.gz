URL: ftp://softlib.rice.edu/pub/CRPC-TRs/reports/CRPC-TR95608.ps.gz
Refering-URL: http://www.crpc.rice.edu/CRPC/softlib/TRs_online.html
Root-URL: 
Title: Object-Parallel Programming with pC++  
Author: Shelby X. Yang, Dennis Gannon, Peter Beckman, Jacob Gotwals, Neelakantan Sundaresan 
Note: This research is supported in part by ARPA DABT63-94-C-0029 and Rome Labs Contract AF 30602-92-C-0135. Copyright MIT Press and Indiana University. This material is to appear in Parallel Programming Using C++, MIT Press, 1996  
Date: November 17, 1995  
Abstract: pC++ is a data parallel extension to C++ that is based on the concept of collections and concurrent aggregates. It is similar in many ways to newer languages like ICC++, Amelia and C** in that it is based on the application of functions to sets of objects. However, it also allows functions to be invoked on each processor to support SPMD-style libraries and it is designed to link with HPF programs. pC++ currently runs on almost all commercial massively-parallel computers, and is being used by the NSF Computational Grand Challenge Cosmology Consortium to support simulations of the evolution of the universe. In this chapter we describe the language and its performance on a variety of problems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G.E. Blelloch. NESL: </author> <title> A Nested Data-Parallel Language. </title> <type> Technical Report CMU-CS-92-103, </type> <institution> School of Computer Science, Carnegie-Mellon University, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: Because the current pC++ preprocessor translates the single threaded data parallel style into direct SPMD emulation of data parallelism, it is very difficult to allow nested parallel operations. Our thinking here has been greatly influenced by the NESL project at Carnegie-Mellon University <ref> [1] </ref>. This research has demonstrated that a wide variety of nested parallel computations can be "flattened" by the compiler and runtime system to produce very efficient code.
Reference: [2] <author> F. Bodin, P. Beckman, D. Gannon, J. Gotwals, S. Narayana, S. Srinivas, and B. Win-nicka. Sage++: </author> <title> An Object Oriented Toolkit and Class Library for Building Fortran and C++ Restructuring Tools. </title> <editor> In M. Chapman and A. Vermeulen, editors, </editor> <booktitle> Proceedings of the Second Annual Object-Oriented Numerics Conference, </booktitle> <address> Corvallis, OR, </address> <year> 1994. </year> <title> Rogue Wave Software. </title>
Reference-contexts: This chapter describes some of these applications. We also discuss two libraries that support parallel I/O and persistent objects in pC++ programs. One of the most interesting byproducts of the pC++ project has been a language preprocessor toolkit called Sage++ <ref> [2] </ref>.
Reference: [3] <author> F. Bodin, P. Beckman, D. Gannon, S. Narayana, and S. Yang. </author> <title> Distributed pC++: Basic Ideas for an Object Parallel Language. </title> <journal> Scientific Programming, </journal> <volume> 2(3), </volume> <year> 1993. </year>
Reference-contexts: Other examples of pC++ programs and performance can be found in <ref> [10, 11, 8, 3, 12] </ref>. Our primary experience with testing the pC++ ideas on large scale problems has come from our involvement with the NSF Grand Challenge Cosmology Consortium GC 3 . This chapter describes some of these applications.
Reference: [4] <author> M.J. Carey, D.J. DeWitt, M.J. Franklin, N.E. Hall, M.L. McAuliffe, J.F. Naughton, D.T. Schuh, M.H. Solomon, C.K. Tan, O.G. Tsatalos, S.J. White, and Y. Zwilling. </author> <title> Shoring Up Persistent Applications. </title> <booktitle> In Proceedings of the 1994 ACM-SIGMOD Conference on the Management of Data, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Extraction functions are defined similarly. pC++/streams is described in more detail in [14]. 3.4 Persistence pC++/persistence is an I/O library supporting persistence for pC++ collections. This library is currently implemented using the SHORE persistent object system from the University of Wisconsin, Madison <ref> [4] </ref>. Normally, elements of pC++ collections are transitory, i.e., their data disappears when the program terminates.
Reference: [5] <author> K.M. Chandy and C. Kesselman. </author> <title> CC++: A Declarative Concurrent Object-oriented Programming Notation. </title> <editor> In G. Agha, P. Wegner, and A. Yonezawa, editors, </editor> <booktitle> Research Directions in Concurrent Object-Oriented Programming, </booktitle> <pages> pages 281-313. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year> <note> ISBN 0-272-01139-5. </note>
Reference-contexts: parallel object-oriented software capable of running without modification on all commercial MIMD systems; * an interface to Single Program Multiple Data (SPMD) libraries such as ScaLapack++ [6], A++ [18] and POOMA; * an interface to High Performance Fortran (HPF) [17]; * an interface to control-parallel C++-based languages such as CC++ <ref> [5] </ref>; * a way to exploit parallel I/O systems and persistent object databases; and * a complete programming environment including all the tools that users of conventional C++ systems expect, as well as tools for parallel performance analysis and debugging.
Reference: [6] <author> J. Choi, J.J. Dongarra, and D.W. Walker. </author> <title> The Design of Scalable Software Libraries for Distributed Memory Concurrent Computers. </title> <editor> In H.J. Siegel, editor, </editor> <booktitle> Proc. Eighth International Parallel Processing Symposium. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: The goal of the pC++ project was to design a simple extension to C++ for parallel pro gramming that provides: * a platform for parallel object-oriented software capable of running without modification on all commercial MIMD systems; * an interface to Single Program Multiple Data (SPMD) libraries such as ScaLapack++ <ref> [6] </ref>, A++ [18] and POOMA; * an interface to High Performance Fortran (HPF) [17]; * an interface to control-parallel C++-based languages such as CC++ [5]; * a way to exploit parallel I/O systems and persistent object databases; and * a complete programming environment including all the tools that users of conventional
Reference: [7] <author> R. Ferrell and E. Bertschinger. </author> <title> Particle-Mesh Methods on the Connection Machine. </title> <journal> International Journal of Modern Physics C, </journal> <year> 1993. </year>
Reference-contexts: The expansions were truncated at nmax = 6 and lmax = 4. 7 The Particle Mesh Code Another N-body code in the dossier of the GC 3 group is the Particle Mesh (PM) code <ref> [7] </ref>. Originally implemented in Fortran-77 and CM Fortran, the particle-mesh method used in the PM code computes long-range gravitational forces in a galaxy or galaxy cluster system by solving the gravitational potential on a mesh. The three-dimensional space is discretize by a three-dimensional grid.
Reference: [8] <author> D. Gannon. </author> <title> Libraries and Tools for Object Parallel Programming. </title> <booktitle> In Advances in Parallel Computing: CNRS-NSF Workshop on Environments and Tools for Parallel Scientific Computing, Saint Hilaire du Touvet, </booktitle> <volume> volume 6, </volume> <pages> pages 231-246. </pages> <publisher> Elsevier Science Publisher, </publisher> <year> 1993. </year>
Reference-contexts: Other examples of pC++ programs and performance can be found in <ref> [10, 11, 8, 3, 12] </ref>. Our primary experience with testing the pC++ ideas on large scale problems has come from our involvement with the NSF Grand Challenge Cosmology Consortium GC 3 . This chapter describes some of these applications.
Reference: [9] <author> D. Gannon, V. Guarna, and J.-K. Lee. </author> <title> Static Analysis and Runtime Support for Parallel Execution of C. </title> <booktitle> In Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 254-274. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: a large number of applications, including the TAU programming environment. 2 History In 1984 the parallel programming research group at Indiana University, working with the Center for Supercomputing Research and Development (CSRD) at the University of Illinois, developed an extension to the C programming language called Vector Parallel C (VPC) <ref> [9] </ref>.
Reference: [10] <author> D. Gannon and J.-K. Lee. </author> <title> Object Oriented Parallelism: pC++ Ideas and Experiments. </title> <booktitle> In Japan Society for Parallel Processing, </booktitle> <pages> pages 13-23, </pages> <year> 1991. </year>
Reference-contexts: Other examples of pC++ programs and performance can be found in <ref> [10, 11, 8, 3, 12] </ref>. Our primary experience with testing the pC++ ideas on large scale problems has come from our involvement with the NSF Grand Challenge Cosmology Consortium GC 3 . This chapter describes some of these applications.
Reference: [11] <author> D. Gannon and J.-K. Lee. </author> <title> On Using Object Oriented Parallel Programming to Build Distributed Algebraic Abstractions. </title> <editor> In Bourge and Cosnard, editors, </editor> <booktitle> Proceedings of CONPAR 92-VAPP V, </booktitle> <pages> pages 769-774. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Other examples of pC++ programs and performance can be found in <ref> [10, 11, 8, 3, 12] </ref>. Our primary experience with testing the pC++ ideas on large scale problems has come from our involvement with the NSF Grand Challenge Cosmology Consortium GC 3 . This chapter describes some of these applications.
Reference: [12] <author> D. Gannon, N. Sundaresan, and P. Beckman. </author> <title> pC++ Meets Multithreaded Computation. </title> <editor> In J.J. Dongarra and B. Tourancheau, editors, </editor> <booktitle> Second Workshop on Environments and Tools for Parallel Scientific Computing, </booktitle> <pages> pages 76-85. </pages> <publisher> SIAM Press, </publisher> <year> 1994. </year>
Reference-contexts: Other examples of pC++ programs and performance can be found in <ref> [10, 11, 8, 3, 12] </ref>. Our primary experience with testing the pC++ ideas on large scale problems has come from our involvement with the NSF Grand Challenge Cosmology Consortium GC 3 . This chapter describes some of these applications.
Reference: [13] <author> D. Gannon, S. Yang, P. Bode, and V. Menkov. </author> <title> Object Oriented Methods for Parallel Execution of Astrophysics Simulations. In Mardigras Teraflops Grand Challenge Conference. </title> <institution> Lousiana State University, </institution> <year> 1994. </year> <month> 31 </month>
Reference-contexts: This work is abstracted from two longer papers [20] and <ref> [13] </ref>. One of the N-body codes developed by the GC 3 researchers is the Self-Consistent Field (SCF) code, which is used to simulate the evolution of galaxies. It solves the coupled Vlasov and Poisson equation for collisionless stellar systems using the N -body approximation approach.
Reference: [14] <author> J. Gotwals, S. Srinivas, and D. Gannon. pC++/streams: </author> <title> a Library for I/O on Complex Distributed Data Structures. </title> <booktitle> In Symposium on the Principles and Practice of Parallel Programming. ACM, </booktitle> <year> 1995. </year>
Reference-contexts: Extraction functions are defined similarly. pC++/streams is described in more detail in <ref> [14] </ref>. 3.4 Persistence pC++/persistence is an I/O library supporting persistence for pC++ collections. This library is currently implemented using the SHORE persistent object system from the University of Wisconsin, Madison [4]. Normally, elements of pC++ collections are transitory, i.e., their data disappears when the program terminates.
Reference: [15] <author> L. Hernquist and J.P. Ostriker. </author> <title> A Self-Consistent Field Method for Galactic Dynamics. </title> <journal> The Astrophysical Journal, </journal> <volume> 386 </volume> <pages> 375-397, </pages> <year> 1992. </year>
Reference-contexts: The basis set is constructed so that the lowest order members well-approximate a galaxy obeying the de 21 Vaucouleurs R 1=4 projected density profile law. The algorithm used is described in detail in <ref> [15] </ref>. The original SCF code was written in Fortran-77 by Lars Hernquist in 1991. In 1993, the code was converted to Thinking Machines CM Fortran by Greg Bryan. <p> In 1993, the code was converted to Thinking Machines CM Fortran by Greg Bryan. Expirements conducted by Bryan on the 512-node CM-5 at the National Center for Supercomputing Applications (NCSA) indicate that with 10 million particles the CMF code can achieve 14.4 Gflops on 512 nodes of the CM-5 <ref> [15] </ref>. The expansions of the density and potential take the following forms: (~r) = nlm (~r) = nlm where n is the radial quantum number and l and m are quantum numbers for the angular variables. Generally, the two sums will involve different expansion coefficients.
Reference: [16] <author> Y. Ishikawa, A. Hori, M. Sato, M. Matsuda, J. Nolte, H. Tezuka, H. Konaka, M. Maeda, and T. Tomokiyo. </author> <title> RWC Massively Parallel Software Environment and An Overview of MPC++. </title> <booktitle> In Proceedings of the Workshop on Parallel Symbolic Languages and Systems, </booktitle> <year> 1995. </year>
Reference-contexts: Users require programming environments that are stable and that are supported by all vendors. For the future it may be important to design a meta-level control extension facility for C++ (similar to the Japanese RWPC C++ system <ref> [16] </ref>) so that language extensions are needed. With this approach, new parallel constructs 29 could be added to the language by providing a library that would work with any C++ system. It is a mistake to design a system that limits the parallel programming paradigms which can be used.
Reference: [17] <author> C.H. Koelbel, D.B. Loveman, R.S. Schreiber, G.L. Steele Jr., and M.E. Zosel. </author> <title> The High Performance Fortran Handbook. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: C++ for parallel pro gramming that provides: * a platform for parallel object-oriented software capable of running without modification on all commercial MIMD systems; * an interface to Single Program Multiple Data (SPMD) libraries such as ScaLapack++ [6], A++ [18] and POOMA; * an interface to High Performance Fortran (HPF) <ref> [17] </ref>; * an interface to control-parallel C++-based languages such as CC++ [5]; * a way to exploit parallel I/O systems and persistent object databases; and * a complete programming environment including all the tools that users of conventional C++ systems expect, as well as tools for parallel performance analysis and debugging.
Reference: [18] <author> M. Lemke and D. Quinlan. </author> <title> P++, a Parallel C++ Array Class Library for Architecture-Independent Development of Numerical Software. </title> <booktitle> In Proceedings of the First Annual Object-Oriented Numerics Conference, </booktitle> <pages> pages 268-269, </pages> <year> 1993. </year>
Reference-contexts: of the pC++ project was to design a simple extension to C++ for parallel pro gramming that provides: * a platform for parallel object-oriented software capable of running without modification on all commercial MIMD systems; * an interface to Single Program Multiple Data (SPMD) libraries such as ScaLapack++ [6], A++ <ref> [18] </ref> and POOMA; * an interface to High Performance Fortran (HPF) [17]; * an interface to control-parallel C++-based languages such as CC++ [5]; * a way to exploit parallel I/O systems and persistent object databases; and * a complete programming environment including all the tools that users of conventional C++ systems
Reference: [19] <author> B. Stroustrup. </author> <title> Parameterized Types for C++. </title> <booktitle> In USENIX C++ Conference, </booktitle> <address> Denver, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: The first problem to be solved was how to describe a generic set of objects in C++. At the time, the C++ template mechanism was not yet a complete proposal to the C++ standards committee, although early public documents such as <ref> [19] </ref> guided our thinking. Even had they existed, templates would not have solved all of our problems.
Reference: [20] <author> S. Yang, D. Gannon, S. Bodin, P. Bode, and S. Srinivas. </author> <title> High Performance Fortran Interface to the Parallel C++. </title> <booktitle> In Scalable High Performance Computing Conference. IEEE, </booktitle> <year> 1994. </year> <month> 32 </month>
Reference-contexts: This work is abstracted from two longer papers <ref> [20] </ref> and [13]. One of the N-body codes developed by the GC 3 researchers is the Self-Consistent Field (SCF) code, which is used to simulate the evolution of galaxies. It solves the coupled Vlasov and Poisson equation for collisionless stellar systems using the N -body approximation approach. <p> Now Fortran subroutines in the original Fortran code can be used as member functions of the Segment class, although subroutines involving inter-element communication and I/O need to be modified. The Fortran subroutines are called by pC++ through a specially designed Fortran interface <ref> [20] </ref>.
References-found: 20

