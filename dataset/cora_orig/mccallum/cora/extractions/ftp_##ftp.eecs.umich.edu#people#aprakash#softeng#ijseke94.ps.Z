URL: ftp://ftp.eecs.umich.edu/people/aprakash/softeng/ijseke94.ps.Z
Refering-URL: http://www.eecs.umich.edu/~aprakash/csrg_pub.html
Root-URL: http://www.cs.umich.edu
Email: email: fsantanu,aprakashg@eecs.umich.edu  email: aprakash@eecs.umich.edu  
Phone: phone: (313) 763-1585 FAX: (313) 763-1503  
Title: Supporting Queries on Source Code: A Formal Framework  
Author: Santanu Paul Atul Prakash 
Note: Contact Addresses: Prof. Atul Prakash (Primary Contact)  Office  This research was supported in part by a fellowship from IBM Canada Ltd.  
Address: Ann Arbor, MI 48109-2122  Ann Arbor, MI 48109-2122.  
Affiliation: Software Systems Research Laboratory Department of Electrical Engineering and Computer Science University of Michigan  Dept. of Electrical Engineering and Computer Science University of Michigan  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> T.A. Corbi. </author> <title> Program Understanding: Challenge for the 1990s. </title> <journal> IBM Systems Journal, </journal> <volume> 28(2) </volume> <pages> 294-306, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Programmers have become part historian, part detective, and part clairvoyant. Tom Corbi, in Program Understanding: Challenge for the 1990s <ref> [1] </ref>. In the last few years, software reverse engineering, code re-engineering, and program understanding have emerged as the latest challenges in the field of software engineering. <p> One of the early conclusions in reverse engineering research is that a complete automation of the design recovery process is not feasible <ref> [1] </ref>. Given the current state-of-art in reverse engineering technology, it is felt that reverse engineering of real systems can at best be automated 50 percent, and the rest must be by human participation [2].
Reference: [2] <author> E. Yourdon. </author> <title> RE-3. </title> <journal> American Programmer, </journal> <volume> 2(4) </volume> <pages> 3-10, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Given the current state-of-art in reverse engineering technology, it is felt that reverse engineering of real systems can at best be automated 50 percent, and the rest must be by human participation <ref> [2] </ref>. This acceptance of the critical role that must be played by a human reverse engineer has led to research in software tools that can assist or support the human in this task.
Reference: [3] <author> Y. Chen, M.Y. Nishimoto, </author> <title> and C.V. Ramamoorthy. The C Information Abstraction System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 325-334, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Support for extracting relevant information from source code has so far been left either to rudimentary, string searching tools like grep, awk, etc. (which are capable of handling only trivial queries), or to general-purpose database approaches that have limited querying power for the source code domain <ref> [3, 4, 5] </ref>. The need for sophisticated querying tools for reverse engineering has been articulated by Biggerstaff in terms of a "conceptual grep" [6]. <p> One option for us was to use the relational model, as used in several systems such as OMEGA [5], CIA <ref> [3] </ref>, and CIA++ [13]. The advantage of that would have been the availability of a formal query language (based on relational algebra) | our work in developing a query language and a query processor would have been reduced.
Reference: [4] <author> L. Cleveland. </author> <title> A Program Understanding Support Environment. </title> <journal> IBM Systems Journal, </journal> <volume> 28(2) </volume> <pages> 324-344, </pages> <year> 1989. </year>
Reference-contexts: Support for extracting relevant information from source code has so far been left either to rudimentary, string searching tools like grep, awk, etc. (which are capable of handling only trivial queries), or to general-purpose database approaches that have limited querying power for the source code domain <ref> [3, 4, 5] </ref>. The need for sophisticated querying tools for reverse engineering has been articulated by Biggerstaff in terms of a "conceptual grep" [6].
Reference: [5] <author> M.A. Linton. </author> <title> Implementing Relational Views of Programs. </title> <booktitle> In Proc. of ACM SIG-SOFT/SIGPLAN Software Engineering Symposium, </booktitle> <month> May </month> <year> 1984. </year> <title> Practical Software Development Environment. </title>
Reference-contexts: Support for extracting relevant information from source code has so far been left either to rudimentary, string searching tools like grep, awk, etc. (which are capable of handling only trivial queries), or to general-purpose database approaches that have limited querying power for the source code domain <ref> [3, 4, 5] </ref>. The need for sophisticated querying tools for reverse engineering has been articulated by Biggerstaff in terms of a "conceptual grep" [6]. <p> One option for us was to use the relational model, as used in several systems such as OMEGA <ref> [5] </ref>, CIA [3], and CIA++ [13]. The advantage of that would have been the availability of a formal query language (based on relational algebra) | our work in developing a query language and a query processor would have been reduced.
Reference: [6] <author> T. Biggerstaff, B.G. Mitbander, and D. Webster. </author> <title> The Concept Assignment Problem in Program Understanding. </title> <booktitle> In Proc. of the 15th International Conference on Software Engineering, </booktitle> <pages> pages 482-498, </pages> <year> 1993. </year>
Reference-contexts: The need for sophisticated querying tools for reverse engineering has been articulated by Biggerstaff in terms of a "conceptual grep" <ref> [6] </ref>. The purpose of a source code querying tool is to help a human reverse engineer indulge in plausible reasoning [6] or domain bridging [7] | an iterative process of guesswork and verification that leads him or her to a better understanding of what the source code is doing. <p> The need for sophisticated querying tools for reverse engineering has been articulated by Biggerstaff in terms of a "conceptual grep" <ref> [6] </ref>. The purpose of a source code querying tool is to help a human reverse engineer indulge in plausible reasoning [6] or domain bridging [7] | an iterative process of guesswork and verification that leads him or her to a better understanding of what the source code is doing. International Journal of Software Engineering and Knowledge Engineering 4 Reverse engineers may need to make several types of queries.
Reference: [7] <author> R. Brooks. </author> <title> Towards a Theory of Comprehension of Computer Programs. </title> <journal> International Journal of Man Machine Studies, </journal> <volume> 18 </volume> <pages> 543-554, </pages> <year> 1983. </year>
Reference-contexts: The need for sophisticated querying tools for reverse engineering has been articulated by Biggerstaff in terms of a "conceptual grep" [6]. The purpose of a source code querying tool is to help a human reverse engineer indulge in plausible reasoning [6] or domain bridging <ref> [7] </ref> | an iterative process of guesswork and verification that leads him or her to a better understanding of what the source code is doing. International Journal of Software Engineering and Knowledge Engineering 4 Reverse engineers may need to make several types of queries.
Reference: [8] <author> S. Paul and A. Prakash. </author> <title> A Framework for Source Code Search Using Program Patterns. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> June </month> <year> 1994. </year> <journal> International Journal of Software Engineering and Knowledge Engineering 30 </journal>
Reference-contexts: Queries can also be based on statement-level structural information in the source code, e.g., looking for patterns (e.g., loops) that fit a programming plan or a cliche <ref> [8, 9] </ref>. Queries may also be based on flow information derived by static analyses such as data-flow and control-flow analyses, e.g., to locate program slices [10], to find the variables whose values are affected by a particular statement, etc. <p> Unfortunately, one of the fundamental problems designers of source code querying systems face is the lack of good underlying models to represent source code information and to express queries. For example, in our previous work on building source code querying tools SCAN [11] and SCRUPLE <ref> [8] </ref>, and earlier in our work on the Evolution Support Environment System (ESE) [12], we found that no satisfactory choice for the underlying model to represent program information was available. <p> Sequence algorithms were tested in the SCRUPLE system and need to be incorporated into the query processor. Performance results for operating on sequences were promising and are available in <ref> [8] </ref>. 6 Comparison of SCA with other Query Algebras The most well-known query algebra is the relational algebra. Query languages for the nested and extended relational models have also been developed by relaxing the first normal form restriction of relational algebra [18, 19].
Reference: [9] <author> C. Rich and R. Waters. </author> <title> The Programmer's Apprentice. </title> <publisher> Addison-Wesley, </publisher> <address> Baltimore, Maryland, </address> <year> 1990. </year>
Reference-contexts: Queries can also be based on statement-level structural information in the source code, e.g., looking for patterns (e.g., loops) that fit a programming plan or a cliche <ref> [8, 9] </ref>. Queries may also be based on flow information derived by static analyses such as data-flow and control-flow analyses, e.g., to locate program slices [10], to find the variables whose values are affected by a particular statement, etc.
Reference: [10] <author> M. Weiser. </author> <title> Program Slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10(4) </volume> <pages> 352-357, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: Queries may also be based on flow information derived by static analyses such as data-flow and control-flow analyses, e.g., to locate program slices <ref> [10] </ref>, to find the variables whose values are affected by a particular statement, etc. Finally, a reverse engineer may need to make queries that use both structural information as well as program flow information.
Reference: [11] <author> R. Al-Zoubi and A. Prakash. </author> <title> Software Change Analysis via Attributed Dependency Graphs. </title> <type> Technical Report CSE-TR-95-91, </type> <institution> Dept. of EECS, University of Michigan, </institution> <month> May </month> <year> 1991. </year> <note> Also in Software Maintenance, to appear. </note>
Reference-contexts: Unfortunately, one of the fundamental problems designers of source code querying systems face is the lack of good underlying models to represent source code information and to express queries. For example, in our previous work on building source code querying tools SCAN <ref> [11] </ref> and SCRUPLE [8], and earlier in our work on the Evolution Support Environment System (ESE) [12], we found that no satisfactory choice for the underlying model to represent program information was available.
Reference: [12] <author> C.V. Ramamoorthy, Y. Usuda, A. Prakash, and W.T. Tsai. </author> <title> The Evolution Support Environment System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(11) </volume> <pages> 1225-1234, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: For example, in our previous work on building source code querying tools SCAN [11] and SCRUPLE [8], and earlier in our work on the Evolution Support Environment System (ESE) <ref> [12] </ref>, we found that no satisfactory choice for the underlying model to represent program information was available. One option for us was to use the relational model, as used in several systems such as OMEGA [5], CIA [3], and CIA++ [13].
Reference: [13] <author> J.E. Grass. </author> <title> Object-Oriented Design Archaeology with CIA++. </title> <journal> Computing Systems: The Journal of the USENIX Association, </journal> <volume> 5(1) </volume> <pages> 5-67, </pages> <month> Winter </month> <year> 1992. </year>
Reference-contexts: One option for us was to use the relational model, as used in several systems such as OMEGA [5], CIA [3], and CIA++ <ref> [13] </ref>. The advantage of that would have been the availability of a formal query language (based on relational algebra) | our work in developing a query language and a query processor would have been reduced.
Reference: [14] <author> H.A. Muller, M.A Orgun, S.R. Tilley, and J.S. Uhl. </author> <title> A Reverse Engineering Approach to Subsystem Structure Identification. Software Maintenance: </title> <journal> Research and Practice, </journal> <volume> 5(4) </volume> <pages> 181-204, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Another option would have been to use some other representation model such as graphs or abstract syntax trees, as used in Rigi <ref> [14] </ref> or an object-based representation as used in REFINE 1 [15] and in the approach of Heisler et al [16]. However, the problem with those models would have been the lack of a query language with well-defined operators. Either option was somewhat unsatisfactory.
Reference: [15] <author> G.B. Kotik and L.Z. Markosian. </author> <title> Automating Software Analysis and Testing Using a Program Transformation System. </title> <booktitle> In Proceedings of ACM SIGSOFT, </booktitle> <pages> pages 75-84, </pages> <year> 1989. </year>
Reference-contexts: Another option would have been to use some other representation model such as graphs or abstract syntax trees, as used in Rigi [14] or an object-based representation as used in REFINE 1 <ref> [15] </ref> and in the approach of Heisler et al [16]. However, the problem with those models would have been the lack of a query language with well-defined operators. Either option was somewhat unsatisfactory.
Reference: [16] <author> K. Heisler, Y. Kasho, and W.T. Tsai. </author> <title> A Reverse Engineering Model for C Programs. </title> <journal> Information Sciences, </journal> <volume> 68 </volume> <pages> 155-193, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: Another option would have been to use some other representation model such as graphs or abstract syntax trees, as used in Rigi [14] or an object-based representation as used in REFINE 1 [15] and in the approach of Heisler et al <ref> [16] </ref>. However, the problem with those models would have been the lack of a query language with well-defined operators. Either option was somewhat unsatisfactory.
Reference: [17] <author> E.F. Codd. </author> <title> A relational model for large shared data banks. </title> <journal> Communications of the ACM, </journal> <volume> 13(6) </volume> <pages> 377-387, </pages> <year> 1970. </year>
Reference-contexts: An algebra defines a model for representing source code information and gives a well-defined set of operators that can be used to make queries on the information. The analogy is the use of relational algebra <ref> [17] </ref> as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [17], the nested relational model [18], the extended relational model [19], the object model [20, 21, 22, 23], and also in the design of a domain-specific <p> The analogy is the use of relational algebra <ref> [17] </ref> as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [17], the nested relational model [18], the extended relational model [19], the object model [20, 21, 22, 23], and also in the design of a domain-specific query language for structured office documents [24]. <p> Second, it should be non-procedural. The arguments in favor of building a formal query language are compelling. The constructs of a formal language have well-defined semantics. It has been observed in the context of query languages that formal frameworks such as relational algebra <ref> [17] </ref>, relational calculus [25], NST-Algebra 2 [24], etc. have yielded powerful and expressive high-level query languages, and have been argued to be functionally complete within their respective data models. Well-defined semantics has led to clean implementations for query processors. <p> Relations are sets of tuples whose fields have atomic values such as integers, strings, etc. The primitive operators of the algebra are union ([), set difference (), select ( c ), project ( a 1 ;a 2 ;:::; ), and cartesian product (fi) <ref> [17] </ref>. Join (1) is a derived operator of the algebra (composition of and fi). Each of these operators takes relations International Journal of Software Engineering and Knowledge Engineering 11 as arguments, and produces new relations. <p> The signatures of the operators are shown in Table 1. Codd has shown that all information stored using relations can be accessed using the five primitive operators of relational algebra. In that sense, the relational algebra is query-complete <ref> [17] </ref>. Relational algebra has also been shown to be equivalent to relational calculus [25]. Relational algebra (or its equivalent relational calculus) forms the basis of a wide variety of relational database query languages such as SQL, QUEL, ISBL, and QBE [25].
Reference: [18] <author> G. Jaeschke. </author> <title> Recursive Algebra for relations with relation-valued attributes. </title> <type> Technical Report TR 85.03.002, </type> <institution> IBM Heidelberg Scientific Center, </institution> <address> Heidelberg, Germany, </address> <year> 1985. </year> <journal> International Journal of Software Engineering and Knowledge Engineering 31 </journal>
Reference-contexts: The analogy is the use of relational algebra [17] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [17], the nested relational model <ref> [18] </ref>, the extended relational model [19], the object model [20, 21, 22, 23], and also in the design of a domain-specific query language for structured office documents [24]. <p> For example, a while-statement object has two structural components, the condition (of type expression) and the body (of type statement). Singular objects are analogous to nested relations in the nested relational model <ref> [18] </ref>. Collective objects: These are collections of other objects. For example, the type statement-list represents a sequence of objects of type statement. <p> Query languages for the nested and extended relational models have also been developed by relaxing the first normal form restriction of relational algebra <ref> [18, 19] </ref>. The primary data type in these models is the relation, which is a set of tuples. Inspired by the relational model, some object-oriented database systems have attempted to develop object algebras to serve as a basis for their query languages.
Reference: [19] <author> H.J. Schek and M.H. Scholl. </author> <title> An Algebra for the relational model with relation-valued attributes. </title> <journal> Information Systems, </journal> <volume> 11 </volume> <pages> 137-147, </pages> <year> 1986. </year>
Reference-contexts: The analogy is the use of relational algebra [17] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [17], the nested relational model [18], the extended relational model <ref> [19] </ref>, the object model [20, 21, 22, 23], and also in the design of a domain-specific query language for structured office documents [24]. <p> Query languages for the nested and extended relational models have also been developed by relaxing the first normal form restriction of relational algebra <ref> [18, 19] </ref>. The primary data type in these models is the relation, which is a set of tuples. Inspired by the relational model, some object-oriented database systems have attempted to develop object algebras to serve as a basis for their query languages.
Reference: [20] <author> F. Manola and U. Dayal. PDM: </author> <title> an Object-oriented Data Model. </title> <booktitle> In Proc. of Intl. Workshop on Object-oriented Database Systems, </booktitle> <pages> pages 18-25, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: The analogy is the use of relational algebra [17] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [17], the nested relational model [18], the extended relational model [19], the object model <ref> [20, 21, 22, 23] </ref>, and also in the design of a domain-specific query language for structured office documents [24]. <p> The primary data type in these models is the relation, which is a set of tuples. Inspired by the relational model, some object-oriented database systems have attempted to develop object algebras to serve as a basis for their query languages. Some of these algebras are the PDM algebra <ref> [20] </ref>, Osborn's algebra [21], Straube and Ozsu's algebra [23], and Shaw and Zdonik's algebra [22]. The object algebras treat all their data types as first class objects and, compared to relational algebra, permit considerably more orthogonality between objects and type constructors.
Reference: [21] <author> S.L. Osborn. </author> <title> Identity, Equality and Query Optimization. </title> <booktitle> In 2nd Intl. Workshop on Object-oriented Database Systems, </booktitle> <pages> pages 346-351. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1988. </year>
Reference-contexts: The analogy is the use of relational algebra [17] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [17], the nested relational model [18], the extended relational model [19], the object model <ref> [20, 21, 22, 23] </ref>, and also in the design of a domain-specific query language for structured office documents [24]. <p> One reason is that many of the set operators in SCA are extended from relational and extended relational algebras, for which optimizations already exist <ref> [21, 35] </ref>. Furthermore, many sequence operators introduced in SCA (such as seq-extract) can be implemented using efficient algorithms developed in our work on the SCRUPLE system. Obviously, the above is only an outline of the ideas required to incorporate the framework in a query system. <p> Inspired by the relational model, some object-oriented database systems have attempted to develop object algebras to serve as a basis for their query languages. Some of these algebras are the PDM algebra [20], Osborn's algebra <ref> [21] </ref>, Straube and Ozsu's algebra [23], and Shaw and Zdonik's algebra [22]. The object algebras treat all their data types as first class objects and, compared to relational algebra, permit considerably more orthogonality between objects and type constructors.
Reference: [22] <author> G.M. Shaw and S.B. Zdonik. </author> <title> An Object-oriented Query Algebra. </title> <journal> Bulletin of IEEE technical committee on Data Engineering, </journal> <volume> 12(3) </volume> <pages> 29-36, </pages> <year> 1989. </year>
Reference-contexts: The analogy is the use of relational algebra [17] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [17], the nested relational model [18], the extended relational model [19], the object model <ref> [20, 21, 22, 23] </ref>, and also in the design of a domain-specific query language for structured office documents [24]. <p> Inspired by the relational model, some object-oriented database systems have attempted to develop object algebras to serve as a basis for their query languages. Some of these algebras are the PDM algebra [20], Osborn's algebra [21], Straube and Ozsu's algebra [23], and Shaw and Zdonik's algebra <ref> [22] </ref>. The object algebras treat all their data types as first class objects and, compared to relational algebra, permit considerably more orthogonality between objects and type constructors. Object algebras differ from one another in the range of their supported types and, more importantly, in their operators.
Reference: [23] <author> D.D. </author> <title> Straube and M.T. Ozsu. Queries and Query processing in Object-oriented Database Systems. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 8(4), </volume> <month> October </month> <year> 1990. </year>
Reference-contexts: The analogy is the use of relational algebra [17] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [17], the nested relational model [18], the extended relational model [19], the object model <ref> [20, 21, 22, 23] </ref>, and also in the design of a domain-specific query language for structured office documents [24]. <p> Inspired by the relational model, some object-oriented database systems have attempted to develop object algebras to serve as a basis for their query languages. Some of these algebras are the PDM algebra [20], Osborn's algebra [21], Straube and Ozsu's algebra <ref> [23] </ref>, and Shaw and Zdonik's algebra [22]. The object algebras treat all their data types as first class objects and, compared to relational algebra, permit considerably more orthogonality between objects and type constructors.
Reference: [24] <author> R.H. Guting, R. Zicari, </author> <title> and D.M. Choy. An Algebra for Structured Office Documents. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 7(4) </volume> <pages> 123-157, </pages> <year> 1989. </year>
Reference-contexts: Algebras have also been used in the design of general-purpose query languages for the relational data model [17], the nested relational model [18], the extended relational model [19], the object model [20, 21, 22, 23], and also in the design of a domain-specific query language for structured office documents <ref> [24] </ref>. The benefits of using an algebra as the basis for a query language include the ability to provide formal specifications for query language constructs, the ability to use the algebra itself as a low-level query language, and opportunities for query optimization. <p> Second, it should be non-procedural. The arguments in favor of building a formal query language are compelling. The constructs of a formal language have well-defined semantics. It has been observed in the context of query languages that formal frameworks such as relational algebra [17], relational calculus [25], NST-Algebra 2 <ref> [24] </ref>, etc. have yielded powerful and expressive high-level query languages, and have been argued to be functionally complete within their respective data models. Well-defined semantics has led to clean implementations for query processors. <p> However, a major weakness of relational algebra is that it fails to include basic data types such as integers, strings, etc. as elements of the algebra itself. Consequently, many operations permitted in SQL (aggregate, sort, etc.) do not have well-defined semantics in terms of relational algebra <ref> [24] </ref>. Relational algebra also helps in query optimization by algebraic transformations. Consider the relational algebra expression c 1 ( c 2 (R)). <p> This is equivalent to the operator in NST-Algebra <ref> [24] </ref>, and the extend operator in Schek and Scholl's extended relational algebra [35]. extend is an extremely powerful operator that allows new attributes to be added to existing type definitions. <p> One of the major drawbacks of these algebras is that they fail to provide modeling and operator support for data type collections such as sequences. Like relational algebra, object algebras are essentially set-oriented. Unlike set algebras, the field of sequence algebras is in its infancy. The NST-algebra <ref> [24] </ref> is a many-sorted algebra used as a query language for structured office documents, a domain where nested sequences arise naturally. Documents are modeled as nested sequences of tuples (NST).
Reference: [25] <author> J.D. Ullman. </author> <title> Principles of Database Systems. </title> <publisher> Computer Science Press International, </publisher> <address> Rockville, Maryland, </address> <year> 1990. </year>
Reference-contexts: Second, it should be non-procedural. The arguments in favor of building a formal query language are compelling. The constructs of a formal language have well-defined semantics. It has been observed in the context of query languages that formal frameworks such as relational algebra [17], relational calculus <ref> [25] </ref>, NST-Algebra 2 [24], etc. have yielded powerful and expressive high-level query languages, and have been argued to be functionally complete within their respective data models. Well-defined semantics has led to clean implementations for query processors. <p> Codd has shown that all information stored using relations can be accessed using the five primitive operators of relational algebra. In that sense, the relational algebra is query-complete [17]. Relational algebra has also been shown to be equivalent to relational calculus <ref> [25] </ref>. Relational algebra (or its equivalent relational calculus) forms the basis of a wide variety of relational database query languages such as SQL, QUEL, ISBL, and QBE [25]. <p> In that sense, the relational algebra is query-complete [17]. Relational algebra has also been shown to be equivalent to relational calculus <ref> [25] </ref>. Relational algebra (or its equivalent relational calculus) forms the basis of a wide variety of relational database query languages such as SQL, QUEL, ISBL, and QBE [25]. However, a major weakness of relational algebra is that it fails to include basic data types such as integers, strings, etc. as elements of the algebra itself. Consequently, many operations permitted in SQL (aggregate, sort, etc.) do not have well-defined semantics in terms of relational algebra [24]. <p> Many such identities that arise in relational algebra are used in practice to optimize queries <ref> [25] </ref>. 3.2 The Domain of Source Code 3.2.1 Many Data Types An obvious difference between relational algebra and an algebra for source code is that the latter must handle many different kinds of data types. We will concern ourselves with source code written in C. <p> It is important to point out here that new attributes may be added to objects during a query. These can be thought of as derived attributes, and their computation is analogous to the view generation problem in relational databases <ref> [25] </ref>.
Reference: [26] <author> M. Stonebraker et al. </author> <title> Third-generation database system manifesto. </title> <journal> ACM SIGMOD Record, </journal> <volume> 19(3), </volume> <year> 1990. </year>
Reference-contexts: In either case, there is no need for detailed procedural descriptions of queries. In contrast, the lack of formal frameworks and the absence of non-procedural query languages in many object-oriented data models has led to problems in query processing and optimization <ref> [26] </ref>. 2 NST stands for Nested Sequence of Tuples International Journal of Software Engineering and Knowledge Engineering 10 3 Our Approach: An Algebra for Source Code To facilitate queries on source code, we have developed a source code data model that captures the necessary structural and program flow information and designed
Reference: [27] <author> M. Atkinson et al. </author> <title> The Object-Oriented Database System Manifesto. </title> <type> Technical Report ALTAIR TR 30-89, </type> <institution> GIP ALTAIR, LeChesnay, France, </institution> <year> 1989. </year>
Reference-contexts: An attribute of an object can also be a method or a function that is computed on-the-fly. Methods are usually computed to obtain reference or annotation information, during query International Journal of Software Engineering and Knowledge Engineering 14 execution. Methods are a standard feature of object-oriented data models <ref> [27] </ref>, and can be used to introduce complex and specialized algorithms into the data model.
Reference: [28] <author> K. Kennedy. </author> <title> Program Flow Analysis: theory and applications, chapter 1. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Methods are a standard feature of object-oriented data models [27], and can be used to introduce complex and specialized algorithms into the data model. For example, efficient algorithms for data flow analysis such as live variable analysis, available expression analysis, etc. <ref> [28] </ref> can be used to compute the attributes such as "live" (see STATEMENT in next statements in the "uses" chain. While the algebra, in principle, should be powerful enough for such computations, methods can be used as hooks to incorporate specialized algorithms on grounds of efficiency.
Reference: [29] <author> G. Birkhoff and D. Lipson. </author> <title> Heterogeneous Algebras. </title> <journal> Journal of Combinatorial Theory, </journal> <volume> 8 </volume> <pages> 115-133, </pages> <year> 1970. </year> <journal> International Journal of Software Engineering and Knowledge Engineering 32 </journal>
Reference-contexts: The first condition can be satisfied if, instead of using the class of one-sorted algebras, we use the class of many-sorted algebras <ref> [29, 30] </ref> to model SCA. Unlike one-sorted algebras that model a single data type, many-sorted algebras can model a variety of atomic and composite data types and the operations on those types within a single algebraic framework.
Reference: [30] <author> J.A. Goguen, J.W. Thatcher, and E.G. Wagner. </author> <title> An Initial Algebra Approach to the specification, correctness, and implementation of abstract data types. In R.T. Yeh, editor, </title> <booktitle> Current Trends in Programming Methodology, Vol:IV, chapter 5. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1978. </year>
Reference-contexts: The first condition can be satisfied if, instead of using the class of one-sorted algebras, we use the class of many-sorted algebras <ref> [29, 30] </ref> to model SCA. Unlike one-sorted algebras that model a single data type, many-sorted algebras can model a variety of atomic and composite data types and the operations on those types within a single algebraic framework.
Reference: [31] <author> J. Goguen and J. Meseguer. </author> <title> Extensions and Foundations of Object-oriented Programming. </title> <type> Technical report, </type> <institution> SRI, </institution> <year> 1986. </year>
Reference-contexts: The issue of ordering the sorts of a many-sorted algebra was first addressed as a theoretical problem by Goguen and Meseguer <ref> [31] </ref> who proposed an order-sorted algebra based on the interpretation of subsorts (subtypes) as International Journal of Software Engineering and Knowledge Engineering 15 subsets. The interpretation of subsorts was later relaxed in the work of Bruce and Wegner on generalized order-sorted algebras to a weaker form of behavioral compatibility [32].
Reference: [32] <author> K. Bruce and P. Wegner. </author> <title> An Algebraic Model of Subtype and Inheritance. </title> <editor> In F. Bancil-hon and P. Buneman, editors, </editor> <booktitle> Advances in Database Programming Languages, chapter 5. </booktitle> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: The interpretation of subsorts was later relaxed in the work of Bruce and Wegner on generalized order-sorted algebras to a weaker form of behavioral compatibility <ref> [32] </ref>. Essentially, a sort is a subsort of another if the former is behaviorally compatible with (i.e., can be substituted for) the latter. A generalized order-sorted algebra is thus a many-sorted algebra with a partial order defined on its sorts.
Reference: [33] <author> S. Ginsburg and X. Wang. </author> <title> Pattern Matching by Rs-Operations: Towards a Unified Approach to Querying Sequenced Data. </title> <booktitle> In Proc. of the 11th ACM SIGACT/SIGMOD/SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 293-300, </pages> <year> 1992. </year>
Reference-contexts: We have used and extended operators from pre-existing object algebras for set operations, generalizing them to operate on sequences wherever possible, and proposed appropriate operators for sequences. Operators for sequences have only recently begun to be proposed in literature <ref> [33, 34] </ref>. We have introduced seq extract, a powerful new operator for sequences which uses regular expressions as the basis for extracting subsequences. SCA offers a unified approach to querying collections, whether they be sets or sequences.
Reference: [34] <author> J. Richardson. </author> <title> Supporting Lists in a Data Model. </title> <booktitle> In Proc. of the 18th VLDB Conference, </booktitle> <pages> pages 127-138, </pages> <year> 1992. </year>
Reference-contexts: We have used and extended operators from pre-existing object algebras for set operations, generalizing them to operate on sequences wherever possible, and proposed appropriate operators for sequences. Operators for sequences have only recently begun to be proposed in literature <ref> [33, 34] </ref>. We have introduced seq extract, a powerful new operator for sequences which uses regular expressions as the basis for extracting subsequences. SCA offers a unified approach to querying collections, whether they be sets or sequences.
Reference: [35] <author> H.J. Schek and M.H. Scholl. </author> <title> A Relational Object Model. </title> <booktitle> In 3rd Intl. Conference on Database Theory, </booktitle> <pages> pages 89-105. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: This is equivalent to the operator in NST-Algebra [24], and the extend operator in Schek and Scholl's extended relational algebra <ref> [35] </ref>. extend is an extremely powerful operator that allows new attributes to be added to existing type definitions. Given two collections of objects, product returns a set of objects obtained by systematically combining all possible pairs of objects between the two collections. <p> One reason is that many of the set operators in SCA are extended from relational and extended relational algebras, for which optimizations already exist <ref> [21, 35] </ref>. Furthermore, many sequence operators introduced in SCA (such as seq-extract) can be implemented using efficient algorithms developed in our work on the SCRUPLE system. Obviously, the above is only an outline of the ideas required to incorporate the framework in a query system.

References-found: 35

