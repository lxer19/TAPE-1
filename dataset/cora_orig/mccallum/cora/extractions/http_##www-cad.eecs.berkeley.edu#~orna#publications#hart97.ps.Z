URL: http://www-cad.eecs.berkeley.edu/~orna/publications/hart97.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~orna/pub.html
Root-URL: 
Email: Email: ftah,ornag@eecs.berkeley.edu  
Title: From Quantity to Quality  
Author: Thomas A. Henzinger and Orna Kupferman 
Address: Berkeley, CA 94720-1770, U.S.A.  
Affiliation: UC Berkeley, EECS Department,  
Abstract: In temporal-logic model checking, we verify the correctness of a program with respect to a desired behavior by checking whether a structure that models the program satisfies a temporal-logic formula that specifies the behavior. The model-checking problem for the branching-time temporal logic CTL can be solved in linear running time, and model-checking tools for CTL are used successfully in industrial applications. The development of programs that must meet rigid real-time constraints has brought with it a need for real-time temporal logics that enable quantitative reference to time. Early research on real-time temporal logics uses the discrete domain of the integers to model time. Present research on real-time temporal logics focuses on continuous time and uses the dense domain of the reals to model time. There, model checking becomes significantly more complicated. For example, the model-checking problem for TCTL, a continuous-time extension of the logic CTL, is PSPACE-complete. In this paper we suggest a reduction from TCTL model checking to CTL model checking. The contribution of such a reduction is twofold. Theoretically, while it has long been known that model-checking methods for untimed temporal logics can be extended quite easily to handle discrete time, it was not clear whether and how untimed methods can handle the reset quantifier of TCTL, which resets a real-valued clock. Practically, our reduction enables anyone who has a tool for CTL model checking to use it for TCTL model checking. The TCTL model-checking algorithm that follows from our reduction is in PSPACE, matching the known bound for this problem. In addition, it enjoys the wide distribution of CTL model-checking tools and the extensive and fruitful research efforts and heuristics that have been put into these tools.
Abstract-found: 1
Intro-found: 1
Reference: [ACD93] <author> R. Alur, C. Courcoubetis, and D. Dill. </author> <title> Model-checking in dense real-time. </title> <journal> Information and Computation, </journal> <volume> 104(1) </volume> <pages> 2-34, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: On this fourth level of temporal reasoning, we model the programs as timed automata [AD94], where real-valued clocks keep track of timing constraints. The fourth level constitutes the most expressive way of specifying real-time programs. With this semantics, the logic CTL+clocks is called TCTL <ref> [ACD93] </ref>, and the formula 0 asserts that in all computations of the program, every request is followed by a grant within at most two time units. TCTL model checking is the problem of determining whether a given TCTL formula is satisfied in a given timed automaton. <p> More precisely, the automaton partitions the infinite time domain of clock valuations into finitely many regions, each of which can be viewed as a set of clock constraints (e.g., 2 &lt; clock 1 &lt; 3 ; clock 2 = 1). This finite quotient is used in <ref> [ACD93] </ref> in order to solve the model-checking problem for TCTL. Alur et al. also prove that the problem is PSPACE-complete. <p> The graph untime (U ) is essentially the region graph used in <ref> [ACD93] </ref>, augmented by a new atomic proposition and new transitions, which handle the reset quantifier c:'. <p> We consider here TCTL, a real-time extension of the branching temporal logic CTL with clocks <ref> [ACD93] </ref>. Formulas of TCTL are defined with respect to the sets AP and C U of the program's atomic propositions and clocks, respectively, and a set C of specification clocks. We consider TCTL formulas in positive normal form in which negation may apply to atomic propositions only. <p> The model-checking problem for CTL can be solved in space that is polynomial in the specification and only poly-logarithmic in the Kripke structure [BVW94]. Corollary 4 then suggests a PSPACE model-checking algorithm for TCTL, matching the known lower bound <ref> [ACD93] </ref>. 3.4 Moving from CTL ? to CTL The formula fair (S 1 ; S 2 ) that we use in the definition of fair is not a CTL formula.
Reference: [AD94] <author> R. Alur and D. Dill. </author> <title> A theory of timed automata. </title> <journal> Theoretical Computer Science, </journal> <volume> 126(2) </volume> <pages> 183-236, </pages> <year> 1994. </year>
Reference-contexts: Much present research on qualitative reasoning focuses on dense time and uses the domain of the reals to model time in both the state-transition graph and the specification. On this fourth level of temporal reasoning, we model the programs as timed automata <ref> [AD94] </ref>, where real-valued clocks keep track of timing constraints. The fourth level constitutes the most expressive way of specifying real-time programs. <p> The reason is the dense time domain of TCTL, which induces state-transition graphs with infinitely many states. It was shown, however, in <ref> [AD94] </ref>, that each timed automaton induces a finite quotient of the infinite state space, such that two equivalent states satisfy the same TCTL formulas. <p> It was proven in <ref> [AD94] </ref> that a sufficient condition for two environment clocks to be indistinguishable is agreement on the integral parts of all clocks values and agreement on the ordering of the fractional parts of all clock values. This leads to the following definition of regions. <p> A clock environment E then belongs to iff it satisfies all its clock constraints. Following the definition of regions, the constraints that represent specify the integral part of all clocks, the order among the fractional parts, and whether they are equal to 0. Lemma 1. <ref> [AD94] </ref> The number of regions in (C; G) is bounded by jCj!2 jCj Q For a region and a formula ' 2 G, we say that satisfies ' (denoted j= ') iff rep () satisfies '.
Reference: [AH92] <author> R. Alur and T.A. Henzinger. </author> <title> Logics and models of real time: a survey. </title> <editor> In J.W. de Bakker, K. Huizing, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Real Time: </title> <booktitle> Theory in Practice, Lecture Notes in Computer Science 600, </booktitle> <pages> pages 74-106. </pages> <year> 1992. </year>
Reference-contexts: The development of programs that must meet rigid real-time constraints has brought with it a need for real-time temporal logics that enable quantitative reference to time <ref> [EMSS90, AH92] </ref>. We consider here a real-time extension of CTL, which we call CTL+clocks. The syntax of CTL+clocks extends the syntax of CTL by allowing reference to a set of clock variables. <p> to CTL formulas. 4 For example, the CTL+clocks formula 0 above is equivalent to the CTL formula 000 = AG (req ! A ((:tick)U (grant _ (tick ^ AXA ((:tick)U grant))))): Hence, CTL+clocks model checking can be reduced to CTL model checking on this level of temporal reasoning as well <ref> [AH92] </ref>. The main limitation of this level is its limited accuracy. For example, the formula 000 asserts only that in all computations of the program, every request is followed by a grant within more than one and less than three time units.
Reference: [AH93] <author> R. Alur and T. Henzinger. </author> <title> Real-time logics: Complexity and expressiveness. </title> <journal> Information and Computation, </journal> <volume> 104(1) </volume> <pages> 35-77, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The main limitation of this level of temporal reasoning is that while discrete time suffices for modeling globally-clocked programs, continuous time is required for modeling the composition of independently-clocked programs. This limitation has been removed in the third level of temporal reasoning, known as the fictitious-clock approach <ref> [HMP92, AH93, AH94] </ref>. At this level, transitions happen in continuous time, but are recorded by a global digital clock, in discrete time. Accordingly, time is viewed as a state variable that ranges over the domain of the integers.
Reference: [AH94] <author> R. Alur and T.A. Henzinger. </author> <title> A really temporal logic. </title> <journal> Journal of the ACM, </journal> <volume> 41(1) </volume> <pages> 181-204, </pages> <year> 1994. </year>
Reference-contexts: The main limitation of this level of temporal reasoning is that while discrete time suffices for modeling globally-clocked programs, continuous time is required for modeling the composition of independently-clocked programs. This limitation has been removed in the third level of temporal reasoning, known as the fictitious-clock approach <ref> [HMP92, AH93, AH94] </ref>. At this level, transitions happen in continuous time, but are recorded by a global digital clock, in discrete time. Accordingly, time is viewed as a state variable that ranges over the domain of the integers.
Reference: [BHSV + 96] <author> R.K. Brayton, G.D. Hachtel, A. Sangiovanni-Vincentelli, F. Somenzi, A. Aziz, S.- T. Cheng, S. Edwards, S. Khatri, T. Kukimoto, A. Pardo, S. Qadeer, R.K. Ranjan, S. Sarwary, T.R. Shiple, G. Swamy, and T. Villa. </author> <title> VIS: a system for verification and synthesis. </title> <booktitle> In Computer Aided Verification, Proc. 8th Int. Workshop, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 428-432. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Most of the efforts during the last two decades have focused on pure qualitative reasoning, yielding CTL model-checking tools (e.g., SMV, VIS, CADP) that can handle systems with large state spaces <ref> [McM93, CGL93, BHSV + 96, FGK + 96] </ref>. Model-checking algorithms for TCTL adopt some of the techniques used in the tools for 4 Again, the translation involves an exponential blow-up that is unnecessary for model checking. CTL model checking.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <booktitle> In Computer Aided Verification, Proc. 6th Int. Conference, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 142-155, </pages> <year> 1994. </year>
Reference-contexts: The transition from U to K (U ; ) involves an exponential blow-up, and the translation of into untime ( ) involves only a linear blow-up. The model-checking problem for CTL can be solved in space that is polynomial in the specification and only poly-logarithmic in the Kripke structure <ref> [BVW94] </ref>. Corollary 4 then suggests a PSPACE model-checking algorithm for TCTL, matching the known lower bound [ACD93]. 3.4 Moving from CTL ? to CTL The formula fair (S 1 ; S 2 ) that we use in the definition of fair is not a CTL formula.
Reference: [CCM + 94] <author> S. Campos, E.M. Clarke, W. Marrero, M. Minea, and H. Hiraishi. </author> <title> Computing quan-titative characteristics of finite-state real-time systems. </title> <booktitle> In Proceedings of the 15th Annual Real-time Systems Symposium. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: The formulas of CTL+clocks can be interpreted in three different ways, forming the following three levels of quantitative temporal reasoning. Pioneering work on real-time temporal logics allowed very simple quantitative reference to time. In [EMSS90], Emerson et al. interpret CTL+clocks formulas 2 over state-transition graphs (see also <ref> [CCM + 94] </ref>). Each transition in the graph advances the time by one time unit. Hence, this level of temporal reasoning uses the discrete domain of the integers to model time, and it uses quantitative reference to time only in the specifications.
Reference: [CE81] <author> E.M. Clarke and E.A. Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching time temporal logic. </title> <booktitle> In Proc. Workshop on Logic of Programs, volume 131 of Lecture Notes in Computer Science, </booktitle> <pages> pages 52-71. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: In temporal-logic model checking , we verify that a program meets a desired behavior by checking that a mathematical model of the program satisfies a temporal-logic formula that specifies the behavior <ref> [CE81, QS81] </ref>. We distinguish between four levels of temporal reasoning. The verification methods induced by these levels differ in the interpretation given to time. The first level allows only qualitative reference to time. The classical method of CTL model checking belongs to this level.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: The model-checking problem for CTL can be solved in linear time. More precisely, given a state-transition graph K and a CTL formula , we can determine whether K satisfies in time O (jKj j j) <ref> [CES86] </ref>. The development of programs that must meet rigid real-time constraints has brought with it a need for real-time temporal logics that enable quantitative reference to time [EMSS90, AH92]. We consider here a real-time extension of CTL, which we call CTL+clocks.
Reference: [CGL93] <author> E.M. Clarke, O. Grumberg, and D. </author> <title> Long. Verification tools for finite-state concurrent systems. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Decade of Concurrency Reflections and Perspectives (Proceedings of REX School), Lecture Notes in Computer Science, </booktitle> <pages> pages 124-175. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Most of the efforts during the last two decades have focused on pure qualitative reasoning, yielding CTL model-checking tools (e.g., SMV, VIS, CADP) that can handle systems with large state spaces <ref> [McM93, CGL93, BHSV + 96, FGK + 96] </ref>. Model-checking algorithms for TCTL adopt some of the techniques used in the tools for 4 Again, the translation involves an exponential blow-up that is unnecessary for model checking. CTL model checking.
Reference: [EMSS90] <author> E.A. Emerson, A.K. Mok, A.P. Sistla, and J. Srinivasan. </author> <title> Quantitative temporal reasoning. </title> <booktitle> In Proc. 2nd Workshop on Computer Aided Verification, volume 531 of Lecture Notes in Computer Science, </booktitle> <pages> pages 136-145. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The development of programs that must meet rigid real-time constraints has brought with it a need for real-time temporal logics that enable quantitative reference to time <ref> [EMSS90, AH92] </ref>. We consider here a real-time extension of CTL, which we call CTL+clocks. The syntax of CTL+clocks extends the syntax of CTL by allowing reference to a set of clock variables. <p> The exact meaning of 0 depends on the formal interpretation of CTL+clocks. The formulas of CTL+clocks can be interpreted in three different ways, forming the following three levels of quantitative temporal reasoning. Pioneering work on real-time temporal logics allowed very simple quantitative reference to time. In <ref> [EMSS90] </ref>, Emerson et al. interpret CTL+clocks formulas 2 over state-transition graphs (see also [CCM + 94]). Each transition in the graph advances the time by one time unit. <p> Accordingly, time is viewed as a state variable that ranges over the domain of the integers. Some transitions in the state-transition graph are designated as tick transitions (i.e., transitions of the 2 The logic used in <ref> [EMSS90] </ref> is RTCTL, which is a strict syntactic subset of CTL+clocks. 3 We note that while the translation involves an exponential blow-up, using a more sophisticated approach, model checking can still be done in time linear in the original CTL+clocks formula [EMSS90]. global digital clock). <p> (i.e., transitions of the 2 The logic used in <ref> [EMSS90] </ref> is RTCTL, which is a strict syntactic subset of CTL+clocks. 3 We note that while the translation involves an exponential blow-up, using a more sophisticated approach, model checking can still be done in time linear in the original CTL+clocks formula [EMSS90]. global digital clock). Whenever a tick transition is taken, time is advanced by one time unit. Hence, any number of program transitions can be taken in one time unit.
Reference: [FGK + 96] <author> J.-C. Fernandez, H. Garavel, A. Kerbrat, L. Mounier, R. Mateescu, and M. Sighireanu. CADP: </author> <title> a protocol validitation and verification toolbox. </title> <booktitle> In Computer Aided Verification, Proc. 8th Int. Workshop, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 437-440. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Most of the efforts during the last two decades have focused on pure qualitative reasoning, yielding CTL model-checking tools (e.g., SMV, VIS, CADP) that can handle systems with large state spaces <ref> [McM93, CGL93, BHSV + 96, FGK + 96] </ref>. Model-checking algorithms for TCTL adopt some of the techniques used in the tools for 4 Again, the translation involves an exponential blow-up that is unnecessary for model checking. CTL model checking.
Reference: [Hen95] <author> T.A. Henzinger. </author> <title> Hybrid automata with finite bisimulations. </title> <editor> In Z. Fulop and F. Gecseg, editors, </editor> <booktitle> ICALP 95: Automata, Languages, and Programming, Lecture Notes in Computer Science 944, </booktitle> <pages> pages 324-335. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: As such, our reduction can be easily adjusted to handle model checking of TCTL formulas when interpreted with respect to hybrid systems with finite bisimulations <ref> [Hen95] </ref>. The advantage of the algorithm that follows from our reduction is the existence of fine-tuned tools for CTL model checking. The algorithm can be optimized further by exploiting the special structure of K (U ; ).
Reference: [HKV96] <author> T.A. Henzinger, O. Kupferman, and M.Y. Vardi. </author> <title> A space-efficient on-the-fly algorithm for real-time model checking. </title> <booktitle> In Proc. 7th Conferance on Concurrency Theory, </booktitle> <address> Pisa, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: This finite quotient is used in [ACD93] in order to solve the model-checking problem for TCTL. Alur et al. also prove that the problem is PSPACE-complete. The importance of the model-checking problem has led to the development of several other model-checking algorithms for TCTL <ref> [HNSY94, LL95, SS95, HKV96] </ref>, all trying to cope with the large state space that needs to be stored. This space problem, known as the state-explosion problem, is the main computational limitation of all the verification methods induced by the four levels of temporal reasoning. <p> Recall that the way we define the semantics for TCTL, we do not require path quantification to range only over paths for which time diverges. diverge. Since we can replace the divergance requirement by a fairness constraint on K (U ; ) (see <ref> [HKV96] </ref>), it is easy to extend our algorithm to handle a semantics in which path quantification ranges only over divergent paths. Then, TCTL model checking is reduced to Fair-CTL model checking. By [KV95], the latter can be solved with the same space complexity as CTL model checking. <p> The advantage of the algorithm that follows from our reduction is the existence of fine-tuned tools for CTL model checking. The algorithm can be optimized further by exploiting the special structure of K (U ; ). For example, the optimization suggested in <ref> [HKV96] </ref>, which integrates states that differ only in their region element into a single state, can be used also here. It remains to be seen how the algorithm performs in practice.
Reference: [HMP92] <author> T.A. Henzinger, Z. Manna, and A. Pnueli. </author> <title> What good are digital clocks? In W. </title> <editor> Kuich, editor, </editor> <booktitle> ICALP 92: Automata, Languages, and Programming, Lecture Notes in Computer Science 623, </booktitle> <pages> pages 545-558. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The main limitation of this level of temporal reasoning is that while discrete time suffices for modeling globally-clocked programs, continuous time is required for modeling the composition of independently-clocked programs. This limitation has been removed in the third level of temporal reasoning, known as the fictitious-clock approach <ref> [HMP92, AH93, AH94] </ref>. At this level, transitions happen in continuous time, but are recorded by a global digital clock, in discrete time. Accordingly, time is viewed as a state variable that ranges over the domain of the integers.
Reference: [HNSY94] <author> T.A. Henzinger, X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> Symbolic model checking for real-time systems. </title> <journal> Information and Computation, </journal> <volume> 111 </volume> <pages> 193-244, </pages> <year> 1994. </year>
Reference-contexts: This finite quotient is used in [ACD93] in order to solve the model-checking problem for TCTL. Alur et al. also prove that the problem is PSPACE-complete. The importance of the model-checking problem has led to the development of several other model-checking algorithms for TCTL <ref> [HNSY94, LL95, SS95, HKV96] </ref>, all trying to cope with the large state space that needs to be stored. This space problem, known as the state-explosion problem, is the main computational limitation of all the verification methods induced by the four levels of temporal reasoning. <p> We use w; E j= ' to indicate that a formula ' holds at state w with clock environment E (with respect to the given timed structure T ). A formal definition of the relation j= can be found in <ref> [HNSY94] </ref>. We will define later the semantics of TCTL formulas when interpreted over quotient graphs induced by timed structures. For a timed structure T and a TCTL formula , we say that T j= iff hw 0 ; E 0 i j= . <p> We say that R (U ; ) j= iff w 0 j= . Several works on real-time temporal logics consider a more elaborated semantic for TCTL, where path quantification ranges only over paths for which time diverges <ref> [HNSY94] </ref>. As we discuss in Section 4, our algorithm can be easily extended to handle this semantics as well. By the definition of regions, we have the following. Theorem 2. [HNSY94] For every timed automaton U and TCTL formula , we have U j= iff R (U ; ) j= . <p> temporal logics consider a more elaborated semantic for TCTL, where path quantification ranges only over paths for which time diverges <ref> [HNSY94] </ref>. As we discuss in Section 4, our algorithm can be easily extended to handle this semantics as well. By the definition of regions, we have the following. Theorem 2. [HNSY94] For every timed automaton U and TCTL formula , we have U j= iff R (U ; ) j= . 3 Reducing TCTL Model Checking to CTL Model Checking 3.1 Untiming the Program Consider a timed automaton U = hAP; C U ; L; E; P; inv; l 0 i
Reference: [KG96] <author> O. Kupferman and O. Grumberg. </author> <title> Buy one, get one free! Journal of Logic and Computation, </title> <type> 6(4), </type> <year> 1996. </year>
Reference-contexts: E (~ 1 ^ XG~ 2 ^ ' 1 ~ U ' 2 ). We translate the four formulas to a fragment of CTL ? in which the path formulas may contain two temporal operators connected by a boolean operator. Formulas of this fragment have equivalent formulas in CTL <ref> [KG96] </ref>. 1. E (~ 1 ^ XG~ 2 ^ ' 1 U ' 2 ) = ~ 1 ^ [(' 2 ^ EXEG~ 2 ) _ (' 1 ^ EXE ((G~ 2 ) ^ ' 1 U ' 2 )]. 2.
Reference: [KV95] <author> O. Kupferman and M.Y. Vardi. </author> <title> On the complexity of branching modular model checking. </title> <booktitle> In Proc. 6th Conferance on Concurrency Theory, </booktitle> <pages> pages 408-422, </pages> <address> Philadelphia, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: Since we can replace the divergance requirement by a fairness constraint on K (U ; ) (see [HKV96]), it is easy to extend our algorithm to handle a semantics in which path quantification ranges only over divergent paths. Then, TCTL model checking is reduced to Fair-CTL model checking. By <ref> [KV95] </ref>, the latter can be solved with the same space complexity as CTL model checking. Hence, the PSPACE complexity is preserved. Our reduction handles the reset quantifier of TCTL by augmenting the region graph induced by a timed automaton with new transitions and limiting path quantification in the formula.
Reference: [LL95] <author> F. Laroussinie and K. G. Larsen. </author> <title> Compositional model checking of real time systems. </title> <booktitle> In Proc. 6th Conferance on Concurrency Theory, </booktitle> <pages> pages 27-41, </pages> <address> Philadelphia, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: This finite quotient is used in [ACD93] in order to solve the model-checking problem for TCTL. Alur et al. also prove that the problem is PSPACE-complete. The importance of the model-checking problem has led to the development of several other model-checking algorithms for TCTL <ref> [HNSY94, LL95, SS95, HKV96] </ref>, all trying to cope with the large state space that needs to be stored. This space problem, known as the state-explosion problem, is the main computational limitation of all the verification methods induced by the four levels of temporal reasoning.
Reference: [McM93] <author> K.L. McMillan. </author> <title> Symbolic model checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Most of the efforts during the last two decades have focused on pure qualitative reasoning, yielding CTL model-checking tools (e.g., SMV, VIS, CADP) that can handle systems with large state spaces <ref> [McM93, CGL93, BHSV + 96, FGK + 96] </ref>. Model-checking algorithms for TCTL adopt some of the techniques used in the tools for 4 Again, the translation involves an exponential blow-up that is unnecessary for model checking. CTL model checking.
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Temporal logics can describe a temporal ordering of events and have been adopted as a powerful tool for specifying and verifying concurrent programs <ref> [Pnu77, MP92] </ref>. In temporal-logic model checking , we verify that a program meets a desired behavior by checking that a mathematical model of the program satisfies a temporal-logic formula that specifies the behavior [CE81, QS81]. We distinguish between four levels of temporal reasoning.
Reference: [Pnu77] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proc. 18th IEEE Symposium on Foundation of Computer Science, </booktitle> <pages> pages 46-57, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction Temporal logics can describe a temporal ordering of events and have been adopted as a powerful tool for specifying and verifying concurrent programs <ref> [Pnu77, MP92] </ref>. In temporal-logic model checking , we verify that a program meets a desired behavior by checking that a mathematical model of the program satisfies a temporal-logic formula that specifies the behavior [CE81, QS81]. We distinguish between four levels of temporal reasoning.
Reference: [QS81] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in Cesar. </title> <booktitle> In Proc. 5th International Symp. on Programming, </booktitle> <volume> volume 137, </volume> <pages> pages 337-351. </pages> <note> Springer-Verlag, Lecture Notes in Computer Science, </note> <year> 1981. </year>
Reference-contexts: In temporal-logic model checking , we verify that a program meets a desired behavior by checking that a mathematical model of the program satisfies a temporal-logic formula that specifies the behavior <ref> [CE81, QS81] </ref>. We distinguish between four levels of temporal reasoning. The verification methods induced by these levels differ in the interpretation given to time. The first level allows only qualitative reference to time. The classical method of CTL model checking belongs to this level.
Reference: [SS95] <author> O.V. Sokolsky and S.A. Smolka. </author> <title> Local model checking for real-time systems. </title> <booktitle> In Computer Aided Verification, Proc. 7th Int. Workshop, Lecture Notes in Computer Science 939, </booktitle> <pages> pages 211-224, Liege, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: This finite quotient is used in [ACD93] in order to solve the model-checking problem for TCTL. Alur et al. also prove that the problem is PSPACE-complete. The importance of the model-checking problem has led to the development of several other model-checking algorithms for TCTL <ref> [HNSY94, LL95, SS95, HKV96] </ref>, all trying to cope with the large state space that needs to be stored. This space problem, known as the state-explosion problem, is the main computational limitation of all the verification methods induced by the four levels of temporal reasoning.
References-found: 25

