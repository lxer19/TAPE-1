URL: ftp://theory.lcs.mit.edu/pub/tcryptol/96-02r.ps
Refering-URL: http://theory.lcs.mit.edu/~tcryptol/1996/96-02o.html
Root-URL: 
Title: Deniable Encryption  
Author: Ran Canetti Cynthia Dwork Moni Naor Rafail Ostrovsky 
Date: June 2, 1997  
Abstract: Consider a situation in which the transmission of encrypted messages is intercepted by an adversary who can later ask the sender to reveal the random choices (and also the secret key, if one exists) used in generating the ciphertext, thereby exposing the cleartext. An encryption scheme is deniable if the sender can generate `fake random choices' that will make the ciphertext `look like' an encryption of a different cleartext, thus keeping the real cleartext private. Analogous requirements can be formulated with respect to attacking the receiver and with respect to attacking both parties. In this paper we introduce deniable encryption and propose constructions of schemes with polynomial deniability. In addition to being interesting by itself, and having several applications, deniable encryption provides a simplified and elegant construction of adaptively secure multiparty computation.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ajtai, </author> <title> Generating Hard Instances of Lattice Problems, </title> <publisher> STOC'96 </publisher>
Reference-contexts: Indeed, applying the transformation of Section 6 to the basic scheme described in Section 3 yields a complete solution to the adaptive security problem. 2 Definitions Let us first recall the definition of computational distance of distributions. Here and in the sequel a function ffi : N ! <ref> [0; 1] </ref> is negligible if it approaches zero faster than any polynomial (when its argument approaches infinity). Definition 1 Let A = fA n g n2N and B = fB n g n2N be two ensembles of probability distributions, and let ffi : N ! [0; 1]. <p> function ffi : N ! <ref> [0; 1] </ref> is negligible if it approaches zero faster than any polynomial (when its argument approaches infinity). Definition 1 Let A = fA n g n2N and B = fB n g n2N be two ensembles of probability distributions, and let ffi : N ! [0; 1]. We say that A and B are ffi (n)-close if for every polynomial time distinguisher D and for all large enough n, jProb (D (A n ) = 1) Prob (D (B n ) = 1)j &lt; ffi (n). <p> the shortest nonzero vector in an n dimensional lattice L where the shortest vector v is unique in the sense that any other vector whose length is at most n c kvk is parallel to v." The unique shortest vector problem is one of the three famous problems listed in <ref> [1] </ref>. There, a random method is given to generate hard instances of a particular lattice problem so that if it has a polynomial time solution then all of the three worst-case problems (including the unique-shortest vector problem) has a solution.
Reference: [2] <author> M. Ajtai, C. Dwork, </author> <title> A Public-Key Cryptosystem with Average-Case/Worst-Case Equivalence, </title> <note> STOC'97; see also Electronic Colloquium on Computational Complexity TR96-065, http://www.eccc.uni-trier.de/eccc-local/Lists/TR-1996.html </note>
Reference-contexts: Construction II is more efficient in that, given a trapdoor permutation on f0; 1g s , the length of x is only t = s + k instead of t = sk. A third construction relies on the latticed-based public-key cryptosystem described in <ref> [2] </ref>. Roughly speaking, the secret information is an n-dimensional vector u of length at most 1. Let K denote the cube 2 n logn U (n) , where U (n) is the n-dimensional unit cube. <p> There, a random method is given to generate hard instances of a particular lattice problem so that if it has a polynomial time solution then all of the three worst-case problems (including the unique-shortest vector problem) has a solution. The cryptosystem in <ref> [2] </ref> outlined above is secure provided the unique shortest vector problem is hard in the worst case. From this and the proof of Theorem 5 we have: Theorem 6 Assume that the unique shortest vector problem is hard in the worst case.
Reference: [3] <author> D. Beaver and S. Haber, </author> <title> Cryptographic Protocols Provably Secure Against Dynamic Adversaries, </title> <booktitle> Eurocrypt, </booktitle> <year> 1992. </year>
Reference-contexts: Security: For any m 1 ; m 2 2 M we have com (m 1 ) c 2 <ref> [9, 3] </ref> obtain solutions for this problem under the assumption that the parties are trusted to keep erasing past information. Such solutions are unsatisfactory in a setting where parties aren't trusted since erasing cannot be externally verified.
Reference: [4] <editor> J. Benaloh and D. Tunistra, Receipt-Free Secret-Ballot Elections, </editor> <booktitle> 26th STOC, </booktitle> <year> 1994, </year> <pages> pp. </pages> <month> 544-552. </month> <title> 4 In general, when both the sender and the receiver are attacked they are faced with a `coordination problem': to be consistent, they both should claim the same (fake or true) value for the cleartext. We believe that this `coordination' issue should be treated separately. This problem is extensively treated in [5].) </title> <type> 11 </type>
Reference-contexts: Deniable encryption has applications to the prevention of vote-buying in electronic voting schemes <ref> [4, 10, 11, 19] </ref>, storing encrypted data in a deniable way, and uncoercible multiparty computation [5]; it also yields an alternative solution to the adaptive security problem [7]. We elaborate on these applications in Section 1.1. <p> The coercion problem in the context of voting has been studied in the past <ref> [4, 19, 11] </ref>.
Reference: [5] <author> R. Canetti and R. Gennaro, </author> <title> Incoercible multiparty computation, </title> <publisher> FOCS'96 </publisher>
Reference-contexts: Deniable encryption has applications to the prevention of vote-buying in electronic voting schemes [4, 10, 11, 19], storing encrypted data in a deniable way, and uncoercible multiparty computation <ref> [5] </ref>; it also yields an alternative solution to the adaptive security problem [7]. We elaborate on these applications in Section 1.1. <p> coercer hears no ciphertext and the `deniability problem' disappears. 1 Deniable encryptions may be incorporated in these works to replace these physical security assumptions. (One still has to make sure, as before, that the voters are not coerced prior to the elections.) Based on the public-key, sender-deniable construction presented here, <ref> [5] </ref> describe a general multiparty protocol permitting a set of parties to compute a common function of their inputs while keeping their internal data private even in the presence of a coercer.
Reference: [6] <author> R. Canetti, C. Dwork, M. Naor and R. Ostrovsky, </author> <title> Deniable Encryption, Theory of Cryptology Library, </title> <address> http://theory.lcs.mit.edu/ tcryptol, </address> <year> 1996. </year>
Reference: [7] <author> R. Canetti, U. Feige, O. Goldreich and M. Naor, </author> <title> Adaptively secure computation, </title> <booktitle> 28th STOC, </booktitle> <year> 1996. </year>
Reference-contexts: While (passive) semantic security appropriately captures the security needed against passive eavesdroppers, there are settings in which it falls short of providing the desired degree of protection. Such settings include protection against chosen ciphertext attacks (e.g., [17, 18]), non-malleable encryption [8], and protection against adaptive adversaries <ref> [7] </ref>. We investigate the additional properties required to protect the privacy of transmitted data in yet another hostile setting. <p> Deniable encryption has applications to the prevention of vote-buying in electronic voting schemes [4, 10, 11, 19], storing encrypted data in a deniable way, and uncoercible multiparty computation [5]; it also yields an alternative solution to the adaptive security problem <ref> [7] </ref>. We elaborate on these applications in Section 1.1. We classify deniable encryption schemes according to which parties may be coerced: a sender-deniable scheme is resilient against coercing (i.e., demanding to see the secret data) of the sender of the ciphertext; receiver-deniable and sender-and-receiver-deniable schemes are defined analogously. <p> Almost a decade passed before the restriction to non-adaptive 1 In [11] a slightly different physical security assumption is made, namely that the random choices used for encryption are physically unavailable. The result is the same: the `deniability problem' disappears. 3 adversaries was lifted <ref> [7] </ref>. 2 These protocols are based on another type of encryption protocol, called non--committing encryption. Non-committing encryptions have the same flavor as deniable encryptions, in that there exist ciphertexts that can be opened as encryptions of, say, both `1' and `0'. However, non-committing encryptions are strictly weaker than deniable ones. <p> However, non-committing encryptions are strictly weaker than deniable ones. For example, in non-committing encryptions the parties using the scheme are, in general, not able to generate ciphertexts that can be opened both ways; such ciphertexts can only be generated by a simulator (which is an artifact of the <ref> [7] </ref> model). In contrast, in deniable encryption each ciphertext generated by parties using the scheme has unique decryption, and at the same time can be opened in several ways for an adversary (thus, the non-committing encryption scheme in [7] is not deniable). <p> only be generated by a simulator (which is an artifact of the <ref> [7] </ref> model). In contrast, in deniable encryption each ciphertext generated by parties using the scheme has unique decryption, and at the same time can be opened in several ways for an adversary (thus, the non-committing encryption scheme in [7] is not deniable). The key insight is that any deniable encryption scheme resilient against attacking both the sender and the receiver is non-committing.
Reference: [8] <author> D. Dolev, C. Dwork and M. Naor, </author> <title> Non-malleable cryptography, </title> <booktitle> STOC'91 </booktitle>
Reference-contexts: While (passive) semantic security appropriately captures the security needed against passive eavesdroppers, there are settings in which it falls short of providing the desired degree of protection. Such settings include protection against chosen ciphertext attacks (e.g., [17, 18]), non-malleable encryption <ref> [8] </ref>, and protection against adaptive adversaries [7]. We investigate the additional properties required to protect the privacy of transmitted data in yet another hostile setting.
Reference: [9] <author> P. Feldman, </author> <title> Private Communication, </title> <year> 1986. </year>
Reference-contexts: Security: For any m 1 ; m 2 2 M we have com (m 1 ) c 2 <ref> [9, 3] </ref> obtain solutions for this problem under the assumption that the parties are trusted to keep erasing past information. Such solutions are unsatisfactory in a setting where parties aren't trusted since erasing cannot be externally verified.
Reference: [10] <author> A. Herzberg, </author> <note> Rump-Session presentation at CRYPTO 1991. </note>
Reference-contexts: Deniable encryption has applications to the prevention of vote-buying in electronic voting schemes <ref> [4, 10, 11, 19] </ref>, storing encrypted data in a deniable way, and uncoercible multiparty computation [5]; it also yields an alternative solution to the adaptive security problem [7]. We elaborate on these applications in Section 1.1. <p> In Section 5 we review some shared-key deniable schemes. 1.1 Applications and related work A natural application of deniable encryption is to prevent coercion in electronic secret voting schemes <ref> [10] </ref>: a coercer may offer bribe in exchange for proof of a person's vote, after hearing the corresponding ciphertext. The coercion problem in the context of voting has been studied in the past [4, 19, 11].
Reference: [11] <author> R. Gennaro, </author> <type> unpublished manuscript. </type>
Reference-contexts: Deniable encryption has applications to the prevention of vote-buying in electronic voting schemes <ref> [4, 10, 11, 19] </ref>, storing encrypted data in a deniable way, and uncoercible multiparty computation [5]; it also yields an alternative solution to the adaptive security problem [7]. We elaborate on these applications in Section 1.1. <p> The coercion problem in the context of voting has been studied in the past <ref> [4, 19, 11] </ref>. <p> Protocols for securely computing any function in a multiparty scenario in the presence of a non-adaptive adversary were shown in [14]. Almost a decade passed before the restriction to non-adaptive 1 In <ref> [11] </ref> a slightly different physical security assumption is made, namely that the random choices used for encryption are physically unavailable. The result is the same: the `deniability problem' disappears. 3 adversaries was lifted [7]. 2 These protocols are based on another type of encryption protocol, called non--committing encryption.
Reference: [12] <author> O. Goldreich and L. Levin, </author> <title> A Hard-Core Predicate to any One-Way Function, </title> <booktitle> 21st STOC, </booktitle> <year> 1989, </year> <pages> pp. 25-32. </pages>
Reference-contexts: We first present two simple constructions of translucent sets. Both use a trapdoor permutation f : f0; 1g s ! f0; 1g s , and its hard-core predicate B : f0; 1g s ! f0; 1g (say, use the Goldreich-Levin predicate <ref> [12] </ref>). Construction I: Let t = sk. Represent each x 2 f0; 1g t as a vector x = x 1 :::x k where each x i 2 f0; 1g s .
Reference: [13] <author> O. Goldreich, S. Micali and A. Wigderson, </author> <title> Proofs that Yield Nothing but the Validity of the Assertion, and a Methodology of Cryptographic Protocol Design, </title> <booktitle> 27th FOCS, </booktitle> <pages> 174-187, </pages> <year> 1986. </year>
Reference-contexts: In fact, encryption is often conceived of as a committing process, in the sense that the ciphertext may serve as a commitment to the cleartext. (This is a common use for encryption schemes, e.g. in <ref> [13, 14] </ref>.) Deniable encryption radically diverges from this concept. Deniable encryption may seem impossible at first glance: consider a ciphertext c sent from Alice to Bob.
Reference: [14] <author> O. Goldreich, S. Micali and A. Wigderson, </author> <title> How to Play any Mental Game, </title> <booktitle> 19th STOC, </booktitle> <pages> pp. 218-229, </pages> <year> 1987. </year>
Reference-contexts: In fact, encryption is often conceived of as a committing process, in the sense that the ciphertext may serve as a commitment to the cleartext. (This is a common use for encryption schemes, e.g. in <ref> [13, 14] </ref>.) Deniable encryption radically diverges from this concept. Deniable encryption may seem impossible at first glance: consider a ciphertext c sent from Alice to Bob. <p> Protocols for securely computing any function in a multiparty scenario in the presence of a non-adaptive adversary were shown in <ref> [14] </ref>. Almost a decade passed before the restriction to non-adaptive 1 In [11] a slightly different physical security assumption is made, namely that the random choices used for encryption are physically unavailable.
Reference: [15] <author> S. Goldwasser and S. Micali, </author> <title> Probabilistic encryption, </title> <journal> JCSS, </journal> <volume> Vol. 28, No 2, </volume> <month> April </month> <year> 1984, </year> <pages> pp. 270-299. </pages>
Reference-contexts: Alice obtains Bob's (public) encryption key of an asymmetric encryption scheme and uses it, together with local randomness, to encrypt her messages. Now only Bob, who possesses the decryption key, should be able to decrypt. Semantic security <ref> [15] </ref> captures the security requirements that this setting imposes on the encryption function. Basically, semantic security means that Eve learns nothing from the ciphertexts she hears: whatever she can compute having heard the ciphertexts she can also compute from scratch. <p> Let us informally sketch the requirements for a one-round public-key, sender-deniable, bit-by-bit encryption scheme (Section 2 contains a more general definition). Let E k be the sender's encryption algorithm with public key k. First, a deniable encryption scheme should be semantically secure in the sense of <ref> [15] </ref>. In addition we require that the sender have a (publicly known) faking algorithm.
Reference: [16] <author> P. Gutman, </author> <title> Secure Deletion of Data from Magnetic and Solid-State Memory, </title> <booktitle> Sixth USENIX Security Symposium Proceedings, </booktitle> <address> San Jose, California, </address> <month> July 22-25, </month> <year> 1996, </year> <pages> pp. 77-89. </pages>
Reference-contexts: Such solutions are unsatisfactory in a setting where parties aren't trusted since erasing cannot be externally verified. Furthermore, the physical design of computer systems makes erasing information difficult and unreliable <ref> [16] </ref>. 4 Deniability: There exists an efficient faking algorithm having the following property with respect to any m 1 ; m 2 2 M .
Reference: [17] <author> M. Naor and M. </author> <title> Yung " Public key cryptosystems provably secure against chosen ciphertext attacks", </title> <booktitle> Proc. 22nd ACM Annual Symposium on the Theory of Computing, </booktitle> <year> 1990, </year> <pages> pp. 427-437. </pages>
Reference-contexts: While (passive) semantic security appropriately captures the security needed against passive eavesdroppers, there are settings in which it falls short of providing the desired degree of protection. Such settings include protection against chosen ciphertext attacks (e.g., <ref> [17, 18] </ref>), non-malleable encryption [8], and protection against adaptive adversaries [7]. We investigate the additional properties required to protect the privacy of transmitted data in yet another hostile setting.
Reference: [18] <author> C. Rackoff and D. Simon, </author> <title> Non-interactive zero-knowledge proof of knowledge and chosen cipher-text attack, </title> <booktitle> CRYPTO'91, (LNCS 576), </booktitle> <year> 1991. </year>
Reference-contexts: While (passive) semantic security appropriately captures the security needed against passive eavesdroppers, there are settings in which it falls short of providing the desired degree of protection. Such settings include protection against chosen ciphertext attacks (e.g., <ref> [17, 18] </ref>), non-malleable encryption [8], and protection against adaptive adversaries [7]. We investigate the additional properties required to protect the privacy of transmitted data in yet another hostile setting.
Reference: [19] <author> K. Sako and J. Kilian, </author> <title> Receipt-Free Mix-Type Voting Scheme, </title> <booktitle> Eurocrypt 1995, </booktitle> <pages> pp. 393-403. </pages>
Reference-contexts: Deniable encryption has applications to the prevention of vote-buying in electronic voting schemes <ref> [4, 10, 11, 19] </ref>, storing encrypted data in a deniable way, and uncoercible multiparty computation [5]; it also yields an alternative solution to the adaptive security problem [7]. We elaborate on these applications in Section 1.1. <p> The coercion problem in the context of voting has been studied in the past <ref> [4, 19, 11] </ref>.
References-found: 19

