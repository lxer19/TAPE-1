URL: http://www.cs.yale.edu/HTML/YALE/CS/haskell/lib-design.ps.gz
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/haskell/
Root-URL: http://www.cs.yale.edu
Email: freid-alastair,peterson-johng@cs.yale.edu  
Title: Designing the Standard Haskell Libraries (Position Paper)  
Author: Alastair Reid and John Peterson 
Date: June 4, 1995  
Note: Electronic mail:  
Address: P.O. Box 208285, New Haven, CT 06520, USA.  
Affiliation: Department of Computer Science, Yale University,  
Abstract: Five years after the first Haskell report was published, the Haskell language continues to grow and mature. After five years experience of Haskell programming, we wish to both expand and simplify the Haskell language. Over the years, many Haskell libraries have been developed. The Haskell Committee is expanding the language by standard-ising a set of libraries to add to the definition of Haskell. Another goal is to simplify Haskell by moving parts of the prelude, a built-in set of types and functions implicitly a part of every Haskell program, into libraries where they can be loaded on demand, This document describes the issues involved in the design of the Haskell libraries and summarises the library modules being considered.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L Augustsson, M Rittri, and D Synek. </author> <title> On generating unique names. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(1) </volume> <pages> 117-123, </pages> <month> January </month> <year> 1994. </year> <month> 12 </month>
Reference-contexts: This module is included to support supplies of random numbers but has also proved useful within compilers. The current interface is based on Augustsson, Rittri and Synek's splittable supply library <ref> [1] </ref> as distributed with HBC. The price paid for an efficient splittable supply implementation is that programs using the splittable supply module might produce different results when compiled with different compilers, with different optimisation options or even after small semantics-preserving changes to the program.
Reference: [2] <author> RS Bird and PL Wadler. </author> <title> Introduction to Functional Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: LibSubsequences This module provides functions to generate the list of all subsequences, prefixes, suffixes or permutations of a list and to test whether one list is a subsequence, prefix, suffix or permutation of another list. These are based on functions defined by Bird and Wadler <ref> [2] </ref>. 8 3.4 Collections Lists are very heavily used in Haskell programs. Sadly, lists can be quite inefficient (in time) for storing large collections of data and it is possible to do significantly better using data structures based on binary trees or hash tables.
Reference: [3] <author> AD Gordon and K Hammond. </author> <title> Monadic I/O in Haskell. </title> <booktitle> In Proceedings of Haskell Workshop, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: This document describes the issues that arise in turning the existing libraries into a concrete library proposal and briefly summarises each library. This document does not discuss changes to the libraries or prelude which are related to the I/O proposal; these are described in Gordon and Hammond's tutorial paper <ref> [3] </ref>. Detailed definitions of the libraries are supplied in a companion document [11].
Reference: [4] <author> John Hughes. </author> <title> Lazy memo-functions. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <pages> pages 129-146, </pages> <month> September </month> <year> 1985. </year>
Reference-contexts: We are also considering libraries to support matrix operations, regular expressions, Hughes' lazy memo functions <ref> [4] </ref>, Johnsson's lazy arrays, the language independent arithmetic standard [10] and the X11 graphics protocol.
Reference: [5] <author> G Hutton. </author> <title> Higher-order functions for parsing. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(3) </volume> <pages> 323-343, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: The module LibParse provides a new abstract type Parser ff fi of backtracking recursive-descent parsers which consume a token stream of type ff and produces "parse trees" of type fi. The current interface is based on Hutton's parsing library <ref> [5] </ref> as distributed with HBC. 3.8 Binary Files The class Text provides a limited form of persistence: most built in and user-defined types can be printed to text files and subsequently read back in.
Reference: [6] <author> MP Jones. </author> <title> A system of constructor classes: overloading and implicit higher-order polymorphism. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <year> 1993. </year>
Reference-contexts: If constructor classes <ref> [6] </ref> are added to Haskell 1.3, it would be possible to define constructor classes representing monads, monads with a zero element and monads with a choice operator. Such classes could be defined in a library but are sufficiently important to justify their addition to the prelude.
Reference: [7] <editor> SL Peyton Jones and PL Wadler. </editor> <title> Imperative functional programming. </title> <booktitle> In Principles of Programming Languages, </booktitle> <pages> pages 71-84. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1993. </year>
Reference-contexts: Instances would include lists, Maybe, Either, IO and Parser. There are a number of useful monadic functions which can be defined using these operations. The current interface is based on monads used within GHC and on examples distributed with Gofer. 3.6 Mutable Structures Peyton Jones, Wadler and Launchbury <ref> [7, 8] </ref> describe how monads may be used to provide mutable variables and mutable arrays without losing referential transparency. The module LibMutable provides both mutable variables and mutable arrays.
Reference: [8] <author> J Launchbury and SL Peyton Jones. </author> <title> Lazy functional state threads. </title> <booktitle> In Programming Languages Design and Implementation, </booktitle> <year> 1994. </year>
Reference-contexts: Instances would include lists, Maybe, Either, IO and Parser. There are a number of useful monadic functions which can be defined using these operations. The current interface is based on monads used within GHC and on examples distributed with Gofer. 3.6 Mutable Structures Peyton Jones, Wadler and Launchbury <ref> [7, 8] </ref> describe how monads may be used to provide mutable variables and mutable arrays without losing referential transparency. The module LibMutable provides both mutable variables and mutable arrays. <p> unresolved question is whether the operations to create, read and write mutable structures should be part of the IO monad, part of a state thread monad or whether the IO monad should be an instance of state thread monads as in Peyton Jones and Launchbury's elegant lazy state threads paper <ref> [8] </ref>. The problem is that their approach requires the addition of a new language construct runST with special type-checking rules. It is not yet clear whether the extra power justifies complicating the language.
Reference: [9] <author> JT O'Donnell. </author> <title> Bidirectional fold and scan. </title> <booktitle> In Draft Proceedings of Glasgow Functional Programming Workshop, pages XX1 - XX6. Glasgow Functional Programming Group, </booktitle> <month> July </month> <year> 1993. </year>
Reference-contexts: LibScans This module provides unidirectional and bidirectional generalisations of fold and scan based on functions provided in HBC's ListUtils module, GHC's Utils module and O'Donnell's paper on bidirectional fold and scan <ref> [9] </ref>. LibSubsequences This module provides functions to generate the list of all subsequences, prefixes, suffixes or permutations of a list and to test whether one list is a subsequence, prefix, suffix or permutation of another list.
Reference: [10] <author> M Payne, C Schaffert, and BA Wichmann. </author> <title> The language compatible arithmetic standard. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(1) </volume> <pages> 59-86, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: We are also considering libraries to support matrix operations, regular expressions, Hughes' lazy memo functions [4], Johnsson's lazy arrays, the language independent arithmetic standard <ref> [10] </ref> and the X11 graphics protocol.
Reference: [11] <author> AD Reid and JC Peterson. </author> <title> A proposal for the standard Haskell libraries. 1995. In preparation for distribution at Haskell Workshop. </title>
Reference-contexts: This document does not discuss changes to the libraries or prelude which are related to the I/O proposal; these are described in Gordon and Hammond's tutorial paper [3]. Detailed definitions of the libraries are supplied in a companion document <ref> [11] </ref>. <p> necessary for the programmer to import these implicitly-referenced entities, although the compiler must arrange for them to be linked into the resulting program. 3 An Overview of the Proposed Libraries This section summarises those libraries which will be included in Haskell 1.3. (A complete definition may be found in document <ref> [11] </ref>.) We omit LibCharType which provides character operations removed from Prelude, and LibArray, LibComplex and LibRatio which are just old prelude modules turned into libraries. 3.1 Non-overloaded prelude functions Functions such as elem use the Eq class to supply the == operation.
Reference: [12] <author> GL Steele. </author> <title> Common Lisp | The Language. </title> <publisher> Digital Press, </publisher> <address> 2nd edition, </address> <year> 1994. </year>
Reference-contexts: The new types are instances of Integral (and all superclasses); negative numbers are interpreted as though they are represented in two's-complement notation. The current interface is loosely based on the Common Lisp logical operations <ref> [12] </ref> and the Word library distributed with HBC. 3.11 Future Work There is a considerable amount of work ahead designing the exact interface to these modules, defining the precise semantics of these operations and documenting the resulting modules.
Reference: [13] <author> PL Wadler. </author> <title> Comprehending monads. </title> <booktitle> In Proc ACM Conference on Lisp and Functional Programming, Nice. ACM, </booktitle> <month> June </month> <year> 1990. </year> <month> 13 </month>
Reference-contexts: Instances of Hashable may be derived. Modules LibBag, LibSet and LibFiniteMap are based on modules distributed with GHC; LibHash is loosely based on a module distributed with HBC (the type Hash is just Int in the HBC version.) 3.5 Monads Since their first use in pure functional programming <ref> [13] </ref>, monads have revolutionised the way programmers perform input/output, update-in-place, parsing, exception handling and many other tasks. If constructor classes [6] are added to Haskell 1.3, it would be possible to define constructor classes representing monads, monads with a zero element and monads with a choice operator.
References-found: 13

