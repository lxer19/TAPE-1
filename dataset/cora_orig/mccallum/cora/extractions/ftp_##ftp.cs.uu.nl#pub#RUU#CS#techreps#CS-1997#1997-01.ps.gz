URL: ftp://ftp.cs.uu.nl/pub/RUU/CS/techreps/CS-1997/1997-01.ps.gz
Refering-URL: http://www.cs.ruu.nl/docs/research/publication/TechList1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: E-mail: jacques@cs.ruu.nl  
Title: The complexity of scheduling graphs of bounded width subject to non-zero communication delays  
Author: Jacques Verriet 
Address: P.O. Box 80.089, 3508 TB Utrecht, The Netherlands.  
Affiliation: Department of Computer Science, Utrecht University,  
Abstract: In this report, we study the complexity of scheduling problems for precedence graphs of bounded width. For such graphs, the size of a maximum anti-chain is bounded by a constant. It is shown that for graphs of bounded width with unit-length tasks and unit communication delays, a minimum-length schedule on m processors can be constructed in polynomial time using a dynamic-programming algorithm. This approach can be generalised to minimise different objective functions. For graphs of width two with arbitrary task lengths, a polynomial-time algorithm is presented that constructs minimum-length and minimum-tardiness schedules on two processors. If its width is at least three, then constructing a minimum-length schedule for a graph with arbitrary task lengths on two processors is shown to be NP-hard. For the case that the width of the graph equals the number of processors, a dynamic-programming algorithm is presented that constructs minimum-length schedules in polynomial time.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H.H. Ali and H. El-Rewini. </author> <title> An optimal algorithm for scheduling interval ordered tasks with communication on N processors. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 51(2) </volume> <pages> 301-307, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Finta, et al. [9] showed that for series-parallel graphs, a minimum-length schedule on two processors can be constructed in polynomial time. Ali and El-Rewini <ref> [1] </ref> presented a polynomial-time algorithm that constructs minimum-length schedules for sets of interval-ordered tasks. fl This research was partially supported by ESPRIT Long Term Research Project 20244 (project ALCOM IT: Algorithms and Complexity in Information Technology). 1 For these special classes of precedence graphs, we cannot expect to find polynomial-time algo-rithms, <p> T [seq (U; U )] := minfT [seq (U 0 ; U 0 )] j (U 0 ; U 0 ) 2 Av (U; U )g By applying Algorithm Table construction to the timed prefix (?; ? ), we construct a table T with T <ref> [0; 1; : : : ; 0; 1] </ref> = L (?; ? ).
Reference: [2] <author> H. Alt, N. Blum, K. Mehlhorn and M. Paul. </author> <title> Computing a maximum cardinality matching in a bipartite graph in time O(n 1:5 p m= log n). </title> <journal> Information Processing Letters, </journal> <volume> 37(4) </volume> <pages> 237-240, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: Bodlaender and Fellows [3] showed that constructing a minimum-length schedule for an arbitrary graph on k processors without communication delays is a W <ref> [2] </ref>-hard problem (W [2] is the second class of the W -hierarchy for parametrised problems, that was introduced by Downey and Fellows [8]). Consequently, it is unlikely that an algorithm exists with an O (n c ) running time that constructs minimum-length schedules on k processors for some constant c independent of k. <p> Hopcroft and Karp [13] presented an algorithm that computes a maximum matching in O (e p n) time for bipartite graphs with n nodes and e edges. Alt, et al. <ref> [2] </ref> presented an algorithm whose running time is better for dense graphs: it constructs a maximum matching in O (n p ne= log n) time. Let e + be the number of arcs in G + . The number of edges in H equals e + .
Reference: [3] <author> H.L. Bodlaender and M.R. Fellows. </author> <title> W[2]-hardness of precedence constrained k-processor scheduling. </title> <type> Technical Report UU-CS-1994-14, </type> <institution> Department of Computer Science, Utrecht University, </institution> <year> 1994. </year>
Reference-contexts: In addition, it can be used to minimise the makespan for graphs in which the sum of the task lengths is bounded by a polynomial in n and the communication delays are bounded by a constant. Bodlaender and Fellows <ref> [3] </ref> showed that constructing a minimum-length schedule for an arbitrary graph on k processors without communication delays is a W [2]-hard problem (W [2] is the second class of the W -hierarchy for parametrised problems, that was introduced by Downey and Fellows [8]). <p> The running time of the dynamic-programming algorithm is exponential in the width of the precedence graph. It is unlikely that there is an algorithm that constructs minimum-length schedules in O (n c ) time, where c is a constant independent of the width of the graph: Bodlaender and Fellows <ref> [3] </ref> proved that constructing a minimum-length schedule for an arbitrary precedence graph (without communication delays) on k processors is W [2]-hard. <p> This implies that it is unlikely that, for all fixed k, a minimum-length schedule for a graph on k processors can be constructed in O (n c ) time for some constant c. In fact, Bodlaender and Fellows <ref> [3] </ref> proved this for graphs of width k + 1 that have to be scheduled on k processors. Their result can be easily generalised to scheduling with non-zero communication delays.
Reference: [4] <author> P. Chretienne and C. Picouleau. </author> <title> Scheduling with communication delays: a survey. </title> <editor> In P. Chretienne, E.G. Coffman, Jr., J.K. Lenstra and Z. Liu, editors, </editor> <booktitle> Scheduling Theory and its Applications, </booktitle> <pages> pages 65-90. </pages> <publisher> John Wiley & Sons, </publisher> <year> 1995. </year>
Reference-contexts: In a schedule (; ) for (G; w; ), at most w tasks can be executed simultaneously. As a result, any feasible assignment of starting times for (G; 1; ) is also feasible for (G; w; ). Chretienne and Picouleau <ref> [4] </ref> proved that there exists a minimum-length schedule for (G; 1; ) in which incomparable tasks are executed on different processors.
Reference: [5] <author> D. Coppersmith and S. Winograd. </author> <title> Matrix multiplication via algorithmic progressions. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 9 </volume> <pages> 251-280, </pages> <year> 1990. </year>
Reference-contexts: Otherwise, compute the transitive closure G + of G. This takes O (n 2:376 ) time <ref> [5] </ref>. Afterward, construct H using the arcs of G + . Then H is constructed in O (n 2:376 ) time.
Reference: [6] <author> T.H. Cormen, C.E. Leiserson and R.L. Rivest. </author> <title> Introduction to algorithms. </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: If all tasks are of unit length, then we may assume no starting time exceeds n 1. In that case, Algorithm Processor assignment computation requires only O (n + e) time, because sorting n numbers whose values are at most n requires only linear time using counting sort <ref> [6] </ref>. 3 Decomposition into chains Every graph can be viewed as a collection of disjoint chains with some dependencies between tasks in different chains: every graph with n nodes can be considered as the disjoint union of n chains consisting of one task.
Reference: [7] <author> R.P. </author> <title> Dilworth. A decomposition theorem for partially ordered sets. </title> <journal> Annals of Mathematics, </journal> <volume> 51(1) </volume> <pages> 161-166, </pages> <month> January </month> <year> 1950. </year> <month> 34 </month>
Reference-contexts: Dilworth <ref> [7] </ref> proved that a graph of width w can be viewed as the disjoint union of w chains. Theorem 3.1 (Dilworth's decomposition theorem). Let G be a graph of width w.
Reference: [8] <author> R.G. Downey and M.R. Fellows. </author> <title> Fixed-parameter intractability and completeness I: basic results. </title> <journal> SIAM Journal on Computing, </journal> <volume> 24(2) </volume> <pages> 873-921, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Bodlaender and Fellows [3] showed that constructing a minimum-length schedule for an arbitrary graph on k processors without communication delays is a W [2]-hard problem (W [2] is the second class of the W -hierarchy for parametrised problems, that was introduced by Downey and Fellows <ref> [8] </ref>). Consequently, it is unlikely that an algorithm exists with an O (n c ) running time that constructs minimum-length schedules on k processors for some constant c independent of k. In the W [2]-hardness proof, a graph of width k + 1 is constructed.
Reference: [9] <author> L. Finta, Z. Liu, I. Milis and E. Bampis. </author> <title> Scheduling UET-UCT series-parallel graphs on two processors. </title> <type> Technical Report RR 2566, </type> <institution> INRIA, Sophia-Antipolis, France, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: Finta, et al. <ref> [9] </ref> showed that for series-parallel graphs, a minimum-length schedule on two processors can be constructed in polynomial time.
Reference: [10] <author> D.R. Fulkerson. </author> <title> Note on Dilworth's decomposition theorem for partially ordered sets. </title> <booktitle> Proceedings of the AMS, </booktitle> <volume> 7 </volume> <pages> 701-702, </pages> <year> 1956. </year>
Reference-contexts: A decomposition of a graph of width w into w chains will be used by the dynamic-programming algorithms presented in Sections 4 5 and 7. Unfortunately, Dilworth's proof is not constructive: using his proof, one cannot construct a decomposition in an efficient way. The proof by Fulkerson <ref> [10] </ref> is constructive. In his proof of Dilworth's decomposition theorem, Fulkerson presented Algorithm Chain decomposition shown in Figure 3 and proved that it constructs chain decompositions consisting of w chains for graphs of width w. Algorithm Chain decomposition Input: A precedence graph G of width w.
Reference: [11] <author> M.R. Garey and D.S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <publisher> Freeman, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: tasks. fl This research was partially supported by ESPRIT Long Term Research Project 20244 (project ALCOM IT: Algorithms and Complexity in Information Technology). 1 For these special classes of precedence graphs, we cannot expect to find polynomial-time algo-rithms, if the task lengths are not restricted: the well-known NP-hard problem Partition <ref> [11] </ref> can be formulated as the problem of checking the existence of a schedule on two processors of length at most D for trees, series-parallel graphs and interval orders with arbitrary task lengths. <p> The last two sections of this report consider graphs of width w 3 with arbitrary task lengths. Using a polynomial reduction from Partition <ref> [11] </ref>, we will prove that constructing a minimum-length schedule for a graph consisting of three chains on two processors is an NP-hard problem. <p> The nodes of this graph are the common successors of u 1 and u 2 with deadline d + 1; there is an edge between nodes v 1 and v 2 , if D (v 1 ; v 2 ) = d. Since this is an NP-hard problem <ref> [11] </ref>, it is unlikely that this definition allows an efficient method of determining P D (u 1 ; u 2 ; d) for arbitrary precedence graphs. <p> In this section, it will be shown that if G has width w 3, then constructing a minimum-length schedule for (G; 2; ) is NP-hard. This is done using a reduction from Partition. Partition is the following well-known problem <ref> [11] </ref>. Problem. Partition Instance. A set of positive integers A = fa 1 ; : : : ; a n g. Question. Is there a subset A 0 of A, such that X a = a2AnA 0 Partition is an NP-complete problem [11]. Let Width3On2 be the following problem. Problem. <p> Partition is the following well-known problem <ref> [11] </ref>. Problem. Partition Instance. A set of positive integers A = fa 1 ; : : : ; a n g. Question. Is there a subset A 0 of A, such that X a = a2AnA 0 Partition is an NP-complete problem [11]. Let Width3On2 be the following problem. Problem. Width3On2 Instance. An instance (G; 2; ), where G is a graph of width three and a positive integer B. Question.
Reference: [12] <author> A. Goralckova and V. </author> <title> Koubek. A reduct-and-closure algorithm for graphs. </title> <editor> In J. Becvar, editor, </editor> <booktitle> Mathematical Foundations of Computer Science 1979, number 74 in Lecture Notes in Computer Science, </booktitle> <pages> pages 301-307, </pages> <address> Berlin, 1979. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This takes O (2 w w 2 n) time for each pair, so O (2 w w 3 n 2 ) time in total. Goralckova and Koubek <ref> [12] </ref> proved that the transitive closure of a directed graph G can be computed in O (n + e + ne ) time, where e is the number of arcs in the transitive reduction of G. <p> Hence, given the transitive reduction of G, Algorithm Deadline modification constructs a feasible assignment of starting times in O (n 2 ) time. Using the result of Goralckova and Koubek <ref> [12] </ref>, we find that the transitive reduction of a graph of width two can be constructed in O (n 2 ) time. Consequently, assigning starting times takes O (n 2 ) time. Theorem 5.25.
Reference: [13] <author> J.E. Hopcroft and R.M. Karp. </author> <title> A n 5 2 algorithm for maximum matchings in bipartite graphs. </title> <journal> SIAM Journal on Computing, </journal> <volume> 2(4) </volume> <pages> 225-231, </pages> <month> December </month> <year> 1973. </year>
Reference-contexts: Then H is constructed in O (n 2:376 ) time. It is not difficult to see that the time needed to construct the decomposition using bipartite graph H is dominated by the time needed to compute a maximum matching M of H. Hopcroft and Karp <ref> [13] </ref> presented an algorithm that computes a maximum matching in O (e p n) time for bipartite graphs with n nodes and e edges.
Reference: [14] <author> J.K. Lenstra, M. Veldhorst and B. Veltman. </author> <title> The complexity of scheduling trees with communication delays. </title> <journal> Journal of Algorithms, </journal> <volume> 20(1) </volume> <pages> 157-173, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Most scheduling problems with unit communication delays are NP-hard, even if all tasks have unit length: Rayward-Smith [16] proved that constructing minimum-length schedules for arbitrary precedence graphs on m processors is NP-hard. Lenstra, et al. <ref> [14] </ref> showed the same for the case that the precedence constraints form a tree.
Reference: [15] <author> R.H. Mohring. </author> <title> Computationally tractable classes of ordered sets. </title> <editor> In I. Rival, editor, </editor> <booktitle> Algorithms and Order, </booktitle> <pages> pages 105-194, </pages> <address> Dordrecht, the Netherlands, 1989. </address> <publisher> Kluwer Academic Publishers. </publisher>
Reference-contexts: The first considers unit-length tasks that have to be scheduled subject to unit communication delays. It uses the property that at any time t at most 2 w possible combinations of tasks can be executed. The algorithm uses a dynamic-programming approach similar to the ones presented by Mohring <ref> [15] </ref> and Veltman [19]. Given the set of tasks executed at or before time t, it considers all possible assignments of tasks to time t + 1 and determines a set which yields a schedule whose length is minimum with respect to the tasks that have been scheduled earlier. <p> In particular, the dynamic-programming approach can be used for scheduling graphs of bounded width without communication delays. The algorithm presented in this section is similar to the one by Mohring <ref> [15] </ref> for scheduling graphs of bounded width without communication delays, and the one presented by Veltman [19] for scheduling with unit communication delays. Like the algorithm presented in this section, these algorithms use prefixes. They use the name order ideal instead of prefix. <p> Like the algorithm presented in this section, these algorithms use prefixes. They use the name order ideal instead of prefix. When constructing a minimum-length schedule for an instance (G; m; 1l) without communication delays, Mohring <ref> [15] </ref> constructs a directed graph on the prefixes of (G; m; 1l): there is an arc from U 1 to U 2 , if U 1 U 2 , jU 2 n U 1 j m, and U 2 n U 1 does not contain comparable elements.
Reference: [16] <author> V.J. Rayward-Smith. </author> <title> UET scheduling with unit interprocessor communication delays. </title> <journal> Discrete Applied Mathematics, </journal> <volume> 18 </volume> <pages> 55-71, </pages> <year> 1987. </year>
Reference-contexts: In this report, we consider the problem of scheduling with unit-length interprocessor communication delays on a finite set of identical processors. Most scheduling problems with unit communication delays are NP-hard, even if all tasks have unit length: Rayward-Smith <ref> [16] </ref> proved that constructing minimum-length schedules for arbitrary precedence graphs on m processors is NP-hard. Lenstra, et al. [14] showed the same for the case that the precedence constraints form a tree.
Reference: [17] <author> Y.N. Sotskov and N.V. Shakhlevich. </author> <title> NP-hardness of shop-scheduling problems with three jobs. </title> <journal> Discrete Applied Mathematics, </journal> <volume> 59(3) </volume> <pages> 237-266, </pages> <year> 1995. </year>
Reference-contexts: As a result, the dynamic-programming approach is a pseudo-polynomial algorithm. It is unlikely that there is a polynomial-time algorithm that constructs minimum-length schedules for instances (G; 1; ; ): Sotskov and Shakhlevich <ref> [17] </ref> proved that constructing a minimum-length schedule on three processors for a job shop with three jobs is an NP-hard problem.
Reference: [18] <author> T.A. Varvarigou, V.P. Roychowdhury, T. Kailath and E. Lawler. </author> <title> Scheduling in and out forests in the presence of communication delays. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 7(10) </volume> <pages> 1065-1074, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: Lenstra, et al. [14] showed the same for the case that the precedence constraints form a tree. The only scheduling problems that do not neglect communication delays and are solvable in polynomial time consider unit-length tasks and a special kind of precedence constraints: Var-varigou, et al <ref> [18] </ref> presented an algorithm that constructs a minimum-length schedule on m processors for an outforest in O (n 2m2 ) time. Finta, et al. [9] showed that for series-parallel graphs, a minimum-length schedule on two processors can be constructed in polynomial time.
Reference: [19] <author> B. Veltman. </author> <title> Multiprocessor scheduling with communication delays. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology, Eindhoven, </institution> <address> the Netherlands, </address> <year> 1993. </year>
Reference-contexts: It uses the property that at any time t at most 2 w possible combinations of tasks can be executed. The algorithm uses a dynamic-programming approach similar to the ones presented by Mohring [15] and Veltman <ref> [19] </ref>. Given the set of tasks executed at or before time t, it considers all possible assignments of tasks to time t + 1 and determines a set which yields a schedule whose length is minimum with respect to the tasks that have been scheduled earlier. <p> In particular, the dynamic-programming approach can be used for scheduling graphs of bounded width without communication delays. The algorithm presented in this section is similar to the one by Mohring [15] for scheduling graphs of bounded width without communication delays, and the one presented by Veltman <ref> [19] </ref> for scheduling with unit communication delays. Like the algorithm presented in this section, these algorithms use prefixes. They use the name order ideal instead of prefix. <p> A path in the directed graph on the pairs (U 1 ; U 2 ) corresponds to a feasible schedule for (G; m; 1l). Veltman <ref> [19] </ref> states that a minimum-length schedule is constructed in O (n 2w ) if G is a graph of fixed width w.
Reference: [20] <author> J. Verriet. </author> <title> Scheduling interval orders with release dates and deadlines. </title> <type> Technical Report UU-CS-1996-12, </type> <institution> Department of Computer Science, Utrecht University, </institution> <month> March </month> <year> 1996. </year> <note> This report has been revised and submitted for publication in Parallel Computing. 35 </note>
Reference-contexts: The second algorithm is presented in Section 5. It considers graphs of width at most two with arbitrary task lengths. It is a generalisation of an algorithm that constructs minimum-tardiness schedules for interval-ordered tasks of unit length with non-uniform deadlines <ref> [20] </ref>. It will be proved that the algorithm for interval orders also constructs minimum-tardiness schedules on two processors for graphs of width two with unit-length tasks subject to unit communication delays. Such a schedule is constructed in O (n 2 ) time. <p> In earlier work, I presented an algorithm that constructs minimum-tardiness schedules for interval-ordered tasks with non-uniform deadlines on an arbitrary number of processors <ref> [20] </ref>. In Section 5.1, I will show that this algorithm constructs minimum-tardiness schedules for graphs of width two with unit-length tasks. By choosing all deadlines equal, it also constructs minimum-length schedules. <p> It constructs minimum-length schedules if all deadlines are equal. 5.1 Unit-length tasks For interval orders with unit-length tasks, I presented an algorithm for scheduling subject to unit-length communication delays <ref> [20] </ref>. It constructs minimum-tardiness schedules for instances (G; m; 1l; D 0 ), where G is an interval order and D 0 : V G ! ZZ + is a function assigning a deadline to every task of G.
References-found: 20

