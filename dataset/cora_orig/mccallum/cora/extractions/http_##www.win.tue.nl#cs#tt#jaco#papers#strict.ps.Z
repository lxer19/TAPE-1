URL: http://www.win.tue.nl/cs/tt/jaco/papers/strict.ps.Z
Refering-URL: http://www.win.tue.nl/cs/tt/jaco/papers/
Root-URL: http://www.win.tue.nl
Email: jaco@phil.ruu.nl schwicht@rz.mathematik.uni-muenchen.de  
Title: Strict Functionals for Termination Proofs HRS involving map and append. The usual rules for higher
Author: Jaco van de Pol and Helmut Schwichtenberg 
Note: An  the European Community.  
Affiliation: Mathematisches Institut, Universitat Munchen  
Abstract: A semantical method to prove termination of higher order rewrite systems (HRS) is presented. Its main tool is the notion of a strict functional, which is a variant of Gandy's notion of a hereditarily monotonic functional [1]. The main advantage of the method is that it makes it possible to transfer ones intuitions about why an HRS should be terminating into a proof: one has to find a "strict" interpretation of the constants involved in such a way that the left hand side of any rewrite rule gets a bigger value than the right hand side. The applicability of the method is demonstrated in three examples. * Derivation terms for natural deduction systems. We prove termination of the rules for fi-conversion and permutative conversion for logical rules including introduction and elimination rules for the existential quantifier. This has already been proved by Prawitz in [5]; however, our proof seems to be more perspicuous. Technically we build on [7]. There a notion of a strict functional and simultaneously of a strict greater-than relation &gt; str between monotonic functionals is introduced. The main result then is the following. Let M be a term in fi normal form and fl 2 FV(M ). Then for any strict environment U and all monotonic f and g, one has f &gt; mon g =) [[M ]] U[fl7!f] &gt; str [[M ]] U[fl7!g] . From this van de Pol derives the technique described above for proving termination of higher order term rewrite systems, generalizing a similar approach for first order rewrite systems (cf. [3, p. 367]). Interesting applications are given in [7]. Here a slight change in the definition of strictness is exploited (against the original conference paper; cf. [7, Footnote p. 316]). This makes it possible to deal with rewrite rules involving types of level &gt; 2 too, and in particular with proof theoretic applications. In order to do this some theory of strict functionals is developed. We also add product types, which are necessary to treat e.g. the existential quantifier. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Robin O. </author> <title> Gandy. Proofs of strong normalization. </title> <editor> In J.P. Seldin and J.R. Hind-ley, editors, </editor> <booktitle> To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 457-477. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: Proof by simultaneous induction on M (standard). fl 2 Definition. f &gt; mon g () for all ~ x 2 M [ f0; 1g; f ( ~ x) &gt; g ( ~ x). Remark . Gandy's definition of hereditarily monotonic functionals from <ref> [1] </ref> has the following form. <p> Consider e.g. the term xz (y 0), where x is interpreted by x 2 G. Then also in the case [[M ]] &gt; Gandy [[N ]] one cannot conclude [[xM (y 0)]] &gt; [[xN (y 0)]], since [[y 0]] 62 G. Hence Gandy in <ref> [1] </ref> had to restrict himself to -I-terms. As an alternative it is tempting to replace "for all ~ x; ~ y 2 G" in (i) by "for all ~ x; ~ y 2 M". <p> Furthermore it turns out to be useful to add f 2 M to the right hand side of (i) and also f g to the right hand side of (ii). On pairs, the order &gt; Gandy is defined pointwise in <ref> [1] </ref>. We propose a change to obtain a more well suited order for termination proofs. If in a pair hM; N i, M rewrites to M 0 , with [[M ]] &gt; [[M 0 ]], one wants to conclude that the corresponding interpretation gets smaller. <p> In [5] several reductions are given, to bring proofs into a certain normal form. These are divided in proper reductions and permutative conversions. Strong normalization is then proved via a refined notion of strong computability, strong validity. In <ref> [1] </ref> also examples taken from proof theory occur. There a normalization proof is given via hereditarily monotonic functionals, but the permutative conversions are not dealt with.
Reference: [2] <author> Jean-Yves Girard. </author> <title> Proof Theory and Logical Complexity. </title> <type> Bibliopolis, </type> <institution> Napoli, </institution> <year> 1987. </year>
Reference-contexts: Strong normalization is then proved via a refined notion of strong computability, strong validity. In [1] also examples taken from proof theory occur. There a normalization proof is given via hereditarily monotonic functionals, but the permutative conversions are not dealt with. We also refer to <ref> [2] </ref> for another adaptation of Gandy's approach, which can be extended to the full calculus including permutative conversions (See [2, Exc. 2.C.10]). Instead of bounding reduction lengths by functionals, Girard uses the length of a specific reduction path, given by a weak normalization theorem for the full calculus. <p> There a normalization proof is given via hereditarily monotonic functionals, but the permutative conversions are not dealt with. We also refer to [2] for another adaptation of Gandy's approach, which can be extended to the full calculus including permutative conversions (See <ref> [2, Exc. 2.C.10] </ref>). Instead of bounding reduction lengths by functionals, Girard uses the length of a specific reduction path, given by a weak normalization theorem for the full calculus. We present a termination proof for the whole calculus, including the permutative conversions. However, for simplicity we don't include disjunction.
Reference: [3] <author> Gerard Huet and Derek Oppen. </author> <title> Equations and rewrite rules | a survey. </title> <booktitle> In Formal Language Theory | Perspectives and Open Problems, </booktitle> <pages> pages 349-405. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: From this van de Pol derives the technique described above for proving termination of higher order term rewrite systems, generalizing a similar approach for first order rewrite systems (cf. <ref> [3, p. 367] </ref>). Interesting applications are given in [7]. Here a slight change in the definition of strictness is exploited (against the original conference paper; cf. [7, Footnote p. 316]).
Reference: [4] <author> Tobias Nipkow. </author> <title> Orthogonal higher-order rewrite systems are confluent. </title> <editor> In M. Bezem and J.F. Groote, editors, </editor> <title> Typed Lambda Calculi and Applications, </title> <booktitle> volume 664 of Lecture Notes in Computer Science, </booktitle> <pages> pages 306-317, </pages> <address> Berlin, 1993. </address> <publisher> Springer. </publisher>
Reference-contexts: Hence this notion of an HRS is quite liberal (and e.g. strictly includes the one given by Nipkow in <ref> [4] </ref>). The reason for this liberality is of course that termination results get stronger that way. See [8] for a comparison with other higher-order rewrite formats. Example. Consider the rule x:x + x 7! x x.
Reference: [5] <author> Dag Prawitz. </author> <title> Ideas and results in proof theory. </title> <editor> In J.E. Fenstad, editor, </editor> <booktitle> Proceedings of the Second Scandinavian Logic Symposium, </booktitle> <pages> pages 235-307. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1971. </year>
Reference-contexts: introduction and elimination rules for the existential quantifier. This has already been proved by Prawitz in <ref> [5] </ref>; however, our proof seems to be more perspicuous. Technically we build on [7]. There a notion of a strict functional and simultaneously of a strict greater-than relation &gt; str between monotonic functionals is introduced. The main result then is the following. <p> Example: Permutative Conversions The next example comes from proof theory in the style of Prawitz. In <ref> [5] </ref> several reductions are given, to bring proofs into a certain normal form. These are divided in proper reductions and permutative conversions. Strong normalization is then proved via a refined notion of strong computability, strong validity. In [1] also examples taken from proof theory occur. <p> We define FA ("xu:de) := FA (d) [ (FA (e) n fug). In the other cases the set of free assumption variables is defined as usual. The following conversion rules are taken from <ref> [5] </ref>. The first four are the proper reductions, the last four are called permutative conversions.
Reference: [6] <author> Anne S. Troelstra and Dirk van Dalen. </author> <title> Constructivism in Mathematics. An Introduction, </title> <booktitle> volume 121, 123 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1988. </year>
Reference-contexts: This is done by removing the dependencies on object terms, also called collapsing. This technique is also used in <ref> [6, p. 560] </ref>. Collapsing A will be denoted by A fl . In the following definition, P is a predicate symbol.
Reference: [7] <author> Jaco van de Pol. </author> <title> Termination proofs for higher-order rewrite systems. </title> <editor> In J. Heering, K. Meinke, B. Moller, and T. Nipkow, editors, </editor> <title> Higher-Order Algebra, Logic and Term Rewriting (HOA '93), </title> <booktitle> volume 816 of Lecture Notes in Computer Science, </booktitle> <pages> pages 305-325, </pages> <address> Berlin, 1994. </address> <publisher> Springer. </publisher>
Reference-contexts: introduction and elimination rules for the existential quantifier. This has already been proved by Prawitz in [5]; however, our proof seems to be more perspicuous. Technically we build on <ref> [7] </ref>. There a notion of a strict functional and simultaneously of a strict greater-than relation &gt; str between monotonic functionals is introduced. The main result then is the following. Let M be a term in fi normal form and fl 2 FV (M ). <p> From this van de Pol derives the technique described above for proving termination of higher order term rewrite systems, generalizing a similar approach for first order rewrite systems (cf. [3, p. 367]). Interesting applications are given in <ref> [7] </ref>. Here a slight change in the definition of strictness is exploited (against the original conference paper; cf. [7, Footnote p. 316]). This makes it possible to deal with rewrite rules involving types of level &gt; 2 too, and in particular with proof theoretic applications. <p> Interesting applications are given in [7]. Here a slight change in the definition of strictness is exploited (against the original conference paper; cf. <ref> [7, Footnote p. 316] </ref>). This makes it possible to deal with rewrite rules involving types of level &gt; 2 too, and in particular with proof theoretic applications. In order to do this some theory of strict functionals is developed. <p> Remark . In <ref> [7] </ref> a very similar modification of Gandy's definition is used. In a preliminary version, the requirement f g in (ii) was missing. For the examples considered in [7], which only concern rewrite rules for constants of level 2, this makes no difference. <p> Remark . In <ref> [7] </ref> a very similar modification of Gandy's definition is used. In a preliminary version, the requirement f g in (ii) was missing. For the examples considered in [7], which only concern rewrite rules for constants of level 2, this makes no difference. However, if one considers higher order rewrite rules like those for the primitive recursion operators in Godel's T , then it is necessary to be able to infer f g from f &gt; str g. <p> Proposition. &gt; str is well-founded on any T ae . Proof. Let (x i ) i2N of type ae be given. Consider (M ae (x i )) i2N . fl Following <ref> [7] </ref> we define a higher order term rewrite system (HRS) to be given by rules L 7! R with closed terms L; R of the same type ae. <p> See [8] for a comparison with other higher-order rewrite formats. Example. Consider the rule x:x + x 7! x x. Then u; v:c (w:wu + wu)(v + v) ! u; v:c (w:wu)v using the term M := u; v:c (w:fl (wu))(flv). Now we obtain as in <ref> [7] </ref> the following method to prove termination of higher order rewrite systems. (1) For the base types choose domains T together with well-founded (partial) orders &gt; .
Reference: [8] <author> Vincent van Oostrom. </author> <title> Confluence for Abstract and Higher-Order Rewriting. </title> <type> PhD thesis, </type> <institution> Vrije Universiteit, </institution> <address> Amsterdam, </address> <year> 1994. </year> <month> 15 </month>
Reference-contexts: Hence this notion of an HRS is quite liberal (and e.g. strictly includes the one given by Nipkow in [4]). The reason for this liberality is of course that termination results get stronger that way. See <ref> [8] </ref> for a comparison with other higher-order rewrite formats. Example. Consider the rule x:x + x 7! x x. Then u; v:c (w:wu + wu)(v + v) ! u; v:c (w:wu)v using the term M := u; v:c (w:fl (wu))(flv).
References-found: 8

