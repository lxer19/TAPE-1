URL: http://www.cs.columbia.edu/~kar/pubsk/oojive.ps
Refering-URL: http://www.cs.columbia.edu/~kar/pubsk/pubsk.html
Root-URL: http://www.cs.columbia.edu
Email: kar@cs.columbia.edu  
Title: Efficiently Following Object References for Large Object Collections and Small Main Memory  
Author: Kenneth A. Ross 
Address: New York, NY 10027  
Affiliation: Department of Computer Science, Columbia University,  
Abstract: We consider queries over large object-oriented databases in which one class of objects contains references to another class of objects. In order to answer the query efficiently, the database system needs to be able to follow object pointers from a large collection of objects in a way that minimizes the I/O cost. Traditional techniques require significant redundant I/O when both the referencing class and the referenced class are substantially larger than main memory. We propose a new technique for processing a class of object-oriented queries that is an adaptation of the Jive-Join algorithm of Ross and Li. Our algorithm applies as long as the number of disk blocks in the referenced relation is roughly of the order of the square of the number of blocks that fit in main memory. The cost of the algorithm is at most one pass through each input class extension, one pass through an index file if there is an index, and two passes through a temporary file that contains the object-identifier of the referenced object for each output tuple. Almost all of the I/O is sequential, resulting in minimal seek and rotational latencies. We analyze the cost of our algorithm, and compare our algorithm with a naive algorithm, and with an adaptation of an algorithm due to Valduriez. We demonstrate that under a wide range of circumstances, our algorithm performs significantly better than its competitors. The performance improvement is most dramatic when there is a small amount of memory, and when the input class extensions are very large.
Abstract-found: 1
Intro-found: 1
Reference: [A + 94] <author> R. Agrawal et al. </author> <title> Quest: A project on database mining. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <pages> page 514, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Examples include NASA's Earth Observing System, with an estimated 1 terabyte of data per day of information [Doz92], and data mining and decision-support applications with massive amounts of transaction information <ref> [A + 94] </ref>. Multimedia applications in which objects are very large also fit our model. Further, as the technology improves, more applications will emerge to take advantage of techniques for rapidly processing large volumes of data.
Reference: [B + 92] <author> K. Brown et al. </author> <title> Resource allocation and scheduling for mixed database workloads. </title> <type> Technical Report 1095, </type> <institution> University of Wisconsin, Madison, </institution> <year> 1992. </year>
Reference-contexts: T X is the disk transfer time for a disk block of data, and N X is the number of block transfers. Following [HCL93], we choose values of T S , T L , and T X to model an existing disk drive, namely the Fujitsu M2266 described in <ref> [B + 92] </ref>. The parameters are T S = 9:5 msec., T L = 8:3 msec., and T X = 2:6 msec., with the block size b = 8192 bytes, the number of blocks per cylinder c = 83, and a total capacity D = 130000 blocks (1 gigabyte).
Reference: [Bat79] <author> D. S. Batory. </author> <title> On searching transposed files. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(4) </volume> <pages> 531-544, </pages> <year> 1979. </year>
Reference-contexts: The first entry in each of the files corresponds to the first pair of objects, the second entry to the second pair, and so on. There is no need for any additional stored information This vertically fragmented data structure has been termed a "transposed file" <ref> [Bat79] </ref>. 3 Adapting Jive-Join to Object-Oriented Databases Jive-Join is an algorithm for performing joins in a relational database system using a join index [RL95b]. In this section we adapt the algorithm to apply to object-oriented databases.
Reference: [Doz92] <author> J. Dozier. </author> <title> Access to data in NASA's Earth Observing System. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <pages> page 1, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Examples include NASA's Earth Observing System, with an estimated 1 terabyte of data per day of information <ref> [Doz92] </ref>, and data mining and decision-support applications with massive amounts of transaction information [A + 94]. Multimedia applications in which objects are very large also fit our model. Further, as the technology improves, more applications will emerge to take advantage of techniques for rapidly processing large volumes of data.
Reference: [DWNS91] <author> D. De Witt, J. F. Naughton, and D. A. Schneider. </author> <title> Parallel sorting on a shared-nothing architecture using probabilistic splitting. </title> <booktitle> In Proceedings of the Conference on Parallel and Distributed Information Systems, </booktitle> <pages> pages 280-291, </pages> <year> 1991. </year>
Reference-contexts: One would partition the sample, and expect that, for a sufficiently large sample, the partitioning elements of the sample are close to the partitioning elements of the full extension of R 1 . An analysis of this kind of sampling approach is provided in <ref> [DWNS91, SN91] </ref>. We need to balance the I/O cost of the initial sampling step with the probability that skew will make one of the partitions in our algorithm too big to fit in main memory in Step 3.
Reference: [HCL93] <author> L. M. Haas, M. J. Carey, and M. Livny. </author> <title> Seeking the truth about ad hoc join costs. </title> <type> Technical Report RJ9368, </type> <institution> IBM Almaden Research Center, </institution> <year> 1993. </year>
Reference-contexts: The number of blocks per disk device is denoted by D. We denote the size of a disk block pointer by p bytes. 2.2 A Detailed Join Cost-Model Haas, Carey and Livny have proposed a detailed cost model in which seek time and latency time are explicit <ref> [HCL93] </ref>. These authors reexamine a number of ad-hoc join methods using their cost model, and demonstrate that the ranking of join methods obtained by using a block-transfer-only cost model for I/O may change when the same algorithms are analyzed using the more detailed cost model. <p> T X is the disk transfer time for a disk block of data, and N X is the number of block transfers. Following <ref> [HCL93] </ref>, we choose values of T S , T L , and T X to model an existing disk drive, namely the Fujitsu M2266 described in [B + 92]. <p> We compare firstly with the naive approach outlined in Section 1 and discussed in Appendix B. We also compare our algorithm with the modified algorithm of Valduriez, also outlined in Section 1 and presented in detail in Appendix A. We use the detailed cost model of <ref> [HCL93] </ref> for the comparison. Our comparisons will compare the I/O time taken to compute the output result against the memory size for a variety of input class extensions.
Reference: [N + 94] <author> C. Nyberg et al. Alphasort: </author> <title> A RISC machine sort. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <pages> pages 233-242, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Almost all of the CPU-intensive work can be done while waiting for disk I/O. Most of the CPU cycles in the algorithms of this paper are spent sorting; past work on sorting has shown that sorting is I/O-bound, even for systems with high-speed disk arrays <ref> [N + 94] </ref>. In any case, it is difficult to predict the CPU performance of a sorting algorithm without taking into account effects such as cache behavior [N + 94]. <p> of this paper are spent sorting; past work on sorting has shown that sorting is I/O-bound, even for systems with high-speed disk arrays <ref> [N + 94] </ref>. In any case, it is difficult to predict the CPU performance of a sorting algorithm without taking into account effects such as cache behavior [N + 94].
Reference: [RL95a] <author> K. Ross and Z. Li. </author> <title> Efficiently joining multiple large relations. </title> <note> Submitted for publication, </note> <year> 1995. </year>
Reference-contexts: One can extend the algorithm described in this paper to the case where there are several objects from several class extensions referenced by objects in R 1 . The details are beyond the scope of this paper. See <ref> [RL95a] </ref> for a description of how multiple participating relations are handled. Nested References. It is much more difficult to extend the algorithm presented here to queries in which the R 2 objects contain references to a third class R 3 of objects that are referenced by the query. <p> A better solution might be to maintain (or build) a path index containing all of the object-ids along each path of nested references. This path index could be treated like a join index, and processed as in <ref> [RL95a] </ref>. For the reason mentioned above, it would be significantly more difficult to use a version of this algorithm in a system with logical object identifiers.
Reference: [RL95b] <author> K. A. Ross and Z. Li. Jive-join and Smash-join: </author> <title> Efficient join techniques for large relations and small main memory. </title> <note> Submitted for publication, </note> <year> 1995. </year>
Reference-contexts: The I/O overhead is the writing and reading of a temporary file that contains the Condition pointer of every Patient object. The algorithm is an adaptation of the "Jive-join" algorithm of <ref> [RL95b] </ref>. We compare the analytic performance estimates for our extension of Jive-join against other proposed algorithms. For a range of values of the input parameters, we find that our extension of Jive-join significantly outperforms its competitors. <p> There is no need for any additional stored information This vertically fragmented data structure has been termed a "transposed file" [Bat79]. 3 Adapting Jive-Join to Object-Oriented Databases Jive-Join is an algorithm for performing joins in a relational database system using a join index <ref> [RL95b] </ref>. In this section we adapt the algorithm to apply to object-oriented databases. We will measure the cost of the new algorithm using the formula of Section 2.2. Our algorithm uses an internal data structure which we shall refer to as a disk buffer. <p> Differences from the Relational Version of Jive-Join. The basic ideas for Jive-join and its analysis come from <ref> [RL95b] </ref>. We now discuss the basic differences between this paper and [RL95b]. The most obvious difference is that here we do not have access to the join index. Instead, we use the object-identifiers embedded in the referencing objects. There are several consequences of this difference. <p> Differences from the Relational Version of Jive-Join. The basic ideas for Jive-join and its analysis come from <ref> [RL95b] </ref>. We now discuss the basic differences between this paper and [RL95b]. The most obvious difference is that here we do not have access to the join index. Instead, we use the object-identifiers embedded in the referencing objects. There are several consequences of this difference.
Reference: [SN91] <author> S. Seshadri and J. F. Naughton. </author> <title> Sampling issues in parallel database systems. </title> <type> (manuscript), </type> <year> 1991. </year>
Reference-contexts: One would partition the sample, and expect that, for a sufficiently large sample, the partitioning elements of the sample are close to the partitioning elements of the full extension of R 1 . An analysis of this kind of sampling approach is provided in <ref> [DWNS91, SN91] </ref>. We need to balance the I/O cost of the initial sampling step with the probability that skew will make one of the partitions in our algorithm too big to fit in main memory in Step 3.
Reference: [Val87] <author> P. Valduriez. </author> <title> Join indices. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2) </volume> <pages> 218-246, </pages> <year> 1987. </year>
Reference-contexts: One would then access in order only the objects satisfying the age criterion. Without an index on age, though, we must examine every Patient object. A less naive way to answer this query is an adaptation of a technique due to Valduriez <ref> [Val87] </ref>. One would read in as many Patient objects as fit in memory, and sort them based on the (pointer) value of diagnosis. One would then iterate through each memory-resident patient in this order, finding the condition by following the diagnosis pointer, and outputting the desired fields.
Reference: [Yao77] <author> S. B. Yao. </author> <title> Approximating block accesses in database organizations. </title> <journal> Communications of the ACM, </journal> <volume> 20(4) </volume> <pages> 260-261, </pages> <year> 1977. </year>
Reference-contexts: To estimate the number of blocks read, we shall use the function Y (k; d; n), which returns the optimal number of blocks needed to find k random objects out of n objects stored in d disk blocks <ref> [Yao77] </ref>. When k is large compared with d, Y (k; d; n) d. We do not consider input buffering in our cost model because almost all of our disk input is sequential, and we read from at most two inputs at any one time.
References-found: 12

