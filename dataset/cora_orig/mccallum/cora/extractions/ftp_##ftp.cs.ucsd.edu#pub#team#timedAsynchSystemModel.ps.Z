URL: ftp://ftp.cs.ucsd.edu/pub/team/timedAsynchSystemModel.ps.Z
Refering-URL: http://www.cs.ucsd.edu/users/flaviu/publications.html
Root-URL: http://www.cs.ucsd.edu
Title: The Timed Asynchronous System Model  
Author: Flaviu Cristian and Christof Fetzer 
Address: La Jolla, CA 920930114 CSE97-519  
Affiliation: Dept. of Computer Science, UCSD  
Abstract: We propose a formal definition for the timed asynchronous system model, we describe extensive measurements of actual message and process scheduling delays and hardware clock drifts that confirm that this model adequately describes current distributed systems built from networked workstations, and we give an explanation of why practically needed services, such as consensus or leader election, which are not implementable in the time-free asynchronous system model, are implementable in the timed model. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Amir and A. Wool. </author> <title> Evaluating quorum systems over the internet. </title> <booktitle> In Proc. 26th Int Symp on Fault-tolerant Computing, </booktitle> <pages> pages 26-35, </pages> <address> Sendai, Japan, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: For example, Solaris provides a function gethrtime (get high resolution time) that returns a clock value expressed as nanoseconds. In particular, these clocks are not affected by erroneous operator-requested clock adjustments that can be the cause of hardware clock failures <ref> [1] </ref>. For current workstation technology, the granularity of a hardware clock is typically between 1ns and 1s, and the constant is of the order of 10 4 to 3 clock H p is within [-,+]. 10 6 .
Reference: [2] <author> T. Chandra, V. Hadzilacos, S. Toueg, and B. Charron-Bost. </author> <title> On the impossibility of group membership. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 322-330, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Because in the time-free model an observer cannot distinguish between correct, slow or crashed processes, most of the services that are of importance in practice, such as consensus, election or membership, are not implementable <ref> [18, 21, 2] </ref>. Since [4], we have been using a different model for asynchronous systems, which we have called later [10] the timed asynchronous model, to avoid confusion with the time-free model.
Reference: [3] <author> T. Chandra and S. Toueg. </author> <title> Unreliable failure detectors for asynchronous systems. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 325-340, </pages> <month> Aug </month> <year> 1991. </year>
Reference-contexts: Progress assumptions have also a certain similarity with failure detectors <ref> [3] </ref> which are mechanisms for adding synchrony to the time-free model: certain failure detector classes provide their desired behavior based on the observation that the system eventually stabilizes. The quasi-synchronous model [23] is another approach to define a model that is in between synchronous systems and time-free asynchronous systems. <p> There are also many open questions with respect to the relation between the timed model extended by a progress assumption, and the time-free model extended by a failure detector <ref> [3] </ref>. For example, one question is which failure detectors are implementable in timed asynchronous systems and which are not. So far, we have shown that a Perfect failure detector is not implementable in a timed system even when extended by a progress assumption [13]. 11
Reference: [4] <author> F. Cristian. </author> <title> Probabilistic clock synchronization. </title> <journal> Distributed Computing, </journal> <volume> 3 </volume> <pages> 146-158, </pages> <year> 1989. </year> <title> An earlier version IBM Research Report, </title> <address> San Jose, RJ 6432, </address> <year> 1988. </year>
Reference-contexts: Because in the time-free model an observer cannot distinguish between correct, slow or crashed processes, most of the services that are of importance in practice, such as consensus, election or membership, are not implementable [18, 21, 2]. Since <ref> [4] </ref>, we have been using a different model for asynchronous systems, which we have called later [10] the timed asynchronous model, to avoid confusion with the time-free model. <p> Our use of this model was based on intuition that 1) it adequately describes existing distributed systems built from networked workstations and, 2) in contrast with the time-free model, the timed model allows practically needed services such as clock synchronization, membership, consensus, election, and atomic broadcast to be implemented <ref> [4, 10, 12, 6, 17] </ref>. Since it does not assume the existence of hardware 1 clocks or timed services, the time-free model may appear to be more general than the timed model. <p> Buffer overflows do not block senders, but result in com munication omission failures. The timed asynchronous system model was introduced (without being named) in <ref> [4] </ref>. It was further refined in [10] and renamed to avoid confusion with the time-free model [18].
Reference: [5] <author> F. Cristian. </author> <title> Understanding fault-tolerant distributed systems. </title> <journal> Communications of ACM, </journal> <volume> 34(2) </volume> <pages> 56-78, </pages> <month> Feb </month> <year> 1991. </year>
Reference-contexts: The datagram service does not ensure the existence of an upper bound for the transmission delay of messages. But since all services in our model are timed, we define a one-way time-out delay ffi, chosen so that the actual message sent or broadcast are likely <ref> [5] </ref> to be delivered within ffi. A message m whose trans mission delay is at most ffi, i.e. td q (m) ffi, is called timely. If m's transmission delay is greater than ffi, i.e. td q (m) &gt; ffi, we say that m suffers a performance failure (or is late). <p> Based on our measurements, we chose a timeout delay ffi of 20ms for that service. unicast messages sent by a local leader election protocol. This distribution is based on 500,000 replies. In summary, the asynchronous datagram service is assumed to have an omission/performance failure semantics <ref> [5] </ref>: it can lose a message or it can fail to deliver a message in a timely manner, but one can neglect the probability that a message delivered by the service is corrupted. <p> The process management service does not ensure the existence of an upper bound on scheduling delays. However, being a timed service, like all services in the timed model, we define a scheduling timeout delay , so that actual scheduling delays are likely <ref> [5] </ref> to be smaller than . We say that a process p suffers a performance failure when it is not awakened within time units of a specified real alarm time (see Figure 9). Otherwise, p is said to be timely. <p> Based on our mea surements, we selected a scheduling timeout delay of 30ms for this membership protocol. it requested to be awakened. It is based on 350,000 measurements. In summary, the timed model assumes that processes have crash/performance failure semantics <ref> [5] </ref> and that processes can recover from crashes. Since and are such small quantities, we equate (1 ) and (1 + ) with . 4 Extensions The core of the timed asynchronous system model assumes the datagram service, the process management service and the local hardware clocks.
Reference: [6] <author> F. Cristian. </author> <title> Group, majority, and strict agreement in timed asynchronous distributed systems. </title> <booktitle> In Proc. of the 26th Int. Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 178-187, </pages> <address> Sendai, Japan., </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Our use of this model was based on intuition that 1) it adequately describes existing distributed systems built from networked workstations and, 2) in contrast with the time-free model, the timed model allows practically needed services such as clock synchronization, membership, consensus, election, and atomic broadcast to be implemented <ref> [4, 10, 12, 6, 17] </ref>. Since it does not assume the existence of hardware 1 clocks or timed services, the time-free model may appear to be more general than the timed model.
Reference: [7] <author> F. Cristian. </author> <title> Synchronous and asynchronous group communication. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 88-97, </pages> <month> Apr </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Depending on whether the underlying communication and process management services make inter-process communication by messages certain or not, distributed systems can be classified as either synchronous or asynchronous <ref> [7] </ref>. Communication certainty in a synchronous system means that any message sent by a correct process to a correct destination process is received and processed at the destination within a bounded time. <p> Progress assumptions allow to solve problems like consensus, that were originally specified by using unconditional termination conditions, as opposed to our use of conditional timeliness properties. To further highlight the similarities and differences which exist between the synchronous and the timed asynchronous system models, <ref> [7] </ref> compares the properties of fundamental synchronous and asynchronous services such as membership and atomic broadcast. <p> We require that the safety invariants of a protocol designed for the timed asynchronous system model be always true independently of the choice of ffi. The choice of the timeout delay is crucial only for protocol stability and progress (see examples of safety, stability and timeliness properties in <ref> [7] </ref>.) The determination of a good ffi that ensures likely stability and progress typically requires the measurement of protocol specific transmission delays [22]. 3.2.1 Measurements based on 20,000 round-trips for four different message sizes. <p> performance is described in [9]. 4.2 Stability and Progress Assumptions The timeliness requirements encountered in the specification of protocols designed for the timed asynchronous system model are often conditional in the sense that only when some "system stability" predicate is true, the system has to achieve "something good" (see e.g. <ref> [7] </ref>). Such conditional timeli ness requirements express that when some set of pro cesses SP is "stable", that is, the failures affecting SP have a bounded rate of occurrence, the servers in SP have to guarantee progress within a bounded amount of time. <p> As an example of the utility of the above stabil ity predicate, consider an atomic broadcast protocol designed to achieve group agreement semantics <ref> [7] </ref>, where all messages that are possibly lost or late are re-sent up to F + 1 times.
Reference: [8] <author> F. Cristian, H. Aghili, R. Strong, and D. Dolev. </author> <title> Atomic broadcast: From simple message diffusion to Byzantine agreement. </title> <journal> Information and Computation, </journal> <volume> 118 </volume> <pages> 158-179, </pages> <month> April </month> <year> 1995. </year> <note> Early version: FTCS15, </note> <month> June </month> <year> 1985. </year>
Reference-contexts: The bounded failure rate assumption then allows system designers to use space <ref> [8] </ref> or time redundancy [24] to mask lower level communication failures and provide the abstraction of `certain communication'.
Reference: [9] <author> F. Cristian, S. Mishra, and Y. Hyun. </author> <title> Implementation and performance of a stable storage service for unix. </title> <booktitle> In Proceedings of the 15th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 86-95, </pages> <address> Niagara-on-the-Lake, Canada, </address> <month> Oct </month> <year> 1996. </year>
Reference-contexts: A stable storage service can be implemented on top of Unix using the Unix file system. An implementation of such a service and its performance is described in <ref> [9] </ref>. 4.2 Stability and Progress Assumptions The timeliness requirements encountered in the specification of protocols designed for the timed asynchronous system model are often conditional in the sense that only when some "system stability" predicate is true, the system has to achieve "something good" (see e.g. [7]).
Reference: [10] <author> F. Cristian and F. Schmuck. </author> <title> Agreeing on processor-group membership in asynchronous distributed systems. </title> <type> Technical Report CSE95-428, UCSD, </type> <year> 1995. </year>
Reference-contexts: Since [4], we have been using a different model for asynchronous systems, which we have called later <ref> [10] </ref> the timed asynchronous model, to avoid confusion with the time-free model. <p> Our use of this model was based on intuition that 1) it adequately describes existing distributed systems built from networked workstations and, 2) in contrast with the time-free model, the timed model allows practically needed services such as clock synchronization, membership, consensus, election, and atomic broadcast to be implemented <ref> [4, 10, 12, 6, 17] </ref>. Since it does not assume the existence of hardware 1 clocks or timed services, the time-free model may appear to be more general than the timed model. <p> Buffer overflows do not block senders, but result in com munication omission failures. The timed asynchronous system model was introduced (without being named) in [4]. It was further refined in <ref> [10] </ref> and renamed to avoid confusion with the time-free model [18]. In particular, [10] introduces system stability predicates and conditional timeliness properties to capture the intuition that as long as the system is stable, that is, the number of failures affecting the system is below a certain threshold, the system will <p> Buffer overflows do not block senders, but result in com munication omission failures. The timed asynchronous system model was introduced (without being named) in [4]. It was further refined in <ref> [10] </ref> and renamed to avoid confusion with the time-free model [18]. In particular, [10] introduces system stability predicates and conditional timeliness properties to capture the intuition that as long as the system is stable, that is, the number of failures affecting the system is below a certain threshold, the system will make progress within a bounded time. <p> The concept of a stable partition is formalized by a stability predicate that defines if a set of processes SP forms a stable partition in some given time interval [s; t]. There are multiple reasonable definitions for stability predicates: examples are the stable predi cate in <ref> [10] </ref>, or the majority-stable predicate in [12]. In this paper we formally define the stability predicate -F-partition introduced informally in [15]. To do that, we first formalize and generalize the notions of connectedness and disconnectedness introduced in [10]. <p> multiple reasonable definitions for stability predicates: examples are the stable predi cate in <ref> [10] </ref>, or the majority-stable predicate in [12]. In this paper we formally define the stability predicate -F-partition introduced informally in [15]. To do that, we first formalize and generalize the notions of connectedness and disconnectedness introduced in [10]. Two processes are F-connected in the time interval [s; t] iff (1) p and q are timely in [s; t], and (2) all but at most F messages sent between the two processes in [s; t] are delivered within at most ffi time units. <p> Instead, we use conditional timeliness condition. These require that if a system stabilizes for an a priori known duration, "something good" will happen within a bounded time. With the introduction of the -F-stable predicate earlier, we can generalize the specifications given in <ref> [10] </ref> and [17] for the election (or the highly available leadership) problem for timed asynchronous systems as follows: (S) at any real-time there exists at most one leader, and (TT) when a majority of processes are -F-stable in a time interval [s; s + ], then there exists a pro cess <p> The specification (S; T F ) is not implementable in time-free systems, even when only one process is allowed to crash [21], while (S; T T ) is implementable in timed systems <ref> [10, 17] </ref>. To explain why this is so, consider a time-free system that contains at least two processes p and q. <p> Second, when the system is stable, a majority of timely processes can communicate with each other in a timely fashion. This is sufficient to elect one of these processes as leader in a bounded amount of time and ensure that the timeliness requirement is also satisfied <ref> [10, 17] </ref>. Note that the specification (S; T F ) is not implementable in the core timed model even when only one process is allowed to crash.
Reference: [11] <author> D. Dolev, C. Dwork, and L. Stockmeyer. </author> <title> On the minimal synchronism needed for distributed consensus. </title> <journal> Journal of the ACM, </journal> <volume> 34(1) </volume> <pages> 77-97, </pages> <month> Jan </month> <year> 1987. </year>
Reference-contexts: a systematic means of transforming synchronous service specifications into (fail-aware) specifications that are im plementable in timed asynchronous systems. 2 Progress assumptions, which require that, infinitely often, some majority set of processes becomes "stable" for a certain amount of time, have a certain similarity to the global stabilization requirement of <ref> [11] </ref>, which postulates that eventually a system must permanently stabilize, in the sense that there must exist a time beyond which all messages and all non-crashed processes become timely.
Reference: [12] <author> C. Fetzer and F. Cristian. </author> <title> On the possibility of consensus in asynchronous systems. </title> <booktitle> In Proceedings of the 1995 Pacific Rim Int'l Symp. on Fault-Tolerant Systems, </booktitle> <address> Newport Beach, CA, </address> <month> Dec </month> <year> 1995. </year>
Reference-contexts: Our use of this model was based on intuition that 1) it adequately describes existing distributed systems built from networked workstations and, 2) in contrast with the time-free model, the timed model allows practically needed services such as clock synchronization, membership, consensus, election, and atomic broadcast to be implemented <ref> [4, 10, 12, 6, 17] </ref>. Since it does not assume the existence of hardware 1 clocks or timed services, the time-free model may appear to be more general than the timed model. <p> Well-tuned systems are expected to alternate between long periods of stability and short periods of unstability, in which the failure rate raises beyond the assumed threshold. In <ref> [12] </ref> we introduced progress assumptions as an extension of the timed asynchronous system model: a progress assumption states that after an unstable period there always exists a time interval of bounded length in which the system will be stable. <p> There are multiple reasonable definitions for stability predicates: examples are the stable predi cate in [10], or the majority-stable predicate in <ref> [12] </ref>. In this paper we formally define the stability predicate -F-partition introduced informally in [15]. To do that, we first formalize and generalize the notions of connectedness and disconnectedness introduced in [10]. <p> These stability periods alternate with short instability periods. Based on this observation, 8 we introduced the concept of progress assumptions <ref> [12] </ref> to show that classical services, such as consensus, originally specified by using unconditional termination requirements, are implementable in the extended timed model.
Reference: [13] <author> C. Fetzer and F. Cristian. </author> <title> Fail-aware failure detectors. </title> <booktitle> In Proceedings of the 15th Symposium on Reliable Distributed Systems, </booktitle> <address> Niagara-on-the-Lake, Canada, </address> <month> Oct </month> <year> 1996. </year>
Reference-contexts: For example, one question is which failure detectors are implementable in timed asynchronous systems and which are not. So far, we have shown that a Perfect failure detector is not implementable in a timed system even when extended by a progress assumption <ref> [13] </ref>. 11
Reference: [14] <author> C. Fetzer and F. Cristian. </author> <title> Fail-aware membership services. </title> <type> Technical Report CSE96-XXX, UCSD, </type> <year> 1996. </year>
Reference-contexts: Unix tries to awake the process before the specified time interval expires using an internal timer. This timer has typically a resolution of 10ms. Thus, the scheduling delay is at least 10ms. Figure 10 shows the distribution of scheduling delays experienced by a process execut ing a membership protocol <ref> [14] </ref>. Based on our mea surements, we selected a scheduling timeout delay of 30ms for this membership protocol. it requested to be awakened. It is based on 350,000 measurements. In summary, the timed model assumes that processes have crash/performance failure semantics [5] and that processes can recover from crashes. <p> The set of all six processes were, on the average, -1-stable for about 218s. The average distance between two -1-stable periods was about 340ms. The typical behavior experienced during an "unstable" phase was that one of the six processes was slow. The membership service <ref> [14] </ref> allows the fast processes to continue to make progress by temporarily removing the slow process (es) from the membership.
Reference: [15] <author> C. Fetzer and F. Cristian. Fail-awareness: </author> <title> An approach to construct fail-safe applications. </title> <type> Technical Report CS96-501, UCSD, </type> <month> Nov </month> <year> 1996. </year>
Reference-contexts: There are multiple reasonable definitions for stability predicates: examples are the stable predi cate in [10], or the majority-stable predicate in [12]. In this paper we formally define the stability predicate -F-partition introduced informally in <ref> [15] </ref>. To do that, we first formalize and generalize the notions of connectedness and disconnectedness introduced in [10]. <p> To illustrate how processes can communicate by (measuring the passage) of time in timed asynchronous system, we sketch how two processes p and q can ensure that at any time at most one of them is leader. We uses a locking mechanism <ref> [15] </ref> that facilitates communication by time even when local clocks are not synchronized.
Reference: [16] <author> C. Fetzer and F. Cristian. </author> <title> Fail-awareness in timed asynchronous systems. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Principles of Distribute d Computing, </booktitle> <address> Philadelphia, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: To further highlight the similarities and differences which exist between the synchronous and the timed asynchronous system models, [7] compares the properties of fundamental synchronous and asynchronous services such as membership and atomic broadcast. In <ref> [16] </ref> we introduced the notion of fail-awareness as a systematic means of transforming synchronous service specifications into (fail-aware) specifications that are im plementable in timed asynchronous systems. 2 Progress assumptions, which require that, infinitely often, some majority set of processes becomes "stable" for a certain amount of time, have a certain <p> A common situation in which two processes are -disconnected is when the network between them is overloaded or at least one of the processes is slow. One can use a fail-aware datagram service <ref> [16] </ref> to classify messages with a transmission delay greater than some &gt; ffi as "slow" and messages with a transmission delay of at most ffi as "fast". Messages with a transmission delay within (ffi; ] are either classified as "slow" or "fast". <p> Process q has to calculate an upper bound on the transmission delay of m to determine if it can use m. The fail-aware datagram service introduced in <ref> [16] </ref> calculates an upper bound on the transmission delay of messages (using round-trip messages). It delivers m as "fast" when its transmission delay is at most .
Reference: [17] <author> C. Fetzer and F. Cristian. </author> <title> A highly available local leader service. </title> <type> Technical Report CS96-499, UCSD, </type> <month> Nov </month> <year> 1996. </year>
Reference-contexts: Our use of this model was based on intuition that 1) it adequately describes existing distributed systems built from networked workstations and, 2) in contrast with the time-free model, the timed model allows practically needed services such as clock synchronization, membership, consensus, election, and atomic broadcast to be implemented <ref> [4, 10, 12, 6, 17] </ref>. Since it does not assume the existence of hardware 1 clocks or timed services, the time-free model may appear to be more general than the timed model. <p> For simplicity, we assume however that ffi and ffi min are constant. This is a valid assumption since the message size is bounded from below and above. 5 To demonstrate that transmission delays can be very protocol dependent, we measured the transmission times experienced by a local leadership service <ref> [17] </ref>. This measurement involved one process p periodically broadcasting messages and five processes sending immediate replies to each broadcast message of p. After receiving a reply, p spends some time processing it before receiving the next reply. <p> We call a set SP a stable partition <ref> [17] </ref> iff * all processes in SP are timely, * all but a bounded number of messages sent between processes in SP per protocol round are delivered in a timely manner, and * from any other partition either no message or only "late" messages arrive in SP . <p> Instead, we use conditional timeliness condition. These require that if a system stabilizes for an a priori known duration, "something good" will happen within a bounded time. With the introduction of the -F-stable predicate earlier, we can generalize the specifications given in [10] and <ref> [17] </ref> for the election (or the highly available leadership) problem for timed asynchronous systems as follows: (S) at any real-time there exists at most one leader, and (TT) when a majority of processes are -F-stable in a time interval [s; s + ], then there exists a pro cess p that <p> The specification (S; T F ) is not implementable in time-free systems, even when only one process is allowed to crash [21], while (S; T T ) is implementable in timed systems <ref> [10, 17] </ref>. To explain why this is so, consider a time-free system that contains at least two processes p and q. <p> Second, when the system is stable, a majority of timely processes can communicate with each other in a timely fashion. This is sufficient to elect one of these processes as leader in a bounded amount of time and ensure that the timeliness requirement is also satisfied <ref> [10, 17] </ref>. Note that the specification (S; T F ) is not implementable in the core timed model even when only one process is allowed to crash.
Reference: [18] <author> M. J. Fischer, N. A. Lynch, and M. S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> Apr </month> <year> 1985. </year>
Reference-contexts: The authors can be contacted by e-mail at: flaviu,cfetzer@cs.ucsd.edu chronous. The vast majority of distributed systems encountered in practice are asynchronous. Most published research on asynchronous systems is based on the well-known time-free model <ref> [18] </ref>, characterized by the following properties: 1) services are time-free: their specification describes what outputs and state transitions should occur in response to inputs without placing any bounds on the time it takes these outputs and state transitions to occur, 2) in-terprocess communication is reliable: any message sent between two non-crashed <p> Because in the time-free model an observer cannot distinguish between correct, slow or crashed processes, most of the services that are of importance in practice, such as consensus, election or membership, are not implementable <ref> [18, 21, 2] </ref>. Since [4], we have been using a different model for asynchronous systems, which we have called later [10] the timed asynchronous model, to avoid confusion with the time-free model. <p> Buffer overflows do not block senders, but result in com munication omission failures. The timed asynchronous system model was introduced (without being named) in [4]. It was further refined in [10] and renamed to avoid confusion with the time-free model <ref> [18] </ref>. In particular, [10] introduces system stability predicates and conditional timeliness properties to capture the intuition that as long as the system is stable, that is, the number of failures affecting the system is below a certain threshold, the system will make progress within a bounded time. <p> The timed asynchronous system model is not only interesting from a practical point of view, it also raises interesting theoretical questions. For example, it does not only allow to solve different problems than the time-free model <ref> [18] </ref>, it seems that the minimum message complexity to solve a problem could be different in the two models because the former allows communication by time.
Reference: [19] <author> L. Lamport and N. Lynch. </author> <title> Distributed computing: Models and methods. </title> <booktitle> In Handbook of Theoretical Computer Science, </booktitle> <pages> pages 1158-1199. </pages> <publisher> Elsevier Science Publishers, </publisher> <year> 1990. </year>
Reference-contexts: of why practically important services such as consensus or leader election, which are not implementable in the time-free asynchronous system model, are implementable in the timed model. 2 Related Work Distributed system models can be classified according to what they assume about network topology, synchrony, failure model, and message buffering <ref> [19] </ref>. According to this taxonomy, the timed asynchronous model can be characterized as follows: * network topology: any process knows the complete set of processes and can send messages to any process.
Reference: [20] <author> J. Postel. </author> <title> User datagram protocol. </title> <type> Technical Report RFC768, </type> <institution> USC/Information Sciences Institute, </institution> <year> 1980. </year>
Reference-contexts: The transmission delay of a message sent between two local processes can be smaller than ffi min . We also assume that the size of a message is not greater than some given upper bound. For example, the maximum message size for the U DP datagram service <ref> [20] </ref> is 64kBytes. The datagram service does not ensure the existence of an upper bound for the transmission delay of messages.
Reference: [21] <author> L. Sabel and K. Marzullo. </author> <title> Election vs. consensus in asynchronous systems. </title> <type> Technical Report TR95-1488, </type> <institution> Cornell University, </institution> <month> Feb </month> <year> 1995. </year>
Reference-contexts: Because in the time-free model an observer cannot distinguish between correct, slow or crashed processes, most of the services that are of importance in practice, such as consensus, election or membership, are not implementable <ref> [18, 21, 2] </ref>. Since [4], we have been using a different model for asynchronous systems, which we have called later [10] the timed asynchronous model, to avoid confusion with the time-free model. <p> For example, <ref> [21] </ref> specifies the election problem for the time-free system model as follows: (S) at any real-time there exists at most one leader, and (TF) infinitely often there exists a leader, i.e. for any real-time s there exists a real-time t s and a process p so that p becomes leader at <p> The specification (S; T F ) is not implementable in time-free systems, even when only one process is allowed to crash <ref> [21] </ref>, while (S; T T ) is implementable in timed systems [10, 17]. To explain why this is so, consider a time-free system that contains at least two processes p and q. <p> It is thus essential to understand that it is the access to local clocks that run within a linear envelope of real-time, which enable communication by time, that allows us to circumvent in the timed model the impossibility result of <ref> [21] </ref> stated for the time-free model. 6.3 Progress Assumptions Another observation is that while (S; T F ) does not have a deterministic solution in the core timed model, it is implementable in a practical network of workstations.
Reference: [22] <author> O. Suciu and C. </author> <title> Fetzer. Determining the user-level transmission delay in networks of workstations. </title> <type> Technical Report CS96-511, UCSD, </type> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: The choice of the timeout delay is crucial only for protocol stability and progress (see examples of safety, stability and timeliness properties in [7].) The determination of a good ffi that ensures likely stability and progress typically requires the measurement of protocol specific transmission delays <ref> [22] </ref>. 3.2.1 Measurements based on 20,000 round-trips for four different message sizes. Message transmission delays increase with message size (see Figure 6) and depend on the message transmission pattern used by a protocol (see Figure 7).
Reference: [23] <author> P. Verissimo and C. Almeida. Quasi-synchronism: </author> <title> a steo away from the traditional fault-tolerant real-time system models. </title> <journal> IEEE TCOS Bulletin, </journal> <volume> 7(4), </volume> <month> Dec </month> <year> 1995. </year>
Reference-contexts: Progress assumptions have also a certain similarity with failure detectors [3] which are mechanisms for adding synchrony to the time-free model: certain failure detector classes provide their desired behavior based on the observation that the system eventually stabilizes. The quasi-synchronous model <ref> [23] </ref> is another approach to define a model that is in between synchronous systems and time-free asynchronous systems.
Reference: [24] <author> P. Verissimo, L. Rodrigues, and M. Baptista. </author> <title> Amp: A highly parallel atomic multicast protocol. </title> <booktitle> In SIGCOMM'89, </booktitle> <pages> pages 83-93, </pages> <address> Austin, TX, </address> <month> Sep </month> <year> 1989. </year> <month> 12 </month>
Reference-contexts: The bounded failure rate assumption then allows system designers to use space [8] or time redundancy <ref> [24] </ref> to mask lower level communication failures and provide the abstraction of `certain communication'.
References-found: 24

