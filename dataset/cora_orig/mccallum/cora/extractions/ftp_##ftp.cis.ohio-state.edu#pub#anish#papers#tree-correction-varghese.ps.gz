URL: ftp://ftp.cis.ohio-state.edu/pub/anish/papers/tree-correction-varghese.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~anish/pub.html
Root-URL: http://www.cis.ohio-state.edu
Email: journals-orders@mit.edu, journals-info@mit.edu.  
Web: http://mitpress.mit.edu/CJTCS/ http://www.cs.uchicago.edu/publications/cjtcs/ ftp://mitpress.mit.edu/pub/CJTCS ftp://cs.uchicago.edu/pub/publications/cjtcs  
Address: Cambridge Center, Cambridge, MA 02142-1493 USA; (617)253-2889;  
Date: 1997, Article 3 4 September 1997  
Note: Chicago Journal of Theoretical Computer Science The MIT Press Volume  ISSN 1073-0486. MIT Press Journals, Five  Published one article at a time in L A T E X source form on the Internet. Pagination varies from copy to copy. For more information and other articles see:  
Abstract-found: 0
Intro-found: 1
Reference: [AG90] <author> Anish Arora and Mohamed G. Gouda. </author> <title> Distributed reset. </title> <booktitle> In Proceedings of the 10th Conference on Foundations of Software Technology and Theoretical Computer Science, volume 472 of Lecture Notes in Computer Science, </booktitle> <pages> pages 316-331, </pages> <address> Berlin, 1990. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: While Dijkstra's model is not very realistic, it captures the essential fea-1.2-2 tures of network protocols in a simple way. This allows us to state a very simple version of our main tree-correction theorem. Second, it allows us to apply our theorem to succinctly understand earlier protocols (e.g., [Dij74], <ref> [AG90] </ref>) that were described using Dijkstra's model. <p> In Section 3 we state Theorem 1, and provide a proof in Section 4. In Section 5, we show how a reset protocol <ref> [AG90] </ref> due to Arora and Gouda can also be simply understood in this framework. In Section 6, we describe how a mutual exclusion protocol, due to Dijkstra, can also be easily understood using our theorem. <p> For our purposes, it is convenient to model the parent values as part of the code at each node. More generally, the parent pointers could be variables that are set by a stabilizing spanning-tree protocol as shown in <ref> [AG90] </ref>. We often use the phrase "tree automaton" to mean a "shared-memory tree automaton," and the phrase "network automaton" to mean a "shared-memory network automaton." In general, shared-memory automata have start states (see first condition 2-9 in definition). <p> Actually the theorem only requires a property we call eventual correction: if a Correct u action is continuously enabled, then a Correct u action occurs within bounded time. This property can be established quite easily for the protocols in [Dij74] and <ref> [AG90] </ref>, allowing all the actions in the entire automaton to be placed in a single class! 5 A Reset Protocol on a Tree Before describing the reset protocol due to Arora and Gouda [AG90], we 5-1 first describe the network reset problem. <p> This property can be established quite easily for the protocols in [Dij74] and <ref> [AG90] </ref>, allowing all the actions in the entire automaton to be placed in a single class! 5 A Reset Protocol on a Tree Before describing the reset protocol due to Arora and Gouda [AG90], we 5-1 first describe the network reset problem. Recall that we have a collection of nodes that communicate by reading the state of their neighbors. The 16 Chicago Journal of Theoretical Computer Science 1997-3 Varghese et al. <p> Then, since the session numbers are only used for comparisons, it suffices to replace the session numbers by a single bit that we call sbit i . This is the first idea in Arora and Gouda's reset protocol <ref> [AG90] </ref>. 5 Finn also considered the problem of using bounded sequence numbers. His solution was shown to be incorrect by Humblett and Soloway, who proposed a fix in [SH87]. <p> Otherwise, multiple reset requests at the same node would cause the difference in session numbers to grow without bound. Thus nodes must coordinate before they increment session numbers. In Arora and Gouda's reset protocol <ref> [AG90] </ref>, the coordination is done 5-5 over a rooted tree. Arora and Gouda first show how to build a rooted tree in a stabilizing fashion. In what follows, we assume that the tree has already been built. <p> The I/O automaton code for this implementation is shown in Figures 2 and 3. 5-9 Notice that besides the actions we have already described, there is a Correct i action in Figure 3. This action was used in an earlier version <ref> [AG90] </ref> to ensure that the reset protocol was stabilizing. Informally, the reset protocol is stabilizing if after bounded time, any reset 5-10 requests will cause the application protocol to be properly reset. The correction action in Figure 3 [AG90] ensures stabilization in a very ingenious way. <p> This action was used in an earlier version <ref> [AG90] </ref> to ensure that the reset protocol was stabilizing. Informally, the reset protocol is stabilizing if after bounded time, any reset 5-10 requests will cause the application protocol to be properly reset. The correction action in Figure 3 [AG90] ensures stabilization in a very ingenious way. However, the proof of stabilization is somewhat difficult, and not as intuitive as one might like. The reader is referred to [AG90] for details. Instead, we will use local checking and tree correction to describe another correction procedure that is very intuitive. <p> The correction action in Figure 3 <ref> [AG90] </ref> ensures stabilization in a very ingenious way. However, the proof of stabilization is somewhat difficult, and not as intuitive as one might like. The reader is referred to [AG90] for details. Instead, we will use local checking and tree correction to describe another correction procedure that is very intuitive. As a result, the proof of stabilization becomes transparent. <p> i (*internal action to propagate completion wave upwards *) Preconditions: mode i = reset For all children j of i: mode j = normal and sbit i = sbit j Effects: mode i := normal Every action is in a separate class with upper bound equal to t node Protocol <ref> [AG90] </ref> 20 Chicago Journal of Theoretical Computer Science 1997-3 Varghese et al. <p> Correct i (*extra internal action for correction at node i*) Preconditions: j = parent (i) 6= nil (mode j = mode i ) and (sbit i 6= sbit j ) Effects: sbit i := sbit j Every action is in a separate class with upper bound equal to t node <ref> [AG90] </ref> If the child has not "noticed" that the parent's state is reset, then the child's bit is not equal to the parent's bit. (This follows because when the parent changes its mode to reset, the parent also changes its bit; and just before such an action the second predicate assures <p> Then <ref> [AG90] </ref> shows that the system will execute reset requests correctly in any state starting with s. This is not very hard to believe, but it means that all we have to do is add correction actions so that all link predicates will become true in bounded time.
Reference: [AGV94] <author> Anish Arora, Mohamed G. Gouda, and George Varghese. </author> <title> Distributed constraint satisfaction. </title> <booktitle> In DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <month> February </month> <year> 1994. </year>
Reference-contexts: We conjecture that their method could be applied to make our theorem applicable to uniform tree networks. Also, [CDK91] has a number of other results on general networks, including a self-stabilizing procedure to find a feasible solution using distributed backtracking. Finally, <ref> [AGV94] </ref> also expresses local checkability conditions using con-7-8 straint graphs. The formulation in [AGV94] applies to more general protocols than the constraint satisfaction protocols of [CDK91]. However, none of the theorems in [AGV94] imply our tree-correction theorem. 8 Conclusions It may seem obvious that any locally checkable protocol on a tree <p> Also, [CDK91] has a number of other results on general networks, including a self-stabilizing procedure to find a feasible solution using distributed backtracking. Finally, <ref> [AGV94] </ref> also expresses local checkability conditions using con-7-8 straint graphs. The formulation in [AGV94] applies to more general protocols than the constraint satisfaction protocols of [CDK91]. However, none of the theorems in [AGV94] imply our tree-correction theorem. 8 Conclusions It may seem obvious that any locally checkable protocol on a tree can be 8-1 stabilized; however, it is a different matter to state and <p> Finally, <ref> [AGV94] </ref> also expresses local checkability conditions using con-7-8 straint graphs. The formulation in [AGV94] applies to more general protocols than the constraint satisfaction protocols of [CDK91]. However, none of the theorems in [AGV94] imply our tree-correction theorem. 8 Conclusions It may seem obvious that any locally checkable protocol on a tree can be 8-1 stabilized; however, it is a different matter to state and prove a precise result that embodies this intuition.
Reference: [APV91] <author> Baruch Awerbuch, Boaz Patt-Shamir, and George Varghese. </author> <title> Self-stabilization by local checking and correction. </title> <booktitle> In Proceedings of the 32nd IEEE Symposium on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: Intuitively, centralized checking and correction is slow, and has high message complexity. Thus the general transformation is expensive; hence more efficient (and possibly less general) techniques are worth investigating. One such direction <ref> [APV91, Var93] </ref> is to divide the network into a num-1.1-2 ber of overlapping link subsystems. A link subsystem consists of a pair of neighboring nodes and the channels, if any, between them. 1 The idea is to replace the global, centralized checking of [KP90] with local, decentralized checking. <p> Clearly, local correction is non trivial, because link subsystems overlap at nodes that have more than two neighbors. Techniques that transform any locally checkable and correctable protocol 1.1-4 into a stabilizing equivalent are given in <ref> [APV91, Var93] </ref>. The idea is simple: a leader is elected for each link subsystem. Each leader periodically checks the invariants of its link subsystem and corrects the subsystem if it finds an error. <p> Each leader periodically checks the invariants of its link subsystem and corrects the subsystem if it finds an error. Because checking and correction proceed in parallel for each subsystem, this method yields fast stabilization times for several protocols <ref> [APV91, Var93] </ref>. <p> Self-Stabilization by Tree Correction x1.3 can be too slow, the local correctability requirement of <ref> [APV91, Var93] </ref> can be too restrictive. There are several protocols (including some described in this paper) that are not locally correctable using the definitions of [APV91, Var93]. The tree-correction technique described in this paper provides some middle ground. <p> Self-Stabilization by Tree Correction x1.3 can be too slow, the local correctability requirement of <ref> [APV91, Var93] </ref> can be too restrictive. There are several protocols (including some described in this paper) that are not locally correctable using the definitions of [APV91, Var93]. The tree-correction technique described in this paper provides some middle ground. We show how to efficiently stabilize protocols that are locally checkable and work over a tree topology. Thus we have removed the local correctability requirement, but added a requirement for tree topologies. <p> This would make our definition of stabilization meaningless. Note that we do not require that each of the local predicates L u;v be closed, a much stronger condition required in <ref> [APV91] </ref>. <p> The original paper on local checking and correction <ref> [APV91] </ref> proved a local 7-2 correction theorem: any locally checkable protocol that met certain other 26 Chicago Journal of Theoretical Computer Science 1997-3 Varghese et al. Self-Stabilization by Tree Correction x7 conditions (referred to as local correctability) can be stabilized. However, that theorem does not imply our tree-correction theorem. <p> Finally, the definition of local checkability used in <ref> [APV91] </ref> is stronger than ours. The previous definitions require that each local predicate be a closed predicate. This is a strong assumption that we do not require. Both local correction and tree correction are useful techniques that apply 7-3 to different problems. <p> This is a strong assumption that we do not require. Both local correction and tree correction are useful techniques that apply 7-3 to different problems. For example, local correction has been used to provide stabilizing solutions to many problems on general graphs (e.g., synchronizers [Var93] and end-to-end protocols <ref> [APV91] </ref>) for which tree correction is inapplicable. On the other hand, local correction does not seem applicable to the reset protocol described in Section 5. This is because the correction action (Figure 4) depends on the state of both the parent and the child. <p> Much of the initial work in self-stabilization was done in the context 8-2 of Dijkstra's shared-memory model of networks. Later, the work on local checking and correction was introduced <ref> [APV91] </ref> in a message-passing model. A contribution of this paper is to show that existing work in the shared-memory model can be understood crisply in terms of local checking and correction.
Reference: [CDK91] <author> Z. Collin, R. Dechter, and S. Katz. </author> <title> On the feasibility of distributed constraint satisfaction. </title> <booktitle> In Proceedings of the 12th IJCAI, </booktitle> <month> August </month> <year> 1991. </year>
Reference-contexts: A constraint can be considered to be a local predicate between two neighboring nodes, and the goal is to find a solution that meets all constraints. A seminal paper 6 by Collin, Dechter, and Katz <ref> [CDK91] </ref> considers the feasibility of self-stabilizing, distributed constraint satisfaction, and shows that the problem is impossible in general graphs without some form of symmetry breaking. However, the authors also show that the problem is solvable in tree networks. <p> Self-Stabilization by Tree Correction x8 actions continue to occur. To allow this, we added an extra modification beyond the normaliza-7-6 tion and local correction modifications needed by <ref> [CDK91] </ref>: we modified the original protocol actions to add an extra guard to check whether all local predicates are satisfied before the action is executed. <p> The proof of stability requires the notion of local extensibility (Lemma 2). None of these notions are required for the result in <ref> [CDK91] </ref>. Thus our theorem does not follow from the result in [CDK91]. How-7-7 ever, the result in [CDK91] applies to uniform tree networks|i.e., without symmetry breaking in the form of parent pointers, as we have used. <p> The proof of stability requires the notion of local extensibility (Lemma 2). None of these notions are required for the result in <ref> [CDK91] </ref>. Thus our theorem does not follow from the result in [CDK91]. How-7-7 ever, the result in [CDK91] applies to uniform tree networks|i.e., without symmetry breaking in the form of parent pointers, as we have used. This is done by a protocol that finds tree centers and directs each node's parent pointer toward its closest center [KPBG94]. <p> The proof of stability requires the notion of local extensibility (Lemma 2). None of these notions are required for the result in <ref> [CDK91] </ref>. Thus our theorem does not follow from the result in [CDK91]. How-7-7 ever, the result in [CDK91] applies to uniform tree networks|i.e., without symmetry breaking in the form of parent pointers, as we have used. This is done by a protocol that finds tree centers and directs each node's parent pointer toward its closest center [KPBG94]. <p> This is done by a protocol that finds tree centers and directs each node's parent pointer toward its closest center [KPBG94]. We conjecture that their method could be applied to make our theorem applicable to uniform tree networks. Also, <ref> [CDK91] </ref> has a number of other results on general networks, including a self-stabilizing procedure to find a feasible solution using distributed backtracking. Finally, [AGV94] also expresses local checkability conditions using con-7-8 straint graphs. The formulation in [AGV94] applies to more general protocols than the constraint satisfaction protocols of [CDK91]. <p> Also, <ref> [CDK91] </ref> has a number of other results on general networks, including a self-stabilizing procedure to find a feasible solution using distributed backtracking. Finally, [AGV94] also expresses local checkability conditions using con-7-8 straint graphs. The formulation in [AGV94] applies to more general protocols than the constraint satisfaction protocols of [CDK91]. However, none of the theorems in [AGV94] imply our tree-correction theorem. 8 Conclusions It may seem obvious that any locally checkable protocol on a tree can be 8-1 stabilized; however, it is a different matter to state and prove a precise result that embodies this intuition.
Reference: [Dij74] <author> Edsger W. Dijkstra. </author> <title> Self stabilization in spite of distributed control. </title> <journal> Communications of the ACM, </journal> <volume> 17 </volume> <pages> 643-644, </pages> <year> 1974. </year>
Reference-contexts: Thus stabilizing protocols are attractive because they offer increased robustness as well as potential simplicity. Self-stabilizing algorithms can be simpler, because they use uniform mechanisms to deal with many different kinds of failures. Self-stabilizing protocols were introduced by Dijkstra <ref> [Dij74] </ref>, and have 1-2 been studied by various researchers (see [Sch93] for a survey). There have been few general techniques for self-stabilization. This paper introduces one such general technique which we call tree correction. <p> For this reason, we defer these more technical comparisons to Section 7. The nuances in Section 7 can be better understood after the tree-correction technique is presented. 1.2 Dijkstra's Shared-Memory Model In this paper, we use Dijkstra's <ref> [Dij74] </ref> shared-memory model to model net-1.2-1 work protocols. In this model, a network protocol is modeled using a graph of finite-state machines. In a single move, a single node is allowed to read the state of its neighbors, compute, and then possibly change its state. <p> While Dijkstra's model is not very realistic, it captures the essential fea-1.2-2 tures of network protocols in a simple way. This allows us to state a very simple version of our main tree-correction theorem. Second, it allows us to apply our theorem to succinctly understand earlier protocols (e.g., <ref> [Dij74] </ref>, [AG90]) that were described using Dijkstra's model. <p> extended to work in message-passing models. 2 In summary, we use Dijkstra's model because it allows a simple expo-1.2-3 sition of tree correction; tree correction can be extended to more realistic message-passing models [Var93] with some additional complexity in the theorem statement and proof. 2 The first two protocols in <ref> [Dij74] </ref> are extended to message-passing models in [Var93]. 3 Chicago Journal of Theoretical Computer Science 1997-3 Varghese et al. <p> Actually the theorem only requires a property we call eventual correction: if a Correct u action is continuously enabled, then a Correct u action occurs within bounded time. This property can be established quite easily for the protocols in <ref> [Dij74] </ref> and [AG90], allowing all the actions in the entire automaton to be placed in a single class! 5 A Reset Protocol on a Tree Before describing the reset protocol due to Arora and Gouda [AG90], we 5-1 first describe the network reset problem. <p> The advantage of our presentation is that it provides a simple and transparent proof. We reconsider the second example in <ref> [Dij74] </ref>. This protocol is essentially a token-passing protocol on a line of nodes with process indices ranging from 0 to n 1. <p> Then we can use Theorem 1 to convert D2 into a new automaton D2 + , which stabilizes to executions where there is exactly one token in each state. The correction actions we add are once again different from the original actions in <ref> [Dij74] </ref>. However, the correction actions we add (and consequently, the proofs) are much more transparent than the original version. 7 Detailed Discussion of Related Work In this section, we discuss some subtle differences between the work in this 7-1 paper and closely related works.
Reference: [Fin79] <author> Steven G. Finn. </author> <title> Resynch procedures and a fail-safe network protocol. </title> <journal> IEEE Transactions on Communications, </journal> <volume> COM-27(6):840-845, </volume> <month> June </month> <year> 1979. </year>
Reference-contexts: A "legal" global state is allowed to be any global state that is reachable by the application protocol after correct initialization. The problem is called distributed reset, because reset requests may arrive at any node. A simple and elegant network-reset protocol is due to Finn <ref> [Fin79] </ref>. In this 5-2 protocol each node i running the application protocol has a session number. When the reset protocol is not running, the session numbers at every node are the same. <p> This check prevents older instances of the application protocol from "communicating" with newer instances of the protocol. This protocol is shown to be correct <ref> [Fin79] </ref> if all the session numbers are initially zero and the session numbers are allowed to grow without bound. 5 We rule out the use of unbounded session numbers as unrealistic. Also, in 5-3 a stabilizing setting, having a "large enough" size for a session number does not work.
Reference: [KP90] <author> Shmuel Katz and Kenneth Perry. </author> <title> Self-stabilizing extensions for message-passing systems. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Principles of Distributed Computing, ACM, </booktitle> <address> Quebec City, Canada, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Work on general techniques for self-stabilization began with a seminal paper by Katz and Perry <ref> [KP90] </ref> which showed how to compile an arbitrary asynchronous protocol into a stabilizing equivalent. In Katz and Perry's method, there is a leader that periodically checks the network. <p> One such direction [APV91, Var93] is to divide the network into a num-1.1-2 ber of overlapping link subsystems. A link subsystem consists of a pair of neighboring nodes and the channels, if any, between them. 1 The idea is to replace the global, centralized checking of <ref> [KP90] </ref> with local, decentralized checking. The intent, of course, is to allow each link subsystem to be checked in parallel. This results in faster stabilization. A network protocol is locally checkable if whenever the protocol is in a 1.1-3 bad state, some link subsystem is also in a bad state. <p> Because checking and correction proceed in parallel for each subsystem, this method yields fast stabilization times for several protocols [APV91, Var93]. While the centralized checking and correction of Katz and Perry <ref> [KP90] </ref> 1.1-5 1 In simple shared-memory models, such as the ones considered in this paper, we con sider a link subsystem just to be a pair of neighboring nodes. 2 Chicago Journal of Theoretical Computer Science 1997-3 Varghese et al.
Reference: [KPBG94] <author> M. Karaata, S. Pemmaraju, S. Bruell, and S. Ghosh. </author> <title> Self-stabilizing algorithms for finding centers and medians of trees. </title> <booktitle> In PODC 94, </booktitle> <month> August </month> <year> 1994. </year> <note> 31 Chicago Journal of Theoretical Computer Science 1997-3 Varghese et al. Self-Stabilization by Tree Correction (Ref) </note>
Reference-contexts: How-7-7 ever, the result in [CDK91] applies to uniform tree networks|i.e., without symmetry breaking in the form of parent pointers, as we have used. This is done by a protocol that finds tree centers and directs each node's parent pointer toward its closest center <ref> [KPBG94] </ref>. We conjecture that their method could be applied to make our theorem applicable to uniform tree networks. Also, [CDK91] has a number of other results on general networks, including a self-stabilizing procedure to find a feasible solution using distributed backtracking.
Reference: [MMT91] <author> M. Merritt, F. Modugno, and M. R. Tuttle. </author> <title> Time constrained automata. </title> <booktitle> In CONCUR 91, </booktitle> <pages> pages 408-423, </pages> <year> 1991. </year>
Reference-contexts: The appendix contains a formal summary of the timed I/O automaton model used in this paper. 2 Modeling Shared-Memory Protocols We will use a version of the timed I/O automaton model <ref> [MMT91] </ref>. The 2-1 appendix contains a formal summary of this model. It is essentially a state-machine model described using automata. The state transitions of the automata are called actions. <p> A Formal Summary of the I/O Automaton Model In this paper, we use the following model, which is a special case of the timed A-1 I/O automaton model in <ref> [MMT91] </ref>. However, our terminology is slightly different from that of [MMT91]. An I/O automaton A consists of five components: A-2 * A finite set of actions, actions (A), that is partitioned into three sets called the set of input, output, and internal actions. <p> A Formal Summary of the I/O Automaton Model In this paper, we use the following model, which is a special case of the timed A-1 I/O automaton model in <ref> [MMT91] </ref>. However, our terminology is slightly different from that of [MMT91]. An I/O automaton A consists of five components: A-2 * A finite set of actions, actions (A), that is partitioned into three sets called the set of input, output, and internal actions.
Reference: [Sch93] <author> M. Schneider. </author> <title> Self-stabilization. </title> <journal> ACM Computing Surveys, </journal> <volume> 25, </volume> <month> March </month> <year> 1993. </year>
Reference-contexts: Thus stabilizing protocols are attractive because they offer increased robustness as well as potential simplicity. Self-stabilizing algorithms can be simpler, because they use uniform mechanisms to deal with many different kinds of failures. Self-stabilizing protocols were introduced by Dijkstra [Dij74], and have 1-2 been studied by various researchers (see <ref> [Sch93] </ref> for a survey). There have been few general techniques for self-stabilization. This paper introduces one such general technique which we call tree correction. We will show that, fl A preliminary version of this paper appeared in [VAG95]. 1 Chicago Journal of Theoretical Computer Science 1997-3 Varghese et al.
Reference: [SH87] <author> Stuart R. Soloway and Pierre A. Humblet. </author> <title> On distributed network protocols for changing topologies. </title> <type> Technical Report LIDS-P-1564, </type> <month> May </month> <year> 1987. </year> <note> Also have version from May 1986. </note>
Reference-contexts: This is the first idea in Arora and Gouda's reset protocol [AG90]. 5 Finn also considered the problem of using bounded sequence numbers. His solution was shown to be incorrect by Humblett and Soloway, who proposed a fix in <ref> [SH87] </ref>. However, neither paper addresses the problem of designing a self-stabilizing reset protocol. 17 Chicago Journal of Theoretical Computer Science 1997-3 Varghese et al.
Reference: [VAG95] <author> George Varghese, Anish Arora, and Mohamed G. Gouda. </author> <title> Self-stabilization by tree correction. </title> <booktitle> In Proceedings of the 2nd Workshop on Self-Stabilizing Systems, </booktitle> <address> Las Vegas, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: There have been few general techniques for self-stabilization. This paper introduces one such general technique which we call tree correction. We will show that, fl A preliminary version of this paper appeared in <ref> [VAG95] </ref>. 1 Chicago Journal of Theoretical Computer Science 1997-3 Varghese et al.
Reference: [Var93] <author> George Varghese. </author> <title> Self-stabilization by local checking and correction. </title> <type> Phd thesis, also technical report mit/lcs/tr-583, </type> <institution> Massachus-setts Institute of Technology, </institution> <month> October </month> <year> 1993. </year> <note> 32 Chicago Journal of Theoretical Computer Science 1997-3 </note>
Reference-contexts: Intuitively, centralized checking and correction is slow, and has high message complexity. Thus the general transformation is expensive; hence more efficient (and possibly less general) techniques are worth investigating. One such direction <ref> [APV91, Var93] </ref> is to divide the network into a num-1.1-2 ber of overlapping link subsystems. A link subsystem consists of a pair of neighboring nodes and the channels, if any, between them. 1 The idea is to replace the global, centralized checking of [KP90] with local, decentralized checking. <p> Clearly, local correction is non trivial, because link subsystems overlap at nodes that have more than two neighbors. Techniques that transform any locally checkable and correctable protocol 1.1-4 into a stabilizing equivalent are given in <ref> [APV91, Var93] </ref>. The idea is simple: a leader is elected for each link subsystem. Each leader periodically checks the invariants of its link subsystem and corrects the subsystem if it finds an error. <p> Each leader periodically checks the invariants of its link subsystem and corrects the subsystem if it finds an error. Because checking and correction proceed in parallel for each subsystem, this method yields fast stabilization times for several protocols <ref> [APV91, Var93] </ref>. <p> Self-Stabilization by Tree Correction x1.3 can be too slow, the local correctability requirement of <ref> [APV91, Var93] </ref> can be too restrictive. There are several protocols (including some described in this paper) that are not locally correctable using the definitions of [APV91, Var93]. The tree-correction technique described in this paper provides some middle ground. <p> Self-Stabilization by Tree Correction x1.3 can be too slow, the local correctability requirement of <ref> [APV91, Var93] </ref> can be too restrictive. There are several protocols (including some described in this paper) that are not locally correctable using the definitions of [APV91, Var93]. The tree-correction technique described in this paper provides some middle ground. We show how to efficiently stabilize protocols that are locally checkable and work over a tree topology. Thus we have removed the local correctability requirement, but added a requirement for tree topologies. <p> Third, many protocols that work in Dijkstra's model have been easily extended to work in message-passing models. 2 In summary, we use Dijkstra's model because it allows a simple expo-1.2-3 sition of tree correction; tree correction can be extended to more realistic message-passing models <ref> [Var93] </ref> with some additional complexity in the theorem statement and proof. 2 The first two protocols in [Dij74] are extended to message-passing models in [Var93]. 3 Chicago Journal of Theoretical Computer Science 1997-3 Varghese et al. <p> In summary, we use Dijkstra's model because it allows a simple expo-1.2-3 sition of tree correction; tree correction can be extended to more realistic message-passing models <ref> [Var93] </ref> with some additional complexity in the theorem statement and proof. 2 The first two protocols in [Dij74] are extended to message-passing models in [Var93]. 3 Chicago Journal of Theoretical Computer Science 1997-3 Varghese et al. Self-Stabilization by Tree Correction x2 1.3 Paper Organization The main result of the paper is a theorem (Theorem 1) that states that any 1.3-1 locally checkable protocol on a rooted tree can be efficiently stabilized. <p> Proof of Lemma 2 2 The labeling procedure used in the lemma depends crucially on the fact 4.3-4 that the topology is a tree. To prove the main theorem, we use an execution convergence lemma first 4.3-5 stated and proved in <ref> [Var93] </ref>. To state the theorem, we need the following 12 Chicago Journal of Theoretical Computer Science 1997-3 Varghese et al. Self-Stabilization by Tree Correction x4.3 definition. <p> This is a strong assumption that we do not require. Both local correction and tree correction are useful techniques that apply 7-3 to different problems. For example, local correction has been used to provide stabilizing solutions to many problems on general graphs (e.g., synchronizers <ref> [Var93] </ref> and end-to-end protocols [APV91]) for which tree correction is inapplicable. On the other hand, local correction does not seem applicable to the reset protocol described in Section 5. This is because the correction action (Figure 4) depends on the state of both the parent and the child. <p> On the other hand, local correction does not seem applicable to the reset protocol described in Section 5. This is because the correction action (Figure 4) depends on the state of both the parent and the child. There are still other problems (e.g., mutual exclusion on a tree <ref> [Var93] </ref>) for which both techniques are applicable. There has also been significant work in the Artificial Intelligence literature 7-4 on distributed constraint satisfaction. A constraint can be considered to be a local predicate between two neighboring nodes, and the goal is to find a solution that meets all constraints. <p> The main theorem in this paper states that any locally checkable protocol that uses a tree topology can be efficiently stabilized. As the reader might expect, there is a corresponding tree correction theorem for message-passing systems. This theorem is described in <ref> [Var93] </ref>. The theorem requires a lot more notation to state. While the proof is similar, the reasoning is more tedious; thus, we believe that the theorem stated in this paper conveys the essential ideas in a much simpler fashion.
References-found: 13

