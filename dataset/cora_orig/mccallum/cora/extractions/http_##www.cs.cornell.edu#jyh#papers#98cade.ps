URL: http://www.cs.cornell.edu/jyh/papers/98cade.ps
Refering-URL: http://www.cs.cornell.edu/jyh/cornell-papers.html
Root-URL: 
Email: fkreitz,hayden,jyhg@cs.cornell.edu  
Title: A Proof Environment for the Development of Group Communication Systems  
Author: Christoph Kreitz Mark Hayden Jason Hickey 
Address: Ithaca, NY 14853-7501, U.S.A.  
Affiliation: Department of Computer Science, Cornell University  
Abstract: We present a theorem proving environment for the development of reliable and efficient group communication systems. Our approach makes methods of automated deduction applicable to the implementation of real-world systems by linking the Ensemble group communication toolkit to the NuPRL proof development system. We will present tools for importing Ensemble's code into NuPRL and exporting it back into the programming environment. We will discuss techniques for reasoning about critical properties of Ensemble as well as verified strategies for reconfiguring the Ensemble system in order to improve its performance in concrete applications.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Archer & C. Heitmeyer. </author> <title> Mechanical verification of timed automata: A case study. </title> <type> Technical report, </type> <institution> Naval Research Laboratory, </institution> <address> Washington, DC, </address> <year> 1997. </year>
Reference-contexts: Secondly, there is the secure implementation problem: designing and correctly implementing distributed systems is notoriously difficult [3, 5]. While in principle it is possible to reason formally about theoretical algorithms <ref> [16, 15, 17, 1, 18] </ref> these are often idealizations of the implementations actually used in real systems. Finally, the formalization barrier prevents tools for checking software correctness from being used to maximum benefit. <p> It is based on a formalization of a subset of the programming language Ocaml for which we have developed a type-theoretical semantics. Recent work on the specification and verification of timed automata <ref> [1] </ref>, fault-tolerant systems [18], and protocol stacks for group communication systems [8] has demonstrated that formal reasoning about complex distributed algorithms is feasible.
Reference: 2. <author> W. Bibel, D. Korn, C. Kreitz, F. Kurucz, J. Otten, S. Schmitt, G. Stolpmann. </author> <title> A multi-level approach to program synthesis. </title> <booktitle> In Seventh International Workshop on Logic Program Synthesis and Transformation, </booktitle> <publisher> LNAI, Springer Verlag, </publisher> <year> 1998 </year> <month> (to appear). </month>
Reference-contexts: Our approach, however, is the first to make the code of a real-worlds communication system available for formal reasoning and to combine both verification and optimization within one formal framework. 4 This methodology has already been used successfully for program synthesis <ref> [11, 2] </ref>. 14 While the import/export mechanisms have already been completed, the de-gree of automation of our tools for verifying and reconfiguring protocol stacks as well as their performance need still to be improved. <p> We will also integrate additional tools from the field of automated deduction, such as an extended typechecking algorithm, a proof procedure for first-order logic [13], and a proof planner for inductive proofs <ref> [2] </ref> into the logical programming environment. Finally, we intend to apply our reconfiguration and verification tools to a running application system in order to improve its efficiency while hardening security at the same time.
Reference: 3. <author> K. P. Birman. </author> <title> Building Secure and Reliable Network Applications. </title> <publisher> Manning Publishing Company and Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction Group communication via computer networks is used in a wide range of applications <ref> [3] </ref>. Over the past years the development of a secure and reliable computing and communications infrastructure has become increasingly important. Nevertheless, the current networks are inadequate to support safety-critical applications because considerable technical challenges have not been overcome yet. First, there is the performance cost of modularity. <p> But when modules are combined in a restricted context, much of the code becomes useless or redundant, leading to unnecessary large execution times. Secondly, there is the secure implementation problem: designing and correctly implementing distributed systems is notoriously difficult <ref> [3, 5] </ref>. While in principle it is possible to reason formally about theoretical algorithms [16, 15, 17, 1, 18] these are often idealizations of the implementations actually used in real systems. Finally, the formalization barrier prevents tools for checking software correctness from being used to maximum benefit.
Reference: 4. <author> K. P. Birman & R. van Renesse. </author> <title> Reliable Distributed Computing with the Isis Toolkit. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: The first system, Isis <ref> [4] </ref>, became one of the first widely adopted technologies in this area and found its way into Stock Exchanges, the French Air Traffic Control System, and many other critical applications.
Reference: 5. <author> T. D. Chandra, V. Hadzilacos, S. Toueg, B. Charron-Bost. </author> <title> On the impossibility of group membership. </title> <booktitle> In 15th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 322-330, </pages> <year> 1996. </year>
Reference-contexts: But when modules are combined in a restricted context, much of the code becomes useless or redundant, leading to unnecessary large execution times. Secondly, there is the secure implementation problem: designing and correctly implementing distributed systems is notoriously difficult <ref> [3, 5] </ref>. While in principle it is possible to reason formally about theoretical algorithms [16, 15, 17, 1, 18] these are often idealizations of the implementations actually used in real systems. Finally, the formalization barrier prevents tools for checking software correctness from being used to maximum benefit.
Reference: 6. <author> R. L. Constable, et. al., </author> <title> Implementing Mathematics with the NuPRL proof development system. </title> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: In this paper we address these problems by showing how to make methods of automated deduction applicable to the implementation of a real-world system. Our approach links Ensemble [10], a flexible group communication toolkit, to NuPRL <ref> [6] </ref>, a proof system for mathematical reasoning about programs and for rewriting them into equivalent, but more efficient ones. <p> Despite the use of ML, Ensemble turned out to be the fastest existing reliable multicast system, and also the most scalable and portable. 1 The NuPRL proof development system <ref> [6] </ref> is a framework for mathematical reasoning about programs and secure program transformations. Proof strategies, 1 The Ensemble distribution and related information can be found at Cornell's web site http://www.cs.cornell.edu/Info/Projects/Ensemble 2 Fig. 1.
Reference: 7. <author> D. de Rauglaudre. </author> <note> Camlp4 version 1.06. </note> <institution> Institut National de Recherche en Informatique et en Automatique, </institution> <year> 1997. </year>
Reference-contexts: The latter will create the appropriate terms and store all declared functions and types as abstractions in NuPRL's library. In order to ensure faithfulness wrt. the programming environment for executing Ensemble-code, we chose the Camlp4 parser-preprocessor <ref> [7] </ref>, a modifiable, isolated version of the original Ocaml-parser, as tool for analyzing the structure of program text. <p> This module had to generate pieces of text for each possible content of a syntax tree node, distinguishing the various kinds of identifiers, expressions, patterns, types, signature items, and module expressions according to <ref> [7, Appendix A] </ref>. Since a parser is restricted to a syntactical analysis of a single text file it cannot solve problems which arise when linking the code of several modules.
Reference: 8. <author> A. Fekete, N. Lynch, A. Shvartsman. </author> <title> Specifying and using a partitionable group communication service. </title> <booktitle> In 16th ACM Symp. on Principles of Distributed Computing, </booktitle> <year> 1997. </year>
Reference-contexts: It is based on a formalization of a subset of the programming language Ocaml for which we have developed a type-theoretical semantics. Recent work on the specification and verification of timed automata [1], fault-tolerant systems [18], and protocol stacks for group communication systems <ref> [8] </ref> has demonstrated that formal reasoning about complex distributed algorithms is feasible.
Reference: 9. <author> M. J. Gordon, R. Milner, C. P. Wadsworth. </author> <title> Edinburgh LCF: A mechanized Logic of Computation. </title> <publisher> LNCS 78, Springer Verlag, </publisher> <year> 1979. </year>
Reference-contexts: As a result it is now possible to formally reason on the level of Ocaml-programs (or higher) without having to understand the underlying type-theoretical peculiarities. 3.1 Embedding Objective Caml into Type Theory Ocaml [14], as a member of the ML <ref> [9] </ref> language family, is a strongly typed, (almost) functional language which has been extended by a module system. Although its core is similar to the language of type theory, it has a different syntax and contains many additional features which make it a real programming language.
Reference: 10. <author> M. Hayden. </author> <title> Ensemble Reference Manual. </title> <institution> Cornell University, </institution> <year> 1996. </year>
Reference-contexts: Only few of these tools are integrated into software development environments, nor can they be flexibly and interactively invoked. In this paper we address these problems by showing how to make methods of automated deduction applicable to the implementation of a real-world system. Our approach links Ensemble <ref> [10] </ref>, a flexible group communication toolkit, to NuPRL [6], a proof system for mathematical reasoning about programs and for rewriting them into equivalent, but more efficient ones. <p> However, reconfiguring Horus protocol stacks is difficult and error prone. Its layers were written in C and are too large and complex to reason about. Concerns about the security and reliability of such a technology base for secure net-worked applications led to the implementation of Ensemble <ref> [10] </ref>, which is based on Horus but coded almost entirely in the high-level programming language Ocaml [14].
Reference: 11. <author> C. </author> <title> Kreitz. Formal mathematics for verifiably correct program synthesis. </title> <journal> Journal of the IGPL, </journal> <volume> 4(1) </volume> <pages> 75-94, </pages> <year> 1996. </year>
Reference-contexts: Our approach, however, is the first to make the code of a real-worlds communication system available for formal reasoning and to combine both verification and optimization within one formal framework. 4 This methodology has already been used successfully for program synthesis <ref> [11, 2] </ref>. 14 While the import/export mechanisms have already been completed, the de-gree of automation of our tools for verifying and reconfiguring protocol stacks as well as their performance need still to be improved.
Reference: 12. <author> C. </author> <title> Kreitz. Formal reasoning about communication systems I: Embedding ML into type theory. </title> <type> Technical Report TR97-1637, </type> <institution> Cornell University, </institution> <year> 1997. </year>
Reference-contexts: In the following we shall briefly discuss these features and how they were formally represented. A full account of the embedding can be found in <ref> [12] </ref>. Predefined Data Types and Operations. In Ocaml many standard data types such as arrays, records, queues, etc. and the corresponding operations on their elements are predefined while type theory only contains the most fundamental constructs. <p> Name resolution (dealing with modules), determining the role of identifiers (variable or reference to user-defined object), and overloading (detecting the intended operator via type inference) therefore had addressed by the object generators on the meta-level of NuPRL (see <ref> [12, section 5] </ref> for details). Translating formal representations of protocol layers back into Ocaml source code is easy, because their display is already genuine Ocaml code. <p> So far we have developed a formal programming logic for Ocaml and implemented its rules as NuPRL tactics <ref> [12, section 4] </ref>. These rules raise the level of interactive formal reasoning from NuPRL's logical calculus to a level which is comprehensible for programmers and provide the foundation for the implementation of verification strategies and heuristics. <p> These strategies are based on program transformation rules and conditional rewriting. To support the former, we have implemented a tactic Red for symbolically evaluating Ocaml programs, which is based on derived reduction rules for each language construct (see <ref> [12, section 4] </ref>), while conditional rewrite rules are implemented using NuPRL's substitution rules and lemma application. These tactics are very helpful for reconfiguring individual protocol layers.
Reference: 13. <editor> C. Kreitz, J. Otten, S. Schmitt. </editor> <title> Guiding Program Development Systems by a Connection Based Proof Strategy. </title> <booktitle> In 5th International Workshop on Logic Program Synthesis and Transformation, </booktitle> <volume> LNCS 1048, </volume> <pages> pp. 137-151. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: We will aim at a modularization of the formal database, in order to speed up the search for applicable lemmas. We will also integrate additional tools from the field of automated deduction, such as an extended typechecking algorithm, a proof procedure for first-order logic <ref> [13] </ref>, and a proof planner for inductive proofs [2] into the logical programming environment. Finally, we intend to apply our reconfiguration and verification tools to a running application system in order to improve its efficiency while hardening security at the same time.
Reference: 14. <author> X. Leroy. </author> <title> The Objective Caml system release 1.06. </title> <institution> Institut National de Recherche en Infor-matique et en Automatique, </institution> <year> 1997. </year>
Reference-contexts: Our approach links Ensemble [10], a flexible group communication toolkit, to NuPRL [6], a proof system for mathematical reasoning about programs and for rewriting them into equivalent, but more efficient ones. Because of the similarity between the core of Ocaml <ref> [14] </ref>, the implementation language of Ensemble, and Type Theory, the logical language of NuPRL, we were able to translate the complete implementation of Ensemble into NuPRL-terms and to apply proof tactics and verified program transformations to the actual Ensemble code. <p> Concerns about the security and reliability of such a technology base for secure net-worked applications led to the implementation of Ensemble [10], which is based on Horus but coded almost entirely in the high-level programming language Ocaml <ref> [14] </ref>. One of the main reasons to choose Ocaml, a member of the ML language family with a clean semantics, was to enable formal reasoning about Ensemble's code within a theorem proving environment and to use automated deduction techniques for hardening critical system properties and for system reconfiguration. <p> As a result it is now possible to formally reason on the level of Ocaml-programs (or higher) without having to understand the underlying type-theoretical peculiarities. 3.1 Embedding Objective Caml into Type Theory Ocaml <ref> [14] </ref>, as a member of the ML [9] language family, is a strongly typed, (almost) functional language which has been extended by a module system.
Reference: 15. <author> P. Lincoln & J. Rushby. </author> <title> A formally verified algorithm for interactive consistency under a hybrid fault model. </title> <booktitle> In 23rd Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 402-411, </pages> <year> 1993. </year>
Reference-contexts: Secondly, there is the secure implementation problem: designing and correctly implementing distributed systems is notoriously difficult [3, 5]. While in principle it is possible to reason formally about theoretical algorithms <ref> [16, 15, 17, 1, 18] </ref> these are often idealizations of the implementations actually used in real systems. Finally, the formalization barrier prevents tools for checking software correctness from being used to maximum benefit.
Reference: 16. <author> J. Rushby. </author> <title> Formal methods for dependable real-time systems. </title> <booktitle> In International Symposium on Real-Time Embedded Processing for Space Applications, </booktitle> <pages> pp. 355-366, </pages> <year> 1992. </year>
Reference-contexts: Secondly, there is the secure implementation problem: designing and correctly implementing distributed systems is notoriously difficult [3, 5]. While in principle it is possible to reason formally about theoretical algorithms <ref> [16, 15, 17, 1, 18] </ref> these are often idealizations of the implementations actually used in real systems. Finally, the formalization barrier prevents tools for checking software correctness from being used to maximum benefit.
Reference: 17. <author> J. Rushby. </author> <title> A formally verified algorithm for clock synchronization under a hybrid fault model. </title> <booktitle> In 13th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 304-313, </pages> <year> 1994. </year>
Reference-contexts: Secondly, there is the secure implementation problem: designing and correctly implementing distributed systems is notoriously difficult [3, 5]. While in principle it is possible to reason formally about theoretical algorithms <ref> [16, 15, 17, 1, 18] </ref> these are often idealizations of the implementations actually used in real systems. Finally, the formalization barrier prevents tools for checking software correctness from being used to maximum benefit.
Reference: 18. <author> J. Rushby. </author> <title> Systematic formal verification for fault-tolerant time-triggered algorithms. In Dependable Computing for Critical Applications: </title> <booktitle> 6, </booktitle> <pages> pp. 191-210. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1997. </year>
Reference-contexts: Secondly, there is the secure implementation problem: designing and correctly implementing distributed systems is notoriously difficult [3, 5]. While in principle it is possible to reason formally about theoretical algorithms <ref> [16, 15, 17, 1, 18] </ref> these are often idealizations of the implementations actually used in real systems. Finally, the formalization barrier prevents tools for checking software correctness from being used to maximum benefit. <p> It is based on a formalization of a subset of the programming language Ocaml for which we have developed a type-theoretical semantics. Recent work on the specification and verification of timed automata [1], fault-tolerant systems <ref> [18] </ref>, and protocol stacks for group communication systems [8] has demonstrated that formal reasoning about complex distributed algorithms is feasible.
Reference: 19. <author> R. van Renesse, K. Birman, & S. Maffeis. Horus: </author> <title> A flexible group communication system. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 76-83, </pages> <year> 1996. </year> <title> 15 This article was processed using the L A T E X macro package with LLNCS style 16 </title>
Reference-contexts: The first system, Isis [4], became one of the first widely adopted technologies in this area and found its way into Stock Exchanges, the French Air Traffic Control System, and many other critical applications. The Horus system <ref> [19] </ref>, a modular redesign of Isis, is based on stacking protocol layers which are linked by simple input/output channels and can be combined almost arbitrarily. The system can be reconfigured to continuously match the properties of its protocols to the specific needs of the application.
References-found: 19

