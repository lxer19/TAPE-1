URL: http://www.cs.colostate.edu/~ftppub/TechReports/1995/tr95-106.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Title: Self-Stabilizing Distributed Algorithm to Construct An Arbitrary Spanning Tree of a Connected Graph  
Author: Gheorghe Antonoiu and Pradip K Srimani Pradip K Srimani, 
Address: Ft. Collins, CO 80523  Fort Collins, CO 80523-1873  Ft. Collins, CO 80523,  
Affiliation: Department of Computer Science Colorado State University  Computer Science Department Colorado State University  Department of Computer Science, Colorado State University,  
Note: A  Address for Correspondence:  
Pubnum: Technical Report CS-95-106  
Email: Email: srimani@CS.ColoState.Edu  
Phone: Phone: (970) 491-5792 Fax: (970) 491-2466  Tel: (303) 491 7097, Fax: (303) 491-2466,  
Web: WWW: http://www.cs.colostate.edu  
Abstract: Computer Science Technical Report 
Abstract-found: 1
Intro-found: 1
Reference: [ADG92] <author> A. Arora, S. Dolev, and M. Gouda. </author> <title> Maintaining digital clocks in step. </title> <journal> Parallel Processing Letters, </journal> <volume> 1(1) </volume> <pages> 11-18, </pages> <year> 1992. </year>
Reference-contexts: This kind of property is highly desirable for any distributed system, since without having a global memory global synchronization is achieved in finite time and thus the system can correct itself automatically from spurious perturbation or failures. Few such algorithms have recently appeared in the literature <ref> [GH90, SS92, BGW89, FD92, ADG92] </ref>; a good survey of self-stabilizing algorithms can be found in [Sch93]. Every node in a self-stabilizing system has a set of rules, each rule having two parts an antecedent (boolean condition) part and an action part.
Reference: [BGW89] <author> G. M. Brown, M. G. Gouda, and C. L. Wu. </author> <title> Token systems that self-stabilize. </title> <journal> IEEE Trans. Comput., </journal> <volume> 38(6) </volume> <pages> 845-852, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: This kind of property is highly desirable for any distributed system, since without having a global memory global synchronization is achieved in finite time and thus the system can correct itself automatically from spurious perturbation or failures. Few such algorithms have recently appeared in the literature <ref> [GH90, SS92, BGW89, FD92, ADG92] </ref>; a good survey of self-stabilizing algorithms can be found in [Sch93]. Every node in a self-stabilizing system has a set of rules, each rule having two parts an antecedent (boolean condition) part and an action part.
Reference: [Dij74] <author> E. W. Dijkstra. </author> <title> Self-stabilizing systems in spite of distributed control. </title> <journal> Communications of the ACM, </journal> <volume> 17(11) </volume> <pages> 643-644, </pages> <month> November </month> <year> 1974. </year>
Reference-contexts: Systems that reach the legitimate state starting from any illegitimate state in a finite number of steps are called self-stabilizing systems <ref> [Dij74, Dij86] </ref>. This kind of property is highly desirable for any distributed system, since without having a global memory global synchronization is achieved in finite time and thus the system can correct itself automatically from spurious perturbation or failures. <p> Another interesting feature of our algorithm is that we allow multiple privileged nodes to be concurrently active. Most self-stabilizing algorithms assume that there is a central daemon <ref> [Dij74] </ref> that decides which of the privileged nodes makes a move. In other words, the central daemon serializes the moves made by the privileged nodes, but the order in which the privileged nodes are chosen to make their moves is not known a priori.
Reference: [Dij86] <author> E. W. Dijkstra. </author> <title> A belated proof of self-stabilization. </title> <journal> J. of Distributed Computing, </journal> <volume> 1(1) </volume> <pages> 5-6, </pages> <year> 1986. </year>
Reference-contexts: Systems that reach the legitimate state starting from any illegitimate state in a finite number of steps are called self-stabilizing systems <ref> [Dij74, Dij86] </ref>. This kind of property is highly desirable for any distributed system, since without having a global memory global synchronization is achieved in finite time and thus the system can correct itself automatically from spurious perturbation or failures. <p> possible sequence of moves that will bring the state back to a stable state starting from the same initial illegitimate state. 3 Correctness Proof In order to prove that the correctness of a self-stabilizing algorithm, we need to show that it meets the following three requirements of a self-stabilizing algorithm <ref> [Dij86] </ref>: (a) In any illegitimate state there is at least one privileged node; (b) In a legitimate state no node is privileged; and (c) For all possible initial states and for all possible ways a privileged node is selected to take action during execution of the algorithm, the system is guaranteed
Reference: [FD92] <author> M. Flatebo and A. K. Datta. </author> <title> Two-State self-Stabilizing algorithms. </title> <booktitle> In Proceedings of the IPPS-92, </booktitle> <address> California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: This kind of property is highly desirable for any distributed system, since without having a global memory global synchronization is achieved in finite time and thus the system can correct itself automatically from spurious perturbation or failures. Few such algorithms have recently appeared in the literature <ref> [GH90, SS92, BGW89, FD92, ADG92] </ref>; a good survey of self-stabilizing algorithms can be found in [Sch93]. Every node in a self-stabilizing system has a set of rules, each rule having two parts an antecedent (boolean condition) part and an action part.
Reference: [GH90] <author> M. Gouda and T. Herman. </author> <title> Stabilizing unison. </title> <journal> Inf. Processing Letters, </journal> <volume> 35(4) </volume> <pages> 171-175, </pages> <year> 1990. </year>
Reference-contexts: This kind of property is highly desirable for any distributed system, since without having a global memory global synchronization is achieved in finite time and thus the system can correct itself automatically from spurious perturbation or failures. Few such algorithms have recently appeared in the literature <ref> [GH90, SS92, BGW89, FD92, ADG92] </ref>; a good survey of self-stabilizing algorithms can be found in [Sch93]. Every node in a self-stabilizing system has a set of rules, each rule having two parts an antecedent (boolean condition) part and an action part.
Reference: [HC92] <author> S.T. Huang and N.-S. Chen. </author> <title> A self-stabilizing algorithm for constructing breadth first trees. </title> <journal> Inf. Processing Letters, </journal> <volume> 41 </volume> <pages> 109-117, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Collins, CO 80523, Tel: (303) 491-7097, Fax: (303) 491-2466, Email: srimani@CS.ColoState.Edu 1 It is to be noted that there exist self-stabilizing algorithms for the spanning tree problem <ref> [HC92, SS92] </ref>; but both of these algorithms always construct a breadth-first spanning tree; they cannot recognize an arbitrary spanning tree. Also, the proof technique used in [HC92] is complicated using bounded monotonically decreasing functions defined on global system states. <p> Also, the proof technique used in <ref> [HC92] </ref> is complicated using bounded monotonically decreasing functions defined on global system states. Most existing self-stabilizing algorithms are proved to be correct by defining a bounded function that is shown to decrease monotonically at every step [Kes88]. <p> Our algorithm does not assume any order or any specific rule in which the set of active nodes is chosen at any point of time. This is also true for the algorithm in <ref> [HC92] </ref>. But unlike [HC92], we do not need any extra complication in the proof; our proof technique inherently accommodates concurrent actions by nodes. 2 The Algorithm Let G be the given connected graph (V; E) where a specific node r is designated to be the root node. <p> Our algorithm does not assume any order or any specific rule in which the set of active nodes is chosen at any point of time. This is also true for the algorithm in <ref> [HC92] </ref>. But unlike [HC92], we do not need any extra complication in the proof; our proof technique inherently accommodates concurrent actions by nodes. 2 The Algorithm Let G be the given connected graph (V; E) where a specific node r is designated to be the root node.
Reference: [Kes88] <author> J. L. W. Kessels. </author> <title> An exercise in proving self-stabilization with a variant function. </title> <journal> Inf. Processing Letters, </journal> <volume> 29(2) </volume> <pages> 39-42, </pages> <year> 1988. </year>
Reference-contexts: Also, the proof technique used in [HC92] is complicated using bounded monotonically decreasing functions defined on global system states. Most existing self-stabilizing algorithms are proved to be correct by defining a bounded function that is shown to decrease monotonically at every step <ref> [Kes88] </ref>. The proposed algorithm can recognize any arbitrary spanning tree and our proof technique is completely new and does not need any such bounded function (we have also not used any operational arguments). Another interesting feature of our algorithm is that we allow multiple privileged nodes to be concurrently active.
Reference: [Sch93] <author> M. Schneider. </author> <title> Self-stabilization. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(1) </volume> <pages> 45-67, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Few such algorithms have recently appeared in the literature [GH90, SS92, BGW89, FD92, ADG92]; a good survey of self-stabilizing algorithms can be found in <ref> [Sch93] </ref>. Every node in a self-stabilizing system has a set of rules, each rule having two parts an antecedent (boolean condition) part and an action part. A node is said to be privileged if the antecedent part of some rule is true for that node.
Reference: [SS92] <author> S. Sur and P. K. Srimani. </author> <title> A self-stabilizing distributed algorithm to construct BFS spanning tress of a symmetric graph. Parallel Processing Letters, </title> <address> 2(2,3):171-180, </address> <month> September </month> <year> 1992. </year> <month> 6 </month>
Reference-contexts: This kind of property is highly desirable for any distributed system, since without having a global memory global synchronization is achieved in finite time and thus the system can correct itself automatically from spurious perturbation or failures. Few such algorithms have recently appeared in the literature <ref> [GH90, SS92, BGW89, FD92, ADG92] </ref>; a good survey of self-stabilizing algorithms can be found in [Sch93]. Every node in a self-stabilizing system has a set of rules, each rule having two parts an antecedent (boolean condition) part and an action part. <p> Collins, CO 80523, Tel: (303) 491-7097, Fax: (303) 491-2466, Email: srimani@CS.ColoState.Edu 1 It is to be noted that there exist self-stabilizing algorithms for the spanning tree problem <ref> [HC92, SS92] </ref>; but both of these algorithms always construct a breadth-first spanning tree; they cannot recognize an arbitrary spanning tree. Also, the proof technique used in [HC92] is complicated using bounded monotonically decreasing functions defined on global system states.
References-found: 10

