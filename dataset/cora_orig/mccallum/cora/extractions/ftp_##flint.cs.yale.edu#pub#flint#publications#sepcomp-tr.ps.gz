URL: ftp://flint.cs.yale.edu/pub/flint/publications/sepcomp-tr.ps.gz
Refering-URL: http://daffy.cs.yale.edu/users/shao-zhong/papers.html
Root-URL: http://www.cs.yale.edu
Email: zsh@princeton.edu appel@princeton.edu  
Title: Smartest Recompilation  
Author: Zhong Shao Andrew W. Appel 
Date: October 1992  
Affiliation: Princeton University  
Pubnum: CS-TR-395-92  
Abstract: To separately compile a program module in traditional statically-typed languages, one has to manually write down an import interface which explicitly specifies all the external symbols referenced in the module. Whenever the definitions of these external symbols are changed, the module has to be recompiled. In this paper, we present an algorithm which can automatically infer the "minimum" import interface for any module in languages based on the Damas-Milner type discipline (e.g., ML). By "minimum", we mean that the interface specifies a set of assumptions (for external symbols) that are just enough to make the module type-check and compile. By compiling each module using its "minimum" import interface, we get a separate compilation method that can achieve the following optimal property: A compilation unit never needs to be recompiled unless its own implementation changes. fl A short version of this paper will appear in the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, January, 1993. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Shail Aditya and Rishiyur S. Nikhil. </author> <title> Incremental polymorphism. </title> <booktitle> In The Fifth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 378-405, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: Gansner is also planning to export the static semantics of each module into the binary file so that redundant recompilations can be detected and avoided if the static semantics of a module has not been changed. 17 Aditya and Nikhil <ref> [1] </ref> have been working on similar kinds of assumption inference algorithms for their incremental compiler for Id [23]. However as far as we know, their algorithm does not infer the minimum constraints, thus fails to achieve our theorem 2.1.
Reference: [2] <author> William E. Aitken and John H. Reppy. </author> <title> Abstract value constructors. </title> <booktitle> In ACM SIGPLAN Workshop on ML and its Applications, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: However this imposes some problems if we want to separately compile structure B. What representations are we going to use for A.RED and A.MIX in the redp function? Again this is solved by making the representation of data constructors abstract (as in Aitken and Reppy's recent work <ref> [2] </ref>). A "constant" data constructor (such as A.RED) is compiled as a variable. A value carrying constructor (such as A.MIX) is compiled as a pair of injection and projection functions. These details are filled in at link time when the definition of the datatype is known.
Reference: [3] <author> Maria Virginia Aponte. </author> <title> Typage d'un systeme de modules parametriques avec partage: une application de l'unification dans les theories equationnelles. </title> <type> PhD thesis, </type> <institution> Universite de Paris, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: The algorithm V in Leivant [16] is just Damas's T restricted to the type system without ML-polymorphism. Its extension V 2 is for the polymorphic discipline of rank 2 and the relation between W and V 2 is not clear. On the side of the SML module language, Aponte <ref> [3] </ref> presented a type checking algorithm for ModL based on Remy's approach to record typing [25]. Her approach is very elegant; however, in practice it is probably very difficult to implement efficiently.
Reference: [4] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In Martin Wirsing, editor, </editor> <booktitle> Third Int'l Symp. on Prog. Lang. Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: To achieve the "smartest recompilation rule", the back end of the compiler must use only the type information specified in the module's inferred import interface. This limitation is not a big problem. The back end of the current SML/NJ compiler <ref> [4] </ref> uses almost no type information from the front end but it still produces quite efficient code. Many optimization techniques that do use the type information, such as Leroy's representation analysis [17], can still be partially incorporated into our separate compilation system. <p> Fortunately there are very few dependencies between the static semantics and the dynamic semantics in SML. Moreover, although Leroy's representation analysis [17] shows that the compiler can benefit a lot by using type information in the front end, the SML/NJ compiler <ref> [4] </ref> uses almost no type information in its back end but it still produces quite efficient code. In SML/NJ, the only things that the back end needs to know from the front end are the corresponding dynamic interface for each signature and the identifier status for each identifier. <p> The independent compilation of each module may disable some inter-module optimizations, but we believe that the code generated by our recompilation method will be comparable to the quite efficient code generated by the current SML/NJ compiler <ref> [4] </ref>. We plan to implement and measure our algorithm in SML/NJ in the future. The smartest recompilation technique in this paper is presented in the framework of SML; however, it can be easily applied to other polymorphic languages based on the Damas-Milner type discipline.
Reference: [5] <author> Hans Boehm and Alan J. Demers. </author> <title> Implementing Russell. </title> <booktitle> In Symposium on Compiler Construction, </booktitle> <pages> pages 186-195. </pages> <booktitle> ACM Sigplan, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: Languages with very powerful module systems such as Mesa [21], the System Modeller in Cedar [15], and FX-87 [8] also adopt similar separate compilation methods which are only applicable to closed modules. The compiler for Russell <ref> [5] </ref> does partially support separate compilations on "open-formed" expressions, however its "module system" is very restrictive and all "modules" must be loaded and compiled in an order determined by their dependencies.
Reference: [6] <author> Luis Damas. </author> <title> Type Assignment in Programming Languages. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, Department of Computer Science, Edinburgh, UK, </institution> <year> 1985. </year>
Reference-contexts: It is just proving that the result of W fl and Match is equivalent to the result of W . Proving this kind of equivalence is 6 relatively easier. From the soundness and completeness of the algorithm W (which is proved in Damas's Ph.D thesis <ref> [6] </ref>), and the above theorem 2.1, we can easily get the following soundness and completeness results for our algorithm W fl . <p> Because their system allows mutually recursive top-level declarations, it cannot fully recover the correct type information by simply using our assumption inference and matching algorithm. In the SML module language, however, top-level declarations cannot be mutually recursive. Damas <ref> [6] </ref> gave an inference algorithm called T which is very similar to our W fl in section 2. His type system permits that a variable can be bound to several distinct types in the type environment (just like our assumption environment).
Reference: [7] <author> Luis Damas and Robin Milner. </author> <title> Principal type-schemes for functional programs. </title> <booktitle> In Ninth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <address> New York, Jan 1982. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Programmers can write their programs all in the form of closed functors such as FOO'. On the other hand, in practice, we find it extremely convenient and flexible to write parts of our programs as open-formed modules. For languages based on the Damas-Milner type discipline <ref> [7] </ref> such as SML and Haskell [11], there is another reason in favor of writing certain modules in opened forms. One of the most important features of the Damas-Milner type discipline is that the most general type for arbitrary expressions can be automatically inferred by compilers.
Reference: [8] <author> David K. Gifford et al. </author> <title> FX-87 reference manual. </title> <type> Technical Report MIT/LCS/TR-407, </type> <institution> M.I.T. Laboratory for Computer Science, </institution> <month> September </month> <year> 1987. </year>
Reference-contexts: Languages with very powerful module systems such as Mesa [21], the System Modeller in Cedar [15], and FX-87 <ref> [8] </ref> also adopt similar separate compilation methods which are only applicable to closed modules. The compiler for Russell [5] does partially support separate compilations on "open-formed" expressions, however its "module system" is very restrictive and all "modules" must be loaded and compiled in an order determined by their dependencies.
Reference: [9] <author> Stuart I. Feldman. </author> <title> Make a program for maintaining computer programs. </title> <journal> Software Practice and Experience, </journal> <volume> 9(4) </volume> <pages> 255-265, </pages> <month> Apirl </month> <year> 1979. </year>
Reference-contexts: This also means that programmers need no longer maintain dependency files (e.g., Makefile <ref> [9] </ref>). * Open-formed modules can also be separately compiled. * Cross-module type errors are now symmetric. In traditional methods, if module A references identifiers defined in module B, type inconsistencies between module A and module B will show up when A is compiled. <p> Each compilation unit contains an implementation plus several interface files. It has to be fully closed up to the pervasive basis so that the specifications of all external symbols will be found at compile time. The make system <ref> [9] </ref> is the simplest one along this line. It will trigger recompilations if the interface file a module depends on changes. Tichy [30] and Schwanke [29] eliminated most recompilations by examining finer-levels of dependency relations between interfaces and implementations.
Reference: [10] <author> Emden R. </author> <type> Gansner. </type> <institution> AT&T Bell Labs, </institution> <type> personal communication, </type> <year> 1992. </year>
Reference-contexts: In SML, two kinds of separate compilation methods have been proposed: Rothwell and Tofte's import scheme [28] and Rollins's SourceGroup scheme [27]; both methods apply only to closed functors. Recently, Emden Gansner <ref> [10] </ref> is implementing a make-like separate compilation system for open-formed modules in the interactive SML/NJ compiler. In his method, all modules are loaded and compiled in a top level environment in an order determined by their dependencies.
Reference: [11] <editor> Paul Hudak, Simon Peyton Jones, and Philip Wadler et al. </editor> <title> Report on the programming language Haskell a non-strict, purely functional language version 1.2. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: On the other hand, in practice, we find it extremely convenient and flexible to write parts of our programs as open-formed modules. For languages based on the Damas-Milner type discipline [7] such as SML and Haskell <ref> [11] </ref>, there is another reason in favor of writing certain modules in opened forms. One of the most important features of the Damas-Milner type discipline is that the most general type for arbitrary expressions can be automatically inferred by compilers. <p> In SML/NJ (as in all ML compilers to our knowledge), the polymorphic equality function is implemented as a runtime "equality interpreter" which checks equality of two objects based on their runtime tags. Another way to implement polymorphic equality, which is used in Haskell <ref> [11] </ref>, is to pass an equality function for each formal parameter that is a polymorphic equality type variable. The code produced by this scheme closely depends on the derivation tree of the elaboration phase.
Reference: [12] <author> Mark P. Jones. </author> <title> A theory of qualified types. </title> <booktitle> In The 4th European Symposium on Programming, </booktitle> <pages> pages 287-306, </pages> <address> Berlin, </address> <month> February </month> <year> 1992. </year> <pages> Spinger-Verlag. </pages>
Reference-contexts: It turns out that this problem can be elegantly solved by extending ML types with type predicates and assumptions. This extension, which is called "constrained type" in Kaes [13] and "qualified type" in Jones <ref> [12] </ref>, is normally used to reason about the ML type system in the presence of overloading and subtyping. The algorithm D presented in this section is the type reconstruction algorithm for Kaes's constrained type system. <p> type predicates, the algorithm D can efficiently solve the assumption inference problem even when there is a pervasive basis. 2.2.1 An extension of ML with constrained types The extension of ML type system with constrained types (denoted as ML + ) is discussed in detail by Kaes [13] and Jones <ref> [12] </ref> to solve the type inference problem in languages that support overloading and subtyping. It turns out that it can also be used to solve our assumption inference problem. The language syntax they use is essentially same as the mini-ML language Exp.
Reference: [13] <author> Stefan Kaes. </author> <title> Type inference in the presence of overloading, subtyping and recursive types. </title> <booktitle> In 1992 ACM Conference on Lisp and Fucntional Programming, </booktitle> <address> New York, June 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: It turns out that this problem can be elegantly solved by extending ML types with type predicates and assumptions. This extension, which is called "constrained type" in Kaes <ref> [13] </ref> and "qualified type" in Jones [12], is normally used to reason about the ML type system in the presence of overloading and subtyping. The algorithm D presented in this section is the type reconstruction algorithm for Kaes's constrained type system. <p> special set of type predicates, the algorithm D can efficiently solve the assumption inference problem even when there is a pervasive basis. 2.2.1 An extension of ML with constrained types The extension of ML type system with constrained types (denoted as ML + ) is discussed in detail by Kaes <ref> [13] </ref> and Jones [12] to solve the type inference problem in languages that support overloading and subtyping. It turns out that it can also be used to solve our assumption inference problem. The language syntax they use is essentially same as the mini-ML language Exp. <p> Kaes <ref> [13] </ref> presented the type deduction rules (also listed in the appendix at the end of this paper for reference) and the type inference algorithm D (as in figure 2) for the above extension. <p> N (S; N 0 (S 0 )) 2 FunSig = NameSet fi (Str fi Sig) strdec ::= structure strid = strexp B 2 Basis = Nameset fi SigEnv fi FunEnv fi Env work on various extensions of the ML type system with overloading and subtyping such as those in Kaes <ref> [13] </ref>. 3 Assumption Inference in the SML Module Language In this section, we present an assumption inference algorithm for the SML module language. To simplify the presentation, we only consider the skeletal language ModL (as in Tofte [31]) in figure 3. <p> It should be straightforward to extend the algorithm D in section 2.2 to work on the extension of ML type system with parametric overloadings <ref> [13] </ref>. The assumption inference algorithms presented in section 2 and 3 can also be used as a basis to build incremental compilers for similar languages.
Reference: [14] <author> Bill Kalsow and Eric Muller. </author> <note> SRC Modula-3 version 1.6 manual, </note> <month> February </month> <year> 1991. </year>
Reference-contexts: In their methods, if the interface file a module depends on changes, but the set of symbols the module imports does not change, then the module does not need to be recompiled. SRC Modula-3 <ref> [22, 14] </ref> implements exactly the same idea: a version stamp which encodes the specification of a symbol is produced for each exported symbol in an interface; modules import the version stamps of the symbols that they import; a module only needs to be recompiled if any of its imported version stamps
Reference: [15] <author> Butler W. Lampson and Eric S. Schmidt. </author> <title> Pratical use of a polymorphic applicative language. </title> <booktitle> In Tenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <address> New York, Jan 1983. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Languages with very powerful module systems such as Mesa [21], the System Modeller in Cedar <ref> [15] </ref>, and FX-87 [8] also adopt similar separate compilation methods which are only applicable to closed modules.
Reference: [16] <author> Daniel Leivant. </author> <title> Polymorphic type inference. </title> <booktitle> In Tenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <address> New York, Jan 1983. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The soundness and syntactic completeness results he proved for T are only for his particular type system, not for the usual ML type system [31], so they are not in the same sense as our corollary 2.2 and 2.3. The algorithm V in Leivant <ref> [16] </ref> is just Damas's T restricted to the type system without ML-polymorphism. Its extension V 2 is for the polymorphic discipline of rank 2 and the relation between W and V 2 is not clear.
Reference: [17] <author> Xavier Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <address> New York, Jan 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: This limitation is not a big problem. The back end of the current SML/NJ compiler [4] uses almost no type information from the front end but it still produces quite efficient code. Many optimization techniques that do use the type information, such as Leroy's representation analysis <ref> [17] </ref>, can still be partially incorporated into our separate compilation system. The details will be described in section 4 and 5 of this paper. <p> This requires that our code generator should use no more type information than is specified in the "minimum" import interface. Fortunately there are very few dependencies between the static semantics and the dynamic semantics in SML. Moreover, although Leroy's representation analysis <ref> [17] </ref> shows that the compiler can benefit a lot by using type information in the front end, the SML/NJ compiler [4] uses almost no type information in its back end but it still produces quite efficient code. <p> This will have some runtime overhead in the common case that S.g actually never does equality test on its 2nd argument. Representation analysis Leroy <ref> [17] </ref> presented a program transformation that allows polymorphic languages to be implemented with unboxed, multi-word data representation. The main idea is to introduce coercions between various representations based on the typing derivation tree.
Reference: [18] <author> Michael R. Levy. </author> <title> Type checking, separate compilation and reusability. </title> <booktitle> SIGPLAN Notices (Proc. Sigplan '84 Symp. on Compiler Construction), </booktitle> <volume> 19(6) </volume> <pages> 285-289, </pages> <month> June </month> <year> 1984. </year> <month> 19 </month>
Reference-contexts: However, this is based on a big sacrifice: cross-module type errors will be detected only at runtime. Our method, however, will detect all cross-module type errors at link time. Levy <ref> [18] </ref> presents a separate compilation method very similar to ours for PASCAL-like languages. Its compiler also automatically infers the import interface for each compilation unit. Cross-module type errors are reported at link time.
Reference: [19] <author> Robin Milner and Mads Tofte. </author> <title> Commentary on Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: It is, however, nontrivial to infer the most general type simply by hand, especially with the presence of polymorphic references in SML or type classes in Haskell. This makes it also nontrivial to write explicit import interfaces for many modules. The SML commentary <ref> [19] </ref> also suggests that programmers will probably need to write down many sharing equations if they want to close every module and that it will be too restrictive to write everything in closed functors. 2 Assumption Inference in Core ML ML has a sophisticated type inference system.
Reference: [20] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1990. </year>
Reference-contexts: So a natural question to ask is: Can we eliminate all redundant recompilations? that is, can we achieve the following smartest recompilation rule: A compilation unit never needs to be recompiled unless its own implementation (source code) changes? Standard ML (SML) <ref> [20] </ref> has a rather elaborate module system, but SML compilers have not supported separate compilation very well. The problem is that in SML, modules such as structures and functors can liberally reference externally defined identifiers without even mentioning what are their specifications. <p> However, functor applications are considered in our language because they are structure expressions which must be elaborated at compile time. The static semantics of ModL is discussed in detail in the definition <ref> [20] </ref> and Tofte [31]. Its deduction rule is in the form of "B ` phrase ) A" meaning that phrase is elaborated into a semantic object A in the basis B. The semantic objects are also defined in figure 3. <p> Definition 3.6 (Signature Matching) A structure S 0 matches a signature = N (S) if there exists a realization ' such that S 0 enriches '(S). Because the SML module language is explicitly typed, the elaboration of a module expression simply involves type-checking. The static semantics in the Definition <ref> [20] </ref> can be viewed as a type checking algorithm. Given a structure expression with free identifiers, we want to infer the minimum constraints on these free identifiers with which the expression will just type-check. Again the minimum constraints are not expressible if we only use semantic objects in figure 3.
Reference: [21] <author> J. Mitchell, W. Maybury, and R. Sweet. </author> <title> Mesa language manual. </title> <type> Technical Report CSL-79-3, </type> <institution> Xerox Palo Alto Research Center, </institution> <address> Palo Alto, CA, </address> <year> 1979. </year>
Reference-contexts: Languages with very powerful module systems such as Mesa <ref> [21] </ref>, the System Modeller in Cedar [15], and FX-87 [8] also adopt similar separate compilation methods which are only applicable to closed modules.
Reference: [22] <author> Greg Nelson, </author> <title> editor. Systems programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: In their methods, if the interface file a module depends on changes, but the set of symbols the module imports does not change, then the module does not need to be recompiled. SRC Modula-3 <ref> [22, 14] </ref> implements exactly the same idea: a version stamp which encodes the specification of a symbol is produced for each exported symbol in an interface; modules import the version stamps of the symbols that they import; a module only needs to be recompiled if any of its imported version stamps
Reference: [23] <author> Rishiyur S. Nikhil. </author> <title> Id version 90.0 reference manual. </title> <type> Technical Report TR-CSG-Memo 284-1, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1990. </year>
Reference-contexts: static semantics of each module into the binary file so that redundant recompilations can be detected and avoided if the static semantics of a module has not been changed. 17 Aditya and Nikhil [1] have been working on similar kinds of assumption inference algorithms for their incremental compiler for Id <ref> [23] </ref>. However as far as we know, their algorithm does not infer the minimum constraints, thus fails to achieve our theorem 2.1. Because their system allows mutually recursive top-level declarations, it cannot fully recover the correct type information by simply using our assumption inference and matching algorithm.
Reference: [24] <author> Atsushi Ohori. </author> <title> A compilation method for ML-style polymorphic record calculi. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <address> New York, Jan 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: then (ID,m 1 ) else if m 1 ; m 2 2 RigStrName then fail else if m 1 2 RigStrName then (fm 2 7! m 1 g; m 1 ) else (fm 1 7! m 2 g; m 2 ) 13 KindUnify presented there extends the one in Ohori <ref> [24] </ref> with considerations on ML structure names. The following theorem can be proved in the same way as Ohori [24]. Theorem 3.1 Given any kinded set of equations, the algorithm KindUnify computes a most general unifier if one exists and reports failure otherwise. <p> 2 RigStrName then (fm 2 7! m 1 g; m 1 ) else (fm 1 7! m 2 g; m 2 ) 13 KindUnify presented there extends the one in Ohori <ref> [24] </ref> with considerations on ML structure names. The following theorem can be proved in the same way as Ohori [24]. Theorem 3.1 Given any kinded set of equations, the algorithm KindUnify computes a most general unifier if one exists and reports failure otherwise. The following lemma shows how the "thinning" effect is achieved in our algorithm.
Reference: [25] <author> Didier Remy. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> In Sixteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 77-87, </pages> <address> New York, Jan 1989. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Its extension V 2 is for the polymorphic discipline of rank 2 and the relation between W and V 2 is not clear. On the side of the SML module language, Aponte [3] presented a type checking algorithm for ModL based on Remy's approach to record typing <ref> [25] </ref>. Her approach is very elegant; however, in practice it is probably very difficult to implement efficiently.
Reference: [26] <author> J. Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the ACM, </journal> <volume> 12(1) </volume> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: In the following, we use Anfxg to denote the set of type assumptions in A except those for variable x, and A (x) to denote the set of types associated with variable x in A. We also use Unify to denote Robinson's original unification algorithm on classical term algebras <ref> [26] </ref>. Unify takes a set of pairs of types and returns a substitution (the most general unifier). ML expression, and returns a type and an assumption environment. Match takes an ML type environment and an assumption environment, and returns a substitution.
Reference: [27] <author> Eugene J. Rollins. SourceGroup: </author> <title> A selective recompilation system for SML. </title> <booktitle> In Third International Workshop on Standard ML, </booktitle> <address> Pittsburgh, </address> <month> September </month> <year> 1991. </year> <institution> Carnegie Mellon University. </institution>
Reference-contexts: In summary, these previous methods cannot achieve the smartest recompilation rule, neither can they be applied to compile open-formed modules in SML. In SML, two kinds of separate compilation methods have been proposed: Rothwell and Tofte's import scheme [28] and Rollins's SourceGroup scheme <ref> [27] </ref>; both methods apply only to closed functors. Recently, Emden Gansner [10] is implementing a make-like separate compilation system for open-formed modules in the interactive SML/NJ compiler. In his method, all modules are loaded and compiled in a top level environment in an order determined by their dependencies.
Reference: [28] <author> Nick Rothwell and Mads Tofte. </author> <title> Import command source code. with Standard ML of New Jersey releases 0.65. </title>
Reference-contexts: In summary, these previous methods cannot achieve the smartest recompilation rule, neither can they be applied to compile open-formed modules in SML. In SML, two kinds of separate compilation methods have been proposed: Rothwell and Tofte's import scheme <ref> [28] </ref> and Rollins's SourceGroup scheme [27]; both methods apply only to closed functors. Recently, Emden Gansner [10] is implementing a make-like separate compilation system for open-formed modules in the interactive SML/NJ compiler.
Reference: [29] <author> Robert W. Schwanke and Gail E. Kaiser. </author> <title> Smarter recompilation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(4) </volume> <pages> 627-632, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Tichy [30] presents an effective technique called "smart recompilation" that eliminates most of the redundant recompilations triggered by (2). In Tichy's scheme, a compilation unit is recompiled only if its implementation changes, or if it references a symbol defined elsewhere whose definition has changed. Schwanke and Kaiser <ref> [29] </ref> define "smarter recompilation" which can eliminate even more (but not all) redundant recompilations caused by (2). <p> The make system [9] is the simplest one along this line. It will trigger recompilations if the interface file a module depends on changes. Tichy [30] and Schwanke <ref> [29] </ref> eliminated most recompilations by examining finer-levels of dependency relations between interfaces and implementations. In their methods, if the interface file a module depends on changes, but the set of symbols the module imports does not change, then the module does not need to be recompiled.
Reference: [30] <author> Walter Tichy. </author> <title> Smart recompilation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(3) </volume> <pages> 273-291, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: The disadvantage of using these manually created contexts is that to guarantee consistency, all modules using a changed context must be recompiled, no matter how small the change is. The conventional recompilation rule (as described in Tichy <ref> [30] </ref>) is stated as follows: "A compilation unit must be recompiled whenever (1) its own implementation changes, or (2) a context changes upon which the compilation unit depends." This is obviously not satisfactory because adding a comment or adding a new declaration to a pervasive context may cause the unnecessary recompilation <p> Tichy <ref> [30] </ref> presents an effective technique called "smart recompilation" that eliminates most of the redundant recompilations triggered by (2). In Tichy's scheme, a compilation unit is recompiled only if its implementation changes, or if it references a symbol defined elsewhere whose definition has changed. <p> The make system [9] is the simplest one along this line. It will trigger recompilations if the interface file a module depends on changes. Tichy <ref> [30] </ref> and Schwanke [29] eliminated most recompilations by examining finer-levels of dependency relations between interfaces and implementations. In their methods, if the interface file a module depends on changes, but the set of symbols the module imports does not change, then the module does not need to be recompiled.
Reference: [31] <author> Mads Tofte. </author> <title> Operational Semantics and Polymorphic Type Inference. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, Edinburgh, UK, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: For example, if f has type 8ff:ff ! ff and + has type int fl int ! int, e will have type int ! int. Milner's type inference (or type reconstruction) algorithm W (as in Tofte <ref> [31] </ref>) takes two arguments, a type environment TE and an ML expression e; all the free variables in e (such as f and +) must be specified with a type in TE , and W (TE ; e) will return the most general type for e. <p> To simplify the presentations, we divide our algorithms into two parts: this section for Core ML and the next section for the ML module language. We only give the details of our algorithm for the mini-ML language Exp and the skeletal module language ModL used by Tofte <ref> [31] </ref>. However it is easy to extend our algorithm to the rest of SML. <p> The core ML type system, in the form of type deduction rules as TE ` e : t , is listed in the appendix at the end of this paper. It is directly copied from Tofte's thesis <ref> [31] </ref>. 2.1 The assumption inference algorithm W* We define a type assumption to be a pair (x,t ) where x is a program variable and t is a type. <p> This is exactly what we will get if we apply Tofte's algorithm W to TE and e. In fact we can show that the algorithm W fl is equivalent to Milner's W <ref> [31] </ref> in the following sense: Theorem 2.1 Given a type environment TE and an expression e, then (S; t ) = W (TE ; e) succeeds if and only if both (t fl ; A) = W fl (e) and S fl = Match (TE ; A) succeed; Moreover, there exists <p> To simplify the presentation, we only consider the skeletal language ModL (as in Tofte <ref> [31] </ref>) in figure 3. Notice that signature expressions and declarations are intentionally left out because their elaborations can be delayed to link time, thus are irrelevant to our assumption inference. <p> However, functor applications are considered in our language because they are structure expressions which must be elaborated at compile time. The static semantics of ModL is discussed in detail in the definition [20] and Tofte <ref> [31] </ref>. Its deduction rule is in the form of "B ` phrase ) A" meaning that phrase is elaborated into a semantic object A in the basis B. The semantic objects are also defined in figure 3. <p> However since he mainly used the system to handle overloading, he did not try to prove our theorem 2.1. The soundness and syntactic completeness results he proved for T are only for his particular type system, not for the usual ML type system <ref> [31] </ref>, so they are not in the same sense as our corollary 2.2 and 2.3. The algorithm V in Leivant [16] is just Damas's T restricted to the type system without ML-polymorphism.

References-found: 31

