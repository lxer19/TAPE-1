URL: http://www.cs.arizona.edu/xkernel/manual.ps
Refering-URL: http://www.cs.arizona.edu/xkernel/docs.html
Root-URL: http://www.cs.arizona.edu
Title: -kernel Programmer's Manual (Version  
Date: June 1997  
Affiliation: Network Systems Research Group  
Pubnum: 3.3)  
Abstract: This report describes how to implement protocols in the x-kernel. It gives the x-kernel's programming interface, describes how to configure an x-kernel that contains a certain collection of protocols, and demonstrates how to run and debug an x-kernel. The x-kernel can be run in two different environments: (1) as a user program on top of Unix, and (2) as a network simulator on top of Unix. In both cases, the Unix platforms currently supported include Solaris, OSF/1 (Digital Unix), and Linux. (The distribution also includes source code for SunOS and Irix from earlier releases, but these platforms are not supported in the current release.) Protocols can be moved among the different environments without modification. This document assumes that the reader is generally familiar with the x-kernel's object-based infrastructure for implementing protocols. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. S. Brakmo, A. C. Bavier, and L. L. Peterson. </author> <note> x-Sim User's Manual (Version 1.0). </note> <institution> Network Systems Research Group, Department of Computer Science, University of Arizona, </institution> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Fourth, the x-kernel can now be run as a network simulator rather than on top of a real network. This simulator, called x-sim, provides a complete and realistic framework for developing, analyzing, and testing network protocols. Information about how to configure and use x-sim can be found in <ref> [1] </ref>. Finally, various components of the x-kernel are described in detail in a collection of design documents. In particular, [4] describes the implementation of the message library and [3] describes the implementation of the map library. <p> local participant. 23 /* protocol invoking xOpen on low-level protocol llp */ - Part p [2]; ... /* set participant addresses before calling low-level protocol's open */ partInit (p, 2); partPush (p [0], &ServerHostAddr, sizeof (IPhost)); /* remote */ partPush (p [0], &ServerPort, sizeof (long)); /* remote */ partPush (p <ref> [1] </ref>, ANY_HOST, 0); /* local */ partPush (p [1], &ClientPort, sizeof (long)); /* local */ xOpen (self, self, llp, p); ... llp_open (Protl self, Protl hlp, Protl hlpType, Part *p) - /* get participant addresses within low-level protocol's open */ remoteport = (long *)partPop (p [0]); localport = (long *)partPop (p <p> low-level protocol llp */ - Part p [2]; ... /* set participant addresses before calling low-level protocol's open */ partInit (p, 2); partPush (p [0], &ServerHostAddr, sizeof (IPhost)); /* remote */ partPush (p [0], &ServerPort, sizeof (long)); /* remote */ partPush (p <ref> [1] </ref>, ANY_HOST, 0); /* local */ partPush (p [1], &ClientPort, sizeof (long)); /* local */ xOpen (self, self, llp, p); ... llp_open (Protl self, Protl hlp, Protl hlpType, Part *p) - /* get participant addresses within low-level protocol's open */ remoteport = (long *)partPop (p [0]); localport = (long *)partPop (p [1]); ... <p> ANY_HOST, 0); /* local */ partPush (p <ref> [1] </ref>, &ClientPort, sizeof (long)); /* local */ xOpen (self, self, llp, p); ... llp_open (Protl self, Protl hlp, Protl hlpType, Part *p) - /* get participant addresses within low-level protocol's open */ remoteport = (long *)partPop (p [0]); localport = (long *)partPop (p [1]); ... In some cases, it is necessary to specify part of the information in a participant, but it is convenient to allow the lower protocol to fill in the rest. To allow this flexibility, the constant pointers ANY HOST and ANY PORT can be used to specify wildcard values. <p> Most of the difficulting in configuring the simulator is how to specify the network you want to simulate. This specification is given in the file xsim.data, which is described elsewhere <ref> [1] </ref>. 51 13 Running a Kernel This section describes the procedure for running a user level simulator x-kernel. A user level x-kernel runs in Unix user space, and usually uses a Unix socket interface (or other OS-specific interfaces, such as ETHPKT) to send and receive messages on the network.
Reference: [2] <author> N. C. Hutchinson and L. L. Peterson. </author> <title> The x-Kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: There are several other sources of information that you should look at to learn more about the x-kernel. First, the x-kernel was originally described in a pair of research papers <ref> [2, 5] </ref>. These are a good place to start to understand the motivation and design rationale behind the x-kernel. Second, this Programmer's Manual, while thorough, is somewhat cryptic. It does not serve as a tutorial that teaches you how to write x-kernel protocols. <p> For example, a UDP participant contains a UDP port and an IP host. If the local participant is missing from an active participant list, UDP selects an available port for the local participant. 23 /* protocol invoking xOpen on low-level protocol llp */ - Part p <ref> [2] </ref>; ... /* set participant addresses before calling low-level protocol's open */ partInit (p, 2); partPush (p [0], &ServerHostAddr, sizeof (IPhost)); /* remote */ partPush (p [0], &ServerPort, sizeof (long)); /* remote */ partPush (p [1], ANY_HOST, 0); /* local */ partPush (p [1], &ClientPort, sizeof (long)); /* local */ xOpen <p> *); static XkReturn readPort (Protl, char **, int, int, void *); static ProtlRomOpt opts [] = - - "mtu", 3, readMtu -, - "port", 3, readPort - -; static XkReturn readMtu (Protl self, char **arr, int nFields, int line, void *arg) - PState *ps = (PState *)self-&gt;state; return sscanf (arr <ref> [2] </ref>, "%d", &ps-&gt;mtu) &lt; 1 ? XK_FAILURE : XK_SUCCESS; - static XkReturn readPort (Protl self, char **arr, int nFields, int line, void *arg) - PState *ps = (PState *)self-&gt;state; return sscanf (arr [2], "%d", &ps-&gt;port) &lt; 1 ? XK_FAILURE : XK_SUCCESS; - foo_init (Protl self) - findProtlRomOpts (self, opts, sizeof (opts)/sizeof <p> self, char **arr, int nFields, int line, void *arg) - PState *ps = (PState *)self-&gt;state; return sscanf (arr <ref> [2] </ref>, "%d", &ps-&gt;mtu) &lt; 1 ? XK_FAILURE : XK_SUCCESS; - static XkReturn readPort (Protl self, char **arr, int nFields, int line, void *arg) - PState *ps = (PState *)self-&gt;state; return sscanf (arr [2], "%d", &ps-&gt;port) &lt; 1 ? XK_FAILURE : XK_SUCCESS; - foo_init (Protl self) - findProtlRomOpts (self, opts, sizeof (opts)/sizeof (ProtlRomOpt), 0); ... 42 11 Control Operations Control operations are used to perform arbitrary operations on protocols and sessions, via the xControlProtl and xControlSessn operations described in Sections 2.2.9 and 2.2.15. xControlProtl
Reference: [3] <author> D. Mosberger. </author> <title> Map Library Design Notes. </title> <institution> Network Systems Research Group, Department of Computer Science, University of Arizona, </institution> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Information about how to configure and use x-sim can be found in [1]. Finally, various components of the x-kernel are described in detail in a collection of design documents. In particular, [4] describes the implementation of the message library and <ref> [3] </ref> describes the implementation of the map library.
Reference: [4] <author> D. Mosberger. </author> <title> Message Library Design Notes. </title> <institution> Network Systems Research Group, Department of Computer Science, University of Arizona, </institution> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: This simulator, called x-sim, provides a complete and realistic framework for developing, analyzing, and testing network protocols. Information about how to configure and use x-sim can be found in [1]. Finally, various components of the x-kernel are described in detail in a collection of design documents. In particular, <ref> [4] </ref> describes the implementation of the message library and [3] describes the implementation of the map library. <p> This data structure is fairly complex, however, and so we do not describe it in this document. The interested reader is referred to a companion report <ref> [4] </ref>. In addition, there is a MsgWalk structure that is used by msgWalkNext to traverse the buffers that make up a message (see Section 3.3.12). This structure is also defined in [4]. <p> The interested reader is referred to a companion report <ref> [4] </ref>. In addition, there is a MsgWalk structure that is used by msgWalkNext to traverse the buffers that make up a message (see Section 3.3.12). This structure is also defined in [4]. The fields of neither structure should not be directly accessed by the protocol developer. 3.2 Constructor/Destructor Operations These operations are used to create and destroy messages.
Reference: [5] <author> S. W. O'Malley and L. L. Peterson. </author> <title> A dynamic network architecture. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(2) </volume> <pages> 110-143, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: There are several other sources of information that you should look at to learn more about the x-kernel. First, the x-kernel was originally described in a pair of research papers <ref> [2, 5] </ref>. These are a good place to start to understand the motivation and design rationale behind the x-kernel. Second, this Programmer's Manual, while thorough, is somewhat cryptic. It does not serve as a tutorial that teaches you how to write x-kernel protocols.
Reference: [6] <author> L. L. Peterson. </author> <title> Getting Started with the x-kernel. </title> <institution> Network Systems Research Group, Department of Computer Science, University of Arizona, </institution> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: This tutorial borrows liberally from [7], which provides an even more comprehensive discussion of protocol design and implementation. Third, if you have just picked up the x-kernel and want to try it out without having to first learn everything there is to know about it, then <ref> [6] </ref> is a good place to begin. Once you have a version of the x-kernel that builds and runs, it is much easier to start playing with the various features and options discussed in the Programmer's Manual.
Reference: [7] <author> L. L. Peterson and B. S. Davie. </author> <title> Computer Networks: A Systems Approach. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Fransico, CA, </address> <year> 1996. </year>
Reference-contexts: Second, this Programmer's Manual, while thorough, is somewhat cryptic. It does not serve as a tutorial that teaches you how to write x-kernel protocols. For help in learning how to write x-kernel protocols, including examples from several existing protocols, see [8]. This tutorial borrows liberally from <ref> [7] </ref>, which provides an even more comprehensive discussion of protocol design and implementation. Third, if you have just picked up the x-kernel and want to try it out without having to first learn everything there is to know about it, then [6] is a good place to begin.
Reference: [8] <author> L. L. Peterson, B. S. Davie, and A. C. Bavier. </author> <title> x-kernel Tutorial. </title> <institution> Network Systems Research Group, Department of Computer Science, University of Arizona, </institution> <month> Jan. </month> <year> 1996. </year> <month> 56 </month>
Reference-contexts: Second, this Programmer's Manual, while thorough, is somewhat cryptic. It does not serve as a tutorial that teaches you how to write x-kernel protocols. For help in learning how to write x-kernel protocols, including examples from several existing protocols, see <ref> [8] </ref>. This tutorial borrows liberally from [7], which provides an even more comprehensive discussion of protocol design and implementation. <p> graph.comp, e.g., ethdrv/SE0 */ char *state; /* readable/writable */ Binding binding; /* readable/writable */ int id; int *traceVar; /* readable */ /* pointers to protocols configured below this one */ int numdown; /* readable total number in down list */ int downlistsz; /* size of downlist */ struct protl *down <ref> [8] </ref>; /* first 8 in down list */ struct protl **downlist; /* overflow from down array */ /* interface functions */ XOpenFunc open; XOpenEnableFunc openenable; XOpenDisableFunc opendisable; XOpenDisableAllFunc opendisableall; XOpenDoneFunc opendone; XCloseDoneFunc closedone; XDemuxFunc demux; XCallDemuxFunc calldemux; XControlProtlFunc controlprotl; g *Protl; typedef struct sessn f char *state; /* readable/writable */ Binding <p> g *Protl; typedef struct sessn f char *state; /* readable/writable */ Binding binding; /* readable/writable */ int rcnt; unsigned char idle; /* pointers to open sessions below this one */ int numdown; /* readable total number in down list */ int downlistsz; /* size of downlist */ struct sessn *down <ref> [8] </ref>; /* first 8 in down list */ struct sessn **downlist; /* overflow from down array */ 5 /* interface functions */ XCloseFunc close; XPopFunc pop; XCallPopFunc callpop; XPushFunc push; XCallFunc call; XControlSessnFunc controlsessn; XGetParticipantsFunc getparticipants; XDuplicateFunc duplicate; /* pointers to protocols associated with this session */ struct protl *myprotl; /* <p> This can be used to create a permanent handle on session from a temporary handle, or to create a new equivalent handle from an existing handle. For a full discussion of session reference counts, see the x-kernel Tutorial <ref> [8] </ref>. <p> The work generally done by this routine is illustrated by an example protocol in the x-kernel Tutorial <ref> [8] </ref>. 2.5.2 hlp and hlpType The operations xOpen, xOpenEnable, and xOpenDisable take two high-level protocols, hlp and hlpType. hlp is the protocol to which the new lower session should route incoming messages. The lower protocol uses hlpType to determine which messages the new session should handle. <p> For the purpose of the remaining discussion, we assume you are configuring a kernel so as to implement and evaluate protocol ASP (A Simple Protocol), the example protocol used in the x-kernel Tutorial <ref> [8] </ref>. 12.2 Specifying a Protocol Graph The graph.comp file is divided into three sections: device drivers, protocols, and miscellaneous configuration parameters. The sections are separated by lines beginning with @; each section may be empty.
References-found: 8

