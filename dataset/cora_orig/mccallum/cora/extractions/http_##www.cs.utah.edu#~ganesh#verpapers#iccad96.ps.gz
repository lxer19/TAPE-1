URL: http://www.cs.utah.edu/~ganesh/verpapers/iccad96.ps.gz
Refering-URL: http://www.cs.utah.edu/~mjones/papers/utah.notes.html
Root-URL: 
Email: Email: fganesh,ratang@cs.utah.edu  
Phone: Phone: (801) 581-3568 Fax: (801) 581-5843  
Title: Issues in Formal Verification of Multiprocessor Designs Category: 4  
Author: Ganesh Gopalakrishnan Ratan Nalumasu 
Note: Corresponding Author: Ganesh Gopalakrishnan 1 Supported in part by NSF Award MIP 9321836  
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science, University of Utah  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Aharon, A., and Goodman, D. </author> <title> Test program generation for functional verification of powerpc processors in ibm. </title> <booktitle> In Proc. 32nd Design Automation Conference (June 1995), </booktitle> <pages> pp. 279-285. </pages>
Reference-contexts: In a final experiment, we have typed in formulae of the form AG not (true-fmla) and generated an error-trace that acts as a simulation sequence for establishing true-fmla (based on an idea attributed to <ref> [1] </ref>). The effectiveness of this idea is yet to be fully explored. These results (summarized in Figures 9 and 10) point to the potential for more effective 13 //------------------------------------ // Globals, including types typedef enum - SHAR_RTN, // encoded as 000 HOST_CONTROL, // 001 ...
Reference: [2] <author> Alur, R., Holzmann, G., and Peled, D. </author> <title> An analyzer for message sequence charts. </title> <booktitle> In Tools and Algorithms for the Construction and Analysis of Systems (TACAS) (1996), </booktitle> <pages> pp. 35-48. </pages> <publisher> Springer LNCS 1055. </publisher>
Reference-contexts: A good user interface is essential to make effective use of model-checkers for protocols. As an example, the SPIN system has a Tcl/TK-based interface called xspin which presents the results of state enumeration in a number of intuitive ways. One particularly intuitive representation is that of message sequence charts <ref> [2] </ref> (Figure 7) in which there is a time-line per process, with rectangles denoting statements. Each arrow indicates a channel communication, usually between two different processes.
Reference: [3] <author> Bjorner, N., Browne, A., and Manna, Z. </author> <title> Automatic generation of invariants and intermediate assertions. </title> <booktitle> In First International Conference on Principles and Practice of Constraint Programming (Sept. </booktitle> <year> 1995), </year> <editor> U. Montanari, Ed. </editor> <publisher> LNCS. </publisher>
Reference: [4] <author> Bryg, W. R., Chan, K. K., and S.Fiduccia, N. </author> <title> A high-performance, low-cost multiprocessor bus for workstations and midrange servers. </title> <journal> Hewlett-Packard Journal (Feb. </journal> <year> 1996), </year> <pages> 18-24. 18 </pages>
Reference-contexts: Section 6 concludes this paper with a look at related work, a list of challenges, and a few open problems. 2 Overview of the Avalanche Architecture series CPU along with its off-chip L1-cache. This CPU is connected to a high-speed synchronous split-transaction bus called the HP Runway bus <ref> [4] </ref>. Attached to the Runway is the main memory DRAM and a unit called the Widget through which connection to the network is attained. The Widget is the main piece of hardware being developed by the Avalanche group. <p> Instead, we focus on another, largely orthogonal, cycle-level detail, namely the distributed pipelined 12 algorithm of the Runway bus. Several bus arbitration algorithms have been summarized in [17]. None of these algorithms have the complexity of the arbitration algorithm used in the Runway bus (summarized in <ref> [4] </ref>). Figure 8 illustrates the details of this arbitration process. As shown, for the k th bus operation desired by a bus client (OP K) at cycle N+2, all bus clients express their intention to drive (or not drive) the bus at cycle N itself.
Reference: [5] <author> Clarke, E., Grumberg, O., and Long, D. </author> <title> Verification tools for finite-state concurrent systems. In A Decade of Concurrency: REX School/Symposium, </title> <address> Noordwijkerhout, The Netherlands, </address> <month> June </month> <year> 1993 (1994), </year> <pages> pp. 124-175. </pages> <publisher> Springer LNCS 803. </publisher>
Reference-contexts: Cycle level details govern how the Runway bus operates with respect to clock cycles. Busses such as the Runway are often exceedingly complex to understand, let alone to formally model and verify. Although past works have considered the verification of busses such as the Futurebus+ <ref> [5] </ref>, they did not consider cycle-level operations of such busses. Since the Widget must obey these cycle-level details and the cache coherence protocols, our practical recourse was to separately verify the protocol and cycle-level concerns.
Reference: [6] <author> Cousot, P., and Cousot, R. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In 4th ACM Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1977). </year>
Reference-contexts: While the scheme is derived from the particular buffer-sharing configuration, the parameter is derived from the invariant obeyed by the system (also shown in the figure). Thus, further research on this topic might involve automatic invariant computation methods [3,12] to determine, through abstract interpretation <ref> [6] </ref>, the number of responses generated for requests at each stage of the protocol, and from that either: (i) offer advice to the designer about the parameters used in the flow-control method (e.g., the fact that reserving one location suffices); or, (ii) automatically augment the base protocol to incorporate the flow-control
Reference: [7] <author> Dill, D. </author> <title> The stanford murphi verifier. </title> <booktitle> In Proceedings of CAV'96, </booktitle> <address> New Brunswick, New Jersey (July 1996). Tool demo. </address>
Reference-contexts: To understand the problem better, consider a very simplified model of a split-transaction bus presented in Figure 11. In this example, a number of bus clients communicate using send-buffers for read/write requests and receive-buffers for snooping. We created a formal model for this example in Murphi <ref> [7, 8] </ref> and have model-checked (Murphi code can be seen in URL [11]) that the flow-control method described in Figure 11 guarantees the absence of deadlocks. The model-check took about 30 minutes on a Sparc-20 machine with .5G of DRAM.
Reference: [8] <author> Dill, D., Drexler, A., Hu, A., and Yang, C. </author> <title> Protocol verification as a hardware design aid. </title> <booktitle> In IEEE International Conference on Computer Design (ICCD): VLSI In Computers and Processors (1992), </booktitle> <pages> pp. 522-525. </pages>
Reference-contexts: To understand the problem better, consider a very simplified model of a split-transaction bus presented in Figure 11. In this example, a number of bus clients communicate using send-buffers for read/write requests and receive-buffers for snooping. We created a formal model for this example in Murphi <ref> [7, 8] </ref> and have model-checked (Murphi code can be seen in URL [11]) that the flow-control method described in Figure 11 guarantees the absence of deadlocks. The model-check took about 30 minutes on a Sparc-20 machine with .5G of DRAM.
Reference: [9] <author> Eiriksson, A. T., and McMillan, K. </author> <title> Using formal verification/analysis methods on the critical path in system design: A case study. </title> <booktitle> In Proceedings of the 7th International Conference on Computer-Aided Verification (1995), </booktitle> <pages> pp. 367-380. </pages> <publisher> Springer LNCS 939. </publisher>
Reference-contexts: Selective and Hierarchical Verification of DSM Protocols DSM protocols have received considerable attention from the formal verification community <ref> [9, 21] </ref>. The usual method of verifying such protocols is to ensure that they obey a set of desired safety and liveness properties.
Reference: [10] <author> Godefroid, P. </author> <title> Partial-Order Methods for the Verification of Concurrent Systems: An approach to the State-Explosion Problem. </title> <type> PhD thesis, </type> <institution> Univerite De Liege, </institution> <year> 1994-95. </year>
Reference-contexts: We have developed a new partial-order reduction algorithm called the two-phase algorithm that avoids a proviso used in SPIN (and another tool based on Promela, namely PO-PACKAGE <ref> [10] </ref>). Details of this work are reported in [20]. Selected experimental results are presented in Figure 5. As shown here, neither SPIN nor PO-PACKAGE finished model-checking for safety properties for configurations of the Server/Client protocol with more than 8 Server/Client Size SPIN PO-PACK.
Reference: [11] <author> Gopalakrishnan, G. </author> <title> Murphi experiments on finite shared-buffering, </title> <note> 1996. In preparation. Preliminary version in URL http://www.cs.utah.edu/~ganesh. </note>
Reference-contexts: In this example, a number of bus clients communicate using send-buffers for read/write requests and receive-buffers for snooping. We created a formal model for this example in Murphi [7, 8] and have model-checked (Murphi code can be seen in URL <ref> [11] </ref>) that the flow-control method described in Figure 11 guarantees the absence of deadlocks. The model-check took about 30 minutes on a Sparc-20 machine with .5G of DRAM.
Reference: [12] <author> Halbwachs, N. </author> <title> Delay analysis in synchronous programs. </title> <booktitle> In Proc. 5th International Conference on Computer Aided Verification (June 1993), </booktitle> <pages> pp. 333-346. </pages> <publisher> Springer LNCS 697. </publisher>
Reference: [13] <author> Harkness, C., and Wolf, E. </author> <title> Verifying the summit bus converter protocols with symbolic model checking. Formal Methods in System Design, </title> <booktitle> 4 (1994), </booktitle> <pages> 83-97. </pages>
Reference-contexts: The futility of trial-and-error design in this area is revealed by the case of a deadlock 16 relating to the use of finite shared-buffers discovered in the HP Summit bus protocol converter by Harkness and Wolf <ref> [13] </ref>. Although the HP designers knew about this deadlock and had proposed a fix for it, even the fix proved to be insufficient to avoid deadlock [13]! There are several dimensions to the problem of designing protocols with finite buffers. We have studied flow control design problem in detail. <p> case of a deadlock 16 relating to the use of finite shared-buffers discovered in the HP Summit bus protocol converter by Harkness and Wolf <ref> [13] </ref>. Although the HP designers knew about this deadlock and had proposed a fix for it, even the fix proved to be insufficient to avoid deadlock [13]! There are several dimensions to the problem of designing protocols with finite buffers. We have studied flow control design problem in detail. To understand the problem better, consider a very simplified model of a split-transaction bus presented in Figure 11.
Reference: [14] <author> Hennessy, J., and Patterson, D. </author> <title> Computer Architecture: A Quantitative Approach (Second Edition). </title> <publisher> Morgan Kaufman, </publisher> <year> 1995. </year> <month> Appendix-E. </month>
Reference-contexts: For example, it is interesting to note that one of these refinement problems|the 3 impact of finite FIFO buffers on protocols|has received very little attention in the verification literature, but has received a surprising amount of attention from real designers <ref> [14] </ref>. This makes the case that formal methods must be evolved in the context of real designs. The rest of this paper is organized as follows. In Section 2, we will describe the Utah Avalanche multiprocessor in sufficient detail as to motivate the verification challenges in its design. <p> More general schemes include the invalidate scheme in which a 5 write is preceded by an invalidation of other copies, and the update scheme in which updates are sent out following writes. These concepts are standard in the area of multiprocessor design (e.g. <ref> [14] </ref>). To make our discussions more concrete, we will consider the migratory protocol as an example of a simple DSM protocol used in the Avalanche (Figure 2). <p> Upon fixing the deadlocks, the other two tools were able to handle the migratory but not invalidate. The deadlock in the Migratory protocol is a typical mistake made by DSM protocol designers <ref> [14] </ref>. <p> At a conceptual level, designers understand split transaction protocols in terms of messages flowing through unbounded independent FIFO buffers. Unfortunately, buffers are finite and often shared. This alters the behavior of the system sufficiently to introduce unforeseen deadlocks <ref> [14, 18] </ref>. The futility of trial-and-error design in this area is revealed by the case of a deadlock 16 relating to the use of finite shared-buffers discovered in the HP Summit bus protocol converter by Harkness and Wolf [13].
Reference: [15] <author> Holzmann, G. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: The usual method of verifying such protocols is to ensure that they obey a set of desired safety and liveness properties. We have followed a similar approach using the model-checking tool from AT&T called SPIN <ref> [15] </ref> which has been used with great success in validating communicating protocols. (Descriptions to be validated using SPIN are modeled in a protocol modeling language called Promela.) However, when applied to a new domain (DSM protocols), 6 SPIN suffered from state explosion even on simple protocols such as the migratory protocol.
Reference: [16] <author> Hunt, D. </author> <title> Advanced performance features of the 64-bit pa-8000. </title> <booktitle> In Proceedings of COMPCON'95 (1995), </booktitle> <pages> pp. 123-128. </pages>
Reference: [17] <author> IEEE. </author> <title> Multiprocessor Bus Standards. </title> <publisher> IEEE Press, </publisher> <year> 1993. </year> <title> Edited Collection on Recent Bus Standards. </title>
Reference-contexts: Instead, we focus on another, largely orthogonal, cycle-level detail, namely the distributed pipelined 12 algorithm of the Runway bus. Several bus arbitration algorithms have been summarized in <ref> [17] </ref>. None of these algorithms have the complexity of the arbitration algorithm used in the Runway bus (summarized in [4]). Figure 8 illustrates the details of this arbitration process.
Reference: [18] <author> Kuskin, J. </author> <title> The stanford FLASH multiprocessor. </title> <booktitle> In Proceedings of the 21st International Symposium on Computer Architecture (June 1994). </booktitle>
Reference-contexts: At a conceptual level, designers understand split transaction protocols in terms of messages flowing through unbounded independent FIFO buffers. Unfortunately, buffers are finite and often shared. This alters the behavior of the system sufficiently to introduce unforeseen deadlocks <ref> [14, 18] </ref>. The futility of trial-and-error design in this area is revealed by the case of a deadlock 16 relating to the use of finite shared-buffers discovered in the HP Summit bus protocol converter by Harkness and Wolf [13].
Reference: [19] <author> McMillan, K. L. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Press, </publisher> <year> 1993. </year> <month> 19 </month>
Reference-contexts: A Verilog model for the distributed pipelined arbitration process was created using the Verilog supported by the Berkeley VIS tool [25]. VIS supports Verilog simulation, and a host of verification algorithms including CTL model-checking <ref> [19] </ref>, language emptiness checks, etc. Using the symbolic model-checking facility supported by VIS, we have model-checked to prove that the arbitration algorithm ensures at-most one bus driver at any time. This model-checking run completed in less than 10 minutes on a server-class Sparc-20 with 64 Mbytes of physical memory.
Reference: [20] <author> Nalumasu, R., and Gopalakrishnan, G. </author> <title> An improvement to partial-order reductions, </title> <note> 1996. In preparation. Preliminary version in URL http://www.cs.utah.edu/~ganesh. </note>
Reference-contexts: We have developed a new partial-order reduction algorithm called the two-phase algorithm that avoids a proviso used in SPIN (and another tool based on Promela, namely PO-PACKAGE [10]). Details of this work are reported in <ref> [20] </ref>. Selected experimental results are presented in Figure 5. As shown here, neither SPIN nor PO-PACKAGE finished model-checking for safety properties for configurations of the Server/Client protocol with more than 8 Server/Client Size SPIN PO-PACK. <p> Verification using SPIN is in progress. Cycle-level aspects of the Runway were modeled using VIS, as described in Section 4. 3.3 Assessment of Protocol Debugging through Model-checking In summary, in our experience, protocol debugging using model-checkers has proved to be very effective (details are reported in <ref> [20] </ref>). However, the problem that needs more research is, how the protocols are refined to a hardware implementation, which is touched upon in Section 4 and 5. A good user interface is essential to make effective use of model-checkers for protocols.
Reference: [21] <author> Park, S., and Dill, D. </author> <title> Protocol verification by aggregation of distributed actions. </title> <booktitle> In Proceedings of CAV'96, </booktitle> <address> New Brunswick, New Jersey (July 1996). </address> <note> To appear. </note>
Reference-contexts: Selective and Hierarchical Verification of DSM Protocols DSM protocols have received considerable attention from the formal verification community <ref> [9, 21] </ref>. The usual method of verifying such protocols is to ensure that they obey a set of desired safety and liveness properties.
Reference: [22] <author> Rajan, S., Shankar, N., and Srivas, M. </author> <title> An integration of theorem-proving and model-checking. </title> <booktitle> In Proceedings of the 7th International Conference on Computer-Aided Verification (1995), </booktitle> <pages> pp. 84-97. </pages> <publisher> Springer LNCS 939. </publisher>
Reference-contexts: Nevertheless, in order to be really thorough, one must embed this, and similar techniques into the framework of a tool such as a theorem prover [24]. Work in this direction has already begun in other groups <ref> [22] </ref>. We believe that handling resource issues adequately will, in particular, require the help of theorem-proving techniques. The importance of further developing rules of safe design of protocols (such as described in Section 3) are also crucial if we were to replace verification effort by correct by construction techniques.
Reference: [23] <author> Roscoe, A. W., and Dathi, N. </author> <title> The pursuit of deadlock freedom. </title> <booktitle> Information and Computation 75 (1987), </booktitle> <pages> 289-327. </pages>
Reference-contexts: For example, proofs of general properties of process networks can be developed using theorem-proving techniques and then used to construct safe rules of design for protocols. Beginnings of these ideas can already be seen in, e.g., <ref> [23] </ref>. We plan to pursue these ideas more extensively.
Reference: [24] <author> Srivas, M., and Miller, S. </author> <title> Applying formal verification to a commercial microprocessor. </title> <booktitle> In Proceedings of the 1995 Conference on Computer Hardware Description Languages (CHDL'95), Chiba, </booktitle> <address> Japan (1995). </address>
Reference-contexts: Nevertheless, in order to be really thorough, one must embed this, and similar techniques into the framework of a tool such as a theorem prover <ref> [24] </ref>. Work in this direction has already begun in other groups [22]. We believe that handling resource issues adequately will, in particular, require the help of theorem-proving techniques.
Reference: [25] <author> VIS. </author> <note> VIS user's manual, 1996. </note> <institution> University of California, Berkeley, and University of Colorado, Boulder. </institution> <month> 20 </month>
Reference-contexts: A Verilog model for the distributed pipelined arbitration process was created using the Verilog supported by the Berkeley VIS tool <ref> [25] </ref>. VIS supports Verilog simulation, and a host of verification algorithms including CTL model-checking [19], language emptiness checks, etc. Using the symbolic model-checking facility supported by VIS, we have model-checked to prove that the arbitration algorithm ensures at-most one bus driver at any time.
References-found: 25

