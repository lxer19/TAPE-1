URL: ftp://ftp.cs.washington.edu/pub/constraints/papers/kaleidoscope-ecoop-92.ps.Z
Refering-URL: http://www.cs.washington.edu/research/constraints/cip/kaleidoscope-ecoop-92.html
Root-URL: 
Email: bnfb@csr.uvic.ca  borning@cs.washington.edu  
Title: Integrating Constraints with an Object-Oriented Language  
Author: Bjorn N. Freeman-Benson Alan Borning 
Address: P.O. Box 3055 Victoria, B.C., V8W 3P6, CANADA  Seattle, Washington 98195, USA  
Affiliation: University of Victoria Department of Computer Science  Department of Computer Science and Engineering, FR-35 University of Washington  
Abstract: Constraints are declarative statements of relations among elements of the language's computational domain, e.g., integers, booleans, strings, and other objects. Orthogonally, the tools of object-oriented programming, including encapsulation, inheritance, and dynamic message binding, provide important mechanisms for extending a language's domain. Although the integration of constraints and objects seems obvious and natural, one basic obstacle stands in the way: objects provide a new, larger, computational domain, which the language's embedded constraint solver must accommodate. In this paper we list some goals and non-goals for an integration of constraints and object oriented language features, outline previous approaches to this integration, and describe the scheme we use in Kaleidoscope'91, our object-oriented constraint imperative programming language. Kaleidoscope'91 uses a class-based object model, multi-methods, and constraint constructors to integrate cleanly the encapsulation and abstraction of a state-of-the-art object-oriented language with the declarative aspects of constraints. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Avesani, A. Perini, and F. Ricci. </author> <title> COOL: An Object System with Constraints. </title> <booktitle> In TOOLS 2, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: Assuming reasonable abstraction principles and encapsulation mechanisms, the programmer should not need to know anything about the internal implementation of Rectangle, much less about what implementations of Points are used. A representative example of a system that uses this two-domain, constraints-on-leaves technique is the COOL system <ref> [1] </ref>.
Reference: [2] <author> Paul Barth. </author> <title> An Object-Oriented Approach to Graphical Interfaces. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 5(2) </volume> <pages> 142-172, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: The integration seems obvious and natural, as evidenced, for example, by the large number of object-oriented languages and environments that include some sort of constraint-like mechanism, such as a one-way depen dency maintenance system (see e.g. <ref> [2, 28, 32] </ref>). However, one basic obstacle stands in the way of a thorough integration: objects provide a new, larger computational domain, which the language's embedded constraint solver must accommodate. Providing a general solver for arbitrary constraints over arbitrary domains is a completely unreasonable goal.
Reference: [3] <author> Eric A. Bier and Maureen C. Stone. Snap-Dragging. </author> <booktitle> In Proceedings of SIGGRAPH'86, </booktitle> <address> Dallas, Texas, </address> <month> August </month> <year> 1986. </year> <note> Also in Computer Graphics 20(4), </note> <month> August </month> <year> 1986. </year>
Reference-contexts: ( mouse, mercury ) ) then assert medium mouse.location.y = mercury.top; while ( mouse.button = down ); elseif ( near ( mouse, menu.top ) ) then : : : endif; As a second example, consider the definition of an object dragging routine for an object-oriented graphical drawing program such as <ref> [3] </ref>. The object being dragged usually follows the mouse. However, if the dragged object is moved within the "gravity" region of another object, the dragged object sticks to the fixed object while minimizing the distance between itself and the mouse.
Reference: [4] <author> Alan Borning. </author> <title> The Programming Language Aspects of ThingLab, A Constraint-Oriented Simulation Laboratory. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(4) </volume> <pages> 353-387, </pages> <month> October </month> <year> 1981. </year>
Reference-contexts: It should have a clean, declarative semantics. A particular issue concerning semantics is that many of the early interactive constraint-based systems, such as the original ThingLab <ref> [4] </ref> and Magritte [19], used a perturbation model of constraints. In this model, the constraints describe the relations that should hold. The user or some other outside influence perturbs the system, which must then adjust itself to re-satisfy the constraints. <p> Siri has a completely integrated object model similar to that of BETA [27, 26] and thus better satisfies goal 2. 3.5 Other Techniques Another technique that has been used to integrate constraints and objects is the path approach used in the original ThingLab <ref> [4] </ref>. The ThingLab constraint solver was essentially an augmented planned local propagation system|it used both local propagation and iterative relaxation. The planning phase was based on virtual variables.
Reference: [5] <author> Alan Borning and Danial H. H. Ingalls. </author> <title> Multiple Inheritance in Smalltalk-80. </title> <booktitle> In Proceedings of the National Conference on Artificial Intelligence, </booktitle> <pages> pages 234-237, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> August </month> <year> 1982. </year> <journal> American Association for Artificial Intelligence. </journal>
Reference-contexts: This approach is like the one taken in the Smalltalk multiple inheritance extension <ref> [5] </ref> and in Cecil, and in contrast to the more elaborate approach in CLOS, in which a linear ordering is imposed on the inheritance graph.) Kaleidoscope'91 has also inherited Cecil's optional and incremental static type checking system.
Reference: [6] <author> Alan Borning, Michael Maher, Amy Martindale, and Molly Wilson. </author> <title> Constraint Hierarchies and Logic Programming. </title> <booktitle> In Proceedings of the Sixth International Conference on Logic Programming, </booktitle> <pages> pages 149-164, </pages> <address> Lisbon, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: In contrast, in the refinement model of constraints, the set of possible values for each variable is refined during the execution of the program (but never altered in other ways). This model is more declarative, and is invariably used in the constraint systems rooted in logic programming (e.g. <ref> [6, 11, 21, 35] </ref>). We therefore set as a subgoal the use of a refinement model in the integrated language. 6. Finally, it should be reasonably efficient. 1.2 Non-Goals We also suggest a number of "non-goals" for such an integration: 1. <p> A constraint hierarchy can contain an arbitrary number of levels of preference, in either a total or partial order. The solutions to a constraint hierarchy are the valuations (mappings from variables to values) that best satisfy the constraints in the hierarchy, respecting their relative strengths. References <ref> [6, 18] </ref> present a formal description of the theory of constraint hierarchies, while [16, 17] describe two algorithms, DeltaBlue and DeltaStar respectively, for finding solutions to them.
Reference: [7] <author> Timothy A. Budd. </author> <title> Blending Imperative and Relational Programming. </title> <journal> IEEE Software, </journal> <volume> 8(1), </volume> <month> January </month> <year> 1991. </year>
Reference-contexts: Furthermore, the availability of two paradigms will encourage the development of novel dual-paradigm algorithms, such as the associative array and set implementations described in <ref> [7, 8] </ref>. 14 Acknowledgements This work has been supported by the University of Victoria, and by the National Science Foundation under grant IRI-9102938.
Reference: [8] <author> Timothy A. Budd. </author> <title> Multiparadigm Data Structures in Leda. </title> <booktitle> In Proceedings of the IEEE Computer Society 1992 International Conference on Computer Languages, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: Furthermore, the availability of two paradigms will encourage the development of novel dual-paradigm algorithms, such as the associative array and set implementations described in <ref> [7, 8] </ref>. 14 Acknowledgements This work has been supported by the University of Victoria, and by the National Science Foundation under grant IRI-9102938.
Reference: [9] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <booktitle> In Proceedings of the 1992 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 33-56, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: One attribute that is not independent, however, is single dispatching versus multiple dispatching. Kaleidoscope'91 adopts the multiple dispatching techniques of Cecil <ref> [9] </ref>, rather than the single dispatching of Smalltalk and C++. Multi-methods are particularly appropriate in a constraint language, since the multi-directional nature of constraints means that, in general, any argument could be either an input or an output.
Reference: [10] <author> Craig Chambers and David Ungar. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <booktitle> In Proceedings of the 1991 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 1-15, </pages> <address> Phoenix, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Such optimizations are key to efficient implementations of pure object-oriented languages <ref> [10, 13] </ref>.) 3. The work in the logic programming community on integrating constraints with logic programming, and on doing object-oriented programming in a concurrent logic programming framework [23, 24, 36], is quite relevant to the task at hand.
Reference: [11] <author> Jacques Cohen. </author> <title> Constraint Logic Programming Languages. </title> <journal> Communications of the ACM, </journal> <volume> 33(7) </volume> <pages> 52-68, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: In contrast, in the refinement model of constraints, the set of possible values for each variable is refined during the execution of the program (but never altered in other ways). This model is more declarative, and is invariably used in the constraint systems rooted in logic programming (e.g. <ref> [6, 11, 21, 35] </ref>). We therefore set as a subgoal the use of a refinement model in the integrated language. 6. Finally, it should be reasonably efficient. 1.2 Non-Goals We also suggest a number of "non-goals" for such an integration: 1.
Reference: [12] <author> Eric Cournarie and Michel Beaudouin-Lafon. </author> <title> ALIEN: A Prototype-based Constraint System. </title> <booktitle> In Preprints of the Second Eurographics Workshop on Object Oriented Graphics, </booktitle> <pages> pages 93-114, </pages> <address> Texel, The Netherlands, </address> <month> June </month> <year> 1991. </year> <note> To be published in revised form by Springer-Verlag. </note>
Reference-contexts: On the other hand, an advantage of separating the phases is that one particular choice of constraints (a "plan") can be reused until the constraint graph topology changes, thus resulting in better execution speed. Representative examples of systems that use local propagation include Alien <ref> [12] </ref>, Garnet [33], Smalltalk's MVC mechanism 1 [28], and ThingLab II [31]. Alien, Garnet, and MVC all use dataflow propagation, whereas ThingLab II uses planned propagation.
Reference: [13] <author> L. Peter Deutsch and Allan M. Schiffman. </author> <title> Efficient Implementation of the Smalltalk-80 System. </title> <booktitle> In Proceedings of the Eleventh Annual Principles of Programming Languages Symposium, </booktitle> <pages> pages 297-302, </pages> <address> Salt Lake City, Utah, </address> <month> January </month> <year> 1984. </year> <journal> ACM. </journal> <volume> 15 </volume>
Reference-contexts: Such optimizations are key to efficient implementations of pure object-oriented languages <ref> [10, 13] </ref>.) 3. The work in the logic programming community on integrating constraints with logic programming, and on doing object-oriented programming in a concurrent logic programming framework [23, 24, 36], is quite relevant to the task at hand.
Reference: [14] <author> Bjorn Freeman-Benson. </author> <title> A Module Compiler for ThingLab II. </title> <booktitle> In Proceedings of the 1989 ACM Con--ference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 389-396, </pages> <address> New Orleans, </address> <month> October </month> <year> 1989. </year> <note> ACM. </note>
Reference-contexts: However, the greatest savings in execution time will come from moving as much of the constraint satisfaction problem from run time to compile time as possible. When the compiler can statically determine which constraints will be active at run time, it can use the constraint compiling technology of <ref> [14] </ref> to produce a short sequence of instructions instead of a run-time constraint solver call. For example, if there is an assignment to an otherwise unconstrained variable, rather than representing the assignment as a run time constraint and solving it, we can compile it as a simple store instruction.
Reference: [15] <author> Bjorn Freeman-Benson. </author> <title> Kaleidoscope: Mixing Objects, Constraints, and Imperative Programming. </title> <booktitle> In Proceedings of the 1990 Conference on Object-Oriented Programming Systems, Languages, and Applications, and European Conference on Object-Oriented Programming, </booktitle> <pages> pages 77-88, </pages> <address> Ottawa, Canada, </address> <month> October </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: Third, we describe the design and implementation of the integration techniques we are using in Kaleidoscope'91, our second-generation object-oriented constraint imperative programming language. Kaleidoscope'91 contains a number of significant differences from its predecessor, Kaleidoscope'90 (as described in <ref> [15] </ref>). For example, Kaleidoscope'91 uses multi-methods whereas the original Kaleidoscope'90 did not; Kaleidoscope'91 has separate type and implementation inheritance hierarchies whereas Kaleidoscope'90 combined the two; and Kaleidoscope'91 has only one kind of constraint as opposed to the bewildering variety of kinds in Kaleidoscope'90.
Reference: [16] <author> Bjorn Freeman-Benson, John Maloney, and Alan Borning. </author> <title> An Incremental Constraint Solver. </title> <journal> Communications of the ACM, </journal> <volume> 33(1) </volume> <pages> 54-63, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: As demonstrated by the wide variety of systems and languages that use them, constraints are useful in programming languages, user interface toolkits, simulation packages, and many other systems. (See <ref> [16] </ref> or [29] for an overview.) Their usefulness stems from the fact that constraints are declarative: constraints emphasize the relation itself rather than the procedural steps necessary fl Published in the Proceedings of the 1992 European Conference on Object-Oriented Programming, pages 268-286 1 to maintain the relation. <p> The solutions to a constraint hierarchy are the valuations (mappings from variables to values) that best satisfy the constraints in the hierarchy, respecting their relative strengths. References [6, 18] present a formal description of the theory of constraint hierarchies, while <ref> [16, 17] </ref> describe two algorithms, DeltaBlue and DeltaStar respectively, for finding solutions to them.
Reference: [17] <author> Bjorn Freeman-Benson, Molly Wilson, and Alan Borning. DeltaStar: </author> <title> A General Algorithm for Incremental Satisfaction of Constraint Hierarchies. </title> <booktitle> In Proceedings of the Eleventh Annual IEEE Phoenix Conference on Computers and Communications, </booktitle> <pages> pages 561-568, </pages> <address> Scottsdale, Arizona, </address> <month> March </month> <year> 1992. </year> <note> IEEE. </note>
Reference-contexts: The solutions to a constraint hierarchy are the valuations (mappings from variables to values) that best satisfy the constraints in the hierarchy, respecting their relative strengths. References [6, 18] present a formal description of the theory of constraint hierarchies, while <ref> [16, 17] </ref> describe two algorithms, DeltaBlue and DeltaStar respectively, for finding solutions to them.
Reference: [18] <author> Bjorn N. Freeman-Benson. </author> <title> Constraint Imperative Programming. </title> <type> PhD thesis, </type> <institution> University of Washington, Department of Computer Science and Engineering, </institution> <month> July </month> <year> 1991. </year> <note> Published as Department of Computer Science and Engineering Technical Report 91-07-02. </note>
Reference-contexts: A constraint hierarchy can contain an arbitrary number of levels of preference, in either a total or partial order. The solutions to a constraint hierarchy are the valuations (mappings from variables to values) that best satisfy the constraints in the hierarchy, respecting their relative strengths. References <ref> [6, 18] </ref> present a formal description of the theory of constraint hierarchies, while [16, 17] describe two algorithms, DeltaBlue and DeltaStar respectively, for finding solutions to them. <p> Thus the overview of the Kaleidoscope'91 constraint solver is: first, solve the type constraints; second, execute the constraint constructors; and third, solve the primitive constraints. The complete algorithm is omitted here due to space restrictions, but is available in <ref> [18] </ref>.
Reference: [19] <author> James A. Gosling. </author> <title> Algebraic Constraints. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> May </month> <year> 1983. </year> <note> Published as CMU Computer Science Department Technical Report CMU-CS-83-132. </note>
Reference-contexts: It should have a clean, declarative semantics. A particular issue concerning semantics is that many of the early interactive constraint-based systems, such as the original ThingLab [4] and Magritte <ref> [19] </ref>, used a perturbation model of constraints. In this model, the constraints describe the relations that should hold. The user or some other outside influence perturbs the system, which must then adjust itself to re-satisfy the constraints.
Reference: [20] <author> Bruce Horn. </author> <title> A Constrained-Object Language for Reactive Program Implementation. </title> <type> Technical Report CMU-CS-91-152, </type> <institution> School of Computer Science, Carnegie-Mellon University, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: More importantly, graph rewriting is a fundamentally different execution model from the standard imperative one, bringing this technique in conflict with goal 3. The first programming language to use graph rewriting to integrate objects and constraints is Bertrand [29]; later systems of this type are Equate [39], and Siri <ref> [20] </ref>. A primary design goal of Equate is preserving object encapsulation in the internal operation of the constraint satisfier, which, as noted above, we view as an inappropriate goal.
Reference: [21] <author> Joxan Jaffar and Jean-Louis Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proceedings of the Fourteenth ACM Principles of Programming Languages Conference, </booktitle> <address> Munich, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: In contrast, in the refinement model of constraints, the set of possible values for each variable is refined during the execution of the program (but never altered in other ways). This model is more declarative, and is invariably used in the constraint systems rooted in logic programming (e.g. <ref> [6, 11, 21, 35] </ref>). We therefore set as a subgoal the use of a refinement model in the integrated language. 6. Finally, it should be reasonably efficient. 1.2 Non-Goals We also suggest a number of "non-goals" for such an integration: 1.
Reference: [22] <author> Joxan Jaffar, Spiro Michaylov, Peter Stuckey, and Roland Yap. </author> <title> The CLP(R) Language and System. </title> <type> Technical Report CMU-CS-90-181, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> October </month> <year> 1990. </year> <note> To appear in ACM Transactions on Programming Languages and Systems. </note>
Reference-contexts: This works well in a logic programming environment in which there is no mutable state, and is frequently used in programs written in languages such as CLP (R) <ref> [22] </ref>. However, it is problematic in an object-oriented language, since the splitting immediately becomes invalid if either the objects or the implementations change.
Reference: [23] <author> Kenneth Kahn, Eric Tribble, Mark Miller, and Daniel Bobrow. </author> <title> Objects in Concurrent Logic Programming Languages. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 242-257, </pages> <address> Portland, Oregon, </address> <month> September </month> <year> 1986. </year> <note> ACM. </note>
Reference-contexts: Such optimizations are key to efficient implementations of pure object-oriented languages [10, 13].) 3. The work in the logic programming community on integrating constraints with logic programming, and on doing object-oriented programming in a concurrent logic programming framework <ref> [23, 24, 36] </ref>, is quite relevant to the task at hand. However, for the current experiment, we wish to remain rooted in the imperative, object-oriented world; we do not set as a goal supporting logic variables or backtracking.
Reference: [24] <author> Kenneth M. Kahn. </author> <title> Objects|A Fresh Look. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming, </booktitle> <month> July </month> <year> 1990. </year>
Reference-contexts: Such optimizations are key to efficient implementations of pure object-oriented languages [10, 13].) 3. The work in the logic programming community on integrating constraints with logic programming, and on doing object-oriented programming in a concurrent logic programming framework <ref> [23, 24, 36] </ref>, is quite relevant to the task at hand. However, for the current experiment, we wish to remain rooted in the imperative, object-oriented world; we do not set as a goal supporting logic variables or backtracking.
Reference: [25] <author> Glenn Kramer, Jahir Pabon, Walid Keirouz, and Robert Young. </author> <title> Geometric Constraint Satisfaction Problems. </title> <booktitle> In Working Notes of the AAAI Spring Symposium on Constraint-Based Reasoning, </booktitle> <pages> pages 242-251, </pages> <address> Stanford, </address> <month> March </month> <year> 1991. </year>
Reference-contexts: Representative examples of systems that use this new solver approach are the constraint systems for graphical objects described in <ref> [25] </ref> and [37].
Reference: [26] <author> Bent Bruun Kristensen, Ole Lehrmann Madsen, Birger Mtller Pedersen, and Kristen Nygaard. </author> <title> Object Oriented Programming in the Beta Programming Language. </title> <note> Draft of unpublished book, </note> <year> 1991. </year>
Reference-contexts: A primary design goal of Equate is preserving object encapsulation in the internal operation of the constraint satisfier, which, as noted above, we view as an inappropriate goal. Siri has a completely integrated object model similar to that of BETA <ref> [27, 26] </ref> and thus better satisfies goal 2. 3.5 Other Techniques Another technique that has been used to integrate constraints and objects is the path approach used in the original ThingLab [4].
Reference: [27] <author> Bent Bruun Kristensen, Ole Lehrmann Madsen, Birger Mtller Pederson, and Kirsten Nygaard. </author> <title> Abstraction Mechanisms in the BETA Programming Language. </title> <booktitle> In Proceedings of the Tenth Annual Principles of Programming Languages Symposium, </booktitle> <address> Austin, Texas, </address> <month> January </month> <year> 1983. </year> <note> ACM. </note>
Reference-contexts: A primary design goal of Equate is preserving object encapsulation in the internal operation of the constraint satisfier, which, as noted above, we view as an inappropriate goal. Siri has a completely integrated object model similar to that of BETA <ref> [27, 26] </ref> and thus better satisfies goal 2. 3.5 Other Techniques Another technique that has been used to integrate constraints and objects is the path approach used in the original ThingLab [4].
Reference: [28] <author> Wilf R. LaLonde and John R. Pugh. </author> <title> Inside Smalltalk, volume II. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: The integration seems obvious and natural, as evidenced, for example, by the large number of object-oriented languages and environments that include some sort of constraint-like mechanism, such as a one-way depen dency maintenance system (see e.g. <ref> [2, 28, 32] </ref>). However, one basic obstacle stands in the way of a thorough integration: objects provide a new, larger computational domain, which the language's embedded constraint solver must accommodate. Providing a general solver for arbitrary constraints over arbitrary domains is a completely unreasonable goal. <p> Representative examples of systems that use local propagation include Alien [12], Garnet [33], Smalltalk's MVC mechanism 1 <ref> [28] </ref>, and ThingLab II [31]. Alien, Garnet, and MVC all use dataflow propagation, whereas ThingLab II uses planned propagation. Although these systems are all reasonably efficient (meeting goal 6), they are strictly limited in the kinds of constraints they can solve (not meeting goal 4).
Reference: [29] <author> William Leler. </author> <title> Constraint Programming Languages. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: As demonstrated by the wide variety of systems and languages that use them, constraints are useful in programming languages, user interface toolkits, simulation packages, and many other systems. (See [16] or <ref> [29] </ref> for an overview.) Their usefulness stems from the fact that constraints are declarative: constraints emphasize the relation itself rather than the procedural steps necessary fl Published in the Proceedings of the 1992 European Conference on Object-Oriented Programming, pages 268-286 1 to maintain the relation. <p> More importantly, graph rewriting is a fundamentally different execution model from the standard imperative one, bringing this technique in conflict with goal 3. The first programming language to use graph rewriting to integrate objects and constraints is Bertrand <ref> [29] </ref>; later systems of this type are Equate [39], and Siri [20]. A primary design goal of Equate is preserving object encapsulation in the internal operation of the constraint satisfier, which, as noted above, we view as an inappropriate goal.
Reference: [30] <author> Alan K. Mackworth. </author> <title> Consistency in Networks of Relations. </title> <journal> Artificial Intelligence, </journal> <volume> 8(1) </volume> <pages> 99-118, </pages> <year> 1977. </year> <month> 16 </month>
Reference-contexts: For both Kaleidoscope'90 and Kaleidoscope'91, the primitive domain D p consists of three sub-domains: real numbers, booleans, and bitmaps. Each sub-domain has its own primitive constraint solver: a combination local propagation/Simplex algorithm for real numbers, a finite-domain solver <ref> [30] </ref> for booleans and type constraints, and a local propagation solver for bitmaps. These three solvers use a variation of the algorithm described in [34] to cooperate when solving inter-domain constraints. The idea behind the algorithm is that the primitive constraint solvers communicate relevant variable bindings via inter-domain constraints.
Reference: [31] <author> John Maloney. </author> <title> Using Constraints for User Interface Construction. </title> <type> PhD thesis, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> August </month> <year> 1991. </year> <note> Published as Department of Computer Science and Engineering Technical Report 91-08-12. </note>
Reference-contexts: Representative examples of systems that use local propagation include Alien [12], Garnet [33], Smalltalk's MVC mechanism 1 [28], and ThingLab II <ref> [31] </ref>. Alien, Garnet, and MVC all use dataflow propagation, whereas ThingLab II uses planned propagation. Although these systems are all reasonably efficient (meeting goal 6), they are strictly limited in the kinds of constraints they can solve (not meeting goal 4).
Reference: [32] <author> Brad A. Myers, Dario Guise, Roger B. Dannenberg, Brad Vander Zanden, David Kosbie, Philippe Marchal, and Ed Pervin. </author> <title> Comprehensive Support for Graphical, Highly-Interactive User Interfaces: The Garnet User Interface Development Environment. </title> <journal> IEEE Computer, </journal> <volume> 23(11) </volume> <pages> 71-85, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: The integration seems obvious and natural, as evidenced, for example, by the large number of object-oriented languages and environments that include some sort of constraint-like mechanism, such as a one-way depen dency maintenance system (see e.g. <ref> [2, 28, 32] </ref>). However, one basic obstacle stands in the way of a thorough integration: objects provide a new, larger computational domain, which the language's embedded constraint solver must accommodate. Providing a general solver for arbitrary constraints over arbitrary domains is a completely unreasonable goal.
Reference: [33] <author> Brad A. Myers, Dario Guise, Roger B. Dannenberg, Brad Vander Zanden, David Kosbie, Philippe Marchal, Ed Pervin, Andrew Mickish, and John A. Kolojejchick. </author> <title> The Garnet Toolkit Reference Manuals: Support for Highly-Interactive Graphical User Interfaces in Lisp. </title> <type> Technical Report CMU-CS-90-117, </type> <institution> Computer Science Dept, Carnegie Mellon University, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: On the other hand, an advantage of separating the phases is that one particular choice of constraints (a "plan") can be reused until the constraint graph topology changes, thus resulting in better execution speed. Representative examples of systems that use local propagation include Alien [12], Garnet <ref> [33] </ref>, Smalltalk's MVC mechanism 1 [28], and ThingLab II [31]. Alien, Garnet, and MVC all use dataflow propagation, whereas ThingLab II uses planned propagation. Although these systems are all reasonably efficient (meeting goal 6), they are strictly limited in the kinds of constraints they can solve (not meeting goal 4).
Reference: [34] <author> Greg Nelson and Derek C. Oppen. </author> <title> Simplification by Cooperating Decision Procedures. </title> <booktitle> In Proceedings of the Fifth ACM Symposium on Principles of Programming Languages. ACM SIGPLAN, </booktitle> <year> 1978. </year>
Reference-contexts: Each sub-domain has its own primitive constraint solver: a combination local propagation/Simplex algorithm for real numbers, a finite-domain solver [30] for booleans and type constraints, and a local propagation solver for bitmaps. These three solvers use a variation of the algorithm described in <ref> [34] </ref> to cooperate when solving inter-domain constraints. The idea behind the algorithm is that the primitive constraint solvers communicate relevant variable bindings via inter-domain constraints.
Reference: [35] <author> Vijay A. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, Computer Science Department, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: In contrast, in the refinement model of constraints, the set of possible values for each variable is refined during the execution of the program (but never altered in other ways). This model is more declarative, and is invariably used in the constraint systems rooted in logic programming (e.g. <ref> [6, 11, 21, 35] </ref>). We therefore set as a subgoal the use of a refinement model in the integrated language. 6. Finally, it should be reasonably efficient. 1.2 Non-Goals We also suggest a number of "non-goals" for such an integration: 1.
Reference: [36] <author> E. Shapiro and A. Takeuchi. </author> <title> Object-Oriented Programming in Concurrent Prolog. </title> <editor> In Ehud Shapiro, editor, </editor> <title> Concurrent Prolog: </title> <booktitle> Collected Papers, </booktitle> <volume> volume 2, chapter 21. </volume> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Such optimizations are key to efficient implementations of pure object-oriented languages [10, 13].) 3. The work in the logic programming community on integrating constraints with logic programming, and on doing object-oriented programming in a concurrent logic programming framework <ref> [23, 24, 36] </ref>, is quite relevant to the task at hand. However, for the current experiment, we wish to remain rooted in the imperative, object-oriented world; we do not set as a goal supporting logic variables or backtracking.
Reference: [37] <author> Remco C. Veltkamp. </author> <title> A Quantum Approach to Geometric Constraint Satisfaction. </title> <booktitle> In Preprints of the Second Eurographics Workshop on Object Oriented Graphics, </booktitle> <pages> pages 53-67, </pages> <address> Texel, The Netherlands, </address> <month> June </month> <year> 1991. </year> <note> To be published in revised form by Springer-Verlag. </note>
Reference-contexts: Representative examples of systems that use this new solver approach are the constraint systems for graphical objects described in [25] and <ref> [37] </ref>.
Reference: [38] <author> William W. Wadge and Edward A. Ashcroft. </author> <title> Lucid, the Dataflow Programming Language. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1985. </year>
Reference: [39] <author> Michael Wilk. Equate: </author> <title> An Object-Oriented Constraint Solver. </title> <booktitle> In Proceedings of the 1991 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 286-298, </pages> <address> Phoenix, </address> <month> October </month> <year> 1991. </year> <month> 17 </month>
Reference-contexts: More importantly, graph rewriting is a fundamentally different execution model from the standard imperative one, bringing this technique in conflict with goal 3. The first programming language to use graph rewriting to integrate objects and constraints is Bertrand [29]; later systems of this type are Equate <ref> [39] </ref>, and Siri [20]. A primary design goal of Equate is preserving object encapsulation in the internal operation of the constraint satisfier, which, as noted above, we view as an inappropriate goal.
References-found: 39

