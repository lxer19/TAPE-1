URL: ftp://ftp.cs.utah.edu/pub/banavar/etyma.ps.Z
Refering-URL: http://www.cs.utah.edu/~gary/MSO-publications.html
Root-URL: 
Email: fbanavar,lindstrom,dbog@cs.utah.edu  
Phone: Phone +1-801-581-8378, fax +1-801-581-5843.  
Title: Etyma: A Framework for Modular Systems  
Author: Guruduth Banavar Gary Lindstrom Douglas Orr 
Note: This research was sponsored by the Defense Advanced Research Projects Agency (DOD), monitored by the Department of the Navy, Office of the Chief of Naval Research, under Grant number N00014-91-J-4046 and by the Department of the Army under Grant number DABT63-94-C-0058. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing official policies, either expressed or implied, of the Defense Advanced Research Projects Agency or the US Government. Primary contact author.  
Address: Salt Lake City, UT 84112 USA  
Affiliation: Department of Computer Science University of Utah,  
Abstract: Modularity, i.e. support for the flexible construction, adaptation, and combination of units of software, is an important goal in many systems. In most cases, however, systems achieve only a few aspects of modularity. The problem can be traced to the inflexibility, or the limited view of modularity taken by the underlying architecture of these systems. As a remedy, we show that the notions fundamental to object-oriented programming, i.e. classes and inheritance, can be formulated as a simple meta-level architecture that can be effectively reused in a wide variety of contexts. We have realized such an architecture as an O-O framework, and constructed two significant and distinct completions of it. Systems based on this framework benefit not only from design and code reuse, but also from the flexibility that the architecture offers. In addition, the architecture represents a unification of the fundamental ideas of several similar but subtly different module systems. 
Abstract-found: 1
Intro-found: 1
Reference: [BC90] <author> Gilad Bracha and William Cook. </author> <title> Mixin-based inheritance. </title> <booktitle> In Proc. OOPSLA Conference, </booktitle> <address> Ottawa, </address> <month> October </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: The module operators and their semantics will become clearer as we progress through the paper. Bracha and Lindstrom [BL92, Bra92] have given a rigorous formal semantics for Jigsaw's module manipulation, building on the work of Cardelli, Cook, and others <ref> [HP91, CM89, CP89, BC90] </ref>. They have formulated Jigsaw in such a way that it does not prescribe the computational domain, or the control structures, or even the surface syntax of the concrete language in which it is used.
Reference: [BCC + 94] <author> J. Barton, P. Charles, Y. Chee, M. Karasick, D. Lieber, and L. Nackman. Codestore: </author> <title> Infrastructure for C++ knowledgeable tools. </title> <booktitle> Presented at the O-O Compilation Workshop at OOPSLA, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: Compiler frameworks fall into two categories: those that represent programs syntactically such as [WBG94], and those that represent programs semantically, such as ours. Compiler frameworks are designed with various objectives, such as for representing abstract syntax, constructing tools for programming environments <ref> [BCC + 94] </ref>, or for structuring the compiler itself, e.g. with objects representing phases of the compiler [GR83], or for enabling compile-time reflection via 18 meta-object protocols [KLM94].
Reference: [BL92] <author> Gilad Bracha and Gary Lindstrom. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proc. International Conference on Computer Languages, </booktitle> <pages> pages 282-290, </pages> <address> San Francisco, CA, </address> <month> April 20-23, </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal> <note> Also available as Technical Report UUCS-91-017. </note>
Reference-contexts: We believe we have designed such a model, based on an austere notion of classes coupled with a powerful suite of operators to manipulate them, borrowed from a module manipulation language called Jigsaw <ref> [BL92] </ref>. We have designed an O-O framework called Etyma that incorporates this notion of classes as well as abstractions covering much of the value space and type space commonly found in module-based languages. <p> The module operators and their semantics will become clearer as we progress through the paper. Bracha and Lindstrom <ref> [BL92, Bra92] </ref> have given a rigorous formal semantics for Jigsaw's module manipulation, building on the work of Cardelli, Cook, and others [HP91, CM89, CP89, BC90].
Reference: [BL94] <author> Guruduth Banavar and Gary Lindstrom. </author> <booktitle> The design of object-oriented meta-architectures for programming languages. In Proc. Third Golden West International Conference on Intelligent Systems, </booktitle> <address> Las Vegas, NV, </address> <month> June </month> <year> 1994. </year> <note> Also available as Technical Report UUCS-94-033. </note>
Reference-contexts: Etyma is a meta-level language architecture similar to those of familiar languages such as Smalltalk and CLOS MOP. It has the same advantages of enabling the construction of reflective, flexible, and extensible programming systems <ref> [BL94] </ref>. However, the differences are crucial. Firstly, and most importantly, classes and inheritance in most systems are composite notions serving many purposes. In Etyma, classes are very simple units of software that can be composed using a powerful set of operators.
Reference: [BLO94] <author> Guruduth Banavar, Gary Lindstrom, and Douglas Orr. </author> <title> Type-safe composition of object modules. </title> <booktitle> In Computer Systems and Education, </booktitle> <pages> pages 188-200. </pages> <publisher> Tata McGraw Hill Publishing Company, Limited, </publisher> <address> New Delhi, India, </address> <month> June 22-25, </month> <year> 1994. </year> <note> ISBN 0-07-462044-4. Also available as Technical Report UUCS-94-001. </note>
Reference-contexts: Such type-safe linkage of object files is described in detail in <ref> [BLO94] </ref>. Another completion of the type framework of Etyma is described in the following section. 5 An Interface Definition Language This section describes an interface definition language based on the CORBA IDL (as specified in [COR91]) that we are currently designing as another completion of Etyma 3 .
Reference: [Bra92] <author> Gilad Bracha. </author> <title> The Programming Language Jigsaw : Mixins, Modularity and Multiple Inheritance. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> March </month> <year> 1992. </year> <note> Technical report UUCS-92-007; 143 pp.; ONR 94:1 report. </note>
Reference-contexts: The module operators and their semantics will become clearer as we progress through the paper. Bracha and Lindstrom <ref> [BL92, Bra92] </ref> have given a rigorous formal semantics for Jigsaw's module manipulation, building on the work of Cardelli, Cook, and others [HP91, CM89, CP89, BC90].
Reference: [Bru92] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design static typing and semantics. </title> <type> Technical Report CS-92-01, </type> <institution> Williams College, </institution> <month> January 31, </month> <year> 1992. </year>
Reference-contexts: Expressions which are evaluators can only be replaced with expressions whose types are subtypes of the original, while expressions which are acceptors can only be replaced by expressions whose types are supertypes of the original <ref> [Bru92] </ref>. As a result, subtyping of variables is always restricted to type equivalence. Classes StdInterface and RecordType support structural typing, in which the names and types of attributes, but not their order, is significant for type checking . <p> In conclusion, we note that operations on IDL interfaces as defined above can hardly be described as inheritance, since there is no notion of self-reference in the interfaces. We are currently working on incorporating notions such as SelfType <ref> [Bru92] </ref> that introduce recursion into interfaces. The ability to refer to the type of an interface in the specification of its own attributes using SelfType is similar to a class' ability to refer to self.
Reference: [Cha89] <author> Craig Chambers. </author> <title> Customization: Optimizing compiler technology for self, a dynamically typed object-oriented programming language. </title> <booktitle> In SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <volume> Jun 21 - 23, </volume> <year> 1989. </year>
Reference-contexts: Attributes in lexically surrounding scopes are accessed via parent. The inherited msg-send method implements the message sending operation as described earlier. Of course, the method can be refined to incorporate alternate, more efficient dispatch mechanisms <ref> [Cha89] </ref> in other concrete subclasses. Reference to self is an important aspect of O-O programming. Self-reference indirection enables dynamic binding, which in turn enables polymorphism. Self-reference occurs within methods. Methods, i.e. function-valued module attributes, are modeled in Etyma using StdFunction, a concrete subclass of class Function.
Reference: [Cha92] <author> Steve Chamberlain. libbfd. </author> <title> Free Software Foundation, Inc. Contributed by Cygnus Support, </title> <month> March </month> <year> 1992. </year> <month> 20 </month>
Reference-contexts: The above two kinds of information are basically sufficient to implement the module operations of Etyma. Class DotO delegates its operations to class ObjFile which operates on the internal format of dot-o symbol tables and relocation using the BFD package <ref> [Cha92] </ref>. Most module operations are transformations on the symbol table of the object file. The merge operation on a DotO is equivalent to traditional linking, but without fixing relocations. Declarations are matched up with definitions, and conflicting (multiply defined) symbols are flagged as an error.
Reference: [CIJ + 91] <author> Roy H. Campbell, Nayeem Islam, Ralph Johnson, Panos Kougiouris, and Peter Madany. </author> <title> Choices, frameworks and refinement. </title> <booktitle> In Object Orientation in Operating Systems, </booktitle> <pages> pages 9-15, </pages> <address> Palo Alto, CA, </address> <month> October </month> <year> 1991. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: We leave this as future work. 6 Related Work Several O-O frameworks have been developed, initially for user interfaces, and subsequently for many other domains as well <ref> [Deu89, VL89, WGM88, CIJ + 91] </ref>. Etymahas a close relationship to compiler frameworks, which comprise classes usually for generating an internal representation of programs. Compiler frameworks fall into two categories: those that represent programs syntactically such as [WBG94], and those that represent programs semantically, such as ours.
Reference: [CM89] <author> Luca Cardelli and John C. Mitchell. </author> <title> Operations on records. </title> <type> Technical Report 48, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: The module operators and their semantics will become clearer as we progress through the paper. Bracha and Lindstrom [BL92, Bra92] have given a rigorous formal semantics for Jigsaw's module manipulation, building on the work of Cardelli, Cook, and others <ref> [HP91, CM89, CP89, BC90] </ref>. They have formulated Jigsaw in such a way that it does not prescribe the computational domain, or the control structures, or even the surface syntax of the concrete language in which it is used. <p> This models instances. Consequently, an instance "IS-A" record. Class Record models the classical notion of records: functions from labels to values, with no self-reference. Record supports operations such as merge and restrict, similar to the ones found in <ref> [CM89, HP91] </ref>. In particular, the method select (Label) models attribute selection. Class Instance supports operations similar to Record. In addition, class Instance models the traditional O-O notion of sending a message (dynamic dispatch) to an object as select'ing a function-valued attribute followed by invoking eval on the returned function object.
Reference: [COR91] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <month> December </month> <year> 1991. </year> <note> Revision 1.1. </note>
Reference-contexts: This is in addition to its more obvious use for building a processor for a new language. We describe the design of an object system layered on top of ANSI 1 C in Section 4, as well as an extended CORBA Interface Definition Language <ref> [COR91] </ref> in Section 5. In Section 2, we introduce our model of classes and inheritance and describe its realization in the design of the abstract and concrete classes of the Etyma framework in Section 3. <p> Such type-safe linkage of object files is described in detail in [BLO94]. Another completion of the type framework of Etyma is described in the following section. 5 An Interface Definition Language This section describes an interface definition language based on the CORBA IDL (as specified in <ref> [COR91] </ref>) that we are currently designing as another completion of Etyma 3 . In the context of distributed systems, an IDL is a descriptive language used to specify the interfaces that client objects call, and service providing objects implement.
Reference: [CP89] <author> William Cook and Jen Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In Proc. ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications, </booktitle> <pages> pages 433-444, </pages> <year> 1989. </year>
Reference-contexts: The module operators and their semantics will become clearer as we progress through the paper. Bracha and Lindstrom [BL92, Bra92] have given a rigorous formal semantics for Jigsaw's module manipulation, building on the work of Cardelli, Cook, and others <ref> [HP91, CM89, CP89, BC90] </ref>. They have formulated Jigsaw in such a way that it does not prescribe the computational domain, or the control structures, or even the surface syntax of the concrete language in which it is used.
Reference: [Deu89] <author> L. Peter Deutsch. </author> <title> Design reuse and frameworks in the Smalltalk-80 programming system. </title> <editor> In Ted J. Biggerstaff and Alan J. Perlis, editors, </editor> <booktitle> Software Reusability, </booktitle> <volume> volume 2, </volume> <pages> pages 55-71. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: We leave this as future work. 6 Related Work Several O-O frameworks have been developed, initially for user interfaces, and subsequently for many other domains as well <ref> [Deu89, VL89, WGM88, CIJ + 91] </ref>. Etymahas a close relationship to compiler frameworks, which comprise classes usually for generating an internal representation of programs. Compiler frameworks fall into two categories: those that represent programs syntactically such as [WBG94], and those that represent programs semantically, such as ours.
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Access to super methods is achieved with the application of the copy-as operator to superclass methods, as illustrated in Figure 1. Furthermore, static binding of self-references, akin to non-virtual member functions of C++ <ref> [ES90] </ref>, is achieved via the operator freeze.
Reference: [GHJV95] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. Professional Computing Series. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1995. </year>
Reference-contexts: Section 3.1 presents the abstract classes in Etyma, Section 3.2 presents some concrete classes, and Section 3.3 presents type-system related classes. These sections together describe Etyma. Throughout the paper, we use the diagramming conventions 1 as well as the concept of design patterns introduced in <ref> [GHJV95] </ref> to describe Etyma. 3.1 Abstract Classes TypedValue are abstract superclasses that model the linguistic domains of types and values respectively. Etyma models strong typing; hence concrete subclasses of TypedValue are expected to return their concrete type object (see Section 3.3) when queried via type-of ().
Reference: [Gin89] <author> Robert A. Gingell. </author> <title> Shared libraries. </title> <journal> Unix Review, </journal> <volume> 7(8) </volume> <pages> 56-66, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: The particular variety of IPC to be used for generating sending and receiving stubs, e.g. DCE or CORBA, is specified as an extra argument (IPCStyle) to the select methods. 4.3 Modeling Libraries Traditionally, libraries with various semantics are dealt with by linkers and loaders <ref> [Gin89, See90] </ref>. Hence, it is necessary for OMOS to model and manipulate libraries. Archives are a common kind of library, e.g. libc.a on UNIX systems.
Reference: [Gor79] <author> Michael J. C. Gordon. </author> <title> The Denotational Description of Programming Languages. </title> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: A distinguishing feature of Etyma is that its design has been guided mainly by a formal description (i.e. denotational semantics and type rules) of the corresponding linguistic concepts. The reader might have noted the correspondence between the above framework abstraction design and denotational models of programming languages <ref> [Gor79] </ref>. Denotational semantics applies functional programming to abstract over language functionality. Here, we apply a denotational description of modularity to abstract over language modularity.
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Compiler frameworks are designed with various objectives, such as for representing abstract syntax, constructing tools for programming environments [BCC + 94], or for structuring the compiler itself, e.g. with objects representing phases of the compiler <ref> [GR83] </ref>, or for enabling compile-time reflection via 18 meta-object protocols [KLM94]. Etyma, while supporting many of the above, is unique in that it is intended to be a reusable architecture for constructing a variety of modular systems. The Smalltalk-80 system [GR83] is built upon a set of compiler classes that support <p> compiler itself, e.g. with objects representing phases of the compiler <ref> [GR83] </ref>, or for enabling compile-time reflection via 18 meta-object protocols [KLM94]. Etyma, while supporting many of the above, is unique in that it is intended to be a reusable architecture for constructing a variety of modular systems. The Smalltalk-80 system [GR83] is built upon a set of compiler classes that support representing the abstract syntax of programs, as well as an impressive collection of highly intertwined meta-classes that represent the semantics.
Reference: [HP91] <author> Robert Harper and Benjamin Pierce. </author> <title> A record calculus based on symmetric concatenation. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 131-142, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The module operators and their semantics will become clearer as we progress through the paper. Bracha and Lindstrom [BL92, Bra92] have given a rigorous formal semantics for Jigsaw's module manipulation, building on the work of Cardelli, Cook, and others <ref> [HP91, CM89, CP89, BC90] </ref>. They have formulated Jigsaw in such a way that it does not prescribe the computational domain, or the control structures, or even the surface syntax of the concrete language in which it is used. <p> This models instances. Consequently, an instance "IS-A" record. Class Record models the classical notion of records: functions from labels to values, with no self-reference. Record supports operations such as merge and restrict, similar to the ones found in <ref> [CM89, HP91] </ref>. In particular, the method select (Label) models attribute selection. Class Instance supports operations similar to Record. In addition, class Instance models the traditional O-O notion of sending a message (dynamic dispatch) to an object as select'ing a function-valued attribute followed by invoking eval on the returned function object.
Reference: [JR91] <author> Ralph E. Johnson and Vincent F. Russo. </author> <title> Reusing object-oriented designs. </title> <type> Technical Report UIUCDCS 91-1696, </type> <institution> University of Illinois at Urbana-Champagne, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: Such a framework then defines a meta-level language architecture applicable to modular systems. In essence, an O-O framework is an O-O model that captures the essential abstractions in a particular application domain <ref> [JR91] </ref>. It expresses the architecture of applications in the domain in terms of objects and interactions between them. Frameworks allow developers to build applications effectively by concretizing abstract classes in the framework via inheritance and by configuring, i.e. 3 connecting instances of, predefined concrete classes in the framework.
Reference: [KdRB91] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: However, its dynamic meta-circular architecture is tightly coupled with the environment, making it difficult to disentangle the architecture for separate reuse. The Common Lisp Object System Meta-Object Protocol (CLOS MOP) <ref> [KdRB91] </ref> supports user-redefinable protocols for meta-objects such as class, instance, generic function, method, etc. CLOS MOP provides the basis for the development of a "space of languages with the default language being a distinguished point in the space." So, in a sense, its architecture is reusable.
Reference: [KLM94] <author> Gregor Kiczales, John Lamping, and Anurag Mendhekar. </author> <title> What a metaobject protocol based compiler can do for lisp. </title> <note> Unpublished report. A modified version to be presented at the OOPSLA '94 workshop on O-O Compilation., </note> <year> 1994. </year>
Reference-contexts: Compiler frameworks are designed with various objectives, such as for representing abstract syntax, constructing tools for programming environments [BCC + 94], or for structuring the compiler itself, e.g. with objects representing phases of the compiler [GR83], or for enabling compile-time reflection via 18 meta-object protocols <ref> [KLM94] </ref>. Etyma, while supporting many of the above, is unique in that it is intended to be a reusable architecture for constructing a variety of modular systems.
Reference: [Lee92] <author> Arthur H. Lee. </author> <title> The Persistent Object System MetaStore: Persistence Via Metaprogramming. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> June </month> <year> 1992. </year> <note> Technical report UUCS-92-027; 171 pp. </note>
Reference-contexts: Etyma is specifically designed to facilitate the construction of modular systems, but can be used for many purposes that the CLOS MOP has been put to use, notably persistent objects <ref> [Lee92] </ref>. 7 Conclusions and Future Work We have characterized object-oriented programming as the adaptation and combination of a simple notion of classes, called modules. A meta-level architecture for modular systems, realized as a reusable object-oriented framework called Etyma has been described.
Reference: [OBLM93] <author> Douglas Orr, John Bonn, Jay Lepreau, and Robert Mecklenburg. </author> <title> Fast and flexible shared libraries. </title> <booktitle> In Proc. USENIX Summer Conference, </booktitle> <pages> pages 237-251, </pages> <address> Cincinnati, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: This facility is used as the basis for system program execution and shared libraries <ref> [OBLM93] </ref>. Since OMOS is an active entity (a server), it is capable of performing sophisticated module manipulations on each instantiation of a module. Evaluation of a ModuleSpec object could potentially produce different results each time.
Reference: [OM92] <author> Douglas B. Orr and Robert W. Mecklenburg. </author> <title> OMOS | An object server for program execution. </title> <booktitle> In Proc. International Workshop on Object Oriented Operating Systems, </booktitle> <pages> pages 200-209, </pages> <address> Paris, </address> <month> September </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal> <note> Also available as technical report UUCS-92-033. </note>
Reference-contexts: Such tools enable the use of structuring and composition techniques such as O-O inheritance on what are traditionally viewed as rigid system artifacts. We have designed just such a tool, a second-generation programmable linker called OMOS (Object/Meta-Object Server) <ref> [OM92] </ref>, as a completion of Etyma. OMOS is designed as a continuously running server that not only manipulates modules, but also constructs instances and maps them into process address spaces, possibly after performing various optimizations. This section describes the design of OMOS's module manipulation functionality.
Reference: [OMHL93] <author> Douglas B. Orr, Robert W. Mecklenburg, Peter J. Hoogenboom, and Jay Lepreau. </author> <title> Dynamic program monitoring and transformation using the OMOS object server. </title> <booktitle> In Proc. of the 26th Hawaii International Conference on System Sciences, </booktitle> <pages> pages 232-241, </pages> <month> January </month> <year> 1993. </year> <note> Also available as technical report UUCS-92-034. 21 </note>
Reference: [OMHL94] <author> Douglas B. Orr, Robert W. Mecklenburg, Peter J. Hoogenboom, and Jay Lepreau. </author> <title> Dynamic program monitoring and transformation using the OMOS object server. In The Interaction of Compilation Technology and Computer Architecture. </title> <publisher> Kluwer Academic Publishers, </publisher> <month> February </month> <year> 1994. </year>
Reference-contexts: Module expressions that use operations such as the above can perform several useful transformations on programs at link-time <ref> [OMHL94] </ref>. For example, monitoring a program involves transforming the program so that each defined procedure is transparently wrapped with an outer routine that monitors entry to and exit from the procedure. The wrapper can be generated automatically. <p> Since OMOS is an active entity (a server), it is capable of performing sophisticated module manipulations on each instantiation of a module. Evaluation of a ModuleSpec object could potentially produce different results each time. Some OMOS operations such as those used to implement program monitoring and reordering <ref> [OMHL94] </ref> enact program transformations using operations on module expressions themselves. Since OMOS is capable of performing potentially complex manipulations on each invocation, it caches the results of most operations to avoid re-doing work unnecessarily.
Reference: [See90] <author> Donn Seeley. </author> <title> Shared libraries as objects. </title> <booktitle> In Proc. USENIX Summer Conference, </booktitle> <address> Anaheim, CA, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: The particular variety of IPC to be used for generating sending and receiving stubs, e.g. DCE or CORBA, is specified as an extra argument (IPCStyle) to the select methods. 4.3 Modeling Libraries Traditionally, libraries with various semantics are dealt with by linkers and loaders <ref> [Gin89, See90] </ref>. Hence, it is necessary for OMOS to model and manipulate libraries. Archives are a common kind of library, e.g. libc.a on UNIX systems.
Reference: [VL89] <author> John M. Vlissides and Mark A. Linton. Unidraw: </author> <title> a framework for building domain-specific graphical editors. </title> <booktitle> In Proceedings of the ACM User Interface Software and Technologies '89 Conference, </booktitle> <pages> pages 81-94, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: We leave this as future work. 6 Related Work Several O-O frameworks have been developed, initially for user interfaces, and subsequently for many other domains as well <ref> [Deu89, VL89, WGM88, CIJ + 91] </ref>. Etymahas a close relationship to compiler frameworks, which comprise classes usually for generating an internal representation of programs. Compiler frameworks fall into two categories: those that represent programs syntactically such as [WBG94], and those that represent programs semantically, such as ours.
Reference: [WBG94] <author> Beata Winnicka, Francois Bodin, and Dennis Gannon. </author> <title> C++ objects for representing and manipulating program trees in the Sage++ system. </title> <booktitle> Presented at the O-O Compilation Workshop at OOPSLA, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: Etymahas a close relationship to compiler frameworks, which comprise classes usually for generating an internal representation of programs. Compiler frameworks fall into two categories: those that represent programs syntactically such as <ref> [WBG94] </ref>, and those that represent programs semantically, such as ours.
Reference: [WGM88] <author> A. Weinand, E. Gamma, and R. Marty. ET++: </author> <title> an object-oriented application framework in C++. </title> <booktitle> In Proceedings of OOPSLA '88, </booktitle> <pages> pages 46-57. </pages> <publisher> ACM, </publisher> <month> November </month> <year> 1988. </year> <note> Last revised December 2, 1994 22 </note>
Reference-contexts: We leave this as future work. 6 Related Work Several O-O frameworks have been developed, initially for user interfaces, and subsequently for many other domains as well <ref> [Deu89, VL89, WGM88, CIJ + 91] </ref>. Etymahas a close relationship to compiler frameworks, which comprise classes usually for generating an internal representation of programs. Compiler frameworks fall into two categories: those that represent programs syntactically such as [WBG94], and those that represent programs semantically, such as ours.
References-found: 32

