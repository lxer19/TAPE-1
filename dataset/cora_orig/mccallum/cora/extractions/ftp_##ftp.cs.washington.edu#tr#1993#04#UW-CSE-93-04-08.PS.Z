URL: ftp://ftp.cs.washington.edu/tr/1993/04/UW-CSE-93-04-08.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Email: sitaram@cs.washington.edu  
Title: An Automatic Verification Technique for Communicating Real-Time State Machines  
Author: Sitaram C. V. Raju 
Keyword: automatic verification, deadlock, model checking, reachability, real-time, requirements specification.  
Address: Seattle WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: We describe an automatic verification technique for distributed real-time systems that are specified as Communicating Real-Time State Machines (CRSMs). CRSMs are timed state machines that communicate synchronously over uni-directional channels. The proposed approach is to model the behavior of the system of (an expressive subclass of) CRSMs by a timed reachability graph. The system behavior of CRSMs is characterized by a time-stamped trace of communication events. We provide a decision procedure for verifying timing and safety properties (specified in a notation based on Real-Time Logic) of the reachability graph, and hence of the corresponding system of CRSMs. We also present a condition for the existence of deadlock in a system of CRSMs. Finally, we briefly describe an implementation of a verifier program based on the above algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur and D. Dill, </author> <title> "The Theory of Timed Automata", Real-Time: </title> <booktitle> Theory in Practice, Proc. REX Workshop, </booktitle> <volume> LNCS 600, </volume> <pages> pages 45-73, </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: Subtle timing or functional errors in a real-time system can potentially cause loss of life or can be hazardous to the physical environment. To cope with such problems, formal methods <ref> [1, 3, 5, 7, 9] </ref> have been developed to specify real-time systems and to verify their properties. fl This research was supported in part by NSF under grant number CCR-9200858. 1 In this paper, we describe an automatic verification technique for distributed real-time systems using Communicating Real-Time State Machines (CRSMs). <p> A simple way of avoiding this pathological case is by ensuring that the time bounds of all commands is non-zero. Note that in Figure 2 even though state h1 has self-loops with the default time intervals <ref> [0; 1] </ref>, the synchronization requirement with the Recognizer machine (Formula 1) ensures that the time spent in state h1 is always non-zero. 3 Constructing a Finite Reachability Graph A reachability graph contains all possible states that can be reached starting from the start state of the system. <p> This is in contrast with CRSMs, where inputs can be blocked until the machine reaches an appropriate state. Also, we are not aware of a mechanical procedure for verification of timed I/O automata. Timed Automata <ref> [1] </ref> is a specification method that uses continuous, or dense, time instead of discrete time. Another major difference between timed automata and CRSMs is that timed automata do not permit data variables, and arbitrary expressions on time bounds of transitions and assignment statements.
Reference: [2] <author> R. Alur et al., </author> <title> "An Implementation of Three Algorithms for Timing Verification Based on Automata Emptiness", </title> <booktitle> Proc. IEEE Real-Time Systems Symp., </booktitle> <pages> pages 157-166, </pages> <publisher> IEEE Computer Soc. Press, </publisher> <month> Dec </month> <year> 1992. </year>
Reference-contexts: A concern with our verification method (as with many other mechanical verification techniques) is that the reachability graphs may be too big for realistic systems. We are considering techniques such as partial graph generation and minimal model checking <ref> [2] </ref> to ameliorate the problem. 7 Related Work We give a brief survey and comparison of verification techniques for specification methods that are state machine based, because these methods are most closely related to our work.
Reference: [3] <author> H. Attiya and N. A. Lynch, </author> <title> "Time Bounds for Real-Time Process Control in the Presence of Timing Uncertainty", </title> <booktitle> Proc. IEEE Real-Time Systems Symp., </booktitle> <pages> pages 268-284, </pages> <publisher> IEEE Computer Soc. Press, </publisher> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: Subtle timing or functional errors in a real-time system can potentially cause loss of life or can be hazardous to the physical environment. To cope with such problems, formal methods <ref> [1, 3, 5, 7, 9] </ref> have been developed to specify real-time systems and to verify their properties. fl This research was supported in part by NSF under grant number CCR-9200858. 1 In this paper, we describe an automatic verification technique for distributed real-time systems using Communicating Real-Time State Machines (CRSMs). <p> CPU constraints) in a real-time system. A reachability analyzer for CSP is described in [5]. CSR appears to have no provision for performing computations in commands. Also, time is not associated with IO. Timed IO automata <ref> [3] </ref> have some similarities with CRSMs in that their transitions can be one of input, output or internal actions, but the detailed definitions of transitions are different. For example, timed I/O automata are input enabled, which means that they are unable to block inputs. <p> Finally, the new model of time in CRSMs (both for describing the passage of time and for specifying timeouts) also distinguishes the model from the ones listed above. Traces are used for reasoning about the behavior of general systems in [8], and for real-time systems in <ref> [3, 10, 11] </ref>. Our method of reasoning with traces is noteworthy because it is based on RTL.
Reference: [4] <author> M. R. Garey and D. S. Johnson, </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness, </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <year> 1979. </year>
Reference-contexts: In the above algorithm, finding all maximal matchings is intractable. This is established by the following theorem. Theorem 1 Finding all maximal matchings in a graph is NP-hard. Proof: By restricting to the Minimum Maximal Matching (MMM) problem <ref> [4] </ref>.
Reference: [5] <author> R. Gerber and I. Lee, </author> <title> "A Layered Approach to Automating the Verification of Real-Time Systems", </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 18,9, </volume> <pages> pages 768-784, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: Subtle timing or functional errors in a real-time system can potentially cause loss of life or can be hazardous to the physical environment. To cope with such problems, formal methods <ref> [1, 3, 5, 7, 9] </ref> have been developed to specify real-time systems and to verify their properties. fl This research was supported in part by NSF under grant number CCR-9200858. 1 In this paper, we describe an automatic verification technique for distributed real-time systems using Communicating Real-Time State Machines (CRSMs). <p> This value is used as the time interval ([x; 1]) on the succeeding transition to generate the U event. This trick, which is a form of parameterization of the system, generates U event at different times. 4 down up SC? timer? <ref> [5] </ref> SC![0] home U? [0,10] RECOGNIZER MOUSE h1 U? timer? [10] D? [0,5] U? timer? [10] D? HANDLER get_x - else - - - if (x == 10) - x = 10; 5 Every CRSM has a discrete-time clock machine that can be queried for the value of current time over <p> Communicating Shared Resources (CSR) is a formalism that is also based on CSP. An interesting aspect of CSR is that it permits the specification of resource constraints (e.g. CPU constraints) in a real-time system. A reachability analyzer for CSP is described in <ref> [5] </ref>. CSR appears to have no provision for performing computations in commands. Also, time is not associated with IO. Timed IO automata [3] have some similarities with CRSMs in that their transitions can be one of input, output or internal actions, but the detailed definitions of transitions are different.
Reference: [6] <author> F. Jahanian and A. Mok, </author> <title> "Safety Analysis of Timing Properties in Real-Time Systems", </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 12, 9, </volume> <pages> pages 890-904, </pages> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: The properties are specified in an assertion language that is a programming extension of Real-Time Logic (RTL) <ref> [6] </ref>. The assertion language was first presented in [10], and was shown to be useful for checking properties of a trace of simulation events. <p> Decision procedures developed for these logics (or for a subset of these logics) can be used to determine if our reachability graphs satisfy a given property. In this section we specify properties using an assertion language that is a programming extension of Real-Time Logic (RTL) <ref> [6] </ref>. The assertion language was introduced in [10], and was shown to be useful for checking properties of a trace of simulation events. As mentioned earlier (Section 1) the use of a common assertion language for simulation and verification is advantageous.
Reference: [7] <author> F. Jahanian and D. A. Stuart, </author> <title> "A Method for Verifying Properties of Modechart Specifications", </title> <booktitle> Proc. IEEE Real-Time Systems Symp., </booktitle> <pages> pages 12-21, </pages> <publisher> IEEE Computer Soc. Press, </publisher> <month> Dec </month> <year> 1988. </year>
Reference-contexts: Subtle timing or functional errors in a real-time system can potentially cause loss of life or can be hazardous to the physical environment. To cope with such problems, formal methods <ref> [1, 3, 5, 7, 9] </ref> have been developed to specify real-time systems and to verify their properties. fl This research was supported in part by NSF under grant number CCR-9200858. 1 In this paper, we describe an automatic verification technique for distributed real-time systems using Communicating Real-Time State Machines (CRSMs). <p> An example of such a procedure is determining if all nodes in a reachability graph satisfy a certain property, i.e., invariant checking. Many logics have been proposed to express properties of real-time systems (for example RTL <ref> [7] </ref>, RTTL [9]). Decision procedures developed for these logics (or for a subset of these logics) can be used to determine if our reachability graphs satisfy a given property. In this section we specify properties using an assertion language that is a programming extension of Real-Time Logic (RTL) [6]. <p> Modechart is a specification language that partitions the state space of a real-time sys 21 tem into modes. A verification method for Modechart is presented in <ref> [7] </ref>. Unlike CRSMs, Modechart does not allow IO events to have message components. Also, Modechart uses a shared memory model (with broadcast for event communication), whereas CRSMs present a distributed model. In addition, the time bounds on transitions in Modechart are constants, whereas CRSMs permit arbitrary expressions.
Reference: [8] <author> C. A. R. Hoare, </author> <title> Communicating Sequential Processes, </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1985. </year>
Reference-contexts: Double clicks do not overlap and they override single clicks. The CRSM model is a distributed one, except for a single shared variable representing the current time. CRSMs are timed state machines that run concurrently except when they need to communicate. Machines communicate synchronously (as in CSP <ref> [8] </ref>) and instantaneously through messages over uni-directional channels. The set of machines for the mouse clicker and its physical environment is shown in Figure 1. The Mouse and Handler machines describe the behavior of the physical environment and the Recognizer machine describes the real-time system. <p> Finally, the new model of time in CRSMs (both for describing the passage of time and for specifying timeouts) also distinguishes the model from the ones listed above. Traces are used for reasoning about the behavior of general systems in <ref> [8] </ref>, and for real-time systems in [3, 10, 11]. Our method of reasoning with traces is noteworthy because it is based on RTL.
Reference: [9] <author> J. S. Ostroff, </author> <title> "Real-Time Temporal Logic Decision Procedures", </title> <booktitle> Proc. IEEE Real-Time Systems Symp., </booktitle> <pages> pages 92-101, </pages> <publisher> IEEE Computer Soc. Press, </publisher> <month> Dec </month> <year> 1989. </year>
Reference-contexts: Subtle timing or functional errors in a real-time system can potentially cause loss of life or can be hazardous to the physical environment. To cope with such problems, formal methods <ref> [1, 3, 5, 7, 9] </ref> have been developed to specify real-time systems and to verify their properties. fl This research was supported in part by NSF under grant number CCR-9200858. 1 In this paper, we describe an automatic verification technique for distributed real-time systems using Communicating Real-Time State Machines (CRSMs). <p> An example of such a procedure is determining if all nodes in a reachability graph satisfy a certain property, i.e., invariant checking. Many logics have been proposed to express properties of real-time systems (for example RTL [7], RTTL <ref> [9] </ref>). Decision procedures developed for these logics (or for a subset of these logics) can be used to determine if our reachability graphs satisfy a given property. In this section we specify properties using an assertion language that is a programming extension of Real-Time Logic (RTL) [6].
Reference: [10] <author> S. C. V. Raju and A. C. Shaw, </author> <title> "A Prototyping Environment for Specifying, Executing and Checking Communicating Real-Time State Machines", </title> <type> TR 92-10-03, </type> <institution> Dept. of Computer Science and Eng., University of Washington (submitted for publication). </institution>
Reference-contexts: System behavior is characterized by the time-stamped trace or history of communication events between the machines. Desired properties of the system behavior, including safety and timing constraints, are expressed as properties on the trace of communication events. In an earlier work <ref> [10] </ref> we described a toolset consisting of a graphical editor, a simulator and an assertion checker for prototyping and testing CRSMs. The assertion checker tests for violations over the simulation trace only, i.e., it is not an exhaustive verification technique 1 . <p> We 1 Automatic verification of models as powerful as CRSMs (equivalent to Turing machines) is undecidable. 2 The original model of CRSMs [11] uses continuous time, but the simulator for CRSMs <ref> [10] </ref> uses discrete time because it simplifies some of the implementation details. The choice of discrete time was fortuitous because the use of continuous time will make automatic verification impossible. <p> The properties are specified in an assertion language that is a programming extension of Real-Time Logic (RTL) [6]. The assertion language was first presented in <ref> [10] </ref>, and was shown to be useful for checking properties of a trace of simulation events. <p> By using a common assertion language for both simulation and verification we gain an important advantage: The entire system, which can be too complex to verify (because it is not finite state), can be simulated and the simulation trace tested for timing/safety properties (see <ref> [10] </ref>); and by focusing on a small but critical portion of the system, which is finite state, the same properties that were tested on the simulation trace can now be verified. <p> This trick, which is a form of parameterization of the system, generates U event at different times. 4 down up SC? timer? [5] SC![0] home U? [0,10] RECOGNIZER MOUSE h1 U? timer? <ref> [10] </ref> D? [0,5] U? timer? [10] D? HANDLER get_x - else - - - if (x == 10) - x = 10; 5 Every CRSM has a discrete-time clock machine that can be queried for the value of current time over the timer channel. The Recognizer uses timer? [10] to obtain <p> This trick, which is a form of parameterization of the system, generates U event at different times. 4 down up SC? timer? [5] SC![0] home U? [0,10] RECOGNIZER MOUSE h1 U? timer? <ref> [10] </ref> D? [0,5] U? timer? [10] D? HANDLER get_x - else - - - if (x == 10) - x = 10; 5 Every CRSM has a discrete-time clock machine that can be queried for the value of current time over the timer channel. The Recognizer uses timer? [10] to obtain a timeout after spending 10ms <p> U? timer? <ref> [10] </ref> D? [0,5] U? timer? [10] D? HANDLER get_x - else - - - if (x == 10) - x = 10; 5 Every CRSM has a discrete-time clock machine that can be queried for the value of current time over the timer channel. The Recognizer uses timer? [10] to obtain a timeout after spending 10ms in state d1 and no IO has occurred on channel U. If the timeout and U event occur simultaneously then one of them will be chosen non-deterministically 3 . <p> In this section we specify properties using an assertion language that is a programming extension of Real-Time Logic (RTL) [6]. The assertion language was introduced in <ref> [10] </ref>, and was shown to be useful for checking properties of a trace of simulation events. As mentioned earlier (Section 1) the use of a common assertion language for simulation and verification is advantageous. <p> For example, consider the following simulation trace, : : : (D; 12); (U; 19); (D; 21); (U; 25); (DC; 25) : : : 5 There are some minor differences between the above assertion language and the one described in <ref> [10] </ref>. For example, the time function in [10] returns absolute time and not relative time. 17 start i (a) AIndex ! (i) start i BIndex ! (i) (b) AString ! (x ) BString ! (x ) i i start start AIndex ? (inda) [1, ] AString ? (stra) [1, ] BIndex <p> For example, consider the following simulation trace, : : : (D; 12); (U; 19); (D; 21); (U; 25); (DC; 25) : : : 5 There are some minor differences between the above assertion language and the one described in <ref> [10] </ref>. For example, the time function in [10] returns absolute time and not relative time. 17 start i (a) AIndex ! (i) start i BIndex ! (i) (b) AString ! (x ) BString ! (x ) i i start start AIndex ? (inda) [1, ] AString ? (stra) [1, ] BIndex ? (indb) [1, ] BString ? (strb) <p> A graphics editor has been developed for creating CRSM specifications. The graphical representation is translated into a text form that serves as the input to the verifier. We have used the verifier to check the mouse clicker system (Section 2) and the traffic-light controller described in <ref> [10] </ref>. For the mouse clicker system the verifier generates a reachability graph with 29 nodes in about 50ms. The double click property of the system (Section 4) and another property relating to single-clicks were verified. For the traffic-light controller we checked properties relating to mutual exclusion, delays and deadlines. <p> Finally, the new model of time in CRSMs (both for describing the passage of time and for specifying timeouts) also distinguishes the model from the ones listed above. Traces are used for reasoning about the behavior of general systems in [8], and for real-time systems in <ref> [3, 10, 11] </ref>. Our method of reasoning with traces is noteworthy because it is based on RTL. <p> The graph is also used to detect deadlock in CRSMs. We have a prototype implementation of a verifier program. The verifier along with the simulator program described in <ref> [10] </ref> can be used to prototype, simulate/test and verify distributed real-time systems as follows: The entire real-time system, which may not be finite state (and therefore is difficult to verify), is simulated and tested.
Reference: [11] <author> A. C. Shaw, </author> <title> "Communicating Real-Time State Machines", </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 18,9, </volume> <pages> pages 805-816, </pages> <month> Sept. </month> <year> 1992. </year> <month> 23 </month>
Reference-contexts: CRSMs, introduced in <ref> [11] </ref>, are an executable scheme for specifying the requirements and design of both a real-time system and its physical environment. CRSMs are timed state machines that communicate synchronously over uni-directional channels. <p> We 1 Automatic verification of models as powerful as CRSMs (equivalent to Turing machines) is undecidable. 2 The original model of CRSMs <ref> [11] </ref> uses continuous time, but the simulator for CRSMs [10] uses discrete time because it simplifies some of the implementation details. The choice of discrete time was fortuitous because the use of continuous time will make automatic verification impossible. <p> The condition for the existence of deadlock is given in section 5. Section 6 describes current and future work. Section 7 discusses related work. 2 CRSM: An Informal Introduction As an example to describe the CRSM model we use a variation of the mouse clicker system from <ref> [11] </ref>. The main variation is that the mouse CRSM is more elaborate. The description of the system is: A mouse sends down (D) and up (U) clicks to a recognizer. The mouse clicks correspond to a user depressing the mouse button and releasing the mouse button respectively. <p> In the rest of the paper by CRSMs, we mean our restricted CRSMs, and not the CRSMs as defined in <ref> [11] </ref>. A CRSM is a tuple (S; S 0 ; V; I; O; R; C; T ), where * S is a finite set of states * S 0 2 S is the start state * V is a finite set of integer valued variables. <p> Figure 4 shows the reachability graph for the system of CRSMs. We use the semantics of CRSMs to generate the successors of a node. Reference <ref> [11] </ref> describes a simulation algorithm that serves as the operational semantics of CRSMs; the algorithm chooses a single successor nondeterministically. We now present an extension of the simulation algorithm. <p> Finally, the new model of time in CRSMs (both for describing the passage of time and for specifying timeouts) also distinguishes the model from the ones listed above. Traces are used for reasoning about the behavior of general systems in [8], and for real-time systems in <ref> [3, 10, 11] </ref>. Our method of reasoning with traces is noteworthy because it is based on RTL.
References-found: 11

