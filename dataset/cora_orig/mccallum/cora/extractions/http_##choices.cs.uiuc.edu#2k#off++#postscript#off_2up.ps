URL: http://choices.cs.uiuc.edu/2k/off++/postscript/off_2up.ps
Refering-URL: http://choices.cs.uiuc.edu/2k/
Root-URL: http://www.cs.uiuc.edu
Email: nemo@gsyc.inf.uc3m.es ff-kon,royg@cs.uiuc.edu  
Title: The design and implementation of Off a Distributed Adaptable kernel  
Author: Francisco J. Ballesteros Fabio Kon Roy H. Campbell 
Date: August, 1997  
Abstract: The Off ++ distributed adaptable kernel is a minimal kernel whose only task is to safely multiplex and export the distributed hardware present in the network. It is designed to be used as a basis for distributed user-level OS services. This technical report describes the design and implementation of Off ++, the object-oriented redesign of the Off kernel [2, 3]. Off ++ extends the functionalities provided by Off in order to provide basic support for the 2K operating system [5] we are currently building. This document is meant to be the starting point for the system literate implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Francisco J. Ballesteros. </author> <title> Off web site. </title> <note> http://www.gsyc.inf.uc3m.es/off, 1996. </note>
Reference-contexts: By adopting a strict architecture self-awareness philosophy, we will allow system and user modules to be conscious of its own physical and logical architecture. So, the system will be able to adapt itself optimizing its performance and reliability. This document describes the object oriented redesign of the Off kernel <ref> [2, 3, 1] </ref>, named Off ++, and is meant to be the starting point for its literate implementation (see section 1.3). Off ++ also adds new functionalities to the kernel in order to provide basic support for 2K. <p> They are too precious to allow internal fragmentation (i.e. a single application allocating a super-page and using simply a few pages). hSet predefined values for ith bank. i m_base=0x00000000; m_end =0xfeffffff; switch (i)- case 0: m_first=0x00000000; m_last= 1*MBYTE; m_flags= OFF_MF_DMA|OFF_MF_IOM; m_pgsz [0]= PAGE_SIZE; m_pgsz <ref> [1] </ref>= m_pgsz [2]=m_pgsz [3]=0; m_mat=128; break; case 1: m_first=1*MBYTE; m_last= 16*MBYTE; m_flags= OFF_MF_DMA; m_pgsz [0]= PAGE_SIZE; m_pgsz [1]= m_pgsz [2]=m_pgsz [3]=0; m_mat=128; break; case 2: m_first=16*MBYTE; m_last= 2*GBYTE; m_flags= 0; m_pgsz [0]= PAGE_SIZE; m_pgsz [1]= 4*MBYTE; m_pgsz [2]=m_pgsz [3]=0; m_mat=128; break; default: m_first=m_last=0; - hOff machine dependent memory bank implementation dependencies. <p> application allocating a super-page and using simply a few pages). hSet predefined values for ith bank. i m_base=0x00000000; m_end =0xfeffffff; switch (i)- case 0: m_first=0x00000000; m_last= 1*MBYTE; m_flags= OFF_MF_DMA|OFF_MF_IOM; m_pgsz [0]= PAGE_SIZE; m_pgsz <ref> [1] </ref>= m_pgsz [2]=m_pgsz [3]=0; m_mat=128; break; case 1: m_first=1*MBYTE; m_last= 16*MBYTE; m_flags= OFF_MF_DMA; m_pgsz [0]= PAGE_SIZE; m_pgsz [1]= m_pgsz [2]=m_pgsz [3]=0; m_mat=128; break; case 2: m_first=16*MBYTE; m_last= 2*GBYTE; m_flags= 0; m_pgsz [0]= PAGE_SIZE; m_pgsz [1]= 4*MBYTE; m_pgsz [2]=m_pgsz [3]=0; m_mat=128; break; default: m_first=m_last=0; - hOff machine dependent memory bank implementation dependencies. i+ #include &lt;flux/page.h&gt; // for PAGE_SIZE 226 We have to define the flags used before. hOff machine <p> m_base=0x00000000; m_end =0xfeffffff; switch (i)- case 0: m_first=0x00000000; m_last= 1*MBYTE; m_flags= OFF_MF_DMA|OFF_MF_IOM; m_pgsz [0]= PAGE_SIZE; m_pgsz <ref> [1] </ref>= m_pgsz [2]=m_pgsz [3]=0; m_mat=128; break; case 1: m_first=1*MBYTE; m_last= 16*MBYTE; m_flags= OFF_MF_DMA; m_pgsz [0]= PAGE_SIZE; m_pgsz [1]= m_pgsz [2]=m_pgsz [3]=0; m_mat=128; break; case 2: m_first=16*MBYTE; m_last= 2*GBYTE; m_flags= 0; m_pgsz [0]= PAGE_SIZE; m_pgsz [1]= 4*MBYTE; m_pgsz [2]=m_pgsz [3]=0; m_mat=128; break; default: m_first=m_last=0; - hOff machine dependent memory bank implementation dependencies. i+ #include &lt;flux/page.h&gt; // for PAGE_SIZE 226 We have to define the flags used before. hOff machine dependent memory bank flag bits. i // flag bits for off_mdepMBanks. // They are compatible with resource
Reference: [2] <institution> Francisco J. Ballesteros. OffUn Nuevo Enfoque en la Construccion de Sistemas Operativos Distribuidos. </institution> <type> PhD thesis, </type> <institution> Facultad de Informatica. Universidad Po-litecnica de Madrid, </institution> <year> 1998. </year>
Reference-contexts: By adopting a strict architecture self-awareness philosophy, we will allow system and user modules to be conscious of its own physical and logical architecture. So, the system will be able to adapt itself optimizing its performance and reliability. This document describes the object oriented redesign of the Off kernel <ref> [2, 3, 1] </ref>, named Off ++, and is meant to be the starting point for its literate implementation (see section 1.3). Off ++ also adds new functionalities to the kernel in order to provide basic support for 2K. <p> It is putchar that redirects character output to appropriate places. hputchar implementation. i // Same of stdio/putchar // int putchar (int c) - assert (c); #if 0 // XXX fix this if (nd.using_cout ())- char m <ref> [2] </ref>; m [0]=(char)c; m [1]='"0'; nd.puts (m); - else - #endif direct_cons_putchar (c); // if (nd.using_serial_console ()) // gdb_serial_putchar (c); // - return c; - hOff basic console output dependencies. i #include &lt;flux/machine/direct_cons.h&gt; // for direct_cons_putchar #include &lt;flux/gdb_serial.h&gt; // for gdb_serial_putchar #include &lt;node/Node.h&gt; // for nd et al.
Reference: [3] <author> Francisco J. Ballesteros and Luis L. Fernandez. </author> <title> The Network Hardware is the Operating System. </title> <booktitle> In Proceedings of the 6th Hot Topics on Operating Systems (HotOS-VI)., </booktitle> <address> Cape Cod, MA (USA), </address> <month> May </month> <year> 1997. </year>
Reference-contexts: By adopting a strict architecture self-awareness philosophy, we will allow system and user modules to be conscious of its own physical and logical architecture. So, the system will be able to adapt itself optimizing its performance and reliability. This document describes the object oriented redesign of the Off kernel <ref> [2, 3, 1] </ref>, named Off ++, and is meant to be the starting point for its literate implementation (see section 1.3). Off ++ also adds new functionalities to the kernel in order to provide basic support for 2K.
Reference: [4] <author> B.N. Bershad, S. Savage, P. Pardyak, E.G. Sirer, M. Fiuczynski, D. Becker, S. Eg-gers, and C. Chambers. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles. ACM, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: Secondly, a major drawback of current distributed operating systems is their lack of adaptability. It is known that adaptability can be achieved using a minimal microkernel as a foundation for the operating system <ref> [8, 7, 4, 10] </ref>.
Reference: [5] <author> Roy H. Campbell, Francisco J. Ballesteros, Fabio Kon, Ashish Singhai, Dulcineia Carvalho, and Robert Moore. </author> <title> 2k: A distributed adaptable operating system. </title> <note> http://choices.cs.uiuc.edu/2k, August 1997. </note>
Reference: [6] <author> John B. Carter, Dilip Khandekar, and Linus Kamb. </author> <title> Distributed shared memory: Where we are and where we should be headed. </title> <booktitle> In In proceedings of the 5th Workshop on Hot Topics in Operating Systems, </booktitle> <year> 1995. </year>
Reference-contexts: This problem can be noticed by the fact that it is necessary to modify and/or re-implement existing system services to add new distributed services to a typical microkernel based distributed system <ref> [6, 20, 13] </ref>.
Reference: [7] <author> D. Cheriton and K. Duda. </author> <title> A caching model of operating system kernel functionality. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 179193, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Secondly, a major drawback of current distributed operating systems is their lack of adaptability. It is known that adaptability can be achieved using a minimal microkernel as a foundation for the operating system <ref> [8, 7, 4, 10] </ref>.
Reference: [8] <author> D. Engler, M. F. Kaashoek, and J. O'Toole. </author> <title> The Operating System Kernel as a Secure Programmable Machine. </title> <booktitle> In Proc. of the 6th SIGOPS European Workshop, </booktitle> <pages> pages 6267, </pages> <address> Wadern, Germany, </address> <month> Sept </month> <year> 1994. </year> <note> ACM SIGOPS. </note>
Reference-contexts: Secondly, a major drawback of current distributed operating systems is their lack of adaptability. It is known that adaptability can be achieved using a minimal microkernel as a foundation for the operating system <ref> [8, 7, 4, 10] </ref>.
Reference: [9] <author> Bryan Ford, Godmar Back, Greg Benson, Jay Lepreau, Albert Lin, and Olin Shivers. </author> <title> The flux os toolkit: A substrate for kernel and language research. </title> <booktitle> In Proceedings of the 16th SOSP, </booktitle> <address> Saint-Malo, France, </address> <month> October </month> <year> 1997. </year> <note> ACM. </note>
Reference-contexts: GCC is the one we use. * As a support for literate programming, noweb [17] has proven to be a nice tool. * The development environment is a GNU based Linux system known as RedHat GNU/Linux. * Last, but not least (indeed, we should write most) we use the OSKit <ref> [9] </ref> for most of the low-level hardware glue code. All these tools have been already used in the construction of the original Off pro totype. 12 Chapter 2 System structure NOTE: XXX Clearly identify every design pattern being used. <p> is not shared among IO banks in the same node (i.e. it is not static). hoff IOBank::nameof implementation. i // Returns the IO bank name. const char *off_IOBank::nameof (void) - assert (valid ()); if (!io_name)- io_name = new char [strlen (nd.nameof ())+strlen ("/iobank")+9]; // for N...N"0 if (io_name)- char number <ref> [9] </ref>; strcpy (io_name,nd.nameof ()); strcat (io_name,"/iobank"); sprintf (number,"%08x",(natural_t)get_id ()); strcat (io_name,number); - return io_name; - hOther private members of off IOBank. i+ char *io_name; // name for this IO bank. hInitialize other aggregate members of off IOBank. i+ io_name (NULL) IO port inspection IO ports cannot be navigated. <p> The implementation is almost the same of get url. hoff TmrSrv::nameof implementation. i // Returns the timer server name. const char *off_TmrSrv::nameof (void) - assert (valid ()); if (!t_name)- t_name = new char [strlen (nd.nameof ())+strlen ("/tmr")+9]; // for N...N"0 if (t_name)- char number <ref> [9] </ref>; strcpy (t_name,nd.nameof ()); strcat (t_name,"/tmr"); sprintf (number,"%08x",(natural_t)get_id ()); strcat (t_name,number); - return t_name; - hOther private members of off TmrSrv. i+ char *t_name; // name for this TmrSrv hInitialize other aggregate members of off TmrSrv. i+ t_name (NULL) Timer inspection We need get rurl and get url holder for timers <p> the name is not shared among processors in the same node (i.e. it is not static). hoff Processor::nameof implementation. i // Returns the processor name. const char *off_Processor::nameof (void) - assert (valid ()); if (!p_name)- p_name = new char [strlen (nd.nameof ())+strlen ("/proc")+9]; // for N...N"0 if (p_name)- char number <ref> [9] </ref>; strcpy (p_name,nd.nameof ()); strcat (p_name,"/proc"); sprintf (number,"%08x",(natural_t)get_id ()); strcat (p_name,number); - return p_name; - hOther private members of off Processor. i+ char *p_name; // name for this Processor. hInitialize other aggregate members of off Processor. i+ p_name (NULL) Run queue slot inspection We need get rurl and get url holder <p> The implementation is almost the same of get url. hoff ShtlSrv::nameof implementation. i // Returns the shuttle server name. const char *off_ShtlSrv::nameof (void) - assert (valid ()); if (!s_name)- s_name = new char [strlen (nd.nameof ())+strlen ("/shtlsrv")+9]; // for N...N"0 if (s_name)- char number <ref> [9] </ref>; strcpy (s_name,nd.nameof ()); strcat (s_name,"/shtlsrv"); sprintf (number,"%08x",(natural_t)get_id ()); strcat (s_name,number); - return s_name; - hOther private members of off ShtlSrv. i+ char *s_name; // name for this ShtlSrv. hInitialize other aggregate members of off ShtlSrv. i+ s_name (NULL) hOther public methods of off ShtlSrv. i+ // Returns an inspector for
Reference: [10] <author> Bryan Ford, Mike Hibler, Jay Lepreau, Patrick Tullmann, Godmar Back, and Stephen Clawson. </author> <title> Microkernels Meet Recursive Virtual Machines. </title> <booktitle> In Proc. OSDI, </booktitle> <month> October </month> <year> 1996. </year> <month> 531 </month>
Reference-contexts: Secondly, a major drawback of current distributed operating systems is their lack of adaptability. It is known that adaptability can be achieved using a minimal microkernel as a foundation for the operating system <ref> [8, 7, 4, 10] </ref>.
Reference: [11] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patters. Elements of Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: allocate resource units. class off_CompResource : public off_Resource - protected: hOther protected members of off CompResource. i hOther protected methods of off CompResource. i 8 Even though the node is not a CompResource it can be considered to be a container. 9 cf. the wrapper or decorator design pattern (see <ref> [11] </ref>, pp 175.) 45 public: // Dumps it. friend OStr &operator&lt;<(OStr &s, const off_CompResource &r); -; hOff compound resource dependencies. i #include &lt;klib/ids.h&gt; // for off_id_t et al. #include &lt;klib/Resource.h&gt; // for off_Resource #include &lt;klib/Allocator.h&gt; // for off_Allocator. <p> hOther protected members of off Node. i hOff protected methods for sequencing objects. i hOther protected methods of off Node. i public: hoff Node::valid public method. i // Returns the node name. const char *nameof (void) - assert (valid ()); return n_name; - 1 see the singleton design patterm in <ref> [11] </ref>, pp 127. 129 // Returns or sets the authorization server and // the external data translator portals. off_prtl_id_t get_auth (void) - off_prtl_id_t p; assert (valid ()); r_lock (); p=n_auth; r_unlock (); return p; - off_prtl_id_t get_xdt (void) - off_prtl_id_t p; assert (valid ()); r_lock (); p=n_xdt; r_unlock (); return p; <p> Such check will be described below. hOff node dependencies. i #include &lt;assert.h&gt; // for assert #include &lt;klib/ids.h&gt; // for off_id_t et al. #include &lt;klib/err.h&gt; // for err_t and error numbers. #include &lt;klib/Resource.h&gt; // for off_Resource The Node can be also considered to be a facade 2 (see <ref> [11] </ref>) for node-wide system operations. <p> inline off_ShtlSrv get_shtl ( void ); inline off_PrtlSrv get_prtl ( void ); inline off_DMM get_dmm ( void ); const char *get_arch (void) const; const char *get_kvers (void) const; const char *get_owner (void) const; err_t use_serial_console (boolean_t doit = TRUE ); boolean_t using_serial_console (void); 2 see the singleton design patterm in <ref> [11] </ref>, pp 127. 509 // User OS provided output services? err_t set_cout (const off_prtl_id_t &cout ); boolean_t using_cout (void); // Print the string using the user-provided cout device. err_t puts (const char *s); -; Some per-node options may be set by the secondary boot loader at boot time.
Reference: [12] <author> John L. Hennessy and David A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Francisco, California, </address> <note> second edition edition, </note> <year> 1996. </year>
Reference-contexts: As such translations can be handled in a single operation by the hardware, we should rely on PTAddrTrs to do so. Off ++ memory management is based on Distributed TLBs (DTLBs) where TLB stands for Translation Lookaside Buffer, a cache of virtual to physical memory address translations <ref> [12] </ref>. Each Distributed Memory Manager (DMM, for short) is actually a pool of DTLBs. However, DTLBs are an optional feature. Machines dedicated to a single application (like a dedicated file server, an embedded controller, etc.) can use a single protection domain for efficiency purposes.
Reference: [13] <author> Takuro Kitayama, T.Nakajima, and Hideyuki Tokuda. RT-IPC: </author> <title> An IPC Extension for Real-Time Mach. </title> <booktitle> In Proceedings of the 2nd Microkernel and Other Kernel Architectures. USENIX, </booktitle> <year> 1993. </year>
Reference-contexts: This problem can be noticed by the fact that it is necessary to modify and/or re-implement existing system services to add new distributed services to a typical microkernel based distributed system <ref> [6, 20, 13] </ref>.
Reference: [14] <author> Donald E. Knuth. </author> <title> Literate Programming. Center for the Study of Language and Information, </title> <institution> Stanford University, </institution> <year> 1992. </year>
Reference-contexts: Off implements a Distributed Software TLB. The user can establish translations from virtual to distributed physical memory addresses and the address translation hardware is safely multiplexed by Off among the competing applications. 1.3 Literate programming As this document is hardcopy of a literate program <ref> [14] </ref> we think that it is worth saying something about this technique. We do it by citing the comp.programming.literate newsgroup FAQ: Literate programming is the combination of documentation and source together in a fashion suited for reading by human beings.
Reference: [15] <author> Leslie Lamport. </author> <title> A Document Preparation System: L A T E X. </title> <publisher> Addison-Wesley, </publisher> <address> ISBN 0-201-15790-X. </address>
Reference-contexts: The references below each chunk will allow you to navigate through this program's web. 1.5 Tools To implement Off ++ several tools have been used. They are all you need to build a system image from the on-line source for this document. * L A T E X <ref> [15] </ref> has been used to typeset documents, including the printed version of the literate source code. * C ++ [18] has been the programming language employed.
Reference: [16] <author> R. Pike, D. Presotto, K. Thompson, and H. Trickey. </author> <title> Plan 9 from Bell Labs. </title> <booktitle> In NKUUG Proceedings of the Summer 1990 Conference, </booktitle> <address> London (England), </address> <month> July </month> <year> 1990. </year>
Reference-contexts: So, Why are our distributed operating systems based on microkernels which essentially multiplex just local resources? Obviously system services can be later distributed when using a (centralized) mi-crokernel. Indeed, that can be done even when using a monolithic system <ref> [16] </ref>. But this will not solve the actual problem that the system is not being actually distributed and is not transparently multiplexing both local and remote resources. Secondly, a major drawback of current distributed operating systems is their lack of adaptability.
Reference: [17] <author> Norman Ramsey. </author> <title> Literate programming simplified. </title> <journal> IEEE Software, </journal> <volume> 11(5):97 105, </volume> <month> September </month> <year> 1994. </year>
Reference-contexts: The GNU C and C ++ compiler named GCC is the one we use. * As a support for literate programming, noweb <ref> [17] </ref> has proven to be a nice tool. * The development environment is a GNU based Linux system known as RedHat GNU/Linux. * Last, but not least (indeed, we should write most) we use the OSKit [9] for most of the low-level hardware glue code.
Reference: [18] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison Wesley, </publisher> <year> 1986. </year>
Reference-contexts: They are all you need to build a system image from the on-line source for this document. * L A T E X [15] has been used to typeset documents, including the printed version of the literate source code. * C ++ <ref> [18] </ref> has been the programming language employed.
Reference: [19] <author> Andrew S. Tanenbaum. </author> <title> Operating Systems: Design and Implementation. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Introduction 1.1 Motivation The well known definition for operating system is the software that securely abstracts and multiplexes physical resources <ref> [19] </ref>. By no means is it known that those resources should be contained in a single node. So, Why are our distributed operating systems based on microkernels which essentially multiplex just local resources? Obviously system services can be later distributed when using a (centralized) mi-crokernel.
Reference: [20] <author> H. Tokuda, T.Nakajima, and P. Rao. </author> <title> Real-Time Mach: Towards a Predictable Real-Time System. </title> <booktitle> In Proceedings of the 1st USENIX Mach Workshop. USENIX, </booktitle> <month> Oct </month> <year> 1990. </year> <month> 532 </month>
Reference-contexts: This problem can be noticed by the fact that it is necessary to modify and/or re-implement existing system services to add new distributed services to a typical microkernel based distributed system <ref> [6, 20, 13] </ref>.
References-found: 20

