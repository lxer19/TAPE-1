URL: ftp://ftp.win.tue.nl/pub/techreports/cosor/97-24.ps
Refering-URL: http://www.win.tue.nl/math/bs/cosor97.html
Root-URL: http://www.win.tue.nl
Author: Hoogeveen Petra Schuurman Gerhard J. Woeginger 
Keyword: Scheduling, approximation algorithm, approximation scheme, worst-case analysis, non-approximability, L-reduction, unrelated parallel machines, open shop, flow shop, precedence constraints, communication delays.  
Note: Han  
Affiliation: Eindhoven University of Technology  
Date: 97-24, 1997,  
Pubnum: Memorandum COSOR  
Abstract: Non-approximability results for scheduling Abstract We provide several non-approximability results for deterministic scheduling problems whose objective is to minimize the total job completion time. Unless P = N P, none of the problems under consideration can be approximated in polynomial time within arbitrarily good precision. Most of our results are derived by Max SNP hardness proofs. Among the investigated problems are: scheduling unrelated machines with job release dates, scheduling flow shops, scheduling open shops, scheduling parallel machines with precedence constraints and unit processing times, and two variants of the latter problem with unit communication delays. problems with minsum criteria
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. </author> <title> Szegedy [1992], Proof verification and hardness of approximation problems, </title> <booktitle> Proceedings of the 33rd IEEE Symposium on the Foundations of Computer Science, </booktitle> <pages> 14-23. </pages>
Reference-contexts: Finally, let k 1 and k 2 be the number of machines that are idle during the time intervals <ref> [0; 1] </ref> and [1; 2], respectively. There are q ` C of the C-jobs whose processing starts at their release date. All these C-jobs are processed on triple machines, and only k triple machines are good machines. <p> Finally, let k 1 and k 2 be the number of machines that are idle during the time intervals [0; 1] and <ref> [1; 2] </ref>, respectively. There are q ` C of the C-jobs whose processing starts at their release date. All these C-jobs are processed on triple machines, and only k triple machines are good machines. <p> All these C-jobs are processed on triple machines, and only k triple machines are good machines. Hence, the remaining number of at least q ` C k machines that process such a C-job must be idle during the time interval <ref> [0; 1] </ref>, or during [1; 2], or during both intervals. This yields that k 1 + k 2 q ` C k: (3) The number of jobs that have release date zero equals the number of machines. <p> All these C-jobs are processed on triple machines, and only k triple machines are good machines. Hence, the remaining number of at least q ` C k machines that process such a C-job must be idle during the time interval [0; 1], or during <ref> [1; 2] </ref>, or during both intervals. This yields that k 1 + k 2 q ` C k: (3) The number of jobs that have release date zero equals the number of machines. <p> Analogously at least k 2 of the B-jobs and dummy jobs are not processed during the time interval <ref> [1; 2] </ref>, and therefore ` B + ` D 2 k 2 holds. <p> Similarly as in Section 3, we are mainly interested in schedules for R (I) with a special combinatorial structure. In a so-called consistent schedule, for every variable x either both operations B (x i1 ) and B (x i2 ) are processed in the interval <ref> [0; 1] </ref>, or both operations B (x i1 ) and Non-approximability of Scheduling Problems 11 B (x i2 ) are processed during [0; 1]. Moreover, in a consistent schedule the machines process the operations of length 1 during the following intervals. <p> In a so-called consistent schedule, for every variable x either both operations B (x i1 ) and B (x i2 ) are processed in the interval <ref> [0; 1] </ref>, or both operations B (x i1 ) and Non-approximability of Scheduling Problems 11 B (x i2 ) are processed during [0; 1]. Moreover, in a consistent schedule the machines process the operations of length 1 during the following intervals. The assignment machines are only processing length 1 operations during [0; 2], and the consistency machines are only processing such operations during [1; 3]. <p> Moreover, in a consistent schedule the machines process the operations of length 1 during the following intervals. The assignment machines are only processing length 1 operations during [0; 2], and the consistency machines are only processing such operations during <ref> [1; 3] </ref>. On every clause machine, the operations of length 1 are either processed during [2; 3] and [3; 4] or during [3; 4] and [4; 5]. <p> Our first goal is to transform oe into a schedule in which the assignment machines are only busy during [0; 2] and the consistency machines are only busy during <ref> [1; 3] </ref>. We start by shifting all operations on the assignment and consistency machines as far to the left as possible without violating feasibility. Clearly, in the resulting schedule all operations on the assignment machines are processed during [0; 2]. <p> Now suppose that on some consistency machine some operation, say operation M (x i1 ), only completes at time four. Since all operations were shifted to the left, this yields that both operations B (x i1 ) and B (x i2 ) are scheduled during the time interval <ref> [1; 2] </ref>. Moreover, operations B (x i1 ) and B (x i2 ) are both processed during [0; 1]. <p> Since all operations were shifted to the left, this yields that both operations B (x i1 ) and B (x i2 ) are scheduled during the time interval [1; 2]. Moreover, operations B (x i1 ) and B (x i2 ) are both processed during <ref> [0; 1] </ref>. We proceed as follows: If operation M (x i1 ) is processed before M (x i2 ), then we switch the order of the operations B (x i2 ) and B (x i2 ) on their assignment machine. <p> We proceed as follows: If operation M (x i1 ) is processed before M (x i2 ), then we switch the order of the operations B (x i2 ) and B (x i2 ) on their assignment machine. Moreover, we reschedule operation M (x i2 ) during <ref> [1; 2] </ref> and operation M (x i1 ) during [2; 3]. If operation M (x i1 ) is processed after M (x i2 ), then we perform a symmetric switching and rescheduling step. <p> By performing such switches, we eventually get a schedule in which all assignment machines are busy during [0; 2] and all consistency machines are busy during <ref> [1; 3] </ref>. Finally, by shifting all operations on the clause and garbage machines as far to the left as possible, we obtain a schedule oe 0 . <p> First, assume that operation B (x i1 ) starts at time 0. This implies that B (x i1 ) is processed during <ref> [1; 2] </ref>, and that M (x i1 ) is processed during [2; 3]. This in turn implies that M (x i2 ) starts at time 1, and thus B (x i2 ) is processed during [0; 1], and we are done. <p> This implies that B (x i1 ) is processed during [1; 2], and that M (x i1 ) is processed during [2; 3]. This in turn implies that M (x i2 ) starts at time 1, and thus B (x i2 ) is processed during <ref> [0; 1] </ref>, and we are done. In case operation B (x i1 ) starts at time 1, a symmetric argument works. Next, we define a polynomial-time transformation S that maps feasible solutions of R (I) to feasible solutions of the Max-2Sat-B instance I. <p> As described in the proof of Lemma 4.4, we find a corresponding consistent schedule oe 0 . We define the truth setting S (oe) for I as follows. If in oe 0 operations B (x i1 ) and B (x i2 ) are processed during <ref> [0; 1] </ref>, then variable x i is set to TRUE, and if B (x i1 ) and B (x i2 ) are processed during [1; 2], then x i is set to FALSE. <p> If in oe 0 operations B (x i1 ) and B (x i2 ) are processed during [0; 1], then variable x i is set to TRUE, and if B (x i1 ) and B (x i2 ) are processed during <ref> [1; 2] </ref>, then x i is set to FALSE. Non-approximability of Scheduling Problems 12 It can be verified that if a clause is satisfied under the truth setting S (oe), then the length 1 operations on the corresponding clause machine are processed during [2; 3] and [3; 4]. <p> To this end, we introduce a number of additional jobs, which are used to fill the interval <ref> [0; 1] </ref> on the consistency machines and the interval [0; 2] on the clause machines; these additional jobs can be forced to go there, because our objective is to minimize the total completion time, which favors small jobs. <p> Any reasonable schedule processes the oper ations of length 1 3 during <ref> [0; 1] </ref> and the operations of length 3 during [3; 18]. * On each of the s clause machines, we introduce six structure operations of length 1 3 . Any reasonable schedule processes them during [0; 2].
Reference: [2] <author> J.L. Bruno, E.G. Coffman, Jr., and R. </author> <title> Sethi [1974], Scheduling independent tasks to reduce mean finishing time, </title> <journal> Communications of the ACM 17, </journal> <pages> 382-387. </pages>
Reference-contexts: Finally, let k 1 and k 2 be the number of machines that are idle during the time intervals [0; 1] and <ref> [1; 2] </ref>, respectively. There are q ` C of the C-jobs whose processing starts at their release date. All these C-jobs are processed on triple machines, and only k triple machines are good machines. <p> All these C-jobs are processed on triple machines, and only k triple machines are good machines. Hence, the remaining number of at least q ` C k machines that process such a C-job must be idle during the time interval [0; 1], or during <ref> [1; 2] </ref>, or during both intervals. This yields that k 1 + k 2 q ` C k: (3) The number of jobs that have release date zero equals the number of machines. <p> Analogously at least k 2 of the B-jobs and dummy jobs are not processed during the time interval <ref> [1; 2] </ref>, and therefore ` B + ` D 2 k 2 holds. <p> Moreover, in a consistent schedule the machines process the operations of length 1 during the following intervals. The assignment machines are only processing length 1 operations during <ref> [0; 2] </ref>, and the consistency machines are only processing such operations during [1; 3]. On every clause machine, the operations of length 1 are either processed during [2; 3] and [3; 4] or during [3; 4] and [4; 5]. <p> The assignment machines are only processing length 1 operations during [0; 2], and the consistency machines are only processing such operations during [1; 3]. On every clause machine, the operations of length 1 are either processed during <ref> [2; 3] </ref> and [3; 4] or during [3; 4] and [4; 5]. On the garbage machines, all four operations of length 1 are processed during [0; 4]; there are no restrictions on the processing order on the garbage machines. Figure 2 gives an illustration of a consistent schedule. <p> Our first goal is to transform oe into a schedule in which the assignment machines are only busy during <ref> [0; 2] </ref> and the consistency machines are only busy during [1; 3]. We start by shifting all operations on the assignment and consistency machines as far to the left as possible without violating feasibility. Clearly, in the resulting schedule all operations on the assignment machines are processed during [0; 2]. <p> busy during <ref> [0; 2] </ref> and the consistency machines are only busy during [1; 3]. We start by shifting all operations on the assignment and consistency machines as far to the left as possible without violating feasibility. Clearly, in the resulting schedule all operations on the assignment machines are processed during [0; 2]. Now suppose that on some consistency machine some operation, say operation M (x i1 ), only completes at time four. <p> Now suppose that on some consistency machine some operation, say operation M (x i1 ), only completes at time four. Since all operations were shifted to the left, this yields that both operations B (x i1 ) and B (x i2 ) are scheduled during the time interval <ref> [1; 2] </ref>. Moreover, operations B (x i1 ) and B (x i2 ) are both processed during [0; 1]. <p> We proceed as follows: If operation M (x i1 ) is processed before M (x i2 ), then we switch the order of the operations B (x i2 ) and B (x i2 ) on their assignment machine. Moreover, we reschedule operation M (x i2 ) during <ref> [1; 2] </ref> and operation M (x i1 ) during [2; 3]. If operation M (x i1 ) is processed after M (x i2 ), then we perform a symmetric switching and rescheduling step. <p> Moreover, we reschedule operation M (x i2 ) during [1; 2] and operation M (x i1 ) during <ref> [2; 3] </ref>. If operation M (x i1 ) is processed after M (x i2 ), then we perform a symmetric switching and rescheduling step. Note that after these switches, the schedule is still feasible and that on the consistency machines no operation has been shifted to the right. <p> Note that after these switches, the schedule is still feasible and that on the consistency machines no operation has been shifted to the right. By performing such switches, we eventually get a schedule in which all assignment machines are busy during <ref> [0; 2] </ref> and all consistency machines are busy during [1; 3]. Finally, by shifting all operations on the clause and garbage machines as far to the left as possible, we obtain a schedule oe 0 . <p> Finally, by shifting all operations on the clause and garbage machines as far to the left as possible, we obtain a schedule oe 0 . It is routine to check that in schedule oe 0 every clause machine is either busy during <ref> [2; 4] </ref> or during [3; 5], and every garbage machine is busy during [0; 4]. Since in schedule oe 0 no job finishes later than in schedule oe, the objective value has not been increased. <p> First, assume that operation B (x i1 ) starts at time 0. This implies that B (x i1 ) is processed during <ref> [1; 2] </ref>, and that M (x i1 ) is processed during [2; 3]. This in turn implies that M (x i2 ) starts at time 1, and thus B (x i2 ) is processed during [0; 1], and we are done. <p> First, assume that operation B (x i1 ) starts at time 0. This implies that B (x i1 ) is processed during [1; 2], and that M (x i1 ) is processed during <ref> [2; 3] </ref>. This in turn implies that M (x i2 ) starts at time 1, and thus B (x i2 ) is processed during [0; 1], and we are done. In case operation B (x i1 ) starts at time 1, a symmetric argument works. <p> If in oe 0 operations B (x i1 ) and B (x i2 ) are processed during [0; 1], then variable x i is set to TRUE, and if B (x i1 ) and B (x i2 ) are processed during <ref> [1; 2] </ref>, then x i is set to FALSE. Non-approximability of Scheduling Problems 12 It can be verified that if a clause is satisfied under the truth setting S (oe), then the length 1 operations on the corresponding clause machine are processed during [2; 3] and [3; 4]. <p> Non-approximability of Scheduling Problems 12 It can be verified that if a clause is satisfied under the truth setting S (oe), then the length 1 operations on the corresponding clause machine are processed during <ref> [2; 3] </ref> and [3; 4]. Conversely if a clause is not satisfied, then these operations occupy the intervals [3; 4] and [4; 5]. Lemma 4.5 For any instance I of Max-2Sat-B, we have Opt (R (I)) 58 Opt (I). Hence, the polynomial-time transformation R fulfills condition (1) of Definition 2.1. <p> To this end, we introduce a number of additional jobs, which are used to fill the interval [0; 1] on the consistency machines and the interval <ref> [0; 2] </ref> on the clause machines; these additional jobs can be forced to go there, because our objective is to minimize the total completion time, which favors small jobs. We further need some more jobs, which are used to remove unnecessary idle time. This can be worked out as follows. <p> Because of their large processing time, any reasonable schedule processes them during the interval <ref> [2; 17] </ref>. * On each of the 2q consistency machines, we introduce three structure operations of length 1 3 and five structure operations of length 3. <p> Any reasonable schedule processes the oper ations of length 1 3 during [0; 1] and the operations of length 3 during [3; 18]. * On each of the s clause machines, we introduce six structure operations of length 1 3 . Any reasonable schedule processes them during <ref> [0; 2] </ref>. It can be shown that for any feasible schedule for R (I), there exists a reasonable consistent schedule with non-larger objective value. With this, one can define a truth setting S (oe) like in Subsection 4.1.
Reference: [3] <author> P. Crescenzi and V. </author> <title> Kann [1997], A compendium of NP-optimization problems, </title> <address> http://www.nada.kth.se/nada/theory/problemlist/html. </address>
Reference-contexts: Moreover, in a consistent schedule the machines process the operations of length 1 during the following intervals. The assignment machines are only processing length 1 operations during [0; 2], and the consistency machines are only processing such operations during <ref> [1; 3] </ref>. On every clause machine, the operations of length 1 are either processed during [2; 3] and [3; 4] or during [3; 4] and [4; 5]. <p> The assignment machines are only processing length 1 operations during [0; 2], and the consistency machines are only processing such operations during [1; 3]. On every clause machine, the operations of length 1 are either processed during <ref> [2; 3] </ref> and [3; 4] or during [3; 4] and [4; 5]. On the garbage machines, all four operations of length 1 are processed during [0; 4]; there are no restrictions on the processing order on the garbage machines. Figure 2 gives an illustration of a consistent schedule. <p> The assignment machines are only processing length 1 operations during [0; 2], and the consistency machines are only processing such operations during [1; 3]. On every clause machine, the operations of length 1 are either processed during [2; 3] and <ref> [3; 4] </ref> or during [3; 4] and [4; 5]. On the garbage machines, all four operations of length 1 are processed during [0; 4]; there are no restrictions on the processing order on the garbage machines. Figure 2 gives an illustration of a consistent schedule. <p> The assignment machines are only processing length 1 operations during [0; 2], and the consistency machines are only processing such operations during [1; 3]. On every clause machine, the operations of length 1 are either processed during [2; 3] and <ref> [3; 4] </ref> or during [3; 4] and [4; 5]. On the garbage machines, all four operations of length 1 are processed during [0; 4]; there are no restrictions on the processing order on the garbage machines. Figure 2 gives an illustration of a consistent schedule. <p> Our first goal is to transform oe into a schedule in which the assignment machines are only busy during [0; 2] and the consistency machines are only busy during <ref> [1; 3] </ref>. We start by shifting all operations on the assignment and consistency machines as far to the left as possible without violating feasibility. Clearly, in the resulting schedule all operations on the assignment machines are processed during [0; 2]. <p> Moreover, we reschedule operation M (x i2 ) during [1; 2] and operation M (x i1 ) during <ref> [2; 3] </ref>. If operation M (x i1 ) is processed after M (x i2 ), then we perform a symmetric switching and rescheduling step. Note that after these switches, the schedule is still feasible and that on the consistency machines no operation has been shifted to the right. <p> By performing such switches, we eventually get a schedule in which all assignment machines are busy during [0; 2] and all consistency machines are busy during <ref> [1; 3] </ref>. Finally, by shifting all operations on the clause and garbage machines as far to the left as possible, we obtain a schedule oe 0 . <p> Finally, by shifting all operations on the clause and garbage machines as far to the left as possible, we obtain a schedule oe 0 . It is routine to check that in schedule oe 0 every clause machine is either busy during [2; 4] or during <ref> [3; 5] </ref>, and every garbage machine is busy during [0; 4]. Since in schedule oe 0 no job finishes later than in schedule oe, the objective value has not been increased. <p> First, assume that operation B (x i1 ) starts at time 0. This implies that B (x i1 ) is processed during [1; 2], and that M (x i1 ) is processed during <ref> [2; 3] </ref>. This in turn implies that M (x i2 ) starts at time 1, and thus B (x i2 ) is processed during [0; 1], and we are done. In case operation B (x i1 ) starts at time 1, a symmetric argument works. <p> Non-approximability of Scheduling Problems 12 It can be verified that if a clause is satisfied under the truth setting S (oe), then the length 1 operations on the corresponding clause machine are processed during <ref> [2; 3] </ref> and [3; 4]. Conversely if a clause is not satisfied, then these operations occupy the intervals [3; 4] and [4; 5]. Lemma 4.5 For any instance I of Max-2Sat-B, we have Opt (R (I)) 58 Opt (I). Hence, the polynomial-time transformation R fulfills condition (1) of Definition 2.1. <p> Non-approximability of Scheduling Problems 12 It can be verified that if a clause is satisfied under the truth setting S (oe), then the length 1 operations on the corresponding clause machine are processed during [2; 3] and <ref> [3; 4] </ref>. Conversely if a clause is not satisfied, then these operations occupy the intervals [3; 4] and [4; 5]. Lemma 4.5 For any instance I of Max-2Sat-B, we have Opt (R (I)) 58 Opt (I). Hence, the polynomial-time transformation R fulfills condition (1) of Definition 2.1. Proof. <p> Scheduling Problems 12 It can be verified that if a clause is satisfied under the truth setting S (oe), then the length 1 operations on the corresponding clause machine are processed during [2; 3] and <ref> [3; 4] </ref>. Conversely if a clause is not satisfied, then these operations occupy the intervals [3; 4] and [4; 5]. Lemma 4.5 For any instance I of Max-2Sat-B, we have Opt (R (I)) 58 Opt (I). Hence, the polynomial-time transformation R fulfills condition (1) of Definition 2.1. Proof. There are s clause machines and at most 2q garbage machines. <p> Any reasonable schedule processes the oper ations of length 1 3 during [0; 1] and the operations of length 3 during <ref> [3; 18] </ref>. * On each of the s clause machines, we introduce six structure operations of length 1 3 . Any reasonable schedule processes them during [0; 2]. It can be shown that for any feasible schedule for R (I), there exists a reasonable consistent schedule with non-larger objective value. <p> Garey & Johnson [1979]), this transformation computes a set of m machines and 3m precedence constrained jobs with unit processing times. In case the CLIQUE instance has answer YES, the constructed scheduling instance has a schedule where all 3m jobs are processed during the time interval <ref> [0; 3] </ref>. In case the CLIQUE instance has answer NO, in every feasible schedule for the constructed instance at least one job completes at time 4 or later. We add to the 3m jobs in the Lenstra & Rinnooy Kan instance a set of 3m new jobs.
Reference: [4] <author> M.R. Garey and D.S. </author> <title> Johnson [1979], Computers and Intractability: A Guide to the Theory of N P-Completeness, </title> <publisher> Freeman, </publisher> <address> San Francisco. </address>
Reference-contexts: The assignment machines are only processing length 1 operations during [0; 2], and the consistency machines are only processing such operations during [1; 3]. On every clause machine, the operations of length 1 are either processed during [2; 3] and <ref> [3; 4] </ref> or during [3; 4] and [4; 5]. On the garbage machines, all four operations of length 1 are processed during [0; 4]; there are no restrictions on the processing order on the garbage machines. Figure 2 gives an illustration of a consistent schedule. <p> The assignment machines are only processing length 1 operations during [0; 2], and the consistency machines are only processing such operations during [1; 3]. On every clause machine, the operations of length 1 are either processed during [2; 3] and <ref> [3; 4] </ref> or during [3; 4] and [4; 5]. On the garbage machines, all four operations of length 1 are processed during [0; 4]; there are no restrictions on the processing order on the garbage machines. Figure 2 gives an illustration of a consistent schedule. <p> The assignment machines are only processing length 1 operations during [0; 2], and the consistency machines are only processing such operations during [1; 3]. On every clause machine, the operations of length 1 are either processed during [2; 3] and [3; 4] or during [3; 4] and <ref> [4; 5] </ref>. On the garbage machines, all four operations of length 1 are processed during [0; 4]; there are no restrictions on the processing order on the garbage machines. Figure 2 gives an illustration of a consistent schedule. Lemma 4.4 Let oe be any feasible schedule for R (I). <p> On every clause machine, the operations of length 1 are either processed during [2; 3] and [3; 4] or during [3; 4] and [4; 5]. On the garbage machines, all four operations of length 1 are processed during <ref> [0; 4] </ref>; there are no restrictions on the processing order on the garbage machines. Figure 2 gives an illustration of a consistent schedule. Lemma 4.4 Let oe be any feasible schedule for R (I). <p> Finally, by shifting all operations on the clause and garbage machines as far to the left as possible, we obtain a schedule oe 0 . It is routine to check that in schedule oe 0 every clause machine is either busy during <ref> [2; 4] </ref> or during [3; 5], and every garbage machine is busy during [0; 4]. Since in schedule oe 0 no job finishes later than in schedule oe, the objective value has not been increased. <p> It is routine to check that in schedule oe 0 every clause machine is either busy during [2; 4] or during [3; 5], and every garbage machine is busy during <ref> [0; 4] </ref>. Since in schedule oe 0 no job finishes later than in schedule oe, the objective value has not been increased. <p> Non-approximability of Scheduling Problems 12 It can be verified that if a clause is satisfied under the truth setting S (oe), then the length 1 operations on the corresponding clause machine are processed during [2; 3] and <ref> [3; 4] </ref>. Conversely if a clause is not satisfied, then these operations occupy the intervals [3; 4] and [4; 5]. Lemma 4.5 For any instance I of Max-2Sat-B, we have Opt (R (I)) 58 Opt (I). Hence, the polynomial-time transformation R fulfills condition (1) of Definition 2.1. Proof. <p> Scheduling Problems 12 It can be verified that if a clause is satisfied under the truth setting S (oe), then the length 1 operations on the corresponding clause machine are processed during [2; 3] and <ref> [3; 4] </ref>. Conversely if a clause is not satisfied, then these operations occupy the intervals [3; 4] and [4; 5]. Lemma 4.5 For any instance I of Max-2Sat-B, we have Opt (R (I)) 58 Opt (I). Hence, the polynomial-time transformation R fulfills condition (1) of Definition 2.1. Proof. There are s clause machines and at most 2q garbage machines. <p> Conversely if a clause is not satisfied, then these operations occupy the intervals [3; 4] and <ref> [4; 5] </ref>. Lemma 4.5 For any instance I of Max-2Sat-B, we have Opt (R (I)) 58 Opt (I). Hence, the polynomial-time transformation R fulfills condition (1) of Definition 2.1. Proof. There are s clause machines and at most 2q garbage machines.
Reference: [5] <author> R.L. Graham, E.L. Lawler, J.K. Lenstra, and A.H.G. </author> <title> Rinnooy Kan [1979], Optimization and approximation in deterministic sequencing and scheduling: a survey. </title> <journal> Annals of Discrete Mathematics 5, </journal> <pages> 287-326. </pages>
Reference-contexts: The assignment machines are only processing length 1 operations during [0; 2], and the consistency machines are only processing such operations during [1; 3]. On every clause machine, the operations of length 1 are either processed during [2; 3] and [3; 4] or during [3; 4] and <ref> [4; 5] </ref>. On the garbage machines, all four operations of length 1 are processed during [0; 4]; there are no restrictions on the processing order on the garbage machines. Figure 2 gives an illustration of a consistent schedule. Lemma 4.4 Let oe be any feasible schedule for R (I). <p> Finally, by shifting all operations on the clause and garbage machines as far to the left as possible, we obtain a schedule oe 0 . It is routine to check that in schedule oe 0 every clause machine is either busy during [2; 4] or during <ref> [3; 5] </ref>, and every garbage machine is busy during [0; 4]. Since in schedule oe 0 no job finishes later than in schedule oe, the objective value has not been increased. <p> Conversely if a clause is not satisfied, then these operations occupy the intervals [3; 4] and <ref> [4; 5] </ref>. Lemma 4.5 For any instance I of Max-2Sat-B, we have Opt (R (I)) 58 Opt (I). Hence, the polynomial-time transformation R fulfills condition (1) of Definition 2.1. Proof. There are s clause machines and at most 2q garbage machines.
Reference: [6] <author> J.A. Hoogeveen, J.K. Lenstra, and B. </author> <month> Veltman </month> <year> [1994], </year> <title> Three, four, five, six, or the complexity of scheduling with communication delays. </title> <journal> Operations Research Letters 16, </journal> <pages> 129-137. </pages>
Reference: [7] <author> W.A. </author> <title> Horn [1973], Minimizing average flow time on parallel machines. </title> <journal> Operations Research 21, </journal> <pages> 846-847. </pages>
Reference: [8] <author> V. </author> <title> Kann [1991], Maximum bounded 3-dimensional matching is MAX SNP-complete. </title> <journal> Information Processing Letters 37, </journal> <pages> 27-35. </pages>
Reference: [9] <author> H. Kellerer, T. Tautenhahn, and G.J. </author> <title> Woeginger [1996], Approximability and nonapproximability results for minimizing total flow time on a single machine, </title> <booktitle> Proceedings of the 28th Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> 418-426. </pages>
Reference: [10] <author> E.L. Lawler, J.K. Lenstra, A.H.G. Rinnooy Kan, </author> <title> and D.B. Shmoys [1993], Sequencing and scheduling: Algorithms and complexity, in: S.C. Graves, </title> <editor> A.H.G. Rinnooy Kan, and P.H. Zipkin (eds.) </editor> <booktitle> Logistics of Production and Inventory, Handbooks in Operations Research and Management Science 4, </booktitle> <publisher> North-Holland, Amsterdam, </publisher> <pages> 445-522. </pages>
Reference: [11] <author> J.K. Lenstra and A.H.G. </author> <title> Rinnooy Kan [1978], Complexity of scheduling under precedence constraints. </title> <journal> Operations Research 26, </journal> <pages> 22-35. </pages>
Reference: [12] <author> J.K. Lenstra and D.B. </author> <title> Shmoys [1995], Computing near-optimal schedules, </title> <editor> in: P. Chretienne, E.G. Coffman, Jr., J.K. Lenstra and Z. Liu (eds.) </editor> <title> Scheduling Theory and its Applications, </title> <publisher> Wiley, </publisher> <address> Chichester, </address> <month> 1-14. </month> <title> Non-approximability of Scheduling Problems 16 </title>
Reference: [13] <author> J.K. Lenstra, D.B. Shmoys, and E. </author> <title> Tardos [1990], Approximation algorithms for scheduling unrelated parallel machines. Math. </title> <booktitle> Programming 46, </booktitle> <pages> 259-271. </pages>
Reference: [14] <author> S. Leonardi and D. </author> <title> Raz [1997], Approximating total flow time on parallel machines, </title> <booktitle> Proceedings of the 29th Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> 110-119. </pages>
Reference: [15] <author> C.H. </author> <title> Papadimitriou [1994], Computational Complexity, </title> <publisher> Addison-Wesley Publishing Company. </publisher>
Reference: [16] <author> C.H. Papadimitriou and M. </author> <title> Yannakakis [1991], Optimization, approximation, and complexity classes, </title> <journal> Journal of Computer and System Sciences 43, </journal> <pages> 425-440. </pages>
Reference: [17] <author> C. Phillips, C. Stein, and J. </author> <title> Wein [1995], Scheduling jobs that arrive over time, </title> <booktitle> Proceedings of the 4th Workshop on Algorithms and Data Structures, </booktitle> <publisher> LNCS 955, Springer Verlag, </publisher> <pages> 86-97. </pages>
Reference-contexts: Because of their large processing time, any reasonable schedule processes them during the interval <ref> [2; 17] </ref>. * On each of the 2q consistency machines, we introduce three structure operations of length 1 3 and five structure operations of length 3.
Reference: [18] <author> M. </author> <month> Skutella </month> <year> [1997], </year> <title> Problem posed at the open problem session of the Dagstuhl Meeting on "Parallel Machine Scheduling", </title> <publisher> Schlo Dagstuhl, </publisher> <address> Germany, </address> <month> July 14-18, </month> <year> 1997. </year>
Reference-contexts: Any reasonable schedule processes the oper ations of length 1 3 during [0; 1] and the operations of length 3 during <ref> [3; 18] </ref>. * On each of the s clause machines, we introduce six structure operations of length 1 3 . Any reasonable schedule processes them during [0; 2]. It can be shown that for any feasible schedule for R (I), there exists a reasonable consistent schedule with non-larger objective value.
Reference: [19] <author> D.P. Williamson, L.A. Hall, J.A. Hoogeveen, C.A.J. Hurkens, J.K. Lenstra, </author> <title> S.V. </title> <journal> Sevastianov, and D.B. </journal> <note> Shmoys [1997], Short shop schedules, Operations Research 45, 288-294. </note>
References-found: 19

