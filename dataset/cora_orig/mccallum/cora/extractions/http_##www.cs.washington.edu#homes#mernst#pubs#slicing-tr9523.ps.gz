URL: http://www.cs.washington.edu/homes/mernst/pubs/slicing-tr9523.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/mernst/pubs/slicing-tr9523-abstract.html
Root-URL: 
Email: Email: mernst@research.microsoft.com  
Title: Slicing pointers and procedures (abstract)  
Author: Michael D. Ernst 
Date: January 13, 1995  
Address: 1 Microsoft Way, Redmond, WA 98052 USA  
Affiliation: Microsoft Research  
Abstract: Program slicing restricts attention the components of a program relevant to evaluation of one expression, the slicing criterion. Our slicer, which explicitly represents the store as an aggregate value is the first to support arbitrary pointer manipulations and aggregate values, and is faster than more limited techniques. We also improve the asymptotic complexity of slicing in the presence of procedure calls, and of a preprocessing step for computing dependences of procedure returns on formals. Additionally, our interprocedural slices can be smaller than those produced by other techniques. We implement these techniques in the first slicer for an entire practical programming language (ANSI C, except longjmp).
Abstract-found: 1
Intro-found: 1
Reference: [Agr91] <author> H. Agrawal. </author> <title> Towards automatic debugging of computer programs. </title> <type> Technical Report SERC-TR-103-P, </type> <institution> Software Engineering Research Center, Purdue University, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: This paper addresses static slicing, which uses analysis to discover dependences and indicates the program components that may have an effect on (or may be affected by) the slicing criterion values. By contrast, a dynamic slice <ref> [AH90, Agr91, Ven93] </ref> gives definite information for some particular execution by maintaining an execution trace of a running program.
Reference: [AH90] <author> Hiralal Agrawal and Joseph R. Horgan. </author> <title> Dynamic program slicing. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 246-256, </pages> <address> White Plains, NY, </address> <month> June 20-22, </month> <year> 1990. </year>
Reference-contexts: This paper addresses static slicing, which uses analysis to discover dependences and indicates the program components that may have an effect on (or may be affected by) the slicing criterion values. By contrast, a dynamic slice <ref> [AH90, Agr91, Ven93] </ref> gives definite information for some particular execution by maintaining an execution trace of a running program.
Reference: [CWZ90] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <address> White Plains, NY, </address> <month> June 20-22, </month> <year> 1990. </year>
Reference-contexts: Additionally, information about pointers is easy to reflect in the graph (by short-circuiting (Figure 4), store splitting [SW93, Ste94b], and other transformations), making it immediately available to all analyses. 3.2 Pointer analysis VDGomatic makes use of a points-to analysis <ref> [CWZ90, HEGV93, Ruf94b] </ref>, which indicates the possible values for each location-valued expression. (In our representation a points-to analysis is more natural than an alias analysis, which produces a set of possible alias pairs.) In the worst case, 5 the lookup and can make the update dead as well. the analysis indicates
Reference: [EGH94] <author> Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. </author> <title> Context-sensitive interprocedural analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: alias analysis, which produces a set of possible alias pairs.) In the worst case, 5 the lookup and can make the update dead as well. the analysis indicates that a location-returning expression could return any location at run time, but in practice, on average fewer than two values are possible <ref> [LRZ93, EGH94, Ruf94a, Ste94a] </ref>. The details of the analysis are irrelevant to the slicing algorithm. 3.3 Slicing algorithm We now extend the slicing algorithm to process lookup nodes, to traverse store edges, and to process update nodes.
Reference: [Ern94a] <author> Michael D. Ernst. </author> <title> Practical fine-grained static slicing of optimized code. </title> <type> Technical Report MSR-TR-94-14, </type> <institution> Microsoft Research, </institution> <address> Redmond, WA, </address> <month> July 26, </month> <year> 1994. </year>
Reference-contexts: This paper first describes the value dependence graph (VDG), the intermediate representation used by our slicer, then gives an algorithm for slicing with respect to this representation. The next two sections extend the basic algorithm to properly account for pointers and procedures. Finally, the implementation is discussed. Other reports <ref> [Ern94a, Ern94b] </ref> provide more details and discuss our techniques for expression-oriented slicing (we improve the precision of slicing criteria, display of slices, and of slices themselves), for executable slicing (we bypass syntactic constraints in code generation and supply precise liveness information to the back end), and for slicing optimized code (which <p> The screen dump on the right shows how our system indicates, in the programmer's editor, the computations in the slice. The dark highlighting indicates computation; the light highlighting indicates other names for the values in the slice. The user interface issues of communicating a VDG slice to the user <ref> [Ern94a, Ern94b] </ref> are outside the scope of this paper. The advantages of our slicing approach accrue both from the VDG's features and their exploitation by our algorithms. The VDG's fine granularity makes slicing criteria and results more precise than with statement-based representations. <p> The slice should not include the entire store argument, however, because only some operations that contribute to the store are relevant to the lookup node's value. Unlike scalar values, stores can be partially included in a slice. (An aggregate-valued slicing criterion optionally specifies a component of that aggregate <ref> [Ern94a, Ern94b] </ref>.) A slicing traversal along a store specifies a location, and the result includes only operations that can set that location. <p> Our slices exclude more procedure calls and bodies by distinguishing between direct and indirect summary dependences. We produce better executable slices by providing exact liveness information (including demand on call results) to the code generator <ref> [Ern94a, Ern94b] </ref>. 4.1 Summary dependences Precomputed summary dependences for a procedure indicate, for each return value, which formal parameters it depends on. They permit a slicing traversal which encounters a procedure call result to proceed at the demanded actual parameters of the call without entering the procedure body.
Reference: [Ern94b] <author> Michael D. Ernst. </author> <title> Slicing the value dependence graph. </title> <type> Technical Report MSR-TR-94-22, </type> <institution> Microsoft Research, </institution> <address> Redmond, WA, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: This paper first describes the value dependence graph (VDG), the intermediate representation used by our slicer, then gives an algorithm for slicing with respect to this representation. The next two sections extend the basic algorithm to properly account for pointers and procedures. Finally, the implementation is discussed. Other reports <ref> [Ern94a, Ern94b] </ref> provide more details and discuss our techniques for expression-oriented slicing (we improve the precision of slicing criteria, display of slices, and of slices themselves), for executable slicing (we bypass syntactic constraints in code generation and supply precise liveness information to the back end), and for slicing optimized code (which <p> The screen dump on the right shows how our system indicates, in the programmer's editor, the computations in the slice. The dark highlighting indicates computation; the light highlighting indicates other names for the values in the slice. The user interface issues of communicating a VDG slice to the user <ref> [Ern94a, Ern94b] </ref> are outside the scope of this paper. The advantages of our slicing approach accrue both from the VDG's features and their exploitation by our algorithms. The VDG's fine granularity makes slicing criteria and results more precise than with statement-based representations. <p> The slice should not include the entire store argument, however, because only some operations that contribute to the store are relevant to the lookup node's value. Unlike scalar values, stores can be partially included in a slice. (An aggregate-valued slicing criterion optionally specifies a component of that aggregate <ref> [Ern94a, Ern94b] </ref>.) A slicing traversal along a store specifies a location, and the result includes only operations that can set that location. <p> Sets are combined when the traversal simultaneously reaches a node from multiple consumers. (The algorithm queues values needing to be processed, combining queue entries for a single value.) This strategy also enables optimizations that take advantage of pointer equality in addition to the points-to analysis <ref> [Ern94b] </ref>. 3.4 Aggregate values The slicing algorithm treats stores as aggregate values; the same mechanisms can be applied to other aggregates, such as C structs. An edge may be traversed a number of times equal to the number of components in the value carried by the edge. <p> Every bit in a quantum is guaranteed to be identically operated upon, and each quantum is independently treated by the slicing algorithm. Casting, which effectively makes gives union types to arbitrary variables, is similarly handled <ref> [Ern94b] </ref>. While pointers are more expressive (and member specifiers can be resolved at compile time), C's union construct enables aliasing, so many of the same issues are raised for structures as for pointers. <p> Our slices exclude more procedure calls and bodies by distinguishing between direct and indirect summary dependences. We produce better executable slices by providing exact liveness information (including demand on call results) to the code generator <ref> [Ern94a, Ern94b] </ref>. 4.1 Summary dependences Precomputed summary dependences for a procedure indicate, for each return value, which formal parameters it depends on. They permit a slicing traversal which encounters a procedure call result to proceed at the demanded actual parameters of the call without entering the procedure body. <p> Free values defined outside a procedure but used inside without being passed in parameters (such as the use of n in the loop of Figure 1) can be either addressed directly or converted into parameters <ref> [Ern94b] </ref>. For efficiency, VDGomatic does not propagate whole formals properties, but only differences from previous values. Aggregate values such as structures and stores require two modifications to the dataflow equations. First, dependence on part of an aggregate formal does not imply dependence on all of the formal. <p> While optimization can increase the number of nodes and edges in the VDG, it does not increase the number of edge components, which is a more accurate measure of VDG size <ref> [Ern94b] </ref>.) Each variable reference becomes a store lookup, and each assignment is represented by an update-store node. No value is used by more than one consumer. Each program operation becomes (a constant number of ) VDG nodes.
Reference: [HDC88] <author> J. C. Hwang, M. W. Du, and C. R. Chou. </author> <title> Finding program slices for recursive procedures. </title> <booktitle> In Proceedings COMPSAC 88: The Twelfth International Computer Software and Applications Conference, </booktitle> <address> Chicago, </address> <month> October </month> <year> 1988. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: A start has been made on these problems by suggesting techniques for addressing by-reference function parameters <ref> [HDC88, HRB90, LC92] </ref> and providing support for pointer variables [JZR91, LR94]. We provide the first discussion and implementation of slicing techniques for handling arbitrary pointer manipulations (including arithmetic, casting, and function pointers). We then discuss the similar challenges raised by aggregate values, which are also fully supported by VDGomatic. <p> Ghinsu [LR94] uses an extended storage shape graph to add data dependence edges to the program representation. Call-by-reference function parameters can be addressed by duplicating each procedure for every possible alias pattern among its parameters <ref> [HDC88, HRB90, LC92] </ref>, which increases the program size exponentially, or by assuming all possible aliases can occur simultaneously, which degrades slice quality [HRB90]. The only slicer besides VDGomatic which addresses structures is Ghinsu [LR94]. <p> Support for arbitrary pointer manipulations (see Section 3) increases VDG size to quadratic; support for call-by-reference parameters either increases the SDG size to exponential or results in degraded performance. The NCTU slicer <ref> [HDC88] </ref> computes summaries via an exponential time [HRB90] technique. At each call, the called procedure is processed and the results propagated back to that call site.
Reference: [HEGV93] <author> Laurie J. Hendren, Maryam Emami, Rakesh Ghiya, and Clark Verbrugge. </author> <title> A practical context-sensitive interprocedural alias analysis framework for C compilers. </title> <type> ACAPS Technical Memo 72, </type> <institution> McGill University School of Computer Science, Advanced Compilers, Architectures, and Parallel Systems Group, </institution> <address> Montreal, Quebec, </address> <month> July 24, </month> <year> 1993. </year>
Reference-contexts: Additionally, information about pointers is easy to reflect in the graph (by short-circuiting (Figure 4), store splitting [SW93, Ste94b], and other transformations), making it immediately available to all analyses. 3.2 Pointer analysis VDGomatic makes use of a points-to analysis <ref> [CWZ90, HEGV93, Ruf94b] </ref>, which indicates the possible values for each location-valued expression. (In our representation a points-to analysis is more natural than an alias analysis, which produces a set of possible alias pairs.) In the worst case, 5 the lookup and can make the update dead as well. the analysis indicates
Reference: [HRB90] <author> Susan Horwitz, Thomas Reps, and David Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Previous techniques have handled only call-by-reference parameters or 1 limited pointer variables, and have not been as efficient as our method. Our slices include only the relevant parts of aggregate values, which were only partially supported by previous methods. We improve the graph-based interprocedural slicing method <ref> [HRB90] </ref> in several ways. We compute summary dependences faster than previous methods (by a factor of at least O (n)) and via a simpler algorithm. <p> A start has been made on these problems by suggesting techniques for addressing by-reference function parameters <ref> [HDC88, HRB90, LC92] </ref> and providing support for pointer variables [JZR91, LR94]. We provide the first discussion and implementation of slicing techniques for handling arbitrary pointer manipulations (including arithmetic, casting, and function pointers). We then discuss the similar challenges raised by aggregate values, which are also fully supported by VDGomatic. <p> Ghinsu [LR94] uses an extended storage shape graph to add data dependence edges to the program representation. Call-by-reference function parameters can be addressed by duplicating each procedure for every possible alias pattern among its parameters <ref> [HDC88, HRB90, LC92] </ref>, which increases the program size exponentially, or by assuming all possible aliases can occur simultaneously, which degrades slice quality [HRB90]. The only slicer besides VDGomatic which addresses structures is Ghinsu [LR94]. <p> Call-by-reference function parameters can be addressed by duplicating each procedure for every possible alias pattern among its parameters [HDC88, HRB90, LC92], which increases the program size exponentially, or by assuming all possible aliases can occur simultaneously, which degrades slice quality <ref> [HRB90] </ref>. The only slicer besides VDGomatic which addresses structures is Ghinsu [LR94]. <p> This is a result of ascending from formals only to corresponding actuals at call sites in the slice. Figure 8 demonstrates the proper behavior, and Figure 12 shows slicing in the presence of both pointers and procedure calls. Our solution to these problems is patterned after Horwitz's <ref> [HRB90] </ref>. Before slicing, a summary of the dependences of each procedure return on each formal parameter is computed. This summary permits the slicing traversal to proceed directly from a call result to the actuals that affect that result. <p> dependences would be changed.) Therefore, the total theoretical cost of the algorithm is O (n 4 ), though in practice most edges are traversed no more than a few times, and few values have O (n) components or depend on O (n) formals. 4.2 Related work Horwitz, Reps, and Binkley <ref> [HRB90] </ref> compute summary dependences from an attribute grammar that models procedure-call structure and from the subordinate characteristic graphs of the grammar's nonterminals. <p> If n is the size of the original program, constructing the subordinate 13 characteristic graphs requires O (n 5 ) computation <ref> [HRB90, x5.1] </ref>, and the entire summary algo-rithm performs O (n 7 ) steps [RHSR94, x4]. An improved algorithm [RHSR94] finds same-level realizable paths in the graph that end at a procedure's formal-out (return) vertices, which induce summary edges at call sites. <p> Support for arbitrary pointer manipulations (see Section 3) increases VDG size to quadratic; support for call-by-reference parameters either increases the SDG size to exponential or results in degraded performance. The NCTU slicer [HDC88] computes summaries via an exponential time <ref> [HRB90] </ref> technique. At each call, the called procedure is processed and the results propagated back to that call site.
Reference: [JZR91] <author> Jingyue Jiang, Xiling Zhou, and David J. Robson. </author> <title> Program slicing for C | the problems in implementation. </title> <booktitle> In Proceedings, Conference on Software Maintenance 1991, </booktitle> <pages> pages 182-190, </pages> <address> Sorrento, Italy, </address> <month> October 15-17, </month> <title> 1991. </title> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: A start has been made on these problems by suggesting techniques for addressing by-reference function parameters [HDC88, HRB90, LC92] and providing support for pointer variables <ref> [JZR91, LR94] </ref>. We provide the first discussion and implementation of slicing techniques for handling arbitrary pointer manipulations (including arithmetic, casting, and function pointers). We then discuss the similar challenges raised by aggregate values, which are also fully supported by VDGomatic. <p> Neither these transformations nor support for slicing aggregates or pointers increases the size of the VDG (beyond the storage requirements of the points-to analysis). 3.6 Related work Two previous slicers provide limited support for pointer variables (but no arithmetic, casting, function pointers, etc.). CPS <ref> [JZR91] </ref> adds dummy variables and literals for pointer dereferences and address-of operations; pointer references and assignments count as uses and modifications of 8 different parameters for the two calls to set globals.
Reference: [LC92] <author> Panos E. Livadas and Stephen Croll. </author> <title> Program slicing. </title> <type> Technical Report SERC-TR-61-F, </type> <institution> Computer and Information Sciences Department, University of Florida, </institution> <address> Gainesville, FL, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: A start has been made on these problems by suggesting techniques for addressing by-reference function parameters <ref> [HDC88, HRB90, LC92] </ref> and providing support for pointer variables [JZR91, LR94]. We provide the first discussion and implementation of slicing techniques for handling arbitrary pointer manipulations (including arithmetic, casting, and function pointers). We then discuss the similar challenges raised by aggregate values, which are also fully supported by VDGomatic. <p> Ghinsu [LR94] uses an extended storage shape graph to add data dependence edges to the program representation. Call-by-reference function parameters can be addressed by duplicating each procedure for every possible alias pattern among its parameters <ref> [HDC88, HRB90, LC92] </ref>, which increases the program size exponentially, or by assuming all possible aliases can occur simultaneously, which degrades slice quality [HRB90]. The only slicer besides VDGomatic which addresses structures is Ghinsu [LR94]. <p> The algorithm can extend paths up to O (n 4 ) times, and each path extension incurs set operations on sets of size O (n). Livadas and Croll <ref> [LC92] </ref> suggest incrementally constructing and refining an "extended call sequence graph." They have not implemented the technique (Ghinsu handles function calls via inlining [LR94]) or determined its complexity (they do note that it multiply processes looping statements). These methods represent dependences due to calls via a system dependence graph (SDG).
Reference: [LR94] <author> Panos E. Livadas and Adam Rosenstein. </author> <title> Slicing in the presence of pointer variables. </title> <type> Technical Report SERC-TR-74-F, </type> <institution> Computer and Information Sciences Department, University of Florida, </institution> <address> Gainesville, FL, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: A start has been made on these problems by suggesting techniques for addressing by-reference function parameters [HDC88, HRB90, LC92] and providing support for pointer variables <ref> [JZR91, LR94] </ref>. We provide the first discussion and implementation of slicing techniques for handling arbitrary pointer manipulations (including arithmetic, casting, and function pointers). We then discuss the similar challenges raised by aggregate values, which are also fully supported by VDGomatic. <p> Both the lighter highlighting and including portions of the body (as in Figure 11) help indicate which variables carry dependences between calls, when that information is desired. the corresponding dummy variables. Ghinsu <ref> [LR94] </ref> uses an extended storage shape graph to add data dependence edges to the program representation. <p> The only slicer besides VDGomatic which addresses structures is Ghinsu <ref> [LR94] </ref>. <p> Livadas and Croll [LC92] suggest incrementally constructing and refining an "extended call sequence graph." They have not implemented the technique (Ghinsu handles function calls via inlining <ref> [LR94] </ref>) or determined its complexity (they do note that it multiply processes looping statements). These methods represent dependences due to calls via a system dependence graph (SDG).
Reference: [LRZ93] <author> William A. Landi, Barbara G. Ryder, and Sean Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 56-67. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: alias analysis, which produces a set of possible alias pairs.) In the worst case, 5 the lookup and can make the update dead as well. the analysis indicates that a location-returning expression could return any location at run time, but in practice, on average fewer than two values are possible <ref> [LRZ93, EGH94, Ruf94a, Ste94a] </ref>. The details of the analysis are irrelevant to the slicing algorithm. 3.3 Slicing algorithm We now extend the slicing algorithm to process lookup nodes, to traverse store edges, and to process update nodes.
Reference: [OO84] <author> K. J. Ottenstein and L. M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proc. ACM SIGSOFT/SIGPLAN Software Engineering Symp. on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> April </month> <year> 1984. </year>
Reference-contexts: A program's VDG can be computed in linear time, even for programs with irreducible control flow. Furthermore, efficient code can be generated from the VDG [WCES94b, Ste93]. 2.2 Basic slicing algorithm The basic slicing algorithm <ref> [OO84] </ref> on the VDG is extremely simple. A slice consists of all computations encountered in a graph traversal starting at the slicing criterion, which is a particular dependence (value) arc.
Reference: [RHSR94] <author> T. Reps, S. Horwitz, M. Sagiv, and G. Rosay. </author> <title> Speeding up slicing. </title> <note> Submitted for publication, </note> <month> June </month> <year> 1994. </year> <month> 15 </month>
Reference-contexts: If n is the size of the original program, constructing the subordinate 13 characteristic graphs requires O (n 5 ) computation [HRB90, x5.1], and the entire summary algo-rithm performs O (n 7 ) steps <ref> [RHSR94, x4] </ref>. An improved algorithm [RHSR94] finds same-level realizable paths in the graph that end at a procedure's formal-out (return) vertices, which induce summary edges at call sites. <p> If n is the size of the original program, constructing the subordinate 13 characteristic graphs requires O (n 5 ) computation [HRB90, x5.1], and the entire summary algo-rithm performs O (n 7 ) steps [RHSR94, x4]. An improved algorithm <ref> [RHSR94] </ref> finds same-level realizable paths in the graph that end at a procedure's formal-out (return) vertices, which induce summary edges at call sites. The algorithm can extend paths up to O (n 4 ) times, and each path extension incurs set operations on sets of size O (n).
Reference: [Ruf94a] <author> Erik Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <note> Submitted for publication, </note> <month> November </month> <year> 1994. </year>
Reference-contexts: alias analysis, which produces a set of possible alias pairs.) In the worst case, 5 the lookup and can make the update dead as well. the analysis indicates that a location-returning expression could return any location at run time, but in practice, on average fewer than two values are possible <ref> [LRZ93, EGH94, Ruf94a, Ste94a] </ref>. The details of the analysis are irrelevant to the slicing algorithm. 3.3 Slicing algorithm We now extend the slicing algorithm to process lookup nodes, to traverse store edges, and to process update nodes.
Reference: [Ruf94b] <author> Erik Ruf. </author> <title> Optimizing sparse representations for dataflow analysis. </title> <note> Submitted for publication, </note> <month> September </month> <year> 1994. </year>
Reference-contexts: The lookup (and possibly the update as well) becomes dead and can be removed from the graph. Figure 4 demonstrates this "short-circuiting" transformation, which, along with arity raising <ref> [WCES94b, Ruf94b] </ref>, eliminated all store operations from Figure 2. <p> Additionally, information about pointers is easy to reflect in the graph (by short-circuiting (Figure 4), store splitting [SW93, Ste94b], and other transformations), making it immediately available to all analyses. 3.2 Pointer analysis VDGomatic makes use of a points-to analysis <ref> [CWZ90, HEGV93, Ruf94b] </ref>, which indicates the possible values for each location-valued expression. (In our representation a points-to analysis is more natural than an alias analysis, which produces a set of possible alias pairs.) In the worst case, 5 the lookup and can make the update dead as well. the analysis indicates
Reference: [Ste93] <author> Bjarne Steensgaard. </author> <title> Sequentializing program dependence graphs for irreducible programs. </title> <type> Technical Report MSR-TR-93-14, </type> <institution> Microsoft Research, </institution> <address> Redmond, WA, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: A program's VDG can be computed in linear time, even for programs with irreducible control flow. Furthermore, efficient code can be generated from the VDG <ref> [WCES94b, Ste93] </ref>. 2.2 Basic slicing algorithm The basic slicing algorithm [OO84] on the VDG is extremely simple. A slice consists of all computations encountered in a graph traversal starting at the slicing criterion, which is a particular dependence (value) arc.
Reference: [Ste94a] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <note> Submitted for publication, </note> <month> November </month> <year> 1994. </year>
Reference-contexts: alias analysis, which produces a set of possible alias pairs.) In the worst case, 5 the lookup and can make the update dead as well. the analysis indicates that a location-returning expression could return any location at run time, but in practice, on average fewer than two values are possible <ref> [LRZ93, EGH94, Ruf94a, Ste94a] </ref>. The details of the analysis are irrelevant to the slicing algorithm. 3.3 Slicing algorithm We now extend the slicing algorithm to process lookup nodes, to traverse store edges, and to process update nodes.
Reference: [Ste94b] <author> Bjarne Steensgaard. </author> <title> Sparse functional stores for imperative programs. </title> <type> Manuscript, </type> <month> October </month> <year> 1994. </year>
Reference-contexts: Additionally, information about pointers is easy to reflect in the graph (by short-circuiting (Figure 4), store splitting <ref> [SW93, Ste94b] </ref>, and other transformations), making it immediately available to all analyses. 3.2 Pointer analysis VDGomatic makes use of a points-to analysis [CWZ90, HEGV93, Ruf94b], which indicates the possible values for each location-valued expression. (In our representation a points-to analysis is more natural than an alias analysis, which produces a set
Reference: [SW93] <author> Bjarne Steensgaard and Daniel Weise. </author> <title> A sparse representation for programs with pointers. </title> <type> Manuscript, </type> <month> November </month> <year> 1993. </year>
Reference-contexts: Additionally, information about pointers is easy to reflect in the graph (by short-circuiting (Figure 4), store splitting <ref> [SW93, Ste94b] </ref>, and other transformations), making it immediately available to all analyses. 3.2 Pointer analysis VDGomatic makes use of a points-to analysis [CWZ90, HEGV93, Ruf94b], which indicates the possible values for each location-valued expression. (In our representation a points-to analysis is more natural than an alias analysis, which produces a set
Reference: [Ven93] <author> G. A. Venkatesh. </author> <title> Experimental results from slicing C programs. </title> <note> Submitted for publication, Octo-ber 19, </note> <year> 1993. </year>
Reference-contexts: This paper addresses static slicing, which uses analysis to discover dependences and indicates the program components that may have an effect on (or may be affected by) the slicing criterion values. By contrast, a dynamic slice <ref> [AH90, Agr91, Ven93] </ref> gives definite information for some particular execution by maintaining an execution trace of a running program.
Reference: [WCES94a] <author> Daniel Weise, Roger F. Crew, Michael Ernst, and Bjarne Steensgaard. </author> <title> Value dependence graphs: Representation without taxation. </title> <booktitle> In Proceedings of the Twenty First Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 297-310, </pages> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Later sections further detail and enhance the algorithm. 2.1 The value dependence graph The value dependence graph (VDG) <ref> [WCES94a, WCES94b] </ref> is a sparse, parallel, functional, dataflow-like program representation for imperative programs. It is sparse because it directly connects consumers to producers of values, enabling fast, incremental analyses and transformations. It is parallel because it makes no commitment regarding the relative order of noninterfering computations.
Reference: [WCES94b] <author> Daniel Weise, Roger F. Crew, Michael Ernst, and Bjarne Steensgaard. </author> <title> Value dependence graphs: Representation without taxation. </title> <type> Technical Report MSR-TR-94-03, </type> <institution> Microsoft Research, </institution> <address> Redmond, WA, </address> <month> April 13, </month> <year> 1994. </year>
Reference-contexts: Later sections further detail and enhance the algorithm. 2.1 The value dependence graph The value dependence graph (VDG) <ref> [WCES94a, WCES94b] </ref> is a sparse, parallel, functional, dataflow-like program representation for imperative programs. It is sparse because it directly connects consumers to producers of values, enabling fast, incremental analyses and transformations. It is parallel because it makes no commitment regarding the relative order of noninterfering computations. <p> A program's VDG can be computed in linear time, even for programs with irreducible control flow. Furthermore, efficient code can be generated from the VDG <ref> [WCES94b, Ste93] </ref>. 2.2 Basic slicing algorithm The basic slicing algorithm [OO84] on the VDG is extremely simple. A slice consists of all computations encountered in a graph traversal starting at the slicing criterion, which is a particular dependence (value) arc. <p> The lookup (and possibly the update as well) becomes dead and can be removed from the graph. Figure 4 demonstrates this "short-circuiting" transformation, which, along with arity raising <ref> [WCES94b, Ruf94b] </ref>, eliminated all store operations from Figure 2.
Reference: [Wei84] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year> <month> 16 </month>
Reference-contexts: 1 Introduction Program slicing <ref> [Wei84] </ref> is a technique for visualizing dependences and restricting attention to just the components of a program relevant to evaluation of the slicing criterion, which is the particular expression (s) of interest.
References-found: 25

