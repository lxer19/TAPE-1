URL: file://ftp.gvu.gatech.edu/pub/gvu/tech-reports/95-21.ps.Z
Refering-URL: http://www.cs.gatech.edu/grads/m/Scott.McCrickard/Scott.Mccrickard.html
Root-URL: 
Title: Real Clock Time Animation Support for Developing Software Visualizations  
Author: John. T. Stasko D. Scott McCrickard 
Keyword: software visualization, algorithm animation, computer graphics, graphics libraries and toolkits  
Address: Atlanta, GA 30332-0280 U.S.A.  
Affiliation: Graphics, Visualization, and Usability Center College of Computing Georgia Institute of Technology  
Pubnum: Technical Report GIT-GVU-95-21  
Email: E-mail: fmccricks,staskog@cc.gatech.edu  
Date: July 1995  
Abstract: Developers building software visualizations must use a graphics library and user interface toolkit as an underlying support platform. Often, these support environments are large, difficult to learn, low-level, and lacking primitives for capabilities such as animation. We have developed a graphics support environment called Polka-RC for building software visualizations. Polka-RC is a second generation system that leverages the continuous animation primitives of the mature system Polka, and adds the capability of specifying real clock time-based animation activations and durations. The new Polka-RC animation model also provides a flexible multiprocess program-to-visualization mapping. In this article we describe the Polka-RC methodology, list advantages of the approach, and describe how the methodology influences the design of software visualizations and algorithm animations. 
Abstract-found: 1
Intro-found: 1
Reference: [BH92] <author> Marc H. Brown and John Hershberger. </author> <title> Color and sound in algorithm animation. </title> <journal> Computer, </journal> <volume> 25(12) </volume> <pages> 52-63, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Over time these toolkits have evolved to be quite sophisticated graphics systems. The early Balsa environments provided black-and-white images in multiple views [BS85]; Animus provided temporal constraints in a Smalltalk based environment [Dui86]; Tango added color and smooth animation primitives [Sta90]; Zeus added sound in a general object-oriented framework <ref> [BH92] </ref>; Polka-3D examined the use of 3D for software visualization [SW93]; and recent systems have focused on high-level, powerful toolkit primitives [DeT93].
Reference: [Bro88a] <author> Marc H. Brown. </author> <title> Exploring algorithms using Balsa-II. </title> <journal> Computer, </journal> <volume> 21(5) </volume> <pages> 14-36, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: By providing concrete graphical depictions of the normally intangible abstract workings of programs, software visualizers seek to facilitate program understanding and comprehension. Software visualization systems have been used for a number of different purposes, ranging from instructional aids for teaching algorithms (so called algorithm animations <ref> [Bro88b, Bro88a, Sta90] </ref>) to software engineering tools to assist program development and debugging [Rei85, SI91, KRR94]. In all software visualization systems, the visualization or animation depicted must be built using an underlying graphics support environment.
Reference: [Bro88b] <author> Marc H. Brown. </author> <title> Perspectives on algorithm animation. </title> <booktitle> In Proceedings of the ACM SIGCHI '88 Conference on Human Factors in Computing Systems, </booktitle> <pages> pages 33-38, </pages> <address> Washington D.C., </address> <month> May </month> <year> 1988. </year>
Reference-contexts: By providing concrete graphical depictions of the normally intangible abstract workings of programs, software visualizers seek to facilitate program understanding and comprehension. Software visualization systems have been used for a number of different purposes, ranging from instructional aids for teaching algorithms (so called algorithm animations <ref> [Bro88b, Bro88a, Sta90] </ref>) to software engineering tools to assist program development and debugging [Rei85, SI91, KRR94]. In all software visualization systems, the visualization or animation depicted must be built using an underlying graphics support environment.
Reference: [BS85] <author> Marc H. Brown and Robert Sedgewick. </author> <title> Techniques for algorithm animation. </title> <journal> IEEE Software, </journal> <volume> 2(1) </volume> <pages> 28-39, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Over time these toolkits have evolved to be quite sophisticated graphics systems. The early Balsa environments provided black-and-white images in multiple views <ref> [BS85] </ref>; Animus provided temporal constraints in a Smalltalk based environment [Dui86]; Tango added color and smooth animation primitives [Sta90]; Zeus added sound in a general object-oriented framework [BH92]; Polka-3D examined the use of 3D for software visualization [SW93]; and recent systems have focused on high-level, powerful toolkit primitives [DeT93].
Reference: [DeT93] <author> John DeTreville. </author> <title> The GraphVBT interface for programming algorithm animations. </title> <booktitle> In Proceedings of the 1993 IEEE Symposium on Visual Languages, </booktitle> <pages> pages 26-31, </pages> <address> Bergen, Norway, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: multiple views [BS85]; Animus provided temporal constraints in a Smalltalk based environment [Dui86]; Tango added color and smooth animation primitives [Sta90]; Zeus added sound in a general object-oriented framework [BH92]; Polka-3D examined the use of 3D for software visualization [SW93]; and recent systems have focused on high-level, powerful toolkit primitives <ref> [DeT93] </ref>. One area yet to be explored, however, is the capability of real clock time animations, that is, animations whose initiation and duration are specified in physical times of milliseconds, seconds, and so on.
Reference: [Dui86] <author> Robert A. Duisberg. </author> <title> Animated graphical interfaces using temporal constraints. </title> <booktitle> In Proceedings of the ACM SIGCHI '86 Conference on Human Factors in Computing Systems, </booktitle> <pages> pages 131-136, </pages> <address> Boston, MA, </address> <month> April </month> <year> 1986. </year>
Reference-contexts: Over time these toolkits have evolved to be quite sophisticated graphics systems. The early Balsa environments provided black-and-white images in multiple views [BS85]; Animus provided temporal constraints in a Smalltalk based environment <ref> [Dui86] </ref>; Tango added color and smooth animation primitives [Sta90]; Zeus added sound in a general object-oriented framework [BH92]; Polka-3D examined the use of 3D for software visualization [SW93]; and recent systems have focused on high-level, powerful toolkit primitives [DeT93].
Reference: [HS93] <author> Scott E. Hudson and John T. Stasko. </author> <title> Animation support in a user interface toolkit: Flexible, robust and reusable abstractions. </title> <booktitle> In Proceedings of the 1993 ACM Symposium on User Interface Software and Technology, </booktitle> <pages> pages 57-67, </pages> <address> At-lanta, GA, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: These types of animation environments have long existed in 3D computer graphics where an exact frames-per-second rate is used, and recently they have surfaced in user interface development toolkits <ref> [HS93] </ref>. We have built a software visualization support toolkit called Polka-RC (Polka Real Clock) that provides such primitives. Polka-RC is an evolution of the mature software visualization toolkit called Polka [SK93] that provides frame, as opposed to time, based animations. <p> These inquiries led us to develop Polka-RC. 3 Polka-RC The following sections describe the Polka-RC environment, highlighting the differences between it and the original Polka. We begin by describing the new real time animation primitives introduced in Polka-RC, which are partly modeled after those introduced in <ref> [HS93] </ref>. Next, we describe the two process, asynchronous communication model that the environment supports, and we give a small example of what code in Polka-RC looks like. <p> Efforts could be made to estimate the delay and adjust accordingly, but delay spikes (times when the system is busy and delay is high) can cause the delay to be overestimated <ref> [HS93] </ref>. When the next timeout occurs, it may be earlier than the last estimated update time, which would result in the AnimObjects moving backwards! Since the out-of-date time is very small, we decided it was acceptable. As in the original Polka, there are two phases in updating a View.
Reference: [KRR94] <author> Doug Kimelman, Bryan Rosenburg, and Tova Roth. Strata-Various: </author> <title> Multi-layer visualization of dynamics in software system behavior. </title> <booktitle> In Proceedings of the IEEE Visualization '94 Conference, </booktitle> <pages> pages 172-178, </pages> <address> Washington, D.C., </address> <month> October </month> <year> 1994. </year>
Reference-contexts: Software visualization systems have been used for a number of different purposes, ranging from instructional aids for teaching algorithms (so called algorithm animations [Bro88b, Bro88a, Sta90]) to software engineering tools to assist program development and debugging <ref> [Rei85, SI91, KRR94] </ref>. In all software visualization systems, the visualization or animation depicted must be built using an underlying graphics support environment.
Reference: [Las87] <author> J. Lassiter. </author> <title> Principles of traditional animation applied to 3d concurrent animation. </title> <booktitle> In Proceedings of SIGGRAPH '87, </booktitle> <pages> pages 35-44, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Also, we might want the motion to start slowly, speed up, then slow again near its termination, one of the classic animation techniques for presenting movement <ref> [Las87] </ref>. In addition, we want a model in which the animation occurs concurrently with the execution of the program it is representing, without the need for an explicit Animate call. Finally, we wondered how this type of toolkit would influence the design of software visualizations and animations. <p> However, it can be useful to traverse a curve at different speeds depending on the current position on the curve. For example, it has been shown that slowly building up the speed of an object as it begins a motion (called "slow out") helps draw attention to the object <ref> [Las87] </ref>. Similarly, slowing down the speed of an object as it is about to stop (called "slow in") indicates to a viewer that the object is about to stop. A pace function is a way to specify the rate at which a curve is traversed.
Reference: [MS94] <author> Sougata Mukherjea and John T. Stasko. </author> <title> Toward visual debugging: Integrating algorithm animation capabilities within a source level debugger. </title> <journal> ACM Transactions on Computer-Human Interaction, </journal> <volume> 1(3) </volume> <pages> 215-244, </pages> <month> September </month> <year> 1994. </year> <month> 18 </month>
Reference-contexts: This graphics support can be a powerful, but low-level toolkit such as Xlib for X Windows, or it can be an extremely high level interactive visual environment such as the Lens system <ref> [MS94] </ref>. A trade-off exists in these two alternatives. Low-level toolkits are very powerful and can provide rich visualizations, yet they are usually quite large, difficult to learn, and building visualizations with them can be time-consuming.
Reference: [PBS93] <author> Blaine A. Price, Ronald M. Baecker, and Ian S. </author> <title> Small. A principled taxonomy of software visualization. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 4(3) </volume> <pages> 211-266, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Many instructional techniques and software tools have been developed over the past 30 years to aid these activities. This article examines the area of software visualization, the use of computer graphics, visualization, and animation to help illustrate how algorithms and programs work <ref> [SP92, PBS93] </ref>. By providing concrete graphical depictions of the normally intangible abstract workings of programs, software visualizers seek to facilitate program understanding and comprehension.
Reference: [Rei85] <author> Steve P. Reiss. </author> <title> Pecan: Program development systems that support multiple views. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(3):276-285, </volume> <month> March </month> <year> 1985. </year>
Reference-contexts: Software visualization systems have been used for a number of different purposes, ranging from instructional aids for teaching algorithms (so called algorithm animations [Bro88b, Bro88a, Sta90]) to software engineering tools to assist program development and debugging <ref> [Rei85, SI91, KRR94] </ref>. In all software visualization systems, the visualization or animation depicted must be built using an underlying graphics support environment.
Reference: [SI91] <author> Takao Shimomura and Sadahiro Isoda. </author> <title> Linked-list visualization for debugging. </title> <journal> IEEE Software, </journal> <volume> 8(3) </volume> <pages> 44-51, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Software visualization systems have been used for a number of different purposes, ranging from instructional aids for teaching algorithms (so called algorithm animations [Bro88b, Bro88a, Sta90]) to software engineering tools to assist program development and debugging <ref> [Rei85, SI91, KRR94] </ref>. In all software visualization systems, the visualization or animation depicted must be built using an underlying graphics support environment.
Reference: [SK93] <author> John T. Stasko and Eileen Kraemer. </author> <title> A methodology for building application-specific visualizations of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18(2) </volume> <pages> 258-264, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: We have built a software visualization support toolkit called Polka-RC (Polka Real Clock) that provides such primitives. Polka-RC is an evolution of the mature software visualization toolkit called Polka <ref> [SK93] </ref> that provides frame, as opposed to time, based animations. In the next section we provide a brief review of Polka and its components. After that, we describe Polka-RC and the primitives it provides, and we give some examples of its use.
Reference: [SP92] <author> John T. Stasko and Charles Patterson. </author> <title> Understanding and characterizing software visualization systems. </title> <booktitle> In Proceedings of the 1992 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 3-10, </pages> <address> Seattle, WA, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: Many instructional techniques and software tools have been developed over the past 30 years to aid these activities. This article examines the area of software visualization, the use of computer graphics, visualization, and animation to help illustrate how algorithms and programs work <ref> [SP92, PBS93] </ref>. By providing concrete graphical depictions of the normally intangible abstract workings of programs, software visualizers seek to facilitate program understanding and comprehension.
Reference: [Sta90] <author> John T. Stasko. </author> <title> TANGO: A framework and system for algorithm animation. </title> <journal> Computer, </journal> <volume> 23(9) </volume> <pages> 27-39, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: By providing concrete graphical depictions of the normally intangible abstract workings of programs, software visualizers seek to facilitate program understanding and comprehension. Software visualization systems have been used for a number of different purposes, ranging from instructional aids for teaching algorithms (so called algorithm animations <ref> [Bro88b, Bro88a, Sta90] </ref>) to software engineering tools to assist program development and debugging [Rei85, SI91, KRR94]. In all software visualization systems, the visualization or animation depicted must be built using an underlying graphics support environment. <p> Over time these toolkits have evolved to be quite sophisticated graphics systems. The early Balsa environments provided black-and-white images in multiple views [BS85]; Animus provided temporal constraints in a Smalltalk based environment [Dui86]; Tango added color and smooth animation primitives <ref> [Sta90] </ref>; Zeus added sound in a general object-oriented framework [BH92]; Polka-3D examined the use of 3D for software visualization [SW93]; and recent systems have focused on high-level, powerful toolkit primitives [DeT93].
Reference: [SW93] <author> John T. Stasko and Joseph F. Wehrli. </author> <title> Three-dimensional computation visualization. </title> <booktitle> In Proceedings of the 1993 IEEE Symposium on Visual Languages, </booktitle> <pages> pages 100-107, </pages> <address> Bergen, Norway, </address> <month> August </month> <year> 1993. </year> <month> 19 </month>
Reference-contexts: The early Balsa environments provided black-and-white images in multiple views [BS85]; Animus provided temporal constraints in a Smalltalk based environment [Dui86]; Tango added color and smooth animation primitives [Sta90]; Zeus added sound in a general object-oriented framework [BH92]; Polka-3D examined the use of 3D for software visualization <ref> [SW93] </ref>; and recent systems have focused on high-level, powerful toolkit primitives [DeT93]. One area yet to be explored, however, is the capability of real clock time animations, that is, animations whose initiation and duration are specified in physical times of milliseconds, seconds, and so on.
References-found: 17

