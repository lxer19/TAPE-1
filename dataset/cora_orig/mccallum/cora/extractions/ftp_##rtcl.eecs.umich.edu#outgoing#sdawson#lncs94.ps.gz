URL: ftp://rtcl.eecs.umich.edu/outgoing/sdawson/lncs94.ps.gz
Refering-URL: http://www.eecs.umich.edu/~farnam/papers/pubs.html
Root-URL: http://www.cs.umich.edu
Email: fsdawson,farnamg@eecs.umich.edu  
Title: Deterministic Fault Injection of Distributed Systems  
Author: Scott Dawson Farnam Jahanian 
Address: Ann Arbor, MI 48109-2122  
Affiliation: Real-Time Computing Laboratory Electrical Engineering and Computer Science Department University of Michigan  
Abstract: Ensuring that a system meets its prescribed specification is a growing challenge that confronts software developers and system engineers. Meeting this challenge is particularly important for distributed systems with strict dependability and timeliness constraints. This paper presents a technique, called script-driven probing and fault injection, for the evaluation and validation of dependable protocols. The proposed approach can be used to demonstrate three aspects of a target protocol: i) detection of design or implementation errors, ii) identification of violations of protocol specifications, and iii) insight into design decisions made by the implementors. To demonstrate the capabilities of this technique, the paper briefly describes a probing and fault injection tool, called the PFI tool, and several experiments on two protocols: the Transmission Control Protocol (TCP) [4, 24] and the Group Membership Protocol (GMP) [19]. The tool can be used to delay, drop, reorder, duplicate, and modify messages. It can also introduce new messages into the system to probe participants. In the case of TCP, we used the PFI tool to duplicate the experiments reported in [7] on several TCP implementations without access to the vendors' TCP source code in a very short time. We also ran several new experiments that are difficult to perform using past approaches based on packet monitoring and filtering. In the case of GMP, we used the tool to test the fault-tolerance capabilities of an implementation under various failure models including daemon/link crash, send/receive omissions, and timing failures. Furthermore, by selective reordering of messages and spontaneous transmission of new messages, we were able to guide a distributed computation into hard to reach global states without instrumenting the protocol implementation.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. Arlat, Y. Crouzet, and J.-C. Laprie. </author> <title> Fault injection for dependability validation of fault-tolerant computing systems. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 348-355, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Our experience in testing the fault-tolerance capabilities of the Group Membership Protocol (GMP), as described in Section 3, seems to support this view. Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection <ref> [13, 27, 1] </ref> and simulation approaches for injecting hardware failures [6, 14, 9] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 26].
Reference: 2. <author> Jean Arlat, Martine Aguera, Yves Crouzet, Jean-Charles Fabre, Eliane Martins, and David Powell. </author> <title> Experimental evaluation of the fault tolerance of an atomic multicast system. </title> <journal> IEEE Trans. Reliability, </journal> <volume> 39(4) </volume> <pages> 455-467, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: However, fault-injection and testing dependability of distributed systems has received very little attention until recently [11, 12, 3, 16]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. For example, the work reported in <ref> [2] </ref> calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol in the presence of faults. Other work can be characterized as probabilistic approaches to test generation [11, 3].
Reference: 3. <author> D. Avresky, J. Arlat, J.C. Laprie, and Yves Crouzet. </author> <title> Fault injection for the formal testing of fault tolerance. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 345-354. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 26]. Others have emulated fault-injection into CPU components [20], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [11, 12, 3, 16] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> For example, the work reported in [2] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol in the presence of faults. Other work can be characterized as probabilistic approaches to test generation <ref> [11, 3] </ref>. The work reported in [16] focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor.
Reference: 4. <author> R. Braden. RFC-1122: </author> <title> Requirements for internet hosts. Request for Comments, </title> <month> October </month> <year> 1989. </year> <institution> Network Information Center. </institution>
Reference-contexts: Because TCP is designed to operate over links of different speeds and reliability, it is widely used on the Internet. TCP was originally defined in RFC-793 [24] and was updated in RFC-1122 <ref> [4] </ref>. In order to meet the TCP standard, an implementation must follow both RFCs. For testing TCP, we modified an x-kernel protocol stack to include a layer which incorporates the PFI tool. We call this layer the PFI layer.
Reference: 5. <author> R. Chillarege and N. S. Bowen. </author> <title> Understanding large system failures | a fault injection experiment. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 356-363, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Hardware fault-injection [13, 27, 1] and simulation approaches for injecting hardware failures [6, 14, 9] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors <ref> [5, 26] </ref>. Others have emulated fault-injection into CPU components [20], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [11, 12, 3, 16].
Reference: 6. <author> G. Choi, R. Iyer, and V. Carreno. </author> <title> Simulated fault injection: A methodology to evaluate fault tolerant microprocessor architectures. </title> <journal> IEEE Trans. Reliability, </journal> <volume> 39(4) </volume> <pages> 486-490, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection [13, 27, 1] and simulation approaches for injecting hardware failures <ref> [6, 14, 9] </ref> have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 26]. Others have emulated fault-injection into CPU components [20], typically by setting voltages on pins or wires.
Reference: 7. <author> Douglas E. Comer and John C. Lin. </author> <title> Probing TCP implementations. </title> <booktitle> In Proc. Summer USENIX Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Another closely related work is the active probing approach proposed in a recent paper by Comer and Lin <ref> [7] </ref> to study five TCP implementations. Active probing treats a TCP implementation as a black box, and it uses a set of user-level procedures to probe the black box. Using the NetMetrix protocol analyzer and monitor tools, trace data is gathered and analyzed to reveal characteristics of various TCP implementations. <p> Using the NetMetrix protocol analyzer and monitor tools, trace data is gathered and analyzed to reveal characteristics of various TCP implementations. In addition to repeating TCP experiments similar to those reported in <ref> [7] </ref>, our approach allows other tests that are not possible with techniques that are based primarily on monitoring and gathering trace data. In particular, our approach differs from the active probing technique in four major aspects.
Reference: 8. <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> (4):175-187, 1991. 
Reference-contexts: A member may depart from a group due to a normal shutdown, such as a scheduled maintenance, or due to a failure. The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., <ref> [8, 25, 22] </ref>. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in [19], ensures that membership changes are seen in the same order by all members.
Reference: 9. <author> E. Czeck and D. Siewiorek. </author> <title> Effects of transient gate-level faults on program be-haviour. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 236-243. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection [13, 27, 1] and simulation approaches for injecting hardware failures <ref> [6, 14, 9] </ref> have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 26]. Others have emulated fault-injection into CPU components [20], typically by setting voltages on pins or wires.
Reference: 10. <author> Scott Dawson and Farnam Jahanian. </author> <title> Probing and fault injection of protocol implementations. </title> <type> Technical Report CSE-TR-217-94, </type> <institution> The University of Michigan, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: In order to demonstrate the effectiveness of this approach, we developed a tool based on the concept of script-driven probing and fault injection. We also performed experimental studies of of several protocol implementations. A detailed description of the tool and the results of the experiments appears in <ref> [10] </ref>. The remainder of this paper is organized as follows: Section 2 presents the approach for probing and fault injection of distributed systems. Section 3 presents an overview of two experimental studies on several implementations of TCP and GMP protocols. Section 4 describes related work. <p> The tool is meant to be inserted into a protocol stack as a separate layer of the stack below a target protocol. A detailed description of the PFI tool and several experiments appears in <ref> [10] </ref>. This section presents an overview of the results of extensive fault injection experiments on several commercial implementations of TCP and a prototype implementation of a Group Membership Protocol (GMP).
Reference: 11. <author> K. Echtle and Y. Chen. </author> <title> Evaluation of deterministic fault injection for fault-tolerant protocol testing. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 418-425. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 26]. Others have emulated fault-injection into CPU components [20], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [11, 12, 3, 16] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> For example, the work reported in [2] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol in the presence of faults. Other work can be characterized as probabilistic approaches to test generation <ref> [11, 3] </ref>. The work reported in [16] focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor. <p> The tool is used mainly for emulating a wide-area network in a local network development environment and allows the user to specify delays on certain paths which the application is using. This work and that reported in <ref> [11] </ref> are closest to the approach proposed here. Rather than estimating fault coverages for evaluating dependability of distributed systems, this work focuses on techniques for identifying violations of protocol specifications and for detecting design or implementations errors.
Reference: 12. <author> Klaus Echtle and Martin Leu. </author> <title> The EFA fault injector for fault-tolerant distributed system testing. </title> <booktitle> In Workshop on Fault-Tolerant Parallel and Distributed Systems, </booktitle> <pages> pages 28-35. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 26]. Others have emulated fault-injection into CPU components [20], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [11, 12, 3, 16] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics.
Reference: 13. <author> G. Finelli. </author> <title> Characterization of fault recovery through fault injection on ftmp. </title> <journal> IEEE Trans. Reliability, </journal> <volume> 36(2) </volume> <pages> 164-170, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Our experience in testing the fault-tolerance capabilities of the Group Membership Protocol (GMP), as described in Section 3, seems to support this view. Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection <ref> [13, 27, 1] </ref> and simulation approaches for injecting hardware failures [6, 14, 9] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 26].
Reference: 14. <author> K. Goswami and R. Iyer. </author> <title> Simulation of software behaviour under hardware faults. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 218-227. </pages> <publisher> IEEE, </publisher> <year> 1993. </year>
Reference-contexts: Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection [13, 27, 1] and simulation approaches for injecting hardware failures <ref> [6, 14, 9] </ref> have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 26]. Others have emulated fault-injection into CPU components [20], typically by setting voltages on pins or wires.
Reference: 15. <author> Vassos Hadzilacos and Sam Toueg. </author> <title> Fault-tolerant broadcasts and related problems. In Sape Mullender, editor, Distributed Systems. </title> <publisher> Addison Wesley, </publisher> <year> 1993. </year> <note> Second Edition. </note>
Reference-contexts: The fault injection approach introduced earlier can test the fault-tolerance capabilities of protocol implementations under various failure models commonly found in the distributed systems literature including: process crash failures, link crash failures, send omission failures, receive omission failures, timing/performance failures, and arbitrary/byzantine failures <ref> [15] </ref>. 3 Experimental Results In order to demonstrate the effectiveness of the approach presented in Section 2, we developed a tool based on the concept of script-driven probing and fault injection. We also performed extensive experimental studies of several commercial and prototype distributed protocols.
Reference: 16. <author> Seungjae Han, Harold A. Rosenberg, and Kang G. Shin. DOCTOR: </author> <title> An integrateD sOftware fault injeCTOn enviRonment. </title> <type> Technical Report CSE-TR-192-93, </type> <institution> The University of Michigan, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 26]. Others have emulated fault-injection into CPU components [20], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [11, 12, 3, 16] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> Other work can be characterized as probabilistic approaches to test generation [11, 3]. The work reported in <ref> [16] </ref> focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor. The Delayline tool presented in [18] allows the user to introduce delays into user-level protocols.
Reference: 17. <author> Norman C. Hutchinson and Larry L. Peterson. </author> <title> The x-Kernel: An architecture for implementing network protocols. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 17(1) </volume> <pages> 1-13, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Section 5 presents concluding remarks and describes future directions of this work. 2 Approach 2.1 Script-Driven Probing and Fault Injection The proposed approach views a distributed protocol as an abstraction through which a collection of participants communicate by exchanging a set of messages, in the same spirit as the x-kernel <ref> [17] </ref>. In this model, we make no distinction between application-level protocols, interprocess communication protocols, network protocols, or device layer protocols.
Reference: 18. <author> David B. Ingham and Graham D. Parrington. Delayline: </author> <title> A wide-area network emulation tool. </title> <journal> Computing Systems, </journal> <volume> 7(3) </volume> <pages> 313-332, </pages> <month> Summer </month> <year> 1994. </year>
Reference-contexts: The work reported in [16] focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor. The Delayline tool presented in <ref> [18] </ref> allows the user to introduce delays into user-level protocols. The tool is used mainly for emulating a wide-area network in a local network development environment and allows the user to specify delays on certain paths which the application is using.
Reference: 19. <author> Farnam Jahanian, Ragunathan Rajkumar, and Sameh Fakhouri. </author> <title> Processor group membership protocols: Specification, </title> <booktitle> design and implementation. In Proceedings of the 12th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <address> Princeton, New Jersey, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: Table 1. TCP Retransmission Timeout Results 3.2 Testing of GMP The objective of the experiments described in this subsection is to test the fault-tolerance capabilities of a prototype implementation of the strong group membership protocol <ref> [19] </ref> using the probe and fault injection technique presented earlier. In a distributed environment, a collection of processes (or processors) can be grouped together to provide a service. <p> The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., [8, 25, 22]. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in <ref> [19] </ref>, ensures that membership changes are seen in the same order by all members. In this protocol, a group of processors have a unique leader based on the processor id of each member.
Reference: 20. <author> G.A Kanawati, N.A. Kanawati, and J.A. Abraham. FERRARI: </author> <title> A tool for the validation of system dependability properties. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 336-344. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Hardware fault-injection [13, 27, 1] and simulation approaches for injecting hardware failures [6, 14, 9] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 26]. Others have emulated fault-injection into CPU components <ref> [20] </ref>, typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [11, 12, 3, 16]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics.
Reference: 21. <author> Steven McCanne and Van Jacobson. </author> <title> The bsd packet filter: A new architecture for user-level packet capture. </title> <booktitle> In Winter USENIX Conference, </booktitle> <pages> pages 259-269, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter [23], a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator <ref> [21] </ref>, and the Mach Packet Filter (MPF) [28] which is an extension of the BPF, are related to the work presented in this paper. In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network.
Reference: 22. <author> Shivakant Mishra, Larry L. Peterson, and Richard D. Schlichting. </author> <title> A membership protocol based on partial order. </title> <booktitle> In Second Working Conference on Dependable Computing for Critical Applications, </booktitle> <month> February </month> <year> 1990. </year>
Reference-contexts: A member may depart from a group due to a normal shutdown, such as a scheduled maintenance, or due to a failure. The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., <ref> [8, 25, 22] </ref>. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in [19], ensures that membership changes are seen in the same order by all members.
Reference: 23. <author> J. Mogul, R. Rashid, and M. Accetta. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proc. ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year> <note> ACM. </note>
Reference-contexts: To minimize data copying across kernel/user-space protection boundaries, a kernel agent, called a packet filter, is often used to discard unwanted packets as early as possible. Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter <ref> [23] </ref>, a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator [21], and the Mach Packet Filter (MPF) [28] which is an extension of the BPF, are related to the work presented in this paper.
Reference: 24. <author> Jon Postel. RFC-793: </author> <title> Transmission control protocol. Request for Comments, </title> <month> September </month> <year> 1981. </year> <institution> Network Information Center. </institution>
Reference-contexts: TCP is connection-oriented protocol that uses flow-control between protocol participants to operate over network connections that are inherently unreliable. Because TCP is designed to operate over links of different speeds and reliability, it is widely used on the Internet. TCP was originally defined in RFC-793 <ref> [24] </ref> and was updated in RFC-1122 [4]. In order to meet the TCP standard, an implementation must follow both RFCs. For testing TCP, we modified an x-kernel protocol stack to include a layer which incorporates the PFI tool. We call this layer the PFI layer.
Reference: 25. <author> A. M. Ricciardi and K. P. Birman. </author> <title> Using process groups to implement failure detection in asynchronous environments. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Montreal, Quebec, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: A member may depart from a group due to a normal shutdown, such as a scheduled maintenance, or due to a failure. The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., <ref> [8, 25, 22] </ref>. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in [19], ensures that membership changes are seen in the same order by all members.
Reference: 26. <author> Z. Segall et al. </author> <title> Fiat fault injection based automated testing environment. </title> <booktitle> In FTCS-18, </booktitle> <pages> pages 102-107, </pages> <year> 1988. </year>
Reference-contexts: Hardware fault-injection [13, 27, 1] and simulation approaches for injecting hardware failures [6, 14, 9] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors <ref> [5, 26] </ref>. Others have emulated fault-injection into CPU components [20], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [11, 12, 3, 16].
Reference: 27. <author> K. G. Shin and Y. H. Lee. </author> <title> Measurement and application of fault latency. </title> <journal> IEEE Trans. Computers, </journal> <volume> C-35(4):370-375, </volume> <month> April </month> <year> 1986. </year>
Reference-contexts: Our experience in testing the fault-tolerance capabilities of the Group Membership Protocol (GMP), as described in Section 3, seems to support this view. Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection <ref> [13, 27, 1] </ref> and simulation approaches for injecting hardware failures [6, 14, 9] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [5, 26].
Reference: 28. <author> Masanobu Yuhara, Brian N. Bershad, Chris Maeda, and J. Eliot B. Moss. </author> <title> Efficient packet demultiplexing for multiple endpoints and large messages. </title> <booktitle> In Winter USENIX Conference, </booktitle> <month> January </month> <year> 1994. </year> <title> Second Edition. This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter [23], a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator [21], and the Mach Packet Filter (MPF) <ref> [28] </ref> which is an extension of the BPF, are related to the work presented in this paper. In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network.
References-found: 28

