URL: http://www.cs.ucsd.edu/~calder/pfdc/papers/pfdc-truong.ps.Z
Refering-URL: http://www.cs.ucsd.edu/~calder/pfdc/program.html
Root-URL: http://www.cs.ucsd.edu
Email: Dan.Truong@enssat.fr dtruong@irisa.fr  
Title: Considerations on Dynamically Allocated Data Structure Layout Optimization modify their programs to improve their performance,
Author: Dan Truong 
Note: Programmers may be reluctant to  
Address: 22305 Lannion 35042 Rennes FRANCE FRANCE  
Affiliation: ENSSAT-LASTI IRISA 6 rue de Kerampont Campus de Beaulieu  
Abstract: In a previous paper, we proposed two data layout optimizations for dynamically allocated heterogenous data structures, field reorganization and instance interleaving. We proposed that tools for these optimizations be provided within a performance tuning toolbox to help programmers fine-tune their applications. In this communication, we investigate the possibility of automating these optimizations. We show that though we perform the optimization process manually, it is systematic and therefore likely to be automatable at least to some degree. Furthermore, some data-layout constraints related to these optimisations can be removed when the optimization process is automated. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. M. Austin, S. E. Breach, and G. S. Sohi. </author> <title> Efficient detection of all pointer and array access errors. </title> <booktitle> In ACM SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <address> http://www.cs.wisc.edu/ austin/austin.html, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Ialloc reuses the padding space to allocate the fields of other instances, therefore effectively interleaving the fields of different instances. The code transformations necessary can be minimal as shown below for the Ft benchmark <ref> [1] </ref>: BEFORE AFTER graph.h: graph.h: #include "ialloc.h" #define FREE0 (pt) ifree (pt) #define ALLOCATE0 ialloc (Vertices, CHUNKSIZE0, 0) #define CHUNKSIZE0 sizeof (void*) 45 typedef struct _Vertices typedef struct _Vertices 46 - char Pad1 [_IA_INTERLEAVE - sizeof (int)]; 48 Edges * edges; Edges * edges; char Pad2 [_IA_INTERLEAVE - sizeof (void*)]; 49
Reference: [2] <author> D. F. Bacon, S. L. Graham, and O. J. Sharp. </author> <title> Compiler transformations for high-performance computing. </title> <journal> ACM Computing Surveys, </journal> <volume> 26(4):345420, </volume> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: Many layout techniques have already been proposed to optimize arrays and have been shown to be very efficient <ref> [2] </ref>. Therefore, our data-layout optimizations focus on dynamically allocated heterogenous data structures. We proposed in [9] two profile-based data layout techniques, field reorganization and instance interleaving, to improve the spatial and temporal locality of dynamically allocated data structures.
Reference: [3] <author> M. C. Carlisle and A. Rogers. </author> <title> Software caching and computation migration in olden. </title> <type> Technical Report TR-483-95, </type> <institution> Princeton University, </institution> <year> 1995. </year>
Reference-contexts: The other fields of the structure are groupped into more chunks of the same size (or smaller) as the first chunk. Padding arrays are inserted between the chunks and the structure is allocated with the ialloc library to be interleaved, as shown for the Health benchmark <ref> [7, 3, 4] </ref>: BEFORE health.h: 32 struct Patient - 33 int hosps_visited; 34 int time; 35 int time_left; 36 struct Village *home_village; -; 37 38 struct List - 39 struct Patient *patient; 40 struct List *back; 41 struct List *forward; -; health.c: ... list.c: 26 list = (struct List *)mymalloc (sizeof
Reference: [4] <author> C.-K. Luk and T. C. Mowry. </author> <title> Compiler-based prefetching for recursive data structures. </title> <booktitle> In 7th symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <year> 1996. </year>
Reference-contexts: Therefore, our data-layout optimizations focus on dynamically allocated heterogenous data structures. We proposed in [9] two profile-based data layout techniques, field reorganization and instance interleaving, to improve the spatial and temporal locality of dynamically allocated data structures. As opposed to hardware solutions like cache bypassing [10] or prefetching <ref> [4] </ref>, software layout optimizations can improve spatial locality within memory blocks by regroup-ping frequently used data elements together. Therefore after layout optimization, a cache line is more likely to hold data elements with high spatial locality, effectively reducing capacity misses as well as conflict misses. <p> The other fields of the structure are groupped into more chunks of the same size (or smaller) as the first chunk. Padding arrays are inserted between the chunks and the structure is allocated with the ialloc library to be interleaved, as shown for the Health benchmark <ref> [7, 3, 4] </ref>: BEFORE health.h: 32 struct Patient - 33 int hosps_visited; 34 int time; 35 int time_left; 36 struct Village *home_village; -; 37 38 struct List - 39 struct Patient *patient; 40 struct List *back; 41 struct List *forward; -; health.c: ... list.c: 26 list = (struct List *)mymalloc (sizeof

Reference: [6] <author> T. Ozawa, Y. Kimura, and S. Nishizaki. </author> <title> Cache miss heuris tics and preloading techniques for general-purpose pro grams. </title> <booktitle> 28th Annual International Symposium on Microar chitecture, </booktitle> <year> 1995. </year>
Reference-contexts: Truong Considerations on Dynamically Allocated Data Structure Layout Optimization 2. Data layout optimization for dynamically al located data structures Most of the cache misses are usually caused by accesses to dynamically allocated data structures or arrays <ref> [6, 5] </ref>, because these data types are used to store most of the data manipulated by the programs. Many layout techniques have already been proposed to optimize arrays and have been shown to be very efficient [2]. Therefore, our data-layout optimizations focus on dynamically allocated heterogenous data structures.
Reference: [7] <author> A. Rogers, M. Carlisle, J. Reppy, and L. Hendren. </author> <title> Sup porting dynamic data structures on distributed memory ma chines. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(2), </volume> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: The other fields of the structure are groupped into more chunks of the same size (or smaller) as the first chunk. Padding arrays are inserted between the chunks and the structure is allocated with the ialloc library to be interleaved, as shown for the Health benchmark <ref> [7, 3, 4] </ref>: BEFORE health.h: 32 struct Patient - 33 int hosps_visited; 34 int time; 35 int time_left; 36 struct Village *home_village; -; 37 38 struct List - 39 struct Patient *patient; 40 struct List *back; 41 struct List *forward; -; health.c: ... list.c: 26 list = (struct List *)mymalloc (sizeof
Reference: [8] <author> M. D. Smith. </author> <title> Tracing with pixie. </title> <type> Technical Report CSL TR-91-497, </type> <institution> Stanford University, ftp://steward.harvard.edu/users/smith, </institution> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: Profiling It is done using readilly available tools, which are already used for performance tuning. We used SGI's Speedshop package, including Perfex and Ssrun. Ssrun is built on top of Pixie <ref> [8] </ref> and uses hardware counters of the R10000 CPU to count among other things the number of L1 data cache misses caused by program C-source code lines. Often only a few references in the program are responsible for the majority of the cache misses [10].
Reference: [9] <author> D. N. Truong, F. Bodin, and A. Seznec. </author> <title> Improving locality of dynamically allocated data structures. </title> <booktitle> In PACT'98, </booktitle> <month> Oct. </month> <year> 1998. </year>
Reference-contexts: 1. Introduction In a previous paper <ref> [9] </ref>, we proposed two data layout optimizations for dynamically allocated data structures, field reorganization and instance interleaving. We showed that by combining them we were able to improve the performance of memory bound applications which make intensive use of dynamically allocated data structures. <p> Many layout techniques have already been proposed to optimize arrays and have been shown to be very efficient [2]. Therefore, our data-layout optimizations focus on dynamically allocated heterogenous data structures. We proposed in <ref> [9] </ref> two profile-based data layout techniques, field reorganization and instance interleaving, to improve the spatial and temporal locality of dynamically allocated data structures. <p> Since programs often use small data structures [11], field reorganization alone may not be sufficient to speed-up programs. Instance interleaving It is done with the help of the ial-loc library, a special allocation library that we developped to support instance interleaving <ref> [9] </ref>. Padding arrays are inserted between each field in the structure declaration and the instances of the structure are allocated with ialloc/ifree, instead of malloc/free. Ialloc reuses the padding space to allocate the fields of other instances, therefore effectively interleaving the fields of different instances. <p> We have shown in <ref> [9] </ref> that a profile based optimization was likely to provide consistant speedups for different input sets, giving strong incentives to the programmers for using such optimizations. However, these incentives may not be sufficient when software engeneering constraints are taken into account.
Reference: [10] <author> G. Tyson, M. Farrens, J. Matthews, and A. R. Pleszkun. </author> <title> A modified approach to data cache management. </title> <booktitle> 28th Annual International Symposium on Microarchitecture, </booktitle> <year> 1995. </year>
Reference-contexts: Therefore, our data-layout optimizations focus on dynamically allocated heterogenous data structures. We proposed in [9] two profile-based data layout techniques, field reorganization and instance interleaving, to improve the spatial and temporal locality of dynamically allocated data structures. As opposed to hardware solutions like cache bypassing <ref> [10] </ref> or prefetching [4], software layout optimizations can improve spatial locality within memory blocks by regroup-ping frequently used data elements together. Therefore after layout optimization, a cache line is more likely to hold data elements with high spatial locality, effectively reducing capacity misses as well as conflict misses. <p> Often only a few references in the program are responsible for the majority of the cache misses <ref> [10] </ref>. Profile information helps to focus the optimizations onto a few hot spots in the program. <p> Improved cache line reuse reduces the average memory latency while reducing at the same time memory bandwidth consumed. On the other hand, hardware optimizations like cache bypassing <ref> [10] </ref> or prefetching improve average memory latency but may require extra memory bandwidth, since they do not change the program's spatial locality. 4. Conclusion We proposed in a previous paper two profile-based data layout optimizations, field reorganization and instance interleaving.
Reference: [11] <author> B. Zorn and D. Grunwald. </author> <title> Empirical measurment of six allocation-intensive c programs. </title> <journal> ACM Sigplan Notices, </journal> <volume> 27(12):7180, </volume> <month> Dec. </month> <year> 1992. </year> <month> 9 </month>
Reference-contexts: Since programs often use small data structures <ref> [11] </ref>, field reorganization alone may not be sufficient to speed-up programs. Instance interleaving It is done with the help of the ial-loc library, a special allocation library that we developped to support instance interleaving [9].
References-found: 10

