URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3830/3830.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: fshin, saltzg@cs.umd.edu  
Title: Applying DEF/USE Information of Pointer Statements to Traversal-Pattern-Aware Pointer Analysis  
Author: Yuan-Shin Hwang Joel Saltz 
Note: This work was sponsored in part by NSF (ASC-9213821 and CDA9401151).  
Date: July 19, 1997  
Address: College Park, MD 20742  
Affiliation: Department of Computer Science University of Maryland  
Abstract: Pointer analysis is essential for optimizing and parallelizing compilers. It examines pointer assignment statements and estimates pointer-induced aliases among pointer variables or possible shapes of dynamic recursive data structures. However, previously proposed techniques are not able to gather useful information or have to give up further optimizations when overall recursive data structures appear to be cyclic even though patterns of traversal are linear. The reason is that these proposed techniques perform pointer analysis without the knowledge of traversal patterns of dynamic recursive data structures to be constructed. This paper proposes an approach, traversal-pattern-aware pointer analysis, that has the ability to first identify the structures specified by traversal patterns of programs from cyclic data structures and then perform analysis on the specified structures. This paper presents an algorithm to perform shape analysis on the structures specified by traversal patterns. The advantage of this approach is that if the specified structures are recognized to be acyclic, parallelization or optimizations can be applied even when overall data structures might be cyclic. The DEF/USE information of pointer statements is used to relate the identified traversal patterns to the pointer statements which build recursive data structures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Barnes and P. Hut. </author> <title> A hierarchical O(NlogN) force-calculation algorithm. </title> <booktitle> Nature, </booktitle> <pages> pages 446-449, </pages> <month> December </month> <year> 1976. </year>
Reference-contexts: Although the bipartite graph is cyclic, the main traversal structures (lists of E and H nodes) are not. Another example is leaf-connected tree created by the Barnes-Hut N-Body solver <ref> [1] </ref>, as depicted in Figure 1 (b). The structures traversed by the program are a list and a tree, respectively. 1 (a) Bipartite (EM3D) (b) Leaf-Linked Tree (B-H) (c) Cyclic List (Sparse Matrix) that simulate interactions among entities.
Reference: [2] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <journal> SIG-PLAN Notices, </journal> <volume> 25(6) </volume> <pages> 296-310, </pages> <month> June </month> <year> 1990. </year> <booktitle> Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: The characteristic of these pointer analysis approaches is that they estimate the possible locations referenced by each pointer. Shape analysis is another form of pointer analysis. It differs from previous methods by estimating the possible shapes of recursive data structures accessible from pointers <ref> [2, 7, 13, 14] </ref>. The shape information can be exploited to parallelize or optimize programs by providing compilers more insight into the properties of data structures used by programs. <p> The shape graphs presented in this paper are closely related to the Storage Shape Graph (SSG) proposed by Chase et al. <ref> [2] </ref>, the Abstract Storage Graph (ASG) by Plevyak et al. [13], and Shape-Graphs by Sagiv et al. [14] Shape graphs have two types of nodes: pointer stances and storage nodes, which can be further divided into simple nodes that represent allocated allocations and summary nodes each of which represents a set
Reference: [3] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Pointer analysis is essential for optimizing and parallelizing compilers that support languages with pointers like C and Fortran 90. There has been a considerable number of techniques being proposed in this field. Researchers have developed algorithms to detect pointer-induced aliases <ref> [3, 5, 6, 9, 15] </ref>, analyze side effects [3, 10], and identify conflicts/interferences among statements by static analysis [8, 11]. The results of these analysis procedures can be supplied to compilers for optimizations and parallelization on programs with dynamic recursive data structures. <p> 1 Introduction Pointer analysis is essential for optimizing and parallelizing compilers that support languages with pointers like C and Fortran 90. There has been a considerable number of techniques being proposed in this field. Researchers have developed algorithms to detect pointer-induced aliases [3, 5, 6, 9, 15], analyze side effects <ref> [3, 10] </ref>, and identify conflicts/interferences among statements by static analysis [8, 11]. The results of these analysis procedures can be supplied to compilers for optimizations and parallelization on programs with dynamic recursive data structures.
Reference: [4] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: 0 do while (ptr 2 .next) S3 ptr = ptr.next S3 ptr 3 = ptr 2 .next S4 end do S4 end do S5 ptr.next = node S5 ptr 2 .next = node 1 2.3 Intermediate Program Representation Programs will be transformed into an SSA (Static Single Assignment) intermediate representation <ref> [4] </ref>.
Reference: [5] <author> Alain Deutsch. </author> <title> Interprocedural May-Alias analysis for pointers: Beyond k-limiting. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6) </volume> <pages> 230-241, </pages> <month> June </month> <year> 1994. </year> <booktitle> Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: 1 Introduction Pointer analysis is essential for optimizing and parallelizing compilers that support languages with pointers like C and Fortran 90. There has been a considerable number of techniques being proposed in this field. Researchers have developed algorithms to detect pointer-induced aliases <ref> [3, 5, 6, 9, 15] </ref>, analyze side effects [3, 10], and identify conflicts/interferences among statements by static analysis [8, 11]. The results of these analysis procedures can be supplied to compilers for optimizations and parallelization on programs with dynamic recursive data structures.
Reference: [6] <author> Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. </author> <title> Context-sensitive interprocedural Points-to analysis in the presence of function pointers. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6) </volume> <pages> 242-256, </pages> <month> June </month> <year> 1994. </year> <booktitle> Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: 1 Introduction Pointer analysis is essential for optimizing and parallelizing compilers that support languages with pointers like C and Fortran 90. There has been a considerable number of techniques being proposed in this field. Researchers have developed algorithms to detect pointer-induced aliases <ref> [3, 5, 6, 9, 15] </ref>, analyze side effects [3, 10], and identify conflicts/interferences among statements by static analysis [8, 11]. The results of these analysis procedures can be supplied to compilers for optimizations and parallelization on programs with dynamic recursive data structures.
Reference: [7] <author> Rakesh Ghiya and Laurie J. Hendren. </author> <title> Is it a tree, a DAG, or a cyclic graph? A shape analysis for heap-directed pointers in C. </title> <booktitle> In Conference Record of POPL '96: 23nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-15, </pages> <address> St. Petersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: The characteristic of these pointer analysis approaches is that they estimate the possible locations referenced by each pointer. Shape analysis is another form of pointer analysis. It differs from previous methods by estimating the possible shapes of recursive data structures accessible from pointers <ref> [2, 7, 13, 14] </ref>. The shape information can be exploited to parallelize or optimize programs by providing compilers more insight into the properties of data structures used by programs. <p> However, there are cases that even precise shape estimation does not provide useful information for parallelization or optimizations, especially for programs with cyclic data structures but with linear traversal patterns <ref> [7] </ref>. The main reason is because these proposed techniques are performed without taking account of traversal patterns on dynamic recursive data structures by programs. They might gather information that is inappropriate for parallelization and optimizations.
Reference: [8] <author> Laurie J. Hendren and Alexandru Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: There has been a considerable number of techniques being proposed in this field. Researchers have developed algorithms to detect pointer-induced aliases [3, 5, 6, 9, 15], analyze side effects [3, 10], and identify conflicts/interferences among statements by static analysis <ref> [8, 11] </ref>. The results of these analysis procedures can be supplied to compilers for optimizations and parallelization on programs with dynamic recursive data structures. The characteristic of these pointer analysis approaches is that they estimate the possible locations referenced by each pointer. Shape analysis is another form of pointer analysis.
Reference: [9] <author> William Landi and Barbara G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(7) </volume> <pages> 235-248, </pages> <month> July </month> <year> 1992. </year> <booktitle> Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: 1 Introduction Pointer analysis is essential for optimizing and parallelizing compilers that support languages with pointers like C and Fortran 90. There has been a considerable number of techniques being proposed in this field. Researchers have developed algorithms to detect pointer-induced aliases <ref> [3, 5, 6, 9, 15] </ref>, analyze side effects [3, 10], and identify conflicts/interferences among statements by static analysis [8, 11]. The results of these analysis procedures can be supplied to compilers for optimizations and parallelization on programs with dynamic recursive data structures.
Reference: [10] <author> William Landi, Barbara G. Ryder, and Sean Zhang. </author> <title> Interprocedural side effect analysis with pointer aliasing. </title> <journal> SIGPLAN Notices, </journal> <volume> 28(6) </volume> <pages> 56-67, </pages> <month> June </month> <year> 1993. </year> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation. </booktitle> <pages> 17 </pages>
Reference-contexts: 1 Introduction Pointer analysis is essential for optimizing and parallelizing compilers that support languages with pointers like C and Fortran 90. There has been a considerable number of techniques being proposed in this field. Researchers have developed algorithms to detect pointer-induced aliases [3, 5, 6, 9, 15], analyze side effects <ref> [3, 10] </ref>, and identify conflicts/interferences among statements by static analysis [8, 11]. The results of these analysis procedures can be supplied to compilers for optimizations and parallelization on programs with dynamic recursive data structures.
Reference: [11] <author> James R. Larus and Paul N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <journal> SIGPLAN Notices, </journal> <volume> 23(7) </volume> <pages> 21-34, </pages> <month> July </month> <year> 1988. </year> <booktitle> Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: There has been a considerable number of techniques being proposed in this field. Researchers have developed algorithms to detect pointer-induced aliases [3, 5, 6, 9, 15], analyze side effects [3, 10], and identify conflicts/interferences among statements by static analysis <ref> [8, 11] </ref>. The results of these analysis procedures can be supplied to compilers for optimizations and parallelization on programs with dynamic recursive data structures. The characteristic of these pointer analysis approaches is that they estimate the possible locations referenced by each pointer. Shape analysis is another form of pointer analysis.
Reference: [12] <author> N.K. Madsen. </author> <title> Divergence preserving discrete surface integral methods for maxwel l's curl equations using non-orthogonal grids. </title> <type> Technical Report 92.04, </type> <institution> RIACS, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: Accordingly, it will be beneficial if compilers have the knowledge of which pointer statements build the main traversal structures when pointer analysis is performed. One example is the bipartite graph shown in Figure 1 (a) constructed by the program EM3D <ref> [12] </ref>, which models the propagation of electromagnetic waves. It updates the values of E nodes (electric field) by a weighted sum of neighboring H nodes (magnetic field), and then H nodes are similarly updated using the E nodes.
Reference: [13] <author> J. Plevyak, A. Chien, and V. Karamcheti. </author> <title> Analysis of dynamic structures for efficient parallel execution. </title> <booktitle> In Proceedings of the 6th International Workshop on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 37-56, </pages> <address> Portland, Oregon, </address> <month> August </month> <year> 1993. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 768, </volume> <publisher> Springer Verlag. </publisher>
Reference-contexts: The characteristic of these pointer analysis approaches is that they estimate the possible locations referenced by each pointer. Shape analysis is another form of pointer analysis. It differs from previous methods by estimating the possible shapes of recursive data structures accessible from pointers <ref> [2, 7, 13, 14] </ref>. The shape information can be exploited to parallelize or optimize programs by providing compilers more insight into the properties of data structures used by programs. <p> The shape graphs presented in this paper are closely related to the Storage Shape Graph (SSG) proposed by Chase et al. [2], the Abstract Storage Graph (ASG) by Plevyak et al. <ref> [13] </ref>, and Shape-Graphs by Sagiv et al. [14] Shape graphs have two types of nodes: pointer stances and storage nodes, which can be further divided into simple nodes that represent allocated allocations and summary nodes each of which represents a set of allocated locations.
Reference: [14] <author> Mooly Sagiv, Thomas Reps, and Reinhard Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <booktitle> In Conference Record of POPL '96: 23nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 16-31, </pages> <address> St. Petersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: The characteristic of these pointer analysis approaches is that they estimate the possible locations referenced by each pointer. Shape analysis is another form of pointer analysis. It differs from previous methods by estimating the possible shapes of recursive data structures accessible from pointers <ref> [2, 7, 13, 14] </ref>. The shape information can be exploited to parallelize or optimize programs by providing compilers more insight into the properties of data structures used by programs. <p> SUFFIX, and PX = PREFIX 9 4 Traversal-Pattern-Aware Pointer Analysis This section presents an algorithm to perform traversal-pattern-aware shape analysis and outlines the approach to apply results of shape analysis to dependence test. 4.1 Shape Analysis This algorithm is adapted from the shape analysis algorithm proposed by Sagiv et al <ref> [14] </ref>. The main difference is its ability to represent the links of main traversal structures and to maintain the connection information of secondary traversal links on the same shape graphs. <p> The shape graphs presented in this paper are closely related to the Storage Shape Graph (SSG) proposed by Chase et al. [2], the Abstract Storage Graph (ASG) by Plevyak et al. [13], and Shape-Graphs by Sagiv et al. <ref> [14] </ref> Shape graphs have two types of nodes: pointer stances and storage nodes, which can be further divided into simple nodes that represent allocated allocations and summary nodes each of which represents a set of allocated locations. <p> New storage nodes can be created by calling the storage allocation function new () or extracted from summary nodes by link traversing statements (it is called materialization <ref> [14] </ref>). On the other hand, storage nodes will be removed when they are no longer reachable, or be absorbed by summary nodes when they are not directly connected to any pointer instances (i.e. summarization).
Reference: [15] <author> Robert P. Wilson and Monica S. Lam. </author> <title> Efficient context-sensitive pointer analysis for C programs. </title> <journal> SIGPLAN Notices, </journal> <volume> 30(6) </volume> <pages> 1-12, </pages> <month> June </month> <year> 1995. </year> <booktitle> Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation. </booktitle> <pages> 18 </pages>
Reference-contexts: 1 Introduction Pointer analysis is essential for optimizing and parallelizing compilers that support languages with pointers like C and Fortran 90. There has been a considerable number of techniques being proposed in this field. Researchers have developed algorithms to detect pointer-induced aliases <ref> [3, 5, 6, 9, 15] </ref>, analyze side effects [3, 10], and identify conflicts/interferences among statements by static analysis [8, 11]. The results of these analysis procedures can be supplied to compilers for optimizations and parallelization on programs with dynamic recursive data structures.
References-found: 15

