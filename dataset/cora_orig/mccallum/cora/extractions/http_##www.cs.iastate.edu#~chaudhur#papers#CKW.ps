URL: http://www.cs.iastate.edu/~chaudhur/papers/CKW.ps
Refering-URL: http://www.cs.iastate.edu/~chaudhur/homepage.html
Root-URL: http://www.cs.iastate.edu
Title: One-Write Algorithms for Multivalued Regular and Atomic Registers  
Author: Soma Chaudhuri Martha J. Kosa Jennifer L. Welch 
Keyword: Key Words: concurrent reading and writing, shared registers, regular, atomic, complexity analysis, lower bounds.  
Abstract: This paper presents an algorithm for implementing a k-valued regular register (the logical register) using k(k 1)=2 binary regular registers (the physical registers) that requires only one physical write per logical write. The same algorithm using binary atomic registers implements a k-valued atomic register. The algorithm is simple to describe and depends on properties of paths in a related graph. Two lower bounds are given on the number of registers required by any one-write implementation in the regular case. The first lower bound holds for a restricted class of implementations and implies that our algorithm is optimal for this class. The second lower bound, 2k 1 blog kc, holds for a more general class of algorithms. Both lower bounds improve on the best previously known lower bound, which was k. The two lower bounds also hold for the atomic case under further restrictions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Soma Chaudhuri, Martha J. Kosa, and Jennifer L. Welch. </author> <title> Upper and Lower Bounds for One-Write Multivalued Regular Registers. </title> <booktitle> In Proceedings of the Third IEEE Symposium on Parallel and Distributed Processing, </booktitle> <month> December </month> <year> 1991. </year> <note> Also available as TR91-026 from the University of North Carolina at Chapel Hill. </note>
Reference-contexts: Section 3 contains the algorithm and in Section 4 we prove it is correct with respect to regularity and atomicity. Section 5 consists of our lower bounds. We conclude in Section 6. Some of the results of this paper have appeared in preliminary form in <ref> [1] </ref>. 2 Definitions 2.1 Wait-Free Register Implementations We use a simplified form of the I/O automaton model [7] to describe our system.
Reference: [2] <author> Soma Chaudhuri and Jennifer L. Welch. </author> <title> Bounds on the Costs of Register Implementations. </title> <journal> SIAM Journal on Computing, </journal> <volume> 23 (2), </volume> <month> April, </month> <year> 1994. </year>
Reference-contexts: In this paper, we present a one-write algorithm for implementing a k-ary regular register out of binary regular registers. Clearly this algorithm is optimal in the number of physical writes per logical WRITE. The best previous upper bound was dlog ke writes per WRITE, due to Chaudhuri and Welch <ref> [2] </ref>. The algorithm is simple to describe using the complete graph whose nodes are labeled with the logical values. Its correctness proof is based on properties of paths in this graph. The same algorithm also implements a k-ary atomic register out of binary atomic registers. <p> One drawback of our algorithm is that it requires C (k; 2) = k (k 1)=2 = O (k 2 ) physical registers. The best previous lower bound on the number of physical registers for a k-ary regular implementation was k <ref> [2] </ref>, for any number of physical writes per logical WRITE. Thus binary to k-ary regular implementations are inherently expensive in the amount of "hardware" required. <p> the symmetric property: Suppose at some point the current value of the 1 The weakest guarantee, safety, only ensures that a read which does not overlap a write returns the value of the latest preceding write; the value returned by a read that does overlap a write can be arbitrary. <ref> [2] </ref> studied one-write implementations of k-ary safe registers out of binary safe registers and showed that fi (k) physical registers are necessary and sufficient. 2 Logical operation names will be in upper case and physical operation names will be in lower case throughout this paper. 2 logical register is v and <p> However, computing f adds no more to the asymptotic time complexity of the work performed by each reader. READs are very expensive compared to WRITEs, but WRITEs are extremely time-efficient, which may be important for applications where WRITEs outnumber READs. However, Chaudhuri and Welch <ref> [2] </ref> proved that READs are inherently not cheap, by showing that at least k shared memory accesses are required by any one-write algorithm. 4 Proofs of Correctness We first prove that our algorithm implements a k-ary regular register from binary regular registers in Subsection 4.1. <p> The number of registers used by our algorithm is very large, C (k; 2) = O (k 2 ). The best previously known lower bound on the number of registers for this problem is k, shown by Chaudhuri and Welch <ref> [2] </ref>. In this section we show two improved lower bounds for the problem, under certain restrictions. We primarily consider regular registers; the implications of these results for atomic registers are discussed in Section 5.5. <p> Call this graph G A . When k = 3, our algorithm is optimal in the number of binary regular registers used because C (k; 2) matches the lower bound of k from <ref> [2] </ref>. Theorem 5.11 below shows that C (k; 2) binary regular registers are necessary for any k 4.
Reference: [3] <author> Maurice Herlihy and Jeannette Wing. </author> <title> Linearizability: A Correctness Condition for Concurrent Objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 463-492, </pages> <year> 1990. </year>
Reference-contexts: Every physical read operation returns a value written by an overlapping write operation or by the most recent preceding write (or the initial value if there is no preceding write). A physical register is atomic if, in every execution e, it satisfies: * Atomic Property. There exists a linearization <ref> [3] </ref> of the physical operations in the execution, i.e., there is a permutation T of the physical operations in e such that (1) the ordering of non-overlapping operations in T is the same as their ordering in e (two operations do not overlap if the response for one occurs before the
Reference: [4] <author> Prasad Jayanti, Adarshpal Sethi, and Errol L. Lloyd. </author> <title> Minimal Shared Information for Concurrent Reading and Writing. </title> <booktitle> In Proceedings of the Fifth International Workshop on Distributed Algorithms, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: C is constructible from S if for each i 2 f1; : : : ; mg, there exists a C 0 2 S such that C 0 [i] = C [i]. (A similar definition was given in <ref> [4] </ref>.) Let f A (S) = ff A (C) : C 2 Sg.
Reference: [5] <author> Lefteris Kirousis and Evangelos Kranakis. </author> <title> A Survey of Concurrent Readers and Writers. </title> <journal> CWI Quarterly, </journal> <volume> 2 </volume> <pages> 307-330, </pages> <year> 1989. </year>
Reference-contexts: Thus it is helpful to know which types of registers can implement which other types and what the costs of these implementations are. Many such implementations have been developed; <ref> [5] </ref> surveys many representative algorithms. In this paper we focus on implementing a k-ary regular (respectively, atomic) register, the logical register, out of binary regular (respectively, atomic) registers, the physical registers, for k &gt; 2.
Reference: [6] <author> Leslie Lamport. </author> <title> On Interprocess Communication. </title> <journal> Distributed Computing, </journal> <volume> 1(1) </volume> <pages> 86-101, </pages> <year> 1986. </year>
Reference-contexts: Concurrent reads and writes of shared memory cells, or registers, are required for communication. A consistency condition specifies what guarantees are provided concerning the values returned in the presence of concurrent accesses. Lamport introduced three conditions, in increasing order of strength, safe, regular and atomic <ref> [6] </ref>, thus defining three types of registers. If the shared memory provides a stronger guarantee, then it is often easier for users to y To appear in Acta Informatica.
Reference: [7] <author> Nancy A. Lynch and Mark R. Tuttle. </author> <title> Hierarchical Correctness Proofs for Distributed Algorithms. </title> <booktitle> In Proceedings of the Sixth Annual ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 137-151, </pages> <month> August </month> <year> 1987. </year> <month> 27 </month>
Reference-contexts: Section 5 consists of our lower bounds. We conclude in Section 6. Some of the results of this paper have appeared in preliminary form in [1]. 2 Definitions 2.1 Wait-Free Register Implementations We use a simplified form of the I/O automaton model <ref> [7] </ref> to describe our system.
References-found: 7

