URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/95-39.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Title: Gap-Languages and Log-Time Complexity Classes  
Author: Kenneth W. Regan Heribert Vollmer 
Date: September 8, 1995  
Affiliation: State Univ. of N.Y. at Buffalo  Universitat Wurzburg  
Abstract: This paper shows that classical results about complexity classes involving "delayed diagonalization" and "gap languages," such as Ladner's Theorem and Schoning's Theorem and independence results of a kind noted by Schoning and Hartmanis, apply at very low levels of complexity, indeed all the way down in Sipser's log-time hierarchy. This paper also investigates refinements of Sipser's classes and notions of log-time reductions, following on from recent work by Cai, Chen, and others.
Abstract-found: 1
Intro-found: 1
Reference: [ACS87] <author> A. Aggarwal, A. Chandra, and M. Snir. </author> <title> Hierarchical memory with block transfer. </title> <booktitle> In Proc. 28th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 204-216, </pages> <year> 1987. </year>
Reference-contexts: Proviso (R) was defined by Ruzzo [Ruz81] for alternating machines. A fourth proviso, intermediate in power between U and S, has also been defined by Cai and Chen et al. [CCDF94, CC95], taking an idea from the "Block Transfer" model of <ref> [ACS87] </ref>: (B) (for "block read/write") M writes two addresses i; j with i j on its index tape, and receives the string x i : : : x j on that tape, at a cost of dlog ne + (j i) time units.
Reference: [Amb85a] <author> K. Ambos-Spies. </author> <title> Sublattices of the polynomial time degrees. </title> <journal> Inform. and Control, </journal> <volume> 65 </volume> <pages> 63-84, </pages> <year> 1985. </year>
Reference-contexts: 1 Introduction Many theorems about the structure of familiar complexity classes such as P, NP, and PSPACE have been obtained by a technique called delayed diagonalization <ref> [Lad75, CM81, Sch82, MY85, Amb85a] </ref> (see also [BDG88]). For instance, there are languages E in PSPACE such that E is not in LOGSPACE and E is not PSPACE-complete under log-space reductions ( log m ). Moreover, the structure of such languages E under log m embeds all countable partial orders.
Reference: [Amb85b] <author> K. Ambos-Spies. </author> <title> Three theorems on polynomial degrees of NP sets. </title> <booktitle> In Proc. 26th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 51-55, </pages> <year> 1985. </year>
Reference-contexts: Proof. One can follow Mehlhorn's published proof [Meh76] of the corresponding result for polynomial-time degrees, or that in [Reg83] for embedding posets into p-isomorphism types of NP-complete sets. See also <ref> [MY85, Amb85b, Reg86, Amb88] </ref>; the thesis [Reg86] has full details for embedding upper semi-lattices under one fine reducibility r and preserving incomparabilities under a coarser reducibility r 0 . 10 Cai, Chen, and H-astad [CCH95] define refinements 1 bit k = R m ; 2 bits k ; 3 bits k
Reference: [Amb88] <author> K. Ambos-Spies. </author> <title> Polynomial time degrees of NP-sets. </title> <editor> In E. Borger, editor, </editor> <booktitle> Trends in Theoretical Computer Science, </booktitle> <pages> pages 95-142. </pages> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: Proof. One can follow Mehlhorn's published proof [Meh76] of the corresponding result for polynomial-time degrees, or that in [Reg83] for embedding posets into p-isomorphism types of NP-complete sets. See also <ref> [MY85, Amb85b, Reg86, Amb88] </ref>; the thesis [Reg86] has full details for embedding upper semi-lattices under one fine reducibility r and preserving incomparabilities under a coarser reducibility r 0 . 10 Cai, Chen, and H-astad [CCH95] define refinements 1 bit k = R m ; 2 bits k ; 3 bits k
Reference: [BDG88] <author> J. Balcazar, J. Daz, and J. Gabarro. </author> <title> Structural Complexity Theory. </title> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Many theorems about the structure of familiar complexity classes such as P, NP, and PSPACE have been obtained by a technique called delayed diagonalization [Lad75, CM81, Sch82, MY85, Amb85a] (see also <ref> [BDG88] </ref>). For instance, there are languages E in PSPACE such that E is not in LOGSPACE and E is not PSPACE-complete under log-space reductions ( log m ). Moreover, the structure of such languages E under log m embeds all countable partial orders. <p> The union and intersection of two r.p. cfv. classes is also r.p. cfv., unless the latter is empty. We first state a log-time version of the "uniform diagonalization theorem" of Schoning [Sch82] (see also <ref> [BDG88, Reg88] </ref>), and then state and prove an extension to infinitely many classes along the lines of Theorem 5.2 (a) in [Reg92a]. The main point is that now the reduction is a DLT projection reduction.
Reference: [BIS90] <author> D. Mix Barrington, N. Immerman, and H. Straubing. </author> <title> On uniformity within NC 1 . J. </title> <journal> Comp. Sys. Sci., </journal> <volume> 41 </volume> <pages> 274-306, </pages> <year> 1990. </year>
Reference-contexts: Vollmer [Vol90] showed that "gap languages" can be constructed in DLOGTIME. This answered an open question in [Reg92a] about Immerman's class FO, which is currently regarded as the best notion of "uniform" AC 0 <ref> [Imm87, BIS90] </ref>, since DLOGTIME is contained in FO [BIS90]. This also implies that any class that is closed under DLOGTIME many-one reductions, including FO and nonuniform AC 0 , is recursive gap closed. This paper extends the main result in Vollmer [Vol90] from two to infinitely many classes. <p> Vollmer [Vol90] showed that "gap languages" can be constructed in DLOGTIME. This answered an open question in [Reg92a] about Immerman's class FO, which is currently regarded as the best notion of "uniform" AC 0 [Imm87, BIS90], since DLOGTIME is contained in FO <ref> [BIS90] </ref>. This also implies that any class that is closed under DLOGTIME many-one reductions, including FO and nonuniform AC 0 , is recursive gap closed. This paper extends the main result in Vollmer [Vol90] from two to infinitely many classes. <p> A second contribution of this paper is the study of classes within the log-time hierarchy, together with some notions of "DLOGTIME many-one reductions" that are sharper than the one standardly defined and used in <ref> [CKS81, Bus87, Tor88, BIS90, JMT94] </ref>. The standard one is not transitive and does not preserve membership in individual levels of the hierarchy. <p> Proviso (U ) was used in the seminal paper by Chandra, Kozen, and Stockmeyer [CKS81], and is regarded as "standard" after uses in <ref> [Bus87, Tor88, BIS90, JMT94] </ref> and others.
Reference: [BS90] <author> R. Boppana and M. Sipser. </author> <title> The complexity of finite functions. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume A, </booktitle> <pages> pages 757-804. </pages> <publisher> Elsevier and MIT Press, </publisher> <year> 1990. </year> <month> 13 </month>
Reference-contexts: Proviso (S) is equivalent to Sipser's stipulation in <ref> [Sip83, BS90] </ref> that all addresses are encoded by binary strings of length dlog ne, and after each query, the index tape is completely blanked out . Proviso (R) was defined by Ruzzo [Ruz81] for alternating machines. <p> In fact, this argument shows that a machine accepting L bs under proviso B must take time (log 2 n). Cai, Chen, and H-astad [CCH95] show that for all k 1, R k B k R thereby refuting Sipser's claim <ref> [Sip83, BS90] </ref> that R k = S k . (That S k B k falls out of their stated proof of S k U k ; we suspect that B k U k can be shown by combining their techniques with the binary-search idea above.) Thus the provisos give different classes
Reference: [Bus87] <author> S. Buss. </author> <title> The boolean formula value problem is in ALOGTIME. </title> <booktitle> In Proc. 19th Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 123-131, </pages> <year> 1987. </year>
Reference-contexts: A second contribution of this paper is the study of classes within the log-time hierarchy, together with some notions of "DLOGTIME many-one reductions" that are sharper than the one standardly defined and used in <ref> [CKS81, Bus87, Tor88, BIS90, JMT94] </ref>. The standard one is not transitive and does not preserve membership in individual levels of the hierarchy. <p> Proviso (U ) was used in the seminal paper by Chandra, Kozen, and Stockmeyer [CKS81], and is regarded as "standard" after uses in <ref> [Bus87, Tor88, BIS90, JMT94] </ref> and others. <p> Proviso (U ) was used in the seminal paper by Chandra, Kozen, and Stockmeyer [CKS81], and is regarded as "standard" after uses in [Bus87, Tor88, BIS90, JMT94] and others. An observation credited to [Dow86] in <ref> [Bus87] </ref> and noted also in [Tor88] is that it is unnecessary to provide n to the machine: if one allows that queries to a outside the range [0 : : : n 1] return a special symbol `$', then M can calculate n in time O (log n) by binary search.
Reference: [Bus93] <author> S. Buss. </author> <title> Algorithms for Boolean formula evaluation and for tree contraction. </title> <editor> In P. Clote and J. Krajcek, editors, </editor> <title> Arithmetic, Proof Theory, </title> <booktitle> and Computational Complexity, </booktitle> <pages> pages 96-115. </pages> <publisher> Oxford University Press, </publisher> <year> 1993. </year>
Reference-contexts: Since the function h in Theorem 4.2 does not depend on any bit of the input, it falls out that 0 bits 0 is recursive gap closed. With appropriate artifice, one can define "loglog-time Turing machines" (cf. the loglog-space TMs in Buss <ref> [Bus93] </ref>), so that the class of languages F (F (A)) is in loglog time. Then we claim that the mechanism of Lemmas 3.1 through 3.3 can be tweaked to run in loglog time on these machines, so that this class is recursive gap closed.
Reference: [CC95] <author> L. Cai and J. Chen. </author> <title> On input read-modes of alternating Turing machines. </title> <journal> Theor. Comp. Sci., </journal> <volume> 148 </volume> <pages> 33-55, </pages> <year> 1995. </year>
Reference-contexts: The standard one is not transitive and does not preserve membership in individual levels of the hierarchy. Ours, which extend a suggestion of Cai and Chen <ref> [CC95] </ref> on how to define log-time languages, remedy these lacks and seem to suffice for most applications of DLOGTIME reductions and DLOGTIME uniformity in the literature. 2 How to define log time? To define Turing machines M that operate in logarithmic time, the basic idea is to give M "random-access" to <p> When M enters a special query state q ? , M receives in response bit x a of the input x, where a is the number currently on the index tape. Here is where several authorities diverge, as summarized by Cai and Chen <ref> [CC95] </ref>: (U ) (for "unrestricted") M may enter q ? at any time, and is charged 1 time unit for the query. (S) (for "Sipser") M is charged dlog ne time units for the query. 2 (R) (for "Ruzzo") M may enter q ? only once in any computation path; without <p> Proviso (R) was defined by Ruzzo [Ruz81] for alternating machines. A fourth proviso, intermediate in power between U and S, has also been defined by Cai and Chen et al. <ref> [CCDF94, CC95] </ref>, taking an idea from the "Block Transfer" model of [ACS87]: (B) (for "block read/write") M writes two addresses i; j with i j on its index tape, and receives the string x i : : : x j on that tape, at a cost of dlog ne + (j <p> This is equivalent to the "B c " formalism in <ref> [CC95] </ref>. In order for M to run in O (log n) time, all intervals [i : : : j] addressed must have O (log n) size. The additive dlog ne term, analogous to proviso (S), ensures that only constant-many such queries can be made along any one computation path. <p> For instance, the language F 1 equals 0 fl 1 (0 + 1) fl , and belongs to R 1 (hence also to NLOGTIME), but not to U 1 (hence not to DLOGTIME). Lemma 2.3 (cf. <ref> [CC95, CCH95] </ref>) For all d 1, (a) F d belongs to R d but not to U 5 (b) F d is complete for U d under U m , complete for dlt d under dlt m , complete for S d under S m , and complete for R d <p> Part (c) for U m is Theorem 7.4 in <ref> [CC95] </ref>, and the closures for the other reductions follow from Lemma 2.2 (b). Of all our refinements of DLOGTIME reductions, we draw special attention to DLT reductions. These capture in a natural way the idea of "local replacement" used in many reductions among NP-complete problems.
Reference: [CCDF94] <author> L. Cai, J. Chen, R. Downey, and M. Fellows. </author> <title> On the structure of parametrized problems in NP. </title> <booktitle> In Proc. 11th Annual Symposium on Theoretical Aspects of Computer Science, volume 775 of Lect. Notes in Comp. Sci., </booktitle> <pages> pages 509-520. </pages> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Proviso (R) was defined by Ruzzo [Ruz81] for alternating machines. A fourth proviso, intermediate in power between U and S, has also been defined by Cai and Chen et al. <ref> [CCDF94, CC95] </ref>, taking an idea from the "Block Transfer" model of [ACS87]: (B) (for "block read/write") M writes two addresses i; j with i j on its index tape, and receives the string x i : : : x j on that tape, at a cost of dlog ne + (j
Reference: [CCH95] <author> L. Cai, J. Chen, and J. H-astad. </author> <title> Circuit bottom fan-in and computational power, </title> <year> 1995. </year>
Reference-contexts: But then changing the target bit of x 0 to `1' yields a member of L bs that M rejects, giving the desired contradiction. In fact, this argument shows that a machine accepting L bs under proviso B must take time (log 2 n). Cai, Chen, and H-astad <ref> [CCH95] </ref> show that for all k 1, R k B k R thereby refuting Sipser's claim [Sip83, BS90] that R k = S k . (That S k B k falls out of their stated proof of S k U k ; we suspect that B k U k can be <p> For instance, the language F 1 equals 0 fl 1 (0 + 1) fl , and belongs to R 1 (hence also to NLOGTIME), but not to U 1 (hence not to DLOGTIME). Lemma 2.3 (cf. <ref> [CC95, CCH95] </ref>) For all d 1, (a) F d belongs to R d but not to U 5 (b) F d is complete for U d under U m , complete for dlt d under dlt m , complete for S d under S m , and complete for R d <p> Proof. Part (a) follows from methods and results in <ref> [CCH95] </ref>, improving Sipser's theorem that F d 2 R d n S d [Sip83]. <p> See also [MY85, Amb85b, Reg86, Amb88]; the thesis [Reg86] has full details for embedding upper semi-lattices under one fine reducibility r and preserving incomparabilities under a coarser reducibility r 0 . 10 Cai, Chen, and H-astad <ref> [CCH95] </ref> define refinements 1 bit k = R m ; 2 bits k ; 3 bits k ; : : : of S show that for all k 0, the containments in these classes are proper.
Reference: [CKS81] <author> A. Chandra, D. Kozen, and L. Stockmeyer. </author> <title> Alternation. </title> <journal> J. Assn. Comp. Mach., </journal> <volume> 28 </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference-contexts: This paper extends the main result in Vollmer [Vol90] from two to infinitely many classes. We give further applications for diagonalization and independence results in low-level complexity classes. We construct languages E 2 NC 1 that are not in the log-time hierarchy of <ref> [CKS81, Sip83] </ref>, but that are not hard for any level above DLOGTIME either. Indeed, E does not give any "computational help" to these levels. <p> A second contribution of this paper is the study of classes within the log-time hierarchy, together with some notions of "DLOGTIME many-one reductions" that are sharper than the one standardly defined and used in <ref> [CKS81, Bus87, Tor88, BIS90, JMT94] </ref>. The standard one is not transitive and does not preserve membership in individual levels of the hierarchy. <p> Proviso (U ) was used in the seminal paper by Chandra, Kozen, and Stockmeyer <ref> [CKS81] </ref>, and is regarded as "standard" after uses in [Bus87, Tor88, BIS90, JMT94] and others.
Reference: [CM81] <author> P. Chew and M. Machtey. </author> <title> A note on structure and looking-back applied to the relative complexity of computable functions. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 22 </volume> <pages> 53-59, </pages> <year> 1981. </year>
Reference-contexts: 1 Introduction Many theorems about the structure of familiar complexity classes such as P, NP, and PSPACE have been obtained by a technique called delayed diagonalization <ref> [Lad75, CM81, Sch82, MY85, Amb85a] </ref> (see also [BDG88]). For instance, there are languages E in PSPACE such that E is not in LOGSPACE and E is not PSPACE-complete under log-space reductions ( log m ). Moreover, the structure of such languages E under log m embeds all countable partial orders.
Reference: [Dow86] <author> M. Dowd. </author> <title> Notes on log space representation, 1986. </title> <type> Typewritten manuscript. </type>
Reference-contexts: Proviso (U ) was used in the seminal paper by Chandra, Kozen, and Stockmeyer [CKS81], and is regarded as "standard" after uses in [Bus87, Tor88, BIS90, JMT94] and others. An observation credited to <ref> [Dow86] </ref> in [Bus87] and noted also in [Tor88] is that it is unnecessary to provide n to the machine: if one allows that queries to a outside the range [0 : : : n 1] return a special symbol `$', then M can calculate n in time O (log n) by
Reference: [Har85] <author> J. Hartmanis. </author> <title> Independence results about context-free languages and lower bounds. </title> <journal> Inf. Proc. Lett., </journal> <volume> 20 </volume> <pages> 241-248, </pages> <year> 1985. </year>
Reference-contexts: For further results of this type, see Hartmanis <ref> [Har85] </ref> and also [KOR87, Reg88]. fl Author's current address: Computer Science Department, 226 Bell Hall, UB North Campus, Buffalo, NY 14260-2000. Email: regan@cs.buffalo.edu y Author's current address: Theoretische Informatik, Universitat Wurzburg, Am Exerzierplatz 3, D-97072, Germany. Email: vollmer@informatik.uni-wuerzburg.de.
Reference: [H-as89] <author> J. H-astad. </author> <title> Almost optimal lower bounds for small-depth circuits. </title> <editor> In S. Micali, editor, </editor> <booktitle> Randomness and Computation, volume 5 of Advances in Computing Research, </booktitle> <pages> pages 143-170. </pages> <publisher> JAI Press, </publisher> <address> Greenwich, CT, USA, </address> <year> 1989. </year>
Reference-contexts: , with k 0 and m &gt; ` &gt; 0, whose formulation and proof we leave to the reader. (One can also embed all countable partial orders under dlt proj into the difference of the two classes, etc.) Another notion of "computational help," motivated by the well-known Switching Lemma of <ref> [H-as89] </ref> for the Sipser languages F d (variously defined), is the following: Say a language E "helps F d to switch" if F d dlt m f F d ] E. Our next two results use the infinite case, Theorem 4.3.
Reference: [HU79] <author> J. Hopcroft and J. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1979. </year>
Reference-contexts: For comparison, the notion of g being "[fully] time constructible" from <ref> [HU79] </ref> would require that for all n and all x of length n, M (x) runs for [exactly] g (n) steps. To keep this section self-contained, we give the following slightly modified form of Lemma 5.2 in [Vol90].
Reference: [Imm87] <author> N. Immerman. </author> <title> Languages which capture complexity classes. </title> <journal> SIAM J. Comput., </journal> <volume> 16 </volume> <pages> 760-778, </pages> <year> 1987. </year>
Reference-contexts: Vollmer [Vol90] showed that "gap languages" can be constructed in DLOGTIME. This answered an open question in [Reg92a] about Immerman's class FO, which is currently regarded as the best notion of "uniform" AC 0 <ref> [Imm87, BIS90] </ref>, since DLOGTIME is contained in FO [BIS90]. This also implies that any class that is closed under DLOGTIME many-one reductions, including FO and nonuniform AC 0 , is recursive gap closed. This paper extends the main result in Vollmer [Vol90] from two to infinitely many classes.
Reference: [JMT94] <author> B. Jenner, P. McKenzie, and D. Therien. </author> <title> Logspace and logtime leaf languages. </title> <booktitle> In Proc. 9th Annual IEEE Conference on Structure in Complexity Theory, </booktitle> <pages> pages 242-254, </pages> <year> 1994. </year>
Reference-contexts: A second contribution of this paper is the study of classes within the log-time hierarchy, together with some notions of "DLOGTIME many-one reductions" that are sharper than the one standardly defined and used in <ref> [CKS81, Bus87, Tor88, BIS90, JMT94] </ref>. The standard one is not transitive and does not preserve membership in individual levels of the hierarchy. <p> Proviso (U ) was used in the seminal paper by Chandra, Kozen, and Stockmeyer [CKS81], and is regarded as "standard" after uses in <ref> [Bus87, Tor88, BIS90, JMT94] </ref> and others.
Reference: [KOR87] <author> S. Kurtz, M. O'Donnell, and J. Royer. </author> <title> How to prove representation-independent independence results. </title> <journal> Inf. Proc. Lett., </journal> <volume> 24 </volume> <pages> 5-10, </pages> <year> 1987. </year>
Reference-contexts: For further results of this type, see Hartmanis [Har85] and also <ref> [KOR87, Reg88] </ref>. fl Author's current address: Computer Science Department, 226 Bell Hall, UB North Campus, Buffalo, NY 14260-2000. Email: regan@cs.buffalo.edu y Author's current address: Theoretische Informatik, Universitat Wurzburg, Am Exerzierplatz 3, D-97072, Germany. Email: vollmer@informatik.uni-wuerzburg.de.
Reference: [Lad75] <author> R. Ladner. </author> <title> On the structure of polynomial-time reducibility. </title> <journal> J. Assn. Comp. Mach., </journal> <volume> 22 </volume> <pages> 155-171, </pages> <year> 1975. </year>
Reference-contexts: 1 Introduction Many theorems about the structure of familiar complexity classes such as P, NP, and PSPACE have been obtained by a technique called delayed diagonalization <ref> [Lad75, CM81, Sch82, MY85, Amb85a] </ref> (see also [BDG88]). For instance, there are languages E in PSPACE such that E is not in LOGSPACE and E is not PSPACE-complete under log-space reductions ( log m ). Moreover, the structure of such languages E under log m embeds all countable partial orders. <p> That E =2 [ k C k follows by the same analysis as in Theorem 5.2 (a) of [Reg92a]. The proof of Theorem 4.2 is similar. 9 Because the log-time hierarchy is proper, as in equations (2) and (1), we obtain ana-logues of results about the polynomial hierarchy in <ref> [Lad75, Sch82] </ref>, but without any unproven hypotheses about non-collapse of the latter.
Reference: [Meh76] <author> K. Mehlhorn. </author> <title> Polynomial and abstract subrecursive classes. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 12 </volume> <pages> 147-178, </pages> <year> 1976. </year>
Reference-contexts: Proof. One can follow Mehlhorn's published proof <ref> [Meh76] </ref> of the corresponding result for polynomial-time degrees, or that in [Reg83] for embedding posets into p-isomorphism types of NP-complete sets.
Reference: [MY85] <author> S. Mahaney and P. Young. </author> <title> Reductions among polynomial isomorphism types. </title> <journal> Theor. Comp. Sci., </journal> <volume> 39 </volume> <pages> 207-224, </pages> <year> 1985. </year> <month> 14 </month>
Reference-contexts: 1 Introduction Many theorems about the structure of familiar complexity classes such as P, NP, and PSPACE have been obtained by a technique called delayed diagonalization <ref> [Lad75, CM81, Sch82, MY85, Amb85a] </ref> (see also [BDG88]). For instance, there are languages E in PSPACE such that E is not in LOGSPACE and E is not PSPACE-complete under log-space reductions ( log m ). Moreover, the structure of such languages E under log m embeds all countable partial orders. <p> Proof. One can follow Mehlhorn's published proof [Meh76] of the corresponding result for polynomial-time degrees, or that in [Reg83] for embedding posets into p-isomorphism types of NP-complete sets. See also <ref> [MY85, Amb85b, Reg86, Amb88] </ref>; the thesis [Reg86] has full details for embedding upper semi-lattices under one fine reducibility r and preserving incomparabilities under a coarser reducibility r 0 . 10 Cai, Chen, and H-astad [CCH95] define refinements 1 bit k = R m ; 2 bits k ; 3 bits k
Reference: [Reg83] <author> K. Regan. </author> <title> On diagonalization methods and the structure of language classes. </title> <booktitle> In Pro--ceedings, International Conference on Foundations of Computation Theory (FCT'83), </booktitle> <address> Borgholm, Sweden, </address> <month> August </month> <year> 1983, </year> <booktitle> volume 158 of Lect. Notes in Comp. Sci., </booktitle> <pages> pages 368-380. </pages> <publisher> Springer Verlag, </publisher> <year> 1983. </year>
Reference-contexts: Proof. One can follow Mehlhorn's published proof [Meh76] of the corresponding result for polynomial-time degrees, or that in <ref> [Reg83] </ref> for embedding posets into p-isomorphism types of NP-complete sets.
Reference: [Reg86] <author> K. Regan. </author> <title> On the Separation of Complexity Classes, 1986. Dissertation, </title> <publisher> Oxford University. </publisher>
Reference-contexts: Proof. One can follow Mehlhorn's published proof [Meh76] of the corresponding result for polynomial-time degrees, or that in [Reg83] for embedding posets into p-isomorphism types of NP-complete sets. See also <ref> [MY85, Amb85b, Reg86, Amb88] </ref>; the thesis [Reg86] has full details for embedding upper semi-lattices under one fine reducibility r and preserving incomparabilities under a coarser reducibility r 0 . 10 Cai, Chen, and H-astad [CCH95] define refinements 1 bit k = R m ; 2 bits k ; 3 bits k <p> Proof. One can follow Mehlhorn's published proof [Meh76] of the corresponding result for polynomial-time degrees, or that in [Reg83] for embedding posets into p-isomorphism types of NP-complete sets. See also [MY85, Amb85b, Reg86, Amb88]; the thesis <ref> [Reg86] </ref> has full details for embedding upper semi-lattices under one fine reducibility r and preserving incomparabilities under a coarser reducibility r 0 . 10 Cai, Chen, and H-astad [CCH95] define refinements 1 bit k = R m ; 2 bits k ; 3 bits k ; : : : of S
Reference: [Reg88] <author> K. Regan. </author> <title> The topology of provability in complexity theory. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 3 </volume> <pages> 384-432, </pages> <year> 1988. </year>
Reference-contexts: For further results of this type, see Hartmanis [Har85] and also <ref> [KOR87, Reg88] </ref>. fl Author's current address: Computer Science Department, 226 Bell Hall, UB North Campus, Buffalo, NY 14260-2000. Email: regan@cs.buffalo.edu y Author's current address: Theoretische Informatik, Universitat Wurzburg, Am Exerzierplatz 3, D-97072, Germany. Email: vollmer@informatik.uni-wuerzburg.de. <p> Schmidt showed that the class L 1 of languages accepted by log-space Turing machines whose input tape is one-way, which is a proper subclass of LOGSPACE, is recursive gap closed. Regan <ref> [Reg88, Reg92a] </ref> generalized the notion of a "gap language" to a function h from fl to natural numbers, so as to extend the main theorem of [Sch82] from diagonalization over two to infinitely many classes, and showed that such functions h can be computed by log-space bounded machines that run in <p> The union and intersection of two r.p. cfv. classes is also r.p. cfv., unless the latter is empty. We first state a log-time version of the "uniform diagonalization theorem" of Schoning [Sch82] (see also <ref> [BDG88, Reg88] </ref>), and then state and prove an extension to infinitely many classes along the lines of Theorem 5.2 (a) in [Reg92a]. The main point is that now the reduction is a DLT projection reduction. <p> The proof is similar to the above. (For a treatment with attention to the most general details of how statements such as "E has " are formalized, see <ref> [Reg88] </ref>.) 5 Concluding Discussion Schmidt's definition of a class C being "recursive gap closed" is essentially the same as saying that for every A 1 ; A 2 2 C and recursive function f , there is a strongly-growing function g majorizing f such that if one defines the "gap language"
Reference: [Reg92a] <author> K. Regan. </author> <title> Diagonalization, uniformity, and fixed-point theorems. </title> <journal> Inform. and Comp., </journal> <volume> 98 </volume> <pages> 1-40, </pages> <year> 1992. </year>
Reference-contexts: Schmidt showed that the class L 1 of languages accepted by log-space Turing machines whose input tape is one-way, which is a proper subclass of LOGSPACE, is recursive gap closed. Regan <ref> [Reg88, Reg92a] </ref> generalized the notion of a "gap language" to a function h from fl to natural numbers, so as to extend the main theorem of [Sch82] from diagonalization over two to infinitely many classes, and showed that such functions h can be computed by log-space bounded machines that run in <p> Vollmer [Vol90] showed that "gap languages" can be constructed in DLOGTIME. This answered an open question in <ref> [Reg92a] </ref> about Immerman's class FO, which is currently regarded as the best notion of "uniform" AC 0 [Imm87, BIS90], since DLOGTIME is contained in FO [BIS90]. This also implies that any class that is closed under DLOGTIME many-one reductions, including FO and nonuniform AC 0 , is recursive gap closed. <p> Now find a strongly time-constructible function g 0 g as in Lemma 3.1, and define f 0 (x) = 1 g 0 (jxj)1 . The following main lemma is the "infinite version" of Lemma 5.3 from [Vol90], in the sense of the diagonalization over infinitely many classes in <ref> [Reg92a] </ref>. <p> Since for every number ` there are infinitely many k such that the number of trailing zeroes in the binary representation of k is equal to `, the conclusion follows. The preceding lemma can be stated in a form analogous to Theorem 4.1 from <ref> [Reg92a] </ref>, which is more convenient for the theorems that follow. <p> We first state a log-time version of the "uniform diagonalization theorem" of Schoning [Sch82] (see also [BDG88, Reg88]), and then state and prove an extension to infinitely many classes along the lines of Theorem 5.2 (a) in <ref> [Reg92a] </ref>. The main point is that now the reduction is a DLT projection reduction. <p> Define E = k=1 Then E reduces to A ! by the map x 7! hx; h (x)i, which is a DLT projection reduction. That E =2 [ k C k follows by the same analysis as in Theorem 5.2 (a) of <ref> [Reg92a] </ref>. The proof of Theorem 4.2 is similar. 9 Because the log-time hierarchy is proper, as in equations (2) and (1), we obtain ana-logues of results about the polynomial hierarchy in [Lad75, Sch82], but without any unproven hypotheses about non-collapse of the latter. <p> Hence the inability to avoid this "F d fixed point" in a recursive presentation of NC 1 is surprising. The governing factor is that the language F ! belongs to NC 1 . See section 7 of <ref> [Reg92a] </ref> for related results in the polynomial hierarchy and further discussion of fixed-point theorems. Proof. Suppose not; then with A d := F d , C d := f L : L is a finite variation of B d g, the hypotheses of Theorem 4.3 are satisfied.
Reference: [Reg92b] <author> K. Regan. </author> <title> Minimum-complexity pairing functions. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 45 </volume> <pages> 285-295, </pages> <year> 1992. </year>
Reference-contexts: For this we need a pairing function h; i that is computable and invertible in TM linear time in binary notation. We fix the example hx; yi = def xystr (2jxj + jyj 2) from <ref> [Reg92b] </ref>. We can ignore the fact that the three values h; i, h; 0i, and h; 1i are undefined; on the rest of fl fi fl , h; i is bijectively onto fl .
Reference: [Ruz81] <author> W. Ruzzo. </author> <title> On uniform circuit complexity. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 22 </volume> <pages> 365-383, </pages> <year> 1981. </year>
Reference-contexts: Proviso (S) is equivalent to Sipser's stipulation in [Sip83, BS90] that all addresses are encoded by binary strings of length dlog ne, and after each query, the index tape is completely blanked out . Proviso (R) was defined by Ruzzo <ref> [Ruz81] </ref> for alternating machines.
Reference: [Sch82] <author> U. Schoning. </author> <title> A uniform approach to obtain diagonal sets in complexity classes. </title> <journal> Theor. Comp. Sci., </journal> <volume> 18 </volume> <pages> 95-103, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction Many theorems about the structure of familiar complexity classes such as P, NP, and PSPACE have been obtained by a technique called delayed diagonalization <ref> [Lad75, CM81, Sch82, MY85, Amb85a] </ref> (see also [BDG88]). For instance, there are languages E in PSPACE such that E is not in LOGSPACE and E is not PSPACE-complete under log-space reductions ( log m ). Moreover, the structure of such languages E under log m embeds all countable partial orders. <p> For example, for any sound, axiomatizable F , there are languages E 2 PSPACE n LOGSPACE such that for all Turing machines M accepting E, F cannot prove the first-order arithmetical sentence `L (M ) =2 LOGSPACE.' Schoning <ref> [Sch82] </ref> observed an analogous result for unprovable non-membership of NP languages in P, on hypothesis NP 6= P. For further results of this type, see Hartmanis [Har85] and also [KOR87, Reg88]. fl Author's current address: Computer Science Department, 226 Bell Hall, UB North Campus, Buffalo, NY 14260-2000. <p> Regan [Reg88, Reg92a] generalized the notion of a "gap language" to a function h from fl to natural numbers, so as to extend the main theorem of <ref> [Sch82] </ref> from diagonalization over two to infinitely many classes, and showed that such functions h can be computed by log-space bounded machines that run in real time, i.e., where the input head moves right in every step. Vollmer [Vol90] showed that "gap languages" can be constructed in DLOGTIME. <p> The union and intersection of two r.p. cfv. classes is also r.p. cfv., unless the latter is empty. We first state a log-time version of the "uniform diagonalization theorem" of Schoning <ref> [Sch82] </ref> (see also [BDG88, Reg88]), and then state and prove an extension to infinitely many classes along the lines of Theorem 5.2 (a) in [Reg92a]. The main point is that now the reduction is a DLT projection reduction. <p> That E =2 [ k C k follows by the same analysis as in Theorem 5.2 (a) of [Reg92a]. The proof of Theorem 4.2 is similar. 9 Because the log-time hierarchy is proper, as in equations (2) and (1), we obtain ana-logues of results about the polynomial hierarchy in <ref> [Lad75, Sch82] </ref>, but without any unproven hypotheses about non-collapse of the latter.
Reference: [Sch85] <author> D. Schmidt. </author> <title> The recursion-theoretic structure of complexity classes. </title> <journal> Theor. Comp. Sci., </journal> <volume> 38 </volume> <pages> 143-156, </pages> <year> 1985. </year>
Reference-contexts: This work was supported by an Alexander von Humboldt fellowship, while the author held a visiting position at the University of California, Santa Barbara. 1 The languages E constructed above are commonly known as "gap languages." To determine which language classes C admit construction of such "gap languages," Schmidt <ref> [Sch85] </ref> formulated a definition of C being recursive gap closed . Schmidt showed that the class L 1 of languages accepted by log-space Turing machines whose input tape is one-way, which is a proper subclass of LOGSPACE, is recursive gap closed.
Reference: [Sip83] <author> M. Sipser. </author> <title> Borel sets and circuit complexity. </title> <booktitle> In Proc. 15th Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 61-69, </pages> <year> 1983. </year>
Reference-contexts: This paper extends the main result in Vollmer [Vol90] from two to infinitely many classes. We give further applications for diagonalization and independence results in low-level complexity classes. We construct languages E 2 NC 1 that are not in the log-time hierarchy of <ref> [CKS81, Sip83] </ref>, but that are not hard for any level above DLOGTIME either. Indeed, E does not give any "computational help" to these levels. <p> Proviso (S) is equivalent to Sipser's stipulation in <ref> [Sip83, BS90] </ref> that all addresses are encoded by binary strings of length dlog ne, and after each query, the index tape is completely blanked out . Proviso (R) was defined by Ruzzo [Ruz81] for alternating machines. <p> In fact, this argument shows that a machine accepting L bs under proviso B must take time (log 2 n). Cai, Chen, and H-astad [CCH95] show that for all k 1, R k B k R thereby refuting Sipser's claim <ref> [Sip83, BS90] </ref> that R k = S k . (That S k B k falls out of their stated proof of S k U k ; we suspect that B k U k can be shown by combining their techniques with the binary-search idea above.) Thus the provisos give different classes <p> Our main results will construct these sharp reductions. We end this section by noting that the so-called "Sipser functions" remain complete under these reductions. The case of the Sipser functions we use, from <ref> [Sip83] </ref>, gives functions F d : fl ! , F d = [F n n=1 , d 1, defined by taking n = m d in: F n also, F n d is identically 0 if n is not a power of d. <p> Proof. Part (a) follows from methods and results in [CCH95], improving Sipser's theorem that F d 2 R d n S d <ref> [Sip83] </ref>. The main point in (b) is that the projection reduction given by Sipser [Sip83] is also a DLT reduction, basically because any O (log n) consecutive leaves in a balanced binary tree can be visited in O (log n) moves in the tree. <p> Proof. Part (a) follows from methods and results in [CCH95], improving Sipser's theorem that F d 2 R d n S d <ref> [Sip83] </ref>. The main point in (b) is that the projection reduction given by Sipser [Sip83] is also a DLT reduction, basically because any O (log n) consecutive leaves in a balanced binary tree can be visited in O (log n) moves in the tree.
Reference: [SV85] <author> S. Skyum and L. Valiant. </author> <title> A complexity theory based on Boolean algebra. </title> <journal> J. Assn. Comp. Mach., </journal> <volume> 32 </volume> <pages> 484-502, </pages> <year> 1985. </year>
Reference-contexts: Also noteworthy is that (d) is equivalent to a uniform notion of projection reductions as defined by Valiant [Val82] (see also <ref> [SV85] </ref>). A projection reduction is given by a family of mappings n : f 1; : : : ; n 0 g ! f 0; 1; x 1 ; :x 1 ; : : : ; x n ; :x n g.
Reference: [Tor88] <author> J. Toran. </author> <title> An oracle characterization of the counting hierarchy. </title> <booktitle> In Proc. 3rd Annual IEEE Conference on Structure in Complexity Theory, </booktitle> <pages> pages 213-223, </pages> <year> 1988. </year>
Reference-contexts: A second contribution of this paper is the study of classes within the log-time hierarchy, together with some notions of "DLOGTIME many-one reductions" that are sharper than the one standardly defined and used in <ref> [CKS81, Bus87, Tor88, BIS90, JMT94] </ref>. The standard one is not transitive and does not preserve membership in individual levels of the hierarchy. <p> Proviso (U ) was used in the seminal paper by Chandra, Kozen, and Stockmeyer [CKS81], and is regarded as "standard" after uses in <ref> [Bus87, Tor88, BIS90, JMT94] </ref> and others. <p> Proviso (U ) was used in the seminal paper by Chandra, Kozen, and Stockmeyer [CKS81], and is regarded as "standard" after uses in [Bus87, Tor88, BIS90, JMT94] and others. An observation credited to [Dow86] in [Bus87] and noted also in <ref> [Tor88] </ref> is that it is unnecessary to provide n to the machine: if one allows that queries to a outside the range [0 : : : n 1] return a special symbol `$', then M can calculate n in time O (log n) by binary search.
Reference: [Val82] <author> L. Valiant. </author> <title> Reducibility by algebraic projections. </title> <journal> L'Enseignement mathematique, </journal> <volume> 28 </volume> <pages> 253-268, </pages> <year> 1982. </year>
Reference-contexts: Also noteworthy is that (d) is equivalent to a uniform notion of projection reductions as defined by Valiant <ref> [Val82] </ref> (see also [SV85]). A projection reduction is given by a family of mappings n : f 1; : : : ; n 0 g ! f 0; 1; x 1 ; :x 1 ; : : : ; x n ; :x n g.
Reference: [Vol90] <author> H. Vollmer. </author> <title> The gap-language technique revisited. </title> <booktitle> In Proc. 3rd Workshop on Computer Science Logic, </booktitle> <pages> pages 389-399, </pages> <year> 1990. </year> <month> 15 </month>
Reference-contexts: Vollmer <ref> [Vol90] </ref> showed that "gap languages" can be constructed in DLOGTIME. This answered an open question in [Reg92a] about Immerman's class FO, which is currently regarded as the best notion of "uniform" AC 0 [Imm87, BIS90], since DLOGTIME is contained in FO [BIS90]. <p> This also implies that any class that is closed under DLOGTIME many-one reductions, including FO and nonuniform AC 0 , is recursive gap closed. This paper extends the main result in Vollmer <ref> [Vol90] </ref> from two to infinitely many classes. We give further applications for diagonalization and independence results in low-level complexity classes. We construct languages E 2 NC 1 that are not in the log-time hierarchy of [CKS81, Sip83], but that are not hard for any level above DLOGTIME either. <p> For comparison, the notion of g being "[fully] time constructible" from [HU79] would require that for all n and all x of length n, M (x) runs for [exactly] g (n) steps. To keep this section self-contained, we give the following slightly modified form of Lemma 5.2 in <ref> [Vol90] </ref>. Lemma 3.1 For every recursive function g: IN ! IN there is a strongly time constructible g 0 that majorizes g. Proof. Define g 00 (n) = maxfg (n); n 2 g. Then g 00 is recursive, so there is a Turing machine M computing g 00 . <p> Then certainly ^ f (x) = def 1 g (jxj)1 majorizes f. Now find a strongly time-constructible function g 0 g as in Lemma 3.1, and define f 0 (x) = 1 g 0 (jxj)1 . The following main lemma is the "infinite version" of Lemma 5.3 from <ref> [Vol90] </ref>, in the sense of the diagonalization over infinitely many classes in [Reg92a].
References-found: 37

