URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1994/TR27.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Title: method is non-operational, based on specifications of knowledge-transfer among agents over time.  
Note: The  It has the following components:  
Abstract: The need for communication and coordination between agents in a distributed system distinguishes distributed problems from uni-processor problems. The level of coordination achievable in a system determines which problems are solvable in that system. Often, it is not clear from the informal and operational descriptions of systems in the literature just what level of coordination is possible. This leaves us with the practical question: Which properties of a given system are relevant to another system? We introduce a method for building a problem-based taxonomy of distributed systems, where a system is classified according to the distributed problems which it can solve. We expect that such a taxonomy would ease the process of applying results from one system to a new system. 
Abstract-found: 1
Intro-found: 1
Reference: [AGMT92] <author> Y. Afek, D. S. Greenberg, M. Merritt, and G. Taubenfeld. </author> <title> Computing with faulty shared memory (Extended abstract). </title> <booktitle> In Proceedings of the 11th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 47-58, </pages> <year> 1992. </year>
Reference-contexts: The level of coordination achievable in a system determines the problems which are solvable in that system. Often, it is not clear from the descriptions of systems in the literature just what level of coordination is possible. In fact, literature on fault tolerant computing (see, for example, <ref> [DDS87, DLS88, BT85, YK88, AGMT92] </ref>) has shown that problem-solving ability varies drastically between systems, even between apparently similar systems. <p> Bracha and Toueg, [BT85], consider crash and Byzantine fault tolerance of probabilistic protocols. Though most papers have considered message-passing systems, Afek, et. al, <ref> [AGMT92] </ref>, address systems with shared memory. The systems are distinguished by the types of memory faults which may occur.
Reference: [AM86] <author> M. Abadi and Z. Manna. </author> <title> Modal theorem proving. </title> <editor> In J. H. Siekmann, editor, </editor> <booktitle> Proceedings of the 8th International Conference on Automated Deduction, </booktitle> <pages> pages 172-189, </pages> <address> Oxford, England, </address> <month> July </month> <year> 1986. </year> <note> LNCS 230, Springer-Verlag. </note>
Reference-contexts: There are a variety of decision procedures and working theorem provers for propositional modal logics. For discussions of decision procedures, see Rescher and Urquhart, [RU71] and Wolper, [Wol81], and for a survey, Abadi and Manna, <ref> [AM86] </ref>. Catach, in [Cat91], discusses the general theorem proving system, TABLEAUX, for propositional modal logics. Clarke, Emerson and Sistla, [CES83], introduced the idea of an automatic model-checker for a branching time temporal logic.
Reference: [Bar87] <author> J. Barwise. </author> <title> Three views of common knowledge. </title> <editor> In M. Y. Vardi, editor, </editor> <booktitle> Proceedings of the 2nd Conference on Theoretical Aspects of Reasoning about Knowledge (TARK II), </booktitle> <pages> pages 365-379. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1987. </year>
Reference-contexts: A single structure can show temporal relationships among system states, as well as relationships perceived by individual agents inside the system. The Kripke semantics are also relatively practical, as they generate a graph which can be exploited by mechanical decision procedures. In <ref> [Bar87] </ref>, Barwise considers alternative semantics for common knowledge. For purposes of dealing with agents in a distributed computing system, the iterate approach which we choose seems most appropriate. <p> This is called negative introspection and is probably the most controversial of the knowledge axioms. Philosophers do not generally accept that humans are always aware of their ignorance, but from the computer science perspective, this is considered to be an acceptable assumption (see <ref> [Bar87] </ref>.) A computer agent has a "closed world", perhaps a database with a field for every fact the agent could know (i.e., store in memory). The agent need only check whether the field is null to know that it does not know the fact.
Reference: [BND89] <author> A. Bar-Noy and D. Dolev. </author> <title> Shared-memory vs. message-passing in an asynchronous distributed environment. </title> <booktitle> In Proceedings of the 8th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 307-318, </pages> <year> 1989. </year>
Reference-contexts: In [NT88], Neiger and Toueg show primitives which allow protocols for synchronous systems with omission or even Byzantine failures to be compiled from protocols for a synchronous system allowing only crash failures. A similar protocol compiler for asynchronous systems is discussed by Coan in [Coa88]. Bar-Noy and Dolev, <ref> [BND89] </ref>, provide shared 2.2. FOUNDATIONS OF THE APPROACH 15 memory and message-passing primitives for an asynchronous system that permit algorithms to be translated between the two information exchange models.
Reference: [Bra87] <author> G. Bracha. </author> <title> Asynchronous Byzantine agreement protocols. </title> <journal> Information and Computation, </journal> <volume> 75 </volume> <pages> 130-143, </pages> <year> 1987. </year>
Reference-contexts: They then produce broadcast primitives which do not use digital signatures, but have the essential properties of authenticated messages. These primitives can be used in place of signed messages for the purposes of their algorithms. Bracha, in <ref> [Bra87] </ref>, uses a similar reliable broadcast primitive to reduce the impact of Byzantine faults in an asynchronous system. In [NT88], Neiger and Toueg show primitives which allow protocols for synchronous systems with omission or even Byzantine failures to be compiled from protocols for a synchronous system allowing only crash failures.
Reference: [BT85] <author> G. Bracha and S. Toueg. </author> <title> Asynchronous consensus and broadcast protocols. </title> <journal> Journal of the ACM, </journal> <volume> 32(4) </volume> <pages> 824-840, </pages> <year> 1985. </year>
Reference-contexts: The level of coordination achievable in a system determines the problems which are solvable in that system. Often, it is not clear from the descriptions of systems in the literature just what level of coordination is possible. In fact, literature on fault tolerant computing (see, for example, <ref> [DDS87, DLS88, BT85, YK88, AGMT92] </ref>) has shown that problem-solving ability varies drastically between systems, even between apparently similar systems. <p> In [DLS88], Dwork, Lynch and Stockmeyer extend the results of [DDS87] by considering systems with partial communication and processor synchrony and the potential for omission, authenticated Byzantine or Byzantine failures. Bracha and Toueg, <ref> [BT85] </ref>, consider crash and Byzantine fault tolerance of probabilistic protocols. Though most papers have considered message-passing systems, Afek, et. al, [AGMT92], address systems with shared memory. The systems are distinguished by the types of memory faults which may occur.
Reference: [Cat91] <author> L. Catach. </author> <title> TABLEAUX: a general theorem prover for modal logics. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 7(4) </volume> <pages> 489-510, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: There are a variety of decision procedures and working theorem provers for propositional modal logics. For discussions of decision procedures, see Rescher and Urquhart, [RU71] and Wolper, [Wol81], and for a survey, Abadi and Manna, [AM86]. Catach, in <ref> [Cat91] </ref>, discusses the general theorem proving system, TABLEAUX, for propositional modal logics. Clarke, Emerson and Sistla, [CES83], introduced the idea of an automatic model-checker for a branching time temporal logic.
Reference: [CD88] <author> E. M. Clarke and I. A. Draghicescu. </author> <title> Expressibility results for linear-time and branching-time logics. </title> <editor> In J. W. de Bakker and W.-P. de Roever, editors, </editor> <title> Linear Time, Branching Time and Partial Order in Logics and Models for Concurrency, </title> <address> pages 428-437. </address> <publisher> (LNCS 354), Springer-Verlag, </publisher> <month> May/June </month> <year> 1988. </year>
Reference-contexts: Emerson and Lei, in [EL85] cite the lower complexity of model checking as an advantage of branching time over linear time logics. Clarke and Draghicescu, <ref> [CD88] </ref>, provide necessary and sufficient conditions for a formula of CTL* to be expressible in a linear time logic. In [ES88], Emerson and Srinivasan survey branching time systems from the literature, including discussions of their axiomatizations and decision procedures for satisfiability and model-checking problems.
Reference: [CE81] <author> E. M. Clarke and E. A. Emerson. </author> <title> Design and synthesis of synchronisation skeletons using branching time temporal logic. </title> <editor> In D. Kozen, editor, </editor> <booktitle> Logics of Programs, </booktitle> <pages> pages 52-71. </pages> <publisher> LNCS 131, Springer-Verlag, </publisher> <year> 1981. </year> <note> 83 84 BIBLIOGRAPHY </note>
Reference-contexts: and linear time logics, in particular, he found that some common fairness constraints (e.g. strong eventual fairness: if a process demands infinitely often to be executed, then it will eventually be executed) cannot be expressed in the branching time logic CTL (computational tree logic, introduced by Clarke and Emerson in <ref> [CE81] </ref>), though they are easily expressed in a linear time logic. Conversely, branching time logics can naturally express non-determinism (different computations lie on various paths through the structure), but linear time logics cannot.
Reference: [CES83] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications: a practical approach. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 117-126, </pages> <year> 1983. </year>
Reference-contexts: For discussions of decision procedures, see Rescher and Urquhart, [RU71] and Wolper, [Wol81], and for a survey, Abadi and Manna, [AM86]. Catach, in [Cat91], discusses the general theorem proving system, TABLEAUX, for propositional modal logics. Clarke, Emerson and Sistla, <ref> [CES83] </ref>, introduced the idea of an automatic model-checker for a branching time temporal logic. In [LP84], Lichtenstein and Pnueli discuss model-checking for a linear time logic, and in [HM], Halpern and Moses discuss model-checking for logics of knowledge. 20 CHAPTER 2.
Reference: [Cha90] <author> S. Chaudhuri. </author> <title> Agreement is harder than consensus: Set consensus problems in totally asynchronous systems. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 311-324, </pages> <year> 1990. </year>
Reference-contexts: Fischer, Lynch and Merritt, [FLM86], show proofs of the impossibility of solving several consensus problems (Byzantine agreement, weak agreement, Byzantine firing squad, approximate agreement and clock synchronization) in a variety of systems. In <ref> [Cha90] </ref>, Chaudhuri defines the k-set consensus and agreement problems to study the boundary between possibility and impossibility of reaching a solution in an asynchronous system with the potential for crash failures.
Reference: [CM86] <author> K. M. Chandy and J. Misra. </author> <title> How processes learn. </title> <journal> Distributed Computing, </journal> <volume> 1(1) </volume> <pages> 40-52, </pages> <year> 1986. </year>
Reference-contexts: In [HM84] (a revised version appears in [HM90]), Halpern and Moses describe a hierarchy of knowledge states for a system, ranging from implicit knowledge to common knowledge, and show that common knowledge cannot be generated in a realistic distributed system. Chandy and Misra, in <ref> [CM86] </ref>, address the question of how agents acquire knowledge during message exchanges. In particular, 16 CHAPTER 2. RELATED WORK Chandy and Misra show that either a gain or a loss of knowledge requires that information be transferred sequentially.
Reference: [CM88] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1988. </year>
Reference-contexts: We also discuss influences from the literature on temporal logics for analyzing parallel programs and the literature on using knowledge to analyze distributed systems. We then briefly address two other significant bodies of work-Chandy and Misra's Unity system <ref> [CM88] </ref> and Fischer and Ladner's PDL [FL79]-and discuss how they relate to our own. Our method for comparing distributed systems uses full-information protocols and introduces generic problem specifications. We survey the development of full-information protocols in the literature and work which addresses the variety of distributed problems. <p> Lehmann ([Leh84]) provides an axiomatization of a linear time/knowledge theory with a common knowledge operator which also specifies a system's memory characteristics: temporal and knowledge operators appear together in the axioms. 2.2.3 Other Approaches to Analyzing Systems, Protocols and Problems In <ref> [CM88] </ref>, Chandy and Misra discuss an approach to concurrent programming with a focus on producing non-operational program specifications and proving the correctness of those specifications. Their approach emphasizes problems and programs and explicitly avoids formalizing descriptions of specific systems and mappings from program to systems.
Reference: [Coa88] <author> B. Coan. </author> <title> A compiler that increases the fault tolerance of asynchronous protocols. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(12) </volume> <pages> 1541-1553, </pages> <year> 1988. </year>
Reference-contexts: In [NT88], Neiger and Toueg show primitives which allow protocols for synchronous systems with omission or even Byzantine failures to be compiled from protocols for a synchronous system allowing only crash failures. A similar protocol compiler for asynchronous systems is discussed by Coan in <ref> [Coa88] </ref>. Bar-Noy and Dolev, [BND89], provide shared 2.2. FOUNDATIONS OF THE APPROACH 15 memory and message-passing primitives for an asynchronous system that permit algorithms to be translated between the two information exchange models.
Reference: [DDS87] <author> D. Dolev, C. Dwork, and L. Stockmeyer. </author> <title> On the minimal synchronism needed for distributed consensus. </title> <journal> Journal of the ACM, </journal> <volume> 34(1) </volume> <pages> 77-97, </pages> <year> 1987. </year>
Reference-contexts: The level of coordination achievable in a system determines the problems which are solvable in that system. Often, it is not clear from the descriptions of systems in the literature just what level of coordination is possible. In fact, literature on fault tolerant computing (see, for example, <ref> [DDS87, DLS88, BT85, YK88, AGMT92] </ref>) has shown that problem-solving ability varies drastically between systems, even between apparently similar systems. <p> The authors show operational proofs of bounds on the number of failures which each system can tolerate-steps in the computation, or information exchange, are examined to show situations in which an algorithm must fail. In [DLS88], Dwork, Lynch and Stockmeyer extend the results of <ref> [DDS87] </ref> by considering systems with partial communication and processor synchrony and the potential for omission, authenticated Byzantine or Byzantine failures. Bracha and Toueg, [BT85], consider crash and Byzantine fault tolerance of probabilistic protocols. Though most papers have considered message-passing systems, Afek, et. al, [AGMT92], address systems with shared memory. <p> In the future, we hope that this method will be used for comparing a variety of distributed systems. In particular, this method may allow us to find a more intuitive (non-operational) explanation of the results of Dolev, Dwork and Stockmeyer, <ref> [DDS87] </ref>, which showed the crash fault tolerances of a collection of distributed systems, and similar results in the fault tolerance literature.
Reference: [DLS88] <author> C. Dwork, N. Lynch, and L. Stockmeyer. </author> <title> Consensus in the presence of partial synchrony. </title> <journal> Journal of the ACM, </journal> <volume> 35(2) </volume> <pages> 288-323, </pages> <year> 1988. </year>
Reference-contexts: The level of coordination achievable in a system determines the problems which are solvable in that system. Often, it is not clear from the descriptions of systems in the literature just what level of coordination is possible. In fact, literature on fault tolerant computing (see, for example, <ref> [DDS87, DLS88, BT85, YK88, AGMT92] </ref>) has shown that problem-solving ability varies drastically between systems, even between apparently similar systems. <p> The authors show operational proofs of bounds on the number of failures which each system can tolerate-steps in the computation, or information exchange, are examined to show situations in which an algorithm must fail. In <ref> [DLS88] </ref>, Dwork, Lynch and Stockmeyer extend the results of [DDS87] by considering systems with partial communication and processor synchrony and the potential for omission, authenticated Byzantine or Byzantine failures. Bracha and Toueg, [BT85], consider crash and Byzantine fault tolerance of probabilistic protocols.
Reference: [DM86] <author> C. Dwork and Y. Moses. </author> <title> Knowledge and common knowledge in a byzantine environment: Crash failures. </title> <editor> In J. Y. Halpern, editor, </editor> <booktitle> Proceedings of the 1986 Conference on Theoretical Aspects of Reasoning about Knowledge (TARK I), </booktitle> <pages> pages 149-169, </pages> <year> 1986. </year>
Reference-contexts: If we are to study and classify systems, we must eliminate the factors of problems and protocol choice on the analysis. To eliminate protocol choice, we apply the idea of a full-information protocol, described in the literature (see <ref> [PSL80, DM86, MT88, Mic89] </ref>.) A full-information protocol is one in which each agent sends a copy of its state to every other agent as often as possible, forcing maximal knowledge transfer at the fastest rate allowed by the system. <p> A full-information protocol is at least as powerful as any other protocol, and so may be taken as an all-purpose protocol for a 2.4. SOFTWARE TOOLS 19 given system. Dwork and Moses showed in <ref> [DM86] </ref> that agents running a full-information protocol in a crash failure model will achieve agreement as early as they could using any other protocol, when corresponding runs were compared. <p> A full-information protocol requires that each agent send all of its information to all other agents as often as possible. Since all available information is exchanged whenever possible, this protocol effects knowledge transfer at least as fast as any other protocol. As discussed in <ref> [PSL80, DM86, MT88, Mic89] </ref>, if a system cannot solve a problem when running a full-information protocol, it will not be able to solve that problem by running any other protocol. We can, therefore, make a fair capabilities-based comparison of two systems by allowing each to run its own full-information protocol.
Reference: [DM90] <author> C. Dwork and Y. Moses. </author> <title> Knowledge and common knowledge in a byzantine environment: Crash failures. </title> <journal> Information and Computation, </journal> <volume> 88 </volume> <pages> 159-186, </pages> <year> 1990. </year>
Reference-contexts: The interpretation of knowledge is permitted to vary from system to system as long as no agent can detect the difference. If an interpretation is knowledge-consistent with a given system, then protocols can be written for the interpretation which will run successfully in the system. Dwork and Moses, <ref> [DM90] </ref>, study the behavior of fault-tolerant protocols for performing simultaneous actions by determining which facts can become common knowledge as a protocol is executed. In [MT88], Moses and Tuttle describe a simultaneous action protocol which uses tests for common knowledge. Implementations for the tests are shown for several fault models.
Reference: [DS84] <author> C. Dwork and D. Skeen. </author> <title> Patterns of communication in consensus protocols. </title> <booktitle> In Proceedings of the 3rd ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 143-153, </pages> <year> 1984. </year>
Reference-contexts: Just as we fix a protocol and use problems to study systems, Dwork and Skeen, in <ref> [DS84] </ref>, fix a system and control protocols to study the variety of distributed consensus problems. They produce a taxonomy of problems which are characterized by the communication behavior of protocols which solve them.
Reference: [EH83] <author> E. A. Emerson and J. Y. Halpern. </author> <title> `Sometimes' and `not never' revisited: on branching versus linear time. </title> <booktitle> In Proceedings of the Tenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 127-140, </pages> <year> 1983. </year>
Reference-contexts: Lamport begins the argument in [Lam80] with a demonstration of the incomparability of a linear time and a branching time logic and concludes that the linear time logic is better than the branching time logic for reasoning about concurrent programs. In <ref> [EH83] </ref>, Emerson and Halpern produce a more general language (CTL*) for comparing the logics and conclude that the appropriate choice of linear vs. branching time logic is largely application dependent. <p> Conversely, branching time logics can naturally express non-determinism (different computations lie on various paths through the structure), but linear time logics cannot. Emerson and Halpern, in <ref> [EH83] </ref>, take issue with Lamport's basis for comparison and provide a more uniform framework for comparing branching with linear time. Their approach is to define the syntax and semantics of a larger branching language (CT L fl ) and then discuss properties of its sublanguages, some of which are linear.
Reference: [EH85] <author> E. A. Emerson and J. Y. Halpern. </author> <title> Decision procedures and expressiveness in the temporal logic of branching time. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 30(1) </volume> <pages> 1-24, </pages> <year> 1985. </year>
Reference-contexts: L is sound and complete. A soundness proof is provided in Section C.1. In [HM], Halpern and Moses show both soundness and completeness of the knowledge component (the logic S5). In particular, S5 is determined by (i.e., is sound and complete for) the class of equivalence relations. In <ref> [EH85] </ref>, Emerson and Halpern show soundness and completeness for the temporal component of L , CT L fl .
Reference: [EL85] <author> E. A. Emerson and C. L. Lei. </author> <title> Modalities for model checking: Branching time strikes back. </title> <booktitle> In Proceedings 12th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-95, </pages> <year> 1985. </year> <note> BIBLIOGRAPHY 85 </note>
Reference-contexts: In [EH83], Emerson and Halpern produce a more general language (CTL*) for comparing the logics and conclude that the appropriate choice of linear vs. branching time logic is largely application dependent. Emerson and Lei, in <ref> [EL85] </ref> cite the lower complexity of model checking as an advantage of branching time over linear time logics. Clarke and Draghicescu, [CD88], provide necessary and sufficient conditions for a formula of CTL* to be expressible in a linear time logic.
Reference: [End77] <author> H. Enderton. </author> <title> Elements of Set Theory. </title> <publisher> Academic Press, Inc., </publisher> <year> 1977. </year>
Reference-contexts: Therefore, is well-founded and we may use transfinite induction along to show that (M; s) j= A 3 for all s 2 waiting. For a discussion of transfinite induction, see <ref> [End77] </ref>. 78 APPENDIX C. PROOFS Let s 2 waiting . If (M; s) j= A 2 , then (M; s) j= A 3 follows from (M; s) j= (A 2 _ (A 1 ^ A 3 )) ! A 3 .
Reference: [ES88] <author> E. A. Emerson and J. Srinivasan. </author> <title> Branching time temporal logic. </title> <editor> In J. W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Linear Time, Branching Time and Partial Order in Logics and Models for Concurrency, </title> <address> pages 123-172. </address> <publisher> LNCS 354, Springer-Verlag, </publisher> <month> May/June </month> <year> 1988. </year>
Reference-contexts: Emerson and Lei, in [EL85] cite the lower complexity of model checking as an advantage of branching time over linear time logics. Clarke and Draghicescu, [CD88], provide necessary and sufficient conditions for a formula of CTL* to be expressible in a linear time logic. In <ref> [ES88] </ref>, Emerson and Srinivasan survey branching time systems from the literature, including discussions of their axiomatizations and decision procedures for satisfiability and model-checking problems. <p> time)", and "until (since)" is known to be expressively complete with respect to the first order logic of linear order [GPSS80] (i.e., first order logic with arbitrary unary predicates, equality, and the binary &lt; relation.) The expressiveness of a branching time logic, however, is related to less intuitive formalisms (see <ref> [ES88] </ref> for a discussion and further references). We choose linear time variants of the "next time (last time)" and "until (since)" operators (for reasons we discuss in Section 3.2) to express the temporal notions over all possible branches or 21 22 CHAPTER 3. THE SPECIFICATION LANGUAGE L paths of time. <p> Our semantics is based on branching time structures because we consider the ability to show non-determinism to be potentially useful. We should also note that extensions to CTL have been proposed which allow fairness constraints to be expressed (see <ref> [ES88] </ref>). Since our application requires only that we verify a protocol's solution to a given problem, while running in a particular distributed system and that the protocol must solve the problem in every run, we are interested only in those properties that hold over all computation paths. <p> In [Bar87], Barwise considers alternative semantics for common knowledge. For purposes of dealing with agents in a distributed computing system, the iterate approach which we choose seems most appropriate. In <ref> [ES88] </ref>, Emerson and Srinivasan compare the expressiveness of branching time temporal logics to that of finite state automata on infinite trees and the monadic second order theory of n successors. Again, the use of the temporal logic with Kripke semantics is convenient.
Reference: [FHV88] <author> R. Fagin, J. Y. Halpern, and M. Y. Vardi. </author> <title> What can machines know? On the properties of knowledge in distributed systems. </title> <type> Technical Report RJ6250, </type> <institution> IBM Almaden Research Center, </institution> <year> 1988. </year>
Reference-contexts: In [HF85], Halpern and Fagin describe a formal model relating knowledge, action and communication in a distributed computer system. To that end, they introduce the idea of a knowledge-based protocol-an agent's actions are dependent on its knowledge and message history. Fagin, Halpern and Vardi, in <ref> [FHV88] </ref> (a revised version appears in [FHV92]), show how the choice of system affects the properties of knowledge in that system.
Reference: [FHV91] <author> R. Fagin, J. Halpern, and M. Vardi. </author> <title> A model-theoretic analysis of knowledge. </title> <journal> Journal of the ACM, </journal> <volume> 38(2) </volume> <pages> 382-428, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: The resulting Kripke structure will show a branching computational thread with possible states branching off, whenever an agent considers an alternative. Alternatives to Kripke semantics are available, for example, in <ref> [FHV91] </ref>, Fagin, Halpern and Vardi discuss knowledge structures as an alternative to Kripke structures for a language 3.2. SEMANTICS 25 with knowledge operators. But, since a Kripke structure is a state-based semantics, it provides an intuitive picture of the flow (or potential flow) of information through a distributed system.
Reference: [FHV92] <author> R. Fagin, J. Y. Halpern, and M. Y. Vardi. </author> <title> What can machines know? On the properties of knowledge in distributed systems. </title> <journal> Journal of the ACM, </journal> <volume> 39(2) </volume> <pages> 328-376, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: To that end, they introduce the idea of a knowledge-based protocol-an agent's actions are dependent on its knowledge and message history. Fagin, Halpern and Vardi, in [FHV88] (a revised version appears in <ref> [FHV92] </ref>), show how the choice of system affects the properties of knowledge in that system. <p> L , itself, does not make these assumptions, but adding such assumptions at the system formula level could make the logic undecidable. A thorough discussion of these assumptions can be found in <ref> [FHV92] </ref>. Chapter 5 shows decidability by introducing a small model theorem. At that point, we can also address the complexity of model-checking for L . 30 CHAPTER 3.
Reference: [FL77] <author> M. J. Fischer and R. E. Ladner. </author> <title> Propositional modal logic of programs. </title> <booktitle> In Proceedings of the Nineth Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 286-294, </pages> <address> Boulder, CO, </address> <month> May </month> <year> 1977. </year>
Reference-contexts: Their purpose is to describe a foundation, or small collection of basic laws, for (concurrent) programming. Our purpose is taxonomic: we want to classify systems without regard for particular programs which may run on them. Fischer and Ladner, <ref> [FL77] </ref> (a revised version appears in [FL79]), introduced propositional dynamic logic (PDL) for reasoning about sequential programs. PDL is the propositional restriction of Dynamic Logic, introduced by Pratt in [Pra76].
Reference: [FL79] <author> M. J. Fischer and R. E. Ladner. </author> <title> Propositional dynamic logic of regular programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 18 </volume> <pages> 194-211, </pages> <year> 1979. </year>
Reference-contexts: Their purpose is to describe a foundation, or small collection of basic laws, for (concurrent) programming. Our purpose is taxonomic: we want to classify systems without regard for particular programs which may run on them. Fischer and Ladner, [FL77] (a revised version appears in <ref> [FL79] </ref>), introduced propositional dynamic logic (PDL) for reasoning about sequential programs. PDL is the propositional restriction of Dynamic Logic, introduced by Pratt in [Pra76]. <p> PDL is the propositional restriction of Dynamic Logic, introduced by Pratt in [Pra76]. In PDL, programs themselves are modal operators: hProgiA says that program Prog can terminate with formula A holding, whereas [Prog]A says that whenever Prog terminates, A holds. Fischer and Ladner, <ref> [FL79] </ref>, introduce the small model technique which we apply in our small model theorem of Chapter 5.
Reference: [FLM86] <author> M. Fischer, N. Lynch, and M. Merritt. </author> <title> Easy impossibility proofs for distributed consensus problems. </title> <journal> Distributed Computing, </journal> <volume> 1 </volume> <pages> 26-39, </pages> <year> 1986. </year>
Reference-contexts: They produce a taxonomy of problems which are characterized by the communication behavior of protocols which solve them. Fischer, Lynch and Merritt, <ref> [FLM86] </ref>, show proofs of the impossibility of solving several consensus problems (Byzantine agreement, weak agreement, Byzantine firing squad, approximate agreement and clock synchronization) in a variety of systems.
Reference: [FS78] <author> L. Flon and N. Suzuki. </author> <title> Consistent and complete proof rules for the total correctness of parallel programs. </title> <booktitle> In Proceedings of the Nineteenth Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1978. </year>
Reference-contexts: Problems commonly solved by fixed point computation include leader election, termination detection and various flavors of consensus 4.2. GENERIC DISTRIBUTED PROBLEMS 47 (see Flon and Suzuki, <ref> [FS78] </ref>.) Our standard generic assumption is convenient for specifying these types of problems, but not well-suited for specifying others. In particular, reactive systems ([Pnu86]), in which the goal is to maintain some invariant such as mutual exclusion, consistency of duplicated data, etc., are not specified using our generic assumption.
Reference: [Gol92] <author> R. Goldblatt. </author> <title> Logics of Time and Computation. </title> <address> CSLI/Stanford, </address> <year> 1992. </year>
Reference-contexts: This deduction may be accomplished either by hand or by using a theorem prover. The second approach is to build a Kripke structure (introduced by Kripke in [Kri63]), which appears as a graph, showing the potential knowledge transfer behavior of the system. See <ref> [Gol92] </ref> for an introduction to Kripke structures. We can then check the structure to determine the validity of the problem requirement. The process of building and checking the Kripke structure is mechanizable. <p> For purposes of simplifying protocol design and allowing modular proofs of protocol correctness, however, the compiler approach is excellent. 2.2 Foundations of the Approach The work in this thesis is based on well-known features of propositional logics with modal operators to express time and knowledge. In <ref> [Gol92] </ref>, Goldblatt provides an introduction to propositional modal logic, including logics of knowledge and a discussion of linear and branching time (CTL) temporal logics. <p> By the induction hypothesis, (M fl ; t ) j= A 1 . Case 3. The case where A is of the form (A 1 U A 2 ) (similarly, the form (A 1 SA 2 )) is addressed in <ref> [Gol92] </ref>. 2 C.6 Proof of Theorem 2 Let g be a bisimulation from model M 1 to model M 2 , A be a formula of L, and s 1 2 S 1 , s 2 2 S 2 . Suppose that (s 1 ; s 2 ) 2 g.
Reference: [GPSS80] <author> D. Gabbay, A. Pnueli, S. Shelah, and J. Stavi. </author> <title> On the temporal analysis of fairness. </title> <booktitle> In Conference Record of the 7th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <year> 1980. </year>
Reference-contexts: In [Pnu77], Pnueli introduced the idea of using (linear time) temporal logic for reasoning about concurrent programs. A variety of work since then has studied temporal logics with regard to reasoning about programs. Gabbay, et. al., <ref> [GPSS80] </ref>, in particular, consider several desirable properties of concurrent programs-e.g., safety, partial correctness, liveness, deadlock and livelock freedom and fairness-and proposes an expressively complete language that will allow their specification. <p> This will provide a basis for comparing even the most disparate systems. A propositional modal language with operators for expressing knowledge and time meets both these criteria. The language, L, has temporal operators for "next time", for "last time", U for "until", and S for "since." As discussed in <ref> [GPSS80] </ref>, these allow us to express invariances, such as safety, partial correctness, and mutual exclusion and eventualities, such as liveness, total correctness and livelock freedom. <p> The pair of linear temporal operators: "next time (last time)", and "until (since)" is known to be expressively complete with respect to the first order logic of linear order <ref> [GPSS80] </ref> (i.e., first order logic with arbitrary unary predicates, equality, and the binary &lt; relation.) The expressiveness of a branching time logic, however, is related to less intuitive formalisms (see [ES88] for a discussion and further references).
Reference: [HF85] <author> J. Y. Halpern and R. Fagin. </author> <title> A formal model of knowledge, action and communication in distributed systems:Preliminary report. </title> <booktitle> In Proceedings of the 4th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 224-236, </pages> <year> 1985. </year>
Reference-contexts: Chandy and Misra, in [CM86], address the question of how agents acquire knowledge during message exchanges. In particular, 16 CHAPTER 2. RELATED WORK Chandy and Misra show that either a gain or a loss of knowledge requires that information be transferred sequentially. In <ref> [HF85] </ref>, Halpern and Fagin describe a formal model relating knowledge, action and communication in a distributed computer system. To that end, they introduce the idea of a knowledge-based protocol-an agent's actions are dependent on its knowledge and message history.
Reference: [HM] <author> J. Halpern and Y. Moses. </author> <title> A guide to completeness and complexity for modal logics of knowledge and belief. (manuscript 1991). 86 BIBLIOGRAPHY </title>
Reference-contexts: They also compare the logics with respect to their expressive power and ability to specify properties of programs, and provide additional evidence for allowing the application to guide the choice of logic. In [HM85] (a revised version appears in <ref> [HM] </ref>), Halpern and Moses discuss Kripke semantics for logics of knowledge and the choice of an axiom system. <p> Catach, in [Cat91], discusses the general theorem proving system, TABLEAUX, for propositional modal logics. Clarke, Emerson and Sistla, [CES83], introduced the idea of an automatic model-checker for a branching time temporal logic. In [LP84], Lichtenstein and Pnueli discuss model-checking for a linear time logic, and in <ref> [HM] </ref>, Halpern and Moses discuss model-checking for logics of knowledge. 20 CHAPTER 2. RELATED WORK Chapter 3 The Specification Language L Our specification language, L, will be used to define the knowledge transfer behavior and requirements of distributed systems, protocols and problems. <p> This says that on every branch or path, either A 2 holds, or A 1 holds at all states between now and the time that A 2 holds. L is sound and complete. A soundness proof is provided in Section C.1. In <ref> [HM] </ref>, Halpern and Moses show both soundness and completeness of the knowledge component (the logic S5). In particular, S5 is determined by (i.e., is sound and complete for) the class of equivalence relations. <p> Once the Kripke model is constructed, we should be able to determine whether a formula holds at a given state by simply looking at the formulas in the state. We call the resulting model the fl-relevant Kripke model of fl. Much of our notation is borrowed from <ref> [HM] </ref>. We begin by defining the pool of formulas from which the states of our restricted Kripke model are constructed and considering the size of that pool. <p> Case 1. If A 2 P or A is of the form A 1 ^ A 2 , :A 1 , K i A 1 , or CA 1 , we appeal to the proof of Halpern and Moses in <ref> [HM] </ref> (Theorem 4.3). Case 2. We consider the case where A is of the form A 1 . The proof for A of the form A 1 is very similar. =) Suppose that (M fl ; s) j= A 1 and let w = fB : B 2 sg.
Reference: [HM84] <author> J. Y. Halpern and Y. Moses. </author> <title> Knowledge and common knowledge in a distributed environment. </title> <booktitle> In Proceedings of the 3rd ACM Conference on Principles of Distributed Computing, </booktitle> <pages> pages 50-61, </pages> <year> 1984. </year>
Reference-contexts: We will avoid this problem by considering just specifications of the knowledge transfer behavior of agents within a system. Knowledge transfer occurs when an agent sends, via communication channels, information to other agents. Halpern and Moses, in <ref> [HM84] </ref> (a revised version appears in [HM90]), provide an excellent introduction to using knowledge to reason about the behavior of distributed systems, and Chandy and Misra ([CM86]) discuss fundamentals of knowledge transfer. We will specify the knowledge transfer behavior of systems (with protocols) using formulas of a formal specification language. <p> The formal foundations of knowledge-based reasoning about distributed systems established what could be known and learned by agents in a system. In <ref> [HM84] </ref> (a revised version appears in [HM90]), Halpern and Moses describe a hierarchy of knowledge states for a system, ranging from implicit knowledge to common knowledge, and show that common knowledge cannot be generated in a realistic distributed system. <p> Though all of the literature discussed above assume message-passing systems, Merritt and Taubenfeld, [MT91] (see also [MT92]), apply knowledge-based reasoning to shared memory systems, studying the amount of shared memory necessary for learning certain types of facts and confirm results from message-passing systems. The result of <ref> [HM84] </ref>, showing the impossibility of attaining common knowledge in a realistic distributed system, prompted a search for useful and attainable variants of common knowledge and weaker versions of individual knowledge. In [HM84], Halpern and Moses present *-common knowledge, likely common knowledge, eventual common knowledge and timestamped common knowledge. <p> The result of <ref> [HM84] </ref>, showing the impossibility of attaining common knowledge in a realistic distributed system, prompted a search for useful and attainable variants of common knowledge and weaker versions of individual knowledge. In [HM84], Halpern and Moses present *-common knowledge, likely common knowledge, eventual common knowledge and timestamped common knowledge. In [Mos87], Moses is concerned with the limited computational resources of agents in a realistic distributed system.
Reference: [HM85] <author> J. Halpern and Y. Moses. </author> <title> A guide to the modal logics of knowledge and belief. </title> <booktitle> In Proceedings of the 9th International Joint Conference on Artificial Intelligence (IJCAI-85), </booktitle> <pages> pages 480-490, </pages> <year> 1985. </year>
Reference-contexts: To this end, we choose a propositional modal language with knowledge and temporal operators. 1.2. THE METHOD FOR CLASSIFYING SYSTEMS 9 This type of language allows us to specify how the knowledge of individual agents must change over time. Halpern and Moses, <ref> [HM85] </ref>, introduce the logic of knowledge to distributed systems, while Pnueli, [Pnu77], introduce temporal logic for reasoning about concurrent programs. 1.2.2 Isolating Systems from Protocols and Problems The functions of system, protocol and problem specifications are necessarily interrelated, since a system must run a protocol to solve a problem. <p> They also compare the logics with respect to their expressive power and ability to specify properties of programs, and provide additional evidence for allowing the application to guide the choice of logic. In <ref> [HM85] </ref> (a revised version appears in [HM]), Halpern and Moses discuss Kripke semantics for logics of knowledge and the choice of an axiom system.
Reference: [HM90] <author> J. Halpern and Y. Moses. </author> <title> Knowledge and common knowledge in a distributed environment. </title> <journal> Journal of the ACM, </journal> <year> 1990. </year>
Reference-contexts: We will avoid this problem by considering just specifications of the knowledge transfer behavior of agents within a system. Knowledge transfer occurs when an agent sends, via communication channels, information to other agents. Halpern and Moses, in [HM84] (a revised version appears in <ref> [HM90] </ref>), provide an excellent introduction to using knowledge to reason about the behavior of distributed systems, and Chandy and Misra ([CM86]) discuss fundamentals of knowledge transfer. We will specify the knowledge transfer behavior of systems (with protocols) using formulas of a formal specification language. <p> The formal foundations of knowledge-based reasoning about distributed systems established what could be known and learned by agents in a system. In [HM84] (a revised version appears in <ref> [HM90] </ref>), Halpern and Moses describe a hierarchy of knowledge states for a system, ranging from implicit knowledge to common knowledge, and show that common knowledge cannot be generated in a realistic distributed system. Chandy and Misra, in [CM86], address the question of how agents acquire knowledge during message exchanges.
Reference: [HMW90] <author> J. Y. Halpern, Y. Moses, and O. Waarts. </author> <title> A characterization of eventual Byzan-tine agreement. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 333-346, </pages> <year> 1990. </year>
Reference-contexts: In [PT92], Panangaden and Taylor also address the lack of real-time information in a distributed system by defining and showing the applicability of concurrent common knowledge. This variant of common knowledge uses causality, rather than real-time. Halpern, Moses and Waarts, <ref> [HMW90] </ref>, define the notion of continual common knowledge in order to describe the type of knowledge required by the eventual Byzantine agreement problem. Continual common knowledge is contrasted with ordinary common knowledge, which is required for solving the simultaneous Byzantine agreement problem.
Reference: [HV87] <author> J. Halpern and M. Vardi. </author> <title> The complexity of reasoning about knowledge and time, I: Lower bounds. </title> <type> Technical Report RJ5764, </type> <institution> IBM Almaden Research Center, </institution> <year> 1987. </year>
Reference-contexts: This work generalizes the results of Lehmann, [Leh84], and Ladner and Reif, [LR86]. Halpern and Vardi, in 18 CHAPTER 2. RELATED WORK <ref> [HV87] </ref> (a revised version appears in [HV89]) consider the complexity of decision procedures for logics with both temporal and knowledge operators.
Reference: [HV89] <author> J. Halpern and M. Vardi. </author> <title> The complexity of reasoning about knowledge and time, I: Lower bounds. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 38(1) </volume> <pages> 195-237, </pages> <year> 1989. </year>
Reference-contexts: This work generalizes the results of Lehmann, [Leh84], and Ladner and Reif, [LR86]. Halpern and Vardi, in 18 CHAPTER 2. RELATED WORK [HV87] (a revised version appears in <ref> [HV89] </ref>) consider the complexity of decision procedures for logics with both temporal and knowledge operators. <p> In particular, S5 is determined by (i.e., is sound and complete for) the class of equivalence relations. In [EH85], Emerson and Halpern show soundness and completeness for the temporal component of L , CT L fl . From <ref> [HV89] </ref>, we know that the validity problem for a logic with a common knowledge operator and linear time operators is EXPTIME-complete, if we do not assume that no forgetting or no learning takes place in the system. <p> Later, after receiving information from other agents, it broadcasts the facts that everyone knows (EA); the next time, it broadcasts facts that everyone knows that everyone knows (EEA), and so on. This requires that an agent not forget anything while the protocol is running-knowledge can only accumulate. In <ref> [HV89] </ref>, Halpern and Vardi show that a logic for a system with no forgetting is undecidable. Since we want our approach to be mechanizable, we must avoid the assumption of unbounded memory, and, therefore, non-terminating protocols. <p> Since L is sound and complete, theorem-proving is equivalent to validity-checking. In <ref> [HV89] </ref>, Halpern and Vardi show that the complexity of the validity problem is EXPTIME-complete in formula length. Our formula, f 1 ^ f 2 ^ ^ f jSub + (fl)j , is bounded in size by jSub + (fl)j, which, in turn, is less than 2 (n + 3)length (fl).
Reference: [HZ87] <author> J. Halpern and L. Zuck. </author> <title> A little knowledge goes a long way: Simple knowledge-based derivations and correctness proofs for a family of protocols. </title> <booktitle> In Proceedings of the 6th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 269-280, </pages> <year> 1987. </year>
Reference-contexts: In [MT88], Moses and Tuttle describe a simultaneous action protocol which uses tests for common knowledge. Implementations for the tests are shown for several fault models. Halpern and Zuck, <ref> [HZ87] </ref> (a revised version appears in [HZ92]), show derivations of 2.2. FOUNDATIONS OF THE APPROACH 17 knowledge-based protocols for solving the sequence transmission problem and operational proofs of their correctness. Katz and Taubenfeld, in [KT87], present a language and method for proving knowledge assertions about programs.
Reference: [HZ92] <author> J. Halpern and L. Zuck. </author> <title> A little knowledge goes a long way: Knowledge-based derivations and correctness proofs for a family of protocols. </title> <journal> Journal of the ACM, </journal> <volume> 39(3) </volume> <pages> 449-478, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: In [MT88], Moses and Tuttle describe a simultaneous action protocol which uses tests for common knowledge. Implementations for the tests are shown for several fault models. Halpern and Zuck, [HZ87] (a revised version appears in <ref> [HZ92] </ref>), show derivations of 2.2. FOUNDATIONS OF THE APPROACH 17 knowledge-based protocols for solving the sequence transmission problem and operational proofs of their correctness. Katz and Taubenfeld, in [KT87], present a language and method for proving knowledge assertions about programs.
Reference: [Kri63] <author> S. Kripke. </author> <title> A semantical analysis of modal logic I: normal modal propositional calculi. </title> <journal> Zeitschrift fur Mathematische Logik und Grundlagen der Mathematik, </journal> <volume> 9 </volume> <pages> 67-96, </pages> <year> 1963. </year>
Reference-contexts: This deduction may be accomplished either by hand or by using a theorem prover. The second approach is to build a Kripke structure (introduced by Kripke in <ref> [Kri63] </ref>), which appears as a graph, showing the potential knowledge transfer behavior of the system. See [Gol92] for an introduction to Kripke structures. We can then check the structure to determine the validity of the problem requirement. The process of building and checking the Kripke structure is mechanizable. <p> Definition 3 A subformula of formula A is a formula which is a string of consecutively occurring symbols from A. 3.2 Semantics The meaning of a formula of L is given by a Kripke structure, introduced as a formal model for possible worlds semantics by Kripke in <ref> [Kri63] </ref>. A formula may be either true or false in various states, or paths of states, of a given Kripke structure.
Reference: [KT87] <author> S. Katz and G. Taubenfeld. </author> <title> What processes know: Definitions and proof methods (prelimimary version). </title> <booktitle> In Proceedings of the 6th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 249-262, </pages> <year> 1987. </year>
Reference-contexts: Implementations for the tests are shown for several fault models. Halpern and Zuck, [HZ87] (a revised version appears in [HZ92]), show derivations of 2.2. FOUNDATIONS OF THE APPROACH 17 knowledge-based protocols for solving the sequence transmission problem and operational proofs of their correctness. Katz and Taubenfeld, in <ref> [KT87] </ref>, present a language and method for proving knowledge assertions about programs. The method allows proofs of assertions about both message-passing and shared-memory protocols. Sanders shows, in [San91], a programming language which incorporates knowledge.
Reference: [Lam80] <author> L. Lamport. </author> <title> `Sometimes' is sometimes `Not never'. </title> <booktitle> In Proceeedings of the 7th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-185, </pages> <year> 1980. </year>
Reference-contexts: One aspect of the work in temporal logics for program analysis is a lively debate over the "right" logic for proving programs correct. Lamport begins the argument in <ref> [Lam80] </ref> with a demonstration of the incomparability of a linear time and a branching time logic and concludes that the linear time logic is better than the branching time logic for reasoning about concurrent programs. <p> Choosing a branching Next relation over a linear Next relation is not nearly so easy to justify, however. It remains unclear whether linear or branching time logics are more appropriate for reasoning about concurrent programs. Lamport in <ref> [Lam80] </ref> found differences in the expressive power of branching and linear time logics, in particular, he found that some common fairness constraints (e.g. strong eventual fairness: if a process demands infinitely often to be executed, then it will eventually be executed) cannot be expressed in the branching time logic CTL (computational
Reference: [Leh84] <author> D. Lehmann. </author> <title> Knowledge, common knowledge and related puzzles (Extended summary). </title> <booktitle> In Proceedings of the 3rd ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 62-67, </pages> <year> 1984. </year> <note> BIBLIOGRAPHY 87 </note>
Reference-contexts: This work generalizes the results of Lehmann, <ref> [Leh84] </ref>, and Ladner and Reif, [LR86]. Halpern and Vardi, in 18 CHAPTER 2. RELATED WORK [HV87] (a revised version appears in [HV89]) consider the complexity of decision procedures for logics with both temporal and knowledge operators. Lehmann ([Leh84]) provides an axiomatization of a linear time/knowledge theory with a common knowledge operator
Reference: [LP84] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107, </pages> <year> 1984. </year>
Reference-contexts: Catach, in [Cat91], discusses the general theorem proving system, TABLEAUX, for propositional modal logics. Clarke, Emerson and Sistla, [CES83], introduced the idea of an automatic model-checker for a branching time temporal logic. In <ref> [LP84] </ref>, Lichtenstein and Pnueli discuss model-checking for a linear time logic, and in [HM], Halpern and Moses discuss model-checking for logics of knowledge. 20 CHAPTER 2.
Reference: [LR86] <author> R. E. Ladner and J. H. Reif. </author> <title> The logic of distributed protocols. </title> <editor> In J. Halpern, editor, </editor> <booktitle> Conference on Theoretical Aspects of Reasoning about Knowledge, </booktitle> <pages> pages 207-222. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1986. </year>
Reference-contexts: This work generalizes the results of Lehmann, [Leh84], and Ladner and Reif, <ref> [LR86] </ref>. Halpern and Vardi, in 18 CHAPTER 2. RELATED WORK [HV87] (a revised version appears in [HV89]) consider the complexity of decision procedures for logics with both temporal and knowledge operators.
Reference: [MDH86] <author> Y. Moses, D. Dolev, and J. Halpern. </author> <title> Cheating husbands and other stories: A case study of knowledge, action, </title> <journal> and communication. Distributed Computing, </journal> <volume> 1 </volume> <pages> 167-176, </pages> <year> 1986. </year>
Reference-contexts: Distributed problems can often be stated as knowledge transfer problems. Some initial discussions of the relationships among knowledge, communication and action in distributed computer systems borrow logical puzzles from philosophy to help identify how knowledge advances or limits communication and action. In <ref> [MDH86] </ref>, for example, Moses, Dolev and Halpern discuss variants of the cheating husbands puzzle to show how an agent can gain information by watching other agent's actions when the first agent knows how the second agent's actions are related to facts that it knows.
Reference: [Mic89] <author> R. Michel. </author> <title> A categorical approach to distributed systems, expressibility and knowledge. </title> <booktitle> In Proceedings of the 8th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 129-143, </pages> <year> 1989. </year>
Reference-contexts: If we are to study and classify systems, we must eliminate the factors of problems and protocol choice on the analysis. To eliminate protocol choice, we apply the idea of a full-information protocol, described in the literature (see <ref> [PSL80, DM86, MT88, Mic89] </ref>.) A full-information protocol is one in which each agent sends a copy of its state to every other agent as often as possible, forcing maximal knowledge transfer at the fastest rate allowed by the system. <p> This result was extended to omissions models by Moses and Tuttle in [MT88] and to Byzantine models by Michel in <ref> [Mic89] </ref>. 2.3.2 The Variety of Distributed Problems We expect that each class of our taxonomy of distributed systems will be identified with the formal specification of a distributed problem, so that the variety of problems considered will determine the granularity of distinctions among systems. <p> A full-information protocol requires that each agent send all of its information to all other agents as often as possible. Since all available information is exchanged whenever possible, this protocol effects knowledge transfer at least as fast as any other protocol. As discussed in <ref> [PSL80, DM86, MT88, Mic89] </ref>, if a system cannot solve a problem when running a full-information protocol, it will not be able to solve that problem by running any other protocol. We can, therefore, make a fair capabilities-based comparison of two systems by allowing each to run its own full-information protocol.
Reference: [Mos87] <author> Y. Moses. </author> <title> Resource-bounded knowledge. </title> <booktitle> In Proceedings of the 2nd Conference on Theoretical Aspects of Reasoning about Knowledge (TARK II), </booktitle> <pages> pages 261-275, </pages> <year> 1987. </year>
Reference-contexts: In [HM84], Halpern and Moses present *-common knowledge, likely common knowledge, eventual common knowledge and timestamped common knowledge. In <ref> [Mos87] </ref>, Moses is concerned with the limited computational resources of agents in a realistic distributed system.
Reference: [MT88] <author> Y. Moses and M. Tuttle. </author> <title> Programming simultaneous actions using common knowledge. </title> <journal> Algorithmica, </journal> <volume> 3 </volume> <pages> 121-169, </pages> <year> 1988. </year>
Reference-contexts: If we are to study and classify systems, we must eliminate the factors of problems and protocol choice on the analysis. To eliminate protocol choice, we apply the idea of a full-information protocol, described in the literature (see <ref> [PSL80, DM86, MT88, Mic89] </ref>.) A full-information protocol is one in which each agent sends a copy of its state to every other agent as often as possible, forcing maximal knowledge transfer at the fastest rate allowed by the system. <p> Dwork and Moses, [DM90], study the behavior of fault-tolerant protocols for performing simultaneous actions by determining which facts can become common knowledge as a protocol is executed. In <ref> [MT88] </ref>, Moses and Tuttle describe a simultaneous action protocol which uses tests for common knowledge. Implementations for the tests are shown for several fault models. Halpern and Zuck, [HZ87] (a revised version appears in [HZ92]), show derivations of 2.2. <p> Dwork and Moses showed in [DM86] that agents running a full-information protocol in a crash failure model will achieve agreement as early as they could using any other protocol, when corresponding runs were compared. This result was extended to omissions models by Moses and Tuttle in <ref> [MT88] </ref> and to Byzantine models by Michel in [Mic89]. 2.3.2 The Variety of Distributed Problems We expect that each class of our taxonomy of distributed systems will be identified with the formal specification of a distributed problem, so that the variety of problems considered will determine the granularity of distinctions among <p> A full-information protocol requires that each agent send all of its information to all other agents as often as possible. Since all available information is exchanged whenever possible, this protocol effects knowledge transfer at least as fast as any other protocol. As discussed in <ref> [PSL80, DM86, MT88, Mic89] </ref>, if a system cannot solve a problem when running a full-information protocol, it will not be able to solve that problem by running any other protocol. We can, therefore, make a fair capabilities-based comparison of two systems by allowing each to run its own full-information protocol.
Reference: [MT91] <author> M. Merritt and G. Taubenfeld. </author> <title> Knowledge in shared memory systems (Preliminary version). </title> <booktitle> In Proceedings of the 10th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 189-200, </pages> <year> 1991. </year>
Reference-contexts: Fagin, Halpern and Vardi, in [FHV88] (a revised version appears in [FHV92]), show how the choice of system affects the properties of knowledge in that system. Though all of the literature discussed above assume message-passing systems, Merritt and Taubenfeld, <ref> [MT91] </ref> (see also [MT92]), apply knowledge-based reasoning to shared memory systems, studying the amount of shared memory necessary for learning certain types of facts and confirm results from message-passing systems.
Reference: [MT92] <author> M. Merritt and G. Taubenfeld. </author> <title> Errata: </title> <booktitle> Knowledge in shared memory systems (PODC 1991). In Proceedings of the 11th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 285-286, </pages> <year> 1992. </year>
Reference-contexts: Fagin, Halpern and Vardi, in [FHV88] (a revised version appears in [FHV92]), show how the choice of system affects the properties of knowledge in that system. Though all of the literature discussed above assume message-passing systems, Merritt and Taubenfeld, [MT91] (see also <ref> [MT92] </ref>), apply knowledge-based reasoning to shared memory systems, studying the amount of shared memory necessary for learning certain types of facts and confirm results from message-passing systems.
Reference: [Nei87] <author> G. Neiger. </author> <title> Knowledge consistency: A useful suspension of disbelief. </title> <booktitle> In Proceedings of the 2nd Conference on Theoretical Aspects of Reasoning about Knowledge (TARK II), </booktitle> <pages> pages 295-308, </pages> <year> 1987. </year>
Reference-contexts: Continual common knowledge is contrasted with ordinary common knowledge, which is required for solving the simultaneous Byzantine agreement problem. Reasoning about knowledge has been applied to system analysis, proving protocols correct, and protocol development. In <ref> [Nei87] </ref>, Neiger presents an approach to knowledge-based analysis of agent behavior that is helpful in system simulation. The interpretation of knowledge is permitted to vary from system to system as long as no agent can detect the difference.
Reference: [NT87] <author> G. Neiger and S. Toueg. </author> <title> Substituting for real time and common knowledge in asynchronous distributed systems. </title> <booktitle> In Proceedings of the 6th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 281-293, </pages> <year> 1987. </year>
Reference-contexts: To account for knowledge under these circumstances, Moses defines the notion of resource-bounded knowledge. In <ref> [NT87] </ref> (a revised version appears in [NT93]), Neiger and Toueg present logical clocks which substitute for real-time clocks within a class of problems that they formally characterize.
Reference: [NT88] <author> G. Neiger and S. Toueg. </author> <title> Automatically increasing the fault-tolerance of distributed systems (Preliminary Version). </title> <booktitle> In Proceedings of the 7th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 248-262, </pages> <year> 1988. </year>
Reference-contexts: These primitives can be used in place of signed messages for the purposes of their algorithms. Bracha, in [Bra87], uses a similar reliable broadcast primitive to reduce the impact of Byzantine faults in an asynchronous system. In <ref> [NT88] </ref>, Neiger and Toueg show primitives which allow protocols for synchronous systems with omission or even Byzantine failures to be compiled from protocols for a synchronous system allowing only crash failures. A similar protocol compiler for asynchronous systems is discussed by Coan in [Coa88].
Reference: [NT93] <author> G. Neiger and S. Toueg. </author> <title> Simulating synchronized clock and common knowledge in distributed systems. </title> <journal> Journal of the ACM, </journal> <volume> 40(2) </volume> <pages> 334-367, </pages> <month> April </month> <year> 1993. </year> <note> 88 BIBLIOGRAPHY </note>
Reference-contexts: To account for knowledge under these circumstances, Moses defines the notion of resource-bounded knowledge. In [NT87] (a revised version appears in <ref> [NT93] </ref>), Neiger and Toueg present logical clocks which substitute for real-time clocks within a class of problems that they formally characterize. They use these clocks to produce a broadcast primitive which can achieve timestamped common knowledge: for the problem class they characterize, timestamped common knowledge adequately substitutes for common knowledge.
Reference: [Par81] <author> D. Park. </author> <title> Concurrency and automata on infinite sequences. </title> <editor> In P. Deussen, editor, </editor> <booktitle> Proceedings of the 5th GI Conference on Theoretical Computer Science, </booktitle> <pages> pages 167-183. </pages> <publisher> LNCS 104, Springer Verlag, </publisher> <year> 1981. </year>
Reference-contexts: To make an indirect determination that a given system belongs to a particular problem class, we first produce a Kripke structure for the system and then find a bisimulation relation (introduced by Park in <ref> [Par81] </ref>) from states in our structure to states in a structure for a representative member of the class. The existence of the bisimulation between the structures allows us to conclude that the two systems are equivalent under the given problem requirement and, hence, belong in the same class.
Reference: [Pnu77] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proceedings of the 1977 IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 46-57, </pages> <year> 1977. </year>
Reference-contexts: THE METHOD FOR CLASSIFYING SYSTEMS 9 This type of language allows us to specify how the knowledge of individual agents must change over time. Halpern and Moses, [HM85], introduce the logic of knowledge to distributed systems, while Pnueli, <ref> [Pnu77] </ref>, introduce temporal logic for reasoning about concurrent programs. 1.2.2 Isolating Systems from Protocols and Problems The functions of system, protocol and problem specifications are necessarily interrelated, since a system must run a protocol to solve a problem. <p> This gives us precedent for basing our method of classifying systems on knowledge transfer capabilities. 2.2.2 Temporal Logics A thorough introduction to temporal logic can be found in [RU71]. In <ref> [Pnu77] </ref>, Pnueli introduced the idea of using (linear time) temporal logic for reasoning about concurrent programs. A variety of work since then has studied temporal logics with regard to reasoning about programs.
Reference: [Pnu86] <author> A. Pnueli. </author> <title> Applications of temporal logic to the specification and verification of reactive systems: a survey of current trends. </title> <editor> In de Bakker, editor, </editor> <booktitle> Current Trends in Concurrency, </booktitle> <volume> LNCS 224, </volume> <pages> pages 510-584. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference: [Pra76] <author> V. R. Pratt. </author> <title> Semantical considerations on floyd-hoare logic. </title> <booktitle> In Proceedings of the 17th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 109-121, </pages> <year> 1976. </year>
Reference-contexts: Fischer and Ladner, [FL77] (a revised version appears in [FL79]), introduced propositional dynamic logic (PDL) for reasoning about sequential programs. PDL is the propositional restriction of Dynamic Logic, introduced by Pratt in <ref> [Pra76] </ref>. In PDL, programs themselves are modal operators: hProgiA says that program Prog can terminate with formula A holding, whereas [Prog]A says that whenever Prog terminates, A holds. Fischer and Ladner, [FL79], introduce the small model technique which we apply in our small model theorem of Chapter 5.
Reference: [Pra78] <author> V. R. Pratt. </author> <title> A practical decision method for propositional dynamic logic. </title> <booktitle> In 10th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 326-337, </pages> <year> 1978. </year>
Reference-contexts: In PDL, programs themselves are modal operators: hProgiA says that program Prog can terminate with formula A holding, whereas [Prog]A says that whenever Prog terminates, A holds. Fischer and Ladner, [FL79], introduce the small model technique which we apply in our small model theorem of Chapter 5. In <ref> [Pra78] </ref>, Pratt provides a complete axiomatization for PDL as well as a tableaux-based decision procedure for determining the satisfiability of a PDL formula. 2.3 Isolating System Characteristics from Protocols and Problems In order to carefully study distributed systems, we must be able to isolate the systems from closely related concerns about
Reference: [PSL80] <author> M. Pease, R. Shostak, and L. Lamport. </author> <title> Reaching agreement in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 27(2) </volume> <pages> 228-234, </pages> <year> 1980. </year>
Reference-contexts: If we are to study and classify systems, we must eliminate the factors of problems and protocol choice on the analysis. To eliminate protocol choice, we apply the idea of a full-information protocol, described in the literature (see <ref> [PSL80, DM86, MT88, Mic89] </ref>.) A full-information protocol is one in which each agent sends a copy of its state to every other agent as often as possible, forcing maximal knowledge transfer at the fastest rate allowed by the system. <p> A single popular problem is then chosen as representative and analysis proceeds, based on this problem. We discuss first the literature involving full-information protocols and then survey work highlighting analyses of distributed problems. 2.3.1 Full-Information Protocols Full-information protocols have been used since <ref> [PSL80] </ref> to solve a variety of coordinated action problems. These protocols are appealing due to their ability to solve a variety of problems and the simplicity of their specifications. <p> A full-information protocol requires that each agent send all of its information to all other agents as often as possible. Since all available information is exchanged whenever possible, this protocol effects knowledge transfer at least as fast as any other protocol. As discussed in <ref> [PSL80, DM86, MT88, Mic89] </ref>, if a system cannot solve a problem when running a full-information protocol, it will not be able to solve that problem by running any other protocol. We can, therefore, make a fair capabilities-based comparison of two systems by allowing each to run its own full-information protocol.
Reference: [PT92] <author> P. Panangaden and K. Taylor. </author> <title> Concurrent common knowledge:Defining agreement for asynchronous systems. </title> <journal> Distributed Computing, </journal> <volume> 6(2) </volume> <pages> 73-94, </pages> <year> 1992. </year>
Reference-contexts: They use these clocks to produce a broadcast primitive which can achieve timestamped common knowledge: for the problem class they characterize, timestamped common knowledge adequately substitutes for common knowledge. In <ref> [PT92] </ref>, Panangaden and Taylor also address the lack of real-time information in a distributed system by defining and showing the applicability of concurrent common knowledge. This variant of common knowledge uses causality, rather than real-time.
Reference: [RU71] <author> N. Rescher and A. Urquhart. </author> <title> Temporal Logic. </title> <publisher> Springer Verlag, </publisher> <year> 1971. </year>
Reference-contexts: This gives us precedent for basing our method of classifying systems on knowledge transfer capabilities. 2.2.2 Temporal Logics A thorough introduction to temporal logic can be found in <ref> [RU71] </ref>. In [Pnu77], Pnueli introduced the idea of using (linear time) temporal logic for reasoning about concurrent programs. A variety of work since then has studied temporal logics with regard to reasoning about programs. <p> A theorem prover automates the proving process and a model checker determines whether a formula is satisfiable in a given structure. There are a variety of decision procedures and working theorem provers for propositional modal logics. For discussions of decision procedures, see Rescher and Urquhart, <ref> [RU71] </ref> and Wolper, [Wol81], and for a survey, Abadi and Manna, [AM86]. Catach, in [Cat91], discusses the general theorem proving system, TABLEAUX, for propositional modal logics. Clarke, Emerson and Sistla, [CES83], introduced the idea of an automatic model-checker for a branching time temporal logic.
Reference: [San91] <author> B. Sanders. </author> <title> A predicate transformer approach to knowledge and knowledge-based protocols. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 217-230, </pages> <year> 1991. </year>
Reference-contexts: Katz and Taubenfeld, in [KT87], present a language and method for proving knowledge assertions about programs. The method allows proofs of assertions about both message-passing and shared-memory protocols. Sanders shows, in <ref> [San91] </ref>, a programming language which incorporates knowledge. K i A is defined as a function from predicate A to predicates dependent only on variables accessible to Agent i . Such knowledge predicate transformers are then allowed in guards of program statements.
Reference: [ST87] <author> T. Srikanth and S. Toueg. </author> <title> Simulating authenticated broadcasts to derive simple fault-tolerant algorithms. </title> <journal> Distributed Computing, </journal> <volume> 2 </volume> <pages> 80-94, </pages> <year> 1987. </year>
Reference-contexts: In <ref> [ST87] </ref>, Srikanth and Toueg consider algorithms for solving Byzantine agreement and election problems in synchronous systems, assuming that messages are authenticated. They then produce broadcast primitives which do not use digital signatures, but have the essential properties of authenticated messages.
Reference: [Wel87] <author> J. L. Welch. </author> <title> Simulating synchronous processors. </title> <journal> Information and Computation, </journal> <volume> 74 </volume> <pages> 159-171, </pages> <year> 1987. </year>
Reference-contexts: A similar protocol compiler for asynchronous systems is discussed by Coan in [Coa88]. Bar-Noy and Dolev, [BND89], provide shared 2.2. FOUNDATIONS OF THE APPROACH 15 memory and message-passing primitives for an asynchronous system that permit algorithms to be translated between the two information exchange models. In <ref> [Wel87] </ref>, Welch uses a simulation to demonstrate that a system with synchronous agents and unbounded message delays can be simulated by a system with asynchronous agents when faults may occur.
Reference: [Wol81] <author> P. Wolper. </author> <title> Temporal logic can be more expressive. </title> <booktitle> In 22nd Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 340-348, </pages> <year> 1981. </year>
Reference-contexts: A theorem prover automates the proving process and a model checker determines whether a formula is satisfiable in a given structure. There are a variety of decision procedures and working theorem provers for propositional modal logics. For discussions of decision procedures, see Rescher and Urquhart, [RU71] and Wolper, <ref> [Wol81] </ref>, and for a survey, Abadi and Manna, [AM86]. Catach, in [Cat91], discusses the general theorem proving system, TABLEAUX, for propositional modal logics. Clarke, Emerson and Sistla, [CES83], introduced the idea of an automatic model-checker for a branching time temporal logic.
Reference: [Wol86] <author> Wolper. </author> <title> Expresing interesting properties of programs in propositional temporal logic. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 184-193, </pages> <year> 1986. </year>
Reference-contexts: Many problems in distributed systems are considered to be data independent, which 46 CHAPTER 4. ISOLATING SYSTEMS FROM PROTOCOLS AND PROBLEMS means that the values of the input data do not determine the system or protocol behavior (see <ref> [Wol86] </ref> for a discussion of data independence). For example, a message passing system often does not understand or act on the particular messages that it passes. A generic distributed problem is one whose specification is data independent.
Reference: [YK88] <author> M. Yamashita and T. Kameda. </author> <title> Computing on anonymous networks. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 117-130, </pages> <year> 1988. </year> <note> BIBLIOGRAPHY 89 </note>
Reference-contexts: The level of coordination achievable in a system determines the problems which are solvable in that system. Often, it is not clear from the descriptions of systems in the literature just what level of coordination is possible. In fact, literature on fault tolerant computing (see, for example, <ref> [DDS87, DLS88, BT85, YK88, AGMT92] </ref>) has shown that problem-solving ability varies drastically between systems, even between apparently similar systems. <p> Bracha and Toueg, [BT85], consider crash and Byzantine fault tolerance of probabilistic protocols. Though most papers have considered message-passing systems, Afek, et. al, [AGMT92], address systems with shared memory. The systems are distinguished by the types of memory faults which may occur. Yamashita and Kameda, in <ref> [YK88] </ref>, discuss systems that use message-passing, but individual agents cannot be identified (i.e., have no i.d. numbers.) A variety of systems are distinguished by the assumptions made about the availability of topological information: no information about network attributes, a known upper bound on the number of agents, an accurate count of
Reference: [Zuc86] <author> L. Zuck. </author> <title> Past temporal logic. </title> <type> PhD thesis, </type> <institution> Weizmann Institute of Science, Re-hovot, Israel, </institution> <month> August </month> <year> 1986. </year>
Reference-contexts: THE SPECIFICATION LANGUAGE L paths of time. Though not strictly necessary for the sake of expressibility, the past operators are provided as a convenience. With them, one can avoid using history variables, as these two formalisms have been shown in <ref> [Zuc86] </ref> to be equivalent. There is currently no standard for the expressive completeness of a collection of knowledge operators.
References-found: 74

