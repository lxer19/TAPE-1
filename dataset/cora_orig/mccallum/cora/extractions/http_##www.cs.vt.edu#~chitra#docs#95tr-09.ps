URL: http://www.cs.vt.edu/~chitra/docs/95tr-09.ps
Refering-URL: http://www.cs.vt.edu/~chitra/PublicationList.html
Root-URL: http://www.cs.vt.edu
Email: abrams@cs.vt.edu  
Title: An Example of Deriving Performance Properties from a Visual Representation of Program Execution  
Author: Marc Abrams 
Date: June 19, 1995  
Address: VA 24061-0106  
Affiliation: Department of Computer Science Virginia Polytechnic Institute and State University Blacksburg,  
Abstract: This paper demonstrates that one can use a visual representation of the execution of a program to analyze performance properties. The method starts with a visualization of the progress of processes, and then applies geometric properties of the visualization to analyze program execution behavior. The visualization is based on progress graphs from the literature, which map the progress of each process to one Cartesian graph axis. Line segments represent interprocess synchronization. A directed, continuous path that does not cross a segment represents a particular execution of a program, and can be found using computational geometric algorithms. A special case is also considered in which programs display Categories and Subject Descriptors: D.2.8 [Software]: Measures | Performance measures; D.4.8 [Operating Systems]: Performance | Modeling and prediction; C.4 [Performance of Systems]: Modeling techniques Index Terms parallel computation, performance evaluation, computational geometry, ray shooting, timed progress graphs, mutual exclusion, Petri nets periodic behavior. The relation of the program class studied to Petri nets is also examined.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abrams. </author> <title> Computational geometric performance analysis of limit cycles in timed transition systems. </title> <type> Technical Report TR 93-30, </type> <institution> Computer Sci. Dept., Virginia Tech, Blacksburg, </institution> <address> VA 24061-0106, </address> <month> Sept. </month> <year> 1993. </year> <title> Available from World Wide Web location http://info.cs.vt.edu/reports. June 19, 1995| An Example of Deriving Performance Properties 30 </title>
Reference-contexts: See <ref> [1] </ref> for the complete algorithm. Example 7 In Fig. 11, f d (5; 2) = (8; 5). Fig. 12 shows the two ShootRay operations required to compute f d (G) because ray (5; 2); (8; 5) lies in exactly two quadrants.
Reference: [2] <author> M. Abrams. </author> <title> Geometric performance analysis of semaphore programs. </title> <type> Technical Report TR 93-29, </type> <institution> Computer Sci. Dept., Virginia Tech, Blacksburg, </institution> <address> VA 24061-0106, </address> <month> Aug. </month> <year> 1993. </year> <note> Available from World Wide Web location http://info.cs.vt.edu/reports. </note>
Reference-contexts: set of all (possibly unreachable) blocking LCETs can be found by finding all L 2 fl and all i 2 Z satisfying 0 &lt; i 2jjfljj ^ jjf i (L:f )jj = 1 ^ G 2 f i (L:f ) ^ G L:f: Proof: See Theorems 3 and 4 in <ref> [2] </ref>. 2 Let denote the set of LCETs satisfying Lemma 1. We can determine which LCETs in are reachable by calculating, for each line L in an LCET in , ShootRay (L:f; ; L), where L is the same line set as in algorithm FindFreePoints.
Reference: [3] <author> M. Abrams. </author> <title> Geometric performance analysis of periodic behavior. </title> <journal> J. Parallel and Distributed Computing, </journal> <note> to appear. </note>
Reference-contexts: Second, a TET containing only deterministic points will consist of a transient portion followed by an infinite number of repetitions of congruent subtrajectories, representing periodic behavior. (See Theorem 1 in <ref> [3] </ref>.) A repeated subtrajectory is called a limit cycle execution trajectory (LCET). Example 5 In Fig. 11, 0 = 5; 1 = 3.
Reference: [4] <author> M. Abrams, N. Doraswamy, and A. Mathur. Chitra: </author> <title> Visual analysis of parallel and distributed programs in the time, event, and frequency domain. </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 3(6) </volume> <pages> 672-685, </pages> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Systems to visualize the execution history collected from a program can help explain what happens during program execution (e.g., <ref> [4, 10, 13, 15] </ref>).
Reference: [5] <author> V. S. Adve and M. K. Vernon. </author> <title> The influence of random delays on parallel execution times. </title> <booktitle> In Proc. SIGMETRICS, </booktitle> <pages> pages 61-73, </pages> <address> Santa Clara, CA, </address> <month> June </month> <year> 1993. </year> <note> ACM. </note>
Reference-contexts: In principle the analysis presented here can be extended from two to an arbitrary number of processes; see the conclusions (x7) for a discussion. Regarding the constant time assumption (A5), Adve and Vernon <ref> [5] </ref> conclude based on seven parallel applications that "it appears reasonable to ignore the variability in execution times when estimating synchronization delays," and that an exponential task time assumption could actually lead to more severe errors than a constant-time assumption.
Reference: [6] <author> P. K. Agarwal. </author> <title> Intersection and Decomposition Algorithms for Planar Arrangements. </title> <publisher> Cam-bridge Univ. Press, </publisher> <address> Cambridge, </address> <year> 1991. </year>
Reference-contexts: Computation of f d (G): Recall that f d (G) is the smallest of (1; 1) and each point at which a slope one ray rooted at G intersects a constraint line instance. The well known problem of ray shooting with line segments <ref> [6, pp. 234-247] </ref> can be used to find f d (G): Given a point, a direction, and a finite set of line segments in a plane, find the first line segment intersected by a ray rooted at the point with the given direction.
Reference: [7] <author> S. D. Carson and J. P. F. Reynolds. </author> <title> The geometry of semaphore programs. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 25-53, </pages> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: Later, a simplified form of TPG, called an untimed progress graph (UTP), in which each delay in the timed transition diagram is unity, was used to analyze deadlocks. 1 Carson and Reynolds <ref> [7] </ref> define a UPG as "a multidimensional, Cartesian graph in which the progress of each of a set of concurrent processes is measured along an independent time axis. <p> Each point in the graph represents a set of process times." Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood [11, 17, 22, 24] used UPGs to detect deadlocks in lock-based transaction systems. More recently Carson and Reynolds <ref> [7] </ref> used UPGs to prove liveness properties in programs with an arbitrary number of processes containing P and V operations on semaphores that are unconditionally executed. Our use of TPGs to analyze program performance properties is novel. TPGs map the progress of each process to one Cartesian graph axis. <p> Thus when process 1 starts 2 time units after process 0, the program either reaches a deadlock or process 0 blocks for 3 time units after which both processes run forever without blocking. Because UPGs have been used extensively for analysis of deadlocks <ref> [7, 11, 17, 22, 24] </ref>, deadlocks are not considered further in this paper. 2.3 Program 3: A Terminating Program Fig. 7, unlike the previous two programs, contains a terminating program.
Reference: [8] <author> E. G. Coffman, M. J. Elphick, and A. Shoshani. </author> <title> System deadlocks. </title> <journal> ACM Comp. Surv., </journal> <volume> 3(2) </volume> <pages> 70-71, </pages> <month> June </month> <year> 1971. </year>
Reference-contexts: Finally x7 contains conclusions. 2 Timed Progress Graphs We first illustrate our approach to solving for quantities Q1 to Q3 from x1 on three programs. 1 Apparently TPGs were reinvented in the Computer Science field and attributed to Dijkstra <ref> [8] </ref>. June 19, 1995| An Example of Deriving Performance Properties 5 process producer process consumer X: integer; Y: integer; while (TRUE) do while (TRUE) do read X from disk; receive X from consumer; send X to consumer; write X to disk; do od 2.1 Program 1: Non-terminating Producer/Consumer communication.
Reference: [9] <author> M. A. Holliday and M. K. Vernon. </author> <title> A generalized timed Petri net model for performance analysis. </title> <booktitle> In Proc. Int. Workshop on Timed Petri Nets, </booktitle> <month> July </month> <year> 1985. </year>
Reference-contexts: Also proved are complexity results for systems of processes with communication by buffers. Finally, Holliday and Vernon <ref> [9] </ref> use Petri nets with frequency expressions (i.e., probabilities) to resolve deterministically which transition fires when a token enables two or more transitions simultaneously, and analyze a program similar to Fig. 4.
Reference: [10] <author> T. Lehr, Z. Segall, and et al. </author> <title> Visualizing performance debugging. </title> <journal> IEEE Computer, </journal> <volume> 22(10) </volume> <pages> 38-51, </pages> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Systems to visualize the execution history collected from a program can help explain what happens during program execution (e.g., <ref> [4, 10, 13, 15] </ref>).
Reference: [11] <author> W. Lipski and C. H. Papadimitriou. </author> <title> A fast algorithm for testing for safety and detecting deadlocks in locked transaction systems. </title> <journal> J. Alg., </journal> <volume> 2(3) </volume> <pages> 211-226, </pages> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: Each point in the graph represents a set of process times." Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood <ref> [11, 17, 22, 24] </ref> used UPGs to detect deadlocks in lock-based transaction systems. More recently Carson and Reynolds [7] used UPGs to prove liveness properties in programs with an arbitrary number of processes containing P and V operations on semaphores that are unconditionally executed. <p> Thus when process 1 starts 2 time units after process 0, the program either reaches a deadlock or process 0 blocks for 3 time units after which both processes run forever without blocking. Because UPGs have been used extensively for analysis of deadlocks <ref> [7, 11, 17, 22, 24] </ref>, deadlocks are not considered further in this paper. 2.3 Program 3: A Terminating Program Fig. 7, unlike the previous two programs, contains a terminating program. <p> Geometrically, a blocking LCET contains a horizontal or vertical ray, and a non-blocking LCET consists of a single diagonal ray. Two TETs are homotopic if they are continuously transformable avoiding the constraint lines (term due to Lipski and Papadimitriou <ref> [11] </ref> for paths in UPGs). For example, the TETs rooted at all points in fG j 5 G 0 6 ^ G 1 = 0g in Fig. 6 all consist of one diagonal ray and are homotopic.
Reference: [12] <author> J. Magott. </author> <title> Performance evaluation of systems of cyclic processes with mutual exclusion using Petri nets. </title> <journal> Information Processing Letters, </journal> <volume> 21 </volume> <pages> 229-232, </pages> <month> Nov. </month> <year> 1985. </year>
Reference-contexts: Therefore the class of programs meeting assumptions A1 through A6 is a DSSP restricted to two linear processes [23] but generalized to omit the private-buffer assumption (i.e., Definition 2.7 (ii) in [18]). Magott <ref> [12] </ref> gives an O (N ) algorithm to compute minimum cycle time (MCT), or the minimum time required for a consistent Petri net to return to its initial marking, given deterministic firing times for nets consisting of a set of N cyclic processes that mutually exclusively share a single June 19,
Reference: [13] <author> A. D. Malony. </author> <title> JED: Just an event display. </title> <editor> In M. Simmons and R. Koskela, editors, </editor> <booktitle> Performance Instrumentation and Visualization, </booktitle> <pages> pages 99-114. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Systems to visualize the execution history collected from a program can help explain what happens during program execution (e.g., <ref> [4, 10, 13, 15] </ref>).
Reference: [14] <author> J. Matousek. </author> <title> On vertical ray shooting in hyperplanes. Computational Geometry: </title> <journal> Theory and Applications, </journal> <volume> 2(5) </volume> <pages> 279-286, </pages> <month> Mar. </month> <year> 1993. </year>
Reference-contexts: To our knowledge, this is an open computational geometric problem, whose solution would allow solution of problems P1 and P2 for an arbitrary number of processes. The closest problem solved in d dimensions is ray shooting with unbounded hyperplanes that form a simple arrangement (e.g., see <ref> [14] </ref>). One limitation in d dimensions is that a progress graph represents contention by multiple processes for a resource as a nondeterministic choice of which process gets the resource, and does not represent different queueing disciplines.
Reference: [15] <author> B. Miller, M. Clark, J. Hollingsworth, S. Kierstead, S. Lim, and T. Torzewski. IPS-2: </author> <title> The second generation of a parallel program measurement system. </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 1(2) </volume> <pages> 206-217, </pages> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Systems to visualize the execution history collected from a program can help explain what happens during program execution (e.g., <ref> [4, 10, 13, 15] </ref>).
Reference: [16] <author> T. Murata. </author> <title> Petri nets: Properties, analysis and applications. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 77(4) </volume> <pages> 541-580, </pages> <month> Apr. </month> <year> 1989. </year> <month> June 19, </month> <title> 1995| An Example of Deriving Performance Properties 31 </title>
Reference-contexts: Therefore we propose as a solution to P3 the exhaustive testing of all L and i, evaluating f i (L:f ) as described in x5.1. 6 Relation of TPGs to Petri Nets Figures 13 (a) and 13 (b) are Petri net <ref> [16] </ref> representations of Figs. 1 and 4, respectively. The producer/consumer program in Figure 13 (a) is in the Petri Net class called Deterministic Systems of Synchronizing Processes (DSSP) [18]; the shaded place denotes a buffer shared by the two processes. <p> Fig. 13 (b) is a simple (or asymmetric choice) net (i.e., all arc weights are one and if two places share an output transition then the set of output transitions of one place is either equal to or a subset of the output transitions of the other place <ref> [16, p. 554] </ref>). Therefore the class of programs meeting assumptions A1 through A6 is a DSSP restricted to two linear processes [23] but generalized to omit the private-buffer assumption (i.e., Definition 2.7 (ii) in [18]).
Reference: [17] <author> C. H. Papadimitriou. </author> <title> Concurrency control by locking. </title> <journal> SIAM J. on Computing, </journal> <volume> 12(2) </volume> <pages> 215-226, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: Each point in the graph represents a set of process times." Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood <ref> [11, 17, 22, 24] </ref> used UPGs to detect deadlocks in lock-based transaction systems. More recently Carson and Reynolds [7] used UPGs to prove liveness properties in programs with an arbitrary number of processes containing P and V operations on semaphores that are unconditionally executed. <p> Thus when process 1 starts 2 time units after process 0, the program either reaches a deadlock or process 0 blocks for 3 time units after which both processes run forever without blocking. Because UPGs have been used extensively for analysis of deadlocks <ref> [7, 11, 17, 22, 24] </ref>, deadlocks are not considered further in this paper. 2.3 Program 3: A Terminating Program Fig. 7, unlike the previous two programs, contains a terminating program.
Reference: [18] <author> W. Reisig. </author> <title> Deterministic buffer synchronization of sequential systems. </title> <journal> Acta Informatica, </journal> <volume> 18 </volume> <pages> 117-134, </pages> <year> 1982. </year>
Reference-contexts: The producer/consumer program in Figure 13 (a) is in the Petri Net class called Deterministic Systems of Synchronizing Processes (DSSP) <ref> [18] </ref>; the shaded place denotes a buffer shared by the two processes. The data-base transaction program (Fig. 13 (b)), however, is not in class DSSP, because it violates the rule of a place representing a buffer being the input to at most one process. <p> Therefore the class of programs meeting assumptions A1 through A6 is a DSSP restricted to two linear processes [23] but generalized to omit the private-buffer assumption (i.e., Definition 2.7 (ii) in <ref> [18] </ref>).
Reference: [19] <author> G. Roman and K. Cox. </author> <title> A declarative approach to visualizing concurrent computations. </title> <journal> IEEE Computer, </journal> <volume> 22(10) </volume> <pages> 25-36, </pages> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: The answer to "why" helps identify how to change the program to improve the measure. But visualization has a use beyond providing images on a computer monitor: one can formally deduce properties about program execution from a visualization. This was first demonstrated by Roman and Cox <ref> [19] </ref>, who deduced correctness properties.
Reference: [20] <author> M. Sasieni, A. Yaspan, and L. Friedman. </author> <title> Operations Research Methods and Problems. </title> <publisher> John Wiley, </publisher> <address> New York, </address> <year> 1959. </year>
Reference-contexts: Our solution method represents program execution by a Timed Progress Graph (TPG). To our knowledge, TPGs were originally used in Operations Research to find minimum length schedules June 19, 1995| An Example of Deriving Performance Properties 4 for two jobs that share a set of machines <ref> [20, pp. 262-263] </ref>. However, a good and not necessarily minimal schedule was found "by eye" rather than by a formal method.
Reference: [21] <author> R. Sedgewick. </author> <title> Algorithms in C. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Precomputing this set is equivalent to a well known computational geometric June 19, 1995| An Example of Deriving Performance Properties 18 problem: computing all intersections of a collection of horizontal and vertical lines (e.g., see <ref> [21, Ch. 27] </ref>). Thus computation of f o is not considered further. Computation of f d (G): Recall that f d (G) is the smallest of (1; 1) and each point at which a slope one ray rooted at G intersects a constraint line instance.
Reference: [22] <author> E. Soisalon-Soininen and D. Wood. </author> <title> An optimal algorithm for testing for safety and detecting deadlocks in locked transaction system. </title> <booktitle> In Symp. on Principles of Database Systems, </booktitle> <pages> pages 108-116, </pages> <address> Los Angeles, </address> <month> Mar. </month> <year> 1982. </year> <note> ACM. </note>
Reference-contexts: Each point in the graph represents a set of process times." Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood <ref> [11, 17, 22, 24] </ref> used UPGs to detect deadlocks in lock-based transaction systems. More recently Carson and Reynolds [7] used UPGs to prove liveness properties in programs with an arbitrary number of processes containing P and V operations on semaphores that are unconditionally executed. <p> Thus when process 1 starts 2 time units after process 0, the program either reaches a deadlock or process 0 blocks for 3 time units after which both processes run forever without blocking. Because UPGs have been used extensively for analysis of deadlocks <ref> [7, 11, 17, 22, 24] </ref>, deadlocks are not considered further in this paper. 2.3 Program 3: A Terminating Program Fig. 7, unlike the previous two programs, contains a terminating program.
Reference: [23] <author> Y. Souissi and N. Beldiceneau. </author> <title> Deterministic systems of sequential processes: </title> <booktitle> Theory and tools. Concurrency 88, 335 Lecture Notes in Computer Science:380-400, </booktitle> <year> 1988. </year>
Reference-contexts: Therefore the class of programs meeting assumptions A1 through A6 is a DSSP restricted to two linear processes <ref> [23] </ref> but generalized to omit the private-buffer assumption (i.e., Definition 2.7 (ii) in [18]).
Reference: [24] <author> M. Yannakakis, C. H. Papadimitriou, and H. T. Kung. </author> <title> Locking policies: Safety and freedom from deadlock. </title> <booktitle> In 20th ACM Symp. on the Foundations of Computer Sci., </booktitle> <pages> pages 283-287, </pages> <year> 1979. </year>
Reference-contexts: Each point in the graph represents a set of process times." Kung, Lipski, Papadimitriou, Soisalon-Soininen, Yannakakis, and Wood <ref> [11, 17, 22, 24] </ref> used UPGs to detect deadlocks in lock-based transaction systems. More recently Carson and Reynolds [7] used UPGs to prove liveness properties in programs with an arbitrary number of processes containing P and V operations on semaphores that are unconditionally executed. <p> Thus when process 1 starts 2 time units after process 0, the program either reaches a deadlock or process 0 blocks for 3 time units after which both processes run forever without blocking. Because UPGs have been used extensively for analysis of deadlocks <ref> [7, 11, 17, 22, 24] </ref>, deadlocks are not considered further in this paper. 2.3 Program 3: A Terminating Program Fig. 7, unlike the previous two programs, contains a terminating program.
References-found: 24

