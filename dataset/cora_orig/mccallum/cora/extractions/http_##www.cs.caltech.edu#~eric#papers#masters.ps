URL: http://www.cs.caltech.edu/~eric/papers/masters.ps
Refering-URL: http://www.cs.caltech.edu/~eric/papers/papers.html
Root-URL: http://www.cs.caltech.edu
Title: Recurrence-Based Reductions for Inclusion and Exclusion Algorithms Applied to #P Problems  
Author: Eric Bax 
Keyword: Key words algorithms, combinatorial problems, parallel algorithms.  
Address: Technology 256-80, Pasadena, California, 91125  
Affiliation: Computer Science Department, California Institute of  
Note: AMS subject classifications 05,68 Supported by an NSF fellowship.  
Email: (eric@csvax.caltech.edu).  
Date: January 23, 1996  
Abstract: There are inclusion and exclusion algorithms for many #P problems. By imposing a hierarchy on the inclusion and exclusion formula's terms, we develop general reductions for inclusion and exclusion algorithms. We outline sufficient steps to tailor the general reductions to specific problems, and we illustrate this process by applying it to algorithms for several #P problems. We test the reductions on the problem of counting Hamiltonian paths. Within the framework of the general reductions, we develop the concepts of zero sets and vestigial elements, and we present problem decomposition strategies. Also, we show how the reductions can be applied to algorithms that give approximate solutions to #P problems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Bax, </author> <title> Inclusion and exclusion algorithm for the Hamiltonian path problem, </title> <journal> Inf. Proc. Lett., </journal> <volume> 47 (4) (1993), </volume> <pages> pp. 203-207. </pages>
Reference-contexts: So to compute N (;; S), form A (V S) from A by zeroing all rows and columns corresponding to elements of S; then N (;; S) = [A (S) n+1 ] st . This method is explained with more detail in <ref> [1] </ref>. Another method to compute N (;; S) is given in [8]. RECURRENCE-BASED REDUCTIONS 9 3 Theorems, Reductions, and the Counting Al gorithm 3.1 N (R; S) Bounding and Symmetry Theorems Theorem 2 (Nonnegativity) N (R; S) 0. Proof.
Reference: [2] <author> E. Bax, </author> <title> Counting paths and cycles, </title> <journal> Inf. Proc. Lett., </journal> <volume> 52 (1994), </volume> <pages> pp. 249-252. </pages>
Reference-contexts: For example, consider the population of cycles in a graph. Tarjan's cycle listing algorithm [18] has time complexity O (njEjjCj), where n, jEj, and jCj are the numbers of vertices, edges, and cycles, respectively. There is a cycle counting algorithm <ref> [2] </ref> with time complexity O (2 n poly (n)). Since there may be O (n!) cycles, the counting algorithm is more efficient for simply determining the number of cycles. 2 E.
Reference: [3] <author> R. Bellman, </author> <title> Combinatorial processes and dynamic programming, </title> <editor> in: R. Bellman and M. Hall, Eds., </editor> <booktitle> Combinatorial Analysis, Proc. AMS Symposia on Applied Mathematics, </booktitle> <volume> Vol. X, </volume> <publisher> American Mathematical Society, </publisher> <address> Providence, RI, </address> <year> 1960. </year>
Reference: [4] <author> M. R. Garey and D. S. Johnson, </author> <title> Computers and Intractability A Guide to the Theory of NP-Completeness W. </title> <editor> H. </editor> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: But counting the cycles on a vertex is #P-complete [20]. For definitions and in-depth treatment of P, NP, NP-completess, #P, and #P-completeness, refer to <ref> [4] </ref>. Algorithms for #P problems return a population size, not a list of the population's members. When the population size is exponential in the size of the input, a listing algorithm must take at least exponential time.
Reference: [5] <author> Y. Gurevich AND S. Shelah, </author> <title> Expected computation time for Hamil-tonian path problem, </title> <journal> SIAM J. Comput., </journal> <volume> 16 (3) (1987), </volume> <pages> pp. 486-502. </pages>
Reference-contexts: For large n, is the algorithm efficient in the p threshold range? The algorithm's performance in the p threshold range affects its usefulness as a backup algorithm 16 E. BAX RECURRENCE-BASED REDUCTIONS 17 18 E. BAX RECURRENCE-BASED REDUCTIONS 19 for probabilistic detection algorithms (e.g. <ref> [5] </ref>) that work well when G n;p is either almost surely Hamiltonian or almost surely non-Hamiltonian. 20 E. BAX 5 Tailoring the Algorithm to Other #P Prob lems To use the algorithm on a given problem: 1.
Reference: [6] <author> M. Held and R. M. Karp, </author> <title> A dynamic programming approach to sequencing problems, </title> <journal> J. Soc. Indust. Appl. Math., </journal> <volume> 10 (1962), </volume> <pages> pp. 196-210. </pages>
Reference: [7] <author> R. M. Karp, </author> <title> Reducibility among combinatorial problems, </title> <editor> in R. E. Miller and J. W. Thatcher (eds.), </editor> <title> Complexity of Computer Computations, </title> <publisher> Plenum Press, </publisher> <address> New York, </address> <pages> 85-103. </pages>
Reference-contexts: For example, determining whether or not a graph contains a Hamil-tonian cycle is an NP problem. So counting the Hamiltonian cycles in a graph is a #P problem. The Hamiltonian cycle existence problem is NP-complete <ref> [7] </ref>, meaning that every NP problem is polynomially reducible to Hamiltonian cycle existence. Likewise, the counting problem is #P-complete [20], meaning that every #P problem is polynomially reducible to counting Hamiltonian cycles.
Reference: [8] <author> R. M. Karp, </author> <title> Dynamic programming meets the principle of inclusion and exclusion, </title> <journal> Operations Research Letters, </journal> <volume> 1 (2) (1982), </volume> <pages> pp. 49-51. </pages>
Reference-contexts: necessary to implement the dynamic programming algorithm on a parallel computer. 1.3 Inclusion and Exclusion Algorithms for #P Problems There are inclusion and exclusion algorithms for many #P problems, including counting vertex colorings [21], computing the matrix permanent [16], counting Hamiltonian paths, counting feasible solutions for sequencing and bin packing <ref> [8] </ref>, and counting satisfying assignments for conjunctive normal form (CNF) expressions [10]. The primary example in this paper is an inclusion and exclusion algorithm to count Hamiltonian paths. <p> Definition 1 N (R; S) j ( T T N (R; S) counts the members of U that are in every set indexed by R and that are not in any set indexed by S. (This is an extension of Karp's N (S) <ref> [8] </ref>.) Define N (;; ;) to be jU j. For an illustration and examples of N (R; S), see Figures 1 and 2. Theorem 1 (Recursion) 8r 2 R; N (R; S) = N (R frg; S) N (R frg; S [ frg) (3) Proof. <p> This method is explained with more detail in [1]. Another method to compute N (;; S) is given in <ref> [8] </ref>. RECURRENCE-BASED REDUCTIONS 9 3 Theorems, Reductions, and the Counting Al gorithm 3.1 N (R; S) Bounding and Symmetry Theorems Theorem 2 (Nonnegativity) N (R; S) 0. Proof. <p> Assuming that each N (;; S) computation and each symmetry search takes poly (n) time, the worst case time complexity is O (2 n poly (n)). For the Hamiltonian path problem, partitioning R by sym () takes O (njEj) time. Also, computing N (S) requires O (njEj) time <ref> [8] </ref> for each S f1 : : : ng. Therefore, the algorithm to count Hamiltonian paths has time complexity O (2 n njEj). <p> For example, to search for an immediate zero set reduction in the algorithm to count Hamiltonian paths, it is faster to search for a cut vertex in R that separates s from t than to calculate N (;; S [ frg) 8r 2 R by counting s-t walks <ref> [8] </ref>. So if there is a high probability of cut vertices, it is efficient to search for them directly.
Reference: [9] <author> W. X. Li and F. Tian, </author> <title> Some notes on the chromatic polynomials of graphs (Chinese), </title> <journal> Acta Math. Sinica, </journal> <volume> 21 (1978), </volume> <pages> pp. 223-230. </pages>
Reference-contexts: However, they relate the notion of vestigial elements to interesting work by other researchers <ref> [9, 11, 21] </ref>. Theorem 7 (Vestigial Element Cancellation) If v is a vestigial element with structure X, then: X SX Proof. Each S X with v 62 S can be paired with S [ fvg X.
Reference: [10] <author> N. Linial and N. Nisan, </author> <title> Approximate inclusion-exclusion, </title> <journal> Combinator-ica, </journal> <volume> 10 (4) (1990), </volume> <pages> pp. 349-365. </pages>
Reference-contexts: 1.3 Inclusion and Exclusion Algorithms for #P Problems There are inclusion and exclusion algorithms for many #P problems, including counting vertex colorings [21], computing the matrix permanent [16], counting Hamiltonian paths, counting feasible solutions for sequencing and bin packing [8], and counting satisfying assignments for conjunctive normal form (CNF) expressions <ref> [10] </ref>. The primary example in this paper is an inclusion and exclusion algorithm to count Hamiltonian paths. As results are developed, they are generalized and then applied to counting vertex colorings, counting CNF satisfiers, and computing the matrix permanent. 4 E. <p> Otherwise, N (;; S) is 2 m (S) , where m (S) is the number of variables that do not occur in any clause indexed by S. This algorithm was developed by N. Linial and N. Nisan <ref> [10] </ref>. An example will clarify the terms and calculations.
Reference: [11] <author> G. H. J. Meredith, </author> <title> Coefficients of chromatic polynomials, </title> <journal> J. Combinatorial Theory (B), </journal> <volume> 13 (1972), </volume> <pages> pp. 14-17. </pages>
Reference-contexts: However, they relate the notion of vestigial elements to interesting work by other researchers <ref> [9, 11, 21] </ref>. Theorem 7 (Vestigial Element Cancellation) If v is a vestigial element with structure X, then: X SX Proof. Each S X with v 62 S can be paired with S [ fvg X.
Reference: [12] <author> A. Nijenhuis and H. S. Wilf, </author> <title> Combinatorial Algorithms For Computers and Calculators Academic Press, </title> <address> New York, </address> <year> 1978. </year>
Reference-contexts: There are k choices for the root, k 1 thereafter.) So if H (R; S) is a tree there is no need to continue the recursion <ref> [12] </ref>. Also, if H (R; S) is disconnected, then the number of k-colorings is the product of the numbers of k-colorings of its components. So the component colorings can be computed separately.
Reference: [13] <author> C. H. Papadimitriou and K. Steiglitz, </author> <title> Combinatorial Optimization, Algorithms and Complexity Prentice-Hall, </title> <publisher> Inc., </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1982, </year> <pages> pp. 433-448. </pages>
Reference-contexts: BAX 8 Detection and Bounding Algorithms The counting algorithm can be altered to solve the detection problem, i.e. to determine whether or not N (f1 : : : ng; ;) &gt; 0. We follow the branch and bound model <ref> [13] </ref>, but we use the method for counting rather than optimization. The algorithm begins with a single active node representing N (f1 : : : ng; ;). At each step an active node is replaced by an equivalent set of active nodes (branches) or computed N (S) terms (leaves).
Reference: [14] <author> L. P osa, </author> <title> Hamiltonian circuits in random graphs, </title> <journal> Discrete Mathematics, </journal> <volume> 14 (1976), </volume> <pages> pp. 359-364. </pages> <note> RECURRENCE-BASED REDUCTIONS 49 </note>
Reference-contexts: In highly symmetric graphs it may be worthwhile to examine symmetry among subgraphs as well. Posa <ref> [14] </ref> shows that the minimum p value for which G n;p is almost surely Hamiltonian decreases to zero as n goes to infinity.
Reference: [15] <author> R. C. Read and W. T. Tutte, </author> <title> Chromatic Polynomials, Selected Topics in Graph Theory 3, </title> <editor> L. W. Beineke and Robin J. Wilson, ed., </editor> <publisher> Academic Press Limited 1988, </publisher> <address> Ch. </address> <month> 2. </month>
Reference-contexts: To form H (R frg; S), remove edge r from H (R; S); to form H (R frg; S [ frg), contract edge r combine its vertices to make a single vertex with the union of the original vertices' adjacencies. This is the contraction-deletion formula for graph coloring <ref> [15] </ref>. The computation is reduced by multiple edges being combined when we take the union of adjacencies. (This is the completer reduction at work.) So choose the split edge r to be the edge shared by the connected vertex pair with the most adjacencies in common. <p> Also, if H (R; S) is disconnected, then the number of k-colorings is the product of the numbers of k-colorings of its components. So the component colorings can be computed separately. For further discussion, references, and results on coloring, see <ref> [15] </ref>. 6.5.3 CNF Satisfying Assignments Recall that N (;; S) is zero if both a variable and its negation occur in the clauses indexed by S.
Reference: [16] <author> H. J. </author> <title> Ryser, </title> <journal> Combinatorial Mathematics The Mathematical Association of America, 1963, Ch. </journal> <volume> 2. </volume>
Reference-contexts: This requires C (n; k) + C (n; k 1) storage locations. So the algorithm has space complexity O (C (n; d n 2 e)) = n 2 n ). Now examine the inclusion and exclusion algorithm by Ryser <ref> [16] </ref>: perA = X (1) jSj ( i j62S This algorithm will be fully explained later in this paper; for now just consider its time and space requirements. <p> Consequently, much more synchronization waiting and message passing are necessary to implement the dynamic programming algorithm on a parallel computer. 1.3 Inclusion and Exclusion Algorithms for #P Problems There are inclusion and exclusion algorithms for many #P problems, including counting vertex colorings [21], computing the matrix permanent <ref> [16] </ref>, counting Hamiltonian paths, counting feasible solutions for sequencing and bin packing [8], and counting satisfying assignments for conjunctive normal form (CNF) expressions [10]. The primary example in this paper is an inclusion and exclusion algorithm to count Hamiltonian paths. <p> A more general inclusion and exclusion result is given by H. J. Ryser in <ref> [16] </ref>. RECURRENCE-BASED REDUCTIONS 5 6 E. BAX RECURRENCE-BASED REDUCTIONS 7 8 E. BAX 2.2 Counting Hamiltonian Paths To demonstrate the notation, consider the problem of counting s-t Hamiltonian paths in a directed graph with vertex set V = fs; tg [ f1 : : : ng. <p> J. Ryser <ref> [16] </ref>. Since the product of row sums is invariant under permutations of the columns, to use the symmetry reduction, make M the largest set of equal columns in R.
Reference: [17] <author> E. Shamir, </author> <title> How many random edges make a graph Hamiltonian? Combi-natorica, </title> <booktitle> 3 (1) (1983), </booktitle> <pages> pp. 123-131. </pages>
Reference-contexts: In highly symmetric graphs it may be worthwhile to examine symmetry among subgraphs as well. Posa [14] shows that the minimum p value for which G n;p is almost surely Hamiltonian decreases to zero as n goes to infinity. Shamir <ref> [17] </ref> shows that the threshold p range in which G n;p is neither almost surely Hamiltonian nor almost surely non-Hamiltonian decreases to zero as n goes to infinity. These results are validated by Figure 11.
Reference: [18] <author> R. Tarjan, </author> <title> Enumeration of the elementary circuits of a directed graph, </title> <journal> SIAM J. Comput., </journal> <volume> 2 (3) (1973), </volume> <pages> pp. 211-216. </pages>
Reference-contexts: Designers of listing algorithms try to achieve minimum computation per member of the population, while designers of counting algorithms try to determine the population size without enumerating the individual members of the population. For example, consider the population of cycles in a graph. Tarjan's cycle listing algorithm <ref> [18] </ref> has time complexity O (njEjjCj), where n, jEj, and jCj are the numbers of vertices, edges, and cycles, respectively. There is a cycle counting algorithm [2] with time complexity O (2 n poly (n)).
Reference: [19] <author> L. G. Valiant, </author> <title> The complexity of computing the permanent, </title> <type> Theoret. </type> <institution> Comput. Sci., </institution> <month> 8 (2) </month> <year> (1979) </year> <month> 189-201. </month>
Reference-contexts: BAX 1.2 Inclusion and Exclusion Algorithms To compare straightforward computation, dynamic programming, and inclusion and exclusion algorithms, consider the calculation of the permanent of an n fi n matrix A. Valiant <ref> [19] </ref> has shown this problem to be #P-complete. By definition: perA = X a 1j 1 : : : a nj n (1) where j 1 : : : j n is a permutation of 1 : : : n.
Reference: [20] <author> L. G. Valiant, </author> <title> The complexity of enumeration and reliability problems, </title> <note> SIAM J. Comput., 8 (3) (1979) 410-421. </note>
Reference-contexts: So counting the Hamiltonian cycles in a graph is a #P problem. The Hamiltonian cycle existence problem is NP-complete [7], meaning that every NP problem is polynomially reducible to Hamiltonian cycle existence. Likewise, the counting problem is #P-complete <ref> [20] </ref>, meaning that every #P problem is polynomially reducible to counting Hamiltonian cycles. Clearly, if a population can be counted in polynomial time, then the existence of a member of the population can be determined in polynomial time. <p> This problem is in P because there is a cycle on vertex i if and only if [A m ] ii &gt; 0 for some m n. But counting the cycles on a vertex is #P-complete <ref> [20] </ref>. For definitions and in-depth treatment of P, NP, NP-completess, #P, and #P-completeness, refer to [4]. Algorithms for #P problems return a population size, not a list of the population's members.
Reference: [21] <author> H. Whitney, </author> <title> A logical expansion in mathematics, </title> <journal> Bull. Amer. Math. Soc., </journal> <volume> 38 (1932), </volume> <pages> pp. 572-579. </pages>
Reference-contexts: Consequently, much more synchronization waiting and message passing are necessary to implement the dynamic programming algorithm on a parallel computer. 1.3 Inclusion and Exclusion Algorithms for #P Problems There are inclusion and exclusion algorithms for many #P problems, including counting vertex colorings <ref> [21] </ref>, computing the matrix permanent [16], counting Hamiltonian paths, counting feasible solutions for sequencing and bin packing [8], and counting satisfying assignments for conjunctive normal form (CNF) expressions [10]. The primary example in this paper is an inclusion and exclusion algorithm to count Hamiltonian paths. <p> To illustrate the process, we tailor the algorithm to the problems of counting vertex colorings, counting CNF satisfying assignments, and computing the permanent of a 0-1 matrix. 5.1 Vertex Coloring The original inclusion and exclusion algorithm to count colorings is due to H. Whitney <ref> [21] </ref>. For a given k, an assignment is a labelling of the vertices in G = (V; E) such that each vertex receives one of k colors. A monochrome edge has both incident vertices the same color. An edge that is incident to two vertices with different colors is polychrome. <p> However, they relate the notion of vestigial elements to interesting work by other researchers <ref> [9, 11, 21] </ref>. Theorem 7 (Vestigial Element Cancellation) If v is a vestigial element with structure X, then: X SX Proof. Each S X with v 62 S can be paired with S [ fvg X. <p> 1 : : : C K in ascending order of highest-numbered edges, then the conditions of vestigial element interference theorem are satisfied by assigning the highest-numbered edge in C i to v i and setting X i = C i v i . (The X i are Whitney's broken cycles <ref> [21] </ref>.) N (R; S) counts the assignments in which the vertices of each edge in R have separate colors, and every component of G (S) is monochrome.
Reference: [22] <author> D. Zeilberger, </author> <title> Garsia and Milne's bijective proof of the inclusion-exclusion principle, </title> <journal> Discrete Mathematics, </journal> <volume> 51 (1984), </volume> <pages> pp. 109-110. </pages>
Reference-contexts: N (f1 : : : ng; ;) gives the inclusion and exclusion formula: N (f1 : : : ng; ;) = Sf1:::ng jB 1 " : : : " B n j = Sf1;:::;ng " B k j (8) where T For a different proof of inclusion and exclusion, see <ref> [22] </ref>. A more general inclusion and exclusion result is given by H. J. Ryser in [16]. RECURRENCE-BASED REDUCTIONS 5 6 E. BAX RECURRENCE-BASED REDUCTIONS 7 8 E.
References-found: 22

