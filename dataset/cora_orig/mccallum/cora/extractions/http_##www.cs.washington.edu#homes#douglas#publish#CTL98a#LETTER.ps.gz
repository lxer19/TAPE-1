URL: http://www.cs.washington.edu/homes/douglas/publish/CTL98a/LETTER.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/douglas/publish/CTL98a/index.html
Root-URL: http://www.cs.washington.edu
Email: fcollberg,cthombor,dlow001g@cs.auckland.ac.nz  
Phone: Phone: +64-9-373-7599  
Title: Manufacturing Cheap, Resilient, and Stealthy Opaque Constructs  
Author: Christian Collberg Clark Thomborson Douglas Low 
Address: Private Bag 92019 Auckland, New Zealand.  
Affiliation: Department of Computer Science The University of Auckland  
Abstract: It has become common to distribute software in forms that are isomorphic to the original source code. An important example is Java bytecode. Since such codes are easy to decompile, they increase the risk of malicious reverse engineering attacks. In this paper we describe the design of a Java code obfus-cator, a tool which through the application of code transformations converts a Java program into an equivalent one that is more difficult to reverse engineer. We describe a number of transformations which obfuscate control-flow. Transformations are evaluated with respect to potency (To what degree is a human reader confused?), resilience (How well are automatic deobfuscation attacks resisted?), cost (How much time/space overhead is added?), and stealth (How well does obfuscated code blend in with the original code?). The resilience of many control-altering transformations rely on the resilience of opaque predicates. These are boolean valued expressions whose values are known to the obfuscator but difficult to determine for an automatic deobfuscator. We show how to construct resilient, cheap, and stealthy opaque predicates based on the intractability of certain static analysis problems such as alias analysis. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year> <note> ISBN 0-201-10088-6. </note>
Reference-contexts: Language-breaking transformations take advantage of this to introduce virtual machine instruction sequences which have no direct correspondence with any source language construct. a reducible flow graph to a non-reducible one, by turning a structured loop into a loop with multiple headers <ref> [1] </ref>. A bogus jump (protected by an opaque predicate P F ) is added to the code to make it appear that there is a jump into the middle of a loop. <p> Common patterns include pp==nullq, pp==qq, pn &lt;= IntLitq, where p,q are pointers and n is an integer. We must be able to generate cheap and inconspicuous opaque predicates that resemble these patterns. Since we expect most deobfuscators to employ various static analysis techniques (such as data-flow analysis <ref> [1] </ref> and slicing [24]) it seems natural to base the construction of opaque predicates on problems which these techniques cannot handle well. In particular, precise static analysis of pointer-based structures and parallel regions is known to be intractable.
Reference: [2] <author> David F. Bacon, Susan L. Graham, and Oliver J. Sharp. </author> <title> Compiler transformations for high-performance computing. </title> <journal> ACM Computing Surveys, </journal> <volume> 26(4) </volume> <pages> 345-420, </pages> <month> December </month> <year> 1994. </year> <note> http://www.acm.org/pubs/toc/ Abstracts/0360-0300/197406.html. </note>
Reference-contexts: Some of these are closely related to code optimizations such as inlining, outlining, cloning, parallelization, and various loop optimizations <ref> [2] </ref>.
Reference: [3] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <journal> ACM SIG-PLAN Notices, </journal> <volume> 25(6) </volume> <pages> 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Ghiya's [8] algorithm provides accurate information for programs that build simple data structures (trees and arrays of trees), but isn't powerful enough to handle programs that make major structural changes to the structure. Chase's <ref> [3] </ref> algorithm also has problems with destructive updates. In particular, while it handles list append, it fails to analyze an in-place list reversal program. Hendren [12] cannot handle cyclic structures, and many other algorithms only handle recursive structures that are no more than k levels deep.
Reference: [4] <author> Shyam R. Chidamber and Chris F. Kemerer. </author> <title> A metrics suite for object oriented design. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(6) </volume> <pages> 476-493, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Other metrics express that the complexity of a program increases with the the complexity of its data structures [19], the number of inter-basic block variable dependencies [20], the number of formal parameters [13], and the depth of its inheritance tree <ref> [4] </ref>. We say that a transformation which increases any of these metrics is a highly potent obfuscating transformation. 3.2.2 Measures of Resilience At first glance it would seem to be trivial to construct potent obfuscating transformations.
Reference: [5] <author> Cristina Cifuentes and K. John Gough. </author> <title> Decompilation of binary programs. </title> <journal> Software Practice& Experience, </journal> <volume> 25(7) </volume> <pages> 811-829, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: This is a problem that has recently received renewed attention. The reason is that it is becoming more com mon to distribute software in architecture-neutral formats, (such as Java bytecode [10] and ANDF [16]), and because of the emergence of reverse engineering tools such as decom-pilers <ref> [5, 21] </ref> and program slicers [24]. 1.1 Means of Software Protection Alice can protect her code from Bob's attack using either legal [23] or technical [9] protection. <p> When downloading the application, the user's site would identify its architecture, and the corresponding native code version of the application (perhaps digitally signed by Alice to assure authenticity and harmlessness) would be transmitted. Only having access to the native code will make Bob's task more difficult, although not impossible <ref> [5] </ref>. 1.2 Code Obfuscation The final approach, and the one we will advocate in this paper, is code obfuscation (Figure 1).
Reference: [6] <author> Christian Collberg, Clark Thomborson, and Dou-glas Low. </author> <title> A taxonomy of obfuscating transformations. </title> <type> Technical Report 148, </type> <institution> Department of Computer Science, University of Auckland, </institution> <month> July </month> <year> 1997. </year> <note> http://www.cs.auckland.ac.nz/~collberg/ Research/Publications/CollbergThomborsonLow97a. </note>
Reference-contexts: In fact, several variants could be included with (and used in different parts of) the same application. 2. Invocations of the Graph primitives should be subject to the same obfuscations as the user code, including inlining, outlining, and name mangling <ref> [6] </ref>. 3. Rather than including the Graph ADT as a stand-alone class, it could be merged with the most similar user-defined class. This way, the bogus Graph nodes created by the obfuscated application would be indistinguishable from real objects created by the original applica tion. <p> The finalizers may run at any time (or not run at all) after the objects a and b have been released at point 1 . Regardless, pointers p and q will point to different structures at point 2 . tionships <ref> [6] </ref>.
Reference: [7] <author> A. Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In SIGPLAN PLDI'94, </booktitle> <pages> pages 230-241, </pages> <address> Orlando (Florida, USA), </address> <month> June </month> <year> 1994. </year> <journal> ACM. SIGPLAN Notices, </journal> <volume> 29(6). </volume>
Reference-contexts: In particular, while it handles list append, it fails to analyze an in-place list reversal program. Hendren [12] cannot handle cyclic structures, and many other algorithms only handle recursive structures that are no more than k levels deep. The most powerful algorithm to date seems to be Deutsch <ref> [7] </ref>, but the implementation is complex (8000 lines of ML) and slow even for small programs (30 seconds to analyze a 50 line program).
Reference: [8] <author> Rakesh Ghiya and Laurie J. Hendren. </author> <title> Is it a tree, a DAG, or a cyclic graph? A shape analysis for heap-directed pointers in C. </title> <booktitle> In POPL'96, </booktitle> <pages> pages 1-15, </pages> <address> St. Petersburg Beach, Florida, </address> <month> 21-24 January </month> <year> 1996. </year>
Reference-contexts: All practical heap analysis algorithms are by necessity imprecise, but different algorithms will perform more or less well for particular types of dynamic structures. Ghiya's <ref> [8] </ref> algorithm provides accurate information for programs that build simple data structures (trees and arrays of trees), but isn't powerful enough to handle programs that make major structural changes to the structure. Chase's [3] algorithm also has problems with destructive updates.
Reference: [9] <author> James R. Gosler. </author> <title> Software protection: </title> <booktitle> Myth or reality? In CRYPTO'85 | Advances in Cryptology, </booktitle> <pages> pages 140-157, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: distribute software in architecture-neutral formats, (such as Java bytecode [10] and ANDF [16]), and because of the emergence of reverse engineering tools such as decom-pilers [5, 21] and program slicers [24]. 1.1 Means of Software Protection Alice can protect her code from Bob's attack using either legal [23] or technical <ref> [9] </ref> protection. Economic realities often make it difficult for a small company like Alice's to enforce the law against a larger and more powerful competitor [17].
Reference: [10] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year> <note> ISBN 0-201-63451-1. </note>
Reference-contexts: This is a problem that has recently received renewed attention. The reason is that it is becoming more com mon to distribute software in architecture-neutral formats, (such as Java bytecode <ref> [10] </ref> and ANDF [16]), and because of the emergence of reverse engineering tools such as decom-pilers [5, 21] and program slicers [24]. 1.1 Means of Software Protection Alice can protect her code from Bob's attack using either legal [23] or technical [9] protection.
Reference: [11] <author> Warren A. Harrison and Kenneth I. Magel. </author> <title> A complexity measure based on nesting level. </title> <journal> SIGPLAN Notices, </journal> <volume> 16(3) </volume> <pages> 63-74, </pages> <year> 1981. </year>
Reference-contexts: Of particular interest to us are the McCabe [18] and Har-rison <ref> [11] </ref> metrics. McCabe states that the complexity of a program grows with the number of predicates it contains. According to Harrison, the complexity is also proportional to the nesting level of conditional and looping constructs.
Reference: [12] <author> Laurie J. Hendren and Alexandru Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Chase's [3] algorithm also has problems with destructive updates. In particular, while it handles list append, it fails to analyze an in-place list reversal program. Hendren <ref> [12] </ref> cannot handle cyclic structures, and many other algorithms only handle recursive structures that are no more than k levels deep.
Reference: [13] <author> Sallie Henry and Dennis Kafura. </author> <title> Software structure metrics based on information flow. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 7(5) </volume> <pages> 510-518, </pages> <month> Septem-ber </month> <year> 1981. </year>
Reference-contexts: According to Harrison, the complexity is also proportional to the nesting level of conditional and looping constructs. Other metrics express that the complexity of a program increases with the the complexity of its data structures [19], the number of inter-basic block variable dependencies [20], the number of formal parameters <ref> [13] </ref>, and the depth of its inheritance tree [4]. We say that a transformation which increases any of these metrics is a highly potent obfuscating transformation. 3.2.2 Measures of Resilience At first glance it would seem to be trivial to construct potent obfuscating transformations.
Reference: [14] <author> Amir Herzberg and Shlomit S. Pinter. </author> <title> Public protection of software. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(4) </volume> <pages> 371-393, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Bob will never gain physical access to the application and will be unable to reverse engineer it. Because of limits on network capacity the application will perform much worse than if it had run locally. Alternatively, Alice could protect her code through encryption <ref> [14, 27] </ref>. This only works if the entire decryption/execution process takes place in hardware. If the code is executed in software by a virtual machine interpreter (as is most often the case with Java bytecodes), then it will always be possible for Bob to intercept and decompile the decrypted code.
Reference: [15] <author> Jens Knoop, Bernhard Steffen, and Jurgen Vollmer. </author> <title> Parallelism for free: Efficient and optimal bitvector analyses for parallel programs. </title> <journal> TOPLAS, </journal> <volume> 18(3) </volume> <pages> 268-299, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: The reason is their interleaving semantics: n statements in a parallel region PAR S 1 ; S 2 ; ; S n ; ENDPAR can be executed in n! different ways. In spite of this, some static analyses over parallel programs can be performed in polynomial time <ref> [15] </ref>, while others require all n! interleavings to be considered. In Java, parallel regions are constructed using lightweight processes known as threads.
Reference: [16] <author> Stavros Macrakis. </author> <title> Protecting source code with ANDF. </title> <address> ftp://riftp.osf.org/pub/andf/andf_coll_ papers/ProtectingSourceCode.ps, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: This is a problem that has recently received renewed attention. The reason is that it is becoming more com mon to distribute software in architecture-neutral formats, (such as Java bytecode [10] and ANDF <ref> [16] </ref>), and because of the emergence of reverse engineering tools such as decom-pilers [5, 21] and program slicers [24]. 1.1 Means of Software Protection Alice can protect her code from Bob's attack using either legal [23] or technical [9] protection.
Reference: [17] <author> Apple's QuickTime lawsuit. </author> <note> http://www. macworld.com/pages/june.95/News.848.html and may.95/News.705.html, May-June 1995. </note>
Reference-contexts: Economic realities often make it difficult for a small company like Alice's to enforce the law against a larger and more powerful competitor <ref> [17] </ref>. A more attractive solution is for Alice to protect her code by making reverse engineering so technically difficult that it becomes at the very least economically inviable. The most secure approach is for Alice not to sell her application at all, but rather sell its services.
Reference: [18] <author> T. J. McCabe. </author> <title> A complexity measure. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 2(4) </volume> <pages> 308-320, </pages> <month> December </month> <year> 1976. </year>
Reference-contexts: Of particular interest to us are the McCabe <ref> [18] </ref> and Har-rison [11] metrics. McCabe states that the complexity of a program grows with the number of predicates it contains. According to Harrison, the complexity is also proportional to the nesting level of conditional and looping constructs.
Reference: [19] <author> John C. Munson and Taghi M. Kohshgoftaar. </author> <title> Measurement of data structure complexity. </title> <journal> Journal of Systems Software, </journal> <volume> 20 </volume> <pages> 217-225, </pages> <year> 1993. </year>
Reference-contexts: According to Harrison, the complexity is also proportional to the nesting level of conditional and looping constructs. Other metrics express that the complexity of a program increases with the the complexity of its data structures <ref> [19] </ref>, the number of inter-basic block variable dependencies [20], the number of formal parameters [13], and the depth of its inheritance tree [4].
Reference: [20] <author> E. I. Oviedo. </author> <title> Control flow, data flow, and program complexity. </title> <booktitle> In Proceedings of IEEE COMPSAC, </booktitle> <pages> pages 146-152, </pages> <month> November </month> <year> 1980. </year>
Reference-contexts: According to Harrison, the complexity is also proportional to the nesting level of conditional and looping constructs. Other metrics express that the complexity of a program increases with the the complexity of its data structures [19], the number of inter-basic block variable dependencies <ref> [20] </ref>, the number of formal parameters [13], and the depth of its inheritance tree [4]. We say that a transformation which increases any of these metrics is a highly potent obfuscating transformation. 3.2.2 Measures of Resilience At first glance it would seem to be trivial to construct potent obfuscating transformations.
Reference: [21] <author> Todd A. Proebsting and Scott A. Watterson. </author> <title> Krakatoa: Decompilation in java (Does bytecode reveal source?). </title> <booktitle> In Third USENIX Conference on Object-Oriented Technologies and Systems (COOTS), </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: This is a problem that has recently received renewed attention. The reason is that it is becoming more com mon to distribute software in architecture-neutral formats, (such as Java bytecode [10] and ANDF [16]), and because of the emergence of reverse engineering tools such as decom-pilers <ref> [5, 21] </ref> and program slicers [24]. 1.1 Means of Software Protection Alice can protect her code from Bob's attack using either legal [23] or technical [9] protection.
Reference: [22] <author> G. Ramalingam. </author> <title> The undecidability of aliasing. </title> <journal> ACM TOPLAS, </journal> <volume> 16(5) </volume> <pages> 1467-1471, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Next, we will show how to construct opaque predicates based on this insight. 5.1 Opaque Constructs Using Objects and Aliases Inter-procedural static analysis is significantly complicated whenever there is a possibility of aliasing. In fact, precise, flow-sensitive alias analysis is undecidable in languages with dynamic allocation, loops, and if-statements <ref> [22] </ref>.
Reference: [23] <author> Pamela Samuelson. </author> <title> Reverse-engineering someone else's software: </title> <booktitle> Is it legal? IEEE Software, </booktitle> <pages> pages 90-96, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: com mon to distribute software in architecture-neutral formats, (such as Java bytecode [10] and ANDF [16]), and because of the emergence of reverse engineering tools such as decom-pilers [5, 21] and program slicers [24]. 1.1 Means of Software Protection Alice can protect her code from Bob's attack using either legal <ref> [23] </ref> or technical [9] protection. Economic realities often make it difficult for a small company like Alice's to enforce the law against a larger and more powerful competitor [17].
Reference: [24] <author> Frank Tip. </author> <title> A survey of program slicing techniques. </title> <journal> Journal of Programming Languages, </journal> <volume> 3(3) </volume> <pages> 121-189, </pages> <month> Sep-tember </month> <year> 1995. </year>
Reference-contexts: The reason is that it is becoming more com mon to distribute software in architecture-neutral formats, (such as Java bytecode [10] and ANDF [16]), and because of the emergence of reverse engineering tools such as decom-pilers [5, 21] and program slicers <ref> [24] </ref>. 1.1 Means of Software Protection Alice can protect her code from Bob's attack using either legal [23] or technical [9] protection. Economic realities often make it difficult for a small company like Alice's to enforce the law against a larger and more powerful competitor [17]. <p> We must be able to generate cheap and inconspicuous opaque predicates that resemble these patterns. Since we expect most deobfuscators to employ various static analysis techniques (such as data-flow analysis [1] and slicing <ref> [24] </ref>) it seems natural to base the construction of opaque predicates on problems which these techniques cannot handle well. In particular, precise static analysis of pointer-based structures and parallel regions is known to be intractable.
Reference: [25] <author> Robert Tolksdorf. </author> <title> Programming languages for the Java virtual machine, </title> <note> 1997. http://grunge.cs.tu-berlin. de/~tolk/vmlanguages.html. </note>
Reference-contexts: In fact, since our obfuscator targets Java class files it is already able to obfuscate programs written in a variety of languages. The reason, of course, is the existence of translators from many languages (including Ada and Scheme) into Java source or bytecode <ref> [25] </ref>. Acknowledgments: We would like to thank Todd Proebsting, Chris Fraser, Mark Burgess, and Buz Uzgalis for stimulating discussions.
Reference: [26] <author> Hans Peter Van Vliet. </author> <title> Crema | The Java ob-fuscator. </title> <address> http://web.inter.nl.net/users/H.P.van. Vliet/crema.html, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: The output of the tool is a new application which is functionally equivalent to the original one. 3 Obfuscating Transformations Existing obfuscation tools (such as Crema <ref> [26] </ref>) are based on the assumption that the original and obfuscated program must have identical behavior. In the present paper we assume that under certain circumstances it will be possible to relax this constraint. <p> Thus code optimization would normally be applied before obfuscations. 3.1 Classifying Transformations The main dividing line between different classes of obfuscation techniques is the kind of information it targets. Some simple transformations typical of current Java obfuscators such as Crema <ref> [26] </ref> target the lexical structure of the application, such as source code formatting, names of variables, etc.
Reference: [27] <author> Uwe G. Wilhelm. </author> <title> Cryptographically protected objects. </title> <booktitle> In RenPar'9, </booktitle> <month> May </month> <year> 1997. </year> <note> http://lsewww.epfl. ch/~wilhelm/CryPO.html. </note>
Reference-contexts: Bob will never gain physical access to the application and will be unable to reverse engineer it. Because of limits on network capacity the application will perform much worse than if it had run locally. Alternatively, Alice could protect her code through encryption <ref> [14, 27] </ref>. This only works if the entire decryption/execution process takes place in hardware. If the code is executed in software by a virtual machine interpreter (as is most often the case with Java bytecodes), then it will always be possible for Bob to intercept and decompile the decrypted code.
References-found: 27

