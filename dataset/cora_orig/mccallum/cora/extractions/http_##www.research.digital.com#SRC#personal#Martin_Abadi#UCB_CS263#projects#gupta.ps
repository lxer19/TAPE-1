URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/UCB_CS263/projects/gupta.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/UCB_CS263/projects.html
Root-URL: http://www.research.digital.com
Title: Proof Carrying Code: A Survey  
Author: Anupam Gupta 
Abstract: Proof Carrying Code (PCC) is a concept by which the users of a program can verify the safety of a program which is provided by an untrusted source. This is done by attaching a proof of safe behaviour of the program to the code, which can be verified by the user before execution. In this survey, we attempt to look into the issues involved in this mechanism. Further, we try to look at techniques to avoid sending the entire proof (which can be extremely large). These techniques reduce the communication cost at the expense of certainty of safety | i.e. the user can now only be sure of the safety with a high probability. 
Abstract-found: 1
Intro-found: 1
Reference: [BFL90] <author> Laszlo Babai, Lance Fortnow, and Carsten Lund. </author> <title> Non-deterministic exponential time has two-prover interactive protocols. </title> <booktitle> In 31st Annual Symposium on Foundations of Computer Science, </booktitle> <volume> volume I, </volume> <pages> pages 16-25, </pages> <address> St. Louis, Missouri, </address> <month> 22-24 October </month> <year> 1990. </year> <note> IEEE. </note>
Reference-contexts: A famous result by Babai, Fortnow and Lund <ref> [BFL90] </ref> shows that given y, if we can verify OE (x; y) holds in exponential time in the length of x (say, n), then we can write a PCP that can be verified by flipping poly (n) coins and reading only poly (n) bits of .
Reference: [FL97] <author> Joan Feigenbaum and Peter Lee. </author> <title> Trust management and proof-carrying code in secure mobile-code applications. In DARPA Workshop on Foundations for Secure Mobile Code, </title> <month> 26-28 March </month> <year> 1997. </year>
Reference: [HHP93] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> January </month> <year> 1993. </year> <month> 9 </month>
Reference-contexts: But that is not all: it should be able to check deductions for their validity and detect meaningless expressions statically. And all this should be done in a computationally efficient manner. The logical framework we shall look at is the Edinburgh Logical Framework (LF) <ref> [HHP93] </ref>. This is refinement of the simply-typed -calculus that uses the judgments-as-proofs idea. The valid terms in this language are in bijective correspondence with the syntactic entities (terms, formulae, proofs) of the deductive system, such that the judgments are identified with the type of the objects represented by their proofs.
Reference: [Joh92] <author> David S. Johnson. </author> <title> The NP-completeness column: An ongoing guide: The tale of the second prover. </title> <journal> Journal of Algorithms, </journal> <volume> 13(3) </volume> <pages> 502-524, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: To counter this, we propose using ideas from the field of Probabilistically Checkable Proofs (PCP) in complexity theory. A very readable survey of PCP can be found in <ref> [Joh92] </ref>. The idea that started all this was that of Interactive Proof Systems. These involve two individuals, the prover P and the verifier V . Consider the case that P claims that for some predicate and input x, there is a y such that (x; y) is true.
Reference: [Nec97] <author> George C. Necula. </author> <title> Proof-carrying code. </title> <booktitle> In Proceedings of the 24th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> Paris, France, </address> <month> 15-17 January </month> <year> 1997. </year> <note> ACM. </note>
Reference: [NL96a] <author> George C. Necula and Peter Lee. </author> <title> Proof-carrying code. </title> <type> Technical Report CMU-CS-96-165, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1996. </year>
Reference-contexts: These proofs are long but largely mechanical; they are obtained by standard methods like induction on the structure of derivations. We do not give the details here: they can be found in Necula and Lee <ref> [NL96a] </ref>. 4 Further Ideas One of the major problems encountered is the large bandwidth required to send the proof across the network. In general the proofs can be very large, and so this may be a major bottleneck in an efficient implementation of the idea of PCC.
Reference: [NL96b] <author> George C. Necula and Peter Lee. </author> <title> Safe kernel extensions without run-time checking. </title> <booktitle> In Proceedings of the Second Symposium on Operating Systems Design and Implementation, </booktitle> <address> Seattle, Washington, </address> <month> 28-31 Oc-tober </month> <year> 1996. </year>
Reference: [Pfe96] <author> Frank Pfenning. </author> <title> The practice of logical frameworks. </title> <editor> In Helene Kirchner, editor, </editor> <booktitle> Proceedings of the Colloquium on Trees in Algebra and Programming, </booktitle> <pages> pages 119-134, </pages> <address> Linkoping, Sweden, </address> <month> April </month> <year> 1996. </year> <note> Springer-Verlag LNCS 1059. Invited talk. 10 </note>
Reference-contexts: However, this problem has been well studied, and one of the ways to take care of this problem is through the delightful theory of logical frameworks <ref> [Pfe96] </ref>. These are meta-languages in which one can specify and reason about deductive systems, and are thus applicable to the study of of programming languages, especially of type systems and operational semantics. Logical frameworks are means of specifying deductive systems, like the ones used to prove programs correct in PCC.
References-found: 8

