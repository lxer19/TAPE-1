URL: ftp://ftp.cs.toronto.edu/pub/kbms/edbt96.ps.Z
Refering-URL: ftp://ftp.cs.toronto.edu/pub/kbms/readme.html
Root-URL: 
Email: E-mail: fdp,jmg@ai.toronto.edu  
Title: Accommodating Integrity Constraints During Database Design  
Author: Dimitris Plexousakis and John Mylopoulos 
Keyword: Integrity constraints in large knowledge bases, transaction specification, database design, temporal constraints and rules.  
Date: June 28, 1995  
Address: Toronto, M5S 1A4, Canada  
Affiliation: Department of Computer Science University of Toronto  
Abstract: We address the problem of maintaining the integrity of large knowledge bases using a compile-time transaction modification technique. The novelty of the approach lies in the adaptation of ideas from Artificial Intelligence (AI) planning research. Specifically, starting with the observation that solutions to the frame and ramification problems can be used during database transaction design time, we propose an integrity maintenance technique that modifies transaction specifications by incorporating into them conditions necessary of the constraints' satisfaction. Additions to the transactions' postconditions whose effect is to maintain the integrity constraints, are generated from a set of (determinate) transaction specifications. Thus, the implications of constraints are realized by the transaction specifier and the effort of having to prove transaction safety is saved, since it is guaranteed by the correctness of the generation process. We envision the development of a tool that, given a set of determinate transaction specifications, automatically suggests additions to the transaction postconditions whose effect is to maintain the integrity constraints. 
Abstract-found: 1
Intro-found: 1
Reference: [BDM88] <author> F. Bry, H. Decker, and R. Manthey. </author> <title> A Uniform Approach to Constraint Satisfaction and Constraint Satisfiability in Deductive Databases. </title> <booktitle> In Proceedings of the Int. Conference on Extedning Data Base Technology, </booktitle> <pages> pages 488-505, </pages> <year> 1988. </year>
Reference-contexts: The problem of integrity maintenance has received considerable attention in the literature of the past decade. Most proposed techniques for integrity maintenance rely on monitoring by a generic application-independent program that verifies that updates do not violate semantic constraints [Nic82],[LST86], <ref> [BDM88] </ref>, [JJ91], [Cho92], [Ple93a], [Ten95], [Ple95]. Another popular approach is based on maintenance by transactions [Sto75], [GM79], [Lip90], [CW90], [LTW93]. The former technique relieves the user from the burden of implementing database transactions in a way such that no constraint is violated.
Reference: [BMR93] <author> A. Borgida, J. Mylopoulos, and R. Reiter. </author> <title> And nothing else changes: The Frame Problem in Procedure Specifications. </title> <booktitle> In Proceedings of the 15th Int. Conference on Software Engineering, </booktitle> <year> 1993. </year>
Reference-contexts: The ramification problem amounts to devising a way to avoid having to specify indirect effects of actions explicitly. Several attempts to solve these problems have appeared in the AI planning literature of the recent years. [LR94] presents a solution to the frame problem with application to database updates. <ref> [BMR93] </ref> and [BMR95] show why the frame problem becomes particularly acute in object-oriented specifications where transactions are inherited and specialized from superclasses to subclasses. The arguments presented therein apply directly to the specification of database transactions in deductive, active and object-oriented databases. <p> We describe briefly the solution to the frame and ramification problems proposed in [LR92], as well as an extension to the procedure proposed in <ref> [BMR93] </ref> and [Pin94] for systematically solving the problem in the case of determinate transaction specifications. Section 3 presents the ramification method for transaction modification along with several examples of the application of the method on static and dynamic constraints.
Reference: [BMR95] <author> A. Borgida, J. Mylopoulos, and R. Reiter. </author> <title> The Frame Problem in Procedure Specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <note> 1995. To appear. </note>
Reference-contexts: Several attempts to solve these problems have appeared in the AI planning literature of the recent years. [LR94] presents a solution to the frame problem with application to database updates. [BMR93] and <ref> [BMR95] </ref> show why the frame problem becomes particularly acute in object-oriented specifications where transactions are inherited and specialized from superclasses to subclasses. The arguments presented therein apply directly to the specification of database transactions in deductive, active and object-oriented databases. <p> The above axiom can now be written as: 8x=S 8t=T ime T (x; t) ) pre T (x; t) ^ post T (x; next (t)). From the direct effect axioms we can systematically generate positive and negative effect axioms <ref> [BMR95] </ref> for every predicate P that occurs in post T , as described in the following steps. 4 The rationale is to describe concisely all conditions that are necessarily true when a predicate changes value from False to True (True to False respectively). 1.
Reference: [Cho92] <author> J. Chomicki. </author> <title> History-less Checking of Dynamic Integrity Constraints. </title> <booktitle> In 8th Int. Conference on Data Engineering, </booktitle> <pages> pages 557-564, </pages> <address> Phoenix,AZ, </address> <year> 1992. </year>
Reference-contexts: The problem of integrity maintenance has received considerable attention in the literature of the past decade. Most proposed techniques for integrity maintenance rely on monitoring by a generic application-independent program that verifies that updates do not violate semantic constraints [Nic82],[LST86], [BDM88], [JJ91], <ref> [Cho92] </ref>, [Ple93a], [Ten95], [Ple95]. Another popular approach is based on maintenance by transactions [Sto75], [GM79], [Lip90], [CW90], [LTW93]. The former technique relieves the user from the burden of implementing database transactions in a way such that no constraint is violated.
Reference: [CT94] <author> Jan Chomicki and David Toman. </author> <title> Implementing Integrity Constraints Using an Active DBMS. </title> <booktitle> In Proceedings, RIDE-94 Active Database Systems, </booktitle> <pages> pages 87-95, </pages> <year> 1994. </year>
Reference-contexts: Moreover, the problem of implicit updates is not addressed. In [CW90], integrity constraints are semi-automatically translated into set-oriented production rules activated at the commit point of transactions. The focus of this work is on automatic integrity repair rather than optimization of constraint checking. In <ref> [CT94] </ref>, active rules are used to implement temporal integrity constraints, but the problem of implicit updates is not addressed. The previous sections showed how the task of proving integrity maintenance can be assisted by the adaptation of a systematic solution to the frame and ramification problems.
Reference: [CW90] <author> S. Ceri and J. Widom. </author> <title> Deriving Production Rules for Constraint Maintenance. </title> <booktitle> In Proceedings of the 16th Int. Conference in Very Large Databases, </booktitle> <pages> pages 566-577, </pages> <year> 1990. </year>
Reference-contexts: Most proposed techniques for integrity maintenance rely on monitoring by a generic application-independent program that verifies that updates do not violate semantic constraints [Nic82],[LST86], [BDM88], [JJ91], [Cho92], [Ple93a], [Ten95], [Ple95]. Another popular approach is based on maintenance by transactions [Sto75], [GM79], [Lip90], <ref> [CW90] </ref>, [LTW93]. The former technique relieves the user from the burden of implementing database transactions in a way such that no constraint is violated. The latter requires that the specification of updating transactions is given. <p> It It becomes unclear what the specifications of the transaction mean with respect to the database state. Moreover, the problem of implicit updates is not addressed. In <ref> [CW90] </ref>, integrity constraints are semi-automatically translated into set-oriented production rules activated at the commit point of transactions. The focus of this work is on automatic integrity repair rather than optimization of constraint checking.
Reference: [Fin88] <author> J. </author> <title> Finger. Exploiting Constraints in Design Synthesis. </title> <type> Technical Report STAN-CS-88-1204, </type> <institution> Stanford University, </institution> <year> 1988. </year>
Reference-contexts: We choose first-order (temporal) logic as the language for expressing transaction pre/post-conditions, constraints and rules. We address the problem of proving integrity maintenance by relating it to that of reasoning about actions [GS87] and elaborate on the impact that the frame problem [McC69] and ramification problem <ref> [Fin88] </ref> have in transaction specifications. <p> In the first part we review the concept and properties of ramifications and, in the second, we describe the solution to the ramification problem for the class of deterministic transaction specifications. The bulk of the background material is based on <ref> [Fin88] </ref> and [Pin94] but is recast here in database terminology. <p> We will refer to this logic as MSTL for short. Time is interpreted as being relative, linear and discrete. Intuitively, a ramification of a formula is a formula N such that, N is inevitably true if is true <ref> [Fin88] </ref>. This definition is amenable to different interpretations in different world models. If the world model in question the knowledge base is expressed as a first-order theory, then the concept 5 of ramifications can be captured by first-order entailment. <p> From the semi-decidability of first-order entailment, it follows that the problem of finding ramifications is, in its generality, intractable. Tractability can be achieved by restricting the class of formulae for which ramifications are sought. For instance, the task is tractable for ordered conjunctions of literals <ref> [Fin88] </ref>. Furthermore, not all derivable ramifications may be useful for simplifying the task of proving a formula. For that, the generator may be guided to derive only "useful" ramifications by providing appropriate input clauses. <p> The process of modifying a goal by conjoining it with additional constraints so that the reformulated formula is less expensive to check than the original one, has been termed supersumption in <ref> [Fin88] </ref>. The methods proposed therein apply only to conjunctive formulae. It is easy to establish the soundness of supersumption for formulae in disjunctive normal form (DNF). Proposition 2.1 is a direct consequence of the definition of ramifications and proposition 2.2 follows from the properties of first-order entailment.
Reference: [Flo74] <author> J. Florentin. </author> <title> Consistency Auditing of Data Bases. </title> <journal> Computer Journal, </journal> <volume> 17(1) </volume> <pages> 52-58, </pages> <year> 1974. </year>
Reference-contexts: 1 Introduction Integrity constraints specify the valid states of a data or knowledge base as well as its allowable state transitions <ref> [Flo74] </ref>. Structural integrity constraints express properties of the data model used for representing knowledge. Semantic integrity constraints on the other hand, are user-defined and express properties of the domain being modeled. The maintenance of semantic integrity constitutes a major performance bottleneck in database management systems.
Reference: [GM79] <author> G. Gardarin and M. Melkanoff. </author> <title> Proving Consistency of Database Transactions. </title> <booktitle> In Proceedings VLDB '79, </booktitle> <pages> pages 291-298, </pages> <year> 1979. </year>
Reference-contexts: Most proposed techniques for integrity maintenance rely on monitoring by a generic application-independent program that verifies that updates do not violate semantic constraints [Nic82],[LST86], [BDM88], [JJ91], [Cho92], [Ple93a], [Ten95], [Ple95]. Another popular approach is based on maintenance by transactions [Sto75], <ref> [GM79] </ref>, [Lip90], [CW90], [LTW93]. The former technique relieves the user from the burden of implementing database transactions in a way such that no constraint is violated. The latter requires that the specification of updating transactions is given.
Reference: [GS87] <author> M. Ginsberg and D. Smith. </author> <title> Reasoning about Action I: A Possible Worlds Approach. </title> <editor> In Matthew Ginsberg, editor, </editor> <booktitle> Readings in Non-Monotonic Reasoning, </booktitle> <pages> pages 433-463. </pages> <publisher> Morgan Kauffmann, </publisher> <year> 1987. </year>
Reference-contexts: The formal specification language should be accompanied by the appropriate machinery for proving properties of specifications. We choose first-order (temporal) logic as the language for expressing transaction pre/post-conditions, constraints and rules. We address the problem of proving integrity maintenance by relating it to that of reasoning about actions <ref> [GS87] </ref> and elaborate on the impact that the frame problem [McC69] and ramification problem [Fin88] have in transaction specifications.
Reference: [JJ91] <author> M. Jeusfeld and M. Jarke. </author> <title> From Relational to Object-Oriented Integrity Simplification. </title> <booktitle> In 2nd Int. Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 460-477, </pages> <year> 1991. </year>
Reference-contexts: The problem of integrity maintenance has received considerable attention in the literature of the past decade. Most proposed techniques for integrity maintenance rely on monitoring by a generic application-independent program that verifies that updates do not violate semantic constraints [Nic82],[LST86], [BDM88], <ref> [JJ91] </ref>, [Cho92], [Ple93a], [Ten95], [Ple95]. Another popular approach is based on maintenance by transactions [Sto75], [GM79], [Lip90], [CW90], [LTW93]. The former technique relieves the user from the burden of implementing database transactions in a way such that no constraint is violated.
Reference: [Lif91] <author> V. Lifschitz. </author> <title> Towards a Metatheory of Action. </title> <booktitle> In Proceedings of the 2nd International Conference on Knowledge Representation and Reasoning, </booktitle> <pages> pages 376-386, </pages> <year> 1991. </year>
Reference-contexts: Within AI however, the problems have long been recognized as common sense reasoning problems and several attempts towards their solution have appeared (e.g., <ref> [Lif91] </ref>, [Sch90]). The solution presented by Reiter [Rei91], combined and extended previous results, leading to the systematic solution on which this paper is based. In [Sto75], integrity constraints expressed as QUEL queries on relational databases are added as qualifications to transactions. The execution of the resulting transaction guarantees integrity preservation.
Reference: [Lip90] <author> U. Lipeck. </author> <title> Transformation of Dynamic Integrity Constraints into Transaction Specifications. </title> <journal> Theoretical Computer Science, </journal> <volume> 76 </volume> <pages> 115-142, </pages> <year> 1990. </year>
Reference-contexts: Most proposed techniques for integrity maintenance rely on monitoring by a generic application-independent program that verifies that updates do not violate semantic constraints [Nic82],[LST86], [BDM88], [JJ91], [Cho92], [Ple93a], [Ten95], [Ple95]. Another popular approach is based on maintenance by transactions [Sto75], [GM79], <ref> [Lip90] </ref>, [CW90], [LTW93]. The former technique relieves the user from the burden of implementing database transactions in a way such that no constraint is violated. The latter requires that the specification of updating transactions is given. <p> Several modes of feedback to the transaction designer are suggested but are not put into a formal framework. Dynamic integrity constraints specified in temporal logic are translated into transaction specifi 20 cations in <ref> [Lip90] </ref>. Constraints are translated into transition graphs and transformation steps that simulate the evaluation of the constraints on the graphs are applied. Transactions are specified in terms of pre/post-condition pairs and explicit frame assumptions. The transaction specifier has to supply all frame conditions explicitly.
Reference: [LR92] <author> F. Lin and R. Reiter. </author> <title> State Constraints Revisited. </title> <booktitle> In Proceedings of the 2nd Symposium on Logical Formalizations of Commonsense Reasoning, </booktitle> <pages> pages 114-121, </pages> <year> 1992. </year>
Reference-contexts: A non-optimizing transaction modification technique, such as, e.g., in [Sto75], would include as a condition that would need to be conjoined with the transaction postcondition. 2 We review the concept of ramifications in section 2. We describe briefly the solution to the frame and ramification problems proposed in <ref> [LR92] </ref>, as well as an extension to the procedure proposed in [BMR93] and [Pin94] for systematically solving the problem in the case of determinate transaction specifications. Section 3 presents the ramification method for transaction modification along with several examples of the application of the method on static and dynamic constraints.
Reference: [LR94] <author> F. Lin and R. Reiter. </author> <title> State Constraints Revisited. </title> <journal> Journal of Logic and Computation Special Issue on Actions and Processes, </journal> <year> 1994. </year>
Reference-contexts: The ramification problem amounts to devising a way to avoid having to specify indirect effects of actions explicitly. Several attempts to solve these problems have appeared in the AI planning literature of the recent years. <ref> [LR94] </ref> presents a solution to the frame problem with application to database updates. [BMR93] and [BMR95] show why the frame problem becomes particularly acute in object-oriented specifications where transactions are inherited and specialized from superclasses to subclasses. <p> Embodying the implications of constraints in transaction specifications means that the constraints need not be checked at run-time. The solution proposed in <ref> [LR94] </ref> consists of systematically deriving a set of successor-state 3 axioms that completely describe how fluents 1 can change truth value as a result of some action taking place. These axioms formulate closed-world assumptions for actions. <p> The solution to the frame problem was initially proposed in [Rei91] in the framework of situation calculus [McC69]. It was extended in <ref> [LR94] </ref> and [Pin94] for dealing with the ramification problem as well. The solution relies on the automatic generation of complete characterizations of the conditions under which predicates 7 or functions may change (truth) value as a result of transaction execution. <p> The second axiom says that, if function size changes value because of transaction execution, then it is the case that either transaction EnrollInCourse occurred or transaction DropCourse occurred. 2 It has been shown in <ref> [LR94] </ref> that a set, T ss , of successor-state axioms constitutes a solution to the frame and ramification problem if, for every predicate p, the condition T una j= :( p ^ :p ) is satisfied. Moreover, the correctness of the syntactic generation has been proven in [LR94] and [Pin94]. <p> been shown in <ref> [LR94] </ref> that a set, T ss , of successor-state axioms constitutes a solution to the frame and ramification problem if, for every predicate p, the condition T una j= :( p ^ :p ) is satisfied. Moreover, the correctness of the syntactic generation has been proven in [LR94] and [Pin94]. We are now in a position to state the relationship of the syntactic generation of successor-state axioms with ramifications of constraints. A similar result holds for the case in which predicates occur negated in the expression of a constraint. The proposition follows from the syntactic generation process. <p> The complexity of the process of generating these axioms is polynomial in the number of predicates and functions in the constraints <ref> [LR94] </ref>. We extended the method to apply to a class of constraints which includes static and transition constraints. We showed that the introduction of new transaction specifications or new constraints can be accommodated incrementally.
Reference: [LST86] <author> J. Lloyd, E. Sonenberg, and R. Topor. </author> <title> Integrity Constraint Checking in Stratified Databases. </title> <type> Technical Report 86/5, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <year> 1986. </year> <month> 23 </month>
Reference: [LTW93] <author> M. Lawley, R. Topor, and M. Wallace. </author> <title> Using Weakest Preconditions to Simplify Integrity Constraint Checking. </title> <booktitle> In Proceedings of the Australian Database Conference, </booktitle> <pages> pages 161-170, </pages> <year> 1993. </year>
Reference-contexts: Most proposed techniques for integrity maintenance rely on monitoring by a generic application-independent program that verifies that updates do not violate semantic constraints [Nic82],[LST86], [BDM88], [JJ91], [Cho92], [Ple93a], [Ten95], [Ple95]. Another popular approach is based on maintenance by transactions [Sto75], [GM79], [Lip90], [CW90], <ref> [LTW93] </ref>. The former technique relieves the user from the burden of implementing database transactions in a way such that no constraint is violated. The latter requires that the specification of updating transactions is given. <p> The execution of the resulting transaction guarantees integrity preservation. However, no simplification of constraints takes place and the knowledge of their satisfaction prior to the update is not exploited. A set-oriented language for transaction specification is used in <ref> [LTW93] </ref>. For each update and each constraint, a weakest precondition (wp) is derived so that, if wp is true in the state prior to the update, then the constraint is guaranteed to be true in the state resulting from the update.
Reference: [MBJK90] <author> J. Mylopoulos, A. Borgida, M. Jarke, and M. Koubarakis. </author> <title> Telos: A Language for Representing Knowledge in Information Systems. </title> <journal> ACM Transactions On Information Systems, </journal> <volume> 8(4) </volume> <pages> 325-362, </pages> <year> 1990. </year>
Reference: [McC69] <author> J. McCarthy. </author> <title> Some Philosophical Problems from the Standpoint of Artificial Intelligence. </title> <editor> In B. Meltzer and D. Mitchie, editors, </editor> <booktitle> Machine Intelligence 4, </booktitle> <pages> pages 463-502. </pages> <publisher> Edinburg University Press, </publisher> <year> 1969. </year>
Reference-contexts: We choose first-order (temporal) logic as the language for expressing transaction pre/post-conditions, constraints and rules. We address the problem of proving integrity maintenance by relating it to that of reasoning about actions [GS87] and elaborate on the impact that the frame problem <ref> [McC69] </ref> and ramification problem [Fin88] have in transaction specifications. <p> Then, under the assumption that the invariant was satisfied before the transaction execution, the conjunct can be eliminated since its satisfaction 1 Fluents are predicates whose truth value may change from state to state <ref> [McC69] </ref>. 2 We will abandon this notation when we present the formal solution to the frame and ramification problem. Instead, we will use a many-sorted logic and factor time into predicates and functions. 4 persists. <p> The solution to the frame problem was initially proposed in [Rei91] in the framework of situation calculus <ref> [McC69] </ref>. It was extended in [LR94] and [Pin94] for dealing with the ramification problem as well. The solution relies on the automatic generation of complete characterizations of the conditions under which predicates 7 or functions may change (truth) value as a result of transaction execution.
Reference: [MCP + 95] <author> J. Mylopoulos, V. Chaudhri, D. Plexousakis, A. Shrufi, and T. Topaloglou. </author> <title> Building Knowledge Base Management Systems. </title> <journal> The VLDB Journal, </journal> <note> 1995. To appear. </note>
Reference-contexts: We showed that the introduction of new transaction specifications or new constraints can be accommodated incrementally. This technique can lead to the development of a tool which, as part of a knowledge base management system <ref> [MCP + 95] </ref>, will suggest additions to transaction postconditions, whose effect will be to maintain the invariants. This tool aims at assisting the database design process by providing feedback to the designer of transactions and by automating the task of verifying the safety of transactions.
Reference: [MP91] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems. </title> <publisher> Springer Verlag, </publisher> <year> 1991. </year> <note> Vol. 1: Specification. </note>
Reference-contexts: Its addition to the postcondition suffices to ensure the maintenance of the invariant. 2 For the sake of demonstrating the applicability of using ramifications with constraints strictly more general than the ones dealt with so far, we now switch to using first-order temporal logic (FOTL) <ref> [MP91] </ref> as the specification language. 7 FOTL allows one to express constraints referring to an arbitrary number of states. We need to assume, without loss of generality, that exactly one action can occur between two successive states of the knowledge base.
Reference: [Nic82] <author> J.-M. Nicolas. </author> <title> Logic for Improving Integrity Checking in Relational Databases. </title> <journal> Acta Informatica, </journal> <volume> 18 </volume> <pages> 227-253, </pages> <year> 1982. </year>
Reference: [Pin94] <author> J. Pinto. </author> <title> Temporal Reasoning in the Situation Calculus. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1994. </year>
Reference-contexts: These axioms formulate closed-world assumptions for actions. A syntactic generator of successor-state axioms in the presence of binary constraints and stratified definitions of non-primitive fluents is proposed in <ref> [Pin94] </ref>. We relate this solution to the problem of integrity maintenance in the context of temporal deductive KBs. The following example shows the rationale behind the use of ramifications for simplifying the task of proving transaction safety. <p> We describe briefly the solution to the frame and ramification problems proposed in [LR92], as well as an extension to the procedure proposed in [BMR93] and <ref> [Pin94] </ref> for systematically solving the problem in the case of determinate transaction specifications. Section 3 presents the ramification method for transaction modification along with several examples of the application of the method on static and dynamic constraints. <p> In the first part we review the concept and properties of ramifications and, in the second, we describe the solution to the ramification problem for the class of deterministic transaction specifications. The bulk of the background material is based on [Fin88] and <ref> [Pin94] </ref> but is recast here in database terminology. <p> The solution to the frame problem was initially proposed in [Rei91] in the framework of situation calculus [McC69]. It was extended in [LR94] and <ref> [Pin94] </ref> for dealing with the ramification problem as well. The solution relies on the automatic generation of complete characterizations of the conditions under which predicates 7 or functions may change (truth) value as a result of transaction execution. Here we present an extension to the method of [Pin94] for dealing with <p> in [LR94] and <ref> [Pin94] </ref> for dealing with the ramification problem as well. The solution relies on the automatic generation of complete characterizations of the conditions under which predicates 7 or functions may change (truth) value as a result of transaction execution. Here we present an extension to the method of [Pin94] for dealing with transition constraints. The method generates successor-state axioms from a given set of effect axioms, in the presence of a limited class of constraints and definitions of non-primitive predicates. Effect axioms specify the direct effects of transactions on predicates. <p> This class of constraints is an extension of the class of binary constraints of <ref> [Pin94] </ref>, since it allows the temporal variables to occur in evaluable predicates. It includes static constraints and transition constraints, i.e., constraints referring to two consecutive states of the knowledge base, but not general dynamic constraints. <p> Moreover, the correctness of the syntactic generation has been proven in [LR94] and <ref> [Pin94] </ref>. We are now in a position to state the relationship of the syntactic generation of successor-state axioms with ramifications of constraints. A similar result holds for the case in which predicates occur negated in the expression of a constraint. The proposition follows from the syntactic generation process.
Reference: [Ple93a] <author> D. Plexousakis. </author> <title> Integrity Constraint and Rule Maintenance in Temporal Deductive Knowledge Bases. </title> <booktitle> In Proceedings of the 19th Int. Conference on Very Large Data Bases, </booktitle> <pages> pages 146-157, </pages> <address> Dublin, IR, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: The problem of integrity maintenance has received considerable attention in the literature of the past decade. Most proposed techniques for integrity maintenance rely on monitoring by a generic application-independent program that verifies that updates do not violate semantic constraints [Nic82],[LST86], [BDM88], [JJ91], [Cho92], <ref> [Ple93a] </ref>, [Ten95], [Ple95]. Another popular approach is based on maintenance by transactions [Sto75], [GM79], [Lip90], [CW90], [LTW93]. The former technique relieves the user from the burden of implementing database transactions in a way such that no constraint is violated. The latter requires that the specification of updating transactions is given. <p> The latter requires that the specification of updating transactions is given. Transactions are then modified so that database integrity constraints are guaranteed to hold in any executable sequence of transactions. In our earlier work <ref> [Ple93a] </ref>, we presented a compile-time simplification method for temporal deductive knowledge bases, where integrity constraints, specified in a many-sorted temporal assertion language [MBJK90],[Ple93b], are specialized and simplified with respect to the anticipated updates. <p> In this case all transaction specifications have to be taken into account since a constraint may be relevant to, or affected by, more than one transactions. The notion of relevance is formally defined here. It is based on the notion of dependence, taken from <ref> [Ple93a] </ref>. For that we will assume that the specifications are given in first-order temporal logic. Moreover, we will assume that no interleaving of transactions is allowed. A transaction is regarded as the only means of knowledge base state change. <p> The dependence graph is a directed graph representing how implicitly derived facts from deductive rules can affect the integrity of the knowledge base. The graph can be constructed at transaction specification time and, as shown in <ref> [Ple93a] </ref>, is incrementally modifiable to accommodate changes in the sets of rules or constraints.
Reference: [Ple93b] <author> D. Plexousakis. </author> <title> Semantical and Ontological Considerations in Telos: a Lanugage for Knowledge Representation. </title> <journal> Computational Intelligence, </journal> <volume> 9(1) </volume> <pages> 41-72, </pages> <year> 1993. </year>
Reference: [Ple95] <author> D. Plexousakis. </author> <title> Compilation and Simplification of Temporal Integrity Constraints. </title> <booktitle> In Proceedings of the 2nd Int. Workshop on Rules in Database Systems, </booktitle> <address> Athens, GR, </address> <month> September </month> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: The problem of integrity maintenance has received considerable attention in the literature of the past decade. Most proposed techniques for integrity maintenance rely on monitoring by a generic application-independent program that verifies that updates do not violate semantic constraints [Nic82],[LST86], [BDM88], [JJ91], [Cho92], [Ple93a], [Ten95], <ref> [Ple95] </ref>. Another popular approach is based on maintenance by transactions [Sto75], [GM79], [Lip90], [CW90], [LTW93]. The former technique relieves the user from the burden of implementing database transactions in a way such that no constraint is violated. The latter requires that the specification of updating transactions is given.
Reference: [Rei91] <author> R. Reiter. </author> <title> The Frame Problem in the Situation Calculus: A Simple Solution (Sometimes) and a Completeness Model for Goal Regression. </title> <editor> In V. Lifschitz, editor, </editor> <booktitle> Artificial Intelligence and the Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <pages> pages 359-380. </pages> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: Then KB [ fg j= ^ ^ N . 2.2 The Frame and Ramification Problems In this section we sketch the solution to the frame and ramification problems for a class of constraints that encompasses static and transition constraints. The solution to the frame problem was initially proposed in <ref> [Rei91] </ref> in the framework of situation calculus [McC69]. It was extended in [LR94] and [Pin94] for dealing with the ramification problem as well. <p> Within AI however, the problems have long been recognized as common sense reasoning problems and several attempts towards their solution have appeared (e.g., [Lif91], [Sch90]). The solution presented by Reiter <ref> [Rei91] </ref>, combined and extended previous results, leading to the systematic solution on which this paper is based. In [Sto75], integrity constraints expressed as QUEL queries on relational databases are added as qualifications to transactions. The execution of the resulting transaction guarantees integrity preservation.
Reference: [Sch90] <author> L. Schubert. </author> <title> Monotonic Solution to the Frame Problem in the Situation Calculus: An Efficient Method for Worlds with Fully Specified Actions. </title> <editor> In H. Kyberg, R. Loui, and G. Carlson, editors, </editor> <booktitle> Knowledge Representation and Defeasible Reasoning, </booktitle> <pages> pages 23-67. </pages> <year> 1990. </year>
Reference-contexts: Within AI however, the problems have long been recognized as common sense reasoning problems and several attempts towards their solution have appeared (e.g., [Lif91], <ref> [Sch90] </ref>). The solution presented by Reiter [Rei91], combined and extended previous results, leading to the systematic solution on which this paper is based. In [Sto75], integrity constraints expressed as QUEL queries on relational databases are added as qualifications to transactions. The execution of the resulting transaction guarantees integrity preservation.
Reference: [SMS87] <author> D. Stemple, S. Mazumdar, and T. Sheard. </author> <title> On the Modes and Meaning of Feedback to Transaction Designers. </title> <booktitle> In Proceedings of ACM-SIGMOD Int. Conference on the Management of Data, </booktitle> <pages> pages 374-386, </pages> <address> San Francisco, CA, </address> <year> 1987. </year>
Reference-contexts: Although not discussed, the frame problem is implicitly dealt with by restricting attention to the predicates changed by transactions and by eliminating inertial terms from the theorems that have to be proven in order to verify integrity. The concept of constraint protectors discussed in <ref> [SMS87] </ref> resembles that of constraint ramifications. Their generation however assumes the existence of a fairly general theory of lemmas that is independent of the transactions. Several modes of feedback to the transaction designer are suggested but are not put into a formal framework.
Reference: [SP87] <author> S. Schuman and D. Pitt. </author> <title> Object-Oriented Subsystem Specification. </title> <editor> In L. Meertens, editor, </editor> <booktitle> Program Specification and Transformation, </booktitle> <pages> pages 313-341. </pages> <publisher> Elsevier Science, </publisher> <year> 1987. </year>
Reference-contexts: The new ramification can be conjoined with the previously derived ones, so that the new postcondition guarantees the invariants. 4.3 Inheritance of Transaction Specifications In object-oriented specification languages, inheritance of transaction (method) specifications is traditionally accomplished by conjoining the superclass' method specification to that of its subclasses <ref> [SP87] </ref>. We examine whether ramifications derived for the superclass can be inherited by the subclasses.
Reference: [SS89] <author> Tim Sheard and David Stemple. </author> <title> Automatic Verification of Database Transaction Safety. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(3) </volume> <pages> 322-368, </pages> <year> 1989. </year>
Reference-contexts: Finally, although the authors claim that it is trivial to incorporate implicit updates, the machinery provided does not account for them. constraints In <ref> [SS89] </ref>, a general-purpose theorem prover employing heuristic rewrite rules is used for proving safety of transactions with respect to a set of static constraints. Implicit updates and dynamic constraints are not considered.
Reference: [Sto75] <author> M. Stonebraker. </author> <title> Implementation of Integrity Constraints and Views by Query Modification. </title> <booktitle> In Proceedings of ACM-SIGMOD Int. Conference on the Management of Data, </booktitle> <pages> pages 65-78, </pages> <year> 1975. </year>
Reference-contexts: Most proposed techniques for integrity maintenance rely on monitoring by a generic application-independent program that verifies that updates do not violate semantic constraints [Nic82],[LST86], [BDM88], [JJ91], [Cho92], [Ple93a], [Ten95], [Ple95]. Another popular approach is based on maintenance by transactions <ref> [Sto75] </ref>, [GM79], [Lip90], [CW90], [LTW93]. The former technique relieves the user from the burden of implementing database transactions in a way such that no constraint is violated. The latter requires that the specification of updating transactions is given. <p> As will be shown in the sequel, the derived addition to the postcondition is a ramification of (a form of) the invariant and the initial postcondition. This is different than simply conjoining constraints to the transaction postconditions <ref> [Sto75] </ref>. Let us assume for a moment that the invariant had the form 8c=Course size (c) classlimit (c) ^ , where does not mention predicate EnrolledIn or function size. <p> Instead, we will use a many-sorted logic and factor time into predicates and functions. 4 persists. The augmentation to the postcondition that suffices to guarantee the constraint is the same as above, i.e., (size (crs) + 1 classlimit (crs)). A non-optimizing transaction modification technique, such as, e.g., in <ref> [Sto75] </ref>, would include as a condition that would need to be conjoined with the transaction postcondition. 2 We review the concept of ramifications in section 2. <p> Within AI however, the problems have long been recognized as common sense reasoning problems and several attempts towards their solution have appeared (e.g., [Lif91], [Sch90]). The solution presented by Reiter [Rei91], combined and extended previous results, leading to the systematic solution on which this paper is based. In <ref> [Sto75] </ref>, integrity constraints expressed as QUEL queries on relational databases are added as qualifications to transactions. The execution of the resulting transaction guarantees integrity preservation. However, no simplification of constraints takes place and the knowledge of their satisfaction prior to the update is not exploited.
Reference: [Ten95] <author> Teniente, Ernest and Olive, Antoni. </author> <title> Updating Knowledge Bases While Maintaining Their Consistency. </title> <journal> The VLDB Journal, </journal> <volume> 4(2) </volume> <pages> 193-241, </pages> <year> 1995. </year> <month> 25 </month>
Reference-contexts: The problem of integrity maintenance has received considerable attention in the literature of the past decade. Most proposed techniques for integrity maintenance rely on monitoring by a generic application-independent program that verifies that updates do not violate semantic constraints [Nic82],[LST86], [BDM88], [JJ91], [Cho92], [Ple93a], <ref> [Ten95] </ref>, [Ple95]. Another popular approach is based on maintenance by transactions [Sto75], [GM79], [Lip90], [CW90], [LTW93]. The former technique relieves the user from the burden of implementing database transactions in a way such that no constraint is violated. The latter requires that the specification of updating transactions is given.
References-found: 33

