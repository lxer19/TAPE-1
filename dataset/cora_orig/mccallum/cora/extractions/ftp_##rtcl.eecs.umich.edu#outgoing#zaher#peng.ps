URL: ftp://rtcl.eecs.umich.edu/outgoing/zaher/peng.ps
Refering-URL: http://www.eecs.umich.edu/~zaher/publications.html
Root-URL: http://www.cs.umich.edu
Title: Assignment and Scheduling Communicating Periodic Tasks in Distributed Real-Time Systems  
Author: Dar-Tzen Peng, Kang G. Shin, and Tarek F. Abdelzaher 
Keyword: Key Words Branch-and-bound (B&B) algorithm, computation and communication modules, inter-task communication, precedence and timing constraints, task invocation and release times, lower-bound cost.  
Note: Computational experiences and examples are provided to demonstrate the concept, utility, and power of the proposed approach.  
Address: Ann Arbor, Michigan 48109-2122  
Affiliation: Real-Time Computing Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: We present an optimal solution to the problem of allocating communicating periodic tasks to heterogeneous processing nodes (PNs) in a distributed real-time system. The solution is optimal in the sense of minimizing the maximum normalized task response time, called the system hazard , subject to the precedence constraints resulting from intercommunication among the tasks to be allocated. Minimization of the system hazard ensures that the solution algorithm will allocate tasks so as to meet all task deadlines under an optimal schedule, whenever such an allocation exists. The task system is modeled with a task graph (TG), in which computation and communication modules, communication delays, and intertask precedence constraints are clearly described. Tasks described by this TG are assigned to PNs by using a branch-and-bound (B&B) search algorithm. The algorithm traverses a search tree whose leaves correspond to potential solutions to the task allocation problem. We use a bounding method that prunes, in polynomial time, non-leaf vertices that cannot lead to an optimal solution, while ensuring that the search path leading to an optimal solution will never be pruned. For each generated leaf vertex we compute the exact cost using the algorithm developed in [1]. The lowest-cost leaf vertex (one with the least system hazard) represents an optimal task allocation. The work reported in this paper was supported in part by the Office of Naval Research under Grant No. N00014-94-1-0229 and the National Science Foundation under grant No. MIP-9203895. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the authors and do not necessarily reflect the view of the funding agencies. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Peng and K. G. Shin, </author> <title> "Optimal scheduling of cooperative tasks in a distributed system using an enumerative method," </title> <journal> IEEE Trans Soft. Eng., </journal> <volume> vol. 19, no. 3, </volume> <pages> pp. 253-267, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: The ratio of a task's response time to its relative deadline is called normalized task response time <ref> [1] </ref>. This ratio should not exceed 1 for the task 1 to meet its deadline. Also, in order for all tasks to meet their deadlines, the maximum normalized task response time must not exceed 1. <p> The difference between the two solutions would be that in system hazard minimization, task laxity is more likely to be distributed in proportion to task timing constraints. In <ref> [1, 54] </ref> it is argued that this results in a more "robust" schedule. The argument, however, is a rather subjective. Generally, the choice between the two objective functions may depend on the application at hand. <p> That is, we need a method to compute the system hazard for leaf vertices (i.e., those representing complete allocations). Computing the system hazard for a given task assignment requires an optimal schedule to be generated for that assignment. For this purpose, we use the optimal scheduling algorithm described in <ref> [1] </ref>. * Compute a good lower bound fi lb of the system hazard for a vertex. We call it the cost of the vertex. Note that at leaf vertices the (exact) lower bound is equal to the actual value of the performance measure computed using the algorithm in [1]. <p> described in <ref> [1] </ref>. * Compute a good lower bound fi lb of the system hazard for a vertex. We call it the cost of the vertex. Note that at leaf vertices the (exact) lower bound is equal to the actual value of the performance measure computed using the algorithm in [1]. The remaining problem is to compute the cost of non-leaf vertices. In the rest of this paper, we denote the cost of vertex x by fi (x), where at leaf vertices fi (x) is the exact system hazard computed using the algorithm in [1], while at a non-leaf vertex it <p> measure computed using the algorithm in <ref> [1] </ref>. The remaining problem is to compute the cost of non-leaf vertices. In the rest of this paper, we denote the cost of vertex x by fi (x), where at leaf vertices fi (x) is the exact system hazard computed using the algorithm in [1], while at a non-leaf vertex it is the lower bound 9 fi lb (x) computed for the vertex. An optimal solution is a leaf vertex with minimum cost. <p> We describe a method for computing the lower bound at non-leaf vertices in polynomial time. As mentioned in Section 4.1 at leaf vertices the vertex cost is equal to the system hazard computed as described in <ref> [1] </ref>. The lower bound, fi lb (x), of the system hazard for some non-leaf vertex x is computed in three steps: Step 1: Compute the minimum computational load imposed on each processor by tasks already as signed to PNs at search vertex x. <p> Note that the periodicity assumption has been used only to derive the length of the planning cycle and the release times of task invocations. The rest of the paper (as well as the scheduling algorithms <ref> [1, 55] </ref>) does not rely on this assumption. Furthermore, our model can be easily extended to the case where modules, rather than tasks, are the objects to be allocated. The lower-bound costs presented in this paper are shown to reduce the computational difficulty significantly.
Reference: [2] <author> J. K. Strosnider, J. P. Lehoczky, and L. Sha, </author> <title> "The deferrable server algorithm for enhanced aperiodic responsiveness in hard real-time environments," </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. 44, no. 1, </volume> <pages> pp. 73-91, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: 1 Introduction The workload in a real-time system consists of periodic and aperiodic tasks. Periodic tasks are the "base load" invoked at fixed time intervals while aperiodic tasks are the "transient load" generated in response to environmental stimuli. Periodic servers, like the deferrable server <ref> [2] </ref>, are typically used to handle aperiodic task execution requests. The total execution time of aperiodic tasks is "charged" to the periodically-replenished execution budget of the server, essentially converting the "lumped aperiodics" to periodic equivalents.
Reference: [3] <author> K. G. Shin and Y.-C. Chang, </author> <title> "Load sharing in distributed real-time systems with state-change broadcasts," </title> <journal> IEEE Trans. on Comput., </journal> <volume> vol. C-38, no. 8, </volume> <pages> pp. 1124-1142, </pages> <month> August </month> <year> 1989. </year>
Reference: [4] <author> K. Goswami, M. Devarakonda, and R. Lyer, </author> <title> "Prediction-based dynamic load-sharing heuristics," </title> <journal> IEEE Trans. on Parallel and Distrib. Sys., </journal> <volume> vol. 4, no. 6, </volume> <pages> pp. 638-648, </pages> <month> June </month> <year> 1993. </year>
Reference: [5] <author> K. G. Shin and C.-J. Hou, </author> <title> "Analytic models of adaptive load sharing schemes in distributed real-time systems," </title> <journal> IEEE Trans. Paralled and Distributed Systems, </journal> <volume> vol. 4, no. 7, </volume> <pages> pp. 740-761, </pages> <month> July </month> <year> 1993. </year>
Reference: [6] <author> K. R. Baker, </author> <title> Introduction to Sequencing and Scheduling, </title> <publisher> Wiley & Sons, </publisher> <year> 1974. </year>
Reference: [7] <author> W. W. Chu, </author> <title> "Task allocation in distributed data processing," </title> <journal> IEEE Computer, </journal> <volume> vol. 13, </volume> <pages> pp. 57-69, </pages> <month> Nov </month> <year> 1980. </year>
Reference: [8] <author> W. W. Chu and L. M. </author> <title> Lan, "Task allocation and precedence relations for distributed real-time systems," </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. C-36, no. 6, </volume> <pages> pp. 667-679, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Chu and Lan <ref> [8] </ref> chose to minimize the maximum processor workload for the assignment of tasks in a distributed real-time system. Workload was defined as the sum of IPC and accumulated execution time on each processor. A wait-time-ratio between two assignments was defined in terms of task queueing delays.
Reference: [9] <author> S. </author> <title> French, Sequencing and Scheduling, </title> <publisher> Halsted Press, </publisher> <year> 1982. </year>
Reference: [10] <author> R. E. D. Woolsey and H. S. Swanson, </author> <title> Operations Research for Immediate Applications: A Quick and Dirty Manual, </title> <publisher> Harper and Row, </publisher> <year> 1974. </year>
Reference: [11] <author> S. Selvakumar and C. S. R. Murthy, </author> <title> "Static task allocation of concurrent programs for distributed computing systems with processor and resource heterogeneity," </title> <journal> Parallel Computing, </journal> <volume> vol. 20, no. 6, </volume> <pages> pp. 835-851, </pages> <year> 1994. </year>
Reference: [12] <author> H. H. Ali and H. El-Rewini, </author> <title> "Task allocation in distributed systems: a split graph model," </title> <journal> J. Combin. Math. Combin. Comput., </journal> <volume> vol. 14, no. 1, </volume> <pages> pp. 15-32, </pages> <month> January </month> <year> 1993. </year>
Reference: [13] <author> A. Billionnet, M.-C. Costa, and A. Sutter, </author> <title> "An efficient algorithm for a task allocation problem," </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> vol. 39, no. 3, </volume> <pages> pp. 502-518, </pages> <month> March </month> <year> 1992. </year>
Reference: [14] <author> S. H. Bokhari, </author> <title> "A network flow model for load balancing in circuit-switched multicomputers," </title> <journal> IEEE Trans. Parallel and Distrib. Sys., </journal> <volume> vol. 4, no. 6, </volume> <pages> pp. 649-657, </pages> <month> June </month> <year> 1993. </year>
Reference: [15] <author> S. K. Dhall and C. L. Liu, </author> <title> "On a real-time scheduling problem," </title> <journal> Operations Research, </journal> <volume> vol. 26, no. 1, </volume> <pages> pp. 127-140, </pages> <year> 1978. </year>
Reference-contexts: The paper concludes with Section 7. 2 Related Work Task assignment and scheduling problems are studied extensively in both fields of Operations Research and Computer Science [6-14]. For a set of independent periodic tasks, Dhall and Liu <ref> [15] </ref> and their colleagues developed various assignment algorithms based on the rate monotonic scheduling algorithm [16], or intelligent fixed priority algorithm [17]. However, if there exist precedence constraints among tasks like our task system, these algorithms cannot be used. Instead, an approach to general task assignment problems must be taken.
Reference: [16] <author> C. L. Liu and J. W. Layland, </author> <title> "Scheduling algorithms for multiprogramming in a hard-real-time environment," </title> <journal> J. of ACM, </journal> <volume> vol. 20, no. 1, </volume> <pages> pp. 46-61, </pages> <year> 1973. </year>
Reference-contexts: For a set of independent periodic tasks, Dhall and Liu [15] and their colleagues developed various assignment algorithms based on the rate monotonic scheduling algorithm <ref> [16] </ref>, or intelligent fixed priority algorithm [17]. However, if there exist precedence constraints among tasks like our task system, these algorithms cannot be used. Instead, an approach to general task assignment problems must be taken.
Reference: [17] <author> O. </author> <title> Serlin, "Scheduling of time critical processes," </title> <booktitle> in Proc. of AFIPS 1972 Spring Joint Computer Conf., </booktitle> <pages> pp. 925-932, </pages> <editor> Montvale, N. J., </editor> <booktitle> 1972, </booktitle> <publisher> AFIPS Press. </publisher> <pages> 25 </pages>
Reference-contexts: For a set of independent periodic tasks, Dhall and Liu [15] and their colleagues developed various assignment algorithms based on the rate monotonic scheduling algorithm [16], or intelligent fixed priority algorithm <ref> [17] </ref>. However, if there exist precedence constraints among tasks like our task system, these algorithms cannot be used. Instead, an approach to general task assignment problems must be taken. Depending on the assumptions and the objective functions used, general task assignment problems are formulated differently.
Reference: [18] <author> H. S. Stone, </author> <title> "Multiprocessor scheduling with the aid of network flow algorithm," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. SE-3, no. 1, </volume> <pages> pp. 85-93, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: However, most prominent methods for task assignment in distributed systems are concerned with minimizing the sum of task processing costs on all assigned processors and interprocessor communications (IPC) costs. Examples of such methods typically include graph-theoretic solutions <ref> [18, 19] </ref> and integer programming solutions [20] among others [20-23]. Note that minimizing the aggregated processing of, and/or communication cost among, all tasks does not guarantee that individual deadlines will be met. Generally, it is difficult to add real-time constraints when a graph-theoretic approach is used.
Reference: [19] <author> H. S. Stone and S. H. Bokhari, </author> <title> "Control of distributed processes," </title> <journal> IEEE Computer, </journal> <volume> vol. 11, </volume> <pages> pp. 97-106, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: However, most prominent methods for task assignment in distributed systems are concerned with minimizing the sum of task processing costs on all assigned processors and interprocessor communications (IPC) costs. Examples of such methods typically include graph-theoretic solutions <ref> [18, 19] </ref> and integer programming solutions [20] among others [20-23]. Note that minimizing the aggregated processing of, and/or communication cost among, all tasks does not guarantee that individual deadlines will be met. Generally, it is difficult to add real-time constraints when a graph-theoretic approach is used.
Reference: [20] <author> P. Y. R. Ma and et. al., </author> <title> "A task allocation model for distributed computing systems," </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. C-31, no. 1, </volume> <pages> pp. 41-47, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: However, most prominent methods for task assignment in distributed systems are concerned with minimizing the sum of task processing costs on all assigned processors and interprocessor communications (IPC) costs. Examples of such methods typically include graph-theoretic solutions [18, 19] and integer programming solutions <ref> [20] </ref> among others [20-23]. Note that minimizing the aggregated processing of, and/or communication cost among, all tasks does not guarantee that individual deadlines will be met. Generally, it is difficult to add real-time constraints when a graph-theoretic approach is used. <p> Since constraints are defined in terms of average performance, their models are not suitable for hard real-time systems. Shen and Tsai [21], Ma et al. <ref> [20] </ref>, and Sinclair [22] derived optimal task assignments to minimize the sum of task execution and communication costs with the branch-and-bound (B&B) [30] method. The computational complexity of this method was also evaluated using simulation in [20, 22]. <p> Shen and Tsai [21], Ma et al. [20], and Sinclair [22] derived optimal task assignments to minimize the sum of task execution and communication costs with the branch-and-bound (B&B) [30] method. The computational complexity of this method was also evaluated using simulation in <ref> [20, 22] </ref>.
Reference: [21] <author> C. C. Shen and W. H. Tsai, </author> <title> "A graph matching approach to optimal task assignment in distributed computing systems using a minimax criterion," </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. C-34, no. 3, </volume> <pages> pp. 197-203, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: Since constraints are defined in terms of average performance, their models are not suitable for hard real-time systems. Shen and Tsai <ref> [21] </ref>, Ma et al. [20], and Sinclair [22] derived optimal task assignments to minimize the sum of task execution and communication costs with the branch-and-bound (B&B) [30] method. The computational complexity of this method was also evaluated using simulation in [20, 22].
Reference: [22] <author> J. B. Sinclair, </author> <title> "Efficient computation of optimal assignments for distributed tasks," </title> <journal> J. of Parallel and Distributed Computing, </journal> <volume> vol. 4, </volume> <pages> pp. 342-362, </pages> <year> 1987. </year>
Reference-contexts: Since constraints are defined in terms of average performance, their models are not suitable for hard real-time systems. Shen and Tsai [21], Ma et al. [20], and Sinclair <ref> [22] </ref> derived optimal task assignments to minimize the sum of task execution and communication costs with the branch-and-bound (B&B) [30] method. The computational complexity of this method was also evaluated using simulation in [20, 22]. <p> Shen and Tsai [21], Ma et al. [20], and Sinclair [22] derived optimal task assignments to minimize the sum of task execution and communication costs with the branch-and-bound (B&B) [30] method. The computational complexity of this method was also evaluated using simulation in <ref> [20, 22] </ref>.
Reference: [23] <author> V. M. Lo, </author> <title> "Heuristic algorithms for task assignment in distributed systems," </title> <journal> IEEE Trans. Comput., </journal> <volume> vol. 37, no. 11, </volume> <pages> pp. 1384-1397, </pages> <month> November </month> <year> 1988. </year>
Reference: [24] <author> E. G. Coffman, </author> <title> Computer and Job-Shop Scheduling Theory, </title> <publisher> Wiley and Sons, </publisher> <address> New York, </address> <year> 1976. </year>
Reference: [25] <author> M. R. Garey and D. S. Johnson, </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness, </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <year> 1979. </year>
Reference: [26] <author> J. K. Lenstra and A. H. G. R. Kan, </author> <title> "Complexity of scheduling under precedence constraints," </title> <journal> Operations Research, </journal> <volume> vol. 26, no. 1, </volume> <pages> pp. 23-35, </pages> <month> Jan </month> <year> 1978. </year>
Reference: [27] <author> E. L. Lawler, </author> <title> Deterministic and Stochastic Scheduling, chapter Recent Developments in Deterministic Sequencing and Scheduling: </title> <booktitle> A Survey, </booktitle> <pages> pp. 35-74, </pages> <publisher> Reidel, </publisher> <address> Dordrecht, The Netherlands, </address> <year> 1982. </year>
Reference: [28] <author> H. Kasahara and S. Narita, </author> <title> "Practical multiprocessor scheduling algorithms for efficient parallel processing," </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. C-33, no. 11, </volume> <pages> pp. 1023-1029, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: However, these constraints do not account for task queueing and intertask precedence constraints. Since the problem of assigning tasks subject to precedence constraints is generally NP-hard [24-27], some form of enumerative optimization or approximation using heuristics needs to be developed for this problem. For example, in <ref> [28] </ref> an enumeration tree of task scheduling is generated and searched using a heuristic algorithm called the CP/MISF (Critical Path/Most Immediate Successors First) and an optimal/approximate algorithm called the DF/IHS (Depth-First/Implicit Heuristic Search) to obtain an approximate minimum schedule length (i.e., makespan) for a set of tasks.
Reference: [29] <author> W. W. Chu and K. Leung, </author> <title> "Module replication and assignment for real-time distributed processing systems," </title> <journal> Proc of IEEE, </journal> <volume> vol. 75, no. 5, </volume> <pages> pp. 547-562, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: A wait-time-ratio between two assignments was defined in terms of task queueing delays. Precedence relations were used, in conjunction with the wait-time-ratios, to arrive at two heuristic rules for task 2 assignment. Under a slightly different model, Chu and Leung <ref> [29] </ref> presented an optimal solution to the task assignment problem in the sense of minimizing average task response time subject to certain timing constraints. Since constraints are defined in terms of average performance, their models are not suitable for hard real-time systems.
Reference: [30] <author> W. H. Kohler and K. Steiglitz, </author> <title> Computer and Job-Shop Scheduling Theory, chapter Enumerative and Iterative Computational Approach, </title> <journal> pp. </journal> <pages> 229-287, </pages> <publisher> Wiley and Sons, </publisher> <year> 1976. </year>
Reference-contexts: Since constraints are defined in terms of average performance, their models are not suitable for hard real-time systems. Shen and Tsai [21], Ma et al. [20], and Sinclair [22] derived optimal task assignments to minimize the sum of task execution and communication costs with the branch-and-bound (B&B) <ref> [30] </ref> method. The computational complexity of this method was also evaluated using simulation in [20, 22]. <p> In the case where two or more leaf vertices have the same cost, only one of them is retained arbitrarily. The algorithm terminates when the active set contains exactly one leaf vertex. It has been proven in <ref> [30] </ref> that there always exists a leaf vertex surviving the above search process, which is the optimal solution to the original problem. 1 function used to compute vertex cost on line 15.
Reference: [31] <author> M. Alfano, A. Di-Stefano, L. Lo-Bello, O. Mirabella, and J. H. Stewman, </author> <title> "An expert system for planning real-time distributed task allocation," </title> <booktitle> in Proceedings of the Florida AI Research Symposium, </booktitle> <address> Key West, FL, USA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: They are more directly applicable to hard real-time systems and have been motivated primarily by the need of contemporary embedded systems whose growing complexity of software and hardware requires an automated resource allocation approach. For example, task allocation algorithms have been reported for process control <ref> [31, 32] </ref>, turbo engine control [33], autonomous robotic systems [34], and avionics [35]. AI-based approaches that utilize application domain knowledge are described in [31, 34, 35]. Solutions to the allocation problem have also been presented for specific hardware topologies such as hypercubes [36], hexagonal architectures [37] and mesh-connected systems [38]. <p> For example, task allocation algorithms have been reported for process control [31, 32], turbo engine control [33], autonomous robotic systems [34], and avionics [35]. AI-based approaches that utilize application domain knowledge are described in <ref> [31, 34, 35] </ref>. Solutions to the allocation problem have also been presented for specific hardware topologies such as hypercubes [36], hexagonal architectures [37] and mesh-connected systems [38].
Reference: [32] <author> P. Altenbernd, C. Ditze, P. Laplante, and W. Halang, </author> <title> "Allocation of periodic real-time tasks," </title> <booktitle> in 20th IFAC/IFIP Workshop, </booktitle> <address> Fort Lauderdale, FL, USA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: They are more directly applicable to hard real-time systems and have been motivated primarily by the need of contemporary embedded systems whose growing complexity of software and hardware requires an automated resource allocation approach. For example, task allocation algorithms have been reported for process control <ref> [31, 32] </ref>, turbo engine control [33], autonomous robotic systems [34], and avionics [35]. AI-based approaches that utilize application domain knowledge are described in [31, 34, 35]. Solutions to the allocation problem have also been presented for specific hardware topologies such as hypercubes [36], hexagonal architectures [37] and mesh-connected systems [38].
Reference: [33] <author> J. L. Lanet, </author> <title> "Task allocation in a hard real-time distributed system," </title> <booktitle> in Proceedings of the 2nd Conference on Real-Time Systems, </booktitle> <pages> pp. 244-252, </pages> <address> Szlarska Poreba, Poland, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: For example, task allocation algorithms have been reported for process control [31, 32], turbo engine control <ref> [33] </ref>, autonomous robotic systems [34], and avionics [35]. AI-based approaches that utilize application domain knowledge are described in [31, 34, 35]. Solutions to the allocation problem have also been presented for specific hardware topologies such as hypercubes [36], hexagonal architectures [37] and mesh-connected systems [38].
Reference: [34] <author> T. C. Lueth and T. Laengle, </author> <title> "Task description, decomposition and allocation in a distributed autonomous multi-agent robot system," </title> <booktitle> in Proceedings of International Conference on Intelligent Robots and Systems, </booktitle> <pages> pp. 1516-1523, </pages> <address> Munich, Germany, </address> <month> September </month> <year> 1994. </year> <month> 26 </month>
Reference-contexts: For example, task allocation algorithms have been reported for process control [31, 32], turbo engine control [33], autonomous robotic systems <ref> [34] </ref>, and avionics [35]. AI-based approaches that utilize application domain knowledge are described in [31, 34, 35]. Solutions to the allocation problem have also been presented for specific hardware topologies such as hypercubes [36], hexagonal architectures [37] and mesh-connected systems [38]. <p> For example, task allocation algorithms have been reported for process control [31, 32], turbo engine control [33], autonomous robotic systems [34], and avionics [35]. AI-based approaches that utilize application domain knowledge are described in <ref> [31, 34, 35] </ref>. Solutions to the allocation problem have also been presented for specific hardware topologies such as hypercubes [36], hexagonal architectures [37] and mesh-connected systems [38].
Reference: [35] <author> C. M. Hopper and Y. Pan, </author> <title> "Task allocation in distributed computer systems through an ai planner solver," </title> <booktitle> in Proceedings of IEEE 1995 National Aerospace and Electronics Conference, </booktitle> <volume> volume 2, </volume> <pages> pp. 610-616, </pages> <address> Dayton, OH, USA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: For example, task allocation algorithms have been reported for process control [31, 32], turbo engine control [33], autonomous robotic systems [34], and avionics <ref> [35] </ref>. AI-based approaches that utilize application domain knowledge are described in [31, 34, 35]. Solutions to the allocation problem have also been presented for specific hardware topologies such as hypercubes [36], hexagonal architectures [37] and mesh-connected systems [38]. <p> For example, task allocation algorithms have been reported for process control [31, 32], turbo engine control [33], autonomous robotic systems [34], and avionics [35]. AI-based approaches that utilize application domain knowledge are described in <ref> [31, 34, 35] </ref>. Solutions to the allocation problem have also been presented for specific hardware topologies such as hypercubes [36], hexagonal architectures [37] and mesh-connected systems [38].
Reference: [36] <author> B. R. Tsai and K. G. Shin, </author> <title> "Assignment of task modules in hypercube multicomputers with component failures for communication efficiency," </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-43, no. 5, </volume> <pages> pp. 613-618, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: AI-based approaches that utilize application domain knowledge are described in [31, 34, 35]. Solutions to the allocation problem have also been presented for specific hardware topologies such as hypercubes <ref> [36] </ref>, hexagonal architectures [37] and mesh-connected systems [38]. While these application- or topology-specific approaches are efficient in solving the allocation problem for the particular real-time system at hand, those algorithms based on "abstract" task and resource models have the merit of more general applicability.
Reference: [37] <author> K. G. Shin and C. J. Hou, </author> <title> "Evaluation of load sharing in harts with consideration of its communication activities," </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> vol. 7, no. 7, </volume> <pages> pp. 724-739, </pages> <month> July </month> <year> 1996. </year>
Reference-contexts: AI-based approaches that utilize application domain knowledge are described in [31, 34, 35]. Solutions to the allocation problem have also been presented for specific hardware topologies such as hypercubes [36], hexagonal architectures <ref> [37] </ref> and mesh-connected systems [38]. While these application- or topology-specific approaches are efficient in solving the allocation problem for the particular real-time system at hand, those algorithms based on "abstract" task and resource models have the merit of more general applicability.
Reference: [38] <author> S. M. Yoo and H. Y. Youn, </author> <title> "An efficient task allocation scheme for two dimensional mesh-connected systems," </title> <booktitle> in Proceedings of the 15th International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 501-508, </pages> <address> Vancouver, Canada, </address> <year> 1995. </year>
Reference-contexts: AI-based approaches that utilize application domain knowledge are described in [31, 34, 35]. Solutions to the allocation problem have also been presented for specific hardware topologies such as hypercubes [36], hexagonal architectures [37] and mesh-connected systems <ref> [38] </ref>. While these application- or topology-specific approaches are efficient in solving the allocation problem for the particular real-time system at hand, those algorithms based on "abstract" task and resource models have the merit of more general applicability. Several such algorithms have recently been reported in the literature.
Reference: [39] <author> S. Kirkpatrick, C. Gelatt, and M. Vecchi, </author> <title> "Optimization by simulated annealing," </title> <journal> Science, </journal> <volume> vol. 220, </volume> <pages> pp. 671-680, </pages> <year> 1983. </year>
Reference-contexts: Several such algorithms have recently been reported in the literature. The complexity of the allocation problem usually calls for the use of heuristic solutions. Simulated annealing <ref> [39] </ref> has been proposed as an optimization heuristic. Different flavors of using simulated annealing in the context of real-time task assignment and scheduling can be found in [40-43].
Reference: [40] <author> K. Tindell, A. Burns, and A. Wellings, </author> <title> "Allocating hard real-time tasks: An np-hard problem made easy," </title> <journal> J. of Real-Time Systems, </journal> <volume> vol. 4, no. 2, </volume> <pages> pp. 145-166, </pages> <month> May </month> <year> 1992. </year>
Reference: [41] <author> E. Wells and C. C. Caroll, </author> <title> "An augmented approach to task allocation: Combining simulated annealing with list-based heuristics," </title> <booktitle> in Proc. Euromicro Workshop, </booktitle> <pages> pp. 508-515, </pages> <year> 1993. </year>
Reference: [42] <author> J. E. Beck and D. P. Siewiorek, </author> <title> "Simulated annealing applied to multicomputer task allocation and processor specification," </title> <booktitle> in Proceedings of 8th IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pp. 232-239, </pages> <month> October </month> <year> 1996. </year>
Reference: [43] <author> S. T. Cheng, S. I. Hwang, and A. K. Agrawala, </author> <title> "Schedulability oriented replication of periodic tasks in distributed real-time systems," </title> <booktitle> in Proceedings of the 15th International Conference on Distributed Computing Systems, </booktitle> <address> Vancouver, Canada, </address> <year> 1995. </year>
Reference: [44] <author> S. B. Shukla and D. P. Agrawal, </author> <title> "A framework for mapping periodic real-time applications on multicomputers," </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> vol. 5, no. 7, </volume> <pages> pp. 778-784, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: The quality of the solution found using simulated annealing depends on the selected energy-decay function, and in general, is not guaranteed to be optimal. Other heuristic solutions to task allocation in real-time systems include graph-theoretical, communication-oriented and schedulability oriented methods. For example, <ref> [44] </ref> considers an abstract problem where a given task graph is invoked periodically under an end-to-end deadline. A task allocation and message schedule are computed such that the end-to-end deadline is satisfied for each invocation.
Reference: [45] <author> T.-S. Tia and J. W.-S. Liu, </author> <title> "Assigning real-time tasks and resources to distributed systems," </title> <journal> Internnational Journal of Minim and Microcomputers, </journal> <volume> vol. 17, no. 1, </volume> <pages> pp. 18-25, </pages> <year> 1995. </year>
Reference-contexts: To reduce the size of the problem, tasks are pre-clustered before allocation begins. Task clusters (instead of individual tasks) are then assigned to individual processors. Graph-based heuristics, which attempt to minimize interprocessor communication, are used for task assignment in <ref> [45, 46] </ref>. In contrast, the approach in [47] searches the space of all (cluster) assignments and schedules until either a feasible solution is found or the space of all solutions have been searched exhaustively.
Reference: [46] <author> S. S. Wu and D. Sweeping, </author> <title> "Heuristic algorithms for task assignment and scheduling in a processor network," </title> <journal> Parallel Computing, </journal> <volume> vol. 20, </volume> <pages> pp. 1-14, </pages> <year> 1994. </year>
Reference-contexts: To reduce the size of the problem, tasks are pre-clustered before allocation begins. Task clusters (instead of individual tasks) are then assigned to individual processors. Graph-based heuristics, which attempt to minimize interprocessor communication, are used for task assignment in <ref> [45, 46] </ref>. In contrast, the approach in [47] searches the space of all (cluster) assignments and schedules until either a feasible solution is found or the space of all solutions have been searched exhaustively.
Reference: [47] <author> K. Ramamritham, </author> <title> "Allocation and scheduling of precedence-related periodic tasks," </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> vol. 6, no. 4, </volume> <pages> pp. 412-420, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: To reduce the size of the problem, tasks are pre-clustered before allocation begins. Task clusters (instead of individual tasks) are then assigned to individual processors. Graph-based heuristics, which attempt to minimize interprocessor communication, are used for task assignment in [45, 46]. In contrast, the approach in <ref> [47] </ref> searches the space of all (cluster) assignments and schedules until either a feasible solution is found or the space of all solutions have been searched exhaustively. <p> A k-Timely-Fault-Tolerant problem is solved in [50] where an assignment and schedule are found for replicated tasks such that all deadlines are met in the presence of up to k processor failures. The solution in [50] is concerned with independent tasks only. In <ref> [47, 51] </ref> replicated tasks with precedence constraints are considered. While [47] uses a deterministic task execution model, the algorithm of [51] solves a probabilistic model trying to maximize the probability of missing task deadlines. <p> The solution in [50] is concerned with independent tasks only. In [47, 51] replicated tasks with precedence constraints are considered. While <ref> [47] </ref> uses a deterministic task execution model, the algorithm of [51] solves a probabilistic model trying to maximize the probability of missing task deadlines.
Reference: [48] <author> J. Xu, </author> <title> "Multiprocessor scheduling of processes with release times, deadlines, precedence, and exclusion relations," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 19, no. 2, </volume> <pages> pp. 139-154, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: However, since tasks are pre-clustered without consider 3 ing their timing constraints, optimality can be lost because of clustering. Moreover, the approach was concerned with homogeneous systems and non-preemptive scheduling only. Optimal solutions for some class of real-time task allocation problems have been reported in the literature. For example, <ref> [48] </ref> describes an optimal branch and bound (B&B) algorithm for task assignment and scheduling on multiprocessors subject to precedence and exclusion constraints. In [49] a task assignment and scheduling algorithm is presented to optimally minimize the total execution time (TET) of an arbitrary task graph in a distributed real-time system.
Reference: [49] <author> P. Scholz and E. Harbeck, </author> <title> "Task assignment for distributed computing," </title> <booktitle> in Proceedings of the 1997 Conference on Advances in Parallel and Distributed Computing, </booktitle> <pages> pp. 270-277, </pages> <address> Shanghai, China, </address> <month> March </month> <year> 1997. </year> <month> 27 </month>
Reference-contexts: Optimal solutions for some class of real-time task allocation problems have been reported in the literature. For example, [48] describes an optimal branch and bound (B&B) algorithm for task assignment and scheduling on multiprocessors subject to precedence and exclusion constraints. In <ref> [49] </ref> a task assignment and scheduling algorithm is presented to optimally minimize the total execution time (TET) of an arbitrary task graph in a distributed real-time system. It employs a stochastic optimization phase to find a solution with "good" TET.
Reference: [50] <author> Y. Oh and S. H. Son, </author> <title> "Scheduling hard real-time tasks with tolerance to multiple processor failures," </title> <booktitle> Multiprocessing and Multiprogramming, </booktitle> <volume> vol. 40, </volume> <pages> pp. 193-206, </pages> <year> 1994. </year>
Reference-contexts: The algorithm is applicable to systems with a single end-to-end deadline. In systems where different tasks have different deadlines minimizing TET does not necessarily lead to a feasible schedule. Fault-tolerance requirements have also been considered in task allocation problems. A k-Timely-Fault-Tolerant problem is solved in <ref> [50] </ref> where an assignment and schedule are found for replicated tasks such that all deadlines are met in the presence of up to k processor failures. The solution in [50] is concerned with independent tasks only. In [47, 51] replicated tasks with precedence constraints are considered. <p> Fault-tolerance requirements have also been considered in task allocation problems. A k-Timely-Fault-Tolerant problem is solved in <ref> [50] </ref> where an assignment and schedule are found for replicated tasks such that all deadlines are met in the presence of up to k processor failures. The solution in [50] is concerned with independent tasks only. In [47, 51] replicated tasks with precedence constraints are considered. While [47] uses a deterministic task execution model, the algorithm of [51] solves a probabilistic model trying to maximize the probability of missing task deadlines.
Reference: [51] <author> C.-J. Hou and K. G. Shin, </author> <title> "Replication and allocation of task modules in distributed real-time systems," </title> <booktitle> in 24th IEEE Symposuim on Fault-Tolerant Computing Systems, </booktitle> <pages> pp. 26-35, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: A k-Timely-Fault-Tolerant problem is solved in [50] where an assignment and schedule are found for replicated tasks such that all deadlines are met in the presence of up to k processor failures. The solution in [50] is concerned with independent tasks only. In <ref> [47, 51] </ref> replicated tasks with precedence constraints are considered. While [47] uses a deterministic task execution model, the algorithm of [51] solves a probabilistic model trying to maximize the probability of missing task deadlines. <p> The solution in [50] is concerned with independent tasks only. In [47, 51] replicated tasks with precedence constraints are considered. While [47] uses a deterministic task execution model, the algorithm of <ref> [51] </ref> solves a probabilistic model trying to maximize the probability of missing task deadlines. Although it is optimal in minimizing the performance measure, the algorithm in [51] requires information about the task model which may not be available (for example, branching probabilities of individual branch statements). <p> In [47, 51] replicated tasks with precedence constraints are considered. While [47] uses a deterministic task execution model, the algorithm of <ref> [51] </ref> solves a probabilistic model trying to maximize the probability of missing task deadlines. Although it is optimal in minimizing the performance measure, the algorithm in [51] requires information about the task model which may not be available (for example, branching probabilities of individual branch statements). Instead, we use a deterministic approach where worst-case execution times are sufficient to represent task load.
Reference: [52] <author> K. G. Shin and S. Daniel, </author> <title> "Analysis and implementation of hybrid switching," </title> <journal> IEEE Trans. on Computers, </journal> <pages> pp. 211-219, </pages> <year> 1995. </year>
Reference-contexts: In general, for some hybrid switching scheme like the one in <ref> [52] </ref>, the delay may be approximated by d ij = an ij + bl ij + cn ij l ij , where a, b and c are constants for the particular network. Note that the above expression is merely an approximation.
Reference: [53] <author> D. Kandlur, K. G. Shin, and D. Ferrari, </author> <title> "Real-time communication in multihop networks," </title> <journal> IEEE Trans. Parallel and Distributed Systems, </journal> <volume> vol. 5, no. 10, </volume> <pages> pp. 1044-1056, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Note that the above expression is merely an approximation. If a particular communication paradigm (e.g., real-time channels <ref> [53] </ref>) is known then d ij may be expressed precisely. Our allocation algorithm does not make assumptions as to how d ij is computed. Also, note that module execution times and communication delays may be interpreted as worst-case estimates when exact values cannot be obtained.
Reference: [54] <author> D.-T. Peng and K. G. Shin, </author> <title> "A new performance measure for scheduling independent real-time tasks," </title> <journal> J. Parallel Distrib. Comput., </journal> <volume> vol. 19, no. 1, </volume> <pages> pp. 11-26, </pages> <year> 1993. </year>
Reference-contexts: The difference between the two solutions would be that in system hazard minimization, task laxity is more likely to be distributed in proportion to task timing constraints. In <ref> [1, 54] </ref> it is argued that this results in a more "robust" schedule. The argument, however, is a rather subjective. Generally, the choice between the two objective functions may depend on the application at hand.
Reference: [55] <author> K. R. Baker et al., </author> <title> "Preemptive scheduling of a single machine to minimize maximum cost subject to release dates and precedence constraints," </title> <journal> Operations Research, </journal> <volume> vol. 31, no. 2, </volume> <pages> pp. 381-386, </pages> <month> March </month> <year> 1983. </year> <month> 28 </month>
Reference-contexts: Table 1 summarizes how job parameters have been computed. A lower bound of the node hazard is computed for each node N q by applying the optimal uniprocessor scheduling algorithm Algorithm A of <ref> [55] </ref> to the set of jobs, JQ. The algorithm is applied for each processor independently. For completeness, Algorithm A of complexity O (jJQj 2 ) is briefly described below, where jJQj is the number of jobs to be scheduled. <p> Note that the periodicity assumption has been used only to derive the length of the planning cycle and the release times of task invocations. The rest of the paper (as well as the scheduling algorithms <ref> [1, 55] </ref>) does not rely on this assumption. Furthermore, our model can be easily extended to the case where modules, rather than tasks, are the objects to be allocated. The lower-bound costs presented in this paper are shown to reduce the computational difficulty significantly.
References-found: 55

