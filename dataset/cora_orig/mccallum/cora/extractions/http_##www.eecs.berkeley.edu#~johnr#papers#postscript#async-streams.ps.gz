URL: http://www.eecs.berkeley.edu/~johnr/papers/postscript/async-streams.ps.gz
Refering-URL: http://www.eecs.berkeley.edu/~johnr/papers/async.html
Root-URL: 
Email: email: johnr@ee.uts.edu.au  
Title: Modelling Asynchronous Streams in Haskell  
Author: H. John Reekie 
Address: Sydney  
Affiliation: School of Electrical Engineering University of Technology,  
Abstract: This paper explores the use of Haskell to model discrete-time signals, or streams, with an emphasis on application to signal processing. Because of the deterministic nature of functional programs, asynchronous streams must be modelled by explicitly including time. Two types of asynchronous stream are examined: hiatonic streams, and time-stamped streams. A number of utility functions for manipulating asynchronous streams are presented, and their use demonstrated with examples.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Steven Anderson and Paul Hudak. </author> <title> Compilation of Haskell array comprehensions for scientific computing. </title> <booktitle> In Proc. Programming Language Design and Implementation (PLDI), </booktitle> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: The source of this paper is a literate Gofer script|that is, it can be executed by the Gofer interpreter as-is. Lines beginning with "&gt;" are program code. 2 Stream Basics In this paper, a stream is represented by a lazy list, written e.g. <ref> [1; 2; 3; 4; 5; 6; 7] </ref>. (Although this is a finite list, lists can be infinite.) A list containing elements of type a has the type [a]. Functions on lists are best described by example. <p> Pattern-matching is used to bind the head and tail of the list to the variables x and xs. map is applied to a list as follows: map (+1) <ref> [1; 3; 4; 7] </ref> ) [2; 4; 5; 8] where ) means "evaluates to." The expression map (+1) thus represents a process that adds one to each input element. <p> An example of the use of zipW ith is: zipW ith (+) <ref> [1; 3; 4; 7] </ref> [1; 2; 3; 4] ) [2; 5; 7; 11] A fourth useful function is called pref l 1 , for "prefix-from-left." &gt; prefl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a] &gt; prefl f a [] = [] &gt; prefl f a (x:xs) <p> An example of the use of zipW ith is: zipW ith (+) [1; 3; 4; 7] <ref> [1; 2; 3; 4] </ref> ) [2; 5; 7; 11] A fourth useful function is called pref l 1 , for "prefix-from-left." &gt; prefl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a] &gt; prefl f a [] = [] &gt; prefl f a (x:xs) = q : prefl <p> However, the function argument f is applied to an input value and the previous output value, instead of just to the input value. For example, pref l (+) 0 <ref> [1; 3; 4; 7] </ref> ) [1; 4; 8; 15] A third function, f ilter, removes items of a list that do not satisfy a predicate: filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs <p> However, the function argument f is applied to an input value and the previous output value, instead of just to the input value. For example, pref l (+) 0 [1; 3; 4; 7] ) <ref> [1; 4; 8; 15] </ref> A third function, f ilter, removes items of a list that do not satisfy a predicate: filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p <p> f ilter, removes items of a list that do not satisfy a predicate: filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p xs For example, f ilter odd <ref> [1; 3; 4; 7] </ref> ) [1; 3; 7] An introduction to functional programming can be found in [3] or [5]. 1 prefl is very similar to Haskell's scanl: prefl f a = tail scanl f a. <p> a list that do not satisfy a predicate: filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p xs For example, f ilter odd [1; 3; 4; 7] ) <ref> [1; 3; 7] </ref> An introduction to functional programming can be found in [3] or [5]. 1 prefl is very similar to Haskell's scanl: prefl f a = tail scanl f a. <p> A hiatonic stream is a list of these "slots," type [Slot a]. An example of a hiatonic stream is: &gt; hiatonic = [ Val 1, Hiaton, Val 3, Val 4, &gt; Hiaton, Hiaton, Val 7, Hiaton ] :: [Slot Int] for which I use the short-hand representation <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl : For implementation in a real-time context, it will be necessary to "hide" the hiatons from the programmer, and provide the programmer access to hiatonic streams only through the functions of an abstract data type (ADT). <p> function is defined as follows: &gt; mapH :: (a -&gt; b) -&gt; [Slot a] -&gt; [Slot b] &gt; mapH f [] = [] &gt; mapH f (Hiaton:xs) = Hiaton : mapH f xs &gt; mapH f ((Val x):xs) = Val (f x) : mapH f xs For example, mapH (+1) <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [2; fl; 4; 5; fl; fl; 8; fl] fl The asynchronous equivalent of pref l also produces an output value only for each input value: 5 &gt; preflH :: (a -&gt; b -&gt; a) -&gt; a -&gt; [Slot b] -&gt; [Slot <p> a] &gt; preflH f a [] = [] &gt; preflH f a (Hiaton : xs) = Hiaton : preflH f a xs &gt; preflH f a (Val x : xs) = Val y : preflH f y xs where y = f a x For example, pref lH (+) 0 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; fl; 4; 8; fl; fl; 15; fl] fl 4.2 Time-stamped Streams In a hiatonic stream, non-value time slots are marked with a special value. In effect, hiatonic streams are still synchronous. <p> f a (Hiaton : xs) = Hiaton : preflH f a xs &gt; preflH f a (Val x : xs) = Val y : preflH f y xs where y = f a x For example, pref lH (+) 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; fl; 4; 8; fl; fl; 15; fl] </ref> fl 4.2 Time-stamped Streams In a hiatonic stream, non-value time slots are marked with a special value. In effect, hiatonic streams are still synchronous. An alternative representation pairs each value with a "time-stamp," which denotes the time at which the value occurs. <p> Versions of f ilter that do preserve time information could either a) take a synchronous stream and produce an asynchronous stream, or b) take an asynchronous stream and produce another asynchronous stream. selectH and selectT produce an asynchronous stream from a synchronous stream: selectH odd <ref> [1; 2; 3; 4; 5] </ref> ) [1; fl; 3; fl; 5] fl selectT odd [1; 2; 3; 4; 5] ) [1 1 ; 3 2 ; 5 2 ] We can also define functions that remove unwanted elements from asynchronous streams (see f ilterH and f ilterT in Appendix B). 7 <p> of f ilter that do preserve time information could either a) take a synchronous stream and produce an asynchronous stream, or b) take an asynchronous stream and produce another asynchronous stream. selectH and selectT produce an asynchronous stream from a synchronous stream: selectH odd [1; 2; 3; 4; 5] ) <ref> [1; fl; 3; fl; 5] </ref> fl selectT odd [1; 2; 3; 4; 5] ) [1 1 ; 3 2 ; 5 2 ] We can also define functions that remove unwanted elements from asynchronous streams (see f ilterH and f ilterT in Appendix B). 7 5.3 Sampling A synchronous stream can <p> could either a) take a synchronous stream and produce an asynchronous stream, or b) take an asynchronous stream and produce another asynchronous stream. selectH and selectT produce an asynchronous stream from a synchronous stream: selectH odd <ref> [1; 2; 3; 4; 5] </ref> ) [1; fl; 3; fl; 5] fl selectT odd [1; 2; 3; 4; 5] ) [1 1 ; 3 2 ; 5 2 ] We can also define functions that remove unwanted elements from asynchronous streams (see f ilterH and f ilterT in Appendix B). 7 5.3 Sampling A synchronous stream can be "sampled" at time instants specified by a <p> The whenT function does exactly this: 3 <ref> [5; 4; 3; 2; 1] </ref>whenT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [5 1 ; 3 2 ; 2 1 ] 5.4 Resynchronising To convert a time-stamped stream back into a synchronous stream, we must "fill in" the time slots between values. <p> x a &gt; resyncT f g a (Stamp t x : xs ) &gt; = y : resyncT f g y (Stamp (t-1) x : xs) where y = g a For example, resyncT (+) (+1) 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; 2; 5; 9; 10; 11; 18] </ref> When we convert an asynchronous stream back into a synchronous stream, we must fill in the empty time slots. There are two choices for the missing values: i) a specified value, or ii) the most recent value. <p> There are two choices for the missing values: i) a specified value, or ii) the most recent value. The time-stamped versions of the functions below use the resyncT function. f illH and f illT insert a specified value: f illH 0 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 0; 3; 4; 0; 0; 7; 0] f illT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 0; 3; 4; 0; 0; 7] holdH and holdT perform a zero-order hold. <p> The time-stamped versions of the functions below use the resyncT function. f illH and f illT insert a specified value: f illH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 0; 3; 4; 0; 0; 7; 0] </ref> f illT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 0; 3; 4; 0; 0; 7] holdH and holdT perform a zero-order hold. <p> use the resyncT function. f illH and f illT insert a specified value: f illH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1; 0; 3; 4; 0; 0; 7; 0] f illT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; 0; 3; 4; 0; 0; 7] </ref> holdH and holdT perform a zero-order hold. <p> The first argument specifies the value inserted into initial empty time slots: holdH 0 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 1; 3; 4; 4; 4; 7; 7] holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a <p> The first argument specifies the value inserted into initial empty time slots: holdH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 1; 3; 4; 4; 4; 7; 7] </ref> holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing <p> The first argument specifies the value inserted into initial empty time slots: holdH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1; 1; 3; 4; 4; 4; 7; 7] holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; 1; 3; 4; 4; 4; 7] </ref> 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1; 3; 4; 7] desyncT [1 <p> holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 3; 4; 7] desyncT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view <p> ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 3; 4; 7] </ref> desyncT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view this as producing a true asynchronous stream. 8 5.6 Converting <p> the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 3; 4; 7] </ref> desyncT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view this as producing a true asynchronous stream. 8 5.6 Converting stamp converts a hiatonic stream to a stamped stream, while unstamp does the reverse: stamp [1; fl; 3; <p> ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view this as producing a true asynchronous stream. 8 5.6 Converting stamp converts a hiatonic stream to a stamped stream, while unstamp does the reverse: stamp <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1 1 ; 3 2 ; 4 1 ; 7 3 ] unstamp [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; fl; 3; 4; fl; fl; 7] fl Notice that these functions are not quite <p> converts a hiatonic stream to a stamped stream, while unstamp does the reverse: stamp [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1 1 ; 3 2 ; 4 1 ; 7 3 ] unstamp [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; fl; 3; 4; fl; fl; 7] </ref> fl Notice that these functions are not quite inverses of each other, since stamp unstamp = id but unstamp stamp 6= id: This raises an interesting question. <p> The lists <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl and [1; fl; 3; 4; fl; fl; 7] fl are clearly not the same (the former has an extra empty time slot at the end). <p> 7 3 ] ) <ref> [1; fl; 3; 4; fl; fl; 7] </ref> fl Notice that these functions are not quite inverses of each other, since stamp unstamp = id but unstamp stamp 6= id: This raises an interesting question. The lists [1; fl; 3; 4; fl; fl; 7; fl] fl and [1; fl; 3; 4; fl; fl; 7] fl are clearly not the same (the former has an extra empty time slot at the end). <p> Up-sampling is easy, since it is just a matter of inserting extra hiatons or scaling the time-stamps: upsampleH 2 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; fl; fl; fl; 3; fl; 4; fl; fl; fl; fl; fl; 7; fl; fl; fl] upsampleT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1 1 ; 3 4 ; 4 2 ; 7 6 <p> is the starting value with which it compares the first value in the stream. &gt; edges :: (Eq a) =&gt; a -&gt; [a] -&gt; [Slot a] &gt; edges a = mapH snd . selectH neq . pairs a where &gt; neq (x,y) = x /= y For example, edges 0 <ref> [1; 1; 3; 4; 4; 4; 7; 7] </ref> ) [1; fl; 3; 4; fl; fl; 7; fl] fl The pairs function used above combines adjacent elements of a stream into pairs (see Appendix C): pairs 0 [1; 1; 3; 4; 4; 4; 7; 7] ) [(0; 1); (1; 1); (1; 3); <p> first value in the stream. &gt; edges :: (Eq a) =&gt; a -&gt; [a] -&gt; [Slot a] &gt; edges a = mapH snd . selectH neq . pairs a where &gt; neq (x,y) = x /= y For example, edges 0 [1; 1; 3; 4; 4; 4; 7; 7] ) <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl The pairs function used above combines adjacent elements of a stream into pairs (see Appendix C): pairs 0 [1; 1; 3; 4; 4; 4; 7; 7] ) [(0; 1); (1; 1); (1; 3); (3; 4); (4; 4); (4; 4); (4; 7); (7; <p> pairs a where &gt; neq (x,y) = x /= y For example, edges 0 <ref> [1; 1; 3; 4; 4; 4; 7; 7] </ref> ) [1; fl; 3; 4; fl; fl; 7; fl] fl The pairs function used above combines adjacent elements of a stream into pairs (see Appendix C): pairs 0 [1; 1; 3; 4; 4; 4; 7; 7] ) [(0; 1); (1; 1); (1; 3); (3; 4); (4; 4); (4; 4); (4; 7); (7; 7)] 6.2 Detecting zero crossings Detecting the zero-crossings of a signal is a simple but useful operation. <p> It works by taking the sign of each input element and detecting changes in the sign. &gt; zero_crossings :: (Ord a, Num a) =&gt; [a] -&gt; [Stamp Int] &gt; zero_crossings = deltaT . stamp . edges True . map (&gt;= 0) For example, zero crossings <ref> [0; 1; 2; 1; 1; 2; 1; 1] </ref> ) [3 3 ; 3 3 ; 1 1 ] 6.3 Differential PCM Suppose we wish to encode and transmit a signal as straight-line segments. <p> For example, encode <ref> [0; 1; 2; 2; 2; 0; 2; 3; 3; 3; 3] </ref> ) [0 1 ; 1 1 ; 0 2 ; 2 2 ; 1 2 ; 0 1 ] The signal can be re-assembled by doing a zero-order interpolation and then integrating: &gt; decode :: (Num a) =&gt; [Stamp a] <p> re-assembled by doing a zero-order interpolation and then integrating: &gt; decode :: (Num a) =&gt; [Stamp a] -&gt; [a] &gt; decode = prefl (+) 0 . holdT 0 For example, decode [0 1 ; 1 1 ; 0 2 ; 2 2 ; 1 2 ; 0 1 ] ) <ref> [0; 1; 2; 2; 2; 0; 2; 3; 3] </ref> Notice that the final segment has been thrown away, because there is no end marker produced when the differential stream is time-stamped. 6.4 Down-sampling Earlier, I postponed the definitions of functions to down-sample asynchronous streams. <p> is defined in terms of the hiatonic stream function; this implies a large ineffiency if the items occur infrequently: &gt; downsampleT :: Int -&gt; ([a] -&gt; a) -&gt; [Stamp a] -&gt; [Stamp a] &gt; downsampleT k choose = stamp . downsampleH k choose . unstamp For example, downsampleH 2 head <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 3; fl; 7] fl downsampleT 2 head [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1 1 ; 3 1 ; 7 2 ] 6.5 Filtering asynchronous signals One of the reason cited earlier for <p> implies a large ineffiency if the items occur infrequently: &gt; downsampleT :: Int -&gt; ([a] -&gt; a) -&gt; [Stamp a] -&gt; [Stamp a] &gt; downsampleT k choose = stamp . downsampleH k choose . unstamp For example, downsampleH 2 head [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 3; fl; 7] </ref> fl downsampleT 2 head [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1 1 ; 3 1 ; 7 2 ] 6.5 Filtering asynchronous signals One of the reason cited earlier for asynchronous streams was to allow meaningful filtering of non-uniformly sampled <p> By appropriate analysis or through programmer-supplied annotations that indicate strictness conditions, however, real-time implementation may be possible. For example, <ref> [1] </ref> show how appropriate programming constructs can be used to "escape" from lazy evaluation in special circumstances.
Reference: [2] <author> J. C. Bier, E. E. Goei, W. H. Ho, P. D. Lapsley, M. P. O'Reilly, G. C. Sih, and E. A. Lee. Gabriel: </author> <title> A design environment for DSP. </title> <booktitle> IEEE Micro, </booktitle> <pages> pages 28-45, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The source of this paper is a literate Gofer script|that is, it can be executed by the Gofer interpreter as-is. Lines beginning with "&gt;" are program code. 2 Stream Basics In this paper, a stream is represented by a lazy list, written e.g. <ref> [1; 2; 3; 4; 5; 6; 7] </ref>. (Although this is a finite list, lists can be infinite.) A list containing elements of type a has the type [a]. Functions on lists are best described by example. <p> Pattern-matching is used to bind the head and tail of the list to the variables x and xs. map is applied to a list as follows: map (+1) [1; 3; 4; 7] ) <ref> [2; 4; 5; 8] </ref> where ) means "evaluates to." The expression map (+1) thus represents a process that adds one to each input element. <p> An example of the use of zipW ith is: zipW ith (+) [1; 3; 4; 7] <ref> [1; 2; 3; 4] </ref> ) [2; 5; 7; 11] A fourth useful function is called pref l 1 , for "prefix-from-left." &gt; prefl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a] &gt; prefl f a [] = [] &gt; prefl f a (x:xs) = q : prefl <p> An example of the use of zipW ith is: zipW ith (+) [1; 3; 4; 7] [1; 2; 3; 4] ) <ref> [2; 5; 7; 11] </ref> A fourth useful function is called pref l 1 , for "prefix-from-left." &gt; prefl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a] &gt; prefl f a [] = [] &gt; prefl f a (x:xs) = q : prefl f q xs where q <p> b) -&gt; [Slot a] -&gt; [Slot b] &gt; mapH f [] = [] &gt; mapH f (Hiaton:xs) = Hiaton : mapH f xs &gt; mapH f ((Val x):xs) = Val (f x) : mapH f xs For example, mapH (+1) [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [2; fl; 4; 5; fl; fl; 8; fl] </ref> fl The asynchronous equivalent of pref l also produces an output value only for each input value: 5 &gt; preflH :: (a -&gt; b -&gt; a) -&gt; a -&gt; [Slot b] -&gt; [Slot a] &gt; preflH f a [] = [] &gt; preflH <p> Versions of f ilter that do preserve time information could either a) take a synchronous stream and produce an asynchronous stream, or b) take an asynchronous stream and produce another asynchronous stream. selectH and selectT produce an asynchronous stream from a synchronous stream: selectH odd <ref> [1; 2; 3; 4; 5] </ref> ) [1; fl; 3; fl; 5] fl selectT odd [1; 2; 3; 4; 5] ) [1 1 ; 3 2 ; 5 2 ] We can also define functions that remove unwanted elements from asynchronous streams (see f ilterH and f ilterT in Appendix B). 7 <p> could either a) take a synchronous stream and produce an asynchronous stream, or b) take an asynchronous stream and produce another asynchronous stream. selectH and selectT produce an asynchronous stream from a synchronous stream: selectH odd <ref> [1; 2; 3; 4; 5] </ref> ) [1; fl; 3; fl; 5] fl selectT odd [1; 2; 3; 4; 5] ) [1 1 ; 3 2 ; 5 2 ] We can also define functions that remove unwanted elements from asynchronous streams (see f ilterH and f ilterT in Appendix B). 7 5.3 Sampling A synchronous stream can be "sampled" at time instants specified by a <p> The whenT function does exactly this: 3 <ref> [5; 4; 3; 2; 1] </ref>whenT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [5 1 ; 3 2 ; 2 1 ] 5.4 Resynchronising To convert a time-stamped stream back into a synchronous stream, we must "fill in" the time slots between values. <p> x a &gt; resyncT f g a (Stamp t x : xs ) &gt; = y : resyncT f g y (Stamp (t-1) x : xs) where y = g a For example, resyncT (+) (+1) 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; 2; 5; 9; 10; 11; 18] </ref> When we convert an asynchronous stream back into a synchronous stream, we must fill in the empty time slots. There are two choices for the missing values: i) a specified value, or ii) the most recent value. <p> If a stream is taken to represent an infinite discrete-time signal, then there is no need to distinguish between the two. The restriction to infinite streams only is not an unreasonable one in many application domains. For example, the Gabriel programming system <ref> [2] </ref> supports only infinite streams. <p> It works by taking the sign of each input element and detecting changes in the sign. &gt; zero_crossings :: (Ord a, Num a) =&gt; [a] -&gt; [Stamp Int] &gt; zero_crossings = deltaT . stamp . edges True . map (&gt;= 0) For example, zero crossings <ref> [0; 1; 2; 1; 1; 2; 1; 1] </ref> ) [3 3 ; 3 3 ; 1 1 ] 6.3 Differential PCM Suppose we wish to encode and transmit a signal as straight-line segments. <p> For example, encode <ref> [0; 1; 2; 2; 2; 0; 2; 3; 3; 3; 3] </ref> ) [0 1 ; 1 1 ; 0 2 ; 2 2 ; 1 2 ; 0 1 ] The signal can be re-assembled by doing a zero-order interpolation and then integrating: &gt; decode :: (Num a) =&gt; [Stamp a] <p> re-assembled by doing a zero-order interpolation and then integrating: &gt; decode :: (Num a) =&gt; [Stamp a] -&gt; [a] &gt; decode = prefl (+) 0 . holdT 0 For example, decode [0 1 ; 1 1 ; 0 2 ; 2 2 ; 1 2 ; 0 1 ] ) <ref> [0; 1; 2; 2; 2; 0; 2; 3; 3] </ref> Notice that the final segment has been thrown away, because there is no end marker produced when the differential stream is time-stamped. 6.4 Down-sampling Earlier, I postponed the definitions of functions to down-sample asynchronous streams. <p> In the context of stream-based programs, it may be possible to use this idea to enable efficient analysis and code generation techniques developed for dataflow programs <ref> [8, 2] </ref> to be applied to functional process network programs. Work on this idea is currently in progress.
Reference: [3] <author> R. Bird and P. Wadler. </author> <title> Introduction to Functional Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year> <month> 16 </month>
Reference-contexts: The source of this paper is a literate Gofer script|that is, it can be executed by the Gofer interpreter as-is. Lines beginning with "&gt;" are program code. 2 Stream Basics In this paper, a stream is represented by a lazy list, written e.g. <ref> [1; 2; 3; 4; 5; 6; 7] </ref>. (Although this is a finite list, lists can be infinite.) A list containing elements of type a has the type [a]. Functions on lists are best described by example. <p> Pattern-matching is used to bind the head and tail of the list to the variables x and xs. map is applied to a list as follows: map (+1) <ref> [1; 3; 4; 7] </ref> ) [2; 4; 5; 8] where ) means "evaluates to." The expression map (+1) thus represents a process that adds one to each input element. <p> An example of the use of zipW ith is: zipW ith (+) <ref> [1; 3; 4; 7] </ref> [1; 2; 3; 4] ) [2; 5; 7; 11] A fourth useful function is called pref l 1 , for "prefix-from-left." &gt; prefl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a] &gt; prefl f a [] = [] &gt; prefl f a (x:xs) <p> An example of the use of zipW ith is: zipW ith (+) [1; 3; 4; 7] <ref> [1; 2; 3; 4] </ref> ) [2; 5; 7; 11] A fourth useful function is called pref l 1 , for "prefix-from-left." &gt; prefl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a] &gt; prefl f a [] = [] &gt; prefl f a (x:xs) = q : prefl <p> However, the function argument f is applied to an input value and the previous output value, instead of just to the input value. For example, pref l (+) 0 <ref> [1; 3; 4; 7] </ref> ) [1; 4; 8; 15] A third function, f ilter, removes items of a list that do not satisfy a predicate: filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs <p> f ilter, removes items of a list that do not satisfy a predicate: filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p xs For example, f ilter odd <ref> [1; 3; 4; 7] </ref> ) [1; 3; 7] An introduction to functional programming can be found in [3] or [5]. 1 prefl is very similar to Haskell's scanl: prefl f a = tail scanl f a. <p> a list that do not satisfy a predicate: filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p xs For example, f ilter odd [1; 3; 4; 7] ) <ref> [1; 3; 7] </ref> An introduction to functional programming can be found in [3] or [5]. 1 prefl is very similar to Haskell's scanl: prefl f a = tail scanl f a. <p> Bool) -&gt; [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p xs For example, f ilter odd [1; 3; 4; 7] ) [1; 3; 7] An introduction to functional programming can be found in <ref> [3] </ref> or [5]. 1 prefl is very similar to Haskell's scanl: prefl f a = tail scanl f a. <p> A hiatonic stream is a list of these "slots," type [Slot a]. An example of a hiatonic stream is: &gt; hiatonic = [ Val 1, Hiaton, Val 3, Val 4, &gt; Hiaton, Hiaton, Val 7, Hiaton ] :: [Slot Int] for which I use the short-hand representation <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl : For implementation in a real-time context, it will be necessary to "hide" the hiatons from the programmer, and provide the programmer access to hiatonic streams only through the functions of an abstract data type (ADT). <p> function is defined as follows: &gt; mapH :: (a -&gt; b) -&gt; [Slot a] -&gt; [Slot b] &gt; mapH f [] = [] &gt; mapH f (Hiaton:xs) = Hiaton : mapH f xs &gt; mapH f ((Val x):xs) = Val (f x) : mapH f xs For example, mapH (+1) <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [2; fl; 4; 5; fl; fl; 8; fl] fl The asynchronous equivalent of pref l also produces an output value only for each input value: 5 &gt; preflH :: (a -&gt; b -&gt; a) -&gt; a -&gt; [Slot b] -&gt; [Slot <p> a] &gt; preflH f a [] = [] &gt; preflH f a (Hiaton : xs) = Hiaton : preflH f a xs &gt; preflH f a (Val x : xs) = Val y : preflH f y xs where y = f a x For example, pref lH (+) 0 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; fl; 4; 8; fl; fl; 15; fl] fl 4.2 Time-stamped Streams In a hiatonic stream, non-value time slots are marked with a special value. In effect, hiatonic streams are still synchronous. <p> Versions of f ilter that do preserve time information could either a) take a synchronous stream and produce an asynchronous stream, or b) take an asynchronous stream and produce another asynchronous stream. selectH and selectT produce an asynchronous stream from a synchronous stream: selectH odd <ref> [1; 2; 3; 4; 5] </ref> ) [1; fl; 3; fl; 5] fl selectT odd [1; 2; 3; 4; 5] ) [1 1 ; 3 2 ; 5 2 ] We can also define functions that remove unwanted elements from asynchronous streams (see f ilterH and f ilterT in Appendix B). 7 <p> of f ilter that do preserve time information could either a) take a synchronous stream and produce an asynchronous stream, or b) take an asynchronous stream and produce another asynchronous stream. selectH and selectT produce an asynchronous stream from a synchronous stream: selectH odd [1; 2; 3; 4; 5] ) <ref> [1; fl; 3; fl; 5] </ref> fl selectT odd [1; 2; 3; 4; 5] ) [1 1 ; 3 2 ; 5 2 ] We can also define functions that remove unwanted elements from asynchronous streams (see f ilterH and f ilterT in Appendix B). 7 5.3 Sampling A synchronous stream can <p> could either a) take a synchronous stream and produce an asynchronous stream, or b) take an asynchronous stream and produce another asynchronous stream. selectH and selectT produce an asynchronous stream from a synchronous stream: selectH odd <ref> [1; 2; 3; 4; 5] </ref> ) [1; fl; 3; fl; 5] fl selectT odd [1; 2; 3; 4; 5] ) [1 1 ; 3 2 ; 5 2 ] We can also define functions that remove unwanted elements from asynchronous streams (see f ilterH and f ilterT in Appendix B). 7 5.3 Sampling A synchronous stream can be "sampled" at time instants specified by a <p> The whenT function does exactly this: 3 <ref> [5; 4; 3; 2; 1] </ref>whenT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [5 1 ; 3 2 ; 2 1 ] 5.4 Resynchronising To convert a time-stamped stream back into a synchronous stream, we must "fill in" the time slots between values. <p> There are two choices for the missing values: i) a specified value, or ii) the most recent value. The time-stamped versions of the functions below use the resyncT function. f illH and f illT insert a specified value: f illH 0 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 0; 3; 4; 0; 0; 7; 0] f illT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 0; 3; 4; 0; 0; 7] holdH and holdT perform a zero-order hold. <p> The time-stamped versions of the functions below use the resyncT function. f illH and f illT insert a specified value: f illH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 0; 3; 4; 0; 0; 7; 0] </ref> f illT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 0; 3; 4; 0; 0; 7] holdH and holdT perform a zero-order hold. <p> use the resyncT function. f illH and f illT insert a specified value: f illH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1; 0; 3; 4; 0; 0; 7; 0] f illT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; 0; 3; 4; 0; 0; 7] </ref> holdH and holdT perform a zero-order hold. <p> The first argument specifies the value inserted into initial empty time slots: holdH 0 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 1; 3; 4; 4; 4; 7; 7] holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a <p> The first argument specifies the value inserted into initial empty time slots: holdH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 1; 3; 4; 4; 4; 7; 7] </ref> holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing <p> The first argument specifies the value inserted into initial empty time slots: holdH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1; 1; 3; 4; 4; 4; 7; 7] holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; 1; 3; 4; 4; 4; 7] </ref> 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1; 3; 4; 7] desyncT [1 <p> holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 3; 4; 7] desyncT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view <p> ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 3; 4; 7] </ref> desyncT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view this as producing a true asynchronous stream. 8 5.6 Converting <p> the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 3; 4; 7] </ref> desyncT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view this as producing a true asynchronous stream. 8 5.6 Converting stamp converts a hiatonic stream to a stamped stream, while unstamp does the reverse: stamp [1; fl; 3; <p> ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view this as producing a true asynchronous stream. 8 5.6 Converting stamp converts a hiatonic stream to a stamped stream, while unstamp does the reverse: stamp <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1 1 ; 3 2 ; 4 1 ; 7 3 ] unstamp [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; fl; 3; 4; fl; fl; 7] fl Notice that these functions are not quite <p> converts a hiatonic stream to a stamped stream, while unstamp does the reverse: stamp [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1 1 ; 3 2 ; 4 1 ; 7 3 ] unstamp [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; fl; 3; 4; fl; fl; 7] </ref> fl Notice that these functions are not quite inverses of each other, since stamp unstamp = id but unstamp stamp 6= id: This raises an interesting question. <p> The lists <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl and [1; fl; 3; 4; fl; fl; 7] fl are clearly not the same (the former has an extra empty time slot at the end). <p> 7 3 ] ) <ref> [1; fl; 3; 4; fl; fl; 7] </ref> fl Notice that these functions are not quite inverses of each other, since stamp unstamp = id but unstamp stamp 6= id: This raises an interesting question. The lists [1; fl; 3; 4; fl; fl; 7; fl] fl and [1; fl; 3; 4; fl; fl; 7] fl are clearly not the same (the former has an extra empty time slot at the end). <p> Up-sampling is easy, since it is just a matter of inserting extra hiatons or scaling the time-stamps: upsampleH 2 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; fl; fl; fl; 3; fl; 4; fl; fl; fl; fl; fl; 7; fl; fl; fl] upsampleT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1 1 ; 3 4 ; 4 2 ; 7 6 <p> This process effectively spawns a new process each time it receives a value. For example, nested [(3; 4) 1 ; (7; 4) 2 ] ) <ref> [[3; 3; 3; 3] </ref> 1 ; [7; 7; 7; 7] 2 ] Since each stream within the (time-stamped) output stream is synchronous, their values overlap in time as follows: Time slot 0 1 2 3 4 5 --------------------- Values 3 3 3 3 7 7 7 7 One way of making <p> The function combineT accepts a function argument; at each tick, this function is applied to a list containing the front elements of all synchronous streams active at that time. For example, 5 combineT sum 0 <ref> [[3; 3; 3; 3] </ref> 1 ; [7; 7; 7; 7] 2 ] ) [3; 3; 10; 10; 7; 7] nested used mapT to generate a nested stream. Sometimes, however, it is necessary to know both the value at that time, and the rest of the input stream. <p> The function combineT accepts a function argument; at each tick, this function is applied to a list containing the front elements of all synchronous streams active at that time. For example, 5 combineT sum 0 [[3; 3; 3; 3] 1 ; [7; 7; 7; 7] 2 ] ) <ref> [3; 3; 10; 10; 7; 7] </ref> nested used mapT to generate a nested stream. Sometimes, however, it is necessary to know both the value at that time, and the rest of the input stream. <p> is the starting value with which it compares the first value in the stream. &gt; edges :: (Eq a) =&gt; a -&gt; [a] -&gt; [Slot a] &gt; edges a = mapH snd . selectH neq . pairs a where &gt; neq (x,y) = x /= y For example, edges 0 <ref> [1; 1; 3; 4; 4; 4; 7; 7] </ref> ) [1; fl; 3; 4; fl; fl; 7; fl] fl The pairs function used above combines adjacent elements of a stream into pairs (see Appendix C): pairs 0 [1; 1; 3; 4; 4; 4; 7; 7] ) [(0; 1); (1; 1); (1; 3); <p> first value in the stream. &gt; edges :: (Eq a) =&gt; a -&gt; [a] -&gt; [Slot a] &gt; edges a = mapH snd . selectH neq . pairs a where &gt; neq (x,y) = x /= y For example, edges 0 [1; 1; 3; 4; 4; 4; 7; 7] ) <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl The pairs function used above combines adjacent elements of a stream into pairs (see Appendix C): pairs 0 [1; 1; 3; 4; 4; 4; 7; 7] ) [(0; 1); (1; 1); (1; 3); (3; 4); (4; 4); (4; 4); (4; 7); (7; <p> pairs a where &gt; neq (x,y) = x /= y For example, edges 0 <ref> [1; 1; 3; 4; 4; 4; 7; 7] </ref> ) [1; fl; 3; 4; fl; fl; 7; fl] fl The pairs function used above combines adjacent elements of a stream into pairs (see Appendix C): pairs 0 [1; 1; 3; 4; 4; 4; 7; 7] ) [(0; 1); (1; 1); (1; 3); (3; 4); (4; 4); (4; 4); (4; 7); (7; 7)] 6.2 Detecting zero crossings Detecting the zero-crossings of a signal is a simple but useful operation. <p> For example, encode <ref> [0; 1; 2; 2; 2; 0; 2; 3; 3; 3; 3] </ref> ) [0 1 ; 1 1 ; 0 2 ; 2 2 ; 1 2 ; 0 1 ] The signal can be re-assembled by doing a zero-order interpolation and then integrating: &gt; decode :: (Num a) =&gt; [Stamp a] <p> re-assembled by doing a zero-order interpolation and then integrating: &gt; decode :: (Num a) =&gt; [Stamp a] -&gt; [a] &gt; decode = prefl (+) 0 . holdT 0 For example, decode [0 1 ; 1 1 ; 0 2 ; 2 2 ; 1 2 ; 0 1 ] ) <ref> [0; 1; 2; 2; 2; 0; 2; 3; 3] </ref> Notice that the final segment has been thrown away, because there is no end marker produced when the differential stream is time-stamped. 6.4 Down-sampling Earlier, I postponed the definitions of functions to down-sample asynchronous streams. <p> is defined in terms of the hiatonic stream function; this implies a large ineffiency if the items occur infrequently: &gt; downsampleT :: Int -&gt; ([a] -&gt; a) -&gt; [Stamp a] -&gt; [Stamp a] &gt; downsampleT k choose = stamp . downsampleH k choose . unstamp For example, downsampleH 2 head <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 3; fl; 7] fl downsampleT 2 head [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1 1 ; 3 1 ; 7 2 ] 6.5 Filtering asynchronous signals One of the reason cited earlier for <p> implies a large ineffiency if the items occur infrequently: &gt; downsampleT :: Int -&gt; ([a] -&gt; a) -&gt; [Stamp a] -&gt; [Stamp a] &gt; downsampleT k choose = stamp . downsampleH k choose . unstamp For example, downsampleH 2 head [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 3; fl; 7] </ref> fl downsampleT 2 head [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1 1 ; 3 1 ; 7 2 ] 6.5 Filtering asynchronous signals One of the reason cited earlier for asynchronous streams was to allow meaningful filtering of non-uniformly sampled
Reference: [4] <editor> Paul Hudak et al. </editor> <title> Report on the functional programming language Haskell, a non-strict purely-functional language, version 1.2. </title> <journal> SIGPLAN Notices, </journal> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Lazy functional languages such as Haskell <ref> [4] </ref> support infinite data structures. Infinite sequences are the most commonly-used of such structures, and are a natural choice for modelling discrete-time signals. These are often called "streams." With streams, it is straight-forward to construct networks of processes [7, 12]. <p> The source of this paper is a literate Gofer script|that is, it can be executed by the Gofer interpreter as-is. Lines beginning with "&gt;" are program code. 2 Stream Basics In this paper, a stream is represented by a lazy list, written e.g. <ref> [1; 2; 3; 4; 5; 6; 7] </ref>. (Although this is a finite list, lists can be infinite.) A list containing elements of type a has the type [a]. Functions on lists are best described by example. <p> Pattern-matching is used to bind the head and tail of the list to the variables x and xs. map is applied to a list as follows: map (+1) <ref> [1; 3; 4; 7] </ref> ) [2; 4; 5; 8] where ) means "evaluates to." The expression map (+1) thus represents a process that adds one to each input element. <p> Pattern-matching is used to bind the head and tail of the list to the variables x and xs. map is applied to a list as follows: map (+1) [1; 3; 4; 7] ) <ref> [2; 4; 5; 8] </ref> where ) means "evaluates to." The expression map (+1) thus represents a process that adds one to each input element. <p> We may choose to define it as a named function: &gt; incproc :: (Num a) =&gt; [a] -&gt; [a] &gt; incproc = map (+1) The type constraint (N um a) specifies that a must be a type in the hierarchy of numerical types. See <ref> [4] </ref> for details. <p> An example of the use of zipW ith is: zipW ith (+) <ref> [1; 3; 4; 7] </ref> [1; 2; 3; 4] ) [2; 5; 7; 11] A fourth useful function is called pref l 1 , for "prefix-from-left." &gt; prefl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a] &gt; prefl f a [] = [] &gt; prefl f a (x:xs) <p> An example of the use of zipW ith is: zipW ith (+) [1; 3; 4; 7] <ref> [1; 2; 3; 4] </ref> ) [2; 5; 7; 11] A fourth useful function is called pref l 1 , for "prefix-from-left." &gt; prefl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a] &gt; prefl f a [] = [] &gt; prefl f a (x:xs) = q : prefl <p> However, the function argument f is applied to an input value and the previous output value, instead of just to the input value. For example, pref l (+) 0 <ref> [1; 3; 4; 7] </ref> ) [1; 4; 8; 15] A third function, f ilter, removes items of a list that do not satisfy a predicate: filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs <p> However, the function argument f is applied to an input value and the previous output value, instead of just to the input value. For example, pref l (+) 0 [1; 3; 4; 7] ) <ref> [1; 4; 8; 15] </ref> A third function, f ilter, removes items of a list that do not satisfy a predicate: filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p <p> f ilter, removes items of a list that do not satisfy a predicate: filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p xs For example, f ilter odd <ref> [1; 3; 4; 7] </ref> ) [1; 3; 7] An introduction to functional programming can be found in [3] or [5]. 1 prefl is very similar to Haskell's scanl: prefl f a = tail scanl f a. <p> A hiatonic stream is a list of these "slots," type [Slot a]. An example of a hiatonic stream is: &gt; hiatonic = [ Val 1, Hiaton, Val 3, Val 4, &gt; Hiaton, Hiaton, Val 7, Hiaton ] :: [Slot Int] for which I use the short-hand representation <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl : For implementation in a real-time context, it will be necessary to "hide" the hiatons from the programmer, and provide the programmer access to hiatonic streams only through the functions of an abstract data type (ADT). <p> function is defined as follows: &gt; mapH :: (a -&gt; b) -&gt; [Slot a] -&gt; [Slot b] &gt; mapH f [] = [] &gt; mapH f (Hiaton:xs) = Hiaton : mapH f xs &gt; mapH f ((Val x):xs) = Val (f x) : mapH f xs For example, mapH (+1) <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [2; fl; 4; 5; fl; fl; 8; fl] fl The asynchronous equivalent of pref l also produces an output value only for each input value: 5 &gt; preflH :: (a -&gt; b -&gt; a) -&gt; a -&gt; [Slot b] -&gt; [Slot <p> b) -&gt; [Slot a] -&gt; [Slot b] &gt; mapH f [] = [] &gt; mapH f (Hiaton:xs) = Hiaton : mapH f xs &gt; mapH f ((Val x):xs) = Val (f x) : mapH f xs For example, mapH (+1) [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [2; fl; 4; 5; fl; fl; 8; fl] </ref> fl The asynchronous equivalent of pref l also produces an output value only for each input value: 5 &gt; preflH :: (a -&gt; b -&gt; a) -&gt; a -&gt; [Slot b] -&gt; [Slot a] &gt; preflH f a [] = [] &gt; preflH <p> a] &gt; preflH f a [] = [] &gt; preflH f a (Hiaton : xs) = Hiaton : preflH f a xs &gt; preflH f a (Val x : xs) = Val y : preflH f y xs where y = f a x For example, pref lH (+) 0 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; fl; 4; 8; fl; fl; 15; fl] fl 4.2 Time-stamped Streams In a hiatonic stream, non-value time slots are marked with a special value. In effect, hiatonic streams are still synchronous. <p> f a (Hiaton : xs) = Hiaton : preflH f a xs &gt; preflH f a (Val x : xs) = Val y : preflH f y xs where y = f a x For example, pref lH (+) 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; fl; 4; 8; fl; fl; 15; fl] </ref> fl 4.2 Time-stamped Streams In a hiatonic stream, non-value time slots are marked with a special value. In effect, hiatonic streams are still synchronous. An alternative representation pairs each value with a "time-stamp," which denotes the time at which the value occurs. <p> Versions of f ilter that do preserve time information could either a) take a synchronous stream and produce an asynchronous stream, or b) take an asynchronous stream and produce another asynchronous stream. selectH and selectT produce an asynchronous stream from a synchronous stream: selectH odd <ref> [1; 2; 3; 4; 5] </ref> ) [1; fl; 3; fl; 5] fl selectT odd [1; 2; 3; 4; 5] ) [1 1 ; 3 2 ; 5 2 ] We can also define functions that remove unwanted elements from asynchronous streams (see f ilterH and f ilterT in Appendix B). 7 <p> could either a) take a synchronous stream and produce an asynchronous stream, or b) take an asynchronous stream and produce another asynchronous stream. selectH and selectT produce an asynchronous stream from a synchronous stream: selectH odd <ref> [1; 2; 3; 4; 5] </ref> ) [1; fl; 3; fl; 5] fl selectT odd [1; 2; 3; 4; 5] ) [1 1 ; 3 2 ; 5 2 ] We can also define functions that remove unwanted elements from asynchronous streams (see f ilterH and f ilterT in Appendix B). 7 5.3 Sampling A synchronous stream can be "sampled" at time instants specified by a <p> The whenT function does exactly this: 3 <ref> [5; 4; 3; 2; 1] </ref>whenT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [5 1 ; 3 2 ; 2 1 ] 5.4 Resynchronising To convert a time-stamped stream back into a synchronous stream, we must "fill in" the time slots between values. <p> There are two choices for the missing values: i) a specified value, or ii) the most recent value. The time-stamped versions of the functions below use the resyncT function. f illH and f illT insert a specified value: f illH 0 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 0; 3; 4; 0; 0; 7; 0] f illT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 0; 3; 4; 0; 0; 7] holdH and holdT perform a zero-order hold. <p> The time-stamped versions of the functions below use the resyncT function. f illH and f illT insert a specified value: f illH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 0; 3; 4; 0; 0; 7; 0] </ref> f illT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 0; 3; 4; 0; 0; 7] holdH and holdT perform a zero-order hold. <p> use the resyncT function. f illH and f illT insert a specified value: f illH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1; 0; 3; 4; 0; 0; 7; 0] f illT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; 0; 3; 4; 0; 0; 7] </ref> holdH and holdT perform a zero-order hold. <p> The first argument specifies the value inserted into initial empty time slots: holdH 0 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 1; 3; 4; 4; 4; 7; 7] holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a <p> The first argument specifies the value inserted into initial empty time slots: holdH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 1; 3; 4; 4; 4; 7; 7] </ref> holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing <p> The first argument specifies the value inserted into initial empty time slots: holdH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1; 1; 3; 4; 4; 4; 7; 7] holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; 1; 3; 4; 4; 4; 7] </ref> 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1; 3; 4; 7] desyncT [1 <p> holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 3; 4; 7] desyncT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view <p> ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 3; 4; 7] </ref> desyncT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view this as producing a true asynchronous stream. 8 5.6 Converting <p> the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 3; 4; 7] </ref> desyncT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view this as producing a true asynchronous stream. 8 5.6 Converting stamp converts a hiatonic stream to a stamped stream, while unstamp does the reverse: stamp [1; fl; 3; <p> ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view this as producing a true asynchronous stream. 8 5.6 Converting stamp converts a hiatonic stream to a stamped stream, while unstamp does the reverse: stamp <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1 1 ; 3 2 ; 4 1 ; 7 3 ] unstamp [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; fl; 3; 4; fl; fl; 7] fl Notice that these functions are not quite <p> converts a hiatonic stream to a stamped stream, while unstamp does the reverse: stamp [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1 1 ; 3 2 ; 4 1 ; 7 3 ] unstamp [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; fl; 3; 4; fl; fl; 7] </ref> fl Notice that these functions are not quite inverses of each other, since stamp unstamp = id but unstamp stamp 6= id: This raises an interesting question. <p> The lists <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl and [1; fl; 3; 4; fl; fl; 7] fl are clearly not the same (the former has an extra empty time slot at the end). <p> 7 3 ] ) <ref> [1; fl; 3; 4; fl; fl; 7] </ref> fl Notice that these functions are not quite inverses of each other, since stamp unstamp = id but unstamp stamp 6= id: This raises an interesting question. The lists [1; fl; 3; 4; fl; fl; 7; fl] fl and [1; fl; 3; 4; fl; fl; 7] fl are clearly not the same (the former has an extra empty time slot at the end). <p> Up-sampling is easy, since it is just a matter of inserting extra hiatons or scaling the time-stamps: upsampleH 2 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; fl; fl; fl; 3; fl; 4; fl; fl; fl; fl; fl; 7; fl; fl; fl] upsampleT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1 1 ; 3 4 ; 4 2 ; 7 6 <p> is the starting value with which it compares the first value in the stream. &gt; edges :: (Eq a) =&gt; a -&gt; [a] -&gt; [Slot a] &gt; edges a = mapH snd . selectH neq . pairs a where &gt; neq (x,y) = x /= y For example, edges 0 <ref> [1; 1; 3; 4; 4; 4; 7; 7] </ref> ) [1; fl; 3; 4; fl; fl; 7; fl] fl The pairs function used above combines adjacent elements of a stream into pairs (see Appendix C): pairs 0 [1; 1; 3; 4; 4; 4; 7; 7] ) [(0; 1); (1; 1); (1; 3); <p> first value in the stream. &gt; edges :: (Eq a) =&gt; a -&gt; [a] -&gt; [Slot a] &gt; edges a = mapH snd . selectH neq . pairs a where &gt; neq (x,y) = x /= y For example, edges 0 [1; 1; 3; 4; 4; 4; 7; 7] ) <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl The pairs function used above combines adjacent elements of a stream into pairs (see Appendix C): pairs 0 [1; 1; 3; 4; 4; 4; 7; 7] ) [(0; 1); (1; 1); (1; 3); (3; 4); (4; 4); (4; 4); (4; 7); (7; <p> pairs a where &gt; neq (x,y) = x /= y For example, edges 0 <ref> [1; 1; 3; 4; 4; 4; 7; 7] </ref> ) [1; fl; 3; 4; fl; fl; 7; fl] fl The pairs function used above combines adjacent elements of a stream into pairs (see Appendix C): pairs 0 [1; 1; 3; 4; 4; 4; 7; 7] ) [(0; 1); (1; 1); (1; 3); (3; 4); (4; 4); (4; 4); (4; 7); (7; 7)] 6.2 Detecting zero crossings Detecting the zero-crossings of a signal is a simple but useful operation. <p> is defined in terms of the hiatonic stream function; this implies a large ineffiency if the items occur infrequently: &gt; downsampleT :: Int -&gt; ([a] -&gt; a) -&gt; [Stamp a] -&gt; [Stamp a] &gt; downsampleT k choose = stamp . downsampleH k choose . unstamp For example, downsampleH 2 head <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 3; fl; 7] fl downsampleT 2 head [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1 1 ; 3 1 ; 7 2 ] 6.5 Filtering asynchronous signals One of the reason cited earlier for
Reference: [5] <author> Mark Jones. </author> <title> An Introduction to Gofer, </title> <note> version 2.21 edition, 1991. The source code and documentation for Gofer is available by anonymous ftp from dcs.glasgow.ac.uk. </note>
Reference-contexts: A number of examples illustrate the use of these functions, and I conclude with some thoughts on implementation in a real-time context. 1.1 A note on notation The code in this paper is executable by the Gofer <ref> [5] </ref> interpreter. Gofer is very similar to Haskell, and the code will require only one or two minor changes to be compiled by a Haskell compiler. The source of this paper is a literate Gofer script|that is, it can be executed by the Gofer interpreter as-is. <p> The source of this paper is a literate Gofer script|that is, it can be executed by the Gofer interpreter as-is. Lines beginning with "&gt;" are program code. 2 Stream Basics In this paper, a stream is represented by a lazy list, written e.g. <ref> [1; 2; 3; 4; 5; 6; 7] </ref>. (Although this is a finite list, lists can be infinite.) A list containing elements of type a has the type [a]. Functions on lists are best described by example. <p> Pattern-matching is used to bind the head and tail of the list to the variables x and xs. map is applied to a list as follows: map (+1) [1; 3; 4; 7] ) <ref> [2; 4; 5; 8] </ref> where ) means "evaluates to." The expression map (+1) thus represents a process that adds one to each input element. <p> An example of the use of zipW ith is: zipW ith (+) [1; 3; 4; 7] [1; 2; 3; 4] ) <ref> [2; 5; 7; 11] </ref> A fourth useful function is called pref l 1 , for "prefix-from-left." &gt; prefl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a] &gt; prefl f a [] = [] &gt; prefl f a (x:xs) = q : prefl f q xs where q <p> [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p xs For example, f ilter odd [1; 3; 4; 7] ) [1; 3; 7] An introduction to functional programming can be found in [3] or <ref> [5] </ref>. 1 prefl is very similar to Haskell's scanl: prefl f a = tail scanl f a. I use this definition because scanl effectively inserts an unwanted delay in a signal. 3 3 Synchronous Streams As noted in the Introduction, streams are easily used to represent uniformly-sampled discrete-time signals. <p> b) -&gt; [Slot a] -&gt; [Slot b] &gt; mapH f [] = [] &gt; mapH f (Hiaton:xs) = Hiaton : mapH f xs &gt; mapH f ((Val x):xs) = Val (f x) : mapH f xs For example, mapH (+1) [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [2; fl; 4; 5; fl; fl; 8; fl] </ref> fl The asynchronous equivalent of pref l also produces an output value only for each input value: 5 &gt; preflH :: (a -&gt; b -&gt; a) -&gt; a -&gt; [Slot b] -&gt; [Slot a] &gt; preflH f a [] = [] &gt; preflH <p> Versions of f ilter that do preserve time information could either a) take a synchronous stream and produce an asynchronous stream, or b) take an asynchronous stream and produce another asynchronous stream. selectH and selectT produce an asynchronous stream from a synchronous stream: selectH odd <ref> [1; 2; 3; 4; 5] </ref> ) [1; fl; 3; fl; 5] fl selectT odd [1; 2; 3; 4; 5] ) [1 1 ; 3 2 ; 5 2 ] We can also define functions that remove unwanted elements from asynchronous streams (see f ilterH and f ilterT in Appendix B). 7 <p> of f ilter that do preserve time information could either a) take a synchronous stream and produce an asynchronous stream, or b) take an asynchronous stream and produce another asynchronous stream. selectH and selectT produce an asynchronous stream from a synchronous stream: selectH odd [1; 2; 3; 4; 5] ) <ref> [1; fl; 3; fl; 5] </ref> fl selectT odd [1; 2; 3; 4; 5] ) [1 1 ; 3 2 ; 5 2 ] We can also define functions that remove unwanted elements from asynchronous streams (see f ilterH and f ilterT in Appendix B). 7 5.3 Sampling A synchronous stream can <p> could either a) take a synchronous stream and produce an asynchronous stream, or b) take an asynchronous stream and produce another asynchronous stream. selectH and selectT produce an asynchronous stream from a synchronous stream: selectH odd <ref> [1; 2; 3; 4; 5] </ref> ) [1; fl; 3; fl; 5] fl selectT odd [1; 2; 3; 4; 5] ) [1 1 ; 3 2 ; 5 2 ] We can also define functions that remove unwanted elements from asynchronous streams (see f ilterH and f ilterT in Appendix B). 7 5.3 Sampling A synchronous stream can be "sampled" at time instants specified by a <p> The whenT function does exactly this: 3 <ref> [5; 4; 3; 2; 1] </ref>whenT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [5 1 ; 3 2 ; 2 1 ] 5.4 Resynchronising To convert a time-stamped stream back into a synchronous stream, we must "fill in" the time slots between values. <p> x a &gt; resyncT f g a (Stamp t x : xs ) &gt; = y : resyncT f g y (Stamp (t-1) x : xs) where y = g a For example, resyncT (+) (+1) 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; 2; 5; 9; 10; 11; 18] </ref> When we convert an asynchronous stream back into a synchronous stream, we must fill in the empty time slots. There are two choices for the missing values: i) a specified value, or ii) the most recent value.
Reference: [6] <editor> Simon L. Peyton Jones. </editor> <booktitle> The Implementaion of Functional Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: The source of this paper is a literate Gofer script|that is, it can be executed by the Gofer interpreter as-is. Lines beginning with "&gt;" are program code. 2 Stream Basics In this paper, a stream is represented by a lazy list, written e.g. <ref> [1; 2; 3; 4; 5; 6; 7] </ref>. (Although this is a finite list, lists can be infinite.) A list containing elements of type a has the type [a]. Functions on lists are best described by example.
Reference: [7] <author> Paul Kelly. </author> <title> Functional Programming for Loosely-coupled Multiprocessors. </title> <booktitle> Reasearch Monographs in Parallel and Distributed Computing. </booktitle> <publisher> Pitman Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Lazy functional languages such as Haskell [4] support infinite data structures. Infinite sequences are the most commonly-used of such structures, and are a natural choice for modelling discrete-time signals. These are often called "streams." With streams, it is straight-forward to construct networks of processes <ref> [7, 12] </ref>. These networks can also be viewed as large-grain dataflow graphs [8], which is more in tune with the viewpoint of signal processing computation. <p> The source of this paper is a literate Gofer script|that is, it can be executed by the Gofer interpreter as-is. Lines beginning with "&gt;" are program code. 2 Stream Basics In this paper, a stream is represented by a lazy list, written e.g. <ref> [1; 2; 3; 4; 5; 6; 7] </ref>. (Although this is a finite list, lists can be infinite.) A list containing elements of type a has the type [a]. Functions on lists are best described by example. <p> Pattern-matching is used to bind the head and tail of the list to the variables x and xs. map is applied to a list as follows: map (+1) <ref> [1; 3; 4; 7] </ref> ) [2; 4; 5; 8] where ) means "evaluates to." The expression map (+1) thus represents a process that adds one to each input element. <p> An example of the use of zipW ith is: zipW ith (+) <ref> [1; 3; 4; 7] </ref> [1; 2; 3; 4] ) [2; 5; 7; 11] A fourth useful function is called pref l 1 , for "prefix-from-left." &gt; prefl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a] &gt; prefl f a [] = [] &gt; prefl f a (x:xs) <p> An example of the use of zipW ith is: zipW ith (+) [1; 3; 4; 7] [1; 2; 3; 4] ) <ref> [2; 5; 7; 11] </ref> A fourth useful function is called pref l 1 , for "prefix-from-left." &gt; prefl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a] &gt; prefl f a [] = [] &gt; prefl f a (x:xs) = q : prefl f q xs where q <p> However, the function argument f is applied to an input value and the previous output value, instead of just to the input value. For example, pref l (+) 0 <ref> [1; 3; 4; 7] </ref> ) [1; 4; 8; 15] A third function, f ilter, removes items of a list that do not satisfy a predicate: filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs <p> f ilter, removes items of a list that do not satisfy a predicate: filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p xs For example, f ilter odd <ref> [1; 3; 4; 7] </ref> ) [1; 3; 7] An introduction to functional programming can be found in [3] or [5]. 1 prefl is very similar to Haskell's scanl: prefl f a = tail scanl f a. <p> a list that do not satisfy a predicate: filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p xs For example, f ilter odd [1; 3; 4; 7] ) <ref> [1; 3; 7] </ref> An introduction to functional programming can be found in [3] or [5]. 1 prefl is very similar to Haskell's scanl: prefl f a = tail scanl f a. <p> A hiatonic stream is a list of these "slots," type [Slot a]. An example of a hiatonic stream is: &gt; hiatonic = [ Val 1, Hiaton, Val 3, Val 4, &gt; Hiaton, Hiaton, Val 7, Hiaton ] :: [Slot Int] for which I use the short-hand representation <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl : For implementation in a real-time context, it will be necessary to "hide" the hiatons from the programmer, and provide the programmer access to hiatonic streams only through the functions of an abstract data type (ADT). <p> function is defined as follows: &gt; mapH :: (a -&gt; b) -&gt; [Slot a] -&gt; [Slot b] &gt; mapH f [] = [] &gt; mapH f (Hiaton:xs) = Hiaton : mapH f xs &gt; mapH f ((Val x):xs) = Val (f x) : mapH f xs For example, mapH (+1) <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [2; fl; 4; 5; fl; fl; 8; fl] fl The asynchronous equivalent of pref l also produces an output value only for each input value: 5 &gt; preflH :: (a -&gt; b -&gt; a) -&gt; a -&gt; [Slot b] -&gt; [Slot <p> a] &gt; preflH f a [] = [] &gt; preflH f a (Hiaton : xs) = Hiaton : preflH f a xs &gt; preflH f a (Val x : xs) = Val y : preflH f y xs where y = f a x For example, pref lH (+) 0 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; fl; 4; 8; fl; fl; 15; fl] fl 4.2 Time-stamped Streams In a hiatonic stream, non-value time slots are marked with a special value. In effect, hiatonic streams are still synchronous. <p> There are two choices for the missing values: i) a specified value, or ii) the most recent value. The time-stamped versions of the functions below use the resyncT function. f illH and f illT insert a specified value: f illH 0 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 0; 3; 4; 0; 0; 7; 0] f illT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 0; 3; 4; 0; 0; 7] holdH and holdT perform a zero-order hold. <p> The time-stamped versions of the functions below use the resyncT function. f illH and f illT insert a specified value: f illH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 0; 3; 4; 0; 0; 7; 0] </ref> f illT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 0; 3; 4; 0; 0; 7] holdH and holdT perform a zero-order hold. <p> use the resyncT function. f illH and f illT insert a specified value: f illH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1; 0; 3; 4; 0; 0; 7; 0] f illT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; 0; 3; 4; 0; 0; 7] </ref> holdH and holdT perform a zero-order hold. <p> The first argument specifies the value inserted into initial empty time slots: holdH 0 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 1; 3; 4; 4; 4; 7; 7] holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a <p> The first argument specifies the value inserted into initial empty time slots: holdH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 1; 3; 4; 4; 4; 7; 7] </ref> holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing <p> The first argument specifies the value inserted into initial empty time slots: holdH 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1; 1; 3; 4; 4; 4; 7; 7] holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; 1; 3; 4; 4; 4; 7] </ref> 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1; 3; 4; 7] desyncT [1 <p> holdT 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 3; 4; 7] desyncT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view <p> ; 7 3 ] ) [1; 1; 3; 4; 4; 4; 7] 5.5 Desynchronising If we longer need the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 3; 4; 7] </ref> desyncT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view this as producing a true asynchronous stream. 8 5.6 Converting <p> the timing information in a stream, we can discard it. desyncT and desyncH discard timing information, generating a normal list: 4 desyncH [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 3; 4; 7] </ref> desyncT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view this as producing a true asynchronous stream. 8 5.6 Converting stamp converts a hiatonic stream to a stamped stream, while unstamp does the reverse: stamp [1; fl; 3; <p> ] ) [1; 3; 4; 7] 3 The backquotes surroundingwhenTare Haskell's notation for infix operators: f x y = xfy. 4 We could perhaps view this as producing a true asynchronous stream. 8 5.6 Converting stamp converts a hiatonic stream to a stamped stream, while unstamp does the reverse: stamp <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1 1 ; 3 2 ; 4 1 ; 7 3 ] unstamp [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1; fl; 3; 4; fl; fl; 7] fl Notice that these functions are not quite <p> converts a hiatonic stream to a stamped stream, while unstamp does the reverse: stamp [1; fl; 3; 4; fl; fl; 7; fl] fl ) [1 1 ; 3 2 ; 4 1 ; 7 3 ] unstamp [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; fl; 3; 4; fl; fl; 7] </ref> fl Notice that these functions are not quite inverses of each other, since stamp unstamp = id but unstamp stamp 6= id: This raises an interesting question. <p> The lists <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl and [1; fl; 3; 4; fl; fl; 7] fl are clearly not the same (the former has an extra empty time slot at the end). <p> 7 3 ] ) <ref> [1; fl; 3; 4; fl; fl; 7] </ref> fl Notice that these functions are not quite inverses of each other, since stamp unstamp = id but unstamp stamp 6= id: This raises an interesting question. The lists [1; fl; 3; 4; fl; fl; 7; fl] fl and [1; fl; 3; 4; fl; fl; 7] fl are clearly not the same (the former has an extra empty time slot at the end). <p> Up-sampling is easy, since it is just a matter of inserting extra hiatons or scaling the time-stamps: upsampleH 2 <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; fl; fl; fl; 3; fl; 4; fl; fl; fl; fl; fl; 7; fl; fl; fl] upsampleT [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1 1 ; 3 4 ; 4 2 ; 7 6 <p> This process effectively spawns a new process each time it receives a value. For example, nested [(3; 4) 1 ; (7; 4) 2 ] ) [[3; 3; 3; 3] 1 ; <ref> [7; 7; 7; 7] </ref> 2 ] Since each stream within the (time-stamped) output stream is synchronous, their values overlap in time as follows: Time slot 0 1 2 3 4 5 --------------------- Values 3 3 3 3 7 7 7 7 One way of making use of these dynamically-created streams is <p> The function combineT accepts a function argument; at each tick, this function is applied to a list containing the front elements of all synchronous streams active at that time. For example, 5 combineT sum 0 [[3; 3; 3; 3] 1 ; <ref> [7; 7; 7; 7] </ref> 2 ] ) [3; 3; 10; 10; 7; 7] nested used mapT to generate a nested stream. Sometimes, however, it is necessary to know both the value at that time, and the rest of the input stream. <p> The function combineT accepts a function argument; at each tick, this function is applied to a list containing the front elements of all synchronous streams active at that time. For example, 5 combineT sum 0 [[3; 3; 3; 3] 1 ; [7; 7; 7; 7] 2 ] ) <ref> [3; 3; 10; 10; 7; 7] </ref> nested used mapT to generate a nested stream. Sometimes, however, it is necessary to know both the value at that time, and the rest of the input stream. <p> is the starting value with which it compares the first value in the stream. &gt; edges :: (Eq a) =&gt; a -&gt; [a] -&gt; [Slot a] &gt; edges a = mapH snd . selectH neq . pairs a where &gt; neq (x,y) = x /= y For example, edges 0 <ref> [1; 1; 3; 4; 4; 4; 7; 7] </ref> ) [1; fl; 3; 4; fl; fl; 7; fl] fl The pairs function used above combines adjacent elements of a stream into pairs (see Appendix C): pairs 0 [1; 1; 3; 4; 4; 4; 7; 7] ) [(0; 1); (1; 1); (1; 3); <p> first value in the stream. &gt; edges :: (Eq a) =&gt; a -&gt; [a] -&gt; [Slot a] &gt; edges a = mapH snd . selectH neq . pairs a where &gt; neq (x,y) = x /= y For example, edges 0 [1; 1; 3; 4; 4; 4; 7; 7] ) <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl The pairs function used above combines adjacent elements of a stream into pairs (see Appendix C): pairs 0 [1; 1; 3; 4; 4; 4; 7; 7] ) [(0; 1); (1; 1); (1; 3); (3; 4); (4; 4); (4; 4); (4; 7); (7; <p> pairs a where &gt; neq (x,y) = x /= y For example, edges 0 <ref> [1; 1; 3; 4; 4; 4; 7; 7] </ref> ) [1; fl; 3; 4; fl; fl; 7; fl] fl The pairs function used above combines adjacent elements of a stream into pairs (see Appendix C): pairs 0 [1; 1; 3; 4; 4; 4; 7; 7] ) [(0; 1); (1; 1); (1; 3); (3; 4); (4; 4); (4; 4); (4; 7); (7; 7)] 6.2 Detecting zero crossings Detecting the zero-crossings of a signal is a simple but useful operation. <p> is defined in terms of the hiatonic stream function; this implies a large ineffiency if the items occur infrequently: &gt; downsampleT :: Int -&gt; ([a] -&gt; a) -&gt; [Stamp a] -&gt; [Stamp a] &gt; downsampleT k choose = stamp . downsampleH k choose . unstamp For example, downsampleH 2 head <ref> [1; fl; 3; 4; fl; fl; 7; fl] </ref> fl ) [1; 3; fl; 7] fl downsampleT 2 head [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1 1 ; 3 1 ; 7 2 ] 6.5 Filtering asynchronous signals One of the reason cited earlier for <p> implies a large ineffiency if the items occur infrequently: &gt; downsampleT :: Int -&gt; ([a] -&gt; a) -&gt; [Stamp a] -&gt; [Stamp a] &gt; downsampleT k choose = stamp . downsampleH k choose . unstamp For example, downsampleH 2 head [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; 3; fl; 7] </ref> fl downsampleT 2 head [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) [1 1 ; 3 1 ; 7 2 ] 6.5 Filtering asynchronous signals One of the reason cited earlier for asynchronous streams was to allow meaningful filtering of non-uniformly sampled
Reference: [8] <author> Edward A. Lee and David G. Messerschmitt. </author> <title> Synchronous data flow. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 75(9) </volume> <pages> 1235-1245, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: Infinite sequences are the most commonly-used of such structures, and are a natural choice for modelling discrete-time signals. These are often called "streams." With streams, it is straight-forward to construct networks of processes [7, 12]. These networks can also be viewed as large-grain dataflow graphs <ref> [8] </ref>, which is more in tune with the viewpoint of signal processing computation. Although lazy lists are often used to model streams, a distinct Stream datatype can also be used to more clearly indicate the intended use of the data structure. In this paper, however, I use lazy lists. <p> Pattern-matching is used to bind the head and tail of the list to the variables x and xs. map is applied to a list as follows: map (+1) [1; 3; 4; 7] ) <ref> [2; 4; 5; 8] </ref> where ) means "evaluates to." The expression map (+1) thus represents a process that adds one to each input element. <p> However, the function argument f is applied to an input value and the previous output value, instead of just to the input value. For example, pref l (+) 0 [1; 3; 4; 7] ) <ref> [1; 4; 8; 15] </ref> A third function, f ilter, removes items of a list that do not satisfy a predicate: filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter p [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p <p> I use this definition because scanl effectively inserts an unwanted delay in a signal. 3 3 Synchronous Streams As noted in the Introduction, streams are easily used to represent uniformly-sampled discrete-time signals. Systems containing only uniformly-sampled discrete-time signals are also known as synchronous dataflow (SDF) systems in the literature <ref> [8] </ref>, so I will call these synchronous streams. Non-uniformly-sampled signals will therefore be called asynchronous streams. Streams with different sample rates can exist within the same system, provided that the relative rates of streams are consistent with the rates expected by processes that produce and consume them. <p> b) -&gt; [Slot a] -&gt; [Slot b] &gt; mapH f [] = [] &gt; mapH f (Hiaton:xs) = Hiaton : mapH f xs &gt; mapH f ((Val x):xs) = Val (f x) : mapH f xs For example, mapH (+1) [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [2; fl; 4; 5; fl; fl; 8; fl] </ref> fl The asynchronous equivalent of pref l also produces an output value only for each input value: 5 &gt; preflH :: (a -&gt; b -&gt; a) -&gt; a -&gt; [Slot b] -&gt; [Slot a] &gt; preflH f a [] = [] &gt; preflH <p> f a (Hiaton : xs) = Hiaton : preflH f a xs &gt; preflH f a (Val x : xs) = Val y : preflH f y xs where y = f a x For example, pref lH (+) 0 [1; fl; 3; 4; fl; fl; 7; fl] fl ) <ref> [1; fl; 4; 8; fl; fl; 15; fl] </ref> fl 4.2 Time-stamped Streams In a hiatonic stream, non-value time slots are marked with a special value. In effect, hiatonic streams are still synchronous. An alternative representation pairs each value with a "time-stamp," which denotes the time at which the value occurs. <p> In the context of stream-based programs, it may be possible to use this idea to enable efficient analysis and code generation techniques developed for dataflow programs <ref> [8, 2] </ref> to be applied to functional process network programs. Work on this idea is currently in progress.
Reference: [9] <author> H. John Reekie. </author> <title> Towards effective programming for parallel digital signal processing. </title> <type> Technical Report 92.1, </type> <institution> Key Centre for Advanced Computing Sciences, University of Technology, </institution> <address> Sydney, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: If, for example, a stream represents a uniformly-sampled, discrete-time signal, then elements of the stream are taken to occur at precisely-spaced instants. On this basis, it is simple to construct process networks that model real-time signal processing computations <ref> [9] </ref>. Although many signal processing applications can be constructed solely with uniformly-sampled signals, it is useful also to be able to model non-uniformly sampled signals. Streams representing signals of this type are called asynchronous streams. <p> x a &gt; resyncT f g a (Stamp t x : xs ) &gt; = y : resyncT f g y (Stamp (t-1) x : xs) where y = g a For example, resyncT (+) (+1) 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; 2; 5; 9; 10; 11; 18] </ref> When we convert an asynchronous stream back into a synchronous stream, we must fill in the empty time slots. There are two choices for the missing values: i) a specified value, or ii) the most recent value.
Reference: [10] <author> D.A. Turner. </author> <title> An approach to functional operating systems. In D.A. </title> <editor> Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, </booktitle> <pages> pages 199-218. </pages> <address> Addison-Welsey, </address> <year> 1990. </year>
Reference-contexts: To illustrate: a problem that occurs in proposed functional operating systems is that of merging two streams <ref> [10] </ref>. In this context, streams represent channels of communication between processes within the system. If two streams are merged in order of element arrival time, the same two input sequences will not always produce the same output sequence, because the arrival time of elements is in general non-deterministic. <p> x a &gt; resyncT f g a (Stamp t x : xs ) &gt; = y : resyncT f g y (Stamp (t-1) x : xs) where y = g a For example, resyncT (+) (+1) 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; 2; 5; 9; 10; 11; 18] </ref> When we convert an asynchronous stream back into a synchronous stream, we must fill in the empty time slots. There are two choices for the missing values: i) a specified value, or ii) the most recent value. <p> The function combineT accepts a function argument; at each tick, this function is applied to a list containing the front elements of all synchronous streams active at that time. For example, 5 combineT sum 0 [[3; 3; 3; 3] 1 ; [7; 7; 7; 7] 2 ] ) <ref> [3; 3; 10; 10; 7; 7] </ref> nested used mapT to generate a nested stream. Sometimes, however, it is necessary to know both the value at that time, and the rest of the input stream.
Reference: [11] <author> W. W. Wadge and A. Ashcroft. </author> <title> Lucid-the Dataflow Programming Language. </title> <publisher> Academic Press, </publisher> <year> 1985. </year>
Reference-contexts: An example of the use of zipW ith is: zipW ith (+) [1; 3; 4; 7] [1; 2; 3; 4] ) <ref> [2; 5; 7; 11] </ref> A fourth useful function is called pref l 1 , for "prefix-from-left." &gt; prefl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a] &gt; prefl f a [] = [] &gt; prefl f a (x:xs) = q : prefl f q xs where q <p> I use two methods for doing so: hiatonic streams, and time-stamped streams. 4.1 Hiatonic Streams A hiatonic stream represents a uniformly-sampled signal with "non-values"|that is, time instants that do not carry a meaningful value. These instants are called hiatons, a term suggested in <ref> [11] </ref>. The domain of any type to be carried by a hiatonic stream must be extended to include the special hiaton value. <p> x a &gt; resyncT f g a (Stamp t x : xs ) &gt; = y : resyncT f g y (Stamp (t-1) x : xs) where y = g a For example, resyncT (+) (+1) 0 [1 1 ; 3 2 ; 4 1 ; 7 3 ] ) <ref> [1; 2; 5; 9; 10; 11; 18] </ref> When we convert an asynchronous stream back into a synchronous stream, we must fill in the empty time slots. There are two choices for the missing values: i) a specified value, or ii) the most recent value.
Reference: [12] <author> A. Wallace, G. Michaelson, P. McAndrews, K Waugh, and W. Austin. </author> <title> Dynamic control and prototyping of parallel algorithms for intermediate and high-level vision. </title> <journal> IEEE Computer, </journal> <volume> 25(2), </volume> <month> February </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Lazy functional languages such as Haskell [4] support infinite data structures. Infinite sequences are the most commonly-used of such structures, and are a natural choice for modelling discrete-time signals. These are often called "streams." With streams, it is straight-forward to construct networks of processes <ref> [7, 12] </ref>. These networks can also be viewed as large-grain dataflow graphs [8], which is more in tune with the viewpoint of signal processing computation. <p> For a start, the unpredictable time and space behaviour of graph reduction [6]|the most common implementation technique for lazy functional languages|makes real-time execution impossible. A more immediately useful approach would be to view the Haskell functions presented here as a prototyping and simulation tool. <ref> [12] </ref>, for example, have used functional prototypes (written in the strict language SML) to model and to predict performance of parallel programs. By appropriate analysis or through programmer-supplied annotations that indicate strictness conditions, however, real-time implementation may be possible.
References-found: 12

