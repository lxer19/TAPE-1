URL: http://www.cs.washington.edu/homes/mock/papers/ap.ps
Refering-URL: http://www.cs.washington.edu/homes/mock/papers.html
Root-URL: 
Email: email: (phlipp j mock)@ira.uka.de  
Title: Data and Process Alignment in Modula-2*  
Author: Michael Philippsen and Markus U. Mock 
Address: D-7500 Karlsruhe, F.R.G.  
Affiliation: Universitat Karlsruhe Fakultat fur Informatik  
Abstract: In this paper we present a technique implemented in our optimizing compiler that enhances locality in a source-to-source transformation. Analysis of data access patterns and parallel operations leads to an arrangement graph. Processing of this graph reveals conflicting arrangements. Some assumptions and a heuristic based on dynamic programming enables the compiler to find the best alignment in logarithmic time. The technique has improved runtime performance on benchmarks by over 60%. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> American National Standards Institute, Inc., </institution> <address> Washington, D.C. </address> <month> ANSI, </month> <title> Programming Language Fortran Extended (Fortran 90). ANSI X3.198-1992, </title> <year> 1992. </year>
Reference-contexts: Some languages require an explicit mapping of the data onto the topology [16, 9, 14], others are more abstract and offer either sets of directives for the compiler or interactive or knowledge-based environments that help determine the alignment of array dimensions and mapping functions <ref> [3, 10, 7, 1, 2] </ref>. Recent work [5, 6, 4, 15, 8] focuses on static compile-time analysis to automatically find a data decomposition that achieves both goals for vector and data-parallel operations. Modula-2* [17] is designed for high-level, problem-oriented, and machine-independent parallel programming.
Reference: [2] <author> Barbara M. Chapman, Heinz Herbeck, and Hans P. Zima. </author> <title> Automatic support for data distribution. </title> <booktitle> In Proc. of the 6th Distributed Memory Computing Conference, </booktitle> <pages> pages 51-58, </pages> <address> Portland, Oregon, </address> <month> April 28 May 1, </month> <year> 1991. </year>
Reference-contexts: Some languages require an explicit mapping of the data onto the topology [16, 9, 14], others are more abstract and offer either sets of directives for the compiler or interactive or knowledge-based environments that help determine the alignment of array dimensions and mapping functions <ref> [3, 10, 7, 1, 2] </ref>. Recent work [5, 6, 4, 15, 8] focuses on static compile-time analysis to automatically find a data decomposition that achieves both goals for vector and data-parallel operations. Modula-2* [17] is designed for high-level, problem-oriented, and machine-independent parallel programming.
Reference: [3] <author> Geoffrey Fox, Seema Hiranandani, Ken Kennedy, Charles Koelbel, Uli Kremer, Chau-Wen Tseng, and Min-You Wu. </author> <title> Fortran D language specification. </title> <type> Technical Report CRPC-TR90079, </type> <institution> Center for Research on Parallel Computation, Rice University, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: Some languages require an explicit mapping of the data onto the topology [16, 9, 14], others are more abstract and offer either sets of directives for the compiler or interactive or knowledge-based environments that help determine the alignment of array dimensions and mapping functions <ref> [3, 10, 7, 1, 2] </ref>. Recent work [5, 6, 4, 15, 8] focuses on static compile-time analysis to automatically find a data decomposition that achieves both goals for vector and data-parallel operations. Modula-2* [17] is designed for high-level, problem-oriented, and machine-independent parallel programming.
Reference: [4] <author> Manish Gupta and Prithviraj Banerjee. </author> <title> Automatic data partitioning on distributed memory multiprocessors. </title> <booktitle> In Proc. of the 6th Distributed Memory Computing Conference, </booktitle> <pages> pages 43-50, </pages> <address> Portland, Oregon, </address> <month> April 28 May 1, </month> <year> 1991. </year>
Reference-contexts: Recent work <ref> [5, 6, 4, 15, 8] </ref> focuses on static compile-time analysis to automatically find a data decomposition that achieves both goals for vector and data-parallel operations. Modula-2* [17] is designed for high-level, problem-oriented, and machine-independent parallel programming.
Reference: [5] <author> Kathleen Knobe, Joan D. Lukas, and Guy L. Steele. </author> <title> Data optimization: Allocation of arrays to reduce communication on SIMD machines. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 8(2) </volume> <pages> 102-118, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: Recent work <ref> [5, 6, 4, 15, 8] </ref> focuses on static compile-time analysis to automatically find a data decomposition that achieves both goals for vector and data-parallel operations. Modula-2* [17] is designed for high-level, problem-oriented, and machine-independent parallel programming.
Reference: [6] <author> Kathleen Knobe and Venkataraman Natarajan. </author> <title> Data optimization: Minimizing residual interpro-cessor data motion on SIMD machines. </title> <booktitle> In Frontiers '90:The Third Symposium on the Frontiers of Massively Parallel Computation, </booktitle> <institution> College Park, University of Maryland, </institution> <month> October 8-10, </month> <year> 1990. </year>
Reference-contexts: Recent work <ref> [5, 6, 4, 15, 8] </ref> focuses on static compile-time analysis to automatically find a data decomposition that achieves both goals for vector and data-parallel operations. Modula-2* [17] is designed for high-level, problem-oriented, and machine-independent parallel programming. <p> Although data-parallel programming is possible, the notion of process is present. Therefore, both data and process distribution must be found by the compiler. In this paper we present our approach to derive both data and process distribution for Modula-2* programs. Our technique is based on the work of Knobe <ref> [6] </ref> but extends her ideas with the consideration of process distribution and the clear separation of high-level data arrangement and physical data layout. In section 2 we present the basic characteristics of Modula-2*. Section 3 explains the general approach of the Modula-2* compiler.
Reference: [7] <author> Charles Koelbel and Piyush Mehrotra. </author> <title> Supporting shared data structures and distributed memory architectures. </title> <booktitle> In Proc. of the 2nd ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 177-186, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Some languages require an explicit mapping of the data onto the topology [16, 9, 14], others are more abstract and offer either sets of directives for the compiler or interactive or knowledge-based environments that help determine the alignment of array dimensions and mapping functions <ref> [3, 10, 7, 1, 2] </ref>. Recent work [5, 6, 4, 15, 8] focuses on static compile-time analysis to automatically find a data decomposition that achieves both goals for vector and data-parallel operations. Modula-2* [17] is designed for high-level, problem-oriented, and machine-independent parallel programming.
Reference: [8] <author> Jingke Li and Marina Chen. </author> <title> Index domain alignment: Minimizing cost of cross-referencing between distributed arrays. </title> <booktitle> In Frontiers '90: The Third Symposium on the Frontiers of Massively Parallel Computation, </booktitle> <pages> pages 424-433, </pages> <institution> College Park, University of Maryland, </institution> <month> October 8-10, </month> <year> 1990. </year>
Reference-contexts: Recent work <ref> [5, 6, 4, 15, 8] </ref> focuses on static compile-time analysis to automatically find a data decomposition that achieves both goals for vector and data-parallel operations. Modula-2* [17] is designed for high-level, problem-oriented, and machine-independent parallel programming.
Reference: [9] <author> MasPar Computer Corporation. </author> <title> MasPar Parallel Application Language (MPL) Reference Manual, </title> <month> September </month> <year> 1990. </year>
Reference-contexts: Whereas the goals are agreed upon, totally different approaches to reach them have been developed. In many programming languages the user must explicitly provide the data layout. Some languages require an explicit mapping of the data onto the topology <ref> [16, 9, 14] </ref>, others are more abstract and offer either sets of directives for the compiler or interactive or knowledge-based environments that help determine the alignment of array dimensions and mapping functions [3, 10, 7, 1, 2].
Reference: [10] <author> Piyush Mehrotra and John Van Rosendale. </author> <title> The BLAZE language: A parallel language for scientific programming. </title> <journal> Parallel Computing, </journal> <volume> 5 </volume> <pages> 339-361, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Some languages require an explicit mapping of the data onto the topology [16, 9, 14], others are more abstract and offer either sets of directives for the compiler or interactive or knowledge-based environments that help determine the alignment of array dimensions and mapping functions <ref> [3, 10, 7, 1, 2] </ref>. Recent work [5, 6, 4, 15, 8] focuses on static compile-time analysis to automatically find a data decomposition that achieves both goals for vector and data-parallel operations. Modula-2* [17] is designed for high-level, problem-oriented, and machine-independent parallel programming.
Reference: [11] <author> Markus U. Mock. </author> <title> Alignment in Modula-2*. </title> <type> Master's thesis, </type> <institution> University of Karlsruhe, Department of Informatics, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: The run-time of IF- and CASE-statements can be improved if different data arrangements are chosen for different branches. To exploit this possibility, the algorithm considers dynamic array redistribution that ensures the unification of different data arrangements after the branching statements. Details can be found in <ref> [11] </ref>. 6 Example Consider the following code fragment: FORALL i : [1..N] IN SYNC A [i+1] := T [i] + C [i]; A [i+i] := T [i+1] + D [i]; END The data alignment analysis (see section 4.2.1) returns two possible patterns: ALIGN (C,1,1,0) WITH (T,1,1,0) ALIGN (C,1,1,0) WITH (A,1,1,1) ALIGN
Reference: [12] <author> Michael Philippsen. </author> <title> Automatic data distribution for nearest neighbor networks. </title> <booktitle> In Frontiers '92:The Fourth Symposium on the Frontiers of Massively Parallel Computation, </booktitle> <pages> pages 178-185, </pages> <address> Mc Lean, Virginia, </address> <month> October 19-21, </month> <year> 1992. </year>
Reference-contexts: For the second phase we have developed an adequate layout algorithm <ref> [12] </ref> that maps arrays onto the machine depending on their declarations. <p> In the second phase, the layout algorithm maps both arrays to the available processors in the same way. Since both arrays have the same declaration, elements with the same index end up in the same processor. Our layout algorithm, which is described in <ref> [12] </ref>, reaches the following goals: (a) Exploit fast communication patterns if there is special hardware support, e.g. nearest-neighbor networks. (b) Perform simple address calculations.
Reference: [13] <author> Michael Philippsen and Walter F. Tichy. </author> <title> Modula-2* and its compilation. </title> <booktitle> In First International Conference of the Austrian Center for Parallel Computation, </booktitle> <address> Salzburg, Austria, </address> <year> 1991, </year> <pages> pages 169-183. </pages> <publisher> Springer Verlag, Lecture Notes in Computer Science 591, </publisher> <year> 1992. </year>
Reference-contexts: Locality is achieved by applying the owner-computes rule to distribute the statement execution onto the processors accordingly. Modula-2*, however, is not a purely data-parallel programming language. When designing Modula-2*, we wanted to preserve the main advantages of data-parallel languages while avoiding the drawbacks <ref> [13] </ref>. Although data-parallel programming is possible, the notion of process is present. Therefore, both data and process distribution must be found by the compiler. In this paper we present our approach to derive both data and process distribution for Modula-2* programs.
Reference: [14] <editor> Prentice Hall, </editor> <address> Englewood Cliffs, New Jersey. </address> <note> INMOS Limited: Occam Programming Manual, </note> <year> 1984. </year>
Reference-contexts: Whereas the goals are agreed upon, totally different approaches to reach them have been developed. In many programming languages the user must explicitly provide the data layout. Some languages require an explicit mapping of the data onto the topology <ref> [16, 9, 14] </ref>, others are more abstract and offer either sets of directives for the compiler or interactive or knowledge-based environments that help determine the alignment of array dimensions and mapping functions [3, 10, 7, 1, 2].
Reference: [15] <author> J. Ramanujam and P. Sadayappan. </author> <title> Access based data decomposition for distributed memory machines. </title> <booktitle> In Proc. of the 6th Distributed Memory Computing Conference, </booktitle> <pages> pages 196-199, </pages> <address> Portland, Oregon, </address> <month> April 28 May 1, </month> <year> 1991. </year>
Reference-contexts: Recent work <ref> [5, 6, 4, 15, 8] </ref> focuses on static compile-time analysis to automatically find a data decomposition that achieves both goals for vector and data-parallel operations. Modula-2* [17] is designed for high-level, problem-oriented, and machine-independent parallel programming.
Reference: [16] <institution> Thinking Machines Corporation, Cambridge, Massachusetts. </institution> <note> C* Language Reference Manual, </note> <month> April </month> <year> 1991. </year>
Reference-contexts: Whereas the goals are agreed upon, totally different approaches to reach them have been developed. In many programming languages the user must explicitly provide the data layout. Some languages require an explicit mapping of the data onto the topology <ref> [16, 9, 14] </ref>, others are more abstract and offer either sets of directives for the compiler or interactive or knowledge-based environments that help determine the alignment of array dimensions and mapping functions [3, 10, 7, 1, 2].
Reference: [17] <author> Walter F. Tichy and Christian G. Herter. </author> <title> Modula-2*: An extension of Modula-2 for highly parallel, portable programs. </title> <type> Technical Report No. 4/90, </type> <institution> University of Karlsruhe, Department of Informatics, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: Recent work [5, 6, 4, 15, 8] focuses on static compile-time analysis to automatically find a data decomposition that achieves both goals for vector and data-parallel operations. Modula-2* <ref> [17] </ref> is designed for high-level, problem-oriented, and machine-independent parallel programming. The programmer can focus on the problem he has to solve, abstracting from the available number of processors and the interconnection network. Therefore, the compiler has to determine an appropriate data and process distribution. <p> In sections 4 and 5 we give some more details on the alignment graphs, the conflict detection, and the heuristic search mechanism. 2 Modula-2* The programming language Modula-2* was developed to allow for high-level, problem-oriented and machine-independent parallel programming. As described in <ref> [17] </ref>, it provides the following features: * An arbitrary number of processes operate on data in the same single address space. <p> This means that Modula-2* does not require any synchronization between different branches of synchronous CASE or IF statements. The exact synchronous semantics of all Modula-2* statements, including nested FORALLs, are defined in <ref> [17] </ref>. 2.2 Allocation of array data Modula-2* provides a simple, machine-independent construct for controlling the allocation of array data. This construct is optional and does not change the meaning of a program.
References-found: 17

