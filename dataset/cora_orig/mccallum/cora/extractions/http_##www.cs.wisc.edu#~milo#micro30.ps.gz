URL: http://www.cs.wisc.edu/~milo/micro30.ps.gz
Refering-URL: http://www.cs.wisc.edu/~milo/micro30.html
Root-URL: 
Email: fischerg@cs.wisc.edu  
Title: Exploiting Dead Value Information  
Author: Milo M. Martin, Amir Roth, and Charles N. Fischer fmilo, amir, 
Address: Madison, WI 53706  
Affiliation: Computer Sciences Department University of Wisconsin  
Abstract: We describe Dead Value Information (DVI) and introduce three new optimizations which exploit it. DVI provides assertions that certain register values are dead, meaning they will not be read before being overwritten. The processor can use DVI to track dead registers and dynamically eliminate unnecessary save and restore instructions from the execution stream at procedure calls and context switches. Our results indicate that dynamic saves and restore instances can be reduced by 46% for procedure calls and by 51% for context switches. In addition, save/restore elimination for procedure calls can improve overall performance by up to 5%. DVI also allows the processor manage physical registers to efficiently, reducing the size requirements of the physical register file. When the system clock rate is proportional to the register file cycle time, this optimization can improve performance. All of these optimizations can be supported with only a few new instructions and minimal additional hardware structures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. E. Anderson, H. M. Levy, B. N. Bershad, and E. D. Lazowska. </author> <title> The interaction of architecture and operating system design. </title> <booktitle> In Proceedings of the 4th International Conference on Architectural Support for Programming Languages and Operating System, </booktitle> <volume> volume 26, </volume> <pages> pages 108-121, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: While the cost of saving and restoring this state is not significant for context switches [15], it dominates thread switch overhead especially for fine-grained threaded code <ref> [1, 9] </ref>. Non-preemptive switches are implemented using a procedure call interface allowing the compiler to generate specialized save and restore code at these well-defined switch points based on static liveness information [9].
Reference: [2] <author> Doug Burger and Todd M. Austin. </author> <title> The sim-plescalar tool set, version 2.0. </title> <type> Technical Report 1342, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: Simulation Environment. To evaluate our optimizations we used the SimpleScalar tool set <ref> [2] </ref>. The detailed out-of-order processor simulator was modified to support MIPS R10000-style register renaming [10] -2 Parameter Value Issue Width 4 Inst. Window 64 Func.
Reference: [3] <author> Luis A. Lozano C. and Guang R. Gao. </author> <title> Exploiting short-lived variables in superscalar processors. </title> <booktitle> In Proceedings of the 28th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 292-302, </pages> <month> November 29-December 1, </month> <year> 1995. </year>
Reference-contexts: Using DVI allows the processor to reclaim p1 when I3 commits, allowing p1 to be used in renaming the intermediate instructions. 4 Register File Size Reduction Access to a large, multi-ported physical register file is an important element of the timing-critical path in a multiple issue processor <ref> [6, 3, 8] </ref>. Access time is quadratic in the number of read and write ports and linear in the number of registers [6]. Current register file optimizations reduce the number of ports through replication or pipelining. <p> Sohi and Franklin [8] study register instance lifetimes and describe how compiler support -9 can be used to minimize these lifetimes and reduce traffic. Lozano and Gao <ref> [3] </ref> use DVI to reduce write-back traffic between the reorder buffer and the physical register file. More recently, the Multiscalar [16] architecture uses summary masks to streamline register communication. These techniques try to reduce the number of datapaths to the register file.
Reference: [4] <author> Digital Equipment Corporation. </author> <title> VAX-11 Architecture Reference Manual, </title> <year> 1982. </year>
Reference-contexts: More recently, the Multiscalar [16] architecture uses summary masks to streamline register communication. These techniques try to reduce the number of datapaths to the register file. Our method reduces the size of the physical register file. The VAX <ref> [4] </ref> uses compiler-supplied masks to encode saves and restores in the callee based on intra-procedural use information. Huguet and Lang [12] extend this mechanism to eliminate some of these encoded saves and restores in hardware dynamically.
Reference: [5] <author> Keith I. Farkas. </author> <title> Memory-System Design Considerations for Dynamically-Scheduled Microprocessors. </title> <type> PhD thesis, </type> <institution> University of Toronto, </institution> <year> 1997. </year>
Reference-contexts: The E-DVI instructions we insert before procedure calls have little added value, which leads us to believe that a high density of E-DVI is necessary to provide any appreciable additional benefit. System Performance Improvements. To compute overall performance (IPC fi clock rate), we use a modified version of CACTI <ref> [13, 5] </ref> to generate a timing model for multiported register files (a 4 way issue machine requires 8 read ports and 4 write ports) of different sizes.
Reference: [6] <author> Keith I. Farkas, Norman P. Jouppi, and Paul Chow. </author> <title> Register file design considerations in dynamically scheduled processors. </title> <booktitle> In Proceedings of the Second International Symposium on High Performance Computer Architecture, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: Using DVI allows the processor to reclaim p1 when I3 commits, allowing p1 to be used in renaming the intermediate instructions. 4 Register File Size Reduction Access to a large, multi-ported physical register file is an important element of the timing-critical path in a multiple issue processor <ref> [6, 3, 8] </ref>. Access time is quadratic in the number of read and write ports and linear in the number of registers [6]. Current register file optimizations reduce the number of ports through replication or pipelining. <p> Access time is quadratic in the number of read and write ports and linear in the number of registers <ref> [6] </ref>. Current register file optimizations reduce the number of ports through replication or pipelining. Our technique reduces the number of registers in the file and can be used in conjunction with other cycle time optimizations.
Reference: [7] <author> Charles N. Fischer and Richard J. LeBlanc Jr. </author> <title> Crafting a Compiler with C. </title> <publisher> Benjamin/Cummings Publishing Co., </publisher> <year> 1991. </year>
Reference-contexts: Our implementation of E-DVI instructions defines a subset of the non-opcode bits as a kill mask for a register subset, with a register dead if the corresponding bit is set. The information encoded in E-DVI instructions is computed using static, intra-procedural liveness analysis performed in standard compilers <ref> [7] </ref>. However, a full compiler is not necessary to encode E-DVI. Since liveness information is computed for physical registers, E-DVI instructions can be added to an executable using a simple binary rewriting tool. This approach is attractive since it requires neither compiler nor program source code.
Reference: [8] <author> Manoj Franklin and Gurindar S. Sohi. </author> <title> Register traffic analysis for streamlining inter-operation communication in fine-grain parallel processors. </title> <booktitle> In Proceedings of the 25th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 236-245, </pages> <address> De-cember 1-4, </address> <year> 1992. </year>
Reference-contexts: Using DVI allows the processor to reclaim p1 when I3 commits, allowing p1 to be used in renaming the intermediate instructions. 4 Register File Size Reduction Access to a large, multi-ported physical register file is an important element of the timing-critical path in a multiple issue processor <ref> [6, 3, 8] </ref>. Access time is quadratic in the number of read and write ports and linear in the number of registers [6]. Current register file optimizations reduce the number of ports through replication or pipelining. <p> Alternatively, support could be added to save and restore the contents of the LVM (as is already required for our restore elimination across thread switches) and the LVM-Stack. 8 Related Work The idea of using DVI for register file optimizations is not new. Sohi and Franklin <ref> [8] </ref> study register instance lifetimes and describe how compiler support -9 can be used to minimize these lifetimes and reduce traffic. Lozano and Gao [3] use DVI to reduce write-back traffic between the reorder buffer and the physical register file.
Reference: [9] <author> Dirk Grunwald and Richard Neves. </author> <title> Whole-program optimization for time and space efficient threads. </title> <booktitle> In Seventh International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 50-59, </pages> <month> 1-5 October </month> <year> 1996. </year>
Reference-contexts: While the cost of saving and restoring this state is not significant for context switches [15], it dominates thread switch overhead especially for fine-grained threaded code <ref> [1, 9] </ref>. Non-preemptive switches are implemented using a procedure call interface allowing the compiler to generate specialized save and restore code at these well-defined switch points based on static liveness information [9]. <p> Non-preemptive switches are implemented using a procedure call interface allowing the compiler to generate specialized save and restore code at these well-defined switch points based on static liveness information <ref> [9] </ref>. Preemptive switches are not amenable to such static analysis or optimization and must conservatively save and restore all registers. We propose that DVI be used in multi-threaded programs to optimize saves and restores dynamically. <p> Kur-lander and Fischer report an average 5% reduction in execution time on an inorder machine. Our 4.8% average reduction in dynamic instruction count is a comparable result. Grunwald and Neves <ref> [9] </ref> use interprocedural analysis to determine the live registers at each non-preemptive thread-switch call site and compile custom save-restore code for each call. Their solution requires cloning and does not handle preemptive switches.
Reference: [10] <author> Linley Gwennap. </author> <title> Mips R10000 uses decoupled architecture. </title> <type> MicroProcessor Report, </type> <pages> pages 18-22, </pages> <month> October 24 </month> <year> 1994. </year>
Reference-contexts: Simulation Environment. To evaluate our optimizations we used the SimpleScalar tool set [2]. The detailed out-of-order processor simulator was modified to support MIPS R10000-style register renaming <ref> [10] </ref> -2 Parameter Value Issue Width 4 Inst. Window 64 Func. <p> The values were chosen to be representative of current high-performance uniprocessors such as the MIPS R10000 <ref> [10] </ref> and DEC Alpha 21264 [11].
Reference: [11] <author> Linley Gwennap. </author> <title> Digital 21264 sets new standard. </title> <type> MicroProcessor Report, </type> <pages> pages 11-16, </pages> <month> Octo-ber 28 </month> <year> 1996. </year>
Reference-contexts: The values were chosen to be representative of current high-performance uniprocessors such as the MIPS R10000 [10] and DEC Alpha 21264 <ref> [11] </ref>.
Reference: [12] <author> M. Huguet and T. Lang. </author> <title> Architectural support for reduced register saving/restoring in single-window register files. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(1) </volume> <pages> 66-97, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: These techniques try to reduce the number of datapaths to the register file. Our method reduces the size of the physical register file. The VAX [4] uses compiler-supplied masks to encode saves and restores in the callee based on intra-procedural use information. Huguet and Lang <ref> [12] </ref> extend this mechanism to eliminate some of these encoded saves and restores in hardware dynamically. In their solution, called Policy-G, register values are saved when they are overwritten by the callee and restored on a demand basis in the caller.
Reference: [13] <author> Norman P. Jouppi and Steven J.E. Wilton. </author> <title> An enhanced access and cycle time model for on-chip caches. </title> <type> Technical Report 93.5, </type> <institution> DEC Western Research Laboratory, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: The E-DVI instructions we insert before procedure calls have little added value, which leads us to believe that a high density of E-DVI is necessary to provide any appreciable additional benefit. System Performance Improvements. To compute overall performance (IPC fi clock rate), we use a modified version of CACTI <ref> [13, 5] </ref> to generate a timing model for multiported register files (a 4 way issue machine requires 8 read ports and 4 write ports) of different sizes.
Reference: [14] <author> Steven M. Kurlander and Charles N. Fischer. </author> <title> Minimum cost interprocedural register allocation. </title> <booktitle> In The 23rd Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: Since proc does not "know" who is calling it, it must always save and restore r16 so that it executes correctly if called from caller1. Calling conventions and their associated heuristics are unable to handle context-sensitive liveness. Nor can traditional interprocedural analyses <ref> [14, 17] </ref> cope with this problem. This difficulty can only be overcome statically by compiling multiple caller-specific procedure versions (clones), each containing the appropriate save/restore sequence. However, cloning expands code and can have adverse effects on I-cache performance. <p> Policy-G can effectively eliminate restores in a flow-sensitive manner which our technique cannot handle, but does not eliminate saves based on liveness. In addition, Policy-G requires a large amount of critical path hardware, and more involved changes to existing instruction sets. Kurlander and Fischer <ref> [14] </ref> use interprocedural analysis and profile information to produce a statically optimal interprocedural spilling strategy. Their technique attacks all registers, but does not consider path information and must therefore produce conservative save/restore code.
Reference: [15] <author> Jeffrey C. Mogul and Anita Borg. </author> <title> The effect of context switches on cache performance. </title> <booktitle> In Proceedings of the 4th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 75-84, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: While the cost of saving and restoring this state is not significant for context switches <ref> [15] </ref>, it dominates thread switch overhead especially for fine-grained threaded code [1, 9]. Non-preemptive switches are implemented using a procedure call interface allowing the compiler to generate specialized save and restore code at these well-defined switch points based on static liveness information [9].
Reference: [16] <author> G. S. Sohi, S. Breach, and T. N. Vijaykumar. </author> <title> Multiscalar architectures. </title> <booktitle> In The 22nd International Symposium on Computer Architecture, </booktitle> <year> 1995. </year>
Reference-contexts: Sohi and Franklin [8] study register instance lifetimes and describe how compiler support -9 can be used to minimize these lifetimes and reduce traffic. Lozano and Gao [3] use DVI to reduce write-back traffic between the reorder buffer and the physical register file. More recently, the Multiscalar <ref> [16] </ref> architecture uses summary masks to streamline register communication. These techniques try to reduce the number of datapaths to the register file. Our method reduces the size of the physical register file.
Reference: [17] <author> David W. Wall. </author> <title> Global register allocation at link time. </title> <type> Research Report 17, </type> <institution> Digital Western Research Laboratory, </institution> <month> September </month> <year> 1989. </year>
Reference-contexts: Since proc does not "know" who is calling it, it must always save and restore r16 so that it executes correctly if called from caller1. Calling conventions and their associated heuristics are unable to handle context-sensitive liveness. Nor can traditional interprocedural analyses <ref> [14, 17] </ref> cope with this problem. This difficulty can only be overcome statically by compiling multiple caller-specific procedure versions (clones), each containing the appropriate save/restore sequence. However, cloning expands code and can have adverse effects on I-cache performance.
Reference: [18] <author> Kenneth Wilson and Kunle Olukotun. </author> <title> Designing high-bandwidth on-chip caches. </title> <booktitle> In Proceedings of the 24th Annual International Symposium on Computer Architecture, </booktitle> <month> June 2-4 </month> <year> 1997. </year> <month> -11 </month>
Reference-contexts: Multiple cache ports can be implemented through replication or banking. The former is free of bank contention and provides more bandwidth while the latter requires significantly fewer implementation resources. For most programs a banked implementation can realistically achieve the performance of 3 perfect cache ports <ref> [18] </ref>. As our simulations model a replicated (perfect) cache, we expect our performance improvements to be more significant on a more realistic, lower bandwidth banked configuration. While adding cache ports increases the available bandwidth, increasing the issue width increases cache bandwidth requirements.
References-found: 18

