URL: ftp://ftp.sics.se/pub/SICS-reports/Reports/SICS-R--93-01--SE.ps.Z
Refering-URL: http://www.sics.se/libindex.html
Root-URL: 
Title: An Implementation of a Task Specific Problem Solving Method (TDFL) using GCLA II  
Author: by Gran Falkman Jonas Warnby 
Keyword: Expert systems, Diagnosis, GCLA II, Knowledge-Based System, Logic Programming.  
Address: Box 1263, S-164 28 Kista, Sweden  
Note: goran@sics.se  
Affiliation: of Telecommunication Equipment  Swedish Institute of Computer Science  
Pubnum: RR 93:01ISSN 0283-3638 Technical Diagnosis  
Email: jonasw@sics.se  
Date: KBS-lab December 1992  
Abstract: This paper describes an implementation of a small knowledge-based system in GCLA II. GCLA II is perhaps best described as a logical programming language, with some properties usually found among functional languages, and it includes hypothetical and non-monotonic reasoning as integral parts, which makes it easy to handle hypothetical queries, negation and AI-techniques like simulation and planning in a natural way. It also makes implementation of reasoning in knowledge-based systems (KBS) more direct than in Prolog. The application is an already existing KBS that guides a service technician in the task of diagnosing a specific device which is a measuring instrument for testing telecommunications equipment. The method used in the application is a problem solving method called TDFL. The TDFL method is a task specific problem solving method for technical diagnosis that gives strong support for knowledge acquisition. The method is adapted to cope with some features of the application. For example, it gives support for reducing the time required for observations and it handles parts that are not directly testable. This paper describes how to adjust the TDFL method to remedy some errors present in the original version; avoiding unnecessary search of the device and eliminating unnecessary confirmations. Some future extensions to both the TDFL method and the implementation are also presented; allowing the search for more than one fault and the possibility of turning the diagnosis backwards. 
Abstract-found: 1
Intro-found: 1
Reference: [Aro90] <author> M.Aronsson, L-H. Eriksson, A. Gredal, L. Hallns, P. Olin, </author> <title> The Programming Language GCLA: A Definitional Approach to Logic Programming, </title> <booktitle> New Generation Computing 7(4), </booktitle> <pages> pp. 381-404, </pages> <year> 1990. </year>
Reference-contexts: Appendix D, finally, contains a description of the decomposition model. 2 The implementation language 3 2 The implementation language 2.1 Introduction to GCLA The programming system GCLA (Generalized Horn Clause LAnguage) <ref> [Aro90] </ref> has been developed for some years at SICS. It is perhaps best described as a logical programming language, with some properties usually found among functional languages. GCLA has a number of noteworthy properties. <p> One older version interpreting a GCLA program, having some inference rules given beforehand, called GCLA I <ref> [Aro90] </ref>. GCLA I had a very restricted set of control primitives, which led to a large search space for larger programs. From the GCLA I system the GCLA II system was developed.
Reference: [Aro92] <author> M. Aronsson, </author> <title> Methodology and Programming Techniques in GCLA II, </title> <institution> Research Report SICS R9205, Swedish Institute of Computer Science, </institution> <year> 1992. </year>
Reference-contexts: The declarative part consists of a definition D and a set of sequents S. The procedural part consists of the rule definition, R, and the proviso definition, P. For a more complete and comprehensive description of GCLA IIs theoretical properties and its relation to PID see [Kre92]. <ref> [Aro92] </ref> demonstrates the program development methodology used in GCLA II. Various implementation techniques, including functional and object oriented programming, are also demonstrated. This short presentation will focus on the syntax.
Reference: [Hal91] <author> L. Hallns, </author> <title> Partial Inductive Definitions, </title> <booktitle> Theoretical Computer Science vol. </booktitle> <pages> 87 pp. 115-142, </pages> <year> 1991. </year>
Reference-contexts: Generalized Horn clauses are a generalization of definite Horn clauses, not within the traditional logical framework, but rather within the framework of partial inductive definitions (PID), a framework developed by Lars Hallns <ref> [Hal91, HS-H88] </ref>. Partial inductive definitions gives a definitial framework which, in a sense, is of a more primitive and general nature than a standard logical framework.
Reference: [Hp74] <author> Operating and Service Manual Model 3552A, </author> <title> Transmission Test Set, -hp- Part No. </title> <type> 03552-90002, </type> <institution> Hewlett-Packard Company, 1974 Loveland, Colorado USA. </institution>
Reference-contexts: The system finally reports which part of the device is faulty. A complete description of the HP device is found in <ref> [Hp74] </ref>. Using our program the presumptive user may pose queries like: Find a faulty part in the device. and Assuming that these parts are correct and those parts are faulty, find a faulty part in the device.
Reference: [HS-H88] <author> L. Hallns, P. Schroeder-Heister, </author> <title> A Proof-Theoretic Approach to Logic Programming, published in two parts in the Journal of Logic and Computation, part I: Clauses as Rules, </title> <journal> vol. </journal> <volume> 1(2), </volume> <pages> pp. 261-283, </pages> <year> 1990, </year> <title> part II: Programs as Definitions, </title> <journal> vol. </journal> <volume> 1(5), </volume> <pages> pp. 635-660, </pages> <year> 1991. </year>
Reference-contexts: Generalized Horn clauses are a generalization of definite Horn clauses, not within the traditional logical framework, but rather within the framework of partial inductive definitions (PID), a framework developed by Lars Hallns <ref> [Hal91, HS-H88] </ref>. Partial inductive definitions gives a definitial framework which, in a sense, is of a more primitive and general nature than a standard logical framework.
Reference: [Kre92] <author> P. Kreuger, GCLA II, </author> <title> A Definitional Approach to Control, </title> <booktitle> Extensions of Logic Programming: Proceedings of a workshop held at SICS, </booktitle> <month> February </month> <year> 1991, </year> <booktitle> Springer Lecture Notes in Artificial Intelligence. </booktitle>
Reference-contexts: The declarative part consists of a definition D and a set of sequents S. The procedural part consists of the rule definition, R, and the proviso definition, P. For a more complete and comprehensive description of GCLA IIs theoretical properties and its relation to PID see <ref> [Kre92] </ref>. [Aro92] demonstrates the program development methodology used in GCLA II. Various implementation techniques, including functional and object oriented programming, are also demonstrated. This short presentation will focus on the syntax. <p> When the GCLA II system is started, the user is furnished with a general set of provisos and inference rules, implementing the behaviour of GCLA I or, in fact, the rules for the calculus OLD in <ref> [Kre92] </ref>. 2.2.2.1 The rule definition a) Proof terms Proof terms are representations of proofs (or set of proofs). They can be seen as functional expressions that compute sequents from proofs with respect to a certain rule definition.
Reference: [Ors92] <author> Klas Orsvrn, </author> <title> Adaptation of a task specific problem solving method to the features of an application, </title> <note> Paper submitted to the 7th Banff KAW 1992, </note> <institution> Swedish Institute of Computer Science, 1992. Technical Diagnosis of Telecommunication Equipment 52 A 53 </institution>
Reference-contexts: The purpose of this implementation is to explore the possibilities of GCLA II as an implementation language for such systems. l implement a task specific problem solving method called TDFL (Top-Down-Fault Localization), a method fully described in <ref> [Ors92] </ref>. l adjust the TDFL method to remedy some errors present in the original version. Instead of developing a new application from scratch, we have used an already existing KBS developed in 1989 by Infologics and Swedish Telecom. <p> In section 2 we give a short introduction to the implementation language, GCLA II. This presentation will focus on the syntax, and we also present a few examples. In section 3 the top-down-fault-localization method (TDFL) will be presented. The presentation there follows the one given in <ref> [Ors92] </ref>. The original version of the TDFL method contained some errors. In section 4 we present our solutions to remedy these errors. <p> For example, it gives support for reducing the time required for observations and it handles parts that are not directly testable. We will leave out some parts of the method that are not relevant to us. For a more detailed description we refer to <ref> [Ors92] </ref>. In the presentation of the different tasks we will use a Prolog-like syntax with its usual procedural interpretation.
References-found: 7

