URL: http://www.cs.virginia.edu/~cw2e/res/popl97.ps
Refering-URL: http://www.cs.virginia.edu/~cw2e/res/cs851_reading.html
Root-URL: http://www.cs.virginia.edu
Email: necula@cs.cmu.edu  
Title: Proof-Carrying Code  
Author: George C. Necula 
Address: Pittsburgh, Pennsylvania 15213-3891  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: This paper describes proof-carrying code (PCC), a mechanism by which a host system can determine with certainty that it is safe to execute a program supplied (possibly in binary form) by an untrusted source. For this to be possible, the untrusted code producer must supply with the code a safety proof that attests to the code's adherence to a previously defined safety policy. The host can then easily and quickly validate the proof without using cryptography and without consulting any external agents. In order to gain preliminary experience with PCC, we have performed several case studies. We show in this paper how proof-carrying code might be used to develop safe assembly-language extensions of ML programs. In the context of this case study, we present and prove the adequacy of concrete representations for the safety policy, the safety proofs, and the proof validation. Finally, we briefly discuss how we use proof-carrying code to develop network packet filters that are faster than similar filters developed using other techniques and are formally guaranteed to be safe with respect to a given operating system safety policy. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bershad, B., Savage, S., Pardyak, P., Sirer, E. G., Becker, D., Fiuczynski, M., Chambers, C., and Eggers, S. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Symposium on Operating System Principles (Dec. </booktitle> <year> 1995), </year> <pages> pp. 267-284. </pages>
Reference: [2] <author> Boyer, R. S., and Yu, Y. </author> <title> Automated proofs of object code for a widely used microprocessor. </title> <journal> J. ACM 43, </journal> <month> 1 (Jan. </month> <year> 1996), </year> <pages> 166-192. </pages>
Reference-contexts: This is important for certifying extensions to safe programming languages and as a main building block in constructing certifying compilers. Similar techniques have been applied to assembly lan 10 guage before <ref> [2, 3] </ref> but neither as a basis for creating safety proofs nor for checking type safety. We show an encoding of safety proofs as first-order logic derivations in LF.
Reference: [3] <author> Clutterbuck, D., and Carr e, B. </author> <title> The verification of low-level code. </title> <journal> IEEE Software Engineering Journal 3, </journal> <month> 3 (May </month> <year> 1988), </year> <pages> 97-111. </pages>
Reference-contexts: This is important for certifying extensions to safe programming languages and as a main building block in constructing certifying compilers. Similar techniques have been applied to assembly lan 10 guage before <ref> [2, 3] </ref> but neither as a basis for creating safety proofs nor for checking type safety. We show an encoding of safety proofs as first-order logic derivations in LF.
Reference: [4] <author> Floyd, R. W. </author> <title> Assigning meanings to programs. </title> <booktitle> In Mathematical Aspects of Computer Science, </booktitle> <editor> J. T. Schwartz, Ed. </editor> <publisher> American Mathematical Society, </publisher> <year> 1967, </year> <pages> pp. 19-32. </pages>
Reference: [5] <author> Harper, R., Honsell, F., and Plotkin, G. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery 40, </journal> <month> 1 (Jan. </month> <year> 1993), </year> <pages> 143-184. </pages>
Reference-contexts: P , that is P is valid. Furthermore, M = pDq. A similar theorem is proved by Harper, Honsell and Plotkin <ref> [5] </ref> for canonical forms in full LF. In LF 0 the proofs are somewhat simpler because of the syntax directed form of typing judgments and canonical forms.
Reference: [6] <author> McCanne, S., and Jacobson, V. </author> <title> The BSD packet filter: A new architecture for user-level packet capture. </title> <booktitle> In The Winter 1993 USENIX Conference (Jan. 1993), USENIX Association, </booktitle> <pages> pp. 259-269. </pages>
Reference-contexts: Packet filters are supported by most of today's workstation operating systems [9]. The main technical problem is that application programs are inherently untrusted, and so the kernel must employ some method for ensuring safety. One popular solution, exemplified by the BSD Packet Filter architecture (BPF) <ref> [6] </ref>, is to define a safe programming language 8 for writing packet filters, and then use an interpreter in the kernel to execute them.
Reference: [7] <author> Miller, D., Nadathur, G., Pfenning, F., and Scedrov, A. </author> <title> Uniform proofs as a foundation for logic programming. </title> <booktitle> Annals of Pure and Applied Logic 51 (1991), </booktitle> <pages> 125-157. </pages>
Reference-contexts: These fragments of first-order logic admit a complete sequent-style proof system where the declarative meaning of logical connectors coincides with their search-related reading <ref> [7] </ref>. The resulting proofs are called uniform. The LF representation of a uniform proof system for our logic can then be used as a logic program to perform proof search. We represent in LF the uniform derivation rules for our logic in a manner similar to the natural deduction representation.
Reference: [8] <author> Milner, R., Tofte, M., and Harper, R. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference: [9] <author> Mogul, J. C., Rashid, R. F., and Accetta, M. J. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In ACM Symposium on Operating Systems Principles (Nov. 1987), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 39-51. </pages> <note> An updated version is available as DEC WRL Research Report 87/2. </note>
Reference-contexts: The kernel can then avoid delivering uninteresting packets to the application, thereby saving the cost of many unnecessary context switches. Packet filters are supported by most of today's workstation operating systems <ref> [9] </ref>. The main technical problem is that application programs are inherently untrusted, and so the kernel must employ some method for ensuring safety.
Reference: [10] <author> Necula, G. C., and Lee, P. </author> <title> Proof-carrying code. </title> <type> Technical Report CMU-CS-96-165, </type> <institution> Computer Science Department, Carnegie Mellon University, </institution> <month> Sept. </month> <year> 1996. </year> <note> Also appeared as FOX memorandum CMU-CS-FOX-96-03. </note>
Reference: [11] <author> Necula, G. C., and Lee, P. </author> <title> Safe kernel extensions without run-time checking. </title> <booktitle> In Second Symposium on Operating Systems Design and Implementations (Oct. 1996), Usenix. </booktitle>
Reference-contexts: The details of this experiment are described elsewhere <ref> [11] </ref>, and so here we give only a brief summary of the experiment and our results. Many modern operating systems provide a facility for allowing application programs to receive packets directly from the network device.
Reference: [12] <author> Pfenning, F. </author> <title> Elf: A language for logic definition and verified meta-programming. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science (Pacific Grove, </booktitle> <address> California, June 1989), </address> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 313-322. </pages>
Reference-contexts: There are other possible methods that are likely to work better, especially for larger programs. We discuss some of these in Section 6. For our experiments, we use the programming language Elf <ref> [12] </ref> to prove VC predicates and produce LF representation of their proofs. Elf is a logic programming language based on LF. A program in Elf is an LF signature and execution in Elf is search for canonical LF objects inhabiting an LF type in the context of a signature.
Reference: [13] <author> Rouaix, F. </author> <title> A Web navigator with applets in Caml. </title> <booktitle> Proceedings of the 5th International World Wide Web Conference, in Computer Networks and Telecommunications Networking 28, </booktitle> <month> 7-11 (May </month> <year> 1996), </year> <pages> 1365-1371. </pages>
Reference: [14] <author> Sites, R. L. </author> <title> Alpha Architecture Reference Manual. </title> <publisher> Digital Press, </publisher> <year> 1992. </year>
Reference: [15] <author> Tarditi, D., Morrisett, J. G., Cheng, P., Stone, C., Harper, R., and Lee, P. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In PLDI'96 Conference on Programming Language Design and Implementation (May 1996), </booktitle> <pages> pp. 181-192. </pages>

References-found: 15

