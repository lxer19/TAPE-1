URL: http://www.daimi.aau.dk/~beta/Mli/metabeta.ps.Z
Refering-URL: http://www.daimi.aau.dk/~beta/Mli/mli.html
Root-URL: http://www.daimi.aau.dk
Email: email: rws@daimi.aau.dk  
Title: MetaBETA Model and Implementation  
Author: Rene W. Schmidt 
Address: DK-8000 Aarhus C, Denmark  
Affiliation: Department of Computer Science University of Aarhus  
Abstract-found: 0
Intro-found: 1
Reference: [Accetta et al. 86] <author> M. J. Accetta, R. V. Baron, W. Bolosky, D. B. Golub, R. F. Rashid, A. T. Jr., , and M. W. Young. </author> <title> Mach: A New Kernel Foundation for Unix Development. </title> <booktitle> In Proceedings of the 1986 Summer USENIX Conference, </booktitle> <pages> pages 93 - 113, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Thus, a framework should provide two interfaces, a baselevel interface that defines its behaviour, and a metalevel interface that exposes certain parts of its implementation [Kiczales & Lamping 93]. An example, of an open implementation is Mach's virtual memory system and external pagers <ref> [Accetta et al. 86] </ref>. The baselevel interface allows allocation of virtual memory, where as the metalevel interface (external pagers) makes it possible to control the mapping between physical and virtual memory.
Reference: [Agesen & Ungar 94] <author> O. Agesen and D. Ungar. </author> <title> Sifting Out the Gold: Delivering Compatc Applications from an Exploratory Object-Oriented Programming Environment. </title> <booktitle> In Proceedings of the Ninth Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA), </booktitle> <address> Portland, Oregon, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: By separating the development environment from the runtime system, MetaBETA is not suspect to the problems of extracting an application from the development environment <ref> [Agesen & Ungar 94] </ref>. In fact, the BETA fragment structure [Madsen 93b] can be used in the MetaBETA model too.
Reference: [Agesen et al. 89] <author> O. Agesen, S. Frolund, and M. Olsen. </author> <title> Persistent and Shared Objects in BETA. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <month> April </month> <year> 1989. </year>
Reference: [Aho et al. 88] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers, principles, techniques, and tools. </booktitle> <publisher> Addison-Wesley, </publisher> <month> March </month> <year> 1988. </year>
Reference: [Anderson et al. 92] <author> T. E. Anderson, B. N. Bershad, E. D. Lazowska, and H. M. Levy. </author> <title> Scheduler activations: Effective kernel support for the user-level management of parallelism. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 53-79, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: In effect, these systems provide a metalevel interface that allows the operating system to be customized. Integrating the MetaBETA runtime system tightly with the operating system can provide more efficient use of the system resources, e.g., combining user-level and system-level thread-scheduling <ref> [Anderson et al. 92] </ref>, and combining garbage-collection and virtual memory management. 6.3 Applicational Implementing distribution and persistence. The experience from designing and implementing the current version of object persistence and distribution has been a major factor in the design of both the metalevel interface and architecture.
Reference: [Arnold & Gosling 96] <author> K. Arnold and J. Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: For example, if only the machine-code part is loaded, then the metalevel architecture degenerates into a traditional compiled language implementation. If only the Alpha code is loaded, we have a system with just-in-time code generation, similar to the Java runtime system <ref> [Arnold & Gosling 96] </ref>. Finally, the metainformation will only be loaded on demand to avoid both time and space overhead for ordinary programs. <p> The last two capabilities are not supported very well by stack-code which was another alternative. Stack-code is used by the Java virtual machine <ref> [Arnold & Gosling 96] </ref>. The Alpha code contains mainly low-level RISC-like primitives, except for 6 BETA specific primitives. The high-level primitives encapsulate architecture-dependent properties, such as object creation, invocation of a method, attribute access, etc. <p> The runtime system can utilize a close-world assumption, since it knows all the code that is loaded at any given point in time. Optimizations such as static class hierarchy analysis would be possible [Dean et al. 95]. Verification of Alpha Code. The success of the Java <ref> [Arnold & Gosling 96] </ref> language as the internet programming language of choice is mainly because it is possible to verify that a Java program is safe at the byte-code level, where the definition of safe can be type-correct, utilize limited amounts memory, limited amount of threads, does not access the file
Reference: [Bershad et al. 95] <author> B. Bershad, S. Savage, P. Pardyak, E. G. Sirer, D. Becker, M. Fiuczynski, C. Chambers, and S. Eggers. </author> <title> Extensibility, safety and performance in the spin operating system. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating System Principles (SOSP), </booktitle> <pages> pages 267-284, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: However, the MetaBETA runtime system is not intended as a general operating system. Instead of being an operating system, the runtime system is the glue between the language and the underlying OS. Spin <ref> [Bershad et al. 95] </ref> is an extensible micro-kernel that allows user-level programs to inject code into the kernel, thereby avoiding the context-switching and IPC 11 cost that is a problem for traditional micro-kernels. Spin uses an event model similar to the intercessory part of the MetaBETA MLI. <p> It provides memory management, threads, and disk-storage abstractions. However, instead of being a full-blown operating system, it should be a thin glue layer, that makes the underlying operating system MetaBETA aware. Several operating system are under development which lets user applications get fine-grained control of system resources <ref> [Bershad et al. 95, Engler et al. 95] </ref>. In effect, these systems provide a metalevel interface that allows the operating system to be customized.
Reference: [Brandt & Knudsen 96] <author> S. Brandt and J. L. Knudsen. </author> <title> Patterns and Qualifications in BETA: A Case for Generalization. </title> <booktitle> In Proceedings of the Ninth European Conference on Object-Oriented Programming (ECOOP), </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: This makes it possible to have explicit references to both objects, patterns, and attributes. In order to make the metalevel interface as simple and elegant as possible, several extensions to the BETA type-system have been proposed. In particular, a broader range of pattern qualifications <ref> [Brandt & Knudsen 96] </ref> and attribute references as first-class values [Brandt 95]. These extensions to BETA are not strictly necessary to implement the MLI. In this report we will restrict ourself to standard BETA syntax and semantics. <p> It would be interesting to combine these two interfaces, so the distinction between static source code manipulations and dynamic source code manipulations would vanish. One possible way of attacking this problem, would be to redesign MPS to use partial pattern qualifications <ref> [Brandt & Knudsen 96] </ref>. Partial pattern qualifications precisely captures the idea of manipulating patterns without having to instantiate them. Extend the metalevel interface to include do-parts. The current metalevel interface does not provide an abstract representation of the do-parts of BETA objects.
Reference: [Brandt & Madsen 94] <author> S. Brandt and O. L. Madsen. </author> <title> Object-Oriented Distributed Programming in BETA. </title> <editor> In R. Guerraoui, O. Nierstrasz, and M. Riveill, editors, </editor> <booktitle> Lecture Notes in Computer Science 791, </booktitle> <pages> pages 185 - 212. </pages> <publisher> Springer-Verlag, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: These problems was recognized during the design and implementation of a number of substrate systems for the Mjolner BETA system, including: type-orthogonal persistence [Brandt 94, Gronbaek et al. 94], distributed object system <ref> [Brandt & Madsen 94] </ref>, an embedded interpreter [Malhotra 93], a source-level debugger, and object- and class-browsers. These tools manipulate objects in a type-independent manner and currently depend on the memory layout of objects, as well as other implementation details. Such dependencies severely compromises portability and type-safety. <p> The first two examples are based on the current implementations of object persistence [Brandt 94] and distribution <ref> [Brandt & Madsen 94] </ref> for the Mjolner BETA System. The last example describes how dynamic slots make it possible to extend an existing framework in a way that is not possible by using subclassing alone. Persistent Storage The persistence model for BETA is based on reachability.
Reference: [Brandt & Schmidt 95] <author> S. Brandt and R. W. Schmidt. </author> <title> Runtime Reflection in a Statically Typed Language. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <month> November </month> <year> 1995. </year>
Reference-contexts: In the following we will first outline the design and rationale of the metalevel interface (MLI) to give a general understanding of it. A detailed description of the MLI can be found in [Brandt 95]. To support the metalevel interface, a metalevel architecture has been designed <ref> [Brandt & Schmidt 95, Brandt & Schmidt 96] </ref> that provides a conceptual model of metalevel programming and extensibility for MetaBETA. <p> Then the runtime system patches the code for that do-part, so it either: i) invokes the reflective hook directly (i.e., a jump to the reflective code), or ii) patches the calling code to call a new version of the do-part where the reflective code has been inlined. In <ref> [Brandt & Schmidt 95] </ref> preliminary performance measurements of the performance degradation due to runtime patching of code is reported. The tradeoff between the two approaches are between the setup cost and the invocation cost.
Reference: [Brandt & Schmidt 96] <author> S. Brandt and R. W. Schmidt. </author> <title> The Design of a Metalevel Architecture for the BETA Language. </title> <editor> In C. Zimmermann, editor, </editor> <title> Metaobject Protocols. </title> <publisher> CRC Press Inc, </publisher> <address> Boca Raton, Florida, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Common for these functionalities are that they all depend on metainformation and possibly implementation details. Without reflective capabilities, the programmer is forced to use source code preprocessing, special compilers, or new runtime systems to implement such functionalities <ref> [Brandt & Schmidt 96] </ref>. The lack of these two facilities are mainly due to the implementation of a language. By providing appropriate standardized interfaces as opposed to new language features both dynamic extensibility and reflection can be supported. <p> In the following we will first outline the design and rationale of the metalevel interface (MLI) to give a general understanding of it. A detailed description of the MLI can be found in [Brandt 95]. To support the metalevel interface, a metalevel architecture has been designed <ref> [Brandt & Schmidt 95, Brandt & Schmidt 96] </ref> that provides a conceptual model of metalevel programming and extensibility for MetaBETA. <p> Earlier papers on MetaBETA have discussed work related to the metalevel interface <ref> [Brandt 95, Brandt & Schmidt 96] </ref>, so in this report we will restrict ourselves to work related to dynamic slots and the MetaBETA implementation. 5.1 Dynamic Slots The dynamic slot concept presented here for a class-based language has previously materialized itself in a number of other languages and systems, including Self, <p> That is crucial to support type-orthogonal abstractions. Metalevel interfaces have been constructed for several statically-typed languages, including Open C++ [Chiba 95], Napier88 [Kirby et al. 94], and BETA <ref> [Brandt & Schmidt 96] </ref>. They all support the construction of type-orthogonal abstractions directly in the language itself. In principle, all type-orthogonal abstractions can associate additional information to the objects they work on. A type-orthogonal facility to extend objects is therefore needed to allow maximum flexibility and efficiency of metalevel programs.
Reference: [Brandt 94] <author> S. Brandt. </author> <title> Implementing Shared and Persistent Objects in BETA | Progress Report. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: These problems was recognized during the design and implementation of a number of substrate systems for the Mjolner BETA system, including: type-orthogonal persistence <ref> [Brandt 94, Gronbaek et al. 94] </ref>, distributed object system [Brandt & Madsen 94], an embedded interpreter [Malhotra 93], a source-level debugger, and object- and class-browsers. These tools manipulate objects in a type-independent manner and currently depend on the memory layout of objects, as well as other implementation details. <p> The first two examples are based on the current implementations of object persistence <ref> [Brandt 94] </ref> and distribution [Brandt & Madsen 94] for the Mjolner BETA System. The last example describes how dynamic slots make it possible to extend an existing framework in a way that is not possible by using subclassing alone. Persistent Storage The persistence model for BETA is based on reachability. <p> FirstSlot reference will introduce no performance overhead for applications that do not use dynamic slots, at the expense of slightly larger prototypes. 3.3.3 Persistent Store Benchmark Finally, to evaluate the performance increase provided by dynamic slots when implementing type-orthogonal abstractions, we have modified the existing implementation of a persistent store <ref> [Brandt 94] </ref> to use dynamic slots. We compare that implementation against the original type-orthogonal implementation and against a 15 "static" implementation. In the "static" implementation the OID attribute is pre-allocated for all objects so it can be accessed directly. <p> Reflection of object reclamation will be handled by extra checks at garbage-collection time, similar to the implementation of the DOT (Debugger Object Table) in the current BETA implementation. 22 4.4.2 Dynamic Loading, Linking, and Code Generation The MIR representation is stored as persistent objects using the BETA persistent store <ref> [Brandt 94] </ref>. Loading of the code is simply done by opening the persistent store. The persistent store supports lazy fetch of objects, which means that objects are brought in from disk when a reference is followed. Hence, loading on demand is implemented by the persistent store.
Reference: [Brandt 95] <author> S. Brandt. </author> <title> Reflection in a Statically Typed and Object Oriented Language A Meta-Level Interface for BETA. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <year> 1995. </year>
Reference-contexts: In the following we will first outline the design and rationale of the metalevel interface (MLI) to give a general understanding of it. A detailed description of the MLI can be found in <ref> [Brandt 95] </ref>. To support the metalevel interface, a metalevel architecture has been designed [Brandt & Schmidt 95, Brandt & Schmidt 96] that provides a conceptual model of metalevel programming and extensibility for MetaBETA. <p> The metalevel interface is divided into three different categories: introspective, intercessory, and invocational. In this report we will limit our focus to the first two categories. Readers interested in an in depth description of the MLI are refered to <ref> [Brandt 95] </ref>. 2.1.1 Reifying Type-Information A BETA program execution consists of: objects, patterns, and attributes. An object is an instance of a pattern and a pattern is a collection of attributes. <p> In order to make the metalevel interface as simple and elegant as possible, several extensions to the BETA type-system have been proposed. In particular, a broader range of pattern qualifications [Brandt & Knudsen 96] and attribute references as first-class values <ref> [Brandt 95] </ref>. These extensions to BETA are not strictly necessary to implement the MLI. In this report we will restrict ourself to standard BETA syntax and semantics. <p> A valid AttributeRef object can only be manufactured by the metalevel interface. A programmer does not have access to the internal implementation of an attribute reference object. In the case of the simulated attribute access, all type-checking is done at runtime. However, as shown in <ref> [Brandt 95] </ref>, is it possible to statically type-check attribute references 2.1.2 Introspective Capabilities The introspective part of the MLI provides a way to obtain runtime access to class-definitions and type-annotations as they exist in the source code. Metainformation is represented as pattern and attribute references. <p> Earlier papers on MetaBETA have discussed work related to the metalevel interface <ref> [Brandt 95, Brandt & Schmidt 96] </ref>, so in this report we will restrict ourselves to work related to dynamic slots and the MetaBETA implementation. 5.1 Dynamic Slots The dynamic slot concept presented here for a class-based language has previously materialized itself in a number of other languages and systems, including Self,
Reference: [Chambers & Ungar 91] <author> C. Chambers and D. Ungar. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <booktitle> In Proceedings of the sixth Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA), </booktitle> <address> Phoenix, Arizona, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: They are all based on an underlying virtual machine which is responsible for executing programs. In particular, the Self implementation, where lots of effort has been devoted to runtime code generation and runtime optimization of code <ref> [Chambers & Ungar 91, Holzle & Ungar 94] </ref>. Many of the techniques used in the Self implementation is possible to apply to the MetaBETA implementation.
Reference: [Chiba 95] <author> S. Chiba. </author> <title> A Metaobject Protocol for C++. </title> <booktitle> In Proceedings of the 10th Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <month> October </month> <year> 1995. </year>
Reference-contexts: Another requirement when implementing type-orthogonal abstractions is to express the functionality in a manner that does not rely on implementation details or require changes to the language implementation, i.e., the language implementation must be open for extensions. Several languages, including CLOS [Kiczales et al. 91], Open C++ <ref> [Chiba 95] </ref>, and MetaBETA provides such capabilities. However, as illustrated above, some type-orthogonal abstractions may need to associate additional information to the objects they work on. A type-orthogonal facility to extend objects is needed to allow for maximum flexibility and efficiency of metalevel programs. <p> However, by dynamically patching the code, this performance degradation will only be in effect during the use of the reflective hook. This is in contrast to compile-time detection of reflective hook and statically compiling them into the code <ref> [Kirby et al. 94, Chiba 95] </ref>. The key enabling technology is a MetaBETA intermediate representation (MIR). An intermediate representation is used by compiles to separate the code that handles the source language from the code that handles the target language, i.e., to separate the compiler front-end and back-end. <p> These are very similar to the dynamic slots presented in this report, except that we allow dynamic slots to be declared outside a class definition. That is crucial to support type-orthogonal abstractions. Metalevel interfaces have been constructed for several statically-typed languages, including Open C++ <ref> [Chiba 95] </ref>, Napier88 [Kirby et al. 94], and BETA [Brandt & Schmidt 96]. They all support the construction of type-orthogonal abstractions directly in the language itself. In principle, all type-orthogonal abstractions can associate additional information to the objects they work on. <p> The metalevel interface for BETA is entirely a runtime entity. It does not require access to the source code for the objects it works on. Hence, a mechanism for runtime extensibility of objects is mandatory. 5.2 Reflective Languages Open C++ <ref> [Chiba 95] </ref> is a reflective version of C++. Like C++, Open C++ is a statically-typed and compiled language. Its metalevel interface is based on a metaobject protocol (MOP) that controls how classes are compiled.
Reference: [Dean et al. 95] <author> J. Dean, D. Grove, and C. Chambers. </author> <title> Optimization of Object-Oriented Programs Using Staic Class Hierarchy Analysis. </title> <booktitle> In Proceedings of the 9th European Conference on Object-Oriented Programming (ECOOP), </booktitle> <month> August </month> <year> 1995. </year>
Reference-contexts: For example, INNER chains and descriptor-slots can be inlined. The runtime system can utilize a close-world assumption, since it knows all the code that is loaded at any given point in time. Optimizations such as static class hierarchy analysis would be possible <ref> [Dean et al. 95] </ref>. Verification of Alpha Code.
Reference: [Engler & Proebsting 94] <author> D. R. Engler and T. A. Proebsting. </author> <title> DCG: An Efficient, Retargetable Dynamic Code Generation System. </title> <booktitle> In The 6th International Conference on Architectural Support for Programming Language and Operating Systems (ASPLOS), </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: The experience from the implementation of the lcc compiler has shown that efficient code can be generated fast for leading RISC and CISC architectures. Furthermore, the representation has been used for dynamic code generation <ref> [Engler & Proebsting 94] </ref>. 6 Future Work The work on MetaBETA was initiated to provide an open implementation of the BETA language, since functionality such as debuggers and persistent stores was not possible to express directly.
Reference: [Engler et al. 95] <author> D. R. Engler, M. F. Kaashoek, and J. O'Tool. Exokernel: </author> <title> An Operating System Architecture for Application-Level Resource Management. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating System Principles (SOSP), </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: It provides memory management, threads, and disk-storage abstractions. However, instead of being a full-blown operating system, it should be a thin glue layer, that makes the underlying operating system MetaBETA aware. Several operating system are under development which lets user applications get fine-grained control of system resources <ref> [Bershad et al. 95, Engler et al. 95] </ref>. In effect, these systems provide a metalevel interface that allows the operating system to be customized.
Reference: [Fraser & Hanson 91a] <author> C. W. Fraser and D. R. Hanson. </author> <title> A Code Generation Interface for ANSI C. </title> <journal> Software-Practice and Experience, </journal> <volume> 9(21) </volume> <pages> 963-988, </pages> <month> Sep </month> <year> 1991. </year>
Reference-contexts: There as a total of 40 different opcodes. Some of these opcodes have type-suffixes, making a total of 70 operations. Our design is greatly inspired by the design and implementation of the lcc compiler <ref> [Fraser & Hanson 91a, Fraser & Hanson 91b] </ref>. The DAG structure has several nice properties that made it our Alpha representation of choice. First, it does not assume any specific register model or number of registers. <p> The DAG structure has several nice properties that made it our Alpha representation of choice. First, it does not assume any specific register model or number of registers. Second, it is relatively simple to generate efficient RISC code from the DAG <ref> [Fraser & Hanson 91a] </ref>. Third, basic optimizations, such as common subexpression elimination, constant folding, dead code elimination, can easily be carried-out by the compiler, and the DAG representation contains enough information to support more advanced optimizations, such as inlining, at runtime [McConnell 93]. <p> In fact, the BETA fragment structure [Madsen 93b] can be used in the MetaBETA model too. The Alpha code format was directly inspired by the work done on the lcc C compiler <ref> [Fraser & Hanson 91b, Fraser & Hanson 91a] </ref> and on Tree Based code optimizations [McConnell 93]. The experience from the implementation of the lcc compiler has shown that efficient code can be generated fast for leading RISC and CISC architectures.
Reference: [Fraser & Hanson 91b] <author> C. W. Fraser and D. R. Hanson. </author> <title> A Retargetable Compiler for ANSI C. </title> <journal> SIGPLAN Notices, </journal> <volume> 10(26) </volume> <pages> 29-43, </pages> <month> Oct </month> <year> 1991. </year>
Reference-contexts: There as a total of 40 different opcodes. Some of these opcodes have type-suffixes, making a total of 70 operations. Our design is greatly inspired by the design and implementation of the lcc compiler <ref> [Fraser & Hanson 91a, Fraser & Hanson 91b] </ref>. The DAG structure has several nice properties that made it our Alpha representation of choice. First, it does not assume any specific register model or number of registers. <p> In fact, the BETA fragment structure [Madsen 93b] can be used in the MetaBETA model too. The Alpha code format was directly inspired by the work done on the lcc C compiler <ref> [Fraser & Hanson 91b, Fraser & Hanson 91a] </ref> and on Tree Based code optimizations [McConnell 93]. The experience from the implementation of the lcc compiler has shown that efficient code can be generated fast for leading RISC and CISC architectures.
Reference: [Goldberg & Robson 89] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80. The Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: The metalevel interface queries and alters the way the runtime system executes a MetaBETA program. BETA Explorability Eiffel Efficiency C++ CLOS Smalltalk Self Viewing the runtime system as the central execution engine is similar to the view taken by dynamically typed 1 languages, such as Smalltalk <ref> [Goldberg & Robson 89] </ref>, Self [Ungar & Smith 87], and CLOS [Kiczales et al. 91]. These languages are based on integrated programming environments that are responsible for the execution of programs, thereby supporting an exploratory programming style. <p> In BETA, this is done using a virtual class. In C++ [Stroustrup 93], the template mechanism could be used. The drawback of modelling dynamic slots as a 3 Slots are similar to instance variables in Smalltalk <ref> [Goldberg & Robson 89] </ref>, and dynamic object references in BETA. <p> The MetaBETA runtime system is using its ability to do dynamic 11 Inter-Process Communication 25 loading, linking, code generation in a similar fashion. 5.4 Other Systems The MetaBETA execution model is very similar to the implementation of dynamic typed languages, such as Smalltalk <ref> [Goldberg & Robson 89] </ref> and Self [Ungar & Smith 87]. They are all based on an underlying virtual machine which is responsible for executing programs. <p> However, it is not clear how this can be integrated into the current metalevel interface. Incorporating dynamic code modifications. The current metalevel architecture is based on runtime extensibility. It would be interesting to extended it to also include runtime code modifications, much in the same way as the Smalltalk <ref> [Goldberg & Robson 89] </ref> and Self [Ungar & Smith 87] implementations allow. This requires both careful design of a model, an interface, and an implementation.
Reference: [Grarup & Seligmann 93] <author> S. Grarup and J. Seligmann. </author> <title> Incremental Mature Garbage Collection. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: Unfortunately, a trivial implementation which statically extends all objects with the extra word will add a significant time and space overhead to a program execution. The memory behaviour of several BETA programs have previously been studied <ref> [Grarup & Seligmann 93] </ref> and is summarized in Table 1 4 . The table shows memory statistics for the BETA Compiler compiling itself (Compiler), an interactive editor for BETA source code (Sif), and a discrete-event simulation system (Factory). <p> The worst-case space overhead can then never 4 The current BETA implementation uses a generational-based garbage-collector, where copy-collection is used for the Infant Object Area (IOA), and a mark-and-compact collector is used for the Adult Object Area (AOA). For a more detailed discussion see <ref> [Grarup & Seligmann 93] </ref> or [Schmidt 96]. 5 Assuming that the size of the IOA area is 512Kb, which is the default. In Section 3.3 actual measurements results will be shown. 13 be worse than statically extending all objects with an extra word.
Reference: [Gronbaek & Malhotra 94] <author> K. Gronbaek and J. Malhotra. </author> <title> Building Tailorable Hypermedia Systems: the embedded-interpreter approach. </title> <booktitle> In Processings of the 8th Conference On Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: With dynamic extensibility, it is possible to use running applications as building blocks for more specialized applications. For example, a hypermedia application can be extended at runtime with support for a drawing application <ref> [Gronbaek & Malhotra 94] </ref>. Dynamic extensibility is normally achieved by dynamic loading and linking or by interpretation (e.g., emacs [Stallman 81]). Reflection (or metalevel computation) makes it possible for a language to extend its own domain.
Reference: [Gronbaek et al. 94] <author> K. Gronbaek, J. Hem, O. Madsen, and L. Sloth. </author> <title> Hypermedia Systems: A Dexter-Based Architecture. </title> <journal> Communications of the ACM, </journal> <volume> 37(2):64 - 74, </volume> <month> February </month> <year> 1994. </year> <month> 30 </month>
Reference-contexts: These problems was recognized during the design and implementation of a number of substrate systems for the Mjolner BETA system, including: type-orthogonal persistence <ref> [Brandt 94, Gronbaek et al. 94] </ref>, distributed object system [Brandt & Madsen 94], an embedded interpreter [Malhotra 93], a source-level debugger, and object- and class-browsers. These tools manipulate objects in a type-independent manner and currently depend on the memory layout of objects, as well as other implementation details.
Reference: [Grove et al. 94] <author> D. Grove, J. Dean, C. Garrett, and C. Chambers. </author> <title> Profile-Guided Receiver Class Prediction. </title> <booktitle> In Proceedings of the 9th Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA), </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: This can be solved by providing the runtime system with a default policy and the ability to modify it. The application programmer can then replace or fine-tune the policy when needed, or use a policy that is based on profiling information (similar to <ref> [Grove et al. 94] </ref>).
Reference: [Hecht 77] <author> M. S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> North-Holland, </publisher> <year> 1977. </year>
Reference: [Holzle & Ungar 94] <author> U. Holzle and D. Ungar. </author> <title> A Third Generation Self Implementation: Reconciling Responsiveness with Performance. </title> <booktitle> In Proceedings of the 9th Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <pages> pages 229 - 243, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: If a large number of slots are in use for individual objects, it might be feasible to store the dynamic slot values in a hash table instead. The dynamic slot implementation could at runtime choose the optimal representation of the slot values to maximize its performance. The Self system <ref> [Holzle & Ungar 94] </ref> allows objects to be dynamically extended during runtime using the addSlot method. They allocate a new object with the additional slot, copy the contents of the old object to the new object, and update all pointers to point to the new object. <p> They are all based on an underlying virtual machine which is responsible for executing programs. In particular, the Self implementation, where lots of effort has been devoted to runtime code generation and runtime optimization of code <ref> [Chambers & Ungar 91, Holzle & Ungar 94] </ref>. Many of the techniques used in the Self implementation is possible to apply to the MetaBETA implementation. <p> The Alpha code is accessible for the runtime system and can be used to implement optimizations such as inlining, dead-code eliminations, etc. The Self implementation has shown impressive performance improvements by using dynamic profiling and code optimizations <ref> [Holzle & Ungar 94] </ref>. Runtime code optimizations provide new possibilities that are not present at compile-time. In particular, to optimize code across source code boundaries. For example, INNER chains and descriptor-slots can be inlined.
Reference: [Jul et al. 88] <author> E. Jul, H. Levy, N. Hutchinson, and A. Black. </author> <title> Fine-Grained Mobility in the Emerald System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: as a class is required to be of a certain (sub)type to be used by a particular abstraction; (ii) unsatisfactory performance, because the extra information must be found in auxiliary data-structures; or (iii) the design of special-purpose programming languages, that include tailored support for a specific feature, e.g., the Emerald <ref> [Jul et al. 88] </ref> language is designed and implemented with compiler and runtime support for distribution. A metalevel interface makes it possible to express functionality that depends on the type of an object, i.e., in contrast to only on the state of an object.
Reference: [Kiczales & Lamping 93] <author> G. Kiczales and J. </author> <title> Lamping. </title> <booktitle> Operating Systems: Why Object-Oriented? In Proceedings of International Workshop on Object-Orientation in Operating Systems (IWOOS), </booktitle> <year> 1993. </year>
Reference-contexts: One way to deal with these mapping dilemmas is to represent them explicit in the implementation. Thus, a framework should provide two interfaces, a baselevel interface that defines its behaviour, and a metalevel interface that exposes certain parts of its implementation <ref> [Kiczales & Lamping 93] </ref>. An example, of an open implementation is Mach's virtual memory system and external pagers [Accetta et al. 86]. The baselevel interface allows allocation of virtual memory, where as the metalevel interface (external pagers) makes it possible to control the mapping between physical and virtual memory. <p> By having control over these aspects, it can provide detailed information about the current state of the program execution to the application and libraries through its metalevel interface. The runtime system and libraries can also make use of a metalevel interface provided by the operating system <ref> [Kiczales & Lamping 93] </ref>. The definition of a runtime system as a virtual machine for the MetaBETA language pins down the contents of the baselevel interface as the needs defined by the language and its compiler, e.g., memory management and runtime type-checks.
Reference: [Kiczales 92] <author> G. Kiczales. </author> <title> Towards a new model of Abstraction in Software Engineering. </title> <editor> In A. Yonezawa and B. C. Smith, editors, </editor> <booktitle> Proceedings of International Workshop on Reflection and Meta-level Architecture (IMSA), </booktitle> <pages> pages 1-11, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: MetaBETA has has a metalevel interface (MLI) that provides access to the state of a running application and to the default implementation of language primitives. MetaBETA can be viewed as an open implementation <ref> [Kiczales 92] </ref> of the BETA language, since certain implementation aspects are exposed. Class Object Object MLI Runtime System checkpoint Store Persistent serialize arbitrary objects to stable storage. The persistent store has references to a set of objects that are the roots of the object graph that is to be persistent. <p> The design of MetaBETA was initiated to identify the core metalevel functionality needed by these systems and to support those needs through a type-safe metalevel interface. The approach taken in MetaBETA is strongly inspired by the open implementation approach <ref> [Rao 91, Kiczales 92] </ref>. An open implementation is an implementation that not only provides a functional interface but also an implementational interface. It is based on the observation that often a framework might provide (close to) the right abstraction, but certain implementation decisions prevent one from using it.
Reference: [Kiczales et al. 91] <author> G. Kiczales, J. Rivieres, and D. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: BETA Explorability Eiffel Efficiency C++ CLOS Smalltalk Self Viewing the runtime system as the central execution engine is similar to the view taken by dynamically typed 1 languages, such as Smalltalk [Goldberg & Robson 89], Self [Ungar & Smith 87], and CLOS <ref> [Kiczales et al. 91] </ref>. These languages are based on integrated programming environments that are responsible for the execution of programs, thereby supporting an exploratory programming style. This is in sharp contrast to most statically typed languages, where the development environment and program execution environment are separated. <p> Another requirement when implementing type-orthogonal abstractions is to express the functionality in a manner that does not rely on implementation details or require changes to the language implementation, i.e., the language implementation must be open for extensions. Several languages, including CLOS <ref> [Kiczales et al. 91] </ref>, Open C++ [Chiba 95], and MetaBETA provides such capabilities. However, as illustrated above, some type-orthogonal abstractions may need to associate additional information to the objects they work on. A type-orthogonal facility to extend objects is needed to allow for maximum flexibility and efficiency of metalevel programs. <p> Also, static type-checking is not an issue in LISP. In LISP implementations, property-list are typically stored in an external hash table hashed on the symbol's hash value, i.e., not with the symbol. Dynamic slots have also been proposed for CLOS <ref> [Kiczales et al. 91] </ref>, where they denote statically declared attributes but for which memory is allocated on demand. These are very similar to the dynamic slots presented in this report, except that we allow dynamic slots to be declared outside a class definition. That is crucial to support type-orthogonal abstractions. <p> CodA was implemented by modifying the implementation of the Smalltalk interpreter on top of the Smalltalk virtual machine. However, where as in the CodA Smalltalk implementation not much emphasis was put on efficiency, that is a major goal for the MetaBETA implementation. CLOS (Common Lisp Object System) <ref> [Kiczales et al. 91] </ref> was one of the first successful languages with a MOP. It is implemented by a metalevel (or reflective) interpreter, that has a reification interface (or metalevel interface).
Reference: [Kirby et al. 94] <author> G. Kirby, R. Connor, and R. Morrison. </author> <title> START: A Linguistic Reflection Tool Using Hyper-Program Technology. </title> <booktitle> In Proceedings of the 6th International Workshop on Persistent Object Systems, </booktitle> <pages> pages 346 - 365, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: However, by dynamically patching the code, this performance degradation will only be in effect during the use of the reflective hook. This is in contrast to compile-time detection of reflective hook and statically compiling them into the code <ref> [Kirby et al. 94, Chiba 95] </ref>. The key enabling technology is a MetaBETA intermediate representation (MIR). An intermediate representation is used by compiles to separate the code that handles the source language from the code that handles the target language, i.e., to separate the compiler front-end and back-end. <p> These are very similar to the dynamic slots presented in this report, except that we allow dynamic slots to be declared outside a class definition. That is crucial to support type-orthogonal abstractions. Metalevel interfaces have been constructed for several statically-typed languages, including Open C++ [Chiba 95], Napier88 <ref> [Kirby et al. 94] </ref>, and BETA [Brandt & Schmidt 96]. They all support the construction of type-orthogonal abstractions directly in the language itself. In principle, all type-orthogonal abstractions can associate additional information to the objects they work on.
Reference: [Madsen & Norgard 93] <author> O. Madsen and C. Norgard. </author> <title> An Object-Oriented Metaprogramming System. </title> <editor> In J. Knudsen, O. Madsen, B. Magnusson, and M. Lofgren, editors, </editor> <booktitle> Object-Oriented Environments. </booktitle> <publisher> Prentice Hall, </publisher> <month> September </month> <year> 1993. </year>
Reference-contexts: We will in the following describe several future work projects that has been identified. They will be grouped according to the above classification. 6.1 Conceptual Unifying the metalevel interface and the metaprogramming interface. The current Mjolner BETA System contains a metaprogramming system (MPS) <ref> [Madsen & Norgard 93] </ref>, where BETA programs are manipulated as abstract syntax trees (AST).
Reference: [Madsen 93a] <author> O. Madsen. </author> <title> The Implementation of BETA. </title> <editor> In J. Knudsen, O. Madsen, B. Magnusson, and M. Lofgren, editors, </editor> <booktitle> Object-Oriented Environments. </booktitle> <publisher> Prentice Hall, </publisher> <month> September </month> <year> 1993. </year>
Reference-contexts: To avoid this overhead, it is possible to precompile Alpha code to architecture-dependent machine-code and store it in the MIR. Machine-code is generated in units corresponds to an object-descriptor (i.e., an AlphaInfo object). This unit contains the prototype, the generation code (G-code), and the do-part code (M-code) <ref> [Madsen 93a] </ref>. These units can be static linked and stored in an MCimage (see Figure 13). For each object-descriptor, a MachineCode object exist that has a reference to the MCimage that contains the machine-code, and an offset to where it is located in the image.
Reference: [Madsen 93b] <author> O. Madsen. </author> <title> The Mjolner BETA fragment system. </title> <editor> In J. Knudsen, O. Madsen, B. Magnusson, and M. Lofgren, editors, </editor> <booktitle> Object-Oriented Environments. </booktitle> <publisher> Prentice Hall, </publisher> <month> September </month> <year> 1993. </year>
Reference-contexts: By separating the development environment from the runtime system, MetaBETA is not suspect to the problems of extracting an application from the development environment [Agesen & Ungar 94]. In fact, the BETA fragment structure <ref> [Madsen 93b] </ref> can be used in the MetaBETA model too. The Alpha code format was directly inspired by the work done on the lcc C compiler [Fraser & Hanson 91b, Fraser & Hanson 91a] and on Tree Based code optimizations [McConnell 93].
Reference: [Madsen et al. 93] <author> O. L. Madsen, B. Moller-Pedersen, and K. Nygaard. </author> <title> Object-Oriented Programming in the BETA Programming Language. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1993. </year>
Reference-contexts: The challenge is to find a consistent, expressive, and simple interface that can be supported across multiple operating systems and hardware architectures and to built an efficient implementation. MetaBETA is an extension of the BETA language <ref> [Madsen et al. 93] </ref> that supports dynamic extensibility and reflection. MetaBETA has has a metalevel interface (MLI) that provides access to the state of a running application and to the default implementation of language primitives.
Reference: [Magnusson 93] <author> B. Magnusson. </author> <title> The Mjolner Orm. </title> <editor> In J. Knudsen, O. Madsen, B. Magnusson, and M. Lofgren, editors, </editor> <booktitle> Object-Oriented Environments. </booktitle> <publisher> Prentice Hall, </publisher> <month> September </month> <year> 1993. </year>
Reference-contexts: Many of the techniques used in the Self implementation is possible to apply to the MetaBETA implementation. However, since BETA is a statically-typed language, we believe that efficient execution times can be achieved without relying on the same amount of aggressive code optimizations. Statically-typed languages, such as Simula (ORM) <ref> [Magnusson 93] </ref> and Trellis/OWL [O'Brien et al. 87] are also based on an active runtime system and an integrated programming environments. In contrast to these systems, the MetaBETA architecture does not define or rely on an integrated program development environment.
Reference: [Malhotra 93] <author> J. Malhotra. </author> <title> Dynamic Extensibility in a Statically-Compiled Object-Oriented Language. </title> <booktitle> In Proceedings of the International Symposium on Object Technologies for Advanced Software (ISO-TAS), </booktitle> <address> Kanazawa, Japan, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: These problems was recognized during the design and implementation of a number of substrate systems for the Mjolner BETA system, including: type-orthogonal persistence [Brandt 94, Gronbaek et al. 94], distributed object system [Brandt & Madsen 94], an embedded interpreter <ref> [Malhotra 93] </ref>, a source-level debugger, and object- and class-browsers. These tools manipulate objects in a type-independent manner and currently depend on the memory layout of objects, as well as other implementation details. Such dependencies severely compromises portability and type-safety. <p> This is in contrast to a traditional compiled language where the compiler generates a monolithic executable image for each application. MetaBETA program executions are based on an extensible model, similar to the models described by <ref> [Age-sen et al. 89, Malhotra 93] </ref>. The runtime system defines the outer-most block-level for all program executions. To execute an application, the runtime system is extended with the patterns describing that particular application.
Reference: [Masuhara et al. 92] <author> H. Masuhara, S. Matsuoka, T. Watanabe, and A. Yonezawa. </author> <title> Object-Oriented Concurrent Reflective Languages can be Implemented Efficiently. </title> <editor> In A. Paepcke, editor, </editor> <booktitle> Proccedings of the 7th Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <pages> pages 127 - 144, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In other words, the metalevel is isomorphic, the result of executing a MLI operating in MetaBETA is also in the domain of MetaBETA. By having an isomorphic metalevel interface, we avoid a tower of reflective languages each describing the program execution at more specialized level <ref> [Masuhara et al. 92] </ref>. 2.2.3 An Extensible Execution Model The runtime system in the metalevel architecture is the only executing program seen by the operating system. To execute a compiled BETA program, the runtime system is started from the operating system commandline with parameters that specify the application's main pattern.
Reference: [Masuhara et al. 95] <author> H. Masuhara, S. Matsuoka, K. Asai, and A. Yonezawa. </author> <title> Compiling Away the Meta-Level in Object-Oriented Concurrent Reflective Languages Using Partial Evaluation. </title> <booktitle> In Proceedings of the 10th Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <month> October </month> <year> 1995. </year>
Reference-contexts: The MetaBETA metalevel architecture is similar in spirit to the reflective interpreter approach, but the implementation language used by the runtime system is not MetaBETA, but Alpha code. The runtime system rely on runtime code optimizations to reconcile a flexible metalevel interface with efficient program execution. ABCL/R3 <ref> [Masuhara et al. 95] </ref> is also based on a reflective interpreter approach similar to CLOS. In order to gain performance, they use an approach, where the reflective interpreter is partial evaluated with the source program.
Reference: [McAffer 95] <author> J. McAffer. </author> <title> Meta-Level Programming with CodA. </title> <booktitle> In Proceedings of the 9th European Conference on Object-Oriented Programming (ECOOP), </booktitle> <month> August </month> <year> 1995. </year> <month> 31 </month>
Reference-contexts: Also, MetaBETA is based on an active runtime system, that provides runtime extensibility and introspective capabilities. That is not an integral part of the Open C++ MOP. CodA <ref> [McAffer 95] </ref> is a language-independent architecture for implementing reflection in a programming language. Its model is based on reification on primitive operations, such as message send, message delivery, message receive, etc. It is similar in nature to the intercessory part of the MetaBETA MLI, but somewhat more fine-grained.
Reference: [McConnell 93] <author> C. D. McConnell. </author> <title> Tree-Based Code Optimization. </title> <type> PhD dissertation, </type> <institution> Department of Com--puter Science, University of Illinois at Urbana-Champaign, </institution> <year> 1993. </year>
Reference-contexts: Third, basic optimizations, such as common subexpression elimination, constant folding, dead code elimination, can easily be carried-out by the compiler, and the DAG representation contains enough information to support more advanced optimizations, such as inlining, at runtime <ref> [McConnell 93] </ref>. The last two capabilities are not supported very well by stack-code which was another alternative. Stack-code is used by the Java virtual machine [Arnold & Gosling 96]. The Alpha code contains mainly low-level RISC-like primitives, except for 6 BETA specific primitives. <p> In fact, the BETA fragment structure [Madsen 93b] can be used in the MetaBETA model too. The Alpha code format was directly inspired by the work done on the lcc C compiler [Fraser & Hanson 91b, Fraser & Hanson 91a] and on Tree Based code optimizations <ref> [McConnell 93] </ref>. The experience from the implementation of the lcc compiler has shown that efficient code can be generated fast for leading RISC and CISC architectures.
Reference: [Meyer 92] <author> B. Meyer. </author> <title> Eiffel, The Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: We have integrated dynamic slots into the BETA programming language. The object layout used by the Mjolner BETA System is fairly standard for a garbage-collected object-oriented language. A similar implementation can be used for languages such as Eiffel <ref> [Meyer 92] </ref> and Modula-3 [Nelson 91]. In the following, the implementation will be described in more details. 3.2.1 Representing Dynamic Slots The representation of dynamic slots at runtime must be space-efficient, so only slots in use take up space.
Reference: [Murata et al. 94] <author> K. Murata, R. N. Horspool, E. G. Manning, Y. Yokote, and M. Tokoro. Cognac: </author> <title> a Reflective Object-Oriented Programming System using Dynamic Compilation Techniques. </title> <booktitle> In Proceedings of the annual conference of Japan Society of Software Science and Technology 1994 (JSSST), </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: The MOP allows user-level programs to tailor most aspects of the operating system, including message passing, thread scheduling, and virtual memory usage. In the first version, a variant of C++ was used to write extensions to Apertos. Currently, a special language, Cognac <ref> [Murata et al. 94] </ref>, is being implemented that is special designed to utilize the Apertos MOP. The MetaBETA language and the runtime system has a similar relation as Cognac and Apertos.
Reference: [Nelson 91] <author> G. Nelson, </author> <title> editor. System Programming with Modula-3. </title> <publisher> Prentice Hall Series in Innovative Technology, </publisher> <year> 1991. </year>
Reference-contexts: We have integrated dynamic slots into the BETA programming language. The object layout used by the Mjolner BETA System is fairly standard for a garbage-collected object-oriented language. A similar implementation can be used for languages such as Eiffel [Meyer 92] and Modula-3 <ref> [Nelson 91] </ref>. In the following, the implementation will be described in more details. 3.2.1 Representing Dynamic Slots The representation of dynamic slots at runtime must be space-efficient, so only slots in use take up space. <p> In the case of a reference to some unimplemented code, an exception method could be called in the runtime system. The exceptions will be similar to the so called checked runtime errors in Modula-3 <ref> [Nelson 91] </ref>. 6.2 Implementational Code Optimizations. In the MetaBETA implementation it is possible to utilize and experiment with runtime code optimizations. The Alpha code is accessible for the runtime system and can be used to implement optimizations such as inlining, dead-code eliminations, etc.
Reference: [O'Brien et al. 87] <author> P. D. O'Brien, D. C. Halbert, and M. F. Kilian. </author> <title> The Trellis Programming Environment. </title> <booktitle> In Proceedings of the Second Conference On Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <month> October </month> <year> 1987. </year>
Reference-contexts: However, since BETA is a statically-typed language, we believe that efficient execution times can be achieved without relying on the same amount of aggressive code optimizations. Statically-typed languages, such as Simula (ORM) [Magnusson 93] and Trellis/OWL <ref> [O'Brien et al. 87] </ref> are also based on an active runtime system and an integrated programming environments. In contrast to these systems, the MetaBETA architecture does not define or rely on an integrated program development environment.
Reference: [Patterson 85] <author> D. Patterson. </author> <title> Reduced Instruction Set Computers. </title> <journal> CACM, </journal> <volume> 28(1), </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: The do-part is represented as a list of bytecodes for an architecture-independent language: Alpha. The Alpha code is a low-level architecture-independent representation of MetaBETA do-parts. It has the following properties: * Close to RISC <ref> [Patterson 85] </ref>. It is possible to quickly generate efficient code for contemporary micro processor architectures. * BETA specific. Complex actions, such as object invocation, INNER calls and attribute assignment are represented as one operation. * Minimal.
Reference: [Rao 91] <editor> R. Rao. Implementational reflection in Silica. In P. America, editor, </editor> <booktitle> Proceedings of 5th Euro-pean Conference on Object-Oriented Programming (ECOOP), Lecture Notes in Computer Science, </booktitle> <pages> pages 251-267. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The design of MetaBETA was initiated to identify the core metalevel functionality needed by these systems and to support those needs through a type-safe metalevel interface. The approach taken in MetaBETA is strongly inspired by the open implementation approach <ref> [Rao 91, Kiczales 92] </ref>. An open implementation is an implementation that not only provides a functional interface but also an implementational interface. It is based on the observation that often a framework might provide (close to) the right abstraction, but certain implementation decisions prevent one from using it.
Reference: [Schmidt 96] <author> R. W. Schmidt. </author> <title> Dynamically Extensible Objects in a Class-Based Language. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <month> Marts </month> <year> 1996. </year>
Reference-contexts: In a strictly class-based language it is not possible to add extra information to an object at runtime. To circumvent these limitations, it is often necessary to look up information in auxiliary data-structures or to sacrifice type-orthogonality <ref> [Schmidt 96] </ref>. In this report we present dynamic slots, which are a solution to this problem and allow type-orthogonal abstractions to be written in a simple and efficient way. The other main area covered in this report is the implementation of MetaBETA. <p> The worst-case space overhead can then never 4 The current BETA implementation uses a generational-based garbage-collector, where copy-collection is used for the Infant Object Area (IOA), and a mark-and-compact collector is used for the Adult Object Area (AOA). For a more detailed discussion see [Grarup & Seligmann 93] or <ref> [Schmidt 96] </ref>. 5 Assuming that the size of the IOA area is 512Kb, which is the default. In Section 3.3 actual measurements results will be shown. 13 be worse than statically extending all objects with an extra word.
Reference: [Shapiro 86] <author> M. Shapiro. </author> <title> Structure and Encapsulation in Distributed Systems: The Proxy Principle. </title> <booktitle> In Proceedings of The Sixth International Conference on Distributed Computing Systems., </booktitle> <pages> pages 198 - 204, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: The implementation using link-time analysis will then on average require a larger memory overhead than the implementation using dynamic slots. Distribution The distribution library provides transparent access to remote objects, i.e., objects located in another process that possibly exists on another physical machine. Transparency is provided by proxies <ref> [Shapiro 86] </ref>. A remote object is represented by a proxy object in the caller's address-space, which forwards all calls to the remote object. For the caller, the proxy is indistinguishable from the remote object.
Reference: [Stallman 81] <author> R. Stallman. </author> <title> Emacs: The extensible, customizable, self-documenting display editor. </title> <booktitle> In Proceedings of the ACM SIGPLAN SIGOA Symposium on Text Manipulation, </booktitle> <pages> pages 147-156, </pages> <year> 1981. </year>
Reference-contexts: For example, a hypermedia application can be extended at runtime with support for a drawing application [Gronbaek & Malhotra 94]. Dynamic extensibility is normally achieved by dynamic loading and linking or by interpretation (e.g., emacs <ref> [Stallman 81] </ref>). Reflection (or metalevel computation) makes it possible for a language to extend its own domain. Type-orthogonal functionality can be expressed directly in the language, i.e., functionality that depends on the type of an object.
Reference: [Steele 84] <author> G. L. Steele. </author> <title> Common LISP: The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: Another approach could be to extend the language definition with a special syntactical construct for dynamic slot declaration. Attribute references could be used in BETA to refer to the dynamically created attributes. Our approach is similar to LISP property lists <ref> [Steele 84] </ref>, which also uses special access methods. 3.1.1 Examples To further motivate dynamic slots, we will look at three examples where they are applicable.
Reference: [Stroustrup 93] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison Wesley, </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: Dynamic slots are statically typed and dynamically allocated. Notice that it is the ability to have generics that makes it possible to implement the dynamic slot interface using a class and still have static type-checking. In BETA, this is done using a virtual class. In C++ <ref> [Stroustrup 93] </ref>, the template mechanism could be used. The drawback of modelling dynamic slots as a 3 Slots are similar to instance variables in Smalltalk [Goldberg & Robson 89], and dynamic object references in BETA.
Reference: [Ungar & Smith 87] <author> D. Ungar and R. B. Smith. </author> <title> Self: The Power of Simplicity. </title> <booktitle> In Proceedings of the Second Conference On Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <month> October </month> <year> 1987. </year>
Reference-contexts: BETA Explorability Eiffel Efficiency C++ CLOS Smalltalk Self Viewing the runtime system as the central execution engine is similar to the view taken by dynamically typed 1 languages, such as Smalltalk [Goldberg & Robson 89], Self <ref> [Ungar & Smith 87] </ref>, and CLOS [Kiczales et al. 91]. These languages are based on integrated programming environments that are responsible for the execution of programs, thereby supporting an exploratory programming style. <p> Dynamic slots are also related to a number of reflective systems. Prototype-based languages use a similar mechanism as dynamic slots to extend objects. In Self <ref> [Ungar & Smith 87] </ref> objects can be extended with new slots at runtime by using the addSlot method. Dynamic slots were strongly inspired by that feature. <p> The MetaBETA runtime system is using its ability to do dynamic 11 Inter-Process Communication 25 loading, linking, code generation in a similar fashion. 5.4 Other Systems The MetaBETA execution model is very similar to the implementation of dynamic typed languages, such as Smalltalk [Goldberg & Robson 89] and Self <ref> [Ungar & Smith 87] </ref>. They are all based on an underlying virtual machine which is responsible for executing programs. In particular, the Self implementation, where lots of effort has been devoted to runtime code generation and runtime optimization of code [Chambers & Ungar 91, Holzle & Ungar 94]. <p> Incorporating dynamic code modifications. The current metalevel architecture is based on runtime extensibility. It would be interesting to extended it to also include runtime code modifications, much in the same way as the Smalltalk [Goldberg & Robson 89] and Self <ref> [Ungar & Smith 87] </ref> implementations allow. This requires both careful design of a model, an interface, and an implementation.
Reference: [Yokote 92] <author> Y. Yokote. </author> <title> The Apertos Reflective Operating System: The Concept and Its Implementation. </title> <editor> In A. Paepcke, editor, </editor> <booktitle> Proceedings of the seventh Conference On Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <pages> pages 414 - 434, </pages> <month> October </month> <year> 1992. </year> <month> 32 </month>
Reference-contexts: Therefor the runtime system uses runtime code generation and optimization to gain performance. In this way, we avoid a statically analysis of an entire application to determine where reflection is used. 5.3 Reflective Operating Systems Apertos <ref> [Yokote 92] </ref> is a reflective operating system built around a metaobject protocol (MOP). The MOP allows user-level programs to tailor most aspects of the operating system, including message passing, thread scheduling, and virtual memory usage. In the first version, a variant of C++ was used to write extensions to Apertos.
References-found: 55

