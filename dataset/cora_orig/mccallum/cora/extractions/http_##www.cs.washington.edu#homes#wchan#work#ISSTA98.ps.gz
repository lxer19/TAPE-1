URL: http://www.cs.washington.edu/homes/wchan/work/ISSTA98.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/wchan/work/ISSTA98.html
Root-URL: 
Email: fwchan,anderson,beame,notking@cs.washington.edu  
Title: Improving Efficiency of Symbolic Model Checking for State-Based System Requirements  
Author: William Chan Richard J. Anderson Paul Beame David Notkin 
Keyword: Formal verification, symbolic model checking, reach-ability analysis, binary decision diagrams, partitioned transition relation, statecharts, RSML, TCAS II, system requirements specification, abstraction.  
Address: Box 352350 Seattle, WA 98195-2350, USA  
Affiliation: Department of Computer Science and Engineering University of Washington,  
Abstract: We present various techniques for improving the time and space efficiency of symbolic model checking for system requirements specified as synchronous finite state machines. We used these techniques in our analysis of the system requirements specification of TCAS II, a complex aircraft collision avoidance system. They together reduce the time and space complexities by orders of magnitude, making feasible some analysis that was previously intractable. The TCAS II requirements were written in RSML, a dialect of state-charts. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. J. Anderson, P. Beame, S. Burns, W. Chan, F. Modugno, D. Notkin, and J. D. Reese. </author> <title> Model checking large software specifications. </title> <editor> In D. Garlan, editor, </editor> <booktitle> Proceedings of the 4th ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 156166, </pages> <address> San Francisco, CA, USA, </address> <month> Oc-tober </month> <year> 1996. </year>
Reference-contexts: Symbolic model checking [6] using binary decision diagrams (BDDs) [4] is an efficient state-exploration technique for finite state systems; it has been successful on verifying (and falsifying) many industry-scale hardware systems. Its application to non-trivial software or process-control systems is far less mature, but is increasingly promising <ref> [1, 13, 25, 27] </ref>. For example, we obtained encouraging results from applying symbolic model checking to a portion of a preliminary version of the system requirements specification of TCAS II, a complex software avionics system for collision avoidance [1]. <p> For example, we obtained encouraging results from applying symbolic model checking to a portion of a preliminary version of the system requirements specification of TCAS II, a complex software avionics system for collision avoidance <ref> [1] </ref>. The full requirements, comprising about four hundred pages, were written in the Requirements State Machine Language (RSML) [23], a hierarchical state-machine language based on statecharts [16]. This work was supported in part by National Science Foundation grant CCR-970670. W. Chan was supported in part by a Microsoft graduate fellowship. <p> The details of the translation, including how the transitions, the state hierarchy and the synchrony hypothesis were handled, as well as the properties analyzed, were given in a previous paper <ref> [1] </ref>. <p> A coauthor of a previous paper subsequently simplified the counterexample search algorithm, resulting in substantial speedup <ref> [1] </ref>. This is the only technique described here that was used in that study. The forward traversal in the first part of Figure 3 is the bottleneck. For our system, the sequence of post-images requires large BDDs. <p> We performed the experiments on a Sun SPARCstation 10 with 128MB of main memory. Most successful checks used less than 30MB of main memory. Several models were examined. Our starting point, called the full model, is close to the one used in our previous paper <ref> [1] </ref>. The mis-translated model contains a real translation bug, and is included to give an example of analyzing a highly flawed design. The serialized model was obtained from the full model with one of the microsteps serialized. <p> Properties P1 through P4 refer to the properties Increase-Descent Inhibition, Function Consistency, Transition Consistency, and Output Agreement explained in the previous paper <ref> [1] </ref>. Property P5 refers to an assertion in Britt [2, p. 49] that Own-Aircraft should never be in two local states Corrective-Climb . Yes and Corrective-Descend . Yes simultaneously (comments in our version of the TCAS II requirements, however, explicitly say that the two local states are not mutually exclusive).
Reference: [2] <author> J. J. Britt. </author> <title> Case study: Applying formal methods to the Traffic Alert and Collision Avoidance System (TCAS) II. </title> <booktitle> In COMPASS'94, Proceedings of the 9th Annual Conference on Computer Assurance, </booktitle> <pages> pages 3951, </pages> <address> Gaithersburg, MD, USA, June/July 1994. </address> <publisher> IEEE. </publisher>
Reference-contexts: Properties P1 through P4 refer to the properties Increase-Descent Inhibition, Function Consistency, Transition Consistency, and Output Agreement explained in the previous paper [1]. Property P5 refers to an assertion in Britt <ref> [2, p. 49] </ref> that Own-Aircraft should never be in two local states Corrective-Climb . Yes and Corrective-Descend . Yes simultaneously (comments in our version of the TCAS II requirements, however, explicitly say that the two local states are not mutually exclusive). <p> Incorporating the mutual exclusion of certain events into backward traversals generally gave an order of magnitude time and space reduction (Row 4). In addition, we could now easily disprove Properties P5 and P6. In particular, the statement in Britt <ref> [2] </ref> mentioned above is provably false in our version of the requirements. Disjunctive partitioning, which must be combined with the mutual exclusion of events, appeared to be inefficient (Row 6) when compared with applying the mutual exclusion alone (Row 4).
Reference: [3] <author> M. C. Browne, E. M. Clarke, and O. Grumberg. </author> <title> Characterizing finite Kripke structures in propositional temporal logic. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 59(1/2):115131, </address> <month> July </month> <year> 1988. </year>
Reference-contexts: In other words, under the assumptions, the transformation preserves equivalence under stuttering bisimulation <ref> [3] </ref>. 6.2 False Dependency Similar dependency analyses could also be performed by model checkers (such as VIS [28]) on the Boolean model of the statecharts machine. However, a straightforward implementation would not be effective.
Reference: [4] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(6):677691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Formal verification based on state exploration can be considered an extreme form of simulation: every possible behavior of the system is checked for correctness. Symbolic model checking [6] using binary decision diagrams (BDDs) <ref> [4] </ref> is an efficient state-exploration technique for finite state systems; it has been successful on verifying (and falsifying) many industry-scale hardware systems. Its application to non-trivial software or process-control systems is far less mature, but is increasingly promising [1, 13, 25, 27]. <p> Intersection, union and complementation on sets or relations respectively becomes conjunction, disjunction and negation on Boolean functions. Now the problem of representation of state sets is reduced to that of Boolean functions. Empirically, the most efficient representation for Boolean functions is BDDs <ref> [4] </ref>. They are canonical, with efficient implementation for Boolean operations. For example, the time and space complexities of computing the conjunction or disjunction of two BDDs are linear in the size of the result, which is at most the product of the sizes of the operands.
Reference: [5] <author> R. E. Bryant. </author> <title> On the complexity of VLSI implementations and graph representation of boolean functions with applications to integer multiplication. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40(2):205213, </volume> <month> February </month> <year> 1991. </year>
Reference-contexts: It would be interesting to see how well the techniques in this paper scale with the system complexity. The natural way is to try applying them to the rest of TCAS II. Unfortunately, that part contains arithmetic operations, such as multiplication, that provably cannot be represented by small BDDs <ref> [5] </ref>. In a recent paper, we suggest coupling a decision procedure for nonlinear arithmetic constraints with BDD-based model checking to attack the problem [9]. More research is needed to see whether this technique scales to large systems.
Reference: [6] <author> J. R. Burch, E. M. Clarke, D. E. Long, K. L. McMillan, and D. L. Dill. </author> <title> Symbolic model checking for sequential circuit verification. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 13(4):401424, </volume> <month> April </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Formal verification based on state exploration can be considered an extreme form of simulation: every possible behavior of the system is checked for correctness. Symbolic model checking <ref> [6] </ref> using binary decision diagrams (BDDs) [4] is an efficient state-exploration technique for finite state systems; it has been successful on verifying (and falsifying) many industry-scale hardware systems. Its application to non-trivial software or process-control systems is far less mature, but is increasingly promising [1, 13, 25, 27]. <p> The set Y i is the states that may reach an error state in at most i transitions. Many other temporal properties can be similarly defined and computed using (possibly multiple or nested) fixed points <ref> [6] </ref>. 2 Start with Y 0 = E and iteratively compute Y i+1 = Pre (Y i ) [Y i until reaching a fixed point. <p> Thanks to the succinctness of BDDs and the efficiency of their algorithms, some systems with over 10 120 states can be analyzed <ref> [6] </ref>. 2.3 Symbolic Model Checking for TCAS II We analyzed the TCAS II requirements using a symbolic model checker SMV (Version 2.4.4). SMV uses algorithms similar to those in Figures 2 and 3. <p> similarly to the machine in Figure 6, and the set of mutually exclusive events was evident. 5 Partitioned Transition Relation Apart from the BDD size for state sets, another bottleneck of model checking is the BDD size for the transition relation, which can be reduced by conjunctive or disjunctive partitioning <ref> [6] </ref>. The former can be used naturally for TCAS II, and we have modified SMV to partition the transition relation more effectively. We also apply disjunctive partitioning, which is normally used only for asynchronous systems. Combining the two techniques, we obtain DNF partitioning. <p> we will see, the issues in this section are not only the BDD size for the transition relation, but also the size of the intermediate BDDs generated for each image computation. 5.1 Background In this subsection, we review the idea of conjunctive and disjunctive partitioning, described in Burch et al. <ref> [6] </ref>. The transition relation R is sometimes given as a disjunction D 1 _ D 2 _ _ D j , and the BDD for R can be huge even though each disjunct has a small BDD. <p> As explained in Section 2.2, an image computation step involves a conjunction and an existential quantification. The two operations can be carried out simultaneously to avoid building the usually large conjunction explicitly <ref> [6] </ref>. SMV performs this optimization except when conjunctive partitioning is used. We simply changed SMV to eliminate this limitation.) Short-circuiting was most effective on Properties P3 and P4 (Row 2). The savings resulting from the heuristic for conjunctive partitioning were also significant (Row 3).
Reference: [7] <author> G. Cabodi, P. Camurati, L. Lavagno, and S. Quer. </author> <title> Disjunctive partitioning and partial iterative squaring: An effective approach for symbolic traversal of large circuits. </title> <booktitle> In 34th Design Automation Conference, Proceedings 1997, </booktitle> <pages> pages 728733, </pages> <address> Anaheim, CA, USA, </address> <month> June </month> <year> 1997. </year> <note> ACM. </note>
Reference-contexts: They also independently propose disjunctive partitioning for synchronous circuits <ref> [7] </ref>. They require the designer to come up with a partition manually, and we again exploit mutually exclusive events.
Reference: [8] <author> G. Cabodi, P. Camurati, and S. Quer. </author> <title> Efficient state space pruning in symbolic backward traversal. </title> <booktitle> In Proceedings 1994 IEEE International Conference on Computer Design: VLSI in Computers and Processors, </booktitle> <pages> pages 230235, </pages> <address> Cambridge, MA, USA, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: Our method of pruning backward traversals using invariants is similar in spirit to the work on hardware verification by Cabodi et al., who propose doing an approximate forward traversal to compute a superset of the reachable states, which is then used to prune backward traversals <ref> [8] </ref>. (An invariant is precisely a superset of the reachable states.) Their method is more automatic, while the in 9 variants we suggest rely on the designer's knowledge on the syn-chronization of the system. They also independently propose disjunctive partitioning for synchronous circuits [7].
Reference: [9] <author> W. Chan, R. J. Anderson, P. Beame, and D. Notkin. </author> <title> Combining constraint solving and symbolic model checking for a class of systems with non-linear constraints. </title> <editor> In O. Grumberg, editor, </editor> <booktitle> Computer Aided Verification, 9th International Conference, CAV'97 Proceedings, volume 1254 of Lecture Notes in Computer Science, </booktitle> <pages> pages 316327, </pages> <address> Haifa, Israel, June 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Unfortunately, that part contains arithmetic operations, such as multiplication, that provably cannot be represented by small BDDs [5]. In a recent paper, we suggest coupling a decision procedure for nonlinear arithmetic constraints with BDD-based model checking to attack the problem <ref> [9] </ref>. More research is needed to see whether this technique scales to large systems. Acknowledgments We thank Steve Burns, who observed the inefficiency of the algorithm in Figure 3 and implemented the one in Figure 4 in SMV.
Reference: [10] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2):244263, </volume> <month> April </month> <year> 1986. </year>
Reference-contexts: Example properties include that a (bad) state is never reached, and that a (good) state is always reached infinitely often. In explicit model checking, the answer is determined in a graph-theoretic manner by traversing and labeling the vertices in the state graph <ref> [10] </ref>. The method is impractical for many large systems because of the state explosion problem. Much more efficient for large state spaces is symbolic model checking, in which the model checker visits sets of states instead of individual states. <p> PSfrag replacements Q 0 Q m q 0 q m 2 and 3 (and similar algorithms for many temporal logics such as CTL <ref> [10] </ref>) can be implemented using BDDs. Thanks to the succinctness of BDDs and the efficiency of their algorithms, some systems with over 10 120 states can be analyzed [6]. 2.3 Symbolic Model Checking for TCAS II We analyzed the TCAS II requirements using a symbolic model checker SMV (Version 2.4.4).
Reference: [11] <author> O. Coudert, C. Berthet, and J. C. Madre. </author> <title> Verification of synchronous sequential machines based on symbolic execution. </title> <editor> In J. Sifakis, editor, </editor> <title> Automatic Verification Methods for Finite State Systems: </title> <booktitle> International Workshop Proceedings, volume 407 of Lecture Notes in Computer Science, </booktitle> <pages> pages 365373, </pages> <address> Grenoble, France, June 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: (Y i Y i1 )[Y i , with the advantage that Y i Y i1 usually requires a much smaller BDD than Y i does, resulting in faster pre-image computation. (In fact, it is sufficient to compute the pre-image of any Z with Y i Y i1 Z Y i <ref> [11] </ref>.) Similar comments apply to the computation of each Q i in Figure 3. Because SMV does not support hierarchical states and other RSML features directly, we had to translate the requirements into an ordinary finite-state transition system in the SMV language. <p> This invariant can be incorporated into the traversals by either intersecting it with the pre-images or using it as a care-set to simplify them <ref> [11] </ref>. To find out such a set of mutually exclusive events, we may perform a conservative static analysis on the causality of the events. Alternatively, the designer may know which events are mutually exclusive, because the synchronization patterns should have been designed under careful consideration.
Reference: [12] <author> J. Crow and B. L. Di Vito. </author> <title> Formalizing space shuttle software requirements. </title> <booktitle> In Proceedings of the ACM SIGSOFT Workshop on Formal Methods in Software Practice, </booktitle> <pages> pages 4048, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: They contain predicates of local states and of the input variables, and often involve complicated arithmetic. While many other researchers conservatively encode each arithmetic predicate as an independent Boolean variable <ref> [12, 18, 27] </ref>, we encode each input bit as a Boolean variable, resulting in more accurate analysis at the expense of more Boolean variables. In addition, a guarding condition can refer to any part of the system, so the interdependencies between the BDD variables are high.
Reference: [13] <author> M. B. Dwyer, V. Carr, and L. Hines. </author> <title> Model checking graphical user interfaces using abstractions. </title> <booktitle> In FSE5 [14]. </booktitle>
Reference-contexts: Symbolic model checking [6] using binary decision diagrams (BDDs) [4] is an efficient state-exploration technique for finite state systems; it has been successful on verifying (and falsifying) many industry-scale hardware systems. Its application to non-trivial software or process-control systems is far less mature, but is increasingly promising <ref> [1, 13, 25, 27] </ref>. For example, we obtained encouraging results from applying symbolic model checking to a portion of a preliminary version of the system requirements specification of TCAS II, a complex software avionics system for collision avoidance [1].
Reference: [14] <institution> Proceedings of the Joint 6th European Software Engineering Conference and 5th ACM SIGSOFT Symposium on the Foundations of Software Engineering, </institution> <address> Zurich, Switzerland, </address> <month> September </month> <year> 1997. </year>
Reference: [15] <author> D. Geist and I. Beer. </author> <title> Efficient model checking by automated ordering of transition relation partitions. </title> <booktitle> In Computer Aided Verification, 6th International Conference, CAV'94 Proceedings, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 299310, </pages> <address> Stanford, CA, USA, June 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: So the partition is solely determined by the syntax, and no heuristic or semantic information is used. To better determine the partition, we changed SMV to allow the user to specify the partition manually. We also implemented in SMV a variant of the heuristics by Geist and Beer <ref> [15] </ref> and by Ran-jan et al. [26] to automatically determine the partition. The central idea behind the heuristics is to greedily select conjuncts that allow early quantification of more variables while introducing fewer variables that cannot be quantified out. Our implementation of the heuristics worked quite well.
Reference: [16] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 8(3):231274, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: The full requirements, comprising about four hundred pages, were written in the Requirements State Machine Language (RSML) [23], a hierarchical state-machine language based on statecharts <ref> [16] </ref>. This work was supported in part by National Science Foundation grant CCR-970670. W. Chan was supported in part by a Microsoft graduate fellowship. In Proceedings of the 1998 International Symposium on Software Testing and Analysis (ISSTA), March 1998, Clearwater Beach, FL, USA.
Reference: [17] <author> D. Harel and A. Naamad. </author> <title> The STATEMATE semantics of statecharts. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 5(4):293333, </volume> <month> October </month> <year> 1996. </year>
Reference-contexts: So only the transition from B . 1 to B . 2 is enabled and taken, generating event z and finishing the step. Subtle but important semantic differences exist among variants of statecharts. The semantics of STATEMATE <ref> [17] </ref>, another major variant of statecharts, are close to those of RSML. STATEMATE does not enforce the synchrony hypothesis in the semantics, but provides it as an option in the simulator.
Reference: [18] <author> M. P. E. Heimdahl and N. G. Leveson. </author> <title> Completeness and consistency in hierarchical state-based requirements. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(6):363377, </volume> <month> June </month> <year> 1996. </year>
Reference-contexts: They contain predicates of local states and of the input variables, and often involve complicated arithmetic. While many other researchers conservatively encode each arithmetic predicate as an independent Boolean variable <ref> [12, 18, 27] </ref>, we encode each input bit as a Boolean variable, resulting in more accurate analysis at the expense of more Boolean variables. In addition, a guarding condition can refer to any part of the system, so the interdependencies between the BDD variables are high. <p> To detect such false dependencies, one can check whether the disjunction of the guarding conditions of the transitions out of a local state with the same trigger and action events is a tautology. This can sometimes be checked efficiently using BDDs <ref> [18] </ref>. However, the syntax of RSML and STATEMATE allows easy detection of most false dependencies of this kind. Notice that the self-loops in Figure 8 are solely for synchronizationthey make sure that u is generated regardless whether there has been a local state change.
Reference: [19] <author> M. P. E. Heimdahl and M. W. Whalen. </author> <title> Reduction and slicing of hierarchical state machines. </title> <booktitle> In FSE5 [14]. </booktitle>
Reference-contexts: They also independently propose disjunctive partitioning for synchronous circuits [7]. They require the designer to come up with a partition manually, and we again exploit mutually exclusive events. In work also independent of ours, Heimdahl and Whalen <ref> [19] </ref> use a dependency analysis technique similar to the one described Section 6.1, but their motivation is to facilitate manual review of the TCAS II requirements, rather than automatic verification.
Reference: [20] <author> A. J. Hu and D. L. Dill. </author> <title> Reducing BDD size by exploiting functional dependencies. </title> <booktitle> In 30th ACM/IEEE Design Automation Conference, Proceedings 1993, </booktitle> <pages> pages 266271, </pages> <address> Dallas, TX, USA, </address> <month> June </month> <year> 1993. </year> <month> 10 </month>
Reference-contexts: Nevertheless, the verification of many hardware systems tends to benefit, rather than suffer, from forward traversals. For example, Iwashita et al. report significant speedup in CTL model checking for their hardware benchmarks when forward instead of backward traversals are used [21]. Partly inspired by Hu and Dill <ref> [20] </ref>, we believe that the inefficiency is mainly due to the complex invariants of TCAS II, which are maintained by forward but not backward traversals. As an example, consider the state machine in Figure 5.
Reference: [21] <author> H. Iwashita, T. Nakata, and F. Hirose. </author> <title> CTL model check-ing based on forward state traversal. </title> <booktitle> In 1996 IEEE/ACM International Conference on Computer-Aided Design, Digest of Technical Papers, </booktitle> <pages> pages 8287, </pages> <address> San Jose, CA, USA, </address> <month> Novem-ber </month> <year> 1996. </year>
Reference-contexts: Nevertheless, the verification of many hardware systems tends to benefit, rather than suffer, from forward traversals. For example, Iwashita et al. report significant speedup in CTL model checking for their hardware benchmarks when forward instead of backward traversals are used <ref> [21] </ref>. Partly inspired by Hu and Dill [20], we believe that the inefficiency is mainly due to the complex invariants of TCAS II, which are maintained by forward but not backward traversals. As an example, consider the state machine in Figure 5.
Reference: [22] <author> R. P. Kurshan. </author> <title> Computer-Aided Verification of Coordinating Processes: The Automata-Theoretic Approach. </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference-contexts: As noted before, we gained relatively large reduction because Other-Aircraft was not fully modeled, and we suspect that in a complete system, the reduction obtained by this exact analysis could be limited. However, more reduction can be obtained if we forsake exactness. For example, localization reduction <ref> [22] </ref> is one such technique, which aggressively generates an abstracted model that may not satisfy the property while the full model does.
Reference: [23] <author> N. G. Leveson, M. P. E. Heimdahl, H. Hildreth, and J. D. Reese. </author> <title> Requirements specification for process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9), </volume> <month> September </month> <year> 1994. </year>
Reference-contexts: The full requirements, comprising about four hundred pages, were written in the Requirements State Machine Language (RSML) <ref> [23] </ref>, a hierarchical state-machine language based on statecharts [16]. This work was supported in part by National Science Foundation grant CCR-970670. W. Chan was supported in part by a Microsoft graduate fellowship.
Reference: [24] <author> K. L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: However, transferring this technology to new domains may require alternative techniques and heuristics to combat the BDD-blowup problem. In this paper, we present modifications to the algorithms implemented in a symbolic model checker (SMV <ref> [24] </ref>), modifications to the model, as well as a simple abstraction technique, to improve the time and space efficiency of the TCAS II analysis.
Reference: [25] <author> R. Pugliese and E. Tronci. </author> <title> Automatic verification of a hydroelectric power plant. </title> <editor> In M.-C. Gaudel and J. Woodcock, editors, FME'96: </editor> <booktitle> Industrial Benefit and Advances in Formal Methods, 3rd International Symposium of Formal Methods Europe, Proceedings, volume 1051 of Lecture Notes in Computer Science, </booktitle> <pages> pages 425444, </pages> <address> Oxford, UK, March 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Symbolic model checking [6] using binary decision diagrams (BDDs) [4] is an efficient state-exploration technique for finite state systems; it has been successful on verifying (and falsifying) many industry-scale hardware systems. Its application to non-trivial software or process-control systems is far less mature, but is increasingly promising <ref> [1, 13, 25, 27] </ref>. For example, we obtained encouraging results from applying symbolic model checking to a portion of a preliminary version of the system requirements specification of TCAS II, a complex software avionics system for collision avoidance [1].
Reference: [26] <author> R. K. Ranjan, A. Aziz, R. K. Brayton, B. Plessier, and C. Pix-ley. </author> <title> Efficient BDD algorithms for FSM synthesis and verification. </title> <booktitle> In Proceedings of IEEE/ACM International Workshop on Logic Synthesis, </booktitle> <address> Lake Tahoe, USA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: To better determine the partition, we changed SMV to allow the user to specify the partition manually. We also implemented in SMV a variant of the heuristics by Geist and Beer [15] and by Ran-jan et al. <ref> [26] </ref> to automatically determine the partition. The central idea behind the heuristics is to greedily select conjuncts that allow early quantification of more variables while introducing fewer variables that cannot be quantified out. Our implementation of the heuristics worked quite well.
Reference: [27] <author> T. Sreemani and J. M. Atlee. </author> <title> Feasibility of model checking software requirements: A case study. </title> <booktitle> In COMPASS'96, Proceedings of the 11th Annual Conference on Computer Assurance, </booktitle> <pages> pages 7788, </pages> <address> Gaithersburg, MD, USA, </address> <month> June </month> <year> 1996. </year> <note> IEEE. </note>
Reference-contexts: Symbolic model checking [6] using binary decision diagrams (BDDs) [4] is an efficient state-exploration technique for finite state systems; it has been successful on verifying (and falsifying) many industry-scale hardware systems. Its application to non-trivial software or process-control systems is far less mature, but is increasingly promising <ref> [1, 13, 25, 27] </ref>. For example, we obtained encouraging results from applying symbolic model checking to a portion of a preliminary version of the system requirements specification of TCAS II, a complex software avionics system for collision avoidance [1]. <p> They contain predicates of local states and of the input variables, and often involve complicated arithmetic. While many other researchers conservatively encode each arithmetic predicate as an independent Boolean variable <ref> [12, 18, 27] </ref>, we encode each input bit as a Boolean variable, resulting in more accurate analysis at the expense of more Boolean variables. In addition, a guarding condition can refer to any part of the system, so the interdependencies between the BDD variables are high.
Reference: [28] <author> The VIS Group. </author> <title> VIS: A system for verification and synthesis. </title> <editor> In R. Alur and T. A. Henzinger, editors, </editor> <booktitle> Computer Aided Verification, 8th International Conference, CAV'96 Proceedings, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 428432, </pages> <address> New Brunswick, NJ, USA, July/August 1996. </address> <publisher> Springer-Verlag. </publisher> <pages> 11 </pages>
Reference-contexts: In other words, under the assumptions, the transformation preserves equivalence under stuttering bisimulation [3]. 6.2 False Dependency Similar dependency analyses could also be performed by model checkers (such as VIS <ref> [28] </ref>) on the Boolean model of the statecharts machine. However, a straightforward implementation would not be effective. The reason is that in the model, an input would appear to depend on every event because of the way we encoded the synchrony hypothesis (Section 2.3).
References-found: 28

