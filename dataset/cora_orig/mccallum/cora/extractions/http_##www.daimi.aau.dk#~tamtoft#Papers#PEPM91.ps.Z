URL: http://www.daimi.aau.dk/~tamtoft/Papers/PEPM91.ps.Z
Refering-URL: http://www.daimi.aau.dk/~tamtoft/papers.html
Root-URL: http://www.daimi.aau.dk
Email: e-mail: tamtoft@daimi.aau.dk  
Title: Properties of Unfolding-based Meta-level Systems  
Author: Torben Amtoft 
Address: Ny Munkegade, building 540 DK-8000 Arhus C, Denmark  
Affiliation: Computer Science Department Aarhus University  
Abstract: It is well known that the performance of a program can often be improved by means of program transformation. Several program transformation techniques, eg. partial evaluation, work as follows: it is recognized that the original program often, when executed, enters states with common components. From these components alone it may be possible to do a lot of computations once and for all, which otherwise would have to be done again and again. The evaluation of the common components mentioned above may itself benefit from identifying common components and evaluating them separately once and for all. Even this evaluation process may possess common components, etc: : : an arbitrarily high level of "nesting" can be achieved, at least in theory. The purpose of this paper is threefold: 
Abstract-found: 1
Intro-found: 1
Reference: [Amt91] <author> Torben Amtoft Hansen: </author> <title> Properties of Unfolding-based Meta-level Systems. </title> <address> DAIMI-PB 348, </address> <month> March </month> <year> 1991, </year> <institution> Computer Science Department, Aarhus University. </institution>
Reference-contexts: Section 7 briefly discusses how to extend the framework to deal with an unrestricted use of folding, as well as how to translate it to a functional setting. Section 8 concludes. For a full version of this paper, including all proofs omitted here, see <ref> [Amt91] </ref>. 2 Examples Loop Combining Consider the set of Horn clauses (which adds one to each element of a list of unary numbers) a1 ([],[]). a suitable representation of which being M 0 .
Reference: [BKPR89] <author> F.S. de Boer, J.N. Kok, C. Palamidessi and J.J.M.M. Rutten: </author> <title> From Failure to Success: Comparing a Denotational and a Declarative Semantics for Horn Clause Logic. </title> <type> Technical Report CS-R89, </type> <institution> Centre for Mathematics and Computer Science, </institution> <address> Amsterdam, </address> <year> 1989 </year>
Reference-contexts: Then E (ff) [ E (fi) so ff " fi = fy=b; w=a; x=f (b; a); z=g (b)g. On the other hand, fx=ag " fx=bg = &gt;. It is in fact possible (as done in <ref> [BKPR89] </ref> and implicitly in [Fra85]) to build a theory of logic programming in terms of the least-upper-bound operation.
Reference: [BonDan90] <author> Anders Bondorf, Olivier Danvy: </author> <title> Automatic Autoprojection of Recursive Equations with Global Variables and Abstract Data types. </title> <type> Technical Report no. 90-4, </type> <institution> DIKU, University of Copenhagen, Denmark </institution>
Reference-contexts: An example of such a system is SIMILIX <ref> [BonDan90] </ref> where let-expressions are inserted during transformation to guarantee that argument expressions are neither thrown away nor duplicated by unfolding. * Evaluation is strict, transformation is (partially) lazy: Then transformation is able to reduce execution time by an order of magnitude, as sketched in section 5.1 (but also to augment it,
Reference: [BurDar77] <author> R.M.Burstall, J. Darlington: </author> <title> A Transformation System for Developing Recursive Programs. </title> <journal> Jour. of the ACM, January 1977, </journal> <volume> vol. 24, no. 1, </volume> <pages> pp. 44-67. </pages>
Reference-contexts: One of his reasons for preferring the framework of expression procedures to the unfold/fold framework of <ref> [BurDar77] </ref> was that transformation based on expression procedures are guaranteed to preserve termination properties. <p> We have thus seen a classical program transformation based on the fold/unfold framework without "where-abstractions" <ref> [BurDar77] </ref> that can be expressed in terms of meta-level systems. We conjecture that almost all examples of applications of the fold/unfold framework can be made to fit into this scheme see [Sch80] for a further discussion on the subject. <p> Another application of the "rewriting" technique is given in [PetBur82]: by a sequence of steps, where function definitions are replaced by equivalent but more efficient counterparts, the fibonacci program is transformed into a logarithmic version. <ref> [BurDar77, p. 48,64] </ref> gives a brief informal account of the efficiency (measured in terms of aritmetic operations performed) of the new program versus the efficiency of the old. Here where-abstractions and rewritings are claimed to be the only sources of efficiency improvement; unfolding only preserves efficiency.
Reference: [Fra85] <author> Gudmund Frandsen: </author> <title> A Denotational Semantics for Logic Programming. </title> <address> DAIMI-PB 201, </address> <month> November </month> <year> 1985, </year> <institution> Computer Science Department, Aarhus University </institution>
Reference-contexts: Then E (ff) [ E (fi) so ff " fi = fy=b; w=a; x=f (b; a); z=g (b)g. On the other hand, fx=ag " fx=bg = &gt;. It is in fact possible (as done in [BKPR89] and implicitly in <ref> [Fra85] </ref>) to build a theory of logic programming in terms of the least-upper-bound operation.
Reference: [Pal89] <author> Catuscia Palamidessi: </author> <title> Algebraic Properties of Idempotent Substitutions. </title> <type> Technical Report TR-33/89, </type> <institution> University of Pisa, </institution> <year> 1989. </year>
Reference-contexts: To do so, we first need (as we work within a logic language) to discuss the properties of substitutions a bit. The treatment is mainly borrowed from <ref> [Pal89] </ref>. 3.1 Substitutions A substitution is a mapping ff from variables into terms such that xff = x for all but a finite number of x, those x where xff 6= x called the domain of ff.
Reference: [PetBur82] <author> Alberto Pettorossi, R.M. Burstall: </author> <title> Deriving very Efficient Algorithms for Evaluating Linear Recurrence Relations Using the Program Transformation Technique. </title> <journal> Acta Informatica, </journal> <volume> vol. 18, </volume> <year> 1982, </year> <pages> pp. 181-206. </pages>
Reference-contexts: Using the equivalence above (and also exploiting that xffi [] = x for all x), one can (using an "accumulating parameter") transform a program doing list reversal from being quadratic into being linear (in the length of the list). Another application of the "rewriting" technique is given in <ref> [PetBur82] </ref>: by a sequence of steps, where function definitions are replaced by equivalent but more efficient counterparts, the fibonacci program is transformed into a logarithmic version. [BurDar77, p. 48,64] gives a brief informal account of the efficiency (measured in terms of aritmetic operations performed) of the new program versus the efficiency
Reference: [Sch80] <author> W.L. Scherlis: </author> <title> Expression Procedures and Program Derivation. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> August </month> <year> 1980. </year> <note> Computer Science Report STAN-CS-80-818 </note>
Reference-contexts: This is the technique corresponding to classical me moization. 1.3 Related work At least when restricted to two levels, meta-level systems as defined in this paper bear a strong resemblance to the expression procedures invented by Scherlis <ref> [Sch80] </ref> in a functional setting (he, however, made no attempt to measure the efficiency improvements). One of his reasons for preferring the framework of expression procedures to the unfold/fold framework of [BurDar77] was that transformation based on expression procedures are guaranteed to preserve termination properties. <p> We have thus seen a classical program transformation based on the fold/unfold framework without "where-abstractions" [BurDar77] that can be expressed in terms of meta-level systems. We conjecture that almost all examples of applications of the fold/unfold framework can be made to fit into this scheme see <ref> [Sch80] </ref> for a further discussion on the subject. <p> The basic deficiency is that it does not account for "strong" transformation techniques, due to the fact that all levels in some sense are isomorphic. * As already mentioned, an analogue to the result proven in section 6 is presented in <ref> [Sch80] </ref> he is also able to prove preservation of termination properties under some very weak conditions. We think it simplifies matters considerably (though the reader may disagree!) to work in a logical setting. * A complexity measure for a given transition was given.
References-found: 8

