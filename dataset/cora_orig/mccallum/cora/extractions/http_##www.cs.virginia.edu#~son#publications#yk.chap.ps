URL: http://www.cs.virginia.edu/~son/publications/yk.chap.ps
Refering-URL: http://www.cs.virginia.edu/~son/publications.html
Root-URL: http://www.cs.virginia.edu
Title: Chapter 21 Predictability and Consistency in Real-Time Database Systems  
Author: Young-Kuk Kim and Sang H. Son 
Note: 21.1 Introduction 509  
Abstract: Real-time database systems (RTDBS) have transactions with explicit timing constraints, such as ready time, deadlines, and temporal constraints. Conventional database systems lack features for supporting these real-time transactions. Meeting the requirements of RTDBS requires a balanced and coordinated effort between concurrency control and transaction scheduling. Current research efforts in RTDBS have been focused on scheduling transactions with soft or firm deadlines with seri-alizability as the sole correctness criterion. In this chapter, we focus on predictability and consistency of RTDBS. We first discuss characteristics and requirements of RTDBS. Then we present a framework to support predictability for real-time transactions and address consistency issues to explore non-serializable semantics of real-time applications. As our society becomes more integrated with computer technology, information processing for human activities necessitates computing that responds to requests in real-time rather than just with best-effort. Many computer systems are now used to monitor and control physical devices and large complex systems which must have predictable and timely behaviors. We call such systems real-time systems. Some real-time systems must maintain and manipulate data shared by many tasks; thus they need to have databases which can provide the services needed by real-time computations. Real-time database systems (RTDBS) have (at least some) transactions with explicit timing constraints, such as deadlines and temporal distances. RTDBS are becoming increasingly important in a wide range of applications, such as aerospace and weapon systems, computer-integrated manufacturing, robotics, nuclear power 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Abbott and H. Garcia-Molina. </author> <title> Scheduling Real-Time Transactions: A Performance Evaluation. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(3) </volume> <pages> 513-560, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Although much work has been done on the topics of real-time transaction processing, it is generally agreed that there is a lack of fundamental theory for real-time database systems <ref> [1, 22, 24] </ref>. Most real-time database operations are characterized by (1) their time constrained access to data, and (2) access to data that has temporal validity. <p> This allows the system to discard infeasible transactions (i.e., transactions which may not complete before its deadline) even before they begin execution so that wasted computations, aborts, and restarts can be avoided <ref> [1, 17] </ref>. 21.2.4 Operating System and Architectural Support Most research efforts on real-time database systems have concentrated on developing and evaluating real-time transaction scheduling algorithms, including priority assignment, disk I/O scheduling, concurrency control, and conflict resolution schemes, all of which performance goals are to minimize the deadline miss ratio of transactions <p> 17]. 21.2.4 Operating System and Architectural Support Most research efforts on real-time database systems have concentrated on developing and evaluating real-time transaction scheduling algorithms, including priority assignment, disk I/O scheduling, concurrency control, and conflict resolution schemes, all of which performance goals are to minimize the deadline miss ratio of transactions <ref> [1, 4, 9-13, 17, 20] </ref>. However, less attention has been paid to architectural and operating system aspects of the system, supporting the predictable behavior of a real-time transaction. We believe that without adequate support in the underlying subsystems, none of the scheduling algorithms can guarantee predictable system performance. <p> transaction management scheme which can guarantee the given performance requirements of real-time applications and maintain consistency requirements of a real-time database. 21.3 The Real-Time Database Model Most real-time database scheduling algorithms have been developed and evaluated under almost the same workload and operating environment model used in conventional database systems <ref> [1, 10, 12, 25] </ref>. That is, transactions are assumed to arrive in a Poisson stream at a specified mean rate. Each transaction consists of a random sequence of pages to be read, a subset of which are also updated. In addition, a conventional disk-based database environment is assumed. <p> However, we decide not to further categorize soft real-time transactions but to concentrate on Class I and II transactions. Much work has been already done for this class of transactions <ref> [1, 10, 12, 25] </ref>. Moreover, all Class III transactions are supposed to have the same level of importance (noncritical) and not to require an individual performance guarantee. <p> Most real-time database research uses the models which include only a subset of the above classes (e.g., fClass Ig [3, 22, 26] or fClass IIIg <ref> [1, 10, 12, 25] </ref>), and never discriminate among transactions in the system. However, in practice, all kinds of transactions can coexist in one system.
Reference: [2] <author> N. C. Audsley, A. Burns, M. F. Richardson, and A. J. Wellings. </author> <title> Hard Real-Time Scheduling: The Deadline Monotonic Approach. </title> <booktitle> In Proceedings of the 8th IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <address> Atlanta, GA, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Then, we can derive the following conditions for a Class IB transaction's period in order to maintain temporal consistency of derived objects, assuming that transactions are scheduled and guaranteed to meet the deadlines based on the deadline-monotonic scheduling algorithm <ref> [2] </ref> and if D x i = D y , then the priority of t y must be higher than that of t x i : P x i + D x i avd x i ; (21.3) D y D x i ; and (21.5) That is, unlike Equation (21.2), <p> Thus, no concurrency control is required and the deadline-monotonic scheduling algorithm can be applied for this group of transactions. Schedulability tests for deadline-monotonic scheduling theory have been developed in <ref> [2] </ref>. Class II Transactions. With deterministic subsystem support, we can bound the time to fetch one instance of the data objects accessed by a Class II transaction t (t fetch ). <p> A method for guaranteeing deadlines of sporadic processes with correct run-time estimates within deadline-monotonic scheduling framework is shown in <ref> [2] </ref>. By using this method, it can guarantee that if the value t s is used as the transaction's run-time estimate, the transaction will meet its deadline with the probability no less than p s (i.e., it will achieve the given guarantee level p s ). <p> In this way, overrunning Class II transactions never affect the other hard real-time transactions in T I [ T II . Even though a basic schedulability analysis for the deadline-monotonic scheduling algorithm has been presented in <ref> [2] </ref>, a more realistic off-line schedulability analysis must be performed on transactions in T I [ T II , which includes all the possible system overheads occurred in the underlying scheduling mechanism [5, 6].
Reference: [3] <author> N. C. Audsley, A. Burns, M. F. Richardson, and A. J. Wellings. </author> <title> Absolute and Relative Temporal Constraints in Hard Real-Time Databases. </title> <booktitle> In Proceedings of the 1992 IEEE EuroMicro Workshop on Real Time Systems, </booktitle> <month> February </month> <year> 1992. </year>
Reference-contexts: However, we exclude these cases from our consideration because it is not feasible to guarantee their timing constraints, and thus they should not be hard real-time transactions. Most real-time database research uses the models which include only a subset of the above classes (e.g., fClass Ig <ref> [3, 22, 26] </ref> or fClass IIIg [1, 10, 12, 25]), and never discriminate among transactions in the system. However, in practice, all kinds of transactions can coexist in one system.
Reference: [4] <author> A. Buchmann et al. </author> <title> Time-Critical Database Scheduling: A Framework for Integrating Real-Time Scheduling and Concurrency Control. </title> <booktitle> In Proceedings of the 5th International Conference on Data Engineering. IEEE, </booktitle> <address> New York, </address> <month> February </month> <year> 1989. </year>
Reference-contexts: 17]. 21.2.4 Operating System and Architectural Support Most research efforts on real-time database systems have concentrated on developing and evaluating real-time transaction scheduling algorithms, including priority assignment, disk I/O scheduling, concurrency control, and conflict resolution schemes, all of which performance goals are to minimize the deadline miss ratio of transactions <ref> [1, 4, 9-13, 17, 20] </ref>. However, less attention has been paid to architectural and operating system aspects of the system, supporting the predictable behavior of a real-time transaction. We believe that without adequate support in the underlying subsystems, none of the scheduling algorithms can guarantee predictable system performance.
Reference: [5] <author> A. Burns and A. J. Wellings. </author> <title> Implementing Analysable Hard Real-Time Sporadic Tasks in Ada 9X. </title> <type> Technical Report YCS209, </type> <institution> Department of Computer Science, University of York, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: Even though a basic schedulability analysis for the deadline-monotonic scheduling algorithm has been presented in [2], a more realistic off-line schedulability analysis must be performed on transactions in T I [ T II , which includes all the possible system overheads occurred in the underlying scheduling mechanism <ref> [5, 6] </ref>.
Reference: [6] <author> A. Burns, A. J. Wellings, and A. D. Hutcheon. </author> <title> The Impact of an Ada Runtime System's Performance Characteristics on Scheduling Models. </title> <booktitle> In Proceedings of the 12th Ada Europe Conference, </booktitle> <volume> LNCS 688, </volume> <pages> pages 240-248. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1993. </year> <title> 530 Predictability and Consistency in Real-Time Database Systems Chap. </title> <type> 21 </type>
Reference-contexts: Even though a basic schedulability analysis for the deadline-monotonic scheduling algorithm has been presented in [2], a more realistic off-line schedulability analysis must be performed on transactions in T I [ T II , which includes all the possible system overheads occurred in the underlying scheduling mechanism <ref> [5, 6] </ref>.
Reference: [7] <author> R. I. Davis. </author> <title> Approximate Slack Stealing Algorithms for Fixed Priority Preemptive Systems. </title> <type> Technical Report YCS217, </type> <institution> Department of Computer Science, University of York, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Class III Transactions. Within the fixed-priority preemptive scheduling framework, a number of approaches have been developed for scheduling soft real-time tasks along with the guaranteed hard real-time tasks [8, 18, 27, 28]. Our scheduling algorithm for Class III transactions is based on a dynamic slack stealing algorithm presented in <ref> [7, 8] </ref>, since it is based on the deadline-monotonic analysis and is claimed to show better flexibility and performance than any other approaches. The transaction processing protocol for Class III can be described as follows: 1.
Reference: [8] <author> R. I. Davis, K. W. Tindell, and A. Burns. </author> <title> Scheduling Slack Time in Fixed Priority Pre-emptive Systems. </title> <booktitle> In Proceedings of the 14th Real-Time Systems Symposium, </booktitle> <pages> pages 222-231, </pages> <address> Raleigh-Durham, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: The parameters and notations used in the above equations are summarized in Table 21.2. Class III Transactions. Within the fixed-priority preemptive scheduling framework, a number of approaches have been developed for scheduling soft real-time tasks along with the guaranteed hard real-time tasks <ref> [8, 18, 27, 28] </ref>. Our scheduling algorithm for Class III transactions is based on a dynamic slack stealing algorithm presented in [7, 8], since it is based on the deadline-monotonic analysis and is claimed to show better flexibility and performance than any other approaches. <p> Class III Transactions. Within the fixed-priority preemptive scheduling framework, a number of approaches have been developed for scheduling soft real-time tasks along with the guaranteed hard real-time tasks [8, 18, 27, 28]. Our scheduling algorithm for Class III transactions is based on a dynamic slack stealing algorithm presented in <ref> [7, 8] </ref>, since it is based on the deadline-monotonic analysis and is claimed to show better flexibility and performance than any other approaches. The transaction processing protocol for Class III can be described as follows: 1.
Reference: [9] <author> J. Haritsa, M. Carey, and M. Livny. </author> <title> Dynamic Real-Time Optimistic Con-currency Control. </title> <booktitle> In Proceedings of the 11th Real-Time Systems Symposium, </booktitle> <pages> pages 94-103, </pages> <address> Orlando, FL, </address> <month> December </month> <year> 1990. </year>
Reference: [10] <author> J. R. Haritsa. </author> <title> Transaction Scheduling in Firm Real-Time Database Systems. </title> <type> Ph.D. thesis, </type> <institution> University of Wisconsin-Madison, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: transaction management scheme which can guarantee the given performance requirements of real-time applications and maintain consistency requirements of a real-time database. 21.3 The Real-Time Database Model Most real-time database scheduling algorithms have been developed and evaluated under almost the same workload and operating environment model used in conventional database systems <ref> [1, 10, 12, 25] </ref>. That is, transactions are assumed to arrive in a Poisson stream at a specified mean rate. Each transaction consists of a random sequence of pages to be read, a subset of which are also updated. In addition, a conventional disk-based database environment is assumed. <p> However, we decide not to further categorize soft real-time transactions but to concentrate on Class I and II transactions. Much work has been already done for this class of transactions <ref> [1, 10, 12, 25] </ref>. Moreover, all Class III transactions are supposed to have the same level of importance (noncritical) and not to require an individual performance guarantee. <p> Most real-time database research uses the models which include only a subset of the above classes (e.g., fClass Ig [3, 22, 26] or fClass IIIg <ref> [1, 10, 12, 25] </ref>), and never discriminate among transactions in the system. However, in practice, all kinds of transactions can coexist in one system. <p> In this section, we present a semantic-based concurrency control and conflict resolution scheme under our real-time database model. The scheme is based on the optimistic real-time concurrency control (OPT-CC) framework <ref> [10, 17] </ref>, since it can be easily integrated with non-serializable transaction scheduling. Class I Transactions. Since Class I transactions write only continuous data objects which do not require serializable accesses as long as they are temporally consistent, there is no data conflict among them. <p> However, if a conflict occurs with other Class III transactions, it should be resolved based on their priorities (e.g., WAIT-50 <ref> [10] </ref> and OCC-TI [17]). 21.5 Conclusions Transactions with soft or firm deadlines can be processed successfully by using time-cognizant transaction scheduling algorithms without making any special assumptions as to data and transaction semantics.
Reference: [11] <author> J. R. Haritsa, M. Livny, and M. J. Carey. </author> <title> Earliest Deadline Scheduling for Real-Time Database Systems. </title> <booktitle> In Proceedings of the 12th Real-Time Systems Symposium, </booktitle> <pages> pages 232-242, </pages> <month> December </month> <year> 1991. </year>
Reference: [12] <author> J. Huang. </author> <title> Real-Time Transaction Processing: Design, Implementation, and Performance Evaluation. </title> <type> Ph.D. thesis, </type> <institution> University of Massachusetts at Amherst, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: transaction management scheme which can guarantee the given performance requirements of real-time applications and maintain consistency requirements of a real-time database. 21.3 The Real-Time Database Model Most real-time database scheduling algorithms have been developed and evaluated under almost the same workload and operating environment model used in conventional database systems <ref> [1, 10, 12, 25] </ref>. That is, transactions are assumed to arrive in a Poisson stream at a specified mean rate. Each transaction consists of a random sequence of pages to be read, a subset of which are also updated. In addition, a conventional disk-based database environment is assumed. <p> However, we decide not to further categorize soft real-time transactions but to concentrate on Class I and II transactions. Much work has been already done for this class of transactions <ref> [1, 10, 12, 25] </ref>. Moreover, all Class III transactions are supposed to have the same level of importance (noncritical) and not to require an individual performance guarantee. <p> Most real-time database research uses the models which include only a subset of the above classes (e.g., fClass Ig [3, 22, 26] or fClass IIIg <ref> [1, 10, 12, 25] </ref>), and never discriminate among transactions in the system. However, in practice, all kinds of transactions can coexist in one system.
Reference: [13] <author> J. Huang, J. A. Stankovic, et al. </author> <title> Experimental Evaluation of Real-Time Transaction Processing. </title> <booktitle> In Proceedings of the 10th Real-Time Systems Symposium, </booktitle> <address> Santa Monica, CA, </address> <month> December </month> <year> 1989. </year>
Reference: [14] <author> D. I. Katcher, H. Arakawa, and J. K. Strosnider. </author> <title> Engineering and Analysis of Fixed Priority Schedulers. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(9), </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: Assume that the transactions in T I [T II (= ft 1 ; t 2 ; : : : ; t n g) are ordered according to priority with t 1 having the highest priority and t n having the lowest and they are scheduled by a timer-driven scheduler <ref> [14] </ref> (i.e., the scheduler is invoked by a regular timing interrupt with a period denoted by P clk ).
Reference: [15] <author> Young-Kuk Kim and Sang H. Son. </author> <title> An Approach towards Predictable Real-Time Transaction Processing. </title> <booktitle> In Proceedings of the 5th Euromicro Workshop on Real-Time Systems, </booktitle> <pages> pages 70-75, </pages> <address> Oulu, Finland, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: There are two possible approaches to maintaining temporal consistency of real-time data objects: one is a static approach which carefully assigns the periods of Class I transactions in order to automatically maintain temporal consistency of the continuous data objects accessed by the transactions as long as they meet the deadlines <ref> [15, 19, 21] </ref>, and the other is a dynamic approach which either uses multiple versions of data objects [26] or delays some transactions so that all the active transactions can meet the temporal consistency requirements [16]. <p> Currently, we have a real-time database server supporting only firm real-time transactions, running on Real-Time Mach 3.0 [30]. We will extend the current system to have a deterministic software structure as proposed in <ref> [15] </ref> and support the real-time database and transaction model presented in this chapter. Acknowledgments This work was supported in part by ONR, by IBM, and by CIT.
Reference: [16] <author> Tei-Wei Kuo and Aloysius K. Mok. </author> <title> SSP: A Semantics-Based Protocol for Real-Time Data Access. </title> <booktitle> In Proceedings of the 14th Real-Time Systems Symposium, </booktitle> <pages> pages 76-86, </pages> <address> Raleigh-Durham, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: the continuous data objects accessed by the transactions as long as they meet the deadlines [15, 19, 21], and the other is a dynamic approach which either uses multiple versions of data objects [26] or delays some transactions so that all the active transactions can meet the temporal consistency requirements <ref> [16] </ref>. In this section, we present a static approach under the proposed real-time transaction classification framework. Class IA Transactions. A Class IA transaction t x is responsible for maintaining the absolute temporal consistency of an image object x.
Reference: [17] <author> Juhnyoung Lee and Sang H. Son. </author> <title> Using Dynamic Adjustment of Serialization Order for Real-Time Database Systems. </title> <booktitle> In Proceedings of the 14th Real-Time Systems Symposium, </booktitle> <pages> pages 66-75, </pages> <address> Raleigh-Durham, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: This allows the system to discard infeasible transactions (i.e., transactions which may not complete before its deadline) even before they begin execution so that wasted computations, aborts, and restarts can be avoided <ref> [1, 17] </ref>. 21.2.4 Operating System and Architectural Support Most research efforts on real-time database systems have concentrated on developing and evaluating real-time transaction scheduling algorithms, including priority assignment, disk I/O scheduling, concurrency control, and conflict resolution schemes, all of which performance goals are to minimize the deadline miss ratio of transactions <p> 17]. 21.2.4 Operating System and Architectural Support Most research efforts on real-time database systems have concentrated on developing and evaluating real-time transaction scheduling algorithms, including priority assignment, disk I/O scheduling, concurrency control, and conflict resolution schemes, all of which performance goals are to minimize the deadline miss ratio of transactions <ref> [1, 4, 9-13, 17, 20] </ref>. However, less attention has been paid to architectural and operating system aspects of the system, supporting the predictable behavior of a real-time transaction. We believe that without adequate support in the underlying subsystems, none of the scheduling algorithms can guarantee predictable system performance. <p> In this section, we present a semantic-based concurrency control and conflict resolution scheme under our real-time database model. The scheme is based on the optimistic real-time concurrency control (OPT-CC) framework <ref> [10, 17] </ref>, since it can be easily integrated with non-serializable transaction scheduling. Class I Transactions. Since Class I transactions write only continuous data objects which do not require serializable accesses as long as they are temporally consistent, there is no data conflict among them. <p> However, if a conflict occurs with other Class III transactions, it should be resolved based on their priorities (e.g., WAIT-50 [10] and OCC-TI <ref> [17] </ref>). 21.5 Conclusions Transactions with soft or firm deadlines can be processed successfully by using time-cognizant transaction scheduling algorithms without making any special assumptions as to data and transaction semantics.
Reference: [18] <author> J. P. Lehoczky and S. Ramos-Thuel. </author> <title> An Optimal Algorithm for Scheduling Soft-Aperiodic Tasks in Fixed-Priority Preemptive Systems. </title> <booktitle> In Proceedings of the 13th Real-Time Systems Symposium, </booktitle> <pages> pages 110-123, </pages> <address> Phoenix, AZ, </address> <month> Decem-ber </month> <year> 1992. </year>
Reference-contexts: The parameters and notations used in the above equations are summarized in Table 21.2. Class III Transactions. Within the fixed-priority preemptive scheduling framework, a number of approaches have been developed for scheduling soft real-time tasks along with the guaranteed hard real-time tasks <ref> [8, 18, 27, 28] </ref>. Our scheduling algorithm for Class III transactions is based on a dynamic slack stealing algorithm presented in [7, 8], since it is based on the deadline-monotonic analysis and is claimed to show better flexibility and performance than any other approaches.
Reference: [19] <author> K.-J. Lin, F. Jahanian, A. Jhingran, and C. D. Locke. </author> <title> A Model of Hard Real-Time Transaction Systems. </title> <type> Technical Report RC 17515, </type> <institution> IBM T.J. Watson Research Center, </institution> <month> January </month> <year> 1992. </year> <note> References 531 </note>
Reference-contexts: There are two possible approaches to maintaining temporal consistency of real-time data objects: one is a static approach which carefully assigns the periods of Class I transactions in order to automatically maintain temporal consistency of the continuous data objects accessed by the transactions as long as they meet the deadlines <ref> [15, 19, 21] </ref>, and the other is a dynamic approach which either uses multiple versions of data objects [26] or delays some transactions so that all the active transactions can meet the temporal consistency requirements [16].
Reference: [20] <author> Y. Lin and S. H. Son. </author> <title> Concurrency Control in Real-Time Databases by Dynamic Adjustment of Serialization Order. </title> <booktitle> In Proceedings of the 11th Real-Time Systems Symposium, </booktitle> <pages> pages 94-103, </pages> <address> Orlando, FL, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: 17]. 21.2.4 Operating System and Architectural Support Most research efforts on real-time database systems have concentrated on developing and evaluating real-time transaction scheduling algorithms, including priority assignment, disk I/O scheduling, concurrency control, and conflict resolution schemes, all of which performance goals are to minimize the deadline miss ratio of transactions <ref> [1, 4, 9-13, 17, 20] </ref>. However, less attention has been paid to architectural and operating system aspects of the system, supporting the predictable behavior of a real-time transaction. We believe that without adequate support in the underlying subsystems, none of the scheduling algorithms can guarantee predictable system performance.
Reference: [21] <author> H. Nakazato. </author> <title> Issues on Synchronization and Scheduling Tasks in Real-Time Database Systems. </title> <type> Ph.D. thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> January </month> <year> 1993. </year> <note> Also available as UIUCDCS-R-93-1786. </note>
Reference-contexts: There are two possible approaches to maintaining temporal consistency of real-time data objects: one is a static approach which carefully assigns the periods of Class I transactions in order to automatically maintain temporal consistency of the continuous data objects accessed by the transactions as long as they meet the deadlines <ref> [15, 19, 21] </ref>, and the other is a dynamic approach which either uses multiple versions of data objects [26] or delays some transactions so that all the active transactions can meet the temporal consistency requirements [16]. <p> The conflicting Class III transaction must wait until the Class II transaction commits. Thus, no priority ceiling protocol (PCP)-based synchronization scheme <ref> [21] </ref> is necessary to solve priority inversion problem due to shared data objects. Class II transactions can also bypass the validation phase of OPT-CC and always commit. Class III Transactions.
Reference: [22] <author> L. Sha, R. Rajkumar, S. H. Son, and C. Chang. </author> <title> A Real-Time Locking Protocol. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40(7), </volume> <month> July </month> <year> 1991. </year>
Reference-contexts: Although much work has been done on the topics of real-time transaction processing, it is generally agreed that there is a lack of fundamental theory for real-time database systems <ref> [1, 22, 24] </ref>. Most real-time database operations are characterized by (1) their time constrained access to data, and (2) access to data that has temporal validity. <p> However, we exclude these cases from our consideration because it is not feasible to guarantee their timing constraints, and thus they should not be hard real-time transactions. Most real-time database research uses the models which include only a subset of the above classes (e.g., fClass Ig <ref> [3, 22, 26] </ref> or fClass IIIg [1, 10, 12, 25]), and never discriminate among transactions in the system. However, in practice, all kinds of transactions can coexist in one system.
Reference: [23] <author> S. H. Son. </author> <title> Real-Time Database Systems: A New Challenge. </title> <journal> IEEE Data Engineering, </journal> <volume> 13(4) </volume> <pages> 39-43, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: In addition, a conventional disk-based database environment is assumed. The general approach is to utilize existing concurrency control protocols, especially two-phase locking, and to apply time-critical transaction scheduling methods that favor more urgent transactions <ref> [23] </ref>.
Reference: [24] <author> S. H. Son, J. Lee, and Y. Lin. </author> <title> Hybrid Protocols Using Dynamic Adjustment of Serialization Order for Real-Time Concurrency Control. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 4(3) </volume> <pages> 269-276, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Although much work has been done on the topics of real-time transaction processing, it is generally agreed that there is a lack of fundamental theory for real-time database systems <ref> [1, 22, 24] </ref>. Most real-time database operations are characterized by (1) their time constrained access to data, and (2) access to data that has temporal validity.
Reference: [25] <author> S. H. Son, S. Park, and Y. Lin. </author> <title> An Integrated Real-Time Locking Protocol. </title> <booktitle> In Proceedings of the 8th IEEE International Conference on Data Engineering, </booktitle> <pages> pages 527-534, </pages> <address> Phoenix, AZ, </address> <month> February </month> <year> 1992. </year>
Reference-contexts: transaction management scheme which can guarantee the given performance requirements of real-time applications and maintain consistency requirements of a real-time database. 21.3 The Real-Time Database Model Most real-time database scheduling algorithms have been developed and evaluated under almost the same workload and operating environment model used in conventional database systems <ref> [1, 10, 12, 25] </ref>. That is, transactions are assumed to arrive in a Poisson stream at a specified mean rate. Each transaction consists of a random sequence of pages to be read, a subset of which are also updated. In addition, a conventional disk-based database environment is assumed. <p> However, we decide not to further categorize soft real-time transactions but to concentrate on Class I and II transactions. Much work has been already done for this class of transactions <ref> [1, 10, 12, 25] </ref>. Moreover, all Class III transactions are supposed to have the same level of importance (noncritical) and not to require an individual performance guarantee. <p> Most real-time database research uses the models which include only a subset of the above classes (e.g., fClass Ig [3, 22, 26] or fClass IIIg <ref> [1, 10, 12, 25] </ref>), and never discriminate among transactions in the system. However, in practice, all kinds of transactions can coexist in one system.
Reference: [26] <author> X. Song and J. Liu. </author> <title> Performance of Multiversion Concurrency Control Algorithms in Maintaining Temporal Consistency. </title> <booktitle> In Proceedings of the IEEE 14th Annual International Computer Software and Applications Conference (COMPSAC), </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: However, we exclude these cases from our consideration because it is not feasible to guarantee their timing constraints, and thus they should not be hard real-time transactions. Most real-time database research uses the models which include only a subset of the above classes (e.g., fClass Ig <ref> [3, 22, 26] </ref> or fClass IIIg [1, 10, 12, 25]), and never discriminate among transactions in the system. However, in practice, all kinds of transactions can coexist in one system. <p> which carefully assigns the periods of Class I transactions in order to automatically maintain temporal consistency of the continuous data objects accessed by the transactions as long as they meet the deadlines [15, 19, 21], and the other is a dynamic approach which either uses multiple versions of data objects <ref> [26] </ref> or delays some transactions so that all the active transactions can meet the temporal consistency requirements [16]. In this section, we present a static approach under the proposed real-time transaction classification framework. Class IA Transactions.
Reference: [27] <author> B. Sprunt. </author> <title> Aperiodic Task Scheduling for Real-Time Systems. </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: The parameters and notations used in the above equations are summarized in Table 21.2. Class III Transactions. Within the fixed-priority preemptive scheduling framework, a number of approaches have been developed for scheduling soft real-time tasks along with the guaranteed hard real-time tasks <ref> [8, 18, 27, 28] </ref>. Our scheduling algorithm for Class III transactions is based on a dynamic slack stealing algorithm presented in [7, 8], since it is based on the deadline-monotonic analysis and is claimed to show better flexibility and performance than any other approaches.
Reference: [28] <author> B. Sprunt, J. Lehoczky, and L. Sha. </author> <title> Exploiting Unused Periodic Time for Aperiodic Service Using the Extended Priority Exchange Algorithm. </title> <booktitle> In Proceedings of the 9th Real-Time Systems Symposium, </booktitle> <pages> pages 251-258, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: The parameters and notations used in the above equations are summarized in Table 21.2. Class III Transactions. Within the fixed-priority preemptive scheduling framework, a number of approaches have been developed for scheduling soft real-time tasks along with the guaranteed hard real-time tasks <ref> [8, 18, 27, 28] </ref>. Our scheduling algorithm for Class III transactions is based on a dynamic slack stealing algorithm presented in [7, 8], since it is based on the deadline-monotonic analysis and is claimed to show better flexibility and performance than any other approaches.
Reference: [29] <author> J. Stankovic. </author> <title> Real-Time Computing Systems: The Next Generation. </title> <type> Technical Report TR-88-06, </type> <institution> University of Massachusetts, Amherst, </institution> <month> January </month> <year> 1988. </year> <note> Also available as Misconceptioins about Real-Time Computing, IEEE Computer, </note> <month> October </month> <year> 1988. </year>
Reference-contexts: For example, the guarantee level of a hard and soft real-time transaction should be 1 and 0, respectively. Sec. 21.2 Characteristics and Requirements 513 21.2.3 Predictability Real-time computing is not equivalent to fast computing <ref> [29] </ref>. Rather than being fast, more important properties of RTDBS should be timeliness, i.e., the ability to produce expected results early or at the right time, and predictability , i.e., the ability to function as deterministically as necessary to satisfy system specifications, including timing constraints.
Reference: [30] <author> H. Tokuda, T. Nakajima, and P. Rao. </author> <title> Real-Time Mach: Towards Predictable Real-Time Systems. </title> <booktitle> In Proceedings of the USENIX 1990 Mach Workshop, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: Future work includes implementing a deterministic real-time database server, developing a real-time transaction workload generator based on the proposed transaction model, and evaluating the performance of our transaction processing scheme. Currently, we have a real-time database server supporting only firm real-time transactions, running on Real-Time Mach 3.0 <ref> [30] </ref>. We will extend the current system to have a deterministic software structure as proposed in [15] and support the real-time database and transaction model presented in this chapter. Acknowledgments This work was supported in part by ONR, by IBM, and by CIT.
References-found: 30

