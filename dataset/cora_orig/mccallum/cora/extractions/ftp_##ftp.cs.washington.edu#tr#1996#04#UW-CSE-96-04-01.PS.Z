URL: ftp://ftp.cs.washington.edu/tr/1996/04/UW-CSE-96-04-01.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: Using Role Components to Implement Collaboration-Based Designs  
Author: Michael VanHilst and David Notkin 
Date: 4 April 1996  
Address: Seattle, Washington 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Pubnum: Technical Report UW-CSE-96-04-01  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Fereidoon Shams Aliee and Brian C. Warboys. </author> <title> Roles represent patterns. </title> <booktitle> In Proceedings of the VanHilst and Notkin 11 UW-CSE-96-04-01 Workshop on Pattern Languages of Object-Oriented Programs at ECOOP'95, </booktitle> <year> 1995. </year>
Reference-contexts: This can be done informally by drawing on a copy of the roles/responsibilities matrix, or more formally using state-transition diagrams or petri nets, as shown by Aliee and Warboys <ref> [1] </ref>. The Adding Item role in the ReceiptBasis class uses a linked list. We separated the Linked List collaboration from that of Adding Item in order to reuse an existing linked list implementation.
Reference: [2] <author> Kent Beck and Ward Cunningham. </author> <title> A laboratory for teaching object-oriented thinking. </title> <booktitle> In Proceedings of the 1989 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 1-6, </pages> <year> 1989. </year>
Reference-contexts: Collaborations are often used to model sequences of message passing and state changes derived from use-case-like scenarios in the requirements analysis. In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal <ref> [2, 3, 11, 18] </ref>, but they have also been formalized in contracts [10], given a notation [13], and associated with framework implementations [7]. Collaborations provide an ability to abstract. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern. <p> The interaction diagram used to describe the Adding Item collaboration shows the operations that each object needs to fulfill its role in that collaboration. We simply collect the operations for a particular object and determine which attributes those operations use. CRC or class cards <ref> [2, 18] </ref> can be used in a similar manner, if the responsibilities are annotated with the names of the collaborations to which they belong. But we need more information to construct our application, especially when trying to compose several roles to form a single class.
Reference: [3] <author> Grady Booch. </author> <title> Object Oriented Design with Applications. </title> <address> Benjamin/Cummings, </address> <year> 1991. </year>
Reference-contexts: Collaborations are often used to model sequences of message passing and state changes derived from use-case-like scenarios in the requirements analysis. In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal <ref> [2, 3, 11, 18] </ref>, but they have also been formalized in contracts [10], given a notation [13], and associated with framework implementations [7]. Collaborations provide an ability to abstract. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern.
Reference: [4] <author> Gilad Bracha. </author> <title> The programming language JIGSAW: Mixins, Modularity and Inheritance. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1992. </year>
Reference-contexts: Unfortunately the meaning of the term mixin is often confused with the different semantics of multiply inherited base classes in C++. Bracha's dissertation focused on semantics and language issues and did not present mixins in the context of a design methodology <ref> [4] </ref>. The C++ Standard Template Library of Stepanov and Musser uses templates extensively [12]. But the STL uses templates for genericity, not composition, and it does not use inheritance. Roles can use STL data structures, but roles can also be used to implement data structures.
Reference: [5] <author> Gilad Bracha and William Cooke. </author> <title> Mixin-based inheritance. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 303311, </pages> <year> 1990. </year>
Reference-contexts: In the OODB sense, an object must have a role of that name. For OODB roles, the main issue if the ability of objects to dynamically change roles. Bracha and Cooke demonstrated delayed inheritance using type parameters in a paper presented at OOPSLA'90 <ref> [5] </ref>. They called the resulting components mixins. The term roughly corresponds to the use of multiply inherited classes in CLOS. Unfortunately the meaning of the term mixin is often confused with the different semantics of multiply inherited base classes in C++.
Reference: [6] <author> Alison M. Burkett. </author> <title> Clarifying roles and responsibilities. </title> <journal> CMA: the Management Accounting Magazine, </journal> <volume> 69(2) </volume> <pages> 26-28, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Finally, we need to determine the order in which to compose the roles. To aid in the process of answering these questions, we have found the roles/responsibilities matrix, adapted from business management <ref> [6] </ref>, to be a useful tool. Figure 3 shows a roles/responsibilities matrix for part of the recycling machine involving the Adding Item, Item Stuck, and Validate Item collaborations. 3 In the matrix, rows represent collaborations, while columns represent classes. The internal cells of the matrix represent roles.
Reference: [7] <author> Eric Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal [2, 3, 11, 18], but they have also been formalized in contracts [10], given a notation [13], and associated with framework implementations <ref> [7] </ref>. Collaborations provide an ability to abstract. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern. Just as a task can be decomposed into simpler tasks, a collaboration can be composed from other, simpler collaborations. <p> However, classes participate in many collaborations and roles in only one, so roles change less frequently. Thus, compared to classes, roles are more stable in evolution and adaptive reuse. A few approaches to object oriented development already use collaborations and role- like decompositions to achieve better design reuse <ref> [7, 14] </ref>. Our strategy is to extend this kind of reuse to code by implementing the roles in the design directly as encapsulated source-code components. Classes are then literally compositions of role components.
Reference: [8] <author> Georg Gottlob, Michael Schrefl, and Brigitte RQ"ock. </author> <title> Extending object-oriented systems with roles. </title> <journal> ACM Transactions on Information Systems, </journal> <note> to appear, </note> <year> 1996. </year>
Reference-contexts: The mechanism of Harrison and Ossher requires a runtime dispatcher and special compiler tools. By comparison, ours is a light weight approach intended for building a single application structure. The notion of role has a counterpart in object oriented data bases <ref> [8, 16] </ref>. The issue for OODB is that an employee object may play the role of trainee at one time and manager at another, or possibly even the same, time. While both uses of role address objects playing roles in different contexts, the OODB usage is more concrete.
Reference: [9] <author> William Harrison and Harold Ossher. </author> <title> Subject-oriented programming (a critique of pure ob-jects). </title> <booktitle> In Proceedings of the 1993 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 411-428, </pages> <year> 1993. </year>
Reference-contexts: VanHilst and Notkin 10 UW-CSE-96-04-01 7 Related Work Our work is similar to subject oriented programming in that both approaches address the issue of composing different views on a common set of objects <ref> [9] </ref>. In subject oriented programming, separate structures are merged by combining common objects. The mechanism of Harrison and Ossher requires a runtime dispatcher and special compiler tools. By comparison, ours is a light weight approach intended for building a single application structure.
Reference: [10] <author> Richard Helm, Ian M. Holland, and Dipayan Gangopadhyay. </author> <title> Contracts: Specifying behavioral compositions in object-oriented systems. </title> <booktitle> In Proceedings of the 1990 ACM Conference on ObjectOriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 169-180, </pages> <year> 1990. </year>
Reference-contexts: In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal [2, 3, 11, 18], but they have also been formalized in contracts <ref> [10] </ref>, given a notation [13], and associated with framework implementations [7]. Collaborations provide an ability to abstract. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern.
Reference: [11] <author> Ivar Jacobson, Magnus Christenson, Patrick Jonsson, and Gunnar Overgaard. </author> <title> Object-Oriented Software Engineering: A Use Case Driven Approach. </title> <publisher> Addison-Wesley, </publisher> <address> 2nd edition, </address> <year> 1992. </year>
Reference-contexts: In the second section, we present the basic details of our method of implementing roles as source code components. 1 In the third section we describe the design of a container recycling machine similar to the one presented in Jacobson, et al. <ref> [11] </ref>. In the fourth section, we show how to implement that design using role components. The fifth section discusses some of the differences between our implementation and the implementation presented by Jacobson, et al., with respect to possible changes. <p> Collaborations are often used to model sequences of message passing and state changes derived from use-case-like scenarios in the requirements analysis. In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal <ref> [2, 3, 11, 18] </ref>, but they have also been formalized in contracts [10], given a notation [13], and associated with framework implementations [7]. Collaborations provide an ability to abstract. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern. <p> Classes are then literally compositions of role components. Because we want to implement roles directly, we need a design methodology in which roles are still identifiable late in the design process. We have found this to be possible with a number of existing collaboration-based design methodologies, such as use-cases <ref> [11] </ref>, responsibilities [17], and role models [14]. 2 Some methodologies make a distinction between collaborations of objects and collaborations of roles. Where that distinction might be significant, we will always mean the latter. <p> Section 5 discusses the ways in which these kinds of flexibility support our strategy for application development and evolution. 4 The Recycling Machine Design To demonstrate our implementation approach, we begin with a modified version of Jacob- son, et al.'s <ref> [11] </ref> collaboration-based design for a container recycling machine. This example defines a vending machine that takes empty beverage containers and issues a receipt for the deposit value of the containers. <p> The recycling machine design in Jacobson, et al., had an alarmist object intended to encapsulate the Item Stuck extension to the DepositReceiver class. Even then, the ideal of completely encapsulating change could not be realized. As described in the book, "Unfortunately, we cannot accomplish this with today's programming languages" <ref> [11, p.250] </ref>. Code in the DepositReceiver class had to be modified to support the Alarmist's extension. Our approach doesn't have the same problem because we don't encapsulate change in separate objects. We encapsulate it in roles that can become an integral part of the original class.
Reference: [12] <author> D. R. Musser and A. A. Stepanov. </author> <title> Algorithm-oriented generic libraries. </title> <journal> Software Practice and Experience, </journal> <volume> 24(7) </volume> <pages> 623-642, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Bracha's dissertation focused on semantics and language issues and did not present mixins in the context of a design methodology [4]. The C++ Standard Template Library of Stepanov and Musser uses templates extensively <ref> [12] </ref>. But the STL uses templates for genericity, not composition, and it does not use inheritance. Roles can use STL data structures, but roles can also be used to implement data structures.
Reference: [13] <author> Trygve Reenskaug, Egil P. Anderson, Arne Jorgan Berre, Anne Hurlen, Anton Landmark, Odd Arild Lehne, Else Nordhagen, Erik Ness-Ulseth, Gro Oftedal, Anne Lise Skaar, and Pal Stenslet. OORASS: </author> <title> Seamless support for the creation and maintenance of object-oriented systems. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 5(6) </volume> <pages> 27-41, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal [2, 3, 11, 18], but they have also been formalized in contracts [10], given a notation <ref> [13] </ref>, and associated with framework implementations [7]. Collaborations provide an ability to abstract. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern.
Reference: [14] <author> Trygve Reenskaug, </author> <title> Per Wold, and Odd Arild Lehne. Working With Objects: The OOram Software Engineering Method. </title> <type> Manning, </type> <year> 1995. </year>
Reference-contexts: Just as a task can be decomposed into simpler tasks, a collaboration can be composed from other, simpler collaborations. Indeed, an entire application can be viewed as a composition of collaborations <ref> [14] </ref>. In this view of collaborations, a role specifies a part of a single object that participates in a particular collaboration. <p> However, classes participate in many collaborations and roles in only one, so roles change less frequently. Thus, compared to classes, roles are more stable in evolution and adaptive reuse. A few approaches to object oriented development already use collaborations and role- like decompositions to achieve better design reuse <ref> [7, 14] </ref>. Our strategy is to extend this kind of reuse to code by implementing the roles in the design directly as encapsulated source-code components. Classes are then literally compositions of role components. <p> Because we want to implement roles directly, we need a design methodology in which roles are still identifiable late in the design process. We have found this to be possible with a number of existing collaboration-based design methodologies, such as use-cases [11], responsibilities [17], and role models <ref> [14] </ref>. 2 Some methodologies make a distinction between collaborations of objects and collaborations of roles. Where that distinction might be significant, we will always mean the latter.
Reference: [15] <author> Michael VanHilst and David Notkin. </author> <title> Using C++ to implement role-based designs. </title> <booktitle> In to appear in Proceedings of the 2nd JSSSST International Symposium on Object Technologies for Advanced Software. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The sixth section contains a discussion of related work, while the last section contains a summary and some concluding remarks. 1 A lengthier discussion of the details is available in an earlier paper, in which we compared our approach to the use of frameworks <ref> [15] </ref>. The paper is also available at http://www.cs.washington.edu/homes/vanhilst/. VanHilst and Notkin 1 UW-CSE-96-04-01 2 Collaborations, Roles, and Collaboration-based Designs A collaboration is a set of objects together with obligations on and relationships among those objects. <p> The emptyClass (essentially a default base class) parameter simply indicates that the Father1Class is a base class. This somewhat abstract description of our implementation method will be clarified by example in Sections 5 and 6; more details also appear elsewhere <ref> [15] </ref>. VanHilst and Notkin 3 UW-CSE-96-04-01 By writing different template instantiations, we could define different combinations of roles without modifying the role definitions themselves. <p> This is an example of what we call specialization by inserting ancestors <ref> [15] </ref>. It may be helpful to model the flow of control among collaborations as well as within collaborations to analyze the complete behavior. <p> This is not a problem for the InsertedItem class inheritance hierarchy, since the Adding Item role does not access anything from the Linked List role. As we explain elsewhere <ref> [15] </ref>, we often make data structure nodes derived classes of the data. This differs from the traditional approach to reusable data structures, where the common data structure parts are base classes and nodes have pointers to data. the two collaborations share many attributes in common.
Reference: [16] <author> Roel J. Wieringa, Wiebren de Jong, and Paul Sprint. </author> <title> Roles and dynamic subclasses: a modal logic approach. </title> <booktitle> In Proceedings of the 1993 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 32-59, </pages> <year> 1994. </year>
Reference-contexts: The mechanism of Harrison and Ossher requires a runtime dispatcher and special compiler tools. By comparison, ours is a light weight approach intended for building a single application structure. The notion of role has a counterpart in object oriented data bases <ref> [8, 16] </ref>. The issue for OODB is that an employee object may play the role of trainee at one time and manager at another, or possibly even the same, time. While both uses of role address objects playing roles in different contexts, the OODB usage is more concrete.
Reference: [17] <author> Rebecca Wirfs-Brock and Brian Wilkerson. </author> <title> Object-oriented design: A responsibility-driven ap-proach. </title> <booktitle> In Proceedings of the 1989 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 71-76, </pages> <year> 1989. </year>
Reference-contexts: Because we want to implement roles directly, we need a design methodology in which roles are still identifiable late in the design process. We have found this to be possible with a number of existing collaboration-based design methodologies, such as use-cases [11], responsibilities <ref> [17] </ref>, and role models [14]. 2 Some methodologies make a distinction between collaborations of objects and collaborations of roles. Where that distinction might be significant, we will always mean the latter.
Reference: [18] <author> Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener. </author> <title> Designing Object-Oriented Software. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year> <note> VanHilst and Notkin 12 </note>
Reference-contexts: Collaborations are often used to model sequences of message passing and state changes derived from use-case-like scenarios in the requirements analysis. In so doing, collaborations offer a view that complements the static view of class and inheritance structures. Collaborations are often informal <ref> [2, 3, 11, 18] </ref>, but they have also been formalized in contracts [10], given a notation [13], and associated with framework implementations [7]. Collaborations provide an ability to abstract. A collaboration can address only the parts of objects needed to participate in a particular task, concern, or pattern. <p> The interaction diagram used to describe the Adding Item collaboration shows the operations that each object needs to fulfill its role in that collaboration. We simply collect the operations for a particular object and determine which attributes those operations use. CRC or class cards <ref> [2, 18] </ref> can be used in a similar manner, if the responsibilities are annotated with the names of the collaborations to which they belong. But we need more information to construct our application, especially when trying to compose several roles to form a single class.
References-found: 18

