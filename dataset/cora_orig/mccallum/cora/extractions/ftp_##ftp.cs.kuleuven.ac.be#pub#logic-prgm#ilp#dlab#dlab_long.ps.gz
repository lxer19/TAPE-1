URL: ftp://ftp.cs.kuleuven.ac.be/pub/logic-prgm/ilp/dlab/dlab_long.ps.gz
Refering-URL: http://www.cs.kuleuven.ac.be/~wimv/ICL/papers.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Dlab A declarative language bias for concept learning and knowledge discovery engines  
Keyword: declarative language bias, machine learning, knowledge discovery  
Affiliation: Department of Computing Science, K.U.Leuven  
Abstract: Luc Dehaspe Luc De Raedt Report CW 214, July 8, 1996 Abstract We describe the principles and functionalities of Dlab (Declarative LAnguage Bias), which is an algorithm for defining syntactically and traversing efficiently hypothesis spaces in the context of concept learning and knowledge discovery tasks. Though Dlab is designed for first-order languages it can also be used to constrain propositional concept spaces. In an appendix we document a Dlab Prolog library available via anonymous ftp. The WWW-homepage of Dlab can be found at URL http : ==www:cs:kuleuven:ac:be=cwis=research=ai=Research=dlab E:shtml
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Ade, L. De Raedt, and M. Bruynooghe. </author> <title> Declarative Bias for Specific-To-General ILP Systems. </title> <booktitle> Machine Learning, </booktitle> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: We then need a formalism to formulate an intensional syntactic definition of language L. The problem of making this type of syntactic bias a parameter to the concept learner has been studied extensively, especially in frameworks that use first-order clausal logic (see <ref> [ 12; 1 ] </ref> for an overview). In this paper we present Dlab (Declarative LAnguage Bias) as a machine learning system component that allows for a straightforward specification of syntactic bias. <p> In this paper we present Dlab (Declarative LAnguage Bias) as a machine learning system component that allows for a straightforward specification of syntactic bias. Dlab extends the syntactic bias of Ade et al. <ref> [ 1 ] </ref> which in turn integrates the schemata of Emde et al. [ 8; 9 ] , and the predicate sets of Bergadano et al. [ 3; 2 ] . <p> A detailed formalization would require a complete introduction into each of the alternatives, and would be outside the scope of this paper. We therefore restrict ourselves to illustrations of the, mostly rather obvious, links. Clausemodels of Ade et al. <ref> [ 1 ] </ref> Closest to Dlab are the clausemodels proposed in [ 1 ] . Clausemodels are expressions of the form Head Body; BodySet whose conversion to Dlab templates is illustrated in the following example. <p> We therefore restrict ourselves to illustrations of the, mostly rather obvious, links. Clausemodels of Ade et al. <ref> [ 1 ] </ref> Closest to Dlab are the clausemodels proposed in [ 1 ] . Clausemodels are expressions of the form Head Body; BodySet whose conversion to Dlab templates is illustrated in the following example. <p> In fact, due to these constraints, none of the previous example Dlab grammars can be translated to clausemodels without adding ad-hoc predicates to the background theory. Schemata of Emde et al. [ 9 ] , and the predicate sets of Bergadano et al. [ 3 ] As discussed in <ref> [ 1 ] </ref> , schemata and predicate sets as used in MOBAL and the FILP system respectively, are special cases of clausemodels, and thus indirectly of Dlab templates. 5 More procedural approaches to syntactic bias specifications use parameters such as the maximal variable depth or term level to control the complexity
Reference: [2] <author> F. Bergadano. </author> <title> Towards an inductive logic programming language. </title> <type> Technical Report ESPRIT project no. 6020 ILP Deliverable TO1, </type> <institution> Computer Science Department, University of Torino, </institution> <year> 1993. </year>
Reference-contexts: Dlab extends the syntactic bias of Ade et al. [ 1 ] which in turn integrates the schemata of Emde et al. [ 8; 9 ] , and the predicate sets of Bergadano et al. <ref> [ 3; 2 ] </ref> . At the end of this article, we give a more detailed account of the relation between Dlab and other formalisms. Prior to that we present an overview of Dlab in two stages.
Reference: [3] <author> F. Bergadano and D. Gunetti. </author> <title> An interactive system to learn functional logic programs. </title> <booktitle> In Proceedings of the 13th International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 1044-1049. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: Dlab extends the syntactic bias of Ade et al. [ 1 ] which in turn integrates the schemata of Emde et al. [ 8; 9 ] , and the predicate sets of Bergadano et al. <ref> [ 3; 2 ] </ref> . At the end of this article, we give a more detailed account of the relation between Dlab and other formalisms. Prior to that we present an overview of Dlab in two stages. <p> In fact, due to these constraints, none of the previous example Dlab grammars can be translated to clausemodels without adding ad-hoc predicates to the background theory. Schemata of Emde et al. [ 9 ] , and the predicate sets of Bergadano et al. <ref> [ 3 ] </ref> As discussed in [ 1 ] , schemata and predicate sets as used in MOBAL and the FILP system respectively, are special cases of clausemodels, and thus indirectly of Dlab templates. 5 More procedural approaches to syntactic bias specifications use parameters such as the maximal variable depth or
Reference: [4] <author> W.F. Clocksin and C.S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: Definition 4 (dlab generate (DGRAM)) Let DGRAM be a Dlab grammar. dlab generate (DGRAM) = fdlab1 (HT ) dlab1 (BT )j (HT BT ) 2 DGRAM g where dlab1 (DAT OM ) is a list of literals generated by the definite clause grammar <ref> [ 4; 14 ] </ref> dlab1: dlab1 (A) ! [A]; fA 6= M in M ax : Lg: (1) dlab1 (M in M ax : []) ! fM in 0g; []: (2) dlab1 (M in M ax : [ jL]) ! dlab1 (M in M ax : L): (3) dlab1 (M in
Reference: [5] <author> W.W. Cohen. </author> <title> Grammatically biased learning: learning logic programs using an explicit antecedent description language. </title> <journal> Artificial Intelligence, </journal> <volume> 68 </volume> <pages> 303-366, </pages> <year> 1994. </year>
Reference-contexts: Parametrized languages should be considered complementary to Dlab, in the sense that the same parameters trivially define (a series of) Dlab grammars. 14 Antecedent description grammars of Cohen <ref> [ 5 ] </ref> An antecedent description grammar, as used in GRENDEL, is in essence a definite clause grammar that generates the antecedents of clauses in L. The following example taken from [ 5 ] is used in the context of learning when a chess position containing two kings and one rook <p> the sense that the same parameters trivially define (a series of) Dlab grammars. 14 Antecedent description grammars of Cohen <ref> [ 5 ] </ref> An antecedent description grammar, as used in GRENDEL, is in essence a definite clause grammar that generates the antecedents of clauses in L. The following example taken from [ 5 ] is used in the context of learning when a chess position containing two kings and one rook is illegal. goal formula (illegal (A; B; C; D; E; F )): body (illegal (A; B; C; D; E; F )) ! rels (A; B; C; D; E; F ) rels
Reference: [6] <author> L. De Raedt. </author> <title> Interactive Theory Revision: an Inductive Logic Programming Approach. </title> <publisher> Academic Press, </publisher> <year> 1992. </year>
Reference-contexts: predicate sets as used in MOBAL and the FILP system respectively, are special cases of clausemodels, and thus indirectly of Dlab templates. 5 More procedural approaches to syntactic bias specifications use parameters such as the maximal variable depth or term level to control the complexity of the concept language, cf. <ref> [ 6; 13 ] </ref> .
Reference: [7] <author> B. Dolsak and S. Muggleton. </author> <title> The application of Inductive Logic Programming to finite element mesh design. </title> <editor> In S. Muggleton, editor, </editor> <booktitle> Inductive logic programming, </booktitle> <pages> pages 453-472. </pages> <publisher> Academic Press, </publisher> <year> 1992. </year>
Reference-contexts: First, we discuss syntax, semantics and a refinement operator for Dlab , a subset of Dlab. We then extend Dlab to full Dlab and show both formalisms at work in the domain of finite element mesh design (see e.g. <ref> [ 7; 10 ] </ref> ). A simplified implementation of Dlab can be found in the text itself.
Reference: [8] <author> W. Emde, C.U. Habel, and C.R. Rollinger. </author> <title> The discovery of the equator or concept driven learning. </title> <booktitle> In Proceedings of the 8th International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 455-458. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1983. </year>
Reference-contexts: In this paper we present Dlab (Declarative LAnguage Bias) as a machine learning system component that allows for a straightforward specification of syntactic bias. Dlab extends the syntactic bias of Ade et al. [ 1 ] which in turn integrates the schemata of Emde et al. <ref> [ 8; 9 ] </ref> , and the predicate sets of Bergadano et al. [ 3; 2 ] . At the end of this article, we give a more detailed account of the relation between Dlab and other formalisms. Prior to that we present an overview of Dlab in two stages.
Reference: [9] <author> J-U. Kietz and S. Wrobel. </author> <title> Controlling the complexity of learning in logic through syntactic and task-oriented models. </title> <editor> In S. Muggleton, editor, </editor> <booktitle> Inductive logic programming, </booktitle> <pages> pages 335-359. </pages> <publisher> Academic Press, </publisher> <year> 1992. </year> <month> 16 </month>
Reference-contexts: In this paper we present Dlab (Declarative LAnguage Bias) as a machine learning system component that allows for a straightforward specification of syntactic bias. Dlab extends the syntactic bias of Ade et al. [ 1 ] which in turn integrates the schemata of Emde et al. <ref> [ 8; 9 ] </ref> , and the predicate sets of Bergadano et al. [ 3; 2 ] . At the end of this article, we give a more detailed account of the relation between Dlab and other formalisms. Prior to that we present an overview of Dlab in two stages. <p> In fact, due to these constraints, none of the previous example Dlab grammars can be translated to clausemodels without adding ad-hoc predicates to the background theory. Schemata of Emde et al. <ref> [ 9 ] </ref> , and the predicate sets of Bergadano et al. [ 3 ] As discussed in [ 1 ] , schemata and predicate sets as used in MOBAL and the FILP system respectively, are special cases of clausemodels, and thus indirectly of Dlab templates. 5 More procedural approaches to
Reference: [10] <author> N. Lavrac and S. Dzeroski. </author> <title> Inductive Logic Programming: Techniques and Applications. </title> <publisher> Ellis Horwood, </publisher> <year> 1994. </year>
Reference-contexts: First, we discuss syntax, semantics and a refinement operator for Dlab , a subset of Dlab. We then extend Dlab to full Dlab and show both formalisms at work in the domain of finite element mesh design (see e.g. <ref> [ 7; 10 ] </ref> ). A simplified implementation of Dlab can be found in the text itself.
Reference: [11] <author> I.G. MacDonald. </author> <title> Symmetric functions and Hall polynomials. </title> <publisher> Clarendon Oxford, </publisher> <year> 1979. </year>
Reference-contexts: Therefore we need e k (s 1 ; : : : ; s n ), where e k is the elementary symmetric function <ref> [ 11 ] </ref> of degree k and the s i are the numbers of marbles in each urn. The first base case of this recursive function accounts for the fact that there is only one way to select 0 objects.
Reference: [12] <author> S. Muggleton. </author> <title> Predicate invention and utility. </title> <journal> Journal for Experimental and Theoretical Artificial Intelligence, </journal> <note> 1994. To appear. </note>
Reference-contexts: We then need a formalism to formulate an intensional syntactic definition of language L. The problem of making this type of syntactic bias a parameter to the concept learner has been studied extensively, especially in frameworks that use first-order clausal logic (see <ref> [ 12; 1 ] </ref> for an overview). In this paper we present Dlab (Declarative LAnguage Bias) as a machine learning system component that allows for a straightforward specification of syntactic bias.
Reference: [13] <author> S. Muggleton and C. Feng. </author> <title> Efficient induction of logic programs. </title> <booktitle> In Proceedings of the 1st conference on algorithmic learning theory, </booktitle> <pages> pages 368-381. </pages> <address> Ohmsma, Tokyo, Japan, </address> <year> 1990. </year>
Reference-contexts: predicate sets as used in MOBAL and the FILP system respectively, are special cases of clausemodels, and thus indirectly of Dlab templates. 5 More procedural approaches to syntactic bias specifications use parameters such as the maximal variable depth or term level to control the complexity of the concept language, cf. <ref> [ 6; 13 ] </ref> .
Reference: [14] <author> Leon Sterling and Ehud Shapiro. </author> <title> The art of Prolog. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year> <month> 17 </month>
Reference-contexts: Definition 4 (dlab generate (DGRAM)) Let DGRAM be a Dlab grammar. dlab generate (DGRAM) = fdlab1 (HT ) dlab1 (BT )j (HT BT ) 2 DGRAM g where dlab1 (DAT OM ) is a list of literals generated by the definite clause grammar <ref> [ 4; 14 ] </ref> dlab1: dlab1 (A) ! [A]; fA 6= M in M ax : Lg: (1) dlab1 (M in M ax : []) ! fM in 0g; []: (2) dlab1 (M in M ax : [ jL]) ! dlab1 (M in M ax : L): (3) dlab1 (M in
References-found: 14

