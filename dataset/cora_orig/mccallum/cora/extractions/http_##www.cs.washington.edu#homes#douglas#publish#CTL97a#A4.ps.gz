URL: http://www.cs.washington.edu/homes/douglas/publish/CTL97a/A4.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/douglas/publish/CTL97a/index.html
Root-URL: http://www.cs.washington.edu
Email: fcollberg,cthombor,dlow001g@cs.auckland.ac.nz  
Title: A Taxonomy of Obfuscating Transformations  
Author: Christian Collberg Clark Thomborson Douglas Low 
Address: Private Bag 92019 Auckland, New Zealand.  
Affiliation: Department of Computer Science The University of Auckland  
Pubnum: Technical Report #148  
Abstract: In this paper we review several techniques for technical protection of software secrets. We will argue that automatic code obfuscation is currently the most viable method for preventing reverse engineering. We then describe the design of a code obfuscator, a tool which converts a program into an equivalent one that is more difficult to understand and reverse engineer. The obfuscator is based on the application of code transformations, in many cases similar to those used by compiler optimizers. We describe a large number of such transformations, classify them, and evaluate them with respect to their potency (To what degree is a human reader confused?), resilience (How well are automatic deobfuscation attacks resisted?), and cost (How much overhead is added to the application?). We finally discuss some possible deobfuscation techniques (such as program slicing) and possible countermeasures an obfuscator could employ against them. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ull-man. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year> <note> ISBN 0-201-10088-6. </note>
Reference-contexts: For example, the Java bytecode has a goto instruction while the Java language has no corresponding goto-statement. This means that the Java bytecode can express arbitrary control flow, whereas the Java language can only (easily) express structured control flow. Technically <ref> [1] </ref>, we say that the control flow graphs produced from Java programs will always be reducible, but the Java bytecode can express non-reducible flow graphs.
Reference: [2] <author> David F. Bacon, Susan L. Graham, and Oliver J. Sharp. </author> <title> Compiler transformations for high-performance computing. </title> <journal> ACM Computing Surveys, </journal> <volume> 26(4) </volume> <pages> 345-420, </pages> <month> December </month> <year> 1994. </year> <note> http:// www.acm.org/pubs/toc/Abstracts/0360-0300/ 197406.html. </note>
Reference-contexts: See Bacon <ref> [2] </ref> for a comprehensive survey. Some of these transformations are useful to us since they also increase the complexity metrics of Table 1. <p> analysis (see 16 (a) for (j=1,j&lt;=n,j++) T for (I=1,I&lt;=n,I+=64) for (i=I,i&lt;=min (I+63,n),i++) a [i,j]=b [j,i] for (i=2,i&lt;(n-1),i++) T for (i=2,i&lt;(n-2),i+=2) f a [i+1] += a [i]*a [i+2]; if (((n-2) % 2) == 1) (c) a [i] += c; g ) a [i] += c; x [i+i]=d+x [i+1]*a [i] adapted from <ref> [2] </ref>. [2, 33]) will have to be performed to determine which reorderings are legal. These transformations have low potency (they do not add much obscurity to the program) but their resilience is high, in many cases one-way. <p> (see 16 (a) for (j=1,j&lt;=n,j++) T for (I=1,I&lt;=n,I+=64) for (i=I,i&lt;=min (I+63,n),i++) a [i,j]=b [j,i] for (i=2,i&lt;(n-1),i++) T for (i=2,i&lt;(n-2),i+=2) f a [i+1] += a [i]*a [i+2]; if (((n-2) % 2) == 1) (c) a [i] += c; g ) a [i] += c; x [i+i]=d+x [i+1]*a [i] adapted from [2]. <ref> [2, 33] </ref>) will have to be performed to determine which reorderings are legal. These transformations have low potency (they do not add much obscurity to the program) but their resilience is high, in many cases one-way. <p> This way, unrelated statements that were previously part of several different procedures are brought together into bogus procedural abstractions. In certain cases it is also possible to reorder loops, for example by running them backwards. Such loop reversal transformations are common in high-performance compilers <ref> [2] </ref>. 7 Data Transformations In this section we will discuss transformations that obscure the data structures used in the source application. <p> A simple encoding function such as i 0 = c 1 i + c 2 in the example above, will add little extra execution time but can be deobfuscated using common compiler analysis techniques <ref> [33, 2] </ref>. 7.1.2 Promote Variables There are a number of simple storage transformations that promote variables from a specialized storage class to a more general class. Their potency and resilience are generally low, but used in conjunction with other transformations they can be quite effective.
Reference: [3] <author> Shyam R. Chidamber and Chris F. Kemerer. </author> <title> A metrics suite for object oriented design. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(6) </volume> <pages> 476-493, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: The complexity of a scalar variable is constant. The complexity of an array increases with the number of dimensions and with the complexity of the element type. The complexity of a record increases with the number and complexity of its fields. 7 OO Metric Chidamber <ref> [3] </ref> E (C) increases with ( a 7 ) the number of methods in C, ( b 7 ) the depth (distance from the root) of C in the inheritance tree, ( c 7 ) the number of direct subclasses of C, ( d 7 ) the number of other classes
Reference: [4] <author> Cristina Cifuentes and K. John Gough. </author> <title> Decompi-lation of binary programs. </title> <journal> Software Practice& Experience, </journal> <volume> 25(7) </volume> <pages> 811-829, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Given enough time, effort and determination, a competent programmer will always be able to reverse engineer any application. Having gained physical access to the application, the reverse engineer can decompile it (using disassemblers or decompilers <ref> [4] </ref>) and then analyze its data structures and control flow. This can either be done manually or with the aid of reverse engineering tools such as program slicers [28]. This is not a new problem. <p> This means that the opaque predicates can be broken (an automatic 21 (1) int A [9]; (3) int B [9],C [19]; (5) C [i] = ; (6) int D [9]; D [i]=2*D [i+1]; (8) int E [2,2]; for (j=0;i&lt;=2;i++) swap (E [i,j], E [j,i]); T (1') int A1 <ref> [4] </ref>,A2 [4]; else A2 [i/2]= ; (4') BC [3*i] = ; (7') for (j=0;j&lt;=1;j++) if (k==4) else D1 [j,k]=2*D1 [j,k+1]; (8') int E1 [8]; swap (E [i], E [3*(i%3)+i/3]); 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
Reference: [5] <author> Jeffrey Dean. </author> <title> Whole-Program Optimization of Object-Oriented Languages. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <year> 1996. </year>
Reference-contexts: Consider a method invocation m:P (). The actual procedure called will depend on the run-time type of m. In cases when more than one method can be invoked at a particular call site, we have to inline all possible methods <ref> [5] </ref> and select the appropriate code by branching on the type of m (see Figure 14).
Reference: [6] <author> James R. Gosler. </author> <title> Software protection: </title> <booktitle> Myth or reality? In CRYPTO'85 | Advances in Cryptology, </booktitle> <pages> pages 140-157, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: A more attractive solution is for Alice to protect her code by making reverse engineering so technically difficult that it becomes impossible or at the very least economically inviable. Some early attempts at technical protection are described by Gosler <ref> [6] </ref>. The most secure approach is for Alice not to sell her application at all, but rather sell its services.
Reference: [7] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year> <note> ISBN 0-201-63451-1. </note>
Reference-contexts: This situation is changing. It is becoming more and more common to distribute software in forms that are easy to decompile and reverse engineer. Important examples include Java bytecode <ref> [7] </ref> and the Architecture Neutral Distribution Format (ANDF) [18]. Java applications in particular pose a problem to software developers. They are distributed over the Internet as Java class files, a hardware-independent virtual machine code that retains virtually all the information of the original Java source.
Reference: [8] <author> M. H. Halstead. </author> <title> Elements of Software Science. </title> <publisher> El-sevier North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: example, all we have to do is to add some arbitrary if-statements to P : 2 We are deliberately vague as to which particular metric (or combination of metrics) to use since the exact choice is not critical to our application. 7 Metric Metric Name Citation 1 Program Length Halstead <ref> [8] </ref> E (P ) increases with the number of operators and operands in P . 2 Cyclomatic Complexity McCabe [20] E (F ) increases with the number of predicates in F . 3 Nesting Complexity Harrison [9] E (F ) increases with the nesting level of conditionals in F . 4 <p> (5) C [i] = ; (6) int D [9]; D [i]=2*D [i+1]; (8) int E [2,2]; for (j=0;i&lt;=2;i++) swap (E [i,j], E [j,i]); T (1') int A1 [4],A2 [4]; else A2 [i/2]= ; (4') BC [3*i] = ; (7') for (j=0;j&lt;=1;j++) if (k==4) else D1 [j,k]=2*D1 [j,k+1]; (8') int E1 <ref> [8] </ref>; swap (E [i], E [3*(i%3)+i/3]); 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 19 0 1 2 3 4 5 6 7 8 9 0 1 2 1 E 1;0
Reference: [9] <author> Warren A. Harrison and Kenneth I. Magel. </author> <title> A complexity measure based on nesting level. </title> <journal> SIGPLAN Notices, </journal> <volume> 16(3) </volume> <pages> 63-74, </pages> <year> 1981. </year>
Reference-contexts: not critical to our application. 7 Metric Metric Name Citation 1 Program Length Halstead [8] E (P ) increases with the number of operators and operands in P . 2 Cyclomatic Complexity McCabe [20] E (F ) increases with the number of predicates in F . 3 Nesting Complexity Harrison <ref> [9] </ref> E (F ) increases with the nesting level of conditionals in F . 4 Data Flow Complexity Oviedo [23] E (F ) increases with the number of inter-basic block variable references in F . 5 Fan-in/out Complexity Henry [10] E (F ) increases with the number of formal parameters to <p> In fact, the quality of most control transformations is directly dependent on the quality of such predicates. In Section 6.1 we gave examples of simple opaque predicates with trivial and weak resilience. This means that the opaque predicates can be broken (an automatic 21 (1) int A <ref> [9] </ref>; (3) int B [9],C [19]; (5) C [i] = ; (6) int D [9]; D [i]=2*D [i+1]; (8) int E [2,2]; for (j=0;i&lt;=2;i++) swap (E [i,j], E [j,i]); T (1') int A1 [4],A2 [4]; else A2 [i/2]= ; (4') BC [3*i] = ; (7') for (j=0;j&lt;=1;j++) if (k==4) else D1 <p> In Section 6.1 we gave examples of simple opaque predicates with trivial and weak resilience. This means that the opaque predicates can be broken (an automatic 21 (1) int A <ref> [9] </ref>; (3) int B [9],C [19]; (5) C [i] = ; (6) int D [9]; D [i]=2*D [i+1]; (8) int E [2,2]; for (j=0;i&lt;=2;i++) swap (E [i,j], E [j,i]); T (1') int A1 [4],A2 [4]; else A2 [i/2]= ; (4') BC [3*i] = ; (7') for (j=0;j&lt;=1;j++) if (k==4) else D1 [j,k]=2*D1 [j,k+1]; (8') int E1 [8]; swap (E [i], E [3*(i%3)+i/3]); 0 1 2
Reference: [10] <author> Sallie Henry and Dennis Kafura. </author> <title> Software structure metrics based on information flow. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 7(5) </volume> <pages> 510-518, </pages> <month> September </month> <year> 1981. </year> <title> used and a hash-value computed from the obfuscated code. </title>
Reference-contexts: the number of predicates in F . 3 Nesting Complexity Harrison [9] E (F ) increases with the nesting level of conditionals in F . 4 Data Flow Complexity Oviedo [23] E (F ) increases with the number of inter-basic block variable references in F . 5 Fan-in/out Complexity Henry <ref> [10] </ref> E (F ) increases with the number of formal parameters to F , and with the number of global data structures read or updated by F . 6 Data Structure Complexity Munson [21] E (P ) increases with the complexity of the static data structures declared in P .
Reference: [11] <author> Amir Herzberg and Shlomit S. Pinter. </author> <title> Public protection of software. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(4) </volume> <pages> 371-393, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Another approach would be for Alice to encrypt her code before it is sent off to the users (Figure 3). Unfortunately, this only works if the entire decryption/execution process takes place in hardware. Such systems are described in Herzberg <ref> [11] </ref> and Wil-helm [31]. If the code is executed in software by a virtual machine interpreter (as is most often the case with Java bytecodes), then it will always be possible for Bob to intercept and decompile the decrypted code.
Reference: [12] <author> Susan Horwitz. </author> <title> Precise flow-insensitive May-Alias analysis is NP-hard. </title> <journal> TOPLAS, </journal> <volume> 19(1) </volume> <pages> 1-6, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: The first one is based on aliasing, the second on lightweight processes. 8.1 Opaque Constructs Using Objects and Aliases Inter-procedural static analysis is significantly complicated whenever there is a possibility of aliasing. In fact, different versions of precise static alias analysis have been shown to be NP-hard <ref> [12] </ref> or even undecidable [24]. We can exploit this fact to construct opaque predicates which are difficult to break. It should be noted that there are many fast but imprecise alias analysis algorithms that will detect some aliases some of the time, but not all aliases all of the time.
Reference: [13] <author> Susan Horwitz, Thomas Reps, and David Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> TOPLAS, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The cost of precise inter-procedural slicing grows with the number of potential aliases in a program, which in turn grows exponentially with the number of formal parameters <ref> [13] </ref>. Hence, if the obfusca-tor adds aliased dummy parameters to a program it will either substantially slow down the slicer (if precise slices are required), or force the slicer to produce imprecise slices (if fast slicing is required).
Reference: [14] <author> Neil D. Jones. </author> <title> An introduction to partial evaluation. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(3) </volume> <pages> 480-503, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: Thus this obfuscation is safe (the original and obfuscated code behave identically), but difficult to deobfuscate. 9.8 Deobfuscation and Partial Evaluation Deobfuscation also bears a striking resemblance to partial evaluation <ref> [14] </ref>. A partial evaluator splits a program into two parts: the static part which can be precom-puted by the partial evaluator, and the dynamic part which is executed at runtime. The dynamic part would correspond to our original, unobfuscated, program.
Reference: [15] <author> Jens Knoop, Bernhard Steffen, and Jurgen Vollmer. </author> <title> Parallelism for free: Efficient and optimal bitvector analyses for parallel programs. </title> <journal> TOPLAS, </journal> <volume> 18(3) </volume> <pages> 268-299, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: The reason is their interleaving semantics: n statements in a parallel region pPAR S 1 ; S 2 ; ; S n ; ENDPARq can be executed in n! different ways. In spite of this, some static analyses over parallel programs can be performed in polynomial time <ref> [15] </ref>, while others require all n! in-terleavings to be considered. In Java, parallel regions are constructed using lightweight processes known as threads.
Reference: [16] <author> Mark D. LaDue. HoseMocha. </author> <note> http://www.xynyx. demon.nl/java/HoseMocha.java, </note> <month> January </month> <year> 1997. </year>
Reference-contexts: (i=1;i&lt;=10;i++) T int B [50]; A [i]=i; g The resilience this inherent preventive transformation adds to the loop reordering transformation depends on the complexity of the bogus dependency and the state-of-the-art in dependency analysis [33]. 9.1.2 Targeted Preventive Transformations As an example of a targeted preventive transformation, consider the HoseMocha <ref> [16] </ref> program. It was designed specifically to explore a weakness in the Mocha [30] de-compiler. HoseMocha inserts extra instructions after every return-statement in every method in the source program.
Reference: [17] <author> James R. Lyle, Dolorres R. Wallace, James R. Graham, Keith B. Gallagher, Joseph P. Poole, and David W Binkley. Unravel: </author> <title> A CASE tool to assist evaluation of high integrity software. Volume 1: Requirements and design. </title> <type> Technical Report NIS-TIR 5691, U.S. </type> <institution> Department of Commerce, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: Hence, if the obfusca-tor adds aliased dummy parameters to a program it will either substantially slow down the slicer (if precise slices are required), or force the slicer to produce imprecise slices (if fast slicing is required). Add variable dependencies Popular slicing tools such as Unravel <ref> [17] </ref> work well for small slices, but will sometimes require excessive time to compute larger ones. For example, when working on a 4000 line C program Unravel in some cases required over 30 minutes to compute a slice.
Reference: [18] <author> Stavros Macrakis. </author> <title> Protecting source code with ANDF. </title> <address> ftp://riftp.osf.org/pub/andf/andf_ coll_papers/ProtectingSourceCode% .ps, </address> <month> Jan-uary </month> <year> 1993. </year>
Reference-contexts: This situation is changing. It is becoming more and more common to distribute software in forms that are easy to decompile and reverse engineer. Important examples include Java bytecode [7] and the Architecture Neutral Distribution Format (ANDF) <ref> [18] </ref>. Java applications in particular pose a problem to software developers. They are distributed over the Internet as Java class files, a hardware-independent virtual machine code that retains virtually all the information of the original Java source. Hence, these class files are easy to decompile.
Reference: [19] <author> Apple's QuickTime lawsuit. </author> <note> http://www. macworld.com/pages/june.95/News.848.html and may.95/News.705.html, May-June 1995. </note>
Reference-contexts: Not only does it give the competitor a commercial edge (by cutting development time and cost), but it is also difficult to detect and pursue legally. The last point is particularly valid for small developers who may ill afford lengthy legal battles against powerful corporations <ref> [19] </ref> with unlimited legal budgets. The purpose of this paper is to discuss the various forms of technical protection of intellectual property which are available to software developers. <p> In Section 6.1 we gave examples of simple opaque predicates with trivial and weak resilience. This means that the opaque predicates can be broken (an automatic 21 (1) int A [9]; (3) int B [9],C <ref> [19] </ref>; (5) C [i] = ; (6) int D [9]; D [i]=2*D [i+1]; (8) int E [2,2]; for (j=0;i&lt;=2;i++) swap (E [i,j], E [j,i]); T (1') int A1 [4],A2 [4]; else A2 [i/2]= ; (4') BC [3*i] = ; (7') for (j=0;j&lt;=1;j++) if (k==4) else D1 [j,k]=2*D1 [j,k+1]; (8') int E1
Reference: [20] <author> T. J. McCabe. </author> <title> A complexity measure. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 2(4) </volume> <pages> 308-320, </pages> <month> December </month> <year> 1976. </year>
Reference-contexts: vague as to which particular metric (or combination of metrics) to use since the exact choice is not critical to our application. 7 Metric Metric Name Citation 1 Program Length Halstead [8] E (P ) increases with the number of operators and operands in P . 2 Cyclomatic Complexity McCabe <ref> [20] </ref> E (F ) increases with the number of predicates in F . 3 Nesting Complexity Harrison [9] E (F ) increases with the nesting level of conditionals in F . 4 Data Flow Complexity Oviedo [23] E (F ) increases with the number of inter-basic block variable references in F
Reference: [21] <author> John C. Munson and Taghi M. Kohshgoftaar. </author> <title> Measurement of data structure complexity. </title> <journal> Journal of Systems Software, </journal> <volume> 20 </volume> <pages> 217-225, </pages> <year> 1993. </year>
Reference-contexts: ) increases with the number of inter-basic block variable references in F . 5 Fan-in/out Complexity Henry [10] E (F ) increases with the number of formal parameters to F , and with the number of global data structures read or updated by F . 6 Data Structure Complexity Munson <ref> [21] </ref> E (P ) increases with the complexity of the static data structures declared in P . The complexity of a scalar variable is constant. The complexity of an array increases with the number of dimensions and with the complexity of the element type.
Reference: [22] <author> William F. Opdyke and Ralph E. Johnson. </author> <title> Creating abstract superclasses by refactoring. </title> <editor> In Stan C. Kwasny and John F. Buck, editors, </editor> <booktitle> Proceedings of the 21st Annual Conference on Computer Science, </booktitle> <pages> pages 66-73, </pages> <address> New York, NY, USA, </address> <month> February </month> <year> 1993. </year> <note> ACM Press. ftp://st.cs.uiuc.edu/pub/papers/ refactoring/refactoring-superclass% es.ps. 32 </note>
Reference-contexts: Another way of increasing the resilience of these types of transformations is to make sure that new objects are created of all introduced classes. false refactoring. Refactoring is a (sometimes automatic) technique for restructuring object-oriented programs whose structure has deteriorated <ref> [22] </ref>. Refactor-ing is a two-step process. First, it is detected that two, apparently independent classes, in fact implement similar behavior. Secondly, features common to both classes are moved into a new (possibly abstract) parent class.
Reference: [23] <author> E. I. Oviedo. </author> <title> Control flow, data flow, and program complexity. </title> <booktitle> In Proceedings of IEEE COMPSAC, </booktitle> <pages> pages 146-152, </pages> <month> November </month> <year> 1980. </year>
Reference-contexts: with the number of operators and operands in P . 2 Cyclomatic Complexity McCabe [20] E (F ) increases with the number of predicates in F . 3 Nesting Complexity Harrison [9] E (F ) increases with the nesting level of conditionals in F . 4 Data Flow Complexity Oviedo <ref> [23] </ref> E (F ) increases with the number of inter-basic block variable references in F . 5 Fan-in/out Complexity Henry [10] E (F ) increases with the number of formal parameters to F , and with the number of global data structures read or updated by F . 6 Data Structure
Reference: [24] <author> G. Ramalingam. </author> <title> The undecidability of aliasing. </title> <journal> TOPLAS, </journal> <volume> 16(5) </volume> <pages> 1467-1471, </pages> <month> September </month> <year> 1997. </year>
Reference-contexts: In fact, different versions of precise static alias analysis have been shown to be NP-hard [12] or even undecidable <ref> [24] </ref>. We can exploit this fact to construct opaque predicates which are difficult to break. It should be noted that there are many fast but imprecise alias analysis algorithms that will detect some aliases some of the time, but not all aliases all of the time.
Reference: [25] <author> Spencer Rugaber, Kurt Stirewalt, and Linda M. Wills. </author> <title> The interleaving problem in program understanding. </title> <booktitle> In 2nd Working Conference on Reverse Engineering, </booktitle> <address> Toronto, Ontario, Canada, </address> <month> July </month> <year> 1995. </year> <note> ftp.cc.gatech.edu//pub/groups/ reverse/repository/interleaving.ps. </note>
Reference-contexts: Rugaber <ref> [25] </ref> writes: One of the factors that can make a program difficult to understand is that code responsible for accomplishing more than one purpose may be woven together in a single section.
Reference: [26] <author> Pamela Samuelson. </author> <title> Reverse-engineering someone else's software: </title> <booktitle> Is it legal? IEEE Software, </booktitle> <pages> pages 90-96, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The main concern of Java developers is not outright reengineering of entire applications. There is relatively little value in such behavior since it clearly violates copyright law <ref> [26] </ref>, and can be handled through litigation. Rather, developers are mostly frightened by the prospect of a competitor being able to extract proprietary algorithms and data structures from their applications in order to incorporate them into their own programs.
Reference: [27] <author> Antero Taivalsaari. </author> <title> On the notion of inheritance. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(3) </volume> <pages> 438-479, </pages> <month> Septem-ber </month> <year> 1996. </year>
Reference-contexts: Borrowing the notation used in <ref> [27] </ref>, we write inheritance as C 2 = C 1 C 2 . C 2 is said to inherit from C 1 , its super- or parent class. The operator is the function that combines the parent class with the new properties defined in C 2 .
Reference: [28] <author> Frank Tip. </author> <title> A survey of program slicing techniques. </title> <journal> Journal of Programming Languages, </journal> <volume> 3(3) </volume> <pages> 121-189, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Having gained physical access to the application, the reverse engineer can decompile it (using disassemblers or decompilers [4]) and then analyze its data structures and control flow. This can either be done manually or with the aid of reverse engineering tools such as program slicers <ref> [28] </ref>. This is not a new problem. Until recently, however, it is a problem that has received relatively little attention from software developers. The reason is that most programs are large, monolithic, and shipped as stripped, native code, making them difficult (although never impossible) to reverse engineer.
Reference: [29] <author> Hans Peter Van Vliet. </author> <title> Crema | The Java obfusca-tor. </title> <address> http://web.inter.nl.net/users/H.P.van. Vliet/crema.html, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: resilience, and cost of T : T qual (P ) = (T pot (P ); T res (P ); T cost (P )): 2 5.5 Layout Transformations Before we explore novel transformations, we will briefly consider the trivial layout transformations which are typical of current Java obfuscators such as Crema <ref> [29] </ref>. The first transformation removes the source code formatting information sometimes available in Java class files.
Reference: [30] <author> Hans Peter Van Vliet. </author> <title> Mocha | The Java de-compiler. </title> <address> http://web.inter.nl.net/users/H. P.van.Vliet/mocha.html, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: It was designed specifically to explore a weakness in the Mocha <ref> [30] </ref> de-compiler. HoseMocha inserts extra instructions after every return-statement in every method in the source program.
Reference: [31] <author> Uwe G. Wilhelm. </author> <title> Cryptographically protected objects. </title> <note> http://lsewww.epfl.ch/~wilhelm/CryPO. html, </note> <year> 1997. </year>
Reference-contexts: Another approach would be for Alice to encrypt her code before it is sent off to the users (Figure 3). Unfortunately, this only works if the entire decryption/execution process takes place in hardware. Such systems are described in Herzberg [11] and Wil-helm <ref> [31] </ref>. If the code is executed in software by a virtual machine interpreter (as is most often the case with Java bytecodes), then it will always be possible for Bob to intercept and decompile the decrypted code. Java has gained popularity mainly because of its architecture neutral bytecode.
Reference: [32] <author> Linda Mary Wills. </author> <title> Automated program recognition: a feasibility demonstration. </title> <journal> Artificial Intelligence, </journal> <volume> 45(1-2):113-172, </volume> <year> 1990. </year>
Reference-contexts: Instead, most Java programmers will construct lists of objects in an ad hoc fashion by linking them together on a next field. Iterat ing through such lists is a very common pattern in Java programs. Techniques invented in the field automatic program recognition <ref> [32] </ref> can be used to identify com mon patterns and replace them with less obvious ones.

References-found: 32

