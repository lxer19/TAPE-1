URL: http://www.cs.mu.oz.au/tr_db/mu_97_09.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: Termination Analysis for Mercury  
Author: Chris Speirs, Zoltan Somogyi and Harald Stndergaard 
Address: Parkville, Victoria 3052, Australia  
Affiliation: Department of Computer Science The University of Melbourne  
Abstract: Since the late eighties, much progress has been made in the theory of termination analysis for logic programs. However, from a practical point of view, the significance of much of the work on termination is hard to judge, since experimental evaluations rarely get published. Here we describe and evaluate a termination analyzer for Mercury, a strongly typed and moded logic- functional programming language. Mercury's high degree of referential transparency and the guaranteed availability of reliable mode information simplify the termination analysis of Mer- cury compared with that of other logic programming languages. We describe our termination analyzer, which uses a variant of a method developed by Plumer. It deals with full Mercury, including modules, declarative input/output, the foreign language interface, and higher-order features. In spite of these obstacles, it produces high-quality termination information, comparable to the results recently obtained by Lindenstrauss and Sagiv. Most important, in stark contrast with Lindenstrauss and Sagiv's experimental results, our analyzer has a negligible impact on the running time of the compiler of which it is part, even for large programs. This means that the Mercury compiler can produce valuable termination information at no real cost to the programmer.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K.R. Apt and D. Pedreschi. </author> <title> Reasoning about termination of pure Prolog programs. </title> <booktitle> In Advances in Logic Programming Theory, </booktitle> <pages> pages 183-229. </pages> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: In this case, the program's input streams are not finite. 5 Experimental evaluation 5.1 Small test programs For their recent paper [13], Lindenstrauss and Sagiv have gathered together a large set of small Prolog programs that have previously been used by other researchers <ref> [1, 7, 8, 16] </ref> to test the perfor <p>- 17 Suite Program Query Time Us LS M/P apt append append (out,out,in) 0.04s T T apt fold fold (in,in,out) 0.03s T T apt list list (in) 0.03s T T apt lte goal 0.04s T T apt map map (in,out) 0.04s T T <p> For three of the benchmark sets (the ones from <ref> [1, 7, 8] </ref>, indicated by apt, bgh and dds respectively) our termination analysis gives answers which are identical to the ones given by the algorithms of Lindenstrauss and Sagiv.
Reference: [2] <author> Michel Berkelaar. </author> <note> lp solve version 2.0. Available from ftp://ftp.es.ele.tue.nl/pub/lp solve. </note>
Reference-contexts: Our implementation solves the final conjunction of constraints using version 2.0 of a third-party package called lp solve, which is a version of the simplex algorithm implemented in C <ref> [2] </ref>. Another refinement is that in the implementation of Step 2, we avoid the repeated traversal of clauses implied by the algorithm in figure 3. As these separate traversals are independent, they can be executed in parallel.
Reference: [3] <author> Roland N. Bol. </author> <title> Loop Checking in Logic Programming. </title> <type> PhD thesis, </type> <institution> University of Amsterdam, </institution> <address> The Netherlands, </address> <year> 1991. </year>
Reference-contexts: The approach that we have used in our implementation has its roots in the seminal work by Ullman and Van Gelder [20], and in the development it spurred, including <ref> [3, 5, 6, 18] </ref>. The immediate inspiration was the work by Plumer [16], and Groger and Plumer's handling of mutual recursion [10].
Reference: [4] <author> A. Bossi, N. Cocco, and M. Fabris. </author> <title> Proving termination of logic programs by exploiting term properties. </title> <editor> In S. Abramsky and T. S. E. Maibaum, editors, </editor> <booktitle> Proc. TAPSOFT'91, </booktitle> <volume> vol. 2, </volume> <booktitle> Lecture Notes in Computer Science 494, </booktitle> <pages> pages 153-180. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: We have not said exactly what "smaller" means in the context of termination analysis. However, the basic idea is obvious: "smaller" has to be with respect to some well-founded ordering. The concept of a "semi-linear norm" <ref> [4] </ref> is a common base for most proposals for termination orderings. We adopt the variant of the definition used by Groger and Plumer. Definition 3.1 Let T erm be the set of terms, F unc the set of function symbols, and N be the set of natural numbers (including 0).
Reference: [5] <author> A. Bossi, N. Cocco, and M. Fabris. </author> <title> Typed norms. </title> <editor> In B. Krieg-Bruckner, editor, </editor> <booktitle> Proc. ESOP'92, Lecture Notes in Computer Science 582, </booktitle> <pages> pages 73-92. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The approach that we have used in our implementation has its roots in the seminal work by Ullman and Van Gelder [20], and in the development it spurred, including <ref> [3, 5, 6, 18] </ref>. The immediate inspiration was the work by Plumer [16], and Groger and Plumer's handling of mutual recursion [10].
Reference: [6] <author> Alexander Brodsky and Yehoshua Sagiv. </author> <title> Inference of inequality constraints in logic programs (extended abstract). </title> <booktitle> In Proc. Tenth ACM SIGACT-SIGMOD-SIGART Symp. Principles of Database Systems, </booktitle> <pages> pages 227-240. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: The approach that we have used in our implementation has its roots in the seminal work by Ullman and Van Gelder [20], and in the development it spurred, including <ref> [3, 5, 6, 18] </ref>. The immediate inspiration was the work by Plumer [16], and Groger and Plumer's handling of mutual recursion [10].
Reference: [7] <author> F. Bueno, M. Garca de la Banda, and M. Hermenegildo. </author> <title> Effectiveness of global analysis in strict independence-based automatic program parallelization. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proc. Int. Logic Programming Symp., </booktitle> <pages> pages 320-336. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year> <month> 22 </month>
Reference-contexts: In this case, the program's input streams are not finite. 5 Experimental evaluation 5.1 Small test programs For their recent paper [13], Lindenstrauss and Sagiv have gathered together a large set of small Prolog programs that have previously been used by other researchers <ref> [1, 7, 8, 16] </ref> to test the perfor <p>- 17 Suite Program Query Time Us LS M/P apt append append (out,out,in) 0.04s T T apt fold fold (in,in,out) 0.03s T T apt list list (in) 0.03s T T apt lte goal 0.04s T T apt map map (in,out) 0.04s T T <p> For three of the benchmark sets (the ones from <ref> [1, 7, 8] </ref>, indicated by apt, bgh and dds respectively) our termination analysis gives answers which are identical to the ones given by the algorithms of Lindenstrauss and Sagiv.
Reference: [8] <author> Danny De Schreye and Stefaan Decorte. </author> <title> Termination of logic programs: The never-ending story. </title> <journal> Journal of Logic Programming, </journal> 19/20:199-260, 1994. 
Reference-contexts: In this case, the program's input streams are not finite. 5 Experimental evaluation 5.1 Small test programs For their recent paper [13], Lindenstrauss and Sagiv have gathered together a large set of small Prolog programs that have previously been used by other researchers <ref> [1, 7, 8, 16] </ref> to test the perfor <p>- 17 Suite Program Query Time Us LS M/P apt append append (out,out,in) 0.04s T T apt fold fold (in,in,out) 0.03s T T apt list list (in) 0.03s T T apt lte goal 0.04s T T apt map map (in,out) 0.04s T T <p> For three of the benchmark sets (the ones from <ref> [1, 7, 8] </ref>, indicated by apt, bgh and dds respectively) our termination analysis gives answers which are identical to the ones given by the algorithms of Lindenstrauss and Sagiv. <p> For a detailed account of the history of termination analysis for logic programs, as well as an instructive taxonomy, we refer the reader to the survey paper by De Schreye and Decorte <ref> [8] </ref>. The approach that we have used in our implementation has its roots in the seminal work by Ullman and Van Gelder [20], and in the development it spurred, including [3, 5, 6, 18].
Reference: [9] <author> Moreno Falaschi, Patrick Hicks, and William Winsborough. </author> <title> Demand transformation analysis for concurrent constraint programs. </title> <editor> In M. Maher, editor, </editor> <booktitle> Proc. Joint Int. Conf. Symp. Logic Programming, </booktitle> <pages> pages 333|347. </pages> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: The immediate inspiration was the work by Plumer [16], and Groger and Plumer's handling of mutual recursion [10]. We have obtained greatly improved results by enhancing the basic method with two kinds of "usage analysis", a process somewhat similar to the demand analysis of Falaschi, Hicks and Winsborough <ref> [9] </ref>. In Stage 1 we track input variables whose sizes contribute to the sizes of the output variables, while in Stage 2 we track input variables whose sizes contribute to the sizes of the input variables in recursive calls.
Reference: [10] <author> Gerhard Groger and Lutz Plumer. </author> <title> Handling of mutual recursion in automatic termination proofs for logic programs. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proc. Joint Int. Conf. Symp. Logic Programming, </booktitle> <pages> pages 336-350. </pages> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: In this paper we report on our experience with automatic termination detection for the logic- functional programming language Mercury. We have implemented a termination analyzer and incorporated it into the Mercury compiler. Our method is mainly based on the work of Groger and Plumer <ref> [10] </ref>. However, we have modified their algorithm slightly, and our modifications have had a great impact on its precision. We explain the Groger-Plumer approach and the changes we have made. <p> This involves producing and solving a set of linear inequalities. 2. Use the solution to check that in every cycle in the program's call graph, the input arguments decrease in size. More precisely we use an improved version of the algorithm given by Groger and Plumer <ref> [10] </ref>. For Groger and Plumer, there is a further initial stage, since programs must be shown to be "well- annotated in the strong sense" [10]. <p> More precisely we use an improved version of the algorithm given by Groger and Plumer <ref> [10] </ref>. For Groger and Plumer, there is a further initial stage, since programs must be shown to be "well- annotated in the strong sense" [10]. Fortunately the mode analysis component of the Mercury compiler already performs an equivalent check, and our termination analysis algorithm, which is also a part of the Mercury compiler, has full access to this mode information. We have not said exactly what "smaller" means in the context of termination analysis. <p> The debt we owe to Groger and Plumer's Algorithms 3.3 and 5.1 <ref> [10] </ref> will be clear to anybody familiar with Groger and Plumer's work, but our algorithms differ in a number of important ways: 1. In Groger and Plumer's algorithm, bags of variables serve to check that input variables are not used excessively, witness the double example. <p> The immediate inspiration was the work by Plumer [16], and Groger and Plumer's handling of mutual recursion <ref> [10] </ref>. We have obtained greatly improved results by enhancing the basic method with two kinds of "usage analysis", a process somewhat similar to the demand analysis of Falaschi, Hicks and Winsborough [9].
Reference: [11] <author> Fergus Henderson, Thomas Conway, Zoltan Somogyi, and David Jeffery. </author> <title> The Mercury lan-guage reference manual. </title> <type> Technical Report 96/10, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <year> 1996. </year> <note> Available from http://www.cs.mu.oz.au/mercury. </note>
Reference-contexts: However, the semantics of Mercury is still first-order, since the language does not allow higher-order terms to be compared or unified (except for unifications that implement assignment). For more details on Mercury, please refer to the language reference manual <ref> [11] </ref>. The compiler converts any predicate definition with two or more clauses into a single clause with an explicit disjunction.
Reference: [12] <author> David B. Kemp, Kotagiri Ramamohanarao, Isaac Balbin, and Krishnamurthy Meenakshi. </author> <title> Propagating constraints in recursive deductive databases. </title> <booktitle> In Proceedings of the First North American Conference on Logic Programming, </booktitle> <pages> pages 981-998. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: This is a significant concern when implementing program transformations that change the order of calls in the program (e.g., constraint propagation <ref> [12, 19] </ref>). For some time now there has been much interest in automatic termination analysis for logic programs, but it appears that implementations are rare and seldom go beyond the prototype stage.
Reference: [13] <author> N. Lindenstrauss and Y. Sagiv. </author> <title> Automatic termination analysis of logic programs (with detailed experimental results). </title> <note> http://www.cs.huji.ac.il/~naomil; Shorter version to appear in L. </note> <editor> Naish, editor, </editor> <booktitle> Logic Programming: Proc. Int. Conf. Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1997, 1997. </year>
Reference-contexts: In this case, the program's input streams are not finite. 5 Experimental evaluation 5.1 Small test programs For their recent paper <ref> [13] </ref>, Lindenstrauss and Sagiv have gathered together a large set of small Prolog programs that have previously been used by other researchers [1, 7, 8, 16] to test the perfor <p>- 17 Suite Program Query Time Us LS M/P apt append append (out,out,in) 0.04s T T apt fold fold (in,in,out) 0.03s <p> Tables 1 and 2 show our results. The first three columns specify the benchmark set (each set corresponds to one of the tables in <ref> [13] </ref>), the program within the benchmark set, and the query form. <p> For programs that use only one CPU (as our tests do), the performance of this machine is very similar to the performance of the SPARCstation 51 used by Lindenstrauss and Sagiv <ref> [13] </ref> for their benchmarking. This permits direct comparisons between their timing results and ours. The main difference is that while their algorithm is usually reasonably fast (taking 0.1 to 0.2 seconds), for a significant number of test programs it is quite slow (taking 20 to 120 seconds). <p> Third, the code within each module tends to be more complex in the compiler than in the library. For such a large program, we consider the accuracy we have achieved to be a very good result. For example, Lindenstrauss and Sagiv state <ref> [13] </ref> that the largest Prolog program they have processed successfully has 57 clauses; the compiler is two orders of magnitude larger than that. We believe there are good reasons why duplicating our level of accuracy for such large programs with a termination analyzer written for Prolog would be very difficult. <p> The obvious question of whether the theory can be turned into useful practical tools for full programming languages has mainly been left unanswered, as have questions about efficiency/precision trade-offs in practice. The only clear exception that we know of is the work by Lindenstrauss and Sagiv <ref> [13] </ref> who give detailed timing and precision results for a large collection of small Prolog programs. In our design and implementation of a termination analyzer for Mercury, this work has helped us in many ways, in particular by setting a goal for us to match. <p> An important conclusion from our work is that this can be done without incurring a high performance penalty. We have tested the performance of our analyzer on most of the benchmark programs used by Lindenstrauss and Sagiv <ref> [13] </ref>. Our results show that our analyzer has comparable accuracy and better performance in the average case. They also show that our analyzer is not subject to the dramatic slowdowns that sometimes affect Lindenstrauss and Sagiv's prototype analyzer. 2 We discovered this fact in the course of this research.
Reference: [14] <institution> The Mercury group. </institution> <note> Mercury 0.6. Available from http://www.cs.mu.oz.au/mercury. </note>
Reference: [15] <author> John K. Ousterhout. </author> <title> Tcl and the tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Second, it gives every Mercury programmer a relatively simple way to interface a Mercury program to code written in other languages, such as tcl and the tk library <ref> [15] </ref>. (Even if the code one wants to interface to is not written in C, one can usually count on the existence of an interface between that language and C.) Given that analyzing C code for termination is not a feasible proposition, not least because of lack of access to the
Reference: [16] <author> Lutz Plumer. </author> <title> Termination Proofs for Logic Programs, </title> <booktitle> volume 446 of Lecture Notes in Artificial Intelligence. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Note that due to mode reordering, the internal form of append (out,out,in) is considerably different. For the sake of simplicity we will show disjunctions as separate clauses in the rest of the paper. 3 3 The termination analysis We follow the overall approach proposed by Plumer <ref> [16] </ref>. The method has two stages: 1. Assign an integer to each procedure, giving the upper bound on the difference between the total size of the output arguments and the total size of the input arguments. This involves producing and solving a set of linear inequalities. 2. <p> This requires the analysis to consider fl qsort to be 1, which can significantly degrade the accuracy of the analysis of the callers of qsort. This type of problem was also identified by Plumer <ref> [16] </ref>, and quite likely by others before him. The problem is that the above analysis does not distinguish between those input arguments whose values contribute to the size of the output arguments and those that do not. <p> In this case, the program's input streams are not finite. 5 Experimental evaluation 5.1 Small test programs For their recent paper [13], Lindenstrauss and Sagiv have gathered together a large set of small Prolog programs that have previously been used by other researchers <ref> [1, 7, 8, 16] </ref> to test the perfor <p>- 17 Suite Program Query Time Us LS M/P apt append append (out,out,in) 0.04s T T apt fold fold (in,in,out) 0.03s T T apt list list (in) 0.03s T T apt lte goal 0.04s T T apt map map (in,out) 0.04s T T <p> For three of the benchmark sets (the ones from [1, 7, 8], indicated by apt, bgh and dds respectively) our termination analysis gives answers which are identical to the ones given by the algorithms of Lindenstrauss and Sagiv. For the fourth benchmark set (the one from <ref> [16] </ref>, indicated by plu) the accuracy of our analyzer is comparable to theirs; while we obtained a more precise result for perm (in, out), they obtained a more precise result for one particular variant of mergesort (in, out). <p> The approach that we have used in our implementation has its roots in the seminal work by Ullman and Van Gelder [20], and in the development it spurred, including [3, 5, 6, 18]. The immediate inspiration was the work by Plumer <ref> [16] </ref>, and Groger and Plumer's handling of mutual recursion [10]. We have obtained greatly improved results by enhancing the basic method with two kinds of "usage analysis", a process somewhat similar to the demand analysis of Falaschi, Hicks and Winsborough [9].
Reference: [17] <author> Robert Sedgewick. </author> <title> Algorithms in C. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference: [18] <author> Kirack Sohn and Allen Van Gelder. </author> <title> Termination detection in logic programs using argument sizes (extended abstract). </title> <booktitle> In Proc. Tenth ACM SIGACT-SIGMOD-SIGART Symp. Principles of Database Systems, </booktitle> <pages> pages 216-226. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: The approach that we have used in our implementation has its roots in the seminal work by Ullman and Van Gelder [20], and in the development it spurred, including <ref> [3, 5, 6, 18] </ref>. The immediate inspiration was the work by Plumer [16], and Groger and Plumer's handling of mutual recursion [10].
Reference: [19] <author> Zoltan Somogyi, Fergus Henderson, and Thomas Conway. </author> <title> The execution algorithm of Mercury, an efficient purely declarative logic programming language. </title> <journal> Journal of Logic Programming, </journal> <volume> 29(1-3):17-64, </volume> <year> 1996. </year>
Reference-contexts: This is a significant concern when implementing program transformations that change the order of calls in the program (e.g., constraint propagation <ref> [12, 19] </ref>). For some time now there has been much interest in automatic termination analysis for logic programs, but it appears that implementations are rare and seldom go beyond the prototype stage.
Reference: [20] <author> Jeffrey D. Ullman and Allen Van Gelder. </author> <title> Efficient tests for top-down termination of logical rules. </title> <journal> Journal of the ACM, </journal> <volume> 35(2) </volume> <pages> 345-373, </pages> <year> 1988. </year> <month> 23 </month>
Reference-contexts: The purpose of Stage 1 is to compute such information. 4 Since a paper by Ullman and Van Gelder <ref> [20] </ref>, researchers in the field have represented this infor-mation via predicate inequalities. <p> The approach that we have used in our implementation has its roots in the seminal work by Ullman and Van Gelder <ref> [20] </ref>, and in the development it spurred, including [3, 5, 6, 18]. The immediate inspiration was the work by Plumer [16], and Groger and Plumer's handling of mutual recursion [10].
References-found: 20

