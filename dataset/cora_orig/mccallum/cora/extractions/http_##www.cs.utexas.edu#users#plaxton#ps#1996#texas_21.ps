URL: http://www.cs.utexas.edu/users/plaxton/ps/1996/texas_21.ps
Refering-URL: http://www.cs.utexas.edu/users/plaxton/html/abc.html
Root-URL: 
Title: Fast Fault-Tolerant Concurrent Access to Shared Objects  
Author: C. Greg Plaxton Rajmohan Rajaraman 
Abstract: We consider a synchronous model of distributed computation in which n nodes communicate via point-to-point messages, subject to the following constraints: (i) in a single "step", a node can only send or receive O(log n) words, and (ii) communication is unreliable in that a constant fraction of all messages may be lost at each step due to node and/or link failures. We design and analyze a simple local protocol for providing fast concurrent access to shared objects in this faulty network environment. In our protocol, clients use a hashing-based method to access shared objects. When a large number of clients attempt to read a given object at the same time, the object is rapidly replicated to an appropriate number of servers. Once the necessary level of replication has been achieved, each remaining request for the object is serviced within O(1) expected steps. Our protocol has practical potential for supporting high levels of concurrency in distributed file systems over wide area networks.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Alon and J. H. Spencer. </author> <title> The Probabilistic Method. </title> <publisher> Wiley, </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference: [2] <author> T. E. Anderson, M. D. Dahlin, J. N. Neefe, D. A. Patterson, D. S. Rosselli, and R. Y. Wang. </author> <title> Serverless network file systems. </title> <booktitle> In Proceedings of the 15th Symposium on Operating Systems Principles, </booktitle> <pages> pages 109-126, </pages> <year> 1995. </year> <month> 26 </month>
Reference-contexts: See Section 4 for a formal statement of our main results. We remark that existing implementations for handling concurrent access to shared objects (e.g., <ref> [2, 5, 10] </ref>) do not provide fast concurrent access in the sense considered in this paper. While these schemes incorporate replication of objects, the only way for a client to determine where the copies of a given object are stored is to consult the "manager" of the object.
Reference: [3] <author> Y. Aumann, Z. Kedem, K. V. Palem, and M. O. Rabin. </author> <title> Highly efficient asynchronous execution of large-grained parallel programs. </title> <booktitle> In Proceedings of the 34th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 271-280, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Thus, IDA can be used to obtain fault-tolerance with only a constant factor space penalty by setting m to fi (log n) and k to fi (m), e.g., k = 2m. This powerful technique is used by Aumann et al. <ref> [3] </ref> as part of an efficient scheme for emulating large-grained PRAM programs on an asynchronous parallel machine. In this paper, we use the same technique to store the "primary" copy of each object.
Reference: [4] <author> E. Berlekamp and L. Welch. </author> <title> Error correction of algebraic block codes. </title> <type> U.S. Patent Number 4,633,470. </type>
Reference-contexts: Unless the noisy fragments can be easily identified as such, the client cannot efficiently reconstruct the object using IDA. In such a noisy setting, it would be worthwhile to consider variants of our protocol based on the Berlekamp-Welch decoder <ref> [4] </ref> (see also [16, Appendix A]), which tolerates noise in a constant fraction of the fragments. We would like to extend our protocols to other interesting models of distributed computation that incorporate asynchrony or locality information.
Reference: [5] <author> M. A. </author> <title> Blaze. Caching in large-scale distributed file systems. </title> <type> Technical Report TR-397-92, </type> <institution> Department of Computer Science, Princeton University, </institution> <month> January </month> <year> 1993. </year> <type> PhD Thesis. </type>
Reference-contexts: See Section 4 for a formal statement of our main results. We remark that existing implementations for handling concurrent access to shared objects (e.g., <ref> [2, 5, 10] </ref>) do not provide fast concurrent access in the sense considered in this paper. While these schemes incorporate replication of objects, the only way for a client to determine where the copies of a given object are stored is to consult the "manager" of the object.
Reference: [6] <author> H. Chernoff. </author> <title> A measure of the asymptotic efficiency for tests of a hypothesis based on the sum of observations. </title> <journal> Annals of Mathematical Statistics, </journal> <volume> 23 </volume> <pages> 493-509, </pages> <year> 1952. </year>
Reference-contexts: By a straightforward Chernoff-type argument <ref> [6] </ref>, we can show that a constant fraction of the client requests for A are satisfied at the current step, establishing Invariant 2. Cache management. Each node has a cache for holding extra object copies. <p> Let a 3 and a 4 be real constants such that for p a 0 log n=n, a 4 np B (n; p) a 3 np whp; a 3 and a 4 are obtained from standard Chernoff bounds <ref> [6] </ref>, given in Theorem A.1. 15 Lemma 6.5 Let rounds 0 through r 1 be good. If object A i is not steady in rounds 0 through r, then whp we have d i (j) = j and e i (j) = j + 1 for 0 j &lt; r.
Reference: [7] <author> V. Chvatal. </author> <title> The tail of the hypergeometric distribution. </title> <journal> Discrete Mathematics, </journal> <volume> 25 </volume> <pages> 285-287, </pages> <year> 1979. </year>
Reference-contexts: It follows from bounds on the tail of the hypergeometric distribution <ref> [7] </ref>, given in Theorem A.2, that a constant fraction of the messages in N (A j ; i; t) are attempted by nodes in U 0 . By setting c 0 and c 1 sufficently large, we obtain that jN 0 ff (A j ; i; t)j 2.
Reference: [8] <author> S. Deering and D. Cheriton. </author> <title> Multicast routing in datagram internetworks and extended LANs. </title> <journal> ACM Transactions on Computer Systems, </journal> <pages> pages 85-111, </pages> <year> 1990. </year>
Reference-contexts: Most of the details of our protocol are concerned with ensuring fast access to popular objects. A variety of other well-known methods have been used for solving this problem, including broadcast, combining [15], and multicast <ref> [8] </ref>. However, the class of architectures that support the efficient implementation of these methods is restricted.
Reference: [9] <author> P. Gibbons, Y. Matias, and V. Ramachandran. </author> <title> The QRQW PRAM: Accounting for contention in parallel algorithms. </title> <booktitle> In Proceedings of the 5th Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 638-648, </pages> <month> January </month> <year> 1994. </year> <note> To appear in SIAM Journal on Computing. </note>
Reference-contexts: In related work, Gibbons et al. <ref> [9] </ref> adopt a different approach to account for contention in parallel algorithms. They introduce the QRQW PRAM model, which permits concurrent reading and writing but at a cost proportional to the number of readers/writers to a memory location in a given step.
Reference: [10] <author> J. S. Gwertzman and M. Seltzer. </author> <title> The case for geographical push-caching. </title> <booktitle> In Proceedings of the 5th Workshop on Hot Topics in Operating Systems, </booktitle> <pages> pages 51-57, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: See Section 4 for a formal statement of our main results. We remark that existing implementations for handling concurrent access to shared objects (e.g., <ref> [2, 5, 10] </ref>) do not provide fast concurrent access in the sense considered in this paper. While these schemes incorporate replication of objects, the only way for a client to determine where the copies of a given object are stored is to consult the "manager" of the object.
Reference: [11] <author> W. Hoeffding. </author> <title> Probability inequalities for sums of bounded random variables. </title> <journal> Journal of the American Statistical Association, </journal> <volume> 58 </volume> <pages> 13-30, </pages> <year> 1963. </year>
Reference: [12] <author> R. Karp, M. Luby, and F. Meyer auf der Heide. </author> <title> Efficient PRAM simulation on a distributed memory machine. </title> <booktitle> In Proceedings of the 24th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 318-326, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: length), we assume that a worst-case adversary determines which subset of the messages of total size c 0 log n are successfully received by a given node if the c 0 log n limit on total size would otherwise be exceeded. (The related c-arbitrary DMM model of Karp et al. <ref> [12] </ref> does not take into account contention among clients trying to access the same object and hence is not well-suited for our study.) Message types. Our protocol makes use of a constant number of different types of messages.
Reference: [13] <author> P. D. MacKenzie, C. G. Plaxton, and R. Rajaraman. </author> <title> On contention resolution protocols and associated probabilistic phenomena. </title> <booktitle> In Proceedings of the 26th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 153-162, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: paper to mean "with high probability" or, more precisely, "with probability 1 n c , where n is the number of nodes in the network and c is a constant that can be set arbitrarily large by appropriately adjusting other constants defined within the relevant context." 3 MacKenzie et al. <ref> [13] </ref> (where all messages have unit length), we assume that a worst-case adversary determines which subset of the messages of total size c 0 log n are successfully received by a given node if the c 0 log n limit on total size would otherwise be exceeded. (The related c-arbitrary DMM
Reference: [14] <author> M. O Rabin. </author> <title> Efficient dispersal of information for security, load balancing and fault tolerance. </title> <journal> JACM, </journal> <volume> 36 </volume> <pages> 335-348, </pages> <year> 1989. </year>
Reference-contexts: Unfortunately, this results in an (log n)-fold increase in the space needed to store each object. However, the theory of erasure codes provides a convenient method for achieving fault-tolerance while paying only a constant factor space penalty. For example, using Rabin's Information Dispersal Algorithm <ref> [14] </ref> (IDA), for any k &gt; m, a given b-bit string can be encoded as a set of k (b=m)-bit strings of length m, with the property that any m of the (b=m)-bit strings suffice to reconstruct the original b-bit string. <p> In our scheme, we choose 2 to replicate whole copies of popular objects, as opposed to fragments, so that the encode-decode overhead associated with IDA can be avoided on retrieval of popular objects. (This may be viewed as a minor optimization since the overhead of IDA is actually quite small <ref> [14] </ref>.) At a high level, our protocol achieves fast concurrent access by enforcing the following two invariants.
Reference: [15] <author> A. G. Ranade. </author> <title> How to emulate shared memory. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 42 </volume> <pages> 307-326, </pages> <year> 1991. </year>
Reference-contexts: Most of the details of our protocol are concerned with ensuring fast access to popular objects. A variety of other well-known methods have been used for solving this problem, including broadcast, combining <ref> [15] </ref>, and multicast [8]. However, the class of architectures that support the efficient implementation of these methods is restricted.
Reference: [16] <author> M. Sudan. </author> <title> Efficient Checking of Polynomials and Proofs and the Hardness of Approximation Problems. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of California at Berkeley, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: Unless the noisy fragments can be easily identified as such, the client cannot efficiently reconstruct the object using IDA. In such a noisy setting, it would be worthwhile to consider variants of our protocol based on the Berlekamp-Welch decoder [4] (see also <ref> [16, Appendix A] </ref>), which tolerates noise in a constant fraction of the fragments. We would like to extend our protocols to other interesting models of distributed computation that incorporate asynchrony or locality information.
Reference: [17] <author> L. Valiant. </author> <title> A combining mechanism for parallel computers. </title> <type> Technical Report TR-24-92, </type> <institution> Center for Research in Computing Technology, Harvard University, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: subsequent steps, each of the outstanding requests is serviced in O (1) expected steps, and in O (log n) steps whp 1 .) The methods used to establish these invariants, discussed in Section 3, are loosely related to Valiant's hashing-based combining mechanism for simulating CRCW PRAM algorithms on parallel computers <ref> [17] </ref>. In related work, Gibbons et al. [9] adopt a different approach to account for contention in parallel algorithms. They introduce the QRQW PRAM model, which permits concurrent reading and writing but at a cost proportional to the number of readers/writers to a memory location in a given step.
Reference: [18] <author> L. G. Valiant. </author> <title> A bridging model for parallel computation. </title> <journal> Communications of the ACM, </journal> <volume> 33 </volume> <pages> 103-111, </pages> <year> 1990. </year>
Reference-contexts: For this reason, we have chosen to implement and evaluate the performance of our protocol under a model of computation that may be loosely viewed as a variant of Valiant's bulk-synchronous parallel (BSP) model <ref> [18] </ref>. As in the BSP model, we assume the existence of a simple point-to-point router with no built-in combining or multicast capability. (See [18] for a detailed justification of this assumption.) In order to demonstrate the fault-tolerance of our protocol, our model of computation incorporates both static and dynamic node faults <p> implement and evaluate the performance of our protocol under a model of computation that may be loosely viewed as a variant of Valiant's bulk-synchronous parallel (BSP) model <ref> [18] </ref>. As in the BSP model, we assume the existence of a simple point-to-point router with no built-in combining or multicast capability. (See [18] for a detailed justification of this assumption.) In order to demonstrate the fault-tolerance of our protocol, our model of computation incorporates both static and dynamic node faults as well as a notion of faulty communication. <p> Receiving messages. In a BSP-like model <ref> [18] </ref>, where communication is assumed to take the form of an h-relation, we might now tend to add a requirement that the total number of words in all messages destined to a single node in one step must be O (log n).
References-found: 18

