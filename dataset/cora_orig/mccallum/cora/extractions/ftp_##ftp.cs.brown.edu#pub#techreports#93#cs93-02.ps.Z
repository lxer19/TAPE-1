URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-02.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-02.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Aggoun and N. Beldiceanu. </author> <title> Extending CHIP To Solve Complex Scheduling and Packing Problems. In Journees Francophones De Programmation Logique, </title> <address> Lille, France, </address> <year> 1992. </year>
Reference-contexts: The generation of places for the squares requires to give values to the x and the y coordinates of all squares. We use the idea of <ref> [1] </ref> for the labeling of a coordinate, exploiting the fact that no empty space is allowed. At each step, the program identifies the smallest possible coordinate and select a square to be placed at this position. On backtracking, another square is selected for the same position.
Reference: [2] <author> M. Bartusch. </author> <title> Optimierung von Netzplaenen mit Anordnungsbeziehungen bei Knappen Betrieb-smitteln. </title> <type> PhD thesis, </type> <institution> Fakultaet fur Mathematik und Informatik, Universitaet Passau (F.R.G), </institution> <year> 1983. </year>
Reference-contexts: The number of lines (which includes blank lines and comments) gives also an idea of the compactness of the programs which enables a short development time. Bridge is a disjunctive scheduling problem from <ref> [2] </ref>, car is a car-sequencing problem [?, 25], cutting is the numerical statement of a cutting-stock problem taken from [10], satel1, satel2 are two resource allocation problems with distance constraints, square is the perfect packing problem, hamilton is the Euler knight problem, donald, sendmory are two cryptarithmetic problems, queens8, queensall, queens96
Reference: [3] <author> W. Buttner and H. Simonis. </author> <title> Embedding Boolean Expressions into Logic Programming. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 4 </volume> <pages> 191-205, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: The CLP scheme can be instantiated to produce a specific language by defining a constraint system (i.e. defining a set of primitive constraints and providing a constraint solver for the constraints). For instance, CHIP contains constraint systems over finite domains [30], Booleans <ref> [3] </ref> and rational numbers [14, 35], Prolog III [9] is endowed with constraint 1 systems over Booleans, rational numbers, and lists, while CLP (&lt;) [17] solves constraints over real numbers.
Reference: [4] <author> J. Carlier. </author> <title> Ordonnancement A Constraintes Disjonctives. </title> <journal> RAIRO Operations Research, </journal> <volume> 12(4) </volume> <pages> 333-351, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: Both algorithms were run on the same machine. As can be seen from the data, cc (FD) compares very well with the specialized program especially for the largest problems. The cc (FD) program is about 200 lines long. Table 3 compares cc (FD) with a specialized scheduling algorithm <ref> [4] </ref>. These are very difficult scheduling problems, requiring sophisticated handling of disjunctions.
Reference: [5] <author> J. Carlier and E. Pinson. </author> <title> Une Methode Arborescente pour Optimiser la Duree d'un JOB-SHOP. </title> <type> Technical Report ISSN 0294-2755, I.M.A, </type> <year> 1986. </year>
Reference-contexts: These approaches are orthogonal and complementary. The global search paradigm has been used successfully to solve a large variety of combinatorial search problems with reasonable efficiency (e.g. scheduling <ref> [5] </ref>, graph coloring [18], Hamiltonian circuits [8], microcode labeling [12]) and provides, at the same time, the basis for exact methods as well as approximate solutions (giving rise to the so-called "anytime algorithms" [11]). CLP languages over finite domains (e.g. <p> In particular, we were able, using cc (FD), to find the optimal solution, and prove its optimality, to a famous 10/10 scheduling problem [23], which was left open for more than 20 years and finally solved in 1988 <ref> [5] </ref>. <p> Finally, it is interesting to point out that the cc (FD) program is able to solve optimally and prove optimality of a famous 10/10 job shop scheduling which was posed in 1963 [23] and left open for 25 years before being solved in <ref> [5] </ref>. The algorithm in [5] is very involved including relaxation techniques to preemptive scheduling. This problem requires about 90 hours of computation. The above results seem to indicate that cc (FD) is a step in closing the gap between declarative constraint languages and procedural languages. <p> Finally, it is interesting to point out that the cc (FD) program is able to solve optimally and prove optimality of a famous 10/10 job shop scheduling which was posed in 1963 [23] and left open for 25 years before being solved in <ref> [5] </ref>. The algorithm in [5] is very involved including relaxation techniques to preemptive scheduling. This problem requires about 90 hours of computation. The above results seem to indicate that cc (FD) is a step in closing the gap between declarative constraint languages and procedural languages.
Reference: [6] <author> M. Carlsson. </author> <title> Freeze, Indexing and Other Implemenation Issues on the WAM. </title> <editor> In J-L. Lassez, editor, </editor> <booktitle> Fourth International Conference on Logic Programming, </booktitle> <pages> pages 40-58, </pages> <address> Melbourne, Aus-tralia, </address> <year> 1987. </year>
Reference-contexts: The list is executed in a depth-first manner for simplicity and closely follows the traditional implementation of delay mechanisms (e.g. <ref> [6] </ref>). 5 Experimental Results In this section, we report a number of experimental results of cc (FD). All times are for a Sun Sparc Station I (Sun 4/60).
Reference: [7] <author> J.W. Chinneck, R.A. Goubran, G.M. Karam, and M Lavoie. </author> <title> A Design Approach For Real-Time Multiprocessor DSP Applications. </title> <type> Report sce-90-05, </type> <institution> Carleton University, </institution> <address> Ottawa, Canada, </address> <month> February </month> <year> 1990. </year>
Reference-contexts: The no-overlap constraint is an important part of the disjunctive scheduling programs reported in the experimental results. Example 13 [Communication Constraints] An interesting application of the cardinality combi-nator occurs in the Digital Signal Processing (DSP) application of <ref> [7, 31] </ref>, whose results are also reported in the experimental results. The purpose of the application is to allocate tasks to processors in an architecture combining pipeline processing and master-slave processing in order to minimize the total delay of the DSP application. <p> Table 2 compares cc (FD) with a specialized branch and bound algorithm written in C on a number of DSP problems <ref> [7, 19] </ref>. Both algorithms were run on the same machine. As can be seen from the data, cc (FD) compares very well with the specialized program especially for the largest problems. The cc (FD) program is about 200 lines long.
Reference: [8] <author> N. Christofides. </author> <title> Graph Theory: An Algorithmic Approach. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1975. </year>
Reference-contexts: These approaches are orthogonal and complementary. The global search paradigm has been used successfully to solve a large variety of combinatorial search problems with reasonable efficiency (e.g. scheduling [5], graph coloring [18], Hamiltonian circuits <ref> [8] </ref>, microcode labeling [12]) and provides, at the same time, the basis for exact methods as well as approximate solutions (giving rise to the so-called "anytime algorithms" [11]). CLP languages over finite domains (e.g.
Reference: [9] <author> A. Colmerauer. </author> <title> An Introduction to Prolog III. </title> <journal> CACM, </journal> <volume> 28(4) </volume> <pages> 412-418, </pages> <year> 1990. </year>
Reference-contexts: For instance, CHIP contains constraint systems over finite domains [30], Booleans [3] and rational numbers [14, 35], Prolog III <ref> [9] </ref> is endowed with constraint 1 systems over Booleans, rational numbers, and lists, while CLP (&lt;) [17] solves constraints over real numbers.
Reference: [10] <author> M.C. Costa. </author> <title> Une etude pratique de decoupes de panneaux de bois. </title> <journal> RAIRO Recherche Opera-tionnelle, </journal> <volume> 18(3) </volume> <pages> 211-219, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Bridge is a disjunctive scheduling problem from [2], car is a car-sequencing problem [?, 25], cutting is the numerical statement of a cutting-stock problem taken from <ref> [10] </ref>, satel1, satel2 are two resource allocation problems with distance constraints, square is the perfect packing problem, hamilton is the Euler knight problem, donald, sendmory are two cryptarithmetic problems, queens8, queensall, queens96 are n-queens programs to find respectively the first solution to the 8-queens problem, all solutions to the 8-queens problem,
Reference: [11] <author> T. Dean and M. Boddy. </author> <title> An Analysis of Time-dependent Planning. </title> <booktitle> In Proceedings of the Seventh National Conference On Artificial Intelligence, </booktitle> <pages> pages 49-54, </pages> <address> Minneapolis, Minnesota, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: been used successfully to solve a large variety of combinatorial search problems with reasonable efficiency (e.g. scheduling [5], graph coloring [18], Hamiltonian circuits [8], microcode labeling [12]) and provides, at the same time, the basis for exact methods as well as approximate solutions (giving rise to the so-called "anytime algorithms" <ref> [11] </ref>). CLP languages over finite domains (e.g. CHIP [13, 30]) have been applied to numerous discrete combinatorial problems, including graph coloring, cutting stock, microcode labeling, warehouse location, and car-sequencing.
Reference: [12] <author> M. Dincbas, H. Simonis, and P. Van Hentenryck. </author> <title> Solving Large Combinatorial Problems in Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 8(1-2):75-93, </volume> <year> 1990. </year>
Reference-contexts: These approaches are orthogonal and complementary. The global search paradigm has been used successfully to solve a large variety of combinatorial search problems with reasonable efficiency (e.g. scheduling [5], graph coloring [18], Hamiltonian circuits [8], microcode labeling <ref> [12] </ref>) and provides, at the same time, the basis for exact methods as well as approximate solutions (giving rise to the so-called "anytime algorithms" [11]). CLP languages over finite domains (e.g.
Reference: [13] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Berthier. </author> <title> The Constraint Logic Programming Language CHIP. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <address> Tokyo, Japan, </address> <month> December </month> <year> 1988. </year> <month> 19 </month>
Reference-contexts: CLP languages over finite domains (e.g. CHIP <ref> [13, 30] </ref>) have been applied to numerous discrete combinatorial problems, including graph coloring, cutting stock, microcode labeling, warehouse location, and car-sequencing. For many problems, they allow a short development time and an efficiency which compares well with procedural languages implementing the same approach.
Reference: [14] <author> T. Graf. </author> <title> Extending Constraint Handling in Logic Programming to Rational Arithmetic. </title> <type> In--ternal Report, </type> <institution> ECRC, Munich, </institution> <month> Septembre </month> <year> 1987. </year>
Reference-contexts: The CLP scheme can be instantiated to produce a specific language by defining a constraint system (i.e. defining a set of primitive constraints and providing a constraint solver for the constraints). For instance, CHIP contains constraint systems over finite domains [30], Booleans [3] and rational numbers <ref> [14, 35] </ref>, Prolog III [9] is endowed with constraint 1 systems over Booleans, rational numbers, and lists, while CLP (&lt;) [17] solves constraints over real numbers.
Reference: [15] <author> T. Graf, P. Van Hentenryck, C. Pradelles, and L. Zimmer. </author> <title> Simulation of Hybrid Circuits in Constraint Logic Programming. </title> <booktitle> In International Joint Conference on Artificial Intelligence, </booktitle> <address> Detroit, Michigan, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: Operationally, the intention is that Min be greater than at least one of the X i that can be equal to Entry. 3.4 The Implication Combinator Motivation Blocking implication <ref> [21, 27, 15] </ref> is a combinator generalizing coroutining mechanisms in logic programming. The main idea behind coroutining mechanisms is to postpone execution of a goal until some conditions on its variables are satisfied. The main idea behind blocking implication is to use constraints for the conditions.
Reference: [16] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In POPL-87, </booktitle> <address> Munich, FRG, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Constraint Logic Programming (CLP) is a new class of declarative programming languages combining nondeterminism and constraint solving. The fundamental idea behind these languages, to use constraint solving instead of unification as the kernel operation of the language, was elegantly captured in the CLP scheme <ref> [16] </ref>. The CLP scheme can be instantiated to produce a specific language by defining a constraint system (i.e. defining a set of primitive constraints and providing a constraint solver for the constraints).
Reference: [17] <author> J. Jaffar and S. Michaylov. </author> <title> Methodology and Implementation of a CLP System. </title> <booktitle> In Fourth International Conference on Logic Programming, </booktitle> <address> Melbourne, Australia, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: For instance, CHIP contains constraint systems over finite domains [30], Booleans [3] and rational numbers [14, 35], Prolog III [9] is endowed with constraint 1 systems over Booleans, rational numbers, and lists, while CLP (&lt;) <ref> [17] </ref> solves constraints over real numbers. The CLP scheme was further generalized into the cc framework of concurrent constraint programming [27, 28, 29] to accommodate additional constraint operations (e.g. constraint entailment [21]) and new ways of combining them (e.g. implication or blocking ask [27] and cardinality [32]).
Reference: [18] <author> M. Kubale and D. Jackowski. </author> <title> A Generalized Implicit Enumeration Algorithm for Graph Coloring. </title> <journal> CACM, </journal> <volume> 28(4) </volume> <pages> 412-418, </pages> <year> 1985. </year>
Reference-contexts: These approaches are orthogonal and complementary. The global search paradigm has been used successfully to solve a large variety of combinatorial search problems with reasonable efficiency (e.g. scheduling [5], graph coloring <ref> [18] </ref>, Hamiltonian circuits [8], microcode labeling [12]) and provides, at the same time, the basis for exact methods as well as approximate solutions (giving rise to the so-called "anytime algorithms" [11]). CLP languages over finite domains (e.g.
Reference: [19] <author> Marco Lavoie. </author> <title> Task Assignment In A DSP Multiprocessor Environment. </title> <type> Master Thesis, </type> <institution> Department of Systems and Computer Engineering, Carleton University, </institution> <address> Ottawa, Ontario, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Table 2 compares cc (FD) with a specialized branch and bound algorithm written in C on a number of DSP problems <ref> [7, 19] </ref>. Both algorithms were run on the same machine. As can be seen from the data, cc (FD) compares very well with the specialized program especially for the largest problems. The cc (FD) program is about 200 lines long.
Reference: [20] <author> A.K. Mackworth. </author> <title> Consistency in Networks of Relations. </title> <journal> Artificial Intelligence, </journal> <volume> 8(1) </volume> <pages> 99-118, </pages> <year> 1977. </year>
Reference-contexts: of the variables at each computation step. 2 Our current design and implementation efforts are devoted to build cc (Q) and cc (B), two instances of the same framework for rational linear arithmetics and Boolean algebra. 3 The use of domain consistency in programming language was suggested first by Mackworth <ref> [20] </ref>. 7 Definition 2 The reduced domains of a constraint store are the largest domains D 1 ; . . . ; D n such that is domain-consistent wrt D 1 ; . . . ; D n , i.e. for all domains D 0 1 ; . . . ;
Reference: [21] <author> M.J. Maher. </author> <title> Logic Semantics for a Class of Committed-Choice Programs. </title> <booktitle> In Fourth International Conference on Logic Programming, </booktitle> <pages> pages 858-876, </pages> <address> Melbourne, Australia, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: The CLP scheme was further generalized into the cc framework of concurrent constraint programming [27, 28, 29] to accommodate additional constraint operations (e.g. constraint entailment <ref> [21] </ref>) and new ways of combining them (e.g. implication or blocking ask [27] and cardinality [32]). CLP languages 1 support, in a declarative way, the solving of combinatorial search problems using the global search paradigm. <p> Operationally, the intention is that Min be greater than at least one of the X i that can be equal to Entry. 3.4 The Implication Combinator Motivation Blocking implication <ref> [21, 27, 15] </ref> is a combinator generalizing coroutining mechanisms in logic programming. The main idea behind coroutining mechanisms is to postpone execution of a goal until some conditions on its variables are satisfied. The main idea behind blocking implication is to use constraints for the conditions.
Reference: [22] <author> R. Mohr and T.C. Henderson. </author> <title> Arc and Path Consistency Revisited. </title> <journal> Artificial Intelligence, </journal> <volume> 28 </volume> <pages> 225-233, </pages> <year> 1986. </year>
Reference-contexts: Note also that our implementation of cardinality enables to implement arc-consistency on arbitrary binary constraints within the optimal (time and space) bounds of the AC-4 algorithm <ref> [22] </ref>. 4.4 Constructive Disjunction Constructive disjunction in cc (FD) is implemented in terms of constraint solving in order to obtain an incremental behaviour. The key idea is to rename the variables in each disjunct independently 16 and to add the renamed disjuncts to the constraint store.
Reference: [23] <author> J.F. Muth and G.L. Thompson. </author> <title> Industrial Scheduling. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1963. </year>
Reference-contexts: In particular, we were able, using cc (FD), to find the optimal solution, and prove its optimality, to a famous 10/10 scheduling problem <ref> [23] </ref>, which was left open for more than 20 years and finally solved in 1988 [5]. <p> The cc (FD) program is about 440 lines long. Finally, it is interesting to point out that the cc (FD) program is able to solve optimally and prove optimality of a famous 10/10 job shop scheduling which was posed in 1963 <ref> [23] </ref> and left open for 25 years before being solved in [5]. The algorithm in [5] is very involved including relaxation techniques to preemptive scheduling. This problem requires about 90 hours of computation.
Reference: [24] <author> R.G. Parker and R.L. Rardin. </author> <title> Discrete Optimization. </title> <publisher> Academic Press, </publisher> <address> London (England), </address> <year> 1988. </year>
Reference-contexts: Subsumption constraints have been investigated previously by Parker <ref> [24] </ref> as a language extension. In cc (FD), they are only used inside the implementation since their directed nature is somewhat in contradiction with the multi-directional philosophy of constraint logic programming.
Reference: [25] <author> B.D. Parrello. </author> <title> CAR WARS: The (Almost) Birth of an Expert System. </title> <journal> AI Expert, </journal> <volume> 3(1) </volume> <pages> 60-64, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: The number of lines (which includes blank lines and comments) gives also an idea of the compactness of the programs which enables a short development time. Bridge is a disjunctive scheduling problem from [2], car is a car-sequencing problem <ref> [?, 25] </ref>, cutting is the numerical statement of a cutting-stock problem taken from [10], satel1, satel2 are two resource allocation problems with distance constraints, square is the perfect packing problem, hamilton is the Euler knight problem, donald, sendmory are two cryptarithmetic problems, queens8, queensall, queens96 are n-queens programs to find respectively
Reference: [26] <author> H.M. Salkin. </author> <title> On the Merit of the Generalized Origin and Restarts in Implicit Enumeration. </title> <journal> Opns. Res., </journal> <volume> 18 </volume> <pages> 549-554, </pages> <year> 1970. </year>
Reference-contexts: The restarting strategy may be of interest when heuristics are strongly influenced by the value of the best solution found so far <ref> [26] </ref>. The typical technique to solve optimization problems amounts to embedding the choice part in the higher-order predicate: 14 solve problem (. . .) :- create variables (. . .), state constraints (. . .), minof (make choice (. . .),Function,Res).
Reference: [27] <author> V.A. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1989. </year>
Reference-contexts: The CLP scheme was further generalized into the cc framework of concurrent constraint programming <ref> [27, 28, 29] </ref> to accommodate additional constraint operations (e.g. constraint entailment [21]) and new ways of combining them (e.g. implication or blocking ask [27] and cardinality [32]). CLP languages 1 support, in a declarative way, the solving of combinatorial search problems using the global search paradigm. <p> The CLP scheme was further generalized into the cc framework of concurrent constraint programming [27, 28, 29] to accommodate additional constraint operations (e.g. constraint entailment [21]) and new ways of combining them (e.g. implication or blocking ask <ref> [27] </ref> and cardinality [32]). CLP languages 1 support, in a declarative way, the solving of combinatorial search problems using the global search paradigm. The global search paradigm amounts to dividing recursively a problem into subproblems until the subproblems are simple enough to be solved in a straightforward way. <p> Operationally, the intention is that Min be greater than at least one of the X i that can be equal to Entry. 3.4 The Implication Combinator Motivation Blocking implication <ref> [21, 27, 15] </ref> is a combinator generalizing coroutining mechanisms in logic programming. The main idea behind coroutining mechanisms is to postpone execution of a goal until some conditions on its variables are satisfied. The main idea behind blocking implication is to use constraints for the conditions.
Reference: [28] <author> V.A. Saraswat and M. Rinard. </author> <title> Concurrent Constraint Programming. </title> <booktitle> In Proceedings of Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: The CLP scheme was further generalized into the cc framework of concurrent constraint programming <ref> [27, 28, 29] </ref> to accommodate additional constraint operations (e.g. constraint entailment [21]) and new ways of combining them (e.g. implication or blocking ask [27] and cardinality [32]). CLP languages 1 support, in a declarative way, the solving of combinatorial search problems using the global search paradigm.
Reference: [29] <author> V.A. Saraswat, M. Rinard, and P. Panangaden. </author> <title> Semantic Foundations of Concurrent Constraint Programming. </title> <booktitle> In Proceedings of Ninth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Orlando, FL, </address> <month> January </month> <year> 1991. </year> <month> 20 </month>
Reference-contexts: The CLP scheme was further generalized into the cc framework of concurrent constraint programming <ref> [27, 28, 29] </ref> to accommodate additional constraint operations (e.g. constraint entailment [21]) and new ways of combining them (e.g. implication or blocking ask [27] and cardinality [32]). CLP languages 1 support, in a declarative way, the solving of combinatorial search problems using the global search paradigm.
Reference: [30] <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. Logic Programming Series, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: The CLP scheme can be instantiated to produce a specific language by defining a constraint system (i.e. defining a set of primitive constraints and providing a constraint solver for the constraints). For instance, CHIP contains constraint systems over finite domains <ref> [30] </ref>, Booleans [3] and rational numbers [14, 35], Prolog III [9] is endowed with constraint 1 systems over Booleans, rational numbers, and lists, while CLP (&lt;) [17] solves constraints over real numbers. <p> CLP languages over finite domains (e.g. CHIP <ref> [13, 30] </ref>) have been applied to numerous discrete combinatorial problems, including graph coloring, cutting stock, microcode labeling, warehouse location, and car-sequencing. For many problems, they allow a short development time and an efficiency which compares well with procedural languages implementing the same approach. <p> donald, sendmory are two cryptarithmetic problems, queens8, queensall, queens96 are n-queens programs to find respectively the first solution to the 8-queens problem, all solutions to the 8-queens problem, and the first solution to the 96 queens problems. magic11, magic16, magic21 are various instances of the magic series problem taken from <ref> [32, 30] </ref> for sizes 11, 16, and 21. Table 2 compares cc (FD) with a specialized branch and bound algorithm written in C on a number of DSP problems [7, 19]. Both algorithms were run on the same machine.
Reference: [31] <author> P. Van Hentenryck. </author> <title> Scheduling and Packing in the Constraint Language cc(FD). </title> <type> Technical Report CS-92-43, </type> <institution> CS Department, Brown University, </institution> <year> 1992. </year>
Reference-contexts: The no-overlap constraint is an important part of the disjunctive scheduling programs reported in the experimental results. Example 13 [Communication Constraints] An interesting application of the cardinality combi-nator occurs in the Digital Signal Processing (DSP) application of <ref> [7, 31] </ref>, whose results are also reported in the experimental results. The purpose of the application is to allocate tasks to processors in an architecture combining pipeline processing and master-slave processing in order to minimize the total delay of the DSP application.
Reference: [32] <author> P. Van Hentenryck and Y. Deville. </author> <title> The Cardinality Operator: A New Logical Connective and Its Application to Constraint Logic Programming. </title> <booktitle> In Eighth International Conference on Logic Programming (ICLP-91), </booktitle> <address> Paris (France), </address> <month> June </month> <year> 1991. </year> <note> Also to appear in Constraint Logic Programming: </note> <editor> Selected Research, </editor> <publisher> The MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: The CLP scheme was further generalized into the cc framework of concurrent constraint programming [27, 28, 29] to accommodate additional constraint operations (e.g. constraint entailment [21]) and new ways of combining them (e.g. implication or blocking ask [27] and cardinality <ref> [32] </ref>). CLP languages 1 support, in a declarative way, the solving of combinatorial search problems using the global search paradigm. The global search paradigm amounts to dividing recursively a problem into subproblems until the subproblems are simple enough to be solved in a straightforward way. <p> The last case is handled by means of a simple rewriting rule <ref> [32] </ref>. Logical connectives (prefixed with #) can also be used freely in cc (FD) and are interpreted as abbreviations for cardinality formulas. <p> donald, sendmory are two cryptarithmetic problems, queens8, queensall, queens96 are n-queens programs to find respectively the first solution to the 8-queens problem, all solutions to the 8-queens problem, and the first solution to the 96 queens problems. magic11, magic16, magic21 are various instances of the magic series problem taken from <ref> [32, 30] </ref> for sizes 11, 16, and 21. Table 2 compares cc (FD) with a specialized branch and bound algorithm written in C on a number of DSP problems [7, 19]. Both algorithms were run on the same machine.
Reference: [33] <author> P. Van Hentenryck, Y. Deville, </author> <title> M.L. Chen, and C.M. Teng. New Results in Consistency of Networks. </title> <type> Technical report, </type> <institution> CS Department, Brown University, </institution> <year> 1992. </year> <month> Forthcoming. </month>
Reference-contexts: Interval consistency of non-binary monotonic constraints requires O (cdn 2 ) amortized where n is the number of variables in the largest constraints. An optimal algorithm of complexity O (cdn) exists <ref> [33] </ref> for linear constraints but our preliminary experimentations indicate that its overhead may reduce its interest.
Reference: [34] <author> P. Van Hentenryck, Y. Deville, </author> <title> and C.M. Teng. A Generic Arc Consistency Algorithm and its Specializations. </title> <booktitle> Artificial Intelligence, </booktitle> <pages> 57(2-3), </pages> <year> 1992. </year>
Reference-contexts: The key novelties in the implementation of cc (FD) (about 40,000 lines of C) are the inclusion of optimal consistency algorithms based on AC-5 <ref> [34] </ref>, dynamic specializations of data structures 1 In the following, we use the term CLP languages generically to denote both CLP and cc languages. 2 sizeMaster (112). sizeSquares ([50,42,37,35,33,29,27,25,24,19,18,17,16,15,11,9,8,7,6,4,2]). and constraints, and incremental algorithms for the combinators. <p> The specialization is performed at run-time in the present implementation but global flow analysis should allow us to move most of the work at compile-time in the next version of the system. 15 The constraint-solving algorithms are based on (non-binary) generalization of the AC-5 algo-rithm <ref> [34] </ref> using a breath-first strategy. In particular, domain-consistency of any combination of binary functional (e.g. X = 0 Y), anti-functional (e.g. X 6= 0 Y), monotonic (e.g. X &gt; 0 Y), and piecewise constraints (e.g. <p> X = 0 Y), anti-functional (e.g. X 6= 0 Y), monotonic (e.g. X &gt; 0 Y), and piecewise constraints (e.g. X = 0 Y mod 7), require O (cd) amortized time, where c is the number of constraints and d is the size of the largest domain <ref> [34] </ref>. Once again, the system (dynamically) compiles constraints differently depending on their properties.
Reference: [35] <author> P. Van Hentenryck and T. Graf. </author> <title> Standard Forms for Rational Linear Arithmetics in Constraint Logic Programming. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <pages> 5(2-4), </pages> <year> 1992. </year>
Reference-contexts: The CLP scheme can be instantiated to produce a specific language by defining a constraint system (i.e. defining a set of primitive constraints and providing a constraint solver for the constraints). For instance, CHIP contains constraint systems over finite domains [30], Booleans [3] and rational numbers <ref> [14, 35] </ref>, Prolog III [9] is endowed with constraint 1 systems over Booleans, rational numbers, and lists, while CLP (&lt;) [17] solves constraints over real numbers.

References-found: 35

