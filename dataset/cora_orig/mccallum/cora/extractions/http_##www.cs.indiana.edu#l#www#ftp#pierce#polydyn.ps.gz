URL: http://www.cs.indiana.edu/l/www/ftp/pierce/polydyn.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/
Root-URL: http://www.cs.indiana.edu
Title: Dynamic Typing in Polymorphic Languages  
Author: Martn Abadi Luca Cardelli Benjamin Pierce Didier Remy 
Affiliation: Systems Research Center Digital Equipment Corporation  LFCS University of Edinburgh  INRIA Rocquencourt  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Martn Abadi, Luca Cardelli, Benjamin Pierce, and Gordon Plotkin. </author> <title> Dynamic typing in a statically-typed language. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 237-268, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Hence, there are situations in programming where one would like to use dynamic types even in the presence of arbitrarily advanced type features. In this paper we investigate the interplay of dynamic typing with polymorphism. Our study extends earlier work (see <ref> [1] </ref>) in allowing polymorphism, but keeps the same basic language constructs (dynamic and typecase) and the same style. The interaction of polymorphism and dynamic types gives rise to problems in binding type variables. We find that these problems can be more clearly addressed in languages with explicit polymorphism. <p> The interaction of polymorphism and dynamic types gives rise to problems in binding type variables. We find that these problems can be more clearly addressed in languages with explicit polymorphism. Even then, we encounter some perplexing difficulties (as indicated in <ref> [1] </ref>). In particular, there is no unique way to match the type tagging a dynamic value with a typecase pattern. Our solution consists in constraining the syntax of typecase patterns, providing static guarantees of unique solutions. <p> Drawing from the experience with explicit polymor-phism, we consider languages with implicit polymor-phism in the ML style. The same ideas can be used, with some interesting twists. In particular, we are led to introduce tuple variables, which stand for tuples of type variables. In addition to <ref> [1] </ref>, several recent studies have considered languages with dynamic types [14, 17, 23]. The work most relevant to ours is that of Leroy and Mauny, who define and investigate two extensions of ML with dynamic types. We compare their designs to ours in section 6. <p> The work most relevant to ours is that of Leroy and Mauny, who define and investigate two extensions of ML with dynamic types. We compare their designs to ours in section 6. Section 2 is a brief review of dynamic typing in simply-typed languages, based on <ref> [1] </ref>. Section 3 considers the general case of adding dynamic typing to a language with higher-order polymorphism [11]. An algorithmic formulation of the general framework is obtained in section 3.5 by restricting polymorphism to the second order and placing conditions on the patters used in typecase expressions. <p> These constructs have surprising expressive power; for example, fixpoint operators can be defined at every type already in a simply typed lambda-calculus extended with Dynamic <ref> [1] </ref>. Important applications of dynamics include persistence and inter-address-space communication.
Reference: [2] <author> Graham M. Birtwistle, Ole-Johan Dahl, Bjorn Myhrhaug, and Kristen Nygaard. </author> <title> Simula Begin. </title> <institution> Studentlitteratur (Lund, Sweden), Bratt Institute Fuer Neues Lerned (Goch, FRG), Chartwell-Bratt Ltd (Kent, </institution> <address> England), </address> <year> 1979. </year>
Reference-contexts: Constructs analogous to dynamic and typecase have been provided in a number of languages, including Simula-67 <ref> [2] </ref>, CLU [18], Cedar/Mesa [16], Amber [3], Modula-2+ [22], Oberon [25], and Modula-3 [9]. These constructs have surprising expressive power; for example, fixpoint operators can be defined at every type already in a simply typed lambda-calculus extended with Dynamic [1]. Important applications of dynamics include persistence and inter-address-space communication.
Reference: [3] <author> Luca Cardelli. </author> <title> Amber. </title> <editor> In Guy Cousineau, Pierre-Louis Curien, and Bernard Robinet, editors, </editor> <booktitle> Com-binators and Functional Programming Languages. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <note> Lecture Notes in Computer Science No. 242. </note>
Reference-contexts: Constructs analogous to dynamic and typecase have been provided in a number of languages, including Simula-67 [2], CLU [18], Cedar/Mesa [16], Amber <ref> [3] </ref>, Modula-2+ [22], Oberon [25], and Modula-3 [9]. These constructs have surprising expressive power; for example, fixpoint operators can be defined at every type already in a simply typed lambda-calculus extended with Dynamic [1]. Important applications of dynamics include persistence and inter-address-space communication. <p> in b) 2 T (Open) In the body of b, we can build dynamic values with tags R or H; a typecase on the former could investigate the representation type while a typecase on the latter could not violate the type abstraction. 5 Subtyping In simple languages with subtyping (e.g., <ref> [3, 9] </ref>) it is natural to extend typecase to perform a subtyping test instead of an exact match. Consider for example: let dx = dynamic (3:Nat) in typecase dx of fg (x:Int) ... else ...
Reference: [4] <author> Luca Cardelli. </author> <title> Structural subtyping and the notion of power type. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 70-79, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: Therefore, we take a different approach that works in general and fits well with the language described in section 3.2. We intend to extend System F with sub-typing along the lines of [5]. In order to incorporate also the higher-order pattern variables, we resort to power-kinds <ref> [4] </ref>. <p> () is introduced by interpreting: AB : K as A : Power (K)(B); where A; B : K F G : (K!K 0 ) as F (X)G (X) : K 0 ; for all X : K, where F; G : (K!K 0 ) The axiomatization of Power (K)(T ) <ref> [4] </ref> is designed to induce the expected subtyping rules. For example, A : Power (A) says that AA. As in section 3.5, we limit kinds to appear only in patterns, although we may allow bounded quantifiers 8 (XT ) T 0 since they can be handled easily.
Reference: [5] <author> Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. </author> <title> An extension of system F with subtyping. </title> <editor> In T. Ito and A. R. Meyer, editors, </editor> <booktitle> Theoretical Aspects of Computer Software, number 526 in Lecture Notes in Computer Science, </booktitle> <pages> pages 750-770. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1991. </year>
Reference-contexts: Therefore, we take a different approach that works in general and fits well with the language described in section 3.2. We intend to extend System F with sub-typing along the lines of <ref> [5] </ref>. In order to incorporate also the higher-order pattern variables, we resort to power-kinds [4].
Reference: [6] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: Given a pattern V fiV , there may be a type AfiB such that A and B have no least upper bound, and so there may be no best instantiation for V. This can happen, for example, in a system with bounded quantifiers <ref> [6, 10] </ref>, and in systems where the collection of base types does not form an upper semi-lattice. Linear patterns (where each pattern variable occurs at most once) avoid these problems, but we find linearity too restrictive.
Reference: [7] <author> Gilles Dowek. </author> <title> A second order pattern matching algorithm in the cube of typed -calculi. </title> <booktitle> In Proceedings of Mathematical Foundation of Computer Science, volume 520 of Lecture Notes in Computer Science, </booktitle> <pages> pages 151-160. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year> <institution> Also Rapport de Recherche INRIA, </institution> <year> 1992. </year>
Reference-contexts: A related problem is that we have no algorithm for the run-time operation of matching patterns against tags. Indeed, it is not known whether the general case of higher-order matching is decidable. Even the second- and third-order cases, whose decid-ability has been established <ref> [15, 7, 8] </ref>, lead to algorithms too inefficient to be of practical use in implementing typecase. 4 3.5 Second-order polymorphism To obtain a practical language design, we need a restriction of our general treatment for which efficient typechecking and matching algorithms can be given.
Reference: [8] <author> Gilles Dowek. </author> <title> Third order matching is decidable. </title> <booktitle> In Proceedings of the Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1992. </year> <note> To appear. </note>
Reference-contexts: A related problem is that we have no algorithm for the run-time operation of matching patterns against tags. Indeed, it is not known whether the general case of higher-order matching is decidable. Even the second- and third-order cases, whose decid-ability has been established <ref> [15, 7, 8] </ref>, lead to algorithms too inefficient to be of practical use in implementing typecase. 4 3.5 Second-order polymorphism To obtain a practical language design, we need a restriction of our general treatment for which efficient typechecking and matching algorithms can be given.
Reference: [9] <author> Greg Nelson (ed.). </author> <title> Systems Programming in Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Constructs analogous to dynamic and typecase have been provided in a number of languages, including Simula-67 [2], CLU [18], Cedar/Mesa [16], Amber [3], Modula-2+ [22], Oberon [25], and Modula-3 <ref> [9] </ref>. These constructs have surprising expressive power; for example, fixpoint operators can be defined at every type already in a simply typed lambda-calculus extended with Dynamic [1]. Important applications of dynamics include persistence and inter-address-space communication. <p> in b) 2 T (Open) In the body of b, we can build dynamic values with tags R or H; a typecase on the former could investigate the representation type while a typecase on the latter could not violate the type abstraction. 5 Subtyping In simple languages with subtyping (e.g., <ref> [3, 9] </ref>) it is natural to extend typecase to perform a subtyping test instead of an exact match. Consider for example: let dx = dynamic (3:Nat) in typecase dx of fg (x:Int) ... else ...
Reference: [10] <author> Giorgio Ghelli. </author> <title> Proof Theoretic Studies about a Minimal Type System Integrating Inclusion and Parametric Polymorphism. </title> <type> PhD thesis, </type> <institution> Universita di Pisa, </institution> <month> March </month> <year> 1990. </year> <type> Technical report TD-6/90, </type> <institution> Dipartimento di Informatica, Universita di Pisa. </institution>
Reference-contexts: Given a pattern V fiV , there may be a type AfiB such that A and B have no least upper bound, and so there may be no best instantiation for V. This can happen, for example, in a system with bounded quantifiers <ref> [6, 10] </ref>, and in systems where the collection of base types does not form an upper semi-lattice. Linear patterns (where each pattern variable occurs at most once) avoid these problems, but we find linearity too restrictive.
Reference: [11] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: We compare their designs to ours in section 6. Section 2 is a brief review of dynamic typing in simply-typed languages, based on [1]. Section 3 considers the general case of adding dynamic typing to a language with higher-order polymorphism <ref> [11] </ref>. An algorithmic formulation of the general framework is obtained in section 3.5 by restricting polymorphism to the second order and placing conditions on the patters used in typecase expressions. Sections 4 and 5 discuss abstract data types and subtyping, respectively. <p> and attempts to construct a Dynamic containing their functional composition: dynCompose = (df:Dynamic) (dg:Dynamic) typecase df of fU,Vg (f:U!V) typecase dg of fTg (g:T!U) dynamic (fffig:T!V) else ... else ... 3 Explicit Polymorphism This formulation of dynamic types may be carried over almost unchanged to languages based on explicit poly-morphism <ref> [11, 21] </ref>. For example, the following function checks that its argument df contains a polymorphic function f taking elements of any type into Int. <p> G =fl (X)Xg Tag: Int Pattern: F (W ) (which reduces to W ) Result: fW = Intg and the result of the application dynApply2 (df )(da) is dynamic (id [Int](3) : Int). 3.2 Syntax We now formalize dynamic types within the context of a higher-order polymorphic -calculus, F ! <ref> [11] </ref>. The syntax of F ! with type Dynamic is given in Figure 1. In examples we also use base types, cartesian products, and labeled records in types and patterns, but we omit these in the formal treatment.
Reference: [12] <author> Mike Gordon. </author> <title> Adding Eval to ML. </title> <type> Personal communication, </type> <month> circa </month> <year> 1980. </year>
Reference-contexts: Important applications of dynamics include persistence and inter-address-space communication. For example, the following primitives provide input and output of a dynamic value from and to a stream: extern 2 WriterfiDynamic!Unit intern 2 Reader!Dynamic Moreover, dynamics can be used to give a type for an eval primitive <ref> [12, 20] </ref>: eval 2 Exp!Dynamic We obtain a much more expressive system by allowing typecase guards to contain pattern variables.
Reference: [13] <author> Robert Harper, Robin Milner, and Mads Tofte. </author> <title> Commentary of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In the context of ML, our definiteness requirement is reminiscent of the type-explication restriction imposed on signatures in Standard ML (see section 7.7 of <ref> [13] </ref>). Pattern variables are bound at the beginning of the typecase, and their scope is the typecase in which they have been introduced. All other free variables are bound at the beginning of the pattern and their scope is the pattern.
Reference: [14] <author> Fritz Henglein. </author> <title> Dynamic typing. </title> <booktitle> In ESOP, </booktitle> <year> 1992. </year>
Reference-contexts: The same ideas can be used, with some interesting twists. In particular, we are led to introduce tuple variables, which stand for tuples of type variables. In addition to [1], several recent studies have considered languages with dynamic types <ref> [14, 17, 23] </ref>. The work most relevant to ours is that of Leroy and Mauny, who define and investigate two extensions of ML with dynamic types. We compare their designs to ours in section 6. Section 2 is a brief review of dynamic typing in simply-typed languages, based on [1].
Reference: [15] <author> Gerard Huet and Bernard Lang. </author> <title> Proving and applying program transformations expressed with second-order patterns. </title> <journal> Acta Informatica, </journal> <volume> 11 </volume> <pages> 31-55, </pages> <year> 1978. </year>
Reference-contexts: A related problem is that we have no algorithm for the run-time operation of matching patterns against tags. Indeed, it is not known whether the general case of higher-order matching is decidable. Even the second- and third-order cases, whose decid-ability has been established <ref> [15, 7, 8] </ref>, lead to algorithms too inefficient to be of practical use in implementing typecase. 4 3.5 Second-order polymorphism To obtain a practical language design, we need a restriction of our general treatment for which efficient typechecking and matching algorithms can be given.
Reference: [16] <author> Butler Lampson. </author> <title> A description of the Cedar language. </title> <type> Technical Report CSL-83-15, </type> <institution> Xerox Palo Alto Research Center, </institution> <year> 1983. </year>
Reference-contexts: Constructs analogous to dynamic and typecase have been provided in a number of languages, including Simula-67 [2], CLU [18], Cedar/Mesa <ref> [16] </ref>, Amber [3], Modula-2+ [22], Oberon [25], and Modula-3 [9]. These constructs have surprising expressive power; for example, fixpoint operators can be defined at every type already in a simply typed lambda-calculus extended with Dynamic [1]. Important applications of dynamics include persistence and inter-address-space communication.
Reference: [17] <author> Xavier Leroy and Michel Mauny. </author> <title> Dynamics in ML. </title> <booktitle> In Proceedings of the ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <year> 1991. </year>
Reference-contexts: The same ideas can be used, with some interesting twists. In particular, we are led to introduce tuple variables, which stand for tuples of type variables. In addition to [1], several recent studies have considered languages with dynamic types <ref> [14, 17, 23] </ref>. The work most relevant to ours is that of Leroy and Mauny, who define and investigate two extensions of ML with dynamic types. We compare their designs to ours in section 6. Section 2 is a brief review of dynamic typing in simply-typed languages, based on [1]. <p> That is, in ML, the typecase would be expected to succeed if an instance of the tag matches the pattern. This principle is called tag instantiation. Dynamics with tag instanti-ation but no pattern variables have been implemented in the language CAML [24]. The dynamics studied by Leroy and Mauny <ref> [17] </ref> have tag instantiation and first-order pattern variables. First-order pattern variables are not powerful enough to type some reasonable examples, such as the applyTwice function shown later. <p> The unique tuple variable that appears in all the t j can be bound to the tuple (ff k ), and its size bound to the tuple sort. 6.4 Related work The work on dynamics most closely related to ours is that of Leroy and Mauny <ref> [17] </ref>. Our system can be seen as an extension of their system with "mixed quantification." Instead of introducing a typecase statement, Leroy and Mauny merge dynamic elimination with the usual case statement of ML.
Reference: [18] <author> B. Liskov, R. Atkinson, T. Bloom, E. Moss, J.C. Schaffert, R. Scheifler, and A. Snyder. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Constructs analogous to dynamic and typecase have been provided in a number of languages, including Simula-67 [2], CLU <ref> [18] </ref>, Cedar/Mesa [16], Amber [3], Modula-2+ [22], Oberon [25], and Modula-3 [9]. These constructs have surprising expressive power; for example, fixpoint operators can be defined at every type already in a simply typed lambda-calculus extended with Dynamic [1]. Important applications of dynamics include persistence and inter-address-space communication.
Reference: [19] <author> John Mitchell and Gordon Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3), </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: For example, a program may create disk files containing dynamic values, which should remain usable even after the program is recompiled, or two programs on different machines may want to exchange abstract data in the form of dynamically typed values. By viewing abstract types formally as existential types <ref> [19] </ref>, we can see exactly where the difference between these two solutions lies and suggest a generalization of existential types that supports both. (Existential types can in turn be coded using universal types; with this coding, our design for dynamic types of the previous sections yields the second solution.) To add
Reference: [20] <author> Alan Mycroft. </author> <title> Dynamic types in ML. </title> <type> Draft article, </type> <year> 1983. </year>
Reference-contexts: Important applications of dynamics include persistence and inter-address-space communication. For example, the following primitives provide input and output of a dynamic value from and to a stream: extern 2 WriterfiDynamic!Unit intern 2 Reader!Dynamic Moreover, dynamics can be used to give a type for an eval primitive <ref> [12, 20] </ref>: eval 2 Exp!Dynamic We obtain a much more expressive system by allowing typecase guards to contain pattern variables.
Reference: [21] <author> John Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proc. Colloque sur la Programmation, </booktitle> <pages> pages 408-425, </pages> <address> New York, </address> <year> 1974. </year> <note> Springer-Verlag Lecture Notes in Computer Science 19. </note>
Reference-contexts: and attempts to construct a Dynamic containing their functional composition: dynCompose = (df:Dynamic) (dg:Dynamic) typecase df of fU,Vg (f:U!V) typecase dg of fTg (g:T!U) dynamic (fffig:T!V) else ... else ... 3 Explicit Polymorphism This formulation of dynamic types may be carried over almost unchanged to languages based on explicit poly-morphism <ref> [11, 21] </ref>. For example, the following function checks that its argument df contains a polymorphic function f taking elements of any type into Int.
Reference: [22] <author> Paul Rovner. </author> <title> On extending Modula-2 to build large, integrated systems. </title> <journal> IEEE Software, </journal> <volume> 3(6) </volume> <pages> 46-57, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Constructs analogous to dynamic and typecase have been provided in a number of languages, including Simula-67 [2], CLU [18], Cedar/Mesa [16], Amber [3], Modula-2+ <ref> [22] </ref>, Oberon [25], and Modula-3 [9]. These constructs have surprising expressive power; for example, fixpoint operators can be defined at every type already in a simply typed lambda-calculus extended with Dynamic [1]. Important applications of dynamics include persistence and inter-address-space communication.
Reference: [23] <author> Satish R. Thatte. </author> <title> Quasi-static typing (preliminary report). </title> <booktitle> In Proceedings of the Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 367-381, </pages> <year> 1990. </year>
Reference-contexts: The same ideas can be used, with some interesting twists. In particular, we are led to introduce tuple variables, which stand for tuples of type variables. In addition to [1], several recent studies have considered languages with dynamic types <ref> [14, 17, 23] </ref>. The work most relevant to ours is that of Leroy and Mauny, who define and investigate two extensions of ML with dynamic types. We compare their designs to ours in section 6. Section 2 is a brief review of dynamic typing in simply-typed languages, based on [1].
Reference: [24] <author> Pierre Weis, Maria-Virginia Aponte, Alain Laville, Michel Mauny, and Ascander Suarez. </author> <title> The CAML reference manual. </title> <type> Research report 121, </type> <institution> INRIA, Rocquencourt, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: That is, in ML, the typecase would be expected to succeed if an instance of the tag matches the pattern. This principle is called tag instantiation. Dynamics with tag instanti-ation but no pattern variables have been implemented in the language CAML <ref> [24] </ref>. The dynamics studied by Leroy and Mauny [17] have tag instantiation and first-order pattern variables. First-order pattern variables are not powerful enough to type some reasonable examples, such as the applyTwice function shown later.
Reference: [25] <author> Niklaus Wirth. </author> <title> From Modula to Oberon and the programming language Oberon. </title> <type> Technical Report 82, </type> <institution> Institut fur Informatik, ETH, </institution> <address> Zurich, </address> <year> 1987. </year>
Reference-contexts: Constructs analogous to dynamic and typecase have been provided in a number of languages, including Simula-67 [2], CLU [18], Cedar/Mesa [16], Amber [3], Modula-2+ [22], Oberon <ref> [25] </ref>, and Modula-3 [9]. These constructs have surprising expressive power; for example, fixpoint operators can be defined at every type already in a simply typed lambda-calculus extended with Dynamic [1]. Important applications of dynamics include persistence and inter-address-space communication.
References-found: 25

