URL: http://www.cs.berkeley.edu/~aiken/cs264/papers/oo-type-inference.ps.Z
Refering-URL: http://www.cs.berkeley.edu/~aiken/cs264/papers/node9.html
Root-URL: 
Email: palsberg@daimi.aau.dk and mis@daimi.aau.dk  
Title: Object-Oriented Type Inference  
Author: Jens Palsberg and Michael I. Schwartzbach 
Address: Ny Munkegade, DK-8000 -Arhus C, Denmark  
Affiliation: Computer Science Department, Aarhus University  
Abstract: We present a new approach to inferring types in un-typed object-oriented programs with inheritance, assignments, and late binding. It guarantees that all messages are understood, annotates the program with type information, allows polymorphic methods, and can be used as the basis of an optimizing compiler. Types are finite sets of classes and subtyping is set inclusion. Using a trace graph, our algorithm constructs a set of conditional type constraints and computes the least solution by least fixed-point derivation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alan H. Borning and Daniel H. H. Ingalls. </author> <title> A type declaration and inference system for Smalltalk. </title> <booktitle> In Ninth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 133-141. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1982. </year>
Reference-contexts: This makes the algorithm capable of checking most common programs; in particular, it allows for polymorphic methods. The algorithm is similar to previous work on type inference <ref> [18, 14, 27, 1, 2, 19, 12, 10, 9] </ref> in using type constraints, but it differs in handling late binding by conditional constraints and in resolving the constraints by least fixed-point derivation rather than unification. The example language resembles Smalltalk [8] but avoids metaclasses, blocks, and primitive methods.
Reference: [2] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In Gilles Kahn, David MacQueen, and Gordon Plotkin, editors, </editor> <booktitle> Semantics of Data Types, </booktitle> <pages> pages 51-68. </pages> <publisher> Springer-Verlag (LNCS 173), </publisher> <year> 1984. </year>
Reference-contexts: This makes the algorithm capable of checking most common programs; in particular, it allows for polymorphic methods. The algorithm is similar to previous work on type inference <ref> [18, 14, 27, 1, 2, 19, 12, 10, 9] </ref> in using type constraints, but it differs in handling late binding by conditional constraints and in resolving the constraints by least fixed-point derivation rather than unification. The example language resembles Smalltalk [8] but avoids metaclasses, blocks, and primitive methods.
Reference: [3] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: An induced type is a subtype of any sound approximation; subtyp-ing is set inclusion. Note also that our notion of type, which we also investigated in [20], differs from those usually used in theoretical studies of types in object-oriented programming <ref> [3, 7] </ref>; these theories have difficulties with late binding and assignments. The goals of type inference can now be phrased as follows.
Reference: [4] <author> William Cook and Jens Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <journal> Information and Computation. </journal> <note> To appear. Also in Proc. </note> <editor> OOPSLA'89, </editor> <booktitle> ACM SIGPLAN Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 433-443, </pages> <address> New Orleans, Louisiana, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: We sketch a proof by induction in the number of message sends performed during the trace. If this is zero, then we rely on the local constraints alone; given a dynamic semantics <ref> [4, 5, 23, 13] </ref> one can easily verify that their satisfaction implies the above property. If we extend a trace with a message send X m: A implemented by a method in a class C, then we can inductively assume that C 2 L ([[X]]).
Reference: [5] <author> William R. Cook. </author> <title> A Denotational Semantics of Inheritance. </title> <type> PhD thesis, </type> <institution> Brown University, </institution> <year> 1989. </year>
Reference-contexts: We sketch a proof by induction in the number of message sends performed during the trace. If this is zero, then we rely on the local constraints alone; given a dynamic semantics <ref> [4, 5, 23, 13] </ref> one can easily verify that their satisfaction implies the above property. If we extend a trace with a message send X m: A implemented by a method in a class C, then we can inductively assume that C 2 L ([[X]]).
Reference: [6] <author> Ole-Johan Dahl, Bjtrn Myhrhaug, and Kristen Ny-gaard. </author> <title> Simula 67 common base language. </title> <type> Technical report, </type> <institution> Norwegian Computing Center, Oslo, Norway, </institution> <year> 1968. </year>
Reference: [7] <author> Scott Danforth and Chris Tomlinson. </author> <title> Type theories and object-oriented programming. </title> <journal> ACM Computing Surveys, </journal> <volume> 20(1) </volume> <pages> 29-72, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: An induced type is a subtype of any sound approximation; subtyp-ing is set inclusion. Note also that our notion of type, which we also investigated in [20], differs from those usually used in theoretical studies of types in object-oriented programming <ref> [3, 7] </ref>; these theories have difficulties with late binding and assignments. The goals of type inference can now be phrased as follows.
Reference: [8] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80|The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: The example language resembles Smalltalk <ref> [8] </ref> but avoids metaclasses, blocks, and primitive methods. Instead, it provides explicit new and if-then-else expressions; classes like Natural can be programmed in the language itself. In the following section we discuss the impacts of late binding on type inference and examine previous work.
Reference: [9] <author> Justin O. Graver and Ralph E. Johnson. </author> <title> A type system for Smalltalk. </title> <booktitle> In Seventeenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 136-150. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: Late binding, however, can cause programs to be unreliable, unreadable, and inefficient [27]. Type inference may help solve these problems, but so far no proposed inference algorithm has been capable of checking most common, completely untyped programs <ref> [9] </ref>. We present a new type inference algorithm for a basic object-oriented language with inheritance, as To appear in proceedings of the ACM Conference on Object-Oriented Programming: Systems, Languages, and Applications (OOPSLA) October 6-11, 1991. c fl1991 ACM. Copied by permission. signments, and late binding. <p> This makes the algorithm capable of checking most common programs; in particular, it allows for polymorphic methods. The algorithm is similar to previous work on type inference <ref> [18, 14, 27, 1, 2, 19, 12, 10, 9] </ref> in using type constraints, but it differs in handling late binding by conditional constraints and in resolving the constraints by least fixed-point derivation rather than unification. The example language resembles Smalltalk [8] but avoids metaclasses, blocks, and primitive methods. <p> Typed object-oriented languages such as Simula [6]/Beta [15], C++ [26], and Eiffel [17] allow separate compilation but sacrifice flexibility. The relations between types and implementation are summarized in figure 1. When programs are: Their implementation is: Untyped Interpretation Typable Compilation Typed Separate Compilation Graver and Johnson <ref> [10, 9] </ref>, in their type system for Smalltalk, take an intermediate approach between "untyped" and "typed" in requiring the programmer to specify types for instance variables whereas types of arguments are inferred. <p> This idea of expansion is inspired by Graver and Johnson <ref> [10, 9] </ref>; note that the size of the expanded program is at most quadratic in the size of the original. The second and third observation lead to a finite representation of type information about all executions of the expanded program; this representation is called the trace graph. <p> Each different node employs unique type variables, except that the types of instance variables are common to all nodes corresponding to methods imple mented in the same class. A similar idea is used by Graver and Johnson <ref> [10, 9] </ref>. 4.3 Trace Graph Edges The edges of the trace graph will reflect the possible connections between a message send and a method that may implement it. The situation is illustrated in figure 6.
Reference: [10] <author> Justin Owen Graver. </author> <title> Type-Checking and Type-Inference for Object-Oriented Programming Languages. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illi-nois at Urbana-Champaign, </institution> <month> August </month> <year> 1989. </year> <month> UIUCD-R-89-1539. </month>
Reference-contexts: This makes the algorithm capable of checking most common programs; in particular, it allows for polymorphic methods. The algorithm is similar to previous work on type inference <ref> [18, 14, 27, 1, 2, 19, 12, 10, 9] </ref> in using type constraints, but it differs in handling late binding by conditional constraints and in resolving the constraints by least fixed-point derivation rather than unification. The example language resembles Smalltalk [8] but avoids metaclasses, blocks, and primitive methods. <p> Typed object-oriented languages such as Simula [6]/Beta [15], C++ [26], and Eiffel [17] allow separate compilation but sacrifice flexibility. The relations between types and implementation are summarized in figure 1. When programs are: Their implementation is: Untyped Interpretation Typable Compilation Typed Separate Compilation Graver and Johnson <ref> [10, 9] </ref>, in their type system for Smalltalk, take an intermediate approach between "untyped" and "typed" in requiring the programmer to specify types for instance variables whereas types of arguments are inferred. <p> This idea of expansion is inspired by Graver and Johnson <ref> [10, 9] </ref>; note that the size of the expanded program is at most quadratic in the size of the original. The second and third observation lead to a finite representation of type information about all executions of the expanded program; this representation is called the trace graph. <p> Each different node employs unique type variables, except that the types of instance variables are common to all nodes corresponding to methods imple mented in the same class. A similar idea is used by Graver and Johnson <ref> [10, 9] </ref>. 4.3 Trace Graph Edges The edges of the trace graph will reflect the possible connections between a message send and a method that may implement it. The situation is illustrated in figure 6.
Reference: [11] <author> Andreas V. Hense. </author> <title> Polymorphic type inference for a simple object oriented programming language with state. </title> <type> Technical Report No. </type> <institution> A 20/90, Fachbericht 14, Universitat des Saarlandes, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: Both these approaches include a notion of method type. Our new type inference algorithm abandons this idea and uses instead the concept of conditional constraints, derived from a finite graph. Recently, Hense <ref> [11] </ref> addressed type inference for a language O'Small which is almost identical to our example language. He uses a radically different technique, with type schemes and unification based on work of Remy [24] and Wand [29]. <p> The program texts are listed together with the corresponding constraints and their least solution, if it exists. Hense's program in figure 11 is the one he gives as a typical example of what he cannot type-check <ref> [11] </ref>. We invite the reader to consult the appendix while reading this section. A trace graph contains three kinds of type information. Three kinds of type information: Local constraints: Generated from method bodies; contained in nodes. Connecting constraints: Reflect message sends; attached to edges. Conditions: Discriminate receivers; attached to edges. <p> In figures 14 and 15 we present two program fragments that are typical for what we cannot type because of these approximations. In both cases the constraints demand the false inclusion fTrueg fNaturalg. Suzuki [27] and Hense <ref> [11] </ref> make the same approximations. For an expression E, the local constraints are generated from all the phrases in its derivation, according to the rules in figure 5. The idea of generating constraints on type variables from the program syntax is also exploited in [28, 25].
Reference: [12] <author> Ralph E. Johnson. </author> <title> Type-checking Smalltalk. </title> <booktitle> In Proc. OOPSLA'86, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 315-321. </pages> <booktitle> Sigplan Notices, </booktitle> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: This makes the algorithm capable of checking most common programs; in particular, it allows for polymorphic methods. The algorithm is similar to previous work on type inference <ref> [18, 14, 27, 1, 2, 19, 12, 10, 9] </ref> in using type constraints, but it differs in handling late binding by conditional constraints and in resolving the constraints by least fixed-point derivation rather than unification. The example language resembles Smalltalk [8] but avoids metaclasses, blocks, and primitive methods.
Reference: [13] <author> Samuel Kamin. </author> <title> Inheritance in Smalltalk-80: A denota-tional definition. </title> <booktitle> In Fifteenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 80-87. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1988. </year>
Reference-contexts: We sketch a proof by induction in the number of message sends performed during the trace. If this is zero, then we rely on the local constraints alone; given a dynamic semantics <ref> [4, 5, 23, 13] </ref> one can easily verify that their satisfaction implies the above property. If we extend a trace with a message send X m: A implemented by a method in a class C, then we can inductively assume that C 2 L ([[X]]).
Reference: [14] <author> Marc A. Kaplan and Jeffrey D. Ullman. </author> <title> A general scheme for the automatic inference of variable types. </title> <booktitle> In Fifth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 60-75. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1978. </year>
Reference-contexts: This makes the algorithm capable of checking most common programs; in particular, it allows for polymorphic methods. The algorithm is similar to previous work on type inference <ref> [18, 14, 27, 1, 2, 19, 12, 10, 9] </ref> in using type constraints, but it differs in handling late binding by conditional constraints and in resolving the constraints by least fixed-point derivation rather than unification. The example language resembles Smalltalk [8] but avoids metaclasses, blocks, and primitive methods.
Reference: [15] <author> Bent B. Kristensen, Ole Lehrmann Madsen, Birger Mtller-Pedersen, and Kristen Nygaard. </author> <title> The BETA programming language. </title> <editor> In Bruce Shriver and Peter Weg-ner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 7-48. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Our type inference algorithm can be used as the basis of such an optimizing compiler. Note, though, that both the safety guarantee and the induced types are sensitive to small changes in the program. Hence, separate compilation of classes seems impossible. Typed object-oriented languages such as Simula [6]/Beta <ref> [15] </ref>, C++ [26], and Eiffel [17] allow separate compilation but sacrifice flexibility. The relations between types and implementation are summarized in figure 1.
Reference: [16] <author> Harry G. Mairson. </author> <title> Decidability of ML typing is complete for deterministic exponential time. </title> <booktitle> In Seventeenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 382-401. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: Note that this situation is similar to that of type inference in ML, which is also worst-case exponential but very useful in practice. The above scenario is in fact not unlike the one presented in <ref> [16] </ref> to illustrate exponential running times in ML.
Reference: [17] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: Note, though, that both the safety guarantee and the induced types are sensitive to small changes in the program. Hence, separate compilation of classes seems impossible. Typed object-oriented languages such as Simula [6]/Beta [15], C++ [26], and Eiffel <ref> [17] </ref> allow separate compilation but sacrifice flexibility. The relations between types and implementation are summarized in figure 1.
Reference: [18] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: This makes the algorithm capable of checking most common programs; in particular, it allows for polymorphic methods. The algorithm is similar to previous work on type inference <ref> [18, 14, 27, 1, 2, 19, 12, 10, 9] </ref> in using type constraints, but it differs in handling late binding by conditional constraints and in resolving the constraints by least fixed-point derivation rather than unification. The example language resembles Smalltalk [8] but avoids metaclasses, blocks, and primitive methods.
Reference: [19] <author> Prateek Mishra and Uday S. Reddy. </author> <title> Declaration-free type checking. </title> <booktitle> In Twelfth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 7-21. </pages> <publisher> ACM Press, </publisher> <month> Jan-uary </month> <year> 1985. </year>
Reference-contexts: This makes the algorithm capable of checking most common programs; in particular, it allows for polymorphic methods. The algorithm is similar to previous work on type inference <ref> [18, 14, 27, 1, 2, 19, 12, 10, 9] </ref> in using type constraints, but it differs in handling late binding by conditional constraints and in resolving the constraints by least fixed-point derivation rather than unification. The example language resembles Smalltalk [8] but avoids metaclasses, blocks, and primitive methods.
Reference: [20] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Static typing for object-oriented programming. </title> <journal> Science of Computer Programming. </journal> <note> To appear. </note>
Reference-contexts: Since induced types are generally uncomputable, a compiler must make do with sound approximations. An induced type is a subtype of any sound approximation; subtyp-ing is set inclusion. Note also that our notion of type, which we also investigated in <ref> [20] </ref>, differs from those usually used in theoretical studies of types in object-oriented programming [3, 7]; these theories have difficulties with late binding and assignments. The goals of type inference can now be phrased as follows. <p> Another challenge is to extend the algorithm to produce type annotations together with type substitution, see <ref> [21, 22, 20] </ref>.
Reference: [21] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Type substitution for object-oriented programming. </title> <booktitle> In Proc. OOPSLA/ECOOP'90, ACM SIGPLAN Fifth Annual Conference on Object-Oriented Programming Systems, Languages and Applications; European Conference on Object-Oriented Programming, </booktitle> <pages> pages 151-160, </pages> <address> Ottawa, Canada, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: Another challenge is to extend the algorithm to produce type annotations together with type substitution, see <ref> [21, 22, 20] </ref>.
Reference: [22] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> What is type-safe code reuse? In Proc. </title> <booktitle> ECOOP'91, Fifth Eu-ropean Conference on Object-Oriented Programming, </booktitle> <pages> pages 325-341. </pages> <publisher> Springer-Verlag (LNCS 512), </publisher> <address> Geneva, Switzerland, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Another challenge is to extend the algorithm to produce type annotations together with type substitution, see <ref> [21, 22, 20] </ref>.
Reference: [23] <author> Uday S. Reddy. </author> <title> Objects as closures: Abstract semantics of object-oriented languages. </title> <booktitle> In Proc. ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 289-297, </pages> <year> 1988. </year>
Reference-contexts: We sketch a proof by induction in the number of message sends performed during the trace. If this is zero, then we rely on the local constraints alone; given a dynamic semantics <ref> [4, 5, 23, 13] </ref> one can easily verify that their satisfaction implies the above property. If we extend a trace with a message send X m: A implemented by a method in a class C, then we can inductively assume that C 2 L ([[X]]).
Reference: [24] <author> Didier Remy. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> In Sixteenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 77-88. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1989. </year>
Reference-contexts: Recently, Hense [11] addressed type inference for a language O'Small which is almost identical to our example language. He uses a radically different technique, with type schemes and unification based on work of Remy <ref> [24] </ref> and Wand [29]. His paper lists four programs of which his algorithm can type-check only the first three. Our algorithm can type-check all four, in particular the fourth which is shown in figure 11 in appendix B. Hense uses record types which can be extendible and recursive.
Reference: [25] <author> Michael I. Schwartzbach. </author> <title> Type inference with inequalities. </title> <booktitle> In Proc. TAPSOFT'91, </booktitle> <pages> pages 441-455. </pages> <publisher> Springer-Verlag (LNCS 493), </publisher> <year> 1991. </year>
Reference-contexts: Suzuki [27] and Hense [11] make the same approximations. For an expression E, the local constraints are generated from all the phrases in its derivation, according to the rules in figure 5. The idea of generating constraints on type variables from the program syntax is also exploited in <ref> [28, 25] </ref>. The constraints guarantee safety; only in the cases 4) and 8) do the approximations manifest themselves.
Reference: [26] <author> Bjarne Stroustrup. </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Note, though, that both the safety guarantee and the induced types are sensitive to small changes in the program. Hence, separate compilation of classes seems impossible. Typed object-oriented languages such as Simula [6]/Beta [15], C++ <ref> [26] </ref>, and Eiffel [17] allow separate compilation but sacrifice flexibility. The relations between types and implementation are summarized in figure 1.
Reference: [27] <author> Norihisa Suzuki. </author> <title> Inferring types in Smalltalk. </title> <booktitle> In Eighth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 187-199. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1981. </year>
Reference-contexts: 1 Introduction Untyped object-oriented languages with assignments and late binding allow rapid prototyping because classes inherit implementation and not specification. Late binding, however, can cause programs to be unreliable, unreadable, and inefficient <ref> [27] </ref>. Type inference may help solve these problems, but so far no proposed inference algorithm has been capable of checking most common, completely untyped programs [9]. <p> This makes the algorithm capable of checking most common programs; in particular, it allows for polymorphic methods. The algorithm is similar to previous work on type inference <ref> [18, 14, 27, 1, 2, 19, 12, 10, 9] </ref> in using type constraints, but it differs in handling late binding by conditional constraints and in resolving the constraints by least fixed-point derivation rather than unification. The example language resembles Smalltalk [8] but avoids metaclasses, blocks, and primitive methods. <p> When programs are: Their implementation is: Untyped Interpretation Typable Compilation Typed Separate Compilation Graver and Johnson [10, 9], in their type system for Smalltalk, take an intermediate approach between "untyped" and "typed" in requiring the programmer to specify types for instance variables whereas types of arguments are inferred. Suzuki <ref> [27] </ref>, in his pioneering work on inferring types in Smalltalk, handles late binding by assuming that each message send may invoke all methods for that message. It turned out, however, that this yields an algorithm which is not capable of checking most common programs. <p> In figures 14 and 15 we present two program fragments that are typical for what we cannot type because of these approximations. In both cases the constraints demand the false inclusion fTrueg fNaturalg. Suzuki <ref> [27] </ref> and Hense [11] make the same approximations. For an expression E, the local constraints are generated from all the phrases in its derivation, according to the rules in figure 5. The idea of generating constraints on type variables from the program syntax is also exploited in [28, 25].
Reference: [28] <author> Mitchell Wand. </author> <title> A simple algorithm and proof for type inference. </title> <journal> Fundamentae Informaticae, </journal> <volume> X:115-122, </volume> <year> 1987. </year>
Reference-contexts: Suzuki [27] and Hense [11] make the same approximations. For an expression E, the local constraints are generated from all the phrases in its derivation, according to the rules in figure 5. The idea of generating constraints on type variables from the program syntax is also exploited in <ref> [28, 25] </ref>. The constraints guarantee safety; only in the cases 4) and 8) do the approximations manifest themselves.
Reference: [29] <author> Mitchell Wand. </author> <title> Type inference for record concatenation and multiple inheritance. </title> <booktitle> In LICS'89, Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 92-97, </pages> <year> 1989. </year>
Reference-contexts: Recently, Hense [11] addressed type inference for a language O'Small which is almost identical to our example language. He uses a radically different technique, with type schemes and unification based on work of Remy [24] and Wand <ref> [29] </ref>. His paper lists four programs of which his algorithm can type-check only the first three. Our algorithm can type-check all four, in particular the fourth which is shown in figure 11 in appendix B. Hense uses record types which can be extendible and recursive.
References-found: 29

