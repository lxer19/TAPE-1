URL: http://www.cs.tamu.edu/faculty/vaidya/papers/fault-tolerance/95-050.ps.Z
Refering-URL: http://www.cs.tamu.edu/faculty/vaidya/Vaidya-ftc.html
Root-URL: http://www.cs.tamu.edu
Email: akella@ece.ucdavis.edu  vaidya@cs.tamu.edu  redinbo@ece.ucdavis.edu  
Phone: Phone: 916-752-9810 Fax: 916-752-8428  Phone: 409-845-0512 Fax: 409-847-8578  Phone: 916-752-3087 Fax: 916-752-8428  
Title: Limitations of VLSI Implementation of Delay-Insensitive Codes  
Author: Venkatesh Akella Nitin H. Vaidya Robert Redinbo 
Address: Davis, CA 95616  College Station, TX 77843-3112  Davis, CA 95616  Texas A&M University  
Affiliation: ECE Department University of California  Computer Science Dept. Texas A&M University  ECE Department University of California  Department of Computer Science  
Abstract: Technical Report 95-050 December 1995 Abstract Implementation of delay-insensitive (DI) or unordered codes is the subject of this report. We present two different architectures for decoding systematic DI codes: (a) enumeration-based decoder, and (b) comparison-based decoder. We argue that enumeration-based decoders are often impractical for many realistic codes. Comparison-based decoders that detect arrival of a code word by comparing the received checkbits with checkbits evaluated using the received data are practical but suffer from the following limitation. If the decoder is to be implemented using asynchronous logic, i.e., if the gate and wire delays are arbitrary (unbounded but finite), then it is impossible to design a comparison-based decoder for any code that is more efficient than a dual-rail code. In other words, the encoded word must contain at least twice as many bits as the data. The report shows that comparison-based decoders for codes that have the requisite level of redundancy can be implemented using asynchronous logic. The report also shows that, by relaxing the delay assumptions, it is possible to implement decoders for delay-insensitive codes that are more efficient than dual-rail codes. fl Research reported is supported in part by National Science Foundation Grants MIP-930868 (at UC-Davis) and MIP-9423735 (at Texas A&M University). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Berger, J. M. </author> <title> A Note on Error Detection Codes for Asymmetric Channels. </title> <booktitle> Information and Control 4 (1961), </booktitle> <pages> 68-73. </pages>
Reference-contexts: Finally, we present some practical constraints on circuit delays under which comparison-based decoders could be implemented for codes with smaller redundancy than dual-rail codes. We illustrate this with the implementation of a Berger code <ref> [1] </ref>. The report is organized as follows. Section 2 discusses our system model. Section 3 discusses the various decoder architectures and their implementation details. Section 4 shows that codes that are not as redundant as dual-rail codes cannot be implemented. <p> The decoder must be hazard-free, otherwise, it may indicate that a code word has been received when the received word, in fact, is not a code word. Consider the (4,2) Berger code <ref> [1] </ref> with 2 data bits (k=2) and 2 checkbits (r=2). The four code words in the (4,2) Berger code are: d1 d0 c1 c0 1 1 0 0 1 0 0 1 where (d1,d0) are the data bits and (c1,c0) are the checkbits.
Reference: [2] <author> Blaum, M., Ed. </author> <title> Codes for Detecting and Correcting Unidirectional Errors. </title> <publisher> IEEE Computer Society, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction In the past, significant effort has been spent in designing efficient codes for detection and correction of unidirectional and asymmetric errors <ref> [2] </ref>. Application of such codes to asynchronous buses has also been explored [3, 14, 5, 4, 17]. An asynchronous bus consists of wires whose transmission delays are unpredictable. <p> While we focus on asynchronous communication as the application of unordered [6] or delay-insensitive codes, the results of this report have implications for all applications of such codes. This report deals with design of asynchronous decoders for codes used for communication on asynchronous buses. Past work on decoders <ref> [2] </ref> implicitly assumes synchronous hardware implementation of the decoder. As noted above, unordered codes have been proposed for two types of problems: (i) detection of arrival of data on the asynchronous bus, (ii) detection and correction of various types of errors on the asynchronous bus. <p> When an unordered code is used, arrival of a code word can be unambiguously recognized by the receiver, in presence of arbitrary delays in the 1 wires. It is easy to see that one-hot and dual-rail (double-rail) codes enjoy this property [17]. Verhoeff [17], Varshavsky [16] and Blaum <ref> [2] </ref> discuss examples of other DI codes, e.g., Sperner codes and Berger codes among others and describe their mathematical properties. VLSI implementation of decoders for systematic unordered (or DI) codes is the subject of this report.
Reference: [3] <author> Blaum, M., and Bruck, J. </author> <title> Unordered error-correcting codes and their applications. </title> <booktitle> In Digest of papers: The 22 th Int. Symp. Fault-Tolerant Comp. </booktitle> <month> (July </month> <year> 1992), </year> <pages> pp. 486-493. </pages>
Reference-contexts: 1 Introduction In the past, significant effort has been spent in designing efficient codes for detection and correction of unidirectional and asymmetric errors [2]. Application of such codes to asynchronous buses has also been explored <ref> [3, 14, 5, 4, 17] </ref>. An asynchronous bus consists of wires whose transmission delays are unpredictable. <p> Some codes for correcting different types of errors and skews on asynchronous buses have also been proposed (e.g., <ref> [3] </ref>). However, the past work has not explored the issues in VLSI implementations of decoders for the proposed codes. While we focus on asynchronous communication as the application of unordered [6] or delay-insensitive codes, the results of this report have implications for all applications of such codes. <p> This implies that, implementation of asynchronous decoders for unidirectional error correcting codes is likely to be very hard. The codes that are useful for detecting arrival of data on an asynchronous bus are said to be unordered <ref> [6, 3, 5] </ref> or delay-insensitive [17]. Mathematically, one can formalize unordered or delay-insensitive (DI) codes as follows. Consider a binary code C.
Reference: [4] <author> Blaum, M., and Bruck, J. </author> <title> Coding for Skew-Tolerant Parallel Asynchronous Communications. </title> <journal> IEEE Transactions on Information Theory 39, </journal> <month> 2 (March </month> <year> 1993), </year> <pages> 379-388. </pages>
Reference-contexts: 1 Introduction In the past, significant effort has been spent in designing efficient codes for detection and correction of unidirectional and asymmetric errors [2]. Application of such codes to asynchronous buses has also been explored <ref> [3, 14, 5, 4, 17] </ref>. An asynchronous bus consists of wires whose transmission delays are unpredictable. <p> Our model is very simple and does not include the idea of pipelined data communication that was proposed by Blaum and Bruck <ref> [4, 5] </ref>. 3 Decoder Architectures Assume that the code being used is an (n; k) systematic unordered code. Thus, each code word contains k data bits, and r = n k checkbits.
Reference: [5] <author> Blaum, M., and Bruck, J. </author> <title> Delay-Insensitive Pipelined Communication on Parallel Buses. </title> <journal> IEEE Transactions on Computers 44, </journal> <month> 5 (May </month> <year> 1995), </year> <pages> 660-668. </pages>
Reference-contexts: 1 Introduction In the past, significant effort has been spent in designing efficient codes for detection and correction of unidirectional and asymmetric errors [2]. Application of such codes to asynchronous buses has also been explored <ref> [3, 14, 5, 4, 17] </ref>. An asynchronous bus consists of wires whose transmission delays are unpredictable. <p> This implies that, implementation of asynchronous decoders for unidirectional error correcting codes is likely to be very hard. The codes that are useful for detecting arrival of data on an asynchronous bus are said to be unordered <ref> [6, 3, 5] </ref> or delay-insensitive [17]. Mathematically, one can formalize unordered or delay-insensitive (DI) codes as follows. Consider a binary code C. <p> Our model is very simple and does not include the idea of pipelined data communication that was proposed by Blaum and Bruck <ref> [4, 5] </ref>. 3 Decoder Architectures Assume that the code being used is an (n; k) systematic unordered code. Thus, each code word contains k data bits, and r = n k checkbits.
Reference: [6] <author> Bose, B. </author> <title> On Unordered Codes. </title> <journal> IEEE Transactions on Computers 40 (February 1991), </journal> <pages> 125-131. </pages>
Reference-contexts: Some codes for correcting different types of errors and skews on asynchronous buses have also been proposed (e.g., [3]). However, the past work has not explored the issues in VLSI implementations of decoders for the proposed codes. While we focus on asynchronous communication as the application of unordered <ref> [6] </ref> or delay-insensitive codes, the results of this report have implications for all applications of such codes. This report deals with design of asynchronous decoders for codes used for communication on asynchronous buses. Past work on decoders [2] implicitly assumes synchronous hardware implementation of the decoder. <p> This implies that, implementation of asynchronous decoders for unidirectional error correcting codes is likely to be very hard. The codes that are useful for detecting arrival of data on an asynchronous bus are said to be unordered <ref> [6, 3, 5] </ref> or delay-insensitive [17]. Mathematically, one can formalize unordered or delay-insensitive (DI) codes as follows. Consider a binary code C.
Reference: [7] <author> Eichelberger, E. B. </author> <title> Hazard Detection in Combinational and Sequential Switching Circuits. </title> <journal> IBM Journal of Research, </journal> <month> 9 (mar </month> <year> 1965), </year> <pages> 90-99. 19 </pages>
Reference-contexts: of the decoder that produces a 1 on receiving a code word and a 0 otherwise would result in glitches (hazards) at the output of the decoder due to unpredictable order of the arrival of the bits and the distribution of delays in the gates and wires inside the decoder <ref> [7, 15] </ref>. This is not acceptable because we expect the decoder output to go to 1 only if we receive a code word. However, we can take advantage of the four-phase protocol to implement the circuit in a hazard-free manner as follows.
Reference: [8] <author> Kohavi, Z. </author> <title> Switching and Finite Automata Theory. </title> <publisher> Tata McGraw-Hill, </publisher> <year> 1978. </year> <note> Chapter 4 and Chapter 6. </note>
Reference-contexts: positive and unate in all the variables: A function g (x 1 ; x 2 ; : : : ; x n ) is said to be unate with respect to a variable x i if only x i or its complement x i appears in g but not both <ref> [8] </ref>. A function g is said to be positive with respect to a variable x i if only the literal x i appears in g. (2) f is hazard-free for all the allowable transitions under the four-phase protocol that is being used in this discussion. <p> of only AND and OR gates, and the output of an AND gate remains at zero till all its inputs are 1 all inputs of an AND gate become 1 only when the corresponding code word is received. (3) It can be shown that the minimal sum-of-products expression is unique <ref> [8] </ref> which means that all the prime-implicants are essential. So, f is the minimal hazard-free sum-of products (SOP) realization of the enumeration-based decoder for (4,2) Berger code. Therefore, f cannot be minimized any further in terms of a two-level logic implementation.
Reference: [9] <author> Martin, A. J. </author> <title> The Limitations to Delay-insensitivity in Asynchronous Circuits. </title> <booktitle> In Advanced Research in VLSI : Proceedings of the Sixth MIT Conference. </booktitle> <publisher> MIT Press, </publisher> <month> Mar. </month> <year> 1990. </year>
Reference-contexts: and d 0 are data bits and c 1 and c 0 are checkbits. d 1 d 0 c 1 c 0 0 1 1 0 1 1 0 0 It follows that, c 1 = d 1 and c 0 = d 0 . 15 denotes a Muller C-element <ref> [10, 9] </ref>. It is a special latch which has the following behavior. <p> An interesting problem is to determine the lower bounds on the redundancy in the unordered (or DI) codes to implement comparison-based decoders with quasi-delay-insensitive (QDI) assumption <ref> [12, 9, 13] </ref> and the speed-independent circuit theory [11]. Acknowledgements We thank Janlung Sung for discussions during the early part of this research.
Reference: [10] <author> Mead, C. A., and Conway, L. </author> <title> An Introduction to VLSI Systems. </title> <publisher> Addison Wesley, </publisher> <year> 1980. </year> <note> Chapter 7, entitled "System Timing". </note>
Reference-contexts: VLSI implementation of decoders for systematic unordered (or DI) codes is the subject of this report. We first describe a communication protocol called the four-phase protocol <ref> [10] </ref> for the exchange of data on an asynchronous bus. Then we define two possible architectures for the decoders. The first is called enumeration-based decoder which examines the entire code word and determines if it is valid or not. It basically implements the membership-test using combinational logic. <p> Data communication in an asynchronous system is accomplished by a handshake protocol <ref> [10] </ref>. There are two popular handshake protocols. The four-phase (or return-to-zero) protocol and the two-phase (or non-return-to-zero) protocol. We will use the four-phase handshake protocol in this study. <p> The dual-rail code is commonly used in asynchronous systems, and for this code k = r. Our design is very similar to the implementations found in asynchronous literature <ref> [10, 12] </ref>. Without loss of generality, let us assume that the number of data bits is 2. Therefore, r = k = 2. <p> and d 0 are data bits and c 1 and c 0 are checkbits. d 1 d 0 c 1 c 0 0 1 1 0 1 1 0 0 It follows that, c 1 = d 1 and c 0 = d 0 . 15 denotes a Muller C-element <ref> [10, 9] </ref>. It is a special latch which has the following behavior.
Reference: [11] <author> Miller, R. E. </author> <title> Switching Theory Volume II: Sequential Circuits and Machines. </title> <publisher> John Wiley & Sons, </publisher> <year> 1965. </year> <title> Chapter 10: Speed Independent Switching Circuit Theory. </title>
Reference-contexts: An interesting problem is to determine the lower bounds on the redundancy in the unordered (or DI) codes to implement comparison-based decoders with quasi-delay-insensitive (QDI) assumption [12, 9, 13] and the speed-independent circuit theory <ref> [11] </ref>. Acknowledgements We thank Janlung Sung for discussions during the early part of this research.
Reference: [12] <author> Nanya, T., Ueno, Y., Kayotomi, H., Kuwako, M., and Takamura, A. TITAC: </author> <title> Design of a Quasi-Delay-Insensitive Microprocessor. </title> <booktitle> IEEE Design and Test of Computers 11, </booktitle> <month> 2 (June </month> <year> 1994), </year> <pages> 50-63. </pages>
Reference-contexts: The dual-rail code is commonly used in asynchronous systems, and for this code k = r. Our design is very similar to the implementations found in asynchronous literature <ref> [10, 12] </ref>. Without loss of generality, let us assume that the number of data bits is 2. Therefore, r = k = 2. <p> An interesting problem is to determine the lower bounds on the redundancy in the unordered (or DI) codes to implement comparison-based decoders with quasi-delay-insensitive (QDI) assumption <ref> [12, 9, 13] </ref> and the speed-independent circuit theory [11]. Acknowledgements We thank Janlung Sung for discussions during the early part of this research.
Reference: [13] <author> Piestrak, S. J., and Nanya, T. </author> <title> Towards totally self-checking delay-insensitive systems. </title> <booktitle> In Digest of papers: The 25 th Int. Symp. Fault-Tolerant Comp. </booktitle> <year> (1995), </year> <pages> pp. 228-237. </pages>
Reference-contexts: An interesting problem is to determine the lower bounds on the redundancy in the unordered (or DI) codes to implement comparison-based decoders with quasi-delay-insensitive (QDI) assumption <ref> [12, 9, 13] </ref> and the speed-independent circuit theory [11]. Acknowledgements We thank Janlung Sung for discussions during the early part of this research.
Reference: [14] <author> Tallini, L., Merani, L., and Bose, B. </author> <title> Balanced codes for noise reductionin VLSI systems. </title> <booktitle> In Digest of papers: The 24 th Int. Symp. Fault-Tolerant Comp. </booktitle> <month> (June </month> <year> 1994), </year> <pages> pp. 212-218. </pages>
Reference-contexts: 1 Introduction In the past, significant effort has been spent in designing efficient codes for detection and correction of unidirectional and asymmetric errors [2]. Application of such codes to asynchronous buses has also been explored <ref> [3, 14, 5, 4, 17] </ref>. An asynchronous bus consists of wires whose transmission delays are unpredictable.
Reference: [15] <author> Unger, S. H. </author> <title> Asynchronous Sequential Switching Circuits. </title> <publisher> Wiley-Interscience, </publisher> <address> New York, </address> <year> 1969. </year>
Reference-contexts: of the decoder that produces a 1 on receiving a code word and a 0 otherwise would result in glitches (hazards) at the output of the decoder due to unpredictable order of the arrival of the bits and the distribution of delays in the gates and wires inside the decoder <ref> [7, 15] </ref>. This is not acceptable because we expect the decoder output to go to 1 only if we receive a code word. However, we can take advantage of the four-phase protocol to implement the circuit in a hazard-free manner as follows.
Reference: [16] <author> Varshavsky, V., Kishnivsky, M., Markhovsky, V., Peschansky, V., Rosen-blum, L., Taubin, A., and Tzirlin, B. </author> <title> Self-Timed Control of Concurrent Processes. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Dordrecht, The Netherlands, </address> <year> 1990. </year>
Reference-contexts: When an unordered code is used, arrival of a code word can be unambiguously recognized by the receiver, in presence of arbitrary delays in the 1 wires. It is easy to see that one-hot and dual-rail (double-rail) codes enjoy this property [17]. Verhoeff [17], Varshavsky <ref> [16] </ref> and Blaum [2] discuss examples of other DI codes, e.g., Sperner codes and Berger codes among others and describe their mathematical properties. VLSI implementation of decoders for systematic unordered (or DI) codes is the subject of this report.
Reference: [17] <author> Verhoeff, T. </author> <title> Delay-insensitive codes an overview. </title> <booktitle> Distributed Computing, 3 (1988), </booktitle> <pages> 1-8. </pages>
Reference-contexts: 1 Introduction In the past, significant effort has been spent in designing efficient codes for detection and correction of unidirectional and asymmetric errors [2]. Application of such codes to asynchronous buses has also been explored <ref> [3, 14, 5, 4, 17] </ref>. An asynchronous bus consists of wires whose transmission delays are unpredictable. <p> An asynchronous bus consists of wires whose transmission delays are unpredictable. The problem of detecting the arrival of information on such a bus has been shown to be equivalent to the problem of designing unordered or all unidirectional error detecting (AUED) codes <ref> [17] </ref> such codes are also useful for unidirectional and asymmetric error control. Some codes for correcting different types of errors and skews on asynchronous buses have also been proposed (e.g., [3]). However, the past work has not explored the issues in VLSI implementations of decoders for the proposed codes. <p> This implies that, implementation of asynchronous decoders for unidirectional error correcting codes is likely to be very hard. The codes that are useful for detecting arrival of data on an asynchronous bus are said to be unordered [6, 3, 5] or delay-insensitive <ref> [17] </ref>. Mathematically, one can formalize unordered or delay-insensitive (DI) codes as follows. Consider a binary code C. A code word u 2 C is said to be contained in a code word v 2 C, if v has a 1 in each position where u has a 1. <p> When an unordered code is used, arrival of a code word can be unambiguously recognized by the receiver, in presence of arbitrary delays in the 1 wires. It is easy to see that one-hot and dual-rail (double-rail) codes enjoy this property <ref> [17] </ref>. Verhoeff [17], Varshavsky [16] and Blaum [2] discuss examples of other DI codes, e.g., Sperner codes and Berger codes among others and describe their mathematical properties. VLSI implementation of decoders for systematic unordered (or DI) codes is the subject of this report. <p> When an unordered code is used, arrival of a code word can be unambiguously recognized by the receiver, in presence of arbitrary delays in the 1 wires. It is easy to see that one-hot and dual-rail (double-rail) codes enjoy this property <ref> [17] </ref>. Verhoeff [17], Varshavsky [16] and Blaum [2] discuss examples of other DI codes, e.g., Sperner codes and Berger codes among others and describe their mathematical properties. VLSI implementation of decoders for systematic unordered (or DI) codes is the subject of this report. <p> At the start of the four phase protocol, the initial values are ack = 0 and B = (000...0). All-0 bus, B = (000...0), is known as the spacer <ref> [17] </ref>. The four-phase protocol has the following four steps (hence the name). 3 (1) Block S (sender) encodes the data and transmits the code word on the asynchronous bus B.
References-found: 17

