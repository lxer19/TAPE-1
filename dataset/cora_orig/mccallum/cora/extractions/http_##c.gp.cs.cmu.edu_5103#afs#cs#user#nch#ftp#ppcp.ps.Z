URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/nch/ftp/ppcp.ps.Z
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/nch/www/sba.html
Root-URL: http://www.cs.cmu.edu
Title: Set Constraints and Set-Based Analysis  
Author: Nevin Heintze and Joxan Jaffar 
Date: May 1994  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Aiken and E. Wimmers, </author> <title> "Solving Systems of Set Constraints", </title> <booktitle> Proc. 7 th IEEE Symp. on Logic in Computer Science, </booktitle> <address> Santa Cruz, </address> <pages> pp. 329-340, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: This procedure further provides an explicit representation of the least model of a (satisfiable) collection of definite set constraints. [17] also posed decidability of the satisfiability problem for general set constraints as an open question. Later, <ref> [1] </ref> proved the decidability of a different, and incomparable, class: the positive set constraints. These are defined simply to be set constraints not involving projection. This procedure reduces the constraints into a simpler form. When reduction terminates without detecting inconsistency, the resulting constraints are evidently satisfiable. <p> Constructing constraints as before yields: W 2 W 1 Y 2 Y 1 X 3 X 2 W 4 cons (X 3 ; Y 3 ) X 4 X 3 Now, suppose that at the start of the program, the variable W is either the list <ref> [1; 2] </ref> or the list [3; 4]. Then the set for X 2 (and X 3 ) is f1; 3g, and the set for Y 3 is f [2]; [4]g. Hence, the set for W 4 is f [1; 2]; [3; 4]; [1; 4]; [3; 2]g. <p> the start of the program, the variable W is either the list <ref> [1; 2] </ref> or the list [3; 4]. Then the set for X 2 (and X 3 ) is f1; 3g, and the set for Y 3 is f [2]; [4]g. Hence, the set for W 4 is f [1; 2]; [3; 4]; [1; 4]; [3; 2]g. In contrast, the only possible values for W after execution of the third statement are [1; 2] and [3; 4]. <p> Then the set for X 2 (and X 3 ) is f1; 3g, and the set for Y 3 is f [2]; [4]g. Hence, the set for W 4 is f [1; 2]; [3; 4]; <ref> [1; 4] </ref>; [3; 2]g. In contrast, the only possible values for W after execution of the third statement are [1; 2] and [3; 4]. The key property of the constraints constructed from a program is that any solution of the constraints conservatively approximates the operational semantics of the program. <p> Hence, the set for W 4 is f <ref> [1; 2] </ref>; [3; 4]; [1; 4]; [3; 2]g. In contrast, the only possible values for W after execution of the third statement are [1; 2] and [3; 4]. The key property of the constraints constructed from a program is that any solution of the constraints conservatively approximates the operational semantics of the program.
Reference: [2] <author> A. Aiken and E. Wimmers, </author> <title> "Type Inclusion Constraints and Type Inference", </title> <booktitle> Proc. 1993 Conf. on Functional Programming and Computer Architecture, Copenhagen, </booktitle> <pages> pp. 31-41, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: One presentational difference in these works is the use of various extensions of regular grammars instead of constraints. 5 Subsequently, a number of set constraint approaches have been developed for the analysis of higher-order functional languages (see, for example, <ref> [27, 12, 2, 3, 13] </ref>). Perhaps the most developed of these approaches are those by [12, 13] and [2, 3]. The former starts with an operational semantics, and develops a set-based analysis for this semantics. The constraints that arise are briefly sketched in Section 3.3. <p> Perhaps the most developed of these approaches are those by [12, 13] and <ref> [2, 3] </ref>. The former starts with an operational semantics, and develops a set-based analysis for this semantics. The constraints that arise are briefly sketched in Section 3.3. <p> Constructing constraints as before yields: W 2 W 1 Y 2 Y 1 X 3 X 2 W 4 cons (X 3 ; Y 3 ) X 4 X 3 Now, suppose that at the start of the program, the variable W is either the list <ref> [1; 2] </ref> or the list [3; 4]. Then the set for X 2 (and X 3 ) is f1; 3g, and the set for Y 3 is f [2]; [4]g. Hence, the set for W 4 is f [1; 2]; [3; 4]; [1; 4]; [3; 2]g. <p> Then the set for X 2 (and X 3 ) is f1; 3g, and the set for Y 3 is f <ref> [2] </ref>; [4]g. Hence, the set for W 4 is f [1; 2]; [3; 4]; [1; 4]; [3; 2]g. In contrast, the only possible values for W after execution of the third statement are [1; 2] and [3; 4]. <p> the start of the program, the variable W is either the list <ref> [1; 2] </ref> or the list [3; 4]. Then the set for X 2 (and X 3 ) is f1; 3g, and the set for Y 3 is f [2]; [4]g. Hence, the set for W 4 is f [1; 2]; [3; 4]; [1; 4]; [3; 2]g. In contrast, the only possible values for W after execution of the third statement are [1; 2] and [3; 4]. <p> Then the set for X 2 (and X 3 ) is f1; 3g, and the set for Y 3 is f [2]; [4]g. Hence, the set for W 4 is f [1; 2]; [3; 4]; [1; 4]; <ref> [3; 2] </ref>g. In contrast, the only possible values for W after execution of the third statement are [1; 2] and [3; 4]. The key property of the constraints constructed from a program is that any solution of the constraints conservatively approximates the operational semantics of the program. <p> Hence, the set for W 4 is f <ref> [1; 2] </ref>; [3; 4]; [1; 4]; [3; 2]g. In contrast, the only possible values for W after execution of the third statement are [1; 2] and [3; 4]. The key property of the constraints constructed from a program is that any solution of the constraints conservatively approximates the operational semantics of the program.
Reference: [3] <author> A. Aiken, E. Wimmers and T.K. Lakshman, </author> <title> "Soft Typing with Conditional Types" Proc. </title> <booktitle> 21 st ACM Symp. on Principles of Programming Languages, </booktitle> <address> Portland, OR, </address> <pages> pp. 163-173, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: One presentational difference in these works is the use of various extensions of regular grammars instead of constraints. 5 Subsequently, a number of set constraint approaches have been developed for the analysis of higher-order functional languages (see, for example, <ref> [27, 12, 2, 3, 13] </ref>). Perhaps the most developed of these approaches are those by [12, 13] and [2, 3]. The former starts with an operational semantics, and develops a set-based analysis for this semantics. The constraints that arise are briefly sketched in Section 3.3. <p> Perhaps the most developed of these approaches are those by [12, 13] and <ref> [2, 3] </ref>. The former starts with an operational semantics, and develops a set-based analysis for this semantics. The constraints that arise are briefly sketched in Section 3.3. <p> We note that both works include a mechanism for reasoning about non-emptiness of sets (these are called "conditional types" in <ref> [3] </ref>). Sorted Unification Broadly, sorted unification is the problem of unifying two terms in the context of a sort theory, the latter imposing constraints on the values that certain variables can take. <p> constraints as before yields: W 2 W 1 Y 2 Y 1 X 3 X 2 W 4 cons (X 3 ; Y 3 ) X 4 X 3 Now, suppose that at the start of the program, the variable W is either the list [1; 2] or the list <ref> [3; 4] </ref>. Then the set for X 2 (and X 3 ) is f1; 3g, and the set for Y 3 is f [2]; [4]g. Hence, the set for W 4 is f [1; 2]; [3; 4]; [1; 4]; [3; 2]g. <p> of the program, the variable W is either the list [1; 2] or the list <ref> [3; 4] </ref>. Then the set for X 2 (and X 3 ) is f1; 3g, and the set for Y 3 is f [2]; [4]g. Hence, the set for W 4 is f [1; 2]; [3; 4]; [1; 4]; [3; 2]g. In contrast, the only possible values for W after execution of the third statement are [1; 2] and [3; 4]. <p> Then the set for X 2 (and X 3 ) is f1; 3g, and the set for Y 3 is f [2]; [4]g. Hence, the set for W 4 is f [1; 2]; [3; 4]; [1; 4]; <ref> [3; 2] </ref>g. In contrast, the only possible values for W after execution of the third statement are [1; 2] and [3; 4]. The key property of the constraints constructed from a program is that any solution of the constraints conservatively approximates the operational semantics of the program. <p> Hence, the set for W 4 is f [1; 2]; <ref> [3; 4] </ref>; [1; 4]; [3; 2]g. In contrast, the only possible values for W after execution of the third statement are [1; 2] and [3; 4]. The key property of the constraints constructed from a program is that any solution of the constraints conservatively approximates the operational semantics of the program. This means that to obtain a safe approximation of the program, it is sufficient to construct a solution to the constraints.
Reference: [4] <author> A. Aiken, D. Kozen and E. Wimmers, </author> <title> "Decidability of Systems of Set Constraints with Negative Constraints", </title> <type> IBM Research Report RJ 9421, </type> <year> 1993. </year>
Reference-contexts: The next step was taken by [10], who proved that negative set constraints, ie. the extension to positve constraints with negations of subset relationships such as se 1 6 se 2 , remains decidable. Once again, tree automata techniques were used here. An alternative procedure was then given by <ref> [4] </ref>, by reduction to a number-theoretic decision problem. Subsequently, [6] used the abovementioned translation of set constraints to the monadic class to provide a straightforward procedure for deciding negative set constraints. Note that none of these works on negative constraints deal with projections. <p> constraints as before yields: W 2 W 1 Y 2 Y 1 X 3 X 2 W 4 cons (X 3 ; Y 3 ) X 4 X 3 Now, suppose that at the start of the program, the variable W is either the list [1; 2] or the list <ref> [3; 4] </ref>. Then the set for X 2 (and X 3 ) is f1; 3g, and the set for Y 3 is f [2]; [4]g. Hence, the set for W 4 is f [1; 2]; [3; 4]; [1; 4]; [3; 2]g. <p> of the program, the variable W is either the list [1; 2] or the list <ref> [3; 4] </ref>. Then the set for X 2 (and X 3 ) is f1; 3g, and the set for Y 3 is f [2]; [4]g. Hence, the set for W 4 is f [1; 2]; [3; 4]; [1; 4]; [3; 2]g. In contrast, the only possible values for W after execution of the third statement are [1; 2] and [3; 4]. <p> Then the set for X 2 (and X 3 ) is f1; 3g, and the set for Y 3 is f [2]; [4]g. Hence, the set for W 4 is f [1; 2]; [3; 4]; <ref> [1; 4] </ref>; [3; 2]g. In contrast, the only possible values for W after execution of the third statement are [1; 2] and [3; 4]. The key property of the constraints constructed from a program is that any solution of the constraints conservatively approximates the operational semantics of the program. <p> Hence, the set for W 4 is f [1; 2]; <ref> [3; 4] </ref>; [1; 4]; [3; 2]g. In contrast, the only possible values for W after execution of the third statement are [1; 2] and [3; 4]. The key property of the constraints constructed from a program is that any solution of the constraints conservatively approximates the operational semantics of the program. This means that to obtain a safe approximation of the program, it is sufficient to construct a solution to the constraints.
Reference: [5] <author> L. Bachmair, H. Ganzinger and U. Waldmann, </author> <title> "Set Constraints are the Monadic Class", </title> <booktitle> Proc. 8 th IEEE Symp. on Logic in Computer Science, </booktitle> <pages> 75-83, </pages> <year> 1993. </year>
Reference-contexts: They further showed that satisfiable positive constraints always have a regular solution (all variables are assigned a regular set), and a minimal and maximal regular solution. While the class of definite constraints and the class of positive classes are not comparable, 3 the work <ref> [5] </ref> proved decidability of a class subsuming the two. Briefly, the set constraints considered here are the positive ones, extended to allow projections in a restricted way.
Reference: [6] <author> W. Charatonik and L. Pacholski, </author> <title> "Negative Set Constraints: an Easy Proof of Decidability", </title> <booktitle> Proc. 9 th IEEE Symp. on Logic in Computer Science, </booktitle> <year> 1994, </year> <note> to appear. </note>
Reference-contexts: Once again, tree automata techniques were used here. An alternative procedure was then given by [4], by reduction to a number-theoretic decision problem. Subsequently, <ref> [6] </ref> used the abovementioned translation of set constraints to the monadic class to provide a straightforward procedure for deciding negative set constraints. Note that none of these works on negative constraints deal with projections. <p> The main question remains how to deal with (unrestricted) projection. At the time of writing, we have verbal communication [26] indicating that the proof in <ref> [6] </ref> can be extended to solve this problem. Thus the question of whether the general set constraint problem is open, now becomes open! 2.3 Applications Early works Two important early works are by Jones and Muchnick [22] and Reynolds [29].
Reference: [7] <author> P. Cousot and R. Cousot, </author> <title> "Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints", </title> <booktitle> Proc. 4 th ACM Symp. on Principles of Programming Languages, </booktitle> <address> Los Angeles, </address> <pages> pp. 238-252, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: This basic formulation of constraints has been extended to deal with arrays, continuations and exceptions. 3.4 Comparison with Other Analysis Techniques A key advantage of set-based analysis (and, more generally, the use of set constraints to perform program analysis), in comparison to standard abstract interpretation techniques <ref> [7] </ref>, is that there is no underlying abstract domain. When using an abstract domain, the requirement of "finite ascending chains" is typically required for termination, and this limits the usable abstract domains. A remedy is to use techniques of "narrowing" and "widening".
Reference: [8] <author> J. Gallagher and D.A. de Wall, </author> <title> "Fast and Precise Regular Approximations of Logic Programs", </title> <booktitle> Proc. International Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <month> to appear </month> <year> 1994. </year>
Reference-contexts: In [16], a more accurate operator t P was used. (Roughly, Y P ignores inter-argument dependencies, while t P ignores only inter-variable dependencies.) A more recent work <ref> [8] </ref> used the closure operators (in conjunction with another approximation technique called widening) to define and compute a program approximation. The relationship between these closure-based fixpoint operators and set constraints was described in [18].
Reference: [9] <author> R. Gilleron, S. Tison and M. Tommasi, </author> <title> "Solving Systems of Set Constraints using Tree Automata", </title> <booktitle> Proc. 10 th Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pp. 505-514, </pages> <year> 1992. </year>
Reference-contexts: These are defined simply to be set constraints not involving projection. This procedure reduces the constraints into a simpler form. When reduction terminates without detecting inconsistency, the resulting constraints are evidently satisfiable. Note that satisfiable positive set constraints do not always have a least model. Subsequently, <ref> [9] </ref> provided an alternative procedure using tree automata techniques. Starting with Rabin's result [28] that the theory of k-successors is decidable, they generalized the Rabin automaton to ac-comodate positive set constraints.
Reference: [10] <author> R. Gilleron, S. Tison and M. Tommasi, </author> <title> "Solving Systems of Set Constraints with Negated Subset Relationships", </title> <booktitle> in Foundations of Computer Science, </booktitle> <pages> 372-380, </pages> <year> 1993. </year>
Reference-contexts: The transformation is simple and elegant, and gave rise to complexity results on set constraints based on similar results in the monadic class. The next step was taken by <ref> [10] </ref>, who proved that negative set constraints, ie. the extension to positve constraints with negations of subset relationships such as se 1 6 se 2 , remains decidable. Once again, tree automata techniques were used here.
Reference: [11] <author> N. Heintze, </author> <title> "Practical Aspects of Set-Based Analysis", </title> <booktitle> Proc. Joint International Conf. and Symp. on Logic Programming, </booktitle> <address> Washington D.C., </address> <publisher> MIT Press, </publisher> <pages> pp. 765-779, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Moreover, the technology for implementing set constraints is still in its infancy. With this in mind, we now briefly describe results from implementations of set-based analysis for two different languages. The first deals with analysis of logic programs <ref> [11] </ref>, and computes type, mode and sharing information. This analysis has a worst case exponential complexity. While substantial progress was made during the development of this implementation, the results indicate that we are still some distance from practical analysis of medium to large programs.
Reference: [12] <author> N. Heintze, </author> <title> "Set-Based Program Analysis", </title> <type> Ph.D. thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: One presentational difference in these works is the use of various extensions of regular grammars instead of constraints. 5 Subsequently, a number of set constraint approaches have been developed for the analysis of higher-order functional languages (see, for example, <ref> [27, 12, 2, 3, 13] </ref>). Perhaps the most developed of these approaches are those by [12, 13] and [2, 3]. The former starts with an operational semantics, and develops a set-based analysis for this semantics. The constraints that arise are briefly sketched in Section 3.3. <p> Perhaps the most developed of these approaches are those by <ref> [12, 13] </ref> and [2, 3]. The former starts with an operational semantics, and develops a set-based analysis for this semantics. The constraints that arise are briefly sketched in Section 3.3. <p> Next, the set-based semantics is reduced to a set constraint problem, and finally, the set constraints are solved. In this paper, we will not go through this process in much formal detail. These details can be found in <ref> [12] </ref>. <p> The more complex constraints using quantified expressions not only provide more accurate program approximation, but they are also more faithful to the notion of set-based analysis. In particular, they have closer and much simpler relationship to the underlying operational semantics (see <ref> [12, 16] </ref> for further details). 3.3 Functional Programs To analyze functional languages such as Standard ML [23], set constraints must be extended with a mechanism to deal with higher-order functions. In essence, this is achieved by the addition of three new components. <p> See <ref> [12, 13] </ref> for further details. The complexity of solving the set constraints is O (n 3 ) [13]. <p> The modifications for solving these new constraints involve steps such as simplifying ground " any into ground , and f (any) " ground into f (ground ). See <ref> [12, 15] </ref> for further details. Note that the constants ground and any behave in essentially the same way as &gt;, and may appear in the output of the algorithm (that is, they may appear in the explicit representations that are computed by the algorithm). <p> Then set constraints are constructed as before, with care to preserve the labels on function symbols call the resulting constraints labeled set constraints. The meaning of these constraints is defined by mapping set expressions into sets of labeled terms. We refer to <ref> [12, 15] </ref> for further details. Interpreted Function Symbols The set constraints considered so far deal with uninterpreted symbols so as to correspond to the data constructors of the language at hand. For analysis of programs involving operations such as arithmetic, this approach must be generalized.
Reference: [13] <author> N. Heintze, </author> <title> "Set-Based Analysis of ML Programs", to appear, </title> <booktitle> ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1994. </year>
Reference-contexts: One presentational difference in these works is the use of various extensions of regular grammars instead of constraints. 5 Subsequently, a number of set constraint approaches have been developed for the analysis of higher-order functional languages (see, for example, <ref> [27, 12, 2, 3, 13] </ref>). Perhaps the most developed of these approaches are those by [12, 13] and [2, 3]. The former starts with an operational semantics, and develops a set-based analysis for this semantics. The constraints that arise are briefly sketched in Section 3.3. <p> Perhaps the most developed of these approaches are those by <ref> [12, 13] </ref> and [2, 3]. The former starts with an operational semantics, and develops a set-based analysis for this semantics. The constraints that arise are briefly sketched in Section 3.3. <p> See <ref> [12, 13] </ref> for further details. The complexity of solving the set constraints is O (n 3 ) [13]. <p> See [12, 13] for further details. The complexity of solving the set constraints is O (n 3 ) <ref> [13] </ref>. <p> One of the main lessons of this implementation is the expense of solving set constraints involving intersection. Much of the work of the implementation was directed at reducing this cost. The second implementation effort provides a contrasting experience. This implementation <ref> [13] </ref> focussed on the analysis of ML programs. The core algorithm for this analysis is 0 (n 3 ) on the size of the input program. Typical execution times are in the range of 200-400 lines per second for programs up to several thousand lines in length.
Reference: [14] <author> N. Heintze, </author> <title> "Set-Based Analysis of Arithmetic", </title> <institution> Carnegie Mellon University technical report CMU-CS-93-221, 20pp., </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Clearly, the actual values of x are included in the set f0; 1; 2; : : :g. <ref> [14] </ref> describes how this approach can be applied to the problem of removing array bounds checks, and this requires that the analysis also reason about arithmetic tests.
Reference: [15] <author> N. Heintze, </author> <title> "Set Constraints in Program Analysis", Workshop on Global Compilation, </title> <booktitle> International Logic Programming Symposium, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: Furthermore, set constraints are inherently more incremental than the iterative fixed-point computations of abstract interpretation. In essence, constraints provide a compact implicit representation of information. This representation 13 supports computation over partial information that is particularly well suited to efficient program analysis. We refer to <ref> [15] </ref> for a deeper discussion of this issue. 3.6 Extensions So far we have focussed on the use of set constraints to obtain an approximation of the possible run-time values of variables in a program. <p> The modifications for solving these new constraints involve steps such as simplifying ground " any into ground , and f (any) " ground into f (ground ). See <ref> [12, 15] </ref> for further details. Note that the constants ground and any behave in essentially the same way as &gt;, and may appear in the output of the algorithm (that is, they may appear in the explicit representations that are computed by the algorithm). <p> Then set constraints are constructed as before, with care to preserve the labels on function symbols call the resulting constraints labeled set constraints. The meaning of these constraints is defined by mapping set expressions into sets of labeled terms. We refer to <ref> [12, 15] </ref> for further details. Interpreted Function Symbols The set constraints considered so far deal with uninterpreted symbols so as to correspond to the data constructors of the language at hand. For analysis of programs involving operations such as arithmetic, this approach must be generalized.
Reference: [16] <author> N. Heintze and J. Jaffar, </author> <title> "A Finite Presentation Theorem for Approximating Logic Programs", </title> <booktitle> Proc. 17 th ACM Symp. on Principles of Programming Languages, </booktitle> <address> San Francisco, </address> <pages> pp. 197-209, </pages> <month> January </month> <year> 1990. </year> <note> (A full version of this paper appears as IBM Technical Report RC 16089 (# 71415), 66 pp., </note> <month> August </month> <year> 1990.) </year> <month> 16 </month>
Reference-contexts: For example, [32] defined the operator Y P (S) def and the approximate meaning of the program is the least fixpoint lfp (Y P ) of Y P (which is always larger than the exact meaning, lfp (T P )). In <ref> [16] </ref>, a more accurate operator t P was used. (Roughly, Y P ignores inter-argument dependencies, while t P ignores only inter-variable dependencies.) A more recent work [8] used the closure operators (in conjunction with another approximation technique called widening) to define and compute a program approximation. <p> The more complex constraints using quantified expressions not only provide more accurate program approximation, but they are also more faithful to the notion of set-based analysis. In particular, they have closer and much simpler relationship to the underlying operational semantics (see <ref> [12, 16] </ref> for further details). 3.3 Functional Programs To analyze functional languages such as Standard ML [23], set constraints must be extended with a mechanism to deal with higher-order functions. In essence, this is achieved by the addition of three new components.
Reference: [17] <author> N. Heintze and J. Jaffar, </author> <title> "A Decision Procedure for a Class of Herbrand Set Constraints", </title> <booktitle> Proc. 5 th IEEE Symp. on Logic in Computer Science, Philadelphia, </booktitle> <pages> pp. 42-51, </pages> <month> June </month> <year> 1990. </year> <note> (A full version of this paper appears as Carnegie Mellon University Technical Report CMU-CS-91-110, 42 pp., </note> <month> February </month> <year> 1991.) </year>
Reference-contexts: We say more about these applications in the next subsection. The general calculus of set constraints, as defined above, was first formalized and studied in a general setting in <ref> [17] </ref>. This work also presented a decision procedure for the class of definite set constraints (recall that definite constraints do not contain the complement symbol, and are restricted to the form a se where the set expression a contain only variables and function symbols). <p> This procedure further provides an explicit representation of the least model of a (satisfiable) collection of definite set constraints. <ref> [17] </ref> also posed decidability of the satisfiability problem for general set constraints as an open question. Later, [1] proved the decidability of a different, and incomparable, class: the positive set constraints. These are defined simply to be set constraints not involving projection.
Reference: [18] <author> N. Heintze and J. Jaffar, </author> <title> "Semantic Types for Logic Programs" in Types in Logic Programming, </title> <editor> F. Pfenning (Ed.), </editor> <booktitle> MIT Press Series in Logic Programming, </booktitle> <pages> pp. 141-155, </pages> <year> 1992. </year>
Reference-contexts: The relationship between these closure-based fixpoint operators and set constraints was described in <ref> [18] </ref>. One result is that the models of the set constraints in [25], essentially correspond to the fixpoints of Y P . A similar result was that the other fixpoint operator t P corresponded to certain formulas obtained from the program.
Reference: [19] <author> N. Heintze and J. Jaffar, </author> <title> "An Engine for Logic Program Analysis", </title> <booktitle> Proc. 7 th IEEE Symp. on Logic in Computer Science, </booktitle> <address> Santa Cruz, </address> <pages> pp. 318-328, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Of course, the main limitation of set-based analysis is that all inter-variable dependencies are ignored. Such dependencies can be crucial for some kinds of analysis such as 12 mode analysis (see <ref> [19] </ref> for a discussion of this issue). In contrast, abstract interpretation techniques can retain a limited amount of information about dependencies (although there is, of course, additional computational cost associated with maintaining information about dependencies). <p> In contrast, abstract interpretation techniques can retain a limited amount of information about dependencies (although there is, of course, additional computational cost associated with maintaining information about dependencies). Motivated by this observation, hybrid approaches that combine aspects of set constraints with abstract interpretation have been developed <ref> [19] </ref>. 3.5 Efficiency Issues It is difficult to quantify a comparison between set-based analysis and standard analysis techniques. While worst case complexity costs can be obtained, it is not clear what conclusions we can draw from these results about the practicality of the various approaches.
Reference: [20] <author> T. Jensen and T. Mogensen, </author> <title> "A Backwards Analysis for Compile-Time Garbage Collection", </title> <booktitle> Proc. 3 rd European Symp. on Programming, Copenhagen, </booktitle> <volume> LNCS 432, </volume> <pages> pp. 227-239, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: It is open as to whether lfp (Y P ) is decidable. Functional Programs The general approach of [22, 29] has been extended by [21] to deal with higher-order functions. This approach has been further developed for binding time analysis [24], garbage collection <ref> [20] </ref> and globalization of function parameters [30].
Reference: [21] <author> N. Jones, </author> <title> "Flow Analysis of Lazy Higher-Order Functional Programs", in Abstract Interpretation of Declarative Languages, </title> <editor> S. Abramsky and C. Hankin (Eds.), </editor> <publisher> Ellis Horwood, </publisher> <year> 1987. </year>
Reference-contexts: It is open as to whether lfp (Y P ) is decidable. Functional Programs The general approach of [22, 29] has been extended by <ref> [21] </ref> to deal with higher-order functions. This approach has been further developed for binding time analysis [24], garbage collection [20] and globalization of function parameters [30].
Reference: [22] <author> N. Jones and S. Muchnick, </author> <title> "Flow Analysis and Optimization of LISP-like Structures", </title> <booktitle> Proc. 6 th ACM Symp. on Principles of Programming Languages, </booktitle> <address> San Antonio, </address> <pages> pp. 244-256, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: variable is a regular set, that is, a set accepted by a nondetermistic tree automaton. 2.2 A Brief History The use of set constraints for analysis of programs dates back to the early works by Reynolds [29] (who presents an analysis for a first-order functional language), and Jones and Muchnick <ref> [22] </ref> (who present an analysis for a simple imperative language). In both of these works, the set constraints used are quite simple: the only set operations employed are union and projection (there are no intersections or quantified expressions). We say more about these applications in the next subsection. <p> Thus the question of whether the general set constraint problem is open, now becomes open! 2.3 Applications Early works Two important early works are by Jones and Muchnick <ref> [22] </ref> and Reynolds [29]. In [22], an analysis is described for an imperative language with lisp-like data structures. The essence here is the construction of set constraints corresponding to a program that capture the flow of values from one variable to another as the program is executed. <p> Thus the question of whether the general set constraint problem is open, now becomes open! 2.3 Applications Early works Two important early works are by Jones and Muchnick <ref> [22] </ref> and Reynolds [29]. In [22], an analysis is described for an imperative language with lisp-like data structures. The essence here is the construction of set constraints corresponding to a program that capture the flow of values from one variable to another as the program is executed. <p> In contrast, the earlier paper [29] used set constraints to compute data type definitions for program variables in a first order functional language. The constraints used are similar to those used in <ref> [22] </ref>. Again the only set operation of the constraints is projection, and so the program approximations obtained can be considerably inaccurate. In summary, the set constraints used in these early works are simple, but the program approximations that they define are not very accurate. <p> The main point here was that the least fixed-point of t P provided a more accurate and intuitive notion of approximation, and importantly, the approximation is decidable. It is open as to whether lfp (Y P ) is decidable. Functional Programs The general approach of <ref> [22, 29] </ref> has been extended by [21] to deal with higher-order functions. This approach has been further developed for binding time analysis [24], garbage collection [20] and globalization of function parameters [30].
Reference: [23] <author> R. Milner, M. Tofte and R. Harper, </author> <title> "The Definition of Standard ML", </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In particular, they have closer and much simpler relationship to the underlying operational semantics (see [12, 16] for further details). 3.3 Functional Programs To analyze functional languages such as Standard ML <ref> [23] </ref>, set constraints must be extended with a mechanism to deal with higher-order functions. In essence, this is achieved by the addition of three new components. First, the set of underlying values is enriched to include a new collection of constants to denote functions.
Reference: [24] <author> T. Mogensen, </author> <title> "Separating Binding Times in Language Specifications", </title> <booktitle> Proc. Functional Programming and Computer Architecture, London, ACM, </booktitle> <pages> pp. 12-25, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: It is open as to whether lfp (Y P ) is decidable. Functional Programs The general approach of [22, 29] has been extended by [21] to deal with higher-order functions. This approach has been further developed for binding time analysis <ref> [24] </ref>, garbage collection [20] and globalization of function parameters [30].
Reference: [25] <author> P. Mishra, </author> <title> "Toward a Theory of Types in PROLOG", </title> <booktitle> Proc. 1 st IEEE Symp. on Logic Programming, Atlantic City, </booktitle> <pages> pp. 289-298, </pages> <year> 1984. </year>
Reference-contexts: As a result, there is no simple connection between the program and its approximation. This particular shortcoming is one of the motivations for set-based analysis, discussed later in this paper. Logic Programs The use of set constraints for the bottom-up analysis of logic programs was first considered in <ref> [25] </ref>. The set constraints in this relatively early work were rather specialized and used a form of approximation called tuple-distributive closure (hereafter just called closure). <p> Thus for example, closing the set ff (a; b); f (c; d)g produces ff (a; b); f (a; c); f (b; d); f (c; d)g. The set constraints used in <ref> [25] </ref> are like the general ones defined above, except that the union operation is interpreted to be the closure of the union of sets. <p> The relationship between these closure-based fixpoint operators and set constraints was described in [18]. One result is that the models of the set constraints in <ref> [25] </ref>, essentially correspond to the fixpoints of Y P . A similar result was that the other fixpoint operator t P corresponded to certain formulas obtained from the program. These formulas are similar to but more general than set constraints.
Reference: [26] <author> L. Pacholski, </author> <type> personal communication, </type> <month> March </month> <year> 1994. </year>
Reference-contexts: In summary, the state of the art for the set constraint decision problem is largely determined by the reduction to the monadic class of formulas. The main question remains how to deal with (unrestricted) projection. At the time of writing, we have verbal communication <ref> [26] </ref> indicating that the proof in [6] can be extended to solve this problem. Thus the question of whether the general set constraint problem is open, now becomes open! 2.3 Applications Early works Two important early works are by Jones and Muchnick [22] and Reynolds [29].
Reference: [27] <author> J. Palsberg and M. Schwartzbach, </author> <title> "Safety Analysis versus Type Inference for Partial Types" Information Processing Letters, </title> <booktitle> Vol 43, </booktitle> <pages> pp. 175-180, </pages> <publisher> North-Holland, </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: One presentational difference in these works is the use of various extensions of regular grammars instead of constraints. 5 Subsequently, a number of set constraint approaches have been developed for the analysis of higher-order functional languages (see, for example, <ref> [27, 12, 2, 3, 13] </ref>). Perhaps the most developed of these approaches are those by [12, 13] and [2, 3]. The former starts with an operational semantics, and develops a set-based analysis for this semantics. The constraints that arise are briefly sketched in Section 3.3.
Reference: [28] <author> M.O. Rabin, </author> <title> "Decidability of Second-order Theories and Automata on Infinite Trees", </title> <journal> Transactions of the American Math. Society 141, </journal> <pages> pp 1 - 35, </pages> <year> 1969. </year>
Reference-contexts: This procedure reduces the constraints into a simpler form. When reduction terminates without detecting inconsistency, the resulting constraints are evidently satisfiable. Note that satisfiable positive set constraints do not always have a least model. Subsequently, [9] provided an alternative procedure using tree automata techniques. Starting with Rabin's result <ref> [28] </ref> that the theory of k-successors is decidable, they generalized the Rabin automaton to ac-comodate positive set constraints. They further showed that satisfiable positive constraints always have a regular solution (all variables are assigned a regular set), and a minimal and maximal regular solution.
Reference: [29] <author> J. Reynolds, </author> <title> "Automatic Computation of Data Set Definitions", </title> <booktitle> Information Processing 68, </booktitle> <pages> pp. 456-461, </pages> <publisher> North-Holland, </publisher> <year> 1969. </year>
Reference-contexts: it can be shown that this solution is regular in the sense that every variable is a regular set, that is, a set accepted by a nondetermistic tree automaton. 2.2 A Brief History The use of set constraints for analysis of programs dates back to the early works by Reynolds <ref> [29] </ref> (who presents an analysis for a first-order functional language), and Jones and Muchnick [22] (who present an analysis for a simple imperative language). <p> Thus the question of whether the general set constraint problem is open, now becomes open! 2.3 Applications Early works Two important early works are by Jones and Muchnick [22] and Reynolds <ref> [29] </ref>. In [22], an analysis is described for an imperative language with lisp-like data structures. The essence here is the construction of set constraints corresponding to a program that capture the flow of values from one variable to another as the program is executed. <p> Further, information relating to well definedness of expressions is ignored (for example, after a statement X = car (Y ), it must be the case that Y is of the form cons ( ) because otherwise the program would have terminated with an error). In contrast, the earlier paper <ref> [29] </ref> used set constraints to compute data type definitions for program variables in a first order functional language. The constraints used are similar to those used in [22]. Again the only set operation of the constraints is projection, and so the program approximations obtained can be considerably inaccurate. <p> The main point here was that the least fixed-point of t P provided a more accurate and intuitive notion of approximation, and importantly, the approximation is decidable. It is open as to whether lfp (Y P ) is decidable. Functional Programs The general approach of <ref> [22, 29] </ref> has been extended by [21] to deal with higher-order functions. This approach has been further developed for binding time analysis [24], garbage collection [20] and globalization of function parameters [30].
Reference: [30] <author> P. Sestoft, </author> <title> "Replacing Function Parameters by Global Variables", </title> <booktitle> Proc. Functional Programming and Computer Architecture, London, ACM, </booktitle> <pages> pp. 39-53, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: It is open as to whether lfp (Y P ) is decidable. Functional Programs The general approach of [22, 29] has been extended by [21] to deal with higher-order functions. This approach has been further developed for binding time analysis [24], garbage collection [20] and globalization of function parameters <ref> [30] </ref>. One presentational difference in these works is the use of various extensions of regular grammars instead of constraints. 5 Subsequently, a number of set constraint approaches have been developed for the analysis of higher-order functional languages (see, for example, [27, 12, 2, 3, 13]).
Reference: [31] <author> T.E. Uribe, </author> <title> "Sorted Unification using Set Constraints", </title> <booktitle> Proc. 11 th Intl. Conf. on Automated Deduction, </booktitle> <editor> D. Kapur (Ed), </editor> <publisher> Springer Verlag Lecture Notes in Computer Science, </publisher> <year> 1992. </year>
Reference-contexts: In the literature, a typical restriction is that the sorts are regular sets. In <ref> [31] </ref>, a restricted class of set constraints is used to represent the sort theory, and a new sorted unification algorithm is presented.
Reference: [32] <author> E. Yardeni and E.Y. Shapiro, </author> <title> "A Type System for Logic Programs", </title> <journal> Journal of Logic Programming, </journal> <volume> Vol. 10, </volume> <pages> pp. 125 - 153, </pages> <year> 1991. </year> <note> (An early version of this paper appears in Concurrent PROLOG: </note> <editor> Collected Papers, </editor> <volume> Vol. 2, </volume> <publisher> MIT Press, </publisher> <pages> pp 211 - 244, </pages> <year> 1987.) </year> <month> 17 </month>
Reference-contexts: A different approach to approximation starts from the (bottom-up) fixpoint operator T P of a program P , and the approximate meaning of a program is obtained by imposing closure on each iteration of the operator. For example, <ref> [32] </ref> defined the operator Y P (S) def and the approximate meaning of the program is the least fixpoint lfp (Y P ) of Y P (which is always larger than the exact meaning, lfp (T P )).
References-found: 32

