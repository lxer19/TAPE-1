URL: ftp://ftp.cis.ohio-state.edu/pub/anish/papers/component.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~anish/pub.html
Root-URL: 
Title: Component Based Design of Multitolerance  
Author: Anish Arora Sandeep S. Kulkarni 
Keyword: formal methods, compositional design, interference-freedom, stepwise design, detectors, correctors, dependability, fault-tolerance, graceful degradation  
Address: Columbus, Ohio 43210 USA  
Affiliation: Department of Computer and Information Science 1 The Ohio State University  
Abstract: The concept of multitolerance abstracts problems in system dependability and provides a basis for improved design of dependable systems. In the abstraction, each source of undependability in the system is represented as a class of faults, and the corresponding ability of the system to deal with that undependability source is represented as a type of tolerance. Multitolerance thus refers to the ability of the system to tolerate multiple fault-classes, each in a possibly different way. In this paper, we present a component based method for designing multitolerance. Two types of components are employed by the method, namely detectors and correctors. A theory of detectors, correctors, and their interference-free composition with intolerant programs is developed, that enables stepwise addition of components to provide tolerance to a new fault-class while preserving the tolerances to the previously added fault-classes. We illustrate the method by designing a fully distributed, multitolerant program for a token ring. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Siewiorek and R. S. Swarz. </author> <title> Reliable Computer Systems: Design and Evaluation. </title> <publisher> Digital Press, </publisher> <year> 1992. </year>
Reference: [2] <author> W.N. </author> <title> Toy and L.C. Toy. </title> <journal> The AT&T Case, </journal> <note> chapter 8. in [1]. </note>
Reference: [3] <author> R.W. Kocsis. </author> <title> The Galileo Case, </title> <note> chapter 9. in [1]. </note>
Reference: [4] <author> F. B. Bastani, I.-L. Yen, and I.-R. Chen. </author> <title> A class of inherently fault-tolerant distributed programs. </title> <journal> IEEE Transactions on Software Eng., </journal> <volume> 14(10) </volume> <pages> 1431-1442, </pages> <year> 1988. </year>
Reference: [5] <author> A. Arora. </author> <title> A Foundation of Fault-Tolerant Computing. </title> <type> PhD thesis, </type> <institution> The University of Texas at Austin, </institution> <year> 1992. </year>
Reference-contexts: Sections 3 and 4); (2) it has yielded simple theorems for composing tolerance actions and underlying actions in an interference-free manner (cf. Sections 5 and 6); (3) it has facilitated our design of novel and complex distributed programs whose tolerances exceed those of comparable programs designed otherwise <ref> [5, 10, 21, 24, 25, 26] </ref>. We have represented faults as state perturbations. This representation readily handles transient faults, but does it also handle permanent faults? intermittent faults? detectable faults? undetectable faults? All these faults can indeed be represented as state perturbations. <p> It is worth pointing out that representing permanent and intermittent faults, such as Byzantine faults and fail-stop and repair faults, may require the introduction auxiliary variables <ref> [5, 10] </ref>. For example, to represent Byzantine faults that affects a process j, we may introduce an auxiliary boolean variable byz:j that is false iff j is Byzantine. If j is not Byzantine, it executes its "normal" actions. Otherwise, it executes some "abnormal" actions.
Reference: [6] <author> A. Gopal and K. Perry. </author> <title> Unifying self-stabilization and fault-tolerance. </title> <booktitle> Proceedings of the Twelfth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 195-206, </pages> <year> 1993. </year>
Reference: [7] <author> S. Dolev and T. Herman. </author> <title> Superstabilizing protocols for dynamic distributed systems. </title> <booktitle> Proceedings of the Second Workshop on Self-Stabilizing Systems, </booktitle> <year> 1995. </year>
Reference: [8] <author> M Gouda and M. Schneider. </author> <title> Maximal flow routing. </title> <booktitle> Proceedings of the Second Workshop on Self Stabilizing Systems, </booktitle> <year> 1995. </year>
Reference: [9] <author> I. Yen and F. Bastani. </author> <title> A highly safe self-stabilizing mutual exclusion algorithm. </title> <booktitle> Proceedings of the Second Workshop on Self-Stabilizing Systems, </booktitle> <year> 1995. </year>
Reference: [10] <author> A. Arora and M. G. Gouda. </author> <title> Closure and convergence: A foundation of fault-tolerant computing. </title> <journal> IEEE Transactions on Software Engineering, </journal> 19(11) 1015-1027, 1993. <volume> 24 </volume>
Reference-contexts: Finally, we discuss some issues raised by our methodology in Section 8 and make concluding remarks in Section 9. 2 Preliminaries In this section, we recall a formal representation of programs, faults, and fault-tolerances. The formalization is adapted from earlier work of the first author with Mohamed Gouda <ref> [10] </ref>, with the exception of the portion on fail-safe tolerance which is new. Programs. A program is a set of variables and a finite set of actions. Each variable has a predefined nonempty domain. <p> Finally, the stability condition implies that Z once established remains true subsequently. Remark. If the witness predicate Z is identical to the correction predicate X, our definition of the detects relation reduces to one given by Arora and Gouda <ref> [10] </ref>. We have considered this more general definition to accommodate the case |which occurs for instance in masking tolerance| where the witness predicate Z can be checked atomically but the correction predicate X cannot. (End of Remark.) Properties. <p> Sections 3 and 4); (2) it has yielded simple theorems for composing tolerance actions and underlying actions in an interference-free manner (cf. Sections 5 and 6); (3) it has facilitated our design of novel and complex distributed programs whose tolerances exceed those of comparable programs designed otherwise <ref> [5, 10, 21, 24, 25, 26] </ref>. We have represented faults as state perturbations. This representation readily handles transient faults, but does it also handle permanent faults? intermittent faults? detectable faults? undetectable faults? All these faults can indeed be represented as state perturbations. <p> It is worth pointing out that representing permanent and intermittent faults, such as Byzantine faults and fail-stop and repair faults, may require the introduction auxiliary variables <ref> [5, 10] </ref>. For example, to represent Byzantine faults that affects a process j, we may introduce an auxiliary boolean variable byz:j that is false iff j is Byzantine. If j is not Byzantine, it executes its "normal" actions. Otherwise, it executes some "abnormal" actions.
Reference: [11] <author> B. Alpern and F. B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21 </volume> <pages> 181-185, </pages> <year> 1985. </year>
Reference-contexts: Note that the set of computations is suffix closed. Problem Specification. The problem specification that p satisfies consists of a "safety" specification and a "liveness" specification <ref> [11] </ref>. A safety specification identifies a set of "bad" finite computation prefixes that should not appear in any program computation. <p> Dually, a liveness specification iden 2 tifies a set of "good" computation suffixes such that every computation has a suffix that is in this set. (Incidentally, our definition of liveness is stronger than Alpern and Schneider's definition <ref> [11] </ref>: the two definitions become identical if the liveness specification is fusion closed; i.e., if computations hff; x; fli and hfi; x; ffii satisfy the liveness specification then computations hff; x; ffii and hfi; x; fli also satisfy the liveness specification, where ff; fi are finite computation prefixes, fl; ffi are
Reference: [12] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1976. </year>
Reference-contexts: Techniques for the design of an invariant of the program have been articulated by Dijkstra <ref> [12] </ref>, using the notion of auxiliary variables, and by Gries [13], using the heuristics of state predicate ballooning and shrinking. Techniques for the mechanical calculation of an invariant predicate have been discussed by Alpern and Schneider [14]. Faults.
Reference: [13] <editor> D. Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Techniques for the design of an invariant of the program have been articulated by Dijkstra [12], using the notion of auxiliary variables, and by Gries <ref> [13] </ref>, using the heuristics of state predicate ballooning and shrinking. Techniques for the mechanical calculation of an invariant predicate have been discussed by Alpern and Schneider [14]. Faults. The faults that a program is subject to are systematically represented by actions whose execution perturbs the program state.
Reference: [14] <author> B. Alpern and F. Schneider. </author> <title> Proving boolean combinations of deterministic properties. </title> <booktitle> Proceedings of the Second Symposium on Logic in Computer Scien ce, </booktitle> <pages> pages 131-137, </pages> <year> 1987. </year>
Reference-contexts: Techniques for the mechanical calculation of an invariant predicate have been discussed by Alpern and Schneider <ref> [14] </ref>. Faults. The faults that a program is subject to are systematically represented by actions whose execution perturbs the program state.
Reference: [15] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation, chapter 9. </title> <publisher> Addison Wesley Publishing Company, </publisher> <year> 1989. </year>
Reference-contexts: The Stability condition implies that once Z is truthified, it continues to hold unless X is violated. Remark. If the detection predicate X is closed in d, our definition of the detects relation reduces to one given by Chandy and Misra <ref> [15] </ref>.
Reference: [16] <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <year> 1993. </year>
Reference: [17] <author> G.M. Levin and D. Gries. </author> <title> A proof technique for communicating sequential processes. </title> <journal> Acta Informatica, </journal> <pages> pages 281-302, </pages> <year> 1981. </year>
Reference: [18] <author> R.J.R. Back and K. Sere. </author> <title> Stepwise refinement of parallel programs. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 3(4) </volume> <pages> 133-180, </pages> <year> 1994. </year>
Reference: [19] <author> J. Misra and K. M. Chandy. </author> <title> Proofs of networks of processes. </title> <journal> IEEE Transactions on Software Engi neering, </journal> <volume> 7(4) </volume> <pages> 417-426, </pages> <year> 1981. </year>
Reference: [20] <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs. </title> <journal> Acta Informatica, </journal> <volume> 6:319 340, </volume> <year> 1976. </year>
Reference: [21] <author> A. Arora and S. S. Kulkarni. </author> <title> Designing masking fault-tolerance via nonmasking fault-tolerance. </title> <journal> Sub mitted to IEEE Transactions on Software Engineering, </journal> <note> a preliminary version of this paper appears in Proceedings of the Fourteenth Symposium on Reliable Distributed Systems, Bad Neuenahr, </note> <year> 1995. </year>
Reference-contexts: Alternatively, we may first augment the program with correctors, and then augment the resulting nonmasking tolerant program with detectors. (See Figure 6.) For reasons of space, we refer the interested reader to <ref> [21] </ref> for more details on this two-stage approach for designing masking tolerance. Second step. This step adds l2 to F 2 and preserves the l1 tolerance to F 1. <p> Sections 3 and 4); (2) it has yielded simple theorems for composing tolerance actions and underlying actions in an interference-free manner (cf. Sections 5 and 6); (3) it has facilitated our design of novel and complex distributed programs whose tolerances exceed those of comparable programs designed otherwise <ref> [5, 10, 21, 24, 25, 26] </ref>. We have represented faults as state perturbations. This representation readily handles transient faults, but does it also handle permanent faults? intermittent faults? detectable faults? undetectable faults? All these faults can indeed be represented as state perturbations. <p> our compositional method compare with the existing methods for designing fault-tolerant programs? Our compositional method is rich in the sense that it accommodates various existing fault-tolerance design methods such as replication, checkpointing and recovery, Schneider's state machine approach, exception handling, and Randell's recovery blocks. (The interested reader is referred to <ref> [21, 25] </ref> for a detailed discussion of how properties such as replication, agreement, and order are designed by interference-free composition.) How are fault-classes derived? Can our method be used if it is difficult to characterize the faults the system is subject to? Derivation of fault-classes is application specific.
Reference: [22] <author> John Rushby. </author> <title> Critical system properties: Survey and taxonomy. </title> <journal> Reliability Engineering and System, </journal> <volume> 43 </volume> <pages> 180-219, </pages> <year> 1994. </year>
Reference-contexts: Can other abstractions be used to formalize multitolerance? What are the advantages of using closure and convergence? In principle, one can formulate the concept of multitolerance using abstractions other than closure and convergence. As pointed out by John Rushby <ref> [22] </ref>, the approaches to formulate fault-tolerance can be classified into two: specification approaches and calculational approaches. In specification approaches, a system is regarded as a composition of several subsystems, each with a standard specification and one or more failure specifications.
Reference: [23] <author> M. Herlihy and J. Wing. </author> <title> Specifying graceful degradation. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 2(1) </volume> <pages> 93-104, </pages> <year> 1991. </year>
Reference-contexts: A system is fault-tolerant if it satisfies its standard specification when all components do, and one of its failure specifications if some of its components depart from their standard specification. One example of this approach is due to Herlihy and Wing <ref> [23] </ref> who thus formulate graceful degradation, a special case of multitolerance. In calculational approaches, the set of computations permissible in the presence of faults is calculated. A system is said to be fault-tolerant if this set satisfies the specification of the system (or a acceptably degraded version of it).
Reference: [24] <author> S. S. Kulkarni and A. Arora. </author> <title> Multitolerance in distributed reset. </title> <type> Technical Report OSU-CISRC 02/96 TR13, </type> <institution> Ohio State University, </institution> <year> 1996. </year> <note> Submitted to Chicago Journal of Theoretical Computer Science, Special Issue on Self-Stabilization. </note>
Reference-contexts: Sections 3 and 4); (2) it has yielded simple theorems for composing tolerance actions and underlying actions in an interference-free manner (cf. Sections 5 and 6); (3) it has facilitated our design of novel and complex distributed programs whose tolerances exceed those of comparable programs designed otherwise <ref> [5, 10, 21, 24, 25, 26] </ref>. We have represented faults as state perturbations. This representation readily handles transient faults, but does it also handle permanent faults? intermittent faults? detectable faults? undetectable faults? All these faults can indeed be represented as state perturbations. <p> For reasons of space, an interested reader is referred to [25] for a case study involving qualitative tolerance. We note that we have used our method to design multitolerant programs for barrier computations, mutual exclusion, tree maintenance, leader election, bounded-space distributed reset, and termination detection <ref> [24, 25, 27] </ref>. To apply our design method in practice, we are currently developing SIEFAST, a simulation and implementation environment that enables stepwise implementation and validation of multitolerant distributed programs. We are also studying the mechanical synthesis of multitolerant concurrent programs. Acknowledgments.
Reference: [25] <author> A. Arora and S. S. Kulkarni. </author> <title> Multitolerance and its design. </title> <type> Technical Report OSU-CISRC 07/96 TR-37, </type> <institution> Ohio State University, </institution> <year> 1996. </year>
Reference-contexts: Sections 3 and 4); (2) it has yielded simple theorems for composing tolerance actions and underlying actions in an interference-free manner (cf. Sections 5 and 6); (3) it has facilitated our design of novel and complex distributed programs whose tolerances exceed those of comparable programs designed otherwise <ref> [5, 10, 21, 24, 25, 26] </ref>. We have represented faults as state perturbations. This representation readily handles transient faults, but does it also handle permanent faults? intermittent faults? detectable faults? undetectable faults? All these faults can indeed be represented as state perturbations. <p> The token ring case study illustrates the use of state perturbations for various classes of transient faults. In an extended version of this paper <ref> [25] </ref>, we present a case study of tree-based mutual exclusion which illustrates the analogous representation for permanent faults and for detectable or undetectable faults. <p> our compositional method compare with the existing methods for designing fault-tolerant programs? Our compositional method is rich in the sense that it accommodates various existing fault-tolerance design methods such as replication, checkpointing and recovery, Schneider's state machine approach, exception handling, and Randell's recovery blocks. (The interested reader is referred to <ref> [21, 25] </ref> for a detailed discussion of how properties such as replication, agreement, and order are designed by interference-free composition.) How are fault-classes derived? Can our method be used if it is difficult to characterize the faults the system is subject to? Derivation of fault-classes is application specific. <p> Our method is effective for the design of quantitative as well as qualitative tolerances. As an example of quantitative tolerance, we presented a token ring protocol that recovers from upto K faults in fi (K) time. For reasons of space, an interested reader is referred to <ref> [25] </ref> for a case study involving qualitative tolerance. We note that we have used our method to design multitolerant programs for barrier computations, mutual exclusion, tree maintenance, leader election, bounded-space distributed reset, and termination detection [24, 25, 27]. <p> For reasons of space, an interested reader is referred to [25] for a case study involving qualitative tolerance. We note that we have used our method to design multitolerant programs for barrier computations, mutual exclusion, tree maintenance, leader election, bounded-space distributed reset, and termination detection <ref> [24, 25, 27] </ref>. To apply our design method in practice, we are currently developing SIEFAST, a simulation and implementation environment that enables stepwise implementation and validation of multitolerant distributed programs. We are also studying the mechanical synthesis of multitolerant concurrent programs. Acknowledgments.
Reference: [26] <author> A. Arora, M. G. Gouda, and G. Varghese. </author> <title> Constraint satisfaction as a basis for designing nonmasking fault-tolerance. </title> <journal> Journal of High Speed Networks, </journal> <volume> 5(3) </volume> <pages> 292-306, </pages> <year> 1996. </year>
Reference-contexts: Sections 3 and 4); (2) it has yielded simple theorems for composing tolerance actions and underlying actions in an interference-free manner (cf. Sections 5 and 6); (3) it has facilitated our design of novel and complex distributed programs whose tolerances exceed those of comparable programs designed otherwise <ref> [5, 10, 21, 24, 25, 26] </ref>. We have represented faults as state perturbations. This representation readily handles transient faults, but does it also handle permanent faults? intermittent faults? detectable faults? undetectable faults? All these faults can indeed be represented as state perturbations.
Reference: [27] <author> S. S. Kulkarni and A. Arora. </author> <title> Stepwise design of tolerances in barrier computations. </title> <type> Technical Report OSU-CISRC 03/96 TR-17, </type> <institution> Ohio State University, </institution> <year> 1996. </year> <month> 25 </month>
Reference-contexts: For reasons of space, an interested reader is referred to [25] for a case study involving qualitative tolerance. We note that we have used our method to design multitolerant programs for barrier computations, mutual exclusion, tree maintenance, leader election, bounded-space distributed reset, and termination detection <ref> [24, 25, 27] </ref>. To apply our design method in practice, we are currently developing SIEFAST, a simulation and implementation environment that enables stepwise implementation and validation of multitolerant distributed programs. We are also studying the mechanical synthesis of multitolerant concurrent programs. Acknowledgments.
References-found: 27

