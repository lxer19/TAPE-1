URL: http://www.cs.virginia.edu/~cw2e/res/lncs98.ps
Refering-URL: http://www.cs.virginia.edu/~cw2e/res/cs851_reading.html
Root-URL: http://www.cs.virginia.edu
Title: Safe, Untrusted Agents using Proof-Carrying Code  
Author: George C. Necula and Peter Lee 
Address: Pittsburgh PA 15217, USA  
Affiliation: Carnegie Mellon University School of Computer Science  
Abstract: Proof-Carrying Code (PCC) enables a computer system to determine, automatically and with certainty, that program code provided by another system is safe to install and execute without requiring interpretation or run-time checking. PCC has applications in any computing system in which the safe, efficient, and dynamic installation of code is needed. The key idea of Proof-Carrying is to attach to the code an easily-checkable proof that its execution does not violate the safety policy of the receiving system. This paper describes the design and a typical implementation of Proof-Carrying Code, where the language used for specifying the safety properties is first-order predicate logic. Examples of safety properties that are covered in this paper are memory safety and compliance with data access policies, resource usage bounds, and data abstraction boundaries. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Bershad, B., Savage, S., Pardyak, P., Sirer, E. G., Becker, D., Fiuczynski, M., Chambers, C., and Eggers, S. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Symposium on Operating System Principles (Dec. </booktitle> <year> 1995), </year> <pages> pp. 267-284. </pages>
Reference-contexts: Furthermore, certain safety properties (e.g. compliance with data abstraction boundaries) cannot be checked at run-time without significant penalties. When compared with approaches based on type-safety <ref> [1, 17] </ref> the advantage of PCC is the increased expressiveness of first-order logic over traditional type systems, which, for example, cannot express resource usage bounds or the arithmetic properties that enable the elimination of array-bounds checking.
Reference: 2. <author> Boyer, R., and Moore, J. S. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: For first-order logic, many theorem-proving systems have been implemented <ref> [2, 4, 5, 7, 9, 14] </ref>. To our knowledge, all of these are able to prove typical safety predicates, sometimes with the help of additional tactics that might be provided by the code consumer. However, for some safety properties, automatic decision procedures do not exist or are not effective.
Reference: 3. <author> Burstall, R., and Landin, P. </author> <title> Programs and their proofs: an algebraic approach. </title> <booktitle> Machine Intelligence, </booktitle> <month> 4 </month> <year> (1969). </year>
Reference-contexts: Then, it would be left to the proof logic to determine the meaning of the saferd predicate. A given logic might even say that saferd is never true, thus effectively disallowing memory reads. Several techniques for implementing VCGen have been described in the literature <ref> [3, 8] </ref>. As shown in Fig. 2, our approach to implementing VCGen involves two main components.
Reference: 4. <author> Constable, R. L., Allen, S. F., Bromley, H. M., Cleaveland, W. R., Cre-mer, J. F., Harper, R. W., Howe, D. J., Knoblock, T. B., Mendler, N. P., Panangaden, P., Sasaki, J. T., and Smith, S. F. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: For first-order logic, many theorem-proving systems have been implemented <ref> [2, 4, 5, 7, 9, 14] </ref>. To our knowledge, all of these are able to prove typical safety predicates, sometimes with the help of additional tactics that might be provided by the code consumer. However, for some safety properties, automatic decision procedures do not exist or are not effective.
Reference: 5. <author> Coquand, T., and Huet, G. </author> <title> Constructions: A higher order proof system for mechanizing mathematics. </title> <booktitle> In Proc. European Conf. on Computer Algebra (EU-ROCAL'85), LNCS 203 (1985), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 151-184. </pages>
Reference-contexts: For first-order logic, many theorem-proving systems have been implemented <ref> [2, 4, 5, 7, 9, 14] </ref>. To our knowledge, all of these are able to prove typical safety predicates, sometimes with the help of additional tactics that might be provided by the code consumer. However, for some safety properties, automatic decision procedures do not exist or are not effective.
Reference: 6. <author> D.C. Luckham, e. </author> <title> Stanford pascal verifier user manual. </title> <type> Tech. Rep. </type> <institution> STAN-CS-79-731, Dept. of Computer Science, Stanford Univ., </institution> <month> Mar. </month> <year> 1979. </year>
Reference-contexts: Lately we have switched to our own implementation of a theorem prover based on the Nelson-Oppen architecture for cooperating decision procedures [13], also implemented in the Stanford Pascal Verifier <ref> [6] </ref> and the Extended Static Checking [7] systems. The distinguishing feature of our implementation is that it outputs an LF representation of the proof of successfully proved predicates.
Reference: 7. <author> Detlefs, D. </author> <title> An overview of the Extended Static Checking system. </title> <booktitle> In Proceedings of the First Formal Methods in Software Practice Workshop (1996). </booktitle>
Reference-contexts: For first-order logic, many theorem-proving systems have been implemented <ref> [2, 4, 5, 7, 9, 14] </ref>. To our knowledge, all of these are able to prove typical safety predicates, sometimes with the help of additional tactics that might be provided by the code consumer. However, for some safety properties, automatic decision procedures do not exist or are not effective. <p> Lately we have switched to our own implementation of a theorem prover based on the Nelson-Oppen architecture for cooperating decision procedures [13], also implemented in the Stanford Pascal Verifier [6] and the Extended Static Checking <ref> [7] </ref> systems. The distinguishing feature of our implementation is that it outputs an LF representation of the proof of successfully proved predicates. The theorem prover uses several decision procedures, the most notable ones being Simplex, for deciding linear inequalities, and the congruence closure, for deciding equalities.
Reference: 8. <author> Dijkstra, E. W. </author> <title> Guarded commands, nondeterminancy and formal derivation of programs. </title> <booktitle> Communications of the ACM 18 (1975), </booktitle> <pages> 453-457. </pages>
Reference-contexts: Then, it would be left to the proof logic to determine the meaning of the saferd predicate. A given logic might even say that saferd is never true, thus effectively disallowing memory reads. Several techniques for implementing VCGen have been described in the literature <ref> [3, 8] </ref>. As shown in Fig. 2, our approach to implementing VCGen involves two main components.
Reference: 9. <author> Gordon, M. </author> <title> HOL: A machine oriented formulation of higher-order logic. </title> <type> Tech. Rep. 85, </type> <institution> University of Cambridge, Computer Laboratory, </institution> <month> July </month> <year> 1985. </year>
Reference-contexts: For first-order logic, many theorem-proving systems have been implemented <ref> [2, 4, 5, 7, 9, 14] </ref>. To our knowledge, all of these are able to prove typical safety predicates, sometimes with the help of additional tactics that might be provided by the code consumer. However, for some safety properties, automatic decision procedures do not exist or are not effective.
Reference: 10. <author> Harper, R., Honsell, F., and Plotkin, G. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery 40, </journal> <month> 1 (Jan. </month> <year> 1993), </year> <pages> 143-184. </pages>
Reference-contexts: All such details are segregated to the configuration file. Fig. 6. The structure of the proof checker To achieve the independence on the safety policy and logic we are currently encoding both the safety predicates and their proofs in the Edinburgh Logical Framework <ref> [10] </ref> (LF), which was specifically designed as a metalanguage for high-level specification of logics. In the rest of this section we only give a brief overview of LF and its use for PCC. <p> Furthermore, because LF type-checking is simple and abstract, it is possible to prove formally its adequacy for proof checking <ref> [10, 12] </ref>. In our PCC implementation the LF signatures are expressed in proof-checker configuration files using a format that is virtually identical to the one used in Fig. 7.
Reference: 11. <author> McCanne, S. </author> <title> The Berkeley Packet Filter man page. </title> <note> BPF distribution available at ftp://ftp.ee.lbl.gov, </note> <month> May </month> <year> 1991. </year>
Reference-contexts: The greatest challenge in this area is the serious difficulty of proving the resulting safety predicates. Proof-Carrying Code compares favorably with other techniques used to prevent untrusted code to step outside a safety policy. When compared with run-time techniques such as hardware or software memory protection [18] and interpretation <ref> [11, 16] </ref> the advantage is the run-time performance and the simplicity of the safety-critical infrastructure. Another advantage over run-time checking is that PCC avoids the possibility that the untrusted code must be terminated abruptly because of a run-time error before it has a chance of cleaning-up the modified state.
Reference: 12. <author> Necula, G. C., and Lee, P. </author> <title> Efficient representation and validation of logi-cal proofs. </title> <type> Technical Report CMU-CS-97-172, </type> <institution> Computer Science Department, Carnegie Mellon University, </institution> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: In the rest of this section we only give a brief overview of LF and its use for PCC. The reader interested in a more comprehensive discussion of the subject, including numerous implementation details, should consult <ref> [12] </ref>. <p> An important feature of LF type-checking is that it is very simple and can be completely described by fifteen inference rules and implemented is less than five pages of C code <ref> [12] </ref>. Furthermore, because the LF type checker is completely independent of the particular logic being used by the safety policy, we can reuse it for checking proofs in other logics. <p> Furthermore, because LF type-checking is simple and abstract, it is possible to prove formally its adequacy for proof checking <ref> [10, 12] </ref>. In our PCC implementation the LF signatures are expressed in proof-checker configuration files using a format that is virtually identical to the one used in Fig. 7.
Reference: 13. <author> Nelson, G., and Oppen, D. </author> <title> Simplification by cooperating decision procedures. </title> <journal> ACM Transactions on Programming Languages and Systems 1, </journal> <month> 2 (Oct. </month> <year> 1979), </year> <pages> 245-257. </pages>
Reference-contexts: Lately we have switched to our own implementation of a theorem prover based on the Nelson-Oppen architecture for cooperating decision procedures <ref> [13] </ref>, also implemented in the Stanford Pascal Verifier [6] and the Extended Static Checking [7] systems. The distinguishing feature of our implementation is that it outputs an LF representation of the proof of successfully proved predicates.
Reference: 14. <author> Owre, S., Rushby, J. M., and Shankar, N. PVS: </author> <title> A prototype verification system. </title> <booktitle> In 11th International Conference on Automated Deduction (CADE) (Saratoga, </booktitle> <address> NY, </address> <month> June </month> <year> 1992), </year> <editor> D. Kapur, Ed., </editor> <volume> vol. </volume> <booktitle> 607 of Lecture Notes in Artificial Intelligence, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 748-752. </pages>
Reference-contexts: For first-order logic, many theorem-proving systems have been implemented <ref> [2, 4, 5, 7, 9, 14] </ref>. To our knowledge, all of these are able to prove typical safety predicates, sometimes with the help of additional tactics that might be provided by the code consumer. However, for some safety properties, automatic decision procedures do not exist or are not effective.
Reference: 15. <author> Pfenning, F. </author> <title> Elf: A meta-language for deductive systems (system description). </title> <booktitle> In 12th International Conference on Automated Deduction (Nancy, </booktitle> <address> France, June 26-July 1, </address> <year> 1994), </year> <editor> A. Bundy, Ed., </editor> <publisher> LNAI 814, Springer-Verlag, </publisher> <pages> pp. 811-815. </pages>
Reference-contexts: In our implementations of PCC we have used two different theorem provers so far. The first, and most primitive, theorem prover that we used was developed using the Elf <ref> [15] </ref> implementation of LF.
Reference: 16. <author> Sun Microsystems. </author> <title> The Java language specification. </title> <note> Available as ftp://ftp.javasoft.com/docs/javaspec.ps.zip, </note> <year> 1995. </year>
Reference-contexts: These experiments confirm the usual intuition that proof generation is more expensive than proof checking. The second set of experiments compared agents using PCC to agents implemented in Java <ref> [16] </ref> and agents isolated using either hardware-memory protection or Software Fault Isolation (SFI) [18]. The comparison is not entirely fair because Java and SFI cannot enforce the database access policy, and thus offer weaker safety guarantees than PCC and hardware-memory protection. <p> The greatest challenge in this area is the serious difficulty of proving the resulting safety predicates. Proof-Carrying Code compares favorably with other techniques used to prevent untrusted code to step outside a safety policy. When compared with run-time techniques such as hardware or software memory protection [18] and interpretation <ref> [11, 16] </ref> the advantage is the run-time performance and the simplicity of the safety-critical infrastructure. Another advantage over run-time checking is that PCC avoids the possibility that the untrusted code must be terminated abruptly because of a run-time error before it has a chance of cleaning-up the modified state.
Reference: 17. <author> Sun Microsystems. </author> <title> The Java Virtual Machine specification. </title> <note> Available as ftp://ftp.javasoft.com/docs/vmspec.ps.zip, </note> <year> 1995. </year>
Reference-contexts: Furthermore, certain safety properties (e.g. compliance with data abstraction boundaries) cannot be checked at run-time without significant penalties. When compared with approaches based on type-safety <ref> [1, 17] </ref> the advantage of PCC is the increased expressiveness of first-order logic over traditional type systems, which, for example, cannot express resource usage bounds or the arithmetic properties that enable the elimination of array-bounds checking.
Reference: 18. <author> Wahbe, R., Lucco, S., Anderson, T. E., and Graham, S. L. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In 14th ACM Symposium on Operating Systems Principles (Dec. 1993), ACM, </booktitle> <pages> pp. </pages> <month> 203-216. </month> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: These experiments confirm the usual intuition that proof generation is more expensive than proof checking. The second set of experiments compared agents using PCC to agents implemented in Java [16] and agents isolated using either hardware-memory protection or Software Fault Isolation (SFI) <ref> [18] </ref>. The comparison is not entirely fair because Java and SFI cannot enforce the database access policy, and thus offer weaker safety guarantees than PCC and hardware-memory protection. All the measurements are done for the implementation of the simple agent on a 175 MHz DEC Alpha running DEC OSF 1.3. <p> The greatest challenge in this area is the serious difficulty of proving the resulting safety predicates. Proof-Carrying Code compares favorably with other techniques used to prevent untrusted code to step outside a safety policy. When compared with run-time techniques such as hardware or software memory protection <ref> [18] </ref> and interpretation [11, 16] the advantage is the run-time performance and the simplicity of the safety-critical infrastructure.
References-found: 18

