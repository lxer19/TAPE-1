URL: http://www.cs.brown.edu/people/jib/Papers/mocha.ps
Refering-URL: http://www.cs.brown.edu/people/jib/Info.html
Root-URL: http://www.cs.brown.edu/
Email: fjib,gl,rtg@cs.brown.edu  isabel@cs.tufts.edu  
Title: Algorithm Animation over the World Wide Web (Extended Abstract)  
Author: James E. Baker Isabel F. Cruz Giuseppe Liotta Roberto Tamassia 
Keyword: algorithm animation, program visualization, WWW interfaces, multimedia.  
Address: 115 Waterman Street, Providence, RI 02912-1910, USA.  161 College Avenue, Medford, MA 02155, USA.  
Affiliation: Department of Computer Science, Brown University,  Department of Electrical Engineering and Computer Science Tufts University,  
Note: Research supported in part by the National Science Foundation under grant CCR-9423847, by the U.S. Army Research Office under grant 34990-MA-MUR, and by the N.A.T.O.-C.N.R. Advanced Fellowships Programme.  
Abstract: In this paper we propose a new model, called Mocha, for providing algorithm animation over the World Wide Web. Mocha is a distributed model with a client-server architecture that optimally partitions the software components of a typical algorithm animation system, and leverages the power of the Java language, an emerging standard for distributing interactive platform-independent applications across the Web. Mocha provides high levels of security, protects the algorithm code, places a light communication load on the Internet, and allows users with limited computing resources to access animations of computationally expensive algorithms. The user interface combines fast responsiveness and user friendliness with the powerful authoring capabilities of hypertext narratives. We describe the architecture of Mocha and show its advantages over previous methods for algorithm animation over the Internet. We also present a prototype of an animation system for geometric algorithms that can be accessed by any user with a WWW browser supporting Java (currently Netscape 2.0 and HotJava) at URL http://www.cs.brown.edu/people/jib/Mocha.html. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Hotjava, </author> <year> 1995. </year> <note> http://www.javasoft.com/hotjava.html. </note>
Reference-contexts: While this mechanism is simple to implement, there are significant security problems associated with remote X sessions, and the communication load placed on the Internet is quite high. The arrival of the HotJava browser <ref> [1] </ref> and of the Java language [18] opens the possibility of embedding interactive applications in HTML documents, which are executed on the user machine after their code has been transferred. <p> In Section 3, we present a prototype of an animation system for geometric algorithms that can be accessed by any user with a WWW browser supporting Java (currently Netscape 2.0 [2] and HotJava <ref> [1] </ref>) at URL http://www.cs.brown.edu/people/jib/Mocha.html. <p> Java is an emerging standard for Internet programming: it is part of the widely used Netscape Navigator browser (version 2.0 in beta) [2] and of the HotJava (in alpha) <ref> [1] </ref> browser from Sun. Being an interactive part of the Web enables greater authoring capabilities through hypertext narratives; it also enables the use of the Web for distribution of this interactive content in terms of Java programs to a large audience. Java incorporates safety and security into its design.
Reference: [2] <author> Netscape, </author> <year> 1995. </year> <note> http://home.netscape.com/comprod/products/navigator/version 2.0/. </note>
Reference-contexts: In Section 3, we present a prototype of an animation system for geometric algorithms that can be accessed by any user with a WWW browser supporting Java (currently Netscape 2.0 <ref> [2] </ref> and HotJava [1]) at URL http://www.cs.brown.edu/people/jib/Mocha.html. <p> A Java program residing on a Web server can be transported over the Web through the HTTP protocol, and executed on the user's machine. Java is an emerging standard for Internet programming: it is part of the widely used Netscape Navigator browser (version 2.0 in beta) <ref> [2] </ref> and of the HotJava (in alpha) [1] browser from Sun. Being an interactive part of the Web enables greater authoring capabilities through hypertext narratives; it also enables the use of the Web for distribution of this interactive content in terms of Java programs to a large audience.
Reference: [3] <author> T. Berners-Lee, R. Cailliau, A. Luotonen, H. F. Nielsen, and A. </author> <title> Secret. The World-Wide Web. </title> <journal> Comm. ACM, </journal> <volume> 37(8) </volume> <pages> 76-82, </pages> <year> 1994. </year>
Reference-contexts: Although HTTP (hypertext transport protocol) is the native protocol of the World Wide Web, Web browsers integrate a large variety of protocols: NNTP (network news), Gopher, WAIS, and FTP (file transfer protocol) are all typically supported <ref> [3] </ref>. We envision that additional, application-specific protocols will become widespread. Examples of such protocols in client-server architectures abound, because of the complex handshaking requirements of such systems. Indeed, DCE, CORBA, and various transaction monitors are responses to the mounting difficulties of maintaining interoperability with so many protocols [19, 24].
Reference: [4] <author> P. Bose, G. Di Battista, W. Lenhart, and G. Liotta. </author> <title> Proximity constraints and representable trees. </title> <editor> In R. Tamassia and I. G. Tollis, editors, </editor> <booktitle> Graph Drawing (Proc. GD '94), volume 894 of Lecture Notes in Computer Science, </booktitle> <pages> pages 340-351. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: An advanced interaction technique allows the user to define the value of fi by sliding a cursor along a logarithmic-scale ruler. The following values of fi, which are of special interest in the theory of proximity graphs (e.g. see <ref> [5, 4] </ref>), are 11 (a) (b) explicitly highlighted below the ruler and cause the cursor to "snap" when dragged near them: fi = 3 1cos ( 2 , and fi = 1 5 ) Other interesting features that are naturally supported by the Mocha architecture, but not demonstrated in this paper,
Reference: [5] <author> P. Bose, W. Lenhart, and G. Liotta. </author> <title> Characterizing proximity trees. </title> <journal> Algorithmica. </journal> <note> (special issue on Graph Drawing, </note> <author> edited by G. Di Battista and R. Tamassia, </author> <note> to appear). </note>
Reference-contexts: An advanced interaction technique allows the user to define the value of fi by sliding a cursor along a logarithmic-scale ruler. The following values of fi, which are of special interest in the theory of proximity graphs (e.g. see <ref> [5, 4] </ref>), are 11 (a) (b) explicitly highlighted below the ruler and cause the cursor to "snap" when dragged near them: fi = 3 1cos ( 2 , and fi = 1 5 ) Other interesting features that are naturally supported by the Mocha architecture, but not demonstrated in this paper,
Reference: [6] <author> M. Brown, J. Domingue, B. Price, and J. Stasko. </author> <title> Software visualization. </title> <booktitle> In Proc. ACM Conf. on Human Factors in Computing Systems, </booktitle> <volume> volume 2, </volume> <pages> page 463, </pages> <year> 1994. </year>
Reference: [7] <author> M. H. Brown. </author> <title> Algorithm Animation. </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1988. </year>
Reference-contexts: of Mocha are given in Section 4. 2 Models for Algorithm Animation on the Internet In this section, we examine the currently used mechanisms for providing algorithm animation over the Internet, and present our new architecture. 2.1 Components of an Algorithm Animation System Following the event-driven approach advocated by Brown <ref> [7] </ref> and the conceptual framework pioneered by Stasko [39, 37, 38], we view algorithm animation as an event driven system of communicating processes: the algorithm augmented with annotations of interesting events, called algorithm operations, and the animation component that provides the multimedia visualization of the the algorithm operations. <p> The three main functional components of the animation system (GUI, animator, and algorithm) reside on the user's machine and receive their Java code and multimedia objects from a server on the provider's machine. All communication is performed with the HTTP protocol. A sorting animation (inspired by Balsa <ref> [7] </ref>) that uses the Java model is shown in Figure 2 (b). Thanks to its built-in features, the Java model provides a high level of security for both the user and the provider. <p> By using MVC we can ensure the correspondence of each view to the model without increasing the complexity of the design (at least beyond the design's initial incorporation of MVC). The importance of this for algorithm animation was introduced by BALSA <ref> [7] </ref>. Mocha extends this conventional use of MVC by partitioning both the model and the controller between the client and the server. <p> Arbitrary attributes and annotations of these objects require a flexible way of describing the signatures of these objects. For example, a node might have a position, color and weight with one algorithm, but this is not applicable to another. Animation events. These correspond to the "interesting" events of BALSA <ref> [7] </ref>, as amplified by TANGO [39, 37] to describe them: images, locations, transitions, and paths. The main limitations of the current prototype is that the signatures of geometric objects are fixed.
Reference: [8] <author> M. H. Brown. ZEUS: </author> <title> A System for Algorithm Animation and Multi-View Editing. </title> <booktitle> In IEEE Symposium on Visual Languages (VL '91), </booktitle> <pages> pages 4-9, </pages> <year> 1992. </year> <note> Also available from http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-075.html. </note>
Reference: [9] <author> M. H. Brown and J. Hershberger. </author> <title> Color and sound in algorithm animation. </title> <journal> IEEE Computer, </journal> <volume> 25(12) </volume> <pages> 52-63, </pages> <year> 1992. </year>
Reference: [10] <author> M. H. Brown and M. A. Najork. </author> <title> Algorithm animation using 3D interactive graphics. </title> <booktitle> In Proc. ACM Symp. on User Interface Software and Technology, </booktitle> <pages> pages 93-100, </pages> <year> 1993. </year>
Reference-contexts: There are many technical challenges in doing algorithm animation. For example, the development of a conceptual framework to modularize and simplify the animation design process (part of the authoring process), for which Stasko proposes the path-transition paradigm [37], 3D visualization <ref> [10, 34, 32] </ref>, and automatic graph layout [12]. Another challenge, which extends beyond algorithm animation, is the visualization of large sets of data [26]. There is a strong pedagogical interest associated with algorithm animation, which can be used by students individually or in class demonstrations [36, 43].
Reference: [11] <author> M. H. Brown and R. Sedgewick. </author> <title> Techniques for algorithm animation. </title> <journal> IEEE Software, </journal> <volume> 2(1) </volume> <pages> 28-39, </pages> <year> 1985. </year>
Reference: [12] <author> G. Di Battista, P. Eades, R. Tamassia, and I. G. Tollis. </author> <title> Algorithms for drawing graphs: an annotated bibliography. </title> <journal> Comput. Geom. Theory Appl., </journal> <volume> 4 </volume> <pages> 235-282, </pages> <year> 1994. </year>
Reference-contexts: There are many technical challenges in doing algorithm animation. For example, the development of a conceptual framework to modularize and simplify the animation design process (part of the authoring process), for which Stasko proposes the path-transition paradigm [37], 3D visualization [10, 34, 32], and automatic graph layout <ref> [12] </ref>. Another challenge, which extends beyond algorithm animation, is the visualization of large sets of data [26]. There is a strong pedagogical interest associated with algorithm animation, which can be used by students individually or in class demonstrations [36, 43]. <p> The animated algorithms solve problems of computational geometry and graph drawing. For an overview of these two fields the reader is referred to [30] and to <ref> [12] </ref>. In what follows, we will call our algorithm animation system Geometry Server or GS for brevity. Geometric algorithms have interesting characteristics.
Reference: [13] <author> G. Di Battista, W. Lenhart, and G. Liotta. </author> <title> Proximity drawability: a survey. </title> <editor> In R. Tamassia and I. G. Tollis, editors, </editor> <booktitle> Graph Drawing (Proc. GD '94), volume 894 of Lecture Notes in Computer Science, </booktitle> <pages> pages 328-339. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Figure 7 (a) shows a set S of points, Figure 7 (b) the corresponding Gabriel graph, and Figure 7 (c) its relative neighborhood graph. For a survey on proximity graphs and on their applications to graph drawing see [21] and <ref> [13] </ref>. The Proximity Server of GS can generate infinitely many proximity graphs on a given set S. The user, through the canvas of the hypertextual interface, specifies both the set S and a nonnegative parameter fi. This parameter unambiguously defines the shape of the proximity region, called the fi-region.
Reference: [14] <author> J. Domingue, B. A. Price, and M. </author> <title> Eisenstadt. A framework for describing and implementing software visualization systems. </title> <booktitle> In Proceedings of Graphics Interface '92, </booktitle> <pages> pages 53-60, </pages> <month> May </month> <year> 1992. </year>
Reference: [15] <author> K. R. Gabriel and R. R. Sokal. </author> <title> A new statistical approach to geographic variation analysis. </title> <journal> Systematic Zoology, </journal> <volume> 18 </volume> <pages> 259-278, </pages> <year> 1969. </year>
Reference-contexts: The points p and q are close if their proximity region is empty, i.e. it does not contain any other point of S. It is the shape of the proximity region that determines the type of graph that results. For example, the Gabriel region <ref> [15] </ref> of p and q is the disk having p and q as antipodal points; the corresponding proximity graph is called Gabriel graph.
Reference: [16] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year>
Reference-contexts: A simple scaling would not produce these numbers; instead the client applet provides for "gravity" near these special points of interest. Other possible input mechanisms would be special grids (hexagonal, octagonal) and coordinate systems (polar) to precisely enter input to observe interesting algorithmic behavior. 4.2 Frameworks Architectural frameworks <ref> [16, 28] </ref> provide for the reusability of the design and implementation of a set of cooperating classes over a given application domain. The advantage that frameworks provide over a monolithic API is that they define the interactions, collaborations, and responsibilities of the components, including the novel parts, in the framework. <p> The mediator is a major component of the animator of the client as well as the server. A protocol describes the set of legal sequences of interactions with an interface <ref> [16] </ref>. The mediator in Mocha thus maps the animation events: user events and algorithm events, between the client and the server, while translating between the model representations.
Reference: [17] <author> S. C. Glassman. </author> <title> A Turbo Environment for Producing Algorithm Animation. </title> <booktitle> In IEEE Symposium on Visual Languages (VL '93), </booktitle> <pages> pages 32-36, </pages> <year> 1993. </year>
Reference: [18] <author> J. Gosling and H. McGilton. </author> <title> The Java language environment: </title> <note> a white paper, 1995. http://java.sun.com/whitePaper/javawhitepaper 1.html. </note>
Reference-contexts: While this mechanism is simple to implement, there are significant security problems associated with remote X sessions, and the communication load placed on the Internet is quite high. The arrival of the HotJava browser [1] and of the Java language <ref> [18] </ref> opens the possibility of embedding interactive applications in HTML documents, which are executed on the user machine after their code has been transferred. <p> Hence, animations with complex dynamic scenes need to transport large amounts of data through the Internet, which makes poor use of the Internet bandwidth and slows down the interaction. 2.4 The Java Model Java <ref> [18] </ref> is an object-oriented language designed to be dynamically redistributable over the Internet, especially in conjunction with the World Wide Web. This is done through the definition of a bytecode that runs on a virtual machine.
Reference: [19] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, </address> <year> 1993. </year>
Reference-contexts: We envision that additional, application-specific protocols will become widespread. Examples of such protocols in client-server architectures abound, because of the complex handshaking requirements of such systems. Indeed, DCE, CORBA, and various transaction monitors are responses to the mounting difficulties of maintaining interoperability with so many protocols <ref> [19, 24] </ref>. However, none of these protocol infrastructures are sufficient for handling more than the semantics of remote procedure calls, possibly with transactions or context. An application-specific protocol is less constrained by these limitations. Animation protocols should support the following: User events.
Reference: [20] <author> S. E. Hudson and J. T. Stasko. </author> <title> Animation Support in a User Interface Toolkit: Flexible, Robust, and Reusable Abstractions. </title> <booktitle> In Proc. UIST, </booktitle> <pages> pages 57-67, </pages> <year> 1993. </year>
Reference: [21] <author> J. W. Jaromczyk and G. T. Toussaint. </author> <title> Relative neighborhood graphs and their relatives. </title> <journal> Proc. IEEE, </journal> <volume> 80(9) </volume> <pages> 1502-1517, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: Figure 7 (a) shows a set S of points, Figure 7 (b) the corresponding Gabriel graph, and Figure 7 (c) its relative neighborhood graph. For a survey on proximity graphs and on their applications to graph drawing see <ref> [21] </ref> and [13]. The Proximity Server of GS can generate infinitely many proximity graphs on a given set S. The user, through the canvas of the hypertextual interface, specifies both the set S and a nonnegative parameter fi.
Reference: [22] <author> D. G. Kirkpatrick and J. D. Radke. </author> <title> A framework for computational morphology. </title> <editor> In G. T. Toussaint, editor, </editor> <booktitle> Computational Geometry, </booktitle> <pages> pages 217-248. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, Netherlands, </address> <year> 1985. </year> <month> 18 </month>
Reference-contexts: The user, through the canvas of the hypertextual interface, specifies both the set S and a nonnegative parameter fi. This parameter unambiguously defines the shape of the proximity region, called the fi-region. For a formal definition of fi-regions see <ref> [22] </ref>. We provide here an intuitive description of them. See Figure 7 (d). For fi = 1 the 1-region of p and q is their Gabriel region.
Reference: [23] <author> G. E. Krasner and S. T. Pope. </author> <title> A cookbook for using the model-view-controller user interface paradigm in Smalltalk-80. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(3) </volume> <pages> 26-49, </pages> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: Mocha is thus both a implementation framework | in terms of support for MVC by animation clients and common mediator code | as well as a design framework for integrating algorithm services. 4.3 The Model-View-Controller Paradigm The Model-View-Controller paradigm <ref> [23] </ref> separates the task of modelling from that of displaying the model (view) and of interacting with the model (controller).
Reference: [24] <author> F. Manola. </author> <title> MetaObject protocol concepts for a RISC object model. </title> <type> Technical Report 0244-12-93-165, </type> <institution> GTE Laboratories, Inc., </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: We envision that additional, application-specific protocols will become widespread. Examples of such protocols in client-server architectures abound, because of the complex handshaking requirements of such systems. Indeed, DCE, CORBA, and various transaction monitors are responses to the mounting difficulties of maintaining interoperability with so many protocols <ref> [19, 24] </ref>. However, none of these protocol infrastructures are sufficient for handling more than the semantics of remote procedure calls, possibly with transactions or context. An application-specific protocol is less constrained by these limitations. Animation protocols should support the following: User events.
Reference: [25] <author> K. Mehlhorn and S. Naher. LEDA: </author> <title> a platform for combinatorial and geometric computing. </title> <journal> CACM, </journal> <volume> 38 </volume> <pages> 96-102, </pages> <year> 1995. </year> <note> http://www.mpi-sb.mpg.de/guide/staff/uhrig/leda.html. </note>
Reference-contexts: On the other hand, the Java model forces the provider to implement in Java all the components of the animation system: GUI, animator, and algorithm. The latter can be particularly disadvantageous since the provider may want to use directly existing algorithm libraries (e.g., LEDA <ref> [25] </ref>). The main drawbacks of the Java model are code protection and accessibility. The user has full access to the Java code; hence, the entire algorithm animation code is given away to the user. <p> Geometric algorithms have interesting characteristics. For example, their representation is in a sense less abstract than that of other combinatorial algorithms, such as sorting, and are close to such applications as geographical databases and computer graphics. 3.1 The LEDA Animation Service LEDA <ref> [25] </ref> is a library of data types and computational geometry algorithms written in C and C++.
Reference: [26] <author> J. Muthukumarasamy and J. T. Stasko. </author> <title> Visualizing Program Executions on Large Data Sets Using Semantic Zooming. </title> <type> Technical Report GIT-GVU-95-02, </type> <institution> Georgia Institute of Technology, </institution> <year> 1995. </year>
Reference-contexts: Another challenge, which extends beyond algorithm animation, is the visualization of large sets of data <ref> [26] </ref>. There is a strong pedagogical interest associated with algorithm animation, which can be used by students individually or in class demonstrations [36, 43]. Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion.
Reference: [27] <author> B. Myers. </author> <title> Taxonomies of visual programming and program visualization. </title> <journal> J. of Visual Languages and Computating, </journal> <volume> 1(1) </volume> <pages> 97-123, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Algorithm animation helps the end-user to understand algorithms by following visually their step-by-step execution, otherwise a complex task if relying on the textual program alone. It is often the case that the animation depicts abstractly <ref> [27] </ref> how the program is executed, by choosing pictures that materialize data otherwise without a specific representation or by displaying certain transitions that do not correspond directly to steps in the algorithm. Also, animation can be used as a debugging tool. <p> Also, animation can be used as a debugging tool. Here, the user is at the same time the algorithm programmer and the animation builder. Extensive work has been done on algorithm animation and program visualization. See, e.g., the survey by Myers <ref> [27] </ref> and [7, 8, 6, 9, 10, 11, 33, 14, 17, 20, 31, 34, 39, 37, 38, 40, 41]. There are many technical challenges in doing algorithm animation.
Reference: [28] <author> O. Nierstraz and T. D. Meijler. </author> <title> Research directions in software composition. </title> <journal> Computing Surveys, </journal> <volume> 27(2), </volume> <year> 1995. </year>
Reference-contexts: A simple scaling would not produce these numbers; instead the client applet provides for "gravity" near these special points of interest. Other possible input mechanisms would be special grids (hexagonal, octagonal) and coordinate systems (polar) to precisely enter input to observe interesting algorithmic behavior. 4.2 Frameworks Architectural frameworks <ref> [16, 28] </ref> provide for the reusability of the design and implementation of a set of cooperating classes over a given application domain. The advantage that frameworks provide over a monolithic API is that they define the interactions, collaborations, and responsibilities of the components, including the novel parts, in the framework. <p> The advantage that frameworks provide over a monolithic API is that they define the interactions, collaborations, and responsibilities of the components, including the novel parts, in the framework. Frameworks thus provide for "generic software architectures" <ref> [28] </ref>. 13 Java provides a GUI framework in terms of its java.awt package and especially the applet class. Users of this GUI framework are constrained to how the framework dispatches events, such as mouse events or repaints.
Reference: [29] <author> Open Software Foundation. </author> <title> Application Environment Specification/Distributed Computing: RPC Volume, revision a edition, 1994. </title> <publisher> Prentice Hall. </publisher>
Reference-contexts: There is some discussion in the graph drawing community to create an open standard appropriate for the needs of geometric objects with arbitrary attributes (as opposed to non-self 15 referential structures, like strings and records which are handled well by current interface definition languages, like DCE IDL <ref> [29] </ref>.) We plan to incorporate these standards to further open Mocha's architecture. Although many classes of interactions are possible, the most useful from the standpoint of algorithm animation are Synchronous. Request-reply. This is the remote procedure call style (RPC) of communication where the client Incremental.
Reference: [30] <author> F. P. Preparata and M. I. Shamos. </author> <title> Computational Geometry: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1985. </year>
Reference-contexts: The animated algorithms solve problems of computational geometry and graph drawing. For an overview of these two fields the reader is referred to <ref> [30] </ref> and to [12]. In what follows, we will call our algorithm animation system Geometry Server or GS for brevity. Geometric algorithms have interesting characteristics.
Reference: [31] <author> S. P. Reiss. </author> <title> Program Visualization: Where We Go from Here. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Algorithms, Software, Architecture, </booktitle> <pages> pages 218-227. </pages> <publisher> Elsevier Science Publishers B.V. (North Holland), </publisher> <year> 1992. </year>
Reference: [32] <author> S. P. Reiss. </author> <title> A Framework for Abstract 3D Visualizations. </title> <booktitle> In IEEE Symposium on Visual Languages (VL '93), </booktitle> <pages> pages 100-107, </pages> <year> 1993. </year>
Reference-contexts: There are many technical challenges in doing algorithm animation. For example, the development of a conceptual framework to modularize and simplify the animation design process (part of the authoring process), for which Stasko proposes the path-transition paradigm [37], 3D visualization <ref> [10, 34, 32] </ref>, and automatic graph layout [12]. Another challenge, which extends beyond algorithm animation, is the visualization of large sets of data [26]. There is a strong pedagogical interest associated with algorithm animation, which can be used by students individually or in class demonstrations [36, 43].
Reference: [33] <author> S. P. Reiss and I. F. Cruz. </author> <title> Practical Software Visualization. </title> <booktitle> In CHI '94 Workshop on Software Visualization, </booktitle> <year> 1994. </year>
Reference: [34] <author> G. G. Robertson, S. K. Card, and J. D. Mackinlay. </author> <title> Information visualization using 3D interactive visualization. </title> <journal> Comm. ACM, </journal> <volume> 36(4) </volume> <pages> 56-71, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: There are many technical challenges in doing algorithm animation. For example, the development of a conceptual framework to modularize and simplify the animation design process (part of the authoring process), for which Stasko proposes the path-transition paradigm [37], 3D visualization <ref> [10, 34, 32] </ref>, and automatic graph layout [12]. Another challenge, which extends beyond algorithm animation, is the visualization of large sets of data [26]. There is a strong pedagogical interest associated with algorithm animation, which can be used by students individually or in class demonstrations [36, 43].
Reference: [35] <author> R. W. Scheifler and J. Gettys. </author> <title> The X window system. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 5(2) </volume> <pages> 79-109, </pages> <year> 1986. </year>
Reference-contexts: Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion. To reach a wide audience, allowing for the animation to occur on the World Wide Web is undoubtedly a interesting prospect. The X Window system <ref> [35] </ref> provides a basic client-server mechanism for algorithm animation over the Internet, which we shall call X model. <p> Accessibility. Users with limited computing resources should be able to access animations of com putationally expensive algorithms. (a) (b) convex hull animation with the X-model. (b) A sorting animation with the Java model. 2.3 The X Model The X Window system <ref> [35] </ref> provides a basic client-server mechanism for algorithm animation over the Internet, which we shall call X model.
Reference: [36] <author> J. Stasko, A. Badre, and C. Lewis. </author> <title> Do algorithm animations assist learning? an empirical study and analysis. </title> <booktitle> In Proc. ACM Conf. on Human Factors in Computing Systems, </booktitle> <pages> pages 61-66, </pages> <year> 1993. </year>
Reference-contexts: Another challenge, which extends beyond algorithm animation, is the visualization of large sets of data [26]. There is a strong pedagogical interest associated with algorithm animation, which can be used by students individually or in class demonstrations <ref> [36, 43] </ref>. Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion. To reach a wide audience, allowing for the animation to occur on the World Wide Web is undoubtedly a interesting prospect.
Reference: [37] <author> J. T. Stasko. </author> <title> The path-transition paradigm: a practical methodology for adding animation to program interfaces. </title> <journal> J. of Visual Languages and Computing, </journal> <volume> 1(3) </volume> <pages> 213-236, </pages> <year> 1990. </year>
Reference-contexts: There are many technical challenges in doing algorithm animation. For example, the development of a conceptual framework to modularize and simplify the animation design process (part of the authoring process), for which Stasko proposes the path-transition paradigm <ref> [37] </ref>, 3D visualization [10, 34, 32], and automatic graph layout [12]. Another challenge, which extends beyond algorithm animation, is the visualization of large sets of data [26]. There is a strong pedagogical interest associated with algorithm animation, which can be used by students individually or in class demonstrations [36, 43]. <p> Models for Algorithm Animation on the Internet In this section, we examine the currently used mechanisms for providing algorithm animation over the Internet, and present our new architecture. 2.1 Components of an Algorithm Animation System Following the event-driven approach advocated by Brown [7] and the conceptual framework pioneered by Stasko <ref> [39, 37, 38] </ref>, we view algorithm animation as an event driven system of communicating processes: the algorithm augmented with annotations of interesting events, called algorithm operations, and the animation component that provides the multimedia visualization of the the algorithm operations. <p> For example, a node might have a position, color and weight with one algorithm, but this is not applicable to another. Animation events. These correspond to the "interesting" events of BALSA [7], as amplified by TANGO <ref> [39, 37] </ref> to describe them: images, locations, transitions, and paths. The main limitations of the current prototype is that the signatures of geometric objects are fixed.
Reference: [38] <author> J. T. Stasko. </author> <title> Simplifying algorithm animation with tango. </title> <booktitle> In Proc. IEEE Workshop on Visual Languages, </booktitle> <pages> pages 1-6, </pages> <year> 1990. </year>
Reference-contexts: Models for Algorithm Animation on the Internet In this section, we examine the currently used mechanisms for providing algorithm animation over the Internet, and present our new architecture. 2.1 Components of an Algorithm Animation System Following the event-driven approach advocated by Brown [7] and the conceptual framework pioneered by Stasko <ref> [39, 37, 38] </ref>, we view algorithm animation as an event driven system of communicating processes: the algorithm augmented with annotations of interesting events, called algorithm operations, and the animation component that provides the multimedia visualization of the the algorithm operations.
Reference: [39] <author> J. T. Stasko. </author> <title> Tango: a framework and system for algorithm animation. </title> <journal> IEEE Computer, </journal> <volume> 23(9) </volume> <pages> 27-39, </pages> <year> 1990. </year> <note> http://www.cc.gatech.edu/gvu/softviz/algoanim/xtango.html. </note>
Reference-contexts: Models for Algorithm Animation on the Internet In this section, we examine the currently used mechanisms for providing algorithm animation over the Internet, and present our new architecture. 2.1 Components of an Algorithm Animation System Following the event-driven approach advocated by Brown [7] and the conceptual framework pioneered by Stasko <ref> [39, 37, 38] </ref>, we view algorithm animation as an event driven system of communicating processes: the algorithm augmented with annotations of interesting events, called algorithm operations, and the animation component that provides the multimedia visualization of the the algorithm operations. <p> For example, this mechanism is used to provide on-line demonstrations of 3 the XTango animation system <ref> [39] </ref>, see Figure 2 (a), where the animation program can be activated by a cgi-bin script launched in a Web browsing session. The X model of algorithm animation is schematically illustrated in Figure 3. <p> For example, a node might have a position, color and weight with one algorithm, but this is not applicable to another. Animation events. These correspond to the "interesting" events of BALSA [7], as amplified by TANGO <ref> [39, 37] </ref> to describe them: images, locations, transitions, and paths. The main limitations of the current prototype is that the signatures of geometric objects are fixed.
Reference: [40] <author> A. Tal and D. Dobkin. </author> <title> Gasp: A system to facilitate animating geometric algorithms. </title> <booktitle> In Proc. 10th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 388-389, </pages> <year> 1994. </year>
Reference: [41] <author> A. Tal and D. P. Dobkin. </author> <title> Visualization of geometric algorithms. </title> <journal> IEEE Trans. on Visualization and Computer Graphics, </journal> <volume> 1, </volume> <year> 1995. </year>
Reference: [42] <author> G. T. Toussaint. </author> <title> The relative neighbourhood graph of a finite planar set. </title> <journal> Pattern Recogn., </journal> <volume> 12 </volume> <pages> 261-268, </pages> <year> 1980. </year>
Reference-contexts: Another example is the lune of p and q, defined as the intersection of two (open) disks whose radius is the distance from p to q, with one disk centered at p and the other at q; the corresponding graph is called the relative neighborhood graph <ref> [42] </ref>. Figure 7 (a) shows a set S of points, Figure 7 (b) the corresponding Gabriel graph, and Figure 7 (c) its relative neighborhood graph. For a survey on proximity graphs and on their applications to graph drawing see [21] and [13].
Reference: [43] <author> A. van Dam. </author> <title> The electronic classroom: Workstations for teaching. </title> <journal> Int. J. of Man-Machine Studies, </journal> <volume> 21(4) </volume> <pages> 353-363, </pages> <year> 1984. </year>
Reference-contexts: Another challenge, which extends beyond algorithm animation, is the visualization of large sets of data [26]. There is a strong pedagogical interest associated with algorithm animation, which can be used by students individually or in class demonstrations <ref> [36, 43] </ref>. Algorithm animation is also a powerful tool to demonstrate new algorithms to others in a intuitive, often appealing fashion. To reach a wide audience, allowing for the animation to occur on the World Wide Web is undoubtedly a interesting prospect.
Reference: [44] <author> G. Wiederhold. </author> <title> Mediation in information systems. </title> <journal> Computing Surveys, </journal> <volume> 27(2), </volume> <year> 1995. </year> <month> 19 </month>
Reference-contexts: However, naive application partitioning can result in high maintenance costs and even a lack of openness if each client-server pair has its own interface. As the number of clients n and the number of servers m expand, the number of potential relationships is of course n fi m. Mediators <ref> [44] </ref> are a well-known mechanism for reducing this interoperability problem.
References-found: 44

