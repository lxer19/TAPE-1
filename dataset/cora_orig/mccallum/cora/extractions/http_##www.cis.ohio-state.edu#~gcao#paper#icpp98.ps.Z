URL: http://www.cis.ohio-state.edu/~gcao/paper/icpp98.ps.Z
Refering-URL: http://www.cis.ohio-state.edu/~gcao/publications.html
Root-URL: 
Email: E-mail: fgcao, singhalg@cis.ohio-state.edu  
Title: On the Impossibility of Min-Process Non-Blocking Checkpointing and An Efficient Checkpointing Algorithm for Mobile Computing Systems  
Author: Guohong Cao and Mukesh Singhal 
Address: Columbus, OH 43210  
Affiliation: Department of Computer and Information Science The Ohio State University  
Date: August 1998 1  
Note: The 27 th International Conference on Parallel Processing (ICPP'98),  
Abstract: Mobile computing raises many new issues, such as lack of stable storage, low bandwidth of wireless channel, high mobility, and limited battery life. These new issues make traditional checkpointing algorithms unsuitable. Prakash and Singhal [14] proposed the first coordinated checkpoint-ing algorithm for mobile computing systems. However, we showed that their algorithm may result in an inconsistency [3]. In this paper, we prove a more general result about coordinated checkpointing: there does not exist a non-blocking algorithm that forces only a minimum number of processes to take their checkpoints. Based on the proof, we propose an efficient algorithm for mobile computing systems, which forces only a minimum number of processes to take checkpoints and dramatically reduces the blocking time during the checkpointing process. Correctness proofs and performance analysis of the algorithm are provided.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Arup Acharya and B.R. Badrinath. </author> <title> Checkpointing Distributed Applications on Mobil Computers. </title> <booktitle> the Third Intl. Conf. on Parallel and Distributed Information Systems, </booktitle> <month> Sep. </month> <year> 1994. </year>
Reference-contexts: Section 4 presents an efficient checkpointing algorithm for mobile computing systems. Performance analysis of the algorithm is provided in Section 5. Section 6 concludes the paper. 2 Preliminaries 2.1 Computation Model A mobile computing system consists of a large number of mobile hosts (M Hs) <ref> [1] </ref> and relatively fewer static hosts called mobile support stations (M SSs). The number of M SSs is denoted by N mss and that of M Hs by N mh with N mh N mss . <p> Therefore, energy conservation and low bandwidth constraints require a checkpointing algorithm to minimize the number of synchronization messages. Due to the vulnerability of mobile computers to catastrophic failures, e.g., loss, theft, or physical damage, the disk storage on an M H cannot be considered to be stable <ref> [1] </ref>. Therefore, we utilize the stable storage at M SSs to store checkpoints of M H s. Then, to take a checkpoint, an M H has to transfer a large amount of data to its local M SS over the wireless link.
Reference: [2] <author> P. Bhagwat and C.E. Perkins. </author> <title> A Mobile Networking System Based on Internet Protocol (IP). </title> <booktitle> USENIX Symp. on Mobile and Location Independent Computing, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: As a result, M SS p needs to first locate M H 2 before it can forward m to M SS q . The cost to locate an M H is referred to as the search cost [11]. Even though many routing protocols <ref> [2, 8] </ref> have been proposed to reduce the search cost, it can still be significant. Therefore, a checkpointing algorithm should try to avoid or reduce the search cost. Energy and bandwidth requirements: The battery of an M H has a limited life.
Reference: [3] <author> G. Cao and M. Singhal. </author> <title> On Consistent Checkpointing in Distributed Systems. </title> <type> OSU Technical Report #OSU-CISRC-9/97-TR44, </type> <year> 1997. </year>
Reference-contexts: Prakash-Singhal algorithm [14] was the first algorithm to combine these two approaches. More specifically, it forces only a minimum number of processes to take checkpoints and does not block the underlying computation during checkpointing. However, we showed that their algorithm may result in an inconsistency <ref> [3] </ref>. In this paper, we prove a more general result about coordinated checkpointing: there does not exist a non-blocking algorithm that forces only a minimum number of processes to take their checkpoints. <p> By using csn and the initiator identification number, they claim that their non-blocking algorithm can avoid inconsistencies and minimize the number of checkpoints during checkpointing. However, we showed that their algorithm may result in an inconsistency <ref> [3] </ref>.
Reference: [4] <author> T. Cormen, C. Leiserson, and R. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: This is essentially the same as finding the transitive closure of the initiator in the dependency tree which is constructed using the dependency vectors. Then, it can be transformed to a matrix multiplication <ref> [4] </ref>. After the proxy M SS finds all the processes that need to take checkpoints, it adds them to the set S f orced and broadcasts S f orced to all M SSs, which are waiting for the result.
Reference: [5] <author> Y. Deng and E.K. Park. </author> <title> Checkpointing and Rollback-Recovery Algorithms in Distributed Systems. </title> <journal> Journal of Systems and Software, </journal> <pages> pages 5971, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: In other words, when a process takes a checkpoint, it asks (by sending checkpoint requests to) all relevant processes to take checkpoints. Therefore, coordinated checkpointing suffers from high overhead associated with the checkpointing process. Much of the previous work <ref> [5, 9, 10] </ref> in coordinated checkpointing has focused on minimizing the number of synchronization messages and the number of checkpoints during the checkpointing process. However, these algorithms (called blocking algorithm) force all relevant processes in the system to block their computations during the checkpointing process. <p> Since the wireless network has low bandwidth, and M Hs have relatively low computation power, a checkpointing algorithm should only force a minimum number of processes to take checkpoints. 2.3 Non-blocking Algorithms Most of the existing coordinated checkpointing algorithms <ref> [5, 10] </ref> rely on the two-phase protocol and save two kinds of checkpoints on the stable storage: tentative and permanent. In the first phase, the initiator takes a tentative checkpoint and forces all relevant processes to take tentative checkpoints. <p> Comparison with other algorithms Table 1 compares our algorithm with two representative approaches for coordinated checkpointing. Koo-Toueg algorithm [10] has the lowest overhead (based on our three parameters) among the blocking algorithms <ref> [5, 9, 10] </ref> which try to minimize the number of synchronization messages and the number of checkpoints during checkpointing. The algorithm in [6] has the lowest overhead (based on our three parameters) among the non-blocking algorithms [6, 15].
Reference: [6] <author> E.N. Elnozahy, D.B. Johnson, and W. Zwaenepoel. </author> <title> The Performance of Consistent Checkpointing. </title> <booktitle> Proc. of the 11th Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 8695, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: Moreover, in mobile computing systems, due to the mobility of M Hs, a message may be routed several times before reaching its destination. Therefore, blocking algorithms may dramatically reduce the performance of these systems <ref> [6] </ref>. Recently, nonblocking algorithms [6, 15] have received considerable attention. In these algorithms, processes need not block during the checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [6, 15] assume that a distinguished initiator decides when to take a checkpoint. <p> Moreover, in mobile computing systems, due to the mobility of M Hs, a message may be routed several times before reaching its destination. Therefore, blocking algorithms may dramatically reduce the performance of these systems [6]. Recently, nonblocking algorithms <ref> [6, 15] </ref> have received considerable attention. In these algorithms, processes need not block during the checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [6, 15] assume that a distinguished initiator decides when to take a checkpoint. <p> Therefore, blocking algorithms may dramatically reduce the performance of these systems [6]. Recently, nonblocking algorithms <ref> [6, 15] </ref> have received considerable attention. In these algorithms, processes need not block during the checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [6, 15] assume that a distinguished initiator decides when to take a checkpoint. Therefore, they suffer from the disadvantages of centralized algorithms, such as poor reliability, bottle neck, etc. Moreover, these algorithms [6, 15] require all processes in the system to take checkpoints during checkpointing, even though many of them may <p> However, these algorithms <ref> [6, 15] </ref> assume that a distinguished initiator decides when to take a checkpoint. Therefore, they suffer from the disadvantages of centralized algorithms, such as poor reliability, bottle neck, etc. Moreover, these algorithms [6, 15] require all processes in the system to take checkpoints during checkpointing, even though many of them may not be necessary. <p> Suppose P 3 processes m1 before it receives the checkpoint request from P 2 . When P 3 receives the checkpoint request from P 2 , it takes a checkpoint (see Figure 1). In this case, m1 becomes an orphan. Most of non-blocking algorithms <ref> [6, 15] </ref> use a Checkpoint Sequence Number (csn) to avoid inconsistencies. In these algorithms, a process is forced to take a checkpoint if it receives a computation message whose csn is greater than its local csn. <p> Koo-Toueg algorithm [10] has the lowest overhead (based on our three parameters) among the blocking algorithms [5, 9, 10] which try to minimize the number of synchronization messages and the number of checkpoints during checkpointing. The algorithm in <ref> [6] </ref> has the lowest overhead (based on our three parameters) among the non-blocking algorithms [6, 15]. We do not compare our algorithm with Prakash-Singhal algorithm since it may result in inconsistencies, and there is no easy solution to fix it without increasing overhead. <p> The algorithm in [6] has the lowest overhead (based on our three parameters) among the non-blocking algorithms <ref> [6, 15] </ref>. We do not compare our algorithm with Prakash-Singhal algorithm since it may result in inconsistencies, and there is no easy solution to fix it without increasing overhead. <p> algorithm, our algorithm avoids the search cost (which is significant) and dramatically reduces the blocking time from Algorithm Blocking time Messages Checkpoints Koo-Toueg [10] N mh fl (4 fl T wireless N mh fl (6 fl C wireless + C search ) M IN +T checkpoint + T search ) <ref> [6] </ref> 0 N mh fl (3 fl C wireless + C search ) M AX Our algorithm 2 fl T static 2C wireless + 3C broadcast + 2N mss fl C static M IN +3N mh fl C wireless 3N mh fl C wireless Table 1: A comparison of performance. <p> N mh fl (4 fl T wireless + T checkpoint + T search ) to 2 fl T static . Besides avoiding the search cost, our algorithm cuts the message overhead by half compared to Koo-Toueg algorithm. Compared to <ref> [6] </ref>, our algorithm avoids the search cost and minimizes the number of checkpoints during checkpointing. Note that there maybe many applications running in a system: some of them have higher reliability requirement, and others do not. Also, different processes run at their own speed. <p> Note that there maybe many applications running in a system: some of them have higher reliability requirement, and others do not. Also, different processes run at their own speed. Then, some processes may need to take checkpoints more frequently than others. However, the algorithm in <ref> [6] </ref> forces all processes in the system to take checkpoints. Thus, our algorithm significantly reduces the message overhead and checkpointing overhead compared to [6]. 6 Conclusions The major contribution of this paper is not just to present an efficient checkpointing algorithm, but to prove a more general result about coordinated checkpointing; <p> Also, different processes run at their own speed. Then, some processes may need to take checkpoints more frequently than others. However, the algorithm in <ref> [6] </ref> forces all processes in the system to take checkpoints. Thus, our algorithm significantly reduces the message overhead and checkpointing overhead compared to [6]. 6 Conclusions The major contribution of this paper is not just to present an efficient checkpointing algorithm, but to prove a more general result about coordinated checkpointing; that is, there does not exist a non-blocking algorithm that forces only a minimum number of processes to take their checkpoints.
Reference: [7] <author> G.H. Forman and J. Zahorjan. </author> <booktitle> The Challenges of Mobile Computing. IEEE Computer, </booktitle> <pages> pages 3847, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Therefore, a checkpointing algorithm should try to avoid or reduce the search cost. Energy and bandwidth requirements: The battery of an M H has a limited life. To save energy, an M H powers down individual components during periods of low activity <ref> [7] </ref>. This strategy is referred to as the doze mode operation. An M H in the doze mode is woken up on receiving a message. Therefore, energy conservation and low bandwidth constraints require a checkpointing algorithm to minimize the number of synchronization messages.
Reference: [8] <author> J. Ioannidis, D. Duchamp, and G.Q. Maguire. </author> <title> Ip-based Protocols for Mobile Internetworking. Pro. </title> <booktitle> of ACM SIGCOMM Symp. on Communication, Architectures and Protocols, </booktitle> <pages> pages 235245, </pages> <month> Sep. </month> <year> 1991. </year>
Reference-contexts: As a result, M SS p needs to first locate M H 2 before it can forward m to M SS q . The cost to locate an M H is referred to as the search cost [11]. Even though many routing protocols <ref> [2, 8] </ref> have been proposed to reduce the search cost, it can still be significant. Therefore, a checkpointing algorithm should try to avoid or reduce the search cost. Energy and bandwidth requirements: The battery of an M H has a limited life. <p> Many routing protocols for the network layer, to handle M H mobility, have been proposed <ref> [8] </ref>. An M H may be disconnected from the network for an arbitrary period of time. At the application level, the check-pointing algorithm may generate a request for the disconnected M H to take a checkpoint. <p> N mh N mss , T wireless T static , C wireless C static , and M AX M IN most of times. In general <ref> [8] </ref>, the local M SS of the source M H is unaware of the current location of the target M H, and will have to search the network, i.e., query all M SSs, to discover the MSS that is local to the target M H.
Reference: [9] <author> J. Kim and T. Park. </author> <title> An Efficient Protocol For Checkpointing Recovery in Distributed Systems. </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: In other words, when a process takes a checkpoint, it asks (by sending checkpoint requests to) all relevant processes to take checkpoints. Therefore, coordinated checkpointing suffers from high overhead associated with the checkpointing process. Much of the previous work <ref> [5, 9, 10] </ref> in coordinated checkpointing has focused on minimizing the number of synchronization messages and the number of checkpoints during the checkpointing process. However, these algorithms (called blocking algorithm) force all relevant processes in the system to block their computations during the checkpointing process. <p> Comparison with other algorithms Table 1 compares our algorithm with two representative approaches for coordinated checkpointing. Koo-Toueg algorithm [10] has the lowest overhead (based on our three parameters) among the blocking algorithms <ref> [5, 9, 10] </ref> which try to minimize the number of synchronization messages and the number of checkpoints during checkpointing. The algorithm in [6] has the lowest overhead (based on our three parameters) among the non-blocking algorithms [6, 15].
Reference: [10] <author> R. Koo and S. Toueg. </author> <title> Checkpointing and Rollback-Recovery for Distributed Systems. </title> <journal> IEEE Trans. on Software Engineering, </journal> <pages> pages 2331, </pages> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: These features make traditional checkpointing algorithms for distributed systems unsuitable for mobile computing systems. Coordinated checkpointing is an attractive approach for transparently adding fault tolerance to distributed applications, since it avoids domino effect <ref> [10] </ref> and minimizes the stable storage requirement. In this approach, the state of each process in the system is periodically saved on the sta ble storage, which is called a checkpoint of the process. <p> A system state is said to be consistent if it contains no orphan message; i.e., a message whose receive event is recorded in the state of the destination process, but its send event is lost <ref> [10, 16] </ref>. In order to record a consistent global checkpoint, processes must synchronize their checkpointing activities. In other words, when a process takes a checkpoint, it asks (by sending checkpoint requests to) all relevant processes to take checkpoints. Therefore, coordinated checkpointing suffers from high overhead associated with the checkpointing process. <p> In other words, when a process takes a checkpoint, it asks (by sending checkpoint requests to) all relevant processes to take checkpoints. Therefore, coordinated checkpointing suffers from high overhead associated with the checkpointing process. Much of the previous work <ref> [5, 9, 10] </ref> in coordinated checkpointing has focused on minimizing the number of synchronization messages and the number of checkpoints during the checkpointing process. However, these algorithms (called blocking algorithm) force all relevant processes in the system to block their computations during the checkpointing process. <p> Since the wireless network has low bandwidth, and M Hs have relatively low computation power, a checkpointing algorithm should only force a minimum number of processes to take checkpoints. 2.3 Non-blocking Algorithms Most of the existing coordinated checkpointing algorithms <ref> [5, 10] </ref> rely on the two-phase protocol and save two kinds of checkpoints on the stable storage: tentative and permanent. In the first phase, the initiator takes a tentative checkpoint and forces all relevant processes to take tentative checkpoints. <p> Each process, which takes a checkpoint, recursively forces its dependent processes to take checkpoints. Koo-Toueg algorithm <ref> [10] </ref> uses this scheme, and it has been proved [10] that this algorithm forces only a minimum number of processes to take checkpoints. In the following, we prove that Koo-Toueg algorithm is a min-process algorithm and a min--process algorithm forces only a minimum number of processes to take checkpoints. <p> Each process, which takes a checkpoint, recursively forces its dependent processes to take checkpoints. Koo-Toueg algorithm <ref> [10] </ref> uses this scheme, and it has been proved [10] that this algorithm forces only a minimum number of processes to take checkpoints. In the following, we prove that Koo-Toueg algorithm is a min-process algorithm and a min--process algorithm forces only a minimum number of processes to take checkpoints. <p> Proposition 2 P p ` j fl j P p i P q =) P p ` i P q Lemma 1 An algorithm forces only a minimum number of processes to take checkpoints if and only if it is a min-process algorithm. Proof. It has been proved <ref> [10] </ref> that Koo-Toueg algorithm forces only a minimum number of processes to take checkpoints; so we only need to prove the following: in [10], when a process P p initiates a new checkpointing and takes a checkpoint C p;i , a process P q takes a checkpoint C q;j associated with <p> Proof. It has been proved <ref> [10] </ref> that Koo-Toueg algorithm forces only a minimum number of processes to take checkpoints; so we only need to prove the following: in [10], when a process P p initiates a new checkpointing and takes a checkpoint C p;i , a process P q takes a checkpoint C q;j associated with C p;i if and only if P q fl j1 Necessity: In [10], when a process P p initiates a new checkpoint C <p> checkpoints; so we only need to prove the following: in <ref> [10] </ref>, when a process P p initiates a new checkpointing and takes a checkpoint C p;i , a process P q takes a checkpoint C q;j associated with C p;i if and only if P q fl j1 Necessity: In [10], when a process P p initiates a new checkpoint C p;i , it recursively asks all dependent processes to take checkpoints. For example, P p asks P k m to take a checkpoint, P k m asks P k m1 to take a checkpoint, and so on. <p> In the worst case, it is 3N mh fl C wireless . Therefore, the total message overhead (worst case) is 2C wireless +3C broadcast + 2N mss fl C static + 3N mh fl C wireless . The number of checkpoints: Similar to Koo-Toueg algorithm <ref> [10] </ref>, our algorithm forces only a minimum number of processes to take checkpoints. Comparison with other algorithms Table 1 compares our algorithm with two representative approaches for coordinated checkpointing. Koo-Toueg algorithm [10] has the lowest overhead (based on our three parameters) among the blocking algorithms [5, 9, 10] which try to <p> The number of checkpoints: Similar to Koo-Toueg algorithm <ref> [10] </ref>, our algorithm forces only a minimum number of processes to take checkpoints. Comparison with other algorithms Table 1 compares our algorithm with two representative approaches for coordinated checkpointing. Koo-Toueg algorithm [10] has the lowest overhead (based on our three parameters) among the blocking algorithms [5, 9, 10] which try to minimize the number of synchronization messages and the number of checkpoints during checkpointing. <p> Comparison with other algorithms Table 1 compares our algorithm with two representative approaches for coordinated checkpointing. Koo-Toueg algorithm [10] has the lowest overhead (based on our three parameters) among the blocking algorithms <ref> [5, 9, 10] </ref> which try to minimize the number of synchronization messages and the number of checkpoints during checkpointing. The algorithm in [6] has the lowest overhead (based on our three parameters) among the non-blocking algorithms [6, 15]. <p> As shown in Table 1, compared to Koo-Toueg algorithm, our algorithm avoids the search cost (which is significant) and dramatically reduces the blocking time from Algorithm Blocking time Messages Checkpoints Koo-Toueg <ref> [10] </ref> N mh fl (4 fl T wireless N mh fl (6 fl C wireless + C search ) M IN +T checkpoint + T search ) [6] 0 N mh fl (3 fl C wireless + C search ) M AX Our algorithm 2 fl T static 2C wireless +
Reference: [11] <author> P. Krishna, N.H. Vaidya, and D.K. Pradhan. </author> <title> Recovery in Distributed Mobile Environments. </title> <booktitle> IEEE Workshop on Advances in Parallel and Distributed System, </booktitle> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: To communicate with M Hs, a conventional distributed system is augmented with mobile support stations (M SSs) that act as access points for the M Hs by wireless networks. The mobility of M Hs raises some new issues <ref> [11] </ref> pertinent to the design of checkpointing algorithms: locating processes that have to take their checkpoints, energy consumption constraints, lack of stable storage in M Hs, and low bandwidth for communication with M Hs. These features make traditional checkpointing algorithms for distributed systems unsuitable for mobile computing systems. <p> As a result, M SS p needs to first locate M H 2 before it can forward m to M SS q . The cost to locate an M H is referred to as the search cost <ref> [11] </ref>. Even though many routing protocols [2, 8] have been proposed to reduce the search cost, it can still be significant. Therefore, a checkpointing algorithm should try to avoid or reduce the search cost. Energy and bandwidth requirements: The battery of an M H has a limited life.
Reference: [12] <author> R. Netzer and J. Xu. </author> <title> Necessary and Sufficient Conditions for Consistent Global Snapshots. </title> <journal> IEEE Trans. on Parallel and Distributed System, </journal> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: Each checkpoint taken by a process is assigned a unique sequence number. The i th (i 0) checkpoint of process P p is assigned a sequence number i and is denoted by C p;i . The i th checkpoint interval <ref> [12] </ref> of process P p denotes all the computation performed between its i th and (i + 1) th checkpoint, including the i th checkpoint but not the (i+1) th checkpoint. 2.2 New Issues in Mobile Computing There are some new issues in mobile computing systems that complicate the design of <p> Therefore, no min-process non-blocking algorithm exists. Corollary 1 No non-blocking algorithm forces only a minimum number of processes to take checkpoints. Proof. The proof directly follows from Lemma 1 and Theorem 1. Remarks Netzer and Xu <ref> [12] </ref> introduced the concept of zigzag paths to define the necessary and sufficient condition for a set of local checkpoints to lie on a consistent checkpoint. Our definition of z-depend captures the essence of zigzag paths.
Reference: [13] <author> R. Prakash and M. Singhal. </author> <title> Maximal Global Snapshot with Concurrent Initiators. </title> <booktitle> Proc. of the Sixth IEEE Symp. on Parallel and Distributed Processing, </booktitle> <pages> pages 344351, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: Otherwise, it asks them to discard their tentative checkpoints. A process, on receiving the message from the proxy M SS, acts accordingly (Techniques to reduce discarded checkpoints can be found in <ref> [13] </ref>). An example: In Figure 4, D i denotes the dependency vector of process P i . When P 1 initiates a checkpointing, the proxy M SS constructs the dependency matrix D, and calculates D 1 fi D= (1 1 1 0 0).
Reference: [14] <author> R. Prakash and M. Singhal. </author> <title> Low-Cost Checkpointing and Failure Recovery in Mobile Computing Systems. </title> <journal> IEEE Trans. on Parallel and Distributed System, </journal> <pages> pages 10351048, </pages> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: If each process can initiate a check-pointing, the network would be flooded with control messages and processes might waste their time taking unnecessary checkpoints. Prakash-Singhal algorithm <ref> [14] </ref> was the first algorithm to combine these two approaches. More specifically, it forces only a minimum number of processes to take checkpoints and does not block the underlying computation during checkpointing. However, we showed that their algorithm may result in an inconsistency [3]. <p> When P 3 receives m1, it takes a checkpoint before processing m1 since the csn appended to m1 is larger than its local csn. This scheme works only when every process in the computation can receive each checkpoint request and then increases its own csn. Since Prakash-Singhal algorithm <ref> [14] </ref> forces only part of processes to take checkpoints, the csn of some processes may be out-of-date, and may not be able to avoid inconsistencies.
Reference: [15] <author> L.M. Silva and J.G. Silva. </author> <title> Global Checkpointing for Distributed Programs. </title> <booktitle> Proc. of the 11th Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 155162, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: Moreover, in mobile computing systems, due to the mobility of M Hs, a message may be routed several times before reaching its destination. Therefore, blocking algorithms may dramatically reduce the performance of these systems [6]. Recently, nonblocking algorithms <ref> [6, 15] </ref> have received considerable attention. In these algorithms, processes need not block during the checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [6, 15] assume that a distinguished initiator decides when to take a checkpoint. <p> Therefore, blocking algorithms may dramatically reduce the performance of these systems [6]. Recently, nonblocking algorithms <ref> [6, 15] </ref> have received considerable attention. In these algorithms, processes need not block during the checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [6, 15] assume that a distinguished initiator decides when to take a checkpoint. Therefore, they suffer from the disadvantages of centralized algorithms, such as poor reliability, bottle neck, etc. Moreover, these algorithms [6, 15] require all processes in the system to take checkpoints during checkpointing, even though many of them may <p> However, these algorithms <ref> [6, 15] </ref> assume that a distinguished initiator decides when to take a checkpoint. Therefore, they suffer from the disadvantages of centralized algorithms, such as poor reliability, bottle neck, etc. Moreover, these algorithms [6, 15] require all processes in the system to take checkpoints during checkpointing, even though many of them may not be necessary. <p> Suppose P 3 processes m1 before it receives the checkpoint request from P 2 . When P 3 receives the checkpoint request from P 2 , it takes a checkpoint (see Figure 1). In this case, m1 becomes an orphan. Most of non-blocking algorithms <ref> [6, 15] </ref> use a Checkpoint Sequence Number (csn) to avoid inconsistencies. In these algorithms, a process is forced to take a checkpoint if it receives a computation message whose csn is greater than its local csn. <p> The algorithm in [6] has the lowest overhead (based on our three parameters) among the non-blocking algorithms <ref> [6, 15] </ref>. We do not compare our algorithm with Prakash-Singhal algorithm since it may result in inconsistencies, and there is no easy solution to fix it without increasing overhead.
Reference: [16] <author> R.E. Strom and S.A. Yemini. </author> <title> Optimistic Recovery In Distributed Systems. </title> <journal> ACM Trans. on Computer Systems, </journal> <pages> pages 204226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: A system state is said to be consistent if it contains no orphan message; i.e., a message whose receive event is recorded in the state of the destination process, but its send event is lost <ref> [10, 16] </ref>. In order to record a consistent global checkpoint, processes must synchronize their checkpointing activities. In other words, when a process takes a checkpoint, it asks (by sending checkpoint requests to) all relevant processes to take checkpoints. Therefore, coordinated checkpointing suffers from high overhead associated with the checkpointing process.
References-found: 16

