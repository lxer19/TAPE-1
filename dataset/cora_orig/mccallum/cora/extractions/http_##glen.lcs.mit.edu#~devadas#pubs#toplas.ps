URL: http://glen.lcs.mit.edu/~devadas/pubs/toplas.ps
Refering-URL: http://glen.lcs.mit.edu/~devadas/pubs/compiler.html
Root-URL: 
Title: Storage Assignment to Decrease Code Size  
Author: Stan Liao Srinivas Devadas Kurt Keutzer Steve Tjiang Albert Wang 
Address: Cambridge, MA 02139-4307 Mountain View, CA 94043-4033  
Affiliation: MIT Department of EECS Synopsys, Inc.  
Abstract: DSP architectures typically provide indirect addressing modes with auto-increment and decrement. In addition, indexing mode is not available, and there are usually few, if any, general-purpose registers. Hence, it is necessary to use address registers and perform address arithmetic to access automatic variables. Subsuming the address arithmetic into auto-increment and auto-decrement modes improves the size of the generated code. In this paper we present a formulation of the problem of optimal storage assignment such that explicit instructions for address arithmetic are minimized. We prove that for the case of a single address register the decision problem is NP-complete. We then generalize the problem to multiple address registers. For both cases heuristic algorithms are given. Our experimental results indicate an improvement of 3% to 20% in code size. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, J. Hopcroft, and J. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: Hence, we will need to develop efficient heuristic algorithms to solve SOA and MWPC for large problems. For small problems, a branch-and-bound procedure is feasible. 3.6 A Heuristic Algorithm for SOA We describe a heuristic algorithm for SOA/MWPC that is similar to Kruskal's maximum spanning tree algorithm <ref> [1] </ref>. The algorithm is greedy in that at each step the edge with the largest weight is selected that does not yield a cycle and does not increase the degree of a node to more than two. The heuristic algorithm is shown in Figure 6.
Reference: [2] <author> A. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: While optimizing compilers have proved effective for general purpose processors, the irregular data-paths and small number of registers found in embedded processors, especially fixed-point DSPs, remain a challenge to compilers. The direct application of conventional code optimization methods (e.g., <ref> [2] </ref>) has thus far been unable to generate code that efficiently uses the features of fixed-point DSP microprocessors.
Reference: [3] <author> G. Araujo, S. Devadas, K. Keutzer, S. Liao, S. Malik, A. Sudarsanam, S. Tjiang, and A. Wang. </author> <booktitle> Challenges in Code Generation for Embedded Processors. </booktitle> <pages> pages 48-64. </pages>
Reference-contexts: Our experiments indicate that, after GOA, between 1/8 and 1/10 of the instructions are address arithmetic instructions. 7 Summary and Ongoing Work The optimization techniques described in this paper are incorporated into our framework for developing compilers for embedded systems <ref> [3] </ref>. A diagram showing the stages of the compiler is shown in Figure 10. We use SUIF [13] as our front-end. Machine-independent optimizations such as global common subexpression elimination is carried out in SUIF.
Reference: [4] <author> D. H. Bartley. </author> <title> Optimizing Stack Frame Accesses for Processors with Restricted Addressing Modes. </title> <journal> Software-Practice and Experience, </journal> <volume> 22(2) </volume> <pages> 101-110, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: We show that the SOA problem is equivalent to a linear graph covering problem of the access graph and that the decision problem for SOA is NP-complete. Bartley was the first to address the SOA problem and presented an approach based on finding a Hamiltonian path on the graph <ref> [4] </ref>. However, his algorithm runs in O (N 3 + L) time, where N is the number of variables and L is the length of the sequence of variable accesses.
Reference: [5] <author> John R. Ellis. </author> <title> A Compiler for VLIW Architectures. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Code generation for irregular data-paths and machines with severely restricted instruction sets, such as those used in DSP and embedded microprocessors, is a problem that has received relatively little attention to date. Previous work <ref> [5, 6, 8, 12] </ref> on VLIW machines, microcode generation and application-specific instruction processors has covered the topic of irregular data paths but restricted 21 addressing and code density has never been their primary concern.
Reference: [6] <author> J. A. Fisher. </author> <title> Trace Scheduling: A Technique for Global Microcode Compaction. </title> <journal> IEEE Trnsactions on Computers, </journal> <volume> C-30(7):478-490, </volume> <year> 1981. </year>
Reference-contexts: Code generation for irregular data-paths and machines with severely restricted instruction sets, such as those used in DSP and embedded microprocessors, is a problem that has received relatively little attention to date. Previous work <ref> [5, 6, 8, 12] </ref> on VLIW machines, microcode generation and application-specific instruction processors has covered the topic of irregular data paths but restricted 21 addressing and code density has never been their primary concern.
Reference: [7] <author> J. G. Ganssle. </author> <title> The Art of Programming Embedded Systems. </title> <address> San Diego, CA: </address> <publisher> Academic Press, Inc., </publisher> <year> 1992. </year>
Reference-contexts: Moreover, designers often devote a significant amount of time to reduce code size so that the code will fit into available ROM; as exceeding on-chip ROM size could require expensive redesign of the entire IC <ref> [7, p. 18] </ref> and even of the whole system. The second trendincreasing software and system complexitymandates the use of high-level languages (HLLs) in order to decrease development costs and time-to-market.
Reference: [8] <author> G. Goossens, J. Rabaey, F. Catthoor, J Vanhoof, R. Jain, H. De Man, and J. Vandewalle. </author> <title> A Computer-Aided Design Methodology for Mapping DSP Algorithms onto Custom Multiprocessor Architectures. </title> <booktitle> In Proceedings of IEEE International Symposium on Circuits and Systems, </booktitle> <pages> pages 924-925, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: Code generation for irregular data-paths and machines with severely restricted instruction sets, such as those used in DSP and embedded microprocessors, is a problem that has received relatively little attention to date. Previous work <ref> [5, 6, 8, 12] </ref> on VLIW machines, microcode generation and application-specific instruction processors has covered the topic of irregular data paths but restricted 21 addressing and code density has never been their primary concern.
Reference: [9] <author> S. Liao, S. Devadas, and K. Keutzer. </author> <title> Code Density Optimization for Embedded DSP Processors Using Data Compression Techniques. </title> <booktitle> In Proceedings of the Chapel Hill Conference on Advanced Research in VLSI, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: Scheduling and register allocation are problems we are currently investigating and will be implemented in the near future.) Object code is then finally obtained through the final phase of code generation and peephole optimization. Code compression on object code <ref> [9] </ref> proves to be effective in further increasing the code density. Code generation for irregular data-paths and machines with severely restricted instruction sets, such as those used in DSP and embedded microprocessors, is a problem that has received relatively little attention to date.
Reference: [10] <author> S. Liao, S. Devadas, K. Keutzer, S. Tjiang, and A. Wang. </author> <title> Code Optimization Techniques for Embedded DSP Microprocessors. </title> <booktitle> In Proceedings of the 32nd Design Automation Conference, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: The SUIF intermediate form is then translated into another intermediate form called TWIF, which is parametrized according to the machine description. 20 It is on this intermediate form that instruction scheduling, offset assignment, and register allocation are performed <ref> [10] </ref>, along with machine-specific data-flow analyses and related optimizations. (At the time of this writing we have only implemented the offset assignment procedure and the final code generation pass. <p> This interaction needs to be taken into account in the scheduling process. The decision to use single static assignment or to merge variables with disjoint life-times affects the cost of offset assignment as well. We are also addressing several other code optimization problems that arise in irregular data-paths <ref> [10] </ref>. Conventional register allocation is not possible for some DSP processors since the number of general-purpose registers available could be very small. Minimizing the number of accumulator spills becomes a relevant optimization problem.
Reference: [11] <author> C. Liem, T. May, and P. Paulin. </author> <title> Instruction-Set Matching and Selection for DSP and ASIP Code Generation. </title> <booktitle> In Proceedings of European Design and Test Conference, </booktitle> <month> March </month> <year> 1994. </year>
Reference-contexts: Previous work [5, 6, 8, 12] on VLIW machines, microcode generation and application-specific instruction processors has covered the topic of irregular data paths but restricted 21 addressing and code density has never been their primary concern. Liem et al. <ref> [11] </ref> presented techniques for generating compact code; however, the benchmark programs were quite small and it is not shown how their techniques perform on larger, more realistic programs. With the increasing use of embedded systems, code generation for them has become very important.
Reference: [12] <author> K. Rimey. </author> <title> A Compiler for Application-Specific signal Processors. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <year> 1989. </year>
Reference-contexts: Code generation for irregular data-paths and machines with severely restricted instruction sets, such as those used in DSP and embedded microprocessors, is a problem that has received relatively little attention to date. Previous work <ref> [5, 6, 8, 12] </ref> on VLIW machines, microcode generation and application-specific instruction processors has covered the topic of irregular data paths but restricted 21 addressing and code density has never been their primary concern.
Reference: [13] <author> R. Wilson, R. French, C. Wilson, S. Amarasinghe, J. Anderson, S. Tjiang, S.-W. Liao, C.-W. Tseng, M. Hall, M. Lam, and J. Hennessy. </author> <title> SUIF: A Parallelizing and Optimizing Research Compiler. </title> <type> Technical Report CSL-TR-94-620, </type> <institution> Stanford University, </institution> <month> May </month> <year> 1994. </year> <month> 23 </month>
Reference-contexts: A diagram showing the stages of the compiler is shown in Figure 10. We use SUIF <ref> [13] </ref> as our front-end. Machine-independent optimizations such as global common subexpression elimination is carried out in SUIF.
References-found: 13

