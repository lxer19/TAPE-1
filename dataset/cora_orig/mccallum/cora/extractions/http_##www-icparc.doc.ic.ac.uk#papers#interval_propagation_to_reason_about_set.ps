URL: http://www-icparc.doc.ic.ac.uk/papers/interval_propagation_to_reason_about_set.ps
Refering-URL: http://www-icparc.doc.ic.ac.uk/papers.html
Root-URL: 
Title: Interval Propagation to Reason about Sets: Definition and Implementation of a Practical Language  
Author: CARMEN GERVET 
Keyword: CSP, finite set domains, relational set constraints, consistency techniques, interval propagation, CLP, constraint programming language.  
Address: London SW7 2AZ, U.K.  
Affiliation: IC-Parc, Imperial College, William Penney Laboratory,  
Note: Constraints, An International Journal,  c 1997 Kluwer Academic Publishers, Boston. Manufactured in The Netherlands.  
Email: c.gervet@doc.ic.ac.uk  
Date: 1, 191-246 (1997)  
Abstract: Local consistency techniques have been introduced in logic programming in order to extend the application domain of logic programming languages. The existing languages based on these techniques consider arithmetic constraints applied to variables ranging over finite integer domains. This makes difficult a natural and concise modelling as well as an efficient solving of a class of N P-complete combinatorial search problems dealing with sets. To overcome these problems, we propose a solution which consists in extending the notion of integer domains to that of set domains (sets of sets). We specify a set domain by an interval whose lower and upper bounds are known sets, ordered by set inclusion. We define the formal and practical framework of a new constraint logic programming language over set domains, called Conjunto. Conjunto comprises the usual set operation symbols ([; "; n), and the set inclusion relation (). Set expressions built using the operation symbols are interpreted as relations (s [ s 1 = s 2 ,...). In addition, Conjunto provides us with a set of constraints called graduated constraints (e.g. the set cardinality) which map sets onto arithmetic terms. This allows us to handle optimization problems by applying a cost function to the quantifiable, i.e., arithmetic, terms which are associated to set terms. The constraint solving in Conjunto is based on local consistency techniques using interval reasoning which are extended to handle set constraints. The main contribution of this paper concerns the formal definition of the language and its design and implementation as a practical language. 
Abstract-found: 1
Intro-found: 1
Reference: <author> P. Baptiste, B. Legeard, and H. Lombardi. </author> <title> Sequence Constraints for Solving Scheduling Problems. </title> <booktitle> In 3rd IFIP working conference, </booktitle> <year> 1994. </year>
Reference-contexts: This is a main drawback of this language when solving set-based combinatorial search problems (e.g. bin packing, set partitioning). However, their later work on constructed terms for multisets and sequences proved to be appropriate for modelling and solving scheduling problems with a reasonable efficiency <ref> (Baptiste et al., 1994, Boucher and Legeard, 1996) </ref>.
Reference: <author> C. Beeri, S. Naqvi, O. Shmueli, and S. Tsur. </author> <title> Set constructors in a logic database language. </title> <journal> In Journal of Logic Programming, </journal> <pages> pages 181-232, </pages> <year> 1991. </year>
Reference-contexts: This means that the satisfaction of the ACI axioms introduces nondeterminism in the unification procedure by deriving disjunctions of a finite number of equalities. In <ref> (Beeri et al., 1991, Jayaraman and Plaisted, 1989) </ref> a term-matching procedure is considered (unification of two sets when one of them contains no variables). This approach reduces significantly the set of unifiers. But term-matching for constructed sets remains an NP-complete problem (Perry et al., 1986, Kapur and Narendran, 1986).
Reference: <author> N. Beldiceanu. </author> <title> Definition of Global Constraints. </title> <type> Internal Report IR-LP-22-30, </type> <institution> ECRC, </institution> <month> Dec </month> <year> 1990. </year>
Reference-contexts: This is not very natural, nor concise. To cope with this problem, two solutions have been proposed. One consists in defining a class of built-in predicates, referred to as global constraints <ref> (Beldiceanu, 1990, Beadiceanu and Contejean, 1994) </ref>, which allow for the concise statement and global solving of a collection of constraints. One way to achieve such a global reasoning is to use operations research techniques in a CLP setting. <p> This requires constraining all the n (n 1) possible pairs (6 per triple [X, Y, Z]: [X,Y], [Y,X], [X,Z], [Z,X], [Y,Z], [Z,Y]) to be pairwise distinct. This approach is sound but far too costly in variables and constraints. A global constraint all_pair_diff has been defined in <ref> (Beldiceanu, 1990, Beldiceanu, 1990a) </ref> to free the user from specifying all the pairwise distinct pairs. If each set of three nodes, describing a triple, can be represented as one variable, then the modelling is simpler and requires less variables. Such a modelling corresponds to a set domain CSP approach.
Reference: <author> N. Beldiceanu. </author> <title> An example of introduction of global constraints in CHIP: Application to block theory problems. </title> <type> Technical Report TR-LP-49, </type> <institution> ECRC, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: This is not very natural, nor concise. To cope with this problem, two solutions have been proposed. One consists in defining a class of built-in predicates, referred to as global constraints <ref> (Beldiceanu, 1990, Beadiceanu and Contejean, 1994) </ref>, which allow for the concise statement and global solving of a collection of constraints. One way to achieve such a global reasoning is to use operations research techniques in a CLP setting. <p> This requires constraining all the n (n 1) possible pairs (6 per triple [X, Y, Z]: [X,Y], [Y,X], [X,Z], [Z,X], [Y,Z], [Z,Y]) to be pairwise distinct. This approach is sound but far too costly in variables and constraints. A global constraint all_pair_diff has been defined in <ref> (Beldiceanu, 1990, Beldiceanu, 1990a) </ref> to free the user from specifying all the pairwise distinct pairs. If each set of three nodes, describing a triple, can be represented as one variable, then the modelling is simpler and requires less variables. Such a modelling corresponds to a set domain CSP approach.
Reference: <author> N. Beldiceanu and E. Contejean. </author> <title> Introducing Global Constraints in CHIP. </title> <booktitle> In Elsevier Science, editor, Mathematical Computation Modelling, volume 20(12), </booktitle> <pages> pages 97-123, </pages> <year> 1994. </year>
Reference: <author> F. </author> <title> Benhamou. Interval Constraint Logic Programming. </title> <editor> In A. Podelski, editor, </editor> <title> Constraint Programming: Basics and Trends. </title> <publisher> LNCS 910, Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: These transformation rules approximate the usual consistency notions. The handling of these rules is done by a relaxation algorithm which resembles the arc-consistency algorithm AC-3 (Mackworth, 1977). This approach prompted the development of the class of CLP (Intervals). A formalization of this approach is given in <ref> (Benhamou, 1995) </ref>. While CLP (Intervals) languages make use of consistency techniques, they do not model CSPs because the solving of a problem modelled in a CLP (Intervals) language searches for the smallest real intervals such that the computations are correct.
Reference: <editor> F. Benhamou, D. MacAllester, and P. Van Hentenryck. </editor> <title> CLP (Intervals) revisited. </title> <booktitle> In ILPS'94, </booktitle> <pages> pages 124-138, </pages> <year> 1994. </year>
Reference-contexts: This algorithm resembles the relaxation algorithm used by CLP (Intervals) systems (Lee and van Emden, 1993) also referred to as fixed point algorithm in <ref> (Ben-hamou et al., 1994, Benhamou, 1995) </ref> All of those can be seen as an adaptation of the AC-3 algorithm (Mackworth, 1977) where domains are specified by intervals. The only difference between the algorithms lies in the inference rules applied.
Reference: <author> G. Birkhoff. </author> <title> Lattice Theory, </title> <booktitle> volume 25 of Colloquium Publications. </booktitle> <publisher> American Mathematical Society, </publisher> <address> Providence, RI, </address> <year> 1967. </year>
Reference-contexts: Basics of powerset lattices Some definitions, properties and results on lattices are necessary to understand the main features of the formal description of the system. These can be found in <ref> (Birkhoff, 1967, Graetzer, 1971, Gierz and Hoffman, 1980) </ref>. The particular lattice we deal with is the powerset lattice. To give an intuitive idea of the subsequent use of these definitions, some examples relating to powerset lattices are given. Readers familiar with these notions can skip this subsection. 2.1.
Reference: <author> E. Boucher and B. Legeard. </author> <title> Fonctions de voisinage progressives et admissibles pour des methodes d'optimisation en PLC sur sequences. </title> <booktitle> In actes du Congres JFPLC'96, </booktitle> <pages> pages 255-270, </pages> <year> 1996. </year>
Reference: <author> P. Bruscoli, A. Dovier, E. Pontelli, and G. Rossi. </author> <title> Compiling Intensional Sets in CLP. </title> <editor> In P. Van Hentenryck, editor, </editor> <booktitle> ICLP'94, </booktitle> <pages> pages 647-664, </pages> <year> 1994. </year>
Reference: <author> B. Carlson, S. Haridi, and S. Janson. </author> <title> AKL(FD) A Concurrent Language for FD Programming. </title>
Reference: <editor> In M. Bruynooghe, editor, </editor> <booktitle> ILPS'94, </booktitle> <pages> pages 521-538, </pages> <year> 1994. </year>
Reference: <author> Y. Caseau and Jean-F. Puget. </author> <title> Constraints on Order-Sorted Domains. </title> <booktitle> In Workshop on constraint processing, in conjunction with ECAI'94, </booktitle> <year> 1994. </year>
Reference-contexts: Discussion and related works Today, the Conjunto solver is available as a library in the ECL i PS e platform, developed at ECRC. Independently of our work, the concept of set domains was briefly introduced in (Puget, 1992) and several set constraints are implemented in the ILOG solver <ref> (Caseau and Puget, 1994, Puget, 1996) </ref>. Detailed comparisons with the ILOG approach are difficult since ILOG solver is an industrial implementation not fully described in the public domain.
Reference: <author> J.G. Cleary. </author> <title> Logical arithmetic. </title> <booktitle> In Future Generation Computing Systems, chapter 2(2), </booktitle> <pages> pages 125-149. </pages> <year> 1987. </year>
Reference-contexts: A real interval is an approximation of a real and is specified by its lower and upper bounds. It does not denote the set of possible values a variable could take but a variation of an infinite number of values. Cleary <ref> (Cleary, 1987) </ref> introduced a relational arithmetic of real intervals into logic programming based on the interpretation of arithmetic expressions as relations. <p> example the n-ary constraint is approximated by the system of constraints: s 1 [ s 2 = s 12 ; s 3 " s 4 = s 34 ; s 12 s 34 This approach is similar to the relational form of arithmetic constraints over real intervals introduced by Cleary <ref> (Cleary, 1987) </ref>. A relation denoting a basic set expression represents a subset of the Cartesian product of the set domains attached to each set variable.
Reference: <author> A. Colmerauer. </author> <title> Opening the prolog III Universe. </title> <journal> In BYTE magazine. </journal> <year> 1987. </year>
Reference-contexts: 1. Introduction and motivation This paper presents a means to tackle set based combinatorial search problems in a Constraint Logic Programming (CLP) framework <ref> (Jaffar and Lassez, 1987, Colmerauer, 1987, Jaffar and Maher, 1994) </ref>. The main contribution of the work is a new language allowing set based constraint satisfaction problems to be modelled and solved in an elegant way using constraint logic programming.
Reference: <author> A. Colmerauer, H. Kanoui, and M. Van Caneghem. </author> <title> Prolog, </title> <journal> bases theoriques et developpements actuels. T.S.I. (Techniques et Sciences Informatiques), </journal> <volume> 2(4) </volume> <pages> 271-311, </pages> <year> 1983. </year>
Reference-contexts: Conjunto is a constraint logic programming language designed and implemented to reason with and about sets ranging over a set domain. Its functionalities (apart from those of a logic-based language like Prolog <ref> (Colmerauer et al., 1983) </ref>) are set operations and relations from set theory together with some graded functions which provide set 216 C. GERVET measures like cardinality, weight, etc. The graded functions map set domains to subsets of the natural numbers (finite domains). <p> This procedure is described together with some programming facilities which enhance the expressive power of the language. 5. Design of Conjunto We describe the functionalities of the Conjunto language and omit a detailed description of the traditional predicates and functions on Prolog terms <ref> (Colmerauer et al., 1983) </ref>. 5.1. Syntax The Conjunto language is a logic-based programming language with the alphabet of a Prolog language (constants, predicates, functions, connectives, etc).
Reference: <author> M. Dincbas, H. Simonis, and P. Van Hentenryck et al. </author> <title> The Constraint Logic Programming Language CHIP. </title> <booktitle> In FGCS, </booktitle> <year> 1988. </year>
Reference-contexts: One use of these techniques in logic programming has aimed at extending a logic-based language with consistency techniques at the language level (Van Hentenryck and Dincbas, 1986). This has led to the first development of a Constraint Logic Programming (CLP) language on finite domains, CHIP <ref> (Dincbas et al., 1988) </ref> (Constraint Handling In Prolog). CHIP extends the application domain of logic programming to the efficient solving of combinatorial search problems. Typical examples are scheduling applications, warehouse location problems, disjunctive scheduling and cutting stock (Dincbas et al., 1988) which are artificial intelligence or operations research problems. <p> first development of a Constraint Logic Programming (CLP) language on finite domains, CHIP <ref> (Dincbas et al., 1988) </ref> (Constraint Handling In Prolog). CHIP extends the application domain of logic programming to the efficient solving of combinatorial search problems. Typical examples are scheduling applications, warehouse location problems, disjunctive scheduling and cutting stock (Dincbas et al., 1988) which are artificial intelligence or operations research problems. The success of CHIP prompted the development of new finite domain CLP languages, classified as CLP (FD) languages (e.g. (Carlson et al., 1994)), but also raised the question of its limitations. <p> This problem has only recently been addressed in computer science. (Beldiceanu, 1990a) addresses this problem for the first time. The approach consists in representing the problem as an integer domain CSP in a constraint logic programming (CHIP <ref> (Dincbas et al., 1988) </ref>), using the new concept of global constraints. The integer domain CSP modelling corresponds to the hypergraph representation: the integer variables represent the nodes and the global constraints represent the hyperarcs. Problem statement The statement is taken from (Beldiceanu, 1990a).
Reference: <author> M. Dincbas, H. Simonis, and P. Van Hentenryck. </author> <title> Solving Large Combinatorial Problems in Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <year> 1988. </year>
Reference-contexts: One use of these techniques in logic programming has aimed at extending a logic-based language with consistency techniques at the language level (Van Hentenryck and Dincbas, 1986). This has led to the first development of a Constraint Logic Programming (CLP) language on finite domains, CHIP <ref> (Dincbas et al., 1988) </ref> (Constraint Handling In Prolog). CHIP extends the application domain of logic programming to the efficient solving of combinatorial search problems. Typical examples are scheduling applications, warehouse location problems, disjunctive scheduling and cutting stock (Dincbas et al., 1988) which are artificial intelligence or operations research problems. <p> first development of a Constraint Logic Programming (CLP) language on finite domains, CHIP <ref> (Dincbas et al., 1988) </ref> (Constraint Handling In Prolog). CHIP extends the application domain of logic programming to the efficient solving of combinatorial search problems. Typical examples are scheduling applications, warehouse location problems, disjunctive scheduling and cutting stock (Dincbas et al., 1988) which are artificial intelligence or operations research problems. The success of CHIP prompted the development of new finite domain CLP languages, classified as CLP (FD) languages (e.g. (Carlson et al., 1994)), but also raised the question of its limitations. <p> This problem has only recently been addressed in computer science. (Beldiceanu, 1990a) addresses this problem for the first time. The approach consists in representing the problem as an integer domain CSP in a constraint logic programming (CHIP <ref> (Dincbas et al., 1988) </ref>), using the new concept of global constraints. The integer domain CSP modelling corresponds to the hypergraph representation: the integer variables represent the nodes and the global constraints represent the hyperarcs. Problem statement The statement is taken from (Beldiceanu, 1990a).
Reference: <author> A. Dovier, E. G. Omodeo, E. Pontelli, and G. Rossi. flogg: </author> <title> A Logic Programming Language with Finite Sets. </title> <booktitle> In ICLP'91, </booktitle> <pages> pages 111-124, </pages> <year> 1991. </year>
Reference-contexts: constructor is specified either by an extensional representation fx 1 ; :::; x n g ((Beeri et al., 1991, Kuper, 1990)) or by an iterative one fxg [ E where E can be unified with a set of terms containing possibly set variables (concept of sets of finite depth in <ref> (Dovier et al., 1991, Legeard and Legros, 1991, Stolzenburg, 1996) </ref>). The equality relation over constructed sets is a particular case of Associative, Commutative and Idempotent (ACI) relation (Livesey and Siekmann, 1976). Each property is usually modelled by a set of axioms.
Reference: <author> A. Dovier and G. Rossi. </author> <title> Embedding Extensional Finite Sets in CLP. </title> <booktitle> In ILPS'93, </booktitle> <year> 1993. </year> <title> ECRC. ECLiPSe (a) user manual, (b) extensions of the user manual. </title> <type> Technical report, </type> <institution> ECRC, </institution> <year> 1994. </year>
Reference-contexts: The complexity of the satisfiability procedure is not given, but infinite computations are avoided thanks to the use of floundering. flogg <ref> (Dovier and Rossi, 1993, Bruscoli et al., 1994) </ref> has been revisited from a LP to a CLP framework in order to provide a uniform framework for the handling of set constraints (2; =; 6=; =2).
Reference: <author> R. E. Fikes. Ref-arf: </author> <title> A system for solving problems stated as procedures. </title> <journal> Artificial Intelligence, </journal> <volume> 1 </volume> <pages> 27-120, </pages> <year> 1970. </year>
Reference-contexts: The main contribution of the work is a new language allowing set based constraint satisfaction problems to be modelled and solved in an elegant way using constraint logic programming. We introduce the notion of set domain following the concept of finite integer domain <ref> (Fikes, 1970) </ref>. The elements of a set domain are known sets containing arbitrary values, and the set domain itself represents a powerset. It is defined as a set interval specified by its lower and upper bounds.
Reference: <author> R. Fraisse. </author> <title> Theory of Relations, </title> <booktitle> volume 118 of Studies in logic and the foundations of mathematics. </booktitle> <publisher> Elsevier Science, </publisher> <year> 1986. </year>
Reference-contexts: Providing relations at the language level extends the expressive power of the language when dealing for example with circuit problems and matching problems originating from Operations research. In relation theory <ref> (Fraisse, 1986) </ref>, a relation R is represented as a set of ordered pairs (x i ; y j ) such that x i belongs to the DS-domain d of R and y j to its AS-range (AS-range stands here for arrival set) a. <p> The schema of these constraints is directly derived from their usual interpretation issued from relation theory <ref> (Fraisse, 1986) </ref>. They are represented below using the mathematical cardinality operation #, the usual set operation symbols ([; ") and the arithmetic inequality ().
Reference: <author> M.R. Garey and D. S. Johnson. </author> <title> Computers and intractability, A guide to the theory of NP-completeness. </title> <editor> Victor Klee, </editor> <year> 1979. </year>
Reference-contexts: This point is illustrated through an integer linear programming optimization problem: the bin packing problem. Problem description Bin packing problems belong to the class of set partitioning problems <ref> (Garey and Johnson, 1979) </ref>. A multiset of n integers fw 1 ; :::; w n g is given INTERVAL PROPAGATION TO REASON ABOUT SETS 239 that specifies the weight elements to partition. Another integer W max is given that represents the weight capacity.
Reference: <author> C. Gervet. </author> <title> New structures of symbolic constraint objects: sets and graphs. </title> <booktitle> In WCLP'93, </booktitle> <year> 1993. </year>
Reference-contexts: This is very inconvenient. Instead, a relation in Conjunto is represented as a specific data structure which is characterized by two ground sets (DS-domain and AS-range) and a list containing the successor sets attached to each element of DS-domain <ref> (Gervet, 1993, Gervet, 1993a) </ref>. Considering one successor set per element splits the domain of a relation into a collection of set domains. The resulting value of a relation is clearly the union of the successor sets.
Reference: <author> C. Gervet. </author> <title> Sets and binary relation variables viewed as constrained objects. </title> <booktitle> In Workshop on Logic Programming with Sets, </booktitle> <month> June </month> <year> 1993. </year> <title> In conjunction with ICLP'93. INTERVAL PROPAGATION TO REASON ABOUT SETS 245 C. Gervet. Conjunto : Constraint Logic Programming with Finite Set Domains. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> ILPS'94, </booktitle> <pages> pages 339-358, </pages> <year> 1994. </year>
Reference-contexts: This is very inconvenient. Instead, a relation in Conjunto is represented as a specific data structure which is characterized by two ground sets (DS-domain and AS-range) and a list containing the successor sets attached to each element of DS-domain <ref> (Gervet, 1993, Gervet, 1993a) </ref>. Considering one successor set per element splits the domain of a relation into a collection of set domains. The resulting value of a relation is clearly the union of the successor sets.
Reference: <author> C. Gervet. </author> <title> Set Intervals in Constraint Logic Programming: Definition and Implementation of a Language. </title> <type> PhD thesis, </type> <institution> Universite de Franche-Comte, France, </institution> <month> September </month> <year> 1995. </year> <note> European thesis, in English. </note>
Reference-contexts: They consist of a collection of constraints defined from the primitive ones, some predicates necessary to access information related to the variable domains, and a built-in set labelling procedure. The most important ones are presented below, others are described in <ref> (Gervet, 1995) </ref>. 5.4.1. Set domain access Set domains are represented as abstract data types, and the users are not supposed to access them directly. So two predicates are provided to allow operations on set domains : glb (s; s glb ) and lub (s; s lub ). <p> The main operations amount to checking disjointness and/or inclusion of sets and to computing cliques over the successor set domains. This is achieved in a very natural manner using Conjunto (for a full description of the modelling see <ref> (Gervet, 1995) </ref>). Problem solving One important strength of solvers based on constraint propagation techniques is their dynamic behaviour thanks to the delay mechanism. In particular, once the simplification rules have been applied, their ripple effects on the set of constraints allows to dynamically reduce the problem size.
Reference: <author> G. Gierz and K.H. Hoffman et al. </author> <title> A Compendium of Continuous Lattices. </title> <publisher> Springer Verlag, </publisher> <address> Berlin Heidelberg New York, </address> <year> 1980. </year>
Reference: <author> M. Gondran and M. Minoux. </author> <title> Graphs and algorithms. Series in Discrete Mathematics. </title> <publisher> Wiley-interscience, </publisher> <year> 1984. </year>
Reference-contexts: Consequently, set constraints resemble some global constraints in terms of problem solving and pruning ability, but to cope with this actual symmetries of the problem a global reasoning on sets is necessary. 7.1.2. The set partitioning problem The set partitioning problem <ref> (Gondran and Minoux, 1984) </ref> is an optimization problem that comes from operations research. Consider a mapping from a set of elements to a collection of equivalence classes each of which contains a subset of these elements, and has a specific cost.
Reference: <author> G. Graetzer. </author> <title> LATTICE THEORY: first concepts and distributive lattices. W.H. </title> <publisher> Freeman and company, </publisher> <year> 1971. </year>
Reference-contexts: The following property establishes a link between and the pair ( V W ) as actual meet and join. Property 1 (Consistency property) Let S be a poset. Then for all x; y 2 S, x y , x = (fx; yg) W Proposition 2 <ref> (Graetzer, 1971) </ref> The following definitions are equivalent: (i) A poset is a lattice iff every finite subset has a meet and a join. (ii) A poset S is a lattice iff every two elements have a meet and a join.
Reference: <author> N. Guerinik and M. Van Caneghem. </author> <title> Solving Crew Scheduling Problems by Constraint Programming. </title> <booktitle> In CP'95, Lecture notes in Computer Science, </booktitle> <year> 1995. </year>
Reference: <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. Logic Programming Series. </title> <publisher> The MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Up to now, the class of CLP (FD) languages are defined as constraint logic programming languages, but their formal definition is still based on the formal framework defined by Van Hentenryck that is, embedding consistency techniques in logic programming <ref> (Van Hentenryck, 1989) </ref>. The formal description of the Conjunto language can be used to give a formal definition of the class of CLP languages which embed consistency techniques as main constraint solving techniques. We believe that some further research on applications and algorithms is needed.
Reference: <author> P. Van Hentenryck, Y. Deville, and C.-M. Teng. </author> <title> A generic arc-consistency algorithm and its specializations. </title> <journal> Artificial Intelligence, </journal> <volume> 57 </volume> <pages> 291-321, </pages> <year> 1992. </year>
Reference-contexts: On the one hand, the flexibility and conciseness of the Conjunto approach is a strength compared with existing mathematical models. On the other hand, constraint propagation techniques are not competitive when compared with global methods like the simplex (e.g. in <ref> (Hoffmann and Padberg, 1992, Guerinik and Van Caneghem, 1995) </ref>). While completing this work, it appeared to us that the set domain CSP approach is promising when investigating feasibility issues that are problematic with the simplex method. <p> However, personal communications with Jean-Fran~cois Puget indicate that the two approaches are similar but differ on one main point: the generic algorithm used to handle set constraints. ILOG solver uses AC-5 <ref> (Van Hentenryck et al., 1992) </ref> whereas we make use of propagation methods based on the AC-3 algorithm (Mackworth, 1977). A related line of work concerns the class of CLP (Sets) languages, that we have presented in the introduction (Walinski, 1989, Dovier and Rossi, 1993, Bruscoli et al., 1994).
Reference: <author> P. Van Hentenryck and M. Dincbas. </author> <title> Domains in Logic Programming. </title> <booktitle> In AAAI-86, </booktitle> <year> 1986. </year>
Reference-contexts: Constraint satisfaction using CLP Logic programming (Kowalski, 1974, Colmerauer et al., 1983, Lloyd, 1987) is a powerful programming framework which enables the user to state nondeterministic programs in relational form. Some ten years ago, the concept of finite domain variables <ref> (Van Hentenryck and Dincbas, 1986) </ref> i.e., variables ranging over a set of natural numbers, has been embedded into logic programming to allow for efficient tackling of combinatorial search problems modelled as Constraint Satisfaction Problems (CSPs)(Mackworth, 1977). <p> These are constraint propagation techniques aiming at pruning the search space, associated to a CSP, by removing values that can never be part of any feasible solution. One use of these techniques in logic programming has aimed at extending a logic-based language with consistency techniques at the language level <ref> (Van Hentenryck and Dincbas, 1986) </ref>. This has led to the first development of a Constraint Logic Programming (CLP) language on finite domains, CHIP (Dincbas et al., 1988) (Constraint Handling In Prolog). CHIP extends the application domain of logic programming to the efficient solving of combinatorial search problems.
Reference: <author> M. Hibti. Decidabilite et complexite de systemes de constraintes ensemblistes. </author> <type> PhD thesis, </type> <institution> Universite de Franche-Comte, Besan~con, </institution> <year> 1995. </year> <note> In French. </note>
Reference: <author> K. L. Hoffman and M. Padberg. </author> <title> Solving Airline Crew-Scheduling Problems by Branch-and-Cut. </title> <type> Technical Report 376, </type> <institution> George Mason and New York University, </institution> <year> 1992. </year>
Reference-contexts: Note that columns 1 and 3 in the ILP modelling correspond here to one equivalence class f1; 2; 3g. The search space associated to these problems is usually very large and simplification rules are applied in order to reduce the initial problem size (e.g. in <ref> (Hoffman and Padberg, 1992, Padberg, 1979) </ref>). They consist in removing rows and columns in the adjacency matrix formulation. This corresponds to removing, in a deterministic manner, redundant sets from the successor set domains, and to bounding some successor sets to the same variable. <p> Computation results A set partitioning problem describing a 0-1 matrix of size 17x197 was implemented using the approach presented here. The complete program takes 200 lines of Conjunto code. The problem was taken from the <ref> (Hoffman and Padberg, 1992) </ref> library. The heuristics led to a simplified problem within 7 seconds and the optimal solution was found within 13 seconds on a Sun4/40. The proof of optimality required 31 additional seconds. (Hoffman and Padberg, 1992) make use of the simplex method combined with a tailored branch and <p> The problem was taken from the <ref> (Hoffman and Padberg, 1992) </ref> library. The heuristics led to a simplified problem within 7 seconds and the optimal solution was found within 13 seconds on a Sun4/40. The proof of optimality required 31 additional seconds. (Hoffman and Padberg, 1992) make use of the simplex method combined with a tailored branch and cut search to tackle set partitioning problems (crew scheduling problems). The optimum solution to the 17x197 problem is found in 0.06 seconds on a VAX 8800. <p> On the one hand, the flexibility and conciseness of the Conjunto approach is a strength compared with existing mathematical models. On the other hand, constraint propagation techniques are not competitive when compared with global methods like the simplex (e.g. in <ref> (Hoffmann and Padberg, 1992, Guerinik and Van Caneghem, 1995) </ref>). While completing this work, it appeared to us that the set domain CSP approach is promising when investigating feasibility issues that are problematic with the simplex method.
Reference: <author> C. Holzbaur. </author> <title> Metastructures vs. Attributed Variables in the Context of Extensible Unification. </title> <booktitle> In PLILP'92, </booktitle> <pages> pages 260-268, </pages> <year> 1992. </year>
Reference: <author> S. Le Huitouze. </author> <title> A New Datastructure for Implementing Extensions to Prolog. </title> <booktitle> In 2nd Int. Work. Programming Languages Implementation and Logic Programming, </booktitle> <volume> LNCS 456, </volume> <pages> pages 136-150, </pages> <year> 1990. </year>
Reference-contexts: The main features provided at the language level comprise the attributed variable data structure and the suspension handling predicates. An attributed variable is a special data type <ref> (Le Huitouze, 1990, Holzbaur, 1992) </ref> which consists of a variable with a set of attributes attached and whose behaviour on unification can be explicitly defined by the user in a way that differs from Prolog unification. Attributed variables aim at dealing with specific computation domains distinct from the Herbrand universe.
Reference: <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 111-119, </pages> <year> 1987. </year>
Reference-contexts: 1. Introduction and motivation This paper presents a means to tackle set based combinatorial search problems in a Constraint Logic Programming (CLP) framework <ref> (Jaffar and Lassez, 1987, Colmerauer, 1987, Jaffar and Maher, 1994) </ref>. The main contribution of the work is a new language allowing set based constraint satisfaction problems to be modelled and solved in an elegant way using constraint logic programming. <p> Unfortunately they are very inefficient in time complexity results. Recently, some alternative approaches have focused on embedding constructed sets in constraint logic programming. CLP languages dealing with sets, CLP (Sets), are defined as instances of the CLP scheme <ref> (Jaffar and Lassez, 1987) </ref> over a specific computation domain describing the class of allowed set expressions and set constructors. These CLP (Sets) languages provide a sound and complete solver.
Reference: <author> J. Jaffar and M. J. Maher. </author> <title> Constraint Logic Programming: a Survey. </title> <booktitle> In Journal of Logic Programming, chapter 19(20), </booktitle> <pages> pages 503-581. </pages> <year> 1994. </year>
Reference-contexts: A CLP system is parameterized by its computation domain and more generally by its constraint domain <ref> (Jaffar and Maher, 1994) </ref>. The computation domain is the algebraic structure over which constraints are applied to set variables and the constraint domain is the algebraic structure over which consistency techniques are performed in terms of set interval reasoning. A clear distinction should be made between them.
Reference: <author> B. Jayaraman and D.A. Plaisted. </author> <title> Programming with Equations, Subsets, and Relations. </title> <editor> In Lusk and Overbeek, editors, </editor> <booktitle> Proceedings of the North American Conference, </booktitle> <pages> pages 1051-1068. </pages> <booktitle> Logic Programming, </booktitle> <year> 1989. </year>
Reference: <author> D. Kapur and P. Narendran. </author> <title> Np-completeness of the set unification and matching problems. </title> <booktitle> In CADE, </booktitle> <pages> pages 489-495, </pages> <year> 1986. </year>
Reference-contexts: In (Beeri et al., 1991, Jayaraman and Plaisted, 1989) a term-matching procedure is considered (unification of two sets when one of them contains no variables). This approach reduces significantly the set of unifiers. But term-matching for constructed sets remains an NP-complete problem <ref> (Perry et al., 1986, Kapur and Narendran, 1986) </ref>. Indeed, if fx 1 ; :::; x n g = f1; :::; mg (m &lt; n) there are at most 2 nm computable solutions. These approaches allow for a high level of abstraction when representing collections of terms.
Reference: <author> R.A. Kowalski. </author> <title> Predicate Logic as a Programming Language. </title> <booktitle> IFIP, </booktitle> <pages> pages 569-574, </pages> <year> 1974. </year>
Reference-contexts: Closely related to our work are the notions of finite domains, sets and intervals embedded in a 192 C. GERVET constraint logic programming framework. These notions presented hereafter come from various backgrounds and were originally meant for different purposes. 1.1. Constraint satisfaction using CLP Logic programming <ref> (Kowalski, 1974, Colmerauer et al., 1983, Lloyd, 1987) </ref> is a powerful programming framework which enables the user to state nondeterministic programs in relational form.
Reference: <author> G. Kuper. </author> <title> Logic Programming with Sets, </title> <booktitle> volume 41 of 1, </booktitle> <pages> pages 44-64. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference: <author> J. L. Lauriere. </author> <title> A Language and a Program for Stating and Solving Combinatorial Problems. </title> <journal> Artificial Intelligence, </journal> <volume> 10 </volume> <pages> 29-127, </pages> <year> 1978. </year>
Reference-contexts: Considering one successor set per element splits the domain of a relation into a collection of set domains. The resulting value of a relation is clearly the union of the successor sets. This approach is close to the one introduced in the seminal work ALICE <ref> (Lauriere, 1978) </ref> which dealt essentially with functions. However in ALICE there is no explicit notion of set domain. Definition 36 Let a relation be r d fi a.
Reference: <author> J.H.M. Lee and H. van Emden. </author> <title> Interval Computation as Deduction in CHIP. </title> <journal> In Journal of Logic Programming, </journal> <volume> chapter vol 16. numb. </volume> <pages> 3-4, pages 255-276. </pages> <publisher> Elsevier, </publisher> <year> 1993. </year>
Reference-contexts: An inconsistency is detected if one of the inference rules I7 or I10 is successfully applied which means a failure is encountered in one (integer, set) domain. This algorithm resembles the relaxation algorithm used by CLP (Intervals) systems <ref> (Lee and van Emden, 1993) </ref> also referred to as fixed point algorithm in (Ben-hamou et al., 1994, Benhamou, 1995) All of those can be seen as an adaptation of the AC-3 algorithm (Mackworth, 1977) where domains are specified by intervals.
Reference: <author> B. Legeard and E. Legros. </author> <title> Short overview of the CLPS System. </title> <booktitle> In Proceedings of PLILP'91, 1991. 3rd International Symposium on Programming Language Implementation and Logic Programming. </booktitle>
Reference-contexts: constructor is specified either by an extensional representation fx 1 ; :::; x n g ((Beeri et al., 1991, Kuper, 1990)) or by an iterative one fxg [ E where E can be unified with a set of terms containing possibly set variables (concept of sets of finite depth in <ref> (Dovier et al., 1991, Legeard and Legros, 1991, Stolzenburg, 1996) </ref>). The equality relation over constructed sets is a particular case of Associative, Commutative and Idempotent (ACI) relation (Livesey and Siekmann, 1976). Each property is usually modelled by a set of axioms. <p> This leads to a hidden exponential growth in the search tree. In this approach, completeness of the solver is required if one aims at performing theorem proving. Thus, there is no possible compromise here between completeness and efficiency. CLPS <ref> (Legeard and Legros, 1991, Legeard and Legros, 1992) </ref> aims at prototyp-ing combinatorial problems using sets, multisets and sequences.
Reference: <author> B. Legeard and E. Legros. </author> <title> Test de satisfaisabilite dans le langage de programmation en logique avec contraintes ensemblistes: </title> <booktitle> CLPS. In Actes des JFPL, </booktitle> <year> 1992. </year>
Reference: <author> C.C. Lindner and A. Rosa. </author> <title> Topics on Steiner Systems, </title> <booktitle> volume 7 of Annals of Discrete Mathematics. </booktitle> <publisher> North Holland, </publisher> <year> 1980. </year>
Reference-contexts: The mathematical properties of this problem prove that n modulo 6 has to be equal to 1 or 3 <ref> (Lindner and Rosa, 1980) </ref>.
Reference: <author> M. Livesey and J. Siekmann. </author> <title> Unification of Sets and Multisets. </title> <institution> Memo seki-76-ii, University of St. Andrews (Scotland) and Universit^at Karlsruhe (Germany) Department of Computer Science, </institution> <year> 1976. </year>
Reference-contexts: The equality relation over constructed sets is a particular case of Associative, Commutative and Idempotent (ACI) relation <ref> (Livesey and Siekmann, 1976) </ref>. Each property is usually modelled by a set of axioms.
Reference: <author> J.W. Lloyd. </author> <title> Foundations of logic programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Definition 27 <ref> (Lloyd, 1987) </ref> An atomic formula (or atom) is defined as follows: If p is an n-ary predicate and t 1 ; :::; t n are terms, then p (t 1 ; :::; t n ) is an atom.
Reference: <author> H. Lueneburg. </author> <title> Tools and fundamental Constructions of Combinatorial Mathematics. </title> <address> Wis-senschaftverlag, </address> <year> 1989. </year>
Reference-contexts: The optimization process will then constrain the integer variable appearing in the graduated constraint to have its value in a new domain whose upper bound is lower than the cost previously computed. 7.1. Modelling facilities The two problems presented hereafter come from the areas of combinatorial mathematics <ref> (Lueneburg, 1989) </ref> and operations research. The first one |the ternary Steiner problem| is to find a specific hypergraph whose nodes are integer variables. Our approach illustrates how an hypergraph whose nodes are integer variables can be modelled as a simple graph whose nodes are set variables.
Reference: <author> A. K. Mackworth. </author> <title> Consistency in networks of relations. </title> <journal> Artificial Intelligence, </journal> <note> 1977. 246 C. </note> <author> GERVET A. K. Mackworth and E. C. Freuder. </author> <title> The complexity of some polynomial network consistency algorithms for constraint satisfaction problems. </title> <journal> Artificial Intelligence, </journal> <volume> 25, </volume> <year> 1985. </year>
Reference-contexts: It is defined as a set interval specified by its lower and upper bounds. The constraints of the language are built-in relations applied to variables ranging over set domains. The solver is based on an extension of consistency techniques <ref> (Mackworth, 1977, Mackworth and Freuder, 1985) </ref> |originating in artificial intelligence| to deal with set constraints. Closely related to our work are the notions of finite domains, sets and intervals embedded in a 192 C. GERVET constraint logic programming framework. <p> One of the distinctive features of CLPS is to allow set elements to range over integer domains. When set elements are finite domain varaibles, the satisfiability problem of constructed sets is tackled by an arc-consistency algorithm of type AC-3 <ref> (Mackworth, 1977) </ref> combined with a local search procedure (forward checking). A system of set constraints where each set element ranges over a finite domain is consistent if each of the set constraints it contains is locally consistent. <p> These transformation rules approximate the usual consistency notions. The handling of these rules is done by a relaxation algorithm which resembles the arc-consistency algorithm AC-3 <ref> (Mackworth, 1977) </ref>. This approach prompted the development of the class of CLP (Intervals). A formalization of this approach is given in (Benhamou, 1995). <p> Consistency notions The standard notions of consistency <ref> (Mackworth, 1977) </ref> applied to integer domains state conditions that must be satisfied by each element belonging to a variable domain. <p> This algorithm resembles the relaxation algorithm used by CLP (Intervals) systems (Lee and van Emden, 1993) also referred to as fixed point algorithm in (Ben-hamou et al., 1994, Benhamou, 1995) All of those can be seen as an adaptation of the AC-3 algorithm <ref> (Mackworth, 1977) </ref> where domains are specified by intervals. The only difference between the algorithms lies in the inference rules applied. The generic algorithm satisfies the following properties of fixed point algorithms : termination, existence of a unique fixed point independent of the constraint ordering, and correctness. <p> However, personal communications with Jean-Fran~cois Puget indicate that the two approaches are similar but differ on one main point: the generic algorithm used to handle set constraints. ILOG solver uses AC-5 (Van Hentenryck et al., 1992) whereas we make use of propagation methods based on the AC-3 algorithm <ref> (Mackworth, 1977) </ref>. A related line of work concerns the class of CLP (Sets) languages, that we have presented in the introduction (Walinski, 1989, Dovier and Rossi, 1993, Bruscoli et al., 1994).
Reference: <author> W. Older and A. Vellino. </author> <title> Constraint Arithmetic on Real Intervals. </title> <editor> In F. Benhamou and A. Colmerauer, editors, </editor> <booktitle> Constraint Logic Programming: Selected Papers. </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Also, if a failure is detected, the algorithm terminates with f ail. Theorem 4 The algorithm has a unique fixed point independent of the ordering of the inference rules. Proof: <ref> (Older and Vellino, 1993) </ref> proved that propagation methods based on the AC-3 algorithm compute a unique fixed point independent of the ordering of the inference rules, if the states of the iteration process can be ordered within a lattice and if the inference rules applied are contracting, idempotent and inclusion monotone.
Reference: <author> M. W. Padberg. </author> <title> Covering, Packing and Knapsack Problems. </title> <journal> In Annals of Discrete Mathematics, </journal> <volume> chapter volume 4, </volume> <pages> pages 265-287. </pages> <publisher> North-Holland Publishing company, </publisher> <year> 1979. </year>
Reference: <author> C. H. Papadimitriou and K. Steiglitz. </author> <title> COMBINATORIAL OPTIMIZATION: Algorithms and Complexity. </title> <publisher> Prentice-Hall, </publisher> <year> 1982. </year>
Reference-contexts: A CSP is commonly described by a set of variables ranging over a set of possible values (the domains) and a set of constraints applied to the variables. It is well known that combinatorial search problems are N P-complete <ref> (Papadimitriou and Steiglitz, 1982) </ref>. The solving of a CSP utilizes local consistency techniques. These are constraint propagation techniques aiming at pruning the search space, associated to a CSP, by removing values that can never be part of any feasible solution. <p> One of these predicates used in a subsequent application (set partitioning), performs the branch and bound search. The predicate min_max (Goal, Cost) searches for a solution to the goal Goal that minimizes the value of the linear term Cost using the branch and bound method from operations research <ref> (Papadimitriou and Steiglitz, 1982) </ref>. As soon as a partial solution to Goal is found whose cost is worse than the previous solution the search is not explored any further and a new solution is searched for.
Reference: <author> Z. Pawlak. </author> <title> Rough Sets: Theoretical Aspects of Reasoning about Data. D: System theory, Knowledge engineering and Problem solving. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: The following properties give the equivalences and/or implications which exist between the lower and upper bounds of a set expression domain and the lower and upper bounds of the set variables invoked. Properties 7 <ref> (Pawlak, 1991) </ref> 1. glb (s 1 ) s 1 lub (s 1 ) 3. glb (s 1 " s 2 ) = glb (s 1 ) " glb (s 2 ) 5. glb (s 1 [ s 2 ) glb (s 1 ) [ glb (s 2 ) Properties 7-2 and
Reference: <author> K. J. Perry, K. V. Palem, K. MacAloon, and G. M. Kuper. </author> <title> The Complexity of Logic Programming with Sets. </title> <booktitle> Computer Science, 1986. J-F. Puget. Programmation par contraintes orientee objet. In Proceedings of Avignon, </booktitle> <pages> pages 129-138, </pages> <year> 1992. </year>
Reference-contexts: In (Beeri et al., 1991, Jayaraman and Plaisted, 1989) a term-matching procedure is considered (unification of two sets when one of them contains no variables). This approach reduces significantly the set of unifiers. But term-matching for constructed sets remains an NP-complete problem <ref> (Perry et al., 1986, Kapur and Narendran, 1986) </ref>. Indeed, if fx 1 ; :::; x n g = f1; :::; mg (m &lt; n) there are at most 2 nm computable solutions. These approaches allow for a high level of abstraction when representing collections of terms.
Reference: <author> J.F. Puget. </author> <title> Finite set intervals. In Workshop on set constraints in conjunction with CP'96, </title> <year> 1996. </year>
Reference: <author> A. Schrijver. </author> <title> Theory of Linear and Integer Programming. Discrete Mathematics. </title> <publisher> Wiley-interscience, </publisher> <year> 1986. </year>
Reference-contexts: Constraints over sets are modelled using arithmetic constraints. This is not natural, costly in variables, and this often makes the program non-generic. The second approach, based on the use of 0-1 variables, originates from 0-1 Integer Linear Programming (ILP) <ref> (Schrijver, 1986) </ref>. It makes use of the one-to-one correspondence which exists between a subset s of a known set S and a boolean algebra.
Reference: <author> J. T. Schwartz, R. B. Dewar, E. Dubinsky, and E. Schonberg. </author> <title> Programming with sets An introduction to SETL. </title> <publisher> Springer-Verlag Ed., </publisher> <year> 1986. </year>
Reference-contexts: Set data structures in logic-based programming languages A set is a collection of distinct elements commonly described by fx 1 ; :::; x n g. The first application to embed sets as a high level programming abstraction was in rapid software prototyping and problem specification <ref> (Oxford 1986, Schwartz et al., 1986, Turner, 1986) </ref> More recent proposals in database query languages, assume a logic-based language as the underlying framework. These proposals aimed at strengthening typical existing set facilities of languages like Prolog (e.g. setof, bagof) to handle sets of terms and complex data structures.
Reference: <author> O. Shmueli, S. Tsur, and C. Zaniolo. </author> <title> Compilation of set terms in the logic data language (LDL). </title> <journal> The Journal of Logic Programming, </journal> <volume> 12(12) </volume> <pages> 89-119, </pages> <year> 1992. </year>
Reference: <author> Frieder Stolzenburg. </author> <title> Membership-constraints and complexity in logic programming with sets. </title> <editor> In Franz Baader and Klaus U. Schulz, editors, </editor> <booktitle> Frontiers in Combining Systems, </booktitle> <pages> pages 196-212. </pages> <publisher> Kluwer Academic, </publisher> <year> 1996. </year>
Reference: <author> D. Turner. </author> <title> An overview of Miranda, volume 21 n. 12. </title> <journal> SIGPLAN Notices, </journal> <year> 1986. </year> <institution> Oxford University Computing Laboratory. Z handbook. </institution> <year> 1986. </year>
Reference-contexts: Set data structures in logic-based programming languages A set is a collection of distinct elements commonly described by fx 1 ; :::; x n g. The first application to embed sets as a high level programming abstraction was in rapid software prototyping and problem specification <ref> (Oxford 1986, Schwartz et al., 1986, Turner, 1986) </ref> More recent proposals in database query languages, assume a logic-based language as the underlying framework. These proposals aimed at strengthening typical existing set facilities of languages like Prolog (e.g. setof, bagof) to handle sets of terms and complex data structures.
Reference: <author> C. Walinsky. </author> <title> CLP( fl ): Constraint Logic Programming with Regular Sets. </title> <booktitle> In ICLP'89, </booktitle> <pages> pages 181-190, </pages> <year> 1989. </year>
Reference-contexts: The concept of constraint solving replaces the unification procedure in logic programming and provides, among others, a uniform framework for handling set constraints (eg. x 2 s; s s 1 ; s = s 2 ). CLP ( fl ) <ref> (Walinsky, 1989) </ref> represents an instance of the CLP scheme over the computation domain of regular sets. A regular set is a finite set composed of strings which are generated from a finite alphabet . This language incorporates strings into logic programming to strengthen the standard string-handling features (eg. concat, substring).
References-found: 64

