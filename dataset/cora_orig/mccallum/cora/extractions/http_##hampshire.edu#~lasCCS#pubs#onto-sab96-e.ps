URL: http://hampshire.edu/~lasCCS/pubs/onto-sab96-e.ps
Refering-URL: http://hampshire.edu/~lasCCS/publications.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Automatic Generation of Adaptive Programs Automatic Generation of Adaptive Programs. In From Animals to Animats
Author: by Lee Spector and Kilian Stoffel Spector, L., and K. Stoffel. . P. Maes, M. Mataric, J.-A. Meyer, J. Pollack, 
Note: Full citation:  and S.W. Wilson (editors). Cambridge, MA: The MIT Press.  
Abstract-found: 0
Intro-found: 1
Reference: <author> Brodie, L. </author> <year> 1981. </year> <title> Starting FORTH. </title> <publisher> Prentice Hall. </publisher>
Reference-contexts: The HiGP virtual machine is similar to standard pushdown automata models (see, e.g., (Kain, 1972)) and to the execution model of the FORTH programming language <ref> (Brodie, 1981) </ref>. It consists of an input tape containing a linear program to be executed, a pushdown stack for function arguments and return values, and a finite-state control unit that controls the execution of the program (see Figure 1).
Reference: <author> Iba, H., T. Sato, and H. de Garis. </author> <year> 1993. </year> <title> Temporal Data Processing Using Genetic Programming. </title> <booktitle> In Proceedings of the 6th International Conference on Genetic Algorithms, </booktitle> <editor> ICGA-95, edited by Larry J. </editor> <booktitle> Eshelman, </booktitle> <pages> pp. 279-286. </pages> <address> San Francisco: </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference: <author> Kain, R.Y. </author> <year> 1972. </year> <title> Automata Theory: Machines and Languages. </title> <address> New York: </address> <publisher> McGraw-Hill Book Company. </publisher>
Reference-contexts: HiGP produces and manipulates linear programs for a stack-based virtual machine (as in (Perkis, 1994)), rather than the tree-structured S-expressions used in traditional genetic programming. The HiGP virtual machine is similar to standard pushdown automata models (see, e.g., <ref> (Kain, 1972) </ref>) and to the execution model of the FORTH programming language (Brodie, 1981).
Reference: <author> Koza, J.R. </author> <year> 1992. </year> <title> Genetic Programming: On the Programming of Computers by Means of Natural Selection. </title> <address> Cambridge, MA: </address> <publisher> The MIT Press. </publisher>
Reference-contexts: 1 Introduction Genetic programming is a methodology for the automatic generation of computer programs by means of biologically-inspired processes of recombination and natural selection <ref> (Koza, 1992) </ref>. Genetic programming systems process populations of computer programs. The initial populations typically consist of programs that are random combinations of elements from problem-specific function and terminal sets. <p> Note that while HiGP evolves programs for the virtual machine, the machine itself never changes|it is simply the execution model for the evolving programs, much as a Lisp-like S-expression evaluator is the execution model for standard genetic programming <ref> (Koza, 1992) </ref>. Further details about HiGP and the HiGP virtual machine can be found in (Stoffel and Spector, 1996). One normally provides a family of push operators that correspond to the terminal set in a traditional genetic programming system; each push operator pushes a pre-determined value onto the stack. <p> In other words, the ontogenetic extensions provide benefits that indexed memory does not. Consider the sequential regression problem, a variant of the symbolic regression problem <ref> (Koza, 1992) </ref>. As in ordinary symbolic regression, the goal in sequential regression is to produce a program that returns the appropriate y value for each x value in a data set. <p> We used a function set consisting of the 2-argument addition function +, the 2-argument subtraction function -, the 2-argument multiplication function *, the 2-argument protected division function % <ref> (Koza, 1992) </ref>, and the 0-argument push-x function for the independent variable x. 1 In addition, we included the stack 1 In previous experiments we also included push-0 and push-1 in the function set (Spector and Stoffel, 1996). <p> This is difficult; in many cases it is necessary to risk death in order to navigate to the gold, and in some cases the gold may be unobtainable because it is in a pit or in a square surrounded by pits. "Standardized fitness" values (for which lower values are better <ref> (Koza, 1992) </ref>) are the average of the scores from the four worlds, subtracted from 100.
Reference: <author> Koza, J.R. </author> <year> 1994. </year> <title> Genetic Programming II: Automatic Discovery of Reusable Programs. </title> <address> Cambridge, MA: </address> <publisher> The MIT Press. </publisher>
Reference-contexts: More work should also be conducted to examine the self-modification strategies actually employed by successful programs. Many possibilities exist; for example, programs might be copying segments of code into multiple program locations, thereby reusing code modules and obtaining an effect similar to that obtained with automatically defined functions <ref> (Koza, 1994) </ref> or automatically defined macros (Spector, 1996). It would also be interesting to trace the patterns of recurrence of particular program configurations as a program runs. The ontogenetic programming technique can be varied in many ways|for example, by changing the set of provided ontogenetic operators.
Reference: <author> Perkis, T. </author> <year> 1994. </year> <title> Stack-Based Genetic Programming. </title> <booktitle> In Proceedings of the 1994 IEEE World Congress on Computational Intelligence, </booktitle> <pages> pp. 148-153. </pages> <publisher> IEEE Press. </publisher>
Reference-contexts: It is a fast, flexible, and portable system with an efficient parallel implementation that scales nearly linearly with the number of available processors. HiGP produces and manipulates linear programs for a stack-based virtual machine (as in <ref> (Perkis, 1994) </ref>), rather than the tree-structured S-expressions used in traditional genetic programming. The HiGP virtual machine is similar to standard pushdown automata models (see, e.g., (Kain, 1972)) and to the execution model of the FORTH programming language (Brodie, 1981). <p> When there are not enough values on the stack to serve as arguments for an opera tor it is skipped by the finite-state control unit and the stack remains untouched (as in <ref> (Perkis, 1994) </ref>). A simple example may help to clarify the operation of the virtual stack machine.
Reference: <author> Russell, S.J., and P. Norvig. </author> <year> 1995. </year> <title> Artificial Intelligence, A Modern Approach. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: Note that in all conditions the average average fitness appears to converge to a value close to the average best fitness. Note also that indexed mem-ory actually makes matters worse; the system performs better without it. 4 Example 2: Action Selection in Wum pus World Wumpus world <ref> (Russell and Norvig, 1995) </ref> is an environment in which an agent must select actions to avoid death and to achieve goals. The use of genetic programming for the evolution of Wumpus world agents has been previously described (Spector, 1996).
Reference: <editor> Siegel, E.V., editor. </editor> <booktitle> 1995. Collective Brainstorming at the AAAI Symposium on Genetic Programming, </booktitle> <address> http://www.cs.columbia.edu/~evs/gpsym95.html. </address>
Reference-contexts: Acknowledgments Mark Feinstein helped to develop our initial interest in ontogeny, and to refine our understanding of its role in biological systems. Discussions at the 1995 AAAI Fall Symposium on Genetic Programming <ref> (Siegel, 1995) </ref> helped to further refine our approach to ontogenetic programming. The comments of two anonymous reviewers lead to several improvements in this paper. This research was supported in part by grants from ONR (N00014-J-91-1451), AFOSR (F49620-93-1-0065), and ARPA contract DAST-95-C0037.
Reference: <author> Spector, L. </author> <year> 1996. </year> <title> Simultaneous Evolution of Programs and their Control Structures. </title> <booktitle> In Advances in Genetic Programming 2, edited by P.J. Angeline and K.E. </booktitle>
Reference-contexts: The HiGP genetic programming system, which operates on linear programs for a stack-based virtual machine, is used for this demonstration. Program modification mechanisms for linear programs are particularly simple, but the technique is not limited to systems with linear programs; see <ref> (Spector and Stoffel, 1996) </ref> for a discussion of ontogenetic programming with more traditional S-expression-based representations. After the description of the technique two examples are provided: a simple but illustrative binary sequence prediction problem, and a more complex action selection problem. <p> The paper concludes with a brief description of work yet to be done. 2 Ontogenetic HiGP HiGP is a high-performance genetic programming engine that combines techniques from string-based genetic algorithms, S-expression-based genetic programming systems, and high-performance parallel computing systems <ref> (Stoffel and Spector, 1996) </ref>. It is a fast, flexible, and portable system with an efficient parallel implementation that scales nearly linearly with the number of available processors. <p> Further details about HiGP and the HiGP virtual machine can be found in <ref> (Stoffel and Spector, 1996) </ref>. One normally provides a family of push operators that correspond to the terminal set in a traditional genetic programming system; each push operator pushes a pre-determined value onto the stack. <p> +, the 2-argument subtraction function -, the 2-argument multiplication function *, the 2-argument protected division function % (Koza, 1992), and the 0-argument push-x function for the independent variable x. 1 In addition, we included the stack 1 In previous experiments we also included push-0 and push-1 in the function set <ref> (Spector and Stoffel, 1996) </ref>. Surprisingly, their removal had almost no effect on the results. manipulation function dup, which pushes a duplicate of the top element onto the stack, and noop. <p> The use of genetic programming for the evolution of Wumpus world agents has been previously described <ref> (Spector, 1996) </ref>. In this section we briefly describe the Wumpus world problem and the results of experiments that use ontogenetic programming to produce Wumpus world agents. Wumpus world is cave represented as a grid of squares surrounded by walls. <p> The agent's program can refer to the components of the percept arbitrarily many times during its execution. Agents are assessed on the basis of performance in four worlds. 2 In each world the agent is allowed to per 2 In <ref> (Spector, 1996) </ref> four new random worlds were generated for each fitness test. <p> Table 1. 4 For the ontogenetic 3 The mapping from integers to actions was: 0 = forward, 1 = turn right, 2 = turn left, 3 = shoot, 4 = grab, 5 = release, 6 = climb. 4 This function set, developed for HiGP, differs slightly from that used in <ref> (Spector, 1996) </ref>, which used S-expression-based genetic programming. runs, the above-described shift-left, shift-right, and segment-copy operators were also included. <p> Many possibilities exist; for example, programs might be copying segments of code into multiple program locations, thereby reusing code modules and obtaining an effect similar to that obtained with automatically defined functions (Koza, 1994) or automatically defined macros <ref> (Spector, 1996) </ref>. It would also be interesting to trace the patterns of recurrence of particular program configurations as a program runs. The ontogenetic programming technique can be varied in many ways|for example, by changing the set of provided ontogenetic operators. No systematic study of such variations has yet been performed. <p> The ontogenetic programming technique can be varied in many ways|for example, by changing the set of provided ontogenetic operators. No systematic study of such variations has yet been performed. The use of ontogenetic programming with traditional S-expression-based genetic programming systems has been described <ref> (Spector and Stoffel, 1996) </ref>, but the impact of program representation on the utility of particular ontogenetic operators has not yet been studied.
Reference: <editor> Kinnear, </editor> <booktitle> Jr., </booktitle> <pages> pp. 137-154. </pages> <address> Cambridge, MA: </address> <publisher> The MIT Press. </publisher>
Reference: <author> Spector, L., and K. Stoffel. </author> <year> 1996. </year> <title> Ontogenetic Programming. </title> <booktitle> In Proceedings of the Genetic Programming 1996 Conference. </booktitle> <address> Cambridge, MA: </address> <publisher> The MIT Press. In press. </publisher>
Reference-contexts: The HiGP genetic programming system, which operates on linear programs for a stack-based virtual machine, is used for this demonstration. Program modification mechanisms for linear programs are particularly simple, but the technique is not limited to systems with linear programs; see <ref> (Spector and Stoffel, 1996) </ref> for a discussion of ontogenetic programming with more traditional S-expression-based representations. After the description of the technique two examples are provided: a simple but illustrative binary sequence prediction problem, and a more complex action selection problem. <p> The paper concludes with a brief description of work yet to be done. 2 Ontogenetic HiGP HiGP is a high-performance genetic programming engine that combines techniques from string-based genetic algorithms, S-expression-based genetic programming systems, and high-performance parallel computing systems <ref> (Stoffel and Spector, 1996) </ref>. It is a fast, flexible, and portable system with an efficient parallel implementation that scales nearly linearly with the number of available processors. <p> Further details about HiGP and the HiGP virtual machine can be found in <ref> (Stoffel and Spector, 1996) </ref>. One normally provides a family of push operators that correspond to the terminal set in a traditional genetic programming system; each push operator pushes a pre-determined value onto the stack. <p> +, the 2-argument subtraction function -, the 2-argument multiplication function *, the 2-argument protected division function % (Koza, 1992), and the 0-argument push-x function for the independent variable x. 1 In addition, we included the stack 1 In previous experiments we also included push-0 and push-1 in the function set <ref> (Spector and Stoffel, 1996) </ref>. Surprisingly, their removal had almost no effect on the results. manipulation function dup, which pushes a duplicate of the top element onto the stack, and noop. <p> The use of genetic programming for the evolution of Wumpus world agents has been previously described <ref> (Spector, 1996) </ref>. In this section we briefly describe the Wumpus world problem and the results of experiments that use ontogenetic programming to produce Wumpus world agents. Wumpus world is cave represented as a grid of squares surrounded by walls. <p> The agent's program can refer to the components of the percept arbitrarily many times during its execution. Agents are assessed on the basis of performance in four worlds. 2 In each world the agent is allowed to per 2 In <ref> (Spector, 1996) </ref> four new random worlds were generated for each fitness test. <p> Table 1. 4 For the ontogenetic 3 The mapping from integers to actions was: 0 = forward, 1 = turn right, 2 = turn left, 3 = shoot, 4 = grab, 5 = release, 6 = climb. 4 This function set, developed for HiGP, differs slightly from that used in <ref> (Spector, 1996) </ref>, which used S-expression-based genetic programming. runs, the above-described shift-left, shift-right, and segment-copy operators were also included. <p> Many possibilities exist; for example, programs might be copying segments of code into multiple program locations, thereby reusing code modules and obtaining an effect similar to that obtained with automatically defined functions (Koza, 1994) or automatically defined macros <ref> (Spector, 1996) </ref>. It would also be interesting to trace the patterns of recurrence of particular program configurations as a program runs. The ontogenetic programming technique can be varied in many ways|for example, by changing the set of provided ontogenetic operators. No systematic study of such variations has yet been performed. <p> The ontogenetic programming technique can be varied in many ways|for example, by changing the set of provided ontogenetic operators. No systematic study of such variations has yet been performed. The use of ontogenetic programming with traditional S-expression-based genetic programming systems has been described <ref> (Spector and Stoffel, 1996) </ref>, but the impact of program representation on the utility of particular ontogenetic operators has not yet been studied.
Reference: <author> Stoffel, K. and L. Spector. </author> <year> 1996. </year> <title> High-Performance Genetic Programming. </title> <booktitle> In Proceedings of the Genetic Programming 1996 Conference. </booktitle> <address> Cambridge, MA: </address> <publisher> The MIT Press. In press. </publisher>
Reference-contexts: The HiGP genetic programming system, which operates on linear programs for a stack-based virtual machine, is used for this demonstration. Program modification mechanisms for linear programs are particularly simple, but the technique is not limited to systems with linear programs; see <ref> (Spector and Stoffel, 1996) </ref> for a discussion of ontogenetic programming with more traditional S-expression-based representations. After the description of the technique two examples are provided: a simple but illustrative binary sequence prediction problem, and a more complex action selection problem. <p> The paper concludes with a brief description of work yet to be done. 2 Ontogenetic HiGP HiGP is a high-performance genetic programming engine that combines techniques from string-based genetic algorithms, S-expression-based genetic programming systems, and high-performance parallel computing systems <ref> (Stoffel and Spector, 1996) </ref>. It is a fast, flexible, and portable system with an efficient parallel implementation that scales nearly linearly with the number of available processors. <p> Further details about HiGP and the HiGP virtual machine can be found in <ref> (Stoffel and Spector, 1996) </ref>. One normally provides a family of push operators that correspond to the terminal set in a traditional genetic programming system; each push operator pushes a pre-determined value onto the stack. <p> +, the 2-argument subtraction function -, the 2-argument multiplication function *, the 2-argument protected division function % (Koza, 1992), and the 0-argument push-x function for the independent variable x. 1 In addition, we included the stack 1 In previous experiments we also included push-0 and push-1 in the function set <ref> (Spector and Stoffel, 1996) </ref>. Surprisingly, their removal had almost no effect on the results. manipulation function dup, which pushes a duplicate of the top element onto the stack, and noop. <p> The ontogenetic programming technique can be varied in many ways|for example, by changing the set of provided ontogenetic operators. No systematic study of such variations has yet been performed. The use of ontogenetic programming with traditional S-expression-based genetic programming systems has been described <ref> (Spector and Stoffel, 1996) </ref>, but the impact of program representation on the utility of particular ontogenetic operators has not yet been studied.
Reference: <author> Teller, A. </author> <year> 1994. </year> <title> The Evolution of Mental Models. </title> <booktitle> In Advances in Genetic Programming, </booktitle> <editor> edited by Ken-neth E. Kinnear, </editor> <booktitle> Jr., </booktitle> <pages> pp. 199-219. </pages> <address> Cambridge, MA: </address> <publisher> The MIT Press. </publisher>
Reference-contexts: These sorts of runtime adaptive capabilities can be critical for achieving good performance in many real-world environments. There are two obvious ways in which genetic programming systems could support runtime adaptation. The first involves the runtime manipulation of dynamic data structures upon which program execution may depend. Indexed memory <ref> (Teller, 1994) </ref> and memory terminals (Iba et al., 1995) both provide the required functionality; programs that use these mechanisms may acquire and store information from their environments at run-time, and they may use this information to guide future behavior. <p> seven valid actions were mapped onto the integers from zero to six (inclusive), and a simple function set was used that consists primarily of simple arithmetic operators that manipulate and return numbers in this range. 3 The agent's memory system was implemented as a two-dimensional (7 by 7) indexed memory <ref> (Teller, 1994) </ref>, each element of which could hold a single number.
Reference: <author> Yamauchi, B. and R. Beer. </author> <year> 1994. </year> <title> Integrating Reactive, Sequential, and Learning Behavior using Dynamical Neural Networks. In From Animals to Animats 3, </title> <editor> edited by D. Cliff, P. Husbands, J. Meyer, </editor> <publisher> and S.W. </publisher>
Reference-contexts: For example, genetic algorithms have been used to evolve the initial parameter vectors for dynamical neural networks that integrate runtime sensor information to modify their own future behavior <ref> (Yamauchi and Beer, 1994) </ref>. In these sorts of systems the runtime adaptive mechanisms (e.g., learning procedures for neural networks) are fixed; by contrast, ontogenetic programming allows for the simultaneous evolution of runtime adaptive mechanisms and the programs that use them.
Reference: <author> Wilson, </author> <booktitle> pp. </booktitle> <pages> 382-391. </pages> <address> Cambridge, MA: </address> <publisher> The MIT Press. </publisher>
References-found: 15

