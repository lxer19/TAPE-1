URL: ftp://www.cs.rutgers.edu/pub/technical-reports/hpcd-tr-13.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: FEEDBACK DIRECTED OPTIMIZATION  Written under the direction of  
Author: BY CHUN WAI LIEW Prof. Louis I. Steinberg 
Degree: A dissertation submitted to the Graduate School|New Brunswick  in partial fulfillment of the requirements for the degree of Doctor of Philosophy  and approved by  
Date: October, 1994  
Note: Graduate Program in Computer Science  
Address: New Jersey  Brunswick, New Jersey  
Affiliation: Rutgers, The State University of  New  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. R. Barbacci and D. P. Sieworiek. </author> <title> The Design and Analysis of Instruction Set Processors. </title> <address> McGraw-Hil, </address> <year> 1982. </year>
Reference-contexts: The next paragraph describing the high level function of DAA is extracted directly from [42]. The problem is given as a behavioural description in the ISPS language <ref> [1] </ref> used to describe the behaviour of microprocessors. The behavioural description is then compiled into a data-flow graph. The data-flow graph represents the computations that must be performed by the hardware and the data values that are passed between the computations.
Reference: [2] <author> Willam Birmingham and Ajay Daga. </author> <title> Failure recovery in the MICON system. </title> <booktitle> In Proceedings of the 27th ACM/IEEE Design Automation Conference, </booktitle> <year> 1990. </year>
Reference-contexts: If the problem solver determines that an assumption is untrue, then all decisions that are dependent upon the assumption are invalidated and an alternative is explored. TMS, ATMS and their successor techniques have the same assumptions and limitations as DDB. Credit-blame assignment in the MICON system. Birmingham and Aga <ref> [2] </ref> have developed a credit-blame assignment for the MICON system [3]. The MICON system is a rule based system for solving digital circuit design problems.
Reference: [3] <editor> W.P. Birmingham, A.P. Gupta, and D.P. Siewiorek. </editor> <booktitle> The MICON system for computer design. In Proceedings of the 26th Design Automation Conference, </booktitle> <year> 1989. </year>
Reference-contexts: TMS, ATMS and their successor techniques have the same assumptions and limitations as DDB. Credit-blame assignment in the MICON system. Birmingham and Aga [2] have developed a credit-blame assignment for the MICON system <ref> [3] </ref>. The MICON system is a rule based system for solving digital circuit design problems. The system maintains a dependency tree linking a decision to either other decisions or to an instantiated component along with the resource usage of the component.
Reference: [4] <author> Forrest D. Brewer. </author> <title> Constraint Driven Behavioral Synthesis. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois, Urbana-Champaign, </institution> <year> 1988. </year>
Reference-contexts: The descriptions are illustrated with the use of the example problem described earlier in Chapter 2. To recap, the design problem is one of designing an elliptic wave filter [35]. The specification (Figure 3.1) is taken from <ref> [4] </ref> and augmented with a specification of resource budgets of 2000 units for TIME and 1000 units for AREA as well as an objective function of AT 2 (AREA multiplied by TIME squared).
Reference: [5] <author> Forrest D. Brewer and Daniel D. Gajski. </author> <title> A design process model. </title> <editor> In C. Tong and D. Sriram, editors, </editor> <booktitle> Artificial Intelligence Approaches To Engineering Design. </booktitle> <year> 1990. </year> <note> To appear. </note>
Reference-contexts: The feedback based model has been explored by researchers in a number of domains, e.g., Knapp in VLSI [29], Dixon and his colleagues in mechanical engineering [23, 47] and Breuer in VLSI <ref> [5] </ref>. The main assumption underlying feedback approaches is that it is easier and more efficient to detect some interactions by analysing a solution, than it is to constrain the problem solver from generating all interactions of those types. <p> In particular the optimum solution for a global tradeoff function is not necessarily achieved by finding the locally optimal solutions for each subproblem. The ADAM system is unable to specify the desired tradeoff point for each subproblem. The CHIPPE system. The CHIPPE system <ref> [5] </ref> also solves problems in VLSI HLS. In many ways it addresses the questions raised by the ADAM system. Feedback is also used to adjust a set of parameters but in this system, there is a set of parameters for each design tool. <p> The system solves design problems in the domain of High Level Synthesis of digital filters (Section 2.1). The domain was chosen because the problems are well understood with existing benchmarks and evaluation criteria. The FDO/HLS system is a naive system compared to existing problem solvers that design digital filters <ref> [5, 33, 48, 8] </ref>. The intent of the system was solely to evaluate the feasibility of feedback, not to determine if it would improve expert systems.
Reference: [6] <author> Eugene Charniak and Drew V. McDermott. </author> <booktitle> Artificial Intelligence. </booktitle> <publisher> Addison Wes-ley, </publisher> <year> 1985. </year>
Reference-contexts: The nodes are also annotated with the names of the variables storing the results of the operations (if there are any). The design system assumes that the whole algorithm is repeated after the output is generated. The parser uses an augmented transition network (ATN) <ref> [6, 7] </ref> to parse the input and generate the corresponding nodes and arcs. The parser generates temporary variables to store the data output from each operation. When the specification includes a statement assigning values to a variable, the temporary variable is not required and is not generated.
Reference: [7] <author> Eugene Charniak, Christopher K. Riesbeck, Drew V. McDermott, and James R. </author> <title> Meehan. </title> <booktitle> Artifical Intelligence Programming. </booktitle> <publisher> Lawrence Erlbaum Associates, </publisher> <year> 1987. </year>
Reference-contexts: The nodes are also annotated with the names of the variables storing the results of the operations (if there are any). The design system assumes that the whole algorithm is repeated after the output is generated. The parser uses an augmented transition network (ATN) <ref> [6, 7] </ref> to parse the input and generate the corresponding nodes and arcs. The parser generates temporary variables to store the data output from each operation. When the specification includes a statement assigning values to a variable, the temporary variable is not required and is not generated.
Reference: [8] <author> Richard J. Cloutier and Donald E. Thomas. </author> <title> The combination of scheduling, allocation and mapping in a single algorithm. </title> <booktitle> In Proceedings of the 27th ACM/IEEE Design Automation Conference, </booktitle> <year> 1990. </year>
Reference-contexts: Therefore Constrained-Redo is well-suited to the individual subproblems but may not be so easily applied to techniques that solve the entire problem without decomposition, e.g., the technique developed by Cloutier <ref> [8] </ref>. 44 How does Constrained-Redo work? Essentially what Constrained-Redo does is to generate a new seed point for the heuristic algorithm of the problem solver. The idea is that the feedback contains a specification of how some part of the problem should be solved differently. <p> The system solves design problems in the domain of High Level Synthesis of digital filters (Section 2.1). The domain was chosen because the problems are well understood with existing benchmarks and evaluation criteria. The FDO/HLS system is a naive system compared to existing problem solvers that design digital filters <ref> [5, 33, 48, 8] </ref>. The intent of the system was solely to evaluate the feasibility of feedback, not to determine if it would improve expert systems.
Reference: [9] <author> S. Davidson, D. Landskov, B.D. Shriver, and P.W. Mallett. </author> <title> Some experiments in local microcode compaction for horizontalmachines. </title> <journal> IEEE Transactions on Computer Aided Design, </journal> <month> July </month> <year> 1985. </year>
Reference-contexts: First the operations are scheduled onto control steps using a priority list scheduler <ref> [9] </ref>. The highest priority is assigned to operations that are on the longest path through each linear block of operations. The length, width and area of each floorplanning leaf cluster is determined using information about the numbers and sizes of registers, multiplexers and wires.
Reference: [10] <author> Johan de Kleer. </author> <title> Choices without backtracking. </title> <booktitle> In Proceedings of AAAI-84, </booktitle> <month> August </month> <year> 1984. </year>
Reference-contexts: Design records are difficult to generate for many design optimization problems because there are many steps per solution so the records would be prohibitively large. 17 Using a TMS or an ATMS for credit-blame assignment Truth Maintenance Systems (TMS) [15] and Assumption based Truth Maintenance Systems (ATMS) <ref> [10, 14, 11, 12, 13] </ref> were improvements to the dependency directed backtracking technique. They extended DDB by recording assertions and assumptions in the design record. Links between these assumptions and the decisions that rely on them are used to correct decisions. <p> Design records are needed for techniques like dependency directed backtracking [54], assumption based truth maintenance <ref> [10] </ref> and explanation based generalisation [45]. * fault localization by component: Resource budget violations are localized to a small set of components or sets of components by resource usage.
Reference: [11] <author> Johan de Kleer. </author> <title> An assumption-based TMS. </title> <journal> Artificial Intelligence, </journal> <volume> 28(2), </volume> <month> March </month> <year> 1986. </year>
Reference-contexts: Design records are difficult to generate for many design optimization problems because there are many steps per solution so the records would be prohibitively large. 17 Using a TMS or an ATMS for credit-blame assignment Truth Maintenance Systems (TMS) [15] and Assumption based Truth Maintenance Systems (ATMS) <ref> [10, 14, 11, 12, 13] </ref> were improvements to the dependency directed backtracking technique. They extended DDB by recording assertions and assumptions in the design record. Links between these assumptions and the decisions that rely on them are used to correct decisions.
Reference: [12] <author> Johan de Kleer. </author> <title> Extending the ATMS. </title> <journal> Artificial Intelligence, </journal> <volume> 28(2), </volume> <month> March </month> <year> 1986. </year>
Reference-contexts: Design records are difficult to generate for many design optimization problems because there are many steps per solution so the records would be prohibitively large. 17 Using a TMS or an ATMS for credit-blame assignment Truth Maintenance Systems (TMS) [15] and Assumption based Truth Maintenance Systems (ATMS) <ref> [10, 14, 11, 12, 13] </ref> were improvements to the dependency directed backtracking technique. They extended DDB by recording assertions and assumptions in the design record. Links between these assumptions and the decisions that rely on them are used to correct decisions.
Reference: [13] <author> Johan de Kleer. </author> <title> Problem solving with the ATMS. </title> <journal> Artificial Intelligence, </journal> <volume> Volume 28(2), </volume> <month> March </month> <year> 1986. </year>
Reference-contexts: Design records are difficult to generate for many design optimization problems because there are many steps per solution so the records would be prohibitively large. 17 Using a TMS or an ATMS for credit-blame assignment Truth Maintenance Systems (TMS) [15] and Assumption based Truth Maintenance Systems (ATMS) <ref> [10, 14, 11, 12, 13] </ref> were improvements to the dependency directed backtracking technique. They extended DDB by recording assertions and assumptions in the design record. Links between these assumptions and the decisions that rely on them are used to correct decisions.
Reference: [14] <author> Johan de Kleer and Brian Williams. </author> <title> Back to backtracking: Controlling the ATMS. </title> <booktitle> In Proceedings of AAAI-86, </booktitle> <year> 1986. </year>
Reference-contexts: Design records are difficult to generate for many design optimization problems because there are many steps per solution so the records would be prohibitively large. 17 Using a TMS or an ATMS for credit-blame assignment Truth Maintenance Systems (TMS) [15] and Assumption based Truth Maintenance Systems (ATMS) <ref> [10, 14, 11, 12, 13] </ref> were improvements to the dependency directed backtracking technique. They extended DDB by recording assertions and assumptions in the design record. Links between these assumptions and the decisions that rely on them are used to correct decisions.
Reference: [15] <author> Jon Doyle. </author> <title> A truth maintenance system. </title> <journal> Artificial Intelligence, </journal> <volume> Volume 12, </volume> <year> 1979. </year> <month> 137 </month>
Reference-contexts: Design records are difficult to generate for many design optimization problems because there are many steps per solution so the records would be prohibitively large. 17 Using a TMS or an ATMS for credit-blame assignment Truth Maintenance Systems (TMS) <ref> [15] </ref> and Assumption based Truth Maintenance Systems (ATMS) [10, 14, 11, 12, 13] were improvements to the dependency directed backtracking technique. They extended DDB by recording assertions and assumptions in the design record. Links between these assumptions and the decisions that rely on them are used to correct decisions.
Reference: [16] <author> A. E. Dunlop and B. W. Kernighan. </author> <title> A Procedure for Placement of Standard-Cell VLSI Circuits. </title> <journal> IEEE Transactions on Computer-Aided-Design, </journal> <volume> 4(1), </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: The clusters generated by the clustering algorithm now form the leaf clusters to be used for floorplanning. The leaf clusters are then assigned to nonterminal clusters using a min-cut partitioning algorithm that is based on <ref> [16] </ref>. An approximate floor plan is generated based on the dimensions of the leaf clusters and their component modules. The area of the bounding box for the floor plan is the total area of the design.
Reference: [17] <author> Ashok K. Goel. </author> <title> Representation of design functions in experience-based design. In D.C. </title> <editor> Brown, M. Waldron, and H. Yoshikawa, editors, </editor> <booktitle> Proceedings of the IFIP TC5/WG5.2 Working Conference on Intelligent Computer Aided Design, </booktitle> <year> 1991. </year>
Reference-contexts: CBR has most often been used for inter-problem learning where experience in solving other problems is used to help solve a new problem. Examples of systems that use CBR are CHEF [18], KRITIK <ref> [17] </ref>, BOGART [46] and ARGO [24]. There are several differences between CBR systems and the systems that use feedback to solve design optimization problems.
Reference: [18] <author> Kristian J. Hammond. </author> <title> Planning and goal interactions: The use of past solutions in present situations. </title> <booktitle> Proceedings of AAAI-83, </booktitle> <year> 1983. </year>
Reference-contexts: CBR has most often been used for inter-problem learning where experience in solving other problems is used to help solve a new problem. Examples of systems that use CBR are CHEF <ref> [18] </ref>, KRITIK [17], BOGART [46] and ARGO [24]. There are several differences between CBR systems and the systems that use feedback to solve design optimization problems.
Reference: [19] <author> Caroline Clarke Hayes. </author> <title> Using goal interactions to guide planning. </title> <booktitle> In Proceedings of AAAI-87, </booktitle> <year> 1987. </year>
Reference-contexts: Previous systems have not used automated localized feedback. The experiments were carried out on several problem solvers, including two existing systems (DAA [33] and MACHINIST <ref> [19, 20, 21] </ref>) that were developed inde pendently of this research. * development of general techniques for providing localized feedback: Two general techniques for providing (1) credit-blame assignment and (2) control over a problem solver have been developed. <p> The framework was used to extend two existing problem solvers, DAA [33] and MACHINIST <ref> [19, 20, 21, 22] </ref>, and to build one new problem solver FDO/HLS [36]. 1.4 Guide to the Thesis This section provides a brief description of the structure of the thesis. Chapter 1 (this chapter) provides an overview of the research and the contributions. <p> Much of the information in this chapter is extracted from Caroline Hayes's thesis. More detailed information can be obtained from Hayes thesis [22] and articles <ref> [19, 20] </ref>. MACHINIST is an OPS5 program that generates manufacturing plans for machined parts made in small batches on a computer controller vertical milling center. The system focuses on "set-up" planning for three axis milling of multi-sided metal parts.
Reference: [20] <author> Caroline Clarke Hayes. </author> <title> A model of planning for plan efficiency: Taking advantage of operator overlap. </title> <booktitle> In Proceedings of IJCAI-89, </booktitle> <year> 1989. </year>
Reference-contexts: Previous systems have not used automated localized feedback. The experiments were carried out on several problem solvers, including two existing systems (DAA [33] and MACHINIST <ref> [19, 20, 21] </ref>) that were developed inde pendently of this research. * development of general techniques for providing localized feedback: Two general techniques for providing (1) credit-blame assignment and (2) control over a problem solver have been developed. <p> The framework was used to extend two existing problem solvers, DAA [33] and MACHINIST <ref> [19, 20, 21, 22] </ref>, and to build one new problem solver FDO/HLS [36]. 1.4 Guide to the Thesis This section provides a brief description of the structure of the thesis. Chapter 1 (this chapter) provides an overview of the research and the contributions. <p> Much of the information in this chapter is extracted from Caroline Hayes's thesis. More detailed information can be obtained from Hayes thesis [22] and articles <ref> [19, 20] </ref>. MACHINIST is an OPS5 program that generates manufacturing plans for machined parts made in small batches on a computer controller vertical milling center. The system focuses on "set-up" planning for three axis milling of multi-sided metal parts. <p> The FDO framework provides guidance about how to (1) extend an existing problem solver to use feedback and (2) construct a problem solver that can maximally utilize feedback. The framework has been used to extend two existing systems, DAA [33] and MACHINIST <ref> [20, 22] </ref>, and to build a new system FDO/HLS [36]. One of the major results of this research is to show that feedback (beyond just resource usage of a solution) is useful and that automated techniques for supporting feedback have been developed.
Reference: [21] <author> Caroline Clarke Hayes. </author> <title> Using process planning knowledge to make design suggestions concurrently. </title> <booktitle> In Proceedings of the ASME Winter Annual Meeting, </booktitle> <year> 1989. </year>
Reference-contexts: Previous systems have not used automated localized feedback. The experiments were carried out on several problem solvers, including two existing systems (DAA [33] and MACHINIST <ref> [19, 20, 21] </ref>) that were developed inde pendently of this research. * development of general techniques for providing localized feedback: Two general techniques for providing (1) credit-blame assignment and (2) control over a problem solver have been developed. <p> The framework was used to extend two existing problem solvers, DAA [33] and MACHINIST <ref> [19, 20, 21, 22] </ref>, and to build one new problem solver FDO/HLS [36]. 1.4 Guide to the Thesis This section provides a brief description of the structure of the thesis. Chapter 1 (this chapter) provides an overview of the research and the contributions. <p> The rest of this section describes (1) the MACHINIST implementation, (2) the implementation of feedback extensions to MACHINIST and (3) the experiments that were run on the new system FDO/MACHINIST. The description of MACHINIST and FDO/MACHINIST uses an example described by Hayes in <ref> [21] </ref>. The example was used by Hayes to illustrate how MACHINIST could be extended to critique its own solutions and make design suggestions. <p> The description speci fies (1) the material used for the part, (2) the dimensions and finish of the part as well as (3) some features. The example was extracted from <ref> [21] </ref>. The specification creates elements in the working memory of OPS5 that are intended to be goals for productions as the system is run. For example, the first production creates (make : : : ) an element with the name part. <p> The previous section described implementation of FDO/MACHINIST and an example of how feedback is used to generate design suggestions and improve the solution. The example is extracted from Hayes article <ref> [21] </ref> describing how MACHINIST can be used to generate design suggestions. <p> The RDT and Constrained-Redo techniques have been implemented in this new domain. * The power of the FDO/MACHINIST concepts and techniques. The FDO/MACHINIST techniques were used to implement a technique that was first discussed by Hayes in <ref> [21] </ref>. In this article, Hayes described how MACHINIST could be used to first generate a plan and then to subsequently critique the plan and offer suggestions for alternative solutions. The meta-level controller in FDO/MACHINIST critiques the plan in a different way.
Reference: [22] <author> Caroline Clarke Hayes. </author> <title> Machining Planning: A Model of an Expert Level Planning Process. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <year> 1990. </year>
Reference-contexts: The experiments have shown that automated feedback techniques providing information about local interactions are feasible and that they can help improve the quality of the solutions. The domains used are those of the generation of plans to make metal parts using the MACHINIST program <ref> [22] </ref>, VLSI microprocessor design using the DAA system [33, 32] and VLSI digital filter design using the FDO/HLS system [36]. <p> The framework was used to extend two existing problem solvers, DAA [33] and MACHINIST <ref> [19, 20, 21, 22] </ref>, and to build one new problem solver FDO/HLS [36]. 1.4 Guide to the Thesis This section provides a brief description of the structure of the thesis. Chapter 1 (this chapter) provides an overview of the research and the contributions. <p> Much of the information in this chapter is extracted from Caroline Hayes's thesis. More detailed information can be obtained from Hayes thesis <ref> [22] </ref> and articles [19, 20]. MACHINIST is an OPS5 program that generates manufacturing plans for machined parts made in small batches on a computer controller vertical milling center. The system focuses on "set-up" planning for three axis milling of multi-sided metal parts. <p> The FDO framework provides guidance about how to (1) extend an existing problem solver to use feedback and (2) construct a problem solver that can maximally utilize feedback. The framework has been used to extend two existing systems, DAA [33] and MACHINIST <ref> [20, 22] </ref>, and to build a new system FDO/HLS [36]. One of the major results of this research is to show that feedback (beyond just resource usage of a solution) is useful and that automated techniques for supporting feedback have been developed.
Reference: [23] <author> A. Howe, J.R. Dixon, P.R. Cohen, and M.K. Simmons. DOMINIC: </author> <title> a domain independent program for mechanical engineering design. </title> <booktitle> In Proceedings First International Conference on Application of Artifical Intelligence to Engineering Problems, </booktitle> <year> 1986. </year>
Reference-contexts: The feedback based model has been explored by researchers in a number of domains, e.g., Knapp in VLSI [29], Dixon and his colleagues in mechanical engineering <ref> [23, 47] </ref> and Breuer in VLSI [5]. The main assumption underlying feedback approaches is that it is easier and more efficient to detect some interactions by analysing a solution, than it is to constrain the problem solver from generating all interactions of those types. <p> This section describes several systems and techniques that use feedback to control the problem solver. Most of these systems have been developed to solve design optimization problems. The DOMINIC system. The DOMINIC system <ref> [23, 47] </ref> uses feedback to solve parameter selection design problems in mechanical engineering. The system uses hierarchical decomposition techniques to decompose a problem structurally until all that is left is to instantiate the numerical parameters for the structural components, e.g., number of gear teeth in a gear pair. <p> The solids lines indicate flow of information when generating a solution and the dashed line indicates feedback, as in the complete solution being returned to the meta-level. The arrows indicate the direction of information flow. This approach has been used in many systems, e.g., ADAM [29] and DOMINIC <ref> [23] </ref>. Within these systems, the meta-level controller contains all the knowledge about evaluating and selecting optimization strategies. In the FDO framework, this type of knowledge is spread out over the meta-level controller and the optimizations associated with each problem solver (Section 3.6.3). <p> These techniques do not use design records and therefore do not have the problems described earlier in this section 5.2.2 Using problem decomposition to solve interacting problems Problem decomposition has been one of the main research issues in AI for many years <ref> [49, 55, 40, 56, 23] </ref>. The research has been focussed on developing ways of finding good decompositions for problems, i.e., decompose them into non-interacting subproblems. This approach has had some success but has not been applicable for problems with global constraints, e.g., design optimization problems.
Reference: [24] <author> M.N. Huhns and Ramon D. Acosta. Argo: </author> <title> An analogical reasoning system for solving design problems. </title> <type> Technical Report AI/CAD-092-87, </type> <institution> Microelectronics and Computer Technology Corporation, 3500 West Balcones Center Drive, </institution> <address> Austin TX 78759, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: CBR has most often been used for inter-problem learning where experience in solving other problems is used to help solve a new problem. Examples of systems that use CBR are CHEF [18], KRITIK [17], BOGART [46] and ARGO <ref> [24] </ref>. There are several differences between CBR systems and the systems that use feedback to solve design optimization problems. An obvious one is that CBR has been commonly used for transferring knowledge between problem solving episodes while design optimization systems have used feedback for intra-problem learning.
Reference: [25] <author> R. Jain, M. J. Mlinar, and A. C. Parker. </author> <title> Area-time model for synthesis of non-pipelined designs. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design. </booktitle> <address> ACM/IEEE, </address> <month> November </month> <year> 1988. </year>
Reference-contexts: Many problem solving techniques, e.g., min-max search with alpha-beta pruning [50], are dependent on hav ing good estimation functions. Work on the development and learning of estimation functions includes the early work of Samuels in checkers [50] and the more recent work in VLSI of Jain <ref> [26, 27, 25] </ref>, Kucukcakar [34] and McFarland [42]. The FDO research complements this body of work in that it focusses on developing methods for correcting inefficiencies a posteriori that could not be detected with estimation functions.
Reference: [26] <author> R. Jain, A. C. Parker, and N. Park. </author> <title> Predicting area-time tradeoffs for pipelined designs. </title> <booktitle> In Proceedings of the 24th ACM/IEEE Design Automation Conference. </booktitle> <address> ACM/IEEE, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: Many problem solving techniques, e.g., min-max search with alpha-beta pruning [50], are dependent on hav ing good estimation functions. Work on the development and learning of estimation functions includes the early work of Samuels in checkers [50] and the more recent work in VLSI of Jain <ref> [26, 27, 25] </ref>, Kucukcakar [34] and McFarland [42]. The FDO research complements this body of work in that it focusses on developing methods for correcting inefficiencies a posteriori that could not be detected with estimation functions.
Reference: [27] <author> Rajiv Jain, Alice Parker, and Nohbyung Park. </author> <title> Module selection for pipelined synthesis. </title> <booktitle> In Proceedings of the 25th ACM/IEEE Design Automation Conference, </booktitle> <year> 1988. </year>
Reference-contexts: Many problem solving techniques, e.g., min-max search with alpha-beta pruning [50], are dependent on hav ing good estimation functions. Work on the development and learning of estimation functions includes the early work of Samuels in checkers [50] and the more recent work in VLSI of Jain <ref> [26, 27, 25] </ref>, Kucukcakar [34] and McFarland [42]. The FDO research complements this body of work in that it focusses on developing methods for correcting inefficiencies a posteriori that could not be detected with estimation functions.
Reference: [28] <author> S.C. Johnson. </author> <title> Hierarchical clustering trees. </title> <journal> Psychometrika, </journal> <volume> 32(3), </volume> <year> 1967. </year>
Reference-contexts: N is the exponent specified by the user for the objective function AT N . The measure described above is similar to one developed by McFarland in [41]. Initially a distance matrix is computed that gives the distance for each pair of op erations. Using the method of <ref> [28] </ref>, the system forms a hierarchical clustering tree that is based on the distances in the distance matrix. The leaves represent the operations or points to be clustered and the heights in tree correspond to distances between points.
Reference: [29] <author> D. Knapp and A. Parker. </author> <title> A design utility manager: the ADAM planning engine. </title> <booktitle> In Proceedings of the 23rd Design Automation Conference, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: A new solution is generated using the information and the cycle is repeated until either a satisfactory solution is obtained or the computational resources have been exhausted. The feedback based model has been explored by researchers in a number of domains, e.g., Knapp in VLSI <ref> [29] </ref>, Dixon and his colleagues in mechanical engineering [23, 47] and Breuer in VLSI [5]. <p> The use of feedback is limited only to the parameter instantiation module. If the structural decomposition is incorrect, i.e., there is no combination of numerical parameters that lead to a desired solution, the system uses chronological backtracking to find a different structural decomposition. The ADAM system. The ADAM system <ref> [29] </ref> solves problems in VLSI HLS. It uses feedback to adjust top-level numeric parameters via interpolation. The parameters specify the relative priorities of the resources with respect to one another. <p> The solids lines indicate flow of information when generating a solution and the dashed line indicates feedback, as in the complete solution being returned to the meta-level. The arrows indicate the direction of information flow. This approach has been used in many systems, e.g., ADAM <ref> [29] </ref> and DOMINIC [23]. Within these systems, the meta-level controller contains all the knowledge about evaluating and selecting optimization strategies. In the FDO framework, this type of knowledge is spread out over the meta-level controller and the optimizations associated with each problem solver (Section 3.6.3). <p> The feedback could even be used between multiple levels of problem solvers. Additionally, the FDO/HLS system was the first system to show that feedback techniques could be automated and used in a system. Earlier feedback techniques <ref> [50, 29] </ref> were limited to information about the resource usage of the solution. The FASOLT system [31] showed in a non-automated way that feedback beyond just the resource usage of the system could be used to improve the quality of a solution.
Reference: [30] <author> David W. Knapp. </author> <title> An interactive tool for register-level structure optimization. </title> <booktitle> In Proceedings of the 26th Design Automation Conference, </booktitle> <year> 1989. </year> <month> 138 </month>
Reference-contexts: Estimates are also generated and these are used to prioritize the list of applicable optimizations. The optimizations affect direct structural modifications in the solution without regard to correctness. Another user controlled system, RLEXT <ref> [30] </ref>, is used to correct the design. RLEXT relies on the user's ability to parse the modified solution, determine what is incorrect and make the appropriate changes to restore correctness of the overall solution.
Reference: [31] <author> David W. Knapp. </author> <title> Feedback-driven datapath optimization in FASOLT. </title> <booktitle> In Proceedings of ICCAD-90, </booktitle> <year> 1990. </year>
Reference-contexts: This is inefficient if the early decisions are incorrect especially when they usually have the largest effect on the quality of the solution. The FASOLT system. The FASOLT system <ref> [31] </ref> was developed to evaluate the utility of feedback in optimizing a Register Level Transfer (RTL) design. The system uses information from placement and layout (lower design levels after the RTL) to generate suggestions about where to 20 optimize the design. <p> Additionally, the FDO/HLS system was the first system to show that feedback techniques could be automated and used in a system. Earlier feedback techniques [50, 29] were limited to information about the resource usage of the solution. The FASOLT system <ref> [31] </ref> showed in a non-automated way that feedback beyond just the resource usage of the system could be used to improve the quality of a solution. <p> One of the major results of this research is to show that feedback (beyond just resource usage of a solution) is useful and that automated techniques for supporting feedback have been developed. The earlier work of Knapp <ref> [31] </ref> showed that feedback helped improve the performance of a naive problem solver. The experiments described in this thesis (Section 4.3) have shown that feedback can help powerful knowledge based problem solvers.
Reference: [32] <author> T. J. Kowalski. </author> <title> An artificial intelligence approach to VLSI design. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1985. </year>
Reference-contexts: The domains used are those of the generation of plans to make metal parts using the MACHINIST program [22], VLSI microprocessor design using the DAA system <ref> [33, 32] </ref> and VLSI digital filter design using the FDO/HLS system [36]. <p> The DAA system is described first followed by a description of the extensions that were added to build the FDO/DAA system. The experiments are subsequently discussed followed by the conclusions that were reached. Much of the description of DAA is extracted from [42] and <ref> [32] </ref>. The reader who is interested in more details about the DAA system should refer to the two references.
Reference: [33] <author> T. J. Kowalski and D. E. Thomas. </author> <title> The VLSI design automation assistant: first steps. </title> <booktitle> In 26th IEEE Computer Society International Conference, </booktitle> <pages> pages 126-130, </pages> <year> 1983. </year>
Reference-contexts: The domains used are those of the generation of plans to make metal parts using the MACHINIST program [22], VLSI microprocessor design using the DAA system <ref> [33, 32] </ref> and VLSI digital filter design using the FDO/HLS system [36]. <p> Previous systems have not used automated localized feedback. The experiments were carried out on several problem solvers, including two existing systems (DAA <ref> [33] </ref> and MACHINIST [19, 20, 21]) that were developed inde pendently of this research. * development of general techniques for providing localized feedback: Two general techniques for providing (1) credit-blame assignment and (2) control over a problem solver have been developed. <p> The framework provides guidance about how to either (1) extend an existing problem solver to use feedback about local interactions or (2) build a new problem solver so that it can make maximal use of feedback. The framework was used to extend two existing problem solvers, DAA <ref> [33] </ref> and MACHINIST [19, 20, 21, 22], and to build one new problem solver FDO/HLS [36]. 1.4 Guide to the Thesis This section provides a brief description of the structure of the thesis. Chapter 1 (this chapter) provides an overview of the research and the contributions. <p> The system solves design problems in the domain of High Level Synthesis of digital filters (Section 2.1). The domain was chosen because the problems are well understood with existing benchmarks and evaluation criteria. The FDO/HLS system is a naive system compared to existing problem solvers that design digital filters <ref> [5, 33, 48, 8] </ref>. The intent of the system was solely to evaluate the feasibility of feedback, not to determine if it would improve expert systems. <p> The FDO framework provides guidance about how to (1) extend an existing problem solver to use feedback and (2) construct a problem solver that can maximally utilize feedback. The framework has been used to extend two existing systems, DAA <ref> [33] </ref> and MACHINIST [20, 22], and to build a new system FDO/HLS [36]. One of the major results of this research is to show that feedback (beyond just resource usage of a solution) is useful and that automated techniques for supporting feedback have been developed.
Reference: [34] <author> Kayhan Kucukcakar and Alice Parker. </author> <title> Data path tradeoffs using MABAL. </title> <booktitle> In Proceedings of the 27th ACM/IEEE Design Automation Conference, </booktitle> <year> 1990. </year>
Reference-contexts: Work on the development and learning of estimation functions includes the early work of Samuels in checkers [50] and the more recent work in VLSI of Jain [26, 27, 25], Kucukcakar <ref> [34] </ref> and McFarland [42]. The FDO research complements this body of work in that it focusses on developing methods for correcting inefficiencies a posteriori that could not be detected with estimation functions.
Reference: [35] <author> S.Y. Kung, H.J. Whitehouse, and T. Kailath. </author> <booktitle> VLSI and Modern Signal Processing, </booktitle> <pages> pages 258-264. </pages> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: VLSI HLS is an example of a design optimization problem. The rest of this section describes some of the characteristics of design optimization problems and the problem solving methods applied to them. 9 2.1.1 An elliptic filter design problem digital filter) taken from <ref> [35] </ref>. The specification is in a pseudo-PASCAL language and describes the transformations that happen with the input data before the new value is output. It is assumed that the chip will run continuously and start over again at the beginning once it reaches the end of the program. <p> The next three sections, Sections 3.3, 3.4 and 3.5 describe the specifics of the redesign iterations. The descriptions are illustrated with the use of the example problem described earlier in Chapter 2. To recap, the design problem is one of designing an elliptic wave filter <ref> [35] </ref>. The specification (Figure 3.1) is taken from [4] and augmented with a specification of resource budgets of 2000 units for TIME and 1000 units for AREA as well as an objective function of AT 2 (AREA multiplied by TIME squared).
Reference: [36] <author> C. W. Liew. </author> <title> Feedback directed modification of designs. </title> <booktitle> In Proceedings of 6th IEEE Conference on AI Applications, </booktitle> <year> 1990. </year> <note> Also available as Technical Report LCSR-TR 135, </note> <institution> Department of Computer Science, Rutgers University. </institution>
Reference-contexts: The domains used are those of the generation of plans to make metal parts using the MACHINIST program [22], VLSI microprocessor design using the DAA system [33, 32] and VLSI digital filter design using the FDO/HLS system <ref> [36] </ref>. <p> The framework was used to extend two existing problem solvers, DAA [33] and MACHINIST [19, 20, 21, 22], and to build one new problem solver FDO/HLS <ref> [36] </ref>. 1.4 Guide to the Thesis This section provides a brief description of the structure of the thesis. Chapter 1 (this chapter) provides an overview of the research and the contributions. <p> The experiments described in this chapter show the results of both approaches. 4.1 The FDO/HLS Experiment The FDO/HLS system <ref> [36] </ref> was constructed to evaluate the feasibility of feedback di rected optimization in design domains. The system solves design problems in the domain of High Level Synthesis of digital filters (Section 2.1). The domain was chosen because the problems are well understood with existing benchmarks and evaluation criteria. <p> The framework has been used to extend two existing systems, DAA [33] and MACHINIST [20, 22], and to build a new system FDO/HLS <ref> [36] </ref>. One of the major results of this research is to show that feedback (beyond just resource usage of a solution) is useful and that automated techniques for supporting feedback have been developed.
Reference: [37] <author> C.W. Liew, L.I. Steinberg, and C.H. Tong. </author> <title> Use of feedback to control redesign. In D.C. </title> <editor> Brown, M. Waldron, and H. Yoshikawa, editors, </editor> <booktitle> Proceedings of the IFIP TC5/WG5.2 Working Conference on Intelligent Computer Aided Design, </booktitle> <year> 1991. </year>
Reference-contexts: The description covers the two techniques that have been developed, Resource Decomposition Trees and Constrained-Redo. It also describes a framework showing how Feedback Directed Optimization can be used in designing and developing new design systems using feedback. Part of this research was reported earlier in <ref> [37] </ref>. 3.1 Overview of Feedback Directed Optimization Conceptually, feedback can provide information that will help a problem solver to improve the quality of solutions. The information might describe how subproblems or decisions interact in a way that was not predicted.
Reference: [38] <author> S. Lin and B.W. Kernighan. </author> <title> An effective heuristic for the travelling salesman problem. </title> <journal> Operations Research, </journal> <volume> 21 </volume> <pages> 498-516, </pages> <year> 1973. </year>
Reference-contexts: There are other optimization methods that use an analysis of a solution to determine how to directly modify and improve a solution. An example of this is the work of Lin 16 and Kernighan <ref> [38] </ref> on the travelling salesman problem. Direct modification of solutions is impractical for the domains that we have studied because the interactions between components makes it difficult to make localised changes and still ensure the correctness of the resulting solution. 2.4.1 Some techniques for credit-blame assignment.
Reference: [39] <author> Stacey Marsella. </author> <title> Planning under the restriction of Hierarchical Partial Orders. </title> <publisher> UMI, </publisher> <year> 1993. </year>
Reference-contexts: In recent years, there has been research that has been focussed on characterising the interactions and developing ways of using this characterisation in problem solving. Problem solvers are guided or restricted in such a way as to only have interactions of a specified type. The PRL system <ref> [39] </ref> uses compiled knowledge to compose music with different requisite structures. The FDO approach on the other hand uses analysis to determine what the desirable or undesirable interactions are.
Reference: [40] <author> Stacey Marsella and C.F. Schmidt. </author> <title> On the application of problem reduction search to automated composition. In Understanding Music with AI: Perspectives on Music Cognition. </title> <publisher> MIT Press/AAAI Press, </publisher> <year> 1992. </year>
Reference-contexts: These techniques do not use design records and therefore do not have the problems described earlier in this section 5.2.2 Using problem decomposition to solve interacting problems Problem decomposition has been one of the main research issues in AI for many years <ref> [49, 55, 40, 56, 23] </ref>. The research has been focussed on developing ways of finding good decompositions for problems, i.e., decompose them into non-interacting subproblems. This approach has had some success but has not been applicable for problems with global constraints, e.g., design optimization problems.
Reference: [41] <author> M.C. McFarland. </author> <title> Computer-aided partitioning of behavioural hardware descriptions. </title> <booktitle> In Proceedings of the 20th Design Automation Conference, </booktitle> <year> 1983. </year>
Reference-contexts: N is the exponent specified by the user for the objective function AT N . The measure described above is similar to one developed by McFarland in <ref> [41] </ref>. Initially a distance matrix is computed that gives the distance for each pair of op erations. Using the method of [28], the system forms a hierarchical clustering tree that is based on the distances in the distance matrix.
Reference: [42] <author> M.C. McFarland. </author> <title> Using bottom-up design techniques in the synthesis of digital hardware from abstract behavioral descriptions. </title> <booktitle> In Proceedings of the 23rd Design Automation Conference, </booktitle> <year> 1986. </year>
Reference-contexts: Work on the development and learning of estimation functions includes the early work of Samuels in checkers [50] and the more recent work in VLSI of Jain [26, 27, 25], Kucukcakar [34] and McFarland <ref> [42] </ref>. The FDO research complements this body of work in that it focusses on developing methods for correcting inefficiencies a posteriori that could not be detected with estimation functions. <p> The module allocator has a library of module prototypes that can be instantiated by specifying the clock speed and bit-width of the desired module. There are two available libraries, a CMOS7000 series from LSI logic and the library that is used by BUD/DAA <ref> [42] </ref>. HLS assumes that all modules are 16 bits wide. Initially, the allocator uses the schedule and assumptions about the clock cycle to determine an initial allocation of the most expensive modules, mainly the ALUs and multipliers and dividers. <p> The DAA system is described first followed by a description of the extensions that were added to build the FDO/DAA system. The experiments are subsequently discussed followed by the conclusions that were reached. Much of the description of DAA is extracted from <ref> [42] </ref> and [32]. The reader who is interested in more details about the DAA system should refer to the two references. <p> The system was originally developed at CMU as part of 96 the CMUDA project and later extended at AT&T as part of the Algorithms to Silicon Project. The next paragraph describing the high level function of DAA is extracted directly from <ref> [42] </ref>. The problem is given as a behavioural description in the ISPS language [1] used to describe the behaviour of microprocessors. The behavioural description is then compiled into a data-flow graph. <p> More precisely the distance between two operations x and y is defined to be (from <ref> [42] </ref>): dist (x; y) = S 1 fi f prox (x; y) S 2 fi cprox (x; y) + N fi S 3 fi par (x; y) (4.1) where f prox (x; y) = f cost (x) + f cost (y) f cost (xy) f cost (xy) cprox (x; y) =
Reference: [43] <author> M.C. McFarland S.J. and T.J. Kowalski. </author> <title> Incorporating bottom-up design into hardware synthesis. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 9(9) </volume> <pages> 938-950, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: For example, TIME and AREA often interact synergistically such that the fastest circuit is frequently the smallest circuit but there are also parts of the circuit where addition of another hardware module thus increasing AREA would result in a faster circuit. McFarland and Kowalski <ref> [43] </ref> showed that for many VLSI HLS problems, the resource interactions cannot be easily predicted and thus there is no clearly identifiable tradeoff curve between the resources. In many cases, especially for large problems, it is difficult to determine if the specified resource budgets are even feasible.
Reference: [44] <author> Michael C. McFarland S.J., Alice C. Parker, and Raul Camposano. </author> <title> Tutorial on high-level synthesis. </title> <booktitle> In Proceedings of the 25th Design Automation Conference, </booktitle> <year> 1988. </year>
Reference-contexts: A more detailed description of High Level Synthesis can be found in <ref> [44] </ref>. The VLSI High Level Synthesis problem is to take an algorithmic (functional) description and generate a register transfer level (RTL) description of a VLSI chip.
Reference: [45] <author> T. M. Mitchell, R. M. Keller, and S. T. Kedar-Cabelli. </author> <title> Explanation-based generalization: A unifying view. </title> <journal> Machine Learning, </journal> <volume> 1(1), </volume> <year> 1986. </year> <month> 139 </month>
Reference-contexts: Design records are needed for techniques like dependency directed backtracking [54], assumption based truth maintenance [10] and explanation based generalisation <ref> [45] </ref>. * fault localization by component: Resource budget violations are localized to a small set of components or sets of components by resource usage.
Reference: [46] <author> J. Mostow, M. Barley, and T. Weinrich. </author> <title> Automated reuse of design plans in BOGART. </title> <booktitle> In Artificial Intelligence in Engineering Design, Volume II. </booktitle> <publisher> Academic Press, </publisher> <year> 1992. </year>
Reference-contexts: CBR has most often been used for inter-problem learning where experience in solving other problems is used to help solve a new problem. Examples of systems that use CBR are CHEF [18], KRITIK [17], BOGART <ref> [46] </ref> and ARGO [24]. There are several differences between CBR systems and the systems that use feedback to solve design optimization problems. An obvious one is that CBR has been commonly used for transferring knowledge between problem solving episodes while design optimization systems have used feedback for intra-problem learning.
Reference: [47] <author> Mark F. Orelup, John R. Dixon, Paul R. Cohen, and Melvin K. Simmons. DO-MINIC II: </author> <title> Meta-Level Control in Iterative Redesign. </title> <booktitle> In Proceedings of AAAI-88, </booktitle> <year> 1988. </year>
Reference-contexts: The feedback based model has been explored by researchers in a number of domains, e.g., Knapp in VLSI [29], Dixon and his colleagues in mechanical engineering <ref> [23, 47] </ref> and Breuer in VLSI [5]. The main assumption underlying feedback approaches is that it is easier and more efficient to detect some interactions by analysing a solution, than it is to constrain the problem solver from generating all interactions of those types. <p> This section describes several systems and techniques that use feedback to control the problem solver. Most of these systems have been developed to solve design optimization problems. The DOMINIC system. The DOMINIC system <ref> [23, 47] </ref> uses feedback to solve parameter selection design problems in mechanical engineering. The system uses hierarchical decomposition techniques to decompose a problem structurally until all that is left is to instantiate the numerical parameters for the structural components, e.g., number of gear teeth in a gear pair.
Reference: [48] <author> P.G. Paulin, J.P. Knight, and E.F. Girczyc. HAL: </author> <title> A multi-paradigm approach to automatic data path synthesis. </title> <booktitle> In Proceedings of the 23rd ACM/IEEE Design Automation Conference, </booktitle> <year> 1986. </year>
Reference-contexts: The system solves design problems in the domain of High Level Synthesis of digital filters (Section 2.1). The domain was chosen because the problems are well understood with existing benchmarks and evaluation criteria. The FDO/HLS system is a naive system compared to existing problem solvers that design digital filters <ref> [5, 33, 48, 8] </ref>. The intent of the system was solely to evaluate the feasibility of feedback, not to determine if it would improve expert systems.
Reference: [49] <author> E. D. Sacerdoti. </author> <title> A Structure for Plans and Behavior. </title> <publisher> Amsterdam: North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: These techniques do not use design records and therefore do not have the problems described earlier in this section 5.2.2 Using problem decomposition to solve interacting problems Problem decomposition has been one of the main research issues in AI for many years <ref> [49, 55, 40, 56, 23] </ref>. The research has been focussed on developing ways of finding good decompositions for problems, i.e., decompose them into non-interacting subproblems. This approach has had some success but has not been applicable for problems with global constraints, e.g., design optimization problems.
Reference: [50] <author> A. L. Samuel. </author> <title> Some studies of machine learning using the game of checkers. </title> <booktitle> In Computers and Thought, </booktitle> <pages> pages 71-105. </pages> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1963. </year>
Reference-contexts: There has been a rich history of work both within and outside of AI on developing good estimation functions and heuristics for problem solvers. Many problem solving techniques, e.g., min-max search with alpha-beta pruning <ref> [50] </ref>, are dependent on hav ing good estimation functions. Work on the development and learning of estimation functions includes the early work of Samuels in checkers [50] and the more recent work in VLSI of Jain [26, 27, 25], Kucukcakar [34] and McFarland [42]. <p> Many problem solving techniques, e.g., min-max search with alpha-beta pruning <ref> [50] </ref>, are dependent on hav ing good estimation functions. Work on the development and learning of estimation functions includes the early work of Samuels in checkers [50] and the more recent work in VLSI of Jain [26, 27, 25], Kucukcakar [34] and McFarland [42]. The FDO research complements this body of work in that it focusses on developing methods for correcting inefficiencies a posteriori that could not be detected with estimation functions. <p> The feedback could even be used between multiple levels of problem solvers. Additionally, the FDO/HLS system was the first system to show that feedback techniques could be automated and used in a system. Earlier feedback techniques <ref> [50, 29] </ref> were limited to information about the resource usage of the solution. The FASOLT system [31] showed in a non-automated way that feedback beyond just the resource usage of the system could be used to improve the quality of a solution.
Reference: [51] <editor> H. A. Simon. </editor> <booktitle> The Sciences Of The Artificial. </booktitle> <publisher> MIT Press, </publisher> <year> 1981. </year>
Reference-contexts: Finding the optimal solution is frequently infeasible because it is too expensive computationally to search the entire solution space. 1 The goal of finding the optimal solution has to be weakened to that of finding a satisficing solution <ref> [53, 52, 51] </ref>. In the case of resource optimization problems, many optimization techniques have a goal of improving the resource usage of an existing solution, rather than finding the solution with the lowest usage.
Reference: [52] <author> Herbert A. Simon. </author> <title> Models of Bounded Rationality: </title> <booktitle> Behavioral Economics and Business Organization, </booktitle> <volume> volume 2. </volume> <publisher> MIT Press, </publisher> <year> 1982. </year>
Reference-contexts: Finding the optimal solution is frequently infeasible because it is too expensive computationally to search the entire solution space. 1 The goal of finding the optimal solution has to be weakened to that of finding a satisficing solution <ref> [53, 52, 51] </ref>. In the case of resource optimization problems, many optimization techniques have a goal of improving the resource usage of an existing solution, rather than finding the solution with the lowest usage.
Reference: [53] <author> Herbert A. Simon. </author> <title> Models of Bounded Rationality: Economic Analysis and Public Policy, volume 1. </title> <publisher> MIT Press, </publisher> <year> 1982. </year>
Reference-contexts: Finding the optimal solution is frequently infeasible because it is too expensive computationally to search the entire solution space. 1 The goal of finding the optimal solution has to be weakened to that of finding a satisficing solution <ref> [53, 52, 51] </ref>. In the case of resource optimization problems, many optimization techniques have a goal of improving the resource usage of an existing solution, rather than finding the solution with the lowest usage.
Reference: [54] <author> R. Stallman and G. Sussman. </author> <title> Forward reasoning and dependency-directed backtracking in a system for computer-aided circuit analysis. </title> <journal> Artificial Intelligence, </journal> <volume> 9 </volume> <pages> 135-196, </pages> <year> 1977. </year>
Reference-contexts: These techniques have been developed primarily in the context of the analysis of either (1) complete, incorrect solutions or (2) incomplete solutions that the problem solver is unable to complete. Using dependency directed backtracking for credit-blame assignment. Dependency directed backtracking (DDB) <ref> [54] </ref> was one of the earliest domain independent techniques (other than chronological backtracking). It has been used to determine what decisions to change when a fault is determined, either through analysis of a complete solution or the failure point of an incomplete solution. <p> The information might describe how subproblems or decisions interact in a way that was not predicted. Existing AI techniques that provide detailed feedback of interactions between decisions and components require the use of design records <ref> [54] </ref>. <p> Design records are needed for techniques like dependency directed backtracking <ref> [54] </ref>, assumption based truth maintenance [10] and explanation based generalisation [45]. * fault localization by component: Resource budget violations are localized to a small set of components or sets of components by resource usage.
Reference: [55] <author> G. Sussman. </author> <title> A computer model of skill acquisition. </title> <address> American-Elsevier, New York, </address> <year> 1975. </year>
Reference-contexts: These techniques do not use design records and therefore do not have the problems described earlier in this section 5.2.2 Using problem decomposition to solve interacting problems Problem decomposition has been one of the main research issues in AI for many years <ref> [49, 55, 40, 56, 23] </ref>. The research has been focussed on developing ways of finding good decompositions for problems, i.e., decompose them into non-interacting subproblems. This approach has had some success but has not been applicable for problems with global constraints, e.g., design optimization problems.
Reference: [56] <author> Austin Tate. </author> <title> Generating project networks. </title> <booktitle> In Proceedings of IJCAI-77, </booktitle> <year> 1977. </year> <month> 140 </month>
Reference-contexts: These techniques do not use design records and therefore do not have the problems described earlier in this section 5.2.2 Using problem decomposition to solve interacting problems Problem decomposition has been one of the main research issues in AI for many years <ref> [49, 55, 40, 56, 23] </ref>. The research has been focussed on developing ways of finding good decompositions for problems, i.e., decompose them into non-interacting subproblems. This approach has had some success but has not been applicable for problems with global constraints, e.g., design optimization problems.
References-found: 56

