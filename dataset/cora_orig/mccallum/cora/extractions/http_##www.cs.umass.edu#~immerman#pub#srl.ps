URL: http://www.cs.umass.edu/~immerman/pub/srl.ps
Refering-URL: http://www.cs.umass.edu/~immerman/pub_immerman.html
Root-URL: 
Title: The Expressiveness of a Family of Finite Set Languages  
Author: Neil Immerman Sushant Patnaik David Stemple 
Date: 155(1) (1996), 111-140.  
Note: Theoretical Computer Science  
Address: Amherst, MA 01003  
Affiliation: Computer and Information Science Department University of Massachusetts  
Abstract: In this paper we characterise exactly the complexity of a set based database language called SRL, which presents a unified framework for queries and updates. By imposing simple syntactic restrictions on it, we are able to express exactly the classes, P and LOGSPACE. We also discuss the role of ordering in database query languages and show that the hom operator of Machiavelli language in [OBB89] does not capture all the order-independent properties.
Abstract-found: 1
Intro-found: 1
Reference: [AU79] <author> A. Aho, J. Ullman: </author> <title> Universality of data retrieval languages. </title> <booktitle> Proceedings of Sixth ACM Symposium on POPL, </booktitle> <month> Jan. </month> <year> 1979, </year> <pages> 110-117. </pages>
Reference-contexts: There have been numerous studies of the expressive power of query languages. For instance, it is well known that first order relational query languages are limited in their expressibility <ref> [AU79] </ref>. However when augmented with recursion or looping (as an added primitive) they become sufficiently powerful to express exactly the queries 2 in various complexity classes. Characterizing the expressive power of such languages has been the principal object of study in [Va82], [CH80], [CH82a], [CH82b], [AU79], [Imm82], [AV89]. <p> are limited in their expressibility <ref> [AU79] </ref>. However when augmented with recursion or looping (as an added primitive) they become sufficiently powerful to express exactly the queries 2 in various complexity classes. Characterizing the expressive power of such languages has been the principal object of study in [Va82], [CH80], [CH82a], [CH82b], [AU79], [Imm82], [AV89]. For example, Immerman and Vardi discovered independently that fixpoint logic plus ordering expresses the set of polynomial time computable queries [Va82], [Imm82]. A common and rather useful way of measuring expressiveness is to use complexity characterizations. <p> We then show that natural restrictions of this language capture P , DSP ACE (log n) and N SP ACE (log n). The expressive power of the bounded loop construct or its variant has been studied before in <ref> [AU79] </ref>, [Va82], [Q89], [CH80], [Imm87], [AV88] but not in this framework.
Reference: [AK90] <author> S. Abiteboul, P. Kanellakis: </author> <title> Database theory column: Query languages for complex object databases. </title> <journal> SIGACT News 21 No. </journal> <volume> 3, </volume> <month> Summer </month> <year> 1990, </year> <pages> 9-18. </pages>
Reference-contexts: Her looping construct closely resembles the set-reduce operator, however the two corresponding languages differ in their algebras. Her definition of "non-deterministic" semantics, identical to Abiteboul and Vianu's, does not lead to a decidable distinction between non-deterministic and deterministic languages. In a recent paper <ref> [AK90] </ref>, Abiteboul and Kanellakis discuss an object oriented database programming language wherein objects are built by applying set and tuple constructors. They define an algebra for their language which is built from first-order operators augmented with the powerset operator.
Reference: [AK89] <author> S. Abiteboul, P. Kanellakis: </author> <title> Object identity as a query language primitive. Rapports de Recherche No. </title> <type> 1022, </type> <institution> INRIA, </institution> <month> Apr </month> <year> 1989. </year>
Reference: [AB88] <author> S. Abiteboul, C. Beeri: </author> <title> On the power of languages for the manipulation of complex objects. Rapports de Recherche no. </title> <type> 846, </type> <institution> INRIA, </institution> <month> May </month> <year> 1988. </year> <month> 33 </month>
Reference: [AC89] <author> F. Arafati, S. Cosmadakis: </author> <title> Expressiveness of restricted recursive queries, </title> <booktitle> Proceed--ings of 21st ACM STOC, </booktitle> <year> 1989, </year> <pages> 113-126. </pages>
Reference-contexts: Interestingly, most of the classes of queries considered turned out to capture some complexity class. It seems that certain query language comparisons are connected with deep problems of complexity theory. Recently parallel evaluation of recursive queries has also drawn considerable attention in [CK85], <ref> [AC89] </ref>. In the past the emphasis has been to develop a natural set of primitives for a query language so that it can compute all the computable queries as in [CH80], [Ch81], [AV88]. Unbounded arity relations or the ability to create new values have been used.
Reference: [AV88] <author> S. Abiteboul, V. Vianu: </author> <title> Procedural and declarative database update languages. </title> <booktitle> Proceedings of the Seventh ACM SIGACT-SIGMOD-SIGART Symposium on PODS, </booktitle> <year> 1988, </year> <pages> 240-250. </pages>
Reference-contexts: Recently parallel evaluation of recursive queries has also drawn considerable attention in [CK85], [AC89]. In the past the emphasis has been to develop a natural set of primitives for a query language so that it can compute all the computable queries as in [CH80], [Ch81], <ref> [AV88] </ref>. Unbounded arity relations or the ability to create new values have been used. <p> We then show that natural restrictions of this language capture P , DSP ACE (log n) and N SP ACE (log n). The expressive power of the bounded loop construct or its variant has been studied before in [AU79], [Va82], [Q89], [CH80], [Imm87], <ref> [AV88] </ref> but not in this framework. <p> The set-reduce construct provides a partial 1 Here a complete database language is one that can compute every partial recursive function of its database [CH80]. 3 answer. In <ref> [AV88] </ref>, Abiteboul and Vianu present declarative and procedural update languages and show that they are complete in Chandra and Harel's sense. They also define restrictions on their languages and characterize their expressiveness. They define the so-called "non-deterministic" updates and show certain languages to be "non-deterministic" update complete. <p> Remarks. This hierarchy is mentioned here for the sake of completeness. It is quite similar in notion to the results of [HS88], <ref> [AV88] </ref> and others. 7. The Role of Ordering A set stored by a computer has its members in some order. Simply put, any object is a sequence of bits, thus falling in place in lexicographical order.
Reference: [AV89] <author> S. Abiteboul, V. Vianu: </author> <title> Fixpoint extensions of first-order logic and datalog-like languages. </title> <booktitle> Proceedings of LICS, </booktitle> <year> 1989, </year> <pages> 2-11. </pages>
Reference-contexts: However when augmented with recursion or looping (as an added primitive) they become sufficiently powerful to express exactly the queries 2 in various complexity classes. Characterizing the expressive power of such languages has been the principal object of study in [Va82], [CH80], [CH82a], [CH82b], [AU79], [Imm82], <ref> [AV89] </ref>. For example, Immerman and Vardi discovered independently that fixpoint logic plus ordering expresses the set of polynomial time computable queries [Va82], [Imm82]. A common and rather useful way of measuring expressiveness is to use complexity characterizations.
Reference: [AV91] <author> S. Abiteboul, V. Vianu: </author> <title> Generic computation and its complexity. </title> <note> To appear in 32nd IEEE Symposium on FOCS, </note> <year> 1991. </year>
Reference-contexts: Thus we 2 In [Va82], Vardi defined the language (FO + while ), i.e. first-order logic together with an unbounded iteration operator, and showed that its expressive power is equal to PSPACE. (See also [Imm82b] for an equivalent formulation of an unbounded iterator applied to FO giving PSPACE.) See also <ref> [AV91] </ref> for a surprising new result: (FO (wo) + while) = (FO (wo) + LFP) if and only if P = PSPACE. 31 can compute hom of a set by walking through the color classes occurring in the set, applying the operator by hand to at most four elements in each
Reference: [BIS88] <author> D. Barrington, N. Immerman, H. Straubing: </author> <title> On uniformity within N C 1 . Journal of Computer Systems and Science 41, </title> <journal> No. </journal> <volume> 3, </volume> <year> 1990, </year> <pages> 274-306. </pages>
Reference: [BM] <author> R.S.Boyer, </author> <title> J.S.Moore:A Computational Logic, </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference: [CFI89] <author> J. Cai, M. Furer, N. Immerman: </author> <title> An optimal lower bound on the number of variables for graph identification. </title> <booktitle> Proceedings of 30th IEEE Symposium on FOCS, </booktitle> <year> 1989, </year> <pages> 612-617. </pages>
Reference-contexts: Here i is a number variable and x is a domain variable. For quite a while, it was an open question whether the language (FO (wo)+LFP+ count) is equal to order independent P. A positive answer would have provided a nice solution to Question 7.1. Instead, in <ref> [CFI89] </ref> it was proved that that (FO (wo) + LFP + count) is strictly contained in order-independent P. See Theorem 7.8 below for an explanation and slight generalization of this result. <p> Let f : D ! N be the function that takes everything in the database domain to the number 1. Then we can count a set S D using hom as follows: count (S) = hom (f; +; 0; S) We next show that the lower bound from <ref> [CFI89] </ref> does apply to the language (FO (wo) + N + hom). It also applies to the language (FO (wo) + count + while). 2 Theorem 7.8 The set (order-independent P) is not contained in (FO (wo) + N + hom + while). Proof The paper [CFI89] constructs a sequence of <p> the lower bound from <ref> [CFI89] </ref> does apply to the language (FO (wo) + N + hom). It also applies to the language (FO (wo) + count + while). 2 Theorem 7.8 The set (order-independent P) is not contained in (FO (wo) + N + hom + while). Proof The paper [CFI89] constructs a sequence of structures G n ; H n , n = 1; 2; : : :. These structures contain O [n] domain elements. G n and H n may be distinguished in linear time if we have access to any ordering on their domains.
Reference: [CH80] <author> A. Chandra, D. Harel: </author> <title> Computable queries for relational databases. </title> <journal> Journal of Computer Systems and Science 21, </journal> <year> 1980, </year> <pages> 156-178. </pages>
Reference-contexts: However when augmented with recursion or looping (as an added primitive) they become sufficiently powerful to express exactly the queries 2 in various complexity classes. Characterizing the expressive power of such languages has been the principal object of study in [Va82], <ref> [CH80] </ref>, [CH82a], [CH82b], [AU79], [Imm82], [AV89]. For example, Immerman and Vardi discovered independently that fixpoint logic plus ordering expresses the set of polynomial time computable queries [Va82], [Imm82]. A common and rather useful way of measuring expressiveness is to use complexity characterizations. <p> Recently parallel evaluation of recursive queries has also drawn considerable attention in [CK85], [AC89]. In the past the emphasis has been to develop a natural set of primitives for a query language so that it can compute all the computable queries as in <ref> [CH80] </ref>, [Ch81], [AV88]. Unbounded arity relations or the ability to create new values have been used. For example, Chandra and Harel, in [CH80], define the concept of computable queries and present a complete database programming language and show that relational algebra augmented with the power of iteration is complete. 1 In <p> the past the emphasis has been to develop a natural set of primitives for a query language so that it can compute all the computable queries as in <ref> [CH80] </ref>, [Ch81], [AV88]. Unbounded arity relations or the ability to create new values have been used. For example, Chandra and Harel, in [CH80], define the concept of computable queries and present a complete database programming language and show that relational algebra augmented with the power of iteration is complete. 1 In [HS89b], Hull and Su consider a hierarchy of languages whose complexity is in the super exponential range. <p> We then show that natural restrictions of this language capture P , DSP ACE (log n) and N SP ACE (log n). The expressive power of the bounded loop construct or its variant has been studied before in [AU79], [Va82], [Q89], <ref> [CH80] </ref>, [Imm87], [AV88] but not in this framework. <p> The set-reduce construct provides a partial 1 Here a complete database language is one that can compute every partial recursive function of its database <ref> [CH80] </ref>. 3 answer. In [AV88], Abiteboul and Vianu present declarative and procedural update languages and show that they are complete in Chandra and Harel's sense. They also define restrictions on their languages and characterize their expressiveness.
Reference: [CH82a] <author> A. Chandra, D. Harel: </author> <title> Structure and complexity of relational queries. </title> <journal> Journal of Computer Systems and Science 25, </journal> <year> 1982, </year> <pages> 99-128. </pages>
Reference-contexts: However when augmented with recursion or looping (as an added primitive) they become sufficiently powerful to express exactly the queries 2 in various complexity classes. Characterizing the expressive power of such languages has been the principal object of study in [Va82], [CH80], <ref> [CH82a] </ref>, [CH82b], [AU79], [Imm82], [AV89]. For example, Immerman and Vardi discovered independently that fixpoint logic plus ordering expresses the set of polynomial time computable queries [Va82], [Imm82]. A common and rather useful way of measuring expressiveness is to use complexity characterizations. <p> In any case, there is general sentiment in the theoretical database community that ordering is dangerous and that order dependent queries should be avoided. In fact, in the influential paper <ref> [CH82a] </ref>, Chandra and Harel define a query to be an order-independent query and they ask the question: Question 7.1 Is there a natural language that expresses exactly the set of polynomial-time computable, order-independent queries? One can make this question more precise by removing the undefined term "natural" and instead ask: Question <p> See [IL90] for a history of this subject. Here we give an overview of what is known about Questions 7.1 and 7.2. In a preliminary version of the paper <ref> [CH82a] </ref>, Chandra and Harel defined fixed point logic, FP, which is an extension of first-order logic to include applications of the fixed point operator, thus allowing the inductive definition of new relations. In symbols: FP = (FO (wo)+ LFP).
Reference: [CH82b] <author> A. Chandra, D. Harel: </author> <title> Horn clauses and fixpoint query hierarchy. </title> <booktitle> Proceedings of 14th ACM STOC, </booktitle> <month> May </month> <year> 1982, </year> <pages> 158-163. </pages>
Reference-contexts: However when augmented with recursion or looping (as an added primitive) they become sufficiently powerful to express exactly the queries 2 in various complexity classes. Characterizing the expressive power of such languages has been the principal object of study in [Va82], [CH80], [CH82a], <ref> [CH82b] </ref>, [AU79], [Imm82], [AV89]. For example, Immerman and Vardi discovered independently that fixpoint logic plus ordering expresses the set of polynomial time computable queries [Va82], [Imm82]. A common and rather useful way of measuring expressiveness is to use complexity characterizations.
Reference: [Ch81] <author> A. Chandra: </author> <title> Programming primitives for database languages. </title> <booktitle> Proceedings of ACM Symposium on POPL, </booktitle> <year> 1981, </year> <pages> 50-62. </pages>
Reference-contexts: Recently parallel evaluation of recursive queries has also drawn considerable attention in [CK85], [AC89]. In the past the emphasis has been to develop a natural set of primitives for a query language so that it can compute all the computable queries as in [CH80], <ref> [Ch81] </ref>, [AV88]. Unbounded arity relations or the ability to create new values have been used. <p> The expressive power of the bounded loop construct or its variant has been studied before in [AU79], [Va82], [Q89], [CH80], [Imm87], [AV88] but not in this framework. In <ref> [Ch81] </ref>, Chandra raises the question of specifying a set of primitives of the form forall tuples t in relation R do statement S, where S is restricted so as not to use the order in which the forall cycles over all the tuples, such that programs in this style can compute
Reference: [CSV84] <author> A. Chandra, L. Stockmeyer, U. Vishkin: </author> <title> Constant-depth reducibility, </title> <journal> SIAM Journal of Computing 13, </journal> <month> May </month> <year> 1984, </year> <pages> 423-439. </pages>
Reference: [Co64] <author> A. Cobham: </author> <title> The intrinsic computational difficulty of functions. </title> <booktitle> Proceedings of the 1964 Congress for Logic, Philosophy and Methodology of Science, </booktitle> <publisher> North Holland, </publisher> <pages> 24-30. </pages>
Reference-contexts: Let us denote this restricted version of the language as SRL. Definition 2.3 We define the class of decision problems (respectively, functions) expressible in SRL as L (SRL) (F (SRL)). Functions expressible in SRL are similar to Cobham's recursive functions <ref> [Co64] </ref> and we show that the two classes are indeed equivalent. The restrictions on set-height and tuple-width are, as shown later, quite crucial to our result.
Reference: [C85] <author> S. Cook: </author> <title> A taxonomy of problems with fast parallel algorithms. </title> <booktitle> Information and Control 64, </booktitle> <year> (1985), </year> <pages> 2-22. </pages>
Reference-contexts: It follows that "proper Machiavelli" is contained in the class NC consisting of those problems computable in parallel time (log n) O [1] using polynomially many processors. NC is believed to be strictly contained in P <ref> [C85] </ref>. We can alleviate this problem by allowing "proper HL" to iterate an operation polynomially many times. One way to do this is to consider the language similar to (FO (wo) + LFP + count) which has a number domain, N , separate from the database domain.
Reference: [CM87] <author> S. Cook, P. McKenzie: </author> <title> Problems complete for deterministic logspace. </title> <journal> Journal of Algorithms 8, </journal> <year> 1987, </year> <pages> 385-394. </pages>
Reference: [CK85] <author> S. Cosmadakis, P. Kanellakis: </author> <title> Parallel evaluation of recursive rule queries. </title> <booktitle> Proceedings of 5th ACM Symposium on PODS, </booktitle> <year> 1986, </year> <pages> 280-290. </pages>
Reference-contexts: Interestingly, most of the classes of queries considered turned out to capture some complexity class. It seems that certain query language comparisons are connected with deep problems of complexity theory. Recently parallel evaluation of recursive queries has also drawn considerable attention in <ref> [CK85] </ref>, [AC89]. In the past the emphasis has been to develop a natural set of primitives for a query language so that it can compute all the computable queries as in [CH80], [Ch81], [AV88]. Unbounded arity relations or the ability to create new values have been used.
Reference: [DW] <author> M. Davis, S. Weyukar: </author> <title> Computability, Complexity and Languages. </title> <publisher> Academic Press, </publisher> <year> 1983. </year>
Reference-contexts: However, we show that these versions express all the primitive recursive functions. Observe that SRL contains a bounded successor function whereas SRL + new contains an unbounded successor function. Let P rimRec denote the class of primitive recursive functions. Recall the definition of P rimRec <ref> [DW] </ref>. Definition 5.1 Let g :N ! N, h :N fi N ! N.
Reference: [Gu83] <author> Y. Gurevich: </author> <title> Algebras of Feasible Functions. </title> <booktitle> Proceedings of 24th IEEE Symposium on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1983, </year> <pages> 210-214. 34 </pages>
Reference-contexts: The latter immediately puts the data-complexity of their language in the exponential range. Had they instead defined a bounded iterator operator, as we do, then it would have been possible ***************** iteration to derive sub-languages whose complexities lie between first-order and exponential. In <ref> [Gu83] </ref>, Gurevich characterized the complexity of functions defined using primitive recursion over structures with finite domains. He showed that different versions of the language (with bounded successor) capture functions in polynomial time and logspace. This paper is organized as follows. Section 2 defines the set-reduce language and gives some background.
Reference: [HS89a] <author> R. Hull, J. Su: </author> <title> Untyped sets, invention and computable queries. </title> <booktitle> Proceedings of 8th ACM Symposium on PODS, </booktitle> <year> 1989, </year> <pages> 347-360. </pages>
Reference: [HS89b] <author> R. Hull, J. Su: </author> <title> On bulk data type constructors and manipulation primitives - a framework for analyzing expressive power and complexity. </title> <booktitle> Proceedings of 2nd International Workshop on Database Programming Languages, </booktitle> <month> June </month> <year> 1989, </year> <pages> 396-410. </pages>
Reference-contexts: Unbounded arity relations or the ability to create new values have been used. For example, Chandra and Harel, in [CH80], define the concept of computable queries and present a complete database programming language and show that relational algebra augmented with the power of iteration is complete. 1 In <ref> [HS89b] </ref>, Hull and Su consider a hierarchy of languages whose complexity is in the super exponential range. However, we are interested in devising a natural language whose complexity is clear from the syntax but for feasible complexity classes from a database point of view, e.g.
Reference: [HS88] <author> R. Hull, J. Su: </author> <title> On the expressive power of database queries with intermediate types. </title> <booktitle> Proceedings of 7th ACM Symposium on PODS, </booktitle> <month> Mar. </month> <year> 1988, </year> <pages> 39-51. </pages>
Reference-contexts: Remarks. This hierarchy is mentioned here for the sake of completeness. It is quite similar in notion to the results of <ref> [HS88] </ref>, [AV88] and others. 7. The Role of Ordering A set stored by a computer has its members in some order. Simply put, any object is a sequence of bits, thus falling in place in lexicographical order.
Reference: [Imm87] <author> N. Immerman: </author> <title> Languages that capture complexity classes. </title> <journal> SIAM Journal on Computing 16 No. </journal> <volume> 4, </volume> <month> Aug. </month> <year> 1987, </year> <pages> 760-778. </pages>
Reference-contexts: We then show that natural restrictions of this language capture P , DSP ACE (log n) and N SP ACE (log n). The expressive power of the bounded loop construct or its variant has been studied before in [AU79], [Va82], [Q89], [CH80], <ref> [Imm87] </ref>, [AV88] but not in this framework. <p> He showed that different versions of the language (with bounded successor) capture functions in polynomial time and logspace. This paper is organized as follows. Section 2 defines the set-reduce language and gives some background. Section 3 presents some tools of descriptive complexity <ref> [Imm87] </ref> and proves that SRL (with set-height at most 1) = P . Section 4 describes ways of restricting the complexity of SRL. Section 5 shows that unrestricted SRL with sets of unbounded width (or, equivalently, SRL with invented values) captures the class of primitive recursive functions. <p> Expressiveness of SRL Our approach to characterizing the expressive complexity of SRL follows the conventions of descriptive complexity <ref> [Imm87] </ref>. We will code all inputs as finite logical structures. The universe of structure is f0; 1; : : : ; n 1g and is denoted by D. We assume that the ordering on the universe (or, synonymously, domain) is given by the one on natural numbers. <p> Let FO be the set of first-order definable problems: F O = fSj (9t )(9' 2 L (t ))S 2 ST RU CT [t ] j= 'g: Let us recall the definition of first-order interpretation <ref> [IL89, Imm87] </ref>. We assume a bit-encoding for the relations in the definition. For example, R (x; y) over D = f0; : : : ; n 1g is represented by a sequence of n 2 bits such that R (x; y) is true iff nx + y-th bit is 1. <p> Let AGAP = fGjAP AT H (V 0 ; V max )g. The predicate, included in the base functions of SRL is crucial to the following result. Fact 3.5 (<ref> [Imm87] </ref>) AGAP is complete for P under first-order reductions. Consider the following monotone operator [Imm87]:- (R)[x; y] (x = y) _ [(9z)(E (x; z) ^ R (z; y)) ^ (A (x) ! ((8z)E (x; z) ! R (z; y)))] It is easy to see that LF P () = AP AT H. <p> Characterizing L and N L as some form of SRL would be interesting since problems in these classes are also efficiently parallelizable. One way of doing this follows easily from the results in <ref> [Imm87] </ref>. We adopt the same notations. Let '(x; x 0 ) be any FO formula. Define T C [x; x 0 '] as the reflexive, transitive closure of the relation '.
Reference: [Imm82] <author> N. Immerman: </author> <title> Relational queries computable in polynomial time. </title> <booktitle> Proceedings of the 14th ACM STOC, </booktitle> <month> May </month> <year> 1982, </year> <pages> 147-152. </pages>
Reference-contexts: However when augmented with recursion or looping (as an added primitive) they become sufficiently powerful to express exactly the queries 2 in various complexity classes. Characterizing the expressive power of such languages has been the principal object of study in [Va82], [CH80], [CH82a], [CH82b], [AU79], <ref> [Imm82] </ref>, [AV89]. For example, Immerman and Vardi discovered independently that fixpoint logic plus ordering expresses the set of polynomial time computable queries [Va82], [Imm82]. A common and rather useful way of measuring expressiveness is to use complexity characterizations. <p> Characterizing the expressive power of such languages has been the principal object of study in [Va82], [CH80], [CH82a], [CH82b], [AU79], <ref> [Imm82] </ref>, [AV89]. For example, Immerman and Vardi discovered independently that fixpoint logic plus ordering expresses the set of polynomial time computable queries [Va82], [Imm82]. A common and rather useful way of measuring expressiveness is to use complexity characterizations. One finds classes of queries capturing LOGSP ACE; P; P SP ACE; P RIM REC. Interestingly, most of the classes of queries considered turned out to capture some complexity class. <p> Indeed, before 1989, examples involving the counting of large, unstructured sets were the only problems known to be in order-independent P but not in (FO (wo) + LFP). In 1982, Immerman <ref> [Imm82] </ref> considered the language (FO (wo)+LFP+count) in which structures are two-sorted, with an unordered domain D = fd 0 ; d 1 ; : : : ; d n1 g and a separate number domain: N = f0; 1; : : : ; n 1g with the database predicates defined on
Reference: [Imm82b] <author> N. Immerman: </author> <title> Upper and lower bounds for first order expressibility. </title> <journal> Journal of Computer and System Sciences 25, </journal> <year> 1982, </year> <pages> 76-98. </pages>
Reference-contexts: Thus we 2 In [Va82], Vardi defined the language (FO + while ), i.e. first-order logic together with an unbounded iteration operator, and showed that its expressive power is equal to PSPACE. (See also <ref> [Imm82b] </ref> for an equivalent formulation of an unbounded iterator applied to FO giving PSPACE.) See also [AV91] for a surprising new result: (FO (wo) + while) = (FO (wo) + LFP) if and only if P = PSPACE. 31 can compute hom of a set by walking through the color classes
Reference: [Imm88] <author> N. Immermann: </author> <title> Nondeterministic space is closed under complementation. </title> <journal> SIAM J. Comput. </journal> <volume> 17, No. 5, </volume> <year> (1988), </year> <pages> 935-938. </pages>
Reference: [IL89] <author> N. Immerman, S. Landau: </author> <title> The complexity of iterated multiplication. </title> <booktitle> Proceedings of 4th Structure in Complexity Theory Conference, </booktitle> <year> 1989, </year> <pages> 104-111. </pages>
Reference-contexts: Let FO be the set of first-order definable problems: F O = fSj (9t )(9' 2 L (t ))S 2 ST RU CT [t ] j= 'g: Let us recall the definition of first-order interpretation <ref> [IL89, Imm87] </ref>. We assume a bit-encoding for the relations in the definition. For example, R (x; y) over D = f0; : : : ; n 1g is represented by a sequence of n 2 bits such that R (x; y) is true iff nx + y-th bit is 1. <p> In other words, any relation of T 2 ST RU CT (t ) is defined by a formula in first order logic over the relations of S 2 ST RU CT (). We refer the reader to <ref> [IL89] </ref> for further details and examples of such reductions. Definition 3.2 A class C is closed under FO interpretations if for any problem T ST RU CT [t ] in C and for any problem S ST RU CT [], S fo T implies that S is in C.
Reference: [IL90] <author> N. Immerman, E. Lander: </author> <title> Describing graphs: a first-order approach to graph canonization. Complexity Theory Retrospective, </title> <editor> A. Selman, ed., </editor> <publisher> Springer Verlag (1990). </publisher>
Reference-contexts: See <ref> [IL90] </ref> for a history of this subject. Here we give an overview of what is known about Questions 7.1 and 7.2. <p> One of us (Immerman) has studied the issue of ordering because of its intimate connection with his study of descriptive and computational complexity <ref> [IL90] </ref>. Another of us (Stemple) has developed a theory of finite sets because of their importance in database transactions [SS89].
Reference: [K88] <author> P. Kanellakis: </author> <title> Elements of relational database theory. </title> <type> Tech. Report CS-88-09, </type> <institution> Dept. Of Computer Science, Brown University, </institution> <month> Apr. </month> <year> 1988. </year>
Reference: [OBB89] <author> A. Ohori, P. Buneman, V. Breazu-Tannen: </author> <title> Database programming in Machiavelli a polymorphic language with static type interference. </title> <booktitle> Proceedings of the ACM SIGMOD, </booktitle> <month> June </month> <year> 1989, </year> <pages> 46-57. </pages>
Reference-contexts: Our measure of complexity is data-complexity as defined by Vardi [Va82]. The set-reduce construct (defined in section 2) can be thought of as a bounded loop primitive. See [SS89] for more details. The set-reduce construct resembles the hom operator of the database programming language called Machiavelli <ref> [OBB89] </ref>. We define the transaction language, unrestricted SRL and show that its corresponding query language captures the primitive recursive properties. We then show that natural restrictions of this language capture P , DSP ACE (log n) and N SP ACE (log n). <p> See Figure 7.6 for the relationships between the polynomial-time query classes we have been discussing. 29 (FO (wo) + LFP) (FO (wo) + LFP + count) (order-independent P) (FO + LFP) = P proper containment.) Another approach to capturing order-independent queries is worthy of mention here. In <ref> [OBB89] </ref> the language Machiavelli is defined. It contains an operator called hom which is similar to set-reduce. <p> However, in <ref> [OBB89] </ref>, an instance of hom is called proper if the corresponding op is commutative and associative. It follows that an application of proper hom does not derive any information from the ordering in which a set is presented.
Reference: [Q89] <author> X.Qian: </author> <title> The expressive power of the bounded iteration construct. </title> <booktitle> Proceedings of the 2nd International Workshop on Database Programming Languages, </booktitle> <year> 1990. </year>
Reference-contexts: We then show that natural restrictions of this language capture P , DSP ACE (log n) and N SP ACE (log n). The expressive power of the bounded loop construct or its variant has been studied before in [AU79], [Va82], <ref> [Q89] </ref>, [CH80], [Imm87], [AV88] but not in this framework. <p> They define the so-called "non-deterministic" updates and show certain languages to be "non-deterministic" update complete. Their definition of "non-deterministic" updates is actually what we refer to as order-dependent. It should not be confused as such with non-determinism as referred to in complexity theory. In <ref> [Q89] </ref>, Qian studies the complexity of a bounded looping construct foreach x in R/p (x) do t (x) and shows that, under deterministic semantics, her language and a subclass of it have polynomial time and first order expressive power.
Reference: [SS89] <author> T. Sheard, D. Stemple: </author> <title> Automatic verification of database transaction safety. </title> <journal> ACM transactions on Database Systems 14, </journal> <volume> No. 3, </volume> <month> Sep. </month> <year> 1989, </year> <pages> 322-368. </pages>
Reference-contexts: Indeed, all of the interesting complexity classes are contained in P rimRec. Our measure of complexity is data-complexity as defined by Vardi [Va82]. The set-reduce construct (defined in section 2) can be thought of as a bounded loop primitive. See <ref> [SS89] </ref> for more details. The set-reduce construct resembles the hom operator of the database programming language called Machiavelli [OBB89]. We define the transaction language, unrestricted SRL and show that its corresponding query language captures the primitive recursive properties. <p> The extra template in the set-reduce operator is for the purpose of passing extra variables into functions so that all reference is local; the use of extra parameters makes nested variable scoping and currying unecessary while allowing succinct expression of a wide variety of functions and algorithms <ref> [SS89] </ref>. The input to any set-reduce expression is a structure or database specified by the name (s) of set (s) or relation (s). <p> typed T i for i = 1 to n; t = [e 1 ; :::; e i ; :::e n ] and t 0 = [e 0 1 ; :::; e 0 n ] i ) for i = 1 to n Finite sets The interested reader is referred to <ref> [SS89] </ref> for a formal specification of the semantics of emptyset; insert; choose and rest (the latter two used in the semantics of set reduce). Here, we point out the salient features. <p> T in the program above is typed as a set of tuples of width 2 and arbitrary nesting, and we redefine f insert as follows: f insert (x; T ) = insert (x:1; insert ([x:2; x:1]; T )) powerset (S) = set-reduce (S; identity; sif t; f [; ]g) In <ref> [SS89] </ref>, a list-reduce construct is defined which is exactly the same as set-reduce except that the object we recurse over is a list, and not a set. The difference is that the items appear in a specific order in the list. <p> One of us (Immerman) has studied the issue of ordering because of its intimate connection with his study of descriptive and computational complexity [IL90]. Another of us (Stemple) has developed a theory of finite sets because of their importance in database transactions <ref> [SS89] </ref>. It is an unaesthetic aspect of any such theory to date, that in order to develop a theory of unordered finite sets that is rich enough to describe computation, one seems to need an ordering on these sets. <p> Our view is that one should use a language that we know includes all the feasible queries, i.e. P. But, that one should use a theorem prover such as Sheard's extended Boyer-Moore theorem prover <ref> [SS89] </ref> to prove that our queries and transactions are correct. Correctness here would mean that the queries and transactions do what we want them to do. In particular, they preserve the database integrity constraints, and, when desired, they compute only order-independent properties. <p> Thus we can add to Figure 7.6 the class (proved order-independent P) of those queries in SRL, or equivalently in (FO + LFP) that our theorem-prover has shown to be order-independent. 8. Conclusions The inference mechanism in <ref> [SS89] </ref> on finite set terms with variables proves only properties that are true in all models.
Reference: [Va82] <author> M.Y. Vardi: </author> <title> The complexity of relational query languages. </title> <booktitle> Proceedings of 14th ACM STOC, </booktitle> <month> May </month> <year> 1982, </year> <pages> 137-146. </pages>
Reference-contexts: However when augmented with recursion or looping (as an added primitive) they become sufficiently powerful to express exactly the queries 2 in various complexity classes. Characterizing the expressive power of such languages has been the principal object of study in <ref> [Va82] </ref>, [CH80], [CH82a], [CH82b], [AU79], [Imm82], [AV89]. For example, Immerman and Vardi discovered independently that fixpoint logic plus ordering expresses the set of polynomial time computable queries [Va82], [Imm82]. A common and rather useful way of measuring expressiveness is to use complexity characterizations. <p> Characterizing the expressive power of such languages has been the principal object of study in <ref> [Va82] </ref>, [CH80], [CH82a], [CH82b], [AU79], [Imm82], [AV89]. For example, Immerman and Vardi discovered independently that fixpoint logic plus ordering expresses the set of polynomial time computable queries [Va82], [Imm82]. A common and rather useful way of measuring expressiveness is to use complexity characterizations. One finds classes of queries capturing LOGSP ACE; P; P SP ACE; P RIM REC. Interestingly, most of the classes of queries considered turned out to capture some complexity class. <p> T IM E [n] and SP ACE [log k n]. Instead of computable queries, we regard primitive recursive queries as the high end of the spectrum. Indeed, all of the interesting complexity classes are contained in P rimRec. Our measure of complexity is data-complexity as defined by Vardi <ref> [Va82] </ref>. The set-reduce construct (defined in section 2) can be thought of as a bounded loop primitive. See [SS89] for more details. The set-reduce construct resembles the hom operator of the database programming language called Machiavelli [OBB89]. <p> We then show that natural restrictions of this language capture P , DSP ACE (log n) and N SP ACE (log n). The expressive power of the bounded loop construct or its variant has been studied before in [AU79], <ref> [Va82] </ref>, [Q89], [CH80], [Imm87], [AV88] but not in this framework. <p> This is because G n and H n are almost ordered. That is, there is a first-order, quasi-total ordering on the vertices. The vertices are partitioned into color classes of size at most 4 and the color classes are totally ordered. Thus we 2 In <ref> [Va82] </ref>, Vardi defined the language (FO + while ), i.e. first-order logic together with an unbounded iteration operator, and showed that its expressive power is equal to PSPACE. (See also [Imm82b] for an equivalent formulation of an unbounded iterator applied to FO giving PSPACE.) See also [AV91] for a surprising new
Reference: [VS90] <author> J. Vitter, E. Shriver: </author> <title> Optimal disk I/O with parallel block transfer. </title> <booktitle> Proceedings of the 22nd ACM STOC, </booktitle> <month> May </month> <year> 1990, </year> <pages> 159-169. 35 </pages>
References-found: 37

