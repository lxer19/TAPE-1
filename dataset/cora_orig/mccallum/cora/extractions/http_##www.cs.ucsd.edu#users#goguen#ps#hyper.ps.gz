URL: http://www.cs.ucsd.edu/users/goguen/ps/hyper.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/goguen/pubs/
Root-URL: http://www.cs.ucsd.edu
Title: HYPERPROGRAMMING: A Formal Approach to Software Environments a variety of different programming, specification, verification, design
Author: Joseph A. Goguen 
Note: Hyperprogramming can also support  
Address: Menlo Park CA 94025  
Affiliation: Programming Research Group, Oxford University SRI International,  
Abstract: Hyperprogramming is an emerging semantics-based technique for the integration of diverse features of programming environments, in particular, rapid prototyp-ing and formal methods. This approach generalizes the notion of module to that of module cluster , which is an association around a central formal specification of various items of programming information, such as interface, source code, compiled code, rapid prototypes, formal proofs, test cases, performance estimates, documentation, history and accounting information. This allows all information items to be composed at the same time, by evaluating a master text called a module expression, which tells how to compose and transform module clusters. Hyperprogramming thus integrates design, specification, prototyping, coding, configuration, proof, testing, documentation and accounting into a single framework significantly generalizing both Ada generics and Unix 1 make. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Rod Burstall. </author> <title> Programming with modules as typed functional programming. </title> <booktitle> Proceedings, International Conference on Fifth Generation Computing Systems, </booktitle> <year> 1985. </year> <month> 16 </month>
Reference-contexts: Order sorted algebra also allows users to declare one sort as a subsort of another. Hereafter, we avoid the word "type" as much as possible, and instead use "sort" or "theory," as appropriate. 3.2 Programming with Modules Programming in the large can be viewed as functional programming with modules <ref> [1] </ref>. In particular, a module expression is a functional program whose values are modules. As a simple example, consider a parameterized module LEXL [X] that provides lists of Xs with a lexicographic ordering, where the parameter X can be instantiated to any partially ordered set.
Reference: [2] <author> Rod Burstall and Joseph Goguen. </author> <title> Putting theories together to make specifications. </title> <editor> In Raj Reddy, editor, </editor> <booktitle> Proceedings, Fifth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 1045-1058. </pages> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <year> 1977. </year>
Reference-contexts: A precise semantics helps us to be sure that we have a coherent, orthogonal set of features with thoroughly understood interactions. 2 2.2 Clear Clear was developed in 1977 as an algebraic specification language with unusually powerful composition mechanisms for generic modules <ref> [2] </ref>. It was, as far as I know, the first specification language to have a rigorous semantics [3, 4].
Reference: [3] <author> Rod Burstall and Joseph Goguen. </author> <title> Semantics of Clear. </title> <booktitle> Unpublished notes handed out at the 1978 Symposium on Algebra and Applications, </booktitle> <institution> Stefan Banach Center, Warsaw, Poland, </institution> <year> 1978. </year>
Reference-contexts: It was, as far as I know, the first specification language to have a rigorous semantics <ref> [3, 4] </ref>. <p> Although originally conceived as an extension of initial algebra semantics "into the large," we soon realized that the module composition mechanisms of Clear were far more general, and could be applied to modules over any desired logical system, using the abstraction of logic that we first called a "language" <ref> [3, 4] </ref> and later called an "institution" [21]. This approach supports not only powerful generic modules, but also multiple inheritance for modules.
Reference: [4] <author> Rod Burstall and Joseph Goguen. </author> <title> The semantics of Clear, a specification language. </title> <editor> In Dines Bjorner, editor, </editor> <booktitle> Proceedings, 1979 Copenhagen Winter School on Abstract Software Specification, </booktitle> <pages> pages 292-332. </pages> <publisher> Springer, </publisher> <year> 1980. </year> <booktitle> Lecture Notes in Computer Science, Volume 86; based on unpublished notes handed out at the Symposium on Algebra and Applications, </booktitle> <institution> Stefan Banach Center, Warsaw, Poland, </institution> <year> 1978. </year>
Reference-contexts: It was, as far as I know, the first specification language to have a rigorous semantics <ref> [3, 4] </ref>. <p> Although originally conceived as an extension of initial algebra semantics "into the large," we soon realized that the module composition mechanisms of Clear were far more general, and could be applied to modules over any desired logical system, using the abstraction of logic that we first called a "language" <ref> [3, 4] </ref> and later called an "institution" [21]. This approach supports not only powerful generic modules, but also multiple inheritance for modules.
Reference: [5] <author> Derek Coleman, Robin Gallimore, and Victoria Stavridou. </author> <title> The design of a rewrite rule interpreter from algebraic specifications. </title> <journal> IEE Software Engineering Journal, </journal> <volume> July:95-104, </volume> <year> 1987. </year>
Reference-contexts: Besides the OBJ3 implementation that is available from SRI International, there is an implementation of OBJ1 done at Washington State University, three from Great Britain, one from Italy, and one from Japan. The UMIST <ref> [5] </ref> effort (University of Manchester Institute of Science and Technology) was supported by the Alvey Program, and involved a rather extensive set of experiments which clearly demonstrated the value of OBJ for practical software engineering applications; UMIST-OBJ is now available as a commercial product, and another version of OBJ is being
Reference: [6] <author> Jeff Conklin. </author> <title> Hypertext: An introduction and survey. </title> <journal> Computer, </journal> <volume> 20(9) </volume> <pages> 17-41, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: This is similar to Knuth's Web system, but with greater flexibility and a more precise formal basis. 4.9 Abstract Syntax and Hypermedia Interfaces The power of hypertext <ref> [34, 6] </ref> comes from its ability to access a variety of texts through a variety of relations; these "texts" may be in multiple media, as emphasized by the word "hypermedia." For example, abstract syntax for FOOPS would allow a surface syntax that is like Ada, Common Lisp, or mathematics, and it
Reference: [7] <author> Frederick Brooks et al. </author> <title> Report of the Defense Science Board Task Force on Military Software. </title> <type> Technical Report AD-A188 561, </type> <institution> Office of the Under Secretary of Defense for Acquisition, Department of Defense, </institution> <address> Washington DC 10301, </address> <month> September </month> <year> 1987. </year>
Reference-contexts: For very large systems, the plunging quality of software may be even more significant than its escalating cost, because of possible severe effects on system reliability [35]. The Brooks Report <ref> [7] </ref> suggests that restructuring the acquisition process may be more beneficial than advances in software technology, even though roughly an order of magnitude improvement can be expected from the combined effect of several such advances.
Reference: [8] <author> Kokichi Futatsugi, Joseph Goguen, Jean-Pierre Jouannaud, and Jose Meseguer. </author> <title> Principles of OBJ2. </title> <editor> In Brian Reid, editor, </editor> <booktitle> Proceedings, Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 52-66. </pages> <institution> Association for Computing Machinery, </institution> <year> 1985. </year>
Reference-contexts: The latest version, called OBJ3, is perhaps the only language which supports specification, rapid prototyping, and verification, within the same implementation and with the same logical system <ref> [31, 17, 8] </ref>. OBJ can be considered an implementation of Clear for the conditional order-sorted equational institution, since it supports both initial and loose semantics, as well as powerful generic modules and module inheritance; OBJ also makes explicit and extends the notion of module expression which was implicit in Clear.
Reference: [9] <author> Joseph Goguen. </author> <title> Mathematical representation of hierarchically organized systems. </title> <editor> In E. At-tinger, editor, </editor> <booktitle> Global Systems Dynamics, </booktitle> <pages> pages 112-128. </pages> <editor> S. Karger, </editor> <year> 1971. </year>
Reference-contexts: The semantic foundation for module expression evaluation is the use of colimits for putting together arbitrary structures, such as code, specification, and documentation; this idea has its origins in some work from the early 1970s on the interconnection of general systems using the category theoretic notion of colimit <ref> [9, 10] </ref>. 2.3 OBJ OBJ arose around 1976 as an executable formal notation for abstract data types with subsorts [11]. Initial algebra semantics is executed by interpreting equations as rewrite rules [29, 12].
Reference: [10] <author> Joseph Goguen. </author> <title> Categorical foundations for general systems theory. </title> <editor> In F. Pichler and R. Trappl, editors, </editor> <booktitle> Advances in Cybernetics and Systems Research, </booktitle> <pages> pages 121-130. </pages> <publisher> Transcripta Books, </publisher> <year> 1973. </year>
Reference-contexts: The semantic foundation for module expression evaluation is the use of colimits for putting together arbitrary structures, such as code, specification, and documentation; this idea has its origins in some work from the early 1970s on the interconnection of general systems using the category theoretic notion of colimit <ref> [9, 10] </ref>. 2.3 OBJ OBJ arose around 1976 as an executable formal notation for abstract data types with subsorts [11]. Initial algebra semantics is executed by interpreting equations as rewrite rules [29, 12].
Reference: [11] <author> Joseph Goguen. </author> <title> Abstract errors for abstract data types. </title> <editor> In Eric Neuhold, editor, </editor> <booktitle> Proceedings, First IFIP Working Conference on Formal Description of Programming Concepts, pages 21.1-21.32. </booktitle> <publisher> MIT, </publisher> <year> 1977. </year> <title> Also in Formal Description of Programming Concepts, </title> <editor> Peter Neuhold, Ed., </editor> <publisher> North-Holland, </publisher> <pages> pages 491-522, </pages> <year> 1979. </year>
Reference-contexts: such as code, specification, and documentation; this idea has its origins in some work from the early 1970s on the interconnection of general systems using the category theoretic notion of colimit [9, 10]. 2.3 OBJ OBJ arose around 1976 as an executable formal notation for abstract data types with subsorts <ref> [11] </ref>. Initial algebra semantics is executed by interpreting equations as rewrite rules [29, 12]. In 1979, Joseph Tardo completed an inplementation, called OBJT, which included both subsorts and generic modules, though not yet in their final form [30, 37].
Reference: [12] <author> Joseph Goguen. </author> <title> Some design principles and theory for OBJ-0, a language for expressing and executing algebraic specifications of programs. </title> <editor> In Edward Blum, Manfred Paul, and Satsoru Takasu, editors, </editor> <booktitle> Proceedings, Conference on Mathematical Studies of Information Processing, </booktitle> <pages> pages 425-473. </pages> <publisher> Springer, </publisher> <year> 1979. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 75. </volume>
Reference-contexts: Initial algebra semantics is executed by interpreting equations as rewrite rules <ref> [29, 12] </ref>. In 1979, Joseph Tardo completed an inplementation, called OBJT, which included both subsorts and generic modules, though not yet in their final form [30, 37].
Reference: [13] <author> Joseph Goguen. </author> <title> Parameterized programming. </title> <journal> Transactions on Software Engineering, </journal> <volume> SE-10(5):528-543, </volume> <month> September </month> <year> 1984. </year>
Reference-contexts: Viewed as a programming language, OBJ is first order and purely functional. The style of programming that results from the systematic use of generic modules and module expressions is called parameterized programming <ref> [13, 18] </ref>. Besides the OBJ3 implementation that is available from SRI International, there is an implementation of OBJ1 done at Washington State University, three from Great Britain, one from Italy, and one from Japan. <p> This section gives an overview of some of the main ideas of parameterized programming, and illustrates them with examples in OBJ3. For more information on parameterized programming, see <ref> [13, 18, 15] </ref>. Appendix A contains the full OBJ3 code for the example discussed below. 3.1 Types OBJ and FOOPS distinguish two levels of typing: Small-grain types are types in the usual sense, such as Int and Bool, and serve to classify data. <p> A Generic Modules for Ordering and Sorting The following specification of various ordering and sorting modules has actually been executed in the OBJ3 system;it is discussed in more detail in <ref> [13] </ref> and [31]. ***&gt; file /users/goguen/obj/exs/sortingAC.obj ***&gt; naive AC sorting th POSET is sort Elt . op _&lt;_ : Elt Elt -&gt; Bool . vars E1 E2 E3 : Elt . eq E1 &lt; E1 = false . ceq E1 &lt; E3 = true if E1 &lt; E2 and E2 &lt;
Reference: [14] <author> Joseph Goguen. </author> <title> Suggestions for using and organizing libraries in software development. </title> <editor> In Steven Kartashev and Svetlana Kartashev, editors, </editor> <booktitle> Proceedings, First International Conference on Supercomputing Systems, </booktitle> <pages> pages 349-360. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1985. </year> <note> Also in Supercomputing Systems, </note> <editor> Steven and Svetlana Kartashev, Eds., </editor> <publisher> Elsevier, </publisher> <year> 1986. </year> <month> 17 </month>
Reference-contexts: FOOPS is recommended an executable formal specification language for use in hyperprogramming. An early form of FOOPS was used as the specification component of LIL, which was originally intended as a Library Interconnection Library for Ada <ref> [14] </ref>. LIL extends the ideas of parameterized programming to module clusters, and is thus the origin of hyperprogramming; see also [15]. <p> In LIL, horizontal inheritance is indicated by a needs clause; such clauses can appear in both imported and parameterized modules, thus providing an interesting interaction between vertical and horizontal structure, as discussed in <ref> [20, 14, 15] </ref>. 4 From Modules to Module Clusters Hyperprogramming generalizes from modules to module clusters, which associate a number of programming texts around a central formal specification, say in FOOPS.
Reference: [15] <author> Joseph Goguen. </author> <title> Reusing and interconnecting software components. </title> <journal> Computer, </journal> <volume> 19(2) </volume> <pages> 16-28, </pages> <month> February </month> <year> 1986. </year> <note> Reprinted in Tutorial: Software Reusability, </note> <editor> Peter Freeman, editor, </editor> <publisher> IEEE Computer Society, </publisher> <year> 1987, </year> <pages> pages 251-263, </pages> <booktitle> and in Domain Analysis and Software Systems Mod-elling, </booktitle> <editor> Ruben Prieto-Daz and Guillermo Arango, editors, </editor> <publisher> IEEE Computer Society, </publisher> <year> 1991, </year> <pages> pages 125-137. </pages>
Reference-contexts: An early form of FOOPS was used as the specification component of LIL, which was originally intended as a Library Interconnection Library for Ada [14]. LIL extends the ideas of parameterized programming to module clusters, and is thus the origin of hyperprogramming; see also <ref> [15] </ref>. <p> This section gives an overview of some of the main ideas of parameterized programming, and illustrates them with examples in OBJ3. For more information on parameterized programming, see <ref> [13, 18, 15] </ref>. Appendix A contains the full OBJ3 code for the example discussed below. 3.1 Types OBJ and FOOPS distinguish two levels of typing: Small-grain types are types in the usual sense, such as Int and Bool, and serve to classify data. <p> In LIL, horizontal inheritance is indicated by a needs clause; such clauses can appear in both imported and parameterized modules, thus providing an interesting interaction between vertical and horizontal structure, as discussed in <ref> [20, 14, 15] </ref>. 4 From Modules to Module Clusters Hyperprogramming generalizes from modules to module clusters, which associate a number of programming texts around a central formal specification, say in FOOPS.
Reference: [16] <author> Joseph Goguen. </author> <title> Graphical programming by generic example. </title> <editor> In Steven Kartashev and Svetlana Kartashev, editors, </editor> <booktitle> Proceedings, Second International Supercomputing Conference, </booktitle> <volume> Volume I, </volume> <pages> pages 209-216. </pages> <booktitle> International Supercomputing Institute, </booktitle> <publisher> Inc. </publisher> <address> (St. Petersburg FL), </address> <year> 1987. </year>
Reference-contexts: * configuration manager, by associating version numbers with texts, using the latest version in evaluating module expressions unless otherwise indicated, reusing its compiled form (if it already exists), and checking consistency with versions of any modules that are imported; * debugger with graphical display, using abstract data type techniques from <ref> [16] </ref>; * structured design display generator, e.g., for Jackson diagrams [32], by extracting information from the object oriented structure declarations given in specifications; * test case generator, using information given in specifications; * performance estimator, obtained by instrumenting an interpreter for an executable specifica tion language; * automatic consistency checker between <p> a variety of relations; these "texts" may be in multiple media, as emphasized by the word "hypermedia." For example, abstract syntax for FOOPS would allow a surface syntax that is like Ada, Common Lisp, or mathematics, and it could also support hypermedia interfaces, e.g., for program animation using ideas from <ref> [16] </ref> to generate displays based on abstract data type specifications. Ideally, hyperprogramming would use abstract syntax for all texts associated to programs, to allow easy display in a variety of media and formats (e.g., movies, computer generated explanations, graphics, etc.).
Reference: [17] <author> Joseph Goguen. </author> <title> OBJ as a theorem prover, with application to hardware verification. In V.P. </title> <editor> Subramanyan and Graham Birtwhistle, editors, </editor> <booktitle> Current Trends in Hardware Verification and Automated Theorem Proving, </booktitle> <pages> pages 218-267. </pages> <publisher> Springer, </publisher> <year> 1989. </year>
Reference-contexts: The latest version, called OBJ3, is perhaps the only language which supports specification, rapid prototyping, and verification, within the same implementation and with the same logical system <ref> [31, 17, 8] </ref>. OBJ can be considered an implementation of Clear for the conditional order-sorted equational institution, since it supports both initial and loose semantics, as well as powerful generic modules and module inheritance; OBJ also makes explicit and extends the notion of module expression which was implicit in Clear.
Reference: [18] <author> Joseph Goguen. </author> <title> Principles of parameterized programming. </title> <editor> In Ted Biggerstaff and Alan Perlis, editors, </editor> <booktitle> Software Reusability, Volume I: Concepts and Models, </booktitle> <pages> pages 159-225. </pages> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Viewed as a programming language, OBJ is first order and purely functional. The style of programming that results from the systematic use of generic modules and module expressions is called parameterized programming <ref> [13, 18] </ref>. Besides the OBJ3 implementation that is available from SRI International, there is an implementation of OBJ1 done at Washington State University, three from Great Britain, one from Italy, and one from Japan. <p> This section gives an overview of some of the main ideas of parameterized programming, and illustrates them with examples in OBJ3. For more information on parameterized programming, see <ref> [13, 18, 15] </ref>. Appendix A contains the full OBJ3 code for the example discussed below. 3.1 Types OBJ and FOOPS distinguish two levels of typing: Small-grain types are types in the usual sense, such as Int and Bool, and serve to classify data.
Reference: [19] <author> Joseph Goguen. </author> <title> Sheaf semantics for concurrent interacting objects. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 11 </volume> <pages> 159-191, </pages> <year> 1992. </year> <note> Given as lecture at Engeler Festschrift, </note> <institution> Zurich, </institution> <month> 7 March </month> <year> 1989, </year> <booktitle> and at U.K.-Japan Symposium on Concurrency, </booktitle> <address> Oxford, </address> <note> September 1989; draft as Report CSLI-91-155, </note> <institution> Center for the Study of Language and Information, Stanford University, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: This theory is a nice generalization of automaton theory; for example, there is a minimal state software module realizing any given behavior [25]. Current research concerns the application of sheaf theory to the semantics of systems of communicating objects <ref> [19] </ref>. FOOPS has all the parameterized programming features of OBJ, and 3 in addition allows objects with local state, local methods, multiple inheritance, and message passing. FOOPS is recommended an executable formal specification language for use in hyperprogramming.
Reference: [20] <author> Joseph Goguen and Rod Burstall. </author> <title> CAT, a system for the structured elaboration of correct programs from structured specifications. </title> <type> Technical Report Report CSL-118, </type> <institution> SRI Computer Science Lab, </institution> <month> October </month> <year> 1980. </year>
Reference-contexts: In LIL, horizontal inheritance is indicated by a needs clause; such clauses can appear in both imported and parameterized modules, thus providing an interesting interaction between vertical and horizontal structure, as discussed in <ref> [20, 14, 15] </ref>. 4 From Modules to Module Clusters Hyperprogramming generalizes from modules to module clusters, which associate a number of programming texts around a central formal specification, say in FOOPS.
Reference: [21] <author> Joseph Goguen and Rod Burstall. Institutions: </author> <title> Abstract model theory for specification and programming. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 39(1) </volume> <pages> 95-146, </pages> <month> January </month> <year> 1992. </year> <note> Draft appears as Report ECS-LFCS-90-106, </note> <institution> Computer Science Department, University of Edinburgh, </institution> <note> January 1990; an early ancestor is "Introducing Institutions," in Proceedings, Logics of Programming Workshop, </note> <editor> Edmund Clarke and Dexter Kozen, Eds., </editor> <booktitle> Springer Lecture Notes in Computer Science, </booktitle> <volume> Volume 164, </volume> <pages> pages 221-256, </pages> <year> 1984. </year>
Reference-contexts: of initial algebra semantics "into the large," we soon realized that the module composition mechanisms of Clear were far more general, and could be applied to modules over any desired logical system, using the abstraction of logic that we first called a "language" [3, 4] and later called an "institution" <ref> [21] </ref>. This approach supports not only powerful generic modules, but also multiple inheritance for modules. Clear also allows both initial and loose semantics in its models; initial semantics defines particular structures and operations, while loose semantics admits a variety of models, and is useful for defining module interfaces.
Reference: [22] <author> Joseph Goguen, Jean-Pierre Jouannaud, and Jose Meseguer. </author> <title> Operational semantics of order-sorted algebra. </title> <editor> In Wilfried Brauer, editor, </editor> <booktitle> Proceedings, 1985 International Conference on Automata, Languages and Programming. Springer, 1985. Lecture Notes in Computer Science, </booktitle> <volume> Volume 194. </volume>
Reference-contexts: This useful generalization of coercions has a rigorous logical basis [28, 26] and some surprising benefits, including rigorous semantics for exception handling, overloading, and partial functions; it also provides a formal semantics for multiple inheritance at the class level for FOOPS [27]. Order sorted rewriting is studied in <ref> [22] </ref>. 3 Parameterized Programming Good modularization is the key to good design. Powerful mechanisms for encapsulation, parameterization, inheritance and refinement can greatly increase opportunities for structuring designs and reusing code.
Reference: [23] <author> Joseph Goguen, Claude Kirchner, and Jose Meseguer. </author> <title> Concurrent term rewriting as a model of computation. </title> <editor> In Robert Keller and Joseph Fasel, editors, </editor> <booktitle> Proceedings, Graph Reduction Workshop, </booktitle> <pages> pages 53-93. </pages> <publisher> Springer, </publisher> <year> 1987. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 279. </volume>
Reference-contexts: In addition, FOOPS has evaluation strategy annotations, which can constrain the order of evaluation of the arguments of an operation in specific ways. <ref> [23] </ref> shows that this can be used for systems programming applications. The object oriented features of FOOPS support distributed programming, since the storage assigned to objects suggests a natural distribution of resources which can be recognized by compilers.
Reference: [24] <author> Joseph Goguen and Jose Meseguer. </author> <title> Rapid prototyping in the OBJ executable specification language. </title> <journal> Software Engineering Notes, </journal> <volume> 7(5) </volume> <pages> 75-84, </pages> <month> December </month> <year> 1982. </year> <title> Proceedings of Rapid Prototyping Workshop. </title> <type> 18 </type>
Reference-contexts: Indeed, FOOPS was designed for hyperprogramming. Of course, FOOPS cannot be executed as efficiently as conventional programing languages like C and Ada, but our experience with OBJ for rapid prototyping <ref> [24] </ref> suggests that FOOPS should be quite adequate. 4.4 Formal Methods "Formal" means "having to do with form" and does not necessarily entail logic or proofs of correctness.
Reference: [25] <author> Joseph Goguen and Jose Meseguer. </author> <title> Universal realization, persistent interconnection and im-plementation of abstract modules. </title> <editor> In M. Nielsen and E.M. Schmidt, editors, </editor> <booktitle> Proceedings, 9th International Conference on Automata, Languages and Programming, </booktitle> <pages> pages 265-281. </pages> <publisher> Springer, </publisher> <year> 1982. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 140. </volume>
Reference-contexts: The logical basis for this is some 1984 work extending equational logic to hidden sorts, in order to model states. This theory is a nice generalization of automaton theory; for example, there is a minimal state software module realizing any given behavior <ref> [25] </ref>. Current research concerns the application of sheaf theory to the semantics of systems of communicating objects [19]. FOOPS has all the parameterized programming features of OBJ, and 3 in addition allows objects with local state, local methods, multiple inheritance, and message passing.
Reference: [26] <author> Joseph Goguen and Jose Meseguer. </author> <title> Order-sorted algebra solves the constructor selector, multiple representation and coercion problems. </title> <booktitle> In Proceedings, Second Symposium on Logic in Computer Science, </booktitle> <pages> pages 18-29. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1987. </year> <note> Also Report CSLI-87-92, </note> <institution> Center for the Study of Language and Information, Stanford University, </institution> <note> March 1987; revised version in Information and Computation, 103, </note> <year> 1993. </year>
Reference-contexts: Order sorted algebra also allows operation symbols to be overloaded; for example, + might denote addition of natural numbers, integers, reals and complexes, as well as exlusive-OR for Booleans. Essentially all mathematical results generalize from many sorted to order sorted algebra in a satisfactory way <ref> [28, 26] </ref>. This useful generalization of coercions has a rigorous logical basis [28, 26] and some surprising benefits, including rigorous semantics for exception handling, overloading, and partial functions; it also provides a formal semantics for multiple inheritance at the class level for FOOPS [27]. <p> Essentially all mathematical results generalize from many sorted to order sorted algebra in a satisfactory way <ref> [28, 26] </ref>. This useful generalization of coercions has a rigorous logical basis [28, 26] and some surprising benefits, including rigorous semantics for exception handling, overloading, and partial functions; it also provides a formal semantics for multiple inheritance at the class level for FOOPS [27]. Order sorted rewriting is studied in [22]. 3 Parameterized Programming Good modularization is the key to good design.
Reference: [27] <author> Joseph Goguen and Jose Meseguer. </author> <title> Unifying functional, object-oriented and relational programming, with logical semantics. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-477. </pages> <publisher> MIT, </publisher> <year> 1987. </year> <journal> Preliminary version in SIGPLAN Notices, </journal> <volume> Volume 21, Number 10, </volume> <pages> pages 153-162, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: by the Alvey Program, and involved a rather extensive set of experiments which clearly demonstrated the value of OBJ for practical software engineering applications; UMIST-OBJ is now available as a commercial product, and another version of OBJ is being developed by Hewlett-Packard's Bristol Research Lab. 2.4 FOOPS and LIL FOOPS <ref> [27] </ref> is an extension of OBJ developed in 1986 to support a simple declarative style of object oriented programming with equations. The logical basis for this is some 1984 work extending equational logic to hidden sorts, in order to model states. <p> This useful generalization of coercions has a rigorous logical basis [28, 26] and some surprising benefits, including rigorous semantics for exception handling, overloading, and partial functions; it also provides a formal semantics for multiple inheritance at the class level for FOOPS <ref> [27] </ref>. Order sorted rewriting is studied in [22]. 3 Parameterized Programming Good modularization is the key to good design. Powerful mechanisms for encapsulation, parameterization, inheritance and refinement can greatly increase opportunities for structuring designs and reusing code.
Reference: [28] <author> Joseph Goguen and Jose Meseguer. </author> <title> Order-sorted algebra I: Equational deduction for multiple inheritance, overloading, exceptions and partial operations. </title> <journal> Theoretical Computer Science, </journal> <volume> 105(2) </volume> <pages> 217-273, </pages> <year> 1992. </year> <note> Also Programming Research Group Technical Monograph PRG-80, </note> <institution> Oxford University, </institution> <month> December </month> <year> 1989, </year> <note> and Technical Report SRI-CSL-89-10, </note> <institution> SRI International, Computer Science Lab, </institution> <note> July 1989; originally given as lecture at Seminar on Types, Carnegie-Mellon University, June 1983; many draft versions exist, from as early as 1985. </note>
Reference-contexts: Order sorted algebra also allows operation symbols to be overloaded; for example, + might denote addition of natural numbers, integers, reals and complexes, as well as exlusive-OR for Booleans. Essentially all mathematical results generalize from many sorted to order sorted algebra in a satisfactory way <ref> [28, 26] </ref>. This useful generalization of coercions has a rigorous logical basis [28, 26] and some surprising benefits, including rigorous semantics for exception handling, overloading, and partial functions; it also provides a formal semantics for multiple inheritance at the class level for FOOPS [27]. <p> Essentially all mathematical results generalize from many sorted to order sorted algebra in a satisfactory way <ref> [28, 26] </ref>. This useful generalization of coercions has a rigorous logical basis [28, 26] and some surprising benefits, including rigorous semantics for exception handling, overloading, and partial functions; it also provides a formal semantics for multiple inheritance at the class level for FOOPS [27]. Order sorted rewriting is studied in [22]. 3 Parameterized Programming Good modularization is the key to good design.
Reference: [29] <author> Joseph Goguen and Joseph Tardo. </author> <title> OBJ-0 preliminary users manual. Semantics and theory of computation report 10, </title> <type> UCLA, </type> <year> 1977. </year>
Reference-contexts: Initial algebra semantics is executed by interpreting equations as rewrite rules <ref> [29, 12] </ref>. In 1979, Joseph Tardo completed an inplementation, called OBJT, which included both subsorts and generic modules, though not yet in their final form [30, 37].
Reference: [30] <author> Joseph Goguen and Joseph Tardo. </author> <title> An introduction to OBJ: A language for writing and testing software specifications. </title> <editor> In Marvin Zelkowitz, editor, </editor> <booktitle> Specification of Reliable Software, </booktitle> <pages> pages 170-189. </pages> <publisher> IEEE, </publisher> <year> 1979. </year> <title> Reprinted in Software Specification Techniques, </title> <editor> Nehan Gehani and Andrew McGettrick, editors, </editor> <publisher> Addison Wesley, </publisher> <year> 1985, </year> <pages> pages 391-420. </pages>
Reference-contexts: Initial algebra semantics is executed by interpreting equations as rewrite rules [29, 12]. In 1979, Joseph Tardo completed an inplementation, called OBJT, which included both subsorts and generic modules, though not yet in their final form <ref> [30, 37] </ref>. The latest version, called OBJ3, is perhaps the only language which supports specification, rapid prototyping, and verification, within the same implementation and with the same logical system [31, 17, 8].
Reference: [31] <author> Joseph Goguen and Timothy Winkler. </author> <title> Introducing OBJ3. </title> <type> Technical Report SRI-CSL-88-9, </type> <institution> SRI International, Computer Science Lab, </institution> <month> August </month> <year> 1988. </year> <note> Revised version to appear with additional authors Jose Meseguer, </note> <editor> Kokichi Futatsugi and Jean-Pierre Jouannaud, </editor> <title> in Applications of Algebraic Specification using OBJ, edited by Joseph Goguen and Grant Malcolm, </title> <note> to appear. </note>
Reference-contexts: The latest version, called OBJ3, is perhaps the only language which supports specification, rapid prototyping, and verification, within the same implementation and with the same logical system <ref> [31, 17, 8] </ref>. OBJ can be considered an implementation of Clear for the conditional order-sorted equational institution, since it supports both initial and loose semantics, as well as powerful generic modules and module inheritance; OBJ also makes explicit and extends the notion of module expression which was implicit in Clear. <p> A Generic Modules for Ordering and Sorting The following specification of various ordering and sorting modules has actually been executed in the OBJ3 system;it is discussed in more detail in [13] and <ref> [31] </ref>. ***&gt; file /users/goguen/obj/exs/sortingAC.obj ***&gt; naive AC sorting th POSET is sort Elt . op _&lt;_ : Elt Elt -&gt; Bool . vars E1 E2 E3 : Elt . eq E1 &lt; E1 = false . ceq E1 &lt; E3 = true if E1 &lt; E2 and E2 &lt; E3 .
Reference: [32] <author> Michael Jackson. </author> <title> Principles of Program Design. </title> <publisher> Academic, </publisher> <year> 1975. </year>
Reference-contexts: the latest version in evaluating module expressions unless otherwise indicated, reusing its compiled form (if it already exists), and checking consistency with versions of any modules that are imported; * debugger with graphical display, using abstract data type techniques from [16]; * structured design display generator, e.g., for Jackson diagrams <ref> [32] </ref>, by extracting information from the object oriented structure declarations given in specifications; * test case generator, using information given in specifications; * performance estimator, obtained by instrumenting an interpreter for an executable specifica tion language; * automatic consistency checker between prototypes, executable specifications and code, using test suites; and *
Reference: [33] <author> David Luckham, Friedrich von Henke, Bernd Krieg-Bruckner, and Olaf Owe. anna: </author> <title> A Language for Annotating Ada Programs. </title> <publisher> Springer, </publisher> <year> 1987. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 260. </volume>
Reference-contexts: LIL extends the ideas of parameterized programming to module clusters, and is thus the origin of hyperprogramming; see also [15]. Will Tracz is implementing a version of LIL that uses ANNA <ref> [33] </ref> as its specification language, for his Ph.D. thesis at Stanford University [38]. 2.5 Inheritance OBJ implements order sorted algebra, which generalizes many sorted algebra by allowing one sort to be a subsort of another; this is interpreted semantically by the subset inclusion relation.
Reference: [34] <author> Ted Nelson. </author> <title> Getting it out of our system. </title> <editor> In G. Schlechter, editor, </editor> <title> Information Retrieval: A Critical Review. </title> <publisher> Thompson Books, </publisher> <year> 1967. </year>
Reference-contexts: This is similar to Knuth's Web system, but with greater flexibility and a more precise formal basis. 4.9 Abstract Syntax and Hypermedia Interfaces The power of hypertext <ref> [34, 6] </ref> comes from its ability to access a variety of texts through a variety of relations; these "texts" may be in multiple media, as emphasized by the word "hypermedia." For example, abstract syntax for FOOPS would allow a surface syntax that is like Ada, Common Lisp, or mathematics, and it
Reference: [35] <author> Charles Perrow. </author> <title> Normal Accidents: Living with High Risk Technologies. </title> <publisher> Basic Books, </publisher> <year> 1984. </year>
Reference-contexts: For very large systems, the plunging quality of software may be even more significant than its escalating cost, because of possible severe effects on system reliability <ref> [35] </ref>. The Brooks Report [7] suggests that restructuring the acquisition process may be more beneficial than advances in software technology, even though roughly an order of magnitude improvement can be expected from the combined effect of several such advances.
Reference: [36] <author> William Scherlis and Dana Scott. </author> <title> First steps towards inferential programming. In R.E.A. </title> <editor> Mason, editor, </editor> <booktitle> Information Processing 83, </booktitle> <pages> pages 199-212. </pages> <publisher> Elsevier, North-Holland, </publisher> <year> 1983. </year> <month> 19 </month>
Reference-contexts: Hereafter, we will use the words "module" and "cluster" interchangeably for the "module cluster" concept. 4.1 Module Expressions and Transformations Hyperprogramming with module expressions seems a natural and general way to integrate "transformational" or "inferential" programming <ref> [36] </ref> with other aspects of a programming environment, since module expressions can be seen as "scripts" which tell how to transform modules, as well as how combine them. Such module expressions capture design information in a natural way, and are easy to edit.
Reference: [37] <author> Joseph Tardo. </author> <title> The Design, Specification and Implementation of OBJT: A Language for Writ--ing and Testing Abstract Algebraic Program Specifications. </title> <type> PhD thesis, </type> <institution> UCLA, Computer Science Department, </institution> <year> 1981. </year>
Reference-contexts: Initial algebra semantics is executed by interpreting equations as rewrite rules [29, 12]. In 1979, Joseph Tardo completed an inplementation, called OBJT, which included both subsorts and generic modules, though not yet in their final form <ref> [30, 37] </ref>. The latest version, called OBJ3, is perhaps the only language which supports specification, rapid prototyping, and verification, within the same implementation and with the same logical system [31, 17, 8].
Reference: [38] <author> William Tracz. </author> <title> Formal Specification of Parameterized Programs in lilleanna. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1997. </year> <month> 20 </month>
Reference-contexts: LIL extends the ideas of parameterized programming to module clusters, and is thus the origin of hyperprogramming; see also [15]. Will Tracz is implementing a version of LIL that uses ANNA [33] as its specification language, for his Ph.D. thesis at Stanford University <ref> [38] </ref>. 2.5 Inheritance OBJ implements order sorted algebra, which generalizes many sorted algebra by allowing one sort to be a subsort of another; this is interpreted semantically by the subset inclusion relation.
References-found: 38

