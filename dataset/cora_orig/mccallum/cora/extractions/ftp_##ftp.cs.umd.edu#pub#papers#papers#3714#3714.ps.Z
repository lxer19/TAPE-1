URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3714/3714.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: amsaleg@cs.umd.edu  franklin@cs.umd.edu  Anthony.Tomasic@inria.fr  
Title: Query Scrambling for Bursty Data Arrival  
Author: Laurent Amsaleg Michael J. Franklin Anthony Tomasic 
Affiliation: University of Maryland  University of Maryland  INRIA  
Pubnum: Technical Report CS-TR-3714 and UMIACS-TR-96-84  
Abstract: Distributed databases operating over wide-area networks, such as the Internet, must deal with the unpredictable nature of the performance of communication. The response times of accessing remote sources may vary widely due to network congestion, link failure, and other problems. In this paper we examine a new class of methods, called query scrambling, for dealing with unpredictable response times. Query scrambling dynamically modifies query execution plans on-the-fly in reaction to unexpected delays in data access. We explore various choices in the implementation of these methods and examine, through a detailed simulation, the effects of these choices. Our experimental environment considers pipelined and non-pipelined join processing in a client with multiple remote data sources and it focuses on bursty arrivals of data. We identify and study a number of the basic trade-offs that arise when designing scrambling policies for the bursty environment. Our performance results show that query scrambling is effective in hiding the impact of delays on query response time for a number of different delay scenarios.
Abstract-found: 1
Intro-found: 1
Reference: [ACPS96] <author> S. Adali, K. Candan, Y. Papakonstantinou, and V. Subrahmanian. </author> <title> Query Caching and Optimization in Distributed Mediator Systems. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <address> Montreal, Canada, </address> <year> 1996. </year>
Reference-contexts: In general, methods that attack poor run-time performance for queries fall into two broad categories: proactive and reactive. Proactive methods (e.g., <ref> [ACPS96, CG94, SAL + 96] </ref>) attempt at compile-time to predict the behavior of query execution and plan ahead for possible contingencies. These approaches use a form of late binding in order to postpone making certain execution choices until the state of the system can be assessed at run-time. <p> During optimization, if a cost comparison returns incomparable, the choice for that part of the search space is encoded in a choose-plan operator. All decisions regarding query execution are then made final at query start-up time. HERMES <ref> [ACPS96] </ref> uses a proactive technique for recording the costs of previous calls to remote sources (in addition to caching the results) and can use resulting history of costs to estimate the cost of new calls.
Reference: [AFTU96] <author> L. Amsaleg, M. Franklin, A. Tomasic, and T. Urhan. </author> <title> Scrambling Query Plans to Cope with Unexpected Delays. </title> <booktitle> In Proc. of the Int. Conf. on Parallel and Distribution Information Systems (PDIS), </booktitle> <address> Miami Beach, Florida, </address> <month> December </month> <year> 1996. </year> <month> 24 </month>
Reference-contexts: That is, a query can execute in the presence of certain delays with little or no response time penalty observable to the user. 1.1 Coping With Bursty Arrival In a previous paper <ref> [AFTU96] </ref>, we identified three types of delay that can arise when requesting data from remote sources: Initial Delay There is an unexpected delay in the arrival of the first tuple from a particular remote source. <p> Bursty Arrival Data is arriving at an unpredictable rate, typically with bursts of data followed by long periods of no arrivals. This problem can arise from fluctuating resource demands and the lack of a global scheduling mechanism in the wide-area environment. The algorithm presented in <ref> [AFTU96] </ref> focused on the problem of Initial Delay. As such, it was assumed that once data started to arrive from a remote source, the remaining data from that source would arrive in an uninterrupted fashion. <p> In this way we avoid the thrashing of memory. 5.2.1 Policies We use three different policies to evaluate the performance of scrambling in a pipelined environment. These policies are Materialize-Leaves, Next-Leaf and Pipe-MRS . The last policy uses a notion developed in <ref> [AFTU96] </ref>, that is, the notion of a Maximal Runnable Subtree (MRS). A runnable subtree is a subtree in which all the operators are in the Not Started state. A runnable subtree is maximal if its root is the direct descendant of a Stalled operator. <p> The primary problem with existing reactive techniques is the weight of monitoring and operations. We classify reactive techniques as heavyweight if the unit of monitoring or operation is large, e.g. a join. Heavyweight reactive techniques also perform poorly in our environment since delays are not quickly detected. In <ref> [AFTU96] </ref>, we developed a collection of reactive techniques that both rescheduled operators and incrementally reorganized the query execution plan.
Reference: [Ant93] <author> G. Antoshenkov. </author> <title> Dynamic Query Optimization in Rdb/VMS. </title> <booktitle> In Proc. of the Data Engineering Int. Conf., </booktitle> <pages> pages 538-547, </pages> <address> Vienna, Austria, </address> <year> 1993. </year>
Reference-contexts: These approaches use a form of late binding in order to postpone making certain execution choices until the state of the system can be assessed at run-time. Typically the binding is done immediately prior to executing the compiled plan, and remains fixed for the entire execution. Reactive methods (e.g., <ref> [TTC + 90, Ant93, ONK + 96] </ref>) monitor the behavior of the run-time system during query execution. When a significant event is detected, the run-time system reacts to the event. Query scrambling is a reactive approach | the query execution is changed on-the-fly in response to run-time events. <p> A similar approach is used in Rdb/VMS <ref> [Ant93] </ref>. Both InterViso [TTC + 90] and MOOD [ONK + 96] are heterogeneous distributed databases that perform query optimization while the query is executing. Heterogeneous distributed database divide a query into a collection of subqueries and a composition query.
Reference: [BE96] <author> O. Bukhres and A. Elmagarmid. </author> <title> Object-Oriented Multidatabase Systems. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction The continued dramatic growth in global interconnectivity via the Internet has made around-the-clock, on demand access to widely-distributed data a common expectation for many computer users. At present, such access is typically obtained through non-database facilities such as the World-Wide-Web. Advances in distributed heterogeneous databases (e.g., <ref> [Kim95, SAD + 95, BE96, TRV96] </ref>) and other non-traditional approaches (e.g., WebSQL [MMM96]), however, aim to make the Internet a viable and important platform for distributed database technology. The Internet environment presents many interesting problems for database systems.
Reference: [BMG93] <author> J. Blakeley, W. McKenna, and G. Graefe. </author> <title> Experiences Building the Open OODB Query Optimizer. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <pages> page 287, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: an efficient plan, and that re-scheduling and materialization can 1 Note that this blocking phenomenon arises even if operators are ones that support intra-operator parallelism such the exchange operator of Volcano [CG94]. 2 This notion of a materialization operator is not related to the operator for path expressions described in <ref> [BMG93] </ref>. 5 result in additional memory, disk I/O, and other costs. Thus, the original plan should be tampered with only if an unexpected problem arises during the execution.
Reference: [BRJ89] <author> P. Bodorik, J. Riordon, and C. Jacob. </author> <title> Dynamic Distributed Query Processing Techniques. </title> <booktitle> In Proc. of the 17th annual ACM Computer Science Conf., </booktitle> <pages> pages 348-357, </pages> <address> Louisville, Kentucky, </address> <month> February </month> <year> 1989. </year>
Reference-contexts: Reasons include inaccurate estimates for intermediate result sizes and direct considerations of problems with response times from remote sources are not accounted for. <ref> [BRJ89] </ref> proposes a reactive technique in which the execution of a distributed query proceeds through three phases: (i) a monitoring phase observing the progress of the execution of the query; (ii) a decision making phase during which a new strategy for executing the query is computed; and (iii) a corrective phase
Reference: [Bro92] <author> K. Brown. PRPL: </author> <title> A Database Workload Specification Language. </title> <type> Master's thesis, </type> <institution> University of Winsconsin, Madison, Winsconsin, </institution> <year> 1992. </year>
Reference-contexts: Each site, except the query execution site, stores one base relation. In this study, the disk at the query execution site (i.e., client) is used to store temporary results. Disks are modeled using a detailed characterization that was adapted from the ZetaSim model <ref> [Bro92] </ref>. The disk model includes costs for random and sequential physical accesses and also charges for software operations implementing I/Os. The unit of disk I/O for the database and the client's disk cache are pages of size DskPageSize. The unit of transfer between sites are pages of size NetPageSize.
Reference: [CDF + 94] <author> M. Carey, D. DeWitt, M. Franklin, N. Hall, M. McAuliffe, J. Naughton, D. Schuh, M. Solomon, C. Tan, O. Tsatalos, S. White, and M. Zwilling. </author> <title> Shoring Up Persistent Applications. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <address> Minneapolis, Minnesota, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: these experiments and also the main settings for configuring the query scrambling scheduler. 4.1 Simulation Environment To study the performance of query scrambling in a bursty environment, we implemented the scheduling engine and several policies on top an existing simulator that models a heterogeneous, peer-to-peer database system such as SHORE <ref> [CDF + 94] </ref>. The simulator we used provides a detailed model of query processing costs in such a system. Here, we briefly describe the simulator, focusing on the aspects that are pertinent to our experiments. More detailed descriptions of the simulator can be found in [FJK96, DFJ + 96].
Reference: [CG94] <author> R. Cole and G. Graefe. </author> <title> Optimization of dynamic query execution plans. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <pages> pages 150-160, </pages> <address> Minneapolis, Minnesota, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: In general, methods that attack poor run-time performance for queries fall into two broad categories: proactive and reactive. Proactive methods (e.g., <ref> [ACPS96, CG94, SAL + 96] </ref>) attempt at compile-time to predict the behavior of query execution and plan ahead for possible contingencies. These approaches use a form of late binding in order to postpone making certain execution choices until the state of the system can be assessed at run-time. <p> The assumption is that the execution plan generated by the optimizer is in fact, an efficient plan, and that re-scheduling and materialization can 1 Note that this blocking phenomenon arises even if operators are ones that support intra-operator parallelism such the exchange operator of Volcano <ref> [CG94] </ref>. 2 This notion of a materialization operator is not related to the operator for path expressions described in [BMG93]. 5 result in additional memory, disk I/O, and other costs. Thus, the original plan should be tampered with only if an unexpected problem arises during the execution. <p> At query start-up time, the plan is fixed, and query execution corresponds exactly to the plan. The Volcano optimizer <ref> [CG94, Gra93] </ref> provides a framework for the application of proactive techniques for distributed query processing. During optimization, if a cost comparison returns incomparable, the choice for that part of the search space is encoded in a choose-plan operator.
Reference: [DFJ + 96] <author> S. Dar, M. Franklin, B. Jonsson, D. Srivastava, and M. Tan. </author> <title> Semantic Data Caching and Replacement. </title> <booktitle> In Proc. of the 22th VLDB Int. Conf, </booktitle> <address> Bombay, India, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: The simulator we used provides a detailed model of query processing costs in such a system. Here, we briefly describe the simulator, focusing on the aspects that are pertinent to our experiments. More detailed descriptions of the simulator can be found in <ref> [FJK96, DFJ + 96] </ref>. Table 2 shows the main parameters for configuring the simulator, and the settings used for this study. Every site has a CPU whose speed is specified by the Mips parameter, NumDisks disks, and a main-memory buffer pool of size Memory.
Reference: [FJK96] <author> M. Franklin, B. Jonsson, and D. Kossmann. </author> <title> Performance Tradeoffs for Client-Server Query Processing. </title> <booktitle> In Proc. of the ACM SIGMOD Int. Conf., </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: In this paper, we focus on query processing using a data-shipping or hybrid-shipping approach <ref> [FJK96] </ref>, where data is ultimately collected from remote sources and integrated at the query source. This approach models remote data access and is also typical of mediated database systems that integrate data from distributed, heterogeneous sources, (e.g., [TRV96]). <p> The simulator we used provides a detailed model of query processing costs in such a system. Here, we briefly describe the simulator, focusing on the aspects that are pertinent to our experiments. More detailed descriptions of the simulator can be found in <ref> [FJK96, DFJ + 96] </ref>. Table 2 shows the main parameters for configuring the simulator, and the settings used for this study. Every site has a CPU whose speed is specified by the Mips parameter, NumDisks disks, and a main-memory buffer pool of size Memory.
Reference: [Gra93] <author> G. Graefe. </author> <title> Query Evaluation Techniques for Large Databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(2) </volume> <pages> 73-170, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: We then use a detailed simulation of a run-time system based on the iterator query processing model <ref> [Gra93] </ref> in order to examine the tradeoffs of the various scrambling policies 3 for both pipelined and non-pipelined execution. In this paper, we focus on query processing using a data-shipping or hybrid-shipping approach [FJK96], where data is ultimately collected from remote sources and integrated at the query source. <p> The iterator model is one way to structure such an execution engine <ref> [Gra93] </ref>. In this model, each node of the query tree is an iterator. Iterators support three different calls: open () to prepare an operator for producing data; next () to produce a single tuple, and close () to perform final housekeeping. <p> At query start-up time, the plan is fixed, and query execution corresponds exactly to the plan. The Volcano optimizer <ref> [CG94, Gra93] </ref> provides a framework for the application of proactive techniques for distributed query processing. During optimization, if a cost comparison returns incomparable, the choice for that part of the search space is encoded in a choose-plan operator.
Reference: [Kim95] <author> W. Kim. </author> <title> Modern Database Systems: The Object Model, Interoperability, and Beyond. </title> <publisher> ACM Press, </publisher> <address> New York, NY, </address> <year> 1995. </year>
Reference-contexts: 1 Introduction The continued dramatic growth in global interconnectivity via the Internet has made around-the-clock, on demand access to widely-distributed data a common expectation for many computer users. At present, such access is typically obtained through non-database facilities such as the World-Wide-Web. Advances in distributed heterogeneous databases (e.g., <ref> [Kim95, SAD + 95, BE96, TRV96] </ref>) and other non-traditional approaches (e.g., WebSQL [MMM96]), however, aim to make the Internet a viable and important platform for distributed database technology. The Internet environment presents many interesting problems for database systems.
Reference: [MMM96] <author> A. Mendelzon, G. Mihaila, and T. Milo. </author> <title> Querying the World Wide Web. </title> <booktitle> In Proc. of the Int. Conf. on Parallel and Distribution Information Systems (PDIS), </booktitle> <address> Miami Beach, Florida, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: At present, such access is typically obtained through non-database facilities such as the World-Wide-Web. Advances in distributed heterogeneous databases (e.g., [Kim95, SAD + 95, BE96, TRV96]) and other non-traditional approaches (e.g., WebSQL <ref> [MMM96] </ref>), however, aim to make the Internet a viable and important platform for distributed database technology. The Internet environment presents many interesting problems for database systems.
Reference: [ONK + 96] <author> F. Ozcan, S. Nural, P. Koksal, C. Evrendilek, and A. Dogac. </author> <title> Dynamic query optimization on a distributed object management platform. </title> <booktitle> In CIKM, </booktitle> <address> Baltimore, Maryland, </address> <month> November </month> <year> 1996. </year>
Reference-contexts: These approaches use a form of late binding in order to postpone making certain execution choices until the state of the system can be assessed at run-time. Typically the binding is done immediately prior to executing the compiled plan, and remains fixed for the entire execution. Reactive methods (e.g., <ref> [TTC + 90, Ant93, ONK + 96] </ref>) monitor the behavior of the run-time system during query execution. When a significant event is detected, the run-time system reacts to the event. Query scrambling is a reactive approach | the query execution is changed on-the-fly in response to run-time events. <p> A similar approach is used in Rdb/VMS [Ant93]. Both InterViso [TTC + 90] and MOOD <ref> [ONK + 96] </ref> are heterogeneous distributed databases that perform query optimization while the query is executing. Heterogeneous distributed database divide a query into a collection of subqueries and a composition query. There is one subquery for each remote source and a composition query than combines the results of the subqueries.
Reference: [SAD + 95] <author> M. Shan, R. Ahmen, J. Davis, W. Du, and W. Kent. </author> <title> Modern Database Systems: The Object Model, Interoperability, and Beyond, chapter Pegasus: A Heterogeneous Information Management System. </title> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: 1 Introduction The continued dramatic growth in global interconnectivity via the Internet has made around-the-clock, on demand access to widely-distributed data a common expectation for many computer users. At present, such access is typically obtained through non-database facilities such as the World-Wide-Web. Advances in distributed heterogeneous databases (e.g., <ref> [Kim95, SAD + 95, BE96, TRV96] </ref>) and other non-traditional approaches (e.g., WebSQL [MMM96]), however, aim to make the Internet a viable and important platform for distributed database technology. The Internet environment presents many interesting problems for database systems.
Reference: [SAL + 96] <author> M. Stonebraker, P. Aoki, W. Litwin, A. Pfeffer, A. Sah, J. Sidell, C. Staelin, and A. Yu. </author> <month> Mariposa: </month>
Reference-contexts: In general, methods that attack poor run-time performance for queries fall into two broad categories: proactive and reactive. Proactive methods (e.g., <ref> [ACPS96, CG94, SAL + 96] </ref>) attempt at compile-time to predict the behavior of query execution and plan ahead for possible contingencies. These approaches use a form of late binding in order to postpone making certain execution choices until the state of the system can be assessed at run-time. <p> As in Volcano, this system optimizes a query both at query compile and query start-up time, but does not change the query plan during query run-time. Mariposa <ref> [SAL + 96] </ref> bases the optimization of distributed queries on an economic paradigm. Although the query optimizer of [SAL + 96] adopts a radical approach since it is first based on negotiation and second it is not based on costs, optimization still builds a plan that is fixed for the duration <p> As in Volcano, this system optimizes a query both at query compile and query start-up time, but does not change the query plan during query run-time. Mariposa <ref> [SAL + 96] </ref> bases the optimization of distributed queries on an economic paradigm. Although the query optimizer of [SAL + 96] adopts a radical approach since it is first based on negotiation and second it is not based on costs, optimization still builds a plan that is fixed for the duration of the execution of the 22 query.
References-found: 17

