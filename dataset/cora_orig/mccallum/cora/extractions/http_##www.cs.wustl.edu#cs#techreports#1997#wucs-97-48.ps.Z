URL: http://www.cs.wustl.edu/cs/techreports/1997/wucs-97-48.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: http://www.cs.wustl.edu
Title: End-User Visualization and Manipulation of Distributed Aggregate Data  
Author: T. Paul McCartney, Kenneth J. Goldman 
Date: December 1997  
Address: Campus Box 1045 One Brookings Drive Saint Louis, MO 63130-4899  
Affiliation: Department of Computer Science Washington University  
Pubnum: WUCS-97-48  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Codd, E. F. </author> <title> Relational Completeness of Data Base Sublanguages. In Data Base Systems, </title> <editor> R. Rustin (ed.), </editor> <title> End-User Visualization and Manipulation of Distributed Aggregate Data - 17 - Englewood Cliffs, </title> <address> N.J. </address> <publisher> Prentice-Hall, </publisher> <pages> pages 65-98, </pages> <year> 1972. </year>
Reference-contexts: Our goal here was to allow the visualization to be decoupled from its underlying application. End-users can visually specify how aggregate data is to be processed from multiple aggregates, using mechanisms functionally similar to select, project, join, and cross product of relational databases <ref> [1] </ref>, [2]. Second, the relationship of the aggregate data to its visualization is specified. The goal of this stage was to enable end-users to create customized visualizations through a visual language interface. <p> An aggregate mapping visualization should be dynamic and bidirectional, responding interactively to both updates in underlying data elements and user manipulation during application execution. The relational database techniques of project, select, join, and cross product <ref> [1] </ref>, [2] should be avail able to allow basic processing of a mappings aggregate data. We intended aggregate mappings to be definable by a broad class of end-users. Visual programming techniques enable end-users to create aggregate mappings that visualize aggregate data received from any Playground module.
Reference: [2] <author> Codd, E. F. </author> <title> A relational model for large shared data banks, </title> <journal> Communications of the ACM, </journal> <volume> 13(6) </volume> <pages> 377-387. </pages>
Reference-contexts: Our goal here was to allow the visualization to be decoupled from its underlying application. End-users can visually specify how aggregate data is to be processed from multiple aggregates, using mechanisms functionally similar to select, project, join, and cross product of relational databases [1], <ref> [2] </ref>. Second, the relationship of the aggregate data to its visualization is specified. The goal of this stage was to enable end-users to create customized visualizations through a visual language interface. Third, the system maintains the relationship of the visualization with the aggregate, and the aggregate with its computation sources. <p> An aggregate mapping visualization should be dynamic and bidirectional, responding interactively to both updates in underlying data elements and user manipulation during application execution. The relational database techniques of project, select, join, and cross product [1], <ref> [2] </ref> should be avail able to allow basic processing of a mappings aggregate data. We intended aggregate mappings to be definable by a broad class of end-users. Visual programming techniques enable end-users to create aggregate mappings that visualize aggregate data received from any Playground module.
Reference: [3] <author> Cordy, James R. and T. C. Nicholas Graham. GVL: </author> <title> Visual Specification of Graphical Output. </title> <journal> Journal of Visual Languages and Computing 3(1) </journal> <pages> 25-47, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Graphics toolkits such as Garnet [18] and Interviews [11] provide programmatic support for visualizing data sets such as lists and graphs. Our work focuses on allowing end-users to create aggregate visualizations without textual programming. Research systems such as Pavane [20] and Weasel <ref> [3] </ref> allow the visualization of aggregate data through the use of a high-level specification language. With Swarm, a specification language associated with Pavane, programmers can write formal textual specifications of End-User Visualization and Manipulation of Distributed Aggregate Data - 3 - concurrent algorithms.
Reference: [4] <author> Derthick, M., Kolojejchick, J. A., and Roth, S. F. </author> <title> An Interactive Visual Query Environment for Exploring Data. </title> <booktitle> Proceedings of the ACM Symposium on User Interface Software and Technology (UIST '97), </booktitle> <publisher> ACM Press, </publisher> <month> October </month> <year> 1997, </year> <pages> pp 189-198. </pages>
Reference-contexts: Weasel provides support for visualizing dynamically changing data in real time, but does not support manipulation of the visualization. However, it is not clear that end-users (i.e., non-programmers) would be able to construct visualizations with Weasel. Other systems such as Magic Lens [5], GQL [19], and Visage <ref> [4] </ref> have focused on the visual specification of database queries. While our system enables end-users to visually specify the functionality of project, select, join, and cross product database operations, our primary contribution is in integrating this functionality with end-user defined dynamic visualizations. <p> Although our system includes a data filtering mechanism, it does not address methods of browsing data through the modifications of visual queries. Instead, our system focuses primarily on creating customized visualizations and reacting to dynamic updates of the data. The Visage system <ref> [4] </ref> enables users to specify visual queries on multiple data sets. Used in conjunction with the SageBrush tool [21], visualizations of a visual query may be created, browsed, and refined.
Reference: [5] <author> Fishkin, Ken and Stone, Maureen C. </author> <title> Enhanced Dynamic Queries via Movable Filters. </title> <booktitle> Proceedings of CHI '95,(Denver, </booktitle> <address> CO, May 8-11) ACM, New York, </address> <year> 1995, </year> <pages> pp. 415-420. </pages>
Reference-contexts: Weasel provides support for visualizing dynamically changing data in real time, but does not support manipulation of the visualization. However, it is not clear that end-users (i.e., non-programmers) would be able to construct visualizations with Weasel. Other systems such as Magic Lens <ref> [5] </ref>, GQL [19], and Visage [4] have focused on the visual specification of database queries. While our system enables end-users to visually specify the functionality of project, select, join, and cross product database operations, our primary contribution is in integrating this functionality with end-user defined dynamic visualizations. <p> Our system allows end-users to define basic operations on the data of distributed applications, to create a customized visualize of the result, and to manipulate the underlying data interactively. Magic Lens <ref> [5] </ref> provides the ability to filter a data set through the use of multiple, overlapping filters. The filtered data is visualized using 2D scatterplots. The strength of this approach is that it allows users to explore data by adjusting the filters interactively.
Reference: [6] <author> Frank, Martin R. Grizzly Bear: </author> <title> A demonstrational learning tool for a user interface specification language. </title> <booktitle> In Proceedings of the ACM Symposium on User Interface Software and Technology, </booktitle> <address> Pittsburgh, Pennsylvania, </address> <pages> pages 75-76, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: Another approach to this problem would be to specify the layout graphically through induction-style rules. With this strategy, similar to a demonstrational approach <ref> [6] </ref>, [17], the end-user would specify the mapping of the first aggregate element (base case) and the relationship between an aggregate instance k and the next element k+1. From this information, the system would inductively place each instance element of the aggregate.
Reference: [7] <author> Freeman-Benson, Bjorn, John Maloney, Alan Borning. </author> <title> An Incremental Constraint Solver. </title> <journal> Communications of the ACM, </journal> <volume> 33(1) </volume> <pages> 54-63, </pages> <year> 1990. </year>
Reference-contexts: When a GUI is complete, the tool palette and data boundary may be hidden. Each graphics item drawn in EUPHORIA has a number of associated attributes (e.g., position, size, etc.). These attributes can be used in forming multi-way constraints relationships <ref> [7] </ref> to other shapes and to external Playground modules. The handles of a selected graphics item act as data ports to the items attributes, allowing end-users to define the constraints.
Reference: [8] <author> Gallager, R. G., P. A. Humblet, and P. M. Spira. </author> <title> A Distributed Algorithm for Minimum-Weight Spanning Trees. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(1) </volume> <pages> 66-77, </pages> <month> January </month> <year> 1983. </year>
Reference-contexts: With a joined aggregate mapping, the data of multiple aggregates is coordinated within an aggregate mapping based on matching operations. 4.5.1 Motivating Example We present the following example to motivate joined aggregate mappings. The Gallager-Humblet-Spira algorithm <ref> [8] </ref> is a distributed algorithm for computing the minimum spanning tree among a number of independent processes. Each process, implemented as a Playground module for this example, represents a vertex of a complete graph.
Reference: [9] <author> Goldman, Kenneth J., Bala Swaminathan, T. Paul McCartney, Michael D. Anderson, and Ram Sethuraman. </author> <title> The Programmers Playground: I/O Abstraction for User-Configurable Distributed Applications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(9) </volume> <pages> 735-746, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Section 4 presents aggregate mappings, the central research contribution of this paper. End-User Visualization and Manipulation of Distributed Aggregate Data - 4 - 3.1 The Programmers Playground The Programmers Playground (Playground) <ref> [9] </ref> is a software library and run-time system that supports the I/O abstraction programming model for distributed applications. I/O abstraction provides a separation of computation from communication that is well-suited for end-user construction of customized distributed applications from computational building blocks. <p> Users can interact with the visualization by moving vertices, adding vertices, or deleting vertices. Each of these actions resets the state of the graph and re-executes the algorithm. represents the visualization from Figure 10, is connected to each vertex module through the use of element-to-aggregate connections <ref> [9] </ref>. In this way, EUPHORIA gathers vertex information from each vertex module and combines it into a list published variable called Vertices (Figure 10). An intermediary module, called the Middle Man, is used to intercept messages passed among the vertices, providing EUPHORIA with the Messages and Edges aggregates (Figure 10).
Reference: [10] <author> Jagadeesh, J. and Y. Wang. </author> <title> LabVIEW. Product Review, </title> <booktitle> Computer, </booktitle> <month> February </month> <year> 1993. </year>
Reference-contexts: The contributions of this work are presented in Section 4, which discusses aggregate mappings. Section 5 discusses future work, and Section 6 provides a brief summary. 2. Related Work Commercial products such as Microsoft Excel [12] and LabView <ref> [10] </ref> provide some support for end-user aggregate visualization. Excel users may choose from a number of pre-defined chart representations (e.g., pie charts, histograms) to view spreadsheet data. Excels visualization is static; once a chart is created the user cannot interact with the display.
Reference: [11] <author> Linton, Mark A., John M. Vlissides and Paul R. Calder. </author> <title> Composing User Interfaces with InterViews. </title> <booktitle> IEEE Computer 22(2) </booktitle> <pages> 8-22, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: Our system gives end-users the ability to specify arbitrary graphical representations of aggregate data and how it is mapped to the display. This gives users the ability to create highly customized, interactive visualizations. Graphics toolkits such as Garnet [18] and Interviews <ref> [11] </ref> provide programmatic support for visualizing data sets such as lists and graphs. Our work focuses on allowing end-users to create aggregate visualizations without textual programming. Research systems such as Pavane [20] and Weasel [3] allow the visualization of aggregate data through the use of a high-level specification language.
Reference: [12] <author> Microsoft Corporation. </author> <title> One Microsoft Way, </title> <address> Redmond, WA 98052-6399. </address>
Reference-contexts: The contributions of this work are presented in Section 4, which discusses aggregate mappings. Section 5 discusses future work, and Section 6 provides a brief summary. 2. Related Work Commercial products such as Microsoft Excel <ref> [12] </ref> and LabView [10] provide some support for end-user aggregate visualization. Excel users may choose from a number of pre-defined chart representations (e.g., pie charts, histograms) to view spreadsheet data. Excels visualization is static; once a chart is created the user cannot interact with the display.
Reference: [13] <author> McCartney T. Paul. </author> <title> End-user Construction and Configuration of Distributed Multimedia Applications. D.Sc. </title> <type> Dissertation, </type> <institution> Washington University 1996. </institution> <note> Also appears as Washington University Department of Computer Science technical report WUCS-96-24, </note> <month> September </month> <year> 1996. </year>
Reference-contexts: The GUI module, described in the next section, uses these updates to animate the movement of the Earth within a graphical interface. 3.2 EUPHORIA User Interface Management System EUPHORIA, Playgrounds user interface management system <ref> [13] </ref>, [16], is a specialized module for creating customized direct manipulation graphical user interfaces (GUIs) without the need to write user interface source code. In EUPHORIA, end-users simply draw GUIs using an interactive graphics editor. <p> Since constraints are multi-way, the computation ow of the constraints changes dynamically based on the addition/deletion of constraints, user interaction, and external updates from published variables. More information about EUPHORIAs constraint system may be found in <ref> [13] </ref>, [16]. End-users can publish Playground variables from EUPHORIA and form constraints among the variables and graphics item attributes. This allows other Playground modules to selectively observe or control the state of EUPHORIAs display. <p> These components are launched and configured through an Application 1. Due to Internet communication delays, updates take time to be received by other participants. End-User Visualization and Manipulation of Distributed Aggregate Data - 8 - Management System <ref> [13] </ref> that is accessible through a World Wide Web interface. However, the details of how the application is started is not important to this discussion. Each participants GUI has a published variable, Cursors, which is a list aggregate containing information about all of the participants cursors. <p> Since these features are general to EUPHORIA, and not specific to aggregate mappings, we list only a brief description of each in this paper. For more information on these and other features of EUPHORIA, see <ref> [13] </ref>, [14], [16]. Other features include: Customizable coordinate systems. Hierarchical constraints (priority based). Implicit aggregate indices. Arbitrary multi-way constraint computations. First, it is possible to change the properties of the visualization coordinate system. <p> For reasonable performance, the storage for matches must be fast, must support cross products efficiently, must keep track of existing matches to avoid redundancy, and must be able to quickly remove matches in a variety of ways. See <ref> [13] </ref> for details on our algorithm for managing the matches of a joined aggregate. (a) (b) End-User Visualization and Manipulation of Distributed Aggregate Data - 16 - 5. Future Work It would be helpful to have an end-user mechanism to specify the layout of aggregate mapping instances.
Reference: [14] <author> McCartney, T. Paul and Kenneth J. Goldman. </author> <title> EUPHORIA Reference Manual. </title> <institution> Washington University Department of Computer Science WUCS-97-13, </institution> <month> February </month> <year> 1997. </year>
Reference-contexts: Since these features are general to EUPHORIA, and not specific to aggregate mappings, we list only a brief description of each in this paper. For more information on these and other features of EUPHORIA, see [13], <ref> [14] </ref>, [16]. Other features include: Customizable coordinate systems. Hierarchical constraints (priority based). Implicit aggregate indices. Arbitrary multi-way constraint computations. First, it is possible to change the properties of the visualization coordinate system.
Reference: [15] <author> McCartney, T. Paul and Kenneth J. Goldman. </author> <title> Visual Specification of Interprocess and Intraprocess Communication. </title> <booktitle> In Proceedings of the 10th International Symposium on Visual Languages, </booktitle> <month> October </month> <year> 1994, </year> <pages> pages 80-87. </pages> <booktitle> End-User Visualization and Manipulation of Distributed Aggregate Data - 18 </booktitle> - 
Reference-contexts: These types may be arbitrarily nested to form new publishable tuple types, and new types of publishable aggregates may be defined as well. Playground modules have a visual representation that was designed as part of a visual configuration language for interprocess and intraprocess communication <ref> [15] </ref>. Figure 1a shows the visual representation of a module with three published variables. The color of a published variable is used to represent its data type.
Reference: [16] <author> McCartney, T. Paul, Goldman, K., and Saff, D., EUPHORIA: </author> <title> End-User Construction of Direct Manipulation User Interfaces for Distributed Applications, </title> <journal> Software-Concepts and Tools, </journal> <volume> 16(4) </volume> <pages> 147-159, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: The GUI module, described in the next section, uses these updates to animate the movement of the Earth within a graphical interface. 3.2 EUPHORIA User Interface Management System EUPHORIA, Playgrounds user interface management system [13], <ref> [16] </ref>, is a specialized module for creating customized direct manipulation graphical user interfaces (GUIs) without the need to write user interface source code. In EUPHORIA, end-users simply draw GUIs using an interactive graphics editor. <p> Since constraints are multi-way, the computation ow of the constraints changes dynamically based on the addition/deletion of constraints, user interaction, and external updates from published variables. More information about EUPHORIAs constraint system may be found in [13], <ref> [16] </ref>. End-users can publish Playground variables from EUPHORIA and form constraints among the variables and graphics item attributes. This allows other Playground modules to selectively observe or control the state of EUPHORIAs display. <p> In this case, each cursor is represented as a labelled graphics item. 4.2 End-User Specification of Aggregate Mappings In EUPHORIA, new data types can be created interactively and published by end-users through standard dialog box style user interfaces <ref> [16] </ref>. EUPHORIA supports the construction all Playground types, including arbitrarily complex nested types. Playground supports the following aggregate types: static array (fixed size), dynamic array (adjustable size), list, and mapping 2 . Each of these types can be used in forming aggregate mappings. <p> A prototype instance is a set of graphics items and constraints that are used to specify how each aggregate element is to be represented graphically. In the collaborative imaging example, the prototype instance is a cursor widget consisting of various simple shapes (Figure 6b). As described in <ref> [16] </ref>, widgets are constructed interactively by the end-user in EUPHORIA. 2. Playgrounds mapping datatype should not to be confused with aggregate mappings. The mapping datatype is a function, in the mathematical sense, from domain values to range values. <p> Since these features are general to EUPHORIA, and not specific to aggregate mappings, we list only a brief description of each in this paper. For more information on these and other features of EUPHORIA, see [13], [14], <ref> [16] </ref>. Other features include: Customizable coordinate systems. Hierarchical constraints (priority based). Implicit aggregate indices. Arbitrary multi-way constraint computations. First, it is possible to change the properties of the visualization coordinate system.
Reference: [17] <author> Myers, Brad A. </author> <title> Creating User Interfaces by Demonstration. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: Another approach to this problem would be to specify the layout graphically through induction-style rules. With this strategy, similar to a demonstrational approach [6], <ref> [17] </ref>, the end-user would specify the mapping of the first aggregate element (base case) and the relationship between an aggregate instance k and the next element k+1. From this information, the system would inductively place each instance element of the aggregate.
Reference: [18] <author> Myers, Brad A., et al. Garnet: </author> <title> Comprehensive Support for Graphical, Highly Interactive User Interfaces. </title> <journal> IEEE Computer, </journal> <volume> 23(11) </volume> <pages> 71-85, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Our system gives end-users the ability to specify arbitrary graphical representations of aggregate data and how it is mapped to the display. This gives users the ability to create highly customized, interactive visualizations. Graphics toolkits such as Garnet <ref> [18] </ref> and Interviews [11] provide programmatic support for visualizing data sets such as lists and graphs. Our work focuses on allowing end-users to create aggregate visualizations without textual programming.
Reference: [19] <author> Papantonakis, A., and King, P. J. H. </author> <title> Synatx and semantics of GQL, a graphical query language. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 6 </volume> <pages> 3-25, </pages> <year> 1995. </year>
Reference-contexts: Weasel provides support for visualizing dynamically changing data in real time, but does not support manipulation of the visualization. However, it is not clear that end-users (i.e., non-programmers) would be able to construct visualizations with Weasel. Other systems such as Magic Lens [5], GQL <ref> [19] </ref>, and Visage [4] have focused on the visual specification of database queries. While our system enables end-users to visually specify the functionality of project, select, join, and cross product database operations, our primary contribution is in integrating this functionality with end-user defined dynamic visualizations.
Reference: [20] <author> Roman, G.-C., Kenneth Cox, C. D. Wilcox, and J. Y. Plun. Pavane: </author> <title> a system for declarative visualization of concurrent computations. </title> <journal> Journal of Visual Languages and Computing 3, </journal> <pages> 161-193. </pages>
Reference-contexts: Graphics toolkits such as Garnet [18] and Interviews [11] provide programmatic support for visualizing data sets such as lists and graphs. Our work focuses on allowing end-users to create aggregate visualizations without textual programming. Research systems such as Pavane <ref> [20] </ref> and Weasel [3] allow the visualization of aggregate data through the use of a high-level specification language. With Swarm, a specification language associated with Pavane, programmers can write formal textual specifications of End-User Visualization and Manipulation of Distributed Aggregate Data - 3 - concurrent algorithms.
Reference: [21] <author> Roth, S.F., Kolojejchick, J., Mattis, J., and Goldstein, J., </author> <title> Interactive Graphic Design Using Automatic Presentation Knowledge, </title> <booktitle> Proceedings of the Conference on Human Factors in Computing Systems (SIGCHI '94), </booktitle> <address> Boston, MA, </address> <month> April </month> <year> 1994, </year> <pages> pp. 112-117. </pages>
Reference-contexts: Instead, our system focuses primarily on creating customized visualizations and reacting to dynamic updates of the data. The Visage system [4] enables users to specify visual queries on multiple data sets. Used in conjunction with the SageBrush tool <ref> [21] </ref>, visualizations of a visual query may be created, browsed, and refined. Like our work, the Visage system provides the ability to work with multiple data sets, providing the functionality of a relational databases project and select operations.
References-found: 21

