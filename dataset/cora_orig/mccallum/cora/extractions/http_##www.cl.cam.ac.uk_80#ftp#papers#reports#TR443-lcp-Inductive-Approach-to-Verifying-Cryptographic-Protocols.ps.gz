URL: http://www.cl.cam.ac.uk:80/ftp/papers/reports/TR443-lcp-Inductive-Approach-to-Verifying-Cryptographic-Protocols.ps.gz
Refering-URL: http://www.cl.cam.ac.uk:80/ftp/papers/reports/
Root-URL: 
Email: lcp@cl.cam.ac.uk  
Title: The Inductive Approach to Verifying Cryptographic Protocols  
Author: Lawrence C. Paulson 
Date: 6 February 1998  
Address: Pembroke Street Cambridge CB2 3QG England  
Affiliation: Computer Laboratory University of Cambridge  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Martn Abadi and Roger Needham. </author> <title> Prudent engineering practice for cryptographic protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(1) </volume> <pages> 6-15, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: One could alter the model to admit type confusion attacks, but a little explicitness in protocols <ref> [1] </ref> can cheaply prevent them. 2.2 The Operators parts, analz and synth Three operations are defined on possibly infinite sets of messages. Each is defined inductively, as the least set closed under specified extensions. Each extends a set of messages H with other items derivable from H. <p> It cannot occur in the original version of Otway-Rees, where Nb is encrypted in the second message. Otway-Rees uses nonces not just to assure freshness, but for binding: to identify the principals <ref> [1] </ref>. Verifying the binding complicates the formal proofs. One can prove|for the corrected protocol|that Na and Nb uniquely identify the messages they originate in and never coincide. <p> The proof again requires our proving by induction a lemma whose main premise is Crypt (shrK A)fjNa; Key Kjg 2 parts (spies evs); with a detailed consideration of how nonces can be used. 4.8 Proving a Simplified Protocol Abadi and Needham <ref> [1] </ref> suggest simplifying Otway-Rees by eliminating the encryption in the first two messages. Nonces serve only for freshness, not for binding. <p> Message 3 explicitly names the intended recipients. 1: A ! B : A; B; Na 3: S ! B : Na; fjNa; A; B; Kabjg Ka ; fjNb; A; B; Kabjg Kb 4: B ! A : Na; fjNa; A; B; Kabjg Ka The authors claim <ref> [1, page 11] </ref>, `The protocol is not only more efficient but conceptually simpler after this modification.' The machine proofs support their claims. The vital guarantees to B and A, from the last two messages, become almost trivial to prove. <p> In the original protocol, an agent's two certificates are distinguished only by their order of arrival; an intruder could easily exchange them. To correct this flaw, I have added the other party's name to each certificate. Such explicitness is good engineering practice <ref> [1] </ref>. It also simplifies the proofs (recall x4.8). Bull and Otway have accepted my change to their protocol [9]. The dummy session key Kcs avoids having to treat the last agent as a special case. All agents except the first take two certificates. <p> The analysis of Needham-Schroeder reveals Lowe's attack, and I have discovered a new attack in a variant of Otway-Rees. In addition to the protocols discussed above, I have analyzed two variants of Yahalom [36], a simplified version of Woo-Lam <ref> [1] </ref> and the shared-key version of Needham-Schroeder. Bella and I have looked at Ker-beros, which is based on timestamps; its use of session keys to encrypt other keys complicates its analysis [4]. <p> Small changes to protocols involve only small changes to proof scripts. 4 Analyzing Needham-Schroeder took only 30 hours of my time, the recursive protocol two weeks. These figures include time spent extending the model with public-key encryption and hashing. Adherence to design principles such as explicitness <ref> [1] </ref> simplifies proofs. Model checking is an effective means of finding attacks [24, 25, 26], but it cannot replace theorem proving. It copes with only finitely many states, and the failure to find an attack says nothing about how a protocol works.
Reference: [2] <author> Peter Aczel. </author> <title> An introduction to inductive definitions. </title> <editor> In J. Barwise, editor, </editor> <booktitle> Handbook of Mathematical Logic, </booktitle> <pages> pages 739-782. </pages> <publisher> North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: Customer. Could an attacker trick Bob into accepting a key shared with himself? Salesman. The use of identifying nonces prevents that. The customer may find such arguments unconvincing, but they can be made rigorous. The necessary formal tool is the inductive definition <ref> [2] </ref>. Each inductive definition lists the possible actions that an agent or system can perform. The corresponding induction rule lets us reason about the consequences of an arbitrary finite sequence of such actions.
Reference: [3] <author> Ross Anderson and Roger Needham. </author> <title> Programming Satan's computer. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Computer Science Today: Recent Trends and Developments, </booktitle> <volume> LNCS 1000, </volume> <pages> pages 426-440. </pages> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: One problem is the combinatorial complexity of the messages that an intruder could generate. A quite different problem is to specify precisely what properties the protocol is intended to achieve. Anderson and Needham's excellent tutorial <ref> [3] </ref> presents several examples and defines the terminology used below. Formal methods can be used to analyze security protocols. Two popular approaches are state exploration and belief logics. * State exploration methods [40] model the protocol as a finite state system.
Reference: [4] <author> Giampaolo Bella and Lawrence C. Paulson. </author> <title> Using Isabelle to prove properties of the Kerberos authentication system. </title> <note> In Orman and Meadows [30]. </note>
Reference-contexts: Bella and I have looked at Ker-beros, which is based on timestamps; its use of session keys to encrypt other keys complicates its analysis <ref> [4] </ref>. I have modelled part of the Internet protocol TLS [15, 35] in which secret nonces are exchanged, then used to compute session keys. Proofs are highly automated. One Isabelle command can generate thousands of inferences.
Reference: [5] <author> Dominique Bolignano. </author> <title> An approach to the formal verification of cryptographic protocols. </title> <booktitle> In Third ACM Conference on Computer and Communications Security, </booktitle> <pages> pages 106-118. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: Proving that state transformations preserve an invariant is the same style of reasoning as induction. Gray and McLean [19] also establish a security invariant by induction, though their work is based on temporal logic and their proofs are done by hand. 41 Bolignano's work <ref> [5] </ref> is based on the Coq proof checker. His X known inH is equivalent to my X 2 synth (analz H) and models fraudulent messages. Instead of formalizing traces, he models the states of the four agents A, B, S and the spy.
Reference: [6] <author> Dominique Bolignano and Valerie Menissier-Morain. </author> <title> Formal verification of cryptographic protocols using Coq. </title> <type> Technical report, </type> <institution> INRIA-Rocquencourt, </institution> <year> 1996. </year> <note> 44 REFERENCES </note>
Reference-contexts: His X known inH is equivalent to my X 2 synth (analz H) and models fraudulent messages. Instead of formalizing traces, he models the states of the four agents A, B, S and the spy. He and Menissier-Morain <ref> [6] </ref> have formalized the Otway-Rees protocol. In their model, the server uses the function KeyAB to choose session keys: whenever A and B participate in a run, the server issues KeyAB (A; B). They have proved three properties. The first resembles the forwarding lemmas described in x4.2.
Reference: [7] <author> Stephen H. Brackin. </author> <title> A HOL extension of GNY for automatically analyzing cryptographic protocols. </title> <booktitle> In Computer Security Foundations Workshop [13], </booktitle> <pages> pages 62-75. </pages>
Reference-contexts: It can even model carelessness, such as agents accidentally revealing secrets. The 2.1 Messages 3 inherent nondeterminism models the possibility of an agent's being unavailable. Belief logics allow short proofs; the main reason for mechanizing them <ref> [7] </ref> is to eliminate human error. In contrast, inductive verification of protocols involves long and detailed proofs. Each safety property is proved by induction over the protocol. Each case considers a state of the system that might be reached by the corresponding protocol step.
Reference: [8] <author> Jeremy Bryans and Steve Schneider. </author> <title> CSP, PVS and a recursive authentication protocol. </title> <note> In Orman and Meadows [30]. </note>
Reference-contexts: He considers a number of authentication properties in increasingly general settings, ultimately allowing concurrent runs. Recently, Dutertre and Schneider [16] have mechanized these hand proofs, revealing 42 8 CONCLUSIONS many errors in them. Bryans and Schneider <ref> [8] </ref> have proved some simple properties for a single run of the recursive authentication protocol. Schneider has considered the consequences of allowing messages to satisfy equational laws on messages. Many protocols|and attacks!|exploit algebraic properties of encryption method, particularly RSA [38]. 8 Conclusions The inductive method is simple and general.
Reference: [9] <author> John A. Bull and David J. Otway. </author> <title> The authentication protocol. </title> <type> Technical Report DRA/CIS3/PROJ/CORBA/SC/1/CSM/436-04/0.5b, </type> <institution> Defence Research Agency, Malvern, UK, </institution> <year> 1997. </year> <note> In press. </note>
Reference-contexts: The paper goes on to describe the method, first in overview (x2) and then in some detail (x3). Three protocols are then analyzed. Otway-Rees illustrates the shared-key model (x4); Needham-Schroeder illustrates the public-key model (x5); the recursive authentication protocol <ref> [9] </ref> demonstrates how to deal with n-way authentication (x6). Related work is discussed (x7) and conclusions given (x8). 2 Overview of the Inductive Method Informal arguments for a protocol's correctness are conducted in terms of what could or could not happen. Here is a hypothetical dialogue: Salesman. <p> of the protocol, somebody has sent the message Crypt (pubK A)fjNa; Nb; Cjg: Also, agent B has sent the message Crypt (pubK A)fjNa; Nb; Bjg: The unicity theorem for Nb implies B = C, a contradiction because C is compromised and B is not. 6 A Recursive Protocol This protocol <ref> [9] </ref> generalizes Otway-Rees to an arbitrary number of parties. First, A contacts B. If B then contacts the authentication server then the run resembles Otway-Rees. But B may choose to contact some other agent C, and so forth; a chain of arbitrary length may form. <p> To correct this flaw, I have added the other party's name to each certificate. Such explicitness is good engineering practice [1]. It also simplifies the proofs (recall x4.8). Bull and Otway have accepted my change to their protocol <ref> [9] </ref>. The dummy session key Kcs avoids having to treat the last agent as a special case. All agents except the first take two certificates. An implementation can safely omit the dummy certificate. Removing information from the system makes less information available to an intruder.
Reference: [10] <author> M. Burrows, M. Abadi, and R. M. Needham. </author> <title> A logic of authentication. </title> <journal> Proceedings of the Royal Society of London, </journal> <volume> 426 </volume> <pages> 233-271, </pages> <year> 1989. </year>
Reference-contexts: Lowe uses a general-purpose model-checker, FDR [24, 26]; the Interrogator [22] is a specialized tool. Attacks are quickly found, but keeping the state space small requires drastic simplifying assumptions. * Belief logics formalize what an agent may infer from messages received. The original BAN logic <ref> [10] </ref> allows short, abstract proofs. It has identified some protocol flaws but missed others. New belief logics [28] address some weaknesses of BAN but sacrifice its simplicity. <p> Laws and proof techniques developed for one protocol are often applicable generally. The approach is oriented around proving guarantees, but their absence can indicate possible attacks. In this way, I have discovered an attack on the variant of the Otway-Rees protocol suggested by Burrows et al. <ref> [10, page 2 2 OVERVIEW OF THE INDUCTIVE METHOD 247] </ref>. (At the time, I was unaware of Mao and Boyd's earlier attack [28].) Even if no attacks are found, the structure of the proof yields insights into the protocol. <p> Apart from the spy, agents only read messages addressed to themselves. The event Notes A X is visible to A and, if A is compromised, to the spy. Consider a variant of the Otway-Rees protocol <ref> [10, page 247] </ref>: 1: A ! B : Na; A; B; fjNa; A; Bjg Ka 2: B ! S : Na; A; B; fjNa; A; Bjg Ka ; Nb; fjNa; A; Bjg Kb 3: S ! B : Na; fjNa; Kabjg Ka ; fjNb; Kabjg Kb 4: B ! A : <p> This argument can be programmed as a tactic, which works for all protocols investigated. For the session key compromise theorem, no further effort is needed. Other secrecy theorems require a detailed argument. Chief among these is proving that nonce Nb of the Yahalom protocol <ref> [10] </ref> remains secret, which requires establishing a correspondence between nonces and keys [36]. 22 4 A SHARED-KEY PROTOCOL: OTWAY-REES 4.6 Proving the Session Key Secrecy Theorem This theorem states that the protocol is correct from the server's viewpoint. Let evs 2 otway and A, B 62 bad. <p> The original Otway-Rees protocol assures A that B is present (I have proved this using Isabelle), but the new protocol does not. However, the original version never assured B that A was present; anybody could replay message 1, as Burrows et al. have noted <ref> [10, page 247] </ref>. 5 A Public-Key Protocol: Needham-Schroeder Needham-Schroeder is the obvious choice for demonstrating the inductive method on public-key protocols. <p> Many researchers have investigated it, and Lowe has discovered a subtle flaw [24]. 5.1 The Protocol and Lowe's Attack The full Needham-Schroeder protocol consists of seven steps, four of which are devoted to distributing public keys. Burrows et al. <ref> [10] </ref> identified a flaw 3 From 82 to 40 seconds, and from 88 proof commands to 53. 5.2 Modelling the Protocol 25 in this part of the protocol: there was no guarantee that the public keys were fresh.
Reference: [11] <author> John Clark and Jeremy Jacob. </author> <title> On the security of recent protocols. </title> <journal> Information Processing Letters, </journal> <volume> 56(3) </volume> <pages> 151-155, </pages> <year> 1995. </year> <booktitle> [12] 8th Computer Security Foundations Workshop. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1995. </year> <booktitle> [13] 9th Computer Security Foundations Workshop. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1996. </year> <booktitle> [14] 10th Computer Security Foundations Workshop. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1997. </year>
Reference-contexts: Including redundancy in message bodies can satisfy these assumptions. 4 2 OVERVIEW OF THE INDUCTIVE METHOD Some published attacks involve accepting a nonce as a key [25] or regarding one component as being two <ref> [11] </ref>. One could alter the model to admit type confusion attacks, but a little explicitness in protocols [1] can cheaply prevent them. 2.2 The Operators parts, analz and synth Three operations are defined on possibly infinite sets of messages.
Reference: [15] <author> Tim Dierks and Christopher Allen. </author> <title> The TLS protocol: </title> <note> Version 1.0, </note> <month> November </month> <year> 1997. </year> <note> Internet-draft draftietftlsprotocol-05.txt. </note>
Reference-contexts: Implicit steps can be modelled, if necessary. For Otway-Rees, it suffices to prove authenticity of the certificate that A receives in step 4. For TLS <ref> [15, 35] </ref>, the model includes a rule for session confirmation in order to support the resumption of past sessions. We cannot assume that a message sent in step i will be received. <p> It includes the spy's initial state, which holds the long-term keys of an arbitrary set of `bad' agents. The spy may say anything he plausibly could say and can masquerade as any of the bad agents. The TLS protocol <ref> [15] </ref> arrives at session keys by exchanging nonces and applying a pseudo-random-number function. I have modelled TLS [35] by assuming this function to be an arbitrary injection. In the protocol specification, agents apply the random-number function when necessary. <p> Bella and I have looked at Ker-beros, which is based on timestamps; its use of session keys to encrypt other keys complicates its analysis [4]. I have modelled part of the Internet protocol TLS <ref> [15, 35] </ref> in which secret nonces are exchanged, then used to compute session keys. Proofs are highly automated. One Isabelle command can generate thousands of inferences.
Reference: [16] <author> Bruno Dutertre and Steve Schneider. </author> <title> Using a PVS embedding of CSP to verify authentication protocols. </title> <editor> In Elsa Gunter, editor, </editor> <title> Theorem Proving in Higher Order Logics: TPHOLs '97, </title> <publisher> LNCS, </publisher> <pages> pages 121-136, </pages> <year> 1997. </year> <note> In press. </note>
Reference-contexts: Proving certain theorems about the rank function establishes the property in question. Schneider has published detailed hand analyses of both the original protocol and Lowe's version. He considers a number of authentication properties in increasingly general settings, ultimately allowing concurrent runs. Recently, Dutertre and Schneider <ref> [16] </ref> have mechanized these hand proofs, revealing 42 8 CONCLUSIONS many errors in them. Bryans and Schneider [8] have proved some simple properties for a single run of the recursive authentication protocol. Schneider has considered the consequences of allowing messages to satisfy equational laws on messages.
Reference: [17] <author> Dieter Gollmann. </author> <title> What do we mean by entity authentication? In Symposium on Security and Privacy, </title> <address> pages 46-54. </address> <publisher> IEEE Computer Society, </publisher> <year> 1996. </year>
Reference-contexts: For simple key-exchange protocols, however, essentially the same six-command proof script always seems to work. The theorem makes explicit something we may have taken for granted: that no agent should use session keys to encrypt other keys (see also Goll-mann <ref> [17, x2.1] </ref>). A generalization of the theorem can be used to prove the secrecy of B's nonce in Yahalom [36]. The session key secrecy theorem states that if the server distributes a session key Kab to A and B, then the spy never gets this key.
Reference: [18] <author> M. J. C. Gordon and T. F. Melham. </author> <title> Introduction to HOL: A Theorem Proving Environment for Higher Order Logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: Some Isabelle syntax appears below in order to convey a feel for how proofs are conducted. The methodology is tailored to Isabelle and makes heavy use of its classical reasoner [34]. However, it can probably be modified to suit other higher-order logic provers such as PVS [31] or HOL <ref> [18] </ref>. At a minimum, the prover should provide a simplifier that takes conditional rewrite rules and that can perform automatic case splits for if-then-else expressions. Unless some form of set theory is available, the algebraic laws for parts, analz and synth will be lost.
Reference: [19] <author> James W. Gray, III and John McLean. </author> <title> Using temporal logic to specify and verify cryptographic protocols. </title> <booktitle> In Computer Security Foundations Workshop [12], </booktitle> <pages> pages 108-116. REFERENCES 45 </pages>
Reference-contexts: He modelled the system as an automaton, defining the initial state and the state transformations, and specifying security goals as invariants. Proving that state transformations preserve an invariant is the same style of reasoning as induction. Gray and McLean <ref> [19] </ref> also establish a security invariant by induction, though their work is based on temporal logic and their proofs are done by hand. 41 Bolignano's work [5] is based on the Coq proof checker.
Reference: [20] <author> Matthew Hennessy. </author> <title> The Semantics of Programming Languages: An Elementary Introduction Using Structural Operational Semantics. </title> <publisher> Wiley, </publisher> <year> 1990. </year>
Reference-contexts: Each inductive definition lists the possible actions that an agent or system can perform. The corresponding induction rule lets us reason about the consequences of an arbitrary finite sequence of such actions. Induction has long been used to specify the semantics of programming languages <ref> [20] </ref>; it copes well with nondeterminism. (Plotkin conceived this application of inductive definitions, while Huet pioneered their use in proof tools.) For security protocols, the model must specify the capabilities of an attacker. Several inductively-defined operators are useful. One (parts) merely returns all the components of a set of messages.
Reference: [21] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: Also, note that the attack of x2.9 works not by giving KeyAB (A; B) to the spy, but by getting A to accept KeyAB (C; A) as a good key for talking to B. Lowe's approach is based on traces, which are specified using the process calculus CSP <ref> [21] </ref> and examined using the model-checker FDR. His work originates in that of Roscoe [39]. Like Bolignano, he models the four agents A, B, S and the spy. However, his model is more realistic. <p> A full analysis carries the same assurance as a formal proof. The precise relationship between Meadows's and my uses of induction needs to be examined. Schneider [42], like Lowe, bases his work on CSP <ref> [21] </ref>. But instead of using a model checker, he applies the laws of CSP in proofs. A rank function is used to describe how an undesirable event is prevented. Proving certain theorems about the rank function establishes the property in question.
Reference: [22] <author> Richard Kemmerer, Catherine Meadows, and Jonathan Millen. </author> <title> Three systems for cryptographic protocol analysis. </title> <journal> Journal of Cryptology, </journal> <volume> 7(2) </volume> <pages> 79-130, </pages> <year> 1994. </year>
Reference-contexts: Two popular approaches are state exploration and belief logics. * State exploration methods [40] model the protocol as a finite state system. An exhaustive search checks that all reachable states are safe. Lowe uses a general-purpose model-checker, FDR [24, 26]; the Interrogator <ref> [22] </ref> is a specialized tool. Attacks are quickly found, but keeping the state space small requires drastic simplifying assumptions. * Belief logics formalize what an agent may infer from messages received. The original BAN logic [10] allows short, abstract proofs. It has identified some protocol flaws but missed others.
Reference: [23] <author> Richard A. Kemmerer. </author> <title> Analyzing encryption protocols using formal verification techniques. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 7(4) </volume> <pages> 448-457, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: Compromise of any one session key would reveal all the others [41]. 7 Related Work Several other researchers are using inductive or trace models. Verification is done using general-purpose theorem provers or model checkers, or by hand. In early work, Kemmerer <ref> [23] </ref> analyzed a protocol in the Ina Jo specification language, which is based on first-order logic. Using an animation tool, he identified two weaknesses in the protocol. He modelled the system as an automaton, defining the initial state and the state transformations, and specifying security goals as invariants.
Reference: [24] <author> Gavin Lowe. </author> <title> Breaking and fixing the Needham-Schroeder public-key protocol using CSP and FDR. </title> <editor> In T. Margaria and B. Steffen, editors, </editor> <booktitle> Tools and Algorithms for the Construction and Analysis of Systems. Second International Workshop, </booktitle> <volume> TACAS '96, LNCS 1055, </volume> <pages> pages 147-166, </pages> <year> 1996. </year>
Reference-contexts: Formal methods can be used to analyze security protocols. Two popular approaches are state exploration and belief logics. * State exploration methods [40] model the protocol as a finite state system. An exhaustive search checks that all reachable states are safe. Lowe uses a general-purpose model-checker, FDR <ref> [24, 26] </ref>; the Interrogator [22] is a specialized tool. Attacks are quickly found, but keeping the state space small requires drastic simplifying assumptions. * Belief logics formalize what an agent may infer from messages received. The original BAN logic [10] allows short, abstract proofs. <p> Many researchers have investigated it, and Lowe has discovered a subtle flaw <ref> [24] </ref>. 5.1 The Protocol and Lowe's Attack The full Needham-Schroeder protocol consists of seven steps, four of which are devoted to distributing public keys. <p> Na and Nb become known only to A and B. (Such shared secrets might be used to compute a session key.) Lowe refuted this claim, noting that if A ran the protocol with an enemy C, then C could start a new run with any agent B, masquerading as A <ref> [24] </ref>. One might argue that this is no attack at all. An agent who is careless enough to talk to the enemy cannot expect any guarantees. The mechanized analysis presented below reveals that the protocol's guarantees for A are adequate. <p> The guarantee is consistent with Lowe's attack because, as always, it considers runs between two uncompromised principals. If A runs the protocol with the spy then her guarantee is void. Lowe himself found no problem with the protocol from A's viewpoint <ref> [24, x3.2] </ref>; his attack concerns the guarantee for B. 5.4 Proving Guarantees for B The situation as seen by B is almost symmetrical to that seen by A. Proving by induction that Nb remains secret would authenticate A. <p> Does the induction formula require strengthening? Must additional lemmas be proved? But, in this case, we easily recognize Lowe's attack. The assumptions describe events that could actually occur: Nb need not remain secret. 30 6 A RECURSIVE PROTOCOL 5.6 Analyzing the Strengthened Protocol Lowe <ref> [24] </ref> suggests improving the Needham-Schroeder protocol by adding explicitness. <p> Like Bolignano, he models the four agents A, B, S and the spy. However, his model is more realistic. A and B may engage in concurrent runs, playing either role; the spy has an identity and a long-term key. Lowe has discovered numerous attacks, some of which are serious <ref> [24, 25, 26] </ref>. I have found his papers most useful in developing the Isabelle model. Meadows's paper on Needham-Schroeder [29] makes direct comparisons with Lowe's. She examines the same variants of the protocol and discusses differences in speed between the NRL Protocol Analyzer and FDR (the latter is faster). <p> These figures include time spent extending the model with public-key encryption and hashing. Adherence to design principles such as explicitness [1] simplifies proofs. Model checking is an effective means of finding attacks <ref> [24, 25, 26] </ref>, but it cannot replace theorem proving. It copes with only finitely many states, and the failure to find an attack says nothing about how a protocol works. An inductive proof is a symbolic examination of the protocol. Each step is analyzed in turn.
Reference: [25] <author> Gavin Lowe. </author> <title> Some new attacks upon security protocols. </title> <booktitle> In Computer Security Foundations Workshop [13], </booktitle> <pages> pages 162-169. </pages>
Reference-contexts: An encrypted message can neither be altered nor read without the appropriate key; different types of components cannot be confused. Including redundancy in message bodies can satisfy these assumptions. 4 2 OVERVIEW OF THE INDUCTIVE METHOD Some published attacks involve accepting a nonce as a key <ref> [25] </ref> or regarding one component as being two [11]. One could alter the model to admit type confusion attacks, but a little explicitness in protocols [1] can cheaply prevent them. 2.2 The Operators parts, analz and synth Three operations are defined on possibly infinite sets of messages. <p> Like Bolignano, he models the four agents A, B, S and the spy. However, his model is more realistic. A and B may engage in concurrent runs, playing either role; the spy has an identity and a long-term key. Lowe has discovered numerous attacks, some of which are serious <ref> [24, 25, 26] </ref>. I have found his papers most useful in developing the Isabelle model. Meadows's paper on Needham-Schroeder [29] makes direct comparisons with Lowe's. She examines the same variants of the protocol and discusses differences in speed between the NRL Protocol Analyzer and FDR (the latter is faster). <p> These figures include time spent extending the model with public-key encryption and hashing. Adherence to design principles such as explicitness [1] simplifies proofs. Model checking is an effective means of finding attacks <ref> [24, 25, 26] </ref>, but it cannot replace theorem proving. It copes with only finitely many states, and the failure to find an attack says nothing about how a protocol works. An inductive proof is a symbolic examination of the protocol. Each step is analyzed in turn.
Reference: [26] <author> Gavin Lowe. SPLICE/AS: </author> <title> A case study in using CSP to detect errors in security protocols. </title> <type> Technical report, </type> <institution> Oxford University Computing Laboratory, </institution> <year> 1996. </year>
Reference-contexts: Formal methods can be used to analyze security protocols. Two popular approaches are state exploration and belief logics. * State exploration methods [40] model the protocol as a finite state system. An exhaustive search checks that all reachable states are safe. Lowe uses a general-purpose model-checker, FDR <ref> [24, 26] </ref>; the Interrogator [22] is a specialized tool. Attacks are quickly found, but keeping the state space small requires drastic simplifying assumptions. * Belief logics formalize what an agent may infer from messages received. The original BAN logic [10] allows short, abstract proofs. <p> Like Bolignano, he models the four agents A, B, S and the spy. However, his model is more realistic. A and B may engage in concurrent runs, playing either role; the spy has an identity and a long-term key. Lowe has discovered numerous attacks, some of which are serious <ref> [24, 25, 26] </ref>. I have found his papers most useful in developing the Isabelle model. Meadows's paper on Needham-Schroeder [29] makes direct comparisons with Lowe's. She examines the same variants of the protocol and discusses differences in speed between the NRL Protocol Analyzer and FDR (the latter is faster). <p> These figures include time spent extending the model with public-key encryption and hashing. Adherence to design principles such as explicitness [1] simplifies proofs. Model checking is an effective means of finding attacks <ref> [24, 25, 26] </ref>, but it cannot replace theorem proving. It copes with only finitely many states, and the failure to find an attack says nothing about how a protocol works. An inductive proof is a symbolic examination of the protocol. Each step is analyzed in turn.
Reference: [27] <author> Gavin Lowe. Casper: </author> <title> A compiler for the analysis of security protocols. </title> <booktitle> In Computer Security Foundations Workshop [14], </booktitle> <pages> pages 18-30. </pages>
Reference-contexts: The spy can masquerade as A by replaying an old message of hers, but cannot read the resulting certificate without her long-term key. Allowing type confusion (such as passing a nonce as a key) often admits attacks <ref> [27, 29] </ref> in which one form of certificate is mistaken for another. The recursive authentication protocol is safe from such attacks because it has only one form of certificate. However, encryption must be secure.
Reference: [28] <author> Wenbo Mao and Colin Boyd. </author> <title> Towards formal analysis of security protocols. </title> <booktitle> In Computer Security Foundations Workshop VI, </booktitle> <pages> pages 147-158. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: Attacks are quickly found, but keeping the state space small requires drastic simplifying assumptions. * Belief logics formalize what an agent may infer from messages received. The original BAN logic [10] allows short, abstract proofs. It has identified some protocol flaws but missed others. New belief logics <ref> [28] </ref> address some weaknesses of BAN but sacrifice its simplicity. We can fruitfully borrow from both approaches: from the first, a concrete notion of events, such as A sending X to B; from the second, the idea of deriving guarantees from each message. <p> In this way, I have discovered an attack on the variant of the Otway-Rees protocol suggested by Burrows et al. [10, page 2 2 OVERVIEW OF THE INDUCTIVE METHOD 247]. (At the time, I was unaware of Mao and Boyd's earlier attack <ref> [28] </ref>.) Even if no attacks are found, the structure of the proof yields insights into the protocol. The paper goes on to describe the method, first in overview (x2) and then in some detail (x3). Three protocols are then analyzed. <p> This attack is more serious than that discovered by Mao and Boyd <ref> [28] </ref>, where the server could detect the repetition of a nonce. It cannot occur in the original version of Otway-Rees, where Nb is encrypted in the second message. Otway-Rees uses nonces not just to assure freshness, but for binding: to identify the principals [1].
Reference: [29] <author> Catherine A. Meadows. </author> <title> Analyzing the Needham-Schroeder public-key protocol: A comparison of two approaches. </title> <editor> In E. Bertino, H. Kurth, G. Martella, and E. Montolivo, editors, </editor> <booktitle> Computer Security | ESORICS 96, </booktitle> <volume> LNCS 1146, </volume> <pages> pages 351-364. </pages> <publisher> Springer, </publisher> <year> 1996. </year>
Reference-contexts: The spy can masquerade as A by replaying an old message of hers, but cannot read the resulting certificate without her long-term key. Allowing type confusion (such as passing a nonce as a key) often admits attacks <ref> [27, 29] </ref> in which one form of certificate is mistaken for another. The recursive authentication protocol is safe from such attacks because it has only one form of certificate. However, encryption must be secure. <p> A and B may engage in concurrent runs, playing either role; the spy has an identity and a long-term key. Lowe has discovered numerous attacks, some of which are serious [24, 25, 26]. I have found his papers most useful in developing the Isabelle model. Meadows's paper on Needham-Schroeder <ref> [29] </ref> makes direct comparisons with Lowe's. She examines the same variants of the protocol and discusses differences in speed between the NRL Protocol Analyzer and FDR (the latter is faster). She reports many other experiments, for example on the possibility of nonces being compromised.
Reference: [30] <author> Hilarie Orman and Catherine Meadows, </author> <title> editors. Workshop on Design and Formal Verification of Security Protocols. </title> <institution> DIMACS, </institution> <month> September </month> <year> 1997. </year>
Reference: [31] <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year> <note> 46 REFERENCES </note>
Reference-contexts: Some Isabelle syntax appears below in order to convey a feel for how proofs are conducted. The methodology is tailored to Isabelle and makes heavy use of its classical reasoner [34]. However, it can probably be modified to suit other higher-order logic provers such as PVS <ref> [31] </ref> or HOL [18]. At a minimum, the prover should provide a simplifier that takes conditional rewrite rules and that can perform automatic case splits for if-then-else expressions. Unless some form of set theory is available, the algebraic laws for parts, analz and synth will be lost.
Reference: [32] <author> Lawrence C. Paulson. </author> <title> Isabelle: A Generic Theorem Prover. </title> <publisher> Springer, </publisher> <year> 1994. </year> <note> LNCS 828. </note>
Reference-contexts: Agents do not know the true sender of a message and may forward items that they cannot read. One agent is an active attacker. Properties are proved by induction on traces, using the theorem prover Isabelle <ref> [32] </ref>. Analyzing a new protocol requires several days' effort, while exploring the effects of a change to an existing protocol often takes just a few hours. Laws and proof techniques developed for one protocol are often applicable generally. <p> prove guarantees for both agents: if they receive the expected messages, and the nonces agree, then the server really did distribute the session key to the intended parties. 11 3 A Mechanized Theory of Messages The approach has been mechanized using Isabelle/HOL, an instantiation of the generic theorem prover Isabelle <ref> [32, 37] </ref> to higher-order logic. Isabelle is appropriate because of its support for inductively defined sets and its automatic tools. Some Isabelle syntax appears below in order to convey a feel for how proofs are conducted.
Reference: [33] <author> Lawrence C. Paulson. </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press, </publisher> <address> 2nd edition, </address> <year> 1996. </year>
Reference-contexts: Unless some form of set theory is available, the algebraic laws for parts, analz and synth will be lost. HOL predicates make satisfactory sets, but finite lists do not. Isabelle/HOL has a polymorphic type system resembling ML's <ref> [33] </ref>. An item of type agent can never appear where something of type msg is expected. Type inference eliminates the need to specify types in expressions.
Reference: [34] <author> Lawrence C. Paulson. </author> <title> Generic automatic proof tools. </title> <editor> In Robert Veroff, editor, </editor> <booktitle> Automated Reasoning and its Applications: Essays in Honor of Larry Wos, chapter 3. </booktitle> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: Isabelle is appropriate because of its support for inductively defined sets and its automatic tools. Some Isabelle syntax appears below in order to convey a feel for how proofs are conducted. The methodology is tailored to Isabelle and makes heavy use of its classical reasoner <ref> [34] </ref>. However, it can probably be modified to suit other higher-order logic provers such as PVS [31] or HOL [18]. At a minimum, the prover should provide a simplifier that takes conditional rewrite rules and that can perform automatic case splits for if-then-else expressions.
Reference: [35] <author> Lawrence C. Paulson. </author> <title> Inductive analysis of the internet protocol TLS. </title> <type> Technical Report 440, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <month> December </month> <year> 1997. </year>
Reference-contexts: Implicit steps can be modelled, if necessary. For Otway-Rees, it suffices to prove authenticity of the certificate that A receives in step 4. For TLS <ref> [15, 35] </ref>, the model includes a rule for session confirmation in order to support the resumption of past sessions. We cannot assume that a message sent in step i will be received. <p> The spy may say anything he plausibly could say and can masquerade as any of the bad agents. The TLS protocol [15] arrives at session keys by exchanging nonces and applying a pseudo-random-number function. I have modelled TLS <ref> [35] </ref> by assuming this function to be an arbitrary injection. In the protocol specification, agents apply the random-number function when necessary. The spy has an additional rule that allows him to apply the function to any message items at his disposal. <p> Bella and I have looked at Ker-beros, which is based on timestamps; its use of session keys to encrypt other keys complicates its analysis [4]. I have modelled part of the Internet protocol TLS <ref> [15, 35] </ref> in which secret nonces are exchanged, then used to compute session keys. Proofs are highly automated. One Isabelle command can generate thousands of inferences.
Reference: [36] <author> Lawrence C. Paulson. </author> <title> On two formal analyses of the Yahalom protocol. </title> <type> Technical Report 432, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: We need an assurance that lost keys cannot compromise future runs. The Oops message includes nonces in order to identify the protocol run, distinguishing between recent and past losses. For some protocols, such as Yahalom, the Oops rule brings hidden properties to light <ref> [36] </ref>. For others, it is not clear whether Oops can be expressed at all. 2.6 Induction The specification defines the set of possible traces inductively: it is the least set closed under the given rules. <p> The theorem makes explicit something we may have taken for granted: that no agent should use session keys to encrypt other keys (see also Goll-mann [17, x2.1]). A generalization of the theorem can be used to prove the secrecy of B's nonce in Yahalom <ref> [36] </ref>. The session key secrecy theorem states that if the server distributes a session key Kab to A and B, then the spy never gets this key. <p> For the session key compromise theorem, no further effort is needed. Other secrecy theorems require a detailed argument. Chief among these is proving that nonce Nb of the Yahalom protocol [10] remains secret, which requires establishing a correspondence between nonces and keys <ref> [36] </ref>. 22 4 A SHARED-KEY PROTOCOL: OTWAY-REES 4.6 Proving the Session Key Secrecy Theorem This theorem states that the protocol is correct from the server's viewpoint. Let evs 2 otway and A, B 62 bad. <p> The analysis of Needham-Schroeder reveals Lowe's attack, and I have discovered a new attack in a variant of Otway-Rees. In addition to the protocols discussed above, I have analyzed two variants of Yahalom <ref> [36] </ref>, a simplified version of Woo-Lam [1] and the shared-key version of Needham-Schroeder. Bella and I have looked at Ker-beros, which is based on timestamps; its use of session keys to encrypt other keys complicates its analysis [4].
Reference: [37] <author> Lawrence C. Paulson. </author> <title> Tool support for logics of programs. </title> <editor> In Manfred Broy, editor, </editor> <booktitle> Mathematical Methods in Program Development: Summer School Marktoberdorf 1996, NATO ASI Series F, </booktitle> <pages> pages 461-498. </pages> <address> Springer, </address> <note> Published 1997. </note>
Reference-contexts: prove guarantees for both agents: if they receive the expected messages, and the nonces agree, then the server really did distribute the session key to the intended parties. 11 3 A Mechanized Theory of Messages The approach has been mechanized using Isabelle/HOL, an instantiation of the generic theorem prover Isabelle <ref> [32, 37] </ref> to higher-order logic. Isabelle is appropriate because of its support for inductively defined sets and its automatic tools. Some Isabelle syntax appears below in order to convey a feel for how proofs are conducted.
Reference: [38] <author> R. L. Rivest, A. Shamir, and L. Adleman. </author> <title> A method for obtaining digital signatures and public-key cryptosystems. </title> <journal> Communications of the ACM, </journal> <volume> 21(2) </volume> <pages> 120-126, </pages> <month> February </month> <year> 1978. </year>
Reference-contexts: Encryption is strong. Injectivity yields the law Crypt KX = Crypt K 0 X 0 =) K = K 0 ^ X = X 0 : Moreover, the spy cannot alter an encrypted message without first decrypting it using the relevant key. Exclusive-or violates these assumptions, as does RSA <ref> [38] </ref> unless redundancy is incorporated. Such forms of encryption could be modelled, but the loss of injectiveness would complicate the theory. 3.2 Defining parts, analz and synth The operators parts, analz and synth are defined inductively, as are protocols themselves. <p> Bryans and Schneider [8] have proved some simple properties for a single run of the recursive authentication protocol. Schneider has considered the consequences of allowing messages to satisfy equational laws on messages. Many protocols|and attacks!|exploit algebraic properties of encryption method, particularly RSA <ref> [38] </ref>. 8 Conclusions The inductive method is simple and general. We have seen how it handles three versions of Otway-Rees, two versions of Needham-Schroeder (with public keys), and a recursive protocol. The analysis of Needham-Schroeder reveals Lowe's attack, and I have discovered a new attack in a variant of Otway-Rees.
Reference: [39] <author> A. W. Roscoe. </author> <title> Modelling and verifying key-exchange protocols using CSP and FDR. </title> <booktitle> In Computer Security Foundations Workshop [12], </booktitle> <pages> pages 98-107. </pages>
Reference-contexts: Lowe's approach is based on traces, which are specified using the process calculus CSP [21] and examined using the model-checker FDR. His work originates in that of Roscoe <ref> [39] </ref>. Like Bolignano, he models the four agents A, B, S and the spy. However, his model is more realistic. A and B may engage in concurrent runs, playing either role; the spy has an identity and a long-term key.
Reference: [40] <author> Peter Y. A. Ryan. </author> <title> The design and verification of security protocols. </title> <type> Technical Report DRA/CIS3/SISG/CR/96/1.0, </type> <institution> Defence Research Agency, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: Anderson and Needham's excellent tutorial [3] presents several examples and defines the terminology used below. Formal methods can be used to analyze security protocols. Two popular approaches are state exploration and belief logics. * State exploration methods <ref> [40] </ref> model the protocol as a finite state system. An exhaustive search checks that all reachable states are safe. Lowe uses a general-purpose model-checker, FDR [24, 26]; the Interrogator [22] is a specialized tool.
Reference: [41] <author> Peter Y. A. Ryan and S. A. Schneider. </author> <title> An attack on a recursive authentication protocol: A cautionary tale. </title> <type> Technical Report TR97245, </type> <institution> Defence Research Agency, </institution> <year> 1997. </year> <note> In Press. </note>
Reference-contexts: Unfortunately, each hash value was used twice: B's session keys Kab and Kbc were encrypted as Kab HashfjKb; Nbjg and Kbc HashfjKb; Nbjg: By forming their XOR, an eavesdropper could immediately obtain Kab Kbc, Kbc Kcd , etc. Compromise of any one session key would reveal all the others <ref> [41] </ref>. 7 Related Work Several other researchers are using inductive or trace models. Verification is done using general-purpose theorem provers or model checkers, or by hand. In early work, Kemmerer [23] analyzed a protocol in the Ina Jo specification language, which is based on first-order logic. <p> REFERENCES 43 x4.7). A protocol proof must contain a separate guarantee|under reasonable assumptions|for each participant. The attack on the recursive protocol <ref> [41] </ref> is a sobering reminder of the limitations of formal methods. Models idealize the real world: here, by assuming strong encryption. Making the model more detailed makes reasoning harder and, eventually, infeasible.
Reference: [42] <author> Steve Schneider. </author> <title> Verifying authentication protocols with CSP. </title> <booktitle> In Computer Security Foundations Workshop [14], </booktitle> <pages> pages 3-17. </pages>
Reference-contexts: Ostensibly based on brute-force state enumeration, it can also prove by induction that infinite sets of states are unreachable. A full analysis carries the same assurance as a formal proof. The precise relationship between Meadows's and my uses of induction needs to be examined. Schneider <ref> [42] </ref>, like Lowe, bases his work on CSP [21]. But instead of using a model checker, he applies the laws of CSP in proofs. A rank function is used to describe how an undesirable event is prevented. Proving certain theorems about the rank function establishes the property in question.
References-found: 39

