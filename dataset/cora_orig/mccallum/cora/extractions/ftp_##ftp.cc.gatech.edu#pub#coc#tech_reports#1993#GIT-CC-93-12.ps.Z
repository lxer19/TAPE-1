URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1993/GIT-CC-93-12.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.93.html
Root-URL: 
Title: Simplifying Fault-Tolerance: Providing the Abstraction of Crash Failures  
Author: Rida A. Bazzi Gil Neiger 
Note: This author was supported in part by a scholarship from the Hariri Foundation.  
Address: Atlanta, Georgia 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  
Date: February 16, 1993  
Pubnum: GIT-CC-93/12  
Abstract: The difficulty of designing fault-tolerant distributed algorithms increases with the severity of failures that an algorithm must tolerate. This paper considers methods that automatically translate algorithms tolerant of simple crash failures into ones tolerant of more severe failures. These translations simplify the design task by allowing algorithm designers to assume that processors fail only by stopping. Such translations can be quantified by two measures: fault-tolerance, which is a measure of how many processors must remain nonfaulty for the translation to be correct, and round-complexity, which is a measure of how the translation increases the running time of an algorithm. Understanding these translations and their limitations with respect to these measures can provide insight into the relative impact of different models of faulty behavior on the ability to provide fault-tolerant applications. This paper considers two classes of translations from crash failures to each of the following types of more severe failures: omission to send messages; omission to send and receive messages; and totally arbitrary behavior. It shows that previously developed translations to send-omission failures are optimal with respect to both fault-tolerance and round-complexity. It exhibits a hierarchy of translations to general (send/receive) omissions that improves upon the fault-tolerance of previously developed translations. It also gives a series of translations to arbitrary failures that improves upon the round-complexity of previously developed translations. All translations developed in this paper are shown to be optimal in that they cannot be improved with respect to one measure without negatively affecting the other; that is, both hierarchies of translations are matched by corresponding hierarchies of impossibility results. fl Partial support for this work was provided by the National Science Foundation under grants CCR-8909663 and CCR-9106627. Earlier versions of parts of this paper appeared as "Optimally Simulating Crash Failures in a Byzantine Environment" in S. Toueg, P. G. Spirakis, and L. Kirousis, editors, Proceedings of the Fifth International Workshop on Distributed Algorithms, volume 579 of Lecture Notes on Computer Science, pages 108-128. Springer-Verlag, October 1991, and as "Simulating Crash Failures with Many Faulty Processors" in A. Segall and S. Zaks, editors, Proceedings of the Sixth International Workshop on Distributed Algorithms, volume 647 of Lecture Notes on Computer Science, pages 166-184. Springer-Verlag, November 1992. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Hagit Attiya, Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. </author> <title> Bounds on the time to reach agreement in the presence of timing uncertainty. </title> <booktitle> In Proceedings of the Twenty-Third ACM Symposium on Theory of Computing, </booktitle> <pages> pages 359-369. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: Translations such as those presented in this paper have been developed for completely asynchronous systems [7] as well as the completely synchronous systems considered here. Other researchers have studied problems in which there exists timing uncertainty that is bounded. Attiya et al. <ref> [1] </ref> consider the consensus problem in such systems with crash failures. Ponzio [21] extends this work to systems with send-omission and arbitrary failures. It seems likely that translations applicable to such systems would simplify the latter and may lead to improved algorithms.
Reference: [2] <author> Rida Bazzi and Gil Neiger. </author> <title> The complexity and impossibility of achieving fault-tolerant coordination. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 203-214. </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1992. </year>
Reference: [3] <author> Piotr Berman and Juan A. Garay. </author> <title> Asymptotically optimal consensus. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Automata, Languages, and Programming, volume 372 of Lecture Notes on Computer Science, </booktitle> <pages> pages 80-94. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <title> Simplifying Fault-Tolerance: Providing the Abstraction of Crash Failures 47 </title>
Reference: [4] <author> Piotr Berman, Juan A. Garay, and Kenneth J. Perry. </author> <title> Towards optimal distributed consensus. </title> <booktitle> In Proceedings of the Thirtieth Symposium on Foundations of Computer Science, </booktitle> <pages> pages 410-415. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> October </month> <year> 1989. </year>
Reference: [5] <author> Brian A. Coan. </author> <title> A communication-efficient canonical form for fault-tolerant distributed protocols. </title> <booktitle> In Proceedings of the Fifth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 63-72, </pages> <month> August </month> <year> 1986. </year> <note> A revised version appears in Coan's Ph.D. dissertation [6]. </note>
Reference-contexts: It is simply one protocol for which the desired impossibility results could be shown (it yields simple proofs). The communication used in the protocol is simply that of a processor broadcasting a message and the receiving processors relaying it. This communication structure is quite common. 40 Arguments by Coan <ref> [5] </ref> can be used to show that, if a translation exists, it can be assumed to be a full-information translation. In such a translation, each processor sends in each round all the information it has (i.e., all the messages it received in the previous round).
Reference: [6] <author> Brian A. Coan. </author> <title> Achieving Consensus in Fault-Tolerant Distributed Computer Systems: Protocols, Lower Bounds, and Simulations. </title> <type> Ph.D. dissertation, </type> <institution> Massachusetts Institute of Technology, </institution> <month> June </month> <year> 1987. </year>
Reference: [7] <author> Brian A. Coan. </author> <title> A compiler that increases the fault-tolerance of asynchronous protocols. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(12) </volume> <pages> 1541-1553, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Such failures are also called malicious or Byzantine. (Other failures models were studied in the literature but are beyond the scope of this paper [22, 23].) Many researchers have developed translations for failures within this hierarchy. 1 Coan <ref> [7] </ref> considered systems with asynchronous message-passing (also called asynchronous systems) and developed a "compiler" that converts algorithms tolerant of crash failures into ones that tolerate arbitrary failures. Thus, his translation spans this hierarchy of failures. <p> This is because there is no way to ensure that the simulated states of faulty processors are those in a history with crash failures; an arbitrarily faulty processor can set its state in any way it chooses. Thus, this section considers only non-uniform translations. Coan <ref> [7] </ref> considered systems with asynchronous systems and developed translations from crash failures to arbitrary failures. Coan's translations does not apply to systems with synchronous message-passing (or synchronous systems). Neiger and Toueg [18] developed two composed translations for synchronous systems. <p> As long as n &gt; 3t, our translations to arbitrary failures have constant round-complexity of at most 4. Translations such as those presented in this paper have been developed for completely asynchronous systems <ref> [7] </ref> as well as the completely synchronous systems considered here. Other researchers have studied problems in which there exists timing uncertainty that is bounded. Attiya et al. [1] consider the consensus problem in such systems with crash failures. Ponzio [21] extends this work to systems with send-omission and arbitrary failures.
Reference: [8] <author> Danny Dolev. </author> <title> The Byzantine generals strike again. </title> <journal> Journal of Algorithms, </journal> <volume> 3(1) </volume> <pages> 14-30, </pages> <year> 1982. </year>
Reference-contexts: In addition, our results can be extended to systems in which processors may receive an external input and produce an external output in any round. 3 Work by Dolev <ref> [8] </ref> and Hadzilacos [13] suggests that our results may be extended to network topologies in which there is less (but sufficient) connectivity. 4 Thus, if p sends no message to q in a round, we say that p "sends" ? to q, although no message is actually sent. 4 state =
Reference: [9] <author> Michael J. Fischer. </author> <title> The consensus problem in unreliable distributed systems (a brief survey). </title> <editor> In M. Karpinsky, editor, </editor> <booktitle> Foundations of Computation Theory, volume 158 of Lecture Notes on Computer Science, </booktitle> <pages> pages 127-140. </pages> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: For example, this type of specification is typically used for characterizing different forms of Distributed Consensus <ref> [9] </ref>. Being able to refer to processor states is not sufficient to specify some problems. For example, the specification of the Byzantine Generals problem [16] refers to the states of the correct processors. Thus, state specifications must be able to refer to the identities of the correct processors.
Reference: [10] <author> Juan A. Garay and Yoram Moses. </author> <title> Fully polynomial Byzantine agreement in t + 1 rounds. </title> <booktitle> In Proceedings of the Twenty-Fifth ACM Symposium on Theory of Computing. </booktitle> <publisher> ACM Press, </publisher> <month> May </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: However, there are solutions to this problem that use fewer rounds. For general omission failures, it is easy to develop an algorithm that uses only t + 1 rounds. For arbitrary failures, Garay and Moses <ref> [10] </ref> have developed and efficient (t + 1)-round algorithm that requires only n &gt; 3t.
Reference: [11] <author> Vassos Hadzilacos. </author> <title> Byzantine agreement under restricted types of failures (not telling the truth is different from telling lies). </title> <type> Technical Report 18-83, </type> <institution> Aiken Computation Laboratory, Harvard University, </institution> <year> 1983. </year> <note> A revised version appears in Hadzilacos's Ph.D. dissertation [12]. </note>
Reference-contexts: Such insights can be gained by examining the properties of the translations. The following failures, which include the ones most commonly considered, form a hierarchy from most benign to most severe: 1. Crash Failures. Processors subject to crash failures fail by stopping prematurely <ref> [11] </ref>. Before they stop, they behave correctly. After they stop, they take no further actions. 2. Send-Omission Failures: Processors subject to send-omission failures fail by intermittently omitting to send some of the messages that it should send [12]. The messages they send are always correct. <p> Hadzilacos <ref> [11] </ref> developed a technique to translate algorithms tolerant of crash failures into ones that tolerate send-omission failures; it was later shown that his translation is not general in that it cannot be applied to all algorithms [15]. 2 Neiger and Toueg [18] gave a translation for those failure type that is <p> Formally, this means that 8H 1 ; H 2 [((H 1 ) ^ 8i 2 Z 8p 2 Correct (H 2 )[q 1 (i; p) = q 2 (i; p)]) ) (H 2 )]: 3.2 Crash Failures A crash failure <ref> [11] </ref> is the most benign type of failure that this paper considers. A processor commits a crash failure by prematurely halting in some round. <p> We begin by noting a result that follows from considering the classical problem of Byzantine Agreement. Hadzilacos <ref> [11] </ref> solved this problem in systems with crash failures for any n t, but Lamport et al. [16] showed that it cannot be solved in a system with arbitrary failures if n 3t; thus, the minimum fault-tolerance of a translation from C (n; t) to A (n; t) is n &gt; <p> The translations to arbitrary failures are all quite different from each other. Three translations cover that entire hierarchy. Using translations such as those developed here does not guarantee the development of the most efficient algorithms possible. For example, Hadzilacos <ref> [11] </ref> developed an efficient (t + 1)-round solution to Byzantine Agreement that tolerates crash failures.
Reference: [12] <author> Vassos Hadzilacos. </author> <title> Issues of Fault Tolerance in Concurrent Computations. </title> <type> Ph.D. dissertation, </type> <institution> Harvard University, </institution> <month> June </month> <year> 1984. </year> <type> Technical Report 11-84, </type> <institution> Aiken Computation Laboratory. </institution>
Reference-contexts: Crash Failures. Processors subject to crash failures fail by stopping prematurely [11]. Before they stop, they behave correctly. After they stop, they take no further actions. 2. Send-Omission Failures: Processors subject to send-omission failures fail by intermittently omitting to send some of the messages that it should send <ref> [12] </ref>. The messages they send are always correct. Because these processors can fail and yet continue to send messages, their failure is more difficult to detect and overcome than crash failures. 3. General Omission Failures. <p> C and F such that C = Correct (H), jF j t, and 8p 2 F 9i c 2 Z [p commits a crash failure in round i c of H]: 3.3 Send-Omission Failures Another type of failure, called a send-omission failure, occurs if a processor omits to send messages <ref> [12] </ref>. <p> However, H b will not satisfy (iv) (reaching agreement may take up to zr &gt; r rounds of communication). 5 Translations from Crash to Send-Omissions Hadzilacos <ref> [12] </ref> gave a 1-round translation from systems with crash failures to those with send-omission failures. Halpern and Strong [15], however, showed that this translation was neither general nor non-uniform as defined above.
Reference: [13] <author> Vassos Hadzilacos. </author> <title> Connectivity requirements for Byzantine agreement under restricted types of failures. </title> <journal> Distributed Computing, </journal> <volume> 2(2) </volume> <pages> 95-103, </pages> <year> 1987. </year>
Reference-contexts: In addition, our results can be extended to systems in which processors may receive an external input and produce an external output in any round. 3 Work by Dolev [8] and Hadzilacos <ref> [13] </ref> suggests that our results may be extended to network topologies in which there is less (but sufficient) connectivity. 4 Thus, if p sends no message to q in a round, we say that p "sends" ? to q, although no message is actually sent. 4 state = initial state; for
Reference: [14] <author> Joseph Y. Halpern and Yoram Moses. </author> <title> Knowledge and common knowledge in a distributed environment. </title> <journal> Journal of the ACM, </journal> <volume> 37(3) </volume> <pages> 549-587, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: In addition, an adaptation of the translations to arbitrary failures may result in new, more efficient algorithms for consensus in partially synchronous systems with arbitrary failures. It is clear that the notion of processor knowledge <ref> [14] </ref> is closely related to the work presented here, especially that in Section 7.2. For example, for a processor to refuse to receive a message from another, it must know that, by the end of the next round, all correct processors refuse messages from that other processor.
Reference: [15] <author> Joseph Y. Halpern and H. Raymond Strong, </author> <month> March </month> <year> 1986. </year> <type> Personal communication. </type>
Reference-contexts: Hadzilacos [11] developed a technique to translate algorithms tolerant of crash failures into ones that tolerate send-omission failures; it was later shown that his translation is not general in that it cannot be applied to all algorithms <ref> [15] </ref>. 2 Neiger and Toueg [18] gave a translation for those failure type that is general. Srikanth and Toueg [23] showed how algorithms that use message authentication to mitigate arbitrary failures can be transformed into ones that do not use message authentication. <p> However, H b will not satisfy (iv) (reaching agreement may take up to zr &gt; r rounds of communication). 5 Translations from Crash to Send-Omissions Hadzilacos [12] gave a 1-round translation from systems with crash failures to those with send-omission failures. Halpern and Strong <ref> [15] </ref>, however, showed that this translation was neither general nor non-uniform as defined above. Neiger and Toueg [18] used the arguments of Halpern and Strong to show that there can be no general 1-round translation from crash to send-omission failures.
Reference: [16] <author> Leslie Lamport, Robert Shostak, and Marshall Pease. </author> <title> The Byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Arbitrary Failures. Processors subject to arbitrary failures can take any action whatsoever <ref> [16] </ref>. They can stop, omit to send or receive messages, or send spurious messages and falsely claim to have received messages they did not actually receive. <p> For example, this type of specification is typically used for characterizing different forms of Distributed Consensus [9]. Being able to refer to processor states is not sufficient to specify some problems. For example, the specification of the Byzantine Generals problem <ref> [16] </ref> refers to the states of the correct processors. Thus, state specifications must be able to refer to the identities of the correct processors. <p> Omission failures place fewer restrictions on this behavior. In the worst case, faulty behavior may be completely arbitrary; processors may fail by sending incorrect messages and by making arbitrary state transitions <ref> [16] </ref>. Processor p is subject to arbitrary failures in history H = h; q; s; ri if it may deviate from in any way. <p> If t = 1, there is a 2-round translation if n &gt; 3t = 3. It is obtained by combining a (t + 1)-round (i.e., 2-round) solution to the Byzantine Generals problem <ref> [16] </ref> with a validation mechanism similar to that given in Section 7.1.1. <p> We begin by noting a result that follows from considering the classical problem of Byzantine Agreement. Hadzilacos [11] solved this problem in systems with crash failures for any n t, but Lamport et al. <ref> [16] </ref> showed that it cannot be solved in a system with arbitrary failures if n 3t; thus, the minimum fault-tolerance of a translation from C (n; t) to A (n; t) is n &gt; 3t.
Reference: [17] <author> Yoram Moses and Mark R. Tuttle. </author> <title> Programming simultaneous actions using common knowledge. </title> <journal> Algorithmica, </journal> <volume> 3(1) </volume> <pages> 121-169, </pages> <year> 1988. </year>
Reference: [18] <author> Gil Neiger and Sam Toueg. </author> <title> Automatically increasing the fault-tolerance of distributed algorithms. </title> <journal> Journal of Algorithms, </journal> <volume> 11(3) </volume> <pages> 374-419, </pages> <month> September </month> <year> 1990. </year> <month> 48 </month>
Reference-contexts: Hadzilacos [11] developed a technique to translate algorithms tolerant of crash failures into ones that tolerate send-omission failures; it was later shown that his translation is not general in that it cannot be applied to all algorithms [15]. 2 Neiger and Toueg <ref> [18] </ref> gave a translation for those failure type that is general. Srikanth and Toueg [23] showed how algorithms that use message authentication to mitigate arbitrary failures can be transformed into ones that do not use message authentication. <p> These are systems in which computation proceeds in synchronous rounds. This section defines a formal model of such systems. This model is an adaptation of that used by Neiger and Toueg <ref> [18] </ref>. 2.1 Distributed Systems A distributed system is a set P of n processors joined by bidirectional communication links. Processors share no memory; they communicate only by sending messages along the communication links. <p> The definition of translation used here is an adaptation of that used by Neiger and Toueg <ref> [18] </ref>. A translation is a function T that converts protocol c , designed to run correctly in C (n; t), into a protocol b = T ( c ) that runs correctly in B (n; t). b may use several rounds of communication to simulate each round of c . <p> Halpern and Strong [15], however, showed that this translation was neither general nor non-uniform as defined above. Neiger and Toueg <ref> [18] </ref> used the arguments of Halpern and Strong to show that there can be no general 1-round translation from crash to send-omission failures. They then gave a general 2-round translation from crash to send-omission failures that required only n &gt; t. <p> Thus, since every general translation is also a non-uniform translation, their translation is also optimal (with respect to fault-tolerance and round-complexity) for non-uniform translations as well. 6 Translations from Crash to General Omissions Neiger and Toueg <ref> [18] </ref> gave a general 2-round translation from crash to general omission failures that requires n &gt; 2t. They also showed that any general translation from crash to general omission failures requires that a majority of processors remain correct (n &gt; 2t). <p> In general, the larger that t is relative to n, the more rounds that are needed to perform the translation. These translations do not contradict an earlier impossibility result of Neiger and Toueg <ref> [18] </ref>, which held that no such translation was possible if n 2t (i.e., if as many as half the processors may fail), because that result applied to the stronger general translations. A primary contribution is that the impossibility result does not apply to non-uniform translations. <p> Thus, this section considers only non-uniform translations. Coan [7] considered systems with asynchronous systems and developed translations from crash failures to arbitrary failures. Coan's translations does not apply to systems with synchronous message-passing (or synchronous systems). Neiger and Toueg <ref> [18] </ref> developed two composed translations for synchronous systems. One was a 4-round translation from crash to arbitrary failures that requires n &gt; 4t and the other a 6-round translation that requires n &gt; 3t. <p> Because the translations developed here are non-uniform, they are applicable to solutions to problems with failure-insensitive specifications. For translations to send-omission failures, the original general translation of Neiger and Toueg <ref> [18] </ref> is simultaneously optimal with respect to fault-tolerance and round-complexity.
Reference: [19] <author> Gil Neiger and Mark R. Tuttle. </author> <title> Common knowledge and consistent simultaneous coordination. </title> <journal> Distributed Computing, </journal> <volume> 6(3), </volume> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: Many other problems considered in fault-tolerant distributed computing have failure-insensitive specifications. Neiger and Tuttle <ref> [19] </ref> give a careful analysis of the distinction between these problems and those that are sensitive to the behavior of faulty processors. Section 4 defines two different kinds of translations between systems with failures. Nonuniform translations apply only to problems with failure-insensitive specifications.
Reference: [20] <author> Kenneth J. Perry and Sam Toueg. </author> <title> Distributed agreement in the presence of processor and communication faults. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(3) </volume> <pages> 477-482, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: If processors may omit to send messages and later function correctly, then the correct processors may have more difficulty agreeing on the identity and timing of failures than they would if only crash failures occurred. 3.4 General Omission Failures A more complex type of failure, called a general omission failure <ref> [20] </ref>, occurs if a processor intermittently fails to send and receive messages.
Reference: [21] <author> Stephen Ponzio. </author> <title> Consensus in the presence of timing uncertainty: Omission and Byzan-tine faults. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 125-138. </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: Other researchers have studied problems in which there exists timing uncertainty that is bounded. Attiya et al. [1] consider the consensus problem in such systems with crash failures. Ponzio <ref> [21] </ref> extends this work to systems with send-omission and arbitrary failures. It seems likely that translations applicable to such systems would simplify the latter and may lead to improved algorithms.
Reference: [22] <author> Richard D. Schlichting and Fred B. Schneider. </author> <title> Fail-stop processors: an approach to designing fault-tolerant computing systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 1(3) </volume> <pages> 222-238, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: They can stop, omit to send or receive messages, or send spurious messages and falsely claim to have received messages they did not actually receive. Such failures are also called malicious or Byzantine. (Other failures models were studied in the literature but are beyond the scope of this paper <ref> [22, 23] </ref>.) Many researchers have developed translations for failures within this hierarchy. 1 Coan [7] considered systems with asynchronous message-passing (also called asynchronous systems) and developed a "compiler" that converts algorithms tolerant of crash failures into ones that tolerate arbitrary failures. Thus, his translation spans this hierarchy of failures. <p> In the weakest case, n = t + 2, t + 1 rounds are required. Note that t + 1 rounds are always sufficient, because fail-stop failures <ref> [22] </ref> can always be simulated in t + 1 rounds, and they are a more restrictive type of failure than crash failures. 22 All the translations are efficient in that they generate protocols that do not require substantially more local computation than the original protocols.
Reference: [23] <author> T. K. Srikanth and Sam Toueg. </author> <title> Simulating authenticated broadcasts to derive simple fault-tolerant algorithms. </title> <journal> Distributed Computing, </journal> <volume> 2(2) </volume> <pages> 80-94, </pages> <year> 1987. </year>
Reference-contexts: They can stop, omit to send or receive messages, or send spurious messages and falsely claim to have received messages they did not actually receive. Such failures are also called malicious or Byzantine. (Other failures models were studied in the literature but are beyond the scope of this paper <ref> [22, 23] </ref>.) Many researchers have developed translations for failures within this hierarchy. 1 Coan [7] considered systems with asynchronous message-passing (also called asynchronous systems) and developed a "compiler" that converts algorithms tolerant of crash failures into ones that tolerate arbitrary failures. Thus, his translation spans this hierarchy of failures. <p> Srikanth and Toueg <ref> [23] </ref> showed how algorithms that use message authentication to mitigate arbitrary failures can be transformed into ones that do not use message authentication.
References-found: 23

