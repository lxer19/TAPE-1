URL: ftp://ftp.cs.uu.nl/pub/RUU/CS/techreps/CS-1997/1997-24.ps.gz
Refering-URL: http://www.cs.ruu.nl/docs/research/publication/TechList1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: e-mail: hansb@cs.ruu.nl  e-mail: deFluiter@cqm.nl  
Title: Reduction Algorithms for Graphs of Small Treewidth  
Author: Hans L. Bodlaender Babette de Fluiter 
Address: P.O. Box 80.089, 3508 TB Utrecht, the Netherlands  P.O. Box 414, 5600 AK Eindhoven, the Netherlands  
Affiliation: Department of Computer Science, Utrecht University  Centre for Quantitative Methods  
Abstract: This paper presents a number of new ideas and results on graph reduction applied to graphs of bounded treewidth. Arnborg et al. [2] have shown that many decision problems on graphs can be solved in linear time on graphs of bounded treewidth, by using a finite set of reduction rules. These algorithms can be used to solve problems on graphs of bounded treewidth without the need to first obtain a tree decomposition of the input graph. We show that the reduction method can be extended to solve the construction variants of many decision problems on graphs of bounded treewidth, including all problems definable in monadic second order logic. We also show that a variant of the reduction algorithms presented in [2] can be used to solve (constructive) optimization problems in O(n) time. For example, optimization and construction variants of INDEPENDENT SET and HAMILTONIAN COMPLETION NUMBER can be solved in this way on graphs of small treewidth. Additionally we show that the results of [8] can be applied to our reduction algorithms, which results in parallel reduction algorithms that use O(n) operations and O(log n log fl n) time on an EREW PRAM, or O(log n) time on a CRCW PRAM.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Abrahamson and M. R. Fellows. </author> <title> Finite automata, bounded treewidth and well-quasiordering. </title> <editor> In N. Robertson and P. Seymour, editors, </editor> <booktitle> Proceedings of the AMS Summer Workshop on Graph Minors, Graph Structure Theory, Contemporary Mathematics vol. </booktitle> <volume> 147, </volume> <pages> pages 539564. </pages> <publisher> American Mathematical Society, </publisher> <year> 1993. </year>
Reference-contexts: Finite index corresponds to `finite state': there exists a linear time algorithm that decides finite index properties on graphs, given their tree decomposition of bounded treewidth. Moreover, this algorithm is of a special, well-described structure <ref> [10, 9, 1] </ref>. The disadvantage of this algorithm is that a tree decomposition of the input graph is needed.
Reference: [2] <author> S. Arnborg, B. Courcelle, A. Proskurowski, and D. Seese. </author> <title> An algebraic theory of graph reduction. </title> <journal> J. ACM, </journal> <volume> 40:11341164, </volume> <year> 1993. </year>
Reference-contexts: Additionally, a tree decomposition of minimum width can be constructed in linear time if the input graph has treewidth at most three. A much more general approach is taken in <ref> [2] </ref>: a set of conditions is given that must hold for a set of reduction rules to ensure that the reduction algorithm works correctly. <p> The finite state decision problems include all MS-definable decision problems. The results of <ref> [2] </ref> are stated in a general, algebraic setting. Bodlaender and Hagerup [8] have shown that the sequential reduction algorithms of [2] and [5] can efficiently be parallelized, if some additional conditions hold for the set of reduction rules. <p> The finite state decision problems include all MS-definable decision problems. The results of <ref> [2] </ref> are stated in a general, algebraic setting. Bodlaender and Hagerup [8] have shown that the sequential reduction algorithms of [2] and [5] can efficiently be parallelized, if some additional conditions hold for the set of reduction rules. <p> For simple graphs of bounded treewidth this gives efficient algorithms for a number of optimization problems. This paper is organized as follows. In Section 2 we discuss reduction algorithms for decision problems as introduced in <ref> [2] </ref>, and reprove some results, but in a less algebraic setting. We also give a reduction algorithm which uses linear time and space, based on the ideas of [2] and of [8]. In Section 3 we extend the theory of reduction algorithms for decision problems to constructive reduction algorithms. <p> This paper is organized as follows. In Section 2 we discuss reduction algorithms for decision problems as introduced in <ref> [2] </ref>, and reprove some results, but in a less algebraic setting. We also give a reduction algorithm which uses linear time and space, based on the ideas of [2] and of [8]. In Section 3 we extend the theory of reduction algorithms for decision problems to constructive reduction algorithms. In Sections 4 and 5 we extend the notion of reduction algorithms and constructive reduction algorithms to optimization problems. <p> For reasons of clarity we present the reduction algorithms in this paper for problems on connected graphs. In Section 7 we briefly discuss how to extend these results to graphs which are not necessarily connected. 2 Reduction Algorithms for Decision Problems In this section we discuss the results of <ref> [2] </ref>, and reprove some of these results, but in a more direct way, avoiding the algebraic setting from [2] this facilitates our later extensions of the results. We start with definitions or reduction rules and reduction systems (Section 2.1). <p> In Section 7 we briefly discuss how to extend these results to graphs which are not necessarily connected. 2 Reduction Algorithms for Decision Problems In this section we discuss the results of <ref> [2] </ref>, and reprove some of these results, but in a more direct way, avoiding the algebraic setting from [2] this facilitates our later extensions of the results. We start with definitions or reduction rules and reduction systems (Section 2.1). Then we give an efficient reduction algorithm based on a special type of reduction system (Section 2.2). <p> If the resulting graph is in I , then P holds for the input graph, and true is returned. Otherwise, false is returned. The algorithm is a simplified sequential simulation of the parallel algorithm given in [8]. It resembles the algorithm of <ref> [2] </ref>, but uses O (n) space, whereas the algorithm of [2] uses W (n p ) space, where p equals the maximum number of terminal vertices in any reduction rule. <p> Otherwise, false is returned. The algorithm is a simplified sequential simulation of the parallel algorithm given in [8]. It resembles the algorithm of <ref> [2] </ref>, but uses O (n) space, whereas the algorithm of [2] uses W (n p ) space, where p equals the maximum number of terminal vertices in any reduction rule. <p> The following theorem has originally been proved in <ref> [2] </ref> for a slightly different kind of special reduction system. In [8] the proof was adapted for the special reduction system as defined here. Using the techniques from [2, 8] we give a proof with some details in a different form. Theorem 2.2. <p> The following theorem has originally been proved in [2] for a slightly different kind of special reduction system. In [8] the proof was adapted for the special reduction system as defined here. Using the techniques from <ref> [2, 8] </ref> we give a proof with some details in a different form. Theorem 2.2. Let P a graph property and suppose P is of finite index. For each integer k 1, there exists a special reduction system (R ; I ) for P k . <p> This completes the proof that R is complete, and hence that (R ; I ) is a special reduction system. The effective construction of the reduction system can be done using the results from <ref> [2] </ref> and [16]. 2 From the proof of Theorem 2.2, we can also conclude the following. Corollary 2.1. Let P be a graph property, and for each l 0, let ~ l be a refinement of ~ P;l . Let k 1. <p> Let G be a finite class of l-terminal graphs containing at least one terminal graph of each equivalence class of ~ F;l . Such a set G can be effectively computed, similar as for finite index problems (use techniques similar as in <ref> [2, 16] </ref>.) Now if there is a G 2 G for which F (H G) 2 , then take any such G and let i = F (H G) F (H 0 G).
Reference: [3] <author> S. Arnborg, J. Lagergren, and D. Seese. </author> <title> Easy problems for tree-decomposable graphs. </title> <editor> J. </editor> <booktitle> Algorithms, </booktitle> <address> 12:308340, </address> <year> 1991. </year>
Reference-contexts: Then Q 1 and Q 2 are also of finite index. For each integer k 1, let TW k be the graph property defined as follows: for each graph G, TW k (G) holds if and only if tw (G) k. Lemma 2.5 <ref> [3, 16] </ref>. <p> In [10] is was shown that MS-definable graph properties are of finite index. There are many (even NP-complete) decision problems which are MS-definable (i.e. the corresponding graph properties are MS-definable). These include HAMILTONIAN CIRCUIT and (for fixed k) k-COLORABILITY (see e.g. <ref> [3] </ref> for a list). Theorem 2.2 now immediately implies the following result. Corollary 2.2. Let P be a graph property which is MS-definable. For each integer k 1, there is a linear time algorithm which decides P k on connected graphs without using a tree decomposition of the input graph. <p> The construction properties defined by (D; Q), where D is a vertex-edge-tuple and Q is an MS-definable extended graph property, correspond exactly to the MS-definable construction problems (see e.g. <ref> [3] </ref>). These MS-definable construction problems can be solved in O (n) time and space for graphs of bounded treewidth if a tree decomposition of bounded width the input graph is given. Theorem 3.3. <p> Let R 0 be the set of all reduction-counter rules that are found this way. 2 Unfortunately, we can not apply Theorem 4.2 to all MS-definable graph optimization problems (see e.g. <ref> [3] </ref> for a definition). Hence the analog of Corollary 2.2 does not hold for optimization problems. However, there are a number of problems for which we can prove that they are of finite integer index. We give them in the next theorem.
Reference: [4] <author> S. Arnborg and A. Proskurowski. </author> <title> Characterization and recognition of partial 3-trees. </title> <journal> SIAM J. Alg. Disc. Meth., </journal> <volume> 7:305314, </volume> <year> 1986. </year>
Reference-contexts: In [18] it was shown how a reduction algorithm based on this set of reduction rules can be implemented in linear time, and hence series-parallel graphs can be recognized in linear time. Arnborg and Proskurowski <ref> [4] </ref> extended these ideas, and obtained reduction rules that characterize the graphs of treewidth at most two or three, and, amongst others, showed that these reduction rules can be used to recognize graphs of treewidth at most three in O (n 3 ) time.
Reference: [5] <author> H. L. Bodlaender. </author> <title> On reduction algorithms for graphs with small treewidth. </title> <booktitle> In Proceedings 19th International Workshop on Graph-Theoretic Concepts in Computer Science WG'93, </booktitle> <pages> pages 4556, </pages> <year> 1994. </year>
Reference-contexts: Parts of this research have been published in preliminary form in <ref> [7, 5] </ref>. 1 The idea of reduction algorithms originates from Duffin's [12] characterization of series--parallel graphs: a multigraph is series-parallel if and only if it can be reduced to a single edge by applying a sequence of series and parallel reductions. <p> The finite state decision problems include all MS-definable decision problems. The results of [2] are stated in a general, algebraic setting. Bodlaender and Hagerup [8] have shown that the sequential reduction algorithms of [2] and <ref> [5] </ref> can efficiently be parallelized, if some additional conditions hold for the set of reduction rules.
Reference: [6] <author> H. L. Bodlaender. </author> <title> A linear time algorithm for finding tree-decompositions of small treewidth. </title> <journal> SIAM J. Comput., </journal> <volume> 25:13051317, </volume> <year> 1996. </year> <month> 40 </month>
Reference-contexts: The disadvantage of this algorithm is that a tree decomposition of the input graph is needed. Although for each fixed k, there is a linear time sequential algorithm which, given a graph G, checks if tw (G) k, and if so, computes a minimum width tree decomposition of G <ref> [6] </ref>, this algorithm is not very practical, due to the large constant factors involved. With reduction algorithms, one does not need to build a tree decomposition first. Lemma 2.6 [8]. Let k and n min be positive integers.
Reference: [7] <author> H. L. Bodlaender and B. de Fluiter. </author> <title> Reduction algorithms for constructing solutions in graphs with small treewidth. </title> <editor> In J.-Y. Cai and C. K. Wong, editors, </editor> <booktitle> Proceedings 2nd Annual International Conference on Computing and Combinatorics, COCOON'96, pages 199208. Springer Verlag, Lecture Notes in Computer Science, </booktitle> <volume> vol. 1090, </volume> <year> 1996. </year>
Reference-contexts: Parts of this research have been published in preliminary form in <ref> [7, 5] </ref>. 1 The idea of reduction algorithms originates from Duffin's [12] characterization of series--parallel graphs: a multigraph is series-parallel if and only if it can be reduced to a single edge by applying a sequence of series and parallel reductions.
Reference: [8] <author> H. L. Bodlaender and T. Hagerup. </author> <title> Parallel algorithms with optimal speedup for bounded treewidth. </title> <editor> In Z. F ul op and F. Gecseg, editors, </editor> <booktitle> Proceedings 22nd International Colloquium on Automata, Languages and Programming, </booktitle> <pages> pages 268279, </pages> <address> Berlin, </address> <year> 1995. </year> <note> Springer-Verlag, Lecture Notes in Computer Science 944. To appear in SIAM J. Computing, </note> <year> 1997. </year>
Reference-contexts: The finite state decision problems include all MS-definable decision problems. The results of [2] are stated in a general, algebraic setting. Bodlaender and Hagerup <ref> [8] </ref> have shown that the sequential reduction algorithms of [2] and [5] can efficiently be parallelized, if some additional conditions hold for the set of reduction rules. <p> In Section 2 we discuss reduction algorithms for decision problems as introduced in [2], and reprove some results, but in a less algebraic setting. We also give a reduction algorithm which uses linear time and space, based on the ideas of [2] and of <ref> [8] </ref>. In Section 3 we extend the theory of reduction algorithms for decision problems to constructive reduction algorithms. In Sections 4 and 5 we extend the notion of reduction algorithms and constructive reduction algorithms to optimization problems. In Section 6, we discuss the parallel reduction algorithms of [8], and in Section <p> [2] and of <ref> [8] </ref>. In Section 3 we extend the theory of reduction algorithms for decision problems to constructive reduction algorithms. In Sections 4 and 5 we extend the notion of reduction algorithms and constructive reduction algorithms to optimization problems. In Section 6, we discuss the parallel reduction algorithms of [8], and in Section 7, we mention some additional results. For reasons of clarity we present the reduction algorithms in this paper for problems on connected graphs. <p> We consider the method used in <ref> [8] </ref>, called the bounded adjacency list search method. (In [8] this method is used to obtain an efficient parallel algorithm; we give an efficient sequential version of this parallel algorithm in this section.) Def inition 2.6. Let d be a positive integer. <p> We consider the method used in <ref> [8] </ref>, called the bounded adjacency list search method. (In [8] this method is used to obtain an efficient parallel algorithm; we give an efficient sequential version of this parallel algorithm in this section.) Def inition 2.6. Let d be a positive integer. <p> If the resulting graph is in I , then P holds for the input graph, and true is returned. Otherwise, false is returned. The algorithm is a simplified sequential simulation of the parallel algorithm given in <ref> [8] </ref>. It resembles the algorithm of [2], but uses O (n) space, whereas the algorithm of [2] uses W (n p ) space, where p equals the maximum number of terminal vertices in any reduction rule. <p> With reduction algorithms, one does not need to build a tree decomposition first. Lemma 2.6 <ref> [8] </ref>. Let k and n min be positive integers. <p> The following theorem has originally been proved in [2] for a slightly different kind of special reduction system. In <ref> [8] </ref> the proof was adapted for the special reduction system as defined here. Using the techniques from [2, 8] we give a proof with some details in a different form. Theorem 2.2. Let P a graph property and suppose P is of finite index. <p> The following theorem has originally been proved in [2] for a slightly different kind of special reduction system. In [8] the proof was adapted for the special reduction system as defined here. Using the techniques from <ref> [2, 8] </ref> we give a proof with some details in a different form. Theorem 2.2. Let P a graph property and suppose P is of finite index. For each integer k 1, there exists a special reduction system (R ; I ) for P k . <p> Use the algorithm for MIN HAMILTONIAN PATH COMPLETION: if a graph is not Hamiltonian (which can be tested a reduction algorithm as HAMILTONIAN CIRCUIT is MS-definable), then its Hamiltonian circuit completion number is one larger than its Hamiltonian path completion number. 2 6 Parallel Reduction Algorithms In <ref> [8] </ref> an efficient parallel variant of algorithm Reduce was given, based on a variant of the special reduction system. In this section we show how to use this algorithm to make an efficient parallel variant of algorithm Reduce-Construct (Section 6.2). <p> We show that these algorithms can be used for large classes of problems on graphs of small treewidth. We start with a description of the parallel reduction algorithm as introduced in <ref> [8] </ref>. 6.1 Decision Problems The basic idea of the parallel reduction algorithm is that, if there are two or more possible applications of reduction rules at a certain time, and these applications do not interfere, then they can be applied concurrently. Def inition 6.1 (Non-Interfering Matches). <p> Let P be a graph property and S = (R ; I ) a special parallel reduction system for P. Let n min , n max , d and c be as in Definition 6.2. The parallel reduction algorithm introduced in <ref> [8] </ref> based on S works as follows. The algorithm finds d-discoverable matches and executes the corresponding reductions, until there are no more d-discoverable matches. In more detail, the following is done. Suppose we are given an input graph G with n vertices. <p> It can be seen that the conflict graph has bounded degree. This means that there is an independent set A 0 of size W (jAj) which can be found efficiently in parallel on an EREW PRAM (for more details, see <ref> [8] </ref>). Note that in step 2, the size of A is at least cm as long as P holds for the input graph. <p> For a CRCW PRAM, the algorithm can be slightly improved: it runs in O (log n) time with O (n) operations and space (see <ref> [8] </ref> for details). Theorem 6.1. Let P be a graph property. <p> However, the best known parallel algorithm for finding a tree decomposition of the input graph takes O (log 2 n) time with O (n) operations on an EREW or CRCW PRAM <ref> [8] </ref>. Hence the reduction algorithms presented in this section are more efficient. 34 6.2 Construction Problems We start with adapting the definition of a special constructive reduction system. Def inition 6.3.
Reference: [9] <author> R. B. Borie, R. G. Parker, and C. A. Tovey. </author> <title> Automatic generation of linear-time algorithms from predicate calculus descriptions of problems on recursively constructed graph families. </title> <journal> Algorithmica, </journal> <volume> 7:555581, </volume> <year> 1992. </year>
Reference-contexts: An equivalence relation ~ 0 is a refinement of an equivalence relation ~ if each equivalence class of ~ 0 is a subset of an equivalence class of ~. Clearly, if ~ 0 is finite, then so is ~. The following result is well-known. Lemma 2.4 <ref> [9, 13] </ref>. Let P 1 and P 2 be graph properties of finite index. <p> Finite index corresponds to `finite state': there exists a linear time algorithm that decides finite index properties on graphs, given their tree decomposition of bounded treewidth. Moreover, this algorithm is of a special, well-described structure <ref> [10, 9, 1] </ref>. The disadvantage of this algorithm is that a tree decomposition of the input graph is needed. <p> For each k 1 there is a special constructive reduction system for P k , which can be effectively constructed if a definition of Q in MSOL is known. Proof. In <ref> [9] </ref> is was shown that for each k 1, there is a homomorphism h, mapping each pair (G; S), where either G is an ordinary graph and S 2 D (G) or G is an l-terminal graph, l k, and S 2 D [] (G), to an element of a finite
Reference: [10] <author> B. Courcelle. </author> <title> The monadic second-order logic of graphs I: Recognizable sets of finite graphs. Information and Computation, </title> <address> 85:1275, </address> <year> 1990. </year>
Reference-contexts: Finite index corresponds to `finite state': there exists a linear time algorithm that decides finite index properties on graphs, given their tree decomposition of bounded treewidth. Moreover, this algorithm is of a special, well-described structure <ref> [10, 9, 1] </ref>. The disadvantage of this algorithm is that a tree decomposition of the input graph is needed. <p> Moreover, if ~ l and P are effectively decidable, then such a system can effectively be constructed. Courcelle <ref> [10] </ref> has given a large class of graph properties which are of finite index, namely the class of properties that are definable in Monadic Second Order Logic or MSOL for graphs. <p> Graph properties that can be defined by an MSOL predicate are called MS-definable graph properties. In <ref> [10] </ref> is was shown that MS-definable graph properties are of finite index. There are many (even NP-complete) decision problems which are MS-definable (i.e. the corresponding graph properties are MS-definable). These include HAMILTONIAN CIRCUIT and (for fixed k) k-COLORABILITY (see e.g. [3] for a list).
Reference: [11] <author> B. de Fluiter. </author> <title> Algorithms for Graphs of Small Treewidth. </title> <type> PhD thesis, </type> <institution> Utrecht University, </institution> <year> 1997. </year>
Reference-contexts: Correctness of the algorithm follows from these invariants, whose proof we leave to the reader (see <ref> [11] </ref> for full details). 2 Consider the time and space complexity of the algorithm. Lemma 2.3. Algorithm Reduce uses O (n) time and space. Proof. We first show that the main loop of the algorithm is iterated O (n) times. <p> We state a number of these problems in the next theorem. We prove it only for one problem; the other proofs are similar, and can be found in <ref> [11] </ref>. Theorem 4.4. The following problems are not of finite integer index. MAX CUT: given a graph G, find a partition (V 1 ;V 2 ) of V (G) such that the number of edges with one end point in V 1 and one in V 2 is maximum. <p> In the following theorem we show for a number of constructive optimization problems that they are efficiently solvable, using the methods of Theorem 5.2.. The proofs are all of the same type; we only give the first one completely, the others can be found in <ref> [11] </ref>. Theorem 5.3. Each of the following constructive optimization problems can be solved in O (n) time and space on graphs of bounded treewidth without making a tree decomposition of the input graph. <p> This can be done in a smart way, such that it takes O (n) time, and after phase two, a graph in I remains if and only if the input graph satisfies the property. A detailed description can be found in <ref> [11] </ref>. The definitions of special constructive reduction systems and special (constructive) reduction-counter systems can be modified in the same way as the definition of special reduction systems. <p> Theorems 2.2, 3.2, 4.2 and 5.2 can also be shown to hold for the new type of special reduction system. For the parallel variant a similar modification can be done to the special parallel reduction system (see <ref> [11] </ref> for more details). It is also possible to generalize the results in this paper to directed, mixed and/or labeled graphs.
Reference: [12] <author> R. J. Duffin. </author> <title> Topology of series-parallel graphs. </title> <journal> J. Math. Anal. Appl., </journal> <volume> 10:303318, </volume> <year> 1965. </year>
Reference-contexts: Parts of this research have been published in preliminary form in [7, 5]. 1 The idea of reduction algorithms originates from Duffin's <ref> [12] </ref> characterization of series--parallel graphs: a multigraph is series-parallel if and only if it can be reduced to a single edge by applying a sequence of series and parallel reductions.
Reference: [13] <author> M. R. Fellows and M. A. Langston. </author> <title> An analogue of the Myhill-Nerode theorem and its use in computing finite-basis characterizations. </title> <booktitle> In Proceedings of the 30th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 520525, </pages> <year> 1989. </year>
Reference-contexts: An equivalence relation ~ 0 is a refinement of an equivalence relation ~ if each equivalence class of ~ 0 is a subset of an equivalence class of ~. Clearly, if ~ 0 is finite, then so is ~. The following result is well-known. Lemma 2.4 <ref> [9, 13] </ref>. Let P 1 and P 2 be graph properties of finite index.
Reference: [14] <author> J. JaJa. </author> <title> An Introduction to Parallel Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: However, we can transform this representation into the representation as described in the proof of Theorem 3.2: for each i, 1 i t, use a parallel prefix algorithm (see e.g. <ref> [14] </ref>) to make a list of all vertices or edges for which b i is true. Since t is fixed, this takes O (log n) time with O (n) operations on an EREW PRAM, and hence does not increase the total running time.
Reference: [15] <author> J. Lagergren. </author> <title> Efficient parallel algorithms for graphs of bounded tree-width. </title> <editor> J. </editor> <booktitle> Algorithms, </booktitle> <address> 20:2044, </address> <year> 1996. </year>
Reference-contexts: The analog of Corollary 2.2 also holds for the parallel case. In the parallel case, there exist algorithms that decide finite index properties in O (log n) time with O (n) operations and space, given a tree decomposition of bounded width of the graph <ref> [15] </ref>. However, the best known parallel algorithm for finding a tree decomposition of the input graph takes O (log 2 n) time with O (n) operations on an EREW or CRCW PRAM [8].
Reference: [16] <author> J. Lagergren and S. Arnborg. </author> <title> Finding minimal forbidden minors using a finite congruence. </title> <booktitle> In Proceedings of the 18th International Colloquium on Automata, Languages and Programming, </booktitle> <pages> pages 532543. </pages> <address> Springer Verlag, </address> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 510, </volume> <year> 1991. </year>
Reference-contexts: Then Q 1 and Q 2 are also of finite index. For each integer k 1, let TW k be the graph property defined as follows: for each graph G, TW k (G) holds if and only if tw (G) k. Lemma 2.5 <ref> [3, 16] </ref>. <p> This completes the proof that R is complete, and hence that (R ; I ) is a special reduction system. The effective construction of the reduction system can be done using the results from [2] and <ref> [16] </ref>. 2 From the proof of Theorem 2.2, we can also conclude the following. Corollary 2.1. Let P be a graph property, and for each l 0, let ~ l be a refinement of ~ P;l . Let k 1. <p> Let G be a finite class of l-terminal graphs containing at least one terminal graph of each equivalence class of ~ F;l . Such a set G can be effectively computed, similar as for finite index problems (use techniques similar as in <ref> [2, 16] </ref>.) Now if there is a G 2 G for which F (H G) 2 , then take any such G and let i = F (H G) F (H 0 G).
Reference: [17] <author> J. Matouffsek and R. Thomas. </author> <title> Algorithms finding tree-decompositions of graphs. </title> <editor> J. </editor> <booktitle> Algorithms, </booktitle> <address> 12:122, </address> <year> 1991. </year>
Reference-contexts: Arnborg and Proskurowski [4] extended these ideas, and obtained reduction rules that characterize the graphs of treewidth at most two or three, and, amongst others, showed that these reduction rules can be used to recognize graphs of treewidth at most three in O (n 3 ) time. In <ref> [17] </ref> it is shown that with a slightly different set of reduction rules graphs of treewidth at most three can be recognized in linear time. Additionally, a tree decomposition of minimum width can be constructed in linear time if the input graph has treewidth at most three.
Reference: [18] <author> J. Valdes, R. E. Tarjan, and E. L. Lawler. </author> <title> The recognition of series parallel digraphs. </title> <journal> SIAM J. Comput., </journal> <volume> 11:298313, </volume> <year> 1982. </year> <month> 41 </month>
Reference-contexts: In <ref> [18] </ref> it was shown how a reduction algorithm based on this set of reduction rules can be implemented in linear time, and hence series-parallel graphs can be recognized in linear time.
References-found: 18

