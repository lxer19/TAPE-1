URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr93/tr93-037.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr93-abstracts.html
Root-URL: http://www.cis.ufl.edu
Email: shasha@cs.nyu.edu  
Title: 2Q: A Low Overhead High Performance Buffer Management Replacement Algorithm processor overhead to implement it.
Author: Theodore Johnson Dennis Shasha 
Note: The one problem of LRU/2 is the  Supported by U.S. Office of Naval Research #N00014-91-J-1472 and #N00014-92-J-1719, U.S. National Science Foundation grants #CCR-9103953 and IRI-9224601, and USRA #5555-19. Part of this work was performed while Theodore Johnson was a 1993 ASEE Summer Faculty Fellow at the National Space Science Data Center of NASA Goddard Space Flight Center. Authors' e-mail addresses ted@cis.ufl.edu and  
Address: Gainesville, FL 32611 New York, NY 10012  Summit, NJ 07901  
Affiliation: University of Florida Courant Institute, New York University  Novell, Inc.  
Abstract: In a path-breaking paper last year Pat and Betty O'Neil and Gerhard Weikum proposed a self-tuning improvement to the Least Recently Used (LRU) buffer management algorithm[15]. Their improvement is called LRU/k and advocates giving priority to buffer pages based on the kth most recent access. (The standard LRU algorithm is denoted LRU/1 according to this terminology.) If P1's kth most recent access is more more recent than P2's, then P1 will be replaced after P2. Intuitively, LRU/k for k &gt; 1 is a good strategy, because it gives low priority to pages that have been scanned or to pages that belong to a big randomly accessed file (e.g., the account file in TPC/A). They found that LRU/2 achieves most of the advantage of their method. Our "Two Queue" algorithm (hereafter 2Q) has constant time overhead, performs as well as LRU/2, and requires no tuning. These results hold for real (DB2 commercial, Swiss bank) traces as well as simulated ones. Based on these experiments, we estimate that 2Q will provide a few percent improvement over LRU without increasing the overhead by more than a constant additive factor. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alonso, D. Barbara, and H. Garcia-Molina. </author> <title> Data caching issues in an information retrieval system. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(3) </volume> <pages> 359-384, </pages> <year> 1990. </year>
Reference-contexts: Algorithms include the Hot Set model [18], the DBMIN algorithm [5] and related extensions [9, 13, 23], and hint passing algorithms <ref> [4, 12, 1, 10, 3] </ref>. In [15], O'Neil, O'Neil and Weikum point out that it is difficult to design a query plan-based buffering algorithm that works well in a multitasking system. Sequences of transactions, concurrent transactions, and partions of the current transaction plan can overlap in complicated ways.
Reference: [2] <author> D.I. Aven, E.G. Coffman, and Y.A. Kogan. </author> <title> Stochastic Analysis of Computer Storage. </title> <address> D. </address> <publisher> Rei-del Publishing, </publisher> <year> 1987. </year>
Reference-contexts: A setting of ff = 0:86 gives an 80/20 distribution, while a setting of ff = :5 give a less skewed distribution (about 45/20). These obey the independent reference model <ref> [2] </ref>, i.e., each page has a single stationary probability to be accessed at any point in time. We set Kin to 1 (since there are no correlated references) and Kout to 50% of the number of page slots in the buffer.
Reference: [3] <author> C.Y. Chan, B.C. Ooi, and H. Lu. </author> <title> Extensible buffer management of indexes. </title> <booktitle> In Proc. 18th Int'l Conf. on Very Large Data Bases, </booktitle> <pages> pages 444-454, </pages> <year> 1992. </year>
Reference-contexts: Algorithms include the Hot Set model [18], the DBMIN algorithm [5] and related extensions [9, 13, 23], and hint passing algorithms <ref> [4, 12, 1, 10, 3] </ref>. In [15], O'Neil, O'Neil and Weikum point out that it is difficult to design a query plan-based buffering algorithm that works well in a multitasking system. Sequences of transactions, concurrent transactions, and partions of the current transaction plan can overlap in complicated ways.
Reference: [4] <author> E.E. Chang and R.H. Katz. </author> <title> Exploiting inheritance and structure semantics for effective clustering and buffering in an object-oriented dbms. </title> <booktitle> In Proc. 1989 ACM SIGMOD Conf., </booktitle> <pages> pages 348-357, </pages> <year> 1989. </year>
Reference-contexts: Algorithms include the Hot Set model [18], the DBMIN algorithm [5] and related extensions [9, 13, 23], and hint passing algorithms <ref> [4, 12, 1, 10, 3] </ref>. In [15], O'Neil, O'Neil and Weikum point out that it is difficult to design a query plan-based buffering algorithm that works well in a multitasking system. Sequences of transactions, concurrent transactions, and partions of the current transaction plan can overlap in complicated ways.
Reference: [5] <author> H.T. Chou and D. DeWitt. </author> <title> An evaluation of buffer management strategies for relational database systems. </title> <booktitle> In Proc. 11th ACM SIGMOD Conf., </booktitle> <pages> pages 127-141, </pages> <year> 1985. </year>
Reference-contexts: Furthermore, database systems usually have access patterns in which LRU performs poorly, as noted by Stone-braker [21], Sacco and Schkolnick [18], and Chou and Dewitt <ref> [5] </ref>. As a result, there has been considerable interest in buffer management algorithms that perform well in a database system. <p> A related approach is to let the query optimizer tell the buffer manager the plan of the query to be processed, so that the buffer manager can allocate and manage its buffers accordingly. Algorithms include the Hot Set model [18], the DBMIN algorithm <ref> [5] </ref> and related extensions [9, 13, 23], and hint passing algorithms [4, 12, 1, 10, 3]. In [15], O'Neil, O'Neil and Weikum point out that it is difficult to design a query plan-based buffering algorithm that works well in a multitasking system.
Reference: [6] <author> E.G. Coffman and P.J. Denning. </author> <title> Operating System Theory. </title> <publisher> Prentice-Hall, </publisher> <year> 1973. </year>
Reference-contexts: As a reference point, we included the hit rate of the A0 algorithm (A0 always replaces the page whose probability of access is lowest) which is known to be optimal for stable probability distributions <ref> [6] </ref>. These charts show that 2Q provides a substantial improvement over LRU, and has performance comparable to that of LRU/2. The performance improvement is highest when the number of page slots is small. <p> .222 .183 .181 .238 40% .544 .529 .519 .535 5% .584 .528 .524 .595 20% .745 .718 .713 .744 Table 4: Independent Zipf hit rate comparison of LRU, LRU/2, and 2Q. 0.5 0.8 Page 9 4.1 Theoretical Setting for 2Q Param- eters On a static reference stream, the A0 algorithm <ref> [6] </ref> is optimal. That algorithm effectively locks the B-1 data items with the highest access probability into memory, and use the last page slot to service page faults. LRU works well because it tends to keep hot items near the front of the queue, removing the cold ones.
Reference: [7] <author> A. Dan and D. Towsley. </author> <title> An approximate analysis of lru and fifo buffer replacement schemes. </title> <booktitle> In Proc. 1990 ACM SIGMETRICS Conf., </booktitle> <pages> pages 143-149, </pages> <year> 1990. </year>
Reference-contexts: Reiter proposed the Domain Separation algorithm [16], which separates the database pages into different pools. Each pool has an allocation of buffers and a special purpose buffer management strategy. The allocation of buffers to pools requires careful tuning for high performance <ref> [7, 22] </ref> and is a well known headache for system administrators of database management systems such as DB2.
Reference: [8] <author> W. Effelsberg and T. Haerder. </author> <title> Principles of database buffer management. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(9) </volume> <pages> 560-595, </pages> <year> 1984. </year>
Reference-contexts: In every case, they show a significant improvement over LRU, sometimes as high as 40%. While LRU/2 is self-tuning in comparison to other buffer management algorithms, such as Gclock <ref> [20, 8, 14] </ref>, two delicate tuning parameters remain. The first is the Correlated Reference Period. This is a time period during which a page is retained in the buffer once it has been accessed.
Reference: [9] <author> C. Faloustos, R. Ng, and T. Sellis. </author> <title> Predictive load control for flexible buffer allocation. </title> <booktitle> In Proc. 17th Conf. on Very Large Data Bases, </booktitle> <pages> pages 265-274, </pages> <year> 1991. </year>
Reference-contexts: A related approach is to let the query optimizer tell the buffer manager the plan of the query to be processed, so that the buffer manager can allocate and manage its buffers accordingly. Algorithms include the Hot Set model [18], the DBMIN algorithm [5] and related extensions <ref> [9, 13, 23] </ref>, and hint passing algorithms [4, 12, 1, 10, 3]. In [15], O'Neil, O'Neil and Weikum point out that it is difficult to design a query plan-based buffering algorithm that works well in a multitasking system.
Reference: [10] <author> R. Juahari, M. Carey, and M. Linvy. </author> <title> Priority hints: An algorithm fir priority-based buffer management. </title> <booktitle> In Proc. 16th Int'l Conf. on Very Large Data Bases, </booktitle> <year> 1990. </year>
Reference-contexts: Algorithms include the Hot Set model [18], the DBMIN algorithm [5] and related extensions [9, 13, 23], and hint passing algorithms <ref> [4, 12, 1, 10, 3] </ref>. In [15], O'Neil, O'Neil and Weikum point out that it is difficult to design a query plan-based buffering algorithm that works well in a multitasking system. Sequences of transactions, concurrent transactions, and partions of the current transaction plan can overlap in complicated ways.
Reference: [11] <author> D. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> volume 3. </volume> <publisher> Addison Wesley, </publisher> <year> 1973. </year>
Reference-contexts: They give some intuition about the behavior of LRU, LRU/2, and 2Q, but do not necessarily represent a real application's behavior. Zipf Distributions Figures 1 and 2 compare the performance of LRU, LRU/2, and 2Q on a Zipfian input distribution <ref> [11] </ref> with parameter ff = 0:5 and ff = 0:86 respectively. That is, if there are N pages, the probability of accessing a page numbered i or less is (i=N ) ff .
Reference: [12] <author> L.A. Haas et al. </author> <title> Starburst midflight: As the dust clears. </title> <journal> IEEE Trans. on Knowledge and Database Systems, </journal> <volume> 2(1) </volume> <pages> 143-160, </pages> <year> 1990. </year>
Reference-contexts: Algorithms include the Hot Set model [18], the DBMIN algorithm [5] and related extensions [9, 13, 23], and hint passing algorithms <ref> [4, 12, 1, 10, 3] </ref>. In [15], O'Neil, O'Neil and Weikum point out that it is difficult to design a query plan-based buffering algorithm that works well in a multitasking system. Sequences of transactions, concurrent transactions, and partions of the current transaction plan can overlap in complicated ways.
Reference: [13] <author> R. Ng, C. Faloustos, and T. Sellis. </author> <title> Flexible buffer management based on marginal gains. </title> <booktitle> In 1991 ACM SIGMOD Conf., </booktitle> <pages> pages 387-396, </pages> <year> 1991. </year> <pages> Page 11 </pages>
Reference-contexts: A related approach is to let the query optimizer tell the buffer manager the plan of the query to be processed, so that the buffer manager can allocate and manage its buffers accordingly. Algorithms include the Hot Set model [18], the DBMIN algorithm [5] and related extensions <ref> [9, 13, 23] </ref>, and hint passing algorithms [4, 12, 1, 10, 3]. In [15], O'Neil, O'Neil and Weikum point out that it is difficult to design a query plan-based buffering algorithm that works well in a multitasking system.
Reference: [14] <author> V.F. Nicola, A. Dan, </author> <title> and D.M. Dias. Analysi of the generalized clock buffer replacement scheme for database transaction processing. </title> <booktitle> In Proc. 1992 ACM SIGMETRICS Conf., </booktitle> <pages> pages 35-46, </pages> <year> 1992. </year>
Reference-contexts: In every case, they show a significant improvement over LRU, sometimes as high as 40%. While LRU/2 is self-tuning in comparison to other buffer management algorithms, such as Gclock <ref> [20, 8, 14] </ref>, two delicate tuning parameters remain. The first is the Correlated Reference Period. This is a time period during which a page is retained in the buffer once it has been accessed. <p> References to a page in the A1in queue are not counted. We adjusted the size of the A1in queue to obtain the best performance for the LRU/2 algorithm. We implemented the Gclock algorithm as described in <ref> [14] </ref>: every page has a history count attached. When a page is referenced, we set the history count of its buffer to init count. If a free page is required, we scan through the pages (starting from the previous stopping point) and examine the history counts.
Reference: [15] <author> E.J. O'Neil, P.E. O'Neil, and G. Weikum. </author> <title> The lru-k page replacement algorithm for database disk buffering. </title> <booktitle> In Proceedings of the 1993 ACM Sigmod International Conference on Management of Data, </booktitle> <pages> pages 297-306, </pages> <year> 1993. </year>
Reference-contexts: Algorithms include the Hot Set model [18], the DBMIN algorithm [5] and related extensions [9, 13, 23], and hint passing algorithms [4, 12, 1, 10, 3]. In <ref> [15] </ref>, O'Neil, O'Neil and Weikum point out that it is difficult to design a query plan-based buffering algorithm that works well in a multitasking system. Sequences of transactions, concurrent transactions, and partions of the current transaction plan can overlap in complicated ways. <p> The results in Table 2 show again that both LRU/2 and 2Q provide a significantly higher hit rate than LRU and Gclock. Trace Data from an On-line Transaction Processing System Gerhard Weikum supplied us with the trace he used to validate the performance of the LRU/2 algorithm <ref> [15] </ref>, a one hour page reference trace to a CODASYL database. The trace consists of of 914145 references to 186880 distinct pages. The results in Table 3 further validate our results. We note that our results on this trace are different than those reported in [15] because the LRU/k authors removed <p> performance of the LRU/2 algorithm <ref> [15] </ref>, a one hour page reference trace to a CODASYL database. The trace consists of of 914145 references to 186880 distinct pages. The results in Table 3 further validate our results. We note that our results on this trace are different than those reported in [15] because the LRU/k authors removed some references in their preprocessing. However, our conclusions about relative performance are the same.
Reference: [16] <author> R. Reiter. </author> <title> A study of buffer management policies for data management systems. </title> <type> Technical Report 1619, </type> <institution> University of Wisconson (Madison) Mathematics Research Center, </institution> <year> 1976. </year>
Reference-contexts: Page 1 has tuned the buffer management algorithm to the expected reference pattern. Reiter proposed the Domain Separation algorithm <ref> [16] </ref>, which separates the database pages into different pools. Each pool has an allocation of buffers and a special purpose buffer management strategy.
Reference: [17] <author> J.T. Robinson and M.V. Devarakonda. </author> <title> Data cache management using frequency-based replacement. </title> <booktitle> In ACM SIGMETRICS Conference, </booktitle> <pages> pages 134-143, </pages> <year> 1990. </year>
Reference-contexts: The authors recommend 200 seconds though higher values don't hurt. A related paper is the frequency-based replacement algorithm of Robinson and Devarakonda <ref> [17] </ref>. These authors found that by not counting correlated references, they could produce a buffering algorithm based on reference frequency counting that has better performance than LRU.
Reference: [18] <author> G.M. Sacco and M. Schkolnick. </author> <title> Buffer management in relational database systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 11(4) </volume> <pages> 473-498, </pages> <year> 1986. </year>
Reference-contexts: Furthermore, database systems usually have access patterns in which LRU performs poorly, as noted by Stone-braker [21], Sacco and Schkolnick <ref> [18] </ref>, and Chou and Dewitt [5]. As a result, there has been considerable interest in buffer management algorithms that perform well in a database system. <p> A related approach is to let the query optimizer tell the buffer manager the plan of the query to be processed, so that the buffer manager can allocate and manage its buffers accordingly. Algorithms include the Hot Set model <ref> [18] </ref>, the DBMIN algorithm [5] and related extensions [9, 13, 23], and hint passing algorithms [4, 12, 1, 10, 3]. In [15], O'Neil, O'Neil and Weikum point out that it is difficult to design a query plan-based buffering algorithm that works well in a multitasking system.
Reference: [19] <author> D.D. Sleator and R.T. Tarjan. </author> <title> Amortized efficiency of list update and paging rules. </title> <journal> Communications of the ACM, </journal> <volume> 28(2) </volume> <pages> 202-208, </pages> <year> 1985. </year>
Reference-contexts: Indeed, the theoretical community blessed it by showing that LRU never replaces more than a factor B as many elements as an optimal clairvoyant algorithm (where B is the size of the buffer) <ref> [19] </ref>. 1 Factors this large can heavily influence the behavior of a database system, however. Furthermore, database systems usually have access patterns in which LRU performs poorly, as noted by Stone-braker [21], Sacco and Schkolnick [18], and Chou and Dewitt [5].
Reference: [20] <author> A.J. Smith. </author> <title> Sequentiality and prefetching in database systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 3(3) </volume> <pages> 223-247, </pages> <year> 1978. </year>
Reference-contexts: In every case, they show a significant improvement over LRU, sometimes as high as 40%. While LRU/2 is self-tuning in comparison to other buffer management algorithms, such as Gclock <ref> [20, 8, 14] </ref>, two delicate tuning parameters remain. The first is the Correlated Reference Period. This is a time period during which a page is retained in the buffer once it has been accessed.
Reference: [21] <author> M. Stonebraker. </author> <title> Operating system support for database management. </title> <journal> Communications of the ACM, </journal> <volume> 24(7) </volume> <pages> 412-428, </pages> <year> 1981. </year>
Reference-contexts: Furthermore, database systems usually have access patterns in which LRU performs poorly, as noted by Stone-braker <ref> [21] </ref>, Sacco and Schkolnick [18], and Chou and Dewitt [5]. As a result, there has been considerable interest in buffer management algorithms that perform well in a database system.
Reference: [22] <author> J.Z. Teng and R.A. Gumaer. </author> <title> Managing IBM Database 2 buffers to maximize performance. </title> <journal> IBM Systems Journal, </journal> <volume> 23(2) </volume> <pages> 211-218, </pages> <year> 1984. </year>
Reference-contexts: Reiter proposed the Domain Separation algorithm [16], which separates the database pages into different pools. Each pool has an allocation of buffers and a special purpose buffer management strategy. The allocation of buffers to pools requires careful tuning for high performance <ref> [7, 22] </ref> and is a well known headache for system administrators of database management systems such as DB2.
Reference: [23] <author> P.S. Yu and D.W. Cornell. </author> <title> Optimal buffer allocation in a multi-query environment. </title> <booktitle> In Proc. 7th Int'l Conf. on Data Engineering, </booktitle> <pages> pages 622-631, </pages> <year> 1991. </year> <pages> Page 12 </pages>
Reference-contexts: A related approach is to let the query optimizer tell the buffer manager the plan of the query to be processed, so that the buffer manager can allocate and manage its buffers accordingly. Algorithms include the Hot Set model [18], the DBMIN algorithm [5] and related extensions <ref> [9, 13, 23] </ref>, and hint passing algorithms [4, 12, 1, 10, 3]. In [15], O'Neil, O'Neil and Weikum point out that it is difficult to design a query plan-based buffering algorithm that works well in a multitasking system.
References-found: 23

