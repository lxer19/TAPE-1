URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/nch/ftp/generic-clp.ps.Z
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/nch/www/sba.html
Root-URL: http://www.cs.cmu.edu
Title: A Generic Algorithm for CLP Analysis (Extended Abstract)  
Author: Nevin Heintze and Joxan Jaffar 
Keyword: (constraint) logic programming, program analysis, abstract interpretation  
Address: Pittsburgh, PA 15213;  PO Box 704, Yorktown Heights, NY 10598;  
Affiliation: School of Computer Science, Carnegie Mellon University,  IBM T.J. Watson Research Center,  
Note: This length of the body of this manuscript is 5034 words (according to delatex and wc).  
Email: nch@cs.cmu.edu  joxan@watson.ibm.com  
Date: June 13, 1995  
Abstract: Logic program analyzers typically employ abstract interpretation and consist of two main components: an abstract domain and a generic iterative fixed-point computation or "engine". In earlier work, we presented a new engine based on an unfolding operation, and showed that it was uniformly more accurate than the standard engine. This unfolding engine however had a crucial limitation: it could not be generalized to constraint logic programming (CLP). In this paper, we develop a fundamentally different view of unfolding, based on a uniform treatment of constraints. The result is a family of analysis algorithms which is modular in the sense that CLP is modular over computation domains. Not only is the new engine more general, but it is also simpler and more flexible. In particular, it provides new opportunities for tuning efficiency/accuracy tradeoffs. At one end of the spectrum, the engine can be used to describe the standard engine; at the other end is an algorithm that is more accurate than the old unfolding engine for traditional logic programs. The main technical result however is that the new engine is uniformly more accurate than a comparable abstract interpretation algorithm for CLP, whatever the constraint and abstract domains used. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Cousot and R. Cousot, </author> <title> "Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints", </title> <booktitle> Proc. 4 th ACM-POPL, </booktitle> <year> 1977, </year> <pages> pp 238-252. </pages>
Reference-contexts: A fundamental difference between the unfolding and standard engines is that the standard engine iterates over a fixed collection of semantic equations, whereas the unfolding engine iterates over dynamically changing equations. Roughly speaking, the unfolding engine combines set constraint techniques [4, 5, 3] with abstract interpretation techniques <ref> [1] </ref>. The former provides a superior ability to reason about term structures, but ignores all dependencies between variables; the latter provides an ability to reason about dependencies. Unfortunately, the unfolding engine relies directly on a specialized representation using substitutions, which cannot be lifted to constraint logic programming (CLP).
Reference: [2] <author> M. Garcia de la Banda and M. Hermenegildo, </author> <title> "A Practical Approach to the Global Analysis of CLP Programs", </title> <booktitle> Proc. Int. Symp. on Logic Programming, </booktitle> <year> 1993, </year> <pages> pp 437-455. </pages>
Reference: [3] <author> N. Heintze, </author> <title> "Set Based Program Analysis", </title> <type> Ph.D. thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> October </month> <year> 1992. </year> <month> 15 </month>
Reference-contexts: A fundamental difference between the unfolding and standard engines is that the standard engine iterates over a fixed collection of semantic equations, whereas the unfolding engine iterates over dynamically changing equations. Roughly speaking, the unfolding engine combines set constraint techniques <ref> [4, 5, 3] </ref> with abstract interpretation techniques [1]. The former provides a superior ability to reason about term structures, but ignores all dependencies between variables; the latter provides an ability to reason about dependencies.
Reference: [4] <author> N. Heintze and J. Jaffar, </author> <title> "A Finite Presentation Theorem for Approximating Logic Programs", </title> <booktitle> Proc. 17 th ACM-POPL, </booktitle> <year> 1990, </year> <pages> pp 197-209. </pages>
Reference-contexts: A fundamental difference between the unfolding and standard engines is that the standard engine iterates over a fixed collection of semantic equations, whereas the unfolding engine iterates over dynamically changing equations. Roughly speaking, the unfolding engine combines set constraint techniques <ref> [4, 5, 3] </ref> with abstract interpretation techniques [1]. The former provides a superior ability to reason about term structures, but ignores all dependencies between variables; the latter provides an ability to reason about dependencies.
Reference: [5] <author> N. Heintze and J. Jaffar, </author> <title> "A Decision Procedure for a Class of Herbrand Set Constraints", </title> <booktitle> Proceedings 5 th IEEE-LICS, </booktitle> <year> 1990, </year> <pages> pp 42-51. </pages>
Reference-contexts: A fundamental difference between the unfolding and standard engines is that the standard engine iterates over a fixed collection of semantic equations, whereas the unfolding engine iterates over dynamically changing equations. Roughly speaking, the unfolding engine combines set constraint techniques <ref> [4, 5, 3] </ref> with abstract interpretation techniques [1]. The former provides a superior ability to reason about term structures, but ignores all dependencies between variables; the latter provides an ability to reason about dependencies.
Reference: [6] <author> N. Heintze and J. Jaffar, </author> <title> "An Engine for Logic Program Analysis", </title> <booktitle> Proc. 7 th IEEE-LICS, </booktitle> <pages> pp 318-328, </pages> <year> 1992. </year>
Reference-contexts: Some specific descriptions of engines are [9], for logic programs, and more recently, [10], for constraint logic programs. In earlier work <ref> [6] </ref>, a new engine, called the unfolding engine, was presented for the analysis of logic programs. Its main advantage was improved accuracy over the standard engine, regardless of the abstract domain used. <p> Typically, we will choose simplify to be a suitable constraint solver for the constraint domain at hand. For the domain of finite trees, it would be appropriate to use a unification algorithm (in effect this is what is used in <ref> [6] </ref>). For the domain of infinite trees, one would use an infinite tree unification algorithm. For linear equalities, a version of Gaussian Elimination could be appropriate. For more complex constraint domains, such as that of CLP (R), the choices are less obvious. <p> For equations over term structures, r can just count the symbols appearing in the constraints (c.f. <ref> [6] </ref>). However, for constraints such as those in CLP (R), there can be infinite collections of constraints of the form fX = 1; X = 2; X = 3; : : :g and so here r must also take into account the size of constants appearing in constraints. <p> To highlight its advantages, we now make two comparison. The first is to an earlier unfolding engine for traditional logic programs <ref> [6] </ref>. The new engine represents a substantial advance because: * The old engine was designed around a specific representation of substitutions that cannot be generalized to CLP.
Reference: [7] <author> J. Jaffar and J.-L. Lassez, </author> <title> "Constraint Logic Programming", </title> <booktitle> Proc. 14 th ACM-POPL, </booktitle> <year> 1990, </year> <pages> pp 111-119. </pages>
Reference-contexts: For the first CLP (R) <ref> [7] </ref> program, the standard algorithm using this domain would be able to infer that Y is ground (because it can combine the formula X Y = obtained from the first rule with the formula X = obtained from the second rule).
Reference: [8] <author> J. Jaffar, S. Michaylov, P. Stuckey and R. Yap, </author> <title> "The CLP(R) Language and System", </title> <journal> ACM TOPLAS, </journal> <volume> 14(3), </volume> <pages> pp 339-395, </pages> <year> 1992. </year>
Reference-contexts: For example, in the context of the CLP (R) system <ref> [8] </ref>, it would be appropriate for simplify to solve tree equations, linear equations and linear inequalities, but not arbitrary non-linear constraints. In general, we want simplify to be weaker than the solver of the CLP system. We next discuss the select operation.
Reference: [9] <author> N.D. Jones and H. Stndergaard, </author> <title> "A Semantics-based Framework for the Abstract Interpretation of PROLOG", in Abstract Interpretation of Declarative Languages, </title> <editor> (S. Abramsky and C. Hankin, Eds), </editor> <publisher> Ellis Horwood, </publisher> <year> 1987, </year> <pages> pp 123-142. </pages>
Reference-contexts: In contrast, differences in the fixed-point components are relatively minor, and it is possible to speak of an idealized generic algorithm or "engine" that encompasses the essence of the fixed-point computation. Some specific descriptions of engines are <ref> [9] </ref>, for logic programs, and more recently, [10], for constraint logic programs. In earlier work [6], a new engine, called the unfolding engine, was presented for the analysis of logic programs. Its main advantage was improved accuracy over the standard engine, regardless of the abstract domain used.
Reference: [10] <author> K. Marriott and H. Stndergaard, </author> <title> "Analysis of Constraint Logic Programs", </title> <booktitle> Proc. 1990 North American Conf. on Logic Programming, </booktitle> <pages> 531-547, </pages> <year> 1990. </year>
Reference-contexts: In contrast, differences in the fixed-point components are relatively minor, and it is possible to speak of an idealized generic algorithm or "engine" that encompasses the essence of the fixed-point computation. Some specific descriptions of engines are [9], for logic programs, and more recently, <ref> [10] </ref>, for constraint logic programs. In earlier work [6], a new engine, called the unfolding engine, was presented for the analysis of logic programs. Its main advantage was improved accuracy over the standard engine, regardless of the abstract domain used.
Reference: [11] <author> K. Marriot and P. Stuckey, </author> <title> "The 3 R's of Optimizing Constraint Logic Programs: Refinment, Removal and Reordering", </title> <booktitle> Proc. 20 th ACM-POPL, </booktitle> <year> 1993, </year> <pages> pp 334-344. </pages>
Reference-contexts: Unfortunately, the unfolding engine relies directly on a specialized representation using substitutions, which cannot be lifted to constraint logic programming (CLP). This is a pity since analysis for CLP is arguably more important than for LP the opportunities for compiler optimizations are considerably greater (see eg. <ref> [11] </ref>). This paper presents an unfolding engine for CLP. The main technical difference from the previous engine is a novel use of input/output variables in the constraints, as opposed to the manipulation of substitutions. <p> This in fact represents the main technical result of this paper. We next illustrate some differences between a standard abstract interpretation algorithm, and the old and new engines. Consider the abstract domain LSign <ref> [11, 12] </ref> which abstracts the coefficients 1 in linear arithmetic expressions by their sign.
Reference: [12] <author> K. Marriot and P. Stuckey, "LSign: </author> <title> Approximating Possible Interaction between Linear Arithmetic Constraints", </title> <note> to appear, Proc. Int. Symp. on Logic Programming, </note> <year> 1994. </year>
Reference-contexts: This in fact represents the main technical result of this paper. We next illustrate some differences between a standard abstract interpretation algorithm, and the old and new engines. Consider the abstract domain LSign <ref> [11, 12] </ref> which abstracts the coefficients 1 in linear arithmetic expressions by their sign.
References-found: 12

