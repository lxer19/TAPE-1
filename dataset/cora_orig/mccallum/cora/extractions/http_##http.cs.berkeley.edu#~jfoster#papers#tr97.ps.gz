URL: http://http.cs.berkeley.edu/~jfoster/papers/tr97.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~jfoster/
Root-URL: 
Title: Flow-Insensitive Points-to Analysis with Term and Set Constraints  
Author: Jeffrey S. Foster Manuel Fahndrich Alexander Aiken 
Address: Berkeley, California 94720  
Affiliation: Computer Science Division (EECS) University of California  
Date: August 1997  
Pubnum: Report No. UCB/CSD-97-964  
Abstract-found: 0
Intro-found: 1
Reference: [And94] <author> L. Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> DIKU, University of Cophenhagen, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: The may-alias information computed by points-to analysis enables many optimizations in pointer-based languages such as C and C++ [ASU88]. Several flow-insensitive points-to analyses for C have been proposed <ref> [And94, Ste96a, Ste96b, SH97] </ref>. These flow-insensitive analyses achieve good scaling behavior by ignoring the ordering of statements [Hor97]. Shapiro and Horwitz [SH97] compare Andersen's and Steensgaard's flow-insensitive points-to analyses [And94, Ste96b]. <p> Several flow-insensitive points-to analyses for C have been proposed [And94, Ste96a, Ste96b, SH97]. These flow-insensitive analyses achieve good scaling behavior by ignoring the ordering of statements [Hor97]. Shapiro and Horwitz [SH97] compare Andersen's and Steensgaard's flow-insensitive points-to analyses <ref> [And94, Ste96b] </ref>. Both algorithms were originally presented using non-standard type systems; however, although both algorithms solve the same problem, the solutions look very different. [SH97] informally unifies the two approaches by describing the algorithms' operation on a points-to graph [EGH94]. <p> In Figure 1b, Steensgaard's analysis conservatively computes that c and e may be aliased, when in fact they cannot. 2 [ : Set Set ! Set 0 : Set 2 Related Work Andersen proposes his algorithm as part of a larger thesis about the analysis of C programs <ref> [And94] </ref>. His type system requires a specialized constraint to model updatable references. In contrast, we show that inclusion constraints on updatable references can be modeled naturally using standard notions of covariance and contravariance. We discuss this issue in Section 4. <p> Notice that ff appears both covariantly and contravariantly, which suggests that correctly modeling references requires covariant and contravariant components. Our naive type rules model references as covariant, which fails. Set-based analysis [Hei92] does not directly model contravariance, and so without specialized constraints as in <ref> [And94] </ref>, it cannot express Andersen's analysis. 5 Andersen-Style Analysis 5.1 Source language definitions. Note that we give a name to the return value from a function (written as y in the grammar). Return statements are treated as assignments to this special return value.
Reference: [ASU88] <author> A. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction For each pointer-valued expression in a program, points-to analysis computes the set of memory locations to which that expression could point. The may-alias information computed by points-to analysis enables many optimizations in pointer-based languages such as C and C++ <ref> [ASU88] </ref>. Several flow-insensitive points-to analyses for C have been proposed [And94, Ste96a, Ste96b, SH97]. These flow-insensitive analyses achieve good scaling behavior by ignoring the ordering of statements [Hor97]. Shapiro and Horwitz [SH97] compare Andersen's and Steensgaard's flow-insensitive points-to analyses [And94, Ste96b].
Reference: [AW92] <author> A. Aiken and E. Wimmers. </author> <title> Solving Systems of Set Constraints. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 329-340, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The correspondence between these new systems is made clear, formalizing the description in [SH97]. The differences between the two algorithms are expressed in a minimal fashion as a choice between inclusion and equality constraints. Our type systems are designed using term and set constraints. Set constraints <ref> [AW92, AW93, FA96, HJ90, Hei92] </ref> define inclusion relationships between types; we use set constraints to describe Andersen's analysis. Term constraints define equality relationships between types (e.g. ML type inference [Mil78]); we use term equations to describe Steensgaard's analysis.
Reference: [AW93] <author> A. Aiken and E. Wimmers. </author> <title> Type Inclusion Constraints and Type Inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: The correspondence between these new systems is made clear, formalizing the description in [SH97]. The differences between the two algorithms are expressed in a minimal fashion as a choice between inclusion and equality constraints. Our type systems are designed using term and set constraints. Set constraints <ref> [AW92, AW93, FA96, HJ90, Hei92] </ref> define inclusion relationships between types; we use set constraints to describe Andersen's analysis. Term constraints define equality relationships between types (e.g. ML type inference [Mil78]); we use term equations to describe Steensgaard's analysis. <p> We use conditional equality for Steensgaard's analysis; see Section 6. analysis. We have omitted rules for negations, rules for simplifying intersections, and some restrictions on the form of solvable constraints. The details may be found in <ref> [AW93, FA97] </ref>. The second flips constraints that arise from contravariant constructor arguments. 4 Andersen's Analysis: A First Cut We begin by examining why standard set-based analysis [Hei92] seems insufficient for expressing Ander-sen's algorithm.
Reference: [EGH94] <author> M. Emami, R. Ghiya, and L. Hendren. </author> <title> Context-Sensitive Interprocedural Points-to Analysis in the Presence of Function Pointers. </title> <booktitle> In Proceedings of the 1994 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256, </pages> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Both algorithms were originally presented using non-standard type systems; however, although both algorithms solve the same problem, the solutions look very different. [SH97] informally unifies the two approaches by describing the algorithms' operation on a points-to graph <ref> [EGH94] </ref>. In this paper, we present new constraint-based type systems for Andersen's and Steensgaard's analyses. The correspondence between these new systems is made clear, formalizing the description in [SH97]. The differences between the two algorithms are expressed in a minimal fashion as a choice between inclusion and equality constraints. <p> We formally show the correspondence between the two analyses and prove a soundness result in Section 7. Finally, Section 8 discusses implementation and performance issues. Section 9 concludes. 1.1 Informal Description Both Andersen's and Steensgaard's analyses build a points-to graph <ref> [EGH94] </ref>. The nodes of a points-to graph represent memory locations or sets of memory locations, and there must be an edge from x to y if any permutation of the assignment statements in the program may cause location x to contain a pointer to y.
Reference: [FA96] <author> M. Fahndrich and A. Aiken. </author> <title> Making Set-Constraint Based Program Analyses Scale. </title> <booktitle> In First Workshop on Set Constraints at CP '96, </booktitle> <address> Cambridge, MA, </address> <month> August </month> <year> 1996. </year> <note> Available as CSD-TR-96-917, </note> <institution> University of California at Berkeley. </institution>
Reference-contexts: The correspondence between these new systems is made clear, formalizing the description in [SH97]. The differences between the two algorithms are expressed in a minimal fashion as a choice between inclusion and equality constraints. Our type systems are designed using term and set constraints. Set constraints <ref> [AW92, AW93, FA96, HJ90, Hei92] </ref> define inclusion relationships between types; we use set constraints to describe Andersen's analysis. Term constraints define equality relationships between types (e.g. ML type inference [Mil78]); we use term equations to describe Steensgaard's analysis. <p> We attribute these results to the effort spent making our general framework scale to large programs <ref> [FA96] </ref>, something that is difficult to do for one-time use systems like SH. There are also two anomalous results: Our system takes twice as long for Andersen-style analysis of espresso and five times as long for Steensgaard-style analysis of flex. We currently have no explanation for these apparent outliers.
Reference: [FA97] <author> M. Fahndrich and A. Aiken. </author> <title> Program Analysis using Mixed Term and Set Constraints. In Static Analysis, </title> <booktitle> Fourth International Symposium, </booktitle> <address> SAS'97, </address> <year> 1997. </year>
Reference-contexts: Term constraints define equality relationships between types (e.g. ML type inference [Mil78]); we use term equations to describe Steensgaard's analysis. We have implemented these new type systems in a mixed term and set constraint framework <ref> [FA97] </ref>. <p> In Section 8, we describe our own implementation and compare its performance to their hand-coded C version. 3 The Analysis Framework We have developed type systems for Andersen's and Steensgaard's points-to analyses in the context of the mixed term and set constraint framework described in <ref> [FA97] </ref>. Each analysis generates a system of constraints, and we compute the points-to graph for a program by solving the generated constraints. In this section, we briefly discuss the framework. We describe the constraint language and give resolution rules for solving a system of constraints. <p> We use conditional equality for Steensgaard's analysis; see Section 6. analysis. We have omitted rules for negations, rules for simplifying intersections, and some restrictions on the form of solvable constraints. The details may be found in <ref> [AW93, FA97] </ref>. The second flips constraints that arise from contravariant constructor arguments. 4 Andersen's Analysis: A First Cut We begin by examining why standard set-based analysis [Hei92] seems insufficient for expressing Ander-sen's algorithm. <p> Thus, in general the p fields may contain a union of terms with ref and lam n head constructors. We use the pattern matching mechanism described in <ref> [FA97] </ref> to select the correct terms when projecting out of a certain constructor. 6 Steensgaard-Style Analysis Intuitively, Steensgaard's analysis replaces inclusion constraints with equality constraints. Where Ander-sen's analysis creates a set, Steensgaard's analysis unifies the members of that set to create an equivalence class.
Reference: [Hei92] <author> N. Heintze. </author> <title> Set Based Program Analysis. </title> <type> PhD dissertation, </type> <institution> Carnegie Mellon University, Department of Computer Science, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: The correspondence between these new systems is made clear, formalizing the description in [SH97]. The differences between the two algorithms are expressed in a minimal fashion as a choice between inclusion and equality constraints. Our type systems are designed using term and set constraints. Set constraints <ref> [AW92, AW93, FA96, HJ90, Hei92] </ref> define inclusion relationships between types; we use set constraints to describe Andersen's analysis. Term constraints define equality relationships between types (e.g. ML type inference [Mil78]); we use term equations to describe Steensgaard's analysis. <p> The details may be found in [AW93, FA97]. The second flips constraints that arise from contravariant constructor arguments. 4 Andersen's Analysis: A First Cut We begin by examining why standard set-based analysis <ref> [Hei92] </ref> seems insufficient for expressing Ander-sen's algorithm. Consider the C fragment e ::= x j fle j &e j e 1 = e 2 j e 1 ; e 2 consisting of variables, pointer dereferencing, the address-of operator, assignment, and sequencing. <p> For example, consider the statement *x = y. Applying the type rules yields x : ref (x) ref (x) s ref (ff) ref (y) s ff 1 In set-based analysis <ref> [Hei92] </ref>, this would be written with an explicit projector ref 1 : 5 def ::= f (x 1 ; : : : ; x n ) ! y = e Function definition j def 1 def 2 Sequencing e ::= n Constant integer n j x Variable j fle Pointer dereference <p> Notice that ff appears both covariantly and contravariantly, which suggests that correctly modeling references requires covariant and contravariant components. Our naive type rules model references as covariant, which fails. Set-based analysis <ref> [Hei92] </ref> does not directly model contravariance, and so without specialized constraints as in [And94], it cannot express Andersen's analysis. 5 Andersen-Style Analysis 5.1 Source language definitions. Note that we give a name to the return value from a function (written as y in the grammar).
Reference: [HJ90] <author> N. Heintze and J. Jaffar. </author> <title> A Decision Procedure for a Class of Herbrand Set Constraints. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 42-51, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The correspondence between these new systems is made clear, formalizing the description in [SH97]. The differences between the two algorithms are expressed in a minimal fashion as a choice between inclusion and equality constraints. Our type systems are designed using term and set constraints. Set constraints <ref> [AW92, AW93, FA96, HJ90, Hei92] </ref> define inclusion relationships between types; we use set constraints to describe Andersen's analysis. Term constraints define equality relationships between types (e.g. ML type inference [Mil78]); we use term equations to describe Steensgaard's analysis.
Reference: [Hor97] <author> S. Horwitz. </author> <title> Precise Flow-Insensitive May-Alias Analysis is NP-Hard. </title> <journal> ACM TOPLAS, </journal> <volume> 19(1) </volume> <pages> 1-6, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: The may-alias information computed by points-to analysis enables many optimizations in pointer-based languages such as C and C++ [ASU88]. Several flow-insensitive points-to analyses for C have been proposed [And94, Ste96a, Ste96b, SH97]. These flow-insensitive analyses achieve good scaling behavior by ignoring the ordering of statements <ref> [Hor97] </ref>. Shapiro and Horwitz [SH97] compare Andersen's and Steensgaard's flow-insensitive points-to analyses [And94, Ste96b].
Reference: [Mil78] <author> R. Milner. </author> <title> A Theory of Type Polymorphism in Programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Our type systems are designed using term and set constraints. Set constraints [AW92, AW93, FA96, HJ90, Hei92] define inclusion relationships between types; we use set constraints to describe Andersen's analysis. Term constraints define equality relationships between types (e.g. ML type inference <ref> [Mil78] </ref>); we use term equations to describe Steensgaard's analysis. We have implemented these new type systems in a mixed term and set constraint framework [FA97].
Reference: [Rem89] <author> D. Remy. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin, Texas, </address> <pages> pages 60-76, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Additionally, our framework lends itself to experimentation, which is often difficult in a custom implementation. For example, we are currently experimenting with changing from fixed-length argument lists to variable-length argument lists using a row type <ref> [Rem89] </ref>.
Reference: [SH97] <author> M. Shapiro and S. Horwitz. </author> <title> Fast and Accurate Flow-Insensitive Points-To Analysis. </title> <booktitle> In Proceedings of the 24th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: The may-alias information computed by points-to analysis enables many optimizations in pointer-based languages such as C and C++ [ASU88]. Several flow-insensitive points-to analyses for C have been proposed <ref> [And94, Ste96a, Ste96b, SH97] </ref>. These flow-insensitive analyses achieve good scaling behavior by ignoring the ordering of statements [Hor97]. Shapiro and Horwitz [SH97] compare Andersen's and Steensgaard's flow-insensitive points-to analyses [And94, Ste96b]. <p> The may-alias information computed by points-to analysis enables many optimizations in pointer-based languages such as C and C++ [ASU88]. Several flow-insensitive points-to analyses for C have been proposed [And94, Ste96a, Ste96b, SH97]. These flow-insensitive analyses achieve good scaling behavior by ignoring the ordering of statements [Hor97]. Shapiro and Horwitz <ref> [SH97] </ref> compare Andersen's and Steensgaard's flow-insensitive points-to analyses [And94, Ste96b]. Both algorithms were originally presented using non-standard type systems; however, although both algorithms solve the same problem, the solutions look very different. [SH97] informally unifies the two approaches by describing the algorithms' operation on a points-to graph [EGH94]. <p> These flow-insensitive analyses achieve good scaling behavior by ignoring the ordering of statements [Hor97]. Shapiro and Horwitz <ref> [SH97] </ref> compare Andersen's and Steensgaard's flow-insensitive points-to analyses [And94, Ste96b]. Both algorithms were originally presented using non-standard type systems; however, although both algorithms solve the same problem, the solutions look very different. [SH97] informally unifies the two approaches by describing the algorithms' operation on a points-to graph [EGH94]. In this paper, we present new constraint-based type systems for Andersen's and Steensgaard's analyses. The correspondence between these new systems is made clear, formalizing the description in [SH97]. <p> same problem, the solutions look very different. <ref> [SH97] </ref> informally unifies the two approaches by describing the algorithms' operation on a points-to graph [EGH94]. In this paper, we present new constraint-based type systems for Andersen's and Steensgaard's analyses. The correspondence between these new systems is made clear, formalizing the description in [SH97]. The differences between the two algorithms are expressed in a minimal fashion as a choice between inclusion and equality constraints. Our type systems are designed using term and set constraints. <p> Finally, his system uses a nonstandard notion of type equivalence. These three points combined to make formal reasoning about the system very difficult. Our work was inspired by Shapiro and Horwitz's paper examining the precision-efficiency tradeoff between the two analyses <ref> [SH97] </ref>. They describe the analyses as being at two ends of a spectrum: Andersen's, the more precise, allows an arbitrary set of successors for a node, while Steensgaard's, which is less precise, allows only one. They measure the performance and precision of both analyses. <p> We explain the reason for these slightly convoluted rules in Section 6. For Andersen's analysis, the result type points to the union of the subexpressions' points-to sets. This is overly conservative for And+Common, but we chose this rule to match <ref> [SH97] </ref>. We discuss this issue further in Section 8. Structures and arrays are atomic; we make no distinction between array elements or between fields of structures. These rules assume that the programmer does not take advantage of the compiler's data layout strategy. <p> The traversal calls the inference rule module in exactly eight cases to assert the appropriate constraints. Shapiro and Horwitz (SH) have implemented these analysis in C <ref> [SH97] </ref>. SH uses the same general technique, although, as their implementation is in C, they do not have a built-in module system. Their rules separate land r-types, which doubles the number of cases. <p> 1054796 1409 100.03 1152974 1417 17.64 flex-2.4.7 9358 10.03 23775 415 2.04 25854 452 0.20 less-177 12108 2.73 147795 646 5.15 151839 656 1.89 make-3.72.1 15214 7.10 927441 1609 73.72 938203 1634 10.38 espresso 21583 12.51 315372 1935 27.23 316999 1970 2.18 16 8.2 Measurements the SH times differ from <ref> [SH97] </ref>. The results are summarized by two metrics. Sets counts the number of non-empty points-to sets computed. Total size is the sum of the cardinalities of all points-to sets. SH has been improved since [SH97], and so the reported sizes do not match. <p> 21583 12.51 315372 1935 27.23 316999 1970 2.18 16 8.2 Measurements the SH times differ from <ref> [SH97] </ref>. The results are summarized by two metrics. Sets counts the number of non-empty points-to sets computed. Total size is the sum of the cardinalities of all points-to sets. SH has been improved since [SH97], and so the reported sizes do not match. The sizes we report do not include temporary variables introduced by SH during program transformations. In order to correspond more closely with SH, we made two modifications to our system. <p> We have shown that, as has been intuitively described in <ref> [SH97] </ref>, these are closely related analyses, and we can account for the difference as a tradeoff between using inclusion constraints and using unification. We believe these type systems demonstrate that our mixed term and set constraint framework is a natural formalism for expressing this kind of analysis. <p> This routine uses a non-portable implementation of varags. When we modified this routine to take a fixed number of arguments (so that we could model it correctly), the set sizes increased dramatically from <ref> [SH97] </ref>. 17 programs. With low implementation cost and competitive performance, our framework provides a useful and productive platform with which to develop program analyses. 10 Acknowledgments The idea for dealing with library functions came from a discussion with Erik Ruf.
Reference: [Ste96a] <author> B. Steensgaard. </author> <title> Points-to Analysis by Type Inference of Programs with Structures and Unions. </title> <booktitle> In Proceedings of the International Conference on Compiler Construction, volume 1060 of Lecture Notes in Computer Science, </booktitle> <pages> pages 136-150. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1996. </year>
Reference-contexts: The may-alias information computed by points-to analysis enables many optimizations in pointer-based languages such as C and C++ [ASU88]. Several flow-insensitive points-to analyses for C have been proposed <ref> [And94, Ste96a, Ste96b, SH97] </ref>. These flow-insensitive analyses achieve good scaling behavior by ignoring the ordering of statements [Hor97]. Shapiro and Horwitz [SH97] compare Andersen's and Steensgaard's flow-insensitive points-to analyses [And94, Ste96b].
Reference: [Ste96b] <author> B. Steensgaard. </author> <title> Points-to Analysis in Almost Linear Time. </title> <booktitle> In Proceedings of the 23th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <month> January </month> <year> 1996. </year> <month> 18 </month>
Reference-contexts: The may-alias information computed by points-to analysis enables many optimizations in pointer-based languages such as C and C++ [ASU88]. Several flow-insensitive points-to analyses for C have been proposed <ref> [And94, Ste96a, Ste96b, SH97] </ref>. These flow-insensitive analyses achieve good scaling behavior by ignoring the ordering of statements [Hor97]. Shapiro and Horwitz [SH97] compare Andersen's and Steensgaard's flow-insensitive points-to analyses [And94, Ste96b]. <p> Several flow-insensitive points-to analyses for C have been proposed [And94, Ste96a, Ste96b, SH97]. These flow-insensitive analyses achieve good scaling behavior by ignoring the ordering of statements [Hor97]. Shapiro and Horwitz [SH97] compare Andersen's and Steensgaard's flow-insensitive points-to analyses <ref> [And94, Ste96b] </ref>. Both algorithms were originally presented using non-standard type systems; however, although both algorithms solve the same problem, the solutions look very different. [SH97] informally unifies the two approaches by describing the algorithms' operation on a points-to graph [EGH94]. <p> His type system requires a specialized constraint to model updatable references. In contrast, we show that inclusion constraints on updatable references can be modeled naturally using standard notions of covariance and contravariance. We discuss this issue in Section 4. Steensgaard proposed his analysis as an efficient alternative to Andersen's <ref> [Ste96b] </ref>. Andersen's analysis runs in O (n 3 ) time, where n is the number of locations in the program. By using unification instead of inclusion constraints, Steensgaard reduces this to O (nff (n; n)), where ff is the inverse Ackerman's function. Steensgaard's system is surprisingly difficult to understand. First, [Ste96b] <p> <ref> [Ste96b] </ref>. Andersen's analysis runs in O (n 3 ) time, where n is the number of locations in the program. By using unification instead of inclusion constraints, Steensgaard reduces this to O (nff (n; n)), where ff is the inverse Ackerman's function. Steensgaard's system is surprisingly difficult to understand. First, [Ste96b] gives a system for type checking rather than type inference: Statements are type checked but the system does not actually assign types to program variables. <p> The tag field t serves to identify equivalence classes. Because pure unification is a coarse operation, Ste uses a form conditional unification to improve the precision of the analysis, as proposed by Steensgaard <ref> [Ste96b] </ref>. We use = c to denote Steensgaard's conditional unification. Figure 3a contains the rewrite rule for = c . Intuitively, conditional unification x = c y becomes unconditional unification x = t y if x is instantiated with a constructed term. <p> More formally, Definition 6.1 Define x = c y (9c:CS ` c (: : : ) = t x =) x = t y). For an example in which conditional unification is useful, consider the program from <ref> [Ste96b] </ref> a = 2, x = a, y = a Since a is not a pointer, x and y may remain distinct.
References-found: 15

