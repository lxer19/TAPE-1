URL: http://www.cs.purdue.edu/homes/spaf/spyder/TR93P.ps
Refering-URL: http://www.cs.purdue.edu/homes/spaf/spyder.html
Root-URL: http://www.cs.purdue.edu
Email: debug@cs.purdue.edu  
Title: Dynamic Slicing in the Presence of Unconstrained Pointers  
Author: Hiralal Agrawal Richard A. DeMillo Eugene H. Spafford 
Address: W. Lafayette, IN 47907-2004  
Affiliation: Software Engineering Research Center Department of Computer Sciences Purdue University  
Pubnum: Technical Report SERC-TR-93-P  
Abstract: Program slices are useful in debugging. Most work on program slicing to date has concentrated on finding slices of programs involving only scalar variables. Pointers and composite variables do not lend themselves well to static analysis, especially when the language involved is not strongly-typed. When debugging a program, however, we are interested in analyzing the program behavior for testcases that reveal a fault. In this paper, we present a uniform approach to handling pointers and composite variables such as arrays, records, and unions for the purpose of obtaining dynamic program slices. The dynamic approach proposed works well even when the language involved allows unconstrained pointers and performs no runtime checks, as in C.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Hiralal Agrawal. </author> <title> Towards Automatic Debugging of Computer Programs. </title> <type> PhD thesis, </type> <institution> Department of Computer Sciences, Purdue University, West Lafayette, IN, </institution> <year> 1991. </year>
Reference-contexts: We identify three types of intersections between l-valued expressions: complete intersection, maybe intersection, and partial intersection. We informally describe these below; see <ref> [1] </ref> for precise definitions. Complete Intersection A use expression e 1 completely intersects a def expression e 2 if the memory location associated with e 1 is totally contained in that associated with e 2 . <p> The static slice would have included the whole program. instead of using a separate assignment for each array element. If we execute this program for the same testcase (i = 1; j = 3; k = 3), we get the following output: a <ref> [1] </ref> = 2; a [3] = 4; a [10] = 0. Instead of printing the value of a [3] it prints that of a [10]. This implies that the value of k somehow got corrupted during the program execution.
Reference: [2] <author> Hiralal Agrawal, Richard A. DeMillo, and Eugene H. Spafford. </author> <title> Efficient debugging with slicing and backtracking. </title> <type> Technical Report SERC-TR-80-P, </type> <institution> Software Engineering Research Center, Purdue University, West Lafayette, </institution> <note> IN, 1990. 17 </note>
Reference-contexts: While the static slicing algorithm assumes that an indirect assignment may potentially modify any variable, the dynamic slicing algorithm detects exact dependencies. We have built a prototype debugging tool, named Spyder, that uses the approach described here to find both static and dynamic program slices <ref> [2] </ref> for programs written in C. The tool supports a powerful debugging paradigm involving dynamic slicing [5] and execution backtracking [4] with the help of which program bugs may be localized quickly.
Reference: [3] <author> Hiralal Agrawal, Richard A. DeMillo, and Eugene H. Spafford. </author> <title> Dynamic slicing in the presence of unconstrained pointers. </title> <booktitle> In Proceedings of the Fourth Symposium on Testing, Analysis and Verification (TAV4). </booktitle> <address> ACM/IEEE-CS, </address> <month> October </month> <year> 1991. </year> <note> Also issued as SERC Technical Report SERC-TR-93-P. </note>
Reference-contexts: Further, when such a reference occurs inside a loop, the memory fl This paper appeared as <ref> [3] </ref>. <p> The static slice would have included the whole program. instead of using a separate assignment for each array element. If we execute this program for the same testcase (i = 1; j = 3; k = 3), we get the following output: a [1] = 2; a <ref> [3] </ref> = 4; a [10] = 0. Instead of printing the value of a [3] it prints that of a [10]. This implies that the value of k somehow got corrupted during the program execution. <p> If we execute this program for the same testcase (i = 1; j = 3; k = 3), we get the following output: a [1] = 2; a <ref> [3] </ref> = 4; a [10] = 0. Instead of printing the value of a [3] it prints that of a [10]. This implies that the value of k somehow got corrupted during the program execution.
Reference: [4] <author> Hiralal Agrawal, Richard A. DeMillo, and Eugene H. Spafford. </author> <title> An execution backtracking approach to program debugging. </title> <journal> IEEE Software, </journal> <pages> pages 21-26, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: We have built a prototype debugging tool, named Spyder, that uses the approach described here to find both static and dynamic program slices [2] for programs written in C. The tool supports a powerful debugging paradigm involving dynamic slicing [5] and execution backtracking <ref> [4] </ref> with the help of which program bugs may be localized quickly. To see how dynamic slices differ from static slices, consider the program in the main window panel of Figure 1. It reads a date (month, day, year) and finds the corresponding day-of-the-year and day-of-the-week.
Reference: [5] <author> Hiralal Agrawal and Joseph R. Horgan. </author> <title> Dynamic program slicing. </title> <booktitle> In Proceedings of the SIG-PLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year> <journal> ACM SIGPLAN. SIGPLAN Notices, </journal> <volume> 25(6) </volume> <pages> 246-256, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction The notion of program slicing has been discussed extensively in the literature <ref> [20, 17, 12, 13, 5] </ref>. This discussion, however, has mostly dealt with finding slices for programs involving scalar variables (see Section 6, Related Work). <p> We have built a prototype debugging tool, named Spyder, that uses the approach described here to find both static and dynamic program slices [2] for programs written in C. The tool supports a powerful debugging paradigm involving dynamic slicing <ref> [5] </ref> and execution backtracking [4] with the help of which program bugs may be localized quickly. To see how dynamic slices differ from static slices, consider the program in the main window panel of Figure 1. It reads a date (month, day, year) and finds the corresponding day-of-the-year and day-of-the-week.
Reference: [6] <author> R. M. Balzer. </author> <title> Exdams: Extendible debugging and monitoring system. </title> <booktitle> In AFIPS Proceedings, Spring Joint Computer Conference, </booktitle> <volume> volume 34, </volume> <pages> pages 567-580, </pages> <address> Montvale, New Jersey, 1969. </address> <publisher> AFIPS Press. </publisher>
Reference-contexts: Miller and Choi also use dynamic dependence graph to perform flow-back analysis <ref> [6] </ref> in their Parallel Program Debugger Ppd [15]. These approaches also treat array elements as separate variables. But as they do not resolve use and def sets in terms of memory cells, they will fail to detect interstatement dependencies like that illustrated in Figure 8.
Reference: [7] <author> Jean-Francois Bergeretti and Bernard A. Carre. </author> <title> Information-flow and data-flow analysis of while programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 37-61, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Bergeretti and Carre have also defined information-flow relations somewhat similar to data- and control dependence relations, that can be used to obtain static program slices (referred to as "partial statements" by them) <ref> [7] </ref>. Podgurski and Clark have extended the regular notion of control dependence (which they refer to as "strong control dependence") to "weak control dependence" that includes inter-statement dependencies involving program nontermination [18]. <p> Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, and automatic integration of program versions (see, e.g., <ref> [20, 7, 11] </ref>). Korel and Laski extended Weiser's static slicing algorithms for the dynamic case [13]. Their definition requires that if any one occurrence of a statement in the execution history is included in the slice then all other occurrences of that statement be automatically included in the slice.
Reference: [8] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year> <journal> ACM SIGPLAN. SIGPLAN Notices, </journal> <volume> 25(6) </volume> <pages> 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The difficulty is compounded if the language used is not strongly-typed and permits integer arithmetic over pointer variables. Techniques proposed in <ref> [8, 10, 14] </ref> may be used to obtain conservative approximations of what a pointer might point to, but in the presence of unconstrained pointers, as in C, such analysis has only limited usefulness.
Reference: [9] <author> Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. </author> <title> The program dependence graph and its uses in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: As SRD (Z, 11, F ) = f2, 9g, there are data dependence edges from node 11 to nodes 2 and 9 in Figure 5. 3 At other places in the literature, particularly that related to vectorizing compilers, e.g., <ref> [9] </ref>, the direction of edges in dependence graphs is reversed. For the purposes of program slicing, however, our definition is more suitable, as will become apparent later. 6 the static slice with respect to variable Y at statement 9. <p> In programs with arbitrary control flow, a control dependence edge from vertex v i to vertex v j implies that v j is the nearest inverse dominator of v i in the control flow graph of the program <ref> [9] </ref>. 5 In other applications like vectorizing compilers, a data dependence graph may include other types of dependence edges besides data and control dependence, e.g., anti-dependence, output-dependence etc., but for the purposes of program slicing, the first two suffice. 7 let F = Flow (P ), D = ProgramDep (P )
Reference: [10] <author> Susan Horwitz, Phil Pfeiffer, and Thomas Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of the SIGPLAN'89 Conference on Programming Language Design and Implementation, </booktitle> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year> <journal> ACM SIGPLAN. SIGPLAN Notices, </journal> <volume> 24(7) </volume> <pages> 28-40, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: The difficulty is compounded if the language used is not strongly-typed and permits integer arithmetic over pointer variables. Techniques proposed in <ref> [8, 10, 14] </ref> may be used to obtain conservative approximations of what a pointer might point to, but in the presence of unconstrained pointers, as in C, such analysis has only limited usefulness. <p> If we execute this program for the same testcase (i = 1; j = 3; k = 3), we get the following output: a [1] = 2; a [3] = 4; a <ref> [10] </ref> = 0. Instead of printing the value of a [3] it prints that of a [10]. This implies that the value of k somehow got corrupted during the program execution. <p> If we execute this program for the same testcase (i = 1; j = 3; k = 3), we get the following output: a [1] = 2; a [3] = 4; a <ref> [10] </ref> = 0. Instead of printing the value of a [3] it prints that of a [10]. This implies that the value of k somehow got corrupted during the program execution. If we obtain the dynamic slice of k on line 27, we would expect only line 8 to be in the slice as that is the only place in the program where k is modified.
Reference: [11] <author> Susan Horwitz, Jan Prins, and Thomas Reps. </author> <title> Integrating noninterfering versions of programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(3) </volume> <pages> 345-387, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, and automatic integration of program versions (see, e.g., <ref> [20, 7, 11] </ref>). Korel and Laski extended Weiser's static slicing algorithms for the dynamic case [13]. Their definition requires that if any one occurrence of a statement in the execution history is included in the slice then all other occurrences of that statement be automatically included in the slice.
Reference: [12] <author> Susan Horwitz, Thomas Reps, and David Binkeley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: 1 Introduction The notion of program slicing has been discussed extensively in the literature <ref> [20, 17, 12, 13, 5] </ref>. This discussion, however, has mostly dealt with finding slices for programs involving scalar variables (see Section 6, Related Work). <p> Figure 9 also shows the interprocedural dynamic slice with respect to date.day of the year on line 91 for the same testcase used for the dynamic slice in Note that unlike interprocedural static slicing <ref> [12] </ref>, our approach for dynamic slicing does not require that we determine which global variables are referenced inside a procedure, or which variables may be aliases to each other, nor do we need to eliminate name conflicts among variables in different procedures. 15 day=1, year=1990). <p> Horwitz, Reps, and Binkley extended the program dependence graph representation to what they call the "system dependence graph" to 16 find interprocedural static slices under the same graph-reachability framework <ref> [12] </ref>. Bergeretti and Carre have also defined information-flow relations somewhat similar to data- and control dependence relations, that can be used to obtain static program slices (referred to as "partial statements" by them) [7].
Reference: [13] <author> Bogdan Korel and Janusz Laski. </author> <title> Dynamic program slicing. </title> <journal> Information Processing Letters, </journal> <volume> 29 </volume> <pages> 155-163, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: 1 Introduction The notion of program slicing has been discussed extensively in the literature <ref> [20, 17, 12, 13, 5] </ref>. This discussion, however, has mostly dealt with finding slices for programs involving scalar variables (see Section 6, Related Work). <p> Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, and automatic integration of program versions (see, e.g., [20, 7, 11]). Korel and Laski extended Weiser's static slicing algorithms for the dynamic case <ref> [13] </ref>. Their definition requires that if any one occurrence of a statement in the execution history is included in the slice then all other occurrences of that statement be automatically included in the slice.
Reference: [14] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation. ACM SIGPLAN, </booktitle> <month> July </month> <year> 1988. </year> <journal> SIGPLAN Notices, </journal> <volume> 23(7) </volume> <pages> 21-34, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: The difficulty is compounded if the language used is not strongly-typed and permits integer arithmetic over pointer variables. Techniques proposed in <ref> [8, 10, 14] </ref> may be used to obtain conservative approximations of what a pointer might point to, but in the presence of unconstrained pointers, as in C, such analysis has only limited usefulness.
Reference: [15] <author> Barton P. Miller and Jong-Deok Choi. </author> <title> A mechanism for efficient debugging of parallel programs. </title> <booktitle> In Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <address> Atlanta, GA, </address> <month> June </month> <year> 1988. </year> <journal> ACM SIGPLAN. SIGPLAN Notices, </journal> <volume> 23(7) </volume> <pages> 135-144, </pages> <month> July </month> <year> 1988. </year> <month> 18 </month>
Reference-contexts: Miller and Choi also use dynamic dependence graph to perform flow-back analysis [6] in their Parallel Program Debugger Ppd <ref> [15] </ref>. These approaches also treat array elements as separate variables. But as they do not resolve use and def sets in terms of memory cells, they will fail to detect interstatement dependencies like that illustrated in Figure 8.
Reference: [16] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Section 5 discusses how our approach may be extended to the interprocedural case. Finally, Section 6 outlines related work. 2 Background 2.1 Notation In the following sections we use a let in construct (adapted from a similar construct in the programming language ML <ref> [16] </ref>). Consider the following generic use of let : let &lt;declarations&gt; in &lt;expression&gt; Here, &lt;declarations&gt; consists of a sequence of name bindings that may be used inside &lt;expression&gt;. The scope of these bindings is limited to &lt;expression&gt;.
Reference: [17] <author> Karl J. Ottenstein and Linda M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Symposium on Practical Software Development Environments, </booktitle> <address> Pittaburgh, PA, </address> <month> April </month> <year> 1984. </year> <journal> ACM SIGSOFT/SIGPLAN. SIGPLAN Notices, </journal> <volume> 19(5) </volume> <pages> 177-184, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: 1 Introduction The notion of program slicing has been discussed extensively in the literature <ref> [20, 17, 12, 13, 5] </ref>. This discussion, however, has mostly dealt with finding slices for programs involving scalar variables (see Section 6, Related Work). <p> Ottenstein and Otten-stein later presented an algorithm in terms of graph reachability in the program dependence graph, but they only considered the intraprocedural case <ref> [17] </ref>. Horwitz, Reps, and Binkley extended the program dependence graph representation to what they call the "system dependence graph" to 16 find interprocedural static slices under the same graph-reachability framework [12].
Reference: [18] <author> Andy Podgurski and Lori A. Clarke. </author> <title> A formal model of program dependences and its implications for software testing, debugging, and maintenance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 965-979, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Podgurski and Clark have extended the regular notion of control dependence (which they refer to as "strong control dependence") to "weak control dependence" that includes inter-statement dependencies involving program nontermination <ref> [18] </ref>. Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, and automatic integration of program versions (see, e.g., [20, 7, 11]). Korel and Laski extended Weiser's static slicing algorithms for the dynamic case [13].
Reference: [19] <author> Mark Weiser. </author> <title> Programmers use slices when debugging. </title> <journal> Communications of the ACM, </journal> <volume> 25(7) </volume> <pages> 446-452, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Call-by-value-result can be handled similarly by making appropriate assignments both at the beginning and the end of the procedure. 6 Related Work The concept of static program slicing was first proposed by Weiser <ref> [19, 20] </ref>. Ottenstein and Otten-stein later presented an algorithm in terms of graph reachability in the program dependence graph, but they only considered the intraprocedural case [17].
Reference: [20] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year> <month> 19 </month>
Reference-contexts: 1 Introduction The notion of program slicing has been discussed extensively in the literature <ref> [20, 17, 12, 13, 5] </ref>. This discussion, however, has mostly dealt with finding slices for programs involving scalar variables (see Section 6, Related Work). <p> Call-by-value-result can be handled similarly by making appropriate assignments both at the beginning and the end of the procedure. 6 Related Work The concept of static program slicing was first proposed by Weiser <ref> [19, 20] </ref>. Ottenstein and Otten-stein later presented an algorithm in terms of graph reachability in the program dependence graph, but they only considered the intraprocedural case [17]. <p> Uses of program slicing have also been suggested in many other applications, e.g., program verification, testing, maintenance, automatic parallelization of program execution, and automatic integration of program versions (see, e.g., <ref> [20, 7, 11] </ref>). Korel and Laski extended Weiser's static slicing algorithms for the dynamic case [13]. Their definition requires that if any one occurrence of a statement in the execution history is included in the slice then all other occurrences of that statement be automatically included in the slice.
References-found: 20

