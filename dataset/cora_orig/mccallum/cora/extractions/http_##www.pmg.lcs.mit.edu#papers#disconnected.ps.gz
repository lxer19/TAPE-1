URL: http://www.pmg.lcs.mit.edu/papers/disconnected.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/Thor-papers.html
Root-URL: 
Title: Disconnected Operation in the Thor Object-Oriented Database System  
Author: Robert Gruber Frans Kaashoek Barbara Liskov Liuba Shrira 
Address: Cambridge, MA 02139  
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  
Date: December 1994.  
Note: To appear in Proceedings of the IEEE Workshop on Mobile Computing Systems and Applications, Santa Cruz, CA,  
Abstract: This paper discusses issues raised by providing disconnected operation in the Thor object-oriented database system. Disconnected operation in such a system poses new challenges because of the small size of objects, the richness and complexity of their interconnections, the huge number of them, and the fact that they are accessed within atomic transactions. We propose three techniques to address these challenges: (1) using the database query language for hoarding; (2) using dependent commits to tentatively commit transactions at the disconnected client; (3) using the high-level semantic of objects to avoid transaction aborts. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Adya, R. Gruber, B. Liskov, and U. Maheshwari. </author> <title> Efficient Optimistic Concurrency Control Using Loosely Synchronized Clocks. </title> <booktitle> Submitted to the 1995 ACM SIGMOD Int. Conf. on Mgmt. of Data, </booktitle> <month> May </month> <year> 1995. </year> <note> Available as Programming Methodology Group Memo 85, </note> <institution> MIT Laboratory for Computer Science. </institution>
Reference-contexts: Transactions are synchronized using optimistic concur-rency control (see <ref> [1] </ref>); we provide some details here since they are relevant to disconnected operation. While a transaction is running, the FE keeps track of which persistent objects it uses (reads and writes).
Reference: [2] <author> M. Carey, D. DeWitt, and J. Naughton. </author> <title> The OO7 Benchmark. </title> <booktitle> In Proc. 1993 ACM SIGMOD Int. Conf. on Mgmt. of Data, </booktitle> <pages> pages 12-21, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: An OODB is structured differently from a file system. Objects are small compared to files: we expect an average object size of under 100 bytes. (This figure is based on analysis of object sizes in the OO7 benchmark <ref> [2] </ref>.) Object interconnections are complicated and irregular, while file system name spaces are simple and highly structured. Finally, the number of objects managed by a database will be much larger than the number of files managed by a file system. 2. An OODB is accessed differently than a file system.
Reference: [3] <author> M. Carey, M. Franklin, M. Livny, and E. Shekita. </author> <title> Data Caching Tradeoffs in Client-Server DBMS Architectures. </title> <booktitle> In Proc. 1991 ACM SIGMOD Int. Conf. on Mgmt. of Data, </booktitle> <address> Denver, CO, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: The Thor architecture is well-suited to disconnected client operation. A transaction that runs at one FE can fetch and commit without the need for servers to communicate with other FE's (as would be the case, e.g., if a locking technique such as call-back locking <ref> [3] </ref> were in use). This is good since other FE's might be disconnected at the time.
Reference: [4] <author> M. Day. </author> <title> Object Groups May Be Better Than Pages. </title> <booktitle> In Proc. 4th Workshop on Workstation Operating Systems, </booktitle> <pages> pages 119-122, </pages> <year> 1993. </year>
Reference-contexts: The set of object references captured in this way can be stored and later used in a hoarding query. Such a tool has been proposed for object prefetching <ref> [4] </ref>; it is similar to the file tracing tool provided by Coda [22] that helps users determine which hidden files are used by an application so that they can be included in their hoarding profiles.
Reference: [5] <author> M. Day. </author> <title> Client Cache Management in a Distributed Object Database. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <note> 1994 in preparation. </note>
Reference-contexts: The FE maintains a cache containing copies of persistent objects; it carries out client requests and interacts with the servers only to handle cache misses (in which case the FE fetches the needed object from its server and prefetches a number of related objects <ref> [5] </ref>) and transaction commits. Transactions are synchronized using optimistic concur-rency control (see [1]); we provide some details here since they are relevant to disconnected operation. While a transaction is running, the FE keeps track of which persistent objects it uses (reads and writes).
Reference: [6] <author> O. </author> <title> Deux et al. </title> <journal> The Story of O 2 . IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 91-108, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: These languages are similar to relational query languages, but have been extended to include object navigation via the traversal of representation-exposing path expressions, e.g., x.project.manager.salary, or, preferably, the invocation of arbitrary methods or functions, e.g., x.manager salary (). Current commercial OODBs support efficient index-based associative access for path expressions <ref> [6, 7, 16, 18, 20] </ref>, while future OODBs should support indexes over methods and functions [14]. Such query languages are a good way to describe hoarding profiles, supporting both simple requests (e.g., prefetch all sections of the paper I am working on) and complex ones.
Reference: [7] <editor> O. Deux et al. </editor> <title> The O 2 System. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 34-48, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: These languages are similar to relational query languages, but have been extended to include object navigation via the traversal of representation-exposing path expressions, e.g., x.project.manager.salary, or, preferably, the invocation of arbitrary methods or functions, e.g., x.manager salary (). Current commercial OODBs support efficient index-based associative access for path expressions <ref> [6, 7, 16, 18, 20] </ref>, while future OODBs should support indexes over methods and functions [14]. Such query languages are a good way to describe hoarding profiles, supporting both simple requests (e.g., prefetch all sections of the paper I am working on) and complex ones.
Reference: [8] <author> A. Fekete, N. Lynch, M. Merritt, and W. Weihl. </author> <title> Commutativity-Based Locking for Nested Transactions. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 41(1) </volume> <pages> 65-156, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: the application should of course include lock timeouts or a means of explicitly releasing locks; thus the client actually holds a lease on the lock [12].) A third way to increase the likelihood of commit is to take advantage of object semantics to increase concurrency, by applying type-specific concurrency control <ref> [8, 23] </ref> instead of simple read-write locking . Herlihy [13] describes 4 type-specific optimistic concurrency control, which is the approach we would use for Thor objects. Briefly, pairwise conflict checks are specified for each pair of methods of a given type.
Reference: [9] <author> H. Garcia-Molina. </author> <title> Using Semantic Knowledge for Transaction Processing in a Distributed Database. </title> <journal> ACM TODS, </journal> <volume> 8(2) </volume> <pages> 186-213, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: Since the effects of aborted transactions are likely to be important to users, tools to help users recover are needed. To help the user recover requires saving context and allowing replay. There has been work in the database area on the recovery problem <ref> [9, 11] </ref>. (There has also been work on supporting recovery for write-write file conflicts in file systems [15].) In the best case, the system can simply re-run the transaction in the new state, but this works only if no user input is required.
Reference: [10] <author> S. Ghemawat. </author> <title> Disk Management for Object-Oriented Databases. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <note> 1995 in preparation. </note>
Reference-contexts: The coordinator records its decision on stable storage and notifies the client; it informs participants of the decision in the background. When a participant finds out about a commit, it installs new states for the modified objects (this does not require an immediate disk I/O <ref> [10, 21] </ref>) and sends invalidation messages to FEs that might contain copies of modified objects. An FE discards invalidated objects from its cache, aborts its current transaction if it used an invalidated object, and acknowledges the invalidation.
Reference: [11] <author> D. Gifford and J. Donahue. </author> <title> Coordinating Independent Atomic Actions. </title> <booktitle> In Proc. of IEEE CompCon85, </booktitle> <pages> pages 92-95, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: Since the effects of aborted transactions are likely to be important to users, tools to help users recover are needed. To help the user recover requires saving context and allowing replay. There has been work in the database area on the recovery problem <ref> [9, 11] </ref>. (There has also been work on supporting recovery for write-write file conflicts in file systems [15].) In the best case, the system can simply re-run the transaction in the new state, but this works only if no user input is required.
Reference: [12] <author> C. Gray and D. Cheriton. Leases: </author> <title> An Efficient Fault-Tolerant Mechanism for Distributed File Cache Consistency. </title> <booktitle> In Proc. 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 202-210, </pages> <year> 1989. </year>
Reference-contexts: To avoid permanent lockup due to a check-in that never has a corresponding check-out, the application should of course include lock timeouts or a means of explicitly releasing locks; thus the client actually holds a lease on the lock <ref> [12] </ref>.) A third way to increase the likelihood of commit is to take advantage of object semantics to increase concurrency, by applying type-specific concurrency control [8, 23] instead of simple read-write locking .
Reference: [13] <author> M. Herlihy. </author> <title> Apologizing Versus Asking Permission: Optimistic Concurrency Control for Abstract Data Types. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 15(1) </volume> <pages> 96-124, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Herlihy <ref> [13] </ref> describes 4 type-specific optimistic concurrency control, which is the approach we would use for Thor objects. Briefly, pairwise conflict checks are specified for each pair of methods of a given type.
Reference: [14] <author> D. Hwang and B. Liskov. </author> <title> Index Maintenance for Object-Oriented Databases Using Semantic Information. </title> <booktitle> Submitted to the 1995 ACM SIGMOD Int. Conf. on Mgmt. of Data, </booktitle> <month> May </month> <year> 1995. </year> <note> Available as Programming Methodology Group Memo 86, </note> <institution> MIT Laboratory for Computer Science. </institution>
Reference-contexts: Current commercial OODBs support efficient index-based associative access for path expressions [6, 7, 16, 18, 20], while future OODBs should support indexes over methods and functions <ref> [14] </ref>. Such query languages are a good way to describe hoarding profiles, supporting both simple requests (e.g., prefetch all sections of the paper I am working on) and complex ones.
Reference: [15] <author> P. Kumar and M. Satyanarayanan. </author> <title> Supporting Application Specific Resolution in an Optimistically Replicated File System. </title> <booktitle> In Proc. 14th Workshop on Workstation Operating Systems, </booktitle> <pages> pages 66-70, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: To help the user recover requires saving context and allowing replay. There has been work in the database area on the recovery problem [9, 11]. (There has also been work on supporting recovery for write-write file conflicts in file systems <ref> [15] </ref>.) In the best case, the system can simply re-run the transaction in the new state, but this works only if no user input is required.
Reference: [16] <author> C. Lamb et al. </author> <title> The ObjectStore Database System. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: These languages are similar to relational query languages, but have been extended to include object navigation via the traversal of representation-exposing path expressions, e.g., x.project.manager.salary, or, preferably, the invocation of arbitrary methods or functions, e.g., x.manager salary (). Current commercial OODBs support efficient index-based associative access for path expressions <ref> [6, 7, 16, 18, 20] </ref>, while future OODBs should support indexes over methods and functions [14]. Such query languages are a good way to describe hoarding profiles, supporting both simple requests (e.g., prefetch all sections of the paper I am working on) and complex ones.
Reference: [17] <author> B. Liskov, M. Day, and L. Shrira. </author> <title> Distributed Object Management in Thor. </title> <editor> In T. Ozsua et al., editors, </editor> <booktitle> Distributed Object Management, </booktitle> <pages> pages 79-91. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1994. </year>
Reference-contexts: An important point of this paper is that existing concepts from databases can be very helpful: our three main proposals all involve a novel application of earlier database work to this new domain. 2 Thor Thor and its implementation are described in <ref> [17] </ref>. This section gives a brief overview of those aspects of the system that are relevant for disconnected operation. Thor provides highly-reliable and highly-available storage for persistent objects at server machines.
Reference: [18] <author> D. Maier and J. Stein. </author> <title> Indexing in an Object-Oriented DBMS. </title> <booktitle> In Proc. 1986 Int. Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 171-182, </pages> <address> Pacific Grove, CA, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: These languages are similar to relational query languages, but have been extended to include object navigation via the traversal of representation-exposing path expressions, e.g., x.project.manager.salary, or, preferably, the invocation of arbitrary methods or functions, e.g., x.manager salary (). Current commercial OODBs support efficient index-based associative access for path expressions <ref> [6, 7, 16, 18, 20] </ref>, while future OODBs should support indexes over methods and functions [14]. Such query languages are a good way to describe hoarding profiles, supporting both simple requests (e.g., prefetch all sections of the paper I am working on) and complex ones.
Reference: [19] <author> W. Montgomery. </author> <title> Robust Concurrency Control for Distributed Information System. </title> <type> Technical Report MIT/LCS/TR-207, </type> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge MA, </address> <month> December </month> <year> 1978. </year>
Reference-contexts: Instead we provide a different kind of action, a tentative commit, which records an intention to commit and allows the client to start up the next transaction. Having tentative commits leads to dependent commits <ref> [19] </ref>: transaction T2 depends on T1 if it uses objects modified by T1 because if T1 ultimately aborts, so must T2. While Thor avoids the possibility of such cascaded aborts during normal operation, it cannot do this for a sequence of tentative commits during disconnect.
Reference: [20] <author> J. Orenstein et al. </author> <title> Query Processing in The ObjectStore Database System. </title> <booktitle> In Proc. 1991 ACM SIGMOD Int. Conf. on Mgmt. of Data, </booktitle> <pages> pages 171-182, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: These languages are similar to relational query languages, but have been extended to include object navigation via the traversal of representation-exposing path expressions, e.g., x.project.manager.salary, or, preferably, the invocation of arbitrary methods or functions, e.g., x.manager salary (). Current commercial OODBs support efficient index-based associative access for path expressions <ref> [6, 7, 16, 18, 20] </ref>, while future OODBs should support indexes over methods and functions [14]. Such query languages are a good way to describe hoarding profiles, supporting both simple requests (e.g., prefetch all sections of the paper I am working on) and complex ones.
Reference: [21] <author> J. O'Toole and L. Shrira. </author> <title> Opportunistic Log: Efficient Installation Reads in a Reliable Object Server. </title> <booktitle> In 1rst Symposium on Operating Systems Design and Implementation, </booktitle> <address> Monterey, CA, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: The coordinator records its decision on stable storage and notifies the client; it informs participants of the decision in the background. When a participant finds out about a commit, it installs new states for the modified objects (this does not require an immediate disk I/O <ref> [10, 21] </ref>) and sends invalidation messages to FEs that might contain copies of modified objects. An FE discards invalidated objects from its cache, aborts its current transaction if it used an invalidated object, and acknowledges the invalidation.
Reference: [22] <author> M. Satyanarayanan, J. Kistler, L. Mummert, M. Ebling, P. Kumar, and Q. Lu. </author> <title> Experience with Disconnected Operation in a Mobile Computing Environment. </title> <booktitle> In Proc. 1993 Usenix Symposium on Mobile and Location Independent Computing, </booktitle> <pages> pages 11-28, </pages> <address> Cambridge, MA, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: We propose to use hoarding queries for this purpose. The Coda system augments the usual LRU cache policy with user-supplied hoarding profiles to ensure that the right files are in a user's client cache on disconnect <ref> [22] </ref>; without such a mechanism, users would be unable to work on anything but their most recently accessed files while disconnected. Coda's hoarding profile language is tailored to the naming structure of a file system (path names with wildcards are used to name files and/or entire subtrees to be prefetched). <p> The set of object references captured in this way can be stored and later used in a hoarding query. Such a tool has been proposed for object prefetching [4]; it is similar to the file tracing tool provided by Coda <ref> [22] </ref> that helps users determine which hidden files are used by an application so that they can be included in their hoarding profiles. However, an OODB trace can include not only object identifiers but descriptions of the queries used during the trace run.
Reference: [23] <author> W. Weihl and B. Liskov. </author> <title> Implementation of Resilient, Atomic Data Types. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 7(2) </volume> <pages> 244-269, </pages> <month> April </month> <year> 1985. </year> <month> 6 </month>
Reference-contexts: the application should of course include lock timeouts or a means of explicitly releasing locks; thus the client actually holds a lease on the lock [12].) A third way to increase the likelihood of commit is to take advantage of object semantics to increase concurrency, by applying type-specific concurrency control <ref> [8, 23] </ref> instead of simple read-write locking . Herlihy [13] describes 4 type-specific optimistic concurrency control, which is the approach we would use for Thor objects. Briefly, pairwise conflict checks are specified for each pair of methods of a given type.
References-found: 23

