URL: ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/iucstr364.ps.gz
Refering-URL: http://www.cs.indiana.edu/scheme-repository/doc.publications.html
Root-URL: http://www.cs.indiana.edu
Title: A Simple Reflective Interpreter  Reflection and Meta-Level Architecture  
Author: Stanley Jefferson Daniel P. Friedman 
Date: November 4-7, 1992  
Note: IMSA '92 International Workshop on  Tokyo,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Bawden, A., </author> <title> Reification without evaluation, </title> <booktitle> Conference Record of the 1988 ACM Symposium on LISP and Functional Programming, </booktitle> <address> Snowbird, Utah, </address> <month> July </month> <year> 1988, </year> <pages> 342-351. </pages>
Reference-contexts: The levels are crucially connected by a mechanism that permits a program running at one level to provide code that is to run at the next higher level. Various accounts of the reflective tower architecture have been given including a meta-circular definition [9, 10], operational definitions <ref> [4, 1] </ref>, and denota-tional definitions based on the meta-continuation concept [12, 2]. We give another account that we believe is simpler and more easily understood than previous accounts. Our approach is to give a literal model of a finite reflective tower. <p> All are interpreters based on the reflective tower architecture described in section 2. I R models a finite reflective tower, whereas the others model an infinite reflective tower. All four languages are lexically scoped, higher order, applicative order dialects of Lisp. We do not include Stepper <ref> [1] </ref> because its reflective architecture differs substantially from that considered here. 3-Lisp differs in significant ways from other Lisp dialects. Before reflection is introduced, a semantically rationalized Lisp is defined.
Reference: [2] <author> Danvy, O., and Malmkjr, K., </author> <title> Intensions and Extensions in a Reflective Tower, </title> <booktitle> Conference Record of the 1988 ACM Symposium on LISP and Functional Programming, </booktitle> <address> Snowbird, Utah, </address> <month> July </month> <year> 1988, </year> <pages> 327-341. </pages>
Reference-contexts: That is, they permit the user to define new language constructs at the semantic level by effectively adding lines of code to the language processor itself. Lisp-based reflective programming languages, such as 3-Lisp [9, 10], Brown [12], and Blond <ref> [2] </ref>, provide such an extension capability by permitting user-level code to be run as if it were interpreter code with access to the interpreter's current expression, environment, and continuation. <p> Various accounts of the reflective tower architecture have been given including a meta-circular definition [9, 10], operational definitions [4, 1], and denota-tional definitions based on the meta-continuation concept <ref> [12, 2] </ref>. We give another account that we believe is simpler and more easily understood than previous accounts. Our approach is to give a literal model of a finite reflective tower. An interpreter for a small, simplified subset of Scheme [8] is implemented in Scheme.
Reference: [3] <author> Danvy, O., and Malmkjr, K., </author> <title> A Blond Primer, </title> <institution> DIKU Rapport, DIKU, Computer Science Dept., University of Copenhagen, Copenhagen, Denmark, </institution> <month> September </month> <year> 1988. </year> <note> [4] des Rivieres, </note> <author> J., and Smith, </author> <title> B.C., </title> <booktitle> The Implementation of Procedurally Reflective Languages, Proc. 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <month> August </month> <year> 1984, </year> <pages> 331-347. </pages> <note> [5] des Rivieres, </note> <author> J., </author> <title> Control-Related Meta-Level Facilities in LISP (Extended Abstract), Meta-Level Architectures and Reflection, </title> <editor> Patti Maes and Daniele Nardi (eds.), </editor> <publisher> North-Holland, </publisher> <year> 1988, </year> <pages> 101-110. </pages>
Reference: [6] <author> Friedman, D.P., and Wand, M., </author> <title> Reification: Reflection without Metaphysics, </title> <booktitle> Proc. 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <month> August </month> <year> 1984, </year> <pages> 348-355. </pages>
Reference: [7] <editor> Maes, P., and Nardi, D. (eds.), </editor> <title> Meta-Level Architectures and Reflection, </title> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference: [8] <editor> Rees, J., and Clinger, W., eds. </editor> <title> Revised 3 Report on the Algorithmic Language Scheme, </title> <journal> SIGPLAN Notices 21,12 (December, </journal> <year> 1986), </year> <pages> 37-79. </pages>
Reference-contexts: We give another account that we believe is simpler and more easily understood than previous accounts. Our approach is to give a literal model of a finite reflective tower. An interpreter for a small, simplified subset of Scheme <ref> [8] </ref> is implemented in Scheme. This interpreter is written in its own subset of Scheme so that it can literally run itself. This permits finite towers of the interpreter to be run (albeit inefficiently).
Reference: [9] <author> Smith, </author> <title> B.C., Reflection and Semantics in a Procedural Language, </title> <address> MIT-LCS-TR-272, Mass. </address> <institution> Inst. of Tech., </institution> <address> Cambridge, MA, </address> <month> January, </month> <year> 1982. </year>
Reference-contexts: 1 Introduction The principal characteristic of reflective programming languages is that they are extensible. That is, they permit the user to define new language constructs at the semantic level by effectively adding lines of code to the language processor itself. Lisp-based reflective programming languages, such as 3-Lisp <ref> [9, 10] </ref>, Brown [12], and Blond [2], provide such an extension capability by permitting user-level code to be run as if it were interpreter code with access to the interpreter's current expression, environment, and continuation. <p> With this language extension capability, otherwise primitive language constructs, such as catch, throw, call/cc, boundp, and quote, can be defined as user procedures. The reflective tower, first introduced by Smith <ref> [9, 10] </ref>, provides a unified and coherent architecture for reflective programming languages. The reflective tower is non-effectively described as an infinitely ascending tower of meta-circular interpreters. The interpreter at the bottom of the fl Supported by grant NSF CCR 89-01919. <p> The levels are crucially connected by a mechanism that permits a program running at one level to provide code that is to run at the next higher level. Various accounts of the reflective tower architecture have been given including a meta-circular definition <ref> [9, 10] </ref>, operational definitions [4, 1], and denota-tional definitions based on the meta-continuation concept [12, 2]. We give another account that we believe is simpler and more easily understood than previous accounts. Our approach is to give a literal model of a finite reflective tower. <p> The result is that semantical levels may only be crossed with the explicit use of up and down. Reflection in 3-Lisp is then described as in section 2. Meta-circular definitions of 3-Lisp are given in <ref> [9, 10, 11] </ref>. The meta-circular definition uses 3-Lisp to define 3-Lisp and hence is not well-founded. The definition of I R is similar to the meta-circular definition of 3-Lisp. Level shifting and meta-circular access are implicit in both definitions, and the code for applying reifiers is essentially identical. <p> The meta-circular definition of 3-Lisp can only be run by a 3-Lisp implementation. * It does not require an understanding of 3-Lisp's recon struction of evaluation and quotation. The non-reflective implementations <ref> [9, 4] </ref> of 3-Lisp are extremely operational. In order to operate efficiently, level shifting in the tower is explicitly modeled with a stack of continuations corresponding to the active levels of the tower. Full access to the interpreter, implied by meta-circularity, is explicitly simulated. <p> Our reflective interpreter illustrates how switching levels in the tower involves treating data as code and vice-versa. For those who are uncomfortable with this sort of semantical level crossing, it serves as additional motivation for understanding the reconstruction of evaluation and quotation in 3-Lisp. <ref> [9, 10] </ref>. Acknowledgements We are grateful to John Simmons for using the system and providing much helpful feedback. We would like to thank Jim des Rivieres, Steve Greenbaum, Evan Kirshenbaum, Daniel Kuokka, and Julia Lawall for their comments on earlier drafts of this paper.
Reference: [10] <author> Smith, </author> <title> B.C., Reflection and Semantics in Lisp, </title> <booktitle> Conf. Rec. 11th ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1984, </year> <pages> 23-35. </pages>
Reference-contexts: 1 Introduction The principal characteristic of reflective programming languages is that they are extensible. That is, they permit the user to define new language constructs at the semantic level by effectively adding lines of code to the language processor itself. Lisp-based reflective programming languages, such as 3-Lisp <ref> [9, 10] </ref>, Brown [12], and Blond [2], provide such an extension capability by permitting user-level code to be run as if it were interpreter code with access to the interpreter's current expression, environment, and continuation. <p> With this language extension capability, otherwise primitive language constructs, such as catch, throw, call/cc, boundp, and quote, can be defined as user procedures. The reflective tower, first introduced by Smith <ref> [9, 10] </ref>, provides a unified and coherent architecture for reflective programming languages. The reflective tower is non-effectively described as an infinitely ascending tower of meta-circular interpreters. The interpreter at the bottom of the fl Supported by grant NSF CCR 89-01919. <p> The levels are crucially connected by a mechanism that permits a program running at one level to provide code that is to run at the next higher level. Various accounts of the reflective tower architecture have been given including a meta-circular definition <ref> [9, 10] </ref>, operational definitions [4, 1], and denota-tional definitions based on the meta-continuation concept [12, 2]. We give another account that we believe is simpler and more easily understood than previous accounts. Our approach is to give a literal model of a finite reflective tower. <p> The full definition of I R appears in the appendix. The expression ((reifier-to-compound proc) (operands-part e) r k) is the essence of our reflective tower model. It is essentially identical to the corresponding expression (#(de-reflect proc!) args env cont) in the meta-circular definition of 3-Lisp <ref> [10] </ref>. The 3-Lisp procedure de-reflect performs the same function as the I R procedure reifier-to-compound: it converts the closure for a reifier into a closure for a compound procedure. <p> The result is that semantical levels may only be crossed with the explicit use of up and down. Reflection in 3-Lisp is then described as in section 2. Meta-circular definitions of 3-Lisp are given in <ref> [9, 10, 11] </ref>. The meta-circular definition uses 3-Lisp to define 3-Lisp and hence is not well-founded. The definition of I R is similar to the meta-circular definition of 3-Lisp. Level shifting and meta-circular access are implicit in both definitions, and the code for applying reifiers is essentially identical. <p> Our reflective interpreter illustrates how switching levels in the tower involves treating data as code and vice-versa. For those who are uncomfortable with this sort of semantical level crossing, it serves as additional motivation for understanding the reconstruction of evaluation and quotation in 3-Lisp. <ref> [9, 10] </ref>. Acknowledgements We are grateful to John Simmons for using the system and providing much helpful feedback. We would like to thank Jim des Rivieres, Steve Greenbaum, Evan Kirshenbaum, Daniel Kuokka, and Julia Lawall for their comments on earlier drafts of this paper.
Reference: [11] <author> Smith, B.C., and des Rivieres, J., </author> <title> Interim 3-LISP Reference Manual, </title> <journal> Intelligent Systems Laboratory, </journal> <note> Xerox PARC, </note> <institution> Palo Alto, California, </institution> <year> 1984. </year>
Reference-contexts: The result is that semantical levels may only be crossed with the explicit use of up and down. Reflection in 3-Lisp is then described as in section 2. Meta-circular definitions of 3-Lisp are given in <ref> [9, 10, 11] </ref>. The meta-circular definition uses 3-Lisp to define 3-Lisp and hence is not well-founded. The definition of I R is similar to the meta-circular definition of 3-Lisp. Level shifting and meta-circular access are implicit in both definitions, and the code for applying reifiers is essentially identical.
Reference: [12] <author> Wand, M., and Friedman, </author> <title> D.P., The Mystery of the Tower Revealed: a non-Reflective Description of the Reflective Tower, </title> <journal> Lisp and Symbolic Computation, </journal> <volume> vol. 1, no. 1, </volume> <month> June </month> <year> 1988, </year> <pages> 11-38. 55 </pages>
Reference-contexts: 1 Introduction The principal characteristic of reflective programming languages is that they are extensible. That is, they permit the user to define new language constructs at the semantic level by effectively adding lines of code to the language processor itself. Lisp-based reflective programming languages, such as 3-Lisp [9, 10], Brown <ref> [12] </ref>, and Blond [2], provide such an extension capability by permitting user-level code to be run as if it were interpreter code with access to the interpreter's current expression, environment, and continuation. <p> Various accounts of the reflective tower architecture have been given including a meta-circular definition [9, 10], operational definitions [4, 1], and denota-tional definitions based on the meta-continuation concept <ref> [12, 2] </ref>. We give another account that we believe is simpler and more easily understood than previous accounts. Our approach is to give a literal model of a finite reflective tower. An interpreter for a small, simplified subset of Scheme [8] is implemented in Scheme.
References-found: 10

