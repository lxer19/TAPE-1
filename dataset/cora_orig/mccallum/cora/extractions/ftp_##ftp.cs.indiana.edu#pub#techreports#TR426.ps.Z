URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR426.ps.Z
Refering-URL: http://www.cs.indiana.edu/hyplan/chaynes.html
Root-URL: 
Email: fchoppell,chaynesg@cs.indiana.edu  
Title: Diagnosis of Ill-typed Programs  
Author: Venkatesh Choppella and Christopher T. Haynes 
Address: USA  
Affiliation: Indiana University,  
Abstract: A framework, based on syntactic and type constraints, is provided for defining program slices that contribute to a given type error or similar syntactic property. We specify soundness, minimality and completeness criterion for these slices and outline an algorithm for their lazy generation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Beaven, M., and Stansifer, R. </author> <title> Explaining type errors in polymorphic languages. </title> <journal> ACM Letters on Programming Languages (1994). </journal>
Reference-contexts: Only parse tree nodes that are adjacent to the node where unification fails are considered. We demonstrate that more distant nodes may contribute to the error. Our algorithm employs adjacency in a type-constraint graph rather than the parse tree. Beaven and Stansifer <ref> [1] </ref> and Soosaipillai [19] develop a method of explaining the flow of type information in a parse tree. Duggan et al. [5] have developed a similar method.
Reference: [2] <author> Cardelli, L. </author> <title> Basic polymorphic typechecking. </title> <booktitle> Science of Computer Programming 8 (1987), </booktitle> <pages> 147-172. </pages>
Reference-contexts: The parse tree for e 0 is given in Figure 1 (a), in which each parse tree node is given a unique index, called its location. The type inference process may be thought of as generating type constraints (equations) as the expression is traversed <ref> [14, 2] </ref>. With each type constraint, we associate the location at which it was generated and the syntactic constraint involved. <p> Unification solves systems of constraints over terms generated over a free algebra. The reduction of the typability problem for an expression e consists of generating a system of constraints from e. It is well-known that the typability problem for if c is reducible to first-order unification <ref> [2, 14, 22] </ref>. We use if c - typability as the running example in this paper, but our techniques are applicable to a broad range of type inference systems and unification variants, including the ML type system and polymorphic recursion (where typability is reducible to semiunification [8]).
Reference: [3] <author> Choppella, V. </author> <title> Type-based diagnostic program analysis. </title> <type> PhD thesis, </type> <institution> Indiana University, </institution> <year> 1995. </year> <month> Forthcoming. </month>
Reference-contexts: The minimal E 0 s are obtained by a refinement to Port's algorithm that requires the inclusion of directed edges of the unfication graph in the specification of the path expressions. The refinement is straightforward and will be reported elsewhere <ref> [3] </ref>. Figure 10 shows the derivation of the minimal "proofs," along with the related syntactic and type constraints for the example of Section 3. 6 Polymorphism In this section we sketch how our analysis may be extended to ML-style polymorphic type reconstruction. <p> The graph rewrite rules implementing semiunification add not only new edges but also new vertices to the term graph. Port's technique can be extended to associate source information with each new edge (or vertex) in the type constraint graph. Details will be reported elsewhere <ref> [3] </ref>. 7 Conclusions Most systems of static program analysis provide too little or too much diagnostic information when the result expected by the user does not match the results of the analysis.
Reference: [4] <author> Damas, L., and Milner, R. </author> <title> Principal type-schemes for functional languages. </title> <booktitle> In Proc. 9th ACM Symp. on Principles of Programming Languages (January 1982), </booktitle> <pages> pp. 207-212. </pages>
Reference-contexts: Traditional presentations, on the other hand, employ side conditions that do not have the form of a type equation or inequation, for in the LET rule the side condition for "closing" over a type is expressed as a set equation <ref> [4, 15] </ref>. The set equation is neither a type inequation or equation. Henglein's framework enables the definition of e relation between syntactic constraints and type constraints; the traditional approach would require a third relational element not expressible as a type equation or inequation.
Reference: [5] <author> Duggan, D., Ophel, J., and Bent, F. </author> <title> Explaining type reconstruction. </title> <booktitle> In ACM SIGPLAN Programming Language Design and Implementation (June 1994), ACM. </booktitle>
Reference-contexts: We demonstrate that more distant nodes may contribute to the error. Our algorithm employs adjacency in a type-constraint graph rather than the parse tree. Beaven and Stansifer [1] and Soosaipillai [19] develop a method of explaining the flow of type information in a parse tree. Duggan et al. <ref> [5] </ref> have developed a similar method. While these techniques are useful for building a type debugging environment that guides the user by "explaining" the process of type inference, they are not designed to identify the source of a type error.
Reference: [6] <author> Gomard, C. K. </author> <title> Partial type inference for untyped functional programs. </title> <booktitle> In Proceedings of the 17th ACM Symposium on Programming Languages (1990). </booktitle>
Reference-contexts: The authors claim that their implementation associates text with type errors, but the details are not published. They provide no correctness criterion or characterization of their complex algorithm. Gomard <ref> [6] </ref> isolates the untypable parts of a program with a two-level syntax and type rules that employ a special type called "untyped." When an expression with well-typed subexpressions is ill-typed, the entire expression is flagged with no indication of which parts of the subexpressions contributed to the error.
Reference: [7] <author> Henglein, F. </author> <title> Efficient type inference for higher-order binding-time analysis. </title> <booktitle> In Functional Programming Languages and Computer Architecture (1991), </booktitle> <pages> pp. 448-472. </pages>
Reference-contexts: If the reduction is syntax-directed then every attribute constraint generated by the reduction is associated with some syntactic constraint. Our technique is directly applicable to the problem of diagnosing results of constraint-based binding-time analysis <ref> [7, 10] </ref>. Since well-annotatedness corresponds to well-typing, a program slice associated with an annotation of a particular subexpression will reveal those program elements that contribute to the subexpression's annotation. We intend to implement these techniques in a "debugging" front end of an existing type inference system.
Reference: [8] <author> Henglein, F. </author> <title> Type inference with polymorphic recursion. </title> <journal> ACM Transactions on Programming Languages and Systems 15, </journal> <month> 2 (April </month> <year> 1993), </year> <pages> 253-289. </pages>
Reference-contexts: We use if c - typability as the running example in this paper, but our techniques are applicable to a broad range of type inference systems and unification variants, including the ML type system and polymorphic recursion (where typability is reducible to semiunification <ref> [8] </ref>). A type equation, , is a tuple t : = t 0 , where t and t 0 are types. A system of type equations E is a multiset of type equations. <p> Rather than using generic type variables, we adopt a technique due to Henglein that reduces the type reconstruction problem of ML to solving a system of equations and inequations (SEI) by semiunification <ref> [8] </ref>. Type constraints are defined as type equations or inequations of the form t t 0 , where t and t 0 are type terms.
Reference: [9] <author> Johnson, G. F., and Walz, J. A. </author> <title> A maximum-flow approach to anomaly isolation in unification-based incremental type inference. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Programming Languages (1986), </booktitle> <pages> pp. 44-57. </pages>
Reference-contexts: For example, for xy:f (y x)(y 3)(not x), Wand's algorithm returns the reason list f (y 3); (not x)g. This set does not imply enough type constraints to derive the type error. The network flow approach of Johnson and Walz <ref> [9, 20] </ref> attempts to derive all "multiply contradictory hypotheses" of the type of a program variable and assign them relative frequencies. The authors claim that their implementation associates text with type errors, but the details are not published. They provide no correctness criterion or characterization of their complex algorithm.
Reference: [10] <author> Jones, N. D., Gomard, C. K., and Sestoft, P. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: If the reduction is syntax-directed then every attribute constraint generated by the reduction is associated with some syntactic constraint. Our technique is directly applicable to the problem of diagnosing results of constraint-based binding-time analysis <ref> [7, 10] </ref>. Since well-annotatedness corresponds to well-typing, a program slice associated with an annotation of a particular subexpression will reveal those program elements that contribute to the subexpression's annotation. We intend to implement these techniques in a "debugging" front end of an existing type inference system.
Reference: [11] <author> Lassez, J., Maher, M. J., and Marriot, K. </author> <title> Unification revisited. In Deductive Databases and Logic Programming, </title> <editor> J. Minker, Ed. </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1988, </year> <journal> ch. </journal> <volume> 15, </volume> <pages> pp. 587-625. </pages>
Reference-contexts: This information plays no role in the unification of the type equations, but is used for building slices that derive a particular type constraint. Standard presentations of rewrite rules transform the initial sysmtem of equations into "solved form" or fail <ref> [11, 12, 16] </ref>. Since our focus is on the sources of non unifiability, we instead adopt a presentation due to Port [17] in which there is no failure. Given a set of type constraints E, let E fl be the closure of E under the rewrite rules of Figure 7.
Reference: [12] <author> Martelli, A., and Montanari, U. </author> <title> An efficient unification algorithm. </title> <journal> ACM Transactions on Programming Languages and Systems 4, </journal> <month> 2 (April </month> <year> 1982), </year> <pages> 258-282. </pages>
Reference-contexts: This information plays no role in the unification of the type equations, but is used for building slices that derive a particular type constraint. Standard presentations of rewrite rules transform the initial sysmtem of equations into "solved form" or fail <ref> [11, 12, 16] </ref>. Since our focus is on the sources of non unifiability, we instead adopt a presentation due to Port [17] in which there is no failure. Given a set of type constraints E, let E fl be the closure of E under the rewrite rules of Figure 7.
Reference: [13] <author> Maruyama, H., Matsuyama, M., and Araki, K. </author> <title> Support tool and strategy for type error correction with 9 polymorphic types. </title> <booktitle> In Proceedings of the Sixteenth an-nual international computer software and applications conference, </booktitle> <address> Chicago (September 1992), </address> <publisher> IEEE, </publisher> <pages> pp. 287-293. </pages>
Reference-contexts: In other words, although his technique identifies untypable subprograms, it does not identify mini-mal slices of these subprograms. Maruyama et al. <ref> [13] </ref> use a tracing technique for type error analysis, but they employ a flawed heuristic. Only parse tree nodes that are adjacent to the node where unification fails are considered. We demonstrate that more distant nodes may contribute to the error.
Reference: [14] <author> Milner, R. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences 17 (1978), </journal> <pages> 348-375. </pages>
Reference-contexts: The parse tree for e 0 is given in Figure 1 (a), in which each parse tree node is given a unique index, called its location. The type inference process may be thought of as generating type constraints (equations) as the expression is traversed <ref> [14, 2] </ref>. With each type constraint, we associate the location at which it was generated and the syntactic constraint involved. <p> Unification solves systems of constraints over terms generated over a free algebra. The reduction of the typability problem for an expression e consists of generating a system of constraints from e. It is well-known that the typability problem for if c is reducible to first-order unification <ref> [2, 14, 22] </ref>. We use if c - typability as the running example in this paper, but our techniques are applicable to a broad range of type inference systems and unification variants, including the ML type system and polymorphic recursion (where typability is reducible to semiunification [8]).
Reference: [15] <author> Mitchell, J. C. </author> <title> Type systems for programming languages. </title> <booktitle> In Handbook of Theoretical Computer Science, </booktitle> <editor> van Leeuwen et al., Eds. </editor> <publisher> North-Holland, </publisher> <year> 1991. </year>
Reference-contexts: Traditional presentations, on the other hand, employ side conditions that do not have the form of a type equation or inequation, for in the LET rule the side condition for "closing" over a type is expressed as a set equation <ref> [4, 15] </ref>. The set equation is neither a type inequation or equation. Henglein's framework enables the definition of e relation between syntactic constraints and type constraints; the traditional approach would require a third relational element not expressible as a type equation or inequation.
Reference: [16] <author> Paterson, M., and Wegman, M. </author> <title> Linear unification. </title> <journal> Journal of Computer and System Sciences 16, </journal> <volume> 2 (1978), </volume> <pages> 158-167. </pages>
Reference-contexts: This information plays no role in the unification of the type equations, but is used for building slices that derive a particular type constraint. Standard presentations of rewrite rules transform the initial sysmtem of equations into "solved form" or fail <ref> [11, 12, 16] </ref>. Since our focus is on the sources of non unifiability, we instead adopt a presentation due to Port [17] in which there is no failure. Given a set of type constraints E, let E fl be the closure of E under the rewrite rules of Figure 7. <p> The rules for diagnostic unification are implemented in the standard manner using a term graph <ref> [16] </ref>. Constraints in E fl correspond to connectivity in the term graph. A functor clash corresponds to an undirected path between two nodes with different functor symbols. An occurs check error corresponds to a path consisting of undirected and directed edges (pointing either way) from a variable vertex to itself.
Reference: [17] <author> Port, G. S. </author> <title> A simple approach to finding the cause of non-unifiability. </title> <booktitle> In Logic Programming: Proceedings of the Fifth International Conference and Symposium (1988), </booktitle> <editor> R. A. Kowalski and K. A. Bowen, Eds., </editor> <publisher> MIT Press, </publisher> <pages> pp. 651-665. </pages>
Reference-contexts: Standard presentations of rewrite rules transform the initial sysmtem of equations into "solved form" or fail [11, 12, 16]. Since our focus is on the sources of non unifiability, we instead adopt a presentation due to Port <ref> [17] </ref> in which there is no failure. Given a set of type constraints E, let E fl be the closure of E under the rewrite rules of Figure 7. Definition 4.1: A type constraint ffi is any pair of the form t = t 0 or t t 0 . <p> Notation: E e denotes R (e). E ` ffi (read E derives ffi) denotes ffi 2 E fl . e ; ffi denotes E e ` ffi Theorem 1 (Port <ref> [17] </ref>) A system of type constraints E is non-unifiable if and only if E ` ffi for some error symptom ffi. The rules for diagnostic unification are implemented in the standard manner using a term graph [16]. Constraints in E fl correspond to connectivity in the term graph.
Reference: [18] <author> Reiter, R. </author> <title> A theory of diagnosis from first principles. </title> <booktitle> Artificial Intelligence 32 (1987), </booktitle> <pages> 57-95. </pages>
Reference-contexts: Program slicing techniques have been studied in the context of "automatic" run-time program debugging [23]. We demonstrate how program slices may be used to diagnose static program properites, including type error analysis. Our approach is related to the more general characterization of conflict sets and diagnosis developed by Reiter <ref> [18] </ref>. Our location sets can be viewed as Reiter's conflict sets. 3 Example In this section we informally introduce the key notions in our diagnosis of type errors by analysing a small ill-typed program in if c : the simply-typed lambda calculus with constants and if.
Reference: [19] <author> Soosaipillai, H. </author> <title> An explanation based polymorphic type checker for Standard ML. </title> <type> Master's thesis, </type> <institution> Heriot-Watt University, </institution> <year> 1990. </year>
Reference-contexts: Only parse tree nodes that are adjacent to the node where unification fails are considered. We demonstrate that more distant nodes may contribute to the error. Our algorithm employs adjacency in a type-constraint graph rather than the parse tree. Beaven and Stansifer [1] and Soosaipillai <ref> [19] </ref> develop a method of explaining the flow of type information in a parse tree. Duggan et al. [5] have developed a similar method.
Reference: [20] <author> Walz, J. A. </author> <title> Extending Attribute Grammars and Type Inference Algorithms. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> February </month> <year> 1989. </year> <type> TR 89-968. </type>
Reference-contexts: For example, for xy:f (y x)(y 3)(not x), Wand's algorithm returns the reason list f (y 3); (not x)g. This set does not imply enough type constraints to derive the type error. The network flow approach of Johnson and Walz <ref> [9, 20] </ref> attempts to derive all "multiply contradictory hypotheses" of the type of a program variable and assign them relative frequencies. The authors claim that their implementation associates text with type errors, but the details are not published. They provide no correctness criterion or characterization of their complex algorithm.
Reference: [21] <author> Wand, M. </author> <title> Finding the source of type errors. </title> <booktitle> In 13th Annual ACM Symp. on Principles of Prog. Languages. </booktitle> <month> (January </month> <year> 1986), </year> <pages> pp. 38-43. </pages>
Reference: [22] <author> Wand, M. </author> <title> A simple algorithm and proof for type inference. </title> <note> Fundamenta Informaticae 10 (1987), 115-122. </note>
Reference-contexts: Unification solves systems of constraints over terms generated over a free algebra. The reduction of the typability problem for an expression e consists of generating a system of constraints from e. It is well-known that the typability problem for if c is reducible to first-order unification <ref> [2, 14, 22] </ref>. We use if c - typability as the running example in this paper, but our techniques are applicable to a broad range of type inference systems and unification variants, including the ML type system and polymorphic recursion (where typability is reducible to semiunification [8]).
Reference: [23] <author> Weiser, M. </author> <title> Program slicing. </title> <journal> IEEE Transactins on Software Engineering 10, </journal> <volume> 4 (1984), </volume> <pages> 352-357. 10 </pages>
Reference-contexts: While these techniques are useful for building a type debugging environment that guides the user by "explaining" the process of type inference, they are not designed to identify the source of a type error. Program slicing techniques have been studied in the context of "automatic" run-time program debugging <ref> [23] </ref>. We demonstrate how program slices may be used to diagnose static program properites, including type error analysis. Our approach is related to the more general characterization of conflict sets and diagnosis developed by Reiter [18].
References-found: 23

