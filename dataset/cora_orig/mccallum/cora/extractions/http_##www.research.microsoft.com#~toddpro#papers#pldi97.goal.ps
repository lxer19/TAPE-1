URL: http://www.research.microsoft.com/~toddpro/papers/pldi97.goal.ps
Refering-URL: http://www.research.microsoft.com/~toddpro/
Root-URL: http://www.research.microsoft.com
Title: Simple Translation of Goal-Directed Evaluation  
Author: Todd A. Proebsting 
Affiliation: The University of Arizona  
Abstract: This paper presents a simple, powerful and flexible technique for reasoning about and translating the goal-directed evaluation of programming language constructs that either succeed (and generate sequences of values) or fail. The technique generalizes the Byrd Box, a well-known device for describing Prolog backtracking. 
Abstract-found: 1
Intro-found: 1
Reference: [Byr80] <author> Lawrence Byrd. </author> <title> Understanding the control of prolog programs. </title> <type> Technical Report 151, </type> <institution> University of Edinburgh, </institution> <year> 1980. </year>
Reference-contexts: The Prolog programming language derives much of its power from goal-directed evaluation (i.e., backtracking) in combination with unification <ref> [Byr80] </ref>. The Icon programming language is an expression-oriented fl Address: Todd A. <p> Unlike Icon, Prolog uses unification and backtracking to produce a sequence of substitutions. Nonetheless, their goal-directed evaluation mechanisms are similar in that expressions (calls in Prolog) are started, succeed or fail, and may be resumed. Byrd <ref> [Byr80] </ref> concisely summarized the execution of Prolog clauses by describing control-flow changes between pairs of calls via four ports: 2 start The start port is the initial entry point into the eval uation of a particular call. resume The resume port is the subsequent re-entry point for all re-evaluations of a <p> It is not clear if Byrd invented the four-port box for translation purposes, or for debugging purposes <ref> [Byr80] </ref>. It appears that Byrd used the boxes to model control flow between calls within a single clause, but not to model the flow of control between clauses within a procedure, nor to model the control-flow in and out of a procedure.
Reference: [Fin96] <author> Raphael A. Finkel. </author> <title> Advanced Programming Language Design. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1996. </year> <note> ISBN 0-8053-1192-0. </note>
Reference-contexts: Satisfying one call leads directly to the initial invocation of a subordinate call. Similarly, the failure of a call causes the re-evaluation of the invoking call. Finkel and Solomon <ref> [FS80, Fin96] </ref> independently developed a similar four-port model of control flow. They used it to describe the control flow of power loops. Power loops backtrack and thus the start/succeed/resume/fail model describes their behavior well.
Reference: [FS80] <author> Raphael Finkel and Marvin Solomon. </author> <title> Nested iterators and recursive backtracking. </title> <type> Technical Report 388, </type> <institution> University of Wisconsin-Madison, </institution> <month> June </month> <year> 1980. </year>
Reference-contexts: Satisfying one call leads directly to the initial invocation of a subordinate call. Similarly, the failure of a call causes the re-evaluation of the invoking call. Finkel and Solomon <ref> [FS80, Fin96] </ref> independently developed a similar four-port model of control flow. They used it to describe the control flow of power loops. Power loops backtrack and thus the start/succeed/resume/fail model describes their behavior well.
Reference: [GG83] <author> Ralph E. Griswold and Madge T. Griswold. </author> <title> The Icon Programming Language. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1983. </year> <note> ISBN 0-13-449777-5. </note>
Reference-contexts: of Arizona, Tucson, AZ 85721; Telephone: 520/621-4326; Email: todd@cs.arizona.edu. http://www.cs.arizona.edu/people/todd/ 1 It's a shame iterators were not adopted by the Java designers Java hype seems to have revived garbage collection and might have done the same for iterators. language that combines generators and goal-directed evaluation into a powerful control-flow mechanism <ref> [GG83] </ref>. One possible explanation for the slow adoption of generators and goal-directed evaluation into mainstream languages may be the perceived difficulty of implementing them correctly and efficiently. This papers presents a new technique for implementing goal-directed evaluation of expressions that generate a sequence of values.
Reference: [GG86] <author> Ralph E. Griswold and Madge T. Griswold. </author> <title> The Implementation of the Icon Programming Language. </title> <publisher> Princeton University Press, </publisher> <year> 1986. </year> <note> ISBN 0-691-08431-9. </note>
Reference-contexts: Many people have studied the translation of Icon's goal-directed evaluation. The popular Icon translation system, which translates Icon into a bytecode for interpretation, controls goal-directed evaluation by maintaining a stack of generator frames that indicate, among other things, what action should be taken upon failure <ref> [GG86] </ref>. Special byte-codes act to manipulate this stackby pushing, popping or modifying generator framesto achieve the desired goal-directed behavior. The new scheme requires nothing more powerful than conditional, direct, and indirect jumps. O'Bagy and Griswold developed a technique for translating Icon that utilized recursive interpreters [OG87].
Reference: [Gud92] <author> David A. Gudeman. </author> <title> Denotational semantics of a goal-directed language. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(1) </volume> <pages> 107-125, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: goto greater.fail to 2 .I 3 goto to 2 .code greater.resume to 2 .I to 2 .I + 1 to 2 .code if (to 2 .I&gt; 4) goto to 1 .resume mult.value to 1 .I * to 2 .I if (5 mult.value) goto greater.resume greater.value mult.value goto greater.succeed Page 5 <ref> [Gud92] </ref>. Different continuations for failure and success are maintained for each generator. While continuations can be compiled into efficient code they are notoriously difficult to understand, and few target languages directly support them.
Reference: [LSAS77] <author> B. Liskov, A. Snyder, R. Atkinson, and C. Schaffert. </author> <title> Abstraction mechanisms in CLU. </title> <journal> Communications of the ACM, </journal> (8):564-576, August 1977. 
Reference-contexts: As evidence, note that CLU-style iterators have been well-understood for around 20 years <ref> [LSAS77] </ref> and yet they appear in no mainstream language. 1 Generators (iterators) and goal-directed expression evaluation are extremely powerful control-flow mechanisms for succinctly expressing operations that operate over a sequence of values.
Reference: [OG87] <author> Janalee O'Bagy and Ralph E. Griswold. </author> <title> A recursive interpreter for the icon programming language. </title> <booktitle> In Proceedings of the SIGPLAN'87 Symposium on Interpreters and Interpretive Techniques, </booktitle> <pages> pages 138-149, </pages> <address> St. Paul, Min-nesota, </address> <month> June </month> <year> 1987. </year> <pages> Page 6 </pages>
Reference-contexts: Special byte-codes act to manipulate this stackby pushing, popping or modifying generator framesto achieve the desired goal-directed behavior. The new scheme requires nothing more powerful than conditional, direct, and indirect jumps. O'Bagy and Griswold developed a technique for translating Icon that utilized recursive interpreters <ref> [OG87] </ref>. The basic idea behind recursive interpreters for goal-directed evaluation is that each generator that produces a value does so by recursively invoking the interpreter. Doing so preserves (suspends) the generator's state for possible resumption when the just-invoked interpreter returns.
References-found: 8

