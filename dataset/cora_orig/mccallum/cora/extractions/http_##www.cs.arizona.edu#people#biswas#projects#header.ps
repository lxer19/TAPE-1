URL: http://www.cs.arizona.edu/people/biswas/projects/header.ps
Refering-URL: http://www.cs.arizona.edu/people/biswas/resume.html
Root-URL: http://www.cs.arizona.edu
Note: s  
Abstract-found: 0
Intro-found: 1
Reference: [ASU88] <author> Alfred V. Aho, Ravi Sethi, and Jeffery D. Ullman. </author> <booktitle> Compilers Principles, Techniques and Tools. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Chapter 4 deals with the data structures and implementation details of the project work. Chapter 5 contains some concluding remarks. Chapter 2 Data Flow Analysis Programs can be viewed as a collection of basic blocks/nodes with directed edges across nodes to represent the direction of program flow <ref> [ASU88] </ref>. Data flow can be in forward/backward direction or it could be bidirectional. For flow in the forward direction the out-properties of a node depend only on the in-property of the node and the statements in the node.
Reference: [CK84] <author> Keith D. Cooper and Ken Kennedy. </author> <title> Efficient computation of flow insensitive interprocedural summary information. </title> <journal> SIGPLAN Notices, </journal> <volume> 19(6) </volume> <pages> 247-258, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: In the latter case we must ensure the correct mapping of data items across procedures. For example global variables may be passed as actual parameters. * Aliasing Effect 3.3 A Framework for Interprocedural Analysis This section gives an overview of the framework adopted in <ref> [CK84] </ref> for global data flow analysis. <p> Using these set of equations one can compute the required data flow equations. The details can be looked up in <ref> [CK84] </ref> and [CK88]. CHAPTER 3. INTERPROCEDURAL DATA FLOW ANALYSIS 15 3.4 Horowitz, Reps and Sagiv Approach 3.4.1 Introduction The PFG used in this approach begins with the concepts used to build the PFG in Fig 3.2.
Reference: [CK88] <author> Keith D. Cooper and Ken Kennedy. </author> <title> Efficient computation of flow insensitive interprocedural summary information a correction. </title> <journal> SIGPLAN Notices, </journal> <volume> 23(4) </volume> <pages> 35-42, </pages> <year> 1988. </year>
Reference-contexts: For example global variables may be passed as actual parameters. * Aliasing Effect 3.3 A Framework for Interprocedural Analysis This section gives an overview of the framework adopted in [CK84] for global data flow analysis. The corrected paper is <ref> [CK88] </ref>. 3.3.1 Notations * s : any statement in the program. * e = &lt; u; v &gt; represents a call from procedure u to procedure v. * fp (p) = Set of formal parameters for procedure p. * ap (e) = Set of actual parameters across edge e. * gv <p> Using these set of equations one can compute the required data flow equations. The details can be looked up in [CK84] and <ref> [CK88] </ref>. CHAPTER 3. INTERPROCEDURAL DATA FLOW ANALYSIS 15 3.4 Horowitz, Reps and Sagiv Approach 3.4.1 Introduction The PFG used in this approach begins with the concepts used to build the PFG in Fig 3.2.
Reference: [Dha95] <author> D. M. Dhamdhere. </author> <title> Gensat a generator for static analysis and transformation programs. </title> <type> Technical report, </type> <institution> Indian Institute of Technology, Bombay, </institution> <year> 1995. </year>
Reference-contexts: The static analysis and program transformations similarly depend on the intended usage. GENSAT provides a specification language called GENPLUS to specify the details of the IR, the static analysis and the program transformations. <ref> [Dha95] </ref> and [Mol95] describe the IR specifications. By analyzing these specifications, GENSAT generates a suite of C++ programs collectively called SAT programs to process the intermediate representation and perform the program transformations. The SAT programs become a part of the PT tool being developed. <p> This section provides an overview of the usage of IRRGEN which takes as input the specification of the Intermediate Representation and generates the IR reader. A complete view can be obtained from <ref> [Dha95] </ref> and [Mol95]. GENSAT views the program flow graph as a collection of basic blocks. Each basic block is a collection of nodes. To site a trivial example, consider a language with only assignment statements. For this language the nodes would be variables, expressions and assignment statements.
Reference: [FH95] <author> Christopher W. Fraser and David R. Hanson. </author> <title> A Retargetable C Compiler. </title> <publisher> The Benjamin/Cummings publishing company, Inc, </publisher> <year> 1995. </year>
Reference-contexts: As an example consider the specifications for assignment and if statements given below. These specifications are a part of LCC IR <ref> [FH95] </ref>. 31 CHAPTER 4.
Reference: [Gup95] <author> Vijay Gupta. </author> <title> Optimizer generator system. </title> <type> Technical report, </type> <institution> Indian Institute of Technology, Bombay, </institution> <year> 1995. </year>
Reference: [Hec77] <author> Matthew S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1977. </year>
Reference-contexts: This computation is done only once. The results are used in global analysis where we iterate over the entire PFG till we reach a maximal fixed point <ref> [Hec77] </ref>. CHAPTER 2. DATA FLOW ANALYSIS 6 2.2.2 Set Representation of Information In the set implementation we make use of the actual data structure of a data item to represent an element in a set.
Reference: [KD94] <author> U. P. Khedkar and D. M. Dhamdhere. </author> <title> A generalized theory of bit vector data flow analysis. </title> <journal> ACM TOPLAS, </journal> <volume> 16(5) </volume> <pages> 1472-1511, </pages> <month> Sept </month> <year> 1994. </year>
Reference-contexts: GENSAT first constructs the program flow graph (PFG) and then applies a simple worklist based algorithm <ref> [KD94] </ref>, to obtain the data flow information. An important aspect of the algorithm is the method of representing information at the entry/exit of nodes. Two ways of representing data has been implemented in GENSAT viz. <p> Node and Edge functions : f f , f b , g f , g b . f f and f b represent flow through a node. g f and g b represent flow through edges. * Meet Operator (u) : The details of this operator can be found in <ref> [KD94] </ref>. * Boundaryinfo, Const in and Const out : Boundaryinfo represents informa tion present at the entry of starting node and exit of final node. Const in /Const out is associated with the values computed by a lower level data flow problems. CHAPTER 2. <p> CHAPTER 2. DATA FLOW ANALYSIS 8 * entry (G) and exit (G) : These functions return the entry and exit nodes of PFG "G" respectively. The algorithm used for intraprocedural data flow analysis in GENSAT, is a stan dard worklist based algorithm <ref> [KD94] </ref>. Chapter 3 Interprocedural Data Flow Analysis Interprocedural data flow analysis is the final step in data flow analysis of programs. There are a few nuances of interprocedural data flow analysis which do not occur during intraprocedural data flow analysis.
Reference: [KS92] <author> Jens Knoop and Bernhard Steffen. </author> <title> The interprocedural coincidence theorem. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> volume 641, </volume> <pages> pages 125-140. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1992. </year> <note> 62 REFERENCES 63 </note>
Reference-contexts: This directly mimics possible program execution: it "meets" all information corresponding to program paths reaching the program point under consideration. This results in an optimal result but in general is not effective <ref> [KS92] </ref>. * MFP (maximal fixed point). Here we iteratively approximate the greatest solution of a system of equations that express consistency between pre 4 CHAPTER 2. DATA FLOW ANALYSIS 5 conditions and post-conditions that are given in terms of data flow information. <p> For unidirectional data flow the pre-condition of a statement must be implied by the post-conditions of its predecessors and the post-conditions must be implied by the result of transforming the pre-condition according to the (abstract) meaning of the statement <ref> [KS92] </ref>. The iterative approach for MFP works only for monotonic frameworks (most data flow frameworks are monotonic). 2.2 Data Flow Analysis in GENSAT Data flow analysis in GENSAT is done using an algorithmic approach to the MFP solution.
Reference: [Mol95] <author> Suja Mol. </author> <title> Generator for static analysis and transformation programs. </title> <type> Master's thesis, </type> <institution> Indian Institute of Technology, Bombay, </institution> <year> 1995. </year>
Reference-contexts: The static analysis and program transformations similarly depend on the intended usage. GENSAT provides a specification language called GENPLUS to specify the details of the IR, the static analysis and the program transformations. [Dha95] and <ref> [Mol95] </ref> describe the IR specifications. By analyzing these specifications, GENSAT generates a suite of C++ programs collectively called SAT programs to process the intermediate representation and perform the program transformations. The SAT programs become a part of the PT tool being developed. <p> This section provides an overview of the usage of IRRGEN which takes as input the specification of the Intermediate Representation and generates the IR reader. A complete view can be obtained from [Dha95] and <ref> [Mol95] </ref>. GENSAT views the program flow graph as a collection of basic blocks. Each basic block is a collection of nodes. To site a trivial example, consider a language with only assignment statements. For this language the nodes would be variables, expressions and assignment statements.
Reference: [Ram96] <author> G. Janaki Ram. </author> <title> Extensions to data flow analysis in gensat. </title> <type> Technical report, </type> <institution> Indian Institute of Technology, Bombay, </institution> <year> 1996. </year>
Reference-contexts: The f i is used to consider the effect of a block/node N i (say) on information flowing through it. The u (meet) operator computes information present at entry/exit of nodes due to its predecessors/successors. The details can be found in <ref> [Ram96] </ref>. 2.2.3 Comparison of Bit Vectors and Sets * In the set representation, each element of the set can be a data structure designed by the compiler writer. <p> This is done by the function Invert Exploded Edges (). 4.3.2 Extensions to the "global prop" data structure As reported in <ref> [Ram96] </ref>, the solution for the entire problem is stored in a data structure called "global prop". <p> The lexical analyser and parser. 2. A suite of C++ programs defining functions such as f f ; f b ; g f etc. 3. An instantiation of the generic SplaySet data structure <ref> [Ram96] </ref>. 4. An instantiation of the generic alogrithm/iterator. 5. The main program. The details of items 1, 3 and 5 can be looked up in [Ram96]. 4.4.1 Function definition and generation We have already looked at the various data flow functions in section 2.3, viz Node and Edge functions, Confluence and <p> An instantiation of the generic SplaySet data structure <ref> [Ram96] </ref>. 4. An instantiation of the generic alogrithm/iterator. 5. The main program. The details of items 1, 3 and 5 can be looked up in [Ram96]. 4.4.1 Function definition and generation We have already looked at the various data flow functions in section 2.3, viz Node and Edge functions, Confluence and Meet operators and Boundary-info. The confluence operator, in the implementation of interprocedural data CHAPTER 4. <p> The confluence operator, in the implementation of interprocedural data CHAPTER 4. IMPLEMENTATION 43 flow analysis, has been assumed to be either union or intersection. Boundaryinfo can be specified by the user; in other cases it is either universal or empty. The method of function generation has been explained in <ref> [Ram96] </ref>, however there have been a few changes in the code generated. Here we will look at the code generated for Node funtions in a specific example. <p> This is the instantiation in the case of reaching definition problem of section 4.4.1. The function "f" referred to in the example is given in Appendix B, while functions "univ set", "getset" and "local set" are given in Appendix C. A similar example has been given in <ref> [Ram96] </ref>. However there are some variations in the generated code. * Functions for Meet and Confluence operators have been removed. * Functions for computation of universal and local sets have been included. It will be useful to compare the code given below with the one in section 5.1.7 of [Ram96]. global <p> in <ref> [Ram96] </ref>. However there are some variations in the generated code. * Functions for Meet and Confluence operators have been removed. * Functions for computation of universal and local sets have been included. It will be useful to compare the code given below with the one in section 5.1.7 of [Ram96]. global prop* Reach def; extern cfg Cfg GL; static element type set ff flow Reach def (element type set); static element type set fb flow Reach def (element type set); static element type set gf flow Reach def (element type set, element type set); static element type set gb flow <p> Local sets are computed using Equation 4.1. The functions corresonding to computation of universal and local sets are "univ set" and "local set" respectively. The C++ codes are given in Appendix C. The SplaySet structure <ref> [Ram96] </ref> has been used for storage purposes of such sets. Computation of the global set of items takes place in "univ set". 4.5 Implementation of the solver This section provides the implementation of the algorithm in GENSAT. <p> We also give an overview of working of the solver. 4.5.1 Data structure of the solver The definition of the data structure is shown below. It retains the essense of the data structure given in <ref> [Ram96] </ref>; however the function specifications are different to the suit the algorithm given in section 3.5. The correspondence between the names of the functions given here and in the alogrithm explain their role. The solver assumes that the flow and other functions are defined.
Reference: [TRH95] <author> M. Sagiv T. Reps and S. Horowitz. </author> <title> Precise interprocedural dataflow analysis via graph reachability. </title> <booktitle> In In Conference Record of the Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, </address> <month> Jan </month> <year> 1995. </year>
Reference-contexts: The detailed proof is given in <ref> [TRH95] </ref>. For the problem in Fig 3.4, the exploded supergraph is given in Fig 3.7. 3.4.3 Intersection Problems Intersection problems can be considered as a complement of a union problem. <p> It is easy to see that f 0 = (x - gen) [ (kill - gen), which is also of the gen/kill form. 3.5 Adaption of Tabulation Algorithm to GEN SAT In <ref> [TRH95] </ref> a tabulation algorithm has been given for doing interprocedural forward data flow analysis. This section presents a possible adaption of the tabulation algorithm to GENSAT. 3.5.1 Preliminaries The algorithm has 3 sets of edges associated with it: CHAPTER 3. INTERPROCEDURAL DATA FLOW ANALYSIS 21 1. <p> The other cases are simply propagation through the edges of the exploded graph. It is easy to see that the above algorithm does interprocedural data flow analysis by computing "meet-over-all-valid-paths"(MVP). The correctness of the above algorithm can be verified by looking at the original algorithm in <ref> [TRH95] </ref>. Implementation issues in this algorithm deal with: 1. cost of Worklist Manipulation 2. cost of installing Summary Edges 3. cost of closure steps Details of the above issues can be seen in [TRH95]. <p> The correctness of the above algorithm can be verified by looking at the original algorithm in <ref> [TRH95] </ref>. Implementation issues in this algorithm deal with: 1. cost of Worklist Manipulation 2. cost of installing Summary Edges 3. cost of closure steps Details of the above issues can be seen in [TRH95]. Chapter 4 Implementation The algorithm described in section 3.5 has been incorporated into GENSAT for the purpose of interprocedural data flow analysis. <p> Bit-vector and set implementation makes GENSAT capable of solving many bidirectional monotone intraprocedural data flow problems. The implementation, carried during the course of this project, has involved incorporation of interprocedural data flow analysis into GENSAT through a slight adaptation of the algorithm given in <ref> [TRH95] </ref>. Data flow results were collected for various data flow problems viz. reaching definitions, available expressions, live variables etc. IRRGEN, section 4.1, will have to be modified to take care of call, variable and entry/exit nodes.
References-found: 12

