URL: http://theory.lcs.mit.edu/~andrews/session-model.ps
Refering-URL: http://theory.lcs.mit.edu/~andrews/
Root-URL: 
Email: ylzg@theory.lcs.mit.edu  
Title: General Dynamic Routing with Per-Packet Delay Guarantees of O( distance 1 session rate  
Author: Matthew Andrews Antonio Fernandez Mor Harchol-Balter Tom Leighton Lisa Zhang 
Note: Supported by Army grant DAAH04-95-1-0607 and ARPA contract N00014-95-1-1246. Supported by NSF contract 9302476-CCR. Supported in part by the Spanish Ministry of Education. On leave from the Departamento  Supported by NSF Postdoctoral Fellowship in the Mathematical Sciences. Supported by an NSF graduate fellowship.  
Date: February 14, 1997  
Address: fandrews, anto, harchol, ftl,  Madrid.  
Affiliation: Laboratory for Computer Science, MIT.  de Arquitectura Tecnologa de Computadores, Universidad Politecnica de  
Abstract: A central issue in the design of modern communication networks is that of providing performance guarantees. This issue is particularly important if the networks support real-time traffic such as voice and video. The most critical performance parameter to bound is the delay experienced by a packet as it travels from its source to its destination. We study the dynamic routing problem in a connection-oriented packet-switching network. We consider a network with arbitrary topology on which a set of sessions is defined. Each session follows a fixed path from a source to a destination. Packets are injected continually in the sessions with rate r i for session i. The exact injection pattern is determined by an adversary. During any time step at most one packet may traverse any edge. Session paths may overlap subject to the constraint that the total rate of sessions using any particular edge is less than 1. We show the existence of an asymptotically-optimal schedule that achieves a delay bound of O(1=r i + d i ) with only constant queues at the switches. We also present a simple distributed algorithm that, with high probability, delivers every session i packet to its destination within O(1=r i + d i log(m=r min )) steps of its injection, where d i is the path length of session i, r min is the minimum session rate, and m is the number of edges in the network. Our results can be generalized to (leaky-bucket constrained) bursty traffic, where session i tolerates a burst size of b i . In this case, our delay bounds become O(b i =r i + d i ) and O(b i =r i + d i log(m=r min )), respectively. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Beck. </author> <title> An algorithmic approach to the lovasz local lemma I. Random Structures and Algorithms, </title> <address> 2(4):343 - 365, </address> <year> 1991. </year>
Reference-contexts: As in Section 2.1, we place initial tokens on the first edge of session i and then delay each token by an amount chosen independently and uniformly at random from <ref> [1; 1=r i ] </ref>. Suppose that a packet now has its initial token at time T . Then for the kth edge on this packet's path the packet is given a "deadline" of T + 2L (k 1) + L, where L = ff 2 log (mM ). <p> Consider any edge e and any t-frame, where log I (q) t 2 log I (q) . Assume each active packet in the region is delayed between the beginning of R and the beginning of the t-frame by a number of steps randomly, independently, and uniformly chosen from <ref> [1; s] </ref>. Then, for any constant k there is some value fl = fi (1)= p log I (q) such that the probability of having a relative congestion larger than r (1 + fl) on e during the t-frame is at most (I (q) ) k . <p> We shall reschedule each block B independently. During a block B we only delay active packets. For each block B, each active packet in B is assigned a delay randomly, uniformly, and independently chosen from <ref> [1; I (q) ] </ref>. An active packet p, whose assigned delay is x, is delayed in the first xI (q) steps of B once every I (q) steps. <p> (I (q) ) 2 the relative congestion is at most (1 + 2=I (q) )c (q) . 2 Now, in order to reduce the frame size in the fuzzy region, we consider only the active packets in each block B, and assign a delay randomly, independently, and uniformly chosen from <ref> [1; (I (q) ) 2 ] </ref> to each active packet. A packet p with delay x waits once every (I (q) ) 3 =x at the beginning of the block and once every (I (q) ) 3 =((I (q) ) 2 x) at the end. <p> Given the way delays are inserted, by the jth step an active packet with delay x has been delayed jx=(I (q) ) 3 steps. Thus, the delay of an active packet at the jth step is essentially a random value uniformly chosen from <ref> [1; j=I (q) ] </ref>. <p> For j I (q) log I (q) the value j=I (q) log 3 Note that before inserting delays, from Lemma 10 the relative congestion in any frame of length log 2 I (q) or larger in the interval <ref> [1; (I (q) ) 3 ] </ref> was at most (1 + fl 1 )c (q) . Then, we can make R = [1; (I (q) ) 3 ], r = (1 + fl 1 )c (q) , s = log I (q) , and t = I , and use Lemma <p> (q) log 3 Note that before inserting delays, from Lemma 10 the relative congestion in any frame of length log 2 I (q) or larger in the interval <ref> [1; (I (q) ) 3 ] </ref> was at most (1 + fl 1 )c (q) . Then, we can make R = [1; (I (q) ) 3 ], r = (1 + fl 1 )c (q) , s = log I (q) , and t = I , and use Lemma 8 to show, for any constant k 3 , the existence of some 3 = fi (1)= p log I (q) such <p> Lemma 13 The relative congestion in any frame of size log 4 I (q) or larger in the intervals <ref> [1; I (q) log I (q) ] </ref> and [2 (I (q) ) 3 + 3 (I (q) ) 2 I (q) log I (q) ; 2 (I (q) ) 3 + 3 (I (q) ) 2 ] is at most (1 + fl 1 )(1 + 1= log I (q) )c <p> Proof: Let us first consider some I -frame in <ref> [1; I (q) log 3 I (q) ] </ref>. Recall that, before inserting delays, the relative congestion for frames of size log 2 I (q) or more was at most (1 + fl 1 )c (q) . In the interval no packet is delayed more than log 3 I (q) steps. <p> Now we insert an initial delay for each session i packet, which has the effect of deferring the start time of the packet. We choose the delays uniformly from <ref> [1; ` i ] </ref>. After the initial delay each packet travels to its destination without further delay. Lemma 15 Consider a particular edge e and a particular t-frame during interval [T ; 2T ).
Reference: [2] <author> H. Chernoff. </author> <title> A measure of asymptotic efficiency for tests of a hypothesis based on the sum of observations. </title> <journal> Annals of Mathematical Statistics, </journal> <volume> 23:493 - 509, </volume> <year> 1952. </year>
Reference: [3] <author> F. T. Leighton, B. M. Maggs, and S. B. Rao. </author> <title> Packet routing and job-shop scheduling in O(congestion + dilation) steps. </title> <journal> Combinatorica, </journal> <volume> 14(2):167 - 186, </volume> <year> 1994. </year>
Reference-contexts: This delay insertion technique is introduced by Leighton et al. in <ref> [3, 4] </ref> in the context of static routing. (In the static routing problem, all packets are present in the network initially.) Since our main result employs many techniques from [3], we give a detailed summary in Section 3.1. 1.5 Our Result We first provide a distributed scheduler with a delay bound <p> This delay insertion technique is introduced by Leighton et al. in [3, 4] in the context of static routing. (In the static routing problem, all packets are present in the network initially.) Since our main result employs many techniques from <ref> [3] </ref>, we give a detailed summary in Section 3.1. 1.5 Our Result We first provide a distributed scheduler with a delay bound of O (1=r i + d i log (m=r min )), where m is the number of edges in the network and r min = min i r i <p> This is interesting because edge queues are much more expensive than initial queues in practice. * A consequence of our result is a packet-based bound, which improves upon the O (c + d) bound in <ref> [3] </ref> for the static problem (see Section 3.1 for the problem and parameter definitions). <p> for solving the static case, and in Section 3.2 we give an overview of the additional complexities that need to be addressed in the dynamic case. 3.1 A Bound of O (c + d) for Static Routing Leighton, Maggs and Rao consider the static routing problem for arbitrary networks in <ref> [3] </ref>. For static routing, all packets are present in the network initially. Each packet is associated with a source, a destination and a route. <p> In this schedule, at most one packet traverses each edge at each time step. A packet waits O (c + d) steps initially before leaving its source, and it waits O (1) steps to cross each edge afterwards. We summarize here the techniques in <ref> [3] </ref>. The strategy for constructing an efficient schedule is to make a succession of refinements to an initial schedule S (0) . In S (0) , each packet moves at every step until it reaches its destination. <p> A final schedule can be constructed by stretching S () by a constant factor. Each refinement is achieved by inserting delays to the packets. It is the central issue in <ref> [3] </ref> to show that a set of delays always exists satisfying the criteria in the table below. <p> Relative congestion S (q) I (q) c (q) Refinement poly log I (q) (1 + o (1))c (q) S (q+1) I (q+1) c (q+1) 3.2 A Bound of O (1=r i + d i ) for Dynamic Routing Our result for the dynamic routing problem is parallel to that in <ref> [3] </ref>. <p> (1=r i + d i ) steps initially before leaving its source, and it waits O (1) steps to cross each edge afterwards. 7 To achieve a session-based, end-to-end delay bound of O (1=r i + d i ) for our dynamic routing problem, we adopt the general approach in <ref> [3] </ref>. However, there are three major problems in transforming the solution for the static problem into a solution for the dynamic problem. In the following we present these three problems and their solutions. Problem 1: Infinite time In [3] all the packets to be scheduled are present initially. <p> ) for our dynamic routing problem, we adopt the general approach in <ref> [3] </ref>. However, there are three major problems in transforming the solution for the static problem into a solution for the dynamic problem. In the following we present these three problems and their solutions. Problem 1: Infinite time In [3] all the packets to be scheduled are present initially. In the dynamic model, packets are injected over an infinite time line. We would like to partition the infinite time line into finite time intervals which can be scheduled independently of each other.
Reference: [4] <author> F. T. Leighton, B. M. Maggs, and A. W. Richa. </author> <title> Fast algorithms for finding O(congestion + dilation) packet routing schedules. </title> <type> Technical report CMU-CS-96-152, </type> <institution> Carnegie Mellon University, </institution> <year> 1996. </year> <month> 24 </month>
Reference-contexts: This delay insertion technique is introduced by Leighton et al. in <ref> [3, 4] </ref> in the context of static routing. (In the static routing problem, all packets are present in the network initially.) Since our main result employs many techniques from [3], we give a detailed summary in Section 3.1. 1.5 Our Result We first provide a distributed scheduler with a delay bound
Reference: [5] <author> F. T. Leighton and G. Plaxton. </author> <title> Hypercubic sorting networks. </title> <note> SIAM Journal of Computing (to appear), </note> <year> 1997. </year>
Reference-contexts: Theorem B.1 in <ref> [5] </ref> shows that Pr [ Y b y c ] 1=2.
Reference: [6] <author> R. Ostrovsky and Y. Rabani. </author> <title> Local control packet switching algorithm. </title> <booktitle> In Proceedings of the 29th Annual ACM Symposium on Theory of Computing (to appear), </booktitle> <month> May </month> <year> 1997. </year>
Reference: [7] <author> A. K. Parekh and R. G. Gallager. </author> <title> A generalized processor sharing approach to flow control in integrated services networks: The single-node case. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(3):344 - 357, </volume> <year> 1993. </year>
Reference-contexts: The recent work seeks to close this gap. The best-known delay bound prior to 1996 is due to Parekh and Gallager <ref> [7, 8] </ref>. They provide an end-to-end delay guarantee of 2d i =r i [8, page 148], when all packets have the same size. Parekh and Gallager convert a GPS-algorithm (Generalized Processor Sharing) to a packet-based algorithm. Their solution is simple and distributed.
Reference: [8] <author> A. K. Parekh and R. G. Gallager. </author> <title> A generalized processor sharing approach to flow con-trol in integrated services networks: The multiple-node case. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 2(2):137 - 150, </volume> <year> 1994. </year>
Reference-contexts: The recent work seeks to close this gap. The best-known delay bound prior to 1996 is due to Parekh and Gallager <ref> [7, 8] </ref>. They provide an end-to-end delay guarantee of 2d i =r i [8, page 148], when all packets have the same size. Parekh and Gallager convert a GPS-algorithm (Generalized Processor Sharing) to a packet-based algorithm. Their solution is simple and distributed. <p> The recent work seeks to close this gap. The best-known delay bound prior to 1996 is due to Parekh and Gallager [7, 8]. They provide an end-to-end delay guarantee of 2d i =r i <ref> [8, page 148] </ref>, when all packets have the same size. Parekh and Gallager convert a GPS-algorithm (Generalized Processor Sharing) to a packet-based algorithm. Their solution is simple and distributed.
Reference: [9] <author> Y. Rabani and E. Tardos. </author> <title> Distributed packet switching in arbitrary networks. </title> <booktitle> In Proceedings of the 28th Annual ACM Symposium on Theory of Computing, </booktitle> <address> Philadelphia, PA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: They provide an end-to-end delay guarantee of 2d i =r i [8, page 148], when all packets have the same size. Parekh and Gallager convert a GPS-algorithm (Generalized Processor Sharing) to a packet-based algorithm. Their solution is simple and distributed. In their 1996 paper, Rabani and Tardos <ref> [9] </ref> produce an algorithm which routes every packet to its destination with probability 1p in time O (R)+(log fl p 1 ) O (log fl p 1 ) D +poly (log p 1 ), where R = max i (1=r i ) and D = max i d i .
Reference: [10] <author> J. Spencer. </author> <title> Ten Lectures on the Probabilistic Methods. </title> <publisher> Capital City Press, </publisher> <address> Philadelphia, Pennsylvania, </address> <year> 1994. </year>
References-found: 10

