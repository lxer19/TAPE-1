URL: ftp://ftp.ecrc.de/pub/eclipse/ECRC_tech_reports/reports/ECRC-92-18.ps.Z
Refering-URL: http://www.ecrc.de/eclipse/html/CHIC_Methodology.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: thom@ecrc.de  
Phone: TEL +49 89/926 99 0 FAX 926 99 170 TLX 521 6910  
Title: Constraint Simplification Rules  
Author: Thom Fruhwirth 
Address: ARABELLASTR. 17 D-8000 M UNCHEN 81, GERMANY  
Affiliation: EUROPEAN COMPUTER-INDUSTRY RESEARCH CENTRE ECRC GMBH,  
Abstract: technical report ECRC-92-18 
Abstract-found: 1
Intro-found: 1
Reference: [A*90] <author> A. Aggoun et al, </author> <title> CHIP Compiler Version 2 Reference Manual, and CHIP Interpreter Version 2.1 Reference Manual, </title> <address> ECRC, Munich, Germany, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: In Sepia-Prolog, this can be done with a meta-call that returns all delayed goals, so the case the guard delays can be determined. 10 Another possibility would be an if-then-else that delays until the condition either succeeds or fails. Such a construct was present in a version of CHIP <ref> [A*90] </ref>. Last but not least, if a user-defined constraint has been tried to match its associated SiRs, but was not replaced, we have to redelay it. In Sepia-Prolog, this is achieved by a special delay declaration. <p> There is work at ECRC on extending propagation over finite domains to arbitrary constraint domains [LPW92], and on compiling propagation into demons [Kue91]. These techniques are orthogonal to our approach and thus can be integrated. Demons <ref> [A*90] </ref> are essentially single-headed Replacement SiRs without guards. However, demons must define a constraint completely, no associated constraint definitions are allowed.
Reference: [AnPa90] <author> Andreoli J.-M. and Pareschi R., </author> <title> Linear Objects: Logical Processes with Built-In Inheritance, </title> <booktitle> Seventh Intl Conf on Logic Programming MIT Press 1990, </booktitle> <pages> pp. 495-510. </pages>
Reference-contexts: More recently, clauses with multiple head atoms were proposed to model parallelism and distributed processing, e.g. [Br90, AnPa91], or objects <ref> [Con88, AnPa90] </ref>. The similarity of the object oriented approaches with SiRs is merely syntactical. Rules about objects cannot be regarded as specifying constraint simplification. Object rules are supposed to model the change of objects, while SiRs model equivalence and implication of constraints. <p> He motivates so-called joint reductions of multiple atoms as analogous to production rules of expert system languages like OPS5. The examples given suggest the use of joint reductions to model objects in a spirit similar to what is worked out in <ref> [AnPa90] </ref>. Multi-headed Replacement SiRs are sufficient to simulate the parallel machine for multiset transformation proposed in [BCL88]. This machine is based on the chemical reaction metaphor as means to describe highly parallel computations for a wide spectrum of applications.
Reference: [AnPa91] <author> Andreoli J.-M. and Pareschi R., </author> <title> Communication as Fair Distribution of Knowledge, </title> <booktitle> Proceedings of OOPSLA '91. </booktitle>
Reference-contexts: More recently, clauses with multiple head atoms were proposed to model parallelism and distributed processing, e.g. <ref> [Br90, AnPa91] </ref>, or objects [Con88, AnPa90]. The similarity of the object oriented approaches with SiRs is merely syntactical. Rules about objects cannot be regarded as specifying constraint simplification. Object rules are supposed to model the change of objects, while SiRs model equivalence and implication of constraints.
Reference: [ApPe90] <author> K. R. Apt and D. Pedreschi, </author> <title> Studies in Pure Prolog: Termination, </title> <booktitle> ESPRIT Computational Logic Symposium, Springer 1990, </booktitle> <pages> pp. 150-176. 15 </pages>
Reference-contexts: Correctness has been discussed in the previous section on declarative semantics. 3.1 Termination and Confluence Termination is a highly desirable property which has been studied in many different contexts. In particular, termination proofs for sets of SiRs can benefit from work in rewriting systems [Der87] and logic programming <ref> [Plu90, VeDe91, Bez89, ApPe90] </ref>. If a set of SiRs is terminating, then there is no simplification step from any resolvent consisting of infinitely many derivation steps. Finding a suitable termination order may need user intervention.
Reference: [BCL88] <author> Banatre J.-P., Coutant A. and Le Metayer D., </author> <title> A Parallel Machine for Multiset Trans--formation and its Programming Style, </title> <booktitle> Future Generation Computer Systems 4 </booktitle> <pages> 133-144, </pages> <year> 1988. </year>
Reference-contexts: The examples given suggest the use of joint reductions to model objects in a spirit similar to what is worked out in [AnPa90]. Multi-headed Replacement SiRs are sufficient to simulate the parallel machine for multiset transformation proposed in <ref> [BCL88] </ref>. This machine is based on the chemical reaction metaphor as means to describe highly parallel computations for a wide spectrum of applications. The proposed implementation on a vector architecture may also be useful for implementing SiRs. Following [BCL88], we implemented the sieve of Eratosthenes to compute primes simply as: primes <p> are sufficient to simulate the parallel machine for multiset transformation proposed in <ref> [BCL88] </ref>. This machine is based on the chemical reaction metaphor as means to describe highly parallel computations for a wide spectrum of applications. The proposed implementation on a vector architecture may also be useful for implementing SiRs. Following [BCL88], we implemented the sieve of Eratosthenes to compute primes simply as: primes (1) , true. primes (N) , N&gt;1 | M is N-1, prime (N),primes (M). prime (I),prime (J) , 0 is J mod I | prime (I). % J is a multiple of I The conditional answer to the
Reference: [Bez89] <author> M. Bezem, </author> <title> Characterizing Termination of Logic Programs with Level Mappings, </title> <booktitle> North American Conference on Logic Programming, </booktitle> <publisher> MIT Press 1989, </publisher> <pages> pp. 69-80. </pages>
Reference-contexts: Correctness has been discussed in the previous section on declarative semantics. 3.1 Termination and Confluence Termination is a highly desirable property which has been studied in many different contexts. In particular, termination proofs for sets of SiRs can benefit from work in rewriting systems [Der87] and logic programming <ref> [Plu90, VeDe91, Bez89, ApPe90] </ref>. If a set of SiRs is terminating, then there is no simplification step from any resolvent consisting of infinitely many derivation steps. Finding a suitable termination order may need user intervention.
Reference: [Br90] <author> Brogi A., </author> <title> AND-Parallelism without Shared Variables, </title> <booktitle> Proc of the Seventh Intl Conf on Logic Programming MIT Press 1990, </booktitle> <pages> pp. 306-321. </pages>
Reference-contexts: More recently, clauses with multiple head atoms were proposed to model parallelism and distributed processing, e.g. <ref> [Br90, AnPa91] </ref>, or objects [Con88, AnPa90]. The similarity of the object oriented approaches with SiRs is merely syntactical. Rules about objects cannot be regarded as specifying constraint simplification. Object rules are supposed to model the change of objects, while SiRs model equivalence and implication of constraints.
Reference: [CAL88] <editor> Aiba A. et al, </editor> <booktitle> Constraint Logic Programming Language CAL, Int Conf on Fifth Generation Computer Systems, 1988, </booktitle> <publisher> Ohmsha Publishers, </publisher> <address> Tokyo, </address> <pages> pp. 263-276. </pages>
Reference: [Coh88] <author> J. Cohen, </author> <title> A View of the Origins and Development of Prolog, </title> <journal> CACM 31(1) </journal> <pages> 26-36, </pages> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: Like most logic programming languages, AKL itself does not support two of the essential features for defining simplification of user-defined constraints: Augmentation rules and multiple head atoms. 6.3 Multiple Head Atoms According to <ref> [Coh88] </ref> at the very beginning of the development of Prolog in the early 70's by Colmerauer and Kowalski, experiments were performed with clauses having multiple head atoms. More recently, clauses with multiple head atoms were proposed to model parallelism and distributed processing, e.g. [Br90, AnPa91], or objects [Con88, AnPa90].
Reference: [Coh90] <author> J. Cohen, </author> <title> Constraint Logic Programming Languages, </title> <journal> CACM 33(7) </journal> <pages> 52-68, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Further optimisations are possible, for example using a dynamic shortest-path algorithm. If further speed-up is needed, once the prototype has been established and "tuned" as required, it can be reworked in a low-level language. 6 Related Work 6.1 Constraint Logic Programming Languages Current constraint logic programming languages <ref> [VH91, Coh90, Fru90] </ref> are not extensible, they do not allow for user-defined constraints. The exception to the rule is the constraint logic programming CHIP [VH89]. The general technique of propagation is employed over finite domains.
Reference: [Con88] <author> Conery J. S., </author> <title> Logical Objects, </title> <booktitle> Proc of the Fifth Intl Conf and Symp on Logic Programming MIT Press 1988, </booktitle> <pages> pp. 420-434. </pages>
Reference-contexts: More recently, clauses with multiple head atoms were proposed to model parallelism and distributed processing, e.g. [Br90, AnPa91], or objects <ref> [Con88, AnPa90] </ref>. The similarity of the object oriented approaches with SiRs is merely syntactical. Rules about objects cannot be regarded as specifying constraint simplification. Object rules are supposed to model the change of objects, while SiRs model equivalence and implication of constraints.
Reference: [DO88] <author> Dershowitz N. and Okada M., </author> <title> Conditional Equational Programming and the Theory of Conditional Term Rewriting, </title> <booktitle> Int Conf on Fifth Generation Computer Systems, Ohmsha 1988, Tokyo, </booktitle> <pages> pp. 337-346 </pages>
Reference-contexts: Of course, adding a SiR implies computing new critical pairs. Orientation of the critical pair is based on the termination order and may fail. Such unorientable rules can be oriented using unfailing completion <ref> [Kir89, KR89, DO88] </ref> by adding an appropriate ordering constraint in the guard.
Reference: [Der87] <author> N. Dershowitz, </author> <title> Termination of Rewriting, </title> <journal> Journal of Symbolic Computation, </journal> 3(1+2):69-116, 1987. 
Reference-contexts: Correctness has been discussed in the previous section on declarative semantics. 3.1 Termination and Confluence Termination is a highly desirable property which has been studied in many different contexts. In particular, termination proofs for sets of SiRs can benefit from work in rewriting systems <ref> [Der87] </ref> and logic programming [Plu90, VeDe91, Bez89, ApPe90]. If a set of SiRs is terminating, then there is no simplification step from any resolvent consisting of infinitely many derivation steps. Finding a suitable termination order may need user intervention.
Reference: [DMP91] <author> R. Dechter, I. Meiri and J. Pearl, </author> <title> Temporal Constraint Networks, </title> <journal> Journal of Artificial Intelligence 49 </journal> <pages> 61-95, </pages> <year> 1991. </year>
Reference-contexts: Finite domains over equalities and inequalities were implemented as introduced in CHIP [VH89]. In terminological reasoning, the constraint simplifier can simplify and prove inconsistency of attributive concept definitions. We plan to extend this application to cover types and subsume finite domains. A constraint solver for temporal time point constraints <ref> [DMP91] </ref> was developed step by step starting from the solver for inequalities. We give a short presentation of this idea in the next section. A generic constraint solver for qualitative and quantitative temporal constraints over points and intervals based on path consistency is described in [Fru93]. <p> This is exactly the notation used in <ref> [DMP91] </ref>. callable X =&lt; Y =&lt; Z if bound (X),ground (Y),bound (Y). X =&lt; Y =&lt; Z:- call (X =&lt; Y, sepia), call (Y =&lt; Z, sepia). callable X =&lt;* Y =&lt;* Z if bound (X),ground (Y),bound (Y).
Reference: [Ea70] <author> J. Earley, </author> <title> An Efficient Context-Free Parsing Algorithm, </title> <journal> CACM, </journal> <volume> 13(2), </volume> <year> 1970. </year>
Reference-contexts: The term manipulation CS turns the built-in predicates functor, arg and =.. into user-defined constraints. SiRs have also been used as a committed choice programming language on their own. Examples from [Sha89] as well as the basics of an Earley parser <ref> [Ea70] </ref> and a distributed shortest path algorithm have been implemented. These constraint solvers back up our claim that it is possible to conveniently define constraint solvers with SiRs. This is because one can directly express the essence of constraint evaluation, the simplification of constraints, without worrying about implementation details.
Reference: [FL88] <author> Falaschi M. and Levi G., </author> <title> Finite Failure and Partial Computations in Concurrent Logic Languages, </title> <booktitle> Int Conf on Fifth Generation Computer Systems, Ohmsha 1988, Tokyo, </booktitle> <pages> pp. 364-381. </pages>
Reference: [Fra90] <author> T. Franzen, </author> <title> Formal Aspects of Kernel Andorra: I, </title> <institution> SICS Research Report R90008, </institution> <month> May </month> <year> 1990, </year> <institution> Swedish Institute of Computer Science, Kista, Sweden. </institution>
Reference: [Fru90] <author> Fruhwirth T., </author> <title> Constraint Logic Programming An Overview, </title> <type> Technical Report E181-2, </type> <institution> Christian Doppler Laboratory For Expert Systems, Vienna Austria, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: Further optimisations are possible, for example using a dynamic shortest-path algorithm. If further speed-up is needed, once the prototype has been established and "tuned" as required, it can be reworked in a low-level language. 6 Related Work 6.1 Constraint Logic Programming Languages Current constraint logic programming languages <ref> [VH91, Coh90, Fru90] </ref> are not extensible, they do not allow for user-defined constraints. The exception to the rule is the constraint logic programming CHIP [VH89]. The general technique of propagation is employed over finite domains.
Reference: [Fru91] <author> Fruhwirth T., </author> <title> Constraint Simplification Rules, Internal Report LP-63, </title> <address> ECRC Mu-nich, Germany, </address> <month> October </month> <year> 1991. </year>
Reference: [Fru93] <author> Fruhwirth T., </author> <title> Temporal Reasoning with Constraint Handling Rules, </title> <type> Technical Report Core-93-8, </type> <institution> ECRC Munich, Germany, </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: A combination with generalised propagation [LPW92] is planned. With the help of the prototype, we designed constraint solvers with SiRs for * n-queens, * inequalities, * booleans, * finite domains (a la CHIP), * terminological reasoning [FrHa93], * temporal reasoning <ref> [Fru93] </ref>, * real closed fields (a la CLP (R)), * term manipulation. 2 Do not confuse with Clarks completion of logic programs. 9 Typically it took only a few days to produce a reasonable prototype. <p> We give a short presentation of this idea in the next section. A generic constraint solver for qualitative and quantitative temporal constraints over points and intervals based on path consistency is described in <ref> [Fru93] </ref>. With real closed fields we mean a CLP (R)-like solver that runs the examples that are distributed with the CLP (R) implementation [Ja*90]. The solver was developed by a straightforward extension of Gaussian elimination with inequalities.
Reference: [FrHa93] <author> Fruhwirth T. and Hanschke P., </author> <title> Terminological Reasoning with Constraint Handling Rules, </title> <type> Technical Report, </type> <note> in preparation, </note> <institution> ECRC Munich, Germany, </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: A combination with generalised propagation [LPW92] is planned. With the help of the prototype, we designed constraint solvers with SiRs for * n-queens, * inequalities, * booleans, * finite domains (a la CHIP), * terminological reasoning <ref> [FrHa93] </ref>, * temporal reasoning [Fru93], * real closed fields (a la CLP (R)), * term manipulation. 2 Do not confuse with Clarks completion of logic programs. 9 Typically it took only a few days to produce a reasonable prototype.
Reference: [Gal86] <author> J. H. Gallier, </author> <title> Logic for Computer Science: Foundations of Automated Theorem Proving, </title> <publisher> Harper and Row, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: introduction to automated theorem proving is <ref> [Gal86] </ref>. For the relationship of automated theorem proving and logic programming we refer the reader to [WoMc91]. Also note that completion of rewrite systems can serve as a theorem proving procedure [Hs85, JSC91].
Reference: [Gr89] <author> T. Graf, </author> <title> Raisonnement sur les contraintes en programmation en logique, </title> <type> Ph.D. Thesis, </type> <institution> Version of June 1989 Universite de Nice, France, </institution> <note> September 1989 (in French). 16 </note>
Reference-contexts: These techniques are orthogonal to our approach and thus can be integrated. Demons [A*90] are essentially single-headed Replacement SiRs without guards. However, demons must define a constraint completely, no associated constraint definitions are allowed. One version of CHIP also included forward rules <ref> [Gr89] </ref>, which correspond to SiRs without guards. [Gr89] also gives a detailed account of the semantics of forward rules and therefore SiRs without guards. In this sense, SiRs can be seen as an extension of the work on demons and forward rules in CHIP. <p> These techniques are orthogonal to our approach and thus can be integrated. Demons [A*90] are essentially single-headed Replacement SiRs without guards. However, demons must define a constraint completely, no associated constraint definitions are allowed. One version of CHIP also included forward rules <ref> [Gr89] </ref>, which correspond to SiRs without guards. [Gr89] also gives a detailed account of the semantics of forward rules and therefore SiRs without guards. In this sense, SiRs can be seen as an extension of the work on demons and forward rules in CHIP.
Reference: [HA88] <author> Hewitt C. and Agha G., </author> <title> Guarded Horn Clause Languages: Are they Deductive and Logical?, </title> <booktitle> Int Conf on Fifth Generation Computer Systems, Ohmsha 1988, Tokyo, </booktitle> <pages> pp. 650-657. </pages>
Reference: [HaJa90] <author> Haridi S. and Janson S., </author> <title> Kernel Andorra Prolog and its Computation Model, </title> <booktitle> Seventh Int Conference on Logic Programming, </booktitle> <publisher> MIT Press 1990, </publisher> <pages> pp. 31-46. </pages>
Reference-contexts: The Andorra Model of D.H.D. Warren for parallel computation has inspired a rapid development of numerous languages and language schemes. The Andorra Kernel Language (AKL) [JaHa91] is a guarded language with built-in constraints based on an instance of the Kernel Andorra Prolog control framework <ref> [HaJa90] </ref>. AKL combines don't care nondeterminism and don't know nondeterministism with the help of different guard operators. There are three kinds of guard operators, namely cut, commit and wait.
Reference: [Hs85] <author> Hsiang J., </author> <title> Refutational Theorem Proving Using Term-Rewriting Systems, </title> <booktitle> Artificial Intelligence 25(3), </booktitle> <publisher> Elsevier, </publisher> <month> March </month> <year> 1985, </year> <pages> pp. 255-300. </pages>
Reference-contexts: introduction to automated theorem proving is [Gal86]. For the relationship of automated theorem proving and logic programming we refer the reader to [WoMc91]. Also note that completion of rewrite systems can serve as a theorem proving procedure <ref> [Hs85, JSC91] </ref>. Correctness has been discussed in the previous section on declarative semantics. 3.1 Termination and Confluence Termination is a highly desirable property which has been studied in many different contexts.
Reference: [JSC91] <editor> Special Issue on Rewriting Techniques in Theorem Proving, Bachmair L. and Hsiang J. (eds), </editor> <booktitle> Journal of Symbolic Computation, </booktitle> <pages> 11(1-2), </pages> <publisher> Academic Press, </publisher> <month> Jan-Feb </month> <year> 1991. </year>
Reference-contexts: introduction to automated theorem proving is [Gal86]. For the relationship of automated theorem proving and logic programming we refer the reader to [WoMc91]. Also note that completion of rewrite systems can serve as a theorem proving procedure <ref> [Hs85, JSC91] </ref>. Correctness has been discussed in the previous section on declarative semantics. 3.1 Termination and Confluence Termination is a highly desirable property which has been studied in many different contexts.
Reference: [Ja*90] <author> J. </author> <title> Jaffar et al The CLP(R) Language and System, </title> <type> Research Report RC 16292, </type> <month> November </month> <year> 1990, </year> <institution> IBM T.J. Watson Research Center. </institution>
Reference-contexts: A generic constraint solver for qualitative and quantitative temporal constraints over points and intervals based on path consistency is described in [Fru93]. With real closed fields we mean a CLP (R)-like solver that runs the examples that are distributed with the CLP (R) implementation <ref> [Ja*90] </ref>. The solver was developed by a straightforward extension of Gaussian elimination with inequalities. Recently we have connected our solver to one for nonlinear polynomials based on Groebner Bases [Mon92]. The term manipulation CS turns the built-in predicates functor, arg and =.. into user-defined constraints.
Reference: [JaHa91] <author> S. Janson and S. Haradi, </author> <title> Programming Paradigms of the Andorra Kernel Language, Draft of March 13, </title> <note> 1991, accepted at ILPS 91 in San Diego, </note> <institution> Swedish Institute of Computer Science, Kista, Sweden. </institution>
Reference-contexts: The Andorra Model of D.H.D. Warren for parallel computation has inspired a rapid development of numerous languages and language schemes. The Andorra Kernel Language (AKL) <ref> [JaHa91] </ref> is a guarded language with built-in constraints based on an instance of the Kernel Andorra Prolog control framework [HaJa90]. AKL combines don't care nondeterminism and don't know nondeterministism with the help of different guard operators. There are three kinds of guard operators, namely cut, commit and wait.
Reference: [JaLa87] <author> J. Jaffar and J.-L. Lassez, </author> <title> Constraint Logic Programming, </title> <booktitle> ACM 14th POPL 87, </booktitle> <address> Munich, Germany, </address> <month> January </month> <year> 1987, </year> <pages> pp. 111-119. </pages>
Reference: [KR89] <author> Kaplan S. and Remy J.-L., </author> <title> Completion Algorithms for Conditional Rewriting Systems, Chapter 5 in Resolution of Equations in Algebraic Structures, Volume 2 Rewriting Techniques, </title> <editor> Ait-Kaci H. and Nivat M. (eds), </editor> <publisher> Academic Press 1989. </publisher>
Reference-contexts: Of course, adding a SiR implies computing new critical pairs. Orientation of the critical pair is based on the termination order and may fail. Such unorientable rules can be oriented using unfailing completion <ref> [Kir89, KR89, DO88] </ref> by adding an appropriate ordering constraint in the guard.
Reference: [Kir89] <author> C. Kirchner and H. Kirchner, </author> <title> Rewriting: </title> <journal> Theory and Applications, </journal> <note> Working paper for a D.E.A. </note> <institution> lecture at the University of Nancy I, France, </institution> <year> 1989. </year>
Reference-contexts: Syntactically different constraint evaluations might also arise if combined solvers share constraints, depending on which solver comes first. To show that a set of SiRs is locally confluent, we employ a variant of the well-known completion 2 procedure originally conceived by Knuth and Bendix <ref> [Kir89] </ref>. For some contrived examples, any completion procedure may not terminate. For each pair of SiRs whose head atoms overlap, so-called critical pairs taking their bodies are produced. <p> Of course, adding a SiR implies computing new critical pairs. Orientation of the critical pair is based on the termination order and may fail. Such unorientable rules can be oriented using unfailing completion <ref> [Kir89, KR89, DO88] </ref> by adding an appropriate ordering constraint in the guard.
Reference: [Kue91] <author> Kuchenhoff V., </author> <title> Compiling Constraint Reduction, </title> <type> Technical Report Draft, </type> <institution> ECRC Munich, Germany, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: The general technique of propagation is employed over finite domains. The idea is to prune large search trees by enforcing local consistency of built-in and user-defined constraints. There is work at ECRC on extending propagation over finite domains to arbitrary constraint domains [LPW92], and on compiling propagation into demons <ref> [Kue91] </ref>. These techniques are orthogonal to our approach and thus can be integrated. Demons [A*90] are essentially single-headed Replacement SiRs without guards. However, demons must define a constraint completely, no associated constraint definitions are allowed.
Reference: [Le88] <author> Levi G., </author> <title> Models, Unfolding Rules and Fixpoint Semantics, Invited Talk, </title> <booktitle> Fifth Intl Conf and Symp on Logic Programming MIT Press 1988, </booktitle> <pages> pp. 1649-1665. </pages>
Reference: [Ll87] <author> Lloyd J. W., </author> <booktitle> Foundations of Logic Programming, 2nd ed., </booktitle> <publisher> Springer, </publisher> <address> New York, </address> <year> 1987. </year>
Reference: [LPW92] <author> Le Provost T. and Wallace M., </author> <title> Domain Independent Propagation, </title> <booktitle> International Conference on Fifth Generation Computer Systems 1992, </booktitle> <address> Tokyo, Japan, </address> <month> June </month> <year> 1992, </year> <pages> p. 1004-1012. </pages>
Reference-contexts: There are some additional features not discussed in full in this paper, including run-time loop checking and a declaration for deterministic predicates to support residuation [Smo91]. A combination with generalised propagation <ref> [LPW92] </ref> is planned. <p> The general technique of propagation is employed over finite domains. The idea is to prune large search trees by enforcing local consistency of built-in and user-defined constraints. There is work at ECRC on extending propagation over finite domains to arbitrary constraint domains <ref> [LPW92] </ref>, and on compiling propagation into demons [Kue91]. These techniques are orthogonal to our approach and thus can be integrated. Demons [A*90] are essentially single-headed Replacement SiRs without guards. However, demons must define a constraint completely, no associated constraint definitions are allowed.
Reference: [M*89] <author> Micha Meier et al., </author> <title> SEPIA An Extendible Prolog System, </title> <booktitle> 11th World Computer Congress IFIP'89, </booktitle> <address> San Francisco, USA, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: An unfailing completion procedure for SiRs is proposed in a forthcoming report by the same author. 4 The Prototype A meta-interpreter for Prolog augmented with SiRs has been implemented on top of Sepia-Prolog <ref> [M*89] </ref> utilizing its delay-mechanism and built-in meta-predicates to create, inspect and manipulate delayed goals. The prototype includes a simple kind of incremental constraints, a preprocessor for SiRs, a tracing tool for user-defined constraints and variable bindings, and a simple partial evaluator based on simplifications.
Reference: [Ma87] <author> Maher M. J., </author> <title> Logic Semantics for a Class of Committed Choice Programs, </title> <booktitle> Proc of the Fourth Intl Conf on Logic Programming MIT Press 1987, </booktitle> <pages> pp. 858-876. </pages>
Reference: [Mon92] <author> Monfroy E., </author> <title> Non-linear Constraints: A Language and a Solver, </title> <type> Technical Report ECRC-92, </type> <institution> ECRC, Munich, Germany, </institution> <year> 1992, </year> <note> to appear. </note>
Reference-contexts: The solver was developed by a straightforward extension of Gaussian elimination with inequalities. Recently we have connected our solver to one for nonlinear polynomials based on Groebner Bases <ref> [Mon92] </ref>. The term manipulation CS turns the built-in predicates functor, arg and =.. into user-defined constraints. SiRs have also been used as a committed choice programming language on their own.
Reference: [Nai85] <author> Naish L., </author> <title> Prolog control rules, </title> <booktitle> Proceedings of the Ninth International Joint Conference on Artificial Intelligence, </booktitle> <address> Los Angeles, California, </address> <month> September </month> <year> 1985, </year> <pages> pp. 720-722. </pages>
Reference: [Nai89] <author> Naish L., </author> <title> Proving Properties of Committed Choice Logic Programs, </title> <journal> Journal of Logic Programming, </journal> <volume> 7(1), </volume> <month> July </month> <year> 1989, </year> <pages> pp. 63-84. 17 </pages>
Reference: [Plu90] <author> L. Pluemer, </author> <title> Termination Proofs for Logic Programs based on Predicate Inequalities, </title> <booktitle> Seventh Int Conference on Logic Programming, </booktitle> <publisher> MIT Press 1990, </publisher> <pages> pp. 634-648. </pages>
Reference-contexts: Correctness has been discussed in the previous section on declarative semantics. 3.1 Termination and Confluence Termination is a highly desirable property which has been studied in many different contexts. In particular, termination proofs for sets of SiRs can benefit from work in rewriting systems [Der87] and logic programming <ref> [Plu90, VeDe91, Bez89, ApPe90] </ref>. If a set of SiRs is terminating, then there is no simplification step from any resolvent consisting of infinitely many derivation steps. Finding a suitable termination order may need user intervention.
Reference: [Sar89] <author> V. A. Saraswat, </author> <title> Concurrent Constraint Programming Languages, </title> <type> Ph.D. Dissertation, </type> <institution> Carnegie Mellon Univ., Draft of Jan. </institution> <year> 1989. </year>
Reference-contexts: Amalgamating pure Prolog with single headed Replacement SiRs only results in a language of the family cc (#; !; )) 1 of the cc framework proposed by Saraswat <ref> [Sar89, Sar90] </ref>. A close study of [Sar89] reveals that he proposes a special Tell operation called "inform" that could be used to simulate Augmentation SiRs. SiRs naturally fit the ask-and-tell interpretation of constraint logic programming introduced by Saraswat and applied by [VH91]. <p> Amalgamating pure Prolog with single headed Replacement SiRs only results in a language of the family cc (#; !; )) 1 of the cc framework proposed by Saraswat [Sar89, Sar90]. A close study of <ref> [Sar89] </ref> reveals that he proposes a special Tell operation called "inform" that could be used to simulate Augmentation SiRs. SiRs naturally fit the ask-and-tell interpretation of constraint logic programming introduced by Saraswat and applied by [VH91]. The resolvent is viewed as constraint store for user-defined constraints.
Reference: [Sar90] <author> V. A. Saraswat, </author> <title> Concurrent Constraint Programming, </title> <booktitle> ACM Seventeenth Symp on Principles of Programming Languages, POPL 1990, </booktitle> <pages> pp. 232-245. </pages>
Reference-contexts: Amalgamating pure Prolog with single headed Replacement SiRs only results in a language of the family cc (#; !; )) 1 of the cc framework proposed by Saraswat <ref> [Sar89, Sar90] </ref>. A close study of [Sar89] reveals that he proposes a special Tell operation called "inform" that could be used to simulate Augmentation SiRs. SiRs naturally fit the ask-and-tell interpretation of constraint logic programming introduced by Saraswat and applied by [VH91].
Reference: [Sha89] <author> Shapiro E., </author> <title> The Family of Concurrent Logic Programming Languages, </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 413-510, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Recently we have connected our solver to one for nonlinear polynomials based on Groebner Bases [Mon92]. The term manipulation CS turns the built-in predicates functor, arg and =.. into user-defined constraints. SiRs have also been used as a committed choice programming language on their own. Examples from <ref> [Sha89] </ref> as well as the basics of an Earley parser [Ea70] and a distributed shortest path algorithm have been implemented. These constraint solvers back up our claim that it is possible to conveniently define constraint solvers with SiRs.
Reference: [Si91] <author> H. Simonis, </author> <title> Constraint Logic Programming as a Digital Circuit Design Tool, </title> <type> Ph.D. Thesis, Draft Version, </type> <month> February </month> <year> 1991. </year>
Reference-contexts: In this sense, SiRs can be seen as an extension of the work on demons and forward rules in CHIP. In practice, demons and forward rules have been proven useful in CHIP applications in the boolean domain for circuit design and verification <ref> [Si91] </ref>. Their potential to define constraint solvers in general was not realised, maybe because of their limitations.
Reference: [Smo91] <author> Smolka G., </author> <title> Residuation and Guarded Rules for Constraint Logic Programming, </title> <institution> Digital Equipment Paris Research Laboratory Research Report, France, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: There are some additional features not discussed in full in this paper, including run-time loop checking and a declaration for deterministic predicates to support residuation <ref> [Smo91] </ref>. A combination with generalised propagation [LPW92] is planned. <p> The resolvent is viewed as constraint store for user-defined constraints. They are matched by the heads of SiRs and the guards ask if certain constraints hold in the built-in constraint store and on the arguments of the matched user-defined constraints. Guarded Rules <ref> [Smo91] </ref> correspond exactly to single headed Replacement SiRs. Like correct SiRs, admissible guarded rules are logical consequences of a program to be amalgamated. However, Smolka does not consider predicates with associated Guarded Rules as definitions for user-defined constraints. There are only built-in constraints. <p> Hence it could be implemented by Replacement SiRs. <ref> [Smo91] </ref> can be read as an excellent introduction to some of the basic ideas also underlying our approach. The Andorra Model of D.H.D. Warren for parallel computation has inspired a rapid development of numerous languages and language schemes.
Reference: [VE88] <author> Van Emden M. H., </author> <title> Conditional Answers for Polymorphic Type Inference, </title> <booktitle> Proc of the Fifth Intl Conf and Symp on Logic Programming MIT Press 1988, </booktitle> <pages> pp. 590-603. </pages>
Reference: [VH89] <author> P. Van Hentenryck, </author> <title> Constraint Satisfaction in Logic Programming, </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, Massachusetts, </address> <year> 1989. </year>
Reference-contexts: In the n-queens problem, treating the no attack predicate as a user-defined constraint has reduced the number of backtracks even more than reported with any of the approaches in <ref> [VH89] </ref>, p. 123. However, the additional cost outweighs the savings in backtracking. The solver for inequalities is based on the one described in the introduction. <p> The boolean solver, given the definition of a full-adder, is able to find out by constraint simplification only that adding a number to itself results in a number whose binary representation is shifted by one digit. Finite domains over equalities and inequalities were implemented as introduced in CHIP <ref> [VH89] </ref>. In terminological reasoning, the constraint simplifier can simplify and prove inconsistency of attributive concept definitions. We plan to extend this application to cover types and subsume finite domains. A constraint solver for temporal time point constraints [DMP91] was developed step by step starting from the solver for inequalities. <p> The exception to the rule is the constraint logic programming CHIP <ref> [VH89] </ref>. The general technique of propagation is employed over finite domains. The idea is to prune large search trees by enforcing local consistency of built-in and user-defined constraints.
Reference: [VH91] <author> P. Van Hentenryck, </author> <title> Constraint Logic Programming, </title> <journal> The Knowledge Engineering Review, </journal> <volume> 6(3), </volume> <pages> pp. 151-194, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Further optimisations are possible, for example using a dynamic shortest-path algorithm. If further speed-up is needed, once the prototype has been established and "tuned" as required, it can be reworked in a low-level language. 6 Related Work 6.1 Constraint Logic Programming Languages Current constraint logic programming languages <ref> [VH91, Coh90, Fru90] </ref> are not extensible, they do not allow for user-defined constraints. The exception to the rule is the constraint logic programming CHIP [VH89]. The general technique of propagation is employed over finite domains. <p> A close study of [Sar89] reveals that he proposes a special Tell operation called "inform" that could be used to simulate Augmentation SiRs. SiRs naturally fit the ask-and-tell interpretation of constraint logic programming introduced by Saraswat and applied by <ref> [VH91] </ref>. The resolvent is viewed as constraint store for user-defined constraints. They are matched by the heads of SiRs and the guards ask if certain constraints hold in the built-in constraint store and on the arguments of the matched user-defined constraints.
Reference: [Va86] <author> Vasey P., </author> <title> Qualified Answers and their Application to Transformation, </title> <booktitle> Proc of the Third Intl Conf on Logic Programming 1986, </booktitle> <pages> pp. 425-432. </pages>
Reference: [VeDe91] <author> K. Verschaetse and D. De Schreye, </author> <title> Deriving Termination Proofs for Logic Programs using Abstract Procedures, </title> <booktitle> 8th Int Conf on Logic Programming, </booktitle> <publisher> MIT Press 1991, </publisher> <pages> pp. 301-315. </pages>
Reference-contexts: Correctness has been discussed in the previous section on declarative semantics. 3.1 Termination and Confluence Termination is a highly desirable property which has been studied in many different contexts. In particular, termination proofs for sets of SiRs can benefit from work in rewriting systems [Der87] and logic programming <ref> [Plu90, VeDe91, Bez89, ApPe90] </ref>. If a set of SiRs is terminating, then there is no simplification step from any resolvent consisting of infinitely many derivation steps. Finding a suitable termination order may need user intervention.
Reference: [WoMc91] <author> Wos L. and McCune W., </author> <title> Automated Theorem Proving and Logic Programming: A Natural Symbiosis, </title> <journal> Journal of Logic Programming, </journal> <volume> 11(1), </volume> <month> July </month> <year> 1991, </year> <pages> pp. 1-53. </pages>
Reference-contexts: introduction to automated theorem proving is [Gal86]. For the relationship of automated theorem proving and logic programming we refer the reader to <ref> [WoMc91] </ref>. Also note that completion of rewrite systems can serve as a theorem proving procedure [Hs85, JSC91]. Correctness has been discussed in the previous section on declarative semantics. 3.1 Termination and Confluence Termination is a highly desirable property which has been studied in many different contexts.
Reference: [YaAi86] <author> Yang R. and Aiso H., </author> <title> A Parallel Logic Language Based on the Exclusive Relation, </title> <booktitle> Third Int Conference on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1986. </year> <note> 18 Other Reports Available from ECRC </note>
Reference: [ECRC-TR-LP-60] <author> Mireille Ducasse and Anna-Maria Emde. </author> <title> Opium 3.1 User Manual A High-level Debugging Environment for Prolog. </title> <year> 1991. </year>
Reference: [ECRC-TR-LP-61] <author> E. Yardeni, T. Fruhwirth, and E. Shapiro. </author> <title> Polymorphically Typed Logic Programs. </title> <year> 1991. </year>
Reference: [ECRC-TR-DPS-81] <author> U. Baron, S. Bescos, and S. </author> <title> Delgado. </title> <booktitle> The ElipSys Logic Programming Language. </booktitle> <volume> 17. 01. </volume> <year> 1991. </year>
Reference: [ECRC-TR-DPS-82] <author> Sergio Delgado, Michel Dorochevsky, and Kees Schuerman. </author> <title> A Shared Environment Parallel Logic Programming System On Distributed Memory Architectures. </title> <type> 18. 01. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-83] <author> Andre Veron, Jiyang Xu, and Kees Schuerman. </author> <title> Virtual Memory Support for OR-Parallel Logic Programming Systems. </title> <type> 05. 03. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-85] <author> Michel Dorochevsky. </author> <title> Garbage Collection in the OR-Parallel Logic Programming. </title> <type> 15. 03. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-100] <author> Alan Sexton. </author> <title> KCM Kernel Implementation Report. </title> <type> 22. 05. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-103] <author> Michel Dorochevsky. </author> <title> Key Features of a Prolog Module System. </title> <type> 08. 03. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-104] <author> Michel Dorochevsky, Kees Schuerman, and Andre Veron. ElipSys: </author> <title> An Integrated Platform for Building Large Decision Support Systems. </title> <type> 29. 01. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-105] <author> Jiyang Xu and Andre Veron. </author> <title> Types and Constraints in the Parallel Logic Programming System ElipSys. </title> <type> 15. 03. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-107] <author> Olivier Thibault. </author> <title> Design and Evaluation of a Symbolic Processor. </title> <type> 13. 06. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-112] <author> Michel Dorochevsky, Jacques Noye, and Olivier Thibault. </author> <title> Has Dedicated Hardware for Prolog a Future ? 14. </title> <type> 09. </type> <year> 1991. </year>
Reference: [ECRC-91-1] <author> Norbert Eisinger and Hans Jurgen Ohlbach. </author> <title> Deduction Systems Based on Resolution. </title> <type> 29. 10. </type> <year> 1991. </year>
Reference: [ECRC-91-2] <author> Michel Kuntz. </author> <title> The Gist of GIUKU: Graphical Interactive Intelligent Utilities for Knowledgeable Users of Data Base Systems. </title> <type> 4. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-3] <author> Michel Kuntz. </author> <title> An Introduction to GIUKU: Graphical Interactive Intelligent Utilities for Knowledgeable Users of Data Base Systems. </title> <type> 4. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-4] <author> Michel Kuntz. </author> <title> Enhanced Graphical Browsing Techniques for Collections of Structured Data. </title> <type> 4. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-5] <author> Michel Kuntz. </author> <title> A Graphical Syntax Facility for Knowledge Base Languages. </title> <type> 4. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-6] <author> Michel Kuntz. </author> <title> A Versatile Browser-Editor for NF2 Relations. </title> <type> 4. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-7] <author> Norbert Eisinger, Nabiel Elshiewy, and Remo Pareschi. </author> <title> Distributed Artificial Intelligence An Overview. </title> <type> 4. 11. </type> <year> 1991. </year> <month> 19 </month>
Reference: [ECRC-91-8] <author> Norbert Eisinger. </author> <title> An Approach to Multi-Agent Problem-Solving. </title> <type> 11. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-9] <author> Klaus H. Ahlers, Michael Fendt, Marc Herrmann, Isabelle Hounieu, and Philippe Marchal. </author> <title> TUBE Implementor's Manual. </title> <type> 21. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-10] <author> Klaus H. Ahlers, Michael Fendt, Marc Herrmann, Isabelle Hounieu, and Philippe Marchal. </author> <title> TUBE Programmer's Manual. </title> <type> 21. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-11] <author> Michael Dahmen. </author> <title> A Debugger for Constraints in Prolog. </title> <type> 26. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-12] <author> Jean-Marc Andreoli and Remo Pareschi. </author> <title> Communication as Fair Distribution of Knowledge. </title> <type> 26. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-13] <author> Jean-Marc Andreoli, Remo Pareschi, and Marc Bourgois. </author> <title> Dynamic Programming as Multiagent Programming. </title> <type> 26. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-14] <author> Volker Kuchenhoff. </author> <title> On the Efficient Computation of the Difference Between Consecutive Database States. </title> <type> 5. 12. </type> <year> 1991. </year>
Reference: [ECRC-91-15] <author> Sylvie Bescos and Michael Ratcliffe. </author> <title> Secondary Structure Prediction of rRNA Molecules Using ElipSys. </title> <type> 16. 12. </type> <year> 1991. </year>
Reference: [ECRC-91-16] <author> Michael Dahmen. </author> <title> Abstract Debugging of Coroutines and Constraints in Prolog. </title> <type> 30. 12. </type> <year> 1991. </year>
Reference: [ECRC-92-1] <author> Thierry Le Provost and Mark Wallace. </author> <title> Constraint Satisfaction Over the CLP Scheme. </title> <type> 30. 1. </type> <year> 1992. </year>
Reference: [ECRC-92-2] <author> Gerard Comyn, M. Jarke, and Suryanarayana M. </author> <title> Sripada. </title> <booktitle> Proceedings of the 1st Compulog Net meeting on Knowledge Bases (CNKBS'92). </booktitle> <volume> 30. 1. </volume> <year> 1992. </year>
Reference: [ECRC-92-3] <author> Jesper Larsson Traeff and Steven David Prestwich. </author> <title> Meta-programming for reordering Literals in Deductive Databases. </title> <type> 30. 1. </type> <year> 1992. </year>
Reference: [ECRC-92-4] <author> Beat Wuthrich. </author> <title> Update Realizations Drawn from Knowledge Base Schemas and Executed by Dialog. </title> <type> 4. 2. </type> <year> 1992. </year>
Reference: [ECRC-92-5] <author> Lone Leth. </author> <title> A New Direction in Functions as Processes. </title> <type> 25. 2. </type> <year> 1992. </year>
Reference: [ECRC-92-6] <author> Steven David Prestwich. </author> <title> The PADDY Partial Deduction System. </title> <type> 23. 3. </type> <year> 1992. </year>
Reference: [ECRC-92-7] <author> Andrei Voronkov. </author> <title> Extracting Higher Order Functions from First Order Proofs. </title> <type> 23. 3. </type> <year> 1992. </year>
Reference: [ECRC-92-8] <editor> Andrei Voronkov. </editor> <booktitle> On Computability by Logic Programs. </booktitle> <volume> 23. 3. </volume> <year> 1992. </year>
Reference: [ECRC-92-9] <author> Beat Wuthrich. </author> <title> Towards Probabilistic Knowledge Bases. </title> <type> 02. 4. </type> <year> 1992. </year>
Reference: [ECRC-92-10] <author> Petra Bayer. </author> <title> Update Propagation for Integrity Checking, Materialized View Maintenance and Production Rule Triggering. </title> <type> 08. 4. </type> <year> 1992. </year>
Reference: [ECRC-92-11] <author> Mireille Ducasse. </author> <title> Abstract views of Prolog executions in Opium. </title> <type> 15. 4. </type> <year> 1992. </year>
Reference: [ECRC-92-12] <author> Alexandre Lefebvre. </author> <title> Towards an Efficient Evaluation of Recursive Aggregates in Deductive Databases. </title> <type> 30. 4. </type> <year> 1992. </year>
Reference: [ECRC-92-13] <author> Udo W. Lipeck and Rainer Manthey (Hrsg.). </author> <title> Kurzfassungen des 4. GI-Workshops "Grundlagen von Datenbanken", </title> <journal> Barsinghausen, 9.-12.6.1992. </journal> <volume> 12. 05. </volume> <year> 1992. </year>
Reference: [ECRC-92-14] <author> Lone Leth and Bent Thomsen. </author> <title> Some Facile Chemistry. </title> <type> 26. 05. </type> <year> 1992. </year>
Reference: [ECRC-92-15] <editor> Jacques Noye (Ed.). </editor> <booktitle> Proceedings of the International KCM User Group Meeting,Munich, 7 and 8 October 1991. </booktitle> <volume> 03. 06. </volume> <year> 1992. </year>
Reference: [ECRC-92-16] <author> Frederick Knabe. </author> <title> A Distributed Protocol for Channel-Based Communication with Choice. </title> <type> 10. 06. </type> <year> 1992. </year>
Reference: [ECRC-92-17] <author> Benoit Baurens, Petra Bayer, Luis Hermosilla, and Andrea Sikeler. </author> <title> Publication Management: A Requirements Analysis. </title> <type> 03. 07. </type> <year> 1992. </year>
Reference: [ECRC-92-18] <author> Thom Fruhwirth. </author> <title> Constraint Simplification Rules. </title> <type> 28. 07. </type> <year> 1992. </year>
Reference: [ECRC-92-19] <author> Mark Wallace. </author> <title> Compiling Integrity Checking into Update Procedures. </title> <type> 29. 07. </type> <year> 1992. </year>
Reference: [ECRC-92-20] <author> Petra Bayer. </author> <title> Data and Knowledge for Medical Applications: A Case Study. </title> <type> 30. 07. </type> <year> 1992. </year>
Reference: [ECRC-92-21] <author> Michel Dorochevsky and Andre Veron. </author> <title> Binding Techniques and Garbage Collection for OR-Parallel CLP Systems. </title> <type> 11. 08. </type> <year> 1992. </year>
Reference: [ECRC-92-22] <author> Shan-Wen Yan. </author> <title> Efficiently Estimating Relative Grain Size for Logic Programs on Basis of Abstract Interpretation. </title> <type> 25. 08. </type> <year> 1992. </year>
Reference: [ECRC-92-23] <author> Jean-Marc Andreoli, Paolo Ciancarini, and Remo Pareschi. </author> <title> Interaction Abstract Machines. </title> <type> 25. 08. </type> <year> 1992. </year>
Reference: [ECRC-92-24] <author> Jean-Marc Andreoli and Remo Pareschi. </author> <title> Associative Communication and its Optimization via Abstract Interpretation. </title> <type> 25. 08. </type> <year> 1992. </year>
Reference: [ECRC-92-25] <author> Jean-Marc Andreoli, Lone Leth, Remo Pareschi, and Bent Thomsen. </author> <title> On the Chemistry of Broadcasting. </title> <type> 25. 08. </type> <year> 1992. </year>
Reference: [ECRC-92-26] <author> Marc Bourgois, Jean-Marc Andreoli, and Remo Pareschi. </author> <title> Extending Objects with Rules, </title> <journal> Composition and Concurrency : the LO Experience. </journal> <volume> 25. 08. </volume> <year> 1992. </year>
Reference: [ECRC-92-27] <author> Benoit Dageville and Kam-Fai Wong. </author> <title> SIM: A C-based SIMulation Package. </title> <type> 28. 09. </type> <year> 1992. </year>
Reference: [ECRC-92-28] <author> Beat Wuthrich. </author> <title> On the Efficient Distribution-free Learning of Rule Uncertainties and their Integration into Probabilistic Knowledge Bases. </title> <type> 29. 09. </type> <year> 1992. </year>
Reference: [ECRC-92-29] <author> Andrei Voronkov. </author> <title> Logic Programming with Bounded Quantifiers. </title> <type> 29. 09. </type> <year> 1992. </year>
Reference: [ECRC-92-30] <author> Eric Monfroy. </author> <title> Grobner Bases: </title> <booktitle> Strategies and Applications. </booktitle> <volume> 30. 09. </volume> <year> 1992. </year>
Reference: [ECRC-92-31] <author> Eric Monfroy. </author> <title> Specification of Geometrical Constraints. </title> <type> 30. 09. </type> <year> 1992. </year>
Reference: [ECRC-92-32] <author> Bent Thomsen, Lone Leth, and Alessandro Giacalone. </author> <title> Some Issues in the Semantics of Facile Distributed Programming. </title> <type> 22. 10. </type> <year> 1992. </year>
Reference: [ECRC-92-33] <author> Mireille Ducasse. </author> <title> An Extendable Trace Analyser to Support Automated Debugging. </title> <type> 04. 12. </type> <year> 1992. </year>
Reference: [ECRC-92-34] <author> Jorge Bocca and Luis Hermosilla. </author> <title> A Preliminary Study of the Performance of MegaLog. </title> <type> 20. 12. </type> <year> 1992. </year> <month> 21 </month>
Reference: [ECRC-93-1] <author> Benoit Dageville and Kam-Fai Wong. </author> <title> Supporting Thousands of Threads Using a Hybrid Stack Sharing Scheme. </title> <type> 18. 01. </type> <year> 1993. </year>
Reference: [ECRC-93-2] <author> Steven Prestwich. </author> <booktitle> ElipSys Programming Tutorial. </booktitle> <volume> 18. 01. </volume> <year> 1993. </year>
Reference: [ECRC-93-3] <author> Beat Wuthrich. </author> <title> Learning Probabilistic Rules. </title> <type> 28. 01. </type> <year> 1993. </year>
Reference: [ECRC-93-4] <author> Eric Monfroy. </author> <title> A Survey of Non-Linear Solvers. </title> <type> 02. 02. </type> <year> 1993. </year>
Reference: [ECRC-93-5] <author> Thom Fruhwirth, Alexander Herold, Volker Kuchenhoff, Thierry Le Provost, Pierre Lim, Eric Monfroy, and Mark Wallace. </author> <title> Constraint Logic Programming - An Informal Introduction. </title> <type> 02. 02. </type> <year> 1993. </year> <month> 22 </month>
References-found: 121

