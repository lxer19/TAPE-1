URL: http://www.cs.clemson.edu/~malloy/papers/simulation/mascots94.ps
Refering-URL: http://www.cs.clemson.edu/~malloy/simulation_papers.html
Root-URL: http://www.cs.clemson.edu
Email: malloy@cs.clemson.edu  
Phone: (803) 656-0808  
Title: Trace-driven and Program-driven Simulation: A Comparison  
Author: Brian A. Malloy 
Address: Clemson, SC 29634-1906  
Affiliation: Clemson University  
Abstract: In this paper, we compare the program-driven and trace-driven approach to simulating the parallel execution of a program on a multiprocessor. To obtain the traces, we used a program-driven simulator that actually executes the instructions in an input program. Our simulator is coded in the process-oriented simulation language SimCal and is guided by a parameterized computational model that describes the target multiprocessor. We have used the program-driven multiprocessor simulator to execute parallel threads produced by our paral-lelizing compiler and we have validated the simulator by comparing the simulation results to results obtained through execution of the threads on an actual multiprocessor, the AT&T 3B2. To compare the trace-driven and program-driven approaches, we used the program-driven simulator to obtain traces of the execution of the threads. we conclude that the trace-driven approach is faster than the program-driven approach since it doesn't actually execute the threads. However, the trace-driven approach must store the traces and therefore requires more space than the program-driven approach. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> F. Dahlgren, </author> <title> ``A Program-driven Simulation Model of an MIMD Multiprocessor,'' </title> <booktitle> 24th Simulation Symposium, </booktitle> <pages> pp. 40-49, </pages> <month> Apr </month> <year> 1991. </year>
Reference-contexts: Previous research has shown that traces obtained on a multiprocessor can produce erroneous results when used to simulate a different multiprocessor <ref> [1] </ref>. In previous work, we presented a program-driven simulator that actually executes the instructions of an input program [7]. Our simulator is coded in SimCal [3, 4], and is guided by a parameterized computational model that describes the target multiprocessor.
Reference: 2. <author> E. Koldinger, S. Eggers, and H. Levy, </author> <title> ``On the Validity of Trace-driven Simulation for Multiprocessors,'' </title> <booktitle> Proceedings of 18th Annual Symposium on Computer Architecture, </booktitle> <pages> pp. 244-253, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: However, there are several problems with applying the trace-driven approach to multiprocessor simulation. The simulated architecture must be similar to the architecture on which the trace was obtained, which can be a significant problem when simulating an architecture that is in the development stage <ref> [2] </ref>. For a new architecture, the order of events, the latency of the network and the number of processors might be completely different from the trace host, rendering the traces useless when evaluating timing-sensitive applications.
Reference: 3. <author> B. A. Malloy and M.L. Soffa , ``Simcal: </author> <title> The Merger of Simula and Pascal,'' </title> <booktitle> Proceedings Winter Simulation Conference, </booktitle> <pages> pp. 397-403, </pages> <address> Washington D. C., </address> <year> 1986. </year>
Reference-contexts: Previous research has shown that traces obtained on a multiprocessor can produce erroneous results when used to simulate a different multiprocessor [1]. In previous work, we presented a program-driven simulator that actually executes the instructions of an input program [7]. Our simulator is coded in SimCal <ref> [3, 4] </ref>, and is guided by a parameterized computational model that describes the target multiprocessor.
Reference: 4. <author> B. A. Malloy and M. L. Soffa, </author> <title> ``Conversion of Simulation Processes to Pascal Constructs,'' </title> <journal> Software Practice and Experience, </journal> <volume> vol. 20(2), </volume> <pages> pp. 191-207, </pages> <month> Feb </month> <year> 1990. </year>
Reference-contexts: Previous research has shown that traces obtained on a multiprocessor can produce erroneous results when used to simulate a different multiprocessor [1]. In previous work, we presented a program-driven simulator that actually executes the instructions of an input program [7]. Our simulator is coded in SimCal <ref> [3, 4] </ref>, and is guided by a parameterized computational model that describes the target multiprocessor.
Reference: 5. <author> B. A. Malloy, R. Gupta, and M. L. Soffa,, </author> <title> ``A Shape Matching Approach for Scheduling Fine-Grained Parallelism,'' </title> <booktitle> MICRO-25, The 25th Annual International Symposium on Microarchitecture, </booktitle> <pages> pp. 131-135, </pages> <month> Dec </month> <year> 1992. </year>
Reference-contexts: We have used the multiprocessor simulator to execute parallel threads (see Table 1) produced by our parallelizing compiler <ref> [5, 6, 8] </ref> and have shown, through the simulations, that our compiler is able to produce significant speed-up in the parallel execution of the program. Through experimentation, we derived parameters that accurately describe the AT&T 3B2/1000 multiprocessor. <p> Overview of the Approach Our approach to comparing trace-driven and program-driven simulations is summarized in Figure 1. The top of Figure 1 indicates that input to our parallelizing compiler <ref> [5, 6, 8] </ref> is a sequential Source Program. The Parallelizing Compiler automatically parallelizes the sequential program by constructing threads that consist of statements from the source program and synchronization primitives to preserve control and data dependences.
Reference: 6. <author> B. A. Malloy, E.L. Lloyd, </author> <title> and M.L. Soffa., ``A Fine Grained Approach to Scheduling Asynchronous Multiprocessors,'' </title> <booktitle> 4th International Conference on Computing and Information,, </booktitle> <pages> pp. 131-135, </pages> <month> May, </month> <year> 1992. </year>
Reference-contexts: We have used the multiprocessor simulator to execute parallel threads (see Table 1) produced by our parallelizing compiler <ref> [5, 6, 8] </ref> and have shown, through the simulations, that our compiler is able to produce significant speed-up in the parallel execution of the program. Through experimentation, we derived parameters that accurately describe the AT&T 3B2/1000 multiprocessor. <p> Overview of the Approach Our approach to comparing trace-driven and program-driven simulations is summarized in Figure 1. The top of Figure 1 indicates that input to our parallelizing compiler <ref> [5, 6, 8] </ref> is a sequential Source Program. The Parallelizing Compiler automatically parallelizes the sequential program by constructing threads that consist of statements from the source program and synchronization primitives to preserve control and data dependences.
Reference: 7. <author> B. A. Malloy, </author> <title> ``The Validation of a Multiprocessor Simulator,'' </title> <booktitle> Proceedings of the 1993 Winter Simulation Conference, </booktitle> <month> Dec </month> <year> 1993. </year>
Reference-contexts: Previous research has shown that traces obtained on a multiprocessor can produce erroneous results when used to simulate a different multiprocessor [1]. In previous work, we presented a program-driven simulator that actually executes the instructions of an input program <ref> [7] </ref>. Our simulator is coded in SimCal [3, 4], and is guided by a parameterized computational model that describes the target multiprocessor.
Reference: 8. <author> B. A. Malloy, E. L. Lloyd, and M. L. Soffa, </author> <title> ``Scheduling Dags for Asynchronous Multiprocessor Execution,'' </title> <journal> IEEE Transactions on Parallel and Distributed Computing, </journal> <note> to appear. </note>
Reference-contexts: We have used the multiprocessor simulator to execute parallel threads (see Table 1) produced by our parallelizing compiler <ref> [5, 6, 8] </ref> and have shown, through the simulations, that our compiler is able to produce significant speed-up in the parallel execution of the program. Through experimentation, we derived parameters that accurately describe the AT&T 3B2/1000 multiprocessor. <p> Overview of the Approach Our approach to comparing trace-driven and program-driven simulations is summarized in Figure 1. The top of Figure 1 indicates that input to our parallelizing compiler <ref> [5, 6, 8] </ref> is a sequential Source Program. The Parallelizing Compiler automatically parallelizes the sequential program by constructing threads that consist of statements from the source program and synchronization primitives to preserve control and data dependences.
References-found: 8

