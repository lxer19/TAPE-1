URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-06.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-06.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> S. Abiteboul and C. Beeri. </author> <title> On the Power of Languages for the Manipulation of Complex Objects. </title> <note> INRIA Research Report 846, 1988. 42 </note>
Reference-contexts: Complex object databases have been proposed as a significant extension of relational databases, with many practical applications; see [2] for a recent survey. Well-known languages in this area are the complex object algebras with or without Powerset of <ref> [1] </ref>. For the analysis of expressibility of the complex object algebra with Powerset we refer to [26, 31] and without Powerset to [39]. Note that, although Powerset in [1] is powerful (as are the second order queries in [10, 15, 46]), it is an impractical primitive, and much attention has been <p> Well-known languages in this area are the complex object algebras with or without Powerset of <ref> [1] </ref>. For the analysis of expressibility of the complex object algebra with Powerset we refer to [26, 31] and without Powerset to [39]. Note that, although Powerset in [1] is powerful (as are the second order queries in [10, 15, 46]), it is an impractical primitive, and much attention has been given to algebras without Powerset for PTIME queries. An elegant way of manipulating complex object databases, related to our paper, is based on functional programming. <p> The typing requirements are taken care of in Section 4.2, using a technique one can describe as "type-laundering." To illustrate the embedding, Section 4.3 contains the representation of the transitive closure query as a detailed example. In Section 5, we PTIME-embed the complex object algebra (and by <ref> [1] </ref>, the complex object calculus) into TLC = . We first present a concise definition of this algebra from [2] (Section 5.1). There are two tasks. The first is to PTIME-embed the algebra without Powerset; this is accomplished in Section 5.2. <p> query is [h1; 2i; h2; 3i; h3; 4i; h1; 3i; h1; 4i; h2; 4i], which is indeed the transitive closure of [h1; 2i; h2; 3i; h3; 4i]. 5 The Complex Object Algebra We conclude our tour of relational query languages with an encoding of Abiteboul's and Beeri's complex object algebra <ref> [1] </ref>. This takes us from manipulating "flat" relations to more complicated data structures, namely arbitrary finite trees built from tuple and set constructors. The algebra under consideration is extremely powerful|in fact it expresses any generic elementary time computation on finite structures. <p> Thus ALG is strictly less expressive than ALG. Paredaens and Van Gucht showed that a query from a relational schema to a relational schema is expressible in ALG iff it is expressible in the classical relational algebra [39]. A restricted calculus is presented in <ref> [1] </ref>. The restrictions consist of syntactically forcing formulas to provide limited ranges to all variables. The restricted calculus is called CALC . The equivalence of ALG and CALC is shown in [1]. 2 We are concerned here exclusively with the data complexity in the sense of [10, 48]. 26 5.2 Coding <p> A restricted calculus is presented in <ref> [1] </ref>. The restrictions consist of syntactically forcing formulas to provide limited ranges to all variables. The restricted calculus is called CALC . The equivalence of ALG and CALC is shown in [1]. 2 We are concerned here exclusively with the data complexity in the sense of [10, 48]. 26 5.2 Coding ALG . We begin by extending our embedding of relational algebra to deal with complex objects and to express the Tup, Tupcomb, Set, and Setcomb operators. <p> In order to construct a typing for a TLC = term realizing , we divide the gates in the circuit into m + 1 layers of circuitry delineated by the placement of Powerset gates in the topological ordering: we define ` 1 = <ref> [1; -1 ] </ref>, ` 2 = (-1 ; -2 ], ` 3 = (-2 ; -3 ], : : : , ` m = (-m1 ; -m ], ` m+1 = (-m ; n]. <p> For example, the typed -calculus with equality is the simplest syntax to date, that can be used to describe the complex object algebra of <ref> [1] </ref>. In our embeddings we use lists of tuples and simulate sets by eliminating duplicates. In [1, 6, 7, 28] sets are used as basic constructs, and set iteration is used instead of list iteration. <p> For example, the typed -calculus with equality is the simplest syntax to date, that can be used to describe the complex object algebra of [1]. In our embeddings we use lists of tuples and simulate sets by eliminating duplicates. In <ref> [1, 6, 7, 28] </ref> sets are used as basic constructs, and set iteration is used instead of list iteration.
Reference: [2] <author> S. Abiteboul and P. Kanellakis. </author> <title> Database Theory Column: Query Languages for Complex Object Databases. </title> <journal> SIGACT News, </journal> <volume> 21 (1990), </volume> <pages> pp. 9-18. </pages>
Reference-contexts: Complex object databases have been proposed as a significant extension of relational databases, with many practical applications; see <ref> [2] </ref> for a recent survey. Well-known languages in this area are the complex object algebras with or without Powerset of [1]. For the analysis of expressibility of the complex object algebra with Powerset we refer to [26, 31] and without Powerset to [39]. <p> In Section 5, we PTIME-embed the complex object algebra (and by [1], the complex object calculus) into TLC = . We first present a concise definition of this algebra from <ref> [2] </ref> (Section 5.1). There are two tasks. The first is to PTIME-embed the algebra without Powerset; this is accomplished in Section 5.2. The second is to embed the Powerset operator; this is accomplished in Section 5.3 using additional "type-laundering" technology. <p> The presentation here is taken with slight modifications from <ref> [2] </ref>. 5.1.1 Complex Object Databases We assume the existence of the following countably infinite and pairwise disjoint sets of atomic elements: relation names fR 1 ; R 2 ; : : :g, attributes fA 1 ; A 2 ; : : :g, constants D = fd 1 ; d 2 ;
Reference: [3] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog Extensions for Database Queries and Updates. </title> <journal> J. Comp. System Sci., </journal> <volume> 43 (1991), </volume> <pages> pp. 62-124. </pages>
Reference-contexts: For example, the PTIME queries are those with data complexity that is polynomial in the size of the input. Relational algebra [14], Datalog and Datalog with Negation [30] (written as Datalog : ), and various fixpoint logics <ref> [3, 10, 11, 20, 32] </ref> express practically interesting sets of database queries, 2 all subsets of the PTIME queries. <p> In addition, as shown in [27, 48], every PTIME query can be expressed using fixpoint queries on ordered structures; and, as shown in <ref> [3] </ref>, it suffices to use Datalog : syntax under a variety of semantics (e.g., inflationary) to express the various fixpoint logics. Complex object databases have been proposed as a significant extension of relational databases, with many practical applications; see [2] for a recent survey.
Reference: [4] <author> H. P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics, revised edition. </title> <publisher> North Holland, </publisher> <year> 1984. </year>
Reference-contexts: In other words, we study the ability of TLC to express database queries. Our interest in database computations is in marked contrast to the classical approach to TLC expressibility, which considers computations over Church numerals (see, e.g., <ref> [4, 16, 42] </ref>). There are several results characterizing the expressive power of TLC over Church numerals, but the picture is somewhat complex. <p> Queries are then encoded as well-typed -terms that apply to encodings of input relations and reduce to an encoding of the output relation. For notational convenience, we use TLC = , the typed -calculus with atomic constants and an equality on them, and the associated ffi-reduction of <ref> [4, 12] </ref>. This is not essential for our analysis. In Section 2.4, we show how to encode atomic constants and equality in TLC. <p> In the following, we identify ff-convertible terms and assume that names of bound variables are chosen to be distinct from each other and from all free variables. See <ref> [4] </ref> for details of this "variable convention", standard definitions of substitution and ff- and fi-reduction for both the typed and untyped -calculus, and other reduction notions such as -reduction. Let &gt; be the reflexive, transitive closure of &gt; fi . Note that, reduction preserves types. <p> A -term from which no reduction is possible is in normal form. TLC and TLC = enjoy the following properties, see <ref> [4, 21] </ref>: 1. Church-Rosser property: If E &gt; E 0 and E &gt; E 00 , then there exists a -term E 000 such that E 0 &gt; E 000 and E 00 &gt; E 000 . 2. <p> For every pair of constants o i ; o j , the normal form of (Eq o i o j ) arises from the normal form of (Eq l o i o j ) by a series of -reductions <ref> [4] </ref>. It is known that in a fi-reduction sequence, -reductions can always be pushed to the end [4, Theorem 15.1.6]. This remains true even if Eq-reductions are added, because Eq- and -reductions commute for well-typed terms. <p> It is known that in a fi-reduction sequence, -reductions can always be pushed to the end <ref> [4, Theorem 15.1.6] </ref>. This remains true even if Eq-reductions are added, because Eq- and -reductions commute for well-typed terms. Thus, the normal form of a query using Eq l instead of Eq -reduces to the normal form of the original query. <p> It motivates the further study of reduction strategies in this setting (see <ref> [4] </ref> for a summary). One interesting problem is the behavior of optimal reduction strategies [34] in our setting|do they yield the same resource bounds as our ad-hoc strategies? (4) Our PTIME-embeddings identify "pure" functional database query languages without added constructs or added polymorphism.
Reference: [5] <author> S. Bellantoni and S. Cook. </author> <title> A New Recursion-Theoretic Characterization of the Polytime Functions. </title> <booktitle> In Proceedings 24th STOC (1992), </booktitle> <pages> pp. 283-293. </pages>
Reference-contexts: Can these fragments, under the appropriate input-output conventions, be used to characterize complexity classes exactly? There has been some recent progress on this question. There are a number of functional characterizations of PTIME, e.g., <ref> [5, 13, 18, 19, 33] </ref>. Another such functional characterization, based on appropriate input-output conventions and order 4 TLC = is presented in [23, 24]. Analogous results for PSPACE/EXPTIME and order 5/order 6 TLC = are in [23].
Reference: [6] <author> V. Breazu-Tannen, P. Buneman, and S. Naqvi. </author> <title> Structural Recursion as a Query Language. </title> <booktitle> In Proceedings DBPL3, </booktitle> <pages> pp. 9-19. </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: An elegant way of manipulating complex object databases, related to our paper, is based on functional programming. There has been some practical work in database query languages in this area, e.g., the early FQL language of [8] and the more recent work on structural recursion as a query language <ref> [6, 7, 28] </ref>. One important difference of the framework developed here from [6, 7, 28] is that we use the "pure" TLC without any added recursion operators (the equality predicate and atomic constants used in our presentation are not essential for our results). <p> There has been some practical work in database query languages in this area, e.g., the early FQL language of [8] and the more recent work on structural recursion as a query language <ref> [6, 7, 28] </ref>. One important difference of the framework developed here from [6, 7, 28] is that we use the "pure" TLC without any added recursion operators (the equality predicate and atomic constants used in our presentation are not essential for our results). <p> For example, the typed -calculus with equality is the simplest syntax to date, that can be used to describe the complex object algebra of [1]. In our embeddings we use lists of tuples and simulate sets by eliminating duplicates. In <ref> [1, 6, 7, 28] </ref> sets are used as basic constructs, and set iteration is used instead of list iteration.
Reference: [7] <author> P. Buneman, S. Naqvi, V. Tannen, and L. Wong. </author> <title> Principles of Programming with Complex Objects and Collection Types. </title> <journal> Theoretical Comp. Sci., </journal> <volume> 149 (1995), </volume> <pages> pp. 3-48. </pages>
Reference-contexts: An elegant way of manipulating complex object databases, related to our paper, is based on functional programming. There has been some practical work in database query languages in this area, e.g., the early FQL language of [8] and the more recent work on structural recursion as a query language <ref> [6, 7, 28] </ref>. One important difference of the framework developed here from [6, 7, 28] is that we use the "pure" TLC without any added recursion operators (the equality predicate and atomic constants used in our presentation are not essential for our results). <p> There has been some practical work in database query languages in this area, e.g., the early FQL language of [8] and the more recent work on structural recursion as a query language <ref> [6, 7, 28] </ref>. One important difference of the framework developed here from [6, 7, 28] is that we use the "pure" TLC without any added recursion operators (the equality predicate and atomic constants used in our presentation are not essential for our results). <p> For example, the typed -calculus with equality is the simplest syntax to date, that can be used to describe the complex object algebra of [1]. In our embeddings we use lists of tuples and simulate sets by eliminating duplicates. In <ref> [1, 6, 7, 28] </ref> sets are used as basic constructs, and set iteration is used instead of list iteration.
Reference: [8] <author> P. Buneman, R. E. Frankel, and R. Nikhil. </author> <title> An Implementation Technique for Database Query Languages. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 7 (1982), </volume> <pages> pp. 164-186. </pages>
Reference-contexts: An elegant way of manipulating complex object databases, related to our paper, is based on functional programming. There has been some practical work in database query languages in this area, e.g., the early FQL language of <ref> [8] </ref> and the more recent work on structural recursion as a query language [6, 7, 28].
Reference: [9] <author> A. K. Chandra and D. Harel. </author> <title> Computable Queries for Relational Databases. </title> <journal> J. Comp. System Sci., </journal> <volume> 21 (1980), </volume> <pages> pp. 156-178. </pages>
Reference-contexts: DB Motivation and Background: Database query languages have been motivated by Codd's work on relational databases [14] and have been studied in the context of finite model theory, e.g., <ref> [9, 10, 11, 15, 27, 46, 48] </ref>. Database queries, i.e., the functions from finite models to finite models expressed in various languages, have been classified based on their complexity. <p> We next define the computable queries using the auxiliary concept of "C-genericity." The queries that we consider are generalizations of the computable relational queries of Chandra and Harel <ref> [9] </ref>. Definition 5.3 Let C be a finite set of constants. A mapping f from instances to instances is C-generic if for each permutation of the constants which is the identity on C and each instance I, f ( (I)) = (f (I)). <p> Clearly, any computation that is not elementary is not captured by our framework. What should be added to the typed -calculus to capture exactly the more powerful database query languages such as the computable queries of <ref> [9] </ref>? (3) The use of reduction strategies in PTIME-embeddings provides a link between complexity theory, finite model theory, and the typed -calculus. It motivates the further study of reduction strategies in this setting (see [4] for a summary).
Reference: [10] <author> A. K. Chandra and D. Harel. </author> <title> Structure and Complexity of Relational Queries. </title> <journal> J. Comp. System Sci., </journal> <volume> 25 (1982), </volume> <pages> pp. 99-128. </pages>
Reference-contexts: DB Motivation and Background: Database query languages have been motivated by Codd's work on relational databases [14] and have been studied in the context of finite model theory, e.g., <ref> [9, 10, 11, 15, 27, 46, 48] </ref>. Database queries, i.e., the functions from finite models to finite models expressed in various languages, have been classified based on their complexity. <p> Database queries, i.e., the functions from finite models to finite models expressed in various languages, have been classified based on their complexity. The most commonly used measure is the one of data complexity of <ref> [10, 48] </ref>, where the program expressing a query is fixed and the input data is variable. For example, the PTIME queries are those with data complexity that is polynomial in the size of the input. <p> For example, the PTIME queries are those with data complexity that is polynomial in the size of the input. Relational algebra [14], Datalog and Datalog with Negation [30] (written as Datalog : ), and various fixpoint logics <ref> [3, 10, 11, 20, 32] </ref> express practically interesting sets of database queries, 2 all subsets of the PTIME queries. <p> For the analysis of expressibility of the complex object algebra with Powerset we refer to [26, 31] and without Powerset to [39]. Note that, although Powerset in [1] is powerful (as are the second order queries in <ref> [10, 15, 46] </ref>), it is an impractical primitive, and much attention has been given to algebras without Powerset for PTIME queries. An elegant way of manipulating complex object databases, related to our paper, is based on functional programming. <p> This seems inherent in our framework, since the - calculus does not provide unordered sets as primitive objects. Note that, condition (3) and the fact that atomic constants are not distinguishable by the Eq-reduction rules, enforce genericity in the sense of <ref> [10] </ref>. To see this, consider a query term Q, input relations R 1 ; : : :; R l for Q, and a bijection of D that acts as the identity on the constants appearing in Q. <p> Furthermore, Hull and Su exhibited a hierarchy of classes of queries based on the level of set nesting allowed in temporary predicates [26]. One level leads to SO, i.e., relational calculus extended with second order quantification <ref> [10] </ref>. Kuper and Vardi showed a somewhat analogous result [31]: there exists a hierarchy of classes of powerset algebras based on the allowable level of nesting of powersets. <p> The restrictions consist of syntactically forcing formulas to provide limited ranges to all variables. The restricted calculus is called CALC . The equivalence of ALG and CALC is shown in [1]. 2 We are concerned here exclusively with the data complexity in the sense of <ref> [10, 48] </ref>. 26 5.2 Coding ALG . We begin by extending our embedding of relational algebra to deal with complex objects and to express the Tup, Tupcomb, Set, and Setcomb operators. The Powerset operator comes with its own share of difficulties and its treatment is postponed to the next section.
Reference: [11] <author> A. K. Chandra and D. Harel. </author> <title> Horn Clause Queries and Generalizations. </title> <journal> J. Logic Programming, </journal> <volume> 2 (1985), </volume> <pages> pp. 1-15. </pages>
Reference-contexts: DB Motivation and Background: Database query languages have been motivated by Codd's work on relational databases [14] and have been studied in the context of finite model theory, e.g., <ref> [9, 10, 11, 15, 27, 46, 48] </ref>. Database queries, i.e., the functions from finite models to finite models expressed in various languages, have been classified based on their complexity. <p> For example, the PTIME queries are those with data complexity that is polynomial in the size of the input. Relational algebra [14], Datalog and Datalog with Negation [30] (written as Datalog : ), and various fixpoint logics <ref> [3, 10, 11, 20, 32] </ref> express practically interesting sets of database queries, 2 all subsets of the PTIME queries.
Reference: [12] <author> A. Church. </author> <title> The Calculi of Lambda-Conversion. </title> <publisher> Princeton University Press, </publisher> <year> 1941. </year>
Reference-contexts: 1 Introduction TLC Motivation and Background: The simply typed -calculus of Church <ref> [12] </ref> (typed - calculus or TLC for short) with its syntax and operational semantics is an essential part of any functional programming language. For example, TLC is a core subset of all state-of-the-art functional languages such as ML, Haskell, Miranda, etc. <p> Queries are then encoded as well-typed -terms that apply to encodings of input relations and reduce to an encoding of the output relation. For notational convenience, we use TLC = , the typed -calculus with atomic constants and an equality on them, and the associated ffi-reduction of <ref> [4, 12] </ref>. This is not essential for our analysis. In Section 2.4, we show how to encode atomic constants and equality in TLC.
Reference: [13] <author> A. Cobham. </author> <title> The Intrinsic Computational Difficulty of Functions. </title> <editor> In Y. Bar-Hillel, editor, </editor> <booktitle> International Conference on Logic, Methodology, and Philosophy of Science, </booktitle> <pages> pp. 24-30. </pages> <publisher> North Holland, </publisher> <year> 1964. </year>
Reference-contexts: Can these fragments, under the appropriate input-output conventions, be used to characterize complexity classes exactly? There has been some recent progress on this question. There are a number of functional characterizations of PTIME, e.g., <ref> [5, 13, 18, 19, 33] </ref>. Another such functional characterization, based on appropriate input-output conventions and order 4 TLC = is presented in [23, 24]. Analogous results for PSPACE/EXPTIME and order 5/order 6 TLC = are in [23].
Reference: [14] <author> E. F. Codd. </author> <title> Relational Completeness of Database Sublanguages. </title> <editor> In R. Rustin, editor, </editor> <booktitle> Database Systems, </booktitle> <pages> pp. 65-98. </pages> <publisher> Prentice Hall, </publisher> <year> 1972. </year>
Reference-contexts: DB Motivation and Background: Database query languages have been motivated by Codd's work on relational databases <ref> [14] </ref> and have been studied in the context of finite model theory, e.g., [9, 10, 11, 15, 27, 46, 48]. Database queries, i.e., the functions from finite models to finite models expressed in various languages, have been classified based on their complexity. <p> The most commonly used measure is the one of data complexity of [10, 48], where the program expressing a query is fixed and the input data is variable. For example, the PTIME queries are those with data complexity that is polynomial in the size of the input. Relational algebra <ref> [14] </ref>, Datalog and Datalog with Negation [30] (written as Datalog : ), and various fixpoint logics [3, 10, 11, 20, 32] express practically interesting sets of database queries, 2 all subsets of the PTIME queries. <p> Section 2.2 outlines the basics of list iteration. Section 2.3 describes our input-output conventions with atomic constants and equality in detail, and Section 2.4 discusses how to encode atomic constants and equality in the "pure" TLC. In Section 3, we PTIME-embed relational algebra (and by <ref> [14] </ref>, relational calculus) into TLC = by encoding the relational algebra operators. The encodings are mostly straightforward, but some care is needed to eliminate duplicate tuples from the output. In Section 4, we PTIME-embed Datalog : into TLC = by encoding fixpoint queries. <p> Thus, the conditions of Definitions 2.1 and 2.3 are still satisfied (at the price of having the typings depend in a uniform fashion on the input size). 3 Coding Relational Algebra We begin by demonstrating how the relational algebra operators of <ref> [14] </ref> can be represented in the simply typed -calculus with equality.
Reference: [15] <author> R. Fagin. </author> <title> Generalized First-Order Spectra and Polynomial-Time Recognizable Sets. </title> <booktitle> SIAM-AMS Proceedings, 7 (1974), </booktitle> <pages> pp. 43-73. </pages>
Reference-contexts: DB Motivation and Background: Database query languages have been motivated by Codd's work on relational databases [14] and have been studied in the context of finite model theory, e.g., <ref> [9, 10, 11, 15, 27, 46, 48] </ref>. Database queries, i.e., the functions from finite models to finite models expressed in various languages, have been classified based on their complexity. <p> For the analysis of expressibility of the complex object algebra with Powerset we refer to [26, 31] and without Powerset to [39]. Note that, although Powerset in [1] is powerful (as are the second order queries in <ref> [10, 15, 46] </ref>), it is an impractical primitive, and much attention has been given to algebras without Powerset for PTIME queries. An elegant way of manipulating complex object databases, related to our paper, is based on functional programming.
Reference: [16] <author> S. Fortune, D. Leivant, and M. O'Donnell. </author> <title> The Expressiveness of Simple and Second-Order Type Structures. </title> <journal> J. of the ACM, </journal> <volume> 30 (1983), </volume> <pages> pp. 151-185. </pages>
Reference-contexts: In other words, we study the ability of TLC to express database queries. Our interest in database computations is in marked contrast to the classical approach to TLC expressibility, which considers computations over Church numerals (see, e.g., <ref> [4, 16, 42] </ref>). There are several results characterizing the expressive power of TLC over Church numerals, but the picture is somewhat complex. <p> If inputs and outputs are Church numerals given more complex types than Int, exponentiation and predecessor can also be expressed. However, Statman (as quoted in <ref> [16] </ref>) showed that equality, ordering, and subtraction are not expressible in TLC for any typing of Church numerals. fl A preliminary version of the work presented here appeared in [25]. y Dept. of Computer Science, Brown University, Box 1910, Providence, RI 02912. <p> This is different from the setting of <ref> [16, 42] </ref>, but necessary to express queries beyond relational algebra. We type k-ary relations as fo k g for inputs and outputs in Section 3 and for outputs in Section 4.
Reference: [17] <author> J.-Y. Girard. </author> <title> Interpretation Fonctionelle et Elimination des Coupures de l'Arithmetique d'Ordre Superieur. </title> <institution> These de Doctorat d'Etat, Universite de Paris VII, </institution> <year> 1972. </year>
Reference-contexts: Simple types have been criticized for limiting flexibility in programs, but they have also been criticized for limiting expressibility. These criticisms have provided some motivation for examining more powerful typed calculi, such as the Girard-Reynolds second-order -calculus <ref> [17, 41] </ref> (adding polymorphism via type quantification) or Milner's ML [22, 38] (adding monomorphic fixpoints and let-polymorphism). We believe that the criticism of TLC inflexibility is justified, although hard to quantify.
Reference: [18] <author> J.-Y. Girard, A. Scedrov, P. J. Scott. </author> <title> Bounded Linear Logic: A Modular Approach to Polynomial Time Computability. </title> <journal> Theoretical Comp. Sci., </journal> <volume> 97 (1992), </volume> <pages> pp. 1-66. </pages>
Reference-contexts: Can these fragments, under the appropriate input-output conventions, be used to characterize complexity classes exactly? There has been some recent progress on this question. There are a number of functional characterizations of PTIME, e.g., <ref> [5, 13, 18, 19, 33] </ref>. Another such functional characterization, based on appropriate input-output conventions and order 4 TLC = is presented in [23, 24]. Analogous results for PSPACE/EXPTIME and order 5/order 6 TLC = are in [23].
Reference: [19] <author> Y. Gurevich. </author> <title> Algebras of Feasible Functions. </title> <booktitle> In Proceedings 24th FOCS (1983), </booktitle> <pages> pp. 210-214. </pages>
Reference-contexts: Can these fragments, under the appropriate input-output conventions, be used to characterize complexity classes exactly? There has been some recent progress on this question. There are a number of functional characterizations of PTIME, e.g., <ref> [5, 13, 18, 19, 33] </ref>. Another such functional characterization, based on appropriate input-output conventions and order 4 TLC = is presented in [23, 24]. Analogous results for PSPACE/EXPTIME and order 5/order 6 TLC = are in [23].
Reference: [20] <author> Y. Gurevich and S. Shelah. </author> <title> Fixed-point Extensions of First Order Logic. </title> <journal> Ann. Pure Appl. Logic, </journal> <volume> 32 (1986), </volume> <pages> pp. 265-280. 43 </pages>
Reference-contexts: For example, the PTIME queries are those with data complexity that is polynomial in the size of the input. Relational algebra [14], Datalog and Datalog with Negation [30] (written as Datalog : ), and various fixpoint logics <ref> [3, 10, 11, 20, 32] </ref> express practically interesting sets of database queries, 2 all subsets of the PTIME queries.
Reference: [21] <author> C. Gunter. </author> <title> Semantics of Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: A -term from which no reduction is possible is in normal form. TLC and TLC = enjoy the following properties, see <ref> [4, 21] </ref>: 1. Church-Rosser property: If E &gt; E 0 and E &gt; E 00 , then there exists a -term E 000 such that E 0 &gt; E 000 and E 00 &gt; E 000 . 2. <p> They work with or without type annotations and with or without constants). TLC and TLC = type reconstruction is linear-time in the size of the program analyzed. 5. Completeness of Equational Reasoning: fi-equality completely characterizes validity in TLC models. See <ref> [21, 44, 45] </ref> for details and for many semantic properties of TLC.
Reference: [22] <author> R. Harper, R. Milner, M. Tofte. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: For example, TLC is a core subset of all state-of-the-art functional languages such as ML, Haskell, Miranda, etc. TLC together with let-polymorphism <ref> [22, 38] </ref> is often informally referred to as core-ML. In this paper, we investigate the expressive power of TLC from the point of view of expressing computations over finite structures. In other words, we study the ability of TLC to express database queries. <p> Simple types have been criticized for limiting flexibility in programs, but they have also been criticized for limiting expressibility. These criticisms have provided some motivation for examining more powerful typed calculi, such as the Girard-Reynolds second-order -calculus [17, 41] (adding polymorphism via type quantification) or Milner's ML <ref> [22, 38] </ref> (adding monomorphic fixpoints and let-polymorphism). We believe that the criticism of TLC inflexibility is justified, although hard to quantify.
Reference: [23] <author> G. Hillebrand. </author> <title> Finite Model Theory in the Simply Typed Lambda Calculus. </title> <type> Ph.D. Thesis, </type> <institution> Brown Univ., </institution> <year> 1994. </year>
Reference-contexts: However, these embeddings are not PTIME-embeddings in the sense above, because they do not come with PTIME reduction strategies. Turning them into PTIME-embeddings requires a change in the computational engine, i.e., the TLC reduction mechanism (this is carried out in <ref> [23, 24] </ref>). The deus ex machina of this paper is list iteration|primitive recursion on lists. While certainly less powerful than unbounded recursion, it does what we need. The list iteration technology developed in our proofs, e.g., duplicate elimination in relational algebra or implementing iteration in Datalog is interesting. <p> This program is carried out in <ref> [23, 24] </ref>, where it is shown that for computations over finite structures, TLC = of order 4 expresses only PTIME computations. Thus, over finite structures, TLC = of order 4 captures exactly PTIME. <p> There are a number of functional characterizations of PTIME, e.g., [5, 13, 18, 19, 33]. Another such functional characterization, based on appropriate input-output conventions and order 4 TLC = is presented in <ref> [23, 24] </ref>. Analogous results for PSPACE/EXPTIME and order 5/order 6 TLC = are in [23]. These characterizations are proven by an analysis of reduction strategies augmented with data structures. Note that increased order leads to more expressive power as in [26, 29, 31]. <p> There are a number of functional characterizations of PTIME, e.g., [5, 13, 18, 19, 33]. Another such functional characterization, based on appropriate input-output conventions and order 4 TLC = is presented in [23, 24]. Analogous results for PSPACE/EXPTIME and order 5/order 6 TLC = are in <ref> [23] </ref>. These characterizations are proven by an analysis of reduction strategies augmented with data structures. Note that increased order leads to more expressive power as in [26, 29, 31].
Reference: [24] <author> G. Hillebrand and P. Kanellakis. </author> <title> Functional Database Query Languages as Typed Lambda Calculi of Fixed Order. </title> <booktitle> In Proceedings 13th PODS (1994), </booktitle> <pages> pp. 222-231. </pages>
Reference-contexts: However, these embeddings are not PTIME-embeddings in the sense above, because they do not come with PTIME reduction strategies. Turning them into PTIME-embeddings requires a change in the computational engine, i.e., the TLC reduction mechanism (this is carried out in <ref> [23, 24] </ref>). The deus ex machina of this paper is list iteration|primitive recursion on lists. While certainly less powerful than unbounded recursion, it does what we need. The list iteration technology developed in our proofs, e.g., duplicate elimination in relational algebra or implementing iteration in Datalog is interesting. <p> This program is carried out in <ref> [23, 24] </ref>, where it is shown that for computations over finite structures, TLC = of order 4 expresses only PTIME computations. Thus, over finite structures, TLC = of order 4 captures exactly PTIME. <p> There are a number of functional characterizations of PTIME, e.g., [5, 13, 18, 19, 33]. Another such functional characterization, based on appropriate input-output conventions and order 4 TLC = is presented in <ref> [23, 24] </ref>. Analogous results for PSPACE/EXPTIME and order 5/order 6 TLC = are in [23]. These characterizations are proven by an analysis of reduction strategies augmented with data structures. Note that increased order leads to more expressive power as in [26, 29, 31].
Reference: [25] <author> G. Hillebrand, P. Kanellakis, and H. Mairson. </author> <title> Database Query Languages Embedded in the Typed Lambda Calculus. </title> <booktitle> In Proceedings 8th LICS (1993), </booktitle> <pages> pp. 332-343. </pages>
Reference-contexts: However, Statman (as quoted in [16]) showed that equality, ordering, and subtraction are not expressible in TLC for any typing of Church numerals. fl A preliminary version of the work presented here appeared in <ref> [25] </ref>. y Dept. of Computer Science, Brown University, Box 1910, Providence, RI 02912. Research supported by ONR Contract N00014-91-J-4052, ARPA Order 8225. z Dept. of Computer Science, Brown University, Box 1910, Providence, RI 02912.
Reference: [26] <author> R. Hull and J. Su. </author> <title> On the Expressive Power of Database Queries with Intermediate Types. </title> <journal> J. Comput. System Sci., </journal> <volume> 43 (1991), </volume> <pages> pp. 219-267. </pages>
Reference-contexts: Well-known languages in this area are the complex object algebras with or without Powerset of [1]. For the analysis of expressibility of the complex object algebra with Powerset we refer to <ref> [26, 31] </ref> and without Powerset to [39]. Note that, although Powerset in [1] is powerful (as are the second order queries in [10, 15, 46]), it is an impractical primitive, and much attention has been given to algebras without Powerset for PTIME queries. <p> It turns out that a query is in ALG/CALC iff it is an elementary query (we refer to <ref> [26, 31] </ref> for detailed definitions and proofs). Furthermore, Hull and Su exhibited a hierarchy of classes of queries based on the level of set nesting allowed in temporary predicates [26]. One level leads to SO, i.e., relational calculus extended with second order quantification [10]. <p> It turns out that a query is in ALG/CALC iff it is an elementary query (we refer to [26, 31] for detailed definitions and proofs). Furthermore, Hull and Su exhibited a hierarchy of classes of queries based on the level of set nesting allowed in temporary predicates <ref> [26] </ref>. One level leads to SO, i.e., relational calculus extended with second order quantification [10]. Kuper and Vardi showed a somewhat analogous result [31]: there exists a hierarchy of classes of powerset algebras based on the allowable level of nesting of powersets. <p> Analogous results for PSPACE/EXPTIME and order 5/order 6 TLC = are in [23]. These characterizations are proven by an analysis of reduction strategies augmented with data structures. Note that increased order leads to more expressive power as in <ref> [26, 29, 31] </ref>. Low orders are particularly interesting because of the few primitives in TLC or TLC = , as opposed to the languages analyzed in [26, 29, 31]. (2) Not all database query languages can be embedded in the typed -calculus. <p> Note that increased order leads to more expressive power as in <ref> [26, 29, 31] </ref>. Low orders are particularly interesting because of the few primitives in TLC or TLC = , as opposed to the languages analyzed in [26, 29, 31]. (2) Not all database query languages can be embedded in the typed -calculus. Clearly, any computation that is not elementary is not captured by our framework.
Reference: [27] <author> N. Immerman. </author> <title> Relational Queries Computable in Polynomial Time. </title> <journal> Info. and Comp., </journal> <volume> 68 (1986), </volume> <pages> pp. 86-104. </pages>
Reference-contexts: DB Motivation and Background: Database query languages have been motivated by Codd's work on relational databases [14] and have been studied in the context of finite model theory, e.g., <ref> [9, 10, 11, 15, 27, 46, 48] </ref>. Database queries, i.e., the functions from finite models to finite models expressed in various languages, have been classified based on their complexity. <p> Relational algebra [14], Datalog and Datalog with Negation [30] (written as Datalog : ), and various fixpoint logics [3, 10, 11, 20, 32] express practically interesting sets of database queries, 2 all subsets of the PTIME queries. In addition, as shown in <ref> [27, 48] </ref>, every PTIME query can be expressed using fixpoint queries on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics (e.g., inflationary) to express the various fixpoint logics. <p> They are easily implementable in PTIME on any Turing Machine implementation of TLC. We also study syntactically restricted fragments of the full TLC defined using the standard notion of functionality order (cf. Section 2.1). Using the characterization of PTIME by <ref> [27, 48] </ref> and a slightly modified encoding of databases, we prove: It is possible to embed all PTIME queries in order 4 TLC = . Here we must keep equality as part of the setting, i.e., its removal would raise the order. <p> The next step is to find a way of iterating such queries in order to compute fixpoints. It suffices to perform a polynomial number of iterations using inflationary semantics to capture all PTIME-computable queries <ref> [27, 48] </ref>. 4.1 Iterating Relational Queries Intuitively, the solution is very simple|we build a sufficiently long list from a Cartesian product of the input relations and then use that list as an iterator to repeat a relational query polynomially many times. <p> We now have the machinery in place to compute inflationary fixpoints of relational algebra queries. By Immerman's and Vardi's characterization of the PTIME queries <ref> [27, 48] </ref>, this gives us the ability the express arbitrary PTIME queries, provided we can encode an ordering relation on the active domain of the input.
Reference: [28] <author> N. Immerman, S. Patnaik, and D. Stemple. </author> <title> The Expressiveness of a Family of Finite Set Languages. </title> <booktitle> In Proceedings 10th PODS (1991), </booktitle> <pages> pp. 37-52. </pages>
Reference-contexts: An elegant way of manipulating complex object databases, related to our paper, is based on functional programming. There has been some practical work in database query languages in this area, e.g., the early FQL language of [8] and the more recent work on structural recursion as a query language <ref> [6, 7, 28] </ref>. One important difference of the framework developed here from [6, 7, 28] is that we use the "pure" TLC without any added recursion operators (the equality predicate and atomic constants used in our presentation are not essential for our results). <p> There has been some practical work in database query languages in this area, e.g., the early FQL language of [8] and the more recent work on structural recursion as a query language <ref> [6, 7, 28] </ref>. One important difference of the framework developed here from [6, 7, 28] is that we use the "pure" TLC without any added recursion operators (the equality predicate and atomic constants used in our presentation are not essential for our results). <p> For example, the typed -calculus with equality is the simplest syntax to date, that can be used to describe the complex object algebra of [1]. In our embeddings we use lists of tuples and simulate sets by eliminating duplicates. In <ref> [1, 6, 7, 28] </ref> sets are used as basic constructs, and set iteration is used instead of list iteration.
Reference: [29] <author> A. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> The Hierarchy of Finitely Typed Functional Programs. </title> <booktitle> In Proceedings 2nd LICS (1987), </booktitle> <pages> pp. 225-235. </pages>
Reference-contexts: Analogous results for PSPACE/EXPTIME and order 5/order 6 TLC = are in [23]. These characterizations are proven by an analysis of reduction strategies augmented with data structures. Note that increased order leads to more expressive power as in <ref> [26, 29, 31] </ref>. Low orders are particularly interesting because of the few primitives in TLC or TLC = , as opposed to the languages analyzed in [26, 29, 31]. (2) Not all database query languages can be embedded in the typed -calculus. <p> Note that increased order leads to more expressive power as in <ref> [26, 29, 31] </ref>. Low orders are particularly interesting because of the few primitives in TLC or TLC = , as opposed to the languages analyzed in [26, 29, 31]. (2) Not all database query languages can be embedded in the typed -calculus. Clearly, any computation that is not elementary is not captured by our framework.
Reference: [30] <author> P. G. Kolaitis and C. H. Papadimitriou. </author> <title> Why Not Negation By Fixpoint? In Proceedings 7th PODS, </title> <journal> pp. </journal> <pages> 231-239, </pages> <year> 1988. </year>
Reference-contexts: For example, the PTIME queries are those with data complexity that is polynomial in the size of the input. Relational algebra [14], Datalog and Datalog with Negation <ref> [30] </ref> (written as Datalog : ), and various fixpoint logics [3, 10, 11, 20, 32] express practically interesting sets of database queries, 2 all subsets of the PTIME queries.
Reference: [31] <author> G. Kuper and M. Vardi. </author> <title> On the Complexity of Queries in the Logical Data Model. </title> <journal> Theoretical Comput. Sci., </journal> <volume> 116 (1993), </volume> <pages> pp. 33-57. </pages>
Reference-contexts: Well-known languages in this area are the complex object algebras with or without Powerset of [1]. For the analysis of expressibility of the complex object algebra with Powerset we refer to <ref> [26, 31] </ref> and without Powerset to [39]. Note that, although Powerset in [1] is powerful (as are the second order queries in [10, 15, 46]), it is an impractical primitive, and much attention has been given to algebras without Powerset for PTIME queries. <p> It turns out that a query is in ALG/CALC iff it is an elementary query (we refer to <ref> [26, 31] </ref> for detailed definitions and proofs). Furthermore, Hull and Su exhibited a hierarchy of classes of queries based on the level of set nesting allowed in temporary predicates [26]. One level leads to SO, i.e., relational calculus extended with second order quantification [10]. <p> Furthermore, Hull and Su exhibited a hierarchy of classes of queries based on the level of set nesting allowed in temporary predicates [26]. One level leads to SO, i.e., relational calculus extended with second order quantification [10]. Kuper and Vardi showed a somewhat analogous result <ref> [31] </ref>: there exists a hierarchy of classes of powerset algebras based on the allowable level of nesting of powersets. One might wonder what is at the bottom of the hierarchy, i.e., what is the power of the algebra without the powerset operation. <p> Analogous results for PSPACE/EXPTIME and order 5/order 6 TLC = are in [23]. These characterizations are proven by an analysis of reduction strategies augmented with data structures. Note that increased order leads to more expressive power as in <ref> [26, 29, 31] </ref>. Low orders are particularly interesting because of the few primitives in TLC or TLC = , as opposed to the languages analyzed in [26, 29, 31]. (2) Not all database query languages can be embedded in the typed -calculus. <p> Note that increased order leads to more expressive power as in <ref> [26, 29, 31] </ref>. Low orders are particularly interesting because of the few primitives in TLC or TLC = , as opposed to the languages analyzed in [26, 29, 31]. (2) Not all database query languages can be embedded in the typed -calculus. Clearly, any computation that is not elementary is not captured by our framework.
Reference: [32] <author> D. Leivant. </author> <title> Inductive Definitions over Finite Structures. </title> <journal> Information and Computation, </journal> <volume> 89 (1990), </volume> <pages> pp. 95-108. </pages>
Reference-contexts: For example, the PTIME queries are those with data complexity that is polynomial in the size of the input. Relational algebra [14], Datalog and Datalog with Negation [30] (written as Datalog : ), and various fixpoint logics <ref> [3, 10, 11, 20, 32] </ref> express practically interesting sets of database queries, 2 all subsets of the PTIME queries.
Reference: [33] <author> D. Leivant and J.-Y. Marion. </author> <title> Lambda Calculus Characterizations of Poly-Time. </title> <journal> Fundamenta Informaticae, </journal> <volume> 19 (1993), </volume> <pages> pp. 167-184. </pages>
Reference-contexts: For example, a simulation of quadratic time is forced to take at least an exponential number of reduction steps in these constructions. One way of avoiding the anomalies associated with representations over Church numerals was recently demonstrated by Leivant and Marion <ref> [33] </ref> for an "impure" version of TLC. By augmenting the simply typed -calculus with a pairing operator and a "bottom tier" consisting of the free algebra of words over f0; 1g with associated constructor, destructor, and discriminator functions, they obtain a simple characterization of the computational complexity class PTIME. <p> Can these fragments, under the appropriate input-output conventions, be used to characterize complexity classes exactly? There has been some recent progress on this question. There are a number of functional characterizations of PTIME, e.g., <ref> [5, 13, 18, 19, 33] </ref>. Another such functional characterization, based on appropriate input-output conventions and order 4 TLC = is presented in [23, 24]. Analogous results for PSPACE/EXPTIME and order 5/order 6 TLC = are in [23].
Reference: [34] <author> J.-J. Levy. </author> <title> Optimal Reductions in the Lambda-Calculus. </title> <editor> In J. Seldin and J. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays in Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pp. 159-191. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: It motivates the further study of reduction strategies in this setting (see [4] for a summary). One interesting problem is the behavior of optimal reduction strategies <ref> [34] </ref> in our setting|do they yield the same resource bounds as our ad-hoc strategies? (4) Our PTIME-embeddings identify "pure" functional database query languages without added constructs or added polymorphism.
Reference: [35] <author> H. G. Mairson. </author> <title> A Simple Proof of a Theorem of Statman. </title> <journal> Theoretical Comp. Sci., </journal> <volume> 103 (1992), </volume> <pages> pp. 387-394. </pages>
Reference-contexts: The proof in [43] uses a result of Meyer concerning the complexity of decision problems in higher-order type theory [37]. A simple proof of both these results appears in <ref> [35] </ref>. However, there are a number of difficulties when one tries to turn these proofs into frameworks for computations. They do not separate the fixed program (representing a function) from the variable data (representing the input). They use computational overkill for lower complexity classes. <p> The additional requirement (3) is important if one wishes to consider the typed -calculus as a functional database query language operating by reduction. We call embeddings that satisfy (1-3) PTIME-embeddings . It is implicit in the literature <ref> [35, 37, 43] </ref> that, under our input-output conventions but without considering an efficient reduction strategy, all elementary functions are expressible (where this class of functions includes PTIME, NP, PSPACE, EXPTIME, k-EXPTIME, etc. [40]). <p> We present here a simple way of encoding these "impure" features using "pure" TLC terms. For another way of coding up equality on finite domains see <ref> [35] </ref>. Let A = fo 1 ; o 2 ; : : :; o N g be the set of constants occurring in a particular input. We call this finite set the active domain.
Reference: [36] <author> J. McCarthy. </author> <title> Recursive Functions of Symbolic Expressions and their Computation by Machine, Part I. </title> <journal> Comm. of the ACM, </journal> <volume> 3 (1960), </volume> <pages> pp. 185-195. </pages>
Reference-contexts: Also, the "type-laundering" constructions are somewhat involved. let-polymorphism would have greatly simplified them, but would have taken us outside TLC. From a programmer's point of view, we illustrate how simply typed LISP <ref> [36] </ref> can accomplish a great deal with lambda, even without using recursion on names or fixpoint combinators! From a database query language perspective, our PTIME-embeddings indicate that the typed - calculus, with its syntax, semantics and reduction strategies, can be viewed as a unifying functional framework that is between the declarative
Reference: [37] <author> A. R. Meyer. </author> <title> The Inherent Computational Complexity of Theories of Ordered Sets. </title> <booktitle> In Proceedings of the International Congress of Mathematicians, </booktitle> <pages> pp. 477-482, </pages> <year> 1975. </year>
Reference-contexts: This follows from a theorem of Statman that deciding equivalence of normal forms of two well-typed -terms is not elementary recursive [43]. The proof in [43] uses a result of Meyer concerning the complexity of decision problems in higher-order type theory <ref> [37] </ref>. A simple proof of both these results appears in [35]. However, there are a number of difficulties when one tries to turn these proofs into frameworks for computations. They do not separate the fixed program (representing a function) from the variable data (representing the input). <p> The additional requirement (3) is important if one wishes to consider the typed -calculus as a functional database query language operating by reduction. We call embeddings that satisfy (1-3) PTIME-embeddings . It is implicit in the literature <ref> [35, 37, 43] </ref> that, under our input-output conventions but without considering an efficient reduction strategy, all elementary functions are expressible (where this class of functions includes PTIME, NP, PSPACE, EXPTIME, k-EXPTIME, etc. [40]).
Reference: [38] <author> R. Milner. </author> <title> A Theory of Type Polymorphism in Programming. </title> <journal> J. Comp. System Sci. </journal> <volume> 17 (1978), </volume> <pages> pp. 348-375. </pages>
Reference-contexts: For example, TLC is a core subset of all state-of-the-art functional languages such as ML, Haskell, Miranda, etc. TLC together with let-polymorphism <ref> [22, 38] </ref> is often informally referred to as core-ML. In this paper, we investigate the expressive power of TLC from the point of view of expressing computations over finite structures. In other words, we study the ability of TLC to express database queries. <p> Simple types have been criticized for limiting flexibility in programs, but they have also been criticized for limiting expressibility. These criticisms have provided some motivation for examining more powerful typed calculi, such as the Girard-Reynolds second-order -calculus [17, 41] (adding polymorphism via type quantification) or Milner's ML <ref> [22, 38] </ref> (adding monomorphic fixpoints and let-polymorphism). We believe that the criticism of TLC inflexibility is justified, although hard to quantify.
Reference: [39] <author> J. Paredaens and D. Van Gucht. </author> <title> Possibilities and Limitations of Using Flat Operators in Nested Algebra Expressions. </title> <booktitle> In Proceedings 7th PODS, </booktitle> <pages> pp. 29-38, </pages> <year> 1988. </year> <month> 44 </month>
Reference-contexts: Well-known languages in this area are the complex object algebras with or without Powerset of [1]. For the analysis of expressibility of the complex object algebra with Powerset we refer to [26, 31] and without Powerset to <ref> [39] </ref>. Note that, although Powerset in [1] is powerful (as are the second order queries in [10, 15, 46]), it is an impractical primitive, and much attention has been given to algebras without Powerset for PTIME queries. <p> Thus ALG is strictly less expressive than ALG. Paredaens and Van Gucht showed that a query from a relational schema to a relational schema is expressible in ALG iff it is expressible in the classical relational algebra <ref> [39] </ref>. A restricted calculus is presented in [1]. The restrictions consist of syntactically forcing formulas to provide limited ranges to all variables. The restricted calculus is called CALC .
Reference: [40] <author> C. H. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison Wesley, </publisher> <year> 1994. </year>
Reference-contexts: We call embeddings that satisfy (1-3) PTIME-embeddings . It is implicit in the literature [35, 37, 43] that, under our input-output conventions but without considering an efficient reduction strategy, all elementary functions are expressible (where this class of functions includes PTIME, NP, PSPACE, EXPTIME, k-EXPTIME, etc. <ref> [40] </ref>). For all practical purposes, ELEMENTARY is a powerful complexity class with a somewhat misleading name; to quote from [40]: "the optimism in this term may seem a little overstated; the term was introduced in the context of undecidability." Thus, our finite model input-output conventions illustrate the nontrivial power of TLC. <p> 37, 43] that, under our input-output conventions but without considering an efficient reduction strategy, all elementary functions are expressible (where this class of functions includes PTIME, NP, PSPACE, EXPTIME, k-EXPTIME, etc. <ref> [40] </ref>). For all practical purposes, ELEMENTARY is a powerful complexity class with a somewhat misleading name; to quote from [40]: "the optimism in this term may seem a little overstated; the term was introduced in the context of undecidability." Thus, our finite model input-output conventions illustrate the nontrivial power of TLC. Our new contribution here is that we provide PTIME-embeddings of various practical query languages.
Reference: [41] <author> J. C. Reynolds. </author> <title> Towards a Theory of Type Structure. </title> <booktitle> In Proceedings of the Paris Colloquium on Programming, </booktitle> <pages> pp. 408-425. </pages> <booktitle> Lecture Notes in Computer Science 19, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1974. </year>
Reference-contexts: Simple types have been criticized for limiting flexibility in programs, but they have also been criticized for limiting expressibility. These criticisms have provided some motivation for examining more powerful typed calculi, such as the Girard-Reynolds second-order -calculus <ref> [17, 41] </ref> (adding polymorphism via type quantification) or Milner's ML [22, 38] (adding monomorphic fixpoints and let-polymorphism). We believe that the criticism of TLC inflexibility is justified, although hard to quantify.
Reference: [42] <author> H. Schwichtenberg. </author> <title> Definierbare Funktionen im -Kalkul mit Typen. </title> <journal> Archiv fur mathemati-sche Logik und Grundlagenforschung, </journal> <volume> 17 (1976), </volume> <pages> pp. 113-114. </pages>
Reference-contexts: In other words, we study the ability of TLC to express database queries. Our interest in database computations is in marked contrast to the classical approach to TLC expressibility, which considers computations over Church numerals (see, e.g., <ref> [4, 16, 42] </ref>). There are several results characterizing the expressive power of TLC over Church numerals, but the picture is somewhat complex. <p> There are several results characterizing the expressive power of TLC over Church numerals, but the picture is somewhat complex. If inputs and outputs are Church numerals typed as Int (where Int (t ! t ) ! t ! t for some fixed t ), Schwichtenberg <ref> [42] </ref> and Statman showed that the expressible multi-argument functions of type (Int; : : :; Int) ! Int (or equivalently, Int ! ! Int ! Int) are exactly the extended polynomials, i.e., the functions generated by 0 and 1 using the operations addition, multiplication and conditional. <p> This is different from the setting of <ref> [16, 42] </ref>, but necessary to express queries beyond relational algebra. We type k-ary relations as fo k g for inputs and outputs in Section 3 and for outputs in Section 4.
Reference: [43] <author> R. Statman. </author> <title> The Typed -Calculus is not Elementary Recursive. </title> <journal> Theoretical Comp. Sci., </journal> <volume> 9 (1979), </volume> <pages> pp. 73-81. </pages>
Reference-contexts: In fact, it is well known that provably hard decision problems can be embedded into TLC. This follows from a theorem of Statman that deciding equivalence of normal forms of two well-typed -terms is not elementary recursive <ref> [43] </ref>. The proof in [43] uses a result of Meyer concerning the complexity of decision problems in higher-order type theory [37]. A simple proof of both these results appears in [35]. However, there are a number of difficulties when one tries to turn these proofs into frameworks for computations. <p> In fact, it is well known that provably hard decision problems can be embedded into TLC. This follows from a theorem of Statman that deciding equivalence of normal forms of two well-typed -terms is not elementary recursive <ref> [43] </ref>. The proof in [43] uses a result of Meyer concerning the complexity of decision problems in higher-order type theory [37]. A simple proof of both these results appears in [35]. However, there are a number of difficulties when one tries to turn these proofs into frameworks for computations. <p> The additional requirement (3) is important if one wishes to consider the typed -calculus as a functional database query language operating by reduction. We call embeddings that satisfy (1-3) PTIME-embeddings . It is implicit in the literature <ref> [35, 37, 43] </ref> that, under our input-output conventions but without considering an efficient reduction strategy, all elementary functions are expressible (where this class of functions includes PTIME, NP, PSPACE, EXPTIME, k-EXPTIME, etc. [40]).
Reference: [44] <author> R. Statman. </author> <title> Completeness, Invariance, and -Definability. </title> <journal> J. Symbolic Logic, </journal> <volume> 47 (1982), </volume> <pages> pp. 17-26. </pages>
Reference-contexts: They work with or without type annotations and with or without constants). TLC and TLC = type reconstruction is linear-time in the size of the program analyzed. 5. Completeness of Equational Reasoning: fi-equality completely characterizes validity in TLC models. See <ref> [21, 44, 45] </ref> for details and for many semantic properties of TLC.
Reference: [45] <author> R. Statman. </author> <title> Equality between Functionals, Revisited. </title> <booktitle> In Harvey Friedman's Research on the Foundations of Mathematics, </booktitle> <pages> pp. 331-338. </pages> <publisher> North-Holland, </publisher> <year> 1985. </year>
Reference-contexts: They work with or without type annotations and with or without constants). TLC and TLC = type reconstruction is linear-time in the size of the program analyzed. 5. Completeness of Equational Reasoning: fi-equality completely characterizes validity in TLC models. See <ref> [21, 44, 45] </ref> for details and for many semantic properties of TLC.
Reference: [46] <author> L. Stockmeyer. </author> <title> The Polynomial-Time Hierarchy. </title> <journal> Theoret. Comp. Sci., </journal> <volume> 3 (1977), </volume> <pages> pp. 1-22. </pages>
Reference-contexts: DB Motivation and Background: Database query languages have been motivated by Codd's work on relational databases [14] and have been studied in the context of finite model theory, e.g., <ref> [9, 10, 11, 15, 27, 46, 48] </ref>. Database queries, i.e., the functions from finite models to finite models expressed in various languages, have been classified based on their complexity. <p> For the analysis of expressibility of the complex object algebra with Powerset we refer to [26, 31] and without Powerset to [39]. Note that, although Powerset in [1] is powerful (as are the second order queries in <ref> [10, 15, 46] </ref>), it is an impractical primitive, and much attention has been given to algebras without Powerset for PTIME queries. An elegant way of manipulating complex object databases, related to our paper, is based on functional programming.
Reference: [47] <author> J. D. Ullman. </author> <booktitle> Principles of Database Systems, </booktitle> <address> 2 nd edition. </address> <publisher> Computer Science Press, </publisher> <year> 1982. </year>
Reference-contexts: This involves coding the following operators, where t; t 0 denote tuples and R; S relations, that is, sets of tuples (see <ref> [47] </ref> for more details): * Intersection, defined by Intersection (R; S) = ft j t 2 R ^ t 2 Sg, where arity (R) = arity (S); * Setminus, defined by Setminus (R; S) = ft j t 2 R ^ t =2 Sg, where arity (R) = arity (S); *
Reference: [48] <author> M. Y. Vardi. </author> <title> The Complexity of Relational Query Languages. </title> <booktitle> In Proceedings 14th STOC, </booktitle> <pages> pp. 137-146, </pages> <year> 1982. </year>
Reference-contexts: DB Motivation and Background: Database query languages have been motivated by Codd's work on relational databases [14] and have been studied in the context of finite model theory, e.g., <ref> [9, 10, 11, 15, 27, 46, 48] </ref>. Database queries, i.e., the functions from finite models to finite models expressed in various languages, have been classified based on their complexity. <p> Database queries, i.e., the functions from finite models to finite models expressed in various languages, have been classified based on their complexity. The most commonly used measure is the one of data complexity of <ref> [10, 48] </ref>, where the program expressing a query is fixed and the input data is variable. For example, the PTIME queries are those with data complexity that is polynomial in the size of the input. <p> Relational algebra [14], Datalog and Datalog with Negation [30] (written as Datalog : ), and various fixpoint logics [3, 10, 11, 20, 32] express practically interesting sets of database queries, 2 all subsets of the PTIME queries. In addition, as shown in <ref> [27, 48] </ref>, every PTIME query can be expressed using fixpoint queries on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics (e.g., inflationary) to express the various fixpoint logics. <p> They are easily implementable in PTIME on any Turing Machine implementation of TLC. We also study syntactically restricted fragments of the full TLC defined using the standard notion of functionality order (cf. Section 2.1). Using the characterization of PTIME by <ref> [27, 48] </ref> and a slightly modified encoding of databases, we prove: It is possible to embed all PTIME queries in order 4 TLC = . Here we must keep equality as part of the setting, i.e., its removal would raise the order. <p> The next step is to find a way of iterating such queries in order to compute fixpoints. It suffices to perform a polynomial number of iterations using inflationary semantics to capture all PTIME-computable queries <ref> [27, 48] </ref>. 4.1 Iterating Relational Queries Intuitively, the solution is very simple|we build a sufficiently long list from a Cartesian product of the input relations and then use that list as an iterator to repeat a relational query polynomially many times. <p> We now have the machinery in place to compute inflationary fixpoints of relational algebra queries. By Immerman's and Vardi's characterization of the PTIME queries <ref> [27, 48] </ref>, this gives us the ability the express arbitrary PTIME queries, provided we can encode an ordering relation on the active domain of the input. <p> The restrictions consist of syntactically forcing formulas to provide limited ranges to all variables. The restricted calculus is called CALC . The equivalence of ALG and CALC is shown in [1]. 2 We are concerned here exclusively with the data complexity in the sense of <ref> [10, 48] </ref>. 26 5.2 Coding ALG . We begin by extending our embedding of relational algebra to deal with complex objects and to express the Tup, Tupcomb, Set, and Setcomb operators. The Powerset operator comes with its own share of difficulties and its treatment is postponed to the next section.
References-found: 48

