URL: http://www.research.digital.com/SRC/personal/caw/papers/deadlock-mit-tr526.ps
Refering-URL: http://www.research.digital.com/SRC/personal/caw/papers.html
Root-URL: http://www.research.digital.com
Title: Preventing Recursion Deadlock in Concurrent Object-Oriented Systems  
Author: by Eric A. Brewer Carl A. Waldspurger 
Keyword: deadlock, recursion, object-oriented systems, programming languages, concurrency  
Address: Cambridge, Massachusetts 02139  
Affiliation: Massachusetts Institute of Technology Laboratory for Computer Science  
Note: c Massachusetts Institute of Technology 1992 This work was supported in part by the National Science Foundation under grant CCR-8716884, by the Defense Advanced Research Projects Agency (DARPA) under Contract N00014-89-J-1988, and by an equipment grant from Digital Equipment Corporation. Eric A. Brewer was supported by an Office of Naval Research Fellowship.  
Date: January 1992  
Pubnum: Technical Report MIT/LCS/TR-526  
Abstract: This paper presents solutions to the problem of deadlock due to recursion in concurrent object-oriented programming languages. Two language-independent, system-level mechanisms for solving this problem are proposed: a novel technique using multi-ported objects, and a named-threads scheme that borrows from previous work in distributed computing. We compare the solutions and present an analysis of their relative merits. 
Abstract-found: 1
Intro-found: 1
Reference: [Agh86] <author> Gul Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: If recursive calling patterns are completely known in advance, deadlock can be avoided in actor systems by using replacement actors. By cleverly specifying insensitive actors that buffer most incoming messages while responding to a few special messages (such as become), programmers can write code that explicitly avoids potential deadlocks <ref> [Agh86] </ref>. Insensitive actors are automatically generated by compilers for actor languages to support the acceptance of include a reference to the client object that originally received the message.
Reference: [Ame87] <author> Pierre America. </author> <title> POOL-T | A Parallel Object-Oriented Language. </title> <editor> In Akinori Yonezawa and Mario Tokoro, eds., </editor> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Recursion is a powerful programming technique that allows straightforward expression of many algorithms. Unfortunately, recursion often leads to deadlock in contemporary concurrent object-oriented systems. In many systems <ref> [Ame87, Yon87, Man87, Chi90] </ref>, a method that modifies an object's state cannot even call itself recursively. This occurs because the object (as sender) is blocked waiting for its call to complete, but the called method never executes because the object (as receiver) is blocked. <p> A combination of three factors leads to recursion deadlock. First, an object must hold a lock on some state. In systems with at most one active thread per object <ref> [Ame87, Yon87, Man87, Chi90] </ref>, there is a single implicit lock for the entire object state. Second, the object must make a blocking call to some object (possibly itself), holding the lock while it waits for the response to the call. <p> A partial solution for fixed-depth recursion is the use of selective message acceptance constructs <ref> [Yon87, Ame87] </ref>. For example, ABCL/1 allows calls to be accepted in the body of a method if the object enters a selective "waiting mode". In this case, the recursive call is handled in the body and need not acquire the object lock. <p> invocation and is released explicitly via the ready construct, which indicates that the method has finished modifying the actor's state. 5 To avoid complication, we will assume that there is a single implicit lock per object that provides mutual exclusion for the entire object state, as in most contemporary languages <ref> [Ame87, Yon87, Man87, Chi90] </ref>. However, the solutions we present can be easily adapted for languages with more sophisticated locking schemes; we briefly discuss this after pre senting the solutions for the single-lock case. * Thread: A thread is a single flow of control that performs a sequential computation.
Reference: [Bos89] <author> Jan van den Bos and Chris Laffra. </author> <title> PROCOL: A Parallel Object Language with Protocols. </title> <booktitle> Proceedings of the Fourth ACM Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA '89), </booktitle> <month> October </month> <year> 1989. </year>
Reference-contexts: In fact, these low-level actor mechanisms could be used to implement the solutions we propose without system-level changes. In general, systems that provide linguistic control of message acceptance, such as enabled-sets [Tom89] or protocols <ref> [Bos89] </ref>, can be used to implement our language-independent solutions. Techniques for deadlock detection from the distributed systems and database literature [Gli80, Sin89] could also be used to address the recursion deadlock problem.
Reference: [Chi90] <author> Andrew A. Chien. </author> <title> Concurrent Aggregates (CA): An Object-Oriented Language for Fine-Grained Message-Passing Machines., </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Recursion is a powerful programming technique that allows straightforward expression of many algorithms. Unfortunately, recursion often leads to deadlock in contemporary concurrent object-oriented systems. In many systems <ref> [Ame87, Yon87, Man87, Chi90] </ref>, a method that modifies an object's state cannot even call itself recursively. This occurs because the object (as sender) is blocked waiting for its call to complete, but the called method never executes because the object (as receiver) is blocked. <p> A combination of three factors leads to recursion deadlock. First, an object must hold a lock on some state. In systems with at most one active thread per object <ref> [Ame87, Yon87, Man87, Chi90] </ref>, there is a single implicit lock for the entire object state. Second, the object must make a blocking call to some object (possibly itself), holding the lock while it waits for the response to the call. <p> invocation and is released explicitly via the ready construct, which indicates that the method has finished modifying the actor's state. 5 To avoid complication, we will assume that there is a single implicit lock per object that provides mutual exclusion for the entire object state, as in most contemporary languages <ref> [Ame87, Yon87, Man87, Chi90] </ref>. However, the solutions we present can be easily adapted for languages with more sophisticated locking schemes; we briefly discuss this after pre senting the solutions for the single-lock case. * Thread: A thread is a single flow of control that performs a sequential computation.
Reference: [Dal87] <author> William J. Dally. </author> <title> A VLSI Architecture for Concurrent Data Structures. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1987. </year> <note> 22 REFERENCES </note>
Reference-contexts: In some languages, such as Acore [Man87], message ordering is completely nondeterministic. Others, such as ABCL/1 [Yon87], make the transmission-order preserva 7 Exceptions include Argus [Lis88] and Concurrent Smalltalk <ref> [Dal87] </ref>. 8 6 MULTI-PORTED OBJECT SOLUTION tion assumption (TOPA). TOPA guarantees point-to-point ordering: for any pair of messages sent from an object X to another object Y , the order of reception is identical to the order of transmission. <p> After perform ing the last call, suspend the current thread pending replies. 9 This extension (or change) is done at most once per method invocation, not once per call. 6.4 Extension for Multiple Locks 11 6.4 Extension for Multiple Locks Some languages, such as Concurrent Smalltalk <ref> [Dal87] </ref>, support the addition of explicit locks for object methods as a general mechanism for concurrency control. The multi-ported object solution for recursion deadlock can be adapted to work with such languages.
Reference: [Gli80] <author> Virgil D. Gligor and Susan H. </author> <title> Shattuck. On Deadlock Detection in Distributed Systems. </title> <journal> IEEE Transactions on Software Engineering 6(5): </journal> <pages> 435-440, </pages> <month> September </month> <year> 1980. </year>
Reference-contexts: In general, systems that provide linguistic control of message acceptance, such as enabled-sets [Tom89] or protocols [Bos89], can be used to implement our language-independent solutions. Techniques for deadlock detection from the distributed systems and database literature <ref> [Gli80, Sin89] </ref> could also be used to address the recursion deadlock problem. Deadlock detection algorithms examine process and resource interactions to find cycles (assumed to be relatively infrequent), and usually operate autonomously, separate from normal system activities.
Reference: [Gol83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: In this case, the original thread is suspended until its subthreads, or children, all reply and join with the original parent thread. 6 4 Recursive Call Semantics 4.1 Existing Sequential Semantics In sequential object-oriented systems such as Smalltalk-80 <ref> [Gol83] </ref> and C++ [Str86], there is only a single thread of control, so mutual-exclusion locks are unnecessary. In these systems, if the call chain generated during a method invocation results in a later invocation on the same object, the recursive call is permitted to modify the object's state.
Reference: [Had77] <author> Bruce K. Haddon. </author> <title> Nested Monitor Calls. </title> <journal> Operating Systems Review, </journal> <volume> vol. 11, no. 3, </volume> <month> October </month> <year> 1977. </year>
Reference-contexts: Thus, deadlock occurs if there is a cycle in the call chain. 3 Most work on the nested-monitor problem occurred before the advent of concurrent object-oriented languages. Solutions presented during that period amounted to either releasing the lock across the call or forbidding calls entirely <ref> [Had77] </ref>. 3 Computational Model We make a few basic assumptions about the underlying computational model. The model we assume encompasses most contemporary concurrent object-oriented systems. Objects abstractly encapsulate local state with a set of methods that can manipulate that state directly.
Reference: [Kah87] <author> Kenneth Kahn, Eric Dean Tribble, Mark S. Miller, and Daniel G. Bobrow. Vulcan: </author> <title> Logical Concurrent Objects. In Ehud Shapiro, Concurrent Prolog: Collected Papers, </title> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: These amount to releasing the object lock and ensuring that the next method invoked is the recursive call (e.g., by prepending it to the incoming message queue), which will reacquire the lock. This approach is implicit in languages such as Vulcan <ref> [Kah87] </ref>, which ensure that calls to self are processed before other incoming messages. Another solution for direct recursion is to provide procedures in addition to methods [Yon87]. Unlike methods, procedures are stateless and need not be associated with an object. Since procedures are stateless, they do not require locks.
Reference: [Kah89] <author> Kenneth Kahn. </author> <title> Objects: A Fresh Look. </title> <booktitle> Proceedings of the Third European Conference on Object-Oriented Programming (ECOOP '89), </booktitle> <publisher> Cambridge University Press, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: Conventional object-oriented systems assume objects have a single port through which all incoming messages arrive. The traditional notion of an object can be relaxed to allow several ports. The use of multiple ports to enable different client capabilities, multiple viewpoints, and secure communications is explored in <ref> [Kah89] </ref>. We demonstrate that the recursion deadlock problem can be solved by providing objects with the 6.1 Message Acceptance 9 ability to create and select ports dynamically. The recursion problem is solved by creating a new current port for each method invocation.
Reference: [Lie86] <author> Henry Lieberman. </author> <title> Using prototypical objects to implement shared behavior in object-oriented systems. </title> <booktitle> Proceedings of the First ACM Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA '86), </booktitle> <month> September </month> <year> 1986. </year>
Reference-contexts: More sophisticated programs that manipulate cyclic data structures, use call-backs while responding to unusual or exceptional conditions, or implement dynamic sharing mechanisms are all candidates for recursion deadlock. Some programming styles are also prone to recursion deadlock. For example, using inheritance by delegation <ref> [Lie86, Lie87] </ref>, an object can delegate the handling of a method to another object dynamically. <p> The term client is used because the object that is the target of the delegation can be thought of as performing a service for the original object <ref> [Lie86] </ref>. 4 3 COMPUTATIONAL MODEL replies to messages sent by a locked actor. 2 Although actor replacement provides the flexibility required to write deadlock-free code, the complexity of explicitly introducing insensitive actors and behaviors for all possible recursive calling patterns is daunting.
Reference: [Lie87] <author> Henry Lieberman. </author> <title> Concurrent Object-Oriented Programming in Act1. </title> <editor> In Akinori Yonezawa and Mario Tokoro, eds., </editor> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: More sophisticated programs that manipulate cyclic data structures, use call-backs while responding to unusual or exceptional conditions, or implement dynamic sharing mechanisms are all candidates for recursion deadlock. Some programming styles are also prone to recursion deadlock. For example, using inheritance by delegation <ref> [Lie86, Lie87] </ref>, an object can delegate the handling of a method to another object dynamically.
Reference: [Lis87] <author> Barbara Liskov. </author> <title> Implementation of Argus. </title> <booktitle> Proceedings of the 11th ACM Symposium on Operating Systems Principles, </booktitle> <month> November </month> <year> 1987. </year>
Reference-contexts: Section 8 presents an example using the multi-ported object approach to avoid recursion deadlock. 7 Named-Threads Solution The essential elements of named threads are based on action ids from Argus <ref> [Lis88, Lis87] </ref>, a language for robust distributed computing. The named-threads approach to avoiding recursion deadlock assigns each thread a unique identifier that travels with it through every object and message. <p> The techniques used to provide fault tolerance over many machines are quite complex and are not all relevant to recursion deadlock. Hidden in those techniques are the use of action ids, upon which thread ids are based <ref> [Lis87] </ref>. 7.1 Concurrent Calls Most concurrent object-oriented languages allow a single thread to create multiple threads. This wreaks havoc with the simple thread-id solution presented above.
Reference: [Lis88] <author> Barbara Liskov. </author> <title> Distributed Programming in Argus. </title> <journal> Communications of the ACM, </journal> <volume> vol. 31, no. 3, </volume> <month> March </month> <year> 1988. </year>
Reference-contexts: In some languages, such as Acore [Man87], message ordering is completely nondeterministic. Others, such as ABCL/1 [Yon87], make the transmission-order preserva 7 Exceptions include Argus <ref> [Lis88] </ref> and Concurrent Smalltalk [Dal87]. 8 6 MULTI-PORTED OBJECT SOLUTION tion assumption (TOPA). TOPA guarantees point-to-point ordering: for any pair of messages sent from an object X to another object Y , the order of reception is identical to the order of transmission. <p> Section 8 presents an example using the multi-ported object approach to avoid recursion deadlock. 7 Named-Threads Solution The essential elements of named threads are based on action ids from Argus <ref> [Lis88, Lis87] </ref>, a language for robust distributed computing. The named-threads approach to avoiding recursion deadlock assigns each thread a unique identifier that travels with it through every object and message. <p> If the ids match, the incoming message has access to the state. Because the new task 12 7 NAMED-THREADS SOLUTION can determine that it already has access, it does not wait for the current task to finish, thus avoiding deadlock. The essential elements of named threads originated in Argus <ref> [Lis88] </ref>, a language for robust distributed computing. Argus uses transactions to provide fault tolerance: a transaction either completes correctly, or if aborted, has no effect on the state of the system. A transaction often involves several objects (possibly on different machines) and several threads within an object.
Reference: [Lis77] <author> Andrew Lister. </author> <title> The problem of nested monitor calls. </title> <journal> Operating Systems Review, </journal> <volume> vol. 11, no. 2, </volume> <month> July </month> <year> 1977. </year>
Reference-contexts: Nevertheless, the general idea of maintaining a list of blocked-process dependencies is related to the deadlock-prevention techniques that we propose. Finally, recursion deadlock is closely related to the nested-monitor problem <ref> [Lis77] </ref>. In the nested-monitor problem, monitors correspond to objects with a single lock. Nested-monitor calls correspond to blocking calls made while an object holds its lock.
Reference: [Man87] <author> Carl R. Manning. Acore: </author> <title> The Design of a Core Actor Language and its Compiler. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Recursion is a powerful programming technique that allows straightforward expression of many algorithms. Unfortunately, recursion often leads to deadlock in contemporary concurrent object-oriented systems. In many systems <ref> [Ame87, Yon87, Man87, Chi90] </ref>, a method that modifies an object's state cannot even call itself recursively. This occurs because the object (as sender) is blocked waiting for its call to complete, but the called method never executes because the object (as receiver) is blocked. <p> A combination of three factors leads to recursion deadlock. First, an object must hold a lock on some state. In systems with at most one active thread per object <ref> [Ame87, Yon87, Man87, Chi90] </ref>, there is a single implicit lock for the entire object state. Second, the object must make a blocking call to some object (possibly itself), holding the lock while it waits for the response to the call. <p> invocation and is released explicitly via the ready construct, which indicates that the method has finished modifying the actor's state. 5 To avoid complication, we will assume that there is a single implicit lock per object that provides mutual exclusion for the entire object state, as in most contemporary languages <ref> [Ame87, Yon87, Man87, Chi90] </ref>. However, the solutions we present can be easily adapted for languages with more sophisticated locking schemes; we briefly discuss this after pre senting the solutions for the single-lock case. * Thread: A thread is a single flow of control that performs a sequential computation. <p> This matches the use of call and send in current object-oriented systems. 4.3 Recursion and Message Order The effect of the proposed mechanisms on message order depends on the policy of the underlying language. In some languages, such as Acore <ref> [Man87] </ref>, message ordering is completely nondeterministic. Others, such as ABCL/1 [Yon87], make the transmission-order preserva 7 Exceptions include Argus [Lis88] and Concurrent Smalltalk [Dal87]. 8 6 MULTI-PORTED OBJECT SOLUTION tion assumption (TOPA).
Reference: [Sin89] <author> Mukesh Singhal. </author> <title> Deadlock Detection in Distributed Systems. </title> <booktitle> IEEE Computer, </booktitle> <month> Novem-ber </month> <year> 1989. </year>
Reference-contexts: In general, systems that provide linguistic control of message acceptance, such as enabled-sets [Tom89] or protocols [Bos89], can be used to implement our language-independent solutions. Techniques for deadlock detection from the distributed systems and database literature <ref> [Gli80, Sin89] </ref> could also be used to address the recursion deadlock problem. Deadlock detection algorithms examine process and resource interactions to find cycles (assumed to be relatively infrequent), and usually operate autonomously, separate from normal system activities.
Reference: [Str86] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: In this case, the original thread is suspended until its subthreads, or children, all reply and join with the original parent thread. 6 4 Recursive Call Semantics 4.1 Existing Sequential Semantics In sequential object-oriented systems such as Smalltalk-80 [Gol83] and C++ <ref> [Str86] </ref>, there is only a single thread of control, so mutual-exclusion locks are unnecessary. In these systems, if the call chain generated during a method invocation results in a later invocation on the same object, the recursive call is permitted to modify the object's state.
Reference: [Tom89] <author> Chris Tomlinson and Vineet Singh. </author> <title> Inheritance and Synchronization with Enabled-Sets. </title> <booktitle> Proceedings of the Fourth ACM Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA '89), </booktitle> <month> October </month> <year> 1989. </year>
Reference-contexts: In fact, these low-level actor mechanisms could be used to implement the solutions we propose without system-level changes. In general, systems that provide linguistic control of message acceptance, such as enabled-sets <ref> [Tom89] </ref> or protocols [Bos89], can be used to implement our language-independent solutions. Techniques for deadlock detection from the distributed systems and database literature [Gli80, Sin89] could also be used to address the recursion deadlock problem.
Reference: [Yon87] <author> Akinori Yonezawa, Etsuya Shibayama, Toshihiro Takada, and Yasuaki Honda. </author> <title> Mod-elling and Programming in an Object-Oriented Concurrent Language ABCL/1. </title> <editor> In Aki-nori Yonezawa and Mario Tokoro, eds., </editor> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Recursion is a powerful programming technique that allows straightforward expression of many algorithms. Unfortunately, recursion often leads to deadlock in contemporary concurrent object-oriented systems. In many systems <ref> [Ame87, Yon87, Man87, Chi90] </ref>, a method that modifies an object's state cannot even call itself recursively. This occurs because the object (as sender) is blocked waiting for its call to complete, but the called method never executes because the object (as receiver) is blocked. <p> A combination of three factors leads to recursion deadlock. First, an object must hold a lock on some state. In systems with at most one active thread per object <ref> [Ame87, Yon87, Man87, Chi90] </ref>, there is a single implicit lock for the entire object state. Second, the object must make a blocking call to some object (possibly itself), holding the lock while it waits for the response to the call. <p> This approach is implicit in languages such as Vulcan [Kah87], which ensure that calls to self are processed before other incoming messages. Another solution for direct recursion is to provide procedures in addition to methods <ref> [Yon87] </ref>. Unlike methods, procedures are stateless and need not be associated with an object. Since procedures are stateless, they do not require locks. Using this approach, a method calls a procedure and the procedure handles the recursion. <p> A partial solution for fixed-depth recursion is the use of selective message acceptance constructs <ref> [Yon87, Ame87] </ref>. For example, ABCL/1 allows calls to be accepted in the body of a method if the object enters a selective "waiting mode". In this case, the recursive call is handled in the body and need not acquire the object lock. <p> invocation and is released explicitly via the ready construct, which indicates that the method has finished modifying the actor's state. 5 To avoid complication, we will assume that there is a single implicit lock per object that provides mutual exclusion for the entire object state, as in most contemporary languages <ref> [Ame87, Yon87, Man87, Chi90] </ref>. However, the solutions we present can be easily adapted for languages with more sophisticated locking schemes; we briefly discuss this after pre senting the solutions for the single-lock case. * Thread: A thread is a single flow of control that performs a sequential computation. <p> In some languages, such as Acore [Man87], message ordering is completely nondeterministic. Others, such as ABCL/1 <ref> [Yon87] </ref>, make the transmission-order preserva 7 Exceptions include Argus [Lis88] and Concurrent Smalltalk [Dal87]. 8 6 MULTI-PORTED OBJECT SOLUTION tion assumption (TOPA).
References-found: 20

