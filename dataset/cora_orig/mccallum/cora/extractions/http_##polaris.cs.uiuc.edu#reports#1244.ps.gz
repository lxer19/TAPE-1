URL: http://polaris.cs.uiuc.edu/reports/1244.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/tech_reports.html
Root-URL: http://www.cs.uiuc.edu
Email: [kwang|harrison]@csrd.uiuc.edu  
Title: Interprocedural Data Flow Analysis for Compile-time Memory Management  
Author: Kwangkeun Yi and Williams Ludwell Harrison III 
Note: Contents  
Affiliation: Center for Supercomputing Research and Development University of Illinois at Urbana-Champaign  
Abstract: We have designed and implemented in C an interprocedural data flow analysis that will estimate the memory object lifetime and its temporal locality. The analysis is an abstract interpretation. The target language is a multilingual intermediate language called MIL. Since we have ANSI C, Fortran, and Scheme front-ends for the target language, the analysis works for programs written in these high-level languages. The analysis information can be used for many kinds of compile-time memory management, which include boosting the generational garbage collection, explicit garbage deallocation, hierarchical memory performance improvement, and static memory performance evaluation. We present an analysis example of our implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [AH87] <editor> Samson Abramsky and Chris Hankin, editors. </editor> <title> Abstract Interpretation of Declarative Languages. </title> <publisher> Ellis Horwood Limited, </publisher> <year> 1987. </year>
Reference-contexts: The reader may want to see [Har92] for a definition of MIL. 1.3 Collecting Analysis from An Abstract Interpreter Our analysis is an abstract interpretation. We will assume the readers have some knowledge of the abstract interpretation framework <ref> [CC77, CC79, Bur87, AH87] </ref>. Throughout this paper, we regard an abstract interpreter definition as a specification for a collecting analysis. A collecting analysis computes, for each program point of an input program, information that describes all the possible program states at that point that can occur during real execution.
Reference: [Amm92] <author> Zahira Ammarguellat. </author> <title> A control-flow normalization algorithm and its complexity. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 18(3) </volume> <pages> 237-251, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Note also that there is no goto or return. Those control constructs are removed by the control flow normalization methods (for example, see <ref> [Amm92] </ref>). The reader may want to see [Har92] for a definition of MIL. 1.3 Collecting Analysis from An Abstract Interpreter Our analysis is an abstract interpretation. We will assume the readers have some knowledge of the abstract interpretation framework [CC77, CC79, Bur87, AH87].
Reference: [Bur87] <author> Geoffrey L. Burn. </author> <title> Abstract Interpretation and the Parallel Evaluation of Functional Languages. </title> <type> PhD thesis, </type> <institution> Department of Computing, Imperial College, University of London, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: Our goal is to develop a static analysis that can reduce the memory management cost at compile-time. We have designed and implemented an interprocedural data flow analysis that estimates the memory object lifetime and its temporal locality. The analysis is an abstract interpretation <ref> [CC77, Bur87] </ref>. It is implementated in C. The target language is a multilingual intermediate language called MIL 1 . Since we have ANSI C, FORTRAN, and SCHEME front-ends for the target language, we analyze programs written in these high-level languages. <p> The reader may want to see [Har92] for a definition of MIL. 1.3 Collecting Analysis from An Abstract Interpreter Our analysis is an abstract interpretation. We will assume the readers have some knowledge of the abstract interpretation framework <ref> [CC77, CC79, Bur87, AH87] </ref>. Throughout this paper, we regard an abstract interpreter definition as a specification for a collecting analysis. A collecting analysis computes, for each program point of an input program, information that describes all the possible program states at that point that can occur during real execution. <p> Definition 1 If f 2 X ! Y then abs X!Y = f:^x: t fabs Y (f (x))jabs X (x) v ^xg: Since all abs comply with the framework of Burn <ref> [Bur87] </ref>, 29 Theorem 1 (Semi-homomorphism) If f : X ! Y; abs Y ffi f v abs X!Y (f ) ffi abs X : Theorem 2 For each abstract operation ^ f : ^ X ! ^ Y defined in the abstract semantics and its concrete correspondent f : X !
Reference: [CC77] <author> Patrick Cousot and Radhia Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Conference Record of the 4th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1977. </year>
Reference-contexts: Our goal is to develop a static analysis that can reduce the memory management cost at compile-time. We have designed and implemented an interprocedural data flow analysis that estimates the memory object lifetime and its temporal locality. The analysis is an abstract interpretation <ref> [CC77, Bur87] </ref>. It is implementated in C. The target language is a multilingual intermediate language called MIL 1 . Since we have ANSI C, FORTRAN, and SCHEME front-ends for the target language, we analyze programs written in these high-level languages. <p> The reader may want to see [Har92] for a definition of MIL. 1.3 Collecting Analysis from An Abstract Interpreter Our analysis is an abstract interpretation. We will assume the readers have some knowledge of the abstract interpretation framework <ref> [CC77, CC79, Bur87, AH87] </ref>. Throughout this paper, we regard an abstract interpreter definition as a specification for a collecting analysis. A collecting analysis computes, for each program point of an input program, information that describes all the possible program states at that point that can occur during real execution.
Reference: [CC79] <author> Patrick Cousot and Radhia Cousot. </author> <title> Systematic design of program analysis frameworks. </title> <booktitle> In Conference Record of the Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 269-282, </pages> <year> 1979. </year>
Reference-contexts: The reader may want to see [Har92] for a definition of MIL. 1.3 Collecting Analysis from An Abstract Interpreter Our analysis is an abstract interpretation. We will assume the readers have some knowledge of the abstract interpretation framework <ref> [CC77, CC79, Bur87, AH87] </ref>. Throughout this paper, we regard an abstract interpreter definition as a specification for a collecting analysis. A collecting analysis computes, for each program point of an input program, information that describes all the possible program states at that point that can occur during real execution.
Reference: [Har89] <author> Williams L. Harrison III. </author> <title> The interprocedural analysis and automatic parallelization of scheme programs. </title> <booktitle> Lisp and Symbolic Computation, 2(3 and </booktitle> 4):179-396, 1989. 
Reference-contexts: The analysis infers the future access frequency of objects at every program point. Thus, at each program point it can be determined which object can be released for it will not be accessed after the point. This analysis is comparable to Harrison's <ref> [Har89] </ref> approach. His analysis determines for each object a procedure whose activation encompasses the object's lifetime. Thus the object is associated with the activation record of the procedure. When the procedure is deactivated, the object can be freed at that time. <p> In this section, we will apply an idea that is orthogonal to the previous one and can be used for all expressions, not restricted to call expression. This idea, which follows, has been proposed by Harri-son <ref> [Har89, Har92] </ref> as "environment pruning" or "reachability." 38 For the evaluation of an expression, we don't have to pass the whole abstract store. We only have to pass a part of it that can be accessed (reached) during the subcomputation.
Reference: [Har92] <author> Williams L. Harrison III. </author> <title> Semantic Analysis of Symbolic Programs for Automatic Parallelization. </title> <note> Book in preparation, </note> <year> 1992. </year>
Reference-contexts: The target language is MIL. To reiterate, since we have ANSI C, FORTRAN, and SCHEME front-ends already built for the target language, our analysis analyzes programs written in those high-level languages. 1 MIL is defined by Harrison <ref> [Har92] </ref> for use in the multilingual parallelizing compiler system MIPRAC. 2 The abstract syntax of MIL is as follows. <p> Note also that there is no goto or return. Those control constructs are removed by the control flow normalization methods (for example, see [Amm92]). The reader may want to see <ref> [Har92] </ref> for a definition of MIL. 1.3 Collecting Analysis from An Abstract Interpreter Our analysis is an abstract interpretation. We will assume the readers have some knowledge of the abstract interpretation framework [CC77, CC79, Bur87, AH87]. <p> The target language is MIL (see Section 1.2). We select the procedural movement (procedure calls and returns) as the time unit. This choice is a reasonable one since the target language (MIL <ref> [Har92] </ref>) has the procedure call as one-and-only control construct in which all iterations are expressed. In Section 2.1 we provide preliminaries about semantic domains and notations. In Section 2.2 we present an instrumented semantics, where the object lifetime and its temporal locality are recorded in terms of procedural movements. <p> Atomic function domain allows an economical representation of its elements; it is identical to a product domain. As we will see, atomic function domain is enough to express a series of abstract semantics for memory management analysis. Notations We follow the notations used in <ref> [Har92] </ref> with some additions. * In the notation let x 1 = Expression 1 x 2 = Expression 2 . . . x n = Expression n in Expression n+1 Expression k+1 may refer to any of x 1 through x k , but there is no recursion among the definitions <p> The portion is determined by the offset z and size k. (The following definition is borrowed from Harrison <ref> [Har92] </ref>.) Read (b; z; k) = let S c = fhz 0 ; k 0 i 2 Z fi Zjz z 0 ^ z + k z 0 + k 0 g in (bj S c j ZfiY ) ffi h * Write : B ! B ! Z ! Z <p> * Write : B ! B ! Z ! Z ! B Write (b d ; b s ; z; k) paste a portion of b s (offset 0 and size k) into a portion of b d (offset z and size k). (The following definition is borrowed from Harrison <ref> [Har92] </ref>.) Write (b d ; b s ; z; k) = let S c = fhz 0 ; k 0 i 2 Z fi Y jz z 0 ^ z + k z 0 + k 0 g h : Z fi Y ! Z fi Z = hz 0 ; <p> In this section, we will apply an idea that is orthogonal to the previous one and can be used for all expressions, not restricted to call expression. This idea, which follows, has been proposed by Harri-son <ref> [Har89, Har92] </ref> as "environment pruning" or "reachability." 38 For the evaluation of an expression, we don't have to pass the whole abstract store. We only have to pass a part of it that can be accessed (reached) during the subcomputation. <p> The time unit is the procedural movements (procedure calls and returns). The procedural movement is a reasonable choice as the abstract time unit since the target language MIL <ref> [Har92] </ref> has the procedure call 46 as the one-and-only control construct in which all iterations are expressed. We found that the semantics expressions, as well as the domain definitions, are very important for the accuracy improvement.
Reference: [Sto77] <author> Joseph E. Stoy. </author> <title> Denotational Semantics: the Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: We will use the fixpoint induction method <ref> [Sto77] </ref>. In the fixpoint induction method, for an inclusive assertion Q (x), we only have to prove that Q (?) holds and that Q (x) implies Q (f (x)), in order to show that Q (fix f (x)) holds. <p> be 1. f and g are monotonic functions and 2. 8h-~ ; e; s; pi : abs (f h-~ ; e; s; pi) v g (h-~ ; abs (e); abs (s); abs (p)i) Note that Q (f; g) is an inclusive assertion, since the abstraction functions (abs ) are continuous <ref> [Sto77] </ref>. Theorem 4 If Q (f; g) holds then Q (F C (f ); F A (g)) holds. Proof. Once the proof idea is known and the main supportive fact is proven in Theorem 3, no real creative acts are needed in applying it.
Reference: [UJ88] <author> David Ungar and Frank Jackson. </author> <title> Tenuring policies for generation-based storage reclamation. </title> <booktitle> In OOPSLA, </booktitle> <pages> pages 1-17, </pages> <year> 1988. </year>
Reference-contexts: If an object survives a given number of garbage collections, then the object is moved into the tenure area where it is exempted from 6 garbage collection. If many tenured objects die, much space will be wasted. This is called the tenuring problem. <ref> [UJ88] </ref> Our analysis estimates the longevity of the memory objects, which is used * to ease the tenuring problem by an appropriate tenuring policy determined by the longevity statistics of objects: proper tenuring threshold value and space sizes for each generation * to reduce the overhead of the scavenging process: bypass
Reference: [Ung84] <author> David Ungar. </author> <title> Generation scavenging: a non-disruptive high performance storage reclamation algorithm. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 19(5), </volume> <month> May </month> <year> 1984. </year> <month> 47 </month>
Reference-contexts: Several problems have worked against the universal acceptance of automatic storage reclamation: distracting pauses while reclaiming garbage, failure to reclaim some types of data structures, and high temporal and spatial overhead. One of the most promising automatic storage reclamation techniques is the generation scavenging <ref> [Ung84] </ref>. The generational scavenging, which is claimed to impose 3% time overhead, divides objects into generations according to their ages. Once objects have been segregated by age, attempts to reclaim storage can be directed at younger objects, which are more likely to be reclaimable.
References-found: 10

