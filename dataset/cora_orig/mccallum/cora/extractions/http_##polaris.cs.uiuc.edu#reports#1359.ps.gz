URL: http://polaris.cs.uiuc.edu/reports/1359.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/polaris/rep2.html
Root-URL: http://www.cs.uiuc.edu
Title: Parallel Performance of a Combustion Chemistry Simulation  
Author: Gregg Skinner Rudolf Eigenmann 
Date: September 1, 1994  
Affiliation: Center for Supercomputing Research and Development University of Illinois at Urbana-Champaign  
Abstract: We used a description of a combustion simulation's mathematical and computational methods to develop a version for parallel execution. The result was a reasonable performance improvement on small numbers of processors. We applied several important programming techniques, which we describe, in optimizing the application. This work has implications for programming languages, compiler design, and software engineering. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Kee and J. Miller. </author> <title> A structured approach to the computational modeling of chemical kinetics and molecular transport in flowing systems. </title> <type> Technical Report SAND86-8841, </type> <institution> Sandia National Laboratories, </institution> <year> 1986. </year>
Reference-contexts: 1 Introduction Numerical simulations of reactive flow are widely used for problems such as controlling combustion-generated pollutants, reducing knocking in internal combustion engines, studying the environmental impact of compounds emitted from combustion, and disposing of toxic wastes <ref> [1] </ref>. These simulations require extensive computation. Many can only be served by the advanced capabilities of a parallel supercomputer. In this paper we describe an effort to optimize the parallel performance of a reactive flow simulation written for serial execution. <p> This approach is successful because the governing equations for each reactive flow application must share a number of features. A general discussion of this structured approach to simulating reactive flow is found in <ref> [1] </ref>. fl This work is supported by the National Security Agency and by Army contract #DABT63-92-C-0033. This work is not necessarily representative of the positions or policies of the Army or the Government. 1 Several codes have been built by Sandia to exploit Chemkin, Transport, and Surfkin.
Reference: [2] <author> R. Kee, J. Grcar, M. Smooke, and J. Miller. </author> <title> A FORTRAN program for modeling steady laminar one-dimensional premixed flames. </title> <type> Technical Report SAND85-8240, </type> <institution> Sandia National Laboratories, </institution> <year> 1985. </year>
Reference-contexts: These simulations require extensive computation. Many can only be served by the advanced capabilities of a parallel supercomputer. In this paper we describe an effort to optimize the parallel performance of a reactive flow simulation written for serial execution. Specifically, we examine Premix <ref> [2] </ref>, which simulates combustion, an important subclass of reactive flow. Reactive flow modeling problems are governed by equations conserving mass, energy, and momentum. They are coupled with a hydrodynamic system driven by the energy released or absorbed from the chemical reactions. <p> A mathematical description of the general problem appears in several references (e.g., <ref> [2] </ref>). We review them briefly here. We then consider the computational methods employed to solve the combustion problem and explore the potential for parallelism in these methods. <p> The steady state is defined by the following conservation equations <ref> [2] </ref>: _ M = uA = constant (mass); (1) _ M dx 1 d dT 1 K X (AZ k )c p k dx A K X _! k h k W k = 0 (energy); (2) _ M dx d (AZ k ) A _! k W k = 0 <p> The diffusive term of the species conservation equation, d dx (AZ k ), is approximated in the same manner. Appropriate boundary conditions are implemented for both the cold and hot boundaries, yielding a two-point boundary value problem. (See equations (10)-(21) in <ref> [2] </ref> and discussion therein for a detailed description.) The nitrogen combustion problem is solved first using windward differences for the convective terms. Then the initial solution is used as a starting condition for a run using central differences for the convective terms. <p> The discretized time integration is again a system of nonlinear equations. The modified Newton-Raphson method is employed to solve the nonlinear system, but in this case it is much more likely to converge. See the discussion in <ref> [2] </ref> for more details. Independence inherent to the computational method Each Newton or time-stepping iteration depends directly on the result of the previous iteration, so we will not discover independence necessary for parallelization outside the computations within a single iteration. <p> The Newton solver is always invoked first; time stepping is only performed when the Newton solution phase fails to converge. A single Newton iteration consists of the following steps <ref> [2] </ref>: 6 Y Perform modified Newton-Raphson N H H Converged? Y Perform modified Newton-Raphson H H Converged? Y Finish, solution found N H H Converged? N ? ? H H - ? ? ? ? - Chemkin Interpreter Transport Property Fitting Code Refine? Initialize Refine approximate solution Perform time stepping Finish,
Reference: [3] <author> C. Curtiss and J. Hirschfelder. </author> <title> Integration of stiff equations. </title> <booktitle> Proceedings of the National Academy of Sciences of the United States of America, </booktitle> <volume> 38 </volume> <pages> 235-243, </pages> <year> 1952. </year>
Reference-contexts: Complicating the numerical simulation of reactive flow is numerical stiffness. Stiff equations have one or more rapidly decaying solutions and usually require special treatment. In the context of chemical kinetics Curtiss and Hirschfelder <ref> [3] </ref> first identified the problem of stiffness in ordinary differential equations in 1952. In reactive flow, stiffness often arises as a result of the differing time scales of the chemical kinetics and the hydrodynamics [4].
Reference: [4] <author> E. Oran and J. Boris. </author> <title> Numerical Simulation of Reactive Flow. </title> <publisher> Elsevier, </publisher> <year> 1987. </year>
Reference-contexts: In the context of chemical kinetics Curtiss and Hirschfelder [3] first identified the problem of stiffness in ordinary differential equations in 1952. In reactive flow, stiffness often arises as a result of the differing time scales of the chemical kinetics and the hydrodynamics <ref> [4] </ref>. Chemical reactions occur on the order of picoseconds, while the convective flow occurs on the order of seconds. Stiffness also results where large temperature gradients occur. To overcome these numerical difficulties researchers often employ time-implicit algorithms and adaptive gridding schemes.
Reference: [5] <author> R. Kee, F. Rupley, and J. Miller. CHEMKIN-II: </author> <title> A FORTRAN chemical kinetics package for the analysis of gas-phase chemical kinetics. </title> <type> Technical Report SAND89-8009, </type> <institution> Sandia National Laboratories, </institution> <year> 1989. </year>
Reference-contexts: To overcome these numerical difficulties researchers often employ time-implicit algorithms and adaptive gridding schemes. A group at Sandia National Laboratories has developed a number of software tools that facilitate simulation of reactive flow. Three basic packages lie at the heart of their effort. The Chemkin library <ref> [5] </ref> is used to analyze gas-phase chemical kinetics. The Transport [6] library is used for evaluating gas-phase multicomponent transport properties. Surfkin [7] is a package for analyzing heterogeneous chemical kinetics at a solid-surface - gas-phase interface. <p> It is a flexible program developed to analyze general problems involving combustion of premixed gases in a flame. Premix consists of a driver and four libraries: Chemkin <ref> [5] </ref>, used to analyze gas-phase chemical kinetics; Transport [6], used to evaluate gas-phase multicomponent transport properties; Twopnt [8], a two-point boundary value problem solver; and Linpack [9], a popular numerical linear algebra package. Each is a standardized, extensible library intended for use on a wide variety of platforms. <p> More detail is available from the Chemkin and Transport documentation <ref> [5, 6] </ref>. rapidly. Assuming a unique solution exists, this process ends when the solution has been resolved to a specified degree. The nonlinear system is solved using the modified Newton-Raphson algorithm. <p> This suggests that if a single level of parallelism is to be exploited, it should be done at the level of residual evaluation. 3.2 Specific implementation The control flow of Premix can be viewed as in Figure 3. The Chemkin Interpreter <ref> [5] </ref> and Transport Property Fitting Code [6] are each external modules which access databases to create "linking" files to be read during execution. The Chemkin and Transport libraries require access to many problem-specific constants, such as the molecular weights of the species.
Reference: [6] <author> R. Kee, G. Dixon-Lewis, J. Warnatz, M. Coltrin, and J. Miller. </author> <title> A FORTRAN computer code package for the evaluation of gas-phase, multicomponent transport properties. </title> <type> Technical Report SAND86-8426, </type> <institution> Sandia National Laboratories, </institution> <year> 1986. </year>
Reference-contexts: A group at Sandia National Laboratories has developed a number of software tools that facilitate simulation of reactive flow. Three basic packages lie at the heart of their effort. The Chemkin library [5] is used to analyze gas-phase chemical kinetics. The Transport <ref> [6] </ref> library is used for evaluating gas-phase multicomponent transport properties. Surfkin [7] is a package for analyzing heterogeneous chemical kinetics at a solid-surface - gas-phase interface. These three combustion libraries undergo continual revision as part of an ongoing effort to provide the numerical combustion community with standardized software. <p> It is a flexible program developed to analyze general problems involving combustion of premixed gases in a flame. Premix consists of a driver and four libraries: Chemkin [5], used to analyze gas-phase chemical kinetics; Transport <ref> [6] </ref>, used to evaluate gas-phase multicomponent transport properties; Twopnt [8], a two-point boundary value problem solver; and Linpack [9], a popular numerical linear algebra package. Each is a standardized, extensible library intended for use on a wide variety of platforms. <p> More detail is available from the Chemkin and Transport documentation <ref> [5, 6] </ref>. rapidly. Assuming a unique solution exists, this process ends when the solution has been resolved to a specified degree. The nonlinear system is solved using the modified Newton-Raphson algorithm. <p> This suggests that if a single level of parallelism is to be exploited, it should be done at the level of residual evaluation. 3.2 Specific implementation The control flow of Premix can be viewed as in Figure 3. The Chemkin Interpreter [5] and Transport Property Fitting Code <ref> [6] </ref> are each external modules which access databases to create "linking" files to be read during execution. The Chemkin and Transport libraries require access to many problem-specific constants, such as the molecular weights of the species.
Reference: [7] <author> M. Coltrin, R. Kee, and F. Rupley. </author> <title> Surface CHEMKIN: A FORTRAN package for analyzing heterogeneous chemical kinetics at a solid-surface-gas-phase interface. </title> <type> Technical Report SAND90-8003, </type> <institution> Sandia National Laboratories, </institution> <year> 1990. </year>
Reference-contexts: Three basic packages lie at the heart of their effort. The Chemkin library [5] is used to analyze gas-phase chemical kinetics. The Transport [6] library is used for evaluating gas-phase multicomponent transport properties. Surfkin <ref> [7] </ref> is a package for analyzing heterogeneous chemical kinetics at a solid-surface - gas-phase interface. These three combustion libraries undergo continual revision as part of an ongoing effort to provide the numerical combustion community with standardized software.
Reference: [8] <author> J. Grcar. </author> <title> The Twopnt program for boundary value problems. </title> <type> Technical Report SAND91-8230, </type> <institution> Sandia National Laboratories, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: It is a flexible program developed to analyze general problems involving combustion of premixed gases in a flame. Premix consists of a driver and four libraries: Chemkin [5], used to analyze gas-phase chemical kinetics; Transport [6], used to evaluate gas-phase multicomponent transport properties; Twopnt <ref> [8] </ref>, a two-point boundary value problem solver; and Linpack [9], a popular numerical linear algebra package. Each is a standardized, extensible library intended for use on a wide variety of platforms. The code, approximately thirty thousand lines of standard FORTRAN 77, is highly modular, robust, and portable.
Reference: [9] <author> J. Dongarra, C. Moler, J. Bunch, and G. Stewart. </author> <title> LINPACK Users' Guide. </title> <institution> Society of Industrial and Applied Mathematics, </institution> <address> Philadelphia, </address> <year> 1979. </year>
Reference-contexts: Premix consists of a driver and four libraries: Chemkin [5], used to analyze gas-phase chemical kinetics; Transport [6], used to evaluate gas-phase multicomponent transport properties; Twopnt [8], a two-point boundary value problem solver; and Linpack <ref> [9] </ref>, a popular numerical linear algebra package. Each is a standardized, extensible library intended for use on a wide variety of platforms. The code, approximately thirty thousand lines of standard FORTRAN 77, is highly modular, robust, and portable.
Reference: [10] <institution> Alliant Computer Systems Corporation, Acton, MA. FX/FORTRAN Programmer's Handbook, </institution> <year> 1985. </year>
Reference-contexts: The code, approximately thirty thousand lines of standard FORTRAN 77, is highly modular, robust, and portable. The program can be stopped at any of several checkpoints and restarted with a new configuration. Our testing environment was a shared-memory MIMD machine, an Alliant FX/80 <ref> [10] </ref> with eight processing units. The processors are register-based with chained functional units and memory port. The computational processors are connected by a concurrency bus, which keeps the overhead for concurrency small.
Reference: [11] <author> J. Tyler, A. Bourgoyne, D. Logan, J. Baron, T. Li, and D. Schneider. </author> <title> A vector-parallel version of BOAST II for the IBM 3090. </title> <type> Internal Report, </type> <institution> IBM Kingston, </institution> <year> 1990. </year>
Reference-contexts: the execution time. 3 Description of the algorithm We first give a description of the mathematical model and the computational method, which assisted us in discovering which level of outer loop parallelism is best to obtain a granularity sufficient to saturate available processors with reasonably sized parcels of independent work <ref> [11] </ref>. A mathematical description of the general problem appears in several references (e.g., [2]). We review them briefly here. We then consider the computational methods employed to solve the combustion problem and explore the potential for parallelism in these methods.
Reference: [12] <author> G. Skinner. </author> <title> Finding and Exploiting Parallelism in a Production Combustion Simulation Program. </title> <type> Master's thesis, </type> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Others are not independent, but many have the form of a reduction, a computation amenable to partial parallel optimization. Let (n) represent the vector of independent variables after Newton iteration n. It has been shown in <ref> [12] </ref> that y = F ( (n) ) depends only on the partial vectors, j1 ; j ; j+1 ; j1 ; j ; j+1 : (11) (The dependence on some previous evaluation n n 0 arises from the fact that the transport coefficients are not recomputed for each iteration.) It
Reference: [13] <author> R. Eigenmann, J. Hoeflinger, Z. Li, and D. Padua. </author> <title> Experience in the Automatic Parallelization of Four Perfect-Benchmarks Programs. </title> <booktitle> In Lecture Notes in Computer Science 589, </booktitle> <pages> pages 65-83. </pages> <publisher> Springer Verlag, </publisher> <address> NY, </address> <year> 1992. </year>
Reference-contexts: We have found this to be important in some cases for our program optimization. 4.3 Comparison to findings of related projects In a related project of optimizing application programs for parallel computers similar results were found. Such projects include the Cedar Fortran project <ref> [13, 14] </ref> which was completed at our center in 1992, and the follow-on Polaris project [15]. Both projects studied transformation techniques that are needed to speed up 9 real programs.
Reference: [14] <author> W. Blume, R. Eigenmann, J. Hoeflinger, D. Padua, and G. Jaxon. </author> <title> The Cedar Fortran Project. </title> <type> Technical Report 1262, </type> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: We have found this to be important in some cases for our program optimization. 4.3 Comparison to findings of related projects In a related project of optimizing application programs for parallel computers similar results were found. Such projects include the Cedar Fortran project <ref> [13, 14] </ref> which was completed at our center in 1992, and the follow-on Polaris project [15]. Both projects studied transformation techniques that are needed to speed up 9 real programs.
Reference: [15] <author> W. Blume, R. Eigenmann, J. Hoeflinger, D. Padua, P. Petersen, L. Rauchwerger, and P. Tu. </author> <title> Automatic Detection of Parallelism: A Grand Challenge for High-Performance Computing. </title> <type> Technical Report 1348, </type> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: Such projects include the Cedar Fortran project [13, 14] which was completed at our center in 1992, and the follow-on Polaris project <ref> [15] </ref>. Both projects studied transformation techniques that are needed to speed up 9 real programs. This was done by hand-parallelizing a suite of codes, including the Perfect Benchmarks and some applications of relevance to the users at the NCSA 1 .
Reference: [16] <author> L. Rauchwerger and D. Padua. </author> <title> Speculative Run-Time Parallelization of Loops. </title> <type> Technical Report 1339, </type> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: In our program we have found that some crucial information for determining the applicability of the parallelization techniques is known only from the input files and thus is not available at compile time. Although there are compilation techniques that are able to parallelize such situations at runtime <ref> [16] </ref>, our findings indicate that it will be at least difficult to detect the parallelism automatically. A full discussion of this point is beyond the scope of this paper and is the object of future projects. A related approach to methodologies for parallel programming is described in [17].
Reference: [17] <author> R. Eigenmann. </author> <title> Toward a methodology of optimizing programs for high-performance computers. </title> <booktitle> In Proceedings of 1993 International Conference on Supercomputing, </booktitle> <address> Tokyo, Japan, </address> <pages> pages 27-36, </pages> <address> Tokyo, Japan, July 19-23 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: A full discussion of this point is beyond the scope of this paper and is the object of future projects. A related approach to methodologies for parallel programming is described in <ref> [17] </ref>. Our findings largely agree with this approach. One difference is that [17] envisions a "program-level" optimization, in which all necessary information for transforming the program can be gathered from the program text. <p> A full discussion of this point is beyond the scope of this paper and is the object of future projects. A related approach to methodologies for parallel programming is described in <ref> [17] </ref>. Our findings largely agree with this approach. One difference is that [17] envisions a "program-level" optimization, in which all necessary information for transforming the program can be gathered from the program text.
Reference: [18] <author> S. Wright. </author> <title> Stable parallel algorithms for two-point boundary value problems. </title> <journal> SIAM Journal on Scientific and Statistical Computing, </journal> <year> 1992. </year>
Reference-contexts: Now that the chemistry can be made relatively cheap, the algorithmic trade-offs have changed. Alternatives to the overall solution strategy should be reviewed. Some discussion of parallel methods for solving two-point boundary value problems can be found in <ref> [18] </ref>. The Lapack effort [19] offers parallel versions of banded system solvers, exploiting parallelism in multiple right-hand sides and blocking algorithms. We did not, however, obtain any performance improvement when we replaced the Linpack linear algebra routines with their Lapack counterparts.
Reference: [19] <author> E. Anderson, Z. Bai, C. Bischof, J. Demmel, J. Dongarra, J. Du Croz, A. Greenbaum, S. Hammarling, A. McKen-ney, S. Ostrouchov, and D. Sorensen. </author> <note> LAPACK Users' Guide. </note> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, </address> <year> 1992. </year> <month> 14 </month>
Reference-contexts: Now that the chemistry can be made relatively cheap, the algorithmic trade-offs have changed. Alternatives to the overall solution strategy should be reviewed. Some discussion of parallel methods for solving two-point boundary value problems can be found in [18]. The Lapack effort <ref> [19] </ref> offers parallel versions of banded system solvers, exploiting parallelism in multiple right-hand sides and blocking algorithms. We did not, however, obtain any performance improvement when we replaced the Linpack linear algebra routines with their Lapack counterparts.
References-found: 19

