URL: http://www.cs.indiana.edu/proglang/papers/stack.ps
Refering-URL: http://www.cs.indiana.edu/proglang/proglang.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Representing Control in the Presence of First-Class Continuations  
Author: Robert Hieb, R. Kent Dybvig, Carl Bruggeman 
Address: Lindley Hall 101 Bloomington IN 47405  
Affiliation: Indiana University Computer Science Department  
Abstract: Languages such as Scheme and Smalltalk that provide continuations as first-class data objects present a challenge to efficient implementation. Allocating activation records in a heap has proven unsatisfactory because of increased frame linkage costs, increased garbage collection overhead, and decreased locality of reference. However, simply allocating activation records on a stack and copying them when a continuation is created results in unbounded copying overhead. This paper describes a new approach based on stack allocation that does not require the stack to be copied when a continuation is created and that allows us to place a small upper bound on the amount copied when a continuation is reinstated. This new approach is faster than the naive stack allocation approach, and it does not suffer from the problems associated with unbounded copying. For continuation-intensive programs, our approach is at worst a constant factor slower than the heap allocation approach, and for typical programs, it is significantly faster. An important additional benefit is that recovery from stack overflow is handled gracefully and efficiently. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel, </author> <title> "Garbage collection can be faster than stack allocation," </title> <journal> Information Processing Letters 25, </journal> <year> 1987, </year> <pages> 275-279. </pages>
Reference-contexts: The disadvantage is that ordinary procedure calls may be slowed down by the increased overhead caused by allocating the activation records in the heap and by more complicated activation record linkages. Furthermore, the storage manager must do more work to reclaim abandoned activation records. Appel <ref> [1] </ref> points out that heap allocation and the associated cost of garbage collection can be made competitive with stack allocation by using large physical memories. The argument is based on the fact that a copying collector takes time proportional to the amount of retained data rather than discarded data.
Reference: [2] <author> David H. Bartley and John C. Jensen, </author> <title> "The Implementation of PC Scheme," </title> <booktitle> Proceedings of the 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <month> August </month> <year> 1986, </year> <pages> 86-93. </pages>
Reference-contexts: Much recent work has been devoted to developing techniques that allow the stack model to be used without making the use of continuations too expensive. For instance, Bartley and Jenson <ref> [2] </ref> "optimistically" stack-allocate control frames, but temper their optimism by using a stack cache of limited size. This places a bound on the worst-case costs of continuation capture and reinstatement, since a bounded amount of memory is copied.
Reference: [3] <author> William D. Clinger, Anne H. Hartheimer, and Eric M. </author> <title> Ost, "Implementation Strategies for Continuations," </title> <booktitle> Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <month> July </month> <year> 1988, </year> <pages> 124-131. </pages>
Reference-contexts: Our approach does not suffer from some of the limitations of the heap-based approach, such as the inability to reuse frames and the inability to stack-allocate objects with dynamic extent. Clinger, et. al. <ref> [3] </ref>, argue that a hybrid stack/heap mechanism may be most appropriate for Scheme and Smalltalk. Their mechanism provides for the frames to be allocated on a stack and moved into a heap-allocated linked list when a continuation is created.
Reference: [4] <author> Olivier Danvy, </author> <title> "Memory Allocation and Higher-Order Functions," </title> <booktitle> Proceedings of the SIGPLAN '87 Symposium on Interpreters and Interpretive Techniques, </booktitle> <month> June </month> <year> 1987, </year> <pages> 241-252. </pages>
Reference-contexts: The primary advantage of the hybrid stack/heap mechanism is that there is never more than one copy of a given frame. They were motivated by Danvy <ref> [4] </ref>, who pointed out that multiple continuation copies can lead to unbounded allocation.
Reference: [5] <author> Edsger W. Dijkstra, </author> <title> "Recursive Programming," in Programming Systems and Languages, </title> <editor> Saul Rosen (ed.), </editor> <publisher> McGraw-Hill, </publisher> <address> NY, </address> <year> 1967. </year>
Reference-contexts: 1 Introduction Stacks have traditionally been used to implement both activation records and local environments in languages that support recursive procedure calls <ref> [5] </ref>. Stacks allow rapid allocation and deallocation of call frames and fl This material is based on work supported in part by the National Science Foundation under grant number CCR-8803432.
Reference: [6] <author> R. Kent Dybvig, </author> <title> Three Implementation Models for Scheme, </title> <institution> University of North Carolina at Chapel Hill Department of Computer Science Technical Report #87-011 (PhD Dissertation), </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: the procedure, or pointers to cells in the heap containing the actual 4 implementing the control stack as a linked list of stack segments, continuation operations are bounded by the size of the top segment instead of the size of the entire control stack. parameters if the parameters are assignable <ref> [6, 13] </ref>. (It is also possible to pass the return address and the first few arguments in registers, leaving a hole in the frame in which the return address can be placed if the called routine itself makes a recursive call.) The remaining words in the frame contain the values of
Reference: [7] <author> R. Kent Dybvig and Robert Hieb, </author> <title> "Engines from Continuations," </title> <institution> Indiana University Computer Science Department Technical Report No. </institution> <month> 254, July </month> <year> 1988. </year>
Reference-contexts: This feature may be used to implement many interesting control structures, including loops, nonblind backtracking [16], coroutines [8], and engines <ref> [10, 7] </ref>. The continuation of a procedure call is nothing more than the control stack of procedure activation records. If continuations were used only for nonlocal exits, as in Common Lisp [15], then the essence of a continuation object would be a pointer into the control stack.
Reference: [8] <author> Daniel P. Friedman, Christopher T. Haynes and Mitchell Wand, </author> <title> "Obtaining Coroutines with Continuations," </title> <booktitle> Computer Languages 11, </booktitle> <volume> 3/4, </volume> <year> 1986, </year> <pages> 143-153. </pages>
Reference-contexts: This feature may be used to implement many interesting control structures, including loops, nonblind backtracking [16], coroutines <ref> [8] </ref>, and engines [10, 7]. The continuation of a procedure call is nothing more than the control stack of procedure activation records. If continuations were used only for nonlocal exits, as in Common Lisp [15], then the essence of a continuation object would be a pointer into the control stack.
Reference: [9] <author> Adele Goldberg and David Robson, </author> <title> Smalltalk 80: the Language and its Implementation, </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Further complications result when a language provides a means for capturing, storing and reinstating control stacks, such as Scheme's first-class continuations [14] and Smalltalk's context objects <ref> [9] </ref>. The need to support continuations or contexts as objects with indefinite extent precludes the use of a simple stack-based implementation of call frames. A continuation represents the rest of the computation from a given point.
Reference: [10] <author> Christopher T. Haynes and Daniel P. Friedman, </author> <title> "Abstracting Timed Preemption with Engines," </title> <journal> Journal of Computer Languages 12, </journal> <volume> 2, </volume> <year> 1987, </year> <pages> 109-121. </pages>
Reference-contexts: This feature may be used to implement many interesting control structures, including loops, nonblind backtracking [16], coroutines [8], and engines <ref> [10, 7] </ref>. The continuation of a procedure call is nothing more than the control stack of procedure activation records. If continuations were used only for nonlocal exits, as in Common Lisp [15], then the essence of a continuation object would be a pointer into the control stack.
Reference: [11] <author> Robert Hieb and R. Kent Dybvig, </author> <title> "Continuations and Concurrency," </title> <booktitle> Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP), </booktitle> <month> March </month> <year> 1990 </year> <month> (to appear). </month>
Reference-contexts: We are investigating the use of similar mechanisms in the implementation of concurrent continuations <ref> [11] </ref>. Acknowledgement: We wish to thank Olivier Danvy for providing comments on an earlier draft of this abstract.
Reference: [12] <author> Drew McDermott, </author> <title> "An Efficient Environment Allocation Scheme in an Interpreter for a Lexically-Scoped Lisp," </title> <booktitle> Conference Record of the 1980 Lisp Conference, </booktitle> <month> August </month> <year> 1980, </year> <pages> 154-162. </pages>
Reference-contexts: When a continuation is invoked, the stack image in the heap is copied into the stack area, where it is treated as an ordinary stack of activation records. The first reference we have found to this approach is by McDermott <ref> [12] </ref>, who suggests copying continuations to and from a control stack so that only programs that actually use first class continuations need pay for the cost of supporting them.
Reference: [13] <author> David Kranz, Richard Kelsey, Jonathan Rees, Paul Hudak, James Philbin, and Norman Adams, </author> <title> "Orbit: An optimizing compiler for Scheme," </title> <booktitle> Proceedings of the SIGPLAN '86 Symposium on Compiler Construction, published as SIGPLAN Notices 21, </booktitle> <volume> 7, </volume> <month> July </month> <year> 1986, </year> <pages> 219-233. </pages>
Reference-contexts: the procedure, or pointers to cells in the heap containing the actual 4 implementing the control stack as a linked list of stack segments, continuation operations are bounded by the size of the top segment instead of the size of the entire control stack. parameters if the parameters are assignable <ref> [6, 13] </ref>. (It is also possible to pass the return address and the first few arguments in registers, leaving a hole in the frame in which the return address can be placed if the called routine itself makes a recursive call.) The remaining words in the frame contain the values of
Reference: [14] <editor> Jonathan A. Rees and William Clinger, eds., </editor> <title> "The Revised 3 Report on the Algorithmic Language Scheme," </title> <journal> SIGPLAN Notices 21, </journal> <volume> 12, </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: Further complications result when a language provides a means for capturing, storing and reinstating control stacks, such as Scheme's first-class continuations <ref> [14] </ref> and Smalltalk's context objects [9]. The need to support continuations or contexts as objects with indefinite extent precludes the use of a simple stack-based implementation of call frames. A continuation represents the rest of the computation from a given point.
Reference: [15] <author> Guy L. Steele Jr., </author> <title> Common LISP: The Language, </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: The continuation of a procedure call is nothing more than the control stack of procedure activation records. If continuations were used only for nonlocal exits, as in Common Lisp <ref> [15] </ref>, then the essence of a continuation object would be a pointer into the control stack. However, because continuations can outlive the context of their capture, continuation objects have indefinite extent and a pointer into the stack is not sufficient.
Reference: [16] <author> Gerald J. Sussman and Guy L. Steele Jr., </author> <title> "Scheme: an Interpreter for Extended Lambda Calculus," </title> <booktitle> Mas-sachusetts Institute of Technology Artificial Intelligence Memo 349, </booktitle> <year> 1975. </year> <month> 12 </month>
Reference-contexts: This feature may be used to implement many interesting control structures, including loops, nonblind backtracking <ref> [16] </ref>, coroutines [8], and engines [10, 7]. The continuation of a procedure call is nothing more than the control stack of procedure activation records.
References-found: 16

