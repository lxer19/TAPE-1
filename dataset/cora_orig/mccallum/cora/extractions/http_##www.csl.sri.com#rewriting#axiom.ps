URL: http://www.csl.sri.com/rewriting/axiom.ps
Refering-URL: http://www.csl.sri.com/rewriting/
Root-URL: 
Title: Axiomatizing Reflective Logics and Languages  
Author: Manuel G. Clavel and Jose Meseguer 
Address: Menlo Park CA 94025  
Affiliation: Computer Science Laboratory SRI International,  
Abstract: The very success and breadth of reflective techniques underscores the need for a general theory of reflection. At present what we have is a wide-ranging variety of reflective systems, each explained in its own idiosyncratic terms. Metalogical foundations can allow us to capture the essential aspects of reflective systems in a formalism-independent way. This paper proposes metalogical axioms for reflective logics and declarative languages based on the theory of general logics [34]. In this way, several strands of work in reflection, including functional, equational, Horn logic, and rewriting logic reflective languages, as well as a variety of reflective theorem proving systems are placed within a common theoretical framework. General axioms for computational strategies, and for the internalization of those strategies in a reflective logic are also given.
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> H. Abramson and M.H. Rogers, editors. </editor> <booktitle> Metaprogramming in Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: The treatment in [40] does not provide a universal theory and seems limited in its reflective power. 3.1.3 Horn Logic Languages There is a long tradition of metacircular interpreters and meta-programming in Prolog (see the papers collected in <ref> [1, 8, 43, 12, 3] </ref> and references there) strongly suggesting that a more declarative variant of Prolog can be made reflective in our axiomatic sense. The "vanilla" interpreters presented in the literature, for example in [55], fall short of being a universal theory and lack adequate semantics.
Reference: [2] <author> William E. Aitken, Robert L. Constable, and Judith L. Underwood. </author> <title> Metalogical frameworks II: Using reflected decision procedures. </title> <type> Technical Report, </type> <institution> Computer Sci. Dept., Cornell University, </institution> <note> 1993; also, </note> <institution> lecture at the Max Planck Institut fur Informatik, Saarbrucken, Germany, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: In computer science it has been present from the beginning in the form of universal Turing machines. Many researchers have recognized its great importance and usefulness in programming languages [54, 51, 60, 56, 23, 19, 30], in theorem-proving <ref> [62, 7, 48, 20, 2, 29, 14, 16] </ref>, in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection). <p> it may be necessary to consider eval functions with a bound on the number of rewrites to remain within the language (see, for example, [47, 31] for a careful treatment of this problem for the calculus of constructions, [45] for a study of reflection in the polymorphic lambda calculus, and <ref> [20, 2, 10] </ref> for the treatment of reflection in Nuprl's constructive type theory a la Martin Lof). <p> In the context of typed lambda calculi, the important advantages of having an internal strategy language has been stressed by several authors. Thus, using reflective capabilities both tactics and decision pocedures can be specified, reasoned about, and executed inside the Nuprl constructive type theory <ref> [2, 10] </ref>. <p> Similar studies can also be useful for other suitable reflective logics. In fact, good evidence already 13 exists about the good properties of Nuprl's constructive type theory as a reflective metalogical framework <ref> [5, 2] </ref>. Acknowledgements We cordially thank Steven Eker, David Israel, Narciso Mart-Oliet, Harald Rue, Johann Schumann, Natajaran Shankar, Mark Stickel, Carolyn Talcott, and Valentin Turchin for their very helpful comments on an earlier version of this paper.
Reference: [3] <editor> Krzysztof Apt and Franco Turini, editors. </editor> <booktitle> Meta-Logics and Logic Programming. Logic Programming Series. </booktitle> <publisher> MIT Press, </publisher> <month> November </month> <year> 1995. </year>
Reference-contexts: The treatment in [40] does not provide a universal theory and seems limited in its reflective power. 3.1.3 Horn Logic Languages There is a long tradition of metacircular interpreters and meta-programming in Prolog (see the papers collected in <ref> [1, 8, 43, 12, 3] </ref> and references there) strongly suggesting that a more declarative variant of Prolog can be made reflective in our axiomatic sense. The "vanilla" interpreters presented in the literature, for example in [55], fall short of being a universal theory and lack adequate semantics.
Reference: [4] <editor> J. Barwise and S. Feferman (eds.). </editor> <booktitle> Model-Theoretic Logics. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The purpose of the concepts presented here is to support reasoning about, and proving properties of, reflective logics and languages in a general and abstract way. The aim is similar to that in abstract model theory <ref> [4, 15] </ref>, where important properties of a logic can be established under general assumptions.
Reference: [5] <author> D. A. Basin and R. L. Constable. </author> <title> Metalogical frameworks. </title> <editor> In G. Huet and G. Plotkin, editors, </editor> <booktitle> Logical Environments, </booktitle> <pages> pages 1-29. </pages> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: Similar studies can also be useful for other suitable reflective logics. In fact, good evidence already 13 exists about the good properties of Nuprl's constructive type theory as a reflective metalogical framework <ref> [5, 2] </ref>. Acknowledgements We cordially thank Steven Eker, David Israel, Narciso Mart-Oliet, Harald Rue, Johann Schumann, Natajaran Shankar, Mark Stickel, Carolyn Talcott, and Valentin Turchin for their very helpful comments on an earlier version of this paper.
Reference: [6] <author> Anders Bondorf. </author> <title> A self-applicable partial evaluator for term rewriting systems. </title> <editor> In J. Daz and F. Orejas, editors, </editor> <booktitle> TAPSOFT'89, </booktitle> <pages> pages 81-95. </pages> <publisher> Springer LNCS 352, </publisher> <year> 1989. </year>
Reference-contexts: area is the use of lambda calculi and monads a la Moggi [39] to give semantics to reflective languages [11, 33]. 3.1.2 Equational Languages There is very strong evidence, thanks to the work on the Refal supercompiler [56, 57, 59] and to related work on partial evaluation of equational programs <ref> [6, 49] </ref>, suggesting that equational languages can be made reflective in our precise axiomatic sense. The careful representation by levels of Refal terms and programs (also represented as terms) [59] has excellent mathematical properties and allows arbitrarily high reflective towers.
Reference: [7] <author> R. S. Boyer and J Strother Moore. Metafunctions: </author> <title> proving them correct and using them efficiently as new proof procedures. </title> <editor> In Robert Boyer and J Moore, editors, </editor> <booktitle> The Correctness Problem in Computer Science, </booktitle> <pages> pages 103-185. </pages> <publisher> Academic Press, </publisher> <year> 1981. </year>
Reference-contexts: In computer science it has been present from the beginning in the form of universal Turing machines. Many researchers have recognized its great importance and usefulness in programming languages [54, 51, 60, 56, 23, 19, 30], in theorem-proving <ref> [62, 7, 48, 20, 2, 29, 14, 16] </ref>, in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection).
Reference: [8] <author> M. Bruynooghe, </author> <title> editor. </title> <booktitle> Proceedings Second Workshop on Meta-programming in Logic. </booktitle> <institution> K.U.Leuven, Department of Comp.Sc., </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: The treatment in [40] does not provide a universal theory and seems limited in its reflective power. 3.1.3 Horn Logic Languages There is a long tradition of metacircular interpreters and meta-programming in Prolog (see the papers collected in <ref> [1, 8, 43, 12, 3] </ref> and references there) strongly suggesting that a more declarative variant of Prolog can be made reflective in our axiomatic sense. The "vanilla" interpreters presented in the literature, for example in [55], fall short of being a universal theory and lack adequate semantics.
Reference: [9] <author> Maura Cerioli and Jose Meseguer. </author> <title> May I borrow your logic? (transporting logical structure along maps). </title> <note> To appear in Theoretical Computer Science, </note> <year> 1996. </year>
Reference-contexts: A flexible axiomatic notion of a proof calculus, in which proofs of entailments, not just the entailments themselves, are first class citizens should also be included. The theory of general logics <ref> [34, 27, 9] </ref> is a study of these different ingredients of a logic and their interrelations, and uses those general notions to obtain a general notion of declarative language based on a given logic. <p> In the theory of general logics, logics are related by mappings preserving the relevant logical structure. These mappings can be very useful for reusing tools and logical components <ref> [9] </ref>. Similar notions of mapping should be investigated in detail for the reflective case. * Modularity. The fact that theories can be represented at the object level offers excellent opportunities for developing a very powerful, internalized and logic-independent theory of modules and module operations for both specifications and programs.
Reference: [10] <author> Robert L. Constable. </author> <title> Using reflection to explain and enhance type theory. </title> <booktitle> In Proof and Computation, </booktitle> <pages> pages 109-144, </pages> <year> 1995. </year>
Reference-contexts: it may be necessary to consider eval functions with a bound on the number of rewrites to remain within the language (see, for example, [47, 31] for a careful treatment of this problem for the calculus of constructions, [45] for a study of reflection in the polymorphic lambda calculus, and <ref> [20, 2, 10] </ref> for the treatment of reflection in Nuprl's constructive type theory a la Martin Lof). <p> In the context of typed lambda calculi, the important advantages of having an internal strategy language has been stressed by several authors. Thus, using reflective capabilities both tactics and decision pocedures can be specified, reasoned about, and executed inside the Nuprl constructive type theory <ref> [2, 10] </ref>.
Reference: [11] <author> Andrzej Filinski. </author> <title> Representing monads. </title> <booktitle> In Conference Record POPL '94 ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 446-457, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Yet another promising recent development in this general area is the use of lambda calculi and monads a la Moggi [39] to give semantics to reflective languages <ref> [11, 33] </ref>. 3.1.2 Equational Languages There is very strong evidence, thanks to the work on the Refal supercompiler [56, 57, 59] and to related work on partial evaluation of equational programs [6, 49], suggesting that equational languages can be made reflective in our precise axiomatic sense.
Reference: [12] <author> Laurent Fribourg and Franco Turini, </author> <title> editors. Logic Program Synthesis and Transformation-Meta-programming in Logic. </title> <publisher> LNCS 883. Springer-Verlag, </publisher> <month> September </month> <year> 1994. </year>
Reference-contexts: The treatment in [40] does not provide a universal theory and seems limited in its reflective power. 3.1.3 Horn Logic Languages There is a long tradition of metacircular interpreters and meta-programming in Prolog (see the papers collected in <ref> [1, 8, 43, 12, 3] </ref> and references there) strongly suggesting that a more declarative variant of Prolog can be made reflective in our axiomatic sense. The "vanilla" interpreters presented in the literature, for example in [55], fall short of being a universal theory and lack adequate semantics.
Reference: [13] <author> K. Futatsugi and T. Sawada. </author> <title> Cafe as an extensible specification environment. </title> <booktitle> To appear in Proc. of the Kunming International CASE Symposium, </booktitle> <address> Kunming, China, </address> <month> November, </month> <year> 1994. </year>
Reference-contexts: Our interest in a conceptual clarification of reflection has been motivated by our current design and implementation work on the Maude rewriting logic language [37]. Two other languages based on rewriting logic have been designed by other researchers <ref> [25, 13] </ref>.
Reference: [14] <author> Fausto Giunchiglia, Paolo Traverso, Alessandro Cimatti, and Paolo Pecchiari. </author> <title> A system for multi-level reasoning. </title> <booktitle> In IMSA'92, </booktitle> <pages> pages 190-195. </pages> <institution> Information-Technology Promotion Agency, </institution> <address> Japan, </address> <year> 1992. </year>
Reference-contexts: In computer science it has been present from the beginning in the form of universal Turing machines. Many researchers have recognized its great importance and usefulness in programming languages [54, 51, 60, 56, 23, 19, 30], in theorem-proving <ref> [62, 7, 48, 20, 2, 29, 14, 16] </ref>, in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection).
Reference: [15] <author> Joseph Goguen and Rod Burstall. Institutions: </author> <title> Abstract model theory for specification and programming. </title> <journal> Journal of the ACM, </journal> <volume> 39(1) </volume> <pages> 95-146, </pages> <year> 1992. </year> <month> 14 </month>
Reference-contexts: The purpose of the concepts presented here is to support reasoning about, and proving properties of, reflective logics and languages in a general and abstract way. The aim is similar to that in abstract model theory <ref> [4, 15] </ref>, where important properties of a logic can be established under general assumptions.
Reference: [16] <author> John Harrison. </author> <title> Metatheory and reflection in theorem proving: a survey and critique. </title> <institution> Univer--sity of Cambridge Computer Laboratory, </institution> <year> 1995. </year>
Reference-contexts: In computer science it has been present from the beginning in the form of universal Turing machines. Many researchers have recognized its great importance and usefulness in programming languages [54, 51, 60, 56, 23, 19, 30], in theorem-proving <ref> [62, 7, 48, 20, 2, 29, 14, 16] </ref>, in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection).
Reference: [17] <author> Christopher P. Higgins. </author> <title> Type-safe reflection and encapsulation in logic programming. </title> <booktitle> In this volume. </booktitle>
Reference-contexts: Furthermore, more work seems to be needed to better understand how other related approaches in this area such as <ref> [22, 17] </ref> could perhaps be used to define universal theories. 3.1.4 Rewriting Logic Languages Rewriting logic [35] is a logic of concurrent action that supports declarative specification and programming of concurrent and distributed systems, including object-oriented ones.
Reference: [18] <author> Patricia Hill and John Lloyd. </author> <title> Analysis of meta-programs. </title> <editor> In H. D. Abramson and M. H. Rogers, editors, </editor> <booktitle> Meta-Programming in Logic Programming, </booktitle> <pages> pages 23-52. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: A systematic effort to carefully represent metalevel concepts and to give a declarative semantics for Horn logic interpreters using a typed version of the logic has been undertaken by Hill and Lloyd <ref> [18] </ref>; this work is the theoretical basis of the Godel language [19]. A metacircular interpreter with properties similar to those of a universal theory is given in [19]. However, the mathematical correctness proofs given in [18] seem to apply to formalizations in which the program P is not represented as a <p> interpreters using a typed version of the logic has been undertaken by Hill and Lloyd <ref> [18] </ref>; this work is the theoretical basis of the Godel language [19]. A metacircular interpreter with properties similar to those of a universal theory is given in [19]. However, the mathematical correctness proofs given in [18] seem to apply to formalizations in which the program P is not represented as a data structure appearing in a goal presented to a universal theory, but is instead represented as an extension of the interpreter by additional atomic clauses of the form clause (A 0 if Q 0 ) <p> The work already done in <ref> [18] </ref> seems a good basis for defining 9 and proving correct a universal theory for Horn logic; however, some extra work seems to be needed to prove the correctness of a universal theory in our sense, since programs should be represented as terms in a goal, and not as extra atomic
Reference: [19] <author> Patricia Hill and John Lloyd. </author> <title> The Godel Programming Language. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: In computer science it has been present from the beginning in the form of universal Turing machines. Many researchers have recognized its great importance and usefulness in programming languages <ref> [54, 51, 60, 56, 23, 19, 30] </ref>, in theorem-proving [62, 7, 48, 20, 2, 29, 14, 16], in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection). <p> A systematic effort to carefully represent metalevel concepts and to give a declarative semantics for Horn logic interpreters using a typed version of the logic has been undertaken by Hill and Lloyd [18]; this work is the theoretical basis of the Godel language <ref> [19] </ref>. A metacircular interpreter with properties similar to those of a universal theory is given in [19]. <p> to give a declarative semantics for Horn logic interpreters using a typed version of the logic has been undertaken by Hill and Lloyd [18]; this work is the theoretical basis of the Godel language <ref> [19] </ref>. A metacircular interpreter with properties similar to those of a universal theory is given in [19].
Reference: [20] <author> Douglas J. Howe. </author> <title> Reflecting the semantics of reflected proof. </title> <editor> In Peter Aczel, Harold Simmons, and Stanley S. Wainer, editors, </editor> <booktitle> Proof Theory, </booktitle> <pages> pages 229-250. </pages> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: In computer science it has been present from the beginning in the form of universal Turing machines. Many researchers have recognized its great importance and usefulness in programming languages [54, 51, 60, 56, 23, 19, 30], in theorem-proving <ref> [62, 7, 48, 20, 2, 29, 14, 16] </ref>, in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection). <p> it may be necessary to consider eval functions with a bound on the number of rewrites to remain within the language (see, for example, [47, 31] for a careful treatment of this problem for the calculus of constructions, [45] for a study of reflection in the polymorphic lambda calculus, and <ref> [20, 2, 10] </ref> for the treatment of reflection in Nuprl's constructive type theory a la Martin Lof).
Reference: [21] <author> C. Dony J. Malenfant and P. Cointe. </author> <title> A semantics of introspection in a reflective prototype-based language. </title> <note> To appear in Lisp and Symbolic Computation. </note>
Reference-contexts: Further evidence is provided by the recent work of Watanabe [61], and of Malenfant, Dony, and Cointe <ref> [21] </ref>, since in these two papers rewriting is used to formalize computational reflection. 3.1.5 Turing Machines Turing machines can be naturally viewed as phrase structure grammars, and therefore as string rewriting systems, that is, as rewrite theories modulo the associativity equation for a binary string concatenation operator. <p> We conjecture that reflective rewriting logic can provide clear and simple semantics for reflective computational systems, as briefly illustrated here by the example of Turing machines and further evidenced by the use of rewriting systems in semantic definitions of reflection by other authors <ref> [61, 21] </ref>. Since a particularly simple rewriting logic semantics for object-oriented systems, including concurrent ones, already exists [37], developing a rewriting logic semantics for reflective object-oriented systems seems a natural and promising research direction. * Mappings between reflective systems.
Reference: [22] <author> Marianne Kalsbeek and Yuejun Jiang. </author> <booktitle> Meta-Logics and Logic Programming, chapter A Vade-mecum of Ambivalent Logic, </booktitle> <pages> pages 27-55. </pages> <publisher> MIT Press, </publisher> <month> November </month> <year> 1995. </year>
Reference-contexts: Furthermore, more work seems to be needed to better understand how other related approaches in this area such as <ref> [22, 17] </ref> could perhaps be used to define universal theories. 3.1.4 Rewriting Logic Languages Rewriting logic [35] is a logic of concurrent action that supports declarative specification and programming of concurrent and distributed systems, including object-oriented ones.
Reference: [23] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In computer science it has been present from the beginning in the form of universal Turing machines. Many researchers have recognized its great importance and usefulness in programming languages <ref> [54, 51, 60, 56, 23, 19, 30] </ref>, in theorem-proving [62, 7, 48, 20, 2, 29, 14, 16], in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection).
Reference: [24] <author> C. Kirchner and H. Kirchner. </author> <type> Personal communication. </type> <month> July </month> <year> 1995. </year>
Reference-contexts: We are currently studying a good choice of M for Maude. Similar ideas about specifying strategies with rewrite rules are also being adopted for the strategies of the ELAN rewriting logic language <ref> [24] </ref>, whose strategy language was initially defined as an external language [25]. In the context of typed lambda calculi, the important advantages of having an internal strategy language has been stressed by several authors.
Reference: [25] <author> C. Kirchner, H. Kirchner, and M. Vittek. </author> <title> Designing constraint logic programming languages using computational systems. </title> <editor> In V. Saraswat and P. van Hentryck, editors, </editor> <booktitle> Principles and Practice of Constraint Programming: The Newport Papers, </booktitle> <pages> pages 133-160. </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Our interest in a conceptual clarification of reflection has been motivated by our current design and implementation work on the Maude rewriting logic language [37]. Two other languages based on rewriting logic have been designed by other researchers <ref> [25, 13] </ref>. <p> We are currently studying a good choice of M for Maude. Similar ideas about specifying strategies with rewrite rules are also being adopted for the strategies of the ELAN rewriting logic language [24], whose strategy language was initially defined as an external language <ref> [25] </ref>. In the context of typed lambda calculi, the important advantages of having an internal strategy language has been stressed by several authors. Thus, using reflective capabilities both tactics and decision pocedures can be specified, reasoned about, and executed inside the Nuprl constructive type theory [2, 10]. <p> A substantial amount of evidence, advocating the suitability of rewriting logic for these purposes already exists <ref> [35, 26, 25, 27] </ref>. Since rewriting logic is reflective and has internal strategy languages, a more systematic exploitation of reflection in its use as a logical and semantic framework seems both promising and natural. Similar studies can also be useful for other suitable reflective logics.
Reference: [26] <author> Narciso Mart-Oliet and Jose Meseguer. </author> <title> Rewriting logic as a logical and semantic framework. </title> <type> Technical Report SRI-CSL-93-05, </type> <institution> SRI International, Computer Science Laboratory, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: Since equational logic and Horn logic are both naturally included in rewriting logic in a conservative way, rewriting logic programming generalizes equational programming and Horn logic programming <ref> [36, 26] </ref>. A first sketch of the reflective aspects of rewriting logic appeared in [27]. The class of finitely presentable rewrite theories has indeed universal theories in exactly the above axiomatic sense. <p> a broader interest in this case due to the fact that rewriting logic can be used as a logical and semantic framework in which a wide range of logics and models of computation|including Horn and equational logic, linear logic, sequent calculi, the lambda calculus, concurrent object-oriented programming, and many others <ref> [35, 26] </ref>| can be naturally represented. Therefore, because of its reflective properties, rewriting logic seems a good semantic framework to specify and prototype many other reflective logics and computational systems; the example of Turing machines discussed below is a case in point. <p> A substantial amount of evidence, advocating the suitability of rewriting logic for these purposes already exists <ref> [35, 26, 25, 27] </ref>. Since rewriting logic is reflective and has internal strategy languages, a more systematic exploitation of reflection in its use as a logical and semantic framework seems both promising and natural. Similar studies can also be useful for other suitable reflective logics.
Reference: [27] <author> Narciso Mart-Oliet and Jose Meseguer. </author> <title> General logics and logical frameworks. </title> <editor> In D. Gabbay, editor, </editor> <booktitle> What is a Logical System?, </booktitle> <pages> pages 355-392. </pages> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: A flexible axiomatic notion of a proof calculus, in which proofs of entailments, not just the entailments themselves, are first class citizens should also be included. The theory of general logics <ref> [34, 27, 9] </ref> is a study of these different ingredients of a logic and their interrelations, and uses those general notions to obtain a general notion of declarative language based on a given logic. <p> Since equational logic and Horn logic are both naturally included in rewriting logic in a conservative way, rewriting logic programming generalizes equational programming and Horn logic programming [36, 26]. A first sketch of the reflective aspects of rewriting logic appeared in <ref> [27] </ref>. The class of finitely presentable rewrite theories has indeed universal theories in exactly the above axiomatic sense. <p> Similarly, Rue [32] discusses in detail an elegant 1 For the definition of a transformation M of this kind in which the strategy expressions actually coincide with multisets of proof expressions see <ref> [27] </ref>; details for other strategy languages M will appear elsewhere. 12 approach for endowing the calculus of constructions with internal strategies, as part of his treatment of reflection for such a calculus. 5 Concluding Remarks This work is a first step within a broader effort to develop a general theory of <p> A substantial amount of evidence, advocating the suitability of rewriting logic for these purposes already exists <ref> [35, 26, 25, 27] </ref>. Since rewriting logic is reflective and has internal strategy languages, a more systematic exploitation of reflection in its use as a logical and semantic framework seems both promising and natural. Similar studies can also be useful for other suitable reflective logics.
Reference: [28] <author> Satoshi Matsuoka, Takuo Watanabe, Yuuji Ichisugi, and Akinori Yonezawa. </author> <title> Object-oriented concurrent reflective architectures. </title> <editor> In M. Tokoro, O. Nierstrasz, and P. Wegner, editors, </editor> <booktitle> Object-Based Concurrent Computing, </booktitle> <pages> pages 211-226. </pages> <publisher> Springer LNCS 612, </publisher> <year> 1992. </year>
Reference-contexts: Many researchers have recognized its great importance and usefulness in programming languages [54, 51, 60, 56, 23, 19, 30], in theorem-proving [62, 7, 48, 20, 2, 29, 14, 16], in concurrent and distributed computation <ref> [28, 41, 46] </ref>, and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection). The very success and extension of reflective ideas underscores the need for conceptual foundations.
Reference: [29] <author> Sean Matthews. </author> <title> Reflection in logical systems. </title> <booktitle> In IMSA'92, </booktitle> <pages> pages 178-183. </pages> <institution> Information-Technology Promotion Agency, </institution> <address> Japan, </address> <year> 1992. </year>
Reference-contexts: In computer science it has been present from the beginning in the form of universal Turing machines. Many researchers have recognized its great importance and usefulness in programming languages [54, 51, 60, 56, 23, 19, 30], in theorem-proving <ref> [62, 7, 48, 20, 2, 29, 14, 16] </ref>, in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection).
Reference: [30] <author> Fran~cois-Nicola Demers and Jacques Malenfant. </author> <title> Reflection in logic, functional and object-oriented programming: a short comparative study. </title> <booktitle> In IJCAI '95 Workshop on Reflection and Metalevel Architectures and their Applications in AI, </booktitle> <pages> pages 29-38, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: In computer science it has been present from the beginning in the form of universal Turing machines. Many researchers have recognized its great importance and usefulness in programming languages <ref> [54, 51, 60, 56, 23, 19, 30] </ref>, in theorem-proving [62, 7, 48, 20, 2, 29, 14, 16], in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection).
Reference: [31] <author> Harald Rue. </author> <title> Computational reflection in the calculus of constructions and its application to theorem proving. </title> <type> Manuscript, </type> <institution> Universitat Ulm, Abt. Kunstliche Intelligenz, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: typecheck an appropriate eval function in the given type discipline; therefore, a universal theory may exist, but outside the class of theories in the language, or it may be necessary to consider eval functions with a bound on the number of rewrites to remain within the language (see, for example, <ref> [47, 31] </ref> for a careful treatment of this problem for the calculus of constructions, [45] for a study of reflection in the polymorphic lambda calculus, and [20, 2, 10] for the treatment of reflection in Nuprl's constructive type theory a la Martin Lof).
Reference: [32] <author> Harald Rue. </author> <title> Reflection of formal tactics in a deductive reflection framework. </title> <type> Manuscript, </type> <institution> Universitat Ulm, Abt. Kunstliche Intelligenz, </institution> <month> January 96. </month>
Reference-contexts: In the context of typed lambda calculi, the important advantages of having an internal strategy language has been stressed by several authors. Thus, using reflective capabilities both tactics and decision pocedures can be specified, reasoned about, and executed inside the Nuprl constructive type theory [2, 10]. Similarly, Rue <ref> [32] </ref> discusses in detail an elegant 1 For the definition of a transformation M of this kind in which the strategy expressions actually coincide with multisets of proof expressions see [27]; details for other strategy languages M will appear elsewhere. 12 approach for endowing the calculus of constructions with internal strategies,
Reference: [33] <author> Anurag Mendhekar and Daniel P. Friedman. </author> <title> An exploration of relationship between reflective theories. </title> <booktitle> In this volume. </booktitle>
Reference-contexts: Yet another promising recent development in this general area is the use of lambda calculi and monads a la Moggi [39] to give semantics to reflective languages <ref> [11, 33] </ref>. 3.1.2 Equational Languages There is very strong evidence, thanks to the work on the Refal supercompiler [56, 57, 59] and to related work on partial evaluation of equational programs [6, 49], suggesting that equational languages can be made reflective in our precise axiomatic sense.
Reference: [34] <author> Jose Meseguer. </author> <title> General logics. </title> <editor> In H.-D. Ebbinghaus et al., editor, </editor> <booktitle> Logic Colloquium'87, </booktitle> <pages> pages 275-329. </pages> <publisher> North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: Since a reflective logic in our sense naturally gives rise to a "reflective tower," it then becomes possible to modify at runtime not only object theories, but also the reified metatheory. The metalogical foundations that we propose use concepts from the theory of general logics <ref> [34] </ref> that are recapitulated in Section 2. Section 3 then presents general axioms for reflective logics and languages, and explains how they are satisfied or not by a variety of declarative languages. <p> A flexible axiomatic notion of a proof calculus, in which proofs of entailments, not just the entailments themselves, are first class citizens should also be included. The theory of general logics <ref> [34, 27, 9] </ref> is a study of these different ingredients of a logic and their interrelations, and uses those general notions to obtain a general notion of declarative language based on a given logic. <p> For our present purposes it will be the notions of syntax, of entailment system and of proof calculus proposed in <ref> [34] </ref> that play a crucial role. We present below in summarized form the axioms characterizing these notions and that of declarative language. <p> We make this relation relative to a signature. In what follows, jCj denotes the collection of objects of a category C. Definition 1 <ref> [34] </ref> An entailment system is a triple E = (Sign; sen; `) such that * (Sign; sen) is a syntax, * ` is a function associating to each 2 jSignj a binary relation ` P (sen ()) fi sen () called entailment such that the following properties are satisfied: 3 1. <p> 3. transitivity: if ` ' i , for all i 2 I, and [ f' i j i 2 Ig ` , then ` , 4. `-translation: if ` ', then for any H : ! 0 in Sign we have sen (H)() ` 0 sen (H)('). 2 Definition 2 <ref> [34] </ref> Given an entailment system E, its category Th of theories has as objects pairs T = (; ) with a signature and sen (). <p> Of course, each theorem of T must have at least one proof, and sentences that are not theorems should have no proof. To summarize, a proof calculus <ref> [34] </ref> consists of an entailment system together with: * A functorial assignment P of a structure P (T ) to each theory T . * An additional functorial assignment of a set proofs (T ) to each structure P (T ). * A natural function T assigning a sentence to each <p> This is axiomatized by the notion of an effective proof subcalculus; we do not give here the details, which can be found in <ref> [34] </ref>. 2.4 Declarative Languages In general, given a logic, what does it mean to have a declarative language based on it? We propose the following view: A program P in such a language is a theory in the logic. <p> Definition 3 below gives an axiomatization|in terms of general logics concepts|of the notion of declarative language just presented; a stronger notion requiring also an initial model semantics can be found in <ref> [34, 36] </ref>. The definition allows careful selection of the signatures and the finite sets of sentences that can be used as statements to make up a program P , and also of those sentences that are admissible as queries. <p> Any such O is called an operational semantics for the declarative programming language L. 2 This definition encompasses a wide range of logics and languages. For example, most equational, functional, Horn logic, and rewriting logic declarative languages, as well as multiparadigm combinations of these, satisfy the definition's requirements <ref> [34, 36] </ref>. 3 Axiomatizing Reflective Logics and Languages A reflective logic is a logic in which important aspects of its metatheory can be represented at the object level in a consistent way, so that the object-level representation correctly simulates the relevant metatheoretic aspects. <p> In addition, we can get corresponding effective notions by requiring the calculus or subcalculus to be effective <ref> [34] </ref>, and the representation map to be computable. 2 The main advantage of a reflective proof calculus over a reflective entailment system is that proofs are also represented, so that proof-checking becomes then expressible as ordinary deduction in the universal theory.
Reference: [35] <author> Jose Meseguer. </author> <title> Conditional rewriting logic as a unified model of concurrency. </title> <journal> Theoretical Computer Science, </journal> <volume> 96(1) </volume> <pages> 73-155, </pages> <year> 1992. </year> <month> 15 </month>
Reference-contexts: Furthermore, more work seems to be needed to better understand how other related approaches in this area such as [22, 17] could perhaps be used to define universal theories. 3.1.4 Rewriting Logic Languages Rewriting logic <ref> [35] </ref> is a logic of concurrent action that supports declarative specification and programming of concurrent and distributed systems, including object-oriented ones. Since equational logic and Horn logic are both naturally included in rewriting logic in a conservative way, rewriting logic programming generalizes equational programming and Horn logic programming [36, 26]. <p> a broader interest in this case due to the fact that rewriting logic can be used as a logical and semantic framework in which a wide range of logics and models of computation|including Horn and equational logic, linear logic, sequent calculi, the lambda calculus, concurrent object-oriented programming, and many others <ref> [35, 26] </ref>| can be naturally represented. Therefore, because of its reflective properties, rewriting logic seems a good semantic framework to specify and prototype many other reflective logics and computational systems; the example of Turing machines discussed below is a case in point. <p> Therefore, they form a very restricted class T of finitely presentable theories in rewriting logic <ref> [35] </ref>. As it is well-known, this class has T -universal theories belonging to it. <p> Then, given a finitely presented rewrite theory R, a good choice for S (R) is the category T M (R) (X) underlying the free M (R)-system <ref> [35] </ref> on a countable set of variables X. Intuitively, M associates to each rewrite theory R the rewrite theory specifying how to compute strategy expressions for it, and then T M (R) (X) is the category of all such strategy expression rewritings. <p> A substantial amount of evidence, advocating the suitability of rewriting logic for these purposes already exists <ref> [35, 26, 25, 27] </ref>. Since rewriting logic is reflective and has internal strategy languages, a more systematic exploitation of reflection in its use as a logical and semantic framework seems both promising and natural. Similar studies can also be useful for other suitable reflective logics.
Reference: [36] <author> Jose Meseguer. </author> <title> Multiparadigm logic programming. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> <booktitle> Proc. 3rd Intl. Conf. on Algebraic and Logic Programming, </booktitle> <pages> pages 158-200. </pages> <publisher> Springer LNCS 632, </publisher> <year> 1992. </year>
Reference-contexts: Definition 3 below gives an axiomatization|in terms of general logics concepts|of the notion of declarative language just presented; a stronger notion requiring also an initial model semantics can be found in <ref> [34, 36] </ref>. The definition allows careful selection of the signatures and the finite sets of sentences that can be used as statements to make up a program P , and also of those sentences that are admissible as queries. <p> Any such O is called an operational semantics for the declarative programming language L. 2 This definition encompasses a wide range of logics and languages. For example, most equational, functional, Horn logic, and rewriting logic declarative languages, as well as multiparadigm combinations of these, satisfy the definition's requirements <ref> [34, 36] </ref>. 3 Axiomatizing Reflective Logics and Languages A reflective logic is a logic in which important aspects of its metatheory can be represented at the object level in a consistent way, so that the object-level representation correctly simulates the relevant metatheoretic aspects. <p> Since equational logic and Horn logic are both naturally included in rewriting logic in a conservative way, rewriting logic programming generalizes equational programming and Horn logic programming <ref> [36, 26] </ref>. A first sketch of the reflective aspects of rewriting logic appeared in [27]. The class of finitely presentable rewrite theories has indeed universal theories in exactly the above axiomatic sense.
Reference: [37] <author> Jose Meseguer. </author> <title> A logical theory of concurrent objects and its realization in the Maude language. </title> <editor> In Gul Agha, Peter Wegner, and Akinori Yonezawa, editors, </editor> <booktitle> Research Directions in Concurrent Object-Oriented Programming, </booktitle> <pages> pages 314-390. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Our interest in a conceptual clarification of reflection has been motivated by our current design and implementation work on the Maude rewriting logic language <ref> [37] </ref>. Two other languages based on rewriting logic have been designed by other researchers [25, 13]. <p> Since a particularly simple rewriting logic semantics for object-oriented systems, including concurrent ones, already exists <ref> [37] </ref>, developing a rewriting logic semantics for reflective object-oriented systems seems a natural and promising research direction. * Mappings between reflective systems. In the theory of general logics, logics are related by mappings preserving the relevant logical structure.
Reference: [38] <author> Torben . Mogensen. </author> <title> Efficient self-interpretation in lambda calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(3) </volume> <pages> 345-364, </pages> <year> 1992. </year>
Reference-contexts: 0 : (9y)(f 1 ; : : : ; f n ):(eval N )(M 1 ; : : : ; M n ) ! nf y: 8 A closed lambda term eval = E and a representation function with exactly these properties have been defined and proved correct by Mogensen <ref> [38] </ref>.
Reference: [39] <author> Eugenio Moggi. </author> <title> Computational lambda-calculus and monads. </title> <booktitle> In Proceedings Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 14-23, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Yet another promising recent development in this general area is the use of lambda calculi and monads a la Moggi <ref> [39] </ref> to give semantics to reflective languages [11, 33]. 3.1.2 Equational Languages There is very strong evidence, thanks to the work on the Refal supercompiler [56, 57, 59] and to related work on partial evaluation of equational programs [6, 49], suggesting that equational languages can be made reflective in our precise
Reference: [40] <author> Masanobu Numazawa, Masahito Kurihara, and Azuma Ohuchi. </author> <title> A reflective language based on conditional term rewriting. </title> <type> Technical report, </type> <institution> Division of Systems and Information Engineering, Hokkaido University, </institution> <address> Sapporo, Japan, </address> <year> 1996. </year>
Reference-contexts: A different approach is taken in <ref> [40] </ref>, where an abstract machine for evaluating conditional equational programs is extended with reflective capabilities. The treatment in [40] does not provide a universal theory and seems limited in its reflective power. 3.1.3 Horn Logic Languages There is a long tradition of metacircular interpreters and meta-programming in Prolog (see the papers <p> A different approach is taken in <ref> [40] </ref>, where an abstract machine for evaluating conditional equational programs is extended with reflective capabilities. The treatment in [40] does not provide a universal theory and seems limited in its reflective power. 3.1.3 Horn Logic Languages There is a long tradition of metacircular interpreters and meta-programming in Prolog (see the papers collected in [1, 8, 43, 12, 3] and references there) strongly suggesting that a more declarative variant of
Reference: [41] <author> Hideaki Okamura, Yutaka Ishikawa, and Mario Tokoro. AL-1/D: </author> <title> A distributed programming system with multi-model reflection framework. </title> <booktitle> In IMSA'92, </booktitle> <pages> pages 36-47. </pages> <institution> Information-Technology Promotion Agency, </institution> <address> Japan, </address> <year> 1992. </year>
Reference-contexts: Many researchers have recognized its great importance and usefulness in programming languages [54, 51, 60, 56, 23, 19, 30], in theorem-proving [62, 7, 48, 20, 2, 29, 14, 16], in concurrent and distributed computation <ref> [28, 41, 46] </ref>, and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection). The very success and extension of reflective ideas underscores the need for conceptual foundations.
Reference: [42] <author> Lawrence Paulson. </author> <title> Tactics and tacticals in Cambridge LCF. </title> <type> Technical Report 39, </type> <institution> University of Cambridge, </institution> <year> 1983. </year>
Reference-contexts: This may be done by having a strategy language S (T ) associated to T . For example, in theorem provers in the LCF tradition, there is a metalanguage, namely ML, in which "tactics" and "tacticals" can be defined for exactly this purpose <ref> [42] </ref>.
Reference: [43] <editor> A. Pettorossi, editor. </editor> <booktitle> Proceedings Third Workshop on Meta-programming in Logic. </booktitle> <publisher> LNCS 649. Springer-Verlag, </publisher> <month> April </month> <year> 1992. </year>
Reference-contexts: The treatment in [40] does not provide a universal theory and seems limited in its reflective power. 3.1.3 Horn Logic Languages There is a long tradition of metacircular interpreters and meta-programming in Prolog (see the papers collected in <ref> [1, 8, 43, 12, 3] </ref> and references there) strongly suggesting that a more declarative variant of Prolog can be made reflective in our axiomatic sense. The "vanilla" interpreters presented in the literature, for example in [55], fall short of being a universal theory and lack adequate semantics.
Reference: [44] <editor> Simon Peyton-Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference: [45] <author> F. Pfenning and P. Lee. </author> <title> Metacircularity in the polymorphic -calculus. </title> <booktitle> Theoretical Computer Science, </booktitle> <pages> pages 137-159, </pages> <year> 1991. </year>
Reference-contexts: may exist, but outside the class of theories in the language, or it may be necessary to consider eval functions with a bound on the number of rewrites to remain within the language (see, for example, [47, 31] for a careful treatment of this problem for the calculus of constructions, <ref> [45] </ref> for a study of reflection in the polymorphic lambda calculus, and [20, 2, 10] for the treatment of reflection in Nuprl's constructive type theory a la Martin Lof).
Reference: [46] <author> Luis H. Rodriguez, Jr. </author> <title> A study on the viability of a production-quality metaobject protocol-based statically parallelizing compiler. </title> <booktitle> In IMSA'92, </booktitle> <pages> pages 107-112. </pages> <institution> Information-Technology Promotion Agency, </institution> <address> Japan, </address> <year> 1992. </year>
Reference-contexts: Many researchers have recognized its great importance and usefulness in programming languages [54, 51, 60, 56, 23, 19, 30], in theorem-proving [62, 7, 48, 20, 2, 29, 14, 16], in concurrent and distributed computation <ref> [28, 41, 46] </ref>, and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection). The very success and extension of reflective ideas underscores the need for conceptual foundations.
Reference: [47] <author> Harald Rue. </author> <title> Formal Meta-Programming in the Calculus of Constructions. </title> <type> PhD thesis, </type> <institution> Universitat Ulm, </institution> <year> 1995. </year>
Reference-contexts: typecheck an appropriate eval function in the given type discipline; therefore, a universal theory may exist, but outside the class of theories in the language, or it may be necessary to consider eval functions with a bound on the number of rewrites to remain within the language (see, for example, <ref> [47, 31] </ref> for a careful treatment of this problem for the calculus of constructions, [45] for a study of reflection in the polymorphic lambda calculus, and [20, 2, 10] for the treatment of reflection in Nuprl's constructive type theory a la Martin Lof).
Reference: [48] <author> N. Shankar. </author> <title> Metamathematics, Machines, and Godel's Proof. </title> <publisher> Cambridge University Press, </publisher> <year> 1994. </year>
Reference-contexts: In computer science it has been present from the beginning in the form of universal Turing machines. Many researchers have recognized its great importance and usefulness in programming languages [54, 51, 60, 56, 23, 19, 30], in theorem-proving <ref> [62, 7, 48, 20, 2, 29, 14, 16] </ref>, in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection).
Reference: [49] <author> David Sherman, Robert Strandh, and Irene Durand. </author> <title> Optimization of equational programs using partial evaluation. </title> <booktitle> In PEPM'91, </booktitle> <pages> pages 72-82. </pages> <booktitle> SIGPLAN Notices, </booktitle> <year> 1991. </year>
Reference-contexts: area is the use of lambda calculi and monads a la Moggi [39] to give semantics to reflective languages [11, 33]. 3.1.2 Equational Languages There is very strong evidence, thanks to the work on the Refal supercompiler [56, 57, 59] and to related work on partial evaluation of equational programs <ref> [6, 49] </ref>, suggesting that equational languages can be made reflective in our precise axiomatic sense. The careful representation by levels of Refal terms and programs (also represented as terms) [59] has excellent mathematical properties and allows arbitrarily high reflective towers.
Reference: [50] <editor> Brian Smith and Akinori Yonezawa, editors. </editor> <booktitle> Proc. of the IMSA'92 International Workshop on Reflection and Meta-Level Architecture, </booktitle> <address> Tokyo, </address> <month> November </month> <year> 1992. </year> <institution> Research Institute of Software Engineering, </institution> <year> 1992. </year>
Reference-contexts: recognized its great importance and usefulness in programming languages [54, 51, 60, 56, 23, 19, 30], in theorem-proving [62, 7, 48, 20, 2, 29, 14, 16], in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see <ref> [50] </ref> for a recent snapshot of research in reflection). The very success and extension of reflective ideas underscores the need for conceptual foundations.
Reference: [51] <author> Brian C. Smith. </author> <title> Reflection and Semantics in Lisp. </title> <booktitle> In Proc. POPL'84, </booktitle> <pages> pages 23-35. </pages> <publisher> ACM, </publisher> <year> 1984. </year>
Reference-contexts: In computer science it has been present from the beginning in the form of universal Turing machines. Many researchers have recognized its great importance and usefulness in programming languages <ref> [54, 51, 60, 56, 23, 19, 30] </ref>, in theorem-proving [62, 7, 48, 20, 2, 29, 14, 16], in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection).
Reference: [52] <author> C. Smorynski. </author> <title> The incompleteness theorems. </title> <editor> In J. Barwise, editor, </editor> <booktitle> Handbook of Mathematical Logic, </booktitle> <pages> pages 821-865. </pages> <publisher> North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: 1 Introduction Reflection is a fundamental idea. In logic it has been vigorously pursued by many researchers since the fundamental work of Godel and Tarski (see the surveys <ref> [52, 53] </ref>). In computer science it has been present from the beginning in the form of universal Turing machines.
Reference: [53] <author> R. M. Smullyan. </author> <title> Diagonalization and Self-Reference. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Reflection is a fundamental idea. In logic it has been vigorously pursued by many researchers since the fundamental work of Godel and Tarski (see the surveys <ref> [52, 53] </ref>). In computer science it has been present from the beginning in the form of universal Turing machines.
Reference: [54] <author> G. L. Steele, Jr. and G. J. Sussman. </author> <title> The art of the interpreter or, the modularity complex. </title> <type> Technical Report AIM-453, </type> <institution> MIT AI-Lab, </institution> <month> May </month> <year> 1978. </year> <month> 16 </month>
Reference-contexts: In computer science it has been present from the beginning in the form of universal Turing machines. Many researchers have recognized its great importance and usefulness in programming languages <ref> [54, 51, 60, 56, 23, 19, 30] </ref>, in theorem-proving [62, 7, 48, 20, 2, 29, 14, 16], in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection).
Reference: [55] <author> Leon Sterling and Ehud Shapiro. </author> <title> The Art of Prolog. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: The "vanilla" interpreters presented in the literature, for example in <ref> [55] </ref>, fall short of being a universal theory and lack adequate semantics.
Reference: [56] <author> Valentin F. Turchin. </author> <title> The concept of a supercompiler. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(3) </volume> <pages> 292-325, </pages> <year> 1986. </year>
Reference-contexts: In computer science it has been present from the beginning in the form of universal Turing machines. Many researchers have recognized its great importance and usefulness in programming languages <ref> [54, 51, 60, 56, 23, 19, 30] </ref>, in theorem-proving [62, 7, 48, 20, 2, 29, 14, 16], in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection). <p> Yet another promising recent development in this general area is the use of lambda calculi and monads a la Moggi [39] to give semantics to reflective languages [11, 33]. 3.1.2 Equational Languages There is very strong evidence, thanks to the work on the Refal supercompiler <ref> [56, 57, 59] </ref> and to related work on partial evaluation of equational programs [6, 49], suggesting that equational languages can be made reflective in our precise axiomatic sense.
Reference: [57] <author> Valentin F. Turchin. REFAL-5, </author> <title> Programming Guide and Reference Manual. </title> <address> New England Publishing Co., </address> <year> 1989. </year>
Reference-contexts: Yet another promising recent development in this general area is the use of lambda calculi and monads a la Moggi [39] to give semantics to reflective languages [11, 33]. 3.1.2 Equational Languages There is very strong evidence, thanks to the work on the Refal supercompiler <ref> [56, 57, 59] </ref> and to related work on partial evaluation of equational programs [6, 49], suggesting that equational languages can be made reflective in our precise axiomatic sense.
Reference: [58] <author> Valentin F. Turchin. </author> <title> Program transformation with metasystem transitions. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(3) </volume> <pages> 283-313, </pages> <year> 1993. </year>
Reference-contexts: The Refal supercompiler|a program transformer also written in Refal [56]|can "compile away" extra levels of interpretation and can support very powerful meta-programming and compilation tasks <ref> [58] </ref>.
Reference: [59] <author> Valentin F. Turchin and Andrei P. Nemytykh. Metavariables: </author> <title> their implementation and use in program transformation. </title> <type> Technical Report CSc-TR-95-012, </type> <institution> City College of CUNY, </institution> <year> 1995. </year>
Reference-contexts: Yet another promising recent development in this general area is the use of lambda calculi and monads a la Moggi [39] to give semantics to reflective languages [11, 33]. 3.1.2 Equational Languages There is very strong evidence, thanks to the work on the Refal supercompiler <ref> [56, 57, 59] </ref> and to related work on partial evaluation of equational programs [6, 49], suggesting that equational languages can be made reflective in our precise axiomatic sense. <p> The careful representation by levels of Refal terms and programs (also represented as terms) <ref> [59] </ref> has excellent mathematical properties and allows arbitrarily high reflective towers. The Refal supercompiler|a program transformer also written in Refal [56]|can "compile away" extra levels of interpretation and can support very powerful meta-programming and compilation tasks [58].
Reference: [60] <author> M. Wand and D.P. Friedman. </author> <title> The mystery of the tower revealed. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 1(1) </volume> <pages> 11-38, </pages> <year> 1988. </year>
Reference-contexts: In computer science it has been present from the beginning in the form of universal Turing machines. Many researchers have recognized its great importance and usefulness in programming languages <ref> [54, 51, 60, 56, 23, 19, 30] </ref>, in theorem-proving [62, 7, 48, 20, 2, 29, 14, 16], in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection).
Reference: [61] <author> Takuo Watanabe. </author> <title> Towards a foundation of computational reflection based on abstract rewriting (preliminary result). </title> <booktitle> In IMSA'95, </booktitle> <pages> pages 143-145. </pages> <institution> Information-Technology Promotion Agency, </institution> <address> Japan, </address> <year> 1995. </year>
Reference-contexts: Therefore, because of its reflective properties, rewriting logic seems a good semantic framework to specify and prototype many other reflective logics and computational systems; the example of Turing machines discussed below is a case in point. Further evidence is provided by the recent work of Watanabe <ref> [61] </ref>, and of Malenfant, Dony, and Cointe [21], since in these two papers rewriting is used to formalize computational reflection. 3.1.5 Turing Machines Turing machines can be naturally viewed as phrase structure grammars, and therefore as string rewriting systems, that is, as rewrite theories modulo the associativity equation for a binary <p> We conjecture that reflective rewriting logic can provide clear and simple semantics for reflective computational systems, as briefly illustrated here by the example of Turing machines and further evidenced by the use of rewriting systems in semantic definitions of reflection by other authors <ref> [61, 21] </ref>. Since a particularly simple rewriting logic semantics for object-oriented systems, including concurrent ones, already exists [37], developing a rewriting logic semantics for reflective object-oriented systems seems a natural and promising research direction. * Mappings between reflective systems.
Reference: [62] <author> Richard W. Weyhrauch. </author> <title> Prolegomena to a theory of mechanized formal reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13 </volume> <pages> 133-170, </pages> <year> 1980. </year>
Reference-contexts: In computer science it has been present from the beginning in the form of universal Turing machines. Many researchers have recognized its great importance and usefulness in programming languages [54, 51, 60, 56, 23, 19, 30], in theorem-proving <ref> [62, 7, 48, 20, 2, 29, 14, 16] </ref>, in concurrent and distributed computation [28, 41, 46], and in many other areas such as compilation, programming environments, operating systems, fault-tolerance, and databases (see [50] for a recent snapshot of research in reflection).
References-found: 62

