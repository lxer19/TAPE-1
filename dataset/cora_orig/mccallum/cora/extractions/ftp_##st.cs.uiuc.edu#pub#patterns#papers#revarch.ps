URL: ftp://st.cs.uiuc.edu/pub/patterns/papers/revarch.ps
Refering-URL: http://st-www.cs.uiuc.edu/users/patterns/papers/
Root-URL: http://www.cs.uiuc.edu
Email: vlis@watson.ibm.com  
Title: Reverse Architecture  
Author: John Vlissides 
Address: P.O. Box 704, Yorktown Heights, NY 10598 USA  
Affiliation: IBM T.J. Watson Research Center,  
Note: Position Paper Dagstuhl Seminar 9508  
Abstract: This paper articulates the need to assimilate and exposit software architecture effectively. The term reverse architecture describes this process. I use design pattern development as an example. I present lessons learned in the development of numerous design patterns to illustrate one approach to reverse architecture. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Grady Booch. </author> <title> Object-Oriented Analysis and Design with Applications. </title> <address> Benjamin/Cummings, Redwood City, CA, </address> <year> 1994. </year> <note> Second Edition. </note>
Reference-contexts: Examples should not be the sole estate of the Motivation section. Use examples throughout the pattern to illustrate key points. Even the most abstract sections in our template (i.e., Applicability, Structure, Participants, and Collaborations) sometimes include examples. For example, the Collaboration sections of some patterns include interaction diagrams <ref> [5, 1] </ref> to show the collaborations between objects at run-time [4]. Refer to such examples when discussing the abstract aspects of the patternbe concrete even when you're being abstract. 8 Keep Patterns Distinct and Complementary There's a common tendency to avoid as you work on multiple patterns.
Reference: [2] <author> Grady Booch and Michael Vilot. </author> <title> The design of the C++ Booch components. </title> <booktitle> In Object-Oriented Programming Systems, Languages, and Applications Conference, </booktitle> <pages> pages 1-11, </pages> <address> Ottawa, Canada, </address> <month> October </month> <year> 1990. </year> <note> ACM Press. 10 </note>
Reference-contexts: In the RTL System for compiler code optimization [6], strategies define different register allocation schemes (RegisterAllocator) and instruction set scheduling policies (RISCscheduler, CISCscheduler). This provides flexibility in targeting the optimizer for different machine architectures. The Booch components <ref> [2] </ref> use strategies as template arguments. The Booch collection classes support three different kinds of memory allocation strategies: managed (allocation out of a pool), controlled (allocations/deallocations are protected by locks), and unmanaged (the normal memory allocator). These strategies are passed as template arguments to a collection class when it's instantiated.
Reference: [3] <author> Elliot J. Chikofsky and James H. </author> <title> Cross II. Reverse engineering and design recovery: A taxonomy. </title> <journal> IEEE Software, </journal> <volume> 7(1) </volume> <pages> 13-17, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Reverse engineering concepts have also found their way into software circles. In software, however, reverse engineering techniques are used for program understanding rather than for duplicating the software (which is easy enough to do already!) <ref> [3] </ref>. Hence the engineering moniker is less appropriate for software than for hardware. The software focus is really architecturalon recovering design rather than implementation. A term like reverse architecting would be more accurate in the software context.
Reference: [4] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year>
Reference-contexts: Reverse architecture is really just my tongue-in-cheek term for what Erich Gamma, Richard Helm, Ralph Johnson, and I did as we wrote Design Patterns: Elements of Reusable Object-Oriented Software <ref> [4] </ref>. Design patterns capture expertise in building object-oriented software. A design pattern describes a solution to a recurring design problem in a consistent and general way. A particular solution by itself is not enough. You need a deeper understanding to tailor the solution to your variant of the problem. <p> Use examples throughout the pattern to illustrate key points. Even the most abstract sections in our template (i.e., Applicability, Structure, Participants, and Collaborations) sometimes include examples. For example, the Collaboration sections of some patterns include interaction diagrams [5, 1] to show the collaborations between objects at run-time <ref> [4] </ref>. Refer to such examples when discussing the abstract aspects of the patternbe concrete even when you're being abstract. 8 Keep Patterns Distinct and Complementary There's a common tendency to avoid as you work on multiple patterns. Patterns tend to grow both in detail and in scope.
Reference: [5] <author> Ivar Jacobson, Magnus Christerson, Patrik Jonsson, and Gunnar Overgaard. </author> <title> Object-Oriented Software EngineeringA Use Case Driven Approach. </title> <publisher> Addison-Wesley, </publisher> <address> Wokingham, England, </address> <year> 1992. </year>
Reference-contexts: Examples should not be the sole estate of the Motivation section. Use examples throughout the pattern to illustrate key points. Even the most abstract sections in our template (i.e., Applicability, Structure, Participants, and Collaborations) sometimes include examples. For example, the Collaboration sections of some patterns include interaction diagrams <ref> [5, 1] </ref> to show the collaborations between objects at run-time [4]. Refer to such examples when discussing the abstract aspects of the patternbe concrete even when you're being abstract. 8 Keep Patterns Distinct and Complementary There's a common tendency to avoid as you work on multiple patterns.
Reference: [6] <author> Ralph E. Johnson, Carl McConnell, and J. Michael Lake. </author> <title> The RTL system: A framework for code optimization. </title> <editor> In Robert Giegerich and Susan L. Graham, editors, </editor> <title> Code GenerationConcepts, Tools, Techniques. </title> <booktitle> Proceedings of the International Workshop on Code Generation, </booktitle> <pages> pages 255-274, </pages> <address> Dagstuhl, Germany, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In general, the Strategy and Context interfaces determine how well the pattern achieves its intent. Known Uses Both ET++ [9] and InterViews use strategies to encapsulate different linebreaking algorithms as we've described. In the RTL System for compiler code optimization <ref> [6] </ref>, strategies define different register allocation schemes (RegisterAllocator) and instruction set scheduling policies (RISCscheduler, CISCscheduler). This provides flexibility in targeting the optimizer for different machine architectures. The Booch components [2] use strategies as template arguments.
Reference: [7] <author> Mark Linton, Paul Calder, John Interrante, Steven Tang, and John Vlissides. </author> <title> InterViews Reference Manual. </title> <type> CSL, </type> <institution> Stanford University, </institution> <address> 3.1 edition, </address> <year> 1992. </year>
Reference-contexts: Sample Code We'll give the high-level code for the Motivation example, which is based on the implementation of Composition and Compositor classes in the InterViews user interface toolkit <ref> [7] </ref>. The Composition class maintains a collection of Component instances, which represent text and graphical elements in a document. A composition arranges component objects into lines using an instance of a Compositor subclass, which encapsulates a linebreaking strategy. Each component has an associated natural size, stretchability, and shrinkability.
Reference: [8] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and William Lorenson. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: Applicability What are the situations in which the design pattern can be applied? What are examples of poor designs that the pattern can address? How can you recognize these situations? Structure A graphical representation of the classes in the pattern using a notation based on the Object Modeling Technique (OMT) <ref> [8] </ref>. Participants The classes and/or objects participating in the design pattern and their responsibilities. Collaborations How the participants collaborate to carry out their responsibilities.
Reference: [9] <author> Andr e Weinand, Erich Gamma, and Rudolf Marty. </author> <title> ET++An object-oriented application framework in C++. </title> <booktitle> In Object-Oriented Programming Systems, Languages, and Applications Conference, </booktitle> <pages> pages 46-57, </pages> <address> San Diego, CA, </address> <month> September </month> <year> 1988. </year> <note> ACM Press. 11 </note>
Reference-contexts: You don't want to have to change this interface with every new subclass, because that will require changing existing subclasses. In general, the Strategy and Context interfaces determine how well the pattern achieves its intent. Known Uses Both ET++ <ref> [9] </ref> and InterViews use strategies to encapsulate different linebreaking algorithms as we've described. In the RTL System for compiler code optimization [6], strategies define different register allocation schemes (RegisterAllocator) and instruction set scheduling policies (RISCscheduler, CISCscheduler). This provides flexibility in targeting the optimizer for different machine architectures.
References-found: 9

