URL: ftp://ftp.cs.unc.edu/pub/publications/techreports/94-008.ps.Z
Refering-URL: ftp://ftp.cs.unc.edu/pub/publications/techreports/FILE.html
Root-URL: http://www.cs.unc.edu
Title: Interactive Display of Large Scale Trimmed NURBS Models  
Author: Subodh Kumar Dinesh Manocha 
Address: Chapel Hill NC 27599  Chapel Hill NC 27599  
Affiliation: Department of Computer Science University of North Carolina  Department of Computer Science University of North Carolina  
Abstract: We present an algorithm for interactive display of trimmed NURBS surfaces. The algorithm converts the NURBS surfaces to Bezier surfaces, tessellates each trimmed Bezier surface into triangles and renders them using the triangle rendering capabilities common in current graphics systems. It makes use of tight bounds for uniform tessellation of Bezier surfaces into cells and traces the trimming curves to compute the trimmed regions of each cell. This is based on trim curve tracing, intersection computation with the cells, and triangulation of the cells. The resulting technique also makes efficient use of spatial and temporal coherence between successive frames for cell computation and triangulation. Polygonization anomalies like cracks and angularities are avoided as well. The algorithm works well in practice and, on the high end graphics systems, is able to display trimmed models described using thousands of Bezier surfaces at interactive frame rates. 
Abstract-found: 1
Intro-found: 1
Reference: [AES91] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> Tessellation of curved surfaces under highly varying transformations. </title> <booktitle> Proceedings of Eurographics'91, </booktitle> <pages> pages 385-97, </pages> <year> 1991. </year>
Reference-contexts: Furthermore, the operations used on trimming curves are relatively expensive and affects the performance of the overall algorithm. Some techniques to improve the tessellation and their computations are presented in <ref> [FMM86, AES91, AES93] </ref>. The algorithm presented in this paper has considerable improvements over these algorithms (e.g. see Figs. 1 and 2). 2 Organization: The rest of the paper is organized in the following manner. <p> On such models the uniform tessellation may supersample the surface. The performance of uniform tessellation algorithms is a direct function of the step sizes. 4.1 Uniform Subdivision There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. There are two main criteria for computing bounds for step sizes: size criterion and deviation criterion. <p> These bounds can be applied in two ways for step size computation: 1. Compute the bounds on the surface in the object space as a preprocessing step. The step size is computed as a function of these bounds and viewing parameters <ref> [LR81, FMM86, AES91] </ref>. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and , the step size as a function of these bounds [Roc87, RHD89]. We start with the size criterion for bound computations. <p> They are used to compute the step sizes as a function of the viewing parameters as shown in [FMM86, AES93]. An algorithm for computation of bounds based on the size criterion has been highlighted in <ref> [AES91] </ref>. However, the derivation of bounds in [AES91] is inaccurate and for a given T OL, our bounds are tighter. We illustrate the derivation on a Bezier curve (it is applied in a similar manner to the surfaces). <p> They are used to compute the step sizes as a function of the viewing parameters as shown in [FMM86, AES93]. An algorithm for computation of bounds based on the size criterion has been highlighted in <ref> [AES91] </ref>. However, the derivation of bounds in [AES91] is inaccurate and for a given T OL, our bounds are tighter. We illustrate the derivation on a Bezier curve (it is applied in a similar manner to the surfaces). Given a rational curve C (t) = (x (t); y (t); z (t); w (t). <p> curves defined as (R i1 ; R i2 ; : : : ; R in ) for all 1 i m and take the maximum of n 0 0 computed in a similar manner. 4.4 Comparison of Methods We empirically compared our bound with those of Rockwood [Roc87] and Abi-Ezzi/Shirman <ref> [AES91] </ref>. These comparisons were performed over a number of models and we computed the averages of the 14 (a) [RHD89]'s Bounds (b) [AES91]'s Bounds (c) Our Bounds I. Alpha 1 Goblet (a) [RHD89]'s Bounds (b) [AES91]'s Bounds (c) Our Bounds II. Alpha 1 Pencil 15 number of polygons generated. <p> The degrees of the models were between two and three in u as well as v. For the same tolerance, our bounds result in about 33% fewer triangles than [Roc87] and about 20% fewer than <ref> [AES91] </ref>. Fig. 7 compares the wireframes and shaded images of a car panel using the three methods. Model Our Algorithm [Roc87] [AES91] Goblet 1 1.48 1.26 Pencil 1 1.51 1.20 Table 1: Relative comparison of the number of triangles generated for a given tolerance 4.5 Crack Prevention Since the bound for <p> For the same tolerance, our bounds result in about 33% fewer triangles than [Roc87] and about 20% fewer than <ref> [AES91] </ref>. Fig. 7 compares the wireframes and shaded images of a car panel using the three methods. Model Our Algorithm [Roc87] [AES91] Goblet 1 1.48 1.26 Pencil 1 1.51 1.20 Table 1: Relative comparison of the number of triangles generated for a given tolerance 4.5 Crack Prevention Since the bound for required tessellation for each patch is evaluated independently, we could mandate different tessellations on two adjacent patches.
Reference: [AES93] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> The scaling behavior of viewing transformations. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 13(3) </volume> <pages> 48-54, </pages> <year> 1993. </year>
Reference-contexts: Furthermore, the operations used on trimming curves are relatively expensive and affects the performance of the overall algorithm. Some techniques to improve the tessellation and their computations are presented in <ref> [FMM86, AES91, AES93] </ref>. The algorithm presented in this paper has considerable improvements over these algorithms (e.g. see Figs. 1 and 2). 2 Organization: The rest of the paper is organized in the following manner. <p> They are used to compute the step sizes as a function of the viewing parameters as shown in <ref> [FMM86, AES93] </ref>. An algorithm for computation of bounds based on the size criterion has been highlighted in [AES91]. However, the derivation of bounds in [AES91] is inaccurate and for a given T OL, our bounds are tighter. <p> Given these bounds in the object space, we compute the step size in the screen space as a function of the viewing transformations. These bounds are invariant to rigid body transformations like rotations and translations. They vary with the perspective transformation matrix as shown in <ref> [AES93] </ref>. 4.3 Curvature Bounds For small values of T OL the size criterion bounds, derived above, work very well. In case the surface area is small and curvature is high, they may undersample the surface.
Reference: [Ake93] <author> K. Akeley. </author> <title> Reality engine graphics. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 109-1116, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Current graphics systems have reached the capability of rendering millions of transformed, shaded and z-buffered triangles per second <ref> [Ake93, Fea89] </ref>.
Reference: [Baj90] <author> C.L. Bajaj. </author> <title> Rational hypersurface display. </title> <booktitle> In Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 117-27, </pages> <address> Snowbird, UT, </address> <year> 1990. </year>
Reference: [Bea91] <author> R. Bedichek et. al. </author> <title> Rapid low-cost display of spline surfaces. </title> <booktitle> In Proceedings of advanced reserach in VLSI, </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference: [Cat74] <author> E. Catmull. </author> <title> A subdivision algorithm for computer display of curved surfaces. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1974. </year>
Reference-contexts: Previous Work: Curved surface rendering has seen active research in the last two decades and boasts of rich literature. The main techniques are based on pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Cla79, LR81, For79, Kaj82, NSK90, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, algorithms based on polygonization are, in general, faster.
Reference: [Che93] <author> F. Cheng. </author> <title> Computation techniques on nurb surfaces. </title> <booktitle> In SIAM Conference on Geometric Design, </booktitle> <address> Tempe, AZ, </address> <year> 1993. </year>
Reference: [Cla79] <author> J. H. Clark. </author> <title> A fast algorithm for rendering parametric surfaces. </title> <booktitle> Proceedings of ACM Siggraph, </booktitle> <pages> pages 289-99, </pages> <year> 1979. </year>
Reference-contexts: Previous Work: Curved surface rendering has seen active research in the last two decades and boasts of rich literature. The main techniques are based on pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Cla79, LR81, For79, Kaj82, NSK90, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, algorithms based on polygonization are, in general, faster.
Reference: [CTV89] <author> K. Clarkson, R. E. Tarjan, and C. J. Van Wyk. </author> <title> A fast Las Vegas algorithm for triangulating a simple polygon. </title> <journal> Discrete Comput. Geom., </journal> <volume> 4 </volume> <pages> 423-432, </pages> <year> 1989. </year>
Reference-contexts: P 8 and R in the cell C2 in Fig. 13. The above two steps can be merged into one, and if all the in-points are on the convex envelope, as they normally are, the complete region is triangulated in linear time. Any concave polygon triangulation algorithm <ref> [PS85, CTV89, Sei91] </ref> can be used to compute the convex envelope while triangulating the region between the envelope and the polygon.
Reference: [Dea89] <author> T. Derose et. al. Apex: </author> <title> two architectures for generating parametric curves and surfaces. </title> <journal> The Visual Computer, </journal> <volume> 5 </volume> <pages> 264-276, </pages> <year> 1989. </year>
Reference: [DN93] <author> M.F. Deering and S.R. Nelson. Leo: </author> <title> A system for cost effective 3d shaded graphics. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 101-108, </pages> <year> 1993. </year>
Reference: [Far90] <author> G. Farin. </author> <title> Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide. </title> <publisher> Academic Press Inc., </publisher> <year> 1990. </year> <month> 34 </month>
Reference-contexts: Spatial and Temporal Coherence : We make use of coherence between successive frames to minimize the overall computations for polygon generation. In particular, we perform incre mental computations. Background: Given a NURBS model, we use knot insertion to decompose them into a series of Bezier patches <ref> [Far90] </ref>. In the process, we insert the minimum number of knots as a function of the knot sequence of the original surface and its order. Closely spaced knots, with tolerance less than 2 fi 10 5 are coerced to the same value before knot insertion. <p> A Bezier surface, defined in homogeneous coordinates as F (u; v) = (X (u; v); Y (u; v); Z (u; v); W (u; v)), is specified by a mesh of control points. Furthermore, the entire surface is contained in the convex polytope of the control points <ref> [Far90] </ref>. Let us denote this convex polytope as P F .
Reference: [FB88] <author> D. Forsey and R.H. Bentels. </author> <title> Heirarchical b-spline refinement. </title> <booktitle> In ACM SIGGRAPH, </booktitle> <pages> pages 205-212, </pages> <year> 1988. </year>
Reference: [Fea89] <author> H. Fuchs and J. Poulton et. al. </author> <title> Pixel-planes 5: A heterogeneous multiprocessor graphics system using processor-enhanced memories. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 79-88, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Current graphics systems have reached the capability of rendering millions of transformed, shaded and z-buffered triangles per second <ref> [Ake93, Fea89] </ref>. <p> The resulting algorithm is portable and its actual performance is a function of the hardware resources available on a system (memory, CPUs, and special purpose chips). Our current implementation on the SGI-VGX can display about four hundred surfaces and on Pixel-planes 5, <ref> [Fea89] </ref> about six thousand surfaces at interactive frame rates (about 12 15 frames a second). Previous Work: Curved surface rendering has seen active research in the last two decades and boasts of rich literature. <p> 1 (3 fps) 1.91 2.67 7.11 Pencil 576 1 (1.1 fps) 1.85 2.89 8.47 Car Panel 1872 1 (.08 fps) 2.13 2.19 7.82 Trimmed 32 1 (5 fps) 2.21 2.41 5.28 teapot Table 2: Relative performance of the techniques on SGI-VGX and does not perform the computations) and 14 renderers <ref> [Fea89] </ref>. The algorithm achieves load balancing by distributing neighboring patches onto different processors statically. The algorithm does not require any inter-processor communication (or shared memory) during execution. As a result it can be easily ported to any other multiple processor machine.
Reference: [FK90] <author> D.R. Forsey and V. Klassen. </author> <title> An adaptive subdivision algorithm for crack prevention in the display of parametric surfaces. </title> <booktitle> Proceedings of Graphics Interface, </booktitle> <pages> pages 1-8, </pages> <year> 1990. </year>
Reference: [FMM86] <author> D. Filip, R. Magedson, and R. Markot. </author> <title> Surface algorithms using bounds on derivatives. </title> <journal> CAGD, </journal> <volume> 3 </volume> <pages> 295-311, </pages> <year> 1986. </year>
Reference-contexts: Furthermore, the operations used on trimming curves are relatively expensive and affects the performance of the overall algorithm. Some techniques to improve the tessellation and their computations are presented in <ref> [FMM86, AES91, AES93] </ref>. The algorithm presented in this paper has considerable improvements over these algorithms (e.g. see Figs. 1 and 2). 2 Organization: The rest of the paper is organized in the following manner. <p> On such models the uniform tessellation may supersample the surface. The performance of uniform tessellation algorithms is a direct function of the step sizes. 4.1 Uniform Subdivision There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. There are two main criteria for computing bounds for step sizes: size criterion and deviation criterion. <p> These bounds can be applied in two ways for step size computation: 1. Compute the bounds on the surface in the object space as a preprocessing step. The step size is computed as a function of these bounds and viewing parameters <ref> [LR81, FMM86, AES91] </ref>. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and , the step size as a function of these bounds [Roc87, RHD89]. We start with the size criterion for bound computations. <p> They are used to compute the step sizes as a function of the viewing parameters as shown in <ref> [FMM86, AES93] </ref>. An algorithm for computation of bounds based on the size criterion has been highlighted in [AES91]. However, the derivation of bounds in [AES91] is inaccurate and for a given T OL, our bounds are tighter. <p> This could result in cracks in the rendered 16 image. To address this issue <ref> [FMM86, RHD89] </ref> suggested that the amount of tessellation at the boundary be based solely on the boundary curve, and a strip of coving triangles be generated at the boundary.
Reference: [For79] <author> A.R. </author> <title> Forest. On the rendering of surfaces. </title> <journal> Computer Graphics, </journal> <volume> 13(2) </volume> <pages> 253-59, </pages> <year> 1979. </year>
Reference-contexts: Previous Work: Curved surface rendering has seen active research in the last two decades and boasts of rich literature. The main techniques are based on pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Cla79, LR81, For79, Kaj82, NSK90, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, algorithms based on polygonization are, in general, faster.
Reference: [Kaj82] <author> J. Kajiya. </author> <title> Ray tracing parametric patches. </title> <journal> Computer Graphics, </journal> <volume> 16(3) </volume> <pages> 245-254, </pages> <year> 1982. </year>
Reference-contexts: Previous Work: Curved surface rendering has seen active research in the last two decades and boasts of rich literature. The main techniques are based on pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Cla79, LR81, For79, Kaj82, NSK90, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, algorithms based on polygonization are, in general, faster.
Reference: [LC93] <author> W.L. Luken and Fuhua Cheng. </author> <title> Rendering trimmed nurb surfaces. </title> <institution> Computer science research report 18669(81711), IBM Research Division, </institution> <year> 1993. </year>
Reference: [LCWB80] <author> J.M. Lane, L.C. Carpenter, J. T. Whitted, and J.F. </author> <title> Blinn. Scan line methods for displaying parametrically defined surfaces. </title> <journal> Communications of ACM, </journal> <volume> 23(1) </volume> <pages> 23-34, </pages> <year> 1980. </year>
Reference-contexts: Previous Work: Curved surface rendering has seen active research in the last two decades and boasts of rich literature. The main techniques are based on pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Cla79, LR81, For79, Kaj82, NSK90, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, algorithms based on polygonization are, in general, faster.
Reference: [LR81] <author> J.M. Lane and R.F. Riesenfeld. </author> <title> Bounds on polynomials. </title> <journal> BIT, </journal> <volume> 2 </volume> <pages> 112-117, </pages> <year> 1981. </year>
Reference-contexts: Previous Work: Curved surface rendering has seen active research in the last two decades and boasts of rich literature. The main techniques are based on pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Cla79, LR81, For79, Kaj82, NSK90, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, algorithms based on polygonization are, in general, faster. <p> On such models the uniform tessellation may supersample the surface. The performance of uniform tessellation algorithms is a direct function of the step sizes. 4.1 Uniform Subdivision There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. There are two main criteria for computing bounds for step sizes: size criterion and deviation criterion. <p> These bounds can be applied in two ways for step size computation: 1. Compute the bounds on the surface in the object space as a preprocessing step. The step size is computed as a function of these bounds and viewing parameters <ref> [LR81, FMM86, AES91] </ref>. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and , the step size as a function of these bounds [Roc87, RHD89]. We start with the size criterion for bound computations. <p> Note that all these computations are part of the preprocessing stage. Similarly, the maximum of f x (0; v) corresponds to computing the roots of f x v (0; v) = 0, which can be computed using root-finders or subdivision properties of Bezier curves <ref> [LR81] </ref>. Based on the solutions of these equations, we compute the maximum values of f x (u; v) in the domain [0; 1] fi [0; 1]. Let the maximum value be at [u x ; v x ].
Reference: [Luk93] <institution> W.L. Luken. Tessellation of trimmed nurb surfaces. Computer science research report 19322(84059), IBM Research Division, </institution> <year> 1993. </year>
Reference: [MD92] <author> D. Manocha and J. Demmel. </author> <title> Algorithms for intersecting parametric and algebraic curves. </title> <booktitle> In Graphics Interface '92, </booktitle> <pages> pages 232-241, </pages> <year> 1992. </year>
Reference-contexts: Thus the problem of computing the maximum derivative vector reduces to computing zeros of polynomial equations. In fact, it geometrically corresponds to curve intersection <ref> [MD92, Sed89] </ref>. <p> This is rather high. However, we are able to compute accurate solutions in double precision arithmetic using the algorithm described in <ref> [MD92] </ref>. In particular, it reduces the problem to computing eigenvalues of a matrix. Good implementations of eigenvalue evaluators are available as part of numerical libraries like EISPACK and LAPACK. The resulting algorithms are fast, accurate and need no initial guess to the solutions. <p> This query reduces to an inversion problem: given a point P and a curve C, find the parameter value t such that C (t) = P . We solve it using techniques from elimination theory <ref> [MD92] </ref>. For each patch boundary, we associate one of the adjacent patches (chosen arbitrarily) with it. If we have two different representations for the same curve, we store the representation of the associated patch's boundary curve with both the patches.
Reference: [Nas93] <author> R. Nash. </author> <title> Silicon Graphics, </title> <type> Personal Communication, </type> <year> 1993. </year>
Reference-contexts: As a result it can be easily ported to any other multiple processor machine. The performance of the algorithm on the SGI-VGX has been shown in Table 2. The SGI-GL implementation is based on the algorithm presented in <ref> [RHD89, Nas93] </ref> and has a microcoded geometry engine implementation for surface evaluations. Although it is difficult to compare two different algorithms and implementations, we tried to run the algorithms on models undergoing the same transformation between two frames.
Reference: [NSK90] <author> T. Nishita, T.W. Sederberg, and M. Kakimoto. </author> <title> Ray tracing trimmed rational surface patches. </title> <journal> Computer Graphics, </journal> <volume> 24(4) </volume> <pages> 337-345, </pages> <year> 1990. </year>
Reference-contexts: Previous Work: Curved surface rendering has seen active research in the last two decades and boasts of rich literature. The main techniques are based on pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Cla79, LR81, For79, Kaj82, NSK90, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current architectures. As a result, algorithms based on polygonization are, in general, faster.
Reference: [PS85] <author> F.P. Preparata and M. I. Shamos. </author> <title> Computational Geometry. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year> <month> 35 </month>
Reference-contexts: P 8 and R in the cell C2 in Fig. 13. The above two steps can be merged into one, and if all the in-points are on the convex envelope, as they normally are, the complete region is triangulated in linear time. Any concave polygon triangulation algorithm <ref> [PS85, CTV89, Sei91] </ref> can be used to compute the convex envelope while triangulating the region between the envelope and the polygon.
Reference: [RHD89] <author> A. Rockwood, K. Heaton, and T. Davis. </author> <title> Real-time rendering of trimmed surfaces. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 107-117, </pages> <year> 1989. </year>
Reference-contexts: As a result, algorithms based on polygonization are, in general, faster. Different methods have been proposed for polygonization [Baj90, AES93, Bea91, Dea89, LR81, Luk93, LC93, Che93, SC88, SL87, FK90, RHD89, Roc87, AES91, FMM86]. These are based on adaptive or uniform subdivision of NURBS surfaces. <ref> [RHD89] </ref> have proposed a real time algorithm for trimmed surfaces. However the bounds used for tessellating the Bezier surfaces are loose for rational surfaces and in some cases even undersample the surface. Furthermore, the operations used on trimming curves are relatively expensive and affects the performance of the overall algorithm. <p> The step size is computed as a function of these bounds and viewing parameters [LR81, FMM86, AES91]. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and , the step size as a function of these bounds <ref> [Roc87, RHD89] </ref>. We start with the size criterion for bound computations. To avoid undersampling highly curved surfaces with low areas, we use an additional estimate based on the geometry of the control points. <p> This could result in cracks in the rendered 16 image. To address this issue <ref> [FMM86, RHD89] </ref> suggested that the amount of tessellation at the boundary be based solely on the boundary curve, and a strip of coving triangles be generated at the boundary. <p> As a result it can be easily ported to any other multiple processor machine. The performance of the algorithm on the SGI-VGX has been shown in Table 2. The SGI-GL implementation is based on the algorithm presented in <ref> [RHD89, Nas93] </ref> and has a microcoded geometry engine implementation for surface evaluations. Although it is difficult to compare two different algorithms and implementations, we tried to run the algorithms on models undergoing the same transformation between two frames.
Reference: [Roc87] <author> A. Rockwood. </author> <title> A generalized scanning technique for display of parametrically defined surface. </title> <journal> IEEE Computer Graphics and Applications, </journal> <pages> pages 15-26, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: On such models the uniform tessellation may supersample the surface. The performance of uniform tessellation algorithms is a direct function of the step sizes. 4.1 Uniform Subdivision There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. There are two main criteria for computing bounds for step sizes: size criterion and deviation criterion. <p> The step size is computed as a function of these bounds and viewing parameters [LR81, FMM86, AES91]. 2. Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and , the step size as a function of these bounds <ref> [Roc87, RHD89] </ref>. We start with the size criterion for bound computations. To avoid undersampling highly curved surfaces with low areas, we use an additional estimate based on the geometry of the control points. <p> Let T OL be the user specified tolerance in screen space. The step sizes along the u and v directions are given as <ref> [Roc87] </ref>: n u = m max T OL fl min (W ij ) k W ij R ij W i;j+1 R i;j+1 k for (1 i m, 1 j n). In practice these bounds are good for polynomial surfaces only, when W ij = 1. <p> consider the Bezier curves defined as (R i1 ; R i2 ; : : : ; R in ) for all 1 i m and take the maximum of n 0 0 computed in a similar manner. 4.4 Comparison of Methods We empirically compared our bound with those of Rockwood <ref> [Roc87] </ref> and Abi-Ezzi/Shirman [AES91]. These comparisons were performed over a number of models and we computed the averages of the 14 (a) [RHD89]'s Bounds (b) [AES91]'s Bounds (c) Our Bounds I. Alpha 1 Goblet (a) [RHD89]'s Bounds (b) [AES91]'s Bounds (c) Our Bounds II. <p> The average has been taken over seven models and the number of patches varied from 72 to 5354. The degrees of the models were between two and three in u as well as v. For the same tolerance, our bounds result in about 33% fewer triangles than <ref> [Roc87] </ref> and about 20% fewer than [AES91]. Fig. 7 compares the wireframes and shaded images of a car panel using the three methods. Model Our Algorithm [Roc87] [AES91] Goblet 1 1.48 1.26 Pencil 1 1.51 1.20 Table 1: Relative comparison of the number of triangles generated for a given tolerance 4.5 <p> For the same tolerance, our bounds result in about 33% fewer triangles than <ref> [Roc87] </ref> and about 20% fewer than [AES91]. Fig. 7 compares the wireframes and shaded images of a car panel using the three methods. Model Our Algorithm [Roc87] [AES91] Goblet 1 1.48 1.26 Pencil 1 1.51 1.20 Table 1: Relative comparison of the number of triangles generated for a given tolerance 4.5 Crack Prevention Since the bound for required tessellation for each patch is evaluated independently, we could mandate different tessellations on two adjacent patches.
Reference: [SC88] <author> M. Shantz and S. Chang. </author> <title> Rendering trimmed nurbs with adaptive forward differencing. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 189-198, </pages> <year> 1988. </year>
Reference: [Sed89] <author> T.W. </author> <title> Sederberg. Algorithms for algebraic curve intersection. </title> <booktitle> Computer-Aided Design, </booktitle> <volume> 21(9) </volume> <pages> 547-555, </pages> <year> 1989. </year>
Reference-contexts: Thus the problem of computing the maximum derivative vector reduces to computing zeros of polynomial equations. In fact, it geometrically corresponds to curve intersection <ref> [MD92, Sed89] </ref>.
Reference: [Sei91] <author> R. Seidel. </author> <title> A simple and fast randomized algorithm for computing trapezoidal decompositions and for triangulating polygons. </title> <journal> Computational Geometry Theory & Applications, </journal> <volume> 1(1) </volume> <pages> 51-64, </pages> <year> 1991. </year>
Reference-contexts: P 8 and R in the cell C2 in Fig. 13. The above two steps can be merged into one, and if all the in-points are on the convex envelope, as they normally are, the complete region is triangulated in linear time. Any concave polygon triangulation algorithm <ref> [PS85, CTV89, Sei91] </ref> can be used to compute the convex envelope while triangulating the region between the envelope and the polygon.
Reference: [SL87] <author> M. Shantz and S. Lien. </author> <title> Shading bicubic patches. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 189-196, </pages> <year> 1987. </year> <month> 36 </month>
References-found: 32

