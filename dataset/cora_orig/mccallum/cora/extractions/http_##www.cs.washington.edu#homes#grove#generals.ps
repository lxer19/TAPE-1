URL: http://www.cs.washington.edu/homes/grove/generals.ps
Refering-URL: http://www.cs.washington.edu/homes/grove/generals.html
Root-URL: 
Keyword: Object-Oriented Languages  
Affiliation: Department of Computer Science and Engineering University of Washington  
Note: David Grove  
Abstract: University of Washington Generals Examination Written Report, June 1995 Constraining Polymorphism in Statically Typed Abstract A major attraction of object-oriented programming languages is the promise of increased code reuse, especially through large class libraries implementing common abstract data types and algorithms. Unfortunately, the type systems of most widely used, statically typed object-oriented languages are unable to express the kinds of constrained polymorphism required to support the construction of such libraries. In this paper, we first document the inadequacies of current statically typed object-oriented languages. We then compare and contrast several proposed solutions focusing on their relative expressivity and complexity. 
Abstract-found: 1
Intro-found: 1
Reference: [Black & Hutchinson 91] <author> Andrew P. Black and Norman C. Hutchinson. </author> <title> Typechecking Polymorphism in Emerald. </title> <type> Technical Report TR 90-34, </type> <institution> Department of Computer Science, University of Ari-zona, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: [T], the need to distinguish between real 10 Constraining Polymorphism in Statically Typed Object-Oriented Languages classes like Set [T] and SymbolTableEntry and pseudo-classes like Comparable [T] may be a source of confusion for the programmer. 5.2 Bounded Matching Bounded matching was first developed as part of the Emerald type system <ref> [Black & Hutchinson 91] </ref> and has since been used by Bruce and his collaborators in the definition of a variety of related statically typed object-oriented languages: Toopl, Toople, Toil, and PolyToil [Bruce 93, Bruce et al. 93, Bruce et al. 95], and in Strongtalk [Bracha & Griswold 93], a strongly typed <p> As mentioned earlier, bounded matching and F-bounded quantification have equivalent expressivity, but bounded matching is an arguably simpler means of expressing it <ref> [Black & Hutchinson 91, Bruce 93] </ref>. <p> Two types are said to match if their structure is identical. Rather than formally defining the matching relationship (see <ref> [Black & Hutchinson 91, Bruce 93] </ref>), we will rely on the example below as illustration. class Comparable - signature =(other:MyType):bool; - class Point - int x, y; method =(other:MyType):bool; - In PolyToil and its related languages, the special type MyType is used to refer to the type of the class currently <p> T that are subtypes of S simple and intuitive inadequate for recursive types, like those needed to specify a generic set F-bounded quantifica tion [Canning et al. 89a] type variables bounded by type functions small extension to bounded quantification specifications are often com plex proliferation of pseudo types Bounded matching <ref> [Black & Hutchinson 91, Bruce et al. 95] </ref> uses a matching relation ship which is distinct from subtyping more direct than F-bounded quantification requires separation of sub-typing and inheritance typing rules are more complex slightly less expressive than where clauses or extended F-bounded quantification Where clauses [Day et al. 95] Recursively
Reference: [Bracha & Griswold 93] <author> Gilad Bracha and David Griswold. Strongtalk: </author> <title> Typechecking Smalltalk in a Production Environment. </title> <booktitle> In Proceedings OOPSLA 93, ACM SIGPLAN Notices, </booktitle> <pages> pages 215 230, </pages> <month> October </month> <year> 1993. </year> <title> Published as Proceedings OOPSLA 93, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> volume 28, number 10. </volume>
Reference-contexts: part of the Emerald type system [Black & Hutchinson 91] and has since been used by Bruce and his collaborators in the definition of a variety of related statically typed object-oriented languages: Toopl, Toople, Toil, and PolyToil [Bruce 93, Bruce et al. 93, Bruce et al. 95], and in Strongtalk <ref> [Bracha & Griswold 93] </ref>, a strongly typed extension of Smalltalk-80. As mentioned earlier, bounded matching and F-bounded quantification have equivalent expressivity, but bounded matching is an arguably simpler means of expressing it [Black & Hutchinson 91, Bruce 93].
Reference: [Bruce 93] <author> Kim B. Bruce. </author> <title> Safe Type Checking in a Statically-Typed Object-Oriented Programming Language. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 285298, </pages> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: confusion for the programmer. 5.2 Bounded Matching Bounded matching was first developed as part of the Emerald type system [Black & Hutchinson 91] and has since been used by Bruce and his collaborators in the definition of a variety of related statically typed object-oriented languages: Toopl, Toople, Toil, and PolyToil <ref> [Bruce 93, Bruce et al. 93, Bruce et al. 95] </ref>, and in Strongtalk [Bracha & Griswold 93], a strongly typed extension of Smalltalk-80. <p> As mentioned earlier, bounded matching and F-bounded quantification have equivalent expressivity, but bounded matching is an arguably simpler means of expressing it <ref> [Black & Hutchinson 91, Bruce 93] </ref>. <p> Two types are said to match if their structure is identical. Rather than formally defining the matching relationship (see <ref> [Black & Hutchinson 91, Bruce 93] </ref>), we will rely on the example below as illustration. class Comparable - signature =(other:MyType):bool; - class Point - int x, y; method =(other:MyType):bool; - In PolyToil and its related languages, the special type MyType is used to refer to the type of the class currently <p> A more detailed and formal discussion of the implications for typechecking of allowing separate inheritance and subtyping hierarchies is beyond the scope of this paper, but more details are available in <ref> [Bruce 93, Eifrig et al. 94] </ref>.
Reference: [Bruce et al. 93] <author> Kim B. Bruce, Jon Crabtree, Thomas P. Murtagh, Robert van Gent, Allyn Dimock, and Robert Muller. </author> <title> Safe and decidable type checking in an object-oriented language. </title> <booktitle> In Proceedings OOPSLA 93, ACM SIGPLAN Notices, </booktitle> <pages> pages 2946, </pages> <month> October </month> <year> 1993. </year> <title> Published as Proceedings OOPSLA 93, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> volume 28, number 10. </volume>
Reference-contexts: confusion for the programmer. 5.2 Bounded Matching Bounded matching was first developed as part of the Emerald type system [Black & Hutchinson 91] and has since been used by Bruce and his collaborators in the definition of a variety of related statically typed object-oriented languages: Toopl, Toople, Toil, and PolyToil <ref> [Bruce 93, Bruce et al. 93, Bruce et al. 95] </ref>, and in Strongtalk [Bracha & Griswold 93], a strongly typed extension of Smalltalk-80.
Reference: [Bruce et al. 95] <author> Kim B. Bruce, Angela Schuett, and Robert van Gent. PolyToil: </author> <title> A Type-Safe Polymorphic Object-Oriented Language. </title> <booktitle> In Proceedings ECOOP 95, </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: confusion for the programmer. 5.2 Bounded Matching Bounded matching was first developed as part of the Emerald type system [Black & Hutchinson 91] and has since been used by Bruce and his collaborators in the definition of a variety of related statically typed object-oriented languages: Toopl, Toople, Toil, and PolyToil <ref> [Bruce 93, Bruce et al. 93, Bruce et al. 95] </ref>, and in Strongtalk [Bracha & Griswold 93], a strongly typed extension of Smalltalk-80. <p> T that are subtypes of S simple and intuitive inadequate for recursive types, like those needed to specify a generic set F-bounded quantifica tion [Canning et al. 89a] type variables bounded by type functions small extension to bounded quantification specifications are often com plex proliferation of pseudo types Bounded matching <ref> [Black & Hutchinson 91, Bruce et al. 95] </ref> uses a matching relation ship which is distinct from subtyping more direct than F-bounded quantification requires separation of sub-typing and inheritance typing rules are more complex slightly less expressive than where clauses or extended F-bounded quantification Where clauses [Day et al. 95] Recursively
Reference: [Canning et al. 89a] <author> Peter Canning, William Cook, Walter Hill, John Mitchell, and Walter Olthoff. </author> <title> F-Bounded Polymorphism for Object-Oriented Programming. </title> <booktitle> In Proceedings of the Fourth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273280. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Its inability to provide intuitively desirable results in the presence of recursive types has motivated the development of several more powerful, but more complex approaches. These approaches may be classified into three major groupings: F-bounded quantification <ref> [Canning et al. 89a] </ref>, bounded matching [Black & Hutchinson 91, Bruce 93, Bruce et al. 95 Bracha & Griswold 93], and where clauses [Day et al. 95] or recursively constrained types [Eifrig et al. 95]. <p> 5.4 summarizes the discussion and highlights the trade-offs between each of these three approaches to constraining polymorphism. 5.1 F-Bounded Quantification F-bounded quantification was proposed by Canning et al as an extension of bounded quantification that would be more effective for the recursive types that are often found in object-oriented programs <ref> [Canning et al. 89a] </ref>. An F-bounded type is a type of the form "tF [t].s, where F [t] is an expression, usually containing the type variable t. <p> an inter procedural dataow prob lem at link-time to ensue type safety Bounded quantification [Cardelli & Wegner 85] allows type variables to range over all types T that are subtypes of S simple and intuitive inadequate for recursive types, like those needed to specify a generic set F-bounded quantifica tion <ref> [Canning et al. 89a] </ref> type variables bounded by type functions small extension to bounded quantification specifications are often com plex proliferation of pseudo types Bounded matching [Black & Hutchinson 91, Bruce et al. 95] uses a matching relation ship which is distinct from subtyping more direct than F-bounded quantification requires separation
Reference: [Canning et al. 89b] <author> Peter S. Canning, William Cook, Walter L. Hill, and Walter G. Olthoff. </author> <title> Interfaces for Strongly-Typed Object-Oriented Programming. </title> <booktitle> In Proceedings OOPSLA 89, ACM SIGP-LAN Notices, </booktitle> <pages> pages 457468, </pages> <month> October </month> <year> 1989. </year> <title> Published as Proceedings OOPSLA 89, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> volume 24, number 10. </volume>
Reference-contexts: One of the underlying premises in all of the languages which utilize matching to constrain polymorphism is that subtyping and inheritance are two different, and not quite compatible, relationships that can be defined over classes * <ref> [Snyder 86, Canning et al. 89b, Cook et al. 90] </ref>. Thus, in these languages it is possible to create subclasses that are not subtypes of their parent classes.
Reference: [Cardelli & Wegner 85] <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding Types, Data Abstraction, and Polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4):471522, </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: this paper, we describe how recent theoretical work in polymorphic type systems for object-oriented languages can be applied to increase the expressivity of statically typed object-oriented languages. 4 Bounded Quantification Cardelli and Wegner first proposed the use of bounded universal quantification as a mechanism for constraining polymorphism in object-oriented languages <ref> [Cardelli & Wegner 85] </ref>. Bounded quantification allows the programmer to express the idea that a function applies to all types T such that T is a subtype of S. <p> code bloat and increased compile time client needs access to source code of template Covariant function sub typing [Meyer 86] uses covariant subtyping rule for function available today adequate for many practical examples requires solution of an inter procedural dataow prob lem at link-time to ensue type safety Bounded quantification <ref> [Cardelli & Wegner 85] </ref> allows type variables to range over all types T that are subtypes of S simple and intuitive inadequate for recursive types, like those needed to specify a generic set F-bounded quantifica tion [Canning et al. 89a] type variables bounded by type functions small extension to bounded quantification
Reference: [Cardelli 88] <author> Luca Cardelli. </author> <title> A Semantics of Multiple Inheritance. </title> <journal> Information and Computation, </journal> <volume> 76:138 164, </volume> <year> 1988. </year>
Reference-contexts: The fundamental premise underlying formal models of singly dispatched object-oriented languages * is that an object may be modeled as a record containing functional components (methods) and that message sending corresponds to record component selection. This model of objects was first developed by Cardelli <ref> [Cardelli 88] </ref> and has been the basis of almost all subsequent theoretical work in object-oriented type systems (this model of objects as records does not generalize very easily to multiply dispatched languages, however until section 6 we will restrict the discussion to singly dispatched languages).
Reference: [Castagna 94] <author> Giuseppe Castagna. </author> <title> Covariance and Contravariance: Conflict without a Cause. </title> <type> Technical Report LIENS-94-18, </type> <institution> Ecole Normale Superieure, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: Castagna has developed an alternative model that is applicable to multi-methods in which methods are represented by functions containing type cases that select the appropriate method based on the runtime types of the arguments <ref> [Castagna 94] </ref>. Additionally, in singly dispatched languages the receiver of a message is usual implicit in the method declaration; it is referred to as self or this rather than appearing explicitly in the methods argument list.
Reference: [Chambers & Leavens 94] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and Modules for Multi-Methods. </title> <booktitle> In Proceedings OOPSLA 94, </booktitle> <pages> pages 115, </pages> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: We extend this definition in a multiply dispatched language by allowing all specialized arguments to vary covariantly while requiring that all non-specialized arguments are contravariantly related. In recent work, Chambers and Leavens have developed a polynomial time type checking algorithm for multiply-dispatched languages <ref> [Chambers & Leavens 94] </ref>. A precise description of their algorithm is beyond the scope of this paper, however, an intuitive understanding of some of the key principles of typechecking multi 15 Constraining Polymorphism in Statically Typed Object-Oriented Languages methods will be useful as a basis for subsequent discussion.
Reference: [Chambers 93] <author> Craig Chambers. </author> <title> The Cecil Language: Specification and Rationale. </title> <type> Technical Report TR-93-03-05, </type> <institution> Department of Computer Science and Engineering. University of Washington, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Thus, supporting pattern matching seems like a requirement for any practical language which relies upon either F-bounded quantification or where clauses to constrain polymorphism. Cecil <ref> [Chambers 93] </ref> includes support for pattern matching, however the implementation is not yet complete and there are a variety of open questions that need to be resolved.
Reference: [Cook 89] <author> William Cook. </author> <title> A Proposal for Making Eiffel Type-safe. </title> <editor> In S. Cook, editor, </editor> <booktitle> Proceedings ECOOP 89, </booktitle> <pages> pages 5770, </pages> <address> Nottingham, July 10-14 1989. </address> <publisher> Cambridge University Press. </publisher>
Reference-contexts: A more natural subtyping relationship for function might be the following (known as the covariant rule): However, applying this possibly more intuitive subtyping rule can have unfortunate results. Consider the following example, based on <ref> [Cook 89] </ref>, which is type correct using the covariant rule for function subtyping: Class Base - method base (n:int):int - return n + 1; -; - Class Extra inherits Base - method extra (n:int):int - return n * 2; -; - Class P - method test (arg:Base):int - return arg.base (1);
Reference: [Cook et al. 90] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance Is Not Subtyping. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125135, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1990. </year> <title> 21 Constraining Polymorphism in Statically Typed Object-Oriented Languages </title>
Reference-contexts: One of the underlying premises in all of the languages which utilize matching to constrain polymorphism is that subtyping and inheritance are two different, and not quite compatible, relationships that can be defined over classes * <ref> [Snyder 86, Canning et al. 89b, Cook et al. 90] </ref>. Thus, in these languages it is possible to create subclasses that are not subtypes of their parent classes.
Reference: [Day et al. 95] <author> Mark Day, Robert Gruber, Barbara Liskov, and Andrew C. Myers. </author> <title> Subtypes vs. Where Clauses: Constraining Parametric Polymorphism. </title> <booktitle> In Proceedings OOPSLA 95, </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: These approaches may be classified into three major groupings: F-bounded quantification [Canning et al. 89a], bounded matching [Black & Hutchinson 91, Bruce 93, Bruce et al. 95 Bracha & Griswold 93], and where clauses <ref> [Day et al. 95] </ref> or recursively constrained types [Eifrig et al. 95]. F-bounded quantification and bounded matching can be shown to be fundamentally equivalent in expressive power; their differences lie in the way in which a particular idea is expressed, not in what can be expressed. <p> The basic approach is to use where clauses, based on ideas from the CLU language [Liskov et al. 77], to explicitly specify the operations required of the arguments to a polymorphic function rather than specifying them indirectly through subtyping or matching <ref> [Day et al. 95] </ref>. <p> pseudo types Bounded matching [Black & Hutchinson 91, Bruce et al. 95] uses a matching relation ship which is distinct from subtyping more direct than F-bounded quantification requires separation of sub-typing and inheritance typing rules are more complex slightly less expressive than where clauses or extended F-bounded quantification Where clauses <ref> [Day et al. 95] </ref> Recursively constrained types [Eifrig et al. 95] constraints are specified explicitly as part of each declaration avoids need for pseudo types and more complicated typing rules all constraints must be explicitly restated in each declaration 20 Constraining Polymorphism in Statically Typed Object-Oriented Languages
Reference: [Eifrig et al. 94] <author> Jonathan Eifrig, Scott Smith, Valery Trifonov, and Amy Zwarico. </author> <title> Application of OOP Type Theory: State, Decidability, Integration. </title> <booktitle> In Proceedings OOPSLA 94, </booktitle> <pages> pages 1630, </pages> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: A more detailed and formal discussion of the implications for typechecking of allowing separate inheritance and subtyping hierarchies is beyond the scope of this paper, but more details are available in <ref> [Bruce 93, Eifrig et al. 94] </ref>.
Reference: [Eifrig et al. 95] <author> Jonathan Eifrig, Scott Smith, and Valery Trifonov. </author> <title> Sound Polymorphic Type Inference for Objects. </title> <booktitle> In Proceedings OOPSLA 95, </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: These approaches may be classified into three major groupings: F-bounded quantification [Canning et al. 89a], bounded matching [Black & Hutchinson 91, Bruce 93, Bruce et al. 95 Bracha & Griswold 93], and where clauses [Day et al. 95] or recursively constrained types <ref> [Eifrig et al. 95] </ref>. F-bounded quantification and bounded matching can be shown to be fundamentally equivalent in expressive power; their differences lie in the way in which a particular idea is expressed, not in what can be expressed. <p> The Theta work has focused mainly on implementation and provides neither a formal definition of its type system, nor any justification of either its soundness or decidability. However, recent work by Eifrig et al can be applied to provide a solid theoretical foundation for the Theta type system <ref> [Eifrig et al. 95] </ref>. They study the usage of polymorphic recursively constrained types as a basis for type inference of object-oriented languages. <p> 91, Bruce et al. 95] uses a matching relation ship which is distinct from subtyping more direct than F-bounded quantification requires separation of sub-typing and inheritance typing rules are more complex slightly less expressive than where clauses or extended F-bounded quantification Where clauses [Day et al. 95] Recursively constrained types <ref> [Eifrig et al. 95] </ref> constraints are specified explicitly as part of each declaration avoids need for pseudo types and more complicated typing rules all constraints must be explicitly restated in each declaration 20 Constraining Polymorphism in Statically Typed Object-Oriented Languages
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Lanaguge and its Implementation. </title> <address> Addision-Wesley, Reading, MA, </address> <year> 1983. </year>
Reference-contexts: To support these kinds of abstractions, a programming language needs to be able to express constrained polymorphism, i.e. that an abstract data type or function can be applied to any object, as long as it satisfies certain properties. In a dynamically typed object-oriented language, such as Smalltalk-80 <ref> [Goldberg & Robson 83] </ref> or SELF [Ungar & Smith 87], it is fairly easy to implement such generic abstractions.
Reference: [Gunter & Mitchell 94] <editor> Carl A. Gunter and John C. Mitchell, editors. </editor> <booktitle> Theoretical Apsects of Object-Oriented Programming: Types, Semantics and Language Design. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1994. </year>
Reference: [Liskov & Wing 93] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> Specifications and Their Use in Defining Sub-types. </title> <booktitle> In Proceedings OOPSLA 93, ACM SIGPLAN Notices, </booktitle> <pages> pages 1628, </pages> <month> October </month> <year> 1993. </year> <title> Published as Proceedings OOPSLA 93, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> volume 28, number 10. </volume>
Reference-contexts: Two systems which support this additional kind of specification are Theta <ref> [Liskov & Wing 93] </ref> and Scratchpad [Watt et al. ]. In these systems, the programmer may annotate method implementations and signatures with abstract properties such as transitive.
Reference: [Liskov et al. 77] <author> Barbara Liskov, Alan Snyder, Russell Atkinson, and Craig Schaffert. </author> <title> Abstraction Mechanisms in CLU. </title> <journal> Communications of the ACM, </journal> <volume> 20(8):564576, </volume> <month> August </month> <year> 1977. </year>
Reference-contexts: The basic approach is to use where clauses, based on ideas from the CLU language <ref> [Liskov et al. 77] </ref>, to explicitly specify the operations required of the arguments to a polymorphic function rather than specifying them indirectly through subtyping or matching [Day et al. 95].
Reference: [Liskov et al. 94] <author> Barbara Liskov, Dorthoy Curtis, Mark Day, Sanjay Ghemawhat, Robert Gruber, Paul Johnson, and Andrew C. Myers. </author> <title> Theta Reference Manual. </title> <type> Technical Report Programming Methodology Group Memo 88, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: more complicated set of typing rules and requires the programmer to be aware of two distinct partial orders, inheritance and subtyping, over the class hierarchy. 5.3 Where Clauses and Recursively Constrained Types An alternative means of expressing constrained polymorphism has been developed in the context of the Theta object-oriented language <ref> [Liskov et al. 94] </ref>. The basic approach is to use where clauses, based on ideas from the CLU language [Liskov et al. 77], to explicitly specify the operations required of the arguments to a polymorphic function rather than specifying them indirectly through subtyping or matching [Day et al. 95].
Reference: [Meyer 86] <author> Bertrand Meyer. </author> <title> Genericity versus Inheritance. </title> <booktitle> In Proceedings OOPSLA 86, ACM SIGP-LAN Notices, </booktitle> <pages> pages 391405, </pages> <month> November </month> <year> 1986. </year> <title> Published as Proceedings OOPSLA 86, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> volume 21, number 11. </volume>
Reference-contexts: correct to compare any two subclasses of Comparable, even though the comparison may be semantically meaningless and thus should be reported as a compile time type error. 6 Constraining Polymorphism in Statically Typed Object-Oriented Languages In Eiffel, a statically typed object-oriented language that uses the covariant rule for function subtyping <ref> [Meyer 86] </ref>, we could define SymbolTableEntry and Point as follows: class SymbolTableEntry subclasses Comparable - string name; method =(other:SymbolTableEntry) - self.name = other.name - - class Point subclasses Comparable - int x,y; method =(other:Point) - self.x = other.x & self.y = other.y - - Using covariance permits declarations of this style, <p> Approach Description Pros Cons Templates instantiates parameterized code for each required type available today adequate for many practical examples potential code bloat and increased compile time client needs access to source code of template Covariant function sub typing <ref> [Meyer 86] </ref> uses covariant subtyping rule for function available today adequate for many practical examples requires solution of an inter procedural dataow prob lem at link-time to ensue type safety Bounded quantification [Cardelli & Wegner 85] allows type variables to range over all types T that are subtypes of S simple
Reference: [Meyer 92] <author> Bertrand Meyer. </author> <title> Eiffel: the language. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: In particular, the static type system should make it possible to easily and efficiently express constrained polymorphism without needing to bypass the type system. Unfortunately, the type systems of commonly used statically typed object-oriented languages, such as C++ [Stroustrup 91], Modula-3 [Nelson 91], or Eiffel <ref> [Meyer 92] </ref>, are inadequate, and the programmer must either forgo static typing to gain expressivity, or sacrifice expressivity to gain static typing. In the next section of this paper, we review some necessary background material. <p> For this reason, all statically typed object-oriented languages, with the notable exception of Eiffel <ref> [Meyer 92] </ref>, either use the contravariant rule for function subtyping, or do not allow the argument types of overridden methods to be redefined at all, since contravariant style redefinition is rarely useful. 3 The Problem In this section, we first describe the example we will use throughout the rest of this
Reference: [Mitchell 90] <author> John C. Mitchell. </author> <title> Toward a Typed Foundation for Method Specialization and Inheritance. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109124, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1990. </year>
Reference: [Nelson 91] <author> Greg Nelson. </author> <title> Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: In particular, the static type system should make it possible to easily and efficiently express constrained polymorphism without needing to bypass the type system. Unfortunately, the type systems of commonly used statically typed object-oriented languages, such as C++ [Stroustrup 91], Modula-3 <ref> [Nelson 91] </ref>, or Eiffel [Meyer 92], are inadequate, and the programmer must either forgo static typing to gain expressivity, or sacrifice expressivity to gain static typing. In the next section of this paper, we review some necessary background material. <p> This facilitates the creation of precompiled libraries that may be provided to clients without requiring the distribution of the actual library source files. We would like to be able to implement a set ADT in a statically typed object-oriented language such as C++[Stroustrup 91] or Modula-3 <ref> [Nelson 91] </ref> without bypassing the type system by relying on type casts and while preserving the three properties mentioned above. One natural way to attempt to do this would be to define a Comparable class which defines an = method.
Reference: [Snyder 86] <author> Alan Snyder. </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Languages. </title> <booktitle> In Proceedings OOPSLA 86, ACM SIGPLAN Notices, </booktitle> <pages> pages 3845, </pages> <month> November </month> <year> 1986. </year> <title> Published as Proceedings OOPSLA 86, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> volume 21, number 11. </volume>
Reference-contexts: One of the underlying premises in all of the languages which utilize matching to constrain polymorphism is that subtyping and inheritance are two different, and not quite compatible, relationships that can be defined over classes * <ref> [Snyder 86, Canning et al. 89b, Cook et al. 90] </ref>. Thus, in these languages it is possible to create subclasses that are not subtypes of their parent classes.
Reference: [Stroustrup 91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language (second edition). </title> <address> Addision-Wesley, Reading, MA, </address> <year> 1991. </year>
Reference-contexts: In particular, the static type system should make it possible to easily and efficiently express constrained polymorphism without needing to bypass the type system. Unfortunately, the type systems of commonly used statically typed object-oriented languages, such as C++ <ref> [Stroustrup 91] </ref>, Modula-3 [Nelson 91], or Eiffel [Meyer 92], are inadequate, and the programmer must either forgo static typing to gain expressivity, or sacrifice expressivity to gain static typing. In the next section of this paper, we review some necessary background material.
Reference: [Ungar & Smith 87] <author> David Ungar and Randall B. Smith. </author> <title> Self: The Power of Simplicity. </title> <booktitle> In Proceedings OOPSLA 87, ACM SIGPLAN Notices, </booktitle> <pages> pages 227242, </pages> <month> December </month> <year> 1987. </year> <title> Published as Proceedings OOPSLA 87, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> volume 22, number 12. </volume>
Reference-contexts: In a dynamically typed object-oriented language, such as Smalltalk-80 [Goldberg & Robson 83] or SELF <ref> [Ungar & Smith 87] </ref>, it is fairly easy to implement such generic abstractions. The data structure or function is simply defined and if it is later applied to an object which does not implement the assumed operations, then a message-not-understood error occurs during program execution.
Reference: [Watt et al. ] <author> Stephen M. Watt, Richard D. Jenks, Robert S. Sutor, and Barry M. Trager. </author> <title> The Scratchpad II Type System: Domains and Subdomains. </title> <type> Technical report, </type> <institution> Mathematical Sciences Department, IBM Thomas J. Watson Research Center. </institution>
Reference-contexts: Two systems which support this additional kind of specification are Theta [Liskov & Wing 93] and Scratchpad <ref> [Watt et al. ] </ref>. In these systems, the programmer may annotate method implementations and signatures with abstract properties such as transitive.
References-found: 30

