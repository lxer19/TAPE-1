URL: http://www.daimi.aau.dk/~hbc/papers/FinalReport.ps.gz
Refering-URL: http://www.daimi.aau.dk/~hbc/Ragnarok.html
Root-URL: http://www.daimi.aau.dk
Title: Ragnarok Contours of a Software Project Development Environment  
Date: 1996  
Note: Summer,  
Abstract: Progress Report by Henrik Brbak Christensen Abstract This report describes the current state of my research in software development environments. I argue in favour of strong support for project management, comprehension and navigation, and collaboration primarily based on experiences from developing large-scale industrial-strength applications. An underlying model of such an environment, named Ragnarok, is outlined. A design and first prototype of important parts of Ragnarok is described as well as some results from initial experiments. 
Abstract-found: 1
Intro-found: 1
Reference: [Andersen et al. 94] <author> Peter Andersen, Lars Bak, Sren Brandt, Jrgen L. Knudsen, Ole L. Madsen, Kim J. Mller, Claus Nrgaard, Elmer Sandvad, </author> <title> The Mjlner BETA System, </title> <editor> in [Knudsen et al. </editor> <volume> 93] </volume>
Reference-contexts: The prototypes are implemented in the BETA language [Madsen et al. 93], using the Mjlner BETA system <ref> [Andersen et al. 94] </ref>, and uses some of the design patterns described in [Gamma et al. 94]. The implementation consists of about 13.000 lines of BETA code and about 385 staff-hours went into it.
Reference: [Bendix95] <author> Lars Bendix, </author> <title> Configuration Management and Version Control Revisited, </title> <type> PhD dissertation, </type> <institution> Institute of Electronic Systems, Aalborg University, Denmark, </institution> <month> Dec. </month> <year> 1995 </year>
Reference-contexts: Though parallels between this approach and that of Bendix <ref> [Bendix95] </ref> and others can be made (see discussion in section 5.7) the motivation grew out of an analysis of the work situation of software developers and managers, more than from theoretical considerations. Generally the terminology defined by Tichy [Tichy88] will be used unless otherwise stated. <p> In RCS [Tichy82], CVS [Berliner90], the three dimensional graph model of Bendix <ref> [Bendix95] </ref> and generally approaches based on selection rules for creating configurations the problem is, that the only way to preserve the context of a component is by tagging i.e. invent tags which must be associated with every file/object used in a configuration 8 . <p> The concept of derived components (section 4.3) also supports managing the different translated components. 5.7 Related work The model outlined here resembles the three dimensional graph model proposed by Bendix <ref> [Bendix95, Chap. 6] </ref>. Bendix proposes the model in order to integrate configurations and versions: In effect setting the dependency information under version control. However in Bendix's model dependencies goes from a single version in a version group to a whole version group. <p> 17 6.4 A flexible proposal I propose the following four mechanisms should be supported: * Hierarchical access control: Access to components of the system should be controllable. * Provide a copy-modify-merge mechanism: To allow concurrent work on a single component. * Version control in workspace: This idea proposed by Bendix <ref> [Bendix95] </ref> is very valuable in order to create the flexibility a developer or sub-team needs to experiment without polluting the project global SCM structure with irrelevant versions. * Powerful constructs to support collaboration around a single component: This range from little support when developer A just uses something in B's component <p> mod ifier has entered the stage. * Explicit check-outs for modification facilitate a modification request driven approach as suggested by Tichy [Tichy88] and used intensively in for instance Aegis [Miller95]. 6.4.3 Version control in workspace Bendix proposes fully supported recursive workspaces in order to provide version control in the workspace <ref> [Bendix95, Chap. 5] </ref>. The proposal is based on identifying the current lack of support for the workspace concept, and argues that this approach allows experiments without polluting the repository with intermediate versions. <p> Also handling of the BETA environment in DEVISE could be used as laboratory. 17 Presently there has been 13 releases 18 Bendix refers to this as the shadow problem <ref> [Bendix95] </ref>. 19 If a team is only interested in the SCM aspects and only use RCM then this is of course fine. 34 * Implementing annotations.
Reference: [Berliner90] <author> Brian Berliner, CVS II: </author> <title> Parallelizing Software Development, </title> <booktitle> in Proceedings of USENIX Winter 1990, </booktitle> <address> Washington D.C. </address>
Reference-contexts: In RCS [Tichy82], CVS <ref> [Berliner90] </ref>, the three dimensional graph model of Bendix [Bendix95] and generally approaches based on selection rules for creating configurations the problem is, that the only way to preserve the context of a component is by tagging i.e. invent tags which must be associated with every file/object used in a configuration 8 <p> When done each must merge their changes into a new version (This step can not be done concurrently). CVS uses this approach <ref> [Berliner90] </ref>. Both have benefits and drawbacks. The benefit of the lock-modify-unlock mechanism it that conflicting changes are avoided, but serialised access may provide a bottle-neck in some situations. <p> A similar technique is available in CVS <ref> [Berliner90] </ref>. Concerning the underlying concepts in RCM they were very positive.
Reference: [Booch91] <author> Grady Booch, </author> <title> Object Oriented Design, </title> <publisher> The Benjamin/Cummings Publishing Company, Inc., </publisher> <year> 1991 </year>
Reference-contexts: Sometimes already fixed bugs suddenly reappeared because code was overwritten by an accidental old copy. Much time was spent diff'ing and merging when two developers had modified the same set of source files at home. 2 The design notations Booch <ref> [Booch91] </ref> and OMT [Rumbaugh et al. 91] were still in their infancy when the basic design was initiated. 5 We had no support for collaborative work and awareness on source files. <p> This would allow the developer to view and navigate in the logical application structure (the road map) and let the environment help locate actual files on the physical store. The road map would typically use a common design notation like OMT [Rumbaugh et al. 91], Booch <ref> [Booch91] </ref>, unified method [Booch et al. 95] or (company defined) variants of these. <p> A small example is depicted in figure 1. Software components as described here are inspired by class categories <ref> [Booch91, Chap. 5] </ref> and clusters [Mathiassen et al. 93, Chap. 4]and of course experience from crafting industrial applications, where creating reusable software components is vital. 4.2 Components and project tasks From a project point of view software components are also natural boundaries for defining tasks and delegating responsibilities.
Reference: [Booch et al. 95] <author> Grady Booch, James Rumbaugh, </author> <title> Unified Method for Object-Oriented Development, Documentation Set Version 0.8, Rational Software Corporation, </title> <address> Santa Clara/CA, </address> <year> 1995 </year>
Reference-contexts: This would allow the developer to view and navigate in the logical application structure (the road map) and let the environment help locate actual files on the physical store. The road map would typically use a common design notation like OMT [Rumbaugh et al. 91], Booch [Booch91], unified method <ref> [Booch et al. 95] </ref> or (company defined) variants of these. <p> One of the items listed in section 3 was the wish for a road map showing the relations between components in the application. The Ragnarok prototype provides a (very) limited set of drawing primitives to allow unified method class diagram <ref> [Booch et al. 95] </ref> notation to be drawn in the abstraction layers. This way the abstraction layers not only can depict the parent-child relation, but also associations, inheritance, roles, multiplicity, comments, etc., between components.
Reference: [Burkle et al. 95] <author> Ute Burkle, Guido Gryczan, Heinz Zullighoven, </author> <title> Object-Oriented System Development in a Banking Project: Methodology, </title> <journal> Experience, and Conclusions, Human-Computer Interaction, </journal> <volume> Vol. 10, </volume> <pages> pp. 293-336, </pages> <year> 1995 </year>
Reference-contexts: It should be studied if e.g. a tools and materials metaphor <ref> [Burkle et al. 95] </ref> could be used to structure the user interaction in a comprehensible and intuitive way. * Integration with tools in the language-near end of the activity spectrum, compilers, debuggers, editors, etc., is vital for acceptance by developers. * Presently Ragnarok relies on two-dimensional planes as physical space and
Reference: [Cagan95] <author> Martin Cagan, </author> <title> Untangling Configuration Management, </title> <booktitle> in [Estublier95] </booktitle>
Reference-contexts: Clearly this is a way to give developers flexibility and freedom while maintaining the overview and control aspect important seen from the management perspective. Cagan terms the versions in workspace micro-version in contrast to the global macro-versions in <ref> [Cagan95] </ref>.
Reference: [Christensen95] <author> Henrik B. Christensen, </author> <title> A Retrospective Case Study: SAVOS, Internal work note, </title> <booktitle> Obtainable from the author. </booktitle>
Reference-contexts: Thus the problems were not tied to the often reported discrepancy between user expectations and developers understanding of the domain. Below a short list of problems is given. A more detailed description can be found in <ref> [Christensen95] </ref>. Problems concerning management Though a work break down had been made, based on initial design, which defined basic milestones the plans were never the less quickly abandoned. This was caused by a number of reasons: * The project manager was involved in software development because of lack of resources.
Reference: [Dowson87] <author> Mark Dowson, </author> <title> Integrated Project Support with IStar, </title> <journal> IEEE Software Nov 1987, </journal> <volume> p. </volume> <pages> 6-15 </pages>
Reference-contexts: This is important for project management and used intensively in the user interface to provide overview. It fits with what is considered good programming practise, the idea of programming by contract [Meyer88] and incremental development [Goldberg et al. 95]. The contractual approach used in IStar <ref> [Dowson87] </ref> resembles the outlined approach. However IStar formalises the interfaces between the components in their hierarchy which can only be changed by renegotiating the contract between the components. 5 Context-Preserving Software Configuration Management This section outlines an approach to software configuration management denoted context-preserving software configuration management.
Reference: [Estublier95] <author> J. Estublier (Ed.), </author> <title> Software Configuration Management, </title> <editor> ICSE SCM-4 and SCM5 Workshops, </editor> <booktitle> Selected Papers, Lecture Notes in Computer Science 1005, </booktitle> <publisher> Springer Verlag 1995 </publisher>
Reference: [Floyd84] <author> C. Floyd, </author> <title> A Systematic Look of Prototyping, </title> <editor> in R. Budde, K. Kuhlenkamp, L. Mathiassen, H. Zullighoven, (Eds.), </editor> <title> Approaches to Prototyping, </title> <publisher> Berlin: Springer-Verlag, </publisher> <year> 1984 </year>
Reference-contexts: In order to test some of the fundamental ideas a rough prototype of Ragnarok was made. The proto type is a vertical prototype <ref> [Floyd84] </ref> with main emphasis on two basic properties: * The basic context-preserving software configuration management model (section 4 and 5). * The use of a spatial metaphor combined with maps for navigation in a project structure (section 7).
Reference: [Freja95] <author> Freja, </author> <title> An Object-Oriented CASE Tool, </title> <institution> MIA 93-24(1.0), Mjlner Informatics Report, </institution> <year> 1995 </year>
Reference-contexts: One could also envisage language support. The ability to draw class diagrams suggests code generation abilities, dependencies could be inferred from the source code itself, etc. However the DEVISE project already has state-of-the-art tools for these aspect, <ref> [Freja95] </ref> and [Sif94], and my interests are more towards the overall aspects of management, project support, and user interface issues.
Reference: [Furnas86] <author> George W. Furnas, </author> <title> Generalized Fisheye Views, </title> <editor> in [Mantei et al. </editor> <volume> 86] </volume>
Reference-contexts: This empowers us to get an overview of relationsin essence giving a topography of the applicationotherwise difficult to infer from textual output. One should also mention the idea of fish-eye views <ref> [Furnas86] </ref> where e.g. the mouse pointer defines the part of the application structure that is interesting (the focus) and therefore shown in great detail while 27 remote regions are shown in successively less detail.
Reference: [Gamma et al. 94] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: </title> <booktitle> Elements of Reuseable Object-Oriented Software, </booktitle> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1994 </year>
Reference-contexts: The prototypes are implemented in the BETA language [Madsen et al. 93], using the Mjlner BETA system [Andersen et al. 94], and uses some of the design patterns described in <ref> [Gamma et al. 94] </ref>. The implementation consists of about 13.000 lines of BETA code and about 385 staff-hours went into it. <p> Most classes should be identifiable from the discussion in section 7. The ControlMap is an abstraction of a Map that is mostly introduced as a way to break dependency between Map and VisualLandmark: Map knows VisualLandmark but VisualLandmark only knows ControlMap. The observer pattern of Gamma et al. <ref> [Gamma et al. 94] </ref> is used to keep maps synchronised when several are displaying the same underlying landmark.
Reference: [Goldberg et al. 95] <author> Adele Goldberg, Kenneth S. Rubin, </author> <title> Succeeding with Objects, Decision Frameworks for Project Management, </title> <publisher> Addison-Wesley 1995 </publisher>
Reference-contexts: This way there is never a useless and out-dated work-break-down structurebecause any change in the application structure is a change in the work-break-down structure as well. Goldberg gives an example list of task related management attributes which could be used as a template <ref> [Goldberg et al. 95, Chap. 7] </ref>. There are other obvious candidates to associate with components: Modification requests [Tichy88]/bug reports, hyper-links (in)to other material like schedules (PERT/Gantt charts [Mikkelsen et al. 89]), requirements specifications (for tracking requirements through the life-cycle), documentation, etc. <p> This is important for project management and used intensively in the user interface to provide overview. It fits with what is considered good programming practise, the idea of programming by contract [Meyer88] and incremental development <ref> [Goldberg et al. 95] </ref>. The contractual approach used in IStar [Dowson87] resembles the outlined approach. <p> A more pragmatic aspect is traceability. Traceability of customer releases is extremely important, but also to provide historical data on process metrics, as Goldberg points out <ref> [Goldberg et al. 95, Chap. 6] </ref>. Context-preserving SCM ensures that the context of i.e. management data is not lost which could render the data useless. 5.2 Context Let us return to the workspace of a developer. <p> As outlined in section 3 I find collaborative issues extremely important. I see software configuration management as a potential candidate for mediating collaboration and collaborative awareness. 6.1 Basic problems There are many ways to delegate responsibilities in a software project, some of them are described in <ref> [Goldberg et al. 95, Chap. 12] </ref>. In most of the team models mentioned there are tasks that are not the sole responsibility of a single person. This may of course also be dictated by the education and background of the team members and the concrete project.
Reference: [Gustavsson90] <author> Anders Gustavsson, </author> <title> Software Configuration Management in an Integrated Environment, </title> <institution> Dept. of Comp. Science, Lund University, </institution> <type> Thesis, </type> <year> 1990 </year>
Reference-contexts: This means that preserving context must be handled by the selection mechanism. As already mentioned in section 5.1 I think this leads back into the unfortunate use of tags. Explicit configuration objects are used for instance in DSEE [Leblang et al. 87] and Mjlner ORM <ref> [Gustavsson90] </ref>. Tichy emphasise that a software object can be a configuration as well and uses it in his AND/OR graph [Tichy88]. <p> Aspects are for instance version control aspect (show current version number and list of files of componentsor maybe a graphical representation of the version graph like in Orm <ref> [Gustavsson90] </ref>), comprehension aspect (show class diagram notation), management aspect (project status summaries), quality assurance aspect (checklists with items marked as unchecked/checked), etc. 7.2.2 Overview map Lots of maps displaying different areas of the underlying abstraction layers do not in itself create overview (more likely the contrary).
Reference: [Harel88] <author> David Harel, </author> <title> On Visual Formalisms, </title> <journal> Communications of the ACM, </journal> <volume> Vol. 31, </volume> <month> May </month> <year> 1988 </year>
Reference-contexts: use of the prototype suggests that the additional graphics (class diagram notation) provides adequate visual clues for small systems. 7.2 Map visual formalism Harel advocates the use of visual formalisms by which (mathematical) problems can be understood and solved by visual means taking advantage of humans highly developed visual system <ref> [Harel88] </ref>.
Reference: [Hedin et al. 94] <author> Gorel Hedin, Boris Magnusson, </author> <title> Direct interaction in the Orm programming environment, </title> <editor> in [Knudsen et al. </editor> <volume> 93] </volume>
Reference-contexts: More abstract manipulations on objects are performed by context-sensitive menus that appear when a mouse button is pressed above an object. The Mjlner Orm system has an object-oriented approach to window systems resembling the Self approach <ref> [Hedin et al. 94] </ref>, using context-sensitive menus. <p> And my own experience is that the large scale structure of an application is more stable than at the class level and especially in larger projects there is a substantial inertia because restructuring is costly. The hierarchical window system of Mjlner Orm <ref> [Magnusson94, Hedin et al. 94] </ref> bears some resemblance to Ragnarok especially in the use of visual nesting. However whereas Orm insists on displaying the context leaving little room for deeply nested views, Ragnarok provides infinite zooming in.
Reference: [Herbsleb et al. 95] <author> James D. Herbsleb, Helen Klein, Gary M. Olson, Hans Brunner, Judith S. Olson, Joe Harding, </author> <title> Object-Oriented Analysis and Design in Software Project Teams, </title> <journal> Human-Computer Interaction, </journal> <volume> Vol. 10, </volume> <pages> pp. 249-292, </pages> <year> 1995 </year>
Reference-contexts: The system consisted of hardware and four special purpose software applications running on IBM compatible PC's in a local area network. I was chief architect, in the sense of Herb-sleb <ref> [Herbsleb et al. 95] </ref>, as well as implemented large parts of two of these applications (both running MicroSoft Windows). The total software side of the product family accounted for about 11.500 staff-hours with project team sizes ranging from 3-7 members. <p> A strong underlying SCM model will also have great value with respect to project management as it provides traceability of development effort (meaning better control) as well as release control. My emphasis on collaboration as an important issue in development environments is supported in <ref> [Herbsleb et al. 95] </ref> where it is stated that The lack of tools to support annotating, keeping abreast of changes, bringing novices up to speedand collaborative use in generalis a serious drawback. 3.3 Discussion Based upon the discussion above I see the following as cornerstones for a software project development environment: <p> An informal definition of a software component is: A part of a software system that is perceived as a logical whole by the team members. Software components are often conceived by a single or a few chief architects <ref> [Herbsleb et al. 95] </ref> and introduced to a broader team of developers and implementors after the initial analysis and design phases.
Reference: [Jacobson et al. 92] <author> Ivar Jacobson, Magnus Christerson, Patrik Jonsson, Gunnar Overgaard, </author> <title> Object-Oriented Software Engineering a Use Case Driven Approach, </title> <publisher> Addison-Wesley 1992 </publisher>
Reference-contexts: Process metrics, in the form of logging and categorising staff hours, were collected for all projects. However as Jacobson notes <ref> [Jacobson et al. 92] </ref>: Actually the real problem with metrics is that they are not used.
Reference: [Joachim96] <author> Joachim Sauter, Terra-Vision, </author> <note> privat comm., project description on WWW: http://www.artcom.de:80/Welcome </note>
Reference-contexts: This approach has the advantage that components that are very alike but belong to different subsystems can still be distinguished easily 14 . The Terra-Vision project at Art+Com in Berlin <ref> [Joachim96] </ref> which uses detailed, zoom-able, satellite images of earth to convey a physical navigation sensation when browsing the World-Wide-Web, can be used as inspiration. The background must of course use very pale colours in order not to disturb other more important information.
Reference: [Jones et al. 86] <author> William P. Jones, Susan T. Dumais, </author> <title> The Spatial Metaphor for User Interfaces: Experimental Tests of References by Location versus Name, </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> Vol 4, No. 1, </volume> <month> Jan </month> <year> 1986 </year> <month> 37 </month>
Reference-contexts: However whereas Orm insists on displaying the context leaving little room for deeply nested views, Ragnarok provides infinite zooming in. An interesting article by Jones et al. questions the usability of a spatial metaphor <ref> [Jones et al. 86] </ref>. In three experiments with persons classifying newspaper articles using names or locations they get strong indications that as the number of items is increased names are more easily remembered than locations.
Reference: [Knudsen et al. 93] <author> J. Lindskov Knudsen, M. L ofgren, O. Lehrmann Madsen, B. Magnusson, </author> <title> Object--Oriented environments The Mjlner Approach, </title> <publisher> Prentice-Hall 1993 </publisher>
Reference: [Leblang et al. 87] <author> David B. Leblang, Robert P. Chase Jr., </author> <title> Parallel Software Configuration Management in a Network Environment, </title> <journal> IEEE Software, </journal> <month> Nov. </month> <year> 1987, </year> <pages> p. 28-35 </pages>
Reference-contexts: This means that preserving context must be handled by the selection mechanism. As already mentioned in section 5.1 I think this leads back into the unfortunate use of tags. Explicit configuration objects are used for instance in DSEE <ref> [Leblang et al. 87] </ref> and Mjlner ORM [Gustavsson90]. Tichy emphasise that a software object can be a configuration as well and uses it in his AND/OR graph [Tichy88].
Reference: [Lidskjalv95] <author> Lidskjalv: </author> <title> User Interface Framework, </title> <institution> MIA 94-27(1.1), Mjlner Informatics Report, </institution> <year> 1995 </year>
Reference-contexts: The reason that class Landmark not is a subclass of SourceComponent is that it may be beneficial to be able to create landmarks but defer the creation of the actual source component, typically in a design situation. 8.4 Visualisation The visualisation part of Ragnarok is build on top of Lidskjalv <ref> [Lidskjalv95] </ref>, a platform independent object-oriented user interface construction framework for the Mjlner BETA System. Most classes should be identifiable from the discussion in section 7.
Reference: [Nardi et al. 93] <author> Bonnie A. Nardi, Craig L. Zarmer, </author> <title> Beyond Models and Metaphors: Visual Formalisms in User Interface Design, </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> Vol. 4, No. 1, </volume> <month> March </month> <year> 1993 </year>
Reference-contexts: Nardi et al. argues in favour of using visual formalisms, like plots, panels, maps, outlines, and tables <ref> [Nardi et al. 93] </ref>. Referring to the work of Reisenberg [Reisberg87] on perceptual knowledge, that is, knowledge that can be accessed only through interaction with external representations, they conclude that: In short, we have access to certain kinds of knowledge only when we see it. 15 .
Reference: [Nrmark89] <author> Kurt Nrmark, </author> <title> Programming Environments Concepts, Architectures and Tools, </title> <institution> R-89-5, IES, Aalborg University, </institution> <month> April </month> <year> 1989 </year>
Reference-contexts: Thus the term software project development environment is meant to stress the focus on project support in a software development environment and not as defining a new category of environments. Rag-narok could be classified as a programming environment <ref> [Nrmark89] </ref> or an integrated project support environment/software engineering environment [Sommerville89]. This progress report is divided in the following manner: Section 2 describes my interest in the subject as well as outlines some experiences gained in my previous job as system designer and implementor. <p> rather costly because it took weeks before we again were proficient in locating things in the new structure. 4 Though it was not necessarily the same 80% that was shared. 6 Nrmark argues in favour of raising the tool abstraction level i.e. let environment tools take over more routine work <ref> [Nrmark89] </ref>.
Reference: [Madsen et al. 93] <author> Ole Lehrmann Madsen, Birger Mller-Pedersen, Kristen Nygaard, </author> <title> Object-Oriented Programming in the Beta Programming Language, </title> <publisher> Addison Wesley, </publisher> <year> 1993 </year>
Reference-contexts: As described in section 9 I got the idea during the initial design phase to actually create two prototypes: A stand-alone command-line tool containing the context-preserving SCM model only, and a graphical prototype with more emphasis on the user interface. The prototypes are implemented in the BETA language <ref> [Madsen et al. 93] </ref>, using the Mjlner BETA system [Andersen et al. 94], and uses some of the design patterns described in [Gamma et al. 94]. The implementation consists of about 13.000 lines of BETA code and about 385 staff-hours went into it.
Reference: [Madsen94] <author> Ole Lehrmann Madsen, </author> <title> The Mjlner BETA fragment system, </title> <editor> in [Knudsen et al. </editor> <volume> 93]. </volume>
Reference-contexts: However this is not always possible for instance two interdependent classes cannot be defined in separate files in the Mjlner BETA fragment system <ref> [Madsen94] </ref>. This is of course unfortunate but can be handled in a pragmatic way, for instance by having a single interface file for the two classes in their common parent component.
Reference: [Magnusson94] <author> Boris Magnusson, </author> <title> The Mjlner Orm System, </title> <editor> in [Knudsen et al. </editor> <volume> 93] </volume>
Reference-contexts: A final, pragmatic, but nevertheless import, point I want to make: An act of navigation should not create lots of individual visual elements. Many systems like for instance Mjlner ORM <ref> [Magnusson94] </ref>, Self 4.0 [Maloney95, Smith et al. 95], many commercial CASE tools (Select OMT, Rational Rose, Cadre ObjectTeam, and others), and many applications using window based desktop systems like MicroSoft Windows, X11, etc., produce large amounts of new windows/object when searching for a specific item (intermediate steps in the navigation). <p> And my own experience is that the large scale structure of an application is more stable than at the class level and especially in larger projects there is a substantial inertia because restructuring is costly. The hierarchical window system of Mjlner Orm <ref> [Magnusson94, Hedin et al. 94] </ref> bears some resemblance to Ragnarok especially in the use of visual nesting. However whereas Orm insists on displaying the context leaving little room for deeply nested views, Ragnarok provides infinite zooming in.
Reference: [Malhotra94] <author> Jawahar Malhotra, </author> <title> Tailorable Systems: Design, Support, Techniques, and Applications, </title> <type> Ph.D. Thesis, </type> <institution> DAIMI PB-466, Aarhus University, </institution> <year> 1994 </year>
Reference-contexts: Thus providing extensibility is important. Inspiration can be found in the work on Emacs [Stallman84] and of Malhotra <ref> [Malhotra94] </ref>. * The landmarks in Ragnarok must cope with a potentially very large set of operations depending on aspects, annotations, etc., which may end in serious problems concerning overview and consistency.
Reference: [Mantei et al. 86] <author> Marilyn Mantei, Peter Orbeton, </author> <booktitle> CHI'86 Human Factors in Computing Systems: Proceedings from a Conference, ACM, </booktitle> <address> New York, </address> <year> 1986 </year>
Reference: [Maloney95] <author> John Maloney, Morphic: </author> <title> The Self User Interface Framework, </title> <publisher> Sun Microsystem Inc, </publisher> <year> 1995 </year>
Reference-contexts: A final, pragmatic, but nevertheless import, point I want to make: An act of navigation should not create lots of individual visual elements. Many systems like for instance Mjlner ORM [Magnusson94], Self 4.0 <ref> [Maloney95, Smith et al. 95] </ref>, many commercial CASE tools (Select OMT, Rational Rose, Cadre ObjectTeam, and others), and many applications using window based desktop systems like MicroSoft Windows, X11, etc., produce large amounts of new windows/object when searching for a specific item (intermediate steps in the navigation). <p> In Ragnarok you simply click the aforementioned circle on the map outline, which is faster and a more direct method. The radar-view of the Self 4.0 programming environment <ref> [Smith et al. 95, Maloney95] </ref> achieves some of the same goals of relating the windows position with respect to the whole and allows movement in the plane. 7.3.2 Avoiding cluttering As mentioned in section 3 a design goal has been to avoid intermediate steps in navigations in the form of spawning <p> The basic idea is to provide visual artifacts that react on user manipulations through devices like keyboard, mouse, joystick, etc., in a sensible way. The Self-4.0 programming environment <ref> [Smith et al. 95, Maloney95] </ref> for the Self prototypical object oriented language [Ungar et al. 95] is based on concreteness and has taken the idea of direct manipulation far. In this environment prototypical objects are moved and manipulated in a very direct way.
Reference: [Mathiassen et al. 93] <author> Lars Mathiassen, A. Munk-Madsen, P. A. Nielsen, J. Stage, Objektorienteret Analyse, Forlaget Marko, </author> <year> 1993 </year>
Reference-contexts: A small example is depicted in figure 1. Software components as described here are inspired by class categories [Booch91, Chap. 5] and clusters <ref> [Mathiassen et al. 93, Chap. 4] </ref>and of course experience from crafting industrial applications, where creating reusable software components is vital. 4.2 Components and project tasks From a project point of view software components are also natural boundaries for defining tasks and delegating responsibilities.
Reference: [McKnight et al. 91] <author> Cliff McKnight, Andrew Dillon, John Richardson, </author> <title> Hypertext in Context, </title> <publisher> Camp-bridge University Press, </publisher> <year> 1991 </year>
Reference-contexts: Still the route chosen may be non-optimal. The third stage is the acquisition of survey knowledge which is the fully developed cognitive map Tolman speaks about. Here we can plan journeys precisely and describe the position of locations within the environment. The overview presented here is due to <ref> [McKnight et al. 91] </ref>.
Reference: [Meier91] <author> Sid Meier, Civilization User Manual, MicroProse, </author> <year> 1991 </year>
Reference-contexts: One way to retain overview is to create a special map whose main purpose is to display the location of other maps. This is an approach often used in computer strategy games like for instance Civilization <ref> [Meier91] </ref>. Ragnarok has an overview map denoted the world map as it defines the world that the developer is working within; other maps are denoted detail maps. The areas that are displayed by detail maps are shown by outlines in the world map.
Reference: [Meyer88] <author> Bertrand Meyer, </author> <title> Object-oriented Sofware Construction, </title> <publisher> Prentice Hall International Series in Computer Science, </publisher> <year> 1988 </year>
Reference-contexts: One of the main aspects of industrial development is in my opinion stated by Bertrand Meyer: ... once everything has been said, software is defined by code. <ref> [Meyer88, p. 30] </ref>. It is a high quality application that pays the bills; not nice OMT diagrams, detailed milestone reports, nor reusable class libraries. <p> This is important for project management and used intensively in the user interface to provide overview. It fits with what is considered good programming practise, the idea of programming by contract <ref> [Meyer88] </ref> and incremental development [Goldberg et al. 95]. The contractual approach used in IStar [Dowson87] resembles the outlined approach.
Reference: [Miller95] <author> Peter Miller, Aegis, </author> <title> A Project Change Supervisor, User Guide, </title> <note> version 2.3, 1995, part of the Aegis distrubution, obtainable through various ftp-sites. </note>
Reference-contexts: can be told if other developers already are modifying the component, and these other developers may be notified that a new mod ifier has entered the stage. * Explicit check-outs for modification facilitate a modification request driven approach as suggested by Tichy [Tichy88] and used intensively in for instance Aegis <ref> [Miller95] </ref>. 6.4.3 Version control in workspace Bendix proposes fully supported recursive workspaces in order to provide version control in the workspace [Bendix95, Chap. 5].
Reference: [Patton80] <author> Michael Quinn Patton, </author> <title> Qualitative Evaluation Methods, </title> <publisher> Sage Publications, </publisher> <address> Bev-erly Hills, Calif., </address> <year> 1980 </year>
Reference-contexts: Both groups are involved with real development projects. The descriptions below are based on one hour open-ended interviews using a mixture of the standardised open-ended interview and the general interview guide approach <ref> [Patton80] </ref>. 9.1 ISA team The ISA team project, named LabSys, is a system for controlling accelerators, storage rings, and other large distributed equipment in experimental physics. The team consists of five people, three in Aarhus and two in Stockholm.
Reference: [Mikkelsen et al. 89] <author> Hans Mikkelsen, Jens O. Riis, </author> <note> Grundbog i Projektledelse, 3. udgave, 2. oplag, Forlaget PROMET Aps, </note> <year> 1989 </year>
Reference-contexts: Goldberg gives an example list of task related management attributes which could be used as a template [Goldberg et al. 95, Chap. 7]. There are other obvious candidates to associate with components: Modification requests [Tichy88]/bug reports, hyper-links (in)to other material like schedules (PERT/Gantt charts <ref> [Mikkelsen et al. 89] </ref>), requirements specifications (for tracking requirements through the life-cycle), documentation, etc.
Reference: [Minor et al. 93] <author> Sten Minor, Boris Magnusson, </author> <title> A mode for Semi-(a)Synchronous Collaborative Editing, </title> <booktitle> Proceedings of Third European Conference on Computer Supported Cooperative Work - ECSCW'93, </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993 </year>
Reference-contexts: The synchronisation scenario in figure 6 could alternatively be realised by developer A and B sharing a common, but local, component storage where the synchronisation could be made. 6.6 Discussion Magnusson et al. propose fine-grained version control to mediate collaborative awareness using a technique called active diffs <ref> [Minor et al. 93, Olsson94] </ref>. The underlying idea is to use visual clues that display the concurrent work of others on the same document. The model outlined here can also provide awareness through version control when combined with the visual mechanisms described in the next section.
Reference: [Prasuan et al. 93] <author> Prasuan Dewan, John Riedl, </author> <title> Towards Computer-Supported Concurrent Software Engineering, </title> <booktitle> IEEE Computer, </booktitle> <month> Jan. </month> <year> 1993 </year>
Reference-contexts: When B submits a new version to the project component storage all developers depending on this is notified. Then they may include the new version in their local work. The third case is an active area of research with many interesting contributions, see for example <ref> [Olsson94, Prasuan et al. 93, Smith et al. 95] </ref>. The general approach is to work on a shared representation so you can see all modifications on-line often combined with some tele conferencing abilities allowing you to talk together. Presently no support for this case is envisaged in Ragnarok. <p> The model outlined here can also provide awareness through version control when combined with the visual mechanisms described in the next section. Prasuan et al. outlines a collaborative software engineering environment, Flecse, with special focus on (geographical) distributed development <ref> [Prasuan et al. 93] </ref>. All shared material is stored at a single site, and a distributed RCSTool (an RCS front-end) provide concurrency control. Though it provides awareness (changes are reflected on local sites concurrently) there is no provision for version control in workspace and the lock-modify-unlock mechanism serialise access.
Reference: [Olsson94] <author> Torsten Olsson, </author> <title> Group Awareness using Fine-Grained Revision Control, </title> <booktitle> Proceedings of NWPER, </booktitle> <year> 1994 </year>
Reference-contexts: When B submits a new version to the project component storage all developers depending on this is notified. Then they may include the new version in their local work. The third case is an active area of research with many interesting contributions, see for example <ref> [Olsson94, Prasuan et al. 93, Smith et al. 95] </ref>. The general approach is to work on a shared representation so you can see all modifications on-line often combined with some tele conferencing abilities allowing you to talk together. Presently no support for this case is envisaged in Ragnarok. <p> The synchronisation scenario in figure 6 could alternatively be realised by developer A and B sharing a common, but local, component storage where the synchronisation could be made. 6.6 Discussion Magnusson et al. propose fine-grained version control to mediate collaborative awareness using a technique called active diffs <ref> [Minor et al. 93, Olsson94] </ref>. The underlying idea is to use visual clues that display the concurrent work of others on the same document. The model outlined here can also provide awareness through version control when combined with the visual mechanisms described in the next section.
Reference: [Reisberg87] <author> D. Reisberg, </author> <title> External representations and the advantages of externalizing one's thought, </title> <booktitle> in Proceedings of the Cognitive Science Society, </booktitle> <address> Seattle, Washington, </address> <pages> pp. 281-293, </pages> <year> 1987 </year>
Reference-contexts: Nardi et al. argues in favour of using visual formalisms, like plots, panels, maps, outlines, and tables [Nardi et al. 93]. Referring to the work of Reisenberg <ref> [Reisberg87] </ref> on perceptual knowledge, that is, knowledge that can be accessed only through interaction with external representations, they conclude that: In short, we have access to certain kinds of knowledge only when we see it. 15 .
Reference: [Rumbaugh et al. 91] <author> James Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, W. Lorensen, </author> <title> Object-Oriented Modeling and Design, </title> <publisher> Prentice-Hall International Editions, </publisher> <year> 1991 </year>
Reference-contexts: Sometimes already fixed bugs suddenly reappeared because code was overwritten by an accidental old copy. Much time was spent diff'ing and merging when two developers had modified the same set of source files at home. 2 The design notations Booch [Booch91] and OMT <ref> [Rumbaugh et al. 91] </ref> were still in their infancy when the basic design was initiated. 5 We had no support for collaborative work and awareness on source files. <p> This would allow the developer to view and navigate in the logical application structure (the road map) and let the environment help locate actual files on the physical store. The road map would typically use a common design notation like OMT <ref> [Rumbaugh et al. 91] </ref>, Booch [Booch91], unified method [Booch et al. 95] or (company defined) variants of these.
Reference: [SCM] <editor> J. F. H. Winkler (ed.), </editor> <booktitle> Proceedings of the International Workshop on Software Version and Configuration Control, </booktitle> <address> Grassau, West Germany, </address> <publisher> B. G. Teubner, Stuttgart, </publisher> <month> Jan </month> <year> 1988 </year> <month> 38 </month>
Reference: [Shneiderman83] <author> Ben Shneiderman, </author> <title> Direct Manipulation: A Step Beyond Programming Lan--guages, </title> <booktitle> IEEE Computer, </booktitle> <month> August </month> <year> 1993 </year>
Reference-contexts: This way a spatial interpretation of hyperlinks is provided hopefully aiding in maintaining the sense of direction. 7.4 Direct manipulation Shneiderman introduced the term direct manipulation in his often cited paper <ref> [Shneiderman83] </ref>. The basic idea is to provide visual artifacts that react on user manipulations through devices like keyboard, mouse, joystick, etc., in a sensible way.
Reference: [Sif94] <editor> Sif / A Hyper Structure Editor / Tutorial and Reference Manual, </editor> <title> MIA 90-11(1.2), </title> <type> Technical Report, </type> <institution> Mjlner Informatics, </institution> <year> 1994 </year>
Reference-contexts: It could be interesting to investigate this technique as well. 7.3.5 Spatial interpretation of hyper-links Powerful editors and browsers of today often also contain cross-referencing abilities like e.g. the Mjlner BETA structure editor Sif <ref> [Sif94] </ref>. Sif can follow semantic links from the application of a name to the declaration. Though useful it has a backside, namely the already mentioned getting-lost-in-hyperspace phenomenon. <p> One could also envisage language support. The ability to draw class diagrams suggests code generation abilities, dependencies could be inferred from the source code itself, etc. However the DEVISE project already has state-of-the-art tools for these aspect, [Freja95] and <ref> [Sif94] </ref>, and my interests are more towards the overall aspects of management, project support, and user interface issues.
Reference: [Smith et al. 95] <author> Randall B. Smith, John Maloney, David Ungar, </author> <title> The Self-4.0 User Interface: Manifesting a System-wide Vision of Concreteness, Uniformity, and Flexibility, Conference Proceedings, </title> <journal> OOPSLA'95, ACM SIGPLAN Notices, </journal> <volume> Vol. 30, No. </volume> <pages> 10 </pages>
Reference-contexts: A final, pragmatic, but nevertheless import, point I want to make: An act of navigation should not create lots of individual visual elements. Many systems like for instance Mjlner ORM [Magnusson94], Self 4.0 <ref> [Maloney95, Smith et al. 95] </ref>, many commercial CASE tools (Select OMT, Rational Rose, Cadre ObjectTeam, and others), and many applications using window based desktop systems like MicroSoft Windows, X11, etc., produce large amounts of new windows/object when searching for a specific item (intermediate steps in the navigation). <p> When B submits a new version to the project component storage all developers depending on this is notified. Then they may include the new version in their local work. The third case is an active area of research with many interesting contributions, see for example <ref> [Olsson94, Prasuan et al. 93, Smith et al. 95] </ref>. The general approach is to work on a shared representation so you can see all modifications on-line often combined with some tele conferencing abilities allowing you to talk together. Presently no support for this case is envisaged in Ragnarok. <p> In Ragnarok you simply click the aforementioned circle on the map outline, which is faster and a more direct method. The radar-view of the Self 4.0 programming environment <ref> [Smith et al. 95, Maloney95] </ref> achieves some of the same goals of relating the windows position with respect to the whole and allows movement in the plane. 7.3.2 Avoiding cluttering As mentioned in section 3 a design goal has been to avoid intermediate steps in navigations in the form of spawning <p> The basic idea is to provide visual artifacts that react on user manipulations through devices like keyboard, mouse, joystick, etc., in a sensible way. The Self-4.0 programming environment <ref> [Smith et al. 95, Maloney95] </ref> for the Self prototypical object oriented language [Ungar et al. 95] is based on concreteness and has taken the idea of direct manipulation far. In this environment prototypical objects are moved and manipulated in a very direct way.
Reference: [Sommerville89] <author> Ian Sommerville, </author> <title> Software Engineering, (3rd edition), </title> <publisher> Addison Wesley, </publisher> <year> 1989 </year>
Reference-contexts: Thus the term software project development environment is meant to stress the focus on project support in a software development environment and not as defining a new category of environments. Rag-narok could be classified as a programming environment [Nrmark89] or an integrated project support environment/software engineering environment <ref> [Sommerville89] </ref>. This progress report is divided in the following manner: Section 2 describes my interest in the subject as well as outlines some experiences gained in my previous job as system designer and implementor. These experiences are summarised in some contours of a system in section 3.
Reference: [Stallman84] <author> Richard M. Stallman, </author> <title> EMACS: The Extensible, Customizable, Self-Documenting Display Editor, in Interactive Programming Environments by D. </title> <editor> R. Barstow, H. E. Shrobe & E. Sandewall, </editor> <year> 1984 </year>
Reference-contexts: Thus providing extensibility is important. Inspiration can be found in the work on Emacs <ref> [Stallman84] </ref> and of Malhotra [Malhotra94]. * The landmarks in Ragnarok must cope with a potentially very large set of operations depending on aspects, annotations, etc., which may end in serious problems concerning overview and consistency.
Reference: [Tichy82] <author> Walter F. Tichy, </author> <title> Design, Implementation, and Evaluation of a Revision Control System, </title> <booktitle> 6th Conference on Software Engineering, </booktitle> <address> Tokyo, Japan, </address> <year> 1982 </year>
Reference-contexts: In RCS <ref> [Tichy82] </ref>, CVS [Berliner90], the three dimensional graph model of Bendix [Bendix95] and generally approaches based on selection rules for creating configurations the problem is, that the only way to preserve the context of a component is by tagging i.e. invent tags which must be associated with every file/object used in a <p> As long as a person holds the lock no one else can change the object. This mechanism serialises all access to an object. A well known tool using this scheme is RCS <ref> [Tichy82] </ref>. * Copy-modify-merge: In this approach several persons are allowed to modify an object concurrently but they all operate on a copy. When done each must merge their changes into a new version (This step can not be done concurrently). CVS uses this approach [Berliner90]. Both have benefits and drawbacks. <p> Each layer knows only the layers below itself and extends the functionality. Below they are described from the simplest layer and up. 8.2 Component Model Component Model is a class category which provides the context-preserving SCM model. Basically it is a front end to RCS <ref> [Tichy82] </ref>; it maintains information about components and their dependencies in flat text files, one for each component, and controls actual source files by calling the RCS ci and co tools and parses their output. <p> The component structure mimics the design architecture. The full LabSys project is estimated to about five man-years with about two man-years worth of work made so far. Before RCM was introduced they had version control using RCS <ref> [Tichy82] </ref> combined with scripts. Now RCM has been adopted as their SCM solution.
Reference: [Tichy88] <author> Walter F. Tichy, </author> <title> Tools for Software Configuration Management, </title> <booktitle> in [SCM] </booktitle>
Reference-contexts: This structure is of course not static, new components may be created and others deleted during the life-cycle. 4.3 Source- and derived components As Tichy <ref> [Tichy88] </ref> distinguishes between source- and derived objects as manually versus automatically generated objects, I distinguish between source components and derived components using the same criteria. Typically files associated with a source component are processed by a compiler, linker, etc. to produce a series of object files or perhaps a library. <p> Though parallels between this approach and that of Bendix [Bendix95] and others can be made (see discussion in section 5.7) the motivation grew out of an analysis of the work situation of software developers and managers, more than from theoretical considerations. Generally the terminology defined by Tichy <ref> [Tichy88] </ref> will be used unless otherwise stated. This includes using the Dewey notation for version identification throughout all examples and figures. The approach is based on two things. <p> A source component version group is a set of source-components-in-the-storage connected by the relations revision-of and variant-of 7 as defined in <ref> [Tichy88] </ref>. This will allow the team to speak in terms of I have fixed the bugs you reported in version X of the graphics component or I've added extra functionality in version X of the meteorological domain knowledge component. <p> Explicit configuration objects are used for instance in DSEE [Leblang et al. 87] and Mjlner ORM [Gustavsson90]. Tichy emphasise that a software object can be a configuration as well and uses it in his AND/OR graph <ref> [Tichy88] </ref>. <p> valuable information to provide collaborative awareness: The requester can be told if other developers already are modifying the component, and these other developers may be notified that a new mod ifier has entered the stage. * Explicit check-outs for modification facilitate a modification request driven approach as suggested by Tichy <ref> [Tichy88] </ref> and used intensively in for instance Aegis [Miller95]. 6.4.3 Version control in workspace Bendix proposes fully supported recursive workspaces in order to provide version control in the workspace [Bendix95, Chap. 5].
Reference: [Ungar et al. 95] <author> David Ungar, Randy B. Smith, </author> <title> SELF: The Power of Simplicity, </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 4, 3, </volume> <year> 1991 </year>
Reference-contexts: The basic idea is to provide visual artifacts that react on user manipulations through devices like keyboard, mouse, joystick, etc., in a sensible way. The Self-4.0 programming environment [Smith et al. 95, Maloney95] for the Self prototypical object oriented language <ref> [Ungar et al. 95] </ref> is based on concreteness and has taken the idea of direct manipulation far. In this environment prototypical objects are moved and manipulated in a very direct way.
Reference: [Vessey et al. 95] <author> Iris Vessey, Ajay P. Sravanapudi, </author> <title> CASE Tools as Collaborative Support Technologies, </title> <journal> Communications of the ACM, </journal> <note> January 1995/Vol. 38, No. 1, p. 83 </note>
Reference-contexts: A hierarchical system akin to UNIX with rights for global, group, and individual access to read, modify, create variants, and so on could be envisaged. Access control also provides some security against deliberate malicious acts <ref> [Vessey et al. 95] </ref>. 6.4.2 Copy-modify-merge mechanism Concurrent work on the same component should be allowed 12 . Before a new version can be entered into a version group all conflicting modifications must be (manually) solved.
Reference: [Winkler et al. 88] <author> J urgen F. H. Winkler, Clemens Stoffel, </author> <note> Program-Variants-in-the-Small in [SCM] 39 </note>
Reference-contexts: has merged B's effort into his own and may create a new ComPack version without creating branches. 10 The RCM tool described in section 8.2.1 will warn in such a situation and allows the user to cancel the operation. 15 5.6 Variants Winkler introduced the terms program-variants-in-the-small and program-variants-in-the-large in <ref> [Winkler et al. 88] </ref>. Using branches in the version groups of components supports the notion of program-variants-in-the-large. However it is often program-variants-in-the-small that is most useful in praxis because variations often occurs at the statement level, not at the component level.
References-found: 56

