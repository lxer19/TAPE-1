URL: http://www.cs.brown.edu/courses/cs227/papers/b4/cm-nested.ps
Refering-URL: http://www.cs.brown.edu/courses/cs227/readinglist.html
Root-URL: http://www.cs.brown.edu/
Email: Sophie.Cluet@inria.fr moer @ira.uka.de  
Title: Nested Queries in Object Bases  
Author: Sophie Cluet Guido Moerkotte 
Address: BP 105 Universitat Karlsruhe Domaine de Voluceau Am Fasanengarten 5 78153 Le Chesnay Cedex D-7500 Karlsruhe France Germany  
Affiliation: INRIA Fakultat fur Informatik  
Abstract: Many declarative query languages for object-oriented databases allow nested subqueries. This paper contains the first (to our knowledge) proposal to optimize them. A two-phase approach is used to optimize nested queries in the object-oriented context. The first phase|called dependency-based optimization|transforms queries at the query language level in order to treat common subexpressions and independent subqueries more efficiently. The transformed queries are translated to nested algebraic expressions. These entail nested loop evaluation which may be very inefficient. Hence, the second phase unnests nested algebraic expressions to allow for more efficient evaluation.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. M. Astrahan and D. D. Chamberlin. </author> <title> Implementation of a structured English query language. </title> <journal> Communications of the ACM, </journal> <volume> 18(10) </volume> <pages> 580-588, </pages> <year> 1975. </year>
Reference-contexts: On the other hand, we introduce novel techniques more directly related to the oo perspective. The optimization of nested queries in the oo context should clearly use the vast body of knowledge on optimizing nested relational queries. Departing from the evaluation of 1 nested SQL queries through nested loops <ref> [1] </ref>, Kim proposed unnesting of SQL queries at the SQL level [16]. The main motivation was a demonstrated substantial gain in efficiency due to unnesting. In order to eliminate some bugs which where subsequently detected, outer-joins were used [14, 7, 9, 17].
Reference: [2] <author> F. Bancilhon, S. Cluet, and C. Delobel. </author> <title> A query language for the O 2 object-oriented database system. </title> <booktitle> In Proc. Int. Workshop on Database Programming Languages, </booktitle> <address> Salishan Lodge, Oregan, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction Many declarative query languages for object-oriented database management systems have been proposed in the last few years (e.g. <ref> [3, 5, 2, 15, 11] </ref>). To express complex conditions, access nested structure, or produce nested results, an essential feature found in these languages is the nesting of queries, i.e., the embedding of a query into another query. <p> Section 3 introduces the algebra. The algebraic equivalences used to unnest nested algebraic expressions are presented in Section 4 and applied to some representative nested queries. Section 5 concludes the paper. 2 Dependency-Based Optimization Throughout the paper we will use the O 2 SQL language <ref> [2] </ref> for the examples. However, the techniques that we present are not restricted to this language and can easily be applied to other languages as well. The schema on which the queries are defined represents a 2 company.
Reference: [3] <author> D. Beech. </author> <title> A foundation for evolution from relational to object databases. </title> <booktitle> In Proc. of the Int. Conf. on Extending Database Technology, </booktitle> <year> 1988. </year>
Reference-contexts: 1 Introduction Many declarative query languages for object-oriented database management systems have been proposed in the last few years (e.g. <ref> [3, 5, 2, 15, 11] </ref>). To express complex conditions, access nested structure, or produce nested results, an essential feature found in these languages is the nesting of queries, i.e., the embedding of a query into another query.
Reference: [4] <author> C. Beeri and Y. Kornatzky. </author> <title> Algebraic optimization of object-oriented query languages. </title> <booktitle> In Proc. Int. Conf. on Database Theory (ICDT), </booktitle> <pages> pages 72-88, </pages> <year> 1990. </year> <month> 11 </month>
Reference-contexts: To express complex conditions, access nested structure, or produce nested results, an essential feature found in these languages is the nesting of queries, i.e., the embedding of a query into another query. The optimization of object-oriented (oo) queries has been intensively studied using algebraic rewriting <ref> [4, 6, 20, 22, 23] </ref> or rewriting of path expressions [6, 10, 11]. However, in spite of the importance of nested queries, we do not know of any research on their optimization.
Reference: [5] <author> M. Carey, D. DeWitt, and S. Vandenberg. </author> <title> A data model and query language for EXODUS. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 413-423, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Many declarative query languages for object-oriented database management systems have been proposed in the last few years (e.g. <ref> [3, 5, 2, 15, 11] </ref>). To express complex conditions, access nested structure, or produce nested results, an essential feature found in these languages is the nesting of queries, i.e., the embedding of a query into another query. <p> During the translation of to the algebra, we make use of the variable dependencies in order to to push simple operations as much inside as possible; especially before join operations are applied. 3 The Algebra Our underlying data model is similar to the O 2 [8], GOM [11] or Exodus <ref> [5] </ref> model. It features objects that have an identity, that are manipulated through user-defined methods, whose structures are complex and that belong to classes that may be refined into subclasses. Each class has an extension which is a set containing the object identifiers of all its instances.
Reference: [6] <author> S. Cluet and C. Delobel. </author> <title> A general framework for the optimization of object-oriented queries. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 383-392, </pages> <year> 1992. </year>
Reference-contexts: To express complex conditions, access nested structure, or produce nested results, an essential feature found in these languages is the nesting of queries, i.e., the embedding of a query into another query. The optimization of object-oriented (oo) queries has been intensively studied using algebraic rewriting <ref> [4, 6, 20, 22, 23] </ref> or rewriting of path expressions [6, 10, 11]. However, in spite of the importance of nested queries, we do not know of any research on their optimization. <p> The optimization of object-oriented (oo) queries has been intensively studied using algebraic rewriting [4, 6, 20, 22, 23] or rewriting of path expressions <ref> [6, 10, 11] </ref>. However, in spite of the importance of nested queries, we do not know of any research on their optimization. Nested queries in the oo context are usually translated to nested algebraic expressions which are evaluated through rather inefficient nested loops. <p> The first phase addresses a new challenge related to the third difference stated above. During this phase we apply dependency-based optimization which transforms queries by factoring out constant or locally constant nested queries as well as common subexpressions. Although not new in the oo context <ref> [6, 11, 13] </ref>, this factorization is essential for finding a good evaluation strategy. Then, the resulting queries are translated in a straightforward manner into the nested algebra. <p> The dependency optimization is performed at the O 2 SQL level. This kind of optimization, although vital, is simple enough and requires mainly one traversal of the syntax tree of the query. Since it had been presented elsewhere <ref> [6] </ref>, we will not detail it. Let us just say that the algorithm consists in splitting every operations. The splitting allows us to consider every possible subexpressions that can be factorized. In this paper, we will not split everywhere but only when necessary in order to demonstrate the major points.
Reference: [7] <author> U. Dayal. </author> <title> Of nests and trees: A unified approach to processing queries that contain nested subqueries, aggregates, and quantifiers. </title> <booktitle> In VLDB, </booktitle> <pages> pages 197-208, </pages> <year> 1987. </year>
Reference-contexts: The main motivation was a demonstrated substantial gain in efficiency due to unnesting. In order to eliminate some bugs which where subsequently detected, outer-joins were used <ref> [14, 7, 9, 17] </ref>. Reordering of outer-joins became an important topic [7, 17, 19]. Last, a unifying framework for different unnesting strategies was proposed in [18]. There exist some significant differences between nested queries in the oo and the relational context. <p> The main motivation was a demonstrated substantial gain in efficiency due to unnesting. In order to eliminate some bugs which where subsequently detected, outer-joins were used [14, 7, 9, 17]. Reordering of outer-joins became an important topic <ref> [7, 17, 19] </ref>. Last, a unifying framework for different unnesting strategies was proposed in [18]. There exist some significant differences between nested queries in the oo and the relational context. First, the result of an oo nested query is not always flat. <p> Another good reason is the reordering possibilities it offers in case of a more complex query (i.e., more levels of nesting) <ref> [7, 17, 19, 18] </ref>.
Reference: [8] <author> O. </author> <title> Deux. </title> <journal> The story of O 2 . IEEE Trans. on Data and Knowledge Eng., </journal> <volume> 2(1) </volume> <pages> 91-108, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: During the translation of to the algebra, we make use of the variable dependencies in order to to push simple operations as much inside as possible; especially before join operations are applied. 3 The Algebra Our underlying data model is similar to the O 2 <ref> [8] </ref>, GOM [11] or Exodus [5] model. It features objects that have an identity, that are manipulated through user-defined methods, whose structures are complex and that belong to classes that may be refined into subclasses.
Reference: [9] <author> R. Ganski and H. Wong. </author> <title> Optimization of nested SQL queries revisited. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 23-33, </pages> <year> 1987. </year>
Reference-contexts: The main motivation was a demonstrated substantial gain in efficiency due to unnesting. In order to eliminate some bugs which where subsequently detected, outer-joins were used <ref> [14, 7, 9, 17] </ref>. Reordering of outer-joins became an important topic [7, 17, 19]. Last, a unifying framework for different unnesting strategies was proposed in [18]. There exist some significant differences between nested queries in the oo and the relational context.
Reference: [10] <author> P. Jenq, D. Woelk, W. Kim, and W. Lee. </author> <title> Query processing in distributed ORION. </title> <booktitle> In Proc. Int. Conf. on Extended Database Technology (EDBT), </booktitle> <pages> pages 169-187, </pages> <address> Venice, </address> <year> 1990. </year>
Reference-contexts: The optimization of object-oriented (oo) queries has been intensively studied using algebraic rewriting [4, 6, 20, 22, 23] or rewriting of path expressions <ref> [6, 10, 11] </ref>. However, in spite of the importance of nested queries, we do not know of any research on their optimization. Nested queries in the oo context are usually translated to nested algebraic expressions which are evaluated through rather inefficient nested loops.
Reference: [11] <author> A. Kemper and G. Moerkotte. </author> <title> Advanced query processing in object bases using access support relations. </title> <booktitle> In Proc. Int. Conf. on Very Large Data Bases, </booktitle> <pages> pages 294-305, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Many declarative query languages for object-oriented database management systems have been proposed in the last few years (e.g. <ref> [3, 5, 2, 15, 11] </ref>). To express complex conditions, access nested structure, or produce nested results, an essential feature found in these languages is the nesting of queries, i.e., the embedding of a query into another query. <p> The optimization of object-oriented (oo) queries has been intensively studied using algebraic rewriting [4, 6, 20, 22, 23] or rewriting of path expressions <ref> [6, 10, 11] </ref>. However, in spite of the importance of nested queries, we do not know of any research on their optimization. Nested queries in the oo context are usually translated to nested algebraic expressions which are evaluated through rather inefficient nested loops. <p> The first phase addresses a new challenge related to the third difference stated above. During this phase we apply dependency-based optimization which transforms queries by factoring out constant or locally constant nested queries as well as common subexpressions. Although not new in the oo context <ref> [6, 11, 13] </ref>, this factorization is essential for finding a good evaluation strategy. Then, the resulting queries are translated in a straightforward manner into the nested algebra. <p> During the translation of to the algebra, we make use of the variable dependencies in order to to push simple operations as much inside as possible; especially before join operations are applied. 3 The Algebra Our underlying data model is similar to the O 2 [8], GOM <ref> [11] </ref> or Exodus [5] model. It features objects that have an identity, that are manipulated through user-defined methods, whose structures are complex and that belong to classes that may be refined into subclasses. Each class has an extension which is a set containing the object identifiers of all its instances.
Reference: [12] <author> A. Kemper and G. Moerkotte. </author> <title> Query optimization in object bases: Exploiting relational techniques. </title> <booktitle> In Proc. Dagstuhl Workshop on Query Optimization (J.-C. </booktitle> <editor> Freytag, D. Maier und G. Vossen (eds.)). Morgan-Kaufman, </editor> <year> 1993. </year>
Reference-contexts: Although not new in the oo context [6, 11, 13], this factorization is essential for finding a good evaluation strategy. Then, the resulting queries are translated in a straightforward manner into the nested algebra. The algebra we use is an extension of the GOM algebra <ref> [12, 13] </ref> and features some nice properties most oo algebras lack (e.g., associativity of join operations). The second phase|called algebraic optimization| exploits new opportunities brought by the possibility to represent non-atomic attributes. More specifically, the applied algebraic equivalences will make extensive use of a new powerful grouping operation.
Reference: [13] <author> A. Kemper, G. Moerkotte, and K. Peithner. </author> <title> A blackboard architecture for query optimization in object bases. </title> <address> Informatik-Fachberichte 92-31, RWTH Aachen, 5100 Aachen, Germany, </address> <year> 1991. </year>
Reference-contexts: The first phase addresses a new challenge related to the third difference stated above. During this phase we apply dependency-based optimization which transforms queries by factoring out constant or locally constant nested queries as well as common subexpressions. Although not new in the oo context <ref> [6, 11, 13] </ref>, this factorization is essential for finding a good evaluation strategy. Then, the resulting queries are translated in a straightforward manner into the nested algebra. <p> Although not new in the oo context [6, 11, 13], this factorization is essential for finding a good evaluation strategy. Then, the resulting queries are translated in a straightforward manner into the nested algebra. The algebra we use is an extension of the GOM algebra <ref> [12, 13] </ref> and features some nice properties most oo algebras lack (e.g., associativity of join operations). The second phase|called algebraic optimization| exploits new opportunities brought by the possibility to represent non-atomic attributes. More specifically, the applied algebraic equivalences will make extensive use of a new powerful grouping operation.
Reference: [14] <author> W. Kiessling. </author> <title> SQL-like and Quel-like correlation queries with aggregates revisited. </title> <type> ERL/UCB Memo 84/75, </type> <institution> University of Berkeley, </institution> <year> 1984. </year>
Reference-contexts: The main motivation was a demonstrated substantial gain in efficiency due to unnesting. In order to eliminate some bugs which where subsequently detected, outer-joins were used <ref> [14, 7, 9, 17] </ref>. Reordering of outer-joins became an important topic [7, 17, 19]. Last, a unifying framework for different unnesting strategies was proposed in [18]. There exist some significant differences between nested queries in the oo and the relational context.
Reference: [15] <author> W. Kim. </author> <title> A model of queries for object-oriented database. </title> <booktitle> In Proc. Int. Conf. on Very Large Data Bases (VLDB), </booktitle> <year> 1989. </year>
Reference-contexts: 1 Introduction Many declarative query languages for object-oriented database management systems have been proposed in the last few years (e.g. <ref> [3, 5, 2, 15, 11] </ref>). To express complex conditions, access nested structure, or produce nested results, an essential feature found in these languages is the nesting of queries, i.e., the embedding of a query into another query.
Reference: [16] <author> W. Kim. </author> <title> On optimizing an SQL-like nested query. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 7(3) </volume> <pages> 443-469, </pages> <month> Sep 82. </month>
Reference-contexts: The optimization of nested queries in the oo context should clearly use the vast body of knowledge on optimizing nested relational queries. Departing from the evaluation of 1 nested SQL queries through nested loops [1], Kim proposed unnesting of SQL queries at the SQL level <ref> [16] </ref>. The main motivation was a demonstrated substantial gain in efficiency due to unnesting. In order to eliminate some bugs which where subsequently detected, outer-joins were used [14, 7, 9, 17]. Reordering of outer-joins became an important topic [7, 17, 19]. <p> This implies that we have to consider queries that do not match any of the types introduced for classifying nested relational queries <ref> [16] </ref>. Third, nested queries in the oo context do not always correspond to algebraic operations (e.g., method calls, path expressions), and we have to find an appropriate treatment for these nested expressions as well. <p> Further, ed=d ( ed:e:dept (Emp [e])) can be processed by a single physical operation or even index scan. The problem with this direct translation is that there is just one underlying evaluation plan for nested expressions which corresponds to a nested loop. As shown in <ref> [16] </ref>, this kind of evaluation can be very inefficient. Indeed, in this example, it implies several scans on the Emp extension. The idea to solve this problem is to unnest the expression by performing a grouping on the nested expression followed by a left outer-join.
Reference: [17] <author> M. Muralikrishna. </author> <title> Optimization and dataflow algorithms for nested tree queries. </title> <booktitle> In Proc. Int. Conf. on Very Large Data Bases (VLDB), </booktitle> <year> 1989. </year>
Reference-contexts: The main motivation was a demonstrated substantial gain in efficiency due to unnesting. In order to eliminate some bugs which where subsequently detected, outer-joins were used <ref> [14, 7, 9, 17] </ref>. Reordering of outer-joins became an important topic [7, 17, 19]. Last, a unifying framework for different unnesting strategies was proposed in [18]. There exist some significant differences between nested queries in the oo and the relational context. <p> The main motivation was a demonstrated substantial gain in efficiency due to unnesting. In order to eliminate some bugs which where subsequently detected, outer-joins were used [14, 7, 9, 17]. Reordering of outer-joins became an important topic <ref> [7, 17, 19] </ref>. Last, a unifying framework for different unnesting strategies was proposed in [18]. There exist some significant differences between nested queries in the oo and the relational context. First, the result of an oo nested query is not always flat. <p> Another good reason is the reordering possibilities it offers in case of a more complex query (i.e., more levels of nesting) <ref> [7, 17, 19, 18] </ref>. <p> To this class belong the extension of existing cost models to the nested algebra as well as the more efficient treatment of special cases of tree queries (in the spirit of <ref> [17] </ref>). The second class contains topics involved in extending the current approach in order to incorporate bags and lists on the data model side as well as quantifiers on the query language side.
Reference: [18] <author> M. Muralikrishna. </author> <title> Improved unnesting algorithms for join aggregate SQL queries. </title> <booktitle> In Proc. Int. Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 91-102, </pages> <year> 1992. </year>
Reference-contexts: In order to eliminate some bugs which where subsequently detected, outer-joins were used [14, 7, 9, 17]. Reordering of outer-joins became an important topic [7, 17, 19]. Last, a unifying framework for different unnesting strategies was proposed in <ref> [18] </ref>. There exist some significant differences between nested queries in the oo and the relational context. First, the result of an oo nested query is not always flat. Second, nested queries in the relational context were restricted to occur in the selection clause only. <p> Another good reason is the reordering possibilities it offers in case of a more complex query (i.e., more levels of nesting) <ref> [7, 17, 19, 18] </ref>.
Reference: [19] <author> A. Rosenthal and C. Galindo-Legaria. </author> <title> Query graphs, implementing trees, and freely-reorderable outerjoins. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 291-299, </pages> <year> 1990. </year> <month> 12 </month>
Reference-contexts: The main motivation was a demonstrated substantial gain in efficiency due to unnesting. In order to eliminate some bugs which where subsequently detected, outer-joins were used [14, 7, 9, 17]. Reordering of outer-joins became an important topic <ref> [7, 17, 19] </ref>. Last, a unifying framework for different unnesting strategies was proposed in [18]. There exist some significant differences between nested queries in the oo and the relational context. First, the result of an oo nested query is not always flat. <p> Another good reason is the reordering possibilities it offers in case of a more complex query (i.e., more levels of nesting) <ref> [7, 17, 19, 18] </ref>.
Reference: [20] <author> G.M. Shaw and S.B. Zdonik. </author> <title> A query algebra for object-oriented databases. </title> <booktitle> In Proc. IEEE Conference on Data Engineering, </booktitle> <pages> pages 154-162, </pages> <year> 1990. </year>
Reference-contexts: To express complex conditions, access nested structure, or produce nested results, an essential feature found in these languages is the nesting of queries, i.e., the embedding of a query into another query. The optimization of object-oriented (oo) queries has been intensively studied using algebraic rewriting <ref> [4, 6, 20, 22, 23] </ref> or rewriting of path expressions [6, 10, 11]. However, in spite of the importance of nested queries, we do not know of any research on their optimization. <p> It is left-associative and will be applied in post order. This operator can be used for unnesting and is in many cases equivalent to a join between two sets with a membership predicate <ref> [20] </ref>. We introduced it in order to cope with the values of types that do not have extension (i.e. there exist no sets on which a join could be applied). The grouping operator will make use of the fact that in the object-oriented context attributes can have set-valued attributes.
Reference: [21] <author> E. J. Shekita and M. J. Carey. </author> <title> A performance evaluation of pointer-based joins. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 300-311, </pages> <year> 1990. </year>
Reference-contexts: For instance, the grouping can be evaluated using a sort operation, or, if there exists an index, by a simple index scan. Further, the outer-join can be implemented efficiently as a pointer-based join <ref> [21] </ref>.
Reference: [22] <author> D. Straube and T. Ozsu. </author> <title> Queries and query processing in object-oriented database systems. </title> <journal> ACM Trans. on Information Systems, </journal> <volume> 8(4) </volume> <pages> 387-430, </pages> <year> 1990. </year>
Reference-contexts: To express complex conditions, access nested structure, or produce nested results, an essential feature found in these languages is the nesting of queries, i.e., the embedding of a query into another query. The optimization of object-oriented (oo) queries has been intensively studied using algebraic rewriting <ref> [4, 6, 20, 22, 23] </ref> or rewriting of path expressions [6, 10, 11]. However, in spite of the importance of nested queries, we do not know of any research on their optimization.
Reference: [23] <author> S. L. Vandenberg and D. DeWitt. </author> <title> Algebraic support for complex objects with arrays, identity, and inheritance. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 158-167, </pages> <year> 1991. </year> <month> 13 </month>
Reference-contexts: To express complex conditions, access nested structure, or produce nested results, an essential feature found in these languages is the nesting of queries, i.e., the embedding of a query into another query. The optimization of object-oriented (oo) queries has been intensively studied using algebraic rewriting <ref> [4, 6, 20, 22, 23] </ref> or rewriting of path expressions [6, 10, 11]. However, in spite of the importance of nested queries, we do not know of any research on their optimization.
References-found: 23

