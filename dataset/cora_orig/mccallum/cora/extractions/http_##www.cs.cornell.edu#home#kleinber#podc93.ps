URL: http://www.cs.cornell.edu/home/kleinber/podc93.ps
Refering-URL: http://www.cs.cornell.edu/home/kleinber/kleinber.html
Root-URL: 
Title: Resource Bounds and Combinations of Consensus Objects  
Author: Jon Kleinberg Sendhil Mullainathan 
Abstract: The shared-memory model of computation typically provides processes with an arbitrary number of copies of the available object types; yet a simple argument shows that any consensus protocol can only make use of some finite subset of these. Thus we believe it is useful to consider the problem of consensus from the point of view of resource bounds, determining whether consensus can still be solved when the number of copies of the system's shared objects is limited. This approach leads to a general technique which we call the combination protocol, in which the number of processes that can achieve consensus with a given object increases as more copies of it are made available. Such a phenomenon brings up questions about the robustness of Herlihy's consensus hierarchy, in that objects are being combined to solve n-process consensus, even though no single copy can do so individually. We show how the ideas in the combination protocol appear even in situations where objects are not explicitly being combined with one another; we also consider the general question of resource bounds in several known consensus protocols. We analyze two such protocols that use seemingly similar primitives, achieving a substantial improvement in one case and showing a tight lower bound in the other. 
Abstract-found: 1
Intro-found: 1
Reference: [CHP] <author> P. Courtois, F. Heymann, D. Parnas, </author> <title> "Concurrent Control with Readers and Writers," </title> <journal> Communications of the ACM, </journal> <volume> 14(1971), </volume> <pages> pp. 667-668. </pages>
Reference-contexts: 1 Introduction Any pessimistic model of distributed computing must take into account the perils of asynchrony. The traditional approaches to process coordination | semaphores and critical sections <ref> [CHP] </ref> | are based on the notion of a shared-memory system in which processes explicitly take turns modifying a globally accessible data structure (object). But processes on such a system are running asynchronously, so that the fast processes must wait for the slower ones to complete their operations.
Reference: [DDS] <author> D. Dolev, C. Dwork, L. Stockmeyer, </author> <title> "On the Minimal Synchronism Needed for Distributed Consensus," </title> <journal> Journal of the ACM, </journal> <month> 34(January </month> <year> 1987), </year> <pages> pp. 77-99. </pages>
Reference-contexts: The consensus number of an object O, as defined in [H1], is the maximum number of processes that can achieve asynchronous consensus using atomic operations on O and any number of atomic registers (recall that the results of <ref> [FLP, DDS, LAA] </ref> show that even two processes cannot achieve consensus using only registers). If any number of processes can achieve consensus using O and atomic registers, then O is said to have infinite consensus number. The resulting classification of shared objects is referred to as the consensus hierarchy. <p> To show the impossibility of a solution to 4-process consensus, we follow the standard structure for impossibility proofs of this sort (see e.g. <ref> [FLP, DDS] </ref>). Assume that such a protocol P exists for 4-process consensus in this system. Let denote the schedule of a partial execution of P and q () the system state following the execution of .
Reference: [FLP] <author> M.J. Fischer, N.A. Lynch, </author> <title> M.S. Paterson, "Impossibility of Distributed Consensus with One Faulty Process," </title> <journal> Journal of the ACM 32(April 1985), </journal> <pages> pp. 374-382. </pages>
Reference-contexts: The consensus number of an object O, as defined in [H1], is the maximum number of processes that can achieve asynchronous consensus using atomic operations on O and any number of atomic registers (recall that the results of <ref> [FLP, DDS, LAA] </ref> show that even two processes cannot achieve consensus using only registers). If any number of processes can achieve consensus using O and atomic registers, then O is said to have infinite consensus number. The resulting classification of shared objects is referred to as the consensus hierarchy. <p> To show the impossibility of a solution to 4-process consensus, we follow the standard structure for impossibility proofs of this sort (see e.g. <ref> [FLP, DDS] </ref>). Assume that such a protocol P exists for 4-process consensus in this system. Let denote the schedule of a partial execution of P and q () the system state following the execution of .
Reference: [H2] <author> M. Herlihy, </author> <title> "Impossibility Results for Asynchronous PRAM," </title> <booktitle> Proc. Third ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <year> 1991. </year>
Reference-contexts: these lines will resolve a number of important questions about the relative power of wait free objects, as well as the problem of whether there exists a robust hierarchy for classifying them. 4 2 Definitions and Initial Results 2.1 The Model We use essentially the model of computation presented in <ref> [H1, H2] </ref>. A concurrent system consists of a set of n processes which can access a collection of shared objects. In what follows, we consider only deterministic processes and objects.
Reference: [H1] <author> M. Herlihy, </author> <title> "Wait-Free Synchronization," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <month> Jan. </month> <year> 1991, </year> <pages> pp. 124-149. </pages>
Reference-contexts: The natural question in this setting is the following: one has a system with a number of primitives that behave atomically (such as atomic registers, test-and-set registers, and the like) and wishes to know whether a given object type has a wait-free implementation in this system. In <ref> [H1] </ref>, Herlihy proposed an approach to this problem in which one classifies shared objects according to their consensus number. The consensus number of an object O, as defined in [H1], is the maximum number of processes that can achieve asynchronous consensus using atomic operations on O and any number of atomic <p> In <ref> [H1] </ref>, Herlihy proposed an approach to this problem in which one classifies shared objects according to their consensus number. The consensus number of an object O, as defined in [H1], is the maximum number of processes that can achieve asynchronous consensus using atomic operations on O and any number of atomic registers (recall that the results of [FLP, DDS, LAA] show that even two processes cannot achieve consensus using only registers). <p> If any number of processes can achieve consensus using O and atomic registers, then O is said to have infinite consensus number. The resulting classification of shared objects is referred to as the consensus hierarchy. In <ref> [H1] </ref>, it is shown that if the consensus number of O is k, the consensus number of O 0 is k 0 , and k &gt; k 0 , then O 0 cannot provide a wait-free implementation of O in a system of k or more processes. <p> objects we combine are all of the same type, this becomes a question of resource bounds | how many copies of an object are needed for some fixed number of processes to achieve consensus? In order to carry out this analysis, we find it useful to make the model of <ref> [H1] </ref> somewhat more flexible. First of all, we will consider the "consensus number" of arbitrary (possibly infinite) collections of objects; i.e. we consider the maximum number of processes that can achieve consensus using precisely objects O 1 ; : : : ; O n . <p> Thus, although the consensus numbers of an individual copy of O are very low, an infinite set of them can solve consensus among an arbitrary set of processes. Hence, for example, even one copy of O cannot be implemented by any of the 2-consensus objects considered in <ref> [H1] </ref>. We believe the protocol itself represents an interesting technique for designing wait-free algorithms. It consists essentially of an "elimination tournament," which processes enter in a staggered fashion so that by the end, many processes are able safely to access a single copy of O simultaneously. <p> The robustness of h r m is an open question. The combination protocol appears to be applicable in a number of non-trivially different contexts. In Section 4, we show an application to the problem of consecutive m-register assignment, under the definitions and hierarchy of <ref> [H1] </ref>. This is based on an atomic primitive considered by Herlihy in [H1]: simultaneous assignment to m registers, which he showed has consensus number exactly 2m 2. However, his protocol relied on the ability of one process to assign to registers very far apart in memory. <p> The combination protocol appears to be applicable in a number of non-trivially different contexts. In Section 4, we show an application to the problem of consecutive m-register assignment, under the definitions and hierarchy of <ref> [H1] </ref>. This is based on an atomic primitive considered by Herlihy in [H1]: simultaneous assignment to m registers, which he showed has consensus number exactly 2m 2. However, his protocol relied on the ability of one process to assign to registers very far apart in memory. <p> Finally, in Section 5, we analyze two other protocols presented in <ref> [H1] </ref> from the point of view of resource bounds. It is worth noting that both of the primitives involved are simply classified as having infinite consensus number; yet our results reveal a strong sense in which one is more powerful than the other. <p> The registers x i can be read atomically, and the value in x i can be atomically copied into x j . <ref> [H1] </ref> gives a protocol for n processes to solve consensus using 2n such registers, allowing atomic writing to each x i as well. <p> In contrast to this exponential improvement in resource requirements is the superficially similar case of registers with atomic swap. Here, the contents of the special registers x i can be atomically swapped or read. Without assuming the ability to write atomically to the x i , <ref> [H1] </ref> gives an n-process consensus protocol using n + 1 such registers; we show that under this model, the protocol is resource-optimal | any n-process consensus protocol in this system requires n+1 registers-with-swap. <p> these lines will resolve a number of important questions about the relative power of wait free objects, as well as the problem of whether there exists a robust hierarchy for classifying them. 4 2 Definitions and Initial Results 2.1 The Model We use essentially the model of computation presented in <ref> [H1, H2] </ref>. A concurrent system consists of a set of n processes which can access a collection of shared objects. In what follows, we consider only deterministic processes and objects. <p> Thus, the validity condition can be viewed as follows: the decision value must be the name of a process that has taken at least one step. This essentially is the type of consensus considered in <ref> [H1] </ref>. We will also consider the other most common variation | binary consensus, in which all proposals must be 0 or 1; i.e. U i = f0; 1g for each i. <p> Corollary 1 The hierarchy h 1 is not robust. 11 4 A Variation on the Protocol For the remainder of this paper, we consider the combination protocol, and resource bounds in general, from the point of view of the original model of Herlihy <ref> [H1] </ref>. Thus, we will assume that our system contains an infinite set of atomic registers; again, we will use the terms consensus and consensus number to refer to the problem of leader election in such systems. [H1] considers the primitive simultaneous m-register assignment. <p> bounds in general, from the point of view of the original model of Herlihy <ref> [H1] </ref>. Thus, we will assume that our system contains an infinite set of atomic registers; again, we will use the terms consensus and consensus number to refer to the problem of leader election in such systems. [H1] considers the primitive simultaneous m-register assignment. A system with this primitive consists of an infinite set of atomic registers, and supports an additional atomic operation in which a process can simultaneously assign m (potentially different) values to m distinct registers. It is shown in [H1] that a system with this <p> leader election in such systems. <ref> [H1] </ref> considers the primitive simultaneous m-register assignment. A system with this primitive consists of an infinite set of atomic registers, and supports an additional atomic operation in which a process can simultaneously assign m (potentially different) values to m distinct registers. It is shown in [H1] that a system with this primitive has consensus number 2m 2. It seems natural to consider what the consensus number would be if we did not allow simultaneous assignment to registers that can be arbitrarily far apart in memory. <p> marks [0; m 1] 12 p 2 marks [1; m] Phase 2 p 1 marks [m + 1; 2m] p 2 marks [3m 1; 4m 2] p 3 marks [2m; 3m 1] Final phase Each p i reads registers 0; : : : ; 4m 2, following the technique of <ref> [H1] </ref> if p 3 completed Phase 2 before p 1 or p 2 then elect p 3 else if p 2 completed Phase 1 before p 1 then elect p 2 else elect p 1 It is straightforward to verify that this satisfies wait-freedom, validity, and agreement. <p> Thus, we consider a boundary state q () in the execution of our supposed 4-process protocol P. Let the "preference" v i of p i be the value it would decide if all other processes crashed at this point. As in <ref> [H1] </ref>, observe that all four steps extending must be consecutive assignments (in this case, to "intervals" in memory), with the properties that the interval of each p i must include a register that no other process writes to, and that if p i and p j have different preferences, their intervals <p> As both cases lead to contradictions, the proof is complete. 5 Resource Bounds Finally, we analyze the resource requirements of n-process consensus using two other primitives considered in <ref> [H1] </ref>. Consider a system with an infinite set of atomic registers, and also some special pre-initialized move-registers x 1 ; : : : ; x k . <p> In the latter case, note the difference between these swap-registers and the object S 2 of Section 3; here, a process can swap between any pair of registers. In <ref> [H1] </ref>, protocols are given for n processes to solve consensus using either kind of primitive; the conclusion is that they both have infinite consensus number (actually, the protocol using move in [H1] required the ability to write directly to the move-registers; below, we give a protocol that does not need this <p> In <ref> [H1] </ref>, protocols are given for n processes to solve consensus using either kind of primitive; the conclusion is that they both have infinite consensus number (actually, the protocol using move in [H1] required the ability to write directly to the move-registers; below, we give a protocol that does not need this assumption). These protocols with move and swap require 2n and n + 1 special registers, respectively, suggesting that there is not much difference in the power of these two primitives. <p> We give an n-process consensus protocol which requires only b2 log n + 2c registers with move; on the other hand, we show that any n-process consensus protocol using swap-registers requires n + 1 such registers; i.e. the protocol of <ref> [H1] </ref> is resource-optimal. We note that the protocol using move still requires n additional ordinary atomic registers; thus, the exponential gap does not extend to the total memory requirements of the protocols.
Reference: [Ja] <author> P. Jayanti, </author> <title> "On the Robustness of Herlihy's Hierarchy," </title> <booktitle> Proc. Twelfth ACM Syposium on Principles of Distributed Computing, </booktitle> <year> 1993. </year>
Reference-contexts: Jayanti has subsequently proved several strong statements about the structure of Herlihy's hierarchy, using objects that can implement our combination protocol and were amenable to a number of highly novel "impossibility" arguments <ref> [Ja] </ref>. <p> In his terminology, our results in Section 3 provide the most basic of these results: h 1 is not robust. <ref> [Ja] </ref> extends this to the more natural structures h m and h r 1 (Herlihy's original hierarchy), showing that neither is robust. The robustness of h r m is an open question. The combination protocol appears to be applicable in a number of non-trivially different contexts. <p> Hence our belief that consensus number, considered by itself, does not give a complete description of the power of a shared object to support consensus protocols. In the terminology of <ref> [Ja] </ref>, the following is an immediate corollary of Theorems 2 and 3 (recall that h 1 is the hierarchy of shared objects in which the consensus number of O is the number of processes that can solve consensus using a single copy of O and no registers). <p> The combination protocol of Section 3 presents a general technique for designing consensus protocols within this framework. A number of questions remain open. First of all, we are interested in other applications of the combination protocol in the design of wait-free algorithms. Our work and that of <ref> [Ja] </ref> suggests that perhaps it is most natural to define the consensus number of an object O as the maximum number of processes that can solve consensus using an infinite set of registers and an infinite set of copies of O.
Reference: [JT] <author> P. Jayanti, S. Toueg, </author> <title> "Some Results on the Impossibility, Universality, and De-cidability of Consensus," </title> <booktitle> Proc. Sixth Workshop on Distributed Algorithms, </booktitle> <year> 1992. </year>
Reference-contexts: This contradiction completes the proof. A similar result clearly holds for m-valued consensus for each 1 &lt; m &lt; n. The theorem above can also be viewed as an extension of the result of <ref> [JT] </ref>, that there exists an object which can solve 2-process leader election but not 2-process binary consensus. 7 3 The Combination Protocol As noted in the Introduction, there are a number of possible objects one could use in implementing the combination protocol; we focus on the finite-state object type S 2
Reference: [LAA] <author> M.C. Loui, H.H. Abu-Amara, </author> <title> "Memory Requirements for Agreement Among Unreliable Asynchronous Processes," </title> <booktitle> Advances in Computing Research, </booktitle> <volume> vol. 4, </volume> <year> 1987, </year> <pages> pp. 163-183. </pages>
Reference-contexts: The consensus number of an object O, as defined in [H1], is the maximum number of processes that can achieve asynchronous consensus using atomic operations on O and any number of atomic registers (recall that the results of <ref> [FLP, DDS, LAA] </ref> show that even two processes cannot achieve consensus using only registers). If any number of processes can achieve consensus using O and atomic registers, then O is said to have infinite consensus number. The resulting classification of shared objects is referred to as the consensus hierarchy.
Reference: [Pl] <author> S. Plotkin, </author> <title> "Sticky Bits and Universality of Consensus," </title> <booktitle> Proc. Eighth ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1989. </year> <month> 17 </month>
Reference-contexts: It is possible for object's bc-number to exceed its le-number by an arbitrary amount. Consider the sticky bit of <ref> [Pl] </ref>; initially it is empty, and the first 0 or 1 written to it "sticks" permanently. A single copy of this object has infinite bc-number, but an le-number of 2. In the other direction, however, we can show the following tight bound. <p> After the first step taken by any process, the values of the two registers become the same | subsequent move operations have 14 no effect. Thus it is straightforward to verify that it is a solution to n-process binary consensus for any n. Now, in <ref> [Pl] </ref> a leader election protocol using blog n + 1c sticky bits is presented (the process is elected "one bit at a time," with n atomic registers used to ensure that validity is satisfied).
References-found: 9

