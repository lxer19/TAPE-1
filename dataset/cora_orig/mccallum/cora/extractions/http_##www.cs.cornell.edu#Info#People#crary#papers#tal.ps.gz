URL: http://www.cs.cornell.edu/Info/People/crary/papers/tal.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/crary/papers/
Root-URL: 
Title: From System F to Typed Assembly Language  
Author: Greg Morrisett David Walker Karl Crary Neal Glew 
Date: January 1998.  
Note: This material is based on work supported in part by AFOSR grant F49620-97-1-0013, ARPA/RADC grant F30602-96-1-0317, ARPA/AF grant F30602-95-1-0047, and AASERT grant N00014- 95-1-0985. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the authors and do not reflect the views of these agencies. Appeared in the 1998 Symposium on Principles of Program- ming Languages, San Diego,  
Affiliation: Cornell University  
Abstract: We motivate the design of a statically typed assembly language (TAL) and present a type-preserving translation from System F to TAL. The TAL we present is based on a conventional RISC assembly language, but its static type system provides support for enforcing high-level language abstractions, such as closures, tuples, and objects, as well as user-defined abstract data types. The type system ensures that well-typed programs cannot violate these abstractions. In addition, the typing constructs place almost no restrictions on low-level optimizations such as register allocation, instruction selection, or instruction scheduling. Our translation to TAL is specified as a sequence of type-preserving transformations, including CPS and closure conversion phases; type-correct source programs are mapped to type-correct assembly language. A key contribution is an approach to polymorphic closure conversion that is considerably simpler than previous work. The compiler and typed assembly language provide a fully automatic way to produce proof carrying code, suitable for use in systems where untrusted and potentially malicious code must be checked for safety before execution. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Aditya, C. Flood, and J. Hicks. </author> <title> Garbage collection for strongly-typed languages using run-time type reconstruc-tion. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 12-23, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: This avoids the need for abstract kinds (since there are no type environments), as well as translucent types. A type-erasure interpretation is not without its costs: It precludes some advanced implementation techniques <ref> [28, 43, 1, 29] </ref> and has subtle interactions with side-effects. We address the latter concern by forcing polymorphic abstractions to be values [42, 49] (i.e., they must be syntactically attached to value abstractions). To support this interpretation, we consider the partial application of functions to type arguments to be values. <p> is created as follows (where types have been added for clarity): let x 0 :hint 0 ; int 0 i = malloc [int ; int ] x 1 :hint 1 ; int 0 i = x 0 [0] v 0 x :hint 1 ; int 1 i = x 1 <ref> [1] </ref> v 1 . . . The "x 0 = malloc [int ; int ]" step allocates an uninitial- ized tuple and binds the address (i.e., label) of the tuple to x 0 . <p> Note that x 1 is assigned a type where the first field has a "1" superscript, indicating that this field is initialized. Finally, the "x = x 1 <ref> [1] </ref> v 1 " step initializes the second field of the tuple with v 1 and binds the address of the tuple to x, which is assigned the fully initialized type hint 1 ; int 1 i.
Reference: [2] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion <ref> [14, 35, 2, 12, 18] </ref>, closure conversion [20, 40, 19, 3, 26], unboxing [22, 28, 38], subsump- tion elimination [9, 11], or region inference [7]. <p> This allows the compiler to aggressively optimize code between any of the translation steps. The inspiration for the phases and their ordering is derived from SML/NJ <ref> [4, 2] </ref> (which is in turn based on the Rab- bit [40] and Orbit compilers [19]) except that types are used throughout compilation.
Reference: [3] <author> A. W. Appel and T. Jim. </author> <title> Continuation-passing, closurepassing style. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 293-302, </pages> <address> Austin, </address> <month> Jan. </month> <year> 1989. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [14, 35, 2, 12, 18], closure conversion <ref> [20, 40, 19, 3, 26] </ref>, unboxing [22, 28, 38], subsump- tion elimination [9, 11], or region inference [7]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [22, 18, 28, 37].
Reference: [4] <author> A. W. Appel and D. B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In M. Wirsing, editor, </editor> <booktitle> Third International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> Aug. </month> <year> 1991. </year> <title> Springer-Verlag. </title> <booktitle> Volume 528 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: This allows the compiler to aggressively optimize code between any of the translation steps. The inspiration for the phases and their ordering is derived from SML/NJ <ref> [4, 2] </ref> (which is in turn based on the Rab- bit [40] and Orbit compilers [19]) except that types are used throughout compilation.
Reference: [5] <author> B. Bershad, S. Savage, P. Pardyak, E. Sirer, M. Fiuczynski, D. Becker, C. Chambers, and S. Eggers. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 267-284, </pages> <address> Copper Mountain, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: For example, as suggested by the SPIN project <ref> [5] </ref>, operating systems could allow users to download TAL extensions into the kernel.
Reference: [6] <author> L. Birkedal, N. Rothwell, M. Tofte, and D. N. Turner. </author> <title> The ML Kit (version 1). </title> <type> Technical Report 93/14, </type> <institution> Department of Computer Science, University of Copenhagen, </institution> <year> 1993. </year>
Reference-contexts: Furthermore, the ability to type-check intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 30]. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits <ref> [22, 34, 6, 41, 24, 39, 13] </ref>. However, in all of these compilers, there is a conceptual line where types are lost. For instance, the TIL/ML compiler preserves type information through approximately 80% of compilation, but the remaining 20% is untyped.
Reference: [7] <author> L. Birkedal, M. Tofte, and M. Vejlstrup. </author> <title> From region infer-ence to von Neumann machines via region representation in-ference. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 171-183, </pages> <address> St. Petersburg, </address> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [14, 35, 2, 12, 18], closure conversion [20, 40, 19, 3, 26], unboxing [22, 28, 38], subsump- tion elimination [9, 11], or region inference <ref> [7] </ref>. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [22, 18, 28, 37].
Reference: [8] <author> H. J. Boehm and M. Weiser. </author> <title> Garbage collection in an unco-operative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: However, this is the only instruction sequence that is abstract in TAL. Real machines also have a finite amount of heap space. It is straightforward to link our TAL to a conservative garbage collector <ref> [8] </ref> in order to reclaim unused heap values. Support for an accurate collector would require introducing tags so that we may distinguish pointers from integers, or else require a type-passing interpretation [43, 29].
Reference: [9] <author> V. Breazu-Tannen, T. Coquand, C. A. Gunter, and A. Scedrov. </author> <title> Inheritance as implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 172-221, </pages> <year> 1991. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [14, 35, 2, 12, 18], closure conversion [20, 40, 19, 3, 26], unboxing [22, 28, 38], subsump- tion elimination <ref> [9, 11] </ref>, or region inference [7]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [22, 18, 28, 37].
Reference: [10] <author> K. Crary. </author> <title> KML Reference Manual. </title> <institution> Department of Computer Science, Cornell University, </institution> <year> 1996. </year>
Reference-contexts: To substantiate this claim, we are constructing a compiler called TALC that maps the KML programming language <ref> [10] </ref> to a variant of the TAL described here, suitably adapted for the Intel x86 family of processors. We have found it straightforward to enrich the target language type system to include support for other type constructors, such as references, higher-order constructors, and recursive types.
Reference: [11] <author> K. Crary. </author> <title> Foundations for the implementation of higherorder subtyping. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 125-135, </pages> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [14, 35, 2, 12, 18], closure conversion [20, 40, 19, 3, 26], unboxing [22, 28, 38], subsump- tion elimination <ref> [9, 11] </ref>, or region inference [7]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [22, 18, 28, 37].
Reference: [12] <author> O. Danvy and A. Filinski. </author> <title> Representing control: a study of the CPS transformation. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(4) </volume> <pages> 361-391, </pages> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion <ref> [14, 35, 2, 12, 18] </ref>, closure conversion [20, 40, 19, 3, 26], unboxing [22, 28, 38], subsump- tion elimination [9, 11], or region inference [7]. <p> The rest of this paper proceeds as follows: Section 2 presents F , the compiler's source language, and sketches a typed CPS translation based on Harper and Lillibridge [18] and Danvy and Filinski <ref> [12] </ref>, to our first intermediate language K . Section 3 presents the next intermediate language, C , and gives a typed closure translation based on, but considerably simpler than, the presentation of Minamide, Morrisett, and Harper [26]. <p> Following Danvy and Filinski <ref> [12] </ref>, our term translation simultaneously CPS converts the term, performs tail- call optimization, and eliminates administrative redices (see the technical report [31] for details).
Reference: [13] <author> A. Dimock, R. Muller, F. Turbak, and J. B. Wells. </author> <title> Strongly typed flow-directed reprsentation transformations. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 85-98, </pages> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Furthermore, the ability to type-check intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 30]. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits <ref> [22, 34, 6, 41, 24, 39, 13] </ref>. However, in all of these compilers, there is a conceptual line where types are lost. For instance, the TIL/ML compiler preserves type information through approximately 80% of compilation, but the remaining 20% is untyped.
Reference: [14] <author> M. J. Fischer. </author> <title> Lambda calculus schemata. </title> <booktitle> In Proceedings of the ACM Conference on Proving Assertions about Programs, </booktitle> <pages> pages 104-109, </pages> <year> 1972. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion <ref> [14, 35, 2, 12, 18] </ref>, closure conversion [20, 40, 19, 3, 26], unboxing [22, 28, 38], subsump- tion elimination [9, 11], or region inference [7].
Reference: [15] <author> J.-Y. Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination de coupures dans l'analyse et la theorie des types. </title> <editor> In J. E. Fenstad, ed-itor, </editor> <booktitle> Proceedings of the Second Scandinavian Logic Symposium, </booktitle> <pages> pages 63-92. </pages> <publisher> North-Holland Publishing Co., </publisher> <year> 1971. </year>
Reference-contexts: Also, the report gives a full proof that the type system for our assembly language is sound. 2 System F and CPS Conversion The source language for our compiler, F , is a call-by- value variant of System F <ref> [15, 16, 36] </ref> (the polymorphic -calculus) augmented with products and recursion on 2 K [[ff]] = ff def K [[t 1 ! t 2 ]] = (K [[t 1 ]]; (K [[t 2 ]]) ! void) ! void K [[8ff:t ]] = 8 [ff]:((K [[t ]]) ! void) ! void K
Reference: [16] <author> J.-Y. Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: Also, the report gives a full proof that the type system for our assembly language is sound. 2 System F and CPS Conversion The source language for our compiler, F , is a call-by- value variant of System F <ref> [15, 16, 36] </ref> (the polymorphic -calculus) augmented with products and recursion on 2 K [[ff]] = ff def K [[t 1 ! t 2 ]] = (K [[t 1 ]]; (K [[t 2 ]]) ! void) ! void K [[8ff:t ]] = 8 [ff]:((K [[t ]]) ! void) ! void K
Reference: [17] <author> J.-Y. Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: Con- sequently, the initialization flags do not prevent a field from being initialized twice. It is possible to use mon- ads [44, 21] or linear types <ref> [17, 45, 46] </ref> to ensure that a tuple is initialized exactly once, but we have avoided these approaches in the interest of a simpler type system. The type translation from C to A is trivial.
Reference: [18] <author> R. Harper and M. Lillibridge. </author> <title> Explicit polymorphism and CPS conversion. </title> <booktitle> In Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 206-219, </pages> <address> Charleston, </address> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion <ref> [14, 35, 2, 12, 18] </ref>, closure conversion [20, 40, 19, 3, 26], unboxing [22, 28, 38], subsump- tion elimination [9, 11], or region inference [7]. <p> Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline <ref> [22, 18, 28, 37] </ref>. Furthermore, the ability to type-check intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 30]. <p> The rest of this paper proceeds as follows: Section 2 presents F , the compiler's source language, and sketches a typed CPS translation based on Harper and Lillibridge <ref> [18] </ref> and Danvy and Filinski [12], to our first intermediate language K . Section 3 presents the next intermediate language, C , and gives a typed closure translation based on, but considerably simpler than, the presentation of Minamide, Morrisett, and Harper [26]. <p> Typically, this construct is used by the top-level continuation. Aside from these differences, the static and dynamic semantics for K is completely standard. The implementation of typed CPS-conversion is based upon that of Harper and Lillibridge <ref> [18] </ref>. The type translation K [[ ]] mapping F types to K types is given in Figure 2.
Reference: [19] <author> D. Kranz, R. Kelsey, J. Rees, P. R. Hudak, J. Philbin, and N. Adams. </author> <title> ORBIT: An optimizing compiler for Scheme. </title> <booktitle> In Proceedings of the ACM SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 219-233, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [14, 35, 2, 12, 18], closure conversion <ref> [20, 40, 19, 3, 26] </ref>, unboxing [22, 28, 38], subsump- tion elimination [9, 11], or region inference [7]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [22, 18, 28, 37]. <p> This allows the compiler to aggressively optimize code between any of the translation steps. The inspiration for the phases and their ordering is derived from SML/NJ [4, 2] (which is in turn based on the Rab- bit [40] and Orbit compilers <ref> [19] </ref>) except that types are used throughout compilation. The rest of this paper proceeds as follows: Section 2 presents F , the compiler's source language, and sketches a typed CPS translation based on Harper and Lillibridge [18] and Danvy and Filinski [12], to our first intermediate language K .
Reference: [20] <author> P. J. Landin. </author> <title> The mechanical evaluation of expressions. </title> <journal> Computer J., </journal> <volume> 6(4) </volume> <pages> 308-20, </pages> <year> 1964. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [14, 35, 2, 12, 18], closure conversion <ref> [20, 40, 19, 3, 26] </ref>, unboxing [22, 28, 38], subsump- tion elimination [9, 11], or region inference [7]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [22, 18, 28, 37].
Reference: [21] <author> J. Launchbury and S. L. Peyton Jones. </author> <title> State in Haskell. </title> <journal> LISP and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 293-341, </pages> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: Con- sequently, the initialization flags do not prevent a field from being initialized twice. It is possible to use mon- ads <ref> [44, 21] </ref> or linear types [17, 45, 46] to ensure that a tuple is initialized exactly once, but we have avoided these approaches in the interest of a simpler type system. The type translation from C to A is trivial.
Reference: [22] <author> X. Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 177-188, </pages> <address> Albuquerque, </address> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [14, 35, 2, 12, 18], closure conversion [20, 40, 19, 3, 26], unboxing <ref> [22, 28, 38] </ref>, subsump- tion elimination [9, 11], or region inference [7]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [22, 18, 28, 37]. <p> Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline <ref> [22, 18, 28, 37] </ref>. Furthermore, the ability to type-check intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 30]. <p> Furthermore, the ability to type-check intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 30]. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits <ref> [22, 34, 6, 41, 24, 39, 13] </ref>. However, in all of these compilers, there is a conceptual line where types are lost. For instance, the TIL/ML compiler preserves type information through approximately 80% of compilation, but the remaining 20% is untyped.
Reference: [23] <author> X. Leroy. </author> <title> The effectiveness of type-based unboxing. </title> <booktitle> In Workshop on Types in Compilation, </booktitle> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year> <institution> ACM SIGPLAN. Published as Boston College Computer Science Dept. </institution> <note> Technical Report BCCS-97-03. </note>
Reference-contexts: Finally, since we chose a type-erasure interpretation of polymorphism, adding floats to the language requires a boxing translation. However, recent work by Leroy <ref> [23] </ref> suggests that it is only important to unbox floats in arrays and within compilation units, which is easily done in our framework. 7 Summary We have given a compiler from System F to a statically typed assembly language.
Reference: [24] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Furthermore, the ability to type-check intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 30]. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits <ref> [22, 34, 6, 41, 24, 39, 13] </ref>. However, in all of these compilers, there is a conceptual line where types are lost. For instance, the TIL/ML compiler preserves type information through approximately 80% of compilation, but the remaining 20% is untyped.
Reference: [25] <author> R. Milner, M. Tofte, R. Harper, and D. MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: Instead, a closure is constructed that consists of closed code, a value environment mapping variables to values, and a type environment mapping type variables to types. In our approach, we assume a type-erasure interpretation of polymorphism as in The Definition of Stan- dard ML <ref> [25] </ref>, and polymorphic instantiation is semantically handled via substitution (i.e., making a copy of the code with the types substituted for the type variables). As we will ultimately erase the types on terms before execution, the "copies" can (and will) be represented by the same term.
Reference: [26] <author> Y. Minamide, G. Morrisett, and R. Harper. </author> <title> Typed closure conversion. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 271-283, </pages> <address> St. Petersburg, </address> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [14, 35, 2, 12, 18], closure conversion <ref> [20, 40, 19, 3, 26] </ref>, unboxing [22, 28, 38], subsump- tion elimination [9, 11], or region inference [7]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [22, 18, 28, 37]. <p> Section 3 presents the next intermediate language, C , and gives a typed closure translation based on, but considerably simpler than, the presentation of Minamide, Morrisett, and Harper <ref> [26] </ref>. Section 4 presents the A intermediate language and a translation that makes allocation and initialization of data structures explicit. At this point in compilation, the intermediate code is essentially in a -calculus syntax for assembly language, following the ideas of Wand [48]. <p> Here we discuss closure conversion proper; the hoisting step is elementary and is discussed briefly at the end of the section. Our approach to typed closure conversion is based on that of Minamide et al. <ref> [26] </ref>: If two functions with the same type but different free variables (and therefore different environment types) were naively closure converted, the types of their closures would not be the same. To prevent this, closures are given existential types [27] where the type of the environment is held abstract.
Reference: [27] <author> J. C. Mitchell and G. D. Plotkin. </author> <title> Abstract types have ex-istential type. </title> <journal> ACM Transactions on Progamming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: To prevent this, closures are given existential types <ref> [27] </ref> where the type of the environment is held abstract. However, we propose an approach to polymorphic closure conversion that is considerably simpler than that of Minamide et al., which requires both abstract kinds and translucent types.
Reference: [28] <author> G. Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1995. </year> <note> Published as CMU Technical Report CMU-CS-95-226. </note>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [14, 35, 2, 12, 18], closure conversion [20, 40, 19, 3, 26], unboxing <ref> [22, 28, 38] </ref>, subsump- tion elimination [9, 11], or region inference [7]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [22, 18, 28, 37]. <p> Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline <ref> [22, 18, 28, 37] </ref>. Furthermore, the ability to type-check intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 30]. <p> This avoids the need for abstract kinds (since there are no type environments), as well as translucent types. A type-erasure interpretation is not without its costs: It precludes some advanced implementation techniques <ref> [28, 43, 1, 29] </ref> and has subtle interactions with side-effects. We address the latter concern by forcing polymorphic abstractions to be values [42, 49] (i.e., they must be syntactically attached to value abstractions). To support this interpretation, we consider the partial application of functions to type arguments to be values.
Reference: [29] <author> G. Morrisett and R. Harper. </author> <title> Semantics of memory manage-ment for polymorphic languages. </title> <editor> In A. Gordon and A. Pitts, editors, </editor> <title> Higher Order Operational Techniques in Semantics, </title> <publisher> Publications of the Newton Institute. Cambridge University Press, </publisher> <year> 1997. </year>
Reference-contexts: This avoids the need for abstract kinds (since there are no type environments), as well as translucent types. A type-erasure interpretation is not without its costs: It precludes some advanced implementation techniques <ref> [28, 43, 1, 29] </ref> and has subtle interactions with side-effects. We address the latter concern by forcing polymorphic abstractions to be values [42, 49] (i.e., they must be syntactically attached to value abstractions). To support this interpretation, we consider the partial application of functions to type arguments to be values. <p> It is straightforward to link our TAL to a conservative garbage collector [8] in order to reclaim unused heap values. Support for an accurate collector would require introducing tags so that we may distinguish pointers from integers, or else require a type-passing interpretation <ref> [43, 29] </ref>. The tagging approach is readily accomplished in our framework. 5.3 TAL Static Semantics The static semantics for TAL appears in Figures 9 and 10 and consists of thirteen judgments, summarized in the conventions of Morrisett and Harper's !8 gc [29]. <p> The tagging approach is readily accomplished in our framework. 5.3 TAL Static Semantics The static semantics for TAL appears in Figures 9 and 10 and consists of thirteen judgments, summarized in the conventions of Morrisett and Harper's !8 gc <ref> [29] </ref>. A weak notion of subtyping is included for technical reasons related to subject reduction, so that an initialized tuple may still be given its old uninitialized type (see the technical report [31] for details).
Reference: [30] <author> G. Morrisett, D. Tarditi, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> The TIL/ML compiler: Performance and safety through types. </title> <booktitle> In Workshop on Compiler Support for Systems Software, </booktitle> <address> Tucson, </address> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [22, 18, 28, 37]. Furthermore, the ability to type-check intermediate code provides an invaluable tool for debugging new transformations and optimizations <ref> [41, 30] </ref>. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits [22, 34, 6, 41, 24, 39, 13]. However, in all of these compilers, there is a conceptual line where types are lost.
Reference: [31] <author> G. Morrisett, D. Walker, K. Crary, and N. Glew. </author> <title> From System F to typed assembly language (extended version). </title> <type> Technical Report TR97-1651, </type> <institution> Cornell University, </institution> <month> Nov. </month> <year> 1997. </year>
Reference-contexts: Section 6 discusses extensions to TAL to support language constructs not considered here. Space considerations prevent us from giving all of the details of the term translations. We encourage those interested to read the companion technical report <ref> [31] </ref>, which gives formal static semantics for each of the intermediate languages. <p> Following Danvy and Filinski [12], our term translation simultaneously CPS converts the term, performs tail- call optimization, and eliminates administrative redices (see the technical report <ref> [31] </ref> for details). <p> v ::= x j i j h~vi j v [t ] j pack [t; v] as 9ff:t 0 j fixcode x [~ff](x 1 :t 1 ; : : : ; x k :t k ):e Our closure conversion technique is formalized as a type-directed translation in the companion technical report <ref> [31] </ref>. <p> A weak notion of subtyping is included for technical reasons related to subject reduction, so that an initialized tuple may still be given its old uninitialized type (see the technical report <ref> [31] </ref> for details). Lemma 5.1 (Subject Reduction) If ` TAL P and P 7! P 0 then ` TAL P 0 . Lemma 5.2 (Progress) If ` TAL P then either: 1. there exists P 0 such that P 7! P 0 , or 2.

Reference: [33] <author> G. Necula and P. Lee. </author> <title> Safe kernel extensions without runtime checking. </title> <booktitle> In Proceedings of Operating System Design and Implementation, </booktitle> <pages> pages 229-243, </pages> <address> Seattle, </address> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: In contrast, TAL does not have the overhead of the additional sandboxing code, as type- checking is performed o*ine. With regard to these security properties, TAL is an instance of Necula and Lee's proof carrying code (PCC) <ref> [33, 32] </ref>. Necula suggests that the relevant operational content of simple type systems may be encoded using extensions to first-order predicate logic, and proofs of relevant security properties such as memory safety may be automatically verified [32].
Reference: [34] <author> S. L. Peyton Jones, C. V. Hall, K. Hammond, W. Partain, and P. Wadler. </author> <title> The Glasgow Haskell compiler: a technical overview. </title> <booktitle> In Proc. UK Joint Framework for Information Technology (JFIT) Technical Conference, </booktitle> <month> July </month> <year> 1993. </year>
Reference-contexts: Furthermore, the ability to type-check intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 30]. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits <ref> [22, 34, 6, 41, 24, 39, 13] </ref>. However, in all of these compilers, there is a conceptual line where types are lost. For instance, the TIL/ML compiler preserves type information through approximately 80% of compilation, but the remaining 20% is untyped.
Reference: [35] <author> G. D. Plotkin. </author> <title> Call-by-name, call-by-value, and the lambda calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion <ref> [14, 35, 2, 12, 18] </ref>, closure conversion [20, 40, 19, 3, 26], unboxing [22, 28, 38], subsump- tion elimination [9, 11], or region inference [7].
Reference: [36] <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Programming Symposium, volume 19 of Lecture Notes in Computer Science, </booktitle> <pages> pages 408-425, </pages> <address> New York, </address> <year> 1974. </year>
Reference-contexts: Also, the report gives a full proof that the type system for our assembly language is sound. 2 System F and CPS Conversion The source language for our compiler, F , is a call-by- value variant of System F <ref> [15, 16, 36] </ref> (the polymorphic -calculus) augmented with products and recursion on 2 K [[ff]] = ff def K [[t 1 ! t 2 ]] = (K [[t 1 ]]; (K [[t 2 ]]) ! void) ! void K [[8ff:t ]] = 8 [ff]:((K [[t ]]) ! void) ! void K
Reference: [37] <author> E. Ruf. </author> <title> Partitioning dataflow analyses using types. </title> <booktitle> In Twenty-Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 15-26, </pages> <address> Paris, </address> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline <ref> [22, 18, 28, 37] </ref>. Furthermore, the ability to type-check intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 30].
Reference: [38] <author> Z. Shao. </author> <title> Flexible representation analysis. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 85-98, </pages> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [14, 35, 2, 12, 18], closure conversion [20, 40, 19, 3, 26], unboxing <ref> [22, 28, 38] </ref>, subsump- tion elimination [9, 11], or region inference [7]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [22, 18, 28, 37].
Reference: [39] <author> Z. Shao. </author> <title> An overview of the FLINT/ML compiler. </title> <booktitle> In Workshop on Types in Compilation, </booktitle> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year> <institution> ACM SIGPLAN. Published as Boston College Computer Science Dept. </institution> <note> Technical Report BCCS-97-03. </note>
Reference-contexts: Furthermore, the ability to type-check intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 30]. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits <ref> [22, 34, 6, 41, 24, 39, 13] </ref>. However, in all of these compilers, there is a conceptual line where types are lost. For instance, the TIL/ML compiler preserves type information through approximately 80% of compilation, but the remaining 20% is untyped.
Reference: [40] <author> G. L. Steele Jr. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <year> 1978. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [14, 35, 2, 12, 18], closure conversion <ref> [20, 40, 19, 3, 26] </ref>, unboxing [22, 28, 38], subsump- tion elimination [9, 11], or region inference [7]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [22, 18, 28, 37]. <p> This allows the compiler to aggressively optimize code between any of the translation steps. The inspiration for the phases and their ordering is derived from SML/NJ [4, 2] (which is in turn based on the Rab- bit <ref> [40] </ref> and Orbit compilers [19]) except that types are used throughout compilation.
Reference: [41] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 181192, </pages> <address> Philadelphia, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [22, 18, 28, 37]. Furthermore, the ability to type-check intermediate code provides an invaluable tool for debugging new transformations and optimizations <ref> [41, 30] </ref>. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits [22, 34, 6, 41, 24, 39, 13]. However, in all of these compilers, there is a conceptual line where types are lost. <p> Furthermore, the ability to type-check intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 30]. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits <ref> [22, 34, 6, 41, 24, 39, 13] </ref>. However, in all of these compilers, there is a conceptual line where types are lost. For instance, the TIL/ML compiler preserves type information through approximately 80% of compilation, but the remaining 20% is untyped.
Reference: [42] <author> M. Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89 </volume> <pages> 1-34, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: A type-erasure interpretation is not without its costs: It precludes some advanced implementation techniques [28, 43, 1, 29] and has subtle interactions with side-effects. We address the latter concern by forcing polymorphic abstractions to be values <ref> [42, 49] </ref> (i.e., they must be syntactically attached to value abstractions). To support this interpretation, we consider the partial application of functions to type arguments to be values.
Reference: [43] <author> A. Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: This avoids the need for abstract kinds (since there are no type environments), as well as translucent types. A type-erasure interpretation is not without its costs: It precludes some advanced implementation techniques <ref> [28, 43, 1, 29] </ref> and has subtle interactions with side-effects. We address the latter concern by forcing polymorphic abstractions to be values [42, 49] (i.e., they must be syntactically attached to value abstractions). To support this interpretation, we consider the partial application of functions to type arguments to be values. <p> It is straightforward to link our TAL to a conservative garbage collector [8] in order to reclaim unused heap values. Support for an accurate collector would require introducing tags so that we may distinguish pointers from integers, or else require a type-passing interpretation <ref> [43, 29] </ref>. The tagging approach is readily accomplished in our framework. 5.3 TAL Static Semantics The static semantics for TAL appears in Figures 9 and 10 and consists of thirteen judgments, summarized in the conventions of Morrisett and Harper's !8 gc [29].
Reference: [44] <author> P. Wadler. </author> <title> Comprehending monads. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 61-78, </pages> <address> Nice, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Con- sequently, the initialization flags do not prevent a field from being initialized twice. It is possible to use mon- ads <ref> [44, 21] </ref> or linear types [17, 45, 46] to ensure that a tuple is initialized exactly once, but we have avoided these approaches in the interest of a simpler type system. The type translation from C to A is trivial.
Reference: [45] <author> P. Wadler. </author> <title> Linear types can change the world! In M. </title> <editor> Broy and C. Jones, editors, </editor> <booktitle> Programming Concepts and Methods, Sea of Galilee, </booktitle> <address> Israel, </address> <month> Apr. </month> <year> 1990. </year> <title> North Holland. </title> <booktitle> IFIP TC 2 Working Conference. </booktitle>
Reference-contexts: Con- sequently, the initialization flags do not prevent a field from being initialized twice. It is possible to use mon- ads [44, 21] or linear types <ref> [17, 45, 46] </ref> to ensure that a tuple is initialized exactly once, but we have avoided these approaches in the interest of a simpler type system. The type translation from C to A is trivial.
Reference: [46] <author> P. Wadler. </author> <title> A taste of linear logic. </title> <booktitle> In Mathematical Foundations of Computer Science, volume 711 of LNCS, </booktitle> <address> Gdansk, Poland, Aug. 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Con- sequently, the initialization flags do not prevent a field from being initialized twice. It is possible to use mon- ads [44, 21] or linear types <ref> [17, 45, 46] </ref> to ensure that a tuple is initialized exactly once, but we have avoided these approaches in the interest of a simpler type system. The type translation from C to A is trivial.
Reference: [47] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Fourteenth ACM Symposium on Operating Systems Principles, pages 203216, </booktitle> <address> Asheville, </address> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Furthermore, critical inner-loops could be hand-written in assembly language in order to achieve optimal performance. TAL could also be used to support extensible web-browsers, extensible servers, active networks, or any other "kernel" where security, performance, and language independence are desired. Software Fault Isolation (SFI) <ref> [47] </ref> also provides memory safety and language independence. However, SFI requires the insertion of extra "sandboxing" code, corresponding to dynamic type tests, to ensure that the extension is safe. In contrast, TAL does not have the overhead of the additional sandboxing code, as type- checking is performed o*ine.
Reference: [48] <author> M. Wand. </author> <title> Correctness of procedure representations in higher-order assembly language. </title> <editor> In S. Brookes, editor, </editor> <booktitle> Proceedings Mathematical Foundations of Programming Semantics '91, volume 598 of Lecture Notes in Computer Science, </booktitle> <pages> pages 294-311. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Section 4 presents the A intermediate language and a translation that makes allocation and initialization of data structures explicit. At this point in compilation, the intermediate code is essentially in a -calculus syntax for assembly language, following the ideas of Wand <ref> [48] </ref>. Finally, Section 5 presents our typed assembly language and defines a translation from A to TAL. Section 6 discusses extensions to TAL to support language constructs not considered here. Space considerations prevent us from giving all of the details of the term translations.

References-found: 47

