URL: http://www.cs.man.ac.uk/~banach/some.pubs/MONSTR.TGR.Par.Mach.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~banach/Recent.publications.html
Root-URL: http://www.cs.man.ac.uk
Title: 18 MONSTR: Term Graph Rewriting for Parallel Machines  
Author: R. Banach 
Note: c fl1993 John Wiley Sons Ltd  
Date: 18.1 INTRODUCTION  
Abstract: In this chapter, the primary issue addressed is the adoptability of generalized Term Graph Rewriting Systems (TGRS) as a fundamental computational model at the architectural level. This is a desirable thing to do since many currently fashionable programming styles (e.g. functional or logic) have easy translations into TGRS. Unfortunately, implementing the model on a parallel machine (an equally fashionable architectural style), is infeasable in its raw form. This is surprising because there are many implementations of fashionable programming styles on fashionable architectures that actually perform acceptably well. This indicates that perhaps the more troublesome features of the full TGR model are not really needed when one translates such languages into the TGR form. This hypothesis turns out to be correct, and gives rise to a program of work to indentify the little used, expensive aspects of general TGRS and to exclude them by carefully redefining TGR languages and/or their semantic models. Some aspects of this work are surveyed in this chapter. There is far too little space available to present all the details, let alone all the proofs. These will appear in [Ban93]. The rest of the chapter is organized as follows. In section 18.2, we present an abstract version of a concrete TGR language, DACTL. In section 18.3 we present a sublanguage, MONSTR, and justify its selection on architectural grounds. In section 18.4, we discuss a number of semantic models for the MONSTR sublanguage, arguing that these more closely reflect the way a realistic parallel machine might execute MONSTR programs. We present the main soundness results that 
Abstract-found: 1
Intro-found: 0
Reference: [BSW + 88] <author> R. Banach, J. Sargeant, I. Watson, P. Watson, V. Woods. </author> <title> The Flagship project. </title> <booktitle> Proc. UK-IT-88 (Alvey Technical Conference), </booktitle> <pages> pp. 242-245, </pages> <institution> Information Engineering Directorate, Department of Trade and Industry, IEE Publications, </institution> <year> 1988. </year>
Reference-contexts: In particular, whatever an implementation does, it must in some acceptable way be equivalent to a serializable sequence of rewrites and notifications. 18.3 MONSTR Now we present an abridged TGR language, MONSTR, first investigated in <ref> [BSW + 88] </ref> and [BW89], which curtails some of the problems inherent in the DACTL definition. The definition is in terms of a list of restrictions on the general structure of DACTL.
Reference: [BW89] <author> R. Banach, P. Watson. </author> <title> Dealing with state in Flagship: the MONSTR computational model. </title> <booktitle> Proc. CONPAR-88, C.R. Jesshope D.K. Reinhartz (eds.), </booktitle> <pages> pp. 595-604, </pages> <booktitle> B.C.S. Workshop Series, </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: In particular, whatever an implementation does, it must in some acceptable way be equivalent to a serializable sequence of rewrites and notifications. 18.3 MONSTR Now we present an abridged TGR language, MONSTR, first investigated in [BSW + 88] and <ref> [BW89] </ref>, which curtails some of the problems inherent in the DACTL definition. The definition is in terms of a list of restrictions on the general structure of DACTL.
Reference: [Ban93] <author> R. </author> <note> Banach. MONSTR. in preparation. </note>
Reference-contexts: Some aspects of this work are surveyed in this chapter. There is far too little space available to present all the details, let alone all the proofs. These will appear in <ref> [Ban93] </ref>. The rest of the chapter is organized as follows. In section 18.2, we present an abstract version of a concrete TGR language, DACTL. In section 18.3 we present a sublanguage, MONSTR, and justify its selection on architectural grounds. <p> Nevertheless these counter examples are usually sufficiently pathological to inspire a search for criteria under which equivalence can be demonstrated, and to date, the search has been a fruitful one. See <ref> [Ban93] </ref> for details.
Reference: [BvEG + 87] <author> H.P. Barendregt, M.C.J.D. van Eekelen, J.R.W. Glauert, J.R Kennaway, M.J. </author> <title> Plasmeijer and M.R. Sleep. Term graph rewriting. </title> <booktitle> Proc. </booktitle> <volume> PARLE-87 Vol. II, LNCS 259, </volume> <pages> pp. 141-158, </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Call the resulting graph Y, and define i X 00 ;Y as the natural injection. The result of the rewrite is the graph Y . For a more detailed exposition of contraction building and redirection, see <ref> [BvEG + 87] </ref> 3.6 (i)-(ii), or [GKSS88] for a more detailed exposition of all the phases in a concrete syntax setting.
Reference: [GKSS88] <author> J.R.W. Glauert, J.R. Kennaway, </author> <title> M.R. Sleep, G.W. Somner. Final Specification of DACTL. </title> <type> Internal Report SYS-C88-11, </type> <institution> School of Information Systems, University of East Anglia, Norwich, UK, </institution> <year> 1988. </year>
Reference-contexts: and M.C. van Eekelen c fl1993 John Wiley & Sons Ltd BANACH map computations according to these more operational models, into computations according to the original semantics, thus giving a handle on correctness. 18.2 ABSTRACT DACTL We present here a rather abstract and slightly simplified version of the language DACTL <ref> [GKSS88, GHK + 88] </ref>. The abstraction takes us away from the tedium of concrete syntax and enables us to concentrate on the semantic issues. We assume we are given an alphabet S = fS; T : : :g of node symbols. <p> Call the resulting graph Y, and define i X 00 ;Y as the natural injection. The result of the rewrite is the graph Y . For a more detailed exposition of contraction building and redirection, see [BvEG + 87] 3.6 (i)-(ii), or <ref> [GKSS88] </ref> for a more detailed exposition of all the phases in a concrete syntax setting. Note that our notion of activation is a little different than that in [GKSS88], the pattern calculus (a feature of true DACTL we ignore), being at the heart of the matter. <p> For a more detailed exposition of contraction building and redirection, see [BvEG + 87] 3.6 (i)-(ii), or <ref> [GKSS88] </ref> for a more detailed exposition of all the phases in a concrete syntax setting. Note that our notion of activation is a little different than that in [GKSS88], the pattern calculus (a feature of true DACTL we ignore), being at the heart of the matter. Also we have combined root quiescence and activation in our version of the activation phase, whereas root quiescence is done right at the beginning of the [GKSS88] definition. <p> a little different than that in <ref> [GKSS88] </ref>, the pattern calculus (a feature of true DACTL we ignore), being at the heart of the matter. Also we have combined root quiescence and activation in our version of the activation phase, whereas root quiescence is done right at the beginning of the [GKSS88] definition. The reason for this is that it yields significant technical simplifications when graph markings are involved in inductive proofs of properties of executions (although the present chapter provides no evidence for this, due to its succinctness). Suppose now that Sel is empty.
Reference: [GHK + 88] <author> J.R.W. Glauert, K. Hammond, J.R. Kennaway, G.A. Papdopoulos, </author> <title> M.R. Sleep. DACTL: Some Introductory Papers. </title> <institution> School of Information Systems, University of East Anglia, Norwich, UK, </institution> <year> 1988. </year>
Reference-contexts: and M.C. van Eekelen c fl1993 John Wiley & Sons Ltd BANACH map computations according to these more operational models, into computations according to the original semantics, thus giving a handle on correctness. 18.2 ABSTRACT DACTL We present here a rather abstract and slightly simplified version of the language DACTL <ref> [GKSS88, GHK + 88] </ref>. The abstraction takes us away from the tedium of concrete syntax and enables us to concentrate on the semantic issues. We assume we are given an alphabet S = fS; T : : :g of node symbols.
Reference: [WW87] <author> P. Watson, I. Watson. </author> <title> Evaluating functional programs on the Flagship machine. </title> <journal> Proc. FLCA-87, </journal> <volume> LNCS 274, </volume> <pages> pp. 80-97, </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: One could then lift the criteria necessary for non-interference to the graph world, and study them in the more convenient abstract setting. For the particular architectural model we have in mind, the Flagship model <ref> [WW87, WWW + 87, WSWW89] </ref>, the problems boil down to the study of the interference of distinct redirections, given a minimal locking strategy for graph nodes.
Reference: [WWW + 87] <author> I. Watson, V. Woods, P. Watson, R. Banach, M. Greenberg, J. Sargeant. Flagship: </author> <title> A parallel architecture for declarative programming. </title> <booktitle> Proc. 15th Annual International Symposium on Computer Architecture, Hawaii, ACM, </booktitle> <year> 1987. </year>
Reference-contexts: One could then lift the criteria necessary for non-interference to the graph world, and study them in the more convenient abstract setting. For the particular architectural model we have in mind, the Flagship model <ref> [WW87, WWW + 87, WSWW89] </ref>, the problems boil down to the study of the interference of distinct redirections, given a minimal locking strategy for graph nodes.
Reference: [WSWW89] <author> I. Watson, J. Sargeant, P. Watson, V. Woods. </author> <booktitle> The Flagship parallel machine. Proc. CONPAR-88, C.R. Jesshope D.K. Reinhartz (eds.), </booktitle> <pages> pp. 125-133, </pages> <booktitle> BCS Workshop Series, </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: One could then lift the criteria necessary for non-interference to the graph world, and study them in the more convenient abstract setting. For the particular architectural model we have in mind, the Flagship model <ref> [WW87, WWW + 87, WSWW89] </ref>, the problems boil down to the study of the interference of distinct redirections, given a minimal locking strategy for graph nodes.
References-found: 9

