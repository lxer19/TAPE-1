URL: http://www.cs.ucsb.edu/oocsb/self/papers/sigplan90.ps.Z
Refering-URL: http://www.cs.ucsb.edu/oocsb/self/papers/iterative-type-analysis.html
Root-URL: http://www.cs.ucsb.edu
Email: (craig@self.stanford.edu)  (ungar@self.stanford.edu)  
Title: Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs  
Author: CRAIG CHAMBERS DAVID UNGAR 
Address: 94305  2500 Garcia Avenue, Mountain View, CA 94043.  
Affiliation: Computer Systems Laboratory, Stanford University, Stanford, California  Sun Microsystems, IBM, Apple Computer, Tandem  Sun Microsystems,  
Date: 4, 3, 1991  
Note: To be published in: LISP AND SYMBOLIC COMPUTATION: An International Journal,  1991 Kluwer Academic Publishers Manufactured in The Netherlands  *This work has been generously supported by National Science Foundation Presidential Young Investigator Grant #CCR-8657631, and by  Computers, NCR, Texas Instruments, the Powell Foundation, and DEC. Authors present address:  
Abstract: Object-oriented languages have suffered from poor performance caused by frequent and slow dynamically-bound procedure calls. The best way to speed up a procedure call is to compile it out, but dynamic binding of object-oriented procedure calls without static receiver type information precludes inlining. Iterative type analysis and extended message splitting are new compilation techniques that extract much of the necessary type information and make it possible to hoist run-time type tests out of loops. Our system compiles code on-the-y that is customized to the actual data types used by a running program. The compiler constructs a control ow graph annotated with type information by simultaneously performing type analysis and inlining. Extended message splitting preserves type information that would otherwise be lost by a control-ow merge by duplicating all the code between the merge and the place that uses the information. Iterative type analysis computes the types of variables used in a loop by repeatedly recompiling the loop until the computed types reach a fix-point. Together these two techniques enable our SELF compiler to split off a copy of an entire loop, optimized for the common-case types. By the time our SELF compiler generates code for the graph, it has eliminated many dynamically-dispatched procedure calls and type tests. The resulting machine code is twice as fast as that generated by the previous SELF compiler, four times faster than ParcPlace Systems Smalltalk-80, the fastest commercially available dynamically-typed object-oriented language implementation, and nearly half the speed of optimized C. Iterative type analysis and extended message splitting have cut the performance penalty for dynamically-typed object-oriented languages in half. This paper was originally published in the Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation (SIGPLAN Notices, 25, 6 (1990) 150-162). 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Aho, A. V., Sethi, R., and Ullman, J. D. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1986). </address>
Reference-contexts: Another solution to the circularity would be to use traditional iterative data ow techniques <ref> [1] </ref> to determine the type bindings for the loop before doing any inlining within the loop. <p> Our extended message splitting is performed at type analysis time as part of message inlining, and additionally can be used to split branches of the control ow graph based on any other information available at type analysis time, such as splitting for available values <ref> [1] </ref> in order to perform more common subex-pression elimination. Extended message splitting with iterative type analysis may lead to more than one version of a loop being compiled, each for different initial type bindings. This is similar to an optimization in some parallelizing Fortran compilers called two-version loops [17].
Reference: 2. <author> Chambers, C., and Ungar, D. </author> <title> Customization: Optimizing Compiler Technology for SELF, a Dynamically-Typed Object-Oriented Programming Language. </title> <booktitle> In Proceedings of the SIGPLAN 89 Conference on Programming Language Design and Implementation. Published as SIGPLAN Notices, </booktitle> <volume> 24, </volume> <month> 7 </month> <year> (1989) </year> <month> 146-160. </month>
Reference-contexts: As part of our earlier work we built an optimizing compiler for SELF that pioneered the use of customization, type prediction, and message splitting <ref> [2, 3] </ref>. These techniques provided the compiler with much more static type information than was previously available, enabling it to aggressively inline away many of the costly message sends without sacrificing source-code compatibility. <p> Section 7 discusses related work. 2 Background The new techniques presented in this paper build upon those introduced in the previous SELF compiler, including customization, type prediction, message splitting (called local message splitting in this paper), message inlining, and primitive inlining <ref> [2, 3] </ref>. Customized compilation. Existing compilers for Smalltalk-80 (as well as most other object-oriented languages) compile a single machine code method for a given source code method. Since many classes may inherit the same method, the Smalltalk-80 compiler cannot know the exact class of the receiver. <p> comparison primitive based solely on integer subrange information or eliminate overow checks and array bounds checks. 4 Extended Message Splitting Both the original and the new SELF compilers use message splitting to take advantage of type information that otherwise would be lost to merges in the control ow graph (see <ref> [2, 3] </ref>). The original SELF compiler was only able to split messages that immediately followed a merge point; we call this local message splitting. <p> This system uses dynamic compilation [4], and is tied with Version 2.5 for the distinction of being the fastest commercially available Smalltalk system. old SELF-89 refers to the measurements taken for the old SELF compiler in early 1989 and published in <ref> [2] </ref>. This was a well-tuned SELF system with a simpler compiler based on expression trees, customization, and local splitting. old SELF-90 is our current, production SELF system which uses the old SELF compiler.
Reference: 3. <author> Chambers, C., Ungar, D., and Lee, E. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In OOPSLA 89 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 24, </volume> <month> 10 </month> <year> (1989) </year> <month> 49-70. </month> <note> Also to be published in Lisp and Symbolic Computation, 4, 3 (1991). </note>
Reference-contexts: As part of our earlier work we built an optimizing compiler for SELF that pioneered the use of customization, type prediction, and message splitting <ref> [2, 3] </ref>. These techniques provided the compiler with much more static type information than was previously available, enabling it to aggressively inline away many of the costly message sends without sacrificing source-code compatibility. <p> Section 7 discusses related work. 2 Background The new techniques presented in this paper build upon those introduced in the previous SELF compiler, including customization, type prediction, message splitting (called local message splitting in this paper), message inlining, and primitive inlining <ref> [2, 3] </ref>. Customized compilation. Existing compilers for Smalltalk-80 (as well as most other object-oriented languages) compile a single machine code method for a given source code method. Since many classes may inherit the same method, the Smalltalk-80 compiler cannot know the exact class of the receiver. <p> comparison primitive based solely on integer subrange information or eliminate overow checks and array bounds checks. 4 Extended Message Splitting Both the original and the new SELF compilers use message splitting to take advantage of type information that otherwise would be lost to merges in the control ow graph (see <ref> [2, 3] </ref>). The original SELF compiler was only able to split messages that immediately followed a merge point; we call this local message splitting.
Reference: 4. <author> Deutsch, L. P., and Schiffman, A. M. </author> <title> Efficient Implementation of the Small-talk-80 System. </title> <booktitle> In Proceedings of the 11th Annual ACM Symposium on the Principles of Programming Languages (1984) 297-302. </booktitle>
Reference-contexts: For richards, which is written in C++, the C version includes the effect of the AT&T cfront 1.2.1 preprocessor. ST-80 refers to the ParcPlace Systems Version 2.4 Smalltalk-80 implementation. This system uses dynamic compilation <ref> [4] </ref>, and is tied with Version 2.5 for the distinction of being the fastest commercially available Smalltalk system. old SELF-89 refers to the measurements taken for the old SELF compiler in early 1989 and published in [2]. <p> This call is polymorphic (since different tasks handle the run message differently), and by invoking a different procedure almost every call defeats the traditional inline-caching optimization <ref> [4] </ref> intended to speed monomorphic call sites. The result is that the overhead to handle this single call site is the same as the total optimized C time of the benchmark. We think we could nearly eliminate this overhead by generating call-site-specific inline-cache miss handlers.
Reference: 5. <author> Goldberg, A., and Robson, D. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1983). </address>
Reference-contexts: This paper describes new techniques for extracting and preserving static type information in dynamically-typed object-oriented programs. This work continues our earlier work on the SELF programming language [12, 22]. SELF is a new dynamically-typed object-oriented language in the spirit of Smalltalk-80 1 <ref> [5] </ref>, but is novel in its use of prototypes instead of classes and its use of messages instead of variables to access state. These features make SELF programs even harder to run efficiently than other dynamically-typed object-oriented languages, since SELF programs send many more messages than equivalent Smalltalk programs.
Reference: 6. <author> Graver, J. O. </author> <title> Type-Checking and Type-Inference for Object-Oriented Programming Languages. </title> <type> Ph.D. thesis, </type> <institution> University of Illinois at Urbana-Cham-paign (1989). </institution>
Reference-contexts: The Typed Smalltalk system includes a type inferencer that infers the types of most methods and local variables based on the user-declared types of instance variables, class variables, global variables, and primitives <ref> [6, 7] </ref>. The type inferencer is based on abstract interpretation of the program in the type domain, and an expression is type-correct if and only if the abstract interpretation of the expression in the context of the current class hierarchy is successful.
Reference: 7. <author> Graver, J. O., and Johnson, R. E. </author> <title> A Type System for Smalltalk. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages (1990) 136-150. </booktitle>
Reference-contexts: The Typed Smalltalk system includes a type inferencer that infers the types of most methods and local variables based on the user-declared types of instance variables, class variables, global variables, and primitives <ref> [6, 7] </ref>. The type inferencer is based on abstract interpretation of the program in the type domain, and an expression is type-correct if and only if the abstract interpretation of the expression in the context of the current class hierarchy is successful.
Reference: 8. <author> Heintz, R. L., Jr. </author> <title> Low Level Optimizations for an Object-Oriented Programming Language. </title> <type> Masters thesis, </type> <institution> University of Illinois at Urbana-Champaign (1990). </institution>
Reference-contexts: Our current range analysis cannot eliminate these bounds checks, since the integer subrange of the array index overlaps the integer subrange for the array length. On the other hand, the TS compiler for Typed Smalltalk <ref> [8, 11, 13] </ref> is able to optimize many of these bounds checks away, since it uses simple theorem proving to propagate the results of conditional expressions and thus avoid repeated tests, such as that the index is less than the array length.
Reference: 9. <author> Hennessy, J. </author> <title> Stanford integer benchmarks. </title> <type> Personal communication (1988). </type>
Reference-contexts: This SELF compiler achieved a performance of between 20% and 25% of optimized C on the Stanford integer benchmarks <ref> [9] </ref>, twice that of the fastest Smalltalk implementation on the same machine. While this performance is a clear improvement over comparable systems, it is still not competitive with traditional languages.
Reference: 10. <author> Johnson, R. E. </author> <title> Type-Checking Smalltalk. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 315-321. </month> <title> ITERATIVE TYPE ANALYSIS AND EXTENDED MESSAGE SPLITTING 121 </title>
Reference-contexts: While this higher-level view of an objects type is best for exible polymorphic type-checking, it provides little information for an optimizing compiler to speed programs. A different approach is taken by the Typed Smalltalk project <ref> [10, 11] </ref>. Their type system is based on sets of classes, and a variables type specifies the possible object classes (not superclasses) that objects stored in the variable may have.
Reference: 11. <author> Johnson, R. E., Graver, J. O., and Zurawski, L. W. </author> <title> TS: An Optimizing Compiler for Smalltalk. </title> <booktitle> In OOPSLA 88 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 23, </volume> <month> 11 </month> <year> (1988) </year> <month> 18-26. </month>
Reference-contexts: While this higher-level view of an objects type is best for exible polymorphic type-checking, it provides little information for an optimizing compiler to speed programs. A different approach is taken by the Typed Smalltalk project <ref> [10, 11] </ref>. Their type system is based on sets of classes, and a variables type specifies the possible object classes (not superclasses) that objects stored in the variable may have. <p> Our current range analysis cannot eliminate these bounds checks, since the integer subrange of the array index overlaps the integer subrange for the array length. On the other hand, the TS compiler for Typed Smalltalk <ref> [8, 11, 13] </ref> is able to optimize many of these bounds checks away, since it uses simple theorem proving to propagate the results of conditional expressions and thus avoid repeated tests, such as that the index is less than the array length.
Reference: 12. <author> Lee, E. </author> <title> Object Storage and Inheritance for SELF, a Prototype-Based Object-Oriented Programming Language. </title> <type> Engineers thesis, </type> <institution> Stanford University (1988). </institution>
Reference-contexts: This paper describes new techniques for extracting and preserving static type information in dynamically-typed object-oriented programs. This work continues our earlier work on the SELF programming language <ref> [12, 22] </ref>. SELF is a new dynamically-typed object-oriented language in the spirit of Smalltalk-80 1 [5], but is novel in its use of prototypes instead of classes and its use of messages instead of variables to access state.
Reference: 13. <author> McConnell, C. D. </author> <title> The Design of the RTL System. </title> <type> Masters thesis, </type> <institution> University of Illinois at Urbana-Champaign (1989). </institution>
Reference-contexts: Our current range analysis cannot eliminate these bounds checks, since the integer subrange of the array index overlaps the integer subrange for the array length. On the other hand, the TS compiler for Typed Smalltalk <ref> [8, 11, 13] </ref> is able to optimize many of these bounds checks away, since it uses simple theorem proving to propagate the results of conditional expressions and thus avoid repeated tests, such as that the index is less than the array length.
Reference: 14. <author> Milner, R., Tofte, M., and Harper, R. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA (1990). </address>
Reference-contexts: Although final proof must await larger SELF programs, we believe that extra code space will not be a problem. ITERATIVE TYPE ANALYSIS AND EXTENDED MESSAGE SPLITTING 117 7 Related Work Other systems perform type analysis over programs without external type declarations. ML <ref> [14] </ref> is a statically-typed function-oriented language in which the compiler is able to infer the types of all procedures and expressions and do static type checking with virtually no type declarations. Researchers have attempted to extend ML-style type inference to object-oriented languages, with some success [15, 16, 23, 24].
Reference: 15. <author> Mitchell, J. </author> <type> Personal communication (1989). </type>
Reference-contexts: ML [14] is a statically-typed function-oriented language in which the compiler is able to infer the types of all procedures and expressions and do static type checking with virtually no type declarations. Researchers have attempted to extend ML-style type inference to object-oriented languages, with some success <ref> [15, 16, 23, 24] </ref>. However, most of these approaches use type systems that describe an objects interface or protocol, rather than the objects representation or method dictionary.
Reference: 16. <author> Ohori, A., and Buneman, P. </author> <title> Static Type Inference for Parametric Classes. </title> <booktitle> In OOPSLA 89 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 24, </volume> <month> 10 </month> <year> (1989) </year> <month> 445-456. </month>
Reference-contexts: ML [14] is a statically-typed function-oriented language in which the compiler is able to infer the types of all procedures and expressions and do static type checking with virtually no type declarations. Researchers have attempted to extend ML-style type inference to object-oriented languages, with some success <ref> [15, 16, 23, 24] </ref>. However, most of these approaches use type systems that describe an objects interface or protocol, rather than the objects representation or method dictionary.
Reference: 17. <author> Padua, D. A., and Wolfe, M. J. </author> <title> Advanced Compiler Optimizations for Supercomputers. </title> <journal> In Communications of the ACM, </journal> <volume> 29, </volume> <month> 12 </month> <year> (1986) </year> <month> 1184-1201. </month>
Reference-contexts: Extended message splitting with iterative type analysis may lead to more than one version of a loop being compiled, each for different initial type bindings. This is similar to an optimization in some parallelizing Fortran compilers called two-version loops <ref> [17] </ref>.
Reference: 18. <editor> Rees, J., and Clinger, W., editors. </editor> <title> Revised 3 Report on the Algorithmic Language Scheme (1986). </title>
Reference-contexts: However, Fortran compilers typically determine subrange information by looking at the bounds specified in do loops. This approach doesnt work in languages with user-defined control structures like SELF, Smalltalk, and Scheme <ref> [18] </ref>, since the compiler has no fixed do construct to look for loop index ranges.
Reference: 19. <author> Sestoft, P., and Sndergaard, H. </author> <title> A Bibliography on Partial Evaluation. </title> <journal> In SIGPLAN Notices, </journal> <volume> 23, </volume> <month> 2 </month> <year> (1988) </year> <month> 19-27. </month>
Reference-contexts: Our type analysis is also similar to partial evaluation <ref> [19] </ref>. Type analysis is a form of abstract interpretation of the nodes in the control ow graph using compile-time types instead of run-time values. Our system partially-evaluates methods with respect to the customized receiver type to produce an optimized version of the method specific to that receiver type.
Reference: 20. <author> Ungar, D. M. </author> <title> The Design and Evaluation of a High-Performance Smalltalk System. </title> <type> Ph.D. thesis, </type> <institution> the University of California at Berkeley (1986). Published by the MIT Press, </institution> <address> Cambridge, MA (1987). </address>
Reference-contexts: The advantage of this approach is that our SELF compiler can know the type of the receiver of the message at compile-time. Type prediction. Sometimes the name of the message is sufficient to predict the type of its receiver. For example, several studies <ref> [20] </ref> have shown that the receiver of a + message is nine times more likely to be a small integer than any other type. Our compiler inserts type tests in these cases so that subsequent code may exploit the type information in the common case. Message inlining.
Reference: 21. <author> Ungar, D. </author> <title> A Performance Comparison of C, SELF, and Smalltalk Implementations. </title> <note> Unpublished manuscript (1989). </note>
Reference-contexts: 1 Introduction Dynamically-typed object-oriented languages have historically been much slower in run-time performance than traditional languages like C and Fortran. Our measurements of several Smalltalk systems on personal computers and workstations <ref> [21] </ref> indicate that their performance is between 5% and 20% of the performance of optimized C programs. This disparity in performance is caused largely by the relatively slow speed and high frequency of message passing and the lack of static type information to reduce either of these costs.
Reference: 22. <author> Ungar, D., and Smith, R. B. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 22, </volume> <month> 12 </month> <year> (1987) </year> <month> 227-241. </month> <note> Also to be published in Lisp and Symbolic Computation, 4, 3 (1991). </note>
Reference-contexts: This paper describes new techniques for extracting and preserving static type information in dynamically-typed object-oriented programs. This work continues our earlier work on the SELF programming language <ref> [12, 22] </ref>. SELF is a new dynamically-typed object-oriented language in the spirit of Smalltalk-80 1 [5], but is novel in its use of prototypes instead of classes and its use of messages instead of variables to access state.
Reference: 23. <author> Wand, M. </author> <title> Complete Type Inference for Simple Objects. </title> <booktitle> In Proceedings of the 2nd IEEE Symposium on Logic in Computer Science (1987) 37-44. </booktitle>
Reference-contexts: ML [14] is a statically-typed function-oriented language in which the compiler is able to infer the types of all procedures and expressions and do static type checking with virtually no type declarations. Researchers have attempted to extend ML-style type inference to object-oriented languages, with some success <ref> [15, 16, 23, 24] </ref>. However, most of these approaches use type systems that describe an objects interface or protocol, rather than the objects representation or method dictionary.
Reference: 24. <author> Wand, M. </author> <title> Type Inference for Record Concatenation and Multiple Inheritance. </title> <booktitle> In Proceedings of the 4th IEEE Symposium on Logic in Computer Science (1989) 92-97. 122 CHAMBERS AND UNGAR </booktitle>
Reference-contexts: ML [14] is a statically-typed function-oriented language in which the compiler is able to infer the types of all procedures and expressions and do static type checking with virtually no type declarations. Researchers have attempted to extend ML-style type inference to object-oriented languages, with some success <ref> [15, 16, 23, 24] </ref>. However, most of these approaches use type systems that describe an objects interface or protocol, rather than the objects representation or method dictionary.
References-found: 24

