URL: http://www.cs.mu.oz.au/tr_db/mu_95_14.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: fzs,fjh,conwayg@cs.mu.OZ.AU  
Phone: Fax: +61 3 348 1184, Phone: +61 3 282 2401  
Title: The execution algorithm of Mercury, an efficient purely declarative logic programming language  
Author: Zoltan Somogyi, Fergus James Henderson and Thomas Charles Conway 
Address: Parkville, 3052 Victoria, Australia  
Affiliation: Department of Computer Science, University of Melbourne  
Abstract: We introduce Mercury, a new purely declarative logic programming language designed to provide the support that groups of application programmers need when building large programs. Mercury's strong type, mode and determinism systems improve program reliability by catching many errors at compile time. We present a new and relatively simple execution model that takes advantage of the information these systems provide to generate very efficient code. The prototype Mercury compiler uses this execution model to generate portable C code. Our benchmarking shows that the code generated by our experimental implementation is significantly faster than the code generated by mature optimizing implementations of other logic programming languages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Ait-Kaci. </author> <title> Warren's abstract machine: a tutorial reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Therefore the second alternative succeeds twice with the solutions A = <ref> [1] </ref>, B = [2] and A = [1,2], B = []. Suppose we wanted to discard nondet stack frames as soon as possible. <p> For example, after returning the solution A = [1,2], B = [] the frame of the original invocation of append 3 1 will be on top of the nondet stack, but after returning A = <ref> [1] </ref>, B = [2] it will not be. Therefore in this case leaving the frame on the nondet stack until failure is faster than trying to discard it on the last success, and this is what the code above does. <p> Our design for all-solutions predicates is based on higher-order predicates. 4 Comparison with the WAM It is interesting to compare our execution model with the Warren Abstract Machine <ref> [1, 25] </ref>. We did not design the Mercury execution model by starting with the WAM and modifying it; we designed it from scratch.
Reference: [2] <author> H. Boehm and M. Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18 </volume> <pages> 807-820, </pages> <year> 1988. </year>
Reference-contexts: For example, by using a data representation without tags (as we discussed in section 3.1) and redefining incr hp to call gc malloc, we can avoid the need for our own garbage collector and simply link in Hans Boehm's conservative garbage collector for C <ref> [2] </ref>. In such a setup we would want to put our own wrappers around malloc and free to allow a restore hp to free all blocks allocated since the corresponding mark hp without invoking the general garbage collector. <p> Since the lifetimes of C and H do not overlap, the compiler uses the same framevar slot for them. The recursive call may succeed several times. In our example, the value of NT will be <ref> [2] </ref>, and the recursive call will succeed twice, the solutions being T = [], B = [2] and T = [2], B = []. <p> The recursive call may succeed several times. In our example, the value of NT will be <ref> [2] </ref>, and the recursive call will succeed twice, the solutions being T = [], B = [2] and T = [2], B = []. <p> The recursive call may succeed several times. In our example, the value of NT will be <ref> [2] </ref>, and the recursive call will succeed twice, the solutions being T = [], B = [2] and T = [2], B = []. <p> Therefore the second alternative succeeds twice with the solutions A = [1], B = <ref> [2] </ref> and A = [1,2], B = []. Suppose we wanted to discard nondet stack frames as soon as possible. <p> For example, after returning the solution A = [1,2], B = [] the frame of the original invocation of append 3 1 will be on top of the nondet stack, but after returning A = [1], B = <ref> [2] </ref> it will not be. Therefore in this case leaving the frame on the nondet stack until failure is faster than trying to discard it on the last success, and this is what the code above does. <p> Without garbage collection, it can correctly compile 120 out of the 125 modules in the compiler. To allow the compiler to compile the remaining modules, we linked our runtime system with Hans Boehm's conservative garbage collector for C <ref> [2] </ref>. This requires that we define incr hp to call gc malloc, the memory allocator supplied by this package. To allow the package to identify pointers properly, we must also use the tagless data representation we discussed in section 3.1. <p> We do not use Boehm's conservative garbage collector for C <ref> [2] </ref> because it slows down forward execution considerably and thus results in performance that is not representative of the final system. 7.2 Speed tests We have tested the speed of the Mercury implementation on a set of standard Prolog benchmarks which we have translated to Mercury.
Reference: [3] <author> M. Carlsson and J. Widen. </author> <title> SICStus-Prolog user's manual. </title> <type> Technical Report 88007B, </type> <institution> Swedish Institute of Computer Science, Kista, Sweden, </institution> <year> 1988. </year>
Reference-contexts: Consider the call append ([1,2], <ref> [3] </ref>, L). <p> parts of argument i are output, ri may be undefined at call but will be in register ri at return * the called procedure is free to destroy rj for values of j greater than its arity For our example, the system will put pointers to the lists [1,2] and <ref> [3] </ref> into registers r1 and r2 respectively before calling append. <p> Besides Mercury, we ran the benchmarks on five other logic programming languages: SWI-Prolog 1.9.0 [26], NU-Prolog 1.6.4 [22], Quintus Pro-log 3.2, SICStus Prolog 2.1 <ref> [3] </ref> and Aquarius Prolog 1.0 [23]; these versions are the latest we have access to.
Reference: [4] <author> S. K. Debray and D. S. Warren. </author> <title> Detection and optimisa-tion of functional computations in Prolog. </title> <booktitle> In Proceedings of the Third International Conference on Logic Programming, </booktitle> <pages> pages 490-504, </pages> <address> London, England, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: The compiler analyses the bodies of predicates to check that their declarations are correct. Although this problem is undecidable in general, several fast approximate solutions are known <ref> [4, 17, 18] </ref>, and they work well in practice. We detect determinism by looking for disjunctions in which all arms contain a test unification of the same variable against different function symbols. We call such disjunctions switches, since only one arm of the disjunction can possibly be executed.
Reference: [5] <author> W. </author> <title> Drabent. </title> <booktitle> Do logic programs resemble programs in conventional languages? In Proceedings of the Fourth IEEE Symposium on Logic Programming, </booktitle> <pages> pages 389-396, </pages> <address> San Francisco, California, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: We provide two standard shorthand modes corresponding to the standard notions of inputs and outputs: :- mode in :: ground -&gt; ground. :- mode out :: free -&gt; ground. These two modes are enough for the vast majority of predicates <ref> [5] </ref>. Nevertheless, Mercury's mode system is sufficiently expressive to handle more complex data-flow patterns, including those involving partially instantiated data structures. For example, consider an interface to a database that associates data with keys, and provides read and write access to the items it stores. <p> Even then, we found them easy to code around, and found the resulting code to be easier to understand than the original. This is consistent with the experiences reported in <ref> [5] </ref> and [21]. We consider Mercury's limitations to be more than worthwhile considering the benefits they bring in terms of productivity, reliability, understandability, maintainability, and efficiency.
Reference: [6] <author> B. Hausman. Carpe diem, </author> <title> some implementation aspects of Turbo Erlang. </title> <booktitle> In Proceedings of the Workshop on Practical Implementations and Systems Experience in Logic Programming, </booktitle> <pages> pages 1-12, </pages> <address> Budapest, Hungary, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: We would have liked to run the benchmarks on some other systems as well, PARMA [21] and Turbo Erlang <ref> [6] </ref> in particular, but we do not have access to those. 2 In all our performance tables, the second column identifies a variant of the system in question. For NU-Prolog, SICStus and Aquarius, the variant name includes the letter "d" if the benchmarks had the appropriate declarations.
Reference: [7] <author> R. C. Haygood. </author> <title> Native code compilation in SICStus Pro-log. </title> <booktitle> In Proceedings of the Eleventh International Conference on Logic Programming, </booktitle> <pages> pages 190-204, </pages> <address> Santa Margherita Ligure, Italy, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: SWI-Prolog, NU-Prolog and probably Quintus Prolog are bytecode interpreters. The compact option of SICStus is also a bytecode interpreter, while its fastcode option is a native code compiler (the fastcode we tested is not the one described in <ref> [7] </ref>, but based on the results reported in that paper, our results would not be much different if it were). Aquarius is also a native code compiler. Aquar-ius has an option asking the compiler to perform global analysis on the program; we tested Aquarius both with and without this option.
Reference: [8] <author> F. J. Henderson. </author> <title> Strong modes can change the world! Technical Report 93/25, </title> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <year> 1993. </year>
Reference-contexts: Finally it checks that the resulting instantiatedness of the predicate's arguments is the same as the one given by the predicate's mode declaration. For further details we refer the reader to <ref> [8, 18, 19] </ref>. The mode analysis algorithm annotates each call with the mode used. This is necessary because our implementation generates separate code for each mode of each predicate, and therefore the code generated for a call depends on the mode in which the predicate is being called. <p> Our execution model allows both approaches; see section 3.6. We can generalize this idea to the notion of polymorphic modes. Other generalizations include the notions of circular modes and of mode segments. As these are beyond the scope of this paper, we refer the interested reader to <ref> [8, 18, 19] </ref>. 2.3 Determinism For each mode of a predicate, we categorize that mode according to the number of solutions that can be returned by calls to the predicate in that mode: * If all calls to a particular mode of a predicate have exactly one solution, then that mode <p> One obvious optimization is to reuse the newly freed memory cell for the following allocation. This is by now a well researched area <ref> [8, 10, 12, 20] </ref>. The key problem is the analysis required to identify the location of the last reference to a memory cell. These analyses require dataflow information, and their accuracy is limited by the accuracy of the dataflow information they are based on. <p> Mercury's mode system therefore provides a concept called unique modes <ref> [8] </ref>, analogous to linear types in functional programming [24]. Unique modes essentially allow the programmer to declare that there should be only one reference to a particular object, thus guaranteeing that the compiler will be able to optimize updates to that object.
Reference: [9] <author> P. M. Hill and J. W. Lloyd. </author> <title> The Godel programming language. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Section 6 gives the current state of the Mercury system while section 7 presents performance results. 2 The Mercury language Syntactically, Mercury is similar to Prolog with additional declarations. Semantically, however, it is very different. Mercury is a pure logic programming language with a well-defined declarative semantics. Like Godel <ref> [9] </ref>, Mercury provides declarative replacements for Prolog's non-logical features. Unlike Godel, Mercury provides replacements for all such features, including I/O. Mercury will appeal to at least two groups of programmers. <p> It is essentially equivalent to the Mycroft-O'Keefe type system [13], and to the type system of Godel <ref> [9] </ref>. We borrow our syntax from the NU-Prolog [22] type checkers. The basic method of defining types is with declarations such as :- type bool ---&gt; true ; false. :- type list (T) ---&gt; [] ; [T | list (T)].
Reference: [10] <author> A. Marien, G. Janssen, A. Mulkers, and M. Bruynooghe. </author> <title> The impact of abstract interpretations: an experiment in code generation. </title> <booktitle> In Proceedings of the Sixth International Conference on Logic Programming, </booktitle> <pages> pages 33-47, </pages> <address> Lisboa, Portugal, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: One obvious optimization is to reuse the newly freed memory cell for the following allocation. This is by now a well researched area <ref> [8, 10, 12, 20] </ref>. The key problem is the analysis required to identify the location of the last reference to a memory cell. These analyses require dataflow information, and their accuracy is limited by the accuracy of the dataflow information they are based on.
Reference: [11] <author> R. Milner. </author> <title> A proposal for standard ML. </title> <booktitle> In Conference Record of the ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 184-197, </pages> <address> Austin, Texas, </address> <month> July </month> <year> 1984. </year>
Reference-contexts: At the same time, it is explicitly designed to support teams of programmers working on large programs. For example, it has a modern module system that separates interfaces from implementations. Mercury's polymorphic type system, modelled after ML's <ref> [11] </ref>, is very expressive. The type system uses declarations supplied by the programmer to detect a large fraction of program errors.
Reference: [12] <author> A. Mulkers, W. Winsborough, and M. Bruynooghe. </author> <title> Analysis of shared data structures for compile-time garbage collection in logic programs. </title> <booktitle> In Proceedings of the Seventh International Conference on Logic Programming, </booktitle> <pages> pages 747-762, </pages> <address> Jerusalem, Israel, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: One obvious optimization is to reuse the newly freed memory cell for the following allocation. This is by now a well researched area <ref> [8, 10, 12, 20] </ref>. The key problem is the analysis required to identify the location of the last reference to a memory cell. These analyses require dataflow information, and their accuracy is limited by the accuracy of the dataflow information they are based on.
Reference: [13] <author> A. Mycroft and R. A. O'Keefe. </author> <title> A polymorphic type system for Prolog. </title> <journal> Artificial Intelligence, </journal> <volume> 23 </volume> <pages> 295-307, </pages> <year> 1984. </year>
Reference-contexts: Space limitations prevent us from describing the whole language; we give a brief overview which provides the background required for the rest of the paper. 2.1 Types Mercury's type system is based on a polymorphic many-sorted logic. It is essentially equivalent to the Mycroft-O'Keefe type system <ref> [13] </ref>, and to the type system of Godel [9]. We borrow our syntax from the NU-Prolog [22] type checkers. The basic method of defining types is with declarations such as :- type bool ---&gt; true ; false. :- type list (T) ---&gt; [] ; [T | list (T)]. <p> Type systems of this nature have been the subject of much research, so we omit a description of the type checking algorithm and refer the reader to papers describing type checking algorithms for equivalent and related type systems (see e.g. <ref> [13, 15] </ref>). 2.2 Modes We consider the mode of a predicate as a mapping from the initial state of instantiation of the arguments of the predicate to their final state of instantiation. To describe states of instantiation, we use information provided by the type system.
Reference: [14] <author> L. M. Pereira. </author> <title> Rational debugging in logic programming. </title> <booktitle> In Proceedings of the Third International Conference on Logic Programming, </booktitle> <pages> pages 203-210, </pages> <address> London, England, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: Prolog programmers therefore often resort to non-logical constructs, which then destroy the declarative semantics of the program, and make the program hard to maintain and more difficult to debug due to the inapplicability of techniques such as declarative debugging (see e.g. <ref> [14] </ref>). The lack of modules and compiler-checked declarations in most Prolog dialects tends not to be a problem for small programs, since a single programmer can understand all of the code at once and since such small programs can be debugged using the Prolog system's typically limited debugging facilities.
Reference: [15] <editor> F. Pfenning, editor. </editor> <booktitle> Types in logic programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Type systems of this nature have been the subject of much research, so we omit a description of the type checking algorithm and refer the reader to papers describing type checking algorithms for equivalent and related type systems (see e.g. <ref> [13, 15] </ref>). 2.2 Modes We consider the mode of a predicate as a mapping from the initial state of instantiation of the arguments of the predicate to their final state of instantiation. To describe states of instantiation, we use information provided by the type system.
Reference: [16] <author> H. Seki and K. Furukawa. </author> <title> Notes on transformation techniques for generate and test logic programs. </title> <booktitle> In Proceedings of the Fourth IEEE Symposium on Logic Programming, </booktitle> <pages> pages 215-223, </pages> <address> San Francisco, California, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: Prime finds all primes up to 100. Qsort quicksorts a list of 50 integers using difference lists. Queen finds all safe placements of 9 queens on a 9x9 chessboard. Cqueen is the same benchmark after it has been put through the source-to-source transformation of Seki and Furukawa <ref> [16] </ref>. Query finds countries with approximately equal population den sity. Tak is an artificial benchmark, originally written in Lisp; it is heavily recursive and does lots of simple integer arithmetic. <p> This is why we cur rently do not have any plans to implement coroutining for Mercury. We intend instead to implement source-level program transformations to change the order of evaluation to a more efficient one, as in <ref> [16] </ref>, and to get the compiler to emit parallel code. (These two approaches also work for programs with circular data dependencies, which currently we do not allow; we intend to relax this restriction.) Coroutining and parallelism both impose overheads on the basic execution algorithm: in some places the code must check
Reference: [17] <author> G. Smolka. </author> <title> Making control and data flow in logic programs explicit. </title> <booktitle> In Conference Record of the ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 311-322, </pages> <address> Austin, Texas, </address> <month> July </month> <year> 1984. </year>
Reference-contexts: The compiler analyses the bodies of predicates to check that their declarations are correct. Although this problem is undecidable in general, several fast approximate solutions are known <ref> [4, 17, 18] </ref>, and they work well in practice. We detect determinism by looking for disjunctions in which all arms contain a test unification of the same variable against different function symbols. We call such disjunctions switches, since only one arm of the disjunction can possibly be executed.
Reference: [18] <author> Z. Somogyi. </author> <title> A parallel logic programming system based on strong and precise modes. </title> <type> PhD thesis, </type> <institution> University of Melbourne, Australia, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: Finally it checks that the resulting instantiatedness of the predicate's arguments is the same as the one given by the predicate's mode declaration. For further details we refer the reader to <ref> [8, 18, 19] </ref>. The mode analysis algorithm annotates each call with the mode used. This is necessary because our implementation generates separate code for each mode of each predicate, and therefore the code generated for a call depends on the mode in which the predicate is being called. <p> Our execution model allows both approaches; see section 3.6. We can generalize this idea to the notion of polymorphic modes. Other generalizations include the notions of circular modes and of mode segments. As these are beyond the scope of this paper, we refer the interested reader to <ref> [8, 18, 19] </ref>. 2.3 Determinism For each mode of a predicate, we categorize that mode according to the number of solutions that can be returned by calls to the predicate in that mode: * If all calls to a particular mode of a predicate have exactly one solution, then that mode <p> The compiler analyses the bodies of predicates to check that their declarations are correct. Although this problem is undecidable in general, several fast approximate solutions are known <ref> [4, 17, 18] </ref>, and they work well in practice. We detect determinism by looking for disjunctions in which all arms contain a test unification of the same variable against different function symbols. We call such disjunctions switches, since only one arm of the disjunction can possibly be executed.
Reference: [19] <author> Z. Somogyi. </author> <title> A system of precise modes for logic programs. </title> <booktitle> In Proceedings of the Fourth International Conference on Logic Programming, </booktitle> <pages> pages 769-787, </pages> <address> Mel-bourne, Australia, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: The children of an or-node are the function symbols that can be used to construct terms of that type; the children of an and-node are the types of the arguments of the function symbol. Following <ref> [19] </ref>, we attach mode information to the or-nodes of type trees. An instantiatedness tree is an assignment of an instanti-atedness | either free or bound | to each or-node of a type tree, with the constraint that all descendants of a free node must be free. <p> Finally it checks that the resulting instantiatedness of the predicate's arguments is the same as the one given by the predicate's mode declaration. For further details we refer the reader to <ref> [8, 18, 19] </ref>. The mode analysis algorithm annotates each call with the mode used. This is necessary because our implementation generates separate code for each mode of each predicate, and therefore the code generated for a call depends on the mode in which the predicate is being called. <p> Our execution model allows both approaches; see section 3.6. We can generalize this idea to the notion of polymorphic modes. Other generalizations include the notions of circular modes and of mode segments. As these are beyond the scope of this paper, we refer the interested reader to <ref> [8, 18, 19] </ref>. 2.3 Determinism For each mode of a predicate, we categorize that mode according to the number of solutions that can be returned by calls to the predicate in that mode: * If all calls to a particular mode of a predicate have exactly one solution, then that mode <p> Since Mercury is a pure language, the only dependencies between predicates are those required by the data flow, and therefore many Mercury programs should have useful parallelism. This holds true even for fully deterministic Mercury programs with a stream AND-parallel implementation <ref> [19] </ref>. A parallel Mercury implementation running on a single processor is of course a coroutining Mercury implementation. With NU-Prolog and SICStus Prolog, it is striking that although declarations can speed up the program dramatically by inducing coroutining (as in queen) or slightly by allowing better indexing (e.g.
Reference: [20] <author> A. Taylor. </author> <title> LIPS on a MIPS: results from a Prolog compiler for a RISC. </title> <booktitle> In Proceedings of the Seventh International Conference on Logic Programming, </booktitle> <pages> pages 174-185, </pages> <address> Jerusalem, Israel, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: One obvious optimization is to reuse the newly freed memory cell for the following allocation. This is by now a well researched area <ref> [8, 10, 12, 20] </ref>. The key problem is the analysis required to identify the location of the last reference to a memory cell. These analyses require dataflow information, and their accuracy is limited by the accuracy of the dataflow information they are based on.
Reference: [21] <author> A. Taylor. </author> <title> High performance Prolog implementation. </title> <type> PhD thesis, </type> <institution> University of Sydney, Australia, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: We would have liked to run the benchmarks on some other systems as well, PARMA <ref> [21] </ref> and Turbo Erlang [6] in particular, but we do not have access to those. 2 In all our performance tables, the second column identifies a variant of the system in question. <p> We therefore quite confident that Mercury will perform just as well on large programs. Mercury is the fastest system on all ten benchmarks, Aquarius with analysis and declarations is the next 3 Andrew Taylor, the author of PARMA <ref> [21] </ref>, has seen the C code generated by the Mercury compiler and the assembly code generated from that by gcc -O2. <p> Even then, we found them easy to code around, and found the resulting code to be easier to understand than the original. This is consistent with the experiences reported in [5] and <ref> [21] </ref>. We consider Mercury's limitations to be more than worthwhile considering the benefits they bring in terms of productivity, reliability, understandability, maintainability, and efficiency.
Reference: [22] <author> J. Thom and J. Zobel. </author> <title> NU-Prolog reference manual. </title> <type> Technical Report 86/10, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <year> 1986. </year>
Reference-contexts: It is essentially equivalent to the Mycroft-O'Keefe type system [13], and to the type system of Godel [9]. We borrow our syntax from the NU-Prolog <ref> [22] </ref> type checkers. The basic method of defining types is with declarations such as :- type bool ---&gt; true ; false. :- type list (T) ---&gt; [] ; [T | list (T)]. <p> Besides Mercury, we ran the benchmarks on five other logic programming languages: SWI-Prolog 1.9.0 [26], NU-Prolog 1.6.4 <ref> [22] </ref>, Quintus Pro-log 3.2, SICStus Prolog 2.1 [3] and Aquarius Prolog 1.0 [23]; these versions are the latest we have access to.
Reference: [23] <author> P. van Roy et al. </author> <title> High-performance logic programming with the Aquarius Prolog compiler. </title> <journal> IEEE Computer, </journal> <volume> 25(1) </volume> <pages> 54-68, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Besides Mercury, we ran the benchmarks on five other logic programming languages: SWI-Prolog 1.9.0 [26], NU-Prolog 1.6.4 [22], Quintus Pro-log 3.2, SICStus Prolog 2.1 [3] and Aquarius Prolog 1.0 <ref> [23] </ref>; these versions are the latest we have access to.
Reference: [24] <editor> P. Wadler. </editor> <booktitle> Linear types can change the world! In Proceedings of the IFIP TC2 Conference on Programming Concepts and Methods, </booktitle> <pages> pages 547-566, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Mercury's mode system therefore provides a concept called unique modes [8], analogous to linear types in functional programming <ref> [24] </ref>. Unique modes essentially allow the programmer to declare that there should be only one reference to a particular object, thus guaranteeing that the compiler will be able to optimize updates to that object.
Reference: [25] <author> D. H. D. Warren. </author> <title> An abstract Prolog instruction set. </title> <type> Technical Report 309, </type> <institution> SRI International, </institution> <address> Menlo Park, California, </address> <month> October </month> <year> 1983. </year>
Reference-contexts: Our design for all-solutions predicates is based on higher-order predicates. 4 Comparison with the WAM It is interesting to compare our execution model with the Warren Abstract Machine <ref> [1, 25] </ref>. We did not design the Mercury execution model by starting with the WAM and modifying it; we designed it from scratch.
Reference: [26] <author> J. Wielemaker. </author> <title> SWI-Prolog reference manual. </title> <type> Technical report, </type> <institution> Department of Social Science Informatics, University of Amsterdam, Netherlands, </institution> <year> 1993. </year>
Reference-contexts: Besides Mercury, we ran the benchmarks on five other logic programming languages: SWI-Prolog 1.9.0 <ref> [26] </ref>, NU-Prolog 1.6.4 [22], Quintus Pro-log 3.2, SICStus Prolog 2.1 [3] and Aquarius Prolog 1.0 [23]; these versions are the latest we have access to.
Reference: [27] <author> N.-F. Zhou. </author> <title> On the scheme of passing arguments in stack frames for Prolog. </title> <booktitle> In Proceedings of the Eleventh International Conference on Logic Programming, </booktitle> <pages> pages 159-174, </pages> <address> Santa Margherita Ligure, Italy, </address> <month> June </month> <year> 1994. </year> <month> 25 </month>
Reference-contexts: For predicates in the second class, the WAM looks marginally faster because its environments have only two fixed slots, CE and CP; however, our frames need not store unbound variables, so the total number of slots will be about the same. (The designers of NTOAM <ref> [27] </ref> also merge environments and choice points into one structure, but their technique and their motivation have little in common with ours.) Last call optimization is easier with the WAM.
References-found: 27

