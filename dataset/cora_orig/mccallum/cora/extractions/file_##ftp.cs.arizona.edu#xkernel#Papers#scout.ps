URL: file://ftp.cs.arizona.edu/xkernel/Papers/scout.ps
Refering-URL: http://www.cs.washington.edu/homes/romer/590lobo/index.html
Root-URL: 
Title: Scout: A Communications-Oriented Operating System  
Author: Allen B. Montz David Mosberger Sean W. O'Malley Larry L. Peterson Todd A. Proebsting John H. Hartman 
Address: Tucson, AZ 85721  
Affiliation: Department of Computer Science The University of Arizona  
Note: June  
Date: TR 94-20  17, 1994  
Abstract: This white paper describes Scout, a new operating system being designed for systems connected to the National Information Infrastructure (NII). Scout provides a communication-oriented software architecture for building operating system code that is specialized for the different systems that we expect to be available on the NII. It includes an explicit path abstraction that both facilitates effective resource management and permits optimizations of the critical path that I/O data follows. These path-enabled optimizations, along with the application of advanced compiler techniques, result in a system that has both predictable and scalable performance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. B. Abbott and L. L. Peterson. </author> <title> Increasing network throughput by integrating protocol layers. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(5) </volume> <pages> 600-610, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: Improving OS performance is the main reason to revisit the compiler issue. For example, our experience with protocol software shows that there is an opportunity for the compiler to automatically organize OS code so that it is more compatible with the memory architectures on modern RISC processors <ref> [1] </ref>. We have also found code patterns unique to operating systems, but not necessarily common in application-level code, that can be more heavily optimized [1]. Such optimizations are necessary if the operating system has any hope of staying on the processor performance curve. <p> there is an opportunity for the compiler to automatically organize OS code so that it is more compatible with the memory architectures on modern RISC processors <ref> [1] </ref>. We have also found code patterns unique to operating systems, but not necessarily common in application-level code, that can be more heavily optimized [1]. Such optimizations are necessary if the operating system has any hope of staying on the processor performance curve. Not only is the compiler a key to performance, but it is also an important tool for easing the task of the operating system implementor. <p> We have previously engineered a general mechanism for realizing the ILP strategy, and investigated its performance limits <ref> [1] </ref>. We plan to apply these results to Scout by providing a meta-tool that allows the various data manipulation tools we build to be integrated.
Reference: [2] <author> M. B. Abbott and L. L. Peterson. </author> <title> A language-based approach to protocol implementation. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(1) </volume> <pages> 4-19, </pages> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: For instance, the Synthesis Kernel [29] was able to generate highly optimized code sequences for reading and writing files tailored to dynamic information that was determined at file open time. Similarly, we have experimented with dynamic code generation for network protocols in Morpheous <ref> [2] </ref>. Scout will build on these two efforts. 3.2 Tools Scout defines a collection of tools that will be created by isolating small, well-defined types of operating system functionality. From several instances of a given type of functionality, we will generalize and create a specification language.
Reference: [3] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: A new kernel foundation for Unix development. </title> <booktitle> In Proceedings of the USENIX Summer '86 Conference, </booktitle> <month> July </month> <year> 1986. </year>
Reference-contexts: On the one hand, operating systems have become significantly more complex. We've gone from monolithic kernels (Unix [28]), to microkernels with OS servers in user tasks (Mach <ref> [3] </ref>), to microkernels with some of the servers put back in the kernel (OSF/1 MK 6.0, FLEX [10]), to extensible systems that support a late binding of exactly what services are provided and where they are implemented (Spring [24], Lipto [18]). <p> Using Scout, such systems 11 would then be able to schedule for worst case behavior that more closely tracks processor performance. Hopefully the differences between Scout and other recent experimental operating systems (e.g., Amoeba [32], V [12], Chorus [41], Mach <ref> [3] </ref>, QNX [26]) are obvious at this pointthey can all be traced to the difference between taking a communication-oriented perspective and a compute-oriented perspective. On the other hand, these two models are really duals of each other: compute-centric systems certainly support communication, and vice versa.
Reference: [4] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: A byproduct of this structure is that ultimately there is a long chain of procedure returns that serve only to unwind the call stack and hand control back to a routine waiting to do useful work. A last call optimization, which is common in functional and logic programming translators <ref> [4] </ref>, can be employed to minimize the overhead of this program structure. This will make it possible to avoid certain procedure call prologue and epilogue code, as well as the chain of jumps that occur at return time.
Reference: [5] <author> D. Bernstein and M. Rodeh. </author> <title> Global instruction scheduling for superscalar machines. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 241-255, </pages> <year> 1991. </year>
Reference-contexts: Moreover, multiple-instruction issue machines like the Alpha present difficult concerns about how to group instructions for simultaneous execution for optimal performance <ref> [5] </ref>. While instruction schedulers know how to handle RISC-style delayed-loads [40], scheduling for cache misses is not currently done well. A simple attack is to separate loads from the instructions consuming their values by at least as many cycles as a cache miss.
Reference: [6] <author> B. N. Bershad, C. Chambers, S. Eggers, C. Maeda, D. McNamee, P. Pardyak, S. Savage, and E. G. Sirer. </author> <title> SPIN: An extensible microkernel for application-specific operating system services. </title> <type> Technical Report 94-03-03, </type> <institution> Department of Computer Science, University of Washington, </institution> <month> Feb. </month> <year> 1994. </year> <month> 13 </month>
Reference-contexts: It concentrates on the former, leaving the latter to high-level, configurable software. Finally, we compare Scout with other new efforts to re-define the structure of the operating system. Three notable examples include Spring developed at Sun Labs [24], SPIN from the University of Washington <ref> [6] </ref>, and the Mach enhancements being done at the University of Utah [10, 21]. On one level, these efforts are complementary to ours: the resource allocation mechanisms, the software tools, and the compiler optimizations developed for Scout could be used in these other systems.
Reference: [7] <author> B. N. Bershad, D. D. Redell, and J. R. Ellis. </author> <title> Fast mutual exclusion for uniprocessors. </title> <booktitle> In 5th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 223-237, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: The partially executed atomic sequence could be rolled back to the beginning or it could be rolled forward to the end. After recovery, rollback will leave the system in a state that is as if the atomic sequence had not been executing at all <ref> [7] </ref>. On the other hand, rollforward will leave the system in a state that is as if the atomic sequence had been executed to the end already. Either solution guarantees atomicity.
Reference: [8] <author> G. Blair, A. Campbell, G. Coulson, D. Hutchinson, M. Papathomas, and P. Robin. </author> <title> On the imple-mentaiton of a quality of service controlled ATM based communicaitons system in Chorus. </title> <type> Technical Report MPG-94-11, </type> <institution> Lancaster University, </institution> <year> 1994. </year>
Reference-contexts: This C compiler had minor extensions, and except for showing some concern about callee-saved registers, does not duplicate any of the work described in this paper. In <ref> [8] </ref>, a set of quality of service extensions to the Chorus operating is described. These extensions are designed to allow incoming data streams to maintain the same kind of QoS guarantee in the host as provided by the network.
Reference: [9] <author> A. F. Brian N. Berhad, Richard P. Draves. </author> <title> Using microbenchmarks to evaluate system performance. </title> <booktitle> In Proc. Third Workshop on Workstation Operating Systems, </booktitle> <pages> pages 148-153, </pages> <address> Key Biscayne, FL (USA), </address> <month> Apr. </month> <year> 1992. </year> <note> IEEE. </note>
Reference-contexts: Finally, we have observed numerous cases where the performance of micro-benchmarks bear little relationship to the performance of the system as a whole, and in fact, optimizing a particular module is just as likely to hurt overall system performance as help it. Others have reported similar phenomena <ref> [9] </ref>. The bottom line is that OS performance will not scale until the OS is able to consistently take advantage of those very architectural features that are responsible for improved performancecaches and instruction pipelines.
Reference: [10] <author> J. Carter, B. Ford, M. Hiber, R. Kuramkote, J. Law, J. Lepreau, D. Orr, L. Stoller, and M. Swanson. </author> <title> Flex: A tool for building efficient and flexible systems. </title> <booktitle> In Proceedings of the Fourth IEEE Workshop on Workstation Operating Systems, </booktitle> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: On the one hand, operating systems have become significantly more complex. We've gone from monolithic kernels (Unix [28]), to microkernels with OS servers in user tasks (Mach [3]), to microkernels with some of the servers put back in the kernel (OSF/1 MK 6.0, FLEX <ref> [10] </ref>), to extensible systems that support a late binding of exactly what services are provided and where they are implemented (Spring [24], Lipto [18]). At the same time, machine architectures are becoming more sophisticated. <p> Finally, we compare Scout with other new efforts to re-define the structure of the operating system. Three notable examples include Spring developed at Sun Labs [24], SPIN from the University of Washington [6], and the Mach enhancements being done at the University of Utah <ref> [10, 21] </ref>. On one level, these efforts are complementary to ours: the resource allocation mechanisms, the software tools, and the compiler optimizations developed for Scout could be used in these other systems. On another level, however, there is an important difference in philosophy between Scout and these other systems.
Reference: [11] <author> J. B. Chen and B. Bershad. </author> <title> The impact of operating system structure on memory system performance. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: In the case of the data cache (D-cache), we found that only 5% of the message fragments brought into the cache when they are received are still there by the time the application is scheduled to run [37]; other studies have uncovered similar effects <ref> [11] </ref>. We also found that making the wrong branch prediction on a critical path can mean the difference between whether or not a real-time embedded system is able to live within its instruction budget [17].
Reference: [12] <author> D. R. Cheriton. </author> <title> The V distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 314-333, </pages> <month> Mar. </month> <year> 1988. </year>
Reference-contexts: Using Scout, such systems 11 would then be able to schedule for worst case behavior that more closely tracks processor performance. Hopefully the differences between Scout and other recent experimental operating systems (e.g., Amoeba [32], V <ref> [12] </ref>, Chorus [41], Mach [3], QNX [26]) are obvious at this pointthey can all be traced to the difference between taking a communication-oriented perspective and a compute-oriented perspective. On the other hand, these two models are really duals of each other: compute-centric systems certainly support communication, and vice versa.
Reference: [13] <author> D. D. Clark and D. L. Tennenhouse. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In Proceedings of the SIGCOMM '90 Symposium, </booktitle> <pages> pages 200-208, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: These functions are becoming more and more important as the gap between processor and memory speeds widens. Integrated layer processing (ILP) is a strategy that mitigates the cost of accessing network data multiple times <ref> [13] </ref>. The idea is to load each word of data once, perform all the computations required by the connection while the word remains in the CPU's registers, and then store the word back to memory.
Reference: [14] <author> J. Danskin. </author> <title> Higher bandwidth X. </title> <note> Submitted to ACM Multimedia 94. </note>
Reference-contexts: A recent study shows that compression algorithms that view network datain the case of this study, X-window messagesas a simple byte-stream, rarely achieve excellent compression rates <ref> [14] </ref>. The study reveals that compressing different message types separately (i.e., treating a mouse message differently from an image message) would help compression ratios.
Reference: [15] <author> P. Druschel, M. B. Abbott, M. Pagels, and L. L. Peterson. </author> <title> Network subsystem design. </title> <journal> IEEE Network (Special Issue on End-System Support for High Speed Networks), </journal> <volume> 7(4) </volume> <pages> 8-17, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Given this situation, it is little wonder that operating systems are not becoming faster as fast as processors are becoming faster [36]. Our experiences integrating the x-kernel into Mach illustrates the problem <ref> [15] </ref>. For example, we have protocol stacks that have no better latency on DECstation 5000 workstations than they did on Sun3 workstations, and changing the load order of the object modules in the system sometimes led to a 50% change in network software latency.
Reference: [16] <author> P. Druschel and L. L. Peterson. Fbufs: </author> <title> A high-bandwidth cross-domain transfer facility. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 189-202, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: We observe that there has recently been a trend in OS design to improve support for the implicit concept of a path, mostly for the sake of improving the performance of layered systems. For example, fbufs are a path-centric buffer management mechanism <ref> [16] </ref>, packet filters are a mechanism for determining which path an incoming packet belongs on [48], and two recent systems provide support for the thread operating on behalf of a path-like computation to migrate across protection boundaries [21, 24].
Reference: [17] <author> P. Druschel, L. L. Peterson, and B. S. Davie. </author> <title> Experience with a high-speed network adaptor: A software perspective. </title> <booktitle> In Proceedings of the SIGCOMM '94 Symposium, </booktitle> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: We also found that making the wrong branch prediction on a critical path can mean the difference between whether or not a real-time embedded system is able to live within its instruction budget <ref> [17] </ref>. Finally, we have observed numerous cases where the performance of micro-benchmarks bear little relationship to the performance of the system as a whole, and in fact, optimizing a particular module is just as likely to hurt overall system performance as help it. Others have reported similar phenomena [9].
Reference: [18] <author> P. Druschel, L. L. Peterson, and N. C. Hutchinson. </author> <title> Beyond micro-kernel design: Decoupling modularity and protection in Lipto. </title> <booktitle> In Proceedings of the Twelfth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 512-520, </pages> <address> Yokohama, Japan., </address> <month> June </month> <year> 1992. </year>
Reference-contexts: [28]), to microkernels with OS servers in user tasks (Mach [3]), to microkernels with some of the servers put back in the kernel (OSF/1 MK 6.0, FLEX [10]), to extensible systems that support a late binding of exactly what services are provided and where they are implemented (Spring [24], Lipto <ref> [18] </ref>). At the same time, machine architectures are becoming more sophisticated. Instruction pipelines are becoming deeper (making it increasingly difficult to avoid processor stalls), and the growing disparity between memory and processor speeds is making it increasingly important to make effective use of the cache.
Reference: [19] <author> D. R. Engler and T. A. Proebsting. </author> <title> DCG: An efficient, retargetable dynamic code generation system. </title> <booktitle> In International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: Furthermore, dynamic code generation must be efficient since the code generation time will be incurred by the executing program. Scout, therefore, includes a Dynamic Code Generator (DCG) that portably and efficiently generates executable code at run-time <ref> [19] </ref>. DCG client programs specify dynamically generated code using the compact, machine-independent intermediate representation (IR) of the lcc compiler [22]. The machine-independent intermediate representation specifies a small, but rich, set of operators that are sufficient to express all C language constructs at nearly a machine-level, without sacrificing portability.
Reference: [20] <author> G. Finn. </author> <title> An integration of network communication with workstation architecture. </title> <journal> Computer Communication Review, </journal> <volume> 21(5) </volume> <pages> 18-29, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: In addition, we plan to port Scout to different platforms, and demonstrate how it can be specialized for different applications: Network Devices: We will port Scout to the LANai boards being built for the NetStation system-area network <ref> [20] </ref>.
Reference: [21] <author> B. Ford and J. Lepreau. </author> <title> Evolving Mach 3.0 to use migrating threads. </title> <booktitle> In Winter 1994 Usenix Conference, </booktitle> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: For example, fbufs are a path-centric buffer management mechanism [16], packet filters are a mechanism for determining which path an incoming packet belongs on [48], and two recent systems provide support for the thread operating on behalf of a path-like computation to migrate across protection boundaries <ref> [21, 24] </ref>. <p> Finally, we compare Scout with other new efforts to re-define the structure of the operating system. Three notable examples include Spring developed at Sun Labs [24], SPIN from the University of Washington [6], and the Mach enhancements being done at the University of Utah <ref> [10, 21] </ref>. On one level, these efforts are complementary to ours: the resource allocation mechanisms, the software tools, and the compiler optimizations developed for Scout could be used in these other systems. On another level, however, there is an important difference in philosophy between Scout and these other systems.
Reference: [22] <author> C. W. Fraser and D. R. Hanson. </author> <title> A code generation interface for ANSI C. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 21(9) </volume> <pages> 963-988, </pages> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: Scout, therefore, includes a Dynamic Code Generator (DCG) that portably and efficiently generates executable code at run-time [19]. DCG client programs specify dynamically generated code using the compact, machine-independent intermediate representation (IR) of the lcc compiler <ref> [22] </ref>. The machine-independent intermediate representation specifies a small, but rich, set of operators that are sufficient to express all C language constructs at nearly a machine-level, without sacrificing portability. Binary code is selected and emitted using the BURS tree pattern-matching technology [39, 23].
Reference: [23] <author> C. W. Fraser, R. R. Henry, and T. A. Proebsting. </author> <title> BURG fast optimal instruction selection and tree parsing. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(4) </volume> <pages> 68-76, </pages> <month> Apr. </month> <year> 1991. </year> <month> 14 </month>
Reference-contexts: The machine-independent intermediate representation specifies a small, but rich, set of operators that are sufficient to express all C language constructs at nearly a machine-level, without sacrificing portability. Binary code is selected and emitted using the BURS tree pattern-matching technology <ref> [39, 23] </ref>. The code generation interface is small and easy to useclients specify expression trees for a desired chunk of code and DCG returns a function pointer callable from the client program.
Reference: [24] <author> G. Hamilton, M. L. Powell, and J. J. Mitchell. Subcontract: </author> <title> A flexible base for distributed programming. </title> <booktitle> In 14th Symposium on Operating System Principles, </booktitle> <pages> pages 69-79, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: For example, fbufs are a path-centric buffer management mechanism [16], packet filters are a mechanism for determining which path an incoming packet belongs on [48], and two recent systems provide support for the thread operating on behalf of a path-like computation to migrate across protection boundaries <ref> [21, 24] </ref>. <p> kernels (Unix [28]), to microkernels with OS servers in user tasks (Mach [3]), to microkernels with some of the servers put back in the kernel (OSF/1 MK 6.0, FLEX [10]), to extensible systems that support a late binding of exactly what services are provided and where they are implemented (Spring <ref> [24] </ref>, Lipto [18]). At the same time, machine architectures are becoming more sophisticated. Instruction pipelines are becoming deeper (making it increasingly difficult to avoid processor stalls), and the growing disparity between memory and processor speeds is making it increasingly important to make effective use of the cache. <p> It concentrates on the former, leaving the latter to high-level, configurable software. Finally, we compare Scout with other new efforts to re-define the structure of the operating system. Three notable examples include Spring developed at Sun Labs <ref> [24] </ref>, SPIN from the University of Washington [6], and the Mach enhancements being done at the University of Utah [10, 21].
Reference: [25] <author> J. H. Hartman and J. K. Ousterhout. </author> <title> The Zebra striped network file system. </title> <booktitle> In 14th Symposium on Operating System Principles, </booktitle> <pages> pages 29-43, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: In a conventional file system, the many paths into the cache are multiplexed onto the few paths out to the servers, but a single path in to the cache only connects to a single path out. In a striped file system like Zebra <ref> [25] </ref>, there will be one path out of the cache per storage server, so that a single path in to the cache will be connected to many paths out. In general, our goal is to build a toolkit of cache modules for Scout. <p> Here, Scout will be configured to support a video camera, and thus will encode, compress, and transmit video frames. 12 Scalable Storage Server: We will port Scout to a set of diskful workstations connected to a high-speed network, and configure them to stripe file data across the set of servers <ref> [25] </ref>. Cluster Computing: We will port Scout to a set of workstations connected by a high-speed network, and configure them to support the run-time system of the C fl data parallel language [45].
Reference: [26] <author> D. Hildebrand. </author> <title> An architectural overview of QNX. </title> <booktitle> In Proceedings of the Usenix Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: Using Scout, such systems 11 would then be able to schedule for worst case behavior that more closely tracks processor performance. Hopefully the differences between Scout and other recent experimental operating systems (e.g., Amoeba [32], V [12], Chorus [41], Mach [3], QNX <ref> [26] </ref>) are obvious at this pointthey can all be traced to the difference between taking a communication-oriented perspective and a compute-oriented perspective. On the other hand, these two models are really duals of each other: compute-centric systems certainly support communication, and vice versa.
Reference: [27] <author> N. C. Hutchinson and L. L. Peterson. </author> <title> The x-Kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: In the case of Scout, the focus is on communication, which requires support for varying degrees of reliability, security, mobility, and real-time. To support this diversity, Scout will draw heavily from a predecessor system, the x-kernel <ref> [27, 34] </ref>, in which network protocols define the fundamental building blocks from which the system is configured. Scout will go beyond the x-kernel in two ways. First, it will broaden the scope from network-specific to all communication-related functions, most notably, file access.
Reference: [28] <author> S. J. Leffler, M. K. McKusick, M. J. Karels, and J. S. Quarterman. </author> <title> The Design and Implementation of the 4.3BSD UNIX Operating System. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1989. </year>
Reference-contexts: On the one hand, operating systems have become significantly more complex. We've gone from monolithic kernels (Unix <ref> [28] </ref>), to microkernels with OS servers in user tasks (Mach [3]), to microkernels with some of the servers put back in the kernel (OSF/1 MK 6.0, FLEX [10]), to extensible systems that support a late binding of exactly what services are provided and where they are implemented (Spring [24], Lipto [18]).
Reference: [29] <author> H. Massalin. </author> <title> Synthesis: An Efficient Implementation of Fundamental Operating System Services. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <year> 1992. </year>
Reference-contexts: Scout will also use run-time code generation to generate highly optimized code for small sequences of critical path code. Run-time code generation is the creation of executable code by an executing process; it enables programs to create specialized instruction sequences based on runtime information. For instance, the Synthesis Kernel <ref> [29] </ref> was able to generate highly optimized code sequences for reading and writing files tailored to dynamic information that was determined at file open time. Similarly, we have experimented with dynamic code generation for network protocols in Morpheous [2]. <p> Individual ideas and techniques have already been cited where appropriate in the body of the paper. The use of run-time code generation in operating systems was explored in the Synthesis Kernel <ref> [29] </ref>, as were some of the techniques we plan to use to improve cache utilization. However, the Synthesis Kernel differs from Scout in that it was implemented entirely in assembler, and the cache optimizations were all done by hand.
Reference: [30] <author> S. McFarling. </author> <title> Program optimization for instruction caches. </title> <booktitle> In Third International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 183-191, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Second, the scattering of the critical path almost randomly through an address space increases the likelihood that two parts of the same path will compete for the same location in a direct mapped I-cache. In both cases, poor I-cache utilization hurts performance <ref> [30] </ref>. A final problem with hand-coded critical paths is that the compiler knows nothing about them, and because of this, cannot correctly predict branches or do optimal register allocation.
Reference: [31] <author> D. Mosberger, P. Druschel, and L. L. Peterson. </author> <title> Fast and general software solution to mutual exclusion on uniprocessors. </title> <type> Technical Report 94-07, </type> <institution> Department of Computer Science, University of Arizona, </institution> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: The classic uni-processor solution to lock-free synchronization is to disable interrupts while executing an atomic sequence. The drawback of this solution is that it requires manipulating a system's interrupt priority level while in privileged mode. Scout will use a novel synchronization technique <ref> [31] </ref> that is not only applicable throughout the OS (not just in privileged mode), but according to preliminary measurements on the Alpha platform, also performs significantly better than the classic technique of disabling interrupts.
Reference: [32] <author> S. J. Mullender, G. van Rossum, A. S. Tanebaum, R. van Renesse, and H. van Staveren. </author> <title> Amoeba: A distributed operating system for the 1990s. </title> <journal> IEEE Computer, </journal> <volume> 23(5) </volume> <pages> 44-53, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Using Scout, such systems 11 would then be able to schedule for worst case behavior that more closely tracks processor performance. Hopefully the differences between Scout and other recent experimental operating systems (e.g., Amoeba <ref> [32] </ref>, V [12], Chorus [41], Mach [3], QNX [26]) are obvious at this pointthey can all be traced to the difference between taking a communication-oriented perspective and a compute-oriented perspective.
Reference: [33] <author> NIST. </author> <title> R&D for the NII: </title> <type> Technical Challenges. </type> <address> Gaithersburg, MD, </address> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: In fact, a recent report on the NII rejects the term computer because of its emphasis on computation, and instead choses to call these systems information appliances that support communication, information storage, and user interactions <ref> [33] </ref>. We expect these information appliances to include video displays, cameras, Personal Digital Assists (PDAs), thermostats, and data servers, as well as more conventional compute servers and desktop workstations.
Reference: [34] <author> S. W. O'Malley and L. L. Peterson. </author> <title> A dynamic network architecture. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(2) </volume> <pages> 110-143, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: In the case of Scout, the focus is on communication, which requires support for varying degrees of reliability, security, mobility, and real-time. To support this diversity, Scout will draw heavily from a predecessor system, the x-kernel <ref> [27, 34] </ref>, in which network protocols define the fundamental building blocks from which the system is configured. Scout will go beyond the x-kernel in two ways. First, it will broaden the scope from network-specific to all communication-related functions, most notably, file access.
Reference: [35] <author> S. W. O'Malley, T. A. Proebsting, and A. B. Montz. </author> <title> Universal stub compiler. </title> <booktitle> In Proceedings of the SIGCOMM '94 Symposium, </booktitle> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: We have therefore designed and are implementing a new special-purpose stub compiler, called the Universal Stub Compiler (USC), that automatically generates stubs to convert a C data structure with one user-defined format to a C structure with another user-defined format <ref> [35] </ref>. USC is general enough to generate all byte swapping and alignment-sensitive code in Scout.
Reference: [36] <author> J. K. Ousterhout. </author> <title> Why aren't operating systems getting faster as fast as hardware? In Proc. </title> <booktitle> Summer 1990 USENIX Conf., </booktitle> <pages> pages 247-256, </pages> <address> Anaheim, CA (USA), June 1990. </address> <publisher> USENIX. </publisher>
Reference-contexts: Given this situation, it is little wonder that operating systems are not becoming faster as fast as processors are becoming faster <ref> [36] </ref>. Our experiences integrating the x-kernel into Mach illustrates the problem [15].
Reference: [37] <author> M. A. Pagels, P. Druschel, and L. L. Peterson. </author> <title> Analysis of cache and TLB effectiveness in processing network I/O. </title> <type> Technical Report 94-08, </type> <institution> Department of Computer Science, University of Arizona, </institution> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: In the case of the data cache (D-cache), we found that only 5% of the message fragments brought into the cache when they are received are still there by the time the application is scheduled to run <ref> [37] </ref>; other studies have uncovered similar effects [11]. We also found that making the wrong branch prediction on a critical path can mean the difference between whether or not a real-time embedded system is able to live within its instruction budget [17].
Reference: [38] <author> R. Pike, D. Presotto, K. Thompson, and H. Trickey. </author> <title> Plan 9 from Bell Labs. </title> <booktitle> In Proceedings UKUUG Conference, </booktitle> <month> July </month> <year> 1990. </year>
Reference-contexts: However, the Synthesis Kernel differs from Scout in that it was implemented entirely in assembler, and the cache optimizations were all done by hand. Scout will leverage both the compiler and the path abstraction to automate these techniques. The Plan 9 operating system <ref> [38] </ref> shares with Scout the characteristic of being implemented from scratch on a RISC processor, and like Scout, it involved the design of a new C compiler [43].
Reference: [39] <author> T. A. Proebsting. </author> <title> Simple and efficient BURS table generation. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 331-340, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The machine-independent intermediate representation specifies a small, but rich, set of operators that are sufficient to express all C language constructs at nearly a machine-level, without sacrificing portability. Binary code is selected and emitted using the BURS tree pattern-matching technology <ref> [39, 23] </ref>. The code generation interface is small and easy to useclients specify expression trees for a desired chunk of code and DCG returns a function pointer callable from the client program.
Reference: [40] <author> T. A. Proebsting and C. N. Fischer. </author> <title> Linear-time optimal code scheduling for delayed-load architectures. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 256-267, </pages> <month> June </month> <year> 1991. </year> <month> 15 </month>
Reference-contexts: Moreover, multiple-instruction issue machines like the Alpha present difficult concerns about how to group instructions for simultaneous execution for optimal performance [5]. While instruction schedulers know how to handle RISC-style delayed-loads <ref> [40] </ref>, scheduling for cache misses is not currently done well. A simple attack is to separate loads from the instructions consuming their values by at least as many cycles as a cache miss.
Reference: [41] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. Kaiser, S. Langlois, P. L eonard, and W. Neuhauser. </author> <title> Chorus distributed operating systems. </title> <journal> Computing Systems Journal, </journal> <volume> 1(4) </volume> <pages> 305-370, </pages> <month> Dec. </month> <year> 1988. </year>
Reference-contexts: Using Scout, such systems 11 would then be able to schedule for worst case behavior that more closely tracks processor performance. Hopefully the differences between Scout and other recent experimental operating systems (e.g., Amoeba [32], V [12], Chorus <ref> [41] </ref>, Mach [3], QNX [26]) are obvious at this pointthey can all be traced to the difference between taking a communication-oriented perspective and a compute-oriented perspective. On the other hand, these two models are really duals of each other: compute-centric systems certainly support communication, and vice versa.
Reference: [42] <author> R. L. </author> <title> Sites, editor. Alpha Architecture Reference Manual. </title> <publisher> Digital Press, </publisher> <address> Burlington, Massachusetts, </address> <year> 1992. </year> <title> Order number EY-L520E-DP. </title>
Reference-contexts: For example, Digital Equipment Corporation estimates that operating system code running on the DEC Alpha (21064) has a cache efficiency of 50%only half the instructions loaded into the I-cache are ever executed <ref> [42] </ref>. Second, the scattering of the critical path almost randomly through an address space increases the likelihood that two parts of the same path will compete for the same location in a direct mapped I-cache. In both cases, poor I-cache utilization hurts performance [30].
Reference: [43] <author> K. Thompson. </author> <title> A new c compiler. </title> <type> Technical report, </type> <institution> AT&T Bell Laboratories. </institution>
Reference-contexts: Scout will leverage both the compiler and the path abstraction to automate these techniques. The Plan 9 operating system [38] shares with Scout the characteristic of being implemented from scratch on a RISC processor, and like Scout, it involved the design of a new C compiler <ref> [43] </ref>. This C compiler had minor extensions, and except for showing some concern about callee-saved registers, does not duplicate any of the work described in this paper. In [8], a set of quality of service extensions to the Chorus operating is described.
Reference: [44] <author> H. Tokuda and T. Nakajima. </author> <title> Evaluation of real-time synchronization in real-time mach. </title> <booktitle> In USENIX Symposium Proceedings, </booktitle> <address> Monterey, Calif., </address> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: This work also does not attempt to schedule such low level hardware features as the cache or memory bus. Scout has definite application as an operating system for embedded and real-time systems. Although there are many examples of such systemsfor example, iRMX [46], RT-Mach <ref> [44] </ref>, and QNX [26]Scout's path abstraction provides the right specialized frameworkone tailored to support communicationto enable a configuration that can be easily and efficiently optimized.
Reference: [45] <author> C. J. Turner, D. Mosberger, and L. L. Peterson. </author> <title> Cluster-C fl : Understanding the performance limits. </title> <booktitle> In Proceedings of the Scalable High Performance Computing Conference, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Cluster Computing: We will port Scout to a set of workstations connected by a high-speed network, and configure them to support the run-time system of the C fl data parallel language <ref> [45] </ref>. Mobile Computing: We will port Scout to the P603 architecture (a low-power implementation of PowerPC) connected by wireless ethernet to demonstrate a distributed object system in a mobile environment. An important question is how we will evaluate the successes and failures of Scout.
Reference: [46] <author> C. Vickery. </author> <title> Real-Time and Systems Programming for PCs. </title> <publisher> McGraw-Hill, </publisher> <year> 1993. </year>
Reference-contexts: This work also does not attempt to schedule such low level hardware features as the cache or memory bus. Scout has definite application as an operating system for embedded and real-time systems. Although there are many examples of such systemsfor example, iRMX <ref> [46] </ref>, RT-Mach [44], and QNX [26]Scout's path abstraction provides the right specialized frameworkone tailored to support communicationto enable a configuration that can be easily and efficiently optimized.
Reference: [47] <author> R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In 14th Symposium on Operating System Principles, </booktitle> <pages> pages 203-216, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Similarly, rather than beginning with protection domains (tasks) as a primary abstraction, and trying to manage the flow of 4 I/O data across multiple domains, Scout starts with the path abstraction, and annotates it with zero or more fault-isolation boundaries <ref> [47] </ref> and zero or more privacy boundaries. The path abstraction provides the focal point for realizing the goals outlined in Section 2. First, paths define an infrastructure for composing together various collections of protocols to provide different communication services.
Reference: [48] <author> M. Yuhara, B. N. Bershad, C. Maeda, and J. E. Moss. </author> <title> Efficient packet demultiplexing for multiple endpoints and large messages. </title> <booktitle> In Winter 1994 Usenix Conference, </booktitle> <month> Jan. </month> <year> 1994. </year> <month> 16 </month>
Reference-contexts: For example, fbufs are a path-centric buffer management mechanism [16], packet filters are a mechanism for determining which path an incoming packet belongs on <ref> [48] </ref>, and two recent systems provide support for the thread operating on behalf of a path-like computation to migrate across protection boundaries [21, 24].
References-found: 48

