URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/phrensy/pub/papers/LeightonMS95.ps
Refering-URL: http://www.cs.cmu.edu/~bmm/papers.html
Root-URL: 
Title: ON THE FAULT TOLERANCE OF SOME POPULAR BOUNDED-DEGREE NETWORKS  
Author: F. THOMSON LEIGHTON BRUCE M. MAGGS AND RAMESH K. SITARAMAN 
Keyword: Key words. fault tolerance, network emulation, butterfly network  
Note: AMS subject classifications. 68M07, 68M10, 68M15, 68Q68  
Abstract: In this paper, we analyze the fault tolerance of several bounded-degree networks that are commonly used for parallel computation. Among other things, we show that an N-node butterfly network containing N 1* worst-case faults (for any constant * &gt; 0) can emulate a fault-free butterfly of the same size with only constant slowdown. The same result is proved for the shu*e-exchange network. Hence, these networks become the first connected bounded-degree networks known to be able to sustain more than a constant number of worst-case faults without suffering more than a constant-factor slowdown in performance. We also show that an N -node butterfly whose nodes fail with some constant probability p can emulate a fault-free network of the same type and size with a slowdown of 2 O(log fl N) . These emulation schemes combine the technique of redundant computation with new algorithms for routing packets around faults in hypercubic networks. We also present techniques for tolerating faults that do not rely on redundant computation. These techniques tolerate fewer faults but are more widely applicable because they can be used with other networks such as binary trees and meshes of trees. 1. Introduction. In this paper, we analyze the effect of faults on the computational power of bounded-degree networks such as the butterfly network, the shu*e-exchange network, and the mesh of trees. The main objective of our work is to devise 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. B. Adams, III and H. J. Siegel, </author> <title> The extra stage cube: A fault-tolerant interconnection network for supersystems, </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-31 (1982), </volume> <pages> pp. 443-454. </pages>
Reference: [2] <author> W. Aiello and T. Leighton, </author> <title> Coding theory, hypercube embeddings, and fault tolerance, </title> <booktitle> in Proceedings of the 3rd Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <month> July </month> <year> 1991, </year> <pages> pp. 125-136. </pages>
Reference-contexts: into an array of the same size containing more than a constant number of worst-case faults must have more than constant load, congestion, or dilation [22, 25, 31], and 2. the N -node hypercube can be reconfigured around log O (1) N worst-case faults with constant load, congestion, and dilation <ref> [2, 12] </ref>. The embeddings that we use in Section 2 are level-preserving, i.e., nodes in a particular level of the fault-free network are mapped to nodes on the same level of the faulty network. <p> with N 1* worst-case faults can emulate T steps of any normal algorithm [27] in O (T + log N ) time. (The set of normal algorithms include FFT, bitonic sort, and other important ascend-descend algorithms.) Previously, such results were known only for hypercubes containing log O (1) N faults <ref> [2, 12, 13] </ref>. Whether or not an N -node hypercube can tolerate more than log O (1) N faults with constant slowdown for general computations remains an important unresolved question. <p> Additional previous work. There is a substantial body of literature concerning the fault-tolerance of communication networks. We do not have the space to review all of this literature here, but we would like to cite the papers that are most relevant. In particular, <ref> [2, 5, 9, 14, 23, 24, 25, 35, 44, 52] </ref> show how to reconfigure a network with faults so that it can emulate a fault-free network of the same type and size. A fault-tolerant area-universal network is presented in [53].
Reference: [3] <author> W. A. Aiello, </author> <month> July </month> <year> 1992. </year> <type> Personal communication. </type>
Reference-contexts: Proof. The proof follows from Theorems 2.2 and 2.5. The results of this subsection can also be shown by using the fact that the butterfly and the mesh of trees can be expressed as the Layered Cross Product [18] of two complete binary trees (or variations thereof) <ref> [3] </ref>, and proving a theorem analogous to Theorem 2.5 for Layered Cross Product graphs. 2.3. Limitations of level-preserving embeddings. We do not know whether Theorems 2.2, 2.6, and 2.7 can be improved if the level-preserving constraint is removed.
Reference: [4] <author> M. Ajtai, N. Alon, J. Bruck, R. Cypher, C. T. Ho, M. Naor, and E. Szemer edi, </author> <title> Fault tolerant graphs, perfect hash functions and disjoint paths, </title> <booktitle> in Proceedings of the 33rd Annual Symposium on Foundations of Computer Science, </booktitle> <month> Oct. </month> <year> 1992, </year> <pages> pp. 693-702. </pages>
Reference-contexts: In particular, [2, 5, 9, 14, 23, 24, 25, 35, 44, 52] show how to reconfigure a network with faults so that it can emulate a fault-free network of the same type and size. A fault-tolerant area-universal network is presented in [53]. References <ref> [4, 10, 11, 16, 17] </ref> show how to design a network H that contains G as a subnetwork even if H contains some faults. Algorithms for routing messages around faults appear in [1, 6, 8, 15, 24, 25, 28, 34, 36, 41, 43, 44, 49].
Reference: [5] <author> F. Annexstein, </author> <title> Fault tolerance in hypercube-derivative networks, </title> <booktitle> in Proceedings of the 1989 ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <month> June </month> <year> 1989, </year> <pages> pp. 179-198. </pages>
Reference-contexts: Whether or not this result can be improved remains an interesting open question. Until recently, no results along these lines were known for the butterfly (unless routing is allowed through faulty nodes <ref> [5] </ref>, which simplifies matters substantially). Tamaki [51] has recently discovered an emulation scheme with slowdown O ((log log N ) 8:2 ). <p> Additional previous work. There is a substantial body of literature concerning the fault-tolerance of communication networks. We do not have the space to review all of this literature here, but we would like to cite the papers that are most relevant. In particular, <ref> [2, 5, 9, 14, 23, 24, 25, 35, 44, 52] </ref> show how to reconfigure a network with faults so that it can emulate a fault-free network of the same type and size. A fault-tolerant area-universal network is presented in [53].
Reference: [6] <author> S. Arora, T. Leighton, and B. Maggs, </author> <title> On-line algorithms for path selection in a non-blocking network, </title> <booktitle> in Proceedings of the 22nd Annual ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1990, </year> <pages> pp. 149-158. </pages>
Reference-contexts: The ability of the butterfly to withstand faults in this context is important because butterflies are often used solely for their routing abilities. Previously, it was known that expander-based multibutterfly networks can tolerate large numbers of worst-case faults without losing their routing powers <ref> [6, 28] </ref>, but no such results were known for butterflies or other hypercubic networks. A corollary of this result is that an N -input butterfly with N=12 worst-case faults can support an O (log N )-step randomized routing algorithm for a majority of its nodes.
Reference: [7] <author> S. Assaf and E. Upfal, </author> <title> Fault-tolerant sorting network, </title> <booktitle> in Proceedings of the 31st Annual Symposium on Foundations of Computer Science, </booktitle> <month> Oct. </month> <year> 1990, </year> <pages> pp. 275-284. </pages>
Reference-contexts: Algorithms for routing messages around faults appear in [1, 6, 8, 15, 24, 25, 28, 34, 36, 41, 43, 44, 49]. The fault-tolerance of sorting networks is studied in <ref> [7, 32] </ref>. Finally, [12, 56, 57] show how to perform certain computations in hypercubes containing faults. 1.5. Network definitions. In this section, we review the structure of some of the networks that we study in this paper.
Reference: [8] <author> Y. Aumann and M. Ben-Or, </author> <title> Asymptotically optimal PRAM emulation on faulty hypercubes, </title> <booktitle> in Proceedings of the 32nd Annual Symposium on Foundations of Computer Science, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> Oct. </month> <year> 1991, </year> <pages> pp. 440-457. </pages>
Reference: [9] <author> S. N. Bhatt, F. R. K. Chung, F. T. Leighton, and A. L. Rosenberg, </author> <title> Tolerating faults in synchronization networks, </title> <type> Technical Report 92-14, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA, </address> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: Additional previous work. There is a substantial body of literature concerning the fault-tolerance of communication networks. We do not have the space to review all of this literature here, but we would like to cite the papers that are most relevant. In particular, <ref> [2, 5, 9, 14, 23, 24, 25, 35, 44, 52] </ref> show how to reconfigure a network with faults so that it can emulate a fault-free network of the same type and size. A fault-tolerant area-universal network is presented in [53].
Reference: [10] <author> J. Bruck, R. Cypher, and C. Ho, </author> <title> Fault-tolerant meshes with minimal numbers of spares, </title> <booktitle> in Proceedings of the 3rd IEEE Symposium on Parallel and Distributed Processing, </booktitle> <month> Dec. </month> <year> 1991, </year> <pages> pp. </pages> <month> 288-295. </month> <title> [11] , Fault-tolerant meshes with small degree, </title> <booktitle> in Proceedings of the 5th Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <month> June </month> <year> 1993, </year> <pages> pp. 1-10. </pages>
Reference-contexts: In particular, [2, 5, 9, 14, 23, 24, 25, 35, 44, 52] show how to reconfigure a network with faults so that it can emulate a fault-free network of the same type and size. A fault-tolerant area-universal network is presented in [53]. References <ref> [4, 10, 11, 16, 17] </ref> show how to design a network H that contains G as a subnetwork even if H contains some faults. Algorithms for routing messages around faults appear in [1, 6, 8, 15, 24, 25, 28, 34, 36, 41, 43, 44, 49].
Reference: [12] <author> J. Bruck, R. Cypher, and D. Soroker, </author> <title> Running algorithms efficiently on faulty hyper-cubes, </title> <booktitle> in Proceedings of the 2nd Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <month> June </month> <year> 1990, </year> <pages> pp. </pages> <month> 37-44. </month> <title> [13] , Tolerating faults in hypercubes using subcube partitioning, </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41 (1992), </volume> <pages> pp. 599-605. </pages>
Reference-contexts: into an array of the same size containing more than a constant number of worst-case faults must have more than constant load, congestion, or dilation [22, 25, 31], and 2. the N -node hypercube can be reconfigured around log O (1) N worst-case faults with constant load, congestion, and dilation <ref> [2, 12] </ref>. The embeddings that we use in Section 2 are level-preserving, i.e., nodes in a particular level of the fault-free network are mapped to nodes on the same level of the faulty network. <p> with N 1* worst-case faults can emulate T steps of any normal algorithm [27] in O (T + log N ) time. (The set of normal algorithms include FFT, bitonic sort, and other important ascend-descend algorithms.) Previously, such results were known only for hypercubes containing log O (1) N faults <ref> [2, 12, 13] </ref>. Whether or not an N -node hypercube can tolerate more than log O (1) N faults with constant slowdown for general computations remains an important unresolved question. <p> Algorithms for routing messages around faults appear in [1, 6, 8, 15, 24, 25, 28, 34, 36, 41, 43, 44, 49]. The fault-tolerance of sorting networks is studied in [7, 32]. Finally, <ref> [12, 56, 57] </ref> show how to perform certain computations in hypercubes containing faults. 1.5. Network definitions. In this section, we review the structure of some of the networks that we study in this paper. In all of these networks, the edges are assumed to be undirected (or bidirectional).
Reference: [14] <author> R. Cole, B. Maggs, and R. Sitaraman, </author> <title> Multi-scale self-simulation: A technique for recon-figuring arrays with faults, </title> <booktitle> in Proceedings of the 25th Annual ACM Symposium on the Theory of Computing, </booktitle> <month> May </month> <year> 1993, </year> <pages> pp. </pages> <month> 561-572. </month> <title> [15] , Routing on butterfly networks with random faults, </title> <booktitle> in Proceedings of the 36th Annual Symposium on Foundations of Computer Science, </booktitle> <month> Oct. </month> <year> 1995, </year> <pages> pp. 558-570. </pages>
Reference-contexts: Additional previous work. There is a substantial body of literature concerning the fault-tolerance of communication networks. We do not have the space to review all of this literature here, but we would like to cite the papers that are most relevant. In particular, <ref> [2, 5, 9, 14, 23, 24, 25, 35, 44, 52] </ref> show how to reconfigure a network with faults so that it can emulate a fault-free network of the same type and size. A fault-tolerant area-universal network is presented in [53].
Reference: [16] <author> S. Dutt and J. P. Hayes, </author> <title> On designing and reconfiguring k-fault-tolerant tree architectures, </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-39 (1990), </volume> <pages> pp. </pages> <month> 490-503. </month> <title> [17] , Designing fault-tolerant systems using automorphisms, </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 12 (1991), </volume> <pages> pp. 249-268. </pages>
Reference-contexts: In particular, [2, 5, 9, 14, 23, 24, 25, 35, 44, 52] show how to reconfigure a network with faults so that it can emulate a fault-free network of the same type and size. A fault-tolerant area-universal network is presented in [53]. References <ref> [4, 10, 11, 16, 17] </ref> show how to design a network H that contains G as a subnetwork even if H contains some faults. Algorithms for routing messages around faults appear in [1, 6, 8, 15, 24, 25, 28, 34, 36, 41, 43, 44, 49].
Reference: [18] <author> S. Even and A. Litman, </author> <title> Layered Cross Product atechnique to construct interconnection networks, </title> <booktitle> in Proceedings of the 4th Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <month> July </month> <year> 1992, </year> <pages> pp. 60-69. </pages>
Reference-contexts: Proof. The proof follows from Theorems 2.2 and 2.5. The results of this subsection can also be shown by using the fact that the butterfly and the mesh of trees can be expressed as the Layered Cross Product <ref> [18] </ref> of two complete binary trees (or variations thereof) [3], and proving a theorem analogous to Theorem 2.5 for Layered Cross Product graphs. 2.3. Limitations of level-preserving embeddings. We do not know whether Theorems 2.2, 2.6, and 2.7 can be improved if the level-preserving constraint is removed.
Reference: [19] <author> M. R. Fellows, </author> <title> Encoding Graphs in Graphs, </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of California, </institution> <address> San Diego, CA, </address> <year> 1985. </year>
Reference-contexts: This technique was previously used in the context of (fault-free) work-preserving emulations of one network by another <ref> [19, 26, 38, 39, 40, 47] </ref>. The techniques developed in Section 4 also have applications for hypercubes.
Reference: [20] <author> D. S. Greenberg, L. S. Heath, and A. L. Rosenberg, </author> <title> Optimal embeddings of butterfly-like graphs in the hypercube, </title> <journal> Mathematical Systems Theory, </journal> <volume> 23 (1990), </volume> <pages> pp. 61-77. </pages>
Reference-contexts: We state a result due to Schwabe [48] to this effect. Lemma 4.6. An N -node butterfly can emulate any normal algorithm of an N - node hypercube with constant slowdown. We also require the following well known result concerning the embedding of a butterfly in a hypercube. (See <ref> [20] </ref> for the stronger result that the butterfly is a subgraph of the hypercube). Lemma 4.7. An N -node butterfly can be embedded in an N -node hypercube with constant load, congestion, and dilation. Theorem 4.8.
Reference: [21] <author> R. I. Greenberg and C. E. Leiserson, </author> <title> Randomized routing on fat-trees, </title> <booktitle> in Randomness and Computation.Volume 5 of Advances in Computing Research, </booktitle> <editor> S. Micali, ed., </editor> <publisher> JAI Press, </publisher> <address> Greenwich, CT, </address> <year> 1989, </year> <pages> pp. 345-374. </pages>
Reference-contexts: We first consider embedding a complete binary tree in a complete binary tree with faults only at its leaves. This result also holds for fat-trees <ref> [21, 33] </ref> with faults at the leaves. We use this result to find reconfigurations of butterflies and meshes of trees in which faults may occur at any node. <p> In this figure, the root has four subtrees, as do the roots of these subtrees. Hence the figure shows a 4-ary fat-tree. This fat-tree was chosen for the figure because a fat-tree of this form has been shown to be area-universal <ref> [33, 21, 30] </ref>. Corollary 2.3 is stated for binary fat-trees (i.e., fat-trees in which the root has two subtrees), but similar results can be proven for 4-ary fat-trees. Corollary 2.3.
Reference: [22] <author> J. W. Greene and A. El Gamal, </author> <title> Configuration of VLSI arrays in the presence of defects, </title> <journal> Journal of the ACM, </journal> <volume> 31 (1984), </volume> <pages> pp. 694-717. </pages> <note> 30 F. </note> <author> T. LEIGHTON AND B. M. MAGGS AND R. K. </author> <note> SITARAMAN </note>
Reference-contexts: Indeed, it was only known that 1. any embedding of an N -node (2 or 3-dimensional) array into an array of the same size containing more than a constant number of worst-case faults must have more than constant load, congestion, or dilation <ref> [22, 25, 31] </ref>, and 2. the N -node hypercube can be reconfigured around log O (1) N worst-case faults with constant load, congestion, and dilation [2, 12].
Reference: [23] <author> J. Hastad, T. Leighton, and M. Newman, </author> <title> Reconfiguring a hypercube in the presence of faults, </title> <booktitle> in Proceedings of the 19th Annual ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1987, </year> <pages> pp. </pages> <month> 274-284. </month> <title> [24] , Fast computation using faulty hypercubes, </title> <booktitle> in Proceedings of the 21st Annual ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1989, </year> <pages> pp. 251-263. </pages>
Reference-contexts: Additional previous work. There is a substantial body of literature concerning the fault-tolerance of communication networks. We do not have the space to review all of this literature here, but we would like to cite the papers that are most relevant. In particular, <ref> [2, 5, 9, 14, 23, 24, 25, 35, 44, 52] </ref> show how to reconfigure a network with faults so that it can emulate a fault-free network of the same type and size. A fault-tolerant area-universal network is presented in [53].
Reference: [25] <author> C. Kaklamanis, A. R. Karlin, F. T. Leighton, V. Milenkovic, P. Raghavan, S. Rao, C. Thomborson, and A. Tsantilas, </author> <title> Asymptotically tight bounds for computing with faulty arrays of processors, </title> <booktitle> in Proceedings of the 31st Annual Symposium on Foundations of Computer Science, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> Oct. </month> <year> 1990, </year> <pages> pp. 285-296. </pages>
Reference-contexts: Indeed, it was only known that 1. any embedding of an N -node (2 or 3-dimensional) array into an array of the same size containing more than a constant number of worst-case faults must have more than constant load, congestion, or dilation <ref> [22, 25, 31] </ref>, and 2. the N -node hypercube can be reconfigured around log O (1) N worst-case faults with constant load, congestion, and dilation [2, 12]. <p> Additional previous work. There is a substantial body of literature concerning the fault-tolerance of communication networks. We do not have the space to review all of this literature here, but we would like to cite the papers that are most relevant. In particular, <ref> [2, 5, 9, 14, 23, 24, 25, 35, 44, 52] </ref> show how to reconfigure a network with faults so that it can emulate a fault-free network of the same type and size. A fault-tolerant area-universal network is presented in [53].
Reference: [26] <author> R. Koch, T. Leighton, B. Maggs, S. Rao, and A. Rosenberg, </author> <title> Work-preserving emulations of fixed-connection networks, </title> <booktitle> in Proceedings of the 21st Annual ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1989, </year> <pages> pp. 227-240. </pages>
Reference-contexts: This technique was previously used in the context of (fault-free) work-preserving emulations of one network by another <ref> [19, 26, 38, 39, 40, 47] </ref>. The techniques developed in Section 4 also have applications for hypercubes.
Reference: [27] <author> F. T. Leighton, </author> <title> Introduction to Parallel Algorithms and Architectures: Arrays * Trees * Hypercubes, </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference-contexts: The techniques developed in Section 4 also have applications for hypercubes. For example, in Section 4.4, we use them to show than an N -node hypercube with N 1* worst-case faults can emulate T steps of any normal algorithm <ref> [27] </ref> in O (T + log N ) time. (The set of normal algorithms include FFT, bitonic sort, and other important ascend-descend algorithms.) Previously, such results were known only for hypercubes containing log O (1) N faults [2, 12, 13]. <p> An N fi N mesh of trees network <ref> [27] </ref>, is formed by first arranging N 2 nodes (but no edges) in a grid of N rows and N columns. Then for each row, an N -leaf complete binary tree, called a row tree, is added. The leaves of the row tree are the nodes of the corresponding row. <p> A useful subclass of leveled algorithms are normal algorithms. A normal algorithm has the additional restriction that the dimensions used in consecutive time steps are consecutive. Many algorithms such including bitonic sort, FFT, and tree-based algorithms like branch-and-bound can be implemented on the hypercube as normal algorithms <ref> [27] </ref>. An additional property of normal algorithms is that they can be emulated efficiently by bounded-degree networks such as the shu*e-exchange network and the butterfly. We state a result due to Schwabe [48] to this effect. Lemma 4.6.
Reference: [28] <author> F. T. Leighton and B. M. Maggs, </author> <title> Fast algorithms for routing around faults in multibutter-flies and randomly-wired splitter networks, </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41 (1992), </volume> <pages> pp. 578-587. </pages>
Reference-contexts: The ability of the butterfly to withstand faults in this context is important because butterflies are often used solely for their routing abilities. Previously, it was known that expander-based multibutterfly networks can tolerate large numbers of worst-case faults without losing their routing powers <ref> [6, 28] </ref>, but no such results were known for butterflies or other hypercubic networks. A corollary of this result is that an N -input butterfly with N=12 worst-case faults can support an O (log N )-step randomized routing algorithm for a majority of its nodes. <p> The same result (without the high probability caveat) was previously shown for the expander-based multibutterfly network <ref> [28] </ref>. A special case of this result is that when f N=12 we can route arbitrary permutations between a majority of nodes in the butterfly. Note that this is optimal within constant factors since N faults on level (log N )=2 partitions the butterfly into many disjoint small connected components.
Reference: [29] <author> F. T. Leighton, B. M. Maggs, A. G. Ranade, and S. B. Rao, </author> <title> Randomized routing and sorting on fixed-connection networks, </title> <journal> Journal of Algorithms, </journal> <volume> 17 (1994), </volume> <pages> pp. 157-205. </pages>
Reference-contexts: In networks such as the butterfly with O (log N ) levels, as long as the (leveled) paths of the packets have congestion O (log N ), a Ranade-type queuing protocol can be used to route the packets in O (log N ) steps using constant-size queues, with high probability <ref> [29] </ref>. Therefore it is sufficient to derive high probabilty bounds on the congestion of the paths in a routing scheme. Our goal is to identify a large set of "good" nodes in a faulty butterfly between which we can route permutations using an algorithm like Valiant's. <p> The choice is made by consulting a table of all such m 00 . Lemma 3.2 shows that, with high probability, these paths have congestion O (log N ). Finally, once the paths are selected, the algorithm for routing on leveled networks <ref> [29] </ref> can be applied to deliver the packets in O (log N ) steps using constant-size queues, with high probability. 3.1.1. Packet routing without routing tables. <p> The analysis for Stage 2 is similar. Thus we have shown that ON THE FAULT TOLERANCE OF SOME POPULAR BOUNDED-DEGREE NETWORKS17 if the inductive hypothesis is true, the congestion of any node is O (log N ) with high probability. Therefore, using the algorithm for routing on leveled networks <ref> [29] </ref> to schedule the packets, the routing completes in C log N steps with probability at least 12=AN k+2 , for an appropriate constant C. The ACKs follow the paths of the packets in the reverse direction.
Reference: [30] <author> F. T. Leighton, B. M. Maggs, and S. B. Rao, </author> <title> Packet routing and job-shop scheduling in O(congestion + dilation) steps, </title> <journal> Combinatorica, </journal> <volume> 14 (1994), </volume> <pages> pp. 167-180. </pages>
Reference-contexts: The load, congestion, and dilation of the embedding determine the time required to emulate each step of G on H. In particular, Leighton, Maggs, and Rao have shown <ref> [30] </ref> that if there is an embedding of G in H with load l, congestion c, and dilation d, then H can emulate any computation on G with slowdown O (l + c + d). <p> In this figure, the root has four subtrees, as do the roots of these subtrees. Hence the figure shows a 4-ary fat-tree. This fat-tree was chosen for the figure because a fat-tree of this form has been shown to be area-universal <ref> [33, 21, 30] </ref>. Corollary 2.3 is stated for binary fat-trees (i.e., fat-trees in which the root has two subtrees), but similar results can be proven for 4-ary fat-trees. Corollary 2.3.
Reference: [31] <author> T. Leighton and C. E. Leiserson, </author> <title> Wafer-scale integration of systolic arrays, </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-34 (1985), </volume> <pages> pp. 448-461. </pages>
Reference-contexts: Indeed, it was only known that 1. any embedding of an N -node (2 or 3-dimensional) array into an array of the same size containing more than a constant number of worst-case faults must have more than constant load, congestion, or dilation <ref> [22, 25, 31] </ref>, and 2. the N -node hypercube can be reconfigured around log O (1) N worst-case faults with constant load, congestion, and dilation [2, 12].
Reference: [32] <author> T. Leighton, Y. Ma, and C. G. Plaxton, </author> <title> Highly fault-tolerant sorting circuits, </title> <booktitle> in Proceedings of the 32nd Annual Symposium on Foundations of Computer Science, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> Oct. </month> <year> 1991, </year> <pages> pp. 458-469. </pages>
Reference-contexts: Algorithms for routing messages around faults appear in [1, 6, 8, 15, 24, 25, 28, 34, 36, 41, 43, 44, 49]. The fault-tolerance of sorting networks is studied in <ref> [7, 32] </ref>. Finally, [12, 56, 57] show how to perform certain computations in hypercubes containing faults. 1.5. Network definitions. In this section, we review the structure of some of the networks that we study in this paper.
Reference: [33] <author> C. E. Leiserson, Fat-trees: </author> <title> universal networks for hardware-efficient supercomputing, </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-34 (1985), </volume> <pages> pp. 892-901. </pages>
Reference-contexts: We first consider embedding a complete binary tree in a complete binary tree with faults only at its leaves. This result also holds for fat-trees <ref> [21, 33] </ref> with faults at the leaves. We use this result to find reconfigurations of butterflies and meshes of trees in which faults may occur at any node. <p> In this figure, the root has four subtrees, as do the roots of these subtrees. Hence the figure shows a 4-ary fat-tree. This fat-tree was chosen for the figure because a fat-tree of this form has been shown to be area-universal <ref> [33, 21, 30] </ref>. Corollary 2.3 is stated for binary fat-trees (i.e., fat-trees in which the root has two subtrees), but similar results can be proven for 4-ary fat-trees. Corollary 2.3.
Reference: [34] <author> G. Lin, </author> <title> Fault tolerant planar communication networks, </title> <booktitle> in Proceedings of the 24th Annual ACM Symposium on the Theory of Computing, </booktitle> <month> May </month> <year> 1992, </year> <pages> pp. 133-139. </pages>
Reference: [35] <author> M. Livingston, Q. Stout, N. Graham, and F. Hararay, </author> <title> Subcube fault-tolerance in hy-percubes, </title> <type> Technical Report CRL-TR-12-87, </type> <institution> University of Michigan Computing Research Laboratory, </institution> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: Additional previous work. There is a substantial body of literature concerning the fault-tolerance of communication networks. We do not have the space to review all of this literature here, but we would like to cite the papers that are most relevant. In particular, <ref> [2, 5, 9, 14, 23, 24, 25, 35, 44, 52] </ref> show how to reconfigure a network with faults so that it can emulate a fault-free network of the same type and size. A fault-tolerant area-universal network is presented in [53].
Reference: [36] <author> Y. Lyuu, </author> <title> Fast fault-tolerant parallel communication and on-line maintenance using information dispersal, </title> <booktitle> in Proceedings of the 2nd Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <month> July </month> <year> 1990, </year> <pages> pp. 378-387. </pages>
Reference: [37] <author> B. M. Maggs and R. K. Sitaraman, </author> <title> Simple algorithms for routing on butterfly networks with bounded queues, </title> <booktitle> in Proceedings of the 24th Annual ACM Symposium on the Theory of Computing, </booktitle> <month> May </month> <year> 1992, </year> <pages> pp. 150-161. </pages>
Reference-contexts: In this section we show how to route packets in an N -input butterfly network with f worst-case faults. In particular, we focus on the problem of routing packets between the nodes of the network in a one-to-one fashion. This type of routing is also called permutation routing. (See <ref> [37] </ref> for references to permutation routing algorithms). In a permutation routing problem, every node is the origin of at most one packet and the destination of at most one packet.
Reference: [38] <editor> F. Meyer auf der Heide, </editor> <title> Efficiency of universal parallel computers, </title> <journal> Acta Informatica, </journal> <volume> 19 (1983), </volume> <pages> pp. </pages> <month> 269-296. </month> <title> [39] , Efficient simulations among several models of parallel computers, </title> <journal> SIAM Journal on Computing, </journal> <volume> 15 (1986), </volume> <pages> pp. 106-119. </pages>
Reference-contexts: This technique was previously used in the context of (fault-free) work-preserving emulations of one network by another <ref> [19, 26, 38, 39, 40, 47] </ref>. The techniques developed in Section 4 also have applications for hypercubes.
Reference: [40] <editor> F. Meyer auf der Heide and R. </editor> <title> Wanka, Time-optimal simulations of networks by universal parallel computers, </title> <booktitle> in Proceedings of the 6th Symposium on Theoretical Aspects of Computer Science, </booktitle> <year> 1989, </year> <pages> pp. 120-131. </pages>
Reference-contexts: This technique was previously used in the context of (fault-free) work-preserving emulations of one network by another <ref> [19, 26, 38, 39, 40, 47] </ref>. The techniques developed in Section 4 also have applications for hypercubes.
Reference: [41] <author> D. C. Opferman and N. T. Tsao-Wu, </author> <title> On a class of rearrangeable switching networks-part II: Enumeration studies and fault diagnosis, </title> <journal> Bell System Technical Journal, </journal> <volume> 50 (1971), </volume> <pages> pp. 1601-1618. </pages>
Reference-contexts: This result substantially improves upon previous algorithms for fault-tolerant circuit switching in Benes networks <ref> [41, 49] </ref> which dealt with a constant number of faults by adding an extra stage to the network. 1.3. Emulations using redundant computation.
Reference: [42] <author> N. Pippenger, </author> <title> Telephone switching networks, </title> <booktitle> in Proceedings of Symposia in Applied Mathematics, </booktitle> <volume> vol. 26, </volume> <publisher> American Mathematical Society, </publisher> <year> 1982, </year> <pages> pp. 101-133. </pages>
Reference-contexts: The result is a 2-regular N fi N bipartite graph. The second step is to split the edges of this graph into two perfect matchings, M 0 and M 1 . (See <ref> [42] </ref> for a nice proof that such a split is possible.) Next, we pick a binary value for random variable X at random.
Reference: [43] <author> N. Pippenger and G. Lin, </author> <title> Fault-tolerant circuit-switching networks, </title> <booktitle> in Proceedings of the 4th Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <month> June </month> <year> 1992, </year> <pages> pp. 229-235. </pages>
Reference: [44] <author> M. O. Rabin, </author> <title> Efficient dispersal of information for security, load balancing, and fault tolerance, </title> <journal> Journal of the ACM, </journal> <month> 36 </month> <year> (1989). </year>
Reference-contexts: Additional previous work. There is a substantial body of literature concerning the fault-tolerance of communication networks. We do not have the space to review all of this literature here, but we would like to cite the papers that are most relevant. In particular, <ref> [2, 5, 9, 14, 23, 24, 25, 35, 44, 52] </ref> show how to reconfigure a network with faults so that it can emulate a fault-free network of the same type and size. A fault-tolerant area-universal network is presented in [53].
Reference: [45] <author> P. Raghavan, </author> <title> Probabilistic construction of deterministic algorithms: approximate packing integer programs, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 37 (1988), </volume> <pages> pp. 130-143. </pages> <note> [46] , Lecture notes on randomized algorithms, Research Report RC 15340 (#68237), </note> <institution> IBM Research Division, T.J. Watson Research Center, </institution> <address> Yorktown Heights, NY, </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: Derandomizing RANDSET. In the proof of Theorem 3.7, we show the existence of edge-disjoint paths by using the fact that algorithm RANDSET finds them with non-zero probability. In this section we construct a deterministic algorithm that finds these paths using the technique due to Raghavan <ref> [45] </ref> and Spencer [50] to remove the randomness. Like Waksman's algorithm for finding the switch settings in a fault-free Benes network with N input switches, the algorithm runs in O (N log N ) time.
Reference: [47] <author> E. J. Schwabe, </author> <title> On the computational equivalence of hypercube-derived networks, </title> <booktitle> in Proceedings of the 2nd Annual ACM Symposium on Parallel Algorithms and Architectures, July ON THE FAULT TOLERANCE OF SOME POPULAR BOUNDED-DEGREE NETWORKS31 1990, </booktitle> <pages> pp. </pages> <month> 388-397. </month> <title> [48] , Efficient Embeddings and Simulations for Hypercubic Networks, </title> <type> PhD thesis, </type> <institution> Department of Mathematics, Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: This technique was previously used in the context of (fault-free) work-preserving emulations of one network by another <ref> [19, 26, 38, 39, 40, 47] </ref>. The techniques developed in Section 4 also have applications for hypercubes. <p> Thus, the extra path length of 4 log N can be amortized over (* log N )=4 s-pebbles. Hence, T 0 = P We can extend these results to the shu*e-exchange network using Schwabe's proof <ref> [47] </ref> that an N -node butterfly can emulate an N -node shu*e-exchange network with constant slowdown, and vice versa. Theorem 4.5. <p> Theorem 4.5. Any computation on a fault-free N -node shu*e-exchange network G that takes time T can be emulated in O (T + log N ) time by an N -node shu*e-exchange network H with N 1* worst-case faults, for any constant * &gt; 0. Proof. Schwabe <ref> [47] </ref> shows how to emulate any computation of a butterfly on a shu*e-exchange network with constant slowdown and vice versa. First we use Schwabe's result to map the computation of a butterfly B to the faulty shu*e-exchange network H.
Reference: [49] <author> S. Sowrirajan and S. M. Reddy, </author> <title> A design for fault-tolerant full connection networks, </title> <booktitle> in Proceedings of the International Conference on Science and Systems, </booktitle> <month> Mar. </month> <year> 1980, </year> <pages> pp. 536-540. </pages>
Reference-contexts: This result substantially improves upon previous algorithms for fault-tolerant circuit switching in Benes networks <ref> [41, 49] </ref> which dealt with a constant number of faults by adding an extra stage to the network. 1.3. Emulations using redundant computation.
Reference: [50] <author> J. Spencer, </author> <title> Ten Lectures on the Probabilistic Method, </title> <publisher> SIAM, </publisher> <address> Philadelphia, PA, </address> <year> 1987. </year>
Reference-contexts: Derandomizing RANDSET. In the proof of Theorem 3.7, we show the existence of edge-disjoint paths by using the fact that algorithm RANDSET finds them with non-zero probability. In this section we construct a deterministic algorithm that finds these paths using the technique due to Raghavan [45] and Spencer <ref> [50] </ref> to remove the randomness. Like Waksman's algorithm for finding the switch settings in a fault-free Benes network with N input switches, the algorithm runs in O (N log N ) time.
Reference: [51] <author> H. Tamaki, </author> <title> Efficient self-embedding of butterfly networks with random faults, </title> <booktitle> in Proceedings of the 33rd Annual Symposium on Foundations of Computer Science, </booktitle> <month> Oct. </month> <year> 1992. </year> <month> 533-541. </month> <title> [52] , Robust bounded-degree networks with small diameters, </title> <booktitle> in Proceedings of the 4th Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <month> June </month> <year> 1992, </year> <pages> pp. 247-256. </pages>
Reference-contexts: Whether or not this result can be improved remains an interesting open question. Until recently, no results along these lines were known for the butterfly (unless routing is allowed through faulty nodes [5], which simplifies matters substantially). Tamaki <ref> [51] </ref> has recently discovered an emulation scheme with slowdown O ((log log N ) 8:2 ). <p> Furthermore, for k = O (log fl N ) the node failure probability, p, is constant, and the slowdown is 2 O (log fl N) . Previously, the most efficient self-emulation scheme known for an N -input butterfly required !(log log N ) slowdown <ref> [51] </ref>. The proof has the following outline. We begin by showing that the host, H, can emulate another N -input butterfly network B k with constant slowdown.
Reference: [53] <author> S. Toledo, </author> <title> Competitive fault-tolerance in area-universal networks, </title> <booktitle> in Proceedings of the 4th Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <month> June </month> <year> 1992, </year> <pages> pp. 236-246. </pages>
Reference-contexts: In particular, [2, 5, 9, 14, 23, 24, 25, 35, 44, 52] show how to reconfigure a network with faults so that it can emulate a fault-free network of the same type and size. A fault-tolerant area-universal network is presented in <ref> [53] </ref>. References [4, 10, 11, 16, 17] show how to design a network H that contains G as a subnetwork even if H contains some faults. Algorithms for routing messages around faults appear in [1, 6, 8, 15, 24, 25, 28, 34, 36, 41, 43, 44, 49].
Reference: [54] <author> L. G. Valiant, </author> <title> A scheme for fast parallel communication, </title> <journal> SIAM Journal on Computing, </journal> <volume> 11 (1982), </volume> <pages> pp. 350-361. </pages>
Reference-contexts: The embedding has load 4, congestion 4, and dilation 1. We start by describing Valiant's algorithm <ref> [54] </ref> for permutation routing on a butterfly without faults.
Reference: [55] <author> A. Waksman, </author> <title> A permutation network, </title> <journal> Journal of the ACM, </journal> <volume> 15 (1968), </volume> <pages> pp. 159-163. </pages>
Reference-contexts: The same is true for paths that end on output edges that share the same output switch. A full permutation consists of a set of 2N input-output pairs to be connected by edge-disjoint paths. The standard algorithm for setting the switches in a Benes network, due to Waksman <ref> [55] </ref>, uses bipartite graph matching to split the set of 2N pairs into two sets of N pairs which are each then routed recursively in one of the smaller sub-Benes networks. We now present Waksman's algorithm with a twist. We call this algorithm RAND-SET (for RANDom switch SETting).
Reference: [56] <author> A. Wang and R. Cypher, </author> <title> Fault-tolerant embeddings of rings, meshes and tori in hypercubes, </title> <type> Technical Report IBM RJ 8569, </type> <institution> IBM Almaden Research Center, </institution> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: Algorithms for routing messages around faults appear in [1, 6, 8, 15, 24, 25, 28, 34, 36, 41, 43, 44, 49]. The fault-tolerance of sorting networks is studied in [7, 32]. Finally, <ref> [12, 56, 57] </ref> show how to perform certain computations in hypercubes containing faults. 1.5. Network definitions. In this section, we review the structure of some of the networks that we study in this paper. In all of these networks, the edges are assumed to be undirected (or bidirectional).
Reference: [57] <author> A. Wang, R. Cypher, and E. Mayr, </author> <title> Embedding complete binary trees in faulty hypercubes, </title> <booktitle> in Proceedings of the 3rd IEEE Symposium on Parallel and Distributed Processing, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> Dec. </month> <year> 1991, </year> <pages> pp. 112-119. </pages>
Reference-contexts: Algorithms for routing messages around faults appear in [1, 6, 8, 15, 24, 25, 28, 34, 36, 41, 43, 44, 49]. The fault-tolerance of sorting networks is studied in [7, 32]. Finally, <ref> [12, 56, 57] </ref> show how to perform certain computations in hypercubes containing faults. 1.5. Network definitions. In this section, we review the structure of some of the networks that we study in this paper. In all of these networks, the edges are assumed to be undirected (or bidirectional).
References-found: 48

