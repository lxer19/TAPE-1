URL: http://shangrila.cs.ucdavis.edu:1234/silo/LNCS780.ps
Refering-URL: http://shangrila.cs.ucdavis.edu:1234/silo/
Root-URL: http://www.cs.ucdavis.edu
Email: email: zhang@cs.ucdavis.edu, verification-lab@cs.ucdavis.edu  
Title: Mechanizing a Programming Logic for the Concurrent Programming Language microSR in HOL  
Author: Cui Zhang, Rob Shaw, Ronald A. Olsson, Karl Levitt, Myla Archer, Mark R. Heckman and Gregory D. Benson 
Address: CA 95616  
Affiliation: Department of Computer Science University of California, Davis,  
Abstract: This paper presents our current effort to formally derive, using HOL, a sound Hoare logic for the concurrent programming language microSR, a derivative of SR. Our methodology is built on Gordon's work on mechanizing programming logics for a small sequential programming language. The constructs of microSR include those basic to common sequential programming languages, in addition to an asynchronous send statement, a synchronous receive statement, a guarded communication input statement, and a co statement for specifying concurrent execution. This language has the appearance of a high-level system programming language that supports distributed applications. The Hoare logic for microSR with concurrency features presented in this paper has been formally proven to be sound within HOL. The logic we derived allows one to reason and state formal assertions about concurrently executing processes that do not share any data objects, but communicate through shared channels.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> G.R. Andrews, R.A. Olsson, M. Coffin, I.J.P. Elshoff, K. Nilsen, T. Purdin, and G. Fig. </author> <title> 4. Verification of microSR Programs Townsend.: An Overview of the SR Language and Implementation. </title> <journal> ACM Transactions on Programming Languages and Systems 10, </journal> <month> 1 (January </month> <year> 1988), </year> <pages> 51-86. </pages>
Reference-contexts: This paper concentrates on the mechanization of a Hoare logic in HOL for the concurrent programming language microSR, which is a derivative of SR <ref> [1, 3] </ref>. SR has several aspects that make it a good language to be used in our research. ? This work was sponsored in part by the US Department of Defense and ARPA. Foremost is SR's expressiveness within the realm of concurrent programming paradigms.
Reference: 2. <author> G.R. Andrews.: </author> <title> Concurrent Programming: </title> <booktitle> Principles and Practice. </booktitle> <publisher> The Ben-jamin/Cummings Publishing Company, Inc. </publisher> <address> Redwood City, CA, </address> <year> 1991. </year>
Reference-contexts: In order to handle interference, we have introduced into our logic the well-known strategy of global invariants and modeled the only potential interference hazard of communication channels as "sent-sets" and "received-sets" as in <ref> [2, 7] </ref>. Messages existing in the FIFO queue associated with a channel are the messages that have already arrived in this channel's "sent-set" but not yet in its "received-set". <p> Putting a message into or picking up a message from a process' queue in an operation is the monitor's atomic action taken with respect to the accessed process' queue in the given operation as in <ref> [2] </ref>. m send = ` def 8 (op:op name) (e:(num)list ! num) (vl:(string)list) (s1:global state) (s2:global state) (p:proc id) . m send (op, e, vl) s1 s2 p = 9 (msg:message) (m id:num) . is valid proc (s1,p)^is valid proc (s2,p)^ is valid op (s1,p,op)^ (get local state (s1,p) = get <p> (dynamic process creation, message-passing, remote procedure calls, and rendezvous) are all amenable to a Hoare-like programming logic because the components of our semantic model for microSR have already formalized most of entities and behaviors that SR programmers as well as other modern concurrent programmers must consider during their design process <ref> [2, 5] </ref>. our logic system. We will continue to examine the expressive power of our logic with more program proofs in a more rigorous manner.
Reference: 3. <author> G.R. Andrews and R.A. Olsson.: </author> <title> The SR Programming Language: Concurrency in Practice. </title> <publisher> Benjamin/Cummings Publishing Company, Inc. </publisher> <address> Redwood City, CA, </address> <year> 1993. </year>
Reference-contexts: This paper concentrates on the mechanization of a Hoare logic in HOL for the concurrent programming language microSR, which is a derivative of SR <ref> [1, 3] </ref>. SR has several aspects that make it a good language to be used in our research. ? This work was sponsored in part by the US Department of Defense and ARPA. Foremost is SR's expressiveness within the realm of concurrent programming paradigms.
Reference: 4. <author> W.R. Bevier, W.A. Hunt, J.S. Moore, and W.D. Young.: </author> <title> An approach to systems verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5 </volume> <pages> 411-428, </pages> <year> 1989. </year>
Reference-contexts: Each layer will be formally modeled as an interpreter that interacts with the other layers. This layered interpreter approach will allow us to verify distributed applications with respect to the entire system. The CLI stack <ref> [4] </ref> has shown the feasibility of full system verification using a layered proof technique, but their model does not allow for concurrency and distributed programming, nor have they fully integrated the operating system into their "stack".
Reference: 5. <author> M. Chandy and J. Misra.: </author> <title> Parallel Program Design: A Foundation of Programming Logic. </title> <publisher> Addison-Wesley Publishing Company, Inc. </publisher> <year> 1988. </year>
Reference-contexts: (dynamic process creation, message-passing, remote procedure calls, and rendezvous) are all amenable to a Hoare-like programming logic because the components of our semantic model for microSR have already formalized most of entities and behaviors that SR programmers as well as other modern concurrent programmers must consider during their design process <ref> [2, 5] </ref>. our logic system. We will continue to examine the expressive power of our logic with more program proofs in a more rigorous manner.
Reference: 6. <author> M. J. C. Gordon.: </author> <title> Mechanizing Programming Logics in Higher Order Logic. In: Current Trends in Hardware Verification and Automated Theorem Proving. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Fig. 1. Overview of Our Research on microSR Our effort to formally derive, using HOL, a sound Hoare logic from microSR semantics is a generalization of similar work by Gordon for a small sequential language <ref> [6] </ref>. Our goal is to develop a feasible methodology for mechanizing Hoare-style programming logics for concurrent programming languages; our current results represent steps toward that goal, although they may not prove to be the best formulation.
Reference: 7. <author> W. Harrison, K. Levitt, and M. Archer.: </author> <title> A HOL Mechanization of the Axiomatic Semantics of a Simple Distributed Programming Language. In: Higher Order Logic Theorem Proving and Its Applications. </title> <publisher> North-Holland, </publisher> <address> Netherlands, </address> <year> 1993. </year>
Reference-contexts: Our axiomatic logic for microSR allows one to reason and state formal assertions about concurrently executing processes that do not share any data objects, but communicate through shared channels. Our current work differs significantly from the early work in our lab by Harrison <ref> [7] </ref>. <p> In order to handle interference, we have introduced into our logic the well-known strategy of global invariants and modeled the only potential interference hazard of communication channels as "sent-sets" and "received-sets" as in <ref> [2, 7] </ref>. Messages existing in the FIFO queue associated with a channel are the messages that have already arrived in this channel's "sent-set" but not yet in its "received-set".
Reference: 8. <author> C.A.R. Hoare.: </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1985. </year>
Reference-contexts: The constructs of mi-croSR include those basic to common programming languages in addition to an asynchronous send statement, a synchronous receive statement, a guarded communication input statement similar to Hoare's CSP <ref> [8] </ref>, and a co statement for specifying concurrent execution. The statement level syntax of microSR used in this paper is specified by the BNF below.
Reference: 9. <author> J.J. Joyce.: </author> <title> A Verified Compiler for a Verified Microprocessor. </title> <type> Technical Report No.167, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <month> March </month> <year> 1989. </year>
Reference-contexts: We expect our verification of concurrent microSR implementation will extend the related works by Joyce <ref> [9] </ref> and Young [11].
Reference: 10. <author> L. C. Paulson.: </author> <title> Logic and Computation: Interactive Proof with Cambridge LCF. </title> <address> Cambridge ; New York : Cambridge University Press, </address> <year> 1987. </year>
Reference-contexts: Sample Proof Outline: Stream Merge Maintains Ordering Property is to establish a systematic method for creating annotated microSR programs including assertions of global invariants on the shared message pool. Another challenging task is to develop in HOL an interactive backward microSR prover of LCF <ref> [10] </ref> style proof tactics based on our logic.
Reference: 11. <author> W. D. Young.: </author> <title> A Mechanically Verified Code Generator. </title> <journal> Journal of Automated Reasoning, </journal> <volume> Vol. 5: </volume> <pages> 493-518, </pages> <year> 1989. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: We expect our verification of concurrent microSR implementation will extend the related works by Joyce [9] and Young <ref> [11] </ref>.
References-found: 11

