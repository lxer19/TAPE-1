URL: http://www.psrg.lcs.mit.edu/~james/drafts/asplos-submission.ps
Refering-URL: http://www.psrg.lcs.mit.edu/ftpdir/pub/james/papers/osdi-distrib/README.html
Root-URL: 
Title: Opportunistic Log: Efficient Reads in a Reliable Object Server  
Author: James O'Toole Liuba Shrira 
Abstract: Object servers offer the potential of improved client caching. However, in comparison to page servers, object servers must perform additional disk reads. These installation reads are required to install modified objects onto their corresponding disk pages. In this paper, we introduce the opportunistic log: a new technique that significantly reduces the cost of these installation reads in object servers. The opportunistic log provides a large pool of pending installation reads that can be scheduled efficiently. Using simulations, we show that the opportunistic log substantially enhances the performance of reliable object servers. An object server without the opportunistic log requires much better client caching to outperform a page server. With an opportunistic log, only a small client cache improvement suffices. Our results affect the fundamental design choice between page-based and object-based servers and imply that efficient scheduling of installation reads is important in future disk design. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Atul Adya. </author> <title> A distributed commit protocol for optimistic concurrency control. </title> <type> Master's thesis, </type> <institution> Mas-sachusetts Institute of Technology, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: We assume the need to abort is detected at the server using a validation phase that does not require any disk accesses; see Adya <ref> [1] </ref> for the details. When considering the choice between page and object servers we are deliberately ignoring the question whether the server uses page level or object level concurrency control. <p> Both page and object level concurrency control can be used with both object and page servers with our validation techniques <ref> [1] </ref>. implemented using a non-volatile memory to ensure reliability. An important point is that committing a transaction does not require a disk write. Without non-volatile memory, the server would record committed modifications in a log on a dedicated disk.
Reference: [2] <author> Jia bing R. Cheng and A. R. Hurson. </author> <title> On the performance issues of object-based buffering. </title> <booktitle> In Proceedings of the Conference on Parallel and Distributed Information Systems, </booktitle> <pages> pages 30-37, </pages> <year> 1991. </year>
Reference-contexts: The relative merits of this fundamental design choice are still subject of debate <ref> [6, 3, 2] </ref>. Object servers have the potential for better client cache usage, while page servers perform less I/O. The choice of designs depends on the relative weight of these two costs. <p> Server ships whole pages to the client, clients send back whole pages that include modified objects. Object server has the potential for better client cache utilization because pages are likely to include unneeded data that can not be discarded from the client cache <ref> [3, 6, 2] </ref>. On the other hand object server may need to do more I/O. When a modified object needs to be updated on disk and its containing page is not present in the object server cache, this page has to be read from the disk. <p> provided more absorption when allocated to the log, we would still want enough memory allocated to dirty pages to provide a low expected disk write cost. 3.2 Performance Impact of Scheduled Reads Several studies have indicated that object servers offer the potential of improving the utilization of the client cache <ref> [2, 3] </ref> as compared to page servers since they can hold more objects useful to the client. Improved client cache utilization translates into better client cache hit ratio, less client fetches and ultimately, reduced I/O demands on the server. <p> Dewitt et.all [6] fo-cusses on the question of distributing the functionality of persistant object system between the client and the server. Day [3] focusses on whether to manage client cache on a page or an object basis. Cheng and Hurson <ref> [2] </ref> demonstrated how object server architecture can enable more efficient client cashe utilization. None of these studies considered the problem of installation reads. 8 Conclusion Modern programming languages support efficient manipulation of objects of heterogeneous user defined types.
Reference: [3] <author> M. Day. </author> <title> Managing a Cache of Swizzled Objects and Surrogates. </title> <type> PhD thesis, </type> <note> miteecs, In preparation. </note>
Reference-contexts: The relative merits of this fundamental design choice are still subject of debate <ref> [6, 3, 2] </ref>. Object servers have the potential for better client cache usage, while page servers perform less I/O. The choice of designs depends on the relative weight of these two costs. <p> Server ships whole pages to the client, clients send back whole pages that include modified objects. Object server has the potential for better client cache utilization because pages are likely to include unneeded data that can not be discarded from the client cache <ref> [3, 6, 2] </ref>. On the other hand object server may need to do more I/O. When a modified object needs to be updated on disk and its containing page is not present in the object server cache, this page has to be read from the disk. <p> provided more absorption when allocated to the log, we would still want enough memory allocated to dirty pages to provide a low expected disk write cost. 3.2 Performance Impact of Scheduled Reads Several studies have indicated that object servers offer the potential of improving the utilization of the client cache <ref> [2, 3] </ref> as compared to page servers since they can hold more objects useful to the client. Improved client cache utilization translates into better client cache hit ratio, less client fetches and ultimately, reduced I/O demands on the server. <p> Several studies have investigated the design choices for persistant object system architecture. Dewitt et.all [6] fo-cusses on the question of distributing the functionality of persistant object system between the client and the server. Day <ref> [3] </ref> focusses on whether to manage client cache on a page or an object basis. Cheng and Hurson [2] demonstrated how object server architecture can enable more efficient client cashe utilization.
Reference: [4] <author> W. de Jonge, F. Kaashoek, and W. Hsieh. </author> <title> The logical disk: A new approach to improving file systems. </title> <booktitle> In Proc. of the 14th Symposium on Operating Systems Principles, </booktitle> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year> <note> ACM. </note>
Reference-contexts: There is substantial previous work on delayed processing of disk write operations [18, 10]. Some methods applied to delayed disk writes involve writing pages at new locations <ref> [4, 7, 15] </ref> and would not work with disk reads. However, standard disk scheduling methods based on head position apply equally well to read operations.
Reference: [5] <author> O. </author> <title> Deux et al. </title> <journal> The story of o 2 . IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 91-108, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Many persistant object systems use the more traditional page based architecture [9, 13, 14]. Other systems like <ref> [11, 5] </ref> use object server architectures but do not specifically address the problem of installation reads. . There is enormous literature on centralized and distributed databses (see Jim Gray's book [8] for excelent survey).
Reference: [6] <author> David J. DeWitt, Philippe Futtersack, David Maier, and Fernando Velez. </author> <title> A study of three alternative workstation-server architectures for object oriented database systems. </title> <booktitle> In Proceedings of the 16th Conference on Very Large Data Bases, </booktitle> <pages> pages 107-121, </pages> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: The relative merits of this fundamental design choice are still subject of debate <ref> [6, 3, 2] </ref>. Object servers have the potential for better client cache usage, while page servers perform less I/O. The choice of designs depends on the relative weight of these two costs. <p> Server ships whole pages to the client, clients send back whole pages that include modified objects. Object server has the potential for better client cache utilization because pages are likely to include unneeded data that can not be discarded from the client cache <ref> [3, 6, 2] </ref>. On the other hand object server may need to do more I/O. When a modified object needs to be updated on disk and its containing page is not present in the object server cache, this page has to be read from the disk. <p> Our techniques directly capitalize on this previous work. We are not aware of any other work that is concerned with efficient scheduling of asynchronous reads. Several studies have investigated the design choices for persistant object system architecture. Dewitt et.all <ref> [6] </ref> fo-cusses on the question of distributing the functionality of persistant object system between the client and the server. Day [3] focusses on whether to manage client cache on a page or an object basis.
Reference: [7] <author> R. English and A. Stepanov. Loge: </author> <title> a self organizing disk controller. </title> <booktitle> In Proceedings of Winter USENIX, </booktitle> <year> 1992. </year>
Reference-contexts: There is substantial previous work on delayed processing of disk write operations [18, 10]. Some methods applied to delayed disk writes involve writing pages at new locations <ref> [4, 7, 15] </ref> and would not work with disk reads. However, standard disk scheduling methods based on head position apply equally well to read operations.
Reference: [8] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: Many persistant object systems use the more traditional page based architecture [9, 13, 14]. Other systems like [11, 5] use object server architectures but do not specifically address the problem of installation reads. . There is enormous literature on centralized and distributed databses (see Jim Gray's book <ref> [8] </ref> for excelent survey). Both classical centralized and modern client-server based relational databases deal with fixed set of system defined types instead of heterogenious user defined types and therefore are universally page based.
Reference: [9] <author> M. Hornick and S. Zdonik. </author> <title> A Shared, Segmented Memory System for an Object-Oriented Database, </title> <address> pages 273-285. </address> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: Many persistant object systems use the more traditional page based architecture <ref> [9, 13, 14] </ref>. Other systems like [11, 5] use object server architectures but do not specifically address the problem of installation reads. . There is enormous literature on centralized and distributed databses (see Jim Gray's book [8] for excelent survey).
Reference: [10] <author> David M. Jacobson and John Wilkes. </author> <title> Disk scheduling algorithms based on rotational position. </title> <type> Technical Report HPL-CSP-91-7, </type> <institution> Hewlett-Packard Laboratories, </institution> <month> February </month> <year> 1991. </year>
Reference-contexts: The objects on disk are updated asynchronously by processing the log, installing the modified object into pages and then writing whole pages to disk. Since installation reads happen outside server commit path they can be delayed. Although there exist substantial work on intelligent disk scheduling of asynchronous writes <ref> [18, 10] </ref>, we are the first to take advantage of the opportunity to schedule asyn chronous reads which are important in the object servers. To investigate the performance advantage provided by scheduled installation reads we compare the throughput of an optimized object server and a page server. <p> By delaying the installation and performing installation reads opportunistically on the basis of disk head position, we can expect to dramatically reduce the expected cost of an installation read. There is substantial previous work on delayed processing of disk write operations <ref> [18, 10] </ref>. Some methods applied to delayed disk writes involve writing pages at new locations [4, 7, 15] and would not work with disk reads. However, standard disk scheduling methods based on head position apply equally well to read operations.
Reference: [11] <author> W. Kim et al. </author> <title> Architecture of the orion next-generation database system. </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 109-124, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Many persistant object systems use the more traditional page based architecture [9, 13, 14]. Other systems like <ref> [11, 5] </ref> use object server architectures but do not specifically address the problem of installation reads. . There is enormous literature on centralized and distributed databses (see Jim Gray's book [8] for excelent survey).
Reference: [12] <author> B. Liskov, M. Day, and L. Shrira. </author> <title> Distributed object management in Thor. </title> <editor> In M. Tamer Ozsu, Umesh Dayal, and Patrick Valduriez, editors, </editor> <booktitle> Distributed Object Management. </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1993. </year>
Reference-contexts: Finally, we discuss related research (Section 7) and our conclusions (Section 8). 2 Reliable Object Servers This section introduces our baseline persistant object system and describes the basic design issues in reliable object and page servers. The object server architecture is derived from the Thor <ref> [12] </ref> persistant object system. The important features of Thor that we use are optimistic concurrency control, in-memory commit, and object-based architecture. The page server also uses optimistic concurrency control and in-memory commit.
Reference: [13] <author> D. Maier and J. Stein. </author> <title> Development and implementation of an object-oriented dbms. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Many persistant object systems use the more traditional page based architecture <ref> [9, 13, 14] </ref>. Other systems like [11, 5] use object server architectures but do not specifically address the problem of installation reads. . There is enormous literature on centralized and distributed databses (see Jim Gray's book [8] for excelent survey).
Reference: [14] <institution> MA Object Design Inc., </institution> <month> Burlingtom. </month> <title> An introduction to object store, release 1.0. </title> <year> 1989. </year>
Reference-contexts: Many persistant object systems use the more traditional page based architecture <ref> [9, 13, 14] </ref>. Other systems like [11, 5] use object server architectures but do not specifically address the problem of installation reads. . There is enormous literature on centralized and distributed databses (see Jim Gray's book [8] for excelent survey).
Reference: [15] <author> M. Rosenblum and J.K. Ousterhout. </author> <title> The design and implementation of a log structured file system. </title> <booktitle> In Proc. of the 13th Symposium on Operating Systems Principles, </booktitle> <address> Pacific Grove, Ca, </address> <month> October </month> <year> 1991. </year> <note> ACM. </note>
Reference-contexts: There is substantial previous work on delayed processing of disk write operations [18, 10]. Some methods applied to delayed disk writes involve writing pages at new locations <ref> [4, 7, 15] </ref> and would not work with disk reads. However, standard disk scheduling methods based on head position apply equally well to read operations.
Reference: [16] <author> Chris Ruemmler and John Wilkes. </author> <title> Modelling disks. </title> <type> Technical Report HPL-93-68rev1, </type> <institution> Hewlett-Packard Laboratories, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: The disk geometry and other performance characteristics are taken from the HP97560 drive, as described by Wilkes <ref> [16] </ref>. We chose the HP97560 model because it is simple, accurate, and available. We believe that newer and faster drives will make opportunistic i/o even more important because transfer time is decreasing much faster than seek time.
Reference: [17] <author> M. Satyanarayanan, H. Mashburn, P. Kumar, D. Steere, and J. Kistler. </author> <title> Leightweight recoverable virtual memory. </title> <booktitle> In Proc. of the 14th Symposium on Operating Systems Principles, </booktitle> <address> Asheville, NC, Decem-ber 1993. </address> <publisher> ACM. </publisher>
Reference-contexts: To make recovery more efficient, the information on page reads is recorded in the log and so during recovery the cache is primed with the required pages before applying the log. Presumably, these reads are scheduled efficiently. Opor-tunistic log exploits these ideas during normal operation. RVM <ref> [17] </ref> is a portable system that uses a write ahead log to implement recoverable virtual memory. Like our work RVM is concerned with efficient propagation of partiall page updates from the log to the persistant data on disk.
Reference: [18] <author> M. Seltzer, P. Chen., and J. Ousterhout. </author> <title> Disk scheduling revisited. </title> <booktitle> In Proceedings of Winter USENIX, </booktitle> <year> 1990. </year>
Reference-contexts: The objects on disk are updated asynchronously by processing the log, installing the modified object into pages and then writing whole pages to disk. Since installation reads happen outside server commit path they can be delayed. Although there exist substantial work on intelligent disk scheduling of asynchronous writes <ref> [18, 10] </ref>, we are the first to take advantage of the opportunity to schedule asyn chronous reads which are important in the object servers. To investigate the performance advantage provided by scheduled installation reads we compare the throughput of an optimized object server and a page server. <p> By delaying the installation and performing installation reads opportunistically on the basis of disk head position, we can expect to dramatically reduce the expected cost of an installation read. There is substantial previous work on delayed processing of disk write operations <ref> [18, 10] </ref>. Some methods applied to delayed disk writes involve writing pages at new locations [4, 7, 15] and would not work with disk reads. However, standard disk scheduling methods based on head position apply equally well to read operations. <p> Some methods applied to delayed disk writes involve writing pages at new locations [4, 7, 15] and would not work with disk reads. However, standard disk scheduling methods based on head position apply equally well to read operations. In particular, Seltzer et. al. <ref> [18] </ref> have shown that when a pool of 1000 operations is available, greedy algorithms can reduce the cost of individual operations to a fraction of the normal random-access cost. The reliable object server must maintain a log of object updates that have not yet been installed onto corresponding pages. <p> When the number of clean pages in the cache drops below the Write-trigger threshold, the server writes one dirty page to the disk. The page is selected using the shortest positioning time algorithm <ref> [18] </ref>. The server primary memory is non-volatile and the page-based server therefore does not require a log. In the object-based server, the simulator models the transaction log as a collection of modified objects. A portion of the non-volatile primary memory is statically allocated to hold log entries. <p> These measurements show that increasing the log is initially very valuable as the installation read cost drops rapidly. However, later improvements are smaller and require much greater increases in log size. Of course, this is the effect we expected, as described by Seltzer <ref> [18] </ref>. Metrics for 50 clients, cache hit 80% Log tx/s I-Abs. <p> Much earlier effort has been invested in optimizing disk scheduling and so widening the performance gap between unoptimized and optimized disk access. A recent study by Seltzer, Chen and Ousterhout <ref> [18] </ref> aggressively takes advan tage of the available large memories to efficiently schedule asynchronous writes. Our techniques directly capitalize on this previous work. We are not aware of any other work that is concerned with efficient scheduling of asynchronous reads.
References-found: 18

