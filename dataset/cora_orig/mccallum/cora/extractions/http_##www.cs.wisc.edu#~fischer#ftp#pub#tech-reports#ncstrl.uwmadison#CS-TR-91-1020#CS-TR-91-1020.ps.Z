URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1020/CS-TR-91-1020.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1020/
Root-URL: http://www.cs.wisc.edu
Email: lieuwen@cs.wisc.edu  dewitt@cs.wisc.edu  
Title: Optimizing Loops in Database Programming Languages  
Author: Daniel F. Lieuwen David J. DeWitt 
Address: Madison, WI 53706  Madison, WI 53706  
Affiliation: Computer Sciences Department University of Wisconsin  Computer Sciences Department University of Wisconsin  
Abstract: Database programming languages like O 2 , E, and O++ include the ability to iterate through a set. Nested iterators can be used to express joins. We describe compile-time optimizations of such programming constructs that are similar to relational transformations like join reordering. Ensuring that the program's semantics are preserved during transformation requires paying careful attention to the flow of values through the program. This paper presents conditions under which such transformations can be applied and analyzes the I/O performance of several different classes of program fragments before and after applying transformations. The analysis shows that the transformations can significantly reduce the number of I/Os performed, even when both the initial and transformed programs use the same join method. 
Abstract-found: 1
Intro-found: 1
Reference: [ABU81] <author> Walid Abu-Sufah, David J. Kuck, and Duncan H. Lawrie. </author> <title> On the Performance Enhancement of Paging Systems Through Program Analysis and Transformations. </title> <journal> IEEE Trans. on Computers C-30,5 (May 1981), </journal> <pages> 341-355. </pages>
Reference-contexts: Thus the general idea is similar although the analysis used is different. Loop fission has been used to optimize FORTRAN programs. Loop fission breaks a single loop into several smaller loops to improve the locality of data reference. This can improve paging performance dramatically <ref> [ABU81] </ref>.
Reference: [AGRA89] <author> R. Agrawal and N. H. Gehani. </author> <title> Rationale for the Design of Persistence and Query Processing Facilities in the Database Programming Language O++. </title> <booktitle> Proc. 2nd Int. Workshop on Database Programming Languages, </booktitle> <month> June </month> <year> 1989. </year>
Reference: [ATKI87] <author> Malcolm P. Atkinson and O. Peter Buneman. </author> <title> Types and Persistence in Database Programming Languages. </title> <journal> ACM Computing Surveys 19,2 (June 1987), </journal> <pages> 105-190. </pages>
Reference: [ATKI89] <author> Malcolm P. Atkinson, Francois Bancilhon, David DeWitt, Klaus Dittrich, David Maier, and Stanley Zdonik. </author> <title> The Object-Oriented Database System Manifesto, invited paper, </title> <booktitle> 1st International Conference on DOOD (Deductive and Object-Oriented Databases), </booktitle> <address> Japan, </address> <month> December, </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Many researchers believe that an object-oriented database system (OODBS) must be computationally complete that programmers and database administrators must have access to a programming language to write methods and application programs <ref> [ATKI89] </ref>. While the programming language for such a system must include the ability to iterate through a set, giving programmers this power allows them to write programs that can be orders of magnitude slower than the desired computation actually requires. Thus, compilers must be extended to include database-style optimizations.
Reference: [BATE90] <author> Samuel Bates, </author> <title> private communication. </title>
Reference-contexts: If the right-hand side of (33) evaluates to a positive integer and v is known to be positive, a /= operation of the above form is also self-commutative ignoring overflow <ref> [BATE90] </ref>. (The result of integer division where one of the operands is negative is implementation dependent in the C language.) Now, consider S when it contains several statements that perform numeric computations.
Reference: [DAYA87] <author> Umeshwar Dayal. </author> <title> Of Nests and Trees: A Unified Approach to Process Queries That Contain Nested Subqueries, Aggregates, and Quantifiers. </title> <booktitle> Proceedings of 1987 Conf. Very Large Databases, </booktitle> <month> August </month> <year> 1987. </year>
Reference: [DEMO85] <author> G. Barbara Demo and Sukhamay Kundu. </author> <title> Analysis of the Context Dependency of CODASYL FIND-statements with Application to Database Program Conversion. </title> <booktitle> Proc. 1985 SIGMOD, </booktitle> <month> May </month> <year> 1985. </year>
Reference-contexts: In [KATZ85], data flow analysis and pattern matching are used to transform CODASYL DML statements into DAPLEX-like statements. This transformation makes some flow of control statements unnecessary, so these statements are removed. Finally, the DAPLEX-like statements are transformed into relational queries. <ref> [DEMO85] </ref> uses more sophisticated analysis to decompile a larger class of programs. Both our work and theirs tries to take an imperative program and make it as declarative as possible while maintaining the program semantics. Both use dataflow analysis and pattern matching.
Reference: [DEWI84] <author> David DeWitt, Randy Katz, Frank Olken, Leonard Shapiro, Michael Stonebraker, and David Wood. </author> <title> Implementation Techniques for Main Memory Database Systems. </title> <booktitle> Proc. 1984 SIGMOD, </booktitle> <month> June </month> <year> 1984. </year>
Reference-contexts: The notation in Table 1 will be used in the analysis below. We will assume that queries are evaluated using the hybrid hash algorithm. <ref> [DEWI84] </ref> describes the hybrid hash algorithm as follows: (1) Scan R, selecting those objects of R that satisfy the selection criterion, projecting out unnecessary attributes to produce R'. <p> The cost of executing a query using the hybrid hash algorithm is: P R + P S Read R and S (P R +P S ) . 2 . (1-q) Writing and rereading hash partitions Our formula for hybrid hash is similar to the one in <ref> [DEWI84] </ref>. There are only two differences: (1) following [SHAP86], we do not distinguish between random and sequential I/O, and (2) R' and S' replace R and S in the definitions of B and q and in the second line of the cost formula. <p> Figure 1 compares the performance predicted by the analysis of the untransformed simple group-by loop (10) and the optimized query (T1) when P Set 1 = 250 and P Set 2 = 5000. Following <ref> [DEWI84] </ref>, we assume F = 1.2. The size of memory was increased in 200 page increments until increasing the memory size did not change performance. The curves flatten when the inner set's hash table fits in main memory, since then each set is read only once.
Reference: [GANS87] <author> Richard A. Ganski and Harry K. T. Wong. </author> <title> Optimization of Nested SQL Queries Revisited. </title> <booktitle> Proc. 1987 SIGMOD, </booktitle> <month> May </month> <year> 1987. </year>
Reference: [KATZ82] <author> R. H. Katz and E. Wong. </author> <title> Decompiling CODASYL DML into Relational Queries. </title> <journal> ACM Trans. Database Syst. </journal> <month> 7,1 (March </month> <year> 1982), </year> <pages> 1-23. </pages>
Reference: [KIM82] <author> Won Kim. </author> <title> On Optimizing an SQL-like Nested Query. </title> <journal> ACM Trans. Database Syst. </journal> <month> 7,3 (September </month> <year> 1982), </year> <pages> 443-469. </pages>
Reference-contexts: The work in this paper is also related to the work by Won Kim on transforming nested query blocks in SQL into equivalent queries with no nesting <ref> [KIM82] </ref>. The style of transformation is similar. He starts with a simple kind of nested query and shows how to transform it into a join query that does not have a nested query in the where clause.
Reference: [LECL89] <author> C. Lecluse and P. Richard. </author> <title> The O 2 Database Programming Language. </title> <booktitle> Proceedings of 1989 Conf. Very Large Databases, </booktitle> <month> August </month> <year> 1989. </year>
Reference: [MURA89] <author> M. Muralikrishna. </author> <title> Optimization and Dataflow Algorithms for Nested Tree Queries. </title> <booktitle> Proceedings of 1989 Conf. Very Large Databases, </booktitle> <month> August </month> <year> 1989. </year>
Reference: [PADU86] <author> David A. Padua and Michael J. Wolfe. </author> <title> Advanced Compiler Optimizations for Supercomputers. </title> <journal> CACM 29,12 (December 1986), </journal> <pages> 1184-1201. </pages>
Reference: [RICH89] <author> Joel Richardson, Michael Carey, and Daniel Schuh. </author> <title> The Design of the E Programming Language. </title> <type> Technical Report #824, </type> <institution> Computer Sciences Department, University of Wisconsin, </institution> <month> February </month> <year> 1989. </year>
Reference: [SELL88] <author> Timos Sellis. </author> <title> Multi-Query Optimization. </title> <journal> ACM Trans. Database Syst. </journal> <month> 13,1 (March </month> <year> 1988), </year> <pages> 23-52. </pages>
Reference-contexts: In addition, we need to develop methods to combine several loops that appear sequentially in the program text into a single large loop (in some ways finding an inverse of transformations (T3) and (T4)closely related to multi-query optimization <ref> [SELL88] </ref>). We examined how this could be done as a clean-up pass, but we did not integrate it with the transformation process.
Reference: [SHAP86] <author> Leonard D. Shapiro. </author> <title> Join Processing in Database Systems with Large Main Memories. </title> <journal> ACM Trans. Database Syst. </journal> <month> 11,3 (September </month> <year> 1986), </year> <pages> 239-264. </pages>
Reference-contexts: There are only two differences: (1) following <ref> [SHAP86] </ref>, we do not distinguish between random and sequential I/O, and (2) R' and S' replace R and S in the definitions of B and q and in the second line of the cost formula. For hybrid hash to be applicable, M ddddd P R .
Reference: [SHEK90] <author> Eugene J. Shekita and Michael J. Carey. </author> <title> A Performance Evaluation of Pointer-Based Joins. </title> <booktitle> Proc. 1990 SIGMOD, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: Thus, value-based joins will be needed. Second, the use of pointers leads to implicit joins. If we blindly follow pointers in the order specified by the user, the execution of the join may become unnecessarily slow <ref> [SHEK90] </ref>. Third, some join-like operations will result from calling functions from within a set iterationsince the functions may also iterate through sets. We will concentrate on value-based joins. <p> This paper's transformations and analysis are designed for value-based joins (i.e., group-by loops). The transformations can also be used to improve the performance of queries that involve implicit joins through pointers, though the analysis presented here will not directly apply to this case. However, using a technique from <ref> [SHEK90] </ref>, pointer dereferencing can be executed in a manner similar to value-based joins when the appropriate extents (sets of all objects of a particular type) exist. <p> The rewritten query might well have no embedded sets. Then S might be self-commutative relative to the new list of sets even though it was not self-commutative relative to X 1 , X 2 , ..., and X m . We will ignore such rewrites in this paper; <ref> [SHEK90] </ref> employs this technique. 2 If Emp = - [Joe,1], [Jim,2], [Ralph,1] and Dept = - [Shoe,1], [Candy,2] and there are persistent pointers E1-E3 to Emp elements and D1-D2 to Dept elements, then the execution of (1) that produces Shoe 1 Joe 1 Shoe 1 Ralph 1 Candy 2 Jim 2 <p> Note that size Temp = (pwidth Set 1 + pwidth Set 2 ). Given this, P Temp can be calculated using the formula in Table 1. Assume that M ddd P Temp hhhhhh . Using the analysis found in <ref> [SHEK90] </ref>, this implies that Temp can be sorted in two passes.
Reference: [SHOP80] <author> Jonathan Shopiro. </author> <title> Ph.D. Thesis. A Very High Level Language And Optimized Implementation Design For Relational Databases. </title> <institution> University of Rochester (1980). </institution>
Reference-contexts: In Section 5, we carefully characterize the class of self-commutative statements. Our conclusions are contained in Section 6. 2 Related Work The work most closely related to ours can be found in <ref> [SHOP80] </ref>; the transformation that [SHOP80] called loop inversion is explored in Section 4.3.3. Loop inversion is the only transformation that is carefully characterized in [SHOP80]other transformations are illustrated with examples, but the conditions under which they are applicable are not stated. <p> In Section 5, we carefully characterize the class of self-commutative statements. Our conclusions are contained in Section 6. 2 Related Work The work most closely related to ours can be found in <ref> [SHOP80] </ref>; the transformation that [SHOP80] called loop inversion is explored in Section 4.3.3. Loop inversion is the only transformation that is carefully characterized in [SHOP80]other transformations are illustrated with examples, but the conditions under which they are applicable are not stated. <p> in Employee where D.id=E.deptid group by D.name This SQL query can be expressed in O++ as: (26) for D in Department - cnt = 0; //S1 for E in Employee suchthat (D-&gt;id == E-&gt;deptid) cnt++; //S2 printf ("%s %d", D-&gt;name, cnt); newline (); //S3 - We consider a transformation from <ref> [SHOP80] </ref> to rewrite queries involving aggregate functions such as (26).
Reference: [WOLF86] <author> Michael Wolfe. </author> <title> Advanced Loop Interchanging. </title> <booktitle> Proc. 1986 Int. Conf. Parallel Processing, </booktitle> <month> August </month> <year> 1986. </year>
Reference: [WOLF89] <author> Michael Wolfe. </author> <title> Optimizing Supercompilers for Supercomputers. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1989. </year>
Reference-contexts: We call operations of the form (33) reductions because they reduce a subset of a set or Cartesian product to a single value in an order independent manner. This is a natural extension to the concept of array reduction, a concept used in the optimization of programs for supercomputers <ref> [WOLF89] </ref>.
References-found: 21

