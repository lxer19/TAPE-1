URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1995/GIT-CC-95-23.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.95.html
Root-URL: 
Title: Object Caching in a CORBA Compliant System  
Author: R. Kordale M. Ahamad 
Address: Atlanta, GA 30332  
Affiliation: College of Computing Georgia Institute of Technology  
Pubnum: Technical Report: GIT-CC-95-23  
Abstract: Distributed object systems provide the key to build large scale applications that can execute on a range of platforms. The Common Object Request Broker Architecture (CORBA) specification from OMG attempts to address interoperability and heterogeneity issues that arise in such systems. Our goal is to investigate performance issues for distributed object systems. We claim that object caching is a must for improved performance and scalability in distributed object systems. However, to our knowledge, the CORBA specification does not address object caching. The purpose of this paper is to serve as a data point in a discussion of issues related to caching in CORBA by describing the design and implementation of ScaFDOCS, a Scalable and Flexible Distributed Object Caching System, on top of the Fresco system that supports CORBA compliant objects. Fresco runs on the Unix operating system and our implementation of ScaFDOCS exploits the features of both Fresco and Unix. We demonstrate that caching could lead to significant improvement in the performance of object method invocations. Keywords: Caching, flexible sharing, open systems, CORBA, Unix. fl This work was supported in part by ARPA contract N00174-93-K-0105.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. G. Mitchell, J. J. Gibbons, G. Hamilton, P. B. Kessler, Y. A. Khalidi, P. Kougiouris, P. W. Madany, M. N. Nelson, M. Powell and S. R. Radia. </author> <title> An Overview of the Spring System. </title> <booktitle> Proceedings of COMPCON, </booktitle> <month> Fall </month> <year> 1994. </year>
Reference-contexts: The underlying system over which one could build a distributed object caching system vary from a generic Unix platform with RPC support but no object support, to a full fledged distributed object oriented system like Choices [2] or Spring <ref> [1] </ref>. Our intention was to build on a general purpose, and a generally available, platform. Thus, we wanted to build our system on top of a CORBA compliant system that runs on Unix.
Reference: [2] <author> R. H. Campbell, N. Islam, P. Madany. </author> <title> Choices, frameworks and refinement. </title> <booktitle> Computing Systems, </booktitle> <month> Summer </month> <year> 1992. </year>
Reference-contexts: ScaFDOCS enhances an existing CORBA compliant system by adding caching to it. The underlying system over which one could build a distributed object caching system vary from a generic Unix platform with RPC support but no object support, to a full fledged distributed object oriented system like Choices <ref> [2] </ref> or Spring [1]. Our intention was to build on a general purpose, and a generally available, platform. Thus, we wanted to build our system on top of a CORBA compliant system that runs on Unix.
Reference: [3] <author> K. Li, and P. Hudak. </author> <title> Memory Coherence in Shared Virtual Memory Systems. </title> <journal> ACM Trans. on Comp. Sys., </journal> <month> Nov </month> <year> 1989. </year>
Reference-contexts: Some 1 of these problems also arise in software based implementations <ref> [3, 6, 8, 7] </ref> of distributed shared memories (DSM). We adapt some of the techniques used in DSM systems to address the problems for sharing objects instead of "memory pages" in the context of a distributed object system. 1.
Reference: [4] <author> M. Ahamad, G. Neiger., J. E. Burns, P. W. Hutto, and P. Kohli. </author> <title> Causal memory: Definitions, Implementations and Programming. </title> <note> to appear in Dist. Computing, </note> <year> 1995. </year>
Reference-contexts: As a result, a wide range of weaker consistency levels have been investigated which not only permit more efficient implementations, but also readily meet the requirements of many distributed applications. One such consistency level that we have investigated extensively is causal consistency <ref> [4] </ref>. It is appropriate for sharing among entities that interact asynchronously (e.g., loosely coupled users in a collaboration environment).
Reference: [5] <author> M. Shapiro. </author> <title> Structure and Encapsulation in Distributed Systems: The Proxy Principle. </title> <booktitle> Intl. Conf. on Dist. Comp. Sys, </booktitle> <year> 1986. </year>
Reference-contexts: This reflects the style of access that is specified by CORBA and is generally available in existing CORBA compliant systems. Basically, when a client tries to access an object server, it receives a handle to a proxy object <ref> [5] </ref>. Any invocation on the proxy object is translated into an invocation at the remote object server. Thus, active objects are implemented by Fresco object servers and are designed to be instances of classes that are descendants of the Proxy class.
Reference: [6] <author> P. Kohli, M. Ahamad, and K. Schwan. Indigo: </author> <title> User Level Support for Building Distributed Shared Abstractions, </title> <booktitle> Fourth Symp. on High Performance Dist. Computing, </booktitle> <month> August </month> <year> 1995. </year>
Reference-contexts: Some 1 of these problems also arise in software based implementations <ref> [3, 6, 8, 7] </ref> of distributed shared memories (DSM). We adapt some of the techniques used in DSM systems to address the problems for sharing objects instead of "memory pages" in the context of a distributed object system. 1.
Reference: [7] <author> B. N. Bershad, M. J. Zekauskas, W. A. Saw-don. </author> <title> The Midway distributed shared memory system. </title> <booktitle> COMPCON, </booktitle> <month> Spring </month> <year> 1993. </year>
Reference-contexts: Some 1 of these problems also arise in software based implementations <ref> [3, 6, 8, 7] </ref> of distributed shared memories (DSM). We adapt some of the techniques used in DSM systems to address the problems for sharing objects instead of "memory pages" in the context of a distributed object system. 1.
Reference: [8] <author> P. Keleher, A. L. Cox, S. Dwarkadas, W. Zwaenepoel. TreadMarks: </author> <title> Distributed shared memory on standard workstations and operating systems. </title> <booktitle> Winter USENIX Conf., </booktitle> <year> 1994. </year>
Reference-contexts: Some 1 of these problems also arise in software based implementations <ref> [3, 6, 8, 7] </ref> of distributed shared memories (DSM). We adapt some of the techniques used in DSM systems to address the problems for sharing objects instead of "memory pages" in the context of a distributed object system. 1.
Reference: [9] <author> C. Fidge. </author> <title> Timestamps in message-passing systems that preserve the partial ordering. </title> <booktitle> Aus-tralian Computer Science Conf., </booktitle> <year> 1988. </year>
Reference-contexts: This is done by associating a lifetime with each object copy. The lifetime is defined by two vector timestamps. These timestamps, called creation time and validation time, are assigned from vector clocks which are used to capture the causal orderings between events in distributed systems <ref> [9] </ref>. Each process cacher maintains a vector clock. Each time an object copy is updated, the process cacher increments its clock and a timestamp read from this clock is assigned as the creation timestamp for the object copy. This captures the per-process ordering of operations.
Reference: [10] <author> J. Kistler and M. Satyanarayanan. </author> <title> Disconnected operation in the Coda file system. </title> <booktitle> In ACM Symp. on Oper. Sys. Principles, </booktitle> <year> 1991. </year>
Reference: [11] <author> L. Lamport. </author> <title> Time, clocks and the ordering of events. </title> <journal> Comm. of the ACM, </journal> <month> July </month> <year> 1978. </year>
Reference-contexts: Causal consistency (CC) is defined based on causality that orders an operation o 1 before another operation o 2 , if o 1 can potentially have an effect on the execution of o 2 <ref> [11] </ref>. A formal definition of causal consistency for shared objects appears in [18] and we illustrate it using an example. Consider two objects: f 1 and f 2 . Node 1 first updates the state of f 1 , producing its copy f 0 1 .
Reference: [12] <author> D. B. Terry, A. J. Demers, K. Petersen, M. J. Spreitzer, M. M. Theimer, and B. B. Welch. </author> <title> Session guarantees for weakly consistent replicated data. </title> <booktitle> In IEEE Symp. on Parallel and Dist. Information Sys., </booktitle> <year> 1994. </year>
Reference-contexts: The caching framework shown in figure 1, shows only two subclasses of the Cached class that provide sequential and causal consistency guarantees. Ultimately, we intend to provide a bigger suite of consistency classes somewhat similar in flavor to the various session guarantees provided in Bayou <ref> [12] </ref>. Our intention is not to claim that each of the classes specified in the caching framework is complete; instead the interfaces reflect what we thought was required for the prototype implementation.
Reference: [13] <author> Fresco Sample Implementation Reference Manual. </author> <title> X Consortium Working Group Draft. </title> <note> Version 0.7. </note> <month> April </month> <year> 1994. </year>
Reference: [14] <author> M. J. Zekauskas, W. A. Sawdon, and B. N. Ber-shad. </author> <title> Software Write Detection for a Distributed Shared Memory. </title> <booktitle> Oper. Sys. Design and Implementation, </booktitle> <year> 1994. </year>
Reference-contexts: Object oriented programming languages can exploit the indirection [21] implicit in the method invocation mechanism to fold residency checks into the overhead of method invocation. In <ref> [14] </ref>, the authors present a method for write detection in a DSM system that relies on the compiler and runtime system. We chose a solution for both object faulting and access detection that did not require any changes to the compiler and was easy to build on the Unix system.
Reference: [15] <author> A. L. Hosking and J. E. B. Moss. </author> <title> Protection traps and alternatives for memory management of an object oriented language. </title> <booktitle> ACM Symp. on Oper. Sys. </booktitle> <address> Principles.'93. </address>
Reference-contexts: A tagged reference contains an object identifier sufficient to locate the object on disk or at a remote server. Every time a reference is traversed the tag is checked to make sure it points to a resident object; if it does not, then an object fault is triggered <ref> [15] </ref>. Object oriented programming languages can exploit the indirection [21] implicit in the method invocation mechanism to fold residency checks into the overhead of method invocation. In [14], the authors present a method for write detection in a DSM system that relies on the compiler and runtime system.
Reference: [16] <author> A. Birrell, G. Nelson, S. Owicki, and E. Wob-ber. </author> <title> Network Objects. </title> <booktitle> ACM Symp. on Oper. Sys. Principles, </booktitle> <year> 1993. </year>
Reference-contexts: The object structure should be linearized, sent over the wire, reconstructed at the other end and finally, we should be able to make an object invocation locally at that end 6 . Examples of systems that support this are DEC's Network Objects <ref> [16] </ref> system, and Xerox PARC's ILU [19]. * Transport mechanisms: CORBA specifications include synchronous, asynchronous, and one-way RPC. From our experience, we found that multicast is an important mechanism that is useful in consistency maintenance in distributed object systems and as such should be part of the specifications.
Reference: [17] <author> M. Satyanarayanan, B. Noble, P. Kumar, M. Price. </author> <title> Application-aware adaptation for mobile computing. </title> <booktitle> Proc. of Intl. Workshop on Mobile Systems and Applications, </booktitle> <year> 1994. </year>
Reference-contexts: The consistency cachers implement functions specific to the level of consistency provided by them and hence implement the type-specific part of caching at the node level (similar to the design in <ref> [17] </ref>). Notice that we chose to use separate cacher processes for different levels of consistency instead of having a single process (the node cacher) handle all the responsibilities of caching at the node level. 6 This design allows new consistency levels to be added easily.
Reference: [18] <author> M. Ahamad, F. J. Torres-Rojas, R. Kordale, J. Singh, S. Smith. </author> <title> Detecting Mutual Consistency of Shared Objects, </title> <booktitle> Proc. of International Workshop on Mobile Systems and Applications, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: Causal consistency (CC) is defined based on causality that orders an operation o 1 before another operation o 2 , if o 1 can potentially have an effect on the execution of o 2 [11]. A formal definition of causal consistency for shared objects appears in <ref> [18] </ref> and we illustrate it using an example. Consider two objects: f 1 and f 2 . Node 1 first updates the state of f 1 , producing its copy f 0 1 . <p> On the other hand, if node 3 caches f 1 1 and f 0 2 , the two copies are consistent according to CC because no causally intervening update overwrites f 1 . A brief description of the implementation of CC is given below. For more details, see <ref> [18] </ref>. We implement CC by keeping objects copies cached at a client mutually consistent with respect to causality. This is done by associating a lifetime with each object copy. The lifetime is defined by two vector timestamps.
Reference: [19] <author> B. Janssen, M. Spreitzer, D. Severson. </author> <note> Inter-Language Unification. Xerox PARC. URL: http://www.xerox.com/PARC/ilu/index.html. </note>
Reference-contexts: The object structure should be linearized, sent over the wire, reconstructed at the other end and finally, we should be able to make an object invocation locally at that end 6 . Examples of systems that support this are DEC's Network Objects [16] system, and Xerox PARC's ILU <ref> [19] </ref>. * Transport mechanisms: CORBA specifications include synchronous, asynchronous, and one-way RPC. From our experience, we found that multicast is an important mechanism that is useful in consistency maintenance in distributed object systems and as such should be part of the specifications.
Reference: [20] <author> T. von Eicken, D. E. Culler, S. C. Goldstein, K. E. Schauser. </author> <title> Active messages: a mechanism for integrated communication and computation. Computer Architecture News, </title> <month> May </month> <year> 1992. </year>
Reference: [21] <author> D. R. Edelson. They're Smart, </author> <title> but They're Not Pointers. </title> <booktitle> USENIX C++ Conference, </booktitle> <year> 1992. </year>
Reference-contexts: Every time a reference is traversed the tag is checked to make sure it points to a resident object; if it does not, then an object fault is triggered [15]. Object oriented programming languages can exploit the indirection <ref> [21] </ref> implicit in the method invocation mechanism to fold residency checks into the overhead of method invocation. In [14], the authors present a method for write detection in a DSM system that relies on the compiler and runtime system.
Reference: [22] <author> M. N. Nelson, G. Hamilton, and Y. A. Khalidi. </author> <title> Caching in an Object Oriented System. </title> <booktitle> Intl. Workshop on Object Orientation in Operating Systems (IWOOOS), </booktitle> <year> 1993. </year> <month> 12 </month>
Reference-contexts: The other alternative is for the client to communicate with a local proxy server which in turn has direct access to the shared memory pool; in other words, objects accessed by clients are actually cached by the proxy server. This alternative is adopted in Spring <ref> [22] </ref>. The ability of the clients to directly access memory instead of going through a proxy server would generally result in better performance. This is because inter-address space communication overhead, introduced by the need to request method invocations from the proxy server is avoided.
References-found: 22

