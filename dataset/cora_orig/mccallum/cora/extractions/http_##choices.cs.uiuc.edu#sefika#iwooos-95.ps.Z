URL: http://choices.cs.uiuc.edu/sefika/iwooos-95.ps.Z
Refering-URL: http://choices.cs.uiuc.edu/Papers.html
Root-URL: http://www.cs.uiuc.edu
Title: An Open Visual Model For Object-Oriented Operating Systems  
Author: Mohlalefi Sefika Roy H. Campbell 
Address: 1304 W. Springfield Avenue, Urbana, IL 61801  
Affiliation: University of Illinois at Urbana-Champaign Department of Computer Science  
Abstract: We present an "open" visual model for object-oriented operating systems that supports browsing, manipulation, and programming. The model exploits the reification of all operating system mechanisms and policies as classified objects to provide interactive visualization, evaluation, and configuration of specialized services and features. The model supports exploration of the dynamic interaction of subsystems within the operating system including comparisons between the abstract architectural properties of the system like its design patterns[5] and specific specializations and customizations of the implementation. This paper describes various visualization experiments and actual experiences of using an implementation of our approach in the Choices object-oriented operating system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Bruegge, T. Gottschalk, and B. Luo. </author> <title> A Framework for Dynamic Program Analyzers. </title> <booktitle> In OOPSLA, </booktitle> <year> 1993. </year>
Reference-contexts: Such an architecture allows a bulk of information processing to be flexibly shifted to either the operating system or the tool as convenient. BEE++ is fundamentally an event processing system <ref> [1] </ref>. Therefore, we believe it would be difficult to use its model for program analysis tasks which are not event-based, without some changes.
Reference: [2] <author> R. H. Campbell, N. Islam, and P. Madany. </author> <title> Choices, Frameworks and Refinement. </title> <booktitle> The Journal of the Usenix Association, </booktitle> <pages> pages 217-257, </pages> <year> 1992. </year>
Reference-contexts: The interaction patterns animated in the snapshot shown in Figure 4 reveal the run-time communication structure of the Choices virtual memory system. The animations are, in practice, consistent across many different normal user workloads. Objects in the animation are clustered. These clusters correspond to the subframeworks of Choices <ref> [2] </ref>. Intra-component communication is much higher than inter-component interaction confirming that these subframeworks capture the design principles of cohesive and loosely coupled subsystems. Because the view highlights control flows and object dependencies, it can guide learning, Choices documentation. customization, debugging, and optimization of system services. <p> The animation can help validate the structural properties of the current system against those recorded in system documentation. To illustrate this idea, consider the entity diagram of Figure 5 which describes the Choices virtual memory system <ref> [2] </ref>. The animation gives us high confidence that our documentation is not lacking or obsolete. First, Figures 4 and 5 agree on which classes are interdependent. Second, the animation clustering indicates the importance of the MemoryObject, Domain, AddressTranslator, and MemoryObjectCache classes in the virtual memory system.
Reference: [3] <author> R. H. Campbell, N. Islam, D. Raila, and P. Madany. </author> <title> Designing and Implementing Choices: An Object-Oriented System in C++. </title> <journal> Communications of the ACM, </journal> <pages> pages 117-126, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Object-orientation has been recognized as a very promising paradigm for structuring and organizing operating systems for reuse, flexibility, user-adaptability, and responsiveness <ref> [3, 9] </ref>. <p> We describe various experiments based on an interactive interface tool, OS View , to browse and configure a real operating system using our approach. The tool visualizes and manipulates the dynamics of the Choices <ref> [3] </ref> object-oriented operating system, aiding understanding and programming. The viewer may navigate and explore the Choices environment using OS View : All operating system objects are visualized and, subject to protection and security considerations, can be directly manipulated. <p> Relational queries allow selective scrutiny of special groups of objects respecting user-selectable properties and attributes. Choices permits new services to be automatically loaded in the system as needed by application and system programs without rebooting the kernel <ref> [3] </ref>. OS View allows scanning or browsing of all the currently loaded services and their corresponding classes and class hierarchies. The visually displayed services and class hierarchy trees reflect the running operating system not the compiled system they depict dynamic system state and evolution. <p> This permits, among other things, run-time type checking when object references are passed across protection boundaries. Also important, the class hierarchy information is available at run-time. Class objects (or Classes) support monitoring, manipulation, and extension of running object-oriented services. See <ref> [3] </ref> for implementation details. The kernel's NameServer keeps information about all the currently loaded classes in the system. The Class objects for the loaded classes can be displayed in a browser (see or by the application interface. These objects can be queried about their instances or inheritance hierarchies. <p> guiding efficient service partitioning and overall system organization to reduce the notorious inter-domain communication overhead. 2.3 Interactive evaluation and configura tion of services Choices provides a dynamic loading mechanism that permits users, applications, and system programs to add new service features and options to the system management policies. as needed <ref> [3] </ref>.
Reference: [4] <author> P. Dasgupta. </author> <title> A Probe-based Monitoring Scheme for an Object-Oriented Distributed Operating System. </title> <booktitle> In OOPSLA, </booktitle> <year> 1986. </year>
Reference-contexts: Indeed, a few tools have already demonstrated the usefulness of visualization in explaining complicated dynamic characteristics of an operating system. Examples include MKM [11] which reveals context switching activities in Mach, a monitoring tool for the Clouds object-oriented system described in <ref> [4] </ref>, and a memory management analysis tool presented in [8]. The above tools are dedicated to very specific parts and aspects of the operating system. What sets OS View apart from existing tools is its versatility.
Reference: [5] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlis-sides. </author> <title> Design Patterns, Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas-sachusetts, </address> <year> 1994. </year>
Reference-contexts: First, some of the best features of object-orientation particularly inheritance and dynamic binding - can also make understanding and modifying large, complex object-oriented systems significantly more difficult <ref> [5] </ref>. Second, whereas the designs and implementations of modern object-oriented operating systems are driven by new demands for user-specific tai-lorability and extensibility, these systems remain black boxes whose internals cannot easily be examined or modified by the user or application. <p> These repetitive patterns range from the conventionalized architectural styles [6] such as Pipeline, Layered Hierarchy, and Client-Server to the codified, object-oriented design patterns <ref> [5] </ref>. Estab 4 lished patterns of software construction significantly improve Choices frameworks' understandability by imposing explicit, well-understood collaboration protocols among objects. Of particular help to understanding Choices, a refined framework must respect, maintain, and reuse all the patterns of object interaction imposed by its abstract framework. <p> The software investigator visually inspects the collaboration activities of those classes in the framework that are hypothesized to interact according to specific patterns. The actual interactions are observed for deviation from or conformance to a high-level model of expected behavior. For example, in an animated display of the Mediator <ref> [5] </ref> pattern, the investigator detects violated constraints if supposedly mediated objects are revealed to bypass their Mediator and communicate directly with each other. Pattern-oriented visual analysis of object communication styles quickly exposes anomalies and suspicious behavior. <p> The need for such tools has repeatedly been recognized [8, 9]. The experiment of Figure 6 was greatly facilitated by structuring the class relationships between a Pager and its Policy objects using the Strategy <ref> [5] </ref> pattern. The pattern allows a family of algorithms to be flexibly interchanged during run-time.
Reference: [6] <author> D. Garlan, R. Allen, and J. Ockerbloom. </author> <title> Exploiting Style in Architectural Design Environments. </title> <booktitle> In Proceedings of the 2nd ACM SIGSOFT, </booktitle> <pages> pages 175-188, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: These repetitive patterns range from the conventionalized architectural styles <ref> [6] </ref> such as Pipeline, Layered Hierarchy, and Client-Server to the codified, object-oriented design patterns [5]. Estab 4 lished patterns of software construction significantly improve Choices frameworks' understandability by imposing explicit, well-understood collaboration protocols among objects. <p> Pattern-oriented visual analysis of object communication styles quickly exposes anomalies and suspicious behavior. All viewers familiar with a given pattern (for example, a Pipeline) have a vivid mental picture of the interaction and data exchange rules obeyed by a correct implementation of the pattern <ref> [6] </ref>. 2.2.2 Application to inter-domain interaction studies In micro-kernel operating systems, versions of the experiment of Figure 4 can assist developers of application-specific services in analyzing the subtle interaction of subsystems.
Reference: [7] <author> S. Javey, K. Mitsui, H. Nakamura, K. Y. T. Ohira, K. Kuse, T. Kamimura, and R. Helm. </author> <title> Architecture of the XL C++ browser. </title> <booktitle> In In Proceedins of CASCON '92, </booktitle> <institution> Center for Advanced Studies. IBM Canada, </institution> <year> 1992. </year>
Reference-contexts: The instruments may be activated or deactivated dynamically. 4 The Visualization Model As observed in [16], software visualization often tends to be ad hoc. Although innumerable visual tools for object-oriented systems are currently operational, few explicit schemes for visualizing such systems exist and have been described (see, for example, <ref> [7, 14] </ref>). Even fewer of the published schemes deal with dynamic illustrations of object interactions and relationships the bulk of existing class browsers highlight static source code properties and give no feel of run-time behavior.
Reference: [8] <author> Krueger K., Loftesness D., Vahdat A, and Anderson T. </author> <title> Tools for the Development of Application-Specific Virtual Memory Management. </title> <booktitle> In OOPSLA, </booktitle> <pages> pages 48-64, </pages> <year> 1993. </year>
Reference-contexts: possibilities that the object technology has created, a new specter of complexity appears to be growing as perceived not only by the developers of such diverse, innovative, and ambitious systems, but also by the users who feel the need to modify parts of the system for their own special needs <ref> [8] </ref>. First, some of the best features of object-orientation particularly inheritance and dynamic binding - can also make understanding and modifying large, complex object-oriented systems significantly more difficult [5]. <p> Analyzing and customizing the run-time dynamics of systems built as black boxes is difficult and time-consuming. Adapting system components for non-traditional applications, including but not limited to multimedia, remains a daunting task for application programmers <ref> [8] </ref>. To address the issue of navigating the diverse environment provided by current and future user-specific object-oriented operating systems, we present an "open" visualization and manipulation model that complements the direction taken by the object technology. <p> This experiment demonstrates that OS View also acts as a performance guidance tool, allowing users to dynamically construct and analyze specialized system services with specific features. The need for such tools has repeatedly been recognized <ref> [8, 9] </ref>. The experiment of Figure 6 was greatly facilitated by structuring the class relationships between a Pager and its Policy objects using the Strategy [5] pattern. The pattern allows a family of algorithms to be flexibly interchanged during run-time. <p> Examples include MKM [11] which reveals context switching activities in Mach, a monitoring tool for the Clouds object-oriented system described in [4], and a memory management analysis tool presented in <ref> [8] </ref>. The above tools are dedicated to very specific parts and aspects of the operating system. What sets OS View apart from existing tools is its versatility.
Reference: [9] <author> D. R. Kohr, S. Zhang, M. Rahman, and D. A. Reed. </author> <title> Object-Oriented Parallel Operating Systems: A Performance Study. </title> <booktitle> In Scientific Programming, </booktitle> <year> 1994. </year>
Reference-contexts: Object-orientation has been recognized as a very promising paradigm for structuring and organizing operating systems for reuse, flexibility, user-adaptability, and responsiveness <ref> [3, 9] </ref>. <p> This experiment demonstrates that OS View also acts as a performance guidance tool, allowing users to dynamically construct and analyze specialized system services with specific features. The need for such tools has repeatedly been recognized <ref> [8, 9] </ref>. The experiment of Figure 6 was greatly facilitated by structuring the class relationships between a Pager and its Policy objects using the Strategy [5] pattern. The pattern allows a family of algorithms to be flexibly interchanged during run-time. <p> The experiment of Figure 6 was greatly facilitated by structuring the class relationships between a Pager and its Policy objects using the Strategy [5] pattern. The pattern allows a family of algorithms to be flexibly interchanged during run-time. In general, it has been our experience (and that of others <ref> [9] </ref>) that reliable 5 object. run-time replacement of object-oriented operating system components can be extremely difficult, partly because of the asynchronous nature of operating system activities, partly because of the complexities introduced by inheritance and dynamic binding.
Reference: [10] <author> J. Kramer and J.Magee. </author> <title> The Evolving Philosophers Problem: Dynamic Change Management. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> Vol. 16, NO. 11,, </volume> <month> November </month> <year> 1990. </year>
Reference-contexts: An important lesson to be learned is that system services should be designed and implemented for run-time adaptability where this feature is deemed necessary. Late ad hoc changes to existing implementations can be daunting and frustrating. Kramer and Magee <ref> [10] </ref> provide a good analysis of design and implementation requirements for dynamically reconfigurable software systems. 3 Instrumentation and Classes For programming convenience, we fully automated source code instrumentation.
Reference: [11] <author> T. Lehr, D. Black, Z. Segall, and D. Vrsalovic. </author> <title> Visualizing Context Switches Using PIE and the Mach Kernel Monitor. </title> <booktitle> In Proc. 5th int'l conf. on parallel processing, </booktitle> <volume> vol II, </volume> <pages> pages 298-299, </pages> <year> 1990. </year>
Reference-contexts: Indeed, a few tools have already demonstrated the usefulness of visualization in explaining complicated dynamic characteristics of an operating system. Examples include MKM <ref> [11] </ref> which reveals context switching activities in Mach, a monitoring tool for the Clouds object-oriented system described in [4], and a memory management analysis tool presented in [8]. The above tools are dedicated to very specific parts and aspects of the operating system.
Reference: [12] <author> J. K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: The visualizer and the operating system may be written in different languages. The visualizer may even run on a different machine and operating system to reduce the disturbance on the visualized system. OS View is written in C++ and Tcl/Tk <ref> [12] </ref>, and the displays shown were captured using a Unix host. 4.5 Extracting system information Information about operating system objects is provided by Classes. The information is visualized using one or more DataCollector modules selected from a system library. DataCollector selection permits problem-specific inspection of groups of operating system objects.
Reference: [13] <author> S. Paul and A. Prakash. </author> <title> A Framework for Source Code Search Using Program Patterns. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> Vol. 20, NO. 6,, </volume> <month> June </month> <year> 1994. </year>
Reference-contexts: Late ad hoc changes to existing implementations can be daunting and frustrating. Kramer and Magee [10] provide a good analysis of design and implementation requirements for dynamically reconfigurable software systems. 3 Instrumentation and Classes For programming convenience, we fully automated source code instrumentation. A programmer uses a pattern language <ref> [13] </ref> to specify the operating system classes to be studied and their interesting events like inter-class calling relations. A preprocessor uses pattern matching to locate the programmer-specified classes and their associated events in source code. The events are annotated with calls to appropriate event monitoring instruments. <p> The events are annotated with calls to appropriate event monitoring instruments. Removing instrumentation code is also accomplished by pattern matching to locate and delete unwanted method calls. Readers interested in the details of efficient, pattern language directed source code search and transformation can refer to <ref> [13] </ref>. At run-time, our object-oriented technique for manipulating and monitoring system objects is completely based on first-class classes. Again, our objectified classes provide meta-information about operating system abstractions and services, making the structure and dynamic behavior of the system dis cernible. Class objects also enable run-time modification of the system.
Reference: [14] <author> W. De Pauw, R. Helm, D. Kimelman, and J. Vlissides. </author> <title> Visualizing the Behavior of Object-Oriented Systems. </title> <booktitle> In OOPSLA, </booktitle> <year> 1993. </year>
Reference-contexts: In that view all the dynamic instances of selected classes are displayed in one display, and communication lines are drawn between each pair of interacting instances. Our animated class interaction views were influenced by the insightful studies of De Pauw et al. to portray the behavior of object-oriented systems <ref> [14] </ref>. <p> The instruments may be activated or deactivated dynamically. 4 The Visualization Model As observed in [16], software visualization often tends to be ad hoc. Although innumerable visual tools for object-oriented systems are currently operational, few explicit schemes for visualizing such systems exist and have been described (see, for example, <ref> [7, 14] </ref>). Even fewer of the published schemes deal with dynamic illustrations of object interactions and relationships the bulk of existing class browsers highlight static source code properties and give no feel of run-time behavior. <p> We had few guidelines to follow, given our requirements to both visualize and manipulate the dynamics of a running object-oriented operating system in an object-oriented manner. The animation architecture presented in <ref> [14] </ref> comes somewhat close to addressing some of our concerns. However, the architecture is asymmetric and "read-only" in the sense that primary interest is in collecting and displaying application data; no consideration is given to on-line manipulation and reconfiguration of the visualized application. <p> None of the existing tools expose run-time communication patterns among arbitrary user-selected operating system components and subsystems. Defining an explicit visualization and manipulation model was the key to successful construction of our multi-dimensional tool. As elaborated in section 4, we feel that the animation architecture presented in <ref> [14] </ref> is so far the most noteworthy approach for visualizing (but not manipulating) running object-oriented systems in an object-oriented fashion. A limitation of the architecture is its asymmetric, read-only nature.
Reference: [15] <author> R. S. Pressman. </author> <title> Software Enginnering: A Practitioner's Approach. </title> <publisher> McGraw-Hill, Inc, </publisher> <year> 1992. </year>
Reference-contexts: Our model defines the six abstractions UserInput, Communication, Modifier, DataCollector, DataAnalyzer, and View to encapsulate these tasks respectively. Figure 10 depicts concisely the model constituents and their abstract association using Pressman's entity relationship notation <ref> [15] </ref> (see Figure 5 for description of the links). 4.1 Visual presentation of the OS. The entity View represents a visual display of operating system data and execution. View animations are composed of modifications to graphical objects.
Reference: [16] <author> J. T. Stasko. </author> <title> A Practical Animation Language for Software Development. </title> <booktitle> In Proc. Int'l Conf. on Computer Languages, </booktitle> <address> Los Alomos, </address> <year> 1990. </year>
Reference-contexts: The instances are inserted into the table when constructed and removed from the table when deleted. Associated with each instance is a collection of instruments recording the instance's interesting activities. The instruments may be activated or deactivated dynamically. 4 The Visualization Model As observed in <ref> [16] </ref>, software visualization often tends to be ad hoc. Although innumerable visual tools for object-oriented systems are currently operational, few explicit schemes for visualizing such systems exist and have been described (see, for example, [7, 14]).
Reference: [17] <author> D. Zernik, M. Snir, and D. Malki. </author> <title> Using Visualization Tools to Understand Concurrency. </title> <journal> IEEE Software, </journal> <pages> pages 87-92, </pages> <month> May </month> <year> 1992. </year> <month> 10 </month>
Reference-contexts: Indeed, visualization has been established as effective in a variety of software understanding-intensive tasks, including dynamic analysis of sophisticated concurrent programs <ref> [17] </ref>. Our approach exploits the advantages of interactive software visualization to simplify both the scrutiny and steering of the run-time properties of an object-oriented operating system. We describe various experiments based on an interactive interface tool, OS View , to browse and configure a real operating system using our approach.
References-found: 17

