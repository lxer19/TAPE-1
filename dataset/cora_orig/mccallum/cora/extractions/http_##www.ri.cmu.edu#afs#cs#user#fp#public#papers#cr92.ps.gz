URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/papers/cr92.ps.gz
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/papers/
Root-URL: 
Title: A Proof of the Church-Rosser Theorem and its Representation in a Logical Framework  
Author: Frank Pfenning 
Note: This research was sponsored by the Avionics Laboratory, Wright Research and Development Center, Aeronautical Systems Division (AFSC), U.S. Air Force, Wright-Patterson AFB, Ohio 45433-6543 under Contract F33615-90-C-1465, ARPA Order No. 7597. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of the U.S. government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: September 1992  
Pubnum: CMU-CS-92-186  
Abstract: We give a detailed, informal proof of the Church-Rosser property for the untyped -calculus and show its representation in LF. The proof is due to Tait and Martin-Lof and is based on the notion of parallel reduction. The representation employs higher-order abstract syntax and the judgments-as-types principle and takes advantage of term reconstruction as it is provided in the Elf implementation of LF. Proofs of meta-theorems are represented as higher-level judgments which relate sequences of reductions and conversions. 
Abstract-found: 1
Intro-found: 1
Reference: [Bar80] <author> H. P. Barendregt. </author> <title> The Lambda-Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <year> 1980. </year>
Reference-contexts: We will use M and N as meta-variables ranging over terms. A term of the form x: M binds the variable x and the rule of ff-conversion allows the explicit renaming of bound variables. We use the convention that ff-conversions can be performed implicitly, or, as Barendregt <ref> [Bar80] </ref> puts it: "Terms that are ff-congruent are identified." Conventions of this kind are common right from the beginning of the study of the -calculus (see, for example, the original paper with a proof of the Church-Rosser theorem [CR36]). <p> For example (x: y: x y y) z would be (x: (y: ((x y) y))) z with all Reduction and Conversion 4 explicit parentheses. For further background material on the untyped -calculus, the reader may consult Barendregt's comprehensive book <ref> [Bar80] </ref>. The representation of the syntax of the untyped -calculus is an archetypical use of higher-order abstract syntax. Variables of the object language (the -calculus, in this example) are represented by variables in the meta-language. <p> -&gt; type. apr1*_id : apr1* id1 id1. apr1*_step : apr1* (step1 R1 R2*) (step1 (apr1 R1) S2*) &lt;- apr1* R2* S2*. 4 Parallel Reduction and Conversion The main tool in this proof of the Church-Rosser theorem is the notion of parallel reduction, usually referred to as the Tait/Martin-Lof method (see <ref> [Bar80] </ref>). We write M =) M 0 for M reduces in parallel to M 0 . Parallel reduction is useful, since it will satisfy the so-called diamond property which is depicted in the following diagram.
Reference: [BM79] <author> Robert S. Boyer and J. Strother Moore. </author> <title> A Computational Logic. </title> <booktitle> ACM monograph series. </booktitle> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: It is interesting to note that de Bruijn's motivation for his notation for -terms came from a proof of the Church-Rosser theorem, and Shankar's mechanization of the Church-Rosser theorem in the Boyer-Moore theorem prover <ref> [Sha88, BM79] </ref> uses de Bruijn indices. In LF, the detour via de Bruijn indices is not necessary, since variable naming conventions can be supported directly in the framework. We use parentheses to disambiguate the concrete syntax of terms. <p> We make the reductions explicit in the formulation of the lemma to simplify the correspondence to the implementation. Another mechanical verification of the Church-Rosser theorem was carried out by Shankar [Sha88] using the Boyer-Moore theorem prover <ref> [BM79] </ref>. Shankar's proof used de Bruijn's representation for term of the -calculus [dB72]; here we try a perhaps more direct route using the idea of higher-order abstract syntax. We hope that this provides a good basis for comparison of representation and proof techniques in different systems. <p> We hope to have convinced the reader that with some practice, representation of non-trivial languages and their properties is possible with a resonable amount of effort. It is interesting to compare this representation with the proof by Shankar [Sha88] in the Boyer-Moore theorem prover <ref> [BM79] </ref>. While the basic mathematical ideas are very similar, Shankar expends much effort to develop an appropriate representation (using de Bruijn numbers [dB72]) and proving it correct.
Reference: [CF58] <author> H. B. Curry and R. Feys. </author> <title> Combinatory Logic. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1958. </year>
Reference-contexts: In order to avoid any possible problems which arise from this convention, a common route is to go to combinatory calculi <ref> [CF58] </ref> or to use de Bruijn indices [dB72]. It is interesting to note that de Bruijn's motivation for his notation for -terms came from a proof of the Church-Rosser theorem, and Shankar's mechanization of the Church-Rosser theorem in the Boyer-Moore theorem prover [Sha88, BM79] uses de Bruijn indices.
Reference: [CR36] <author> Alonzo Church and J.B. Rosser. </author> <title> Some properties of conversion. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 36(3) </volume> <pages> 472-482, </pages> <month> May </month> <year> 1936. </year>
Reference-contexts: use the convention that ff-conversions can be performed implicitly, or, as Barendregt [Bar80] puts it: "Terms that are ff-congruent are identified." Conventions of this kind are common right from the beginning of the study of the -calculus (see, for example, the original paper with a proof of the Church-Rosser theorem <ref> [CR36] </ref>). In order to avoid any possible problems which arise from this convention, a common route is to go to combinatory calculi [CF58] or to use de Bruijn indices [dB72]. <p> 00 red The representation in Elf is a direct transcription. &lt;-&gt; : term -&gt; term -&gt; type. %infix none 10 &lt;-&gt; %name &lt;-&gt; C refl : M &lt;-&gt; M. sym : M &lt;-&gt; M' trans: M &lt;-&gt; M' -&gt; M' &lt;-&gt; M'' red : M --&gt;* M' The Church-Rosser theorem <ref> [CR36] </ref> now states that if M ! M 0 then there exists some N such that M ! fl N and M 0 ! fl N . <p> Now we can prove the diamond property for multi-step reduction which we call confluence. In the literature this property is often refered to as the Church-Rosser theorem, since in most situations it is equivalent to the property of conversion actually proved in <ref> [CR36] </ref> (here: Theorem 16). Lemma 8 (Confluence) If R fl0 :: M =) fl M 0 and R fl00 :: M =) fl M 00 then there exists an N and reductions S fl0 :: M 0 =) fl N and S fl00 :: M 00 =) fl N .
Reference: [dB72] <author> N. G. de Bruijn. </author> <title> Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5) </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference-contexts: In order to avoid any possible problems which arise from this convention, a common route is to go to combinatory calculi [CF58] or to use de Bruijn indices <ref> [dB72] </ref>. It is interesting to note that de Bruijn's motivation for his notation for -terms came from a proof of the Church-Rosser theorem, and Shankar's mechanization of the Church-Rosser theorem in the Boyer-Moore theorem prover [Sha88, BM79] uses de Bruijn indices. <p> We make the reductions explicit in the formulation of the lemma to simplify the correspondence to the implementation. Another mechanical verification of the Church-Rosser theorem was carried out by Shankar [Sha88] using the Boyer-Moore theorem prover [BM79]. Shankar's proof used de Bruijn's representation for term of the -calculus <ref> [dB72] </ref>; here we try a perhaps more direct route using the idea of higher-order abstract syntax. We hope that this provides a good basis for comparison of representation and proof techniques in different systems. <p> It is interesting to compare this representation with the proof by Shankar [Sha88] in the Boyer-Moore theorem prover [BM79]. While the basic mathematical ideas are very similar, Shankar expends much effort to develop an appropriate representation (using de Bruijn numbers <ref> [dB72] </ref>) and proving it correct. Many of the actual proofs are not even explicitly represented, since they are found automatically once the right series of lemmas has been developed.
Reference: [Fel89] <author> Amy Felty. </author> <title> Specifying and Implementing Theorem Provers in a Higher-Order Logic Programming Language. </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: It may appear that the framework is specifically designed just for the implementation of the -calculus, but in fact bound variables occur in most programming languages and the technique of higher-order abstract syntax has wide applicability in theorem proving and logic programming <ref> [Fel89, NM88, Pau86] </ref>, and the theory of programming languages [Han91, HP92, MP91]. The second stage is the formalization of the semantics of the language which is given via judgments defined by inference rules. The judgments are implemented as types and deductions as objects.
Reference: [Han91] <author> John Hannan. </author> <title> Investigating a Proof-Theoretic Meta-Language for Functional Programs. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <month> January </month> <year> 1991. </year> <note> Available as MS-CIS-91-09. </note>
Reference-contexts: may appear that the framework is specifically designed just for the implementation of the -calculus, but in fact bound variables occur in most programming languages and the technique of higher-order abstract syntax has wide applicability in theorem proving and logic programming [Fel89, NM88, Pau86], and the theory of programming languages <ref> [Han91, HP92, MP91] </ref>. The second stage is the formalization of the semantics of the language which is given via judgments defined by inference rules. The judgments are implemented as types and deductions as objects. <p> In our example, we will represent various reduction and conversion relations in this style. Similar techniques have been used to specify type systems, operational semantics, compilation and other aspects of the semantics of programming languages (see, for example, <ref> [Han91, HP92, Har90, MP91] </ref>). The third stage is the formalization of the proofs of meta-theorems in the framework. The construction which is implicit in the proof is represented as a judgment which relates deductions.
Reference: [Har90] <author> Robert Harper. </author> <title> Systems of polymorphic type assignment in LF. </title> <type> Technical Report CMU-CS-90-144, </type> <institution> Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: In our example, we will represent various reduction and conversion relations in this style. Similar techniques have been used to specify type systems, operational semantics, compilation and other aspects of the semantics of programming languages (see, for example, <ref> [Han91, HP92, Har90, MP91] </ref>). The third stage is the formalization of the proofs of meta-theorems in the framework. The construction which is implicit in the proof is represented as a judgment which relates deductions.
Reference: [HHP] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the ACM, </journal> <note> 199? To appear. Available as Technical Report CMU-CS-89-173, Carnegie Mellon University. A preliminary version appeared in Symposium on Logic in Computer Science, pages 194-204, </note> <month> June </month> <year> 1987. </year>
Reference: [HP92] <author> John Hannan and Frank Pfenning. </author> <title> Compiler verification in LF. </title> <editor> In Andre Scedrov, editor, </editor> <booktitle> Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 407-418, </pages> <address> Santa Cruz, California, June 1992. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: may appear that the framework is specifically designed just for the implementation of the -calculus, but in fact bound variables occur in most programming languages and the technique of higher-order abstract syntax has wide applicability in theorem proving and logic programming [Fel89, NM88, Pau86], and the theory of programming languages <ref> [Han91, HP92, MP91] </ref>. The second stage is the formalization of the semantics of the language which is given via judgments defined by inference rules. The judgments are implemented as types and deductions as objects. <p> In our example, we will represent various reduction and conversion relations in this style. Similar techniques have been used to specify type systems, operational semantics, compilation and other aspects of the semantics of programming languages (see, for example, <ref> [Han91, HP92, Har90, MP91] </ref>). The third stage is the formalization of the proofs of meta-theorems in the framework. The construction which is implicit in the proof is represented as a judgment which relates deductions. <p> This is done via an explicit construction which can be represented as a judgment. Verifying that this higher-level judgment indeed represents a proof is left to a process called schema-checking (see <ref> [PR92, HP92] </ref>) which is currently mostly done by hand, since the implementation is still incomplete. This means that there is still the possibility of error in the implementation of the proof. Thus all three stages, representation of abstract syntax, semantics, and meta-theory, are carried out within the same logical framework. <p> Other non-trivial examples have been carried out using the methodology, such as a verification of type soundness of Mini-ML [MP91] and a compiler from Mini-ML to a variant of the Categorial Abstract Machine (CAM) <ref> [HP92] </ref>. As an example for the execution of the Elf program above, reconsider the term (x: x x) ((y: y) (z: z)) which can be reduced in four different ways: the outer redex, the inner redex, both, or neither.
Reference: [Mey82] <author> Albert R. Meyer. </author> <title> What is a model of the lambda calculus. </title> <journal> Information and Control, </journal> <volume> 52 </volume> <pages> 87-122, </pages> <year> 1982. </year>
Reference-contexts: framework and binds a variable x of type A in the object P. x = x x: M = lam ([x:term] M ) For example, x: y: x = lam [x:term] lam [y:term] x: As far as we know, this representation is due to Wadsworth [Wad76] and used by Meyer <ref> [Mey82] </ref> in the construction of an environment model of the untyped -calculus. The notation used there is for lam and for app.
Reference: [ML80] <author> Per Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In Logic, Methodology and Philosophy of Science VI, </booktitle> <pages> pages 153-175. </pages> <publisher> North-Holland, </publisher> <year> 1980. </year>
Reference-contexts: This is the essence of the notion of hypothetical judgment (see, for example, <ref> [ML80] </ref>). We represent the deduction R of the (hypothetical) judgment in the left premiss as a function whose first argument is a term x and whose second argument is a deduction u of x =) x.
Reference: [MP91] <author> Spiro Michaylov and Frank Pfenning. </author> <title> Natural semantics and some of its meta-theory in Elf. </title> <editor> In L.-H. Eriksson, L. Hallnas, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the Second International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 299-344, </pages> <address> Stockholm, Sweden, </address> <month> January </month> <year> 1991. </year> <note> Springer-Verlag LNAI 596. </note>
Reference-contexts: may appear that the framework is specifically designed just for the implementation of the -calculus, but in fact bound variables occur in most programming languages and the technique of higher-order abstract syntax has wide applicability in theorem proving and logic programming [Fel89, NM88, Pau86], and the theory of programming languages <ref> [Han91, HP92, MP91] </ref>. The second stage is the formalization of the semantics of the language which is given via judgments defined by inference rules. The judgments are implemented as types and deductions as objects. <p> In our example, we will represent various reduction and conversion relations in this style. Similar techniques have been used to specify type systems, operational semantics, compilation and other aspects of the semantics of programming languages (see, for example, <ref> [Han91, HP92, Har90, MP91] </ref>). The third stage is the formalization of the proofs of meta-theorems in the framework. The construction which is implicit in the proof is represented as a judgment which relates deductions. <p> Briefly, Elf searches through a signature in a depth-first fashion, trying inference rules from the top to the bottom, solving the innermost subgoal first. For more information on the operational semantics of Elf the reader is referred to [Pfe91b] or <ref> [MP91] </ref> for a more tutorial presentation. Through sheer luck, however, we can generate the deduction above even with this operationally inadequate signature. <p> These observations together verify the diamond lemma. Schema-checking is sketched in [PR92], but the implementation is incomplete and most of it still has to be done by hand. Other non-trivial examples have been carried out using the methodology, such as a verification of type soundness of Mini-ML <ref> [MP91] </ref> and a compiler from Mini-ML to a variant of the Categorial Abstract Machine (CAM) [HP92].
Reference: [NM88] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <volume> Volume 1, </volume> <pages> pages 810-827, </pages> <address> Cambridge, Massachusetts, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: It may appear that the framework is specifically designed just for the implementation of the -calculus, but in fact bound variables occur in most programming languages and the technique of higher-order abstract syntax has wide applicability in theorem proving and logic programming <ref> [Fel89, NM88, Pau86] </ref>, and the theory of programming languages [Han91, HP92, MP91]. The second stage is the formalization of the semantics of the language which is given via judgments defined by inference rules. The judgments are implemented as types and deductions as objects.
Reference: [Pau86] <author> Lawrence Paulson. </author> <title> Natural deduction as higher-order resolution. </title> <journal> Journal of Logic Programming, </journal> <volume> 3 </volume> <pages> 237-258, </pages> <year> 1986. </year> <note> References 46 </note>
Reference-contexts: It may appear that the framework is specifically designed just for the implementation of the -calculus, but in fact bound variables occur in most programming languages and the technique of higher-order abstract syntax has wide applicability in theorem proving and logic programming <ref> [Fel89, NM88, Pau86] </ref>, and the theory of programming languages [Han91, HP92, MP91]. The second stage is the formalization of the semantics of the language which is given via judgments defined by inference rules. The judgments are implemented as types and deductions as objects.
Reference: [Pfe91a] <author> Frank Pfenning. </author> <title> An implementation of the Elf core language in Standard ML. </title> <note> Available via ftp over the Internet, September 1991. Send mail to elf-request@cs.cmu.edu for further information. </note>
Reference: [Pfe91b] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: Such declarations are translated into LF by adding (implicit) -quantifiers for all free variables. The corresponding (implicit) arguments are reconstructed by the Elf front end employing a variant of higher-order unification. This and other aspects of Elf are explained in more detail in <ref> [Pfe91b] </ref>, but we hope that the material in the remainder of this report can be understood at a pragmatic level without detailed knowledge about the term reconstruction algorithm. Single-line comments begin with % and extend through the end of the line. <p> Briefly, Elf searches through a signature in a depth-first fashion, trying inference rules from the top to the bottom, solving the innermost subgoal first. For more information on the operational semantics of Elf the reader is referred to <ref> [Pfe91b] </ref> or [MP91] for a more tutorial presentation. Through sheer luck, however, we can generate the deduction above even with this operationally inadequate signature.
Reference: [Plo75] <author> G. D. Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: Recall that substitution may require renaming of bound variables in M in order to avoid variable capture. This reduction may be applied anywhere inside a term|something which is not true, for example, for evaluation relations for programming languages (both in call-by-name and call-by-value semantics, see <ref> [Plo75] </ref>). One may consider this as a distinguishing characteristic of general reduction compared to evaluation. Thus the first judgment we would like to define is M ! M 0 (read: M reduces to M 0 ). This judgment is defined by a set of inference rules.
Reference: [PR92] <author> Frank Pfenning and Ekkehard Rohwedder. </author> <title> Implementing the meta-theory of deductive systems. </title> <editor> In D. Kapur, editor, </editor> <booktitle> Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <pages> pages 537-551, </pages> <address> Saratoga Springs, New York, June 1992. </address> <publisher> Springer-Verlag LNAI 607. </publisher>
Reference-contexts: This is done via an explicit construction which can be represented as a judgment. Verifying that this higher-level judgment indeed represents a proof is left to a process called schema-checking (see <ref> [PR92, HP92] </ref>) which is currently mostly done by hand, since the implementation is still incomplete. This means that there is still the possibility of error in the implementation of the proof. Thus all three stages, representation of abstract syntax, semantics, and meta-theory, are carried out within the same logical framework. <p> The process of schema-checking guarantees that that dia is The Proof of the Church-Rosser Theorem 25 total in its first two arguments. These observations together verify the diamond lemma. Schema-checking is sketched in <ref> [PR92] </ref>, but the implementation is incomplete and most of it still has to be done by hand.
Reference: [Sha88] <author> N. Shankar. </author> <title> A mechanical proof of the Church-Rosser theorem. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 35(3) </volume> <pages> 475-522, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: It is interesting to note that de Bruijn's motivation for his notation for -terms came from a proof of the Church-Rosser theorem, and Shankar's mechanization of the Church-Rosser theorem in the Boyer-Moore theorem prover <ref> [Sha88, BM79] </ref> uses de Bruijn indices. In LF, the detour via de Bruijn indices is not necessary, since variable naming conventions can be supported directly in the framework. We use parentheses to disambiguate the concrete syntax of terms. <p> In fact, it is the substitution lemma which motivates the notion of parallel reduction. We make the reductions explicit in the formulation of the lemma to simplify the correspondence to the implementation. Another mechanical verification of the Church-Rosser theorem was carried out by Shankar <ref> [Sha88] </ref> using the Boyer-Moore theorem prover [BM79]. Shankar's proof used de Bruijn's representation for term of the -calculus [dB72]; here we try a perhaps more direct route using the idea of higher-order abstract syntax. <p> We hope to have convinced the reader that with some practice, representation of non-trivial languages and their properties is possible with a resonable amount of effort. It is interesting to compare this representation with the proof by Shankar <ref> [Sha88] </ref> in the Boyer-Moore theorem prover [BM79]. While the basic mathematical ideas are very similar, Shankar expends much effort to develop an appropriate representation (using de Bruijn numbers [dB72]) and proving it correct.
Reference: [Wad76] <author> Christopher P. Wadsworth. </author> <title> The relation between computational and denotational properties for Scott's D 1 -models of the lambda-calculus. </title> <journal> SIAM Journal of Computing, </journal> <volume> 5(3) </volume> <pages> 488-521, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: syntax for abstraction in the framework and binds a variable x of type A in the object P. x = x x: M = lam ([x:term] M ) For example, x: y: x = lam [x:term] lam [y:term] x: As far as we know, this representation is due to Wadsworth <ref> [Wad76] </ref> and used by Meyer [Mey82] in the construction of an environment model of the untyped -calculus. The notation used there is for lam and for app.
References-found: 21

