URL: ftp://ftp.cs.umd.edu/pub/papers/TRs/3196.ps.Z
Refering-URL: http://www.cs.umd.edu/users/davew/pubs.html
Root-URL: 
Email: pugh@cs.umd.edu davew@cs.umd.edu  
Title: An Exact Method for Analysis of Value-based Array Data Dependences  
Author: William Pugh David Wonnacott 
Note: This work is supported by an NSF PYI grant CCR-9157384 and by a Packard Fellowship.  
Address: College Park, MD 20742  
Affiliation: Institute for Advanced Computer Studies Dept. of Computer Science Dept. of Computer Science Univ. of Maryland,  
Date: December, 1993  
Pubnum: UMIACS-TR-93-137  CS-TR-3196  
Abstract: Standard array data dependence testing algorithms give information about the aliasing of array references. If statement 1 writes a[5], and statement 2 later reads a[5], standard techniques described this as a flow dependence, even if there was an intervening write. We call a dependence between two references to the same memory location a memory-based dependence. In contrast, if there are no intervening writes, the references touch the same value and we call the dependence a value-based dependence. There has been a surge of recent work on value-based array data dependence analysis (also referred to as computation of array data-flow dependence information). In this paper, we describe a technique that is exact over programs without control flow (other than loops) and non-linear references. We compare our proposal with the technique proposed by Paul Feautrier, which is the other technique that is complete over the same domain as ours. We also compare our work with that of Tu and Padua, a representative approximate scheme for array privatization. 
Abstract-found: 1
Intro-found: 1
Reference: [AI91] <author> Corinne Ancourt and Fran~cois Irigoin. </author> <title> Scanning polyhedra with do loops. </title> <booktitle> In Proc. of the Third ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 39-50, </pages> <month> April </month> <year> 1991. </year>
Reference: [AL93] <author> Saman P. Amarasinghe and Monica S. Lam. </author> <title> Communication optimization and code generation for distributed memory machines. </title> <booktitle> In ACM '93 Conf. on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1993. </year> <month> 16 </month>
Reference-contexts: Since their scheme is targeted at priva-tizing arrays, the information they determine is sufficient. For other purposes, such as analyzing communications <ref> [AL93] </ref> and scalar replacement, additional information is needed. <p> It is unclear if the exact information computed by our scheme and by Feautrier will ever be required, or if approximate information, computed by schemes such as [TP92, PEH + 93], will suffice. For array privatization, approximate schemes may suffice but more advanced transformations <ref> [AL93, PW93] </ref> may require more exact information. We have pursued exact analysis methods because we want to determine exactly how expensive it will be to compute, and because we find that it gives us a better insight into the problem.
Reference: [Bra88] <author> Thomas Brandes. </author> <title> The importance of direct dependences for automatic parallelism. </title> <booktitle> In Proc of 1988 International Conference on Supercomputing, </booktitle> <pages> pages 407-417, </pages> <month> July </month> <year> 1988. </year>
Reference: [CK88] <author> D. Callahan and K. Kennedy. </author> <title> Analysis of interprocedural side effects in a parallel programming environment. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 5 </volume> <pages> 517-550, </pages> <year> 1988. </year>
Reference-contexts: It could make a difference when non-linear subscripts occur, but it is unclear which would be advantageous. Tu and Padua use an extension of regular sections <ref> [CK88] </ref> to represent used, defined and exposed array sections. Their intersection (and their difference?) operators are approximate.
Reference: [DGS93] <author> Evelyn Duesterwald, Rajiv Gupta, and Mary Lou Soffa. </author> <title> A practical data flow framework for array reference analysis and its use in optimizations. </title> <booktitle> In ACM '93 Conf. on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1993. </year>
Reference: [Fea88a] <author> P. Feautrier. </author> <title> Parametric integer programming. </title> <journal> Operationnelle/Operations Research, </journal> <volume> 22(3) </volume> <pages> 243-268, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Check each leaf of the quast/LWT to verify that it is feasible. (Note: this check can be done on-the-fly while building the quast/LWT). 4.1.1 Parametric Integer Programming with the Omega test Paul Feautrier discusses parametric integer programming <ref> [Fea88a] </ref>, which is the problem of finding the optimal/maximal solution to a set of linear constraints over integer variables. For example, maxfi j i j ^ i kg = if j k then j else k. <p> It is our belief that this is responsible for a substantial portion of the time required by Feautrier's algorithm. Some efficient scheme for testing the feasibility of a set of linear constraints is needed, such as [MHL91, Pug92]. In is unclear how effective PIP <ref> [Fea88a] </ref> is at checking feasibility (as opposed to parametric integer programming). In addition, some method like the one we describe here will be required to handle negation efficiently.
Reference: [Fea88b] <author> Paul Feautrier. </author> <title> Array expansion. </title> <booktitle> In ACM Int. Conf. on Supercomputing, St Malo, </booktitle> <pages> pages 429-441, </pages> <year> 1988. </year>
Reference-contexts: However, our method may be more efficient for many simple cases that arise in many applications. 4 Related Work The method described by Feautrier <ref> [Fea88b, Fea91] </ref> was the first method for computing exact value-based dependence information over the restricted domain of programs with structured control flow and affine subscripts, guards and loop bounds. Dror Maydan and Monica Lam developed an alternative way of computing the same information as Feautrier does.
Reference: [Fea91] <author> Paul Feautrier. </author> <title> Dataflow analysis of array and scalar references. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 20(1), </volume> <month> February </month> <year> 1991. </year>
Reference-contexts: However, our method may be more efficient for many simple cases that arise in many applications. 4 Related Work The method described by Feautrier <ref> [Fea88b, Fea91] </ref> was the first method for computing exact value-based dependence information over the restricted domain of programs with structured control flow and affine subscripts, guards and loop bounds. Dror Maydan and Monica Lam developed an alternative way of computing the same information as Feautrier does. <p> and Monica Lam noted that in many common situations, faster techniques would suffice. 4.1.3 Computing dependences from many writes to a read When quasts or LWT's from multiple writes are combined to give a single description of which writes reach a read, the size of the quast/LWT can grow exponentially <ref> [Fea91, May92] </ref>. There is not yet enough experimental evidence to evaluate the growth of quast's/LWT's vs. the growth in the number of conjunctions produced by our methods. We suspect that the requirement that the quast/LWT be a decision tree will tend to make it grow faster. <p> Whatever condition is tested as the root of the tree becomes part of the conditions of every leaf, even it is not relevant to some leaves. 4.1.4 Checking feasibility and handling negation The quasts or Last Write Trees constructed by combining quast's/LWT's may contain infeasible paths <ref> [Fea91, MAL93] </ref>. To enable compile-time transformations such as privatization, it is necessary to determine which of these paths are feasible. This cost is likely to be substantial, particularly since the number of leaves in a quast/LWT grows exponentially when multiple writes are considered. <p> However, we may wish to avoid applying them blindly. It may be cost effective to determine when it might be profitable to have exact value-based dependence information, and 14 Analyzing array variables only From Code M V M + V f77 D M+V D <ref> [Fea91] </ref> across 3 6 9 200 13 0.69 burg 14 58 72 600 32 2.25 relax 4 20 24 400 8 3.00 gosser 5 52 58 700 16 3.63 choles 4 7 12 600 12 1.00 lanczos 29 78 107 1700 136 0.79 jacobi 379 621 999 1600 255 3.92 [MAL93] <p> 1.78 NAS cfft2d1 33 484 516 1500 52 9.92 Kernels cholsky 86 156 242 2900 106 2.28 emit 34 87 121 3700 129 0.94 gmtry 25 70 95 3700 91 1.04 vpenta 262 163 425 5700 1501 0.28 Analyzing array and scalar variables From Code M V M + V <ref> [Fea91] </ref> D M+V D [Fea91] across 3 6 9 600 13 0.69 burg 15 76 91 5600 46 1.98 relax 4 19 24 1700 8 3.00 gosser 6 56 62 2800 24 2.58 choles 6 25 32 2600 32 1.00 lanczos 28 91 119 12600 148 0.80 jacobi 386 718 1104 <p> 484 516 1500 52 9.92 Kernels cholsky 86 156 242 2900 106 2.28 emit 34 87 121 3700 129 0.94 gmtry 25 70 95 3700 91 1.04 vpenta 262 163 425 5700 1501 0.28 Analyzing array and scalar variables From Code M V M + V <ref> [Fea91] </ref> D M+V D [Fea91] across 3 6 9 600 13 0.69 burg 15 76 91 5600 46 1.98 relax 4 19 24 1700 8 3.00 gosser 6 56 62 2800 24 2.58 choles 6 25 32 2600 32 1.00 lanczos 28 91 119 12600 148 0.80 jacobi 386 718 1104 81900 374 2.95 [MAL93] <p> Kernels cholsky 84 162 246 107 2.30 emit 37 144 181 181 1.00 gmtry 34 146 180 161 1.12 vpenta 253 220 473 1757 0.27 M - Memory-based dependence analysis time V - Value-based flow dependence analysis time (needs M ) f77 Time required to compile with f77 -c -O3 <ref> [Fea91] </ref> Times reported by Feautrier D - # of dependences for which value-based dependences are calculated (all times in milliseconds) Table 1: Evaluation of times required to perform analysis 15 apply them only in those cases. Some methods for doing this are described in [PW93].
Reference: [GS90] <author> Thomas Gross and Peter Steenkiste. </author> <title> Structured dataflow analysis for arrays and its use in an optimizing compiler. </title> <journal> Software Practice and Experience, </journal> <volume> 20 </volume> <pages> 133-155, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: previous work on the Omega test [Pug92, PW92] and the techniques described here for handling negation (Section 3). 4.3 Tu's and Padua's Approach We will briefly compare our scheme with that of Tu and Padua [TP92, PEH + 93], as a representative example of other related work on array privatization <ref> [GS90, Ros90, Li92] </ref>. Their scheme handles control flow, while ours currently does not.
Reference: [Li92] <author> Zhiyuan Li. </author> <title> Array privatization for parallel execution of loops. </title> <booktitle> In Proc. of the 1992 International Conference on Supercomputing, </booktitle> <pages> pages 313-322, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: previous work on the Omega test [Pug92, PW92] and the techniques described here for handling negation (Section 3). 4.3 Tu's and Padua's Approach We will briefly compare our scheme with that of Tu and Padua [TP92, PEH + 93], as a representative example of other related work on array privatization <ref> [GS90, Ros90, Li92] </ref>. Their scheme handles control flow, while ours currently does not.
Reference: [MAL92] <author> Dror E. Maydan, Saman P. Amarasinghe, and Monica S. Lam. </author> <title> Data dependence and data-flow analysis of arrays. </title> <booktitle> In 5th Workshop on Languages and Compilers for Parallel Computing (Yale University tech. report YALEU/DCS/RR-915), </booktitle> <pages> pages 283-292, </pages> <month> August </month> <year> 1992. </year>
Reference: [MAL93] <author> Dror E. Maydan, Saman P. Amarasinghe, and Monica S. Lam. </author> <title> Array data-flow analysis and its use in array privatization. </title> <booktitle> In ACM '93 Conf. on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: Whatever condition is tested as the root of the tree becomes part of the conditions of every leaf, even it is not relevant to some leaves. 4.1.4 Checking feasibility and handling negation The quasts or Last Write Trees constructed by combining quast's/LWT's may contain infeasible paths <ref> [Fea91, MAL93] </ref>. To enable compile-time transformations such as privatization, it is necessary to determine which of these paths are feasible. This cost is likely to be substantial, particularly since the number of leaves in a quast/LWT grows exponentially when multiple writes are considered. <p> Directly converting these expressions into disjunctive normal form would be infeasible for many real problems. The methods we describe in Section 3 should reduce this blow-up. The methods described by <ref> [MAL93] </ref> can handle only special cases of negated non-convex constraints. Paul Feautrier uses quasi-linear constraints (constraints containing floor and ceiling operations) to handle negation. Unfortunately, this technique is not complete for all cases. In Section 3.2.1, we describe techniques that do not suffer this incompleteness. <p> While the PIP algorithm is implemented in C, the remainder of his algorithm is implemented in Lisp. Work is underway to recode Feautrier's algorithms more efficiently. Feautrier hopes that this will result in a significant speed-up. Dror Maydan <ref> [MAL93] </ref> notes that his techniques require 100 milliseconds on a Decstation 3100 (a SPECint89 rating of 11.8) to evaluate the relax example and to calculate the dependence direction/distance vectors from the LWT's. <p> [Fea91] across 3 6 9 200 13 0.69 burg 14 58 72 600 32 2.25 relax 4 20 24 400 8 3.00 gosser 5 52 58 700 16 3.63 choles 4 7 12 600 12 1.00 lanczos 29 78 107 1700 136 0.79 jacobi 379 621 999 1600 255 3.92 <ref> [MAL93] </ref> ocean (extract) 11 14 25 500 16 1.56 Perfect olda (simplified) 51 338 389 3300 48 8.10 NASA btrix 330 1036 1369 8600 771 1.78 NAS cfft2d1 33 484 516 1500 52 9.92 Kernels cholsky 86 156 242 2900 106 2.28 emit 34 87 121 3700 129 0.94 gmtry 25 <p> [Fea91] across 3 6 9 600 13 0.69 burg 15 76 91 5600 46 1.98 relax 4 19 24 1700 8 3.00 gosser 6 56 62 2800 24 2.58 choles 6 25 32 2600 32 1.00 lanczos 28 91 119 12600 148 0.80 jacobi 386 718 1104 81900 374 2.95 <ref> [MAL93] </ref> ocean (extract) 10 15 25 16 1.56 Perfect olda (simplified) 65 732 796 142 5.61 NASA btrix 331 1175 1515 809 1.87 NAS cfft2d1 37 540 577 103 5.60 Kernels cholsky 84 162 246 107 2.30 emit 37 144 181 181 1.00 gmtry 34 146 180 161 1.12 vpenta 253
Reference: [Mas94] <author> Vadim Maslov. </author> <title> Lazy array data-flow dependence analysis. </title> <booktitle> In ACM Conference on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: Dror Maydan and Monica Lam developed an alternative way of computing the same information as Feautrier does. This method is faster, but does not apply in some cases (in which case the falls back to Feautrier's method). Vadim Maslov <ref> [Mas94] </ref> has recently described a new framework for value-based dependence information that is exact over the same domain. <p> r ffi 2)] ! [i r ] j 0 (i r ffi 2) m ^ q i r p ^ i r %2 ng It is currently an open question as to whether this extension will allow us to obtain these properties in all cases. 4.2 Maslov's approach Vadim Maslov <ref> [Mas94] </ref> suggested that using just Equation 2 to compute value-based dependences would be inefficient. His observation was that it is wasteful to consider all possible killers for every possible dependence; instead, we can keep track of the upwards exposed iterations of a read, and utilize this information.
Reference: [May92] <author> Dror Eliezer Maydan. </author> <title> Accurate Analysis of Array References. </title> <type> PhD thesis, </type> <institution> Computer Systems Laboratory, Stanford U., </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: and Monica Lam noted that in many common situations, faster techniques would suffice. 4.1.3 Computing dependences from many writes to a read When quasts or LWT's from multiple writes are combined to give a single description of which writes reach a read, the size of the quast/LWT can grow exponentially <ref> [Fea91, May92] </ref>. There is not yet enough experimental evidence to evaluate the growth of quast's/LWT's vs. the growth in the number of conjunctions produced by our methods. We suspect that the requirement that the quast/LWT be a decision tree will tend to make it grow faster.
Reference: [MHL91] <author> D. E. Maydan, J. L. Hennessy, and M. S. Lam. </author> <title> Efficient and exact data dependence analysis. </title> <booktitle> In ACM SIGPLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-14, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: It is our belief that this is responsible for a substantial portion of the time required by Feautrier's algorithm. Some efficient scheme for testing the feasibility of a set of linear constraints is needed, such as <ref> [MHL91, Pug92] </ref>. In is unclear how effective PIP [Fea88a] is at checking feasibility (as opposed to parametric integer programming). In addition, some method like the one we describe here will be required to handle negation efficiently.
Reference: [Opp78] <author> D. Oppen. </author> <title> A 2 2 2 pn upper bound on the complexity of presburger arithmetic. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 16(3) </volume> <pages> 323-332, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: When applying negation, we use the techniques of this section. The best known upper bound on the performance of an algorithm for verifying Presburger formulas is 2 2 2 n <ref> [Opp78] </ref>, and we have no reason to believe that this method be provide better worst-case performance.
Reference: [PEH + 93] <author> David A. Padua, Rudolf Eigenmann, Jay Hoeflinger, Paul Petersen, Peng Tu, Stephen Weatherford, and Keith Faigin. </author> <title> Polaris: A new-generation parallelizing compiler for mpps. CSRD Rpt. </title> <type> 1306, </type> <institution> Dept. of Computer Science, University of Illinois at Urb ana-Champaign, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Maslov utilizes our previous work on the Omega test [Pug92, PW92] and the techniques described here for handling negation (Section 3). 4.3 Tu's and Padua's Approach We will briefly compare our scheme with that of Tu and Padua <ref> [TP92, PEH + 93] </ref>, as a representative example of other related work on array privatization [GS90, Ros90, Li92]. Their scheme handles control flow, while ours currently does not. <p> Equivalently, we could perform the upward-exposed and downward-exposed calculations of Section 2.2. They <ref> [PEH + 93] </ref> note that this is imprecise: ... a naive aggregation of U SE b (L) may exaggerate the exposed use set.... They do not describe in [TP92, PEH + 93] the algorithm used to perform the more sophisticated aggregation. <p> Equivalently, we could perform the upward-exposed and downward-exposed calculations of Section 2.2. They [PEH + 93] note that this is imprecise: ... a naive aggregation of U SE b (L) may exaggerate the exposed use set.... They do not describe in <ref> [TP92, PEH + 93] </ref> the algorithm used to perform the more sophisticated aggregation. It is our belief that the effect of the more sophisticated aggregation will be equivalent, in our scheme, to using only partial covers in computing kills. <p> In addition, some method like the one we describe here will be required to handle negation efficiently. It is unclear if the exact information computed by our scheme and by Feautrier will ever be required, or if approximate information, computed by schemes such as <ref> [TP92, PEH + 93] </ref>, will suffice. For array privatization, approximate schemes may suffice but more advanced transformations [AL93, PW93] may require more exact information.
Reference: [Pug91] <author> William Pugh. </author> <title> Uniform techniques for loop optimization. </title> <booktitle> In 1991 International Conference on Supercom puting, </booktitle> <pages> pages 341-352, </pages> <address> Cologne, Germany, </address> <month> June </month> <year> 1991. </year>
Reference: [Pug92] <author> William Pugh. </author> <title> The Omega test: a fast and practical integer programming algorithm for dependence analysis. </title> <journal> Communications of the ACM, </journal> <volume> 8 </volume> <pages> 102-114, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Variables that we would like to eliminate but cannot because they would intro-duce quasi-linear constraints are called wildcard variables. When we need to verify the existence of solutions to sets of constraints, methods described in <ref> [Pug92] </ref> allow us to do so accurately in the presence of wildcard variables. However, it is easier to negate sets of constraints containing quasilinear constraints than sets containing wildcards. We therefore use quasilinear constraints, when possible, to perform negation. <p> Rather than introducing ceiling and floor operators, we can eliminate variables by using splintering <ref> [Pug92] </ref>. Splintering performs exact elimination by producing a set of problems, the union of which exactly describe the result of the quantifier elimination. The subproblems produced by splintering may contain wildcards (existentially quantified variables). <p> We eliminate universal quantifiers by replacing formulas of the form 8x; P with formulas of the form :9x s:t: :P . Given a quantified expression 9x s:t: P where P contains no embedded quantifiers, we convert P into disjunctive normal form, and then apply the methods of <ref> [Pug92] </ref> to eliminate the existential quantifier (possible leaving wildcards). When applying negation, we use the techniques of this section. <p> Vadim Maslov [Mas94] has recently described a new framework for value-based dependence information that is exact over the same domain. In previous work we described exact methods for computing memory-based dependences <ref> [Pug92] </ref> and methods for identifying some, but not all, dependences that were not value-based [PW92]. 4.1 Feautrier's and Maydan's approach Feautrier and Maydan compute a decision tree (called a quast or a last write tree (LWT)) to describe a dependence. <p> We may be able to handle more killers as partial covers and terminators and we may be able to avoid considering some killers at all. Maslov utilizes our previous work on the Omega test <ref> [Pug92, PW92] </ref> and the techniques described here for handling negation (Section 3). 4.3 Tu's and Padua's Approach We will briefly compare our scheme with that of Tu and Padua [TP92, PEH + 93], as a representative example of other related work on array privatization [GS90, Ros90, Li92]. <p> to omega@cs.umd.edu to receive a copy of the benchmarks and be added to the dataflow benchmarks mailing list. 7 Conclusion The cost of performing exact value-based flow dependence analysis for arrays appears to be 2-7 times that required to do exact memory-based exact array dependence analysis using integer programming techniques <ref> [Pug92] </ref>. We believe that these methods are suitable for use in production compilers. However, we may wish to avoid applying them blindly. <p> Some methods for doing this are described in [PW93]. Also, the methods described here are more susceptible to bad worst-case performance than the methods described in <ref> [Pug92, PW92] </ref>. We might want to be able to detect when computing exact value-based dependence information is going to be very expensive, and use some approximation. Neither Feautrier nor Maydan has does an analysis of which components of their algorithms are expensive. <p> It is our belief that this is responsible for a substantial portion of the time required by Feautrier's algorithm. Some efficient scheme for testing the feasibility of a set of linear constraints is needed, such as <ref> [MHL91, Pug92] </ref>. In is unclear how effective PIP [Fea88a] is at checking feasibility (as opposed to parametric integer programming). In addition, some method like the one we describe here will be required to handle negation efficiently.
Reference: [Pug93] <author> William Pugh. </author> <title> Definitions of dependence distance. </title> <journal> Letters on Programming Languages and Systems, </journal> <month> September </month> <year> 1993. </year>
Reference: [PW92] <author> William Pugh and David Wonnacott. </author> <title> Going beyond integer programming with the Omega test to eliminate false data dependences. </title> <type> Technical Report CS-TR-2993, </type> <institution> Dept. of Computer Science, University of Maryland, College Park, </institution> <month> December </month> <year> 1992. </year> <note> An earlier version of this paper appeared at the SIGPLAN PLDI'92 conference. </note>
Reference-contexts: We simplify each of the 9V i s:t: C i terms using the gist operation we defined in <ref> [PW92] </ref>. We replace each 9V i s:t: C i term with gist (9V i s:t: C i ) given C 0 . This step is justified in Section 3.1. <p> Vadim Maslov [Mas94] has recently described a new framework for value-based dependence information that is exact over the same domain. In previous work we described exact methods for computing memory-based dependences [Pug92] and methods for identifying some, but not all, dependences that were not value-based <ref> [PW92] </ref>. 4.1 Feautrier's and Maydan's approach Feautrier and Maydan compute a decision tree (called a quast or a last write tree (LWT)) to describe a dependence. This decision tree allows the computation of the source of any particular read. The internal nodes represent tests to be performed. <p> We may be able to handle more killers as partial covers and terminators and we may be able to avoid considering some killers at all. Maslov utilizes our previous work on the Omega test <ref> [Pug92, PW92] </ref> and the techniques described here for handling negation (Section 3). 4.3 Tu's and Padua's Approach We will briefly compare our scheme with that of Tu and Padua [TP92, PEH + 93], as a representative example of other related work on array privatization [GS90, Ros90, Li92]. <p> We found that using partial covers give a factor of 2-4+ improvement in analysis time, compared with use of Equation 2 alone. We also experimented with using Equation 2 with the complete cover and termination checks described in <ref> [PW92] </ref> (but not partial cover and termination). For a few programs, computing partial covers gave a nearly a factor of 2 improvement over doing only full cover and termination checks. <p> Some methods for doing this are described in [PW93]. Also, the methods described here are more susceptible to bad worst-case performance than the methods described in <ref> [Pug92, PW92] </ref>. We might want to be able to detect when computing exact value-based dependence information is going to be very expensive, and use some approximation. Neither Feautrier nor Maydan has does an analysis of which components of their algorithms are expensive.
Reference: [PW93] <author> William Pugh and David Wonnacott. </author> <title> Static analysis of upper and lower bounds on dependences and parallelism. </title> <type> Technical Report CS-TR-2994.2, </type> <institution> Dept. of Computer Science, University of Maryland, College Park, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Some methods for doing this are described in <ref> [PW93] </ref>. Also, the methods described here are more susceptible to bad worst-case performance than the methods described in [Pug92, PW92]. We might want to be able to detect when computing exact value-based dependence information is going to be very expensive, and use some approximation. <p> It is unclear if the exact information computed by our scheme and by Feautrier will ever be required, or if approximate information, computed by schemes such as [TP92, PEH + 93], will suffice. For array privatization, approximate schemes may suffice but more advanced transformations <ref> [AL93, PW93] </ref> may require more exact information. We have pursued exact analysis methods because we want to determine exactly how expensive it will be to compute, and because we find that it gives us a better insight into the problem.
Reference: [Rib90] <author> Hudson Ribas. </author> <title> Obtaining dependence vectors for nested-loop computations. </title> <booktitle> In Proc of 1990 International Conference on Parallel Processing, </booktitle> <address> pages II-212 II-219, </address> <month> August </month> <year> 1990. </year>
Reference: [Ros90] <author> Carl Rosene. </author> <title> Incremental Dependence Analysis. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, Rice University, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: previous work on the Omega test [Pug92, PW92] and the techniques described here for handling negation (Section 3). 4.3 Tu's and Padua's Approach We will briefly compare our scheme with that of Tu and Padua [TP92, PEH + 93], as a representative example of other related work on array privatization <ref> [GS90, Ros90, Li92] </ref>. Their scheme handles control flow, while ours currently does not.
Reference: [Str88] <author> Gilbert Strang. </author> <title> Linear Algebra and its Applications. </title> <publisher> Harcourt Brace Jovanovich, Publishers, </publisher> <year> 1988. </year> <month> 17 </month>
Reference-contexts: Due to the way substitutions are performed, the mapping from ~x and ~ff to ~x and ~y is 1-1, so the above equation is equivalent to the following: (where T + is the pseudoinverse <ref> [Str88] </ref> of T ): f~x; ~y j 9~ff s:t: ~x # 2 RowSpace (T ) ^ ~x # " ~y ~c ^ AT + ~x # 7 Each wildcard now appears in only one equality constraint that enforces a modulo constraint (e.g., 9fi s:t: 3fi = x+2y).
Reference: [TP92] <author> Peng Tu and David Padua. </author> <title> Array privatization for shared and distributed memory machines. </title> <booktitle> In Proc. 2nd Workshop on Languages, Compilers, and Run-Time Environments for Distributed Memory Machines, </booktitle> <month> September </month> <year> 1992. </year> <note> appeared in ACM SIGPLAN Notices January 1993. </note>
Reference-contexts: Maslov utilizes our previous work on the Omega test [Pug92, PW92] and the techniques described here for handling negation (Section 3). 4.3 Tu's and Padua's Approach We will briefly compare our scheme with that of Tu and Padua <ref> [TP92, PEH + 93] </ref>, as a representative example of other related work on array privatization [GS90, Ros90, Li92]. Their scheme handles control flow, while ours currently does not. <p> Equivalently, we could perform the upward-exposed and downward-exposed calculations of Section 2.2. They [PEH + 93] note that this is imprecise: ... a naive aggregation of U SE b (L) may exaggerate the exposed use set.... They do not describe in <ref> [TP92, PEH + 93] </ref> the algorithm used to perform the more sophisticated aggregation. It is our belief that the effect of the more sophisticated aggregation will be equivalent, in our scheme, to using only partial covers in computing kills. <p> In addition, some method like the one we describe here will be required to handle negation efficiently. It is unclear if the exact information computed by our scheme and by Feautrier will ever be required, or if approximate information, computed by schemes such as <ref> [TP92, PEH + 93] </ref>, will suffice. For array privatization, approximate schemes may suffice but more advanced transformations [AL93, PW93] may require more exact information.
Reference: [Wol91] <author> Michael Wolfe. </author> <title> The tiny loop restructuring research tool. </title> <booktitle> In Proc of 1991 International Conference on Parallel Processing, </booktitle> <address> pages II-46 II-53, </address> <year> 1991. </year>
Reference-contexts: The relax example does not require merging LWT's. 6 Implementation Status and Benchmark Availability The techniques described here are being implemented in our extended version of Michael Wolfe's tiny tool <ref> [Wol91] </ref>, which is available for anonymous ftp from ftp.cs.umd.edu:pub/omega. The programs analyzed in Table 1 come from a set of benchmark programs for comparing the performance and coverage of algorithms for analyzing value-based flow dependences between array references.
Reference: [ZC91] <author> Hans Zima and Barbara Chapman. </author> <title> Supercompilers for Parallel and Vector Computers. </title> <publisher> ACM Press, </publisher> <year> 1991. </year> <month> 18 </month>
References-found: 28

