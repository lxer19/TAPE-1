URL: http://www.cs.uoregon.edu/paracomp/proj/ariadne/papers/joydip_phd/joydip_thesis.ps.gz
Refering-URL: http://www.cs.uoregon.edu/paracomp/proj/ariadne/publications.html
Root-URL: http://www.cs.uoregon.edu
Title: Integrating Event- and State-Based Approaches to the Debugging of Parallel Programs  
Degree: A Dissertation Presented by Joydip Kundu Submitted to the Graduate School of the  in partial fulfillment of the requirements for the degree of Doctor of Philosophy  
Date: May 1996  
Affiliation: University of Massachusetts Amherst  Department of Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Abrams, M., Doraswamy, N. and Mathur, A. </author> <title> Visual analysis of parallel and distributed programs in time, event and frequency domains. </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> Vol. 3, No. 6, </volume> <pages> pages 672-685, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Several debuggers, including Seeplex [19], SIEVE [81], and Chitra <ref> [1] </ref> address the issue of scalable visual feedback as an aid to data analysis in the context of performance debugging. Scalability is achieved in Seeplex [19] and Chitra [1] by grouping related behaviors together into categories. <p> Several debuggers, including Seeplex [19], SIEVE [81], and Chitra <ref> [1] </ref> address the issue of scalable visual feedback as an aid to data analysis in the context of performance debugging. Scalability is achieved in Seeplex [19] and Chitra [1] by grouping related behaviors together into categories. SIEVE [81] allows the user to focus his/her attention on a particular portion of the event trace through selection of nodes in the static call graph of the program.
Reference: [2] <author> Adams, E. and Muchnick. S. S. Dbxtool: </author> <title> A window based symbolic debugger for Sun workstations. </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 16, No. 7, </volume> <pages> pages 653-669, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: the succ=1 partition, we issued the following commands. with select foreach W color compute link tuple = (pid (W clr), oid (W clr)); with select foreach proc compute link set = link tuple (W clr); with select assert disjoint (link set (proc)); which printed the following: Assertion failed. link set <ref> [2] </ref> and link set [3] have the following elements in common: (1,3), (3,1) To see what color computations are in conflict, we issued the following com mand. with select print color (proc), pid (proc) wrt proc; which printed the following: Abstract Event color pid 9 2 succ = 1 7 3 <p> We could have used any vendor supplied state-examination debugger. For this example which was written for Intel Paragon, we used the vendor-supplied ipd debugger. 5.1.4 The State-Based Component ipd [44] provides comprehensive services for state examination and modification similar to those available on standard, sequential debuggers <ref> [2, 87] </ref>. <p> The odd processes are stopped at the stage where they could still influence compr <ref> [2] </ref> which preserves the information that may be relevant to the error. In a correct execution, all even processes should be stopped After a communication event the initiating ones after receiving the replies, and the non-initiating ones after sending those replies.
Reference: [3] <author> Ahuja, S., Carreiro, N. J., and Gelernter, D. </author> <booktitle> Linda and Friends Computer, </booktitle> <volume> Vol. 19, No. 8, </volume> <pages> pages 26-34, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: In contrast, Roman and Cox in their Pavane animation system [78] propose a declarative approach. Pavane is for animating programs that run on Swarm operating system, which has a shared tuple-space like Linda <ref> [3] </ref>. Instead of annotating the program, the user declares the animation events that need to be displayed when the global state change satisfies the user-defined criteria. Thus, unlike the annotation schemes, the original program does not need to be recompiled in order to build a new animation. <p> issued the following commands. with select foreach W color compute link tuple = (pid (W clr), oid (W clr)); with select foreach proc compute link set = link tuple (W clr); with select assert disjoint (link set (proc)); which printed the following: Assertion failed. link set [2] and link set <ref> [3] </ref> have the following elements in common: (1,3), (3,1) To see what color computations are in conflict, we issued the following com mand. with select print color (proc), pid (proc) wrt proc; which printed the following: Abstract Event color pid 9 2 succ = 1 7 3 6 3 So biconnected
Reference: [4] <author> Alverson, G., Griswold, W., Notkin, D. and Snyder, L. </author> <title> A flexible communication abstraction for nonshared memory parallel computing. </title> <booktitle> Proceedings of Supercomputing '90, </booktitle> <year> 1990. </year>
Reference: [5] <author> Bacon, D. F., and Goldstein, S. C. </author> <title> Hardware-assisted replay of multiprocessor programs. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 26, No. 12, </volume> <pages> pages 194-206, </pages> <month> Dec </month> <year> 1991. </year>
Reference-contexts: Rubin, Rudolph and Zernik in their shared bus Makbilan 25 architecture [80] make non-intrusive replay possible by having shadow processors monitoring processors and the main bus. The monitoring processors are connected by their own private bus. Message logging thus introduces no probe effect. Bacon and Goldstein <ref> [5] </ref> proposed a similar hardware based technique. 2.5.2 State-Based Debugging The most common approach to parallel program debugging is to extend sequential debugging techniques to the domain of parallel programming. The basic facilities of location, visualization and modification of states are augmented to handle the aspects of interprocess communication.
Reference: [6] <author> Baeten, J. C. M., and Weijland, W. P. </author> <title> Process Algebra. </title> <institution> Cambridge University Press, Cambridge Tracts in Theoretical Computer Science, </institution> <year> 1990. </year>
Reference-contexts: The algebraic frameworks developed for studying equivalences for parallel programs include Calculus of Communicating Systems (CCS) by Milner [64] based on observational equivalence of traces, Communicating Sequential Processes (CSP) by Hoare [38] based on failure semantics, and Asynchronous Concurrent Processes (ACP) by Baeten and Weijland <ref> [6] </ref> based on bisimulation equivalence of traces. ACP can model multicast as well as point-to-point communication where as CCS and CSP can only model point-to-point communication. All can be used to detect deadlocks.
Reference: [7] <author> Balzer, R. M. </author> <title> EXDAMS EXtendable Debugging and Monitoring System. </title> <booktitle> Proceedings of AFIPS Spring Joint Computer Conference, </booktitle> <pages> pages 567-580, </pages> <year> 1969. </year>
Reference-contexts: These views include structured flowcharts, module interconnection diagrams, symbol tables and data history. Execution can be animated by highlighting the specific part of the flow graph display where the thread of execution currently resides or has visited previously. Balzer <ref> [7] </ref> in his EXDAMS debugger also records all variable accesses to provide the user with 13 a data history that includes a tree-oriented display showing how a current value of a variable is obtained from the values of other variables.
Reference: [8] <author> Baiardi, F., De Fransesco, N. and Vaglini, G. </author> <title> Development of a debugger for a concurrent language. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-12, No. 4, </volume> <pages> pages 547-553, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Event-based techniques offer an alternative in which user-specified models of intended program behavior are compared to actual program behavior as captured in execution traces <ref> [8, 9, 39, 41] </ref>. <p> This dissertation is based on the premise that parallel debugging requires a multi-level strategy. The strategy we propose employs event-based techniques <ref> [8, 9, 53, 39, 41] </ref> at the highest level where gross patterns of process interactions are investigated. As debugging proceeds and the focus of attention narrows, the behavior of progressively smaller parts of the program are analyzed in progressively finer detail, using a combination of event- and state-based techniques. <p> Event-based approaches can be used with run-time monitor 28 ing or post-mortem modeling. They differ most significantly in their modeling languages: IDD [36], and TSL [37] use temporal logic based modeling language, YODA [54], HARD [23], and TQuel [83] use relational query language, whereas ECSP <ref> [8] </ref>, Kraut [13], EBBA [9], and Meld [41] use variants of regular expressions as their modeling language. <p> Moreover EBBA's pattern matching approach is too unrestrained and, as a result, it is incapable of providing precise feedback on errors. Debuggers that retain the partial order between event occurrences in their internal representation of program behavior include ECSP <ref> [8] </ref> by Baiardi, De Nicola, and Vaglini, Meld [41] by Hseush and Kaiser, Belvedere by Hough [39]. ECSP specifies the program behavior as a set of process-specific models. A specification acts as a trigger for assertion checking. <p> It also impedes abstractio because concurrency between abstract events cannot be specified without referring to the process identifiers of their constituents. EDL's second shortcoming is its use of pattern extraction as the semantics of matching. A model can be matched to a behavior in different ways. Baiardi et. al. <ref> [8] </ref> and Zave [96] require the model to match all input events: no skipping of events is allowed. This can be thought of as parsing approach. Another alternative [37, 9] is to use a pattern extraction approach where events are skipped as needed.
Reference: [9] <author> Bates, P. C. </author> <title> Debugging Programs in a Distributed System Environment. </title> <type> PhD thesis, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <year> 1986. </year> <note> Also COINS Technical Report 86-05. </note>
Reference-contexts: Event-based techniques offer an alternative in which user-specified models of intended program behavior are compared to actual program behavior as captured in execution traces <ref> [8, 9, 39, 41] </ref>. <p> This dissertation is based on the premise that parallel debugging requires a multi-level strategy. The strategy we propose employs event-based techniques <ref> [8, 9, 53, 39, 41] </ref> at the highest level where gross patterns of process interactions are investigated. As debugging proceeds and the focus of attention narrows, the behavior of progressively smaller parts of the program are analyzed in progressively finer detail, using a combination of event- and state-based techniques. <p> The debugger is programmable, the user can even change the matching algorithm. Dalek can be thought of as a sequential variant of Event Based Behavioral Abstraction toolkit (EBBA) <ref> [9] </ref> developed for parallel programs. EBBA is described in Section 2.5.3. 2.2 Program Animation Environments Program animation environments are mainly geared toward educational purposes, where the animation of interesting properties of the algorithm can illuminate the working of a program. <p> The first sophisticated animation system that provides abstract visualizations for parallel program debugging was Belvedere [39]. Belvedere extends Lamport's happened before relation to abstract events and animates the program execution in logical time to filter out perturbations due to asynchrony. EDL <ref> [9] </ref> is used as the modeling language. Belvedere also introduces the concept of perspective views where the user can choose to animate the behavior from a number of different perspectives. Belvedere, however, does not address the issue of scale that arises with massive parallelism. <p> Users can identify an interval in terms of its start and end events. Complex predicates can be specified over the events by defining a metric of interest and specifying assertions about that metric. PSpec can be considered as a variant of EDL the modeling language of EBBA <ref> [9] </ref> that will be discussed in Section 2.5.3. Performance and correctness debugging of parallel programs are similar in spirit: both need to collect "interesting" events, both have to deal with a large data set, both require behavioral modeling, and both need to address the issue of scalable feedback. <p> Event-based approaches can be used with run-time monitor 28 ing or post-mortem modeling. They differ most significantly in their modeling languages: IDD [36], and TSL [37] use temporal logic based modeling language, YODA [54], HARD [23], and TQuel [83] use relational query language, whereas ECSP [8], Kraut [13], EBBA <ref> [9] </ref>, and Meld [41] use variants of regular expressions as their modeling language. <p> Even then, most of the event interleavings can be the artifacts of the physical medium (the shared bus) and may not correspond to the logical view of the programmer. An important event-based modeling language based on the an internal string representation of program behavior is EDL developed by Bates <ref> [9] </ref> as part of his event-based behavioral abstraction (EBBA) toolkit. EBBA uses a constrained event 29 formalism. Models are described in a regular expression based syntax used to specify temporal constraints. A filter associated with each model specifies the constraints on the attributes of the constituent events. <p> This matching can be done efficiently | in most cases in linear time, although the verification of the logical time relationships between abstract events may take polynomial time | avoiding the costliness of pattern matching approaches <ref> [9, 37] </ref> and the expensive implementations (number of states can potentially be exponential in the length of the parallel expression to be recognized) of previous languages [41]. <p> What if only nil is left? The event is stripped automatically, and the relation holds true trivially. In the next section we compare Ariadne's modeling language with three other languages | EDL <ref> [9] </ref>, DPE [41], and PEDL [39] | to highlight the differences. 3.5 Evaluation of Ariadne's Modeling Language Hough in his thesis [39] presents a detailed critique of Event Definition Language (EDL) [9] and Data Path Expressions (DPE) [41] and introduces a new modeling language called Parallel Event Definition Language (PEDL). <p> In the next section we compare Ariadne's modeling language with three other languages | EDL <ref> [9] </ref>, DPE [41], and PEDL [39] | to highlight the differences. 3.5 Evaluation of Ariadne's Modeling Language Hough in his thesis [39] presents a detailed critique of Event Definition Language (EDL) [9] and Data Path Expressions (DPE) [41] and introduces a new modeling language called Parallel Event Definition Language (PEDL). Since these three languages are most similar to ours among the event-based modeling languages, we will evaluate them and present the rationale behind Ariadne's modeling language. <p> A model can be matched to a behavior in different ways. Baiardi et. al. [8] and Zave [96] require the model to match all input events: no skipping of events is allowed. This can be thought of as parsing approach. Another alternative <ref> [37, 9] </ref> is to use a pattern extraction approach where events are skipped as needed. A parsing approach can detect and characterize an error uniquely; a pattern extraction approach, in general, lacks this ability. The difference is illustrated in Figure 3.21. The two approaches reflect extreme points of a spectrum. <p> We showcase both features through another sampling debugging session. The filtering mechanism [46] allows for conditional attribute expressions to be used to guide the matching process as in EDL <ref> [9] </ref>. Unlike EDL, however, Ariadne's filtering scheme is restrained. Use of multiple views of program behavior had been advocated strongly in [53].
Reference: [10] <author> Bingham, T., Hobbs, N., and Husson, D. </author> <title> Experiences developing and using an object-oriented library for program manipulation. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 28, No. 10, </volume> <pages> pages 83-89, </pages> <month> October, </month> <year> 1993. </year>
Reference-contexts: State selection via a higher level mechanism such as predicates on variable values is also available in debuggers like Ladebug <ref> [10] </ref>. Although these debuggers allow the user to examine behavior at the source level, user interaction is still at a low level of abstraction.
Reference: [11] <author> Brinskma, E. </author> <title> A tutorial on LOTOS. </title> <editor> In M.Diaz, ed. </editor> <title> Protocol Specification, Testing and Verification, </title> <booktitle> V, </booktitle> <pages> pages 171-194, </pages> <publisher> Elsevier, </publisher> <year> 1986. </year>
Reference-contexts: ACP can model multicast as well as point-to-point communication where as CCS and CSP can only model point-to-point communication. All can be used to detect deadlocks. Several tools have been developed using these three frameworks: LOTOS <ref> [11] </ref>, ECCS [14], PAL [95] and Concurrency Workbench [17]. None, however, can perform induction over a number of identical processes, and are thus not scalable. The final technique data flow analysis has been used for finding access anomalies in parallel programs.
Reference: [12] <author> Brown, M. H., and Sedgewick, R. </author> <title> A system for algorithm animation. </title> <journal> Computer Graphics, </journal> <volume> Vol. 18, No. 3, </volume> <pages> pages 177-186, </pages> <month> Mar </month> <year> 1984. </year>
Reference-contexts: Annotation-based animation systems collect interesting events by instrumenting the program, and then specify the animation scheme in terms of the collected events and animation icons. Annotation-based parallel program animating systems include Voyeur [85], Belvedere [39] and J2 [50]. Voyeur's architecture resembles that of BALSA <ref> [12] </ref>, an animation system developed for sequential programs; and it supports a class hierarchy of views to create animations at different levels of abstraction. Voyeur, however, does not handle asynchrony properly its notion of time being limited by the assumption of the existence of a global clock.
Reference: [13] <author> Bruegge, B. and Hibbard, P. </author> <title> Generalized path expressions: A high level debugging mechanism. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium in High-Level Debugging, </booktitle> <pages> pages 34-44, </pages> <year> 1983. </year> <month> 191 </month>
Reference-contexts: Event-based approaches can be used with run-time monitor 28 ing or post-mortem modeling. They differ most significantly in their modeling languages: IDD [36], and TSL [37] use temporal logic based modeling language, YODA [54], HARD [23], and TQuel [83] use relational query language, whereas ECSP [8], Kraut <ref> [13] </ref>, EBBA [9], and Meld [41] use variants of regular expressions as their modeling language. <p> As with any run-time monitoring system without a replay facility, this approach suffers from the probe effect, and cannot guarantee reproducible executions. Variants of path expressions are used to specify the control flow of a program by Garcia and Berman [31], by Bruegge in his KRAUT debugger <ref> [13] </ref>, by Hseush and Kaiser in their Meld debugger [41]. Garcia and Berman designed a visualization system that renders the Petri-net equivalent of the path expression specified by the user. The Petri-net is animated to show the program execution, and can be used to set a breakpoint.
Reference: [14] <author> Carchiolo, V., Di Stefano, A, and Faro, A. </author> <title> ECCS and LIPS : Two Languages for OSI systems specification and verification. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 11, No. 2, </volume> <pages> pages 284-329, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: ACP can model multicast as well as point-to-point communication where as CCS and CSP can only model point-to-point communication. All can be used to detect deadlocks. Several tools have been developed using these three frameworks: LOTOS [11], ECCS <ref> [14] </ref>, PAL [95] and Concurrency Workbench [17]. None, however, can perform induction over a number of identical processes, and are thus not scalable. The final technique data flow analysis has been used for finding access anomalies in parallel programs.
Reference: [15] <author> Chandy, K. M., and Lamport, L. </author> <title> Distributed snapshots: Determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 3, No. 1, </volume> <pages> pages 63-65, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: The issue of consistent global states in the context of distributed computation has been addressed by many researchers. Distributed marker passing algorithms are proposed by Chandy and Lamport <ref> [15] </ref>, Miller and Choi [61], Haban and Weigel [35], and Hurfin, Plouzeau and Raynal [43] using specially tagged messages to distribute information about local states across different processes and stop the whole computation in a consistent global state. <p> Alternatively, local breakpoints can be extended dynamically to global breakpoints <ref> [35, 15, 61] </ref>. <p> Alternatively, local breakpoints can be extended dynamically to global breakpoints [35, 15, 61]. This can be done explicitly by notifying the remaining processes either through communication with a central monitor [61] or over normal communication channels <ref> [35, 15] </ref> that a breakpoint has been reached or it can be done implicitly by allowing the remaining processes to run until they block waiting for input.
Reference: [16] <author> Choi, J. D., and Min, S. L. </author> <title> Race frontier: reproducing data races in parallel program debugging. </title> <booktitle> Proceedings of PPoPP 1991. </booktitle>
Reference-contexts: Although this will not detect all the races related to the variable, it guarantees that at least one race involving that variable will be detected. Such optimizations in dynamic data flow analysis for race detections have been proposed in <ref> [16, 67] </ref>. Program analysis techniques are not scalable, and they can account for only a limited types of errors. State-based techniques are prone to explosion in the state space and are thus unable to accommodate massively parallel programs.
Reference: [17] <author> Cleaveland, L, Parrow, J., and Steffen, B. </author> <title> The Concurrency Workbench: A Semantics based Tool for the Verification of Concurrent Systems. </title> <booktitle> Proceedings of the Workshop on Automatic Verification Methods for Finite State Machines, </booktitle> <pages> pages 24-37, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: ACP can model multicast as well as point-to-point communication where as CCS and CSP can only model point-to-point communication. All can be used to detect deadlocks. Several tools have been developed using these three frameworks: LOTOS [11], ECCS [14], PAL [95] and Concurrency Workbench <ref> [17] </ref>. None, however, can perform induction over a number of identical processes, and are thus not scalable. The final technique data flow analysis has been used for finding access anomalies in parallel programs.
Reference: [18] <author> Cooper, R., and Marzullo, K. </author> <title> Consistent detection of global predicates. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 26, No. 12, </volume> <pages> pages 167-174, </pages> <year> 1991. </year>
Reference-contexts: Event-based techniques offer an alternative in which user-specified models of intended program behavior are compared to actual program behavior as captured in execution traces [8, 9, 39, 41]. The use of event traces in conjunction with replay mechanisms avoids issues of global state consistency <ref> [18, 58] </ref> and reproducibility; the use of abstraction makes it possible to contend with large quantities of data; and the use of logical time transformations filters out perturbations due to asynchrony [21, 51].
Reference: [19] <author> Couch, A. A. </author> <title> Categories and context in scalable execution visualization. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol. 18, </volume> <pages> pages 195-204, </pages> <year> 1993. </year>
Reference-contexts: Several debuggers, including Seeplex <ref> [19] </ref>, SIEVE [81], and Chitra [1] address the issue of scalable visual feedback as an aid to data analysis in the context of performance debugging. Scalability is achieved in Seeplex [19] and Chitra [1] by grouping related behaviors together into categories. <p> Several debuggers, including Seeplex <ref> [19] </ref>, SIEVE [81], and Chitra [1] address the issue of scalable visual feedback as an aid to data analysis in the context of performance debugging. Scalability is achieved in Seeplex [19] and Chitra [1] by grouping related behaviors together into categories. SIEVE [81] allows the user to focus his/her attention on a particular portion of the event trace through selection of nodes in the static call graph of the program. <p> In case of error, it can only identify the iteration that contains the erroneous exchange the user needs to investigate further to get a more detailed feedback. Typically there is a trade off between scale and precision <ref> [19] </ref>. Ave allows the user to control the balance so that debugging can begin with the most scalable display and then progress, as the focus of attention narrows, through increasing levels of detail. 55 sion. <p> of attribute values with each partition mapped to a color; note that automatic color binning has been used with the color black representing the range of values f1, 2, 4, 8, 16, 32, 64g, while the color white is used to represent the values f96, 112, 120, 124, 126, 127g <ref> [19] </ref>. We intentionally set the number of colors to 2 to show that color binning can be used successfully even with limited number of colors. 2 Note the individual rectangles in the scatter plot can not be distinguisehed.
Reference: [20] <author> Couch, A. L., and Krumme, D. W. </author> <title> Multidimensional spreadsheets in a graphical symbolic debugger for the Ncube. </title> <booktitle> Proceedings of the 6th Distributed memory Conference, </booktitle> <pages> pages 205-209, </pages> <year> 1993. </year>
Reference-contexts: Trace data is highly structured, and the user can specify the structure using an event syntax. There is a spreadsheet interface for retrieving and analyzing data. Temporal filtering is done on selected data by using historical queries. A spreadsheet interface to specify distributed data is also proposed by Couch <ref> [20] </ref>, but it lacks the static call graph based filtering mechanism presented in SIEVE. Another approach in performance debugging borrows heavily from the event-based approach for correctness debugging. Perl and Weihl [75] proposed PSpec, an event-based modeling language for performance assertion checking.
Reference: [21] <author> Cuny, J. E., Hough, A. A., and Kundu, J. </author> <title> Logical time in visualizations produced by parallel programs. </title> <booktitle> Proceedings of Visualization '92, </booktitle> <pages> pages 186-193 (1992). </pages>
Reference-contexts: The use of event traces in conjunction with replay mechanisms avoids issues of global state consistency [18, 58] and reproducibility; the use of abstraction makes it possible to contend with large quantities of data; and the use of logical time transformations filters out perturbations due to asynchrony <ref> [21, 51] </ref>. Current event-based debugging tools, however, have three major limitations: they do not provide sufficient feedback on match failures, they do not scale well for massive parallelism, and they do not facilitate tracking errors back to the source code.
Reference: [22] <author> Cuny, J. E., Forman, G., Hough, A., Kundu, J., Lin, C., Snyder, L., and Stemple, D. </author> <title> The Ariadne Debugger: Scalable Application of Event-Based Abstraction. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 28, No. 12, </volume> <pages> pages 85-95, </pages> <year> 1994. </year>
Reference-contexts: As we will see later in this dissertation, Ave/Ariadne introduces such a comprehensive solution. Chapter 3 Ave/Ariadne: Introduction and Concepts In this chapter we introduce the Ave/Ariadne 1 event-based debugger <ref> [22] </ref>. Ariadne has a simple modeling language; it can be parsed with collections of finite state machines that provide precise information on the syntactic reasons for a match failure.
Reference: [23] <author> Di Maio, A., Ceri, S., and Crespi-Reghizzi, S. </author> <title> Execution monitoring and debugging tool for Ada using relational algebra. </title> <booktitle> Proceedings of Ada in use, Ada International Conference, </booktitle> <pages> pages 109-123, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: Event-based approaches can be used with run-time monitor 28 ing or post-mortem modeling. They differ most significantly in their modeling languages: IDD [36], and TSL [37] use temporal logic based modeling language, YODA [54], HARD <ref> [23] </ref>, and TQuel [83] use relational query language, whereas ECSP [8], Kraut [13], EBBA [9], and Meld [41] use variants of regular expressions as their modeling language. <p> In TSL, designed for debugging Ada programs, specifications are written as a declarative part of the task bodies, and are enabled any time a task enters the region. YODA [54], HARD <ref> [23] </ref>, and TQuel [83] use relational query languages to verify properties of execution behavior. These methods can be used only with shared bus architectures, where the shared broadcast medium imposes a total order among the inter-process interactions.
Reference: [24] <author> Emrath, P. A., and Padua, D. A. </author> <title> Automated detection and nondeterminacy in parallel programs. </title> <journal> In ACM SIGPLAN Notices, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 89-99, </pages> <year> 1989. </year>
Reference-contexts: Static data flow analysis techniques <ref> [24] </ref>, using compile-time data dependence analysis, cannot capture all the temporal dependencies exactly, and have to be conservative in their estimation. Thus they can report an unacceptable number of false positives.
Reference: [25] <author> Feldman, S., and Brown, C. IGOR: </author> <title> A system for program debugging via reversible execution. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 112-123, </pages> <year> 1989. </year>
Reference-contexts: Systems like Recap [71], Igor <ref> [25] </ref> and Agora [27], also capture the system state periodically through checkpointing, thereby providing the user the capability of random access playback 1 . Recap [71] has an innovative checkpointing scheme that reduces logging overhead by making use of operating system resources. <p> During replay, any halted child can be selected, and executed to reproduce the program behavior with the help of the system log. Recap can be used for both shared-memory and message passing programs. Igor <ref> [25] </ref> optimizes checkpointing overhead in a virtual memory systems by writing out only dirty pages. Since it does not record events during execution, the replay may not reproduce the original program behavior.
Reference: [26] <author> Fidge, C. J. </author> <title> Partial orders for parallel debugging. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 183-194, </pages> <year> 1989. </year> <month> 192 </month>
Reference-contexts: Similar extensions have previously been proposed <ref> [26, 35, 41] </ref> but we have found our definitions to be more appropriate for debugging.
Reference: [27] <author> Forin, A. </author> <title> Debugging of heterogenous parallel systems. </title> <journal> In ACM SIGPLAN Notices, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 130-140, </pages> <year> 1989. </year>
Reference-contexts: Replay techniques guarantee reproducibility by logging the resolution of non-deterministic choices during the initial execution. The log is consulted during re-execution to ensure that the reexecution follows the same state transitions as in the initial execution. Replay systems for message passing programs (for example Radar [51], Belvedere [39], Agora <ref> [27] </ref>, and Recap [71]) log all sends and receives of messages; those for shared memory programs (for example Instant Replay [52], Recap [71]) log the order in which shared variables are accessed. Systems like Recap [71], Igor [25] and Agora [27], also capture the system state periodically through checkpointing, thereby providing <p> message passing programs (for example Radar [51], Belvedere [39], Agora <ref> [27] </ref>, and Recap [71]) log all sends and receives of messages; those for shared memory programs (for example Instant Replay [52], Recap [71]) log the order in which shared variables are accessed. Systems like Recap [71], Igor [25] and Agora [27], also capture the system state periodically through checkpointing, thereby providing the user the capability of random access playback 1 . Recap [71] has an innovative checkpointing scheme that reduces logging overhead by making use of operating system resources.
Reference: [28] <author> Fowler, R. J., Leblanc, T. J., and Mellor-Crummey, J. M. </author> <title> An integrated approach to parallel program debugging and performance analysis on large-scale multiprocessors. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 163-173, </pages> <year> 1989. </year>
Reference: [29] <author> Gait, J. </author> <title> A debugger for concurrent programs. </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 15, No. 6, </volume> <pages> pages 539-554, </pages> <year> 1985. </year>
Reference-contexts: In this way, the user does not need to restart the program from the very beginning to explore its states. However the implementation of logging and checkpointing adds extra computational overhead, which can alter the program behavior. This is known as probe effect <ref> [29] </ref> and gives rise to non-transparency. * Non-transparency: Sequential debuggers are transparent with respect to nonreactive programs, that is, program monitoring does not change the behavior of the program. Parallel debuggers cannot guarantee such transparency. <p> Breakpoints can be set by specifying the statement number: all threads are suspended when the statement is executed by any thread. The user is allowed to choose any one of the suspended threads and run it in isolation. Gait <ref> [29] </ref> proposed a debugger for concurrent processes running on a single processor. This method, however, cannot be extended to parallel programs running on multiprocessor machines. Parallel programs contain multiple processes interacting among themselves through inter-process communication.
Reference: [30] <author> Garcia, M. E., and Berman, W. J. </author> <title> An approach to concurrent systems debugging. </title> <booktitle> Proc. of the 5th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 507-514, </pages> <year> 1985. </year>
Reference: [31] <author> Garcia-Molina, H., Germano, F., and Kohler, </author> <title> W.H. Debugging a distributed computing system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-10, No. 2, </volume> <pages> pages 210-219, </pages> <month> March </month> <year> 1984. </year>
Reference-contexts: As with any run-time monitoring system without a replay facility, this approach suffers from the probe effect, and cannot guarantee reproducible executions. Variants of path expressions are used to specify the control flow of a program by Garcia and Berman <ref> [31] </ref>, by Bruegge in his KRAUT debugger [13], by Hseush and Kaiser in their Meld debugger [41]. Garcia and Berman designed a visualization system that renders the Petri-net equivalent of the path expression specified by the user.
Reference: [32] <author> Godefroid, P., and Wolper, P. </author> <title> Using partial orders for the efficient verification of deadlock freedom and safety properties. </title> <editor> In K.G. Larsen and A. Skou, eds., </editor> <booktitle> Computer Aided Verification, </booktitle> <publisher> LNCS 575, Springer-Verlag, </publisher> <address> New York, NY, </address> <pages> pages 332-342, </pages> <year> 1991. </year>
Reference-contexts: Under these techniques, the states between two synchronization operations are collapsed into one single state. Taylor [91] has also suggested a parceling technique that analyzes the graph in pieces. Reduction techniques have also been proposed in the domain of petri nets. Valmari [93] and Godefroid and Wolper <ref> [32] </ref> suggest techniques that observe the fact that when two mutually independent concurrent actions are possible from a state, the order in which the actions are executed does not affect the invariance of the safety properties. <p> Valmari [93] proposes a way to choose the particular order by finding a special 20 set of transitions for every state represented in the petri net, called the stubborn set. Godefroid and Wolper <ref> [32] </ref> give a separate implementation. In contrast to the reachability analysis proposed by state-based techniques, proof-based techniques try to model the program under study using some axiomatic system.
Reference: [33] <author> Goldberg, A.P., Gopal, A., Lowry, A., and Strom, R. </author> <title> Restoring consistent global states of distributed systems. </title> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 144-154, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: In some cases, this procedure results in a state that is not consistent, that is, a state that could not have occurred in an actual execution. We define consistency as in <ref> [33] </ref>, letting e i;k be the k-th event on process i, which gives rise to s i;k the k-th state on process i, and signals the termination of s i;k1 the (k-1)-th state on process i.
Reference: [34] <author> Greenberg, M., and Cuny, </author> <title> J.E. </title> <booktitle> Parallelism in knowledge-based systems with inheritance Proceedings International Conference on Parallel Processing, </booktitle> <volume> Vol. III, </volume> <pages> pages 141-145, </pages> <year> 1988. </year>
Reference-contexts: () that decides what reply to send, did not have a special check for the case when the message content is 2. 5.3 Tracking Elusive States with Event-Based Breakpointing In this section, we demonstrate the use of our integrated debugging environment on a parallel program for querying a knowledge base <ref> [34] </ref>. The knowledge is stored hierarchically as objects and classes of objects related by the is-a relation. To avoid redundancy, object attributes are stored as high as possible in the hierarchy and are then inherited at the lower levels.
Reference: [35] <author> Haban, D., and Weigel, W. </author> <title> Global events and global breakpoints in distributed systems. </title> <booktitle> 21st Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 166-174, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: The issue of consistent global states in the context of distributed computation has been addressed by many researchers. Distributed marker passing algorithms are proposed by Chandy and Lamport [15], Miller and Choi [61], Haban and Weigel <ref> [35] </ref>, and Hurfin, Plouzeau and Raynal [43] using specially tagged messages to distribute information about local states across different processes and stop the whole computation in a consistent global state. <p> Similar extensions have previously been proposed <ref> [26, 35, 41] </ref> but we have found our definitions to be more appropriate for debugging. <p> Alternatively, local breakpoints can be extended dynamically to global breakpoints <ref> [35, 15, 61] </ref>. <p> Alternatively, local breakpoints can be extended dynamically to global breakpoints [35, 15, 61]. This can be done explicitly by notifying the remaining processes either through communication with a central monitor [61] or over normal communication channels <ref> [35, 15] </ref> that a breakpoint has been reached or it can be done implicitly by allowing the remaining processes to run until they block waiting for input.
Reference: [36] <author> Harter, P. K., Heimbigner, D. M., and King, R. IDD: </author> <title> an interactive distributed debugger. </title> <booktitle> In Proceedings of the 5th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 498-506, </pages> <year> 1985. </year>
Reference-contexts: We have already seen such modeling approaches used in the state-based techniques as a mechanism to set a global breakpoint. Event-based approaches can be used with run-time monitor 28 ing or post-mortem modeling. They differ most significantly in their modeling languages: IDD <ref> [36] </ref>, and TSL [37] use temporal logic based modeling language, YODA [54], HARD [23], and TQuel [83] use relational query language, whereas ECSP [8], Kraut [13], EBBA [9], and Meld [41] use variants of regular expressions as their modeling language. <p> Those using the total order cannot model true concurrency and their matching algorithms are susceptible to a change in relative process speed. We will discuss these issues in more detail in Chapter 3. IDD <ref> [36] </ref> by Harter, Heimbigner and King, and TSL [37] by Luckham are both event-based run-time monitors that impose a total order on event occurrences. In IDD, a programmer uses interval logic to specify assertions that should hold at intervals delimited by distinct events.
Reference: [37] <author> Hembold, D., and Luckham, D. </author> <title> Debugging Ada tasking programs. </title> <journal> IEEE Software, </journal> <volume> Vol. 2, No. 2, </volume> <pages> pages 47-57, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: We have already seen such modeling approaches used in the state-based techniques as a mechanism to set a global breakpoint. Event-based approaches can be used with run-time monitor 28 ing or post-mortem modeling. They differ most significantly in their modeling languages: IDD [36], and TSL <ref> [37] </ref> use temporal logic based modeling language, YODA [54], HARD [23], and TQuel [83] use relational query language, whereas ECSP [8], Kraut [13], EBBA [9], and Meld [41] use variants of regular expressions as their modeling language. <p> Those using the total order cannot model true concurrency and their matching algorithms are susceptible to a change in relative process speed. We will discuss these issues in more detail in Chapter 3. IDD [36] by Harter, Heimbigner and King, and TSL <ref> [37] </ref> by Luckham are both event-based run-time monitors that impose a total order on event occurrences. In IDD, a programmer uses interval logic to specify assertions that should hold at intervals delimited by distinct events. <p> This matching can be done efficiently | in most cases in linear time, although the verification of the logical time relationships between abstract events may take polynomial time | avoiding the costliness of pattern matching approaches <ref> [9, 37] </ref> and the expensive implementations (number of states can potentially be exponential in the length of the parallel expression to be recognized) of previous languages [41]. <p> A model can be matched to a behavior in different ways. Baiardi et. al. [8] and Zave [96] require the model to match all input events: no skipping of events is allowed. This can be thought of as parsing approach. Another alternative <ref> [37, 9] </ref> is to use a pattern extraction approach where events are skipped as needed. A parsing approach can detect and characterize an error uniquely; a pattern extraction approach, in general, lacks this ability. The difference is illustrated in Figure 3.21. The two approaches reflect extreme points of a spectrum.
Reference: [38] <author> Hoare, C. </author> <title> Communicating Sequential Processes. </title>
Reference-contexts: The algebraic frameworks developed for studying equivalences for parallel programs include Calculus of Communicating Systems (CCS) by Milner [64] based on observational equivalence of traces, Communicating Sequential Processes (CSP) by Hoare <ref> [38] </ref> based on failure semantics, and Asynchronous Concurrent Processes (ACP) by Baeten and Weijland [6] based on bisimulation equivalence of traces. ACP can model multicast as well as point-to-point communication where as CCS and CSP can only model point-to-point communication. All can be used to detect deadlocks.
Reference: [39] <author> Hough, A. A. </author> <title> Debugging Parallel Programs Using Abstract Visualizations. </title> <type> PhD thesis, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <year> 1991. </year> <note> Also COINS Technical Report 91-53. 193 </note>
Reference-contexts: Event-based techniques offer an alternative in which user-specified models of intended program behavior are compared to actual program behavior as captured in execution traces <ref> [8, 9, 39, 41] </ref>. <p> This dissertation is based on the premise that parallel debugging requires a multi-level strategy. The strategy we propose employs event-based techniques <ref> [8, 9, 53, 39, 41] </ref> at the highest level where gross patterns of process interactions are investigated. As debugging proceeds and the focus of attention narrows, the behavior of progressively smaller parts of the program are analyzed in progressively finer detail, using a combination of event- and state-based techniques. <p> These similarities between the two domains have led to the development of several 14 abstract animation systems <ref> [39, 50] </ref> geared expressly toward debugging of parallel programs. Animation systems require the user to specify the events to be animated, select or design animation objects that will form the animation, and define a mapping between the program objects and the animation objects. <p> Annotation-based animation systems collect interesting events by instrumenting the program, and then specify the animation scheme in terms of the collected events and animation icons. Annotation-based parallel program animating systems include Voyeur [85], Belvedere <ref> [39] </ref> and J2 [50]. Voyeur's architecture resembles that of BALSA [12], an animation system developed for sequential programs; and it supports a class hierarchy of views to create animations at different levels of abstraction. <p> Voyeur, however, does not handle asynchrony properly its notion of time being limited by the assumption of the existence of a global clock. The first sophisticated animation system that provides abstract visualizations for parallel program debugging was Belvedere <ref> [39] </ref>. Belvedere extends Lamport's happened before relation to abstract events and animates the program execution in logical time to filter out perturbations due to asynchrony. EDL [9] is used as the modeling language. <p> Replay techniques guarantee reproducibility by logging the resolution of non-deterministic choices during the initial execution. The log is consulted during re-execution to ensure that the reexecution follows the same state transitions as in the initial execution. Replay systems for message passing programs (for example Radar [51], Belvedere <ref> [39] </ref>, Agora [27], and Recap [71]) log all sends and receives of messages; those for shared memory programs (for example Instant Replay [52], Recap [71]) log the order in which shared variables are accessed. <p> Debuggers that retain the partial order between event occurrences in their internal representation of program behavior include ECSP [8] by Baiardi, De Nicola, and Vaglini, Meld [41] by Hseush and Kaiser, Belvedere by Hough <ref> [39] </ref>. ECSP specifies the program behavior as a set of process-specific models. A specification acts as a trigger for assertion checking. Once the specification is matched certain user-defined assertions can be checked, or mode control can be transferred to the user. <p> This rigidity often hinders the specification of complex behavior where the user is interested only in the temporal order between parts of abstract events and does not really care about a total order. Event-based modeling complements the state-based debugging approach by providing support for behavioral abstraction. Some of them <ref> [39, 41] </ref> also contain the correct notion of logical time to accommodate asynchronous execution. None, however, have tackled the issue of providing hierarchical error feedback in presence of massive parallelism. Moreover in the process of avoiding issue of state consistency event-based debuggers eliminate any considerations of local states. <p> What if only nil is left? The event is stripped automatically, and the relation holds true trivially. In the next section we compare Ariadne's modeling language with three other languages | EDL [9], DPE [41], and PEDL <ref> [39] </ref> | to highlight the differences. 3.5 Evaluation of Ariadne's Modeling Language Hough in his thesis [39] presents a detailed critique of Event Definition Language (EDL) [9] and Data Path Expressions (DPE) [41] and introduces a new modeling language called Parallel Event Definition Language (PEDL). <p> In the next section we compare Ariadne's modeling language with three other languages | EDL [9], DPE [41], and PEDL <ref> [39] </ref> | to highlight the differences. 3.5 Evaluation of Ariadne's Modeling Language Hough in his thesis [39] presents a detailed critique of Event Definition Language (EDL) [9] and Data Path Expressions (DPE) [41] and introduces a new modeling language called Parallel Event Definition Language (PEDL).
Reference: [40] <author> Hough, A. A., and Cuny, J. E. </author> <title> Perspective views: A technique for enchanc-ing visualizations of parallel programs. </title> <booktitle> In 1990 International Conference on Parallel Processing, </booktitle> <pages> pages II 124-132, </pages> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: At the primitive event level, this ordering is captured by Lamport's happened before relation. Ariadne imports Belvedere's extension of Lamport's relation to sets of primitive events; defining three relations: precedes, parallels, and overlaps <ref> [40] </ref> for use in the construction of pt-chains.
Reference: [41] <author> Hseush, W., and Kaiser, G. E. </author> <title> Modeling concurrency in parallel debugging. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 11-20, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Event-based techniques offer an alternative in which user-specified models of intended program behavior are compared to actual program behavior as captured in execution traces <ref> [8, 9, 39, 41] </ref>. <p> This dissertation is based on the premise that parallel debugging requires a multi-level strategy. The strategy we propose employs event-based techniques <ref> [8, 9, 53, 39, 41] </ref> at the highest level where gross patterns of process interactions are investigated. As debugging proceeds and the focus of attention narrows, the behavior of progressively smaller parts of the program are analyzed in progressively finer detail, using a combination of event- and state-based techniques. <p> They differ most significantly in their modeling languages: IDD [36], and TSL [37] use temporal logic based modeling language, YODA [54], HARD [23], and TQuel [83] use relational query language, whereas ECSP [8], Kraut [13], EBBA [9], and Meld <ref> [41] </ref> use variants of regular expressions as their modeling language. Independent of their modeling languages event-based approaches can be compared in terms of their internal representation of behavior: string representations impose a total order on event occurrences while partial order, graph representations based on Lamport's happened before relation do not. <p> Moreover EBBA's pattern matching approach is too unrestrained and, as a result, it is incapable of providing precise feedback on errors. Debuggers that retain the partial order between event occurrences in their internal representation of program behavior include ECSP [8] by Baiardi, De Nicola, and Vaglini, Meld <ref> [41] </ref> by Hseush and Kaiser, Belvedere by Hough [39]. ECSP specifies the program behavior as a set of process-specific models. A specification acts as a trigger for assertion checking. Once the specification is matched certain user-defined assertions can be checked, or mode control can be transferred to the user. <p> Variants of path expressions are used to specify the control flow of a program by Garcia and Berman [31], by Bruegge in his KRAUT debugger [13], by Hseush and Kaiser in their Meld debugger <ref> [41] </ref>. Garcia and Berman designed a visualization system that renders the Petri-net equivalent of the path expression specified by the user. The Petri-net is animated to show the program execution, and can be used to set a breakpoint. <p> This rigidity often hinders the specification of complex behavior where the user is interested only in the temporal order between parts of abstract events and does not really care about a total order. Event-based modeling complements the state-based debugging approach by providing support for behavioral abstraction. Some of them <ref> [39, 41] </ref> also contain the correct notion of logical time to accommodate asynchronous execution. None, however, have tackled the issue of providing hierarchical error feedback in presence of massive parallelism. Moreover in the process of avoiding issue of state consistency event-based debuggers eliminate any considerations of local states. <p> time, although the verification of the logical time relationships between abstract events may take polynomial time | avoiding the costliness of pattern matching approaches [9, 37] and the expensive implementations (number of states can potentially be exponential in the length of the parallel expression to be recognized) of previous languages <ref> [41] </ref>. At the same time, our matching algorithm can provide precise information on the reasons for a match failure. 3.2.2.1 Example: Binary Image Compression To illustrate our modeling language, we consider a parallel version of an image compression algorithm [72]. <p> Similar extensions have previously been proposed <ref> [26, 35, 41] </ref> but we have found our definitions to be more appropriate for debugging. <p> What if only nil is left? The event is stripped automatically, and the relation holds true trivially. In the next section we compare Ariadne's modeling language with three other languages | EDL [9], DPE <ref> [41] </ref>, and PEDL [39] | to highlight the differences. 3.5 Evaluation of Ariadne's Modeling Language Hough in his thesis [39] presents a detailed critique of Event Definition Language (EDL) [9] and Data Path Expressions (DPE) [41] and introduces a new modeling language called Parallel Event Definition Language (PEDL). <p> next section we compare Ariadne's modeling language with three other languages | EDL [9], DPE <ref> [41] </ref>, and PEDL [39] | to highlight the differences. 3.5 Evaluation of Ariadne's Modeling Language Hough in his thesis [39] presents a detailed critique of Event Definition Language (EDL) [9] and Data Path Expressions (DPE) [41] and introduces a new modeling language called Parallel Event Definition Language (PEDL). Since these three languages are most similar to ours among the event-based modeling languages, we will evaluate them and present the rationale behind Ariadne's modeling language.
Reference: [42] <author> Hu, A. J., Dill, D., Crexler, A., and Yang, C. H. </author> <title> Higher Level Specification and Verification with BDDs. </title> <booktitle> Proceedings of the 3rd International Workshop on Computer Aided Verification, </booktitle> <address> Montreal Canada, </address> <month> July </month> <year> 1992. </year>
Reference: [43] <author> Hurfin, M., Plouzeau, N., and Raynal, M. </author> <title> Detecting atomic sequences of predicates in distributed computations. </title> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Computing, </booktitle> <pages> pages 32-42, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The issue of consistent global states in the context of distributed computation has been addressed by many researchers. Distributed marker passing algorithms are proposed by Chandy and Lamport [15], Miller and Choi [61], Haban and Weigel [35], and Hurfin, Plouzeau and Raynal <ref> [43] </ref> using specially tagged messages to distribute information about local states across different processes and stop the whole computation in a consistent global state.
Reference: [44] <author> Intel Supercomputer Systems Division. </author> <title> Paragon Interactive Parallel Debugger Reference Manual. Paragon Documentation, </title> <year> 1994. </year>
Reference-contexts: Finally, at the lowest level, when the error has been isolated to specific sections of sequential code, traditional state-based techniques <ref> [44, 92, 73] </ref> are used. This integrated strategy 2 effectively addresses the inadequacies of both approaches: it provides powerful abstraction mechanisms for understanding complex behaviors that purely state-based approaches lack, and it provides the ability to examine state information at an arbitrary level of detail that standard event-based debuggers lack. <p> At this point in our debugging session, we need to examine the local states of our program. We could have used any vendor supplied state-examination debugger. For this example which was written for Intel Paragon, we used the vendor-supplied ipd debugger. 5.1.4 The State-Based Component ipd <ref> [44] </ref> provides comprehensive services for state examination and modification similar to those available on standard, sequential debuggers [2, 87].
Reference: [45] <author> Joyce, J. et al. </author> <title> Monitoring distributed systems. </title> <journal> ACM Transactions of Computing Systems, </journal> <volume> Vol. 5, No. 2, </volume> <pages> pages 124-150, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: This architecture has been used by Miller, Macrander and Sechrest [63], and in the Jade system by Joyce et al. <ref> [45] </ref> to collect event traces for performance analysis. 17 The other aspect of performance monitoring deals with the analysis of the large data set collected by program instrumentation. <p> They also prove, that for global predicates specified as a disjunction of local predicates, this can be accomplished only by replaying the trace twice. Several state-based techniques also subsume the functionality provided by run-time monitoring systems. Jade <ref> [45] </ref> described in Section 2.3 and SPIDER [82] are examples of such systems. Jade allows the user to control the total ordering of the interprocess communication through a system-wide controller process. The SPIDER system by Smith [82] uses demons that continuously monitor the message traffic.
Reference: [46] <author> Kundu, J. </author> <note> Ariadne User's Manual (in preparation) </note>
Reference-contexts: With large programs consisting of many modules, however, this is hardly feasible. 4.2 Other Features of Ave/Ariadne Ave/Ariadne features two other powerful mechanisms a sophisticated filtering scheme and the capability of imposing multiple views on a behavior. We showcase both features through another sampling debugging session. The filtering mechanism <ref> [46] </ref> allows for conditional attribute expressions to be used to guide the matching process as in EDL [9]. Unlike EDL, however, Ariadne's filtering scheme is restrained. Use of multiple views of program behavior had been advocated strongly in [53].
Reference: [47] <author> Kundu, J., and Cuny, J. E. </author> <title> A scalable, visual interface for debugging with event-based behavioral abstraction. </title> <booktitle> In Proceedings of New Frontiers on Massively Parallel Processing, </booktitle> <pages> pages 472-479, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Ariadne models often provide only a coarse description of program behavior that may match an execution in unintended ways, and ii. Ariadne's output is not sufficiently scalable. both of these are addressed in the design of the Ave <ref> [47] </ref> user interface. 3.3 Ave: Scalable, Visual Feedback Mechanism The tree has been compressed both horizontally and vertically: horizontally by eliding sibling nodes and vertically by pruning levels.
Reference: [48] <author> Lamport, L. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> Vol. 21, No. 7, </volume> <pages> pages 558-565, </pages> <year> 1978. </year>
Reference-contexts: This graph is called a time diagram, and an example is shown in Figure 3.1. The transitive closure of a time diagram represents Lamport's happened before relation <ref> [48] </ref>, also known as the causality relation [59]. The matching semantics employed by Ariadne is that of parsing: each input event must be matched by the model, no skipping of events is allowed unless explicitly specified by the user.
Reference: [49] <author> Lauer, P. E., Torrigani, P. R., and Shields, M. W. </author> <title> COSY | A system specification language based on paths and processes. </title> <journal> Acta Informatica, </journal> <volume> Vol. 12, </volume> <pages> pages 109-158, </pages> <year> 1979. </year>
Reference: [50] <author> Leban, B. </author> <title> Representative Views of Parallel Computation. </title> <type> Unpublished Thesis Proposal, </type> <institution> Department of Computer Science, University of Massachusetts, Amherst, </institution> <year> 1993. </year>
Reference-contexts: These similarities between the two domains have led to the development of several 14 abstract animation systems <ref> [39, 50] </ref> geared expressly toward debugging of parallel programs. Animation systems require the user to specify the events to be animated, select or design animation objects that will form the animation, and define a mapping between the program objects and the animation objects. <p> Annotation-based animation systems collect interesting events by instrumenting the program, and then specify the animation scheme in terms of the collected events and animation icons. Annotation-based parallel program animating systems include Voyeur [85], Belvedere [39] and J2 <ref> [50] </ref>. Voyeur's architecture resembles that of BALSA [12], an animation system developed for sequential programs; and it supports a class hierarchy of views to create animations at different levels of abstraction. <p> Belvedere, however, does not address the issue of scale that arises with massive parallelism. Leban addresses the issue of scalability in a comprehensive manner in his J2 system <ref> [50] </ref>. J2 animates the program execution in terms of the representative 15 behavior of the program by combining processes exhibiting similar behaviors into a group. J2 has been shown to accommodate fixed communication patterns scalably.
Reference: [51] <author> LeBlanc, R. J., and Robbins, A. D. </author> <title> Event-driven monitoring of distributed programs. </title> <booktitle> In Proceedings of the 5th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 515-522, </pages> <year> 1985. </year>
Reference-contexts: The use of event traces in conjunction with replay mechanisms avoids issues of global state consistency [18, 58] and reproducibility; the use of abstraction makes it possible to contend with large quantities of data; and the use of logical time transformations filters out perturbations due to asynchrony <ref> [21, 51] </ref>. Current event-based debugging tools, however, have three major limitations: they do not provide sufficient feedback on match failures, they do not scale well for massive parallelism, and they do not facilitate tracking errors back to the source code. <p> Replay techniques guarantee reproducibility by logging the resolution of non-deterministic choices during the initial execution. The log is consulted during re-execution to ensure that the reexecution follows the same state transitions as in the initial execution. Replay systems for message passing programs (for example Radar <ref> [51] </ref>, Belvedere [39], Agora [27], and Recap [71]) log all sends and receives of messages; those for shared memory programs (for example Instant Replay [52], Recap [71]) log the order in which shared variables are accessed.
Reference: [52] <author> LeBlanc, T. J., and Mellor-Crummey, J. M. </author> <title> Debugging parallel programs with instant replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. C-36, No. 4, </volume> <pages> pages 471-482, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: Replay systems for message passing programs (for example Radar [51], Belvedere [39], Agora [27], and Recap [71]) log all sends and receives of messages; those for shared memory programs (for example Instant Replay <ref> [52] </ref>, Recap [71]) log the order in which shared variables are accessed. Systems like Recap [71], Igor [25] and Agora [27], also capture the system state periodically through checkpointing, thereby providing the user the capability of random access playback 1 .
Reference: [53] <author> LeBlanc, T. J., Mellor-Crummey, J. M., and Fowler, R. J. </author> <title> Analyzing parallel program executions using multiple views. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol. 9, </volume> <pages> pages 203-217, </pages> <year> 1990. </year> <month> 194 </month>
Reference-contexts: This dissertation is based on the premise that parallel debugging requires a multi-level strategy. The strategy we propose employs event-based techniques <ref> [8, 9, 53, 39, 41] </ref> at the highest level where gross patterns of process interactions are investigated. As debugging proceeds and the focus of attention narrows, the behavior of progressively smaller parts of the program are analyzed in progressively finer detail, using a combination of event- and state-based techniques. <p> The vastness of such state space coupled with the presence of physical asynchrony renders the traditional 31 state-based debugging techniques useless. Parallel program debugging requires a sophisticated abstraction mechanism, and the ability to investigate behavior from different view points in a manageable way. Mellor-Crummey, LeBlanc and Fowler in Moviola <ref> [53] </ref> and Lin and Leblanc in their Clouds [55] debugger argue for such abstraction facility. The use of sophisticated abstraction in itself, however, does not provide a comprehensive solution. <p> The filtering mechanism [46] allows for conditional attribute expressions to be used to guide the matching process as in EDL [9]. Unlike EDL, however, Ariadne's filtering scheme is restrained. Use of multiple views of program behavior had been advocated strongly in <ref> [53] </ref>. Ariadne provides it in two ways: it allows the user to select a portion of the execution history and model the behavior of the selected events in multiple ways, and it provides the capability of partitioning the abstract events into equivalence classes based on their derived/primitive attributes.
Reference: [54] <author> Ledoux, C. H., and Stott-Parker, D. Jr. </author> <title> Saving traces for Ada debugging. Ada in use, </title> <booktitle> Ada International Conference, </booktitle> <pages> pages 97-108, </pages> <address> Paris 14-16, </address> <month> May </month> <year> 1985. </year>
Reference-contexts: Event-based approaches can be used with run-time monitor 28 ing or post-mortem modeling. They differ most significantly in their modeling languages: IDD [36], and TSL [37] use temporal logic based modeling language, YODA <ref> [54] </ref>, HARD [23], and TQuel [83] use relational query language, whereas ECSP [8], Kraut [13], EBBA [9], and Meld [41] use variants of regular expressions as their modeling language. <p> In IDD, a programmer uses interval logic to specify assertions that should hold at intervals delimited by distinct events. In TSL, designed for debugging Ada programs, specifications are written as a declarative part of the task bodies, and are enabled any time a task enters the region. YODA <ref> [54] </ref>, HARD [23], and TQuel [83] use relational query languages to verify properties of execution behavior. These methods can be used only with shared bus architectures, where the shared broadcast medium imposes a total order among the inter-process interactions.
Reference: [55] <author> Lin, C., and LeBlanc, R. </author> <title> Event-based debugging of object/action programs. </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 23-34, </pages> <month> Jan </month> <year> 1989. </year>
Reference-contexts: Parallel program debugging requires a sophisticated abstraction mechanism, and the ability to investigate behavior from different view points in a manageable way. Mellor-Crummey, LeBlanc and Fowler in Moviola [53] and Lin and Leblanc in their Clouds <ref> [55] </ref> debugger argue for such abstraction facility. The use of sophisticated abstraction in itself, however, does not provide a comprehensive solution. It must be accompanied by a facility to track the error detected at a higher level of abstraction down to the source construct.
Reference: [56] <author> Lo, V., Rajopadhye, S., Mohamed, M., Gupta, S., Nitzberg, B., Telle, J., Zhong, X. LaRCS: </author> <title> A language for describing parallel computations for the purpose of mapping. </title> <type> Technical Report CIS-TR-90-16, </type> <institution> University of Oregon Dept. of Computer Science, </institution> <year> 1990. </year>
Reference-contexts: The decomposition of the matching algorithm allows us to distinguish between these classes. 39 The three definitional levels appear to form a natural mechanism for describing parallel systems, as evidenced by their use in other contexts such as the XYZ levels of Phase Abstractions [84] and the LaRCS specification language <ref> [56] </ref>. The matching algorithm for our language is straightforward: a pt-chain is recognized by a finite state machine that invokes copies of other finite state machines to recognize chains on specific processes.
Reference: [57] <author> Long, D. L., and Clarke, L. A. </author> <title> Task interaction graphs for concurrency analysis. </title> <booktitle> Proceedings of the 11th International Conference on Software Engg., </booktitle> <pages> pages 44-52, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: The primary problem with state based analysis is the explosion of state space: the number of states in a concurrency graph and the number of places in a petri-net is exponential in the number of tasks. Long and Clarke <ref> [57] </ref>, and McDowell [60] have suggested ways to construct the graph from task interaction analysis rather than from control flow analysis to reduce the size of the graph. Under these techniques, the states between two synchronization operations are collapsed into one single state.
Reference: [58] <author> Manabe, Y., and Imase, M. </author> <title> Global conditions in debugging distributed programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol. 15, </volume> <pages> pages 62-69, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Event-based techniques offer an alternative in which user-specified models of intended program behavior are compared to actual program behavior as captured in execution traces [8, 9, 39, 41]. The use of event traces in conjunction with replay mechanisms avoids issues of global state consistency <ref> [18, 58] </ref> and reproducibility; the use of abstraction makes it possible to contend with large quantities of data; and the use of logical time transformations filters out perturbations due to asynchrony [21, 51]. <p> Specifying consistent global states in presence of multiple processes is difficult: it is even harder to stop the computation at such a consistent state once it is specified. Manabe and Imase <ref> [58] </ref> have proved that in order to stop a parallel program at certain states, the program may need to be replayed twice. * Asynchrony: In absence of a global clock, processes in a asynchronous parallel program do not execute in lock-step. <p> In contrast, Manabe and Imase <ref> [58] </ref> present a centralized algorithm that ensures, for global predicates specifiable as conjunctions of local predicates, a debugger controlling the distributed system can halt all the processes at the earliest consistent global state. This requires running the program under the control of the debugger, and can induce time delay. <p> Section 5.4 presents three more debugging examples that showcase the integrated debugging environment. 5.1 Setting of Consistent Global Breakpoints Based on Abstract Events Manabe and Imase <ref> [58] </ref> also use a replay-based approach, allowing break-points to be to specified as conjunctions and disjunctions of predicates on local states. It may, however, be difficult to determine the appropriate predicates: errors observable only as incorrect output are often hard to relate back to individual, local predicates in specific processes.
Reference: [59] <author> Mattern, F. </author> <title> Virtual time and global states of distributed systems. </title> <editor> M. Cosnard et al, eds., </editor> <booktitle> "Parallel and Distributed Algorithms", </booktitle> <publisher> Elsvier Science Publishers B. V. (North Holland), </publisher> <pages> pages 215-226, </pages> <year> 1989. </year>
Reference-contexts: This graph is called a time diagram, and an example is shown in Figure 3.1. The transitive closure of a time diagram represents Lamport's happened before relation [48], also known as the causality relation <ref> [59] </ref>. The matching semantics employed by Ariadne is that of parsing: each input event must be matched by the model, no skipping of events is allowed unless explicitly specified by the user.
Reference: [60] <author> McDowell, C. E. </author> <title> A practical algorithm for static analysis of programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol. 6, </volume> <pages> pages 515-536, </pages> <year> 1989. </year>
Reference-contexts: The primary problem with state based analysis is the explosion of state space: the number of states in a concurrency graph and the number of places in a petri-net is exponential in the number of tasks. Long and Clarke [57], and McDowell <ref> [60] </ref> have suggested ways to construct the graph from task interaction analysis rather than from control flow analysis to reduce the size of the graph. Under these techniques, the states between two synchronization operations are collapsed into one single state.
Reference: [61] <author> Miller, B. P., and Choi, J.-D. </author> <title> Breakpoints and halting in distributed systems. </title> <booktitle> Proceedings of 8th International Conference of Distributed Computing Systems, </booktitle> <pages> pages 316-323, </pages> <year> 1988. </year>
Reference-contexts: The issue of consistent global states in the context of distributed computation has been addressed by many researchers. Distributed marker passing algorithms are proposed by Chandy and Lamport [15], Miller and Choi <ref> [61] </ref>, Haban and Weigel [35], and Hurfin, Plouzeau and Raynal [43] using specially tagged messages to distribute information about local states across different processes and stop the whole computation in a consistent global state. <p> Alternatively, local breakpoints can be extended dynamically to global breakpoints <ref> [35, 15, 61] </ref>. <p> Alternatively, local breakpoints can be extended dynamically to global breakpoints [35, 15, 61]. This can be done explicitly by notifying the remaining processes either through communication with a central monitor <ref> [61] </ref> or over normal communication channels [35, 15] that a breakpoint has been reached or it can be done implicitly by allowing the remaining processes to run until they block waiting for input.
Reference: [62] <author> Miller, B., and Choi, J.-D. </author> <title> A mechanism for efficient debugging of parallel programs. </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 141-150, </pages> <year> 1989. </year>
Reference-contexts: This flowback analysis technique has also been used in parallel program debugging by Choi and Miller <ref> [62] </ref>. Similar event-based technique of logging all variable accesses has also been used in PROVIDE [65] to animate complex program states. The most high level event-based approach to sequential debugging is imported from the domain of parallel debugging. <p> A reexecution that differs from the original execution indicates that additional synchronization constraints are needed for correct execution. Miller and Choi extended Balzer's flowback analysis for shared memory parallel programs in their PPD debugger <ref> [62] </ref>. The debugger uses interprocedural data flow analysis to identify the variables that may be read at each block. Instrumentation is generated automatically to save all the variables at the beginning of a block that might be read before the next log point.
Reference: [63] <author> Miller, B., Macrander, S., and Sechrest, A. </author> <title> Monitoring distributed systems. </title> <journal> Software Practices and Experience, </journal> <volume> Vol. 162, No. 2, </volume> <pages> pages 183-200, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: Each instrumented system call to send a message, generates a duplicate message to central a filter process that contains a user-specified template to determine whether the message is to be stored in the trace. This architecture has been used by Miller, Macrander and Sechrest <ref> [63] </ref>, and in the Jade system by Joyce et al. [45] to collect event traces for performance analysis. 17 The other aspect of performance monitoring deals with the analysis of the large data set collected by program instrumentation.
Reference: [64] <author> Milner, R. </author> <title> Elements of interaction. </title> <journal> Communications of the ACM, </journal> <volume> Vol. 36, No. 1, </volume> <pages> pages 78-89, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The idea is to derive certain properties of simple systems using the axiomatic framework, and then show equivalence between a known system and the program in hand. The algebraic frameworks developed for studying equivalences for parallel programs include Calculus of Communicating Systems (CCS) by Milner <ref> [64] </ref> based on observational equivalence of traces, Communicating Sequential Processes (CSP) by Hoare [38] based on failure semantics, and Asynchronous Concurrent Processes (ACP) by Baeten and Weijland [6] based on bisimulation equivalence of traces.
Reference: [65] <author> Moher, T. G. </author> <title> PROVIDE: A process visualization and debugging environment. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-14, No. 6, </volume> <pages> pages 849-857, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: This flowback analysis technique has also been used in parallel program debugging by Choi and Miller [62]. Similar event-based technique of logging all variable accesses has also been used in PROVIDE <ref> [65] </ref> to animate complex program states. The most high level event-based approach to sequential debugging is imported from the domain of parallel debugging.
Reference: [66] <author> Mohr, B., Brown, D., Malony, A. </author> <title> TAU: A Portable Parallel Program Analysis Environment for pC++, </title> <booktitle> Proc. of CONPAR 94 - VAPP VI, </booktitle> <address> Linz, Austria, </address> <publisher> Springer Verlag, LNCS 854, </publisher> <pages> pages 29-40, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: are problematic: How are the breakpoints to be specified across multiple processes? Must they be globally consistent or are local breakpoints sufficient? If local, how and when should the remaining processes be stopped in order to provide a meaningful state? One possibility is to allow breakpoints only at barrier synchronizations <ref> [66] </ref> but this is overly constraining in multithreaded language environments. Alternatively, local breakpoints can be extended dynamically to global breakpoints [35, 15, 61].
Reference: [67] <author> Netzer, R. H. B. </author> <title> Optimal tracing and replay for debugging shared-memory parallel programs. </title> <journal> In ACM SIGPLAN Notices, </journal> <volume> Vol. 26, No. 12, </volume> <pages> pages 1-11, </pages> <year> 1991. </year> <month> 195 </month>
Reference-contexts: Although this will not detect all the races related to the variable, it guarantees that at least one race involving that variable will be detected. Such optimizations in dynamic data flow analysis for race detections have been proposed in <ref> [16, 67] </ref>. Program analysis techniques are not scalable, and they can account for only a limited types of errors. State-based techniques are prone to explosion in the state space and are thus unable to accommodate massively parallel programs.
Reference: [68] <author> Netzer, R. H. B., and Miller, B. P. </author> <title> Improving the accuracy of data race detection. </title> <booktitle> Proc. of the 3rd ACM Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 133-141, </pages> <month> April </month> <year> 1991. </year>
Reference: [69] <author> Netzer, R. H. B., and Xu, J. </author> <title> Incremental replay of message-passing programs. </title> <booktitle> Proceedings of Supercomputing '93, </booktitle> <pages> pages 840-849, </pages> <year> 1993. </year>
Reference-contexts: None 1 This facility is mistakenly called reverse execution by many authors. 24 of the debuggers mentioned above can guarantee global consistency with their local checkpoints: they can only allow process-specific random-access playback. Netzer and Xu have addressed the issue of consistent global checkpoints in <ref> [69] </ref>, by providing a scheme that can identify sets of local checkpoints making up consistent global states. Replay techniques have been enhanced to be used directly for debugging purposes. Stone makes use of non-deterministic replay [89] to give the user the capacity to ask what-if questions. <p> We thus inherit the limitations of any replay-based scheme. Firstly, for a long running program the collected trace would be large. To ameleorate the effects of tracing overhead would require Ave/Ariadne to incorporate consistent checkpointing and optimal tracing as outlined by Netzer and Xu <ref> [69] </ref>. Secondly, Ave/Ariadne guarantees reproducible execution only for passive message passing programs. Implementing a a replay facility in an active message passing environment would require kernel support. Most importantly, our replay scheme assumes that the program is unoptimized. In presence of aggressive optimizations, the replay scheme may not work.
Reference: [70] <author> Olsson, R. A., Crawford, R. H., and Ho, W. W. </author> <title> A dataflow approach to event-based debugging. </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 21, No. 2, </volume> <pages> pages 209-229, </pages> <month> Feb </month> <year> 1991. </year>
Reference-contexts: Similar event-based technique of logging all variable accesses has also been used in PROVIDE [65] to animate complex program states. The most high level event-based approach to sequential debugging is imported from the domain of parallel debugging. Olsson, Crawford and Ho in their Dalek system <ref> [70] </ref> incorporate many ideas found in the event-based parallel debugging field in order to build a high level sequential debugger. Dalek takes a dataflow approach to event recognition.
Reference: [71] <author> Pan, D. Z., and Linton, M. A. </author> <title> Supporting reverse execution for parallel programs. </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 124-129, </pages> <month> Jan </month> <year> 1989. </year>
Reference-contexts: The log is consulted during re-execution to ensure that the reexecution follows the same state transitions as in the initial execution. Replay systems for message passing programs (for example Radar [51], Belvedere [39], Agora [27], and Recap <ref> [71] </ref>) log all sends and receives of messages; those for shared memory programs (for example Instant Replay [52], Recap [71]) log the order in which shared variables are accessed. Systems like Recap [71], Igor [25] and Agora [27], also capture the system state periodically through checkpointing, thereby providing the user the <p> Replay systems for message passing programs (for example Radar [51], Belvedere [39], Agora [27], and Recap <ref> [71] </ref>) log all sends and receives of messages; those for shared memory programs (for example Instant Replay [52], Recap [71]) log the order in which shared variables are accessed. Systems like Recap [71], Igor [25] and Agora [27], also capture the system state periodically through checkpointing, thereby providing the user the capability of random access playback 1 . Recap [71] has an innovative checkpointing scheme that reduces logging overhead by <p> Replay systems for message passing programs (for example Radar [51], Belvedere [39], Agora [27], and Recap <ref> [71] </ref>) log all sends and receives of messages; those for shared memory programs (for example Instant Replay [52], Recap [71]) log the order in which shared variables are accessed. Systems like Recap [71], Igor [25] and Agora [27], also capture the system state periodically through checkpointing, thereby providing the user the capability of random access playback 1 . Recap [71] has an innovative checkpointing scheme that reduces logging overhead by making use of operating system resources. <p> for shared memory programs (for example Instant Replay [52], Recap <ref> [71] </ref>) log the order in which shared variables are accessed. Systems like Recap [71], Igor [25] and Agora [27], also capture the system state periodically through checkpointing, thereby providing the user the capability of random access playback 1 . Recap [71] has an innovative checkpointing scheme that reduces logging overhead by making use of operating system resources. At periodic checkpoints, each process forks a child that inherits its data structures and state; the child is immediately halted after its creation.
Reference: [72] <author> Scheuermann, P., Yaagoub, A., and Aris-Ouksel, M. </author> <title> Compression of binary images on a hypercube machine. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol 23, </volume> <pages> pages 49-59, </pages> <year> 1994. </year>
Reference-contexts: At the same time, our matching algorithm can provide precise information on the reasons for a match failure. 3.2.2.1 Example: Binary Image Compression To illustrate our modeling language, we consider a parallel version of an image compression algorithm <ref> [72] </ref>. Because the same example is used throughout the thesis, we digress slightly here to discuss it in some detail.
Reference: [73] <institution> Sequent Computer Systems, Inc. </institution> <note> DYNIX Pdbx Debugger User's Manual. </note> <year> 1986. </year>
Reference-contexts: Introduction The debugging of parallel programs is often difficult. State-based techniques <ref> [92, 73] </ref> allow the user to directly examine an execution to an arbitrary level of detail and to relate errors to source code constructs. <p> Finally, at the lowest level, when the error has been isolated to specific sections of sequential code, traditional state-based techniques <ref> [44, 92, 73] </ref> are used. This integrated strategy 2 effectively addresses the inadequacies of both approaches: it provides powerful abstraction mechanisms for understanding complex behaviors that purely state-based approaches lack, and it provides the ability to examine state information at an arbitrary level of detail that standard event-based debuggers lack. <p> The basic facilities of location, visualization and modification of states are augmented to handle the aspects of interprocess communication. Commercial multiprocessor debuggers like Pdbx by Sequent Corporation <ref> [73] </ref>, or udb provided by KSR [92] stop the execution on per-process basis. Breakpoints can be set by specifying the statement number: all threads are suspended when the statement is executed by any thread.
Reference: [74] <institution> Sequent Computer Systems, Inc. </institution> <note> Guide to Parallel Programming on Sequent Computer Systems. </note> <year> 1987. </year>
Reference-contexts: debugging sessions deal with shared memory programs written for the Sequent Symmetry, while the last four consider explicit message passing programs written for the Intel Paragon. 4.1 Sample Debugging Sessions with Ave/Ariadne 4.1.1 Dynamic Task Allocation This program and the detected bug was taken directly from the Sequent Programming Guide <ref> [74] </ref>. It was written for shared memory and uses a dynamic task allocation scheme to search a list of cities for the one closest to an origin. Each process repeatedly gets a sublist of cities and determines whether any of them is closer than the closest city currently known.
Reference: [75] <author> Perl, S., and Weihl, W. </author> <title> Performance assertion checking. </title> <booktitle> Proc. of the ACM Symposium on Operating System Principles, </booktitle> <pages> pages 134-145, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: A spreadsheet interface to specify distributed data is also proposed by Couch [20], but it lacks the static call graph based filtering mechanism presented in SIEVE. Another approach in performance debugging borrows heavily from the event-based approach for correctness debugging. Perl and Weihl <ref> [75] </ref> proposed PSpec, an event-based modeling language for performance assertion checking. Users can identify an interval in terms of its start and end events. Complex predicates can be specified over the events by defining a metric of interest and specifying assertions about that metric.
Reference: [76] <author> Peterson, J.L. </author> <title> Petri Nets. </title> <journal> Computing Surveys, </journal> <volume> Vol. 9, No. 3, </volume> <pages> pages 223-252, </pages> <year> 1977. </year>
Reference-contexts: Potential race conditions can be found by looking for a node with more than one outgoing edges representing accesses to the same shared variable. Alternative state-based approaches construct a petri net <ref> [76] </ref> representation of the parallel program, where a place represents a concurrent state of the program, and a transition represents the execution of a single statement by a single task. These techniques rely on reachability analysis of the resulting petri net.
Reference: [77] <author> Reiss, S. </author> <title> PECAN: Program development systems that support multiple views. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-11, No. 3, </volume> <pages> pages 276-285, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: Moreover debugging requires viewing a program execution from a variety of view points. To this end, the standard services provided by the break/examine/repeat methodology is inadequate. Several non-commercial debuggers have attempted to address these issues. Reiss in his PECAN <ref> [77] </ref> programming environment allows multiple views of the abstract syntax tree representation of the program. These views include structured flowcharts, module interconnection diagrams, symbol tables and data history.
Reference: [78] <author> Roman, G.-C., and Cox, K.C. </author> <title> A declarative approach to visualizing concurrent computations. </title> <journal> Computer, </journal> <volume> Vol. 22, No. 10, </volume> <pages> pages 25-36, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: This work is still under progress. All annotation-based animating system share a common characteristic: programs need to be annotated afresh and recompiled if the user wants to modify the animation. In contrast, Roman and Cox in their Pavane animation system <ref> [78] </ref> propose a declarative approach. Pavane is for animating programs that run on Swarm operating system, which has a shared tuple-space like Linda [3]. Instead of annotating the program, the user declares the animation events that need to be displayed when the global state change satisfies the user-defined criteria.
Reference: [79] <author> Roman, G.-C., and Cox, K.C. </author> <title> A taxonomy of program visualization systems. </title> <journal> Computer, </journal> <volume> Vol. 26, No. 12, </volume> <pages> pages 11-24, </pages> <month> December </month> <year> 1993. </year>
Reference: [80] <author> Rubin, R. V., Rudolph, L., and Zernik, D. </author> <title> Debugging parallel programs in parallel. </title> <journal> In ACM SIGPLAN Notices, </journal> <volume> Vol. 26, No. 12, </volume> <pages> pages 216-225, </pages> <year> 1991. </year>
Reference-contexts: Parallel debuggers cannot guarantee such transparency. Monitoring a single process can change the order in which shared resources are accessed, and hence alter the program behavior. There is no software 4 solution to the probe effect. But use of additional hardware can achieve transparent monitoring <ref> [80] </ref>, albeit at a prohibitive cost. * Specification and Detection of Consistent Global States: Parallel programs contain multiple loci of control and the core behavior of a parallel program is determined by the inter-dependence among the multiple loci through in-terprocess communications. <p> All the replay techniques described above introduce probe effect through the logging overhead. To overcome that, systems have been designed to achieve nonintrusive monitoring. Rubin, Rudolph and Zernik in their shared bus Makbilan 25 architecture <ref> [80] </ref> make non-intrusive replay possible by having shadow processors monitoring processors and the main bus. The monitoring processors are connected by their own private bus. Message logging thus introduces no probe effect.
Reference: [81] <author> Sarukkai, S., and Gannon, D. </author> <title> SIEVE: A performance debugging environment for parallel programs. </title> <journal> J. of Parallel and Distributed Computing, </journal> <volume> Vol. 18, No. 2, </volume> <pages> pages 147-168, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Several debuggers, including Seeplex [19], SIEVE <ref> [81] </ref>, and Chitra [1] address the issue of scalable visual feedback as an aid to data analysis in the context of performance debugging. Scalability is achieved in Seeplex [19] and Chitra [1] by grouping related behaviors together into categories. SIEVE [81] allows the user to focus his/her attention on a particular <p> Several debuggers, including Seeplex [19], SIEVE <ref> [81] </ref>, and Chitra [1] address the issue of scalable visual feedback as an aid to data analysis in the context of performance debugging. Scalability is achieved in Seeplex [19] and Chitra [1] by grouping related behaviors together into categories. SIEVE [81] allows the user to focus his/her attention on a particular portion of the event trace through selection of nodes in the static call graph of the program. Trace data is highly structured, and the user can specify the structure using an event syntax. <p> The more general relationship descendant and ancestor can be used to identify a single or a set of nodes uniquely. A spreadsheet interface for performance debugging has been proposed and implemented by Sarukkai and Gannon <ref> [81] </ref>. However, instead of process interaction, they use the static control flow structure to achieve coarse grained filtering. Events are selected by walking down the static control flow graph, and then issuing temporal queries on a historical database.
Reference: [82] <author> Smith, E. T. </author> <title> A debugger for message based processes. </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 15, No. 11, </volume> <pages> pages 1073-1086, </pages> <month> November </month> <year> 1985. </year>
Reference-contexts: They also prove, that for global predicates specified as a disjunction of local predicates, this can be accomplished only by replaying the trace twice. Several state-based techniques also subsume the functionality provided by run-time monitoring systems. Jade [45] described in Section 2.3 and SPIDER <ref> [82] </ref> are examples of such systems. Jade allows the user to control the total ordering of the interprocess communication through a system-wide controller process. The SPIDER system by Smith [82] uses demons that continuously monitor the message traffic. The demons can atomically examine, interpret and modify interprocess communication. <p> Several state-based techniques also subsume the functionality provided by run-time monitoring systems. Jade [45] described in Section 2.3 and SPIDER <ref> [82] </ref> are examples of such systems. Jade allows the user to control the total ordering of the interprocess communication through a system-wide controller process. The SPIDER system by Smith [82] uses demons that continuously monitor the message traffic. The demons can atomically examine, interpret and modify interprocess communication. The user can write a boolean trigger function for each demon, and can assign priority classes to determine which demon should execute first in case of multiple firing.
Reference: [83] <author> Snodgrass, R. </author> <title> A relational database approach to real-time monitoring. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 6, No. 3, </volume> <pages> pages 157-196, </pages> <month> May </month> <year> 1988. </year> <month> 196 </month>
Reference-contexts: Event-based approaches can be used with run-time monitor 28 ing or post-mortem modeling. They differ most significantly in their modeling languages: IDD [36], and TSL [37] use temporal logic based modeling language, YODA [54], HARD [23], and TQuel <ref> [83] </ref> use relational query language, whereas ECSP [8], Kraut [13], EBBA [9], and Meld [41] use variants of regular expressions as their modeling language. <p> In TSL, designed for debugging Ada programs, specifications are written as a declarative part of the task bodies, and are enabled any time a task enters the region. YODA [54], HARD [23], and TQuel <ref> [83] </ref> use relational query languages to verify properties of execution behavior. These methods can be used only with shared bus architectures, where the shared broadcast medium imposes a total order among the inter-process interactions.
Reference: [84] <author> Snyder, L. </author> <title> The XYZ abstraction levels of Poker-like languages. Languages and Compilers for Parallel Computing, </title> <editor> David Gelernter and Alexandru Nicolau and David Padua(eds.), </editor> <publisher> MIT Press, </publisher> <pages> pages 470-489, </pages> <year> 1990. </year>
Reference-contexts: The decomposition of the matching algorithm allows us to distinguish between these classes. 39 The three definitional levels appear to form a natural mechanism for describing parallel systems, as evidenced by their use in other contexts such as the XYZ levels of Phase Abstractions <ref> [84] </ref> and the LaRCS specification language [56]. The matching algorithm for our language is straightforward: a pt-chain is recognized by a finite state machine that invokes copies of other finite state machines to recognize chains on specific processes.
Reference: [85] <author> Socha, D., Bailey, M., and Notkin, D. Voyeur: </author> <title> Graphical views of parallel programs. </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 206-215, </pages> <year> 1989. </year>
Reference-contexts: Annotation-based animation systems collect interesting events by instrumenting the program, and then specify the animation scheme in terms of the collected events and animation icons. Annotation-based parallel program animating systems include Voyeur <ref> [85] </ref>, Belvedere [39] and J2 [50]. Voyeur's architecture resembles that of BALSA [12], an animation system developed for sequential programs; and it supports a class hierarchy of views to create animations at different levels of abstraction.
Reference: [86] <author> Spezialetti, M., and Kearns, J. </author> <title> A general approach to recognizing event occurences in distributed computations. </title> <booktitle> Proceedings of the 8th International Confrenece of Distributed Computing Systems, </booktitle> <pages> pages 300-307, </pages> <month> July </month> <year> 1988. </year>
Reference: [87] <author> Stallman, R. M. </author> <title> GDB Manual (The GNU Source-Level Debugger). Free Software Foundation, </title> <address> Cambridge, MA. </address>
Reference-contexts: We could have used any vendor supplied state-examination debugger. For this example which was written for Intel Paragon, we used the vendor-supplied ipd debugger. 5.1.4 The State-Based Component ipd [44] provides comprehensive services for state examination and modification similar to those available on standard, sequential debuggers <ref> [2, 87] </ref>.
Reference: [88] <author> Stasko, J. T. </author> <title> Tango: A framework and system for algorithm animation. </title> <journal> Computer, </journal> <volume> Vol. 23, No. 9, </volume> <pages> pages 27-39, </pages> <month> September </month> <year> 1990. </year>
Reference: [89] <author> Stone, J. </author> <title> A graphical representation of concurrent processes. </title> <journal> In ACM SIG-PLAN Notices, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 226-235, </pages> <year> 1989. </year>
Reference-contexts: Netzer and Xu have addressed the issue of consistent global checkpoints in [69], by providing a scheme that can identify sets of local checkpoints making up consistent global states. Replay techniques have been enhanced to be used directly for debugging purposes. Stone makes use of non-deterministic replay <ref> [89] </ref> to give the user the capacity to ask what-if questions. During execution, all messages are logged. The system then shows the potential concurrent local states of a program via concurrency map in which local states within a process between two communication events are coalesced into one state.
Reference: [90] <author> Tai, K. C., Carver, R. H., and Obaid, E. E. </author> <title> Debugging concurrent Ada programs by deterministic execution. </title> <journal> IEEE Trans. of Software Engineering, </journal> <month> Jan </month> <year> 1991. </year>
Reference: [91] <author> Taylor, R. </author> <title> A general purpose algorithm for analyzing concurrent programs. </title> <journal> Comm. of the ACM, </journal> <volume> Vol. 26, No. 5, </volume> <pages> pages 363-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: Such a graph called a concurrency history graph can then be analyzed for properties such as presence of deadlock or potential access anomalies <ref> [91] </ref>. A deadlock state can be found, for example, by searching the graph for a node that represents an active task without a successor. Potential race conditions can be found by looking for a node with more than one outgoing edges representing accesses to the same shared variable. <p> Long and Clarke [57], and McDowell [60] have suggested ways to construct the graph from task interaction analysis rather than from control flow analysis to reduce the size of the graph. Under these techniques, the states between two synchronization operations are collapsed into one single state. Taylor <ref> [91] </ref> has also suggested a parceling technique that analyzes the graph in pieces. Reduction techniques have also been proposed in the domain of petri nets.
Reference: [92] <author> KSR Corporation Udb: </author> <title> User manual, </title> <publisher> KSR Corporation. </publisher> <year> 1993 </year>
Reference-contexts: Introduction The debugging of parallel programs is often difficult. State-based techniques <ref> [92, 73] </ref> allow the user to directly examine an execution to an arbitrary level of detail and to relate errors to source code constructs. <p> Finally, at the lowest level, when the error has been isolated to specific sections of sequential code, traditional state-based techniques <ref> [44, 92, 73] </ref> are used. This integrated strategy 2 effectively addresses the inadequacies of both approaches: it provides powerful abstraction mechanisms for understanding complex behaviors that purely state-based approaches lack, and it provides the ability to examine state information at an arbitrary level of detail that standard event-based debuggers lack. <p> The basic facilities of location, visualization and modification of states are augmented to handle the aspects of interprocess communication. Commercial multiprocessor debuggers like Pdbx by Sequent Corporation [73], or udb provided by KSR <ref> [92] </ref> stop the execution on per-process basis. Breakpoints can be set by specifying the statement number: all threads are suspended when the statement is executed by any thread. The user is allowed to choose any one of the suspended threads and run it in isolation.
Reference: [93] <author> Valmari, A. </author> <title> Eliminating redundant interleavings during concurrent program verification. </title> <editor> In E. Odjik, M. Rem and J. C. Syre, eds, </editor> <booktitle> Parallel Architecture and Language (PARLE), </booktitle> <publisher> LNCS 266, Springer-Verlag, </publisher> <address> New York, NY, </address> <pages> pages 89-103, </pages> <year> 1989. </year>
Reference-contexts: Under these techniques, the states between two synchronization operations are collapsed into one single state. Taylor [91] has also suggested a parceling technique that analyzes the graph in pieces. Reduction techniques have also been proposed in the domain of petri nets. Valmari <ref> [93] </ref> and Godefroid and Wolper [32] suggest techniques that observe the fact that when two mutually independent concurrent actions are possible from a state, the order in which the actions are executed does not affect the invariance of the safety properties. <p> The state space can thus be constructed by choosing one arbitrary ordering, and ignoring the rest, and the analysis techniques would still work. Valmari <ref> [93] </ref> proposes a way to choose the particular order by finding a special 20 set of transitions for every state represented in the petri net, called the stubborn set. Godefroid and Wolper [32] give a separate implementation.
Reference: [94] <author> Wittie, L. </author> <title> Debugging distributed C programs by real time replay. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 24, No. 1, </volume> <pages> pages 57-67, </pages> <year> 1989. </year>
Reference: [95] <author> Yeh, W. J., and Yopung, M. </author> <title> Compositional Reachability Analysis Using Process Algebra. </title> <booktitle> Proceedings of the ACM SIGSOFT Symposium on Testing, Analysis and Verification (TAV4), </booktitle> <pages> pages 49-59, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: ACP can model multicast as well as point-to-point communication where as CCS and CSP can only model point-to-point communication. All can be used to detect deadlocks. Several tools have been developed using these three frameworks: LOTOS [11], ECCS [14], PAL <ref> [95] </ref> and Concurrency Workbench [17]. None, however, can perform induction over a number of identical processes, and are thus not scalable. The final technique data flow analysis has been used for finding access anomalies in parallel programs.
Reference: [96] <author> Zave, P. </author> <title> A distributed alternative to finite state machine specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 7, No. 1, </volume> <pages> pages 10-36, </pages> <month> Jan </month> <year> 1985. </year>
Reference-contexts: EDL's second shortcoming is its use of pattern extraction as the semantics of matching. A model can be matched to a behavior in different ways. Baiardi et. al. [8] and Zave <ref> [96] </ref> require the model to match all input events: no skipping of events is allowed. This can be thought of as parsing approach. Another alternative [37, 9] is to use a pattern extraction approach where events are skipped as needed.
Reference: [97] <author> Zernik, D., Snir, M., and Malki, D. </author> <title> Using visualization tools to understand concurrency. </title> <journal> IEEE Software, </journal> <pages> pages 87-92, </pages> <month> May </month> <year> 1992. </year>
References-found: 97

