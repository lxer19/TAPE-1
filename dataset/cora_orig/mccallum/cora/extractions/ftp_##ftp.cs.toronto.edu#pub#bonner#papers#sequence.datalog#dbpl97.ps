URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/sequence.datalog/dbpl97.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@db.toronto.edu  mecca@dis.uniroma1.it  
Title: Querying Sequence Databases with Transducers  
Author: Anthony Bonner Giansalvatore Mecca 
Web: URL: http://www.cs.toronto.edu/~bonner/papers.html#sequence-datalog  
Note: Appears in Proceedings of the Sixth International Workshop on Database Program ming Languages (DBPL), August 18-20, 1997, Estes Park, Colorado. This and related papers are available at the following  
Address: Toronto Canada M5S 1A1  Via della Tecnica, 3 85100 Potenza, Italy  
Affiliation: Department of Computer Science University of  D.I.F.A. Universita della Basilicata  
Abstract: This paper develops a database query language called Transducer Datalog motivated by the needs of a new and emerging class of database applications. In these applications, such as text databases and genome databases, the storage and manipulation of long character sequences is a crucial feature. The issues involved in managing this kind of data are not addressed by traditional database systems, either in theory or in practice. To address these issues, in recent work, we introduced a new machine model called a generalized sequence transducer. These generalized transducers extend ordinary transducers by allowing them to invoke other transducers as "subroutines." This paper establishes the computational properties of Transducer Datalog, a query language based on this new machine model. In the process, we develop a hierarchy of time-complexity classes based on the Ackermann function. The lower levels of this hierarchy correspond to well-known complexity classes, such as polynomial time and hyper-exponential time. We establish a tight relationship between levels in this hierarchy and the depth of subroutine calls within Transducer Datalog programs. Finally, we show that Transducer Datalog programs of arbitrary depth express exactly the sequence functions computable in primitive-recursive time. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and P. Kanellakis. </author> <title> Object identity as a query language primitive. </title> <booktitle> In ACM SIGMOD International Conf. on Management of Data, </booktitle> <pages> pages 159-173, </pages> <year> 1989. </year>
Reference-contexts: Theorem 3 (Completeness) Stratified Transducer Datalog expresses all computable sequence queries. 5 Safe Transducer Datalog In [22, 6, 20], we introduced syntactic restrictions that define a sublanguage of Transducer Data-log called safe Transducer Datalog. The restrictions forbid recursion through transducer terms in a rather standard way <ref> [1] </ref>, in order to guarantee that the transducer network corresponding to a Transducer Datalog program is acyclic. From a database perspective, safe Transducer Datalog programs are interesting because they are finite, i:e:, their least fixpoint is finite for every database [22, 6, 20], and can thus be materialized.
Reference: [2] <author> W. </author> <title> Ackermann. </title> <journal> Zum Hilbertschen Aufbau der reellen Zahlen. Math. Annalen, </journal> <volume> 99 </volume> <pages> 118-133, </pages> <year> 1928. </year>
Reference-contexts: Section 3 first reviews the definition of generalized transducers. It then introduces a restriction called controlled feedback, and shows that this leads to an elegant characterization of the complexity and expressibility of generalized transducers in terms of the Ackermann function <ref> [2, 25] </ref>. Section 4 reviews the query language Transducer Datalog, which is obtained by enriching classical Datalog with interpreted function terms called transducer terms. <p> We show in particular that the complexity of a safe program depends on its order, i:e:, on the maximum depth to which transducers are invoked as subroutines. Formally, we first develop a hierarchy of time-complexity classes based on the Ackermann function <ref> [2, 25] </ref>. We then show that the lower levels of this hierarchy correspond to well-known complexity classes, such as ptime and the elementary functions [24], i.e. hyper-exponential time. This extends the complexity results of our previous work [22, 6]. <p> After reviewing the definition, this section introduces a restriction called controlled feedback, and shows that it leads to a characterization of the complexity of generalized transducers in terms of the Ackermann function <ref> [2, 25] </ref>. Ordinary transducers - i.e., finite state machines with n input lines and one output line have very low complexity|essentially linear time. There are therefore many sequence restructurings that they cannot perform. <p> We shall see that the deterministic time complexity of a transducer is closely related to the Ackermann function <ref> [2, 25] </ref>, also called the generalized exponential function. This is a ternary function ack (k; x; y) such that: ack (1; x; y) = y + x; ack (3; x; y) = y x ; We call the first argument, k, the level of the function. <p> We say that a transducer computes an integer function v = f (w) if on input # w , of length w, it produces the output # f (w) , of length f (w). 1 This definition is a minor variant of the definition given in <ref> [2] </ref>. In particular, ack (k; x; y) in our definition coincides with ack (k 1; x; y) in the definition of [2]. 8 Theorem 2 (Computing Ackermann's Function) For every integer k 1, there is a gen-eralized sequence transducer of order k with 2 inputs that computes ack (k; x; y). <p> w , of length w, it produces the output # f (w) , of length f (w). 1 This definition is a minor variant of the definition given in <ref> [2] </ref>. In particular, ack (k; x; y) in our definition coincides with ack (k 1; x; y) in the definition of [2]. 8 Theorem 2 (Computing Ackermann's Function) For every integer k 1, there is a gen-eralized sequence transducer of order k with 2 inputs that computes ack (k; x; y).
Reference: [3] <author> K. Apt, H. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kauffman, </publisher> <address> Los Altos, </address> <year> 1988. </year>
Reference-contexts: To achieve query completeness, we must add some form of non-monotonicity to the language. We do this by allowing negated atoms in rule bodies, and interpreting negation as failure. To avoid the plethora of problems associated with recursion through negation, we restrict our attention to stratified negation <ref> [3, 8] </ref>, which can be extended from classical Datalog to Transducer Datalog in a natural way. The following theorem is the main result about this language, which we call stratified Transducer Datalog.
Reference: [4] <author> F. Bancilhon, S. Cluet, and C. Delobel. </author> <title> A query language for the O 2 object-oriented database system. </title> <booktitle> In Second Intern. Workshop on Database Programming Languages (DBPL'89), </booktitle> <pages> pages 122-138, </pages> <year> 1989. </year>
Reference-contexts: Thus, they cannot interrogate or manipulate the sequential structure of items such as documents, DNA sequences and protein sequences. To address this limitation, sequence operations have been introduced into recent data models and query languages (e.g. <ref> [4, 7] </ref>). In many cases, however, the sequence operations are ad hoc and are not investigated in a theoretical framework. In other cases, (e.g. [17, 26]) the operations are designed for pattern extraction but not for sequence restructuring.
Reference: [5] <author> A. J. Bonner and G. Mecca. </author> <title> Querying sequence databases with Transducers. </title> <address> http://- poincare.inf.uniroma3.it:8080, </address> <year> 1997. </year>
Reference-contexts: The query completeness result and the characterization in terms of the Ackermann complexity hierarchy represent the main contributions of the paper. For space reasons, proofs are omitted and can be found in the full paper <ref> [5] </ref>. Note that the Ackermann hierarchy is somewhat similar to the Grzegorczyk hierarchy [16] of primitive recursive functions. However, the latter is based on a different set of initial functions and each level is obtained by closure with respect to substitution and bounded primitive recursion, instead of function composition.
Reference: [6] <author> A. J. Bonner and G. Mecca. </author> <title> Sequences, Datalog and Transducers. </title> <journal> Journal of Computing and System Sciences, </journal> <note> Special Issue on PODS'95, 1997. To Appear. http://poincare.inf.- uniroma3.it:8080. </note>
Reference-contexts: Unfortunately, the resulting languages are unsafe, and to achieve safety, syntactic restrictions have been imposed, restrictions that severely limit expressiveness (e:g:, [11, 14]). To resolve these problems, we recently developed a query language for sequence data called Transducer Datalog <ref> [22, 6, 20] </ref>, which extends classical Datalog [8] so that it can handle sequence data. A key element in Transducer Datalog is a new machine model called a generalized sequence transducer. <p> The expressive power of classical Datalog grows dramatically when transducers are added to it. We show, for instance, that Transducer Datalog with stratified negation is computationally complete for sequence databases. This completeness result extends our previous results on function expressibility <ref> [22, 6] </ref> to query expressibility. Like classical Datalog, queries in Transducer Datalog can be recursive. However, in Transducer Datalog, the combination of recursion and transducers allows queries to be infinite and non-terminating. <p> Like classical Datalog, queries in Transducer Datalog can be recursive. However, in Transducer Datalog, the combination of recursion and transducers allows queries to be infinite and non-terminating. To guarantee finiteness and termination, we previously introduced a syntactic restriction called safety, in which recursion through transducer terms is not allowed <ref> [22, 6, 20] </ref>. Section 5 reviews the definition of safety, and then establishes several new expressibility results for safe programs. We show in particular that the complexity of a safe program depends on its order, i:e:, on the maximum depth to which transducers are invoked as subroutines. <p> We then show that the lower levels of this hierarchy correspond to well-known complexity classes, such as ptime and the elementary functions [24], i.e. hyper-exponential time. This extends the complexity results of our previous work <ref> [22, 6] </ref>. Finally, we show that safe programs of order k express exactly the sequence functions in the k th level of this hierarchy. As a corollary, we show that safe Transducer Datalog expresses exactly the sequence functions computable in primitive-recursive time. <p> that a language L expresses a class qc of queries if (i) each sequence query expressible in L has complexity in c, and conversely, (ii) each sequence query with complexity in c can be expressed in L. 3 Generalized Sequence Transducers The notion of generalized sequence transducer was introduced in <ref> [22, 6, 20] </ref>. After reviewing the definition, this section introduces a restriction called controlled feedback, and shows that it leads to a characterization of the complexity of generalized transducers in terms of the Ackermann function [2, 25]. <p> Thus, when T append finishes this computation, its output is i copies of in concatenated together. This behaviour is illustrated in Figure 1, in which the transducer input is abc, and the output is abcabcabc. 2 3.1 Controlled Feedback In <ref> [22, 6] </ref>, we established the complexity of generalized transducers of order 2 and 3. This paper extends those results to transducers of arbitrary order. <p> That is, for all inputs x; y with x &gt; 0, the output of the transducer is ack (k; x; y). Theorem 2 shows that the upper bound in Theorem 1 is tight. These results will prove useful in the following sections. 4 Transducer Datalog In <ref> [22, 6, 20] </ref>, we developed a query language for sequence databases by incorporating generalized transducers into classical Datalog [8]. <p> Due to space limitations, we cannot present the formal semantics of Transducer Datalog here. Instead, we illustrate the semantics informally through examples. The interested reader is referred to <ref> [22, 6, 20] </ref> for details. 4.1 Syntax and Semantics To invoke transducer computations from within a logical rule, we augment the syntax of classical Datalog (function-free Horn logic) with special interpreted function symbols, one symbol for each generalized sequence transducer. <p> Each application of T P;db may create new atoms, which may contain new sequences. We have shown that T P;db is monotonic and continuous, and thus has a least fixpoint that can be computed in a bottom-up, iterative fashion <ref> [22, 6, 20] </ref>. If a Transducer Datalog program has recursion through transducer terms, then the least fixpoint of the program can be infinite. That is, as a result of evaluating transducer terms, new sequences can be computed; and because of recursion, the length of these sequences can be unbounded. <p> The following theorem is the main result about this language, which we call stratified Transducer Datalog. Theorem 3 (Completeness) Stratified Transducer Datalog expresses all computable sequence queries. 5 Safe Transducer Datalog In <ref> [22, 6, 20] </ref>, we introduced syntactic restrictions that define a sublanguage of Transducer Data-log called safe Transducer Datalog. The restrictions forbid recursion through transducer terms in a rather standard way [1], in order to guarantee that the transducer network corresponding to a Transducer Datalog program is acyclic. <p> From a database perspective, safe Transducer Datalog programs are interesting because they are finite, i:e:, their least fixpoint is finite for every database <ref> [22, 6, 20] </ref>, and can thus be materialized. This section reviews the definition of safe Transducer Datalog, and establishes results on its expressibility. <p> Theorem 4 (Safe Programs of Order-k) Safe Transducer Datalog programs of order k express exactly k-acktime, for k 2. Note that since 2-acktime is ptime, and 3-acktime is the class of elementary sequence functions, Theorem 4 leads immediately to Corollaries 1 and 2, below. In <ref> [6] </ref>, we show that Corollary 2 also holds for the unrestricted transducer model developed in Section 3, i:e:, the model without controlled feedback. The two transducer models are therefore equivalent for order 3.
Reference: [7] <author> R. G. G. Cattel. </author> <title> The Object Database Standard ODMG-93. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Francisco, CA, </address> <year> 1994. </year>
Reference-contexts: Thus, they cannot interrogate or manipulate the sequential structure of items such as documents, DNA sequences and protein sequences. To address this limitation, sequence operations have been introduced into recent data models and query languages (e.g. <ref> [4, 7] </ref>). In many cases, however, the sequence operations are ad hoc and are not investigated in a theoretical framework. In other cases, (e.g. [17, 26]) the operations are designed for pattern extraction but not for sequence restructuring.
Reference: [8] <author> S. Ceri, G. Gottlob, and L. Tanca. </author> <title> Logic Programming and Data Bases. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Unfortunately, the resulting languages are unsafe, and to achieve safety, syntactic restrictions have been imposed, restrictions that severely limit expressiveness (e:g:, [11, 14]). To resolve these problems, we recently developed a query language for sequence data called Transducer Datalog [22, 6, 20], which extends classical Datalog <ref> [8] </ref> so that it can handle sequence data. A key element in Transducer Datalog is a new machine model called a generalized sequence transducer. Intuitively, a generalized transducer is a transducer that can invoke other transducers as "subroutines." These subtransducers can likewise invoke other transducers as sub-subroutines. Etc. <p> Theorem 2 shows that the upper bound in Theorem 1 is tight. These results will prove useful in the following sections. 4 Transducer Datalog In [22, 6, 20], we developed a query language for sequence databases by incorporating generalized transducers into classical Datalog <ref> [8] </ref>. This language allows an application programmer to use the framework of classical Datalog to combine generalized transducers into networks, in which the output of one transducer can be fed to the inputs of other transducers. <p> The semantics of clauses is defined in terms of a least fixpoint theory. As in classical logic programming <ref> [19, 8] </ref>, each Transducer Datalog program, P , and database, db, has an associated operator, T P;db , that maps relational databases to relational databases. Each application of T P;db may create new atoms, which may contain new sequences. <p> To achieve query completeness, we must add some form of non-monotonicity to the language. We do this by allowing negated atoms in rule bodies, and interpreting negation as failure. To avoid the plethora of problems associated with recursion through negation, we restrict our attention to stratified negation <ref> [3, 8] </ref>, which can be extended from classical Datalog to Transducer Datalog in a natural way. The following theorem is the main result about this language, which we call stratified Transducer Datalog.
Reference: [9] <author> A. K. Chandra and D. Harel. </author> <title> Computable queries for relational databases. </title> <journal> Journal of Computing and System Sciences, </journal> <volume> 21 </volume> <pages> 333-347, </pages> <year> 1980. </year>
Reference-contexts: A sequence query is a partial mapping from the databases over to the relations over . Given a sequence query, Q, and a database, db, Q (db) is the result of evaluating Q over db. Usually, a notion of genericity <ref> [9] </ref> is introduced for queries. The notion can be extended to sequence queries in a natural way. <p> We say that a sequence query Q is computable <ref> [9] </ref> if it is generic and partial recursive. A sequence function is a partial mapping from fl to itself.
Reference: [10] <institution> Communications of the ACM. </institution> <note> Special issue on the Human Genome project. vol. 34(11), </note> <month> November </month> <year> 1991. </year>
Reference-contexts: 1 Introduction This paper develops a database query language, called Transducer Datalog, motivated by the needs of a new and emerging class of database applications. In these applications, such as text databases and genome databases, the storage and manipulation of long sequences is a crucial feature <ref> [12, 10] </ref>. The issues involved in managing this kind of data are not addressed by traditional database systems, either in theory or in practice. In particular, traditional database query languages are poor at manipulating sequence data. This is because they treat data items as atomic entities without any internal structure.
Reference: [11] <author> S. Ginsburg and X. Wang. </author> <title> Pattern matching by RS-operations: towards a unified approach to querying sequence data. </title> <booktitle> In Eleventh ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS'92), </booktitle> <pages> pages 293-300, </pages> <year> 1992. </year>
Reference-contexts: To achieve expressiveness, database researchers have developed sequence query languages based on abstract machines, such as automata or transducers. Unfortunately, the resulting languages are unsafe, and to achieve safety, syntactic restrictions have been imposed, restrictions that severely limit expressiveness (e:g:, <ref> [11, 14] </ref>). To resolve these problems, we recently developed a query language for sequence data called Transducer Datalog [22, 6, 20], which extends classical Datalog [8] so that it can handle sequence data. A key element in Transducer Datalog is a new machine model called a generalized sequence transducer. <p> Let be a countable set of symbols, called the alphabet. fl denotes the set of all possible sequences over , including the empty sequence, *. We now describe an extension of the relational model, in the spirit of <ref> [11, 14] </ref>. The model allows for tuples containing sequences of elements, instead of just constant symbols. A relation of arity k over is a finite subset of the k-fold Cartesian product of fl with itself. A database over is a finite set of relations over . <p> Although the following definition is for deterministic transducers, it can easily be generalized to allow nondeterministic computations. As such, it generalizes other transducer models proposed in the literature (for example, see <ref> [11, 27] </ref>).
Reference: [12] <author> G. H. Gonnet. </author> <title> Text dominated databases: Theory, practice and experience. </title> <booktitle> Tutorial presented at PODS, </booktitle> <year> 1994. </year>
Reference-contexts: 1 Introduction This paper develops a database query language, called Transducer Datalog, motivated by the needs of a new and emerging class of database applications. In these applications, such as text databases and genome databases, the storage and manipulation of long sequences is a crucial feature <ref> [12, 10] </ref>. The issues involved in managing this kind of data are not addressed by traditional database systems, either in theory or in practice. In particular, traditional database query languages are poor at manipulating sequence data. This is because they treat data items as atomic entities without any internal structure.
Reference: [13] <author> N. Goodman. </author> <title> Research issues in Genome databases. </title> <booktitle> Tutorial presented at PODS, </booktitle> <year> 1995. </year>
Reference-contexts: For example, in genome databases, because genome-technology is rapidly evolving, new sequence operations are constantly needed, operations that cannot be anticipated in advance. Genome databases thus need to combine a query language with arbitrary procedures for executing sequence operations <ref> [13] </ref>. Clearly, different models of computation could be embedded in the query language to 2 achieve the same goal. However, unlike other models, generalized transducers are highly modular, and although very powerful, they preserve finiteness and allow one to tune the complexity of the language.
Reference: [14] <author> G. Grahne, M. Nykanen, and E. Ukkonen. </author> <title> Reasoning about strings in databases. </title> <booktitle> In Thirteenth ACM SIGMOD Intern. Symposium on Principles of Database Systems (PODS'94), </booktitle> <pages> pages 303-312, </pages> <year> 1994. </year>
Reference-contexts: To achieve expressiveness, database researchers have developed sequence query languages based on abstract machines, such as automata or transducers. Unfortunately, the resulting languages are unsafe, and to achieve safety, syntactic restrictions have been imposed, restrictions that severely limit expressiveness (e:g:, <ref> [11, 14] </ref>). To resolve these problems, we recently developed a query language for sequence data called Transducer Datalog [22, 6, 20], which extends classical Datalog [8] so that it can handle sequence data. A key element in Transducer Datalog is a new machine model called a generalized sequence transducer. <p> Let be a countable set of symbols, called the alphabet. fl denotes the set of all possible sequences over , including the empty sequence, *. We now describe an extension of the relational model, in the spirit of <ref> [11, 14] </ref>. The model allows for tuples containing sequences of elements, instead of just constant symbols. A relation of arity k over is a finite subset of the k-fold Cartesian product of fl with itself. A database over is a finite set of relations over .
Reference: [15] <author> S. Grumbach and T. Milo. </author> <title> An algebra for POMSETS. </title> <booktitle> In Fifth International Conference on Data Base Theory, (ICDT'95), Prague, Lecture Notes in Computer Science, </booktitle> <pages> pages 191-207, </pages> <year> 1995. </year>
Reference: [16] <author> A. Grzegorczyk. </author> <title> Some classes of recursive functions. </title> <journal> Rozprawy Matematyczne, </journal> <volume> 4, </volume> <year> 1953. </year> <institution> Instytut Matematyczne Polskiej Akademie Nauk, Warsaw. </institution>
Reference-contexts: The query completeness result and the characterization in terms of the Ackermann complexity hierarchy represent the main contributions of the paper. For space reasons, proofs are omitted and can be found in the full paper [5]. Note that the Ackermann hierarchy is somewhat similar to the Grzegorczyk hierarchy <ref> [16] </ref> of primitive recursive functions. However, the latter is based on a different set of initial functions and each level is obtained by closure with respect to substitution and bounded primitive recursion, instead of function composition. <p> The Ackermann time hierarchy coincides with this time class; that is ack-hier = pr-time. These relationships are summarized in Figure 3. Note that the Ackermann hierarchy is somewhat similar to the Grzegorczyk hierarchy <ref> [16] </ref> of primitive recursive functions.
Reference: [17] <author> C. Hegelsen and P. R. Sibbald. </author> <title> PALM a pattern language for molecular biology. </title> <booktitle> In First Intern. Conference on Intelligent Systems for Molecular Biology, </booktitle> <pages> pages 172-180, </pages> <year> 1993. </year>
Reference-contexts: To address this limitation, sequence operations have been introduced into recent data models and query languages (e.g. [4, 7]). In many cases, however, the sequence operations are ad hoc and are not investigated in a theoretical framework. In other cases, (e.g. <ref> [17, 26] </ref>) the operations are designed for pattern extraction but not for sequence restructuring. Although pattern recognition is a fundamental feature of any language for querying sequences, sequence restructurings are equally important.
Reference: [18] <author> V. A. Kozmidiadi. </author> <title> On a generalization of finite automata generating a hierarchy analogous to the A. Grzegorczyk's classification of the primitive recursive functions. </title> <journal> Problemi Kibernetiki, </journal> <volume> 23 </volume> <pages> 127-170, </pages> <year> 1970. </year>
Reference-contexts: Note that the Ackermann hierarchy is somewhat similar to the Grzegorczyk hierarchy [16] of primitive recursive functions. However, the latter is based on a different set of initial functions and each level is obtained by closure with respect to substitution and bounded primitive recursion, instead of function composition. In <ref> [18] </ref> a hierarchy of primitive recursive functions based on the Grzegorczyk hierarchy is presented to characterize the behavior of a family of finite automata. However, unlike the generalized transducers used here, the machines used in [18] are not finite state devices in the usual sense, since a "state" is essentially a <p> In <ref> [18] </ref> a hierarchy of primitive recursive functions based on the Grzegorczyk hierarchy is presented to characterize the behavior of a family of finite automata. However, unlike the generalized transducers used here, the machines used in [18] are not finite state devices in the usual sense, since a "state" is essentially a counter, so a machine of this kind can have infinitely many states. In contrast, generalized transducers have a finite number of states.
Reference: [19] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: Moreover, if s 1 and s 2 are sequence terms, then s 1 = s 2 and s 1 6= s 2 are also atoms. From atoms, we build facts and clauses in the usual way <ref> [19] </ref>. A clause that contains a transducer term in its head is called a constructive clause. A Transducer Datalog program is a set of Transducer Datalog clauses. As usual, we require that each variable occurring in the head of a rule also occur in the body of the rule. <p> The semantics of clauses is defined in terms of a least fixpoint theory. As in classical logic programming <ref> [19, 8] </ref>, each Transducer Datalog program, P , and database, db, has an associated operator, T P;db , that maps relational databases to relational databases. Each application of T P;db may create new atoms, which may contain new sequences.
Reference: [20] <author> G. Mecca. </author> <title> From Datalog to Sequence Datalog: Languages and Techniques for Querying Sequence Databases. </title> <type> PhD thesis, </type> <institution> Universita di Roma "La Sapienza", Dipartimento di Informatica e Sistemistica, </institution> <year> 1996. </year> <note> http://poincare.inf.uniroma3.it:8080. </note>
Reference-contexts: Unfortunately, the resulting languages are unsafe, and to achieve safety, syntactic restrictions have been imposed, restrictions that severely limit expressiveness (e:g:, [11, 14]). To resolve these problems, we recently developed a query language for sequence data called Transducer Datalog <ref> [22, 6, 20] </ref>, which extends classical Datalog [8] so that it can handle sequence data. A key element in Transducer Datalog is a new machine model called a generalized sequence transducer. <p> Like classical Datalog, queries in Transducer Datalog can be recursive. However, in Transducer Datalog, the combination of recursion and transducers allows queries to be infinite and non-terminating. To guarantee finiteness and termination, we previously introduced a syntactic restriction called safety, in which recursion through transducer terms is not allowed <ref> [22, 6, 20] </ref>. Section 5 reviews the definition of safety, and then establishes several new expressibility results for safe programs. We show in particular that the complexity of a safe program depends on its order, i:e:, on the maximum depth to which transducers are invoked as subroutines. <p> that a language L expresses a class qc of queries if (i) each sequence query expressible in L has complexity in c, and conversely, (ii) each sequence query with complexity in c can be expressed in L. 3 Generalized Sequence Transducers The notion of generalized sequence transducer was introduced in <ref> [22, 6, 20] </ref>. After reviewing the definition, this section introduces a restriction called controlled feedback, and shows that it leads to a characterization of the complexity of generalized transducers in terms of the Ackermann function [2, 25]. <p> That is, for all inputs x; y with x &gt; 0, the output of the transducer is ack (k; x; y). Theorem 2 shows that the upper bound in Theorem 1 is tight. These results will prove useful in the following sections. 4 Transducer Datalog In <ref> [22, 6, 20] </ref>, we developed a query language for sequence databases by incorporating generalized transducers into classical Datalog [8]. <p> Due to space limitations, we cannot present the formal semantics of Transducer Datalog here. Instead, we illustrate the semantics informally through examples. The interested reader is referred to <ref> [22, 6, 20] </ref> for details. 4.1 Syntax and Semantics To invoke transducer computations from within a logical rule, we augment the syntax of classical Datalog (function-free Horn logic) with special interpreted function symbols, one symbol for each generalized sequence transducer. <p> Each application of T P;db may create new atoms, which may contain new sequences. We have shown that T P;db is monotonic and continuous, and thus has a least fixpoint that can be computed in a bottom-up, iterative fashion <ref> [22, 6, 20] </ref>. If a Transducer Datalog program has recursion through transducer terms, then the least fixpoint of the program can be infinite. That is, as a result of evaluating transducer terms, new sequences can be computed; and because of recursion, the length of these sequences can be unbounded. <p> The following theorem is the main result about this language, which we call stratified Transducer Datalog. Theorem 3 (Completeness) Stratified Transducer Datalog expresses all computable sequence queries. 5 Safe Transducer Datalog In <ref> [22, 6, 20] </ref>, we introduced syntactic restrictions that define a sublanguage of Transducer Data-log called safe Transducer Datalog. The restrictions forbid recursion through transducer terms in a rather standard way [1], in order to guarantee that the transducer network corresponding to a Transducer Datalog program is acyclic. <p> From a database perspective, safe Transducer Datalog programs are interesting because they are finite, i:e:, their least fixpoint is finite for every database <ref> [22, 6, 20] </ref>, and can thus be materialized. This section reviews the definition of safe Transducer Datalog, and establishes results on its expressibility.
Reference: [21] <author> G. Mecca and A. J. Bonner. </author> <title> Finite query languages for sequence databases. </title> <booktitle> In Fifth Intern. Workshop on Database Programming Languages (DBPL'95), </booktitle> <address> Gubbio, Italy. </address> <publisher> electronic Workshops in Computing - Springer-Verlag, </publisher> <year> 1995. </year> <note> http://www.springer.co.uk/eWiC/Workshops/- DBPL5.html. </note>
Reference: [22] <author> G. Mecca and A. J. Bonner. </author> <title> Sequences, Datalog and Transducers. </title> <booktitle> In Fourteenth ACM SIG-MOD Intern. Symposium on Principles of Database Systems (PODS'95), </booktitle> <address> San Jose, California, </address> <pages> pages 23-35, </pages> <year> 1995. </year> <note> http://poincare.inf.uniroma3.it:8080. </note>
Reference-contexts: Unfortunately, the resulting languages are unsafe, and to achieve safety, syntactic restrictions have been imposed, restrictions that severely limit expressiveness (e:g:, [11, 14]). To resolve these problems, we recently developed a query language for sequence data called Transducer Datalog <ref> [22, 6, 20] </ref>, which extends classical Datalog [8] so that it can handle sequence data. A key element in Transducer Datalog is a new machine model called a generalized sequence transducer. <p> The expressive power of classical Datalog grows dramatically when transducers are added to it. We show, for instance, that Transducer Datalog with stratified negation is computationally complete for sequence databases. This completeness result extends our previous results on function expressibility <ref> [22, 6] </ref> to query expressibility. Like classical Datalog, queries in Transducer Datalog can be recursive. However, in Transducer Datalog, the combination of recursion and transducers allows queries to be infinite and non-terminating. <p> Like classical Datalog, queries in Transducer Datalog can be recursive. However, in Transducer Datalog, the combination of recursion and transducers allows queries to be infinite and non-terminating. To guarantee finiteness and termination, we previously introduced a syntactic restriction called safety, in which recursion through transducer terms is not allowed <ref> [22, 6, 20] </ref>. Section 5 reviews the definition of safety, and then establishes several new expressibility results for safe programs. We show in particular that the complexity of a safe program depends on its order, i:e:, on the maximum depth to which transducers are invoked as subroutines. <p> We then show that the lower levels of this hierarchy correspond to well-known complexity classes, such as ptime and the elementary functions [24], i.e. hyper-exponential time. This extends the complexity results of our previous work <ref> [22, 6] </ref>. Finally, we show that safe programs of order k express exactly the sequence functions in the k th level of this hierarchy. As a corollary, we show that safe Transducer Datalog expresses exactly the sequence functions computable in primitive-recursive time. <p> that a language L expresses a class qc of queries if (i) each sequence query expressible in L has complexity in c, and conversely, (ii) each sequence query with complexity in c can be expressed in L. 3 Generalized Sequence Transducers The notion of generalized sequence transducer was introduced in <ref> [22, 6, 20] </ref>. After reviewing the definition, this section introduces a restriction called controlled feedback, and shows that it leads to a characterization of the complexity of generalized transducers in terms of the Ackermann function [2, 25]. <p> Thus, when T append finishes this computation, its output is i copies of in concatenated together. This behaviour is illustrated in Figure 1, in which the transducer input is abc, and the output is abcabcabc. 2 3.1 Controlled Feedback In <ref> [22, 6] </ref>, we established the complexity of generalized transducers of order 2 and 3. This paper extends those results to transducers of arbitrary order. <p> That is, for all inputs x; y with x &gt; 0, the output of the transducer is ack (k; x; y). Theorem 2 shows that the upper bound in Theorem 1 is tight. These results will prove useful in the following sections. 4 Transducer Datalog In <ref> [22, 6, 20] </ref>, we developed a query language for sequence databases by incorporating generalized transducers into classical Datalog [8]. <p> Due to space limitations, we cannot present the formal semantics of Transducer Datalog here. Instead, we illustrate the semantics informally through examples. The interested reader is referred to <ref> [22, 6, 20] </ref> for details. 4.1 Syntax and Semantics To invoke transducer computations from within a logical rule, we augment the syntax of classical Datalog (function-free Horn logic) with special interpreted function symbols, one symbol for each generalized sequence transducer. <p> Each application of T P;db may create new atoms, which may contain new sequences. We have shown that T P;db is monotonic and continuous, and thus has a least fixpoint that can be computed in a bottom-up, iterative fashion <ref> [22, 6, 20] </ref>. If a Transducer Datalog program has recursion through transducer terms, then the least fixpoint of the program can be infinite. That is, as a result of evaluating transducer terms, new sequences can be computed; and because of recursion, the length of these sequences can be unbounded. <p> (i) all sequence restructurings performed by the program take place "inside" the transducers; and (ii) the program terminates for every database, since there is no recursion through construction of new sequences. 2 4.2 Expressive Power Transducer Datalog has considerable power for manipulating sequences, and can express any computable sequence function <ref> [22] </ref>. However, although Transducer Datalog is function complete, it is not query complete, since it expresses only monotonic queries. Thus, like classical Datalog, it cannot express non-monotonic queries, even very simple ones, such as the difference of two database relations. <p> The following theorem is the main result about this language, which we call stratified Transducer Datalog. Theorem 3 (Completeness) Stratified Transducer Datalog expresses all computable sequence queries. 5 Safe Transducer Datalog In <ref> [22, 6, 20] </ref>, we introduced syntactic restrictions that define a sublanguage of Transducer Data-log called safe Transducer Datalog. The restrictions forbid recursion through transducer terms in a rather standard way [1], in order to guarantee that the transducer network corresponding to a Transducer Datalog program is acyclic. <p> From a database perspective, safe Transducer Datalog programs are interesting because they are finite, i:e:, their least fixpoint is finite for every database <ref> [22, 6, 20] </ref>, and can thus be materialized. This section reviews the definition of safe Transducer Datalog, and establishes results on its expressibility. <p> Finally, Theorem 4 also leads to Corollary 3, which gives a simple characterization of the expressive power of safe Transducer Datalog programs. Corollary 1 (Safe Programs of Order-2) Safe Transducer Datalog programs of order 2 express exactly ptime <ref> [22] </ref>. Corollary 2 (Safe Programs of Order-3) Safe Transducer Datalog programs of order 3 express exactly the elementary sequence functions. Corollary 3 (Safe Programs of Arbitrary Order) Safe Transducer Datalog programs express exactly pr-time, the class of sequence functions computable in primitive-recursive time.
Reference: [23] <author> A. R. Meyer and D. M. Ritchie. </author> <title> Computational complexity and program structure. I.B.M. </title> <journal> Res. Rep., </journal> <volume> 1817, </volume> <year> 1967. </year>
Reference-contexts: In contrast, generalized transducers have a finite number of states. Other characterizations of the primitive recursive functions have been presented in the literature. For instance, a characterization in terms of loop programs is developed in <ref> [23] </ref>.
Reference: [24] <author> C. H. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Formally, we first develop a hierarchy of time-complexity classes based on the Ackermann function [2, 25]. We then show that the lower levels of this hierarchy correspond to well-known complexity classes, such as ptime and the elementary functions <ref> [24] </ref>, i.e. hyper-exponential time. This extends the complexity results of our previous work [22, 6]. Finally, we show that safe programs of order k express exactly the sequence functions in the k th level of this hierarchy. <p> For instance, it is not hard to see that (i) 2-acktime is ptime, and (ii) 3-acktime is the class of elementary sequence functions <ref> [24] </ref>, that is, the class of sequence functions computable in hyper-exponential time. In addition, the hierarchy is related to the classical notion of primitive recursive function [25]. Formally, let pr-time denote the class of sequence functions computable in primitive-recursive time.
Reference: [25] <author> H. Rogers, Jr. </author> <title> Theory of recursive functions and effective computability. </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, Mass., </address> <year> 1987. </year>
Reference-contexts: Section 3 first reviews the definition of generalized transducers. It then introduces a restriction called controlled feedback, and shows that this leads to an elegant characterization of the complexity and expressibility of generalized transducers in terms of the Ackermann function <ref> [2, 25] </ref>. Section 4 reviews the query language Transducer Datalog, which is obtained by enriching classical Datalog with interpreted function terms called transducer terms. <p> We show in particular that the complexity of a safe program depends on its order, i:e:, on the maximum depth to which transducers are invoked as subroutines. Formally, we first develop a hierarchy of time-complexity classes based on the Ackermann function <ref> [2, 25] </ref>. We then show that the lower levels of this hierarchy correspond to well-known complexity classes, such as ptime and the elementary functions [24], i.e. hyper-exponential time. This extends the complexity results of our previous work [22, 6]. <p> After reviewing the definition, this section introduces a restriction called controlled feedback, and shows that it leads to a characterization of the complexity of generalized transducers in terms of the Ackermann function <ref> [2, 25] </ref>. Ordinary transducers - i.e., finite state machines with n input lines and one output line have very low complexity|essentially linear time. There are therefore many sequence restructurings that they cannot perform. <p> We shall see that the deterministic time complexity of a transducer is closely related to the Ackermann function <ref> [2, 25] </ref>, also called the generalized exponential function. This is a ternary function ack (k; x; y) such that: ack (1; x; y) = y + x; ack (3; x; y) = y x ; We call the first argument, k, the level of the function. <p> For instance, it is not hard to see that (i) 2-acktime is ptime, and (ii) 3-acktime is the class of elementary sequence functions [24], that is, the class of sequence functions computable in hyper-exponential time. In addition, the hierarchy is related to the classical notion of primitive recursive function <ref> [25] </ref>. Formally, let pr-time denote the class of sequence functions computable in primitive-recursive time. That is, pr-time = S f2PR dtime [f (O (n))], where PR 12 ' $ 1-acktime 2-acktime = ptime 3-acktime = elementary functions ack-hier = prtime .... is the set of primitive recursive functions.
Reference: [26] <author> D. B. </author> <title> Searls. String Variable Grammars: a logic grammar formalism for dna sequences. </title> <type> Technical report, </type> <institution> University of Pennsylvania, School of Medicine, </institution> <year> 1993. </year>
Reference-contexts: To address this limitation, sequence operations have been introduced into recent data models and query languages (e.g. [4, 7]). In many cases, however, the sequence operations are ad hoc and are not investigated in a theoretical framework. In other cases, (e.g. <ref> [17, 26] </ref>) the operations are designed for pattern extraction but not for sequence restructuring. Although pattern recognition is a fundamental feature of any language for querying sequences, sequence restructurings are equally important.
Reference: [27] <author> D. Stott Parker, E. Simon, and P. Valduriez. </author> <title> SVP a model capturing sets, streams and parallelism. </title> <booktitle> In Eighteenth International Conference on Very Large Data Bases (VLDB'92), </booktitle> <address> Vancouver, Canada, </address> <pages> pages 115-126, </pages> <year> 1992. </year>
Reference-contexts: Although the following definition is for deterministic transducers, it can easily be generalized to allow nondeterministic computations. As such, it generalizes other transducer models proposed in the literature (for example, see <ref> [11, 27] </ref>).
Reference: [28] <author> M. Vardi. </author> <title> The complexity of relational query languages. </title> <booktitle> In Fourteenth ACM SIGACT Symp. on Theory of Computing, </booktitle> <pages> pages 137-146, </pages> <year> 1988. </year>
Reference-contexts: This paper focuses on sequence functions for which the alphabet, , is finite. Of course, the domain of such functions may still be infinite; e:g:, it may be all of fl . In this paper, we address the complexity of sequence functions, and the data complexity <ref> [28] </ref> of sequence queries. Given a sequence function, f , the complexity of f is defined in the usual way, as the complexity of computing f ( in ), measured with respect to the length of the input sequence, in .
Reference: [29] <author> J. D. Watson et al. </author> <title> Molecular biology of the gene. </title> <publisher> Benjamin and Cummings Publ. Co., </publisher> <address> Menlo Park, California, </address> <note> fourth edition, 1987. 15 </note>
Reference-contexts: To translate RNA into protein, ribonucleotides are grouped into triplets, called codons, such as aug, acg, ggu, : : : 3 Each codon is then translated into a single amino-acid. Different codons may 2 For simplicity, this example ignores biological complications such as intron splicing <ref> [29] </ref>, even though it can be encoded in Transducer Datalog without difficulty. 3 This grouping is analogous to the grouping of bits into bytes in computers. 10 have the same translation. For example, the codons gau and gac both translate to aspartic acid, denoted D in the twenty-letter alphabet. <p> This section reviews the definition of safe Transducer Datalog, and establishes results on its expressibility. Formally, we introduce a hierarchy of complexity classes 4 For simplicity, this example ignores biological complications such as reading frames, ribosomal binding sites, and stop codons <ref> [29] </ref>. 11 based on the Ackermann function, and then we characterize the expressibility of natural fragments of safe Transducer Datalog in terms of this hierarchy.
References-found: 29

