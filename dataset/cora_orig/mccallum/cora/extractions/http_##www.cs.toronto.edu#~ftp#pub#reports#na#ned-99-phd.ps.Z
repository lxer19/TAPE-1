URL: http://www.cs.toronto.edu/~ftp/pub/reports/na/ned-99-phd.ps.Z
Refering-URL: http://www.cs.toronto.edu/NA/reports.html
Root-URL: http://www.cs.toronto.edu
Title: Computing Rigorous Bounds on the Solution of an Initial Value Problem for an Ordinary Differential Equation  
Author: by Nedialko Stoyanov Nedialkov 
Degree: A thesis submitted in conformity with the requirements for the degree of Doctor of Philosophy  
Note: Copyright c 1999 by Nedialko Stoyanov Nedialkov  
Address: Toronto  
Affiliation: Graduate Department of Computer Science University of  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> E. Adams, D. Cordes, and R. Lohner. </author> <title> Enclosure of solutions of ordinary initial value problems and applications. </title> <editor> In E. Adams, R. Ansorge, Chr. Gromann, and H. G. Roos, editors, </editor> <booktitle> Discretization in Differential Equations and Enclosures, </booktitle> <pages> pages 9-28. </pages> <publisher> Akademie-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: Significant developments in the area of validated solutions of IVPs for ODEs are the interval methods of Moore [48], [49], [50], Kruckeberg [40], Eijgenraam [19], and Lohner <ref> [1] </ref>, [44], [46]. All these methods are based on Taylor series. One reason for the popularity of the Taylor series approach is the simple form of the error term. <p> Taylor Series Methods for IVPs for ODEs 22 where J is the Jacobian of f [i] with its lth row evaluated at y j + il (^y j y j ) for some il 2 <ref> [0; 1] </ref> (l = 1; : : : ; n). <p> j+1 = ^y j + i=1 j f [i] (^y j ) + h k + I + i=1 j J f [i] ; y j ; ^y j ) (3.2.4) This formula is the basis of the interval Taylor series methods of Moore [48], [49], [50], Eijgenraam [19], Lohner <ref> [1] </ref>, [44], [46], and Rihm [61] (see also [52]). <p> Output: [y j+1 ], ^y j+1 . Computing [S j ] We show how the matrices [S j ] can be computed <ref> [1] </ref>. Consider the variational equation 0 = J (f ; y) ; (t j ) = I: (3.2.11) It can be shown that (i) (t) = J f [i] ; y (t); (3.2.12) where f [i] is defined in (2.4.19-2.4.20), and J is the Jacobian of f [i] . <p> Contracting Bounds Here, we consider one of the best cases that can occur. If the diagonal elements of J f <ref> [1] </ref> ; [y j ] are negative, then, in many cases, we can choose h j such that fl fl fl fl I + i=1 j J f [i] ; [y j ] fl If ^y j = m ([y j ]), then fl fl fl fl fl fl fl fl <p> Taylor Series Methods for IVPs for ODEs 30 y (t; t j ; [y j ]) t j t j+1 contains y (t j+1 ; t j ; [y j ]) and the local excess. 3.2.5 Lohner's Method We derive Lohner's method from (3.2.4) in a different way than in <ref> [1] </ref>, [44], and [46]. We show how [y 1 ] and [y 2 ] are computed and then give the algorithm for any [y j ]. <p> Example Let A = B 1 1 1 A and [r] = B <ref> [1; 2] </ref> 1 A : The QR-factorization of A is A = &gt; &lt; p 0 @ 2 1 C 9 &gt; ; &gt; &lt; p 0 @ 0 1 C 9 &gt; ; Consider the set The parallelepiped specified by [r] (see Figure 3.3 (a)) is mapped by A into <p> i (y j ^y j ) (p + q)! p+q+1 y (p+q+1) (t; t j ; t j+1 ) ; where J i (0) j is the Jacobian of f [i] with its lth row evaluated at y j+1 + il (^y j+1 y j+1 ) for some il 2 <ref> [0; 1] </ref>, and J is the Jacobian of f [i] with its lth row evaluated at y j + j il (^y j y j ) for some j il 2 [0; 1], l = 1; : : : ; n. Chapter 4. <p> with its lth row evaluated at y j+1 + il (^y j+1 y j+1 ) for some il 2 <ref> [0; 1] </ref>, and J is the Jacobian of f [i] with its lth row evaluated at y j + j il (^y j y j ) for some j il 2 [0; 1], l = 1; : : : ; n. Chapter 4. <p> Chapter 5. A Taylor Series Method for Validation 68 Before we consider how to implement a method based on (5.1.3), we illustrate this approach with a few examples. Consider y 0 = y; y (0) = 1 (5.1.4) and let [~y 0 ] = <ref> [1; 2] </ref>. Then (5.1.3) on (5.1.4) with [~y 0 ] = [1; 2] gives 1 + [0; h 0 ] + [0; h 2 0 =(k 1)!] + [0; h k which is satisfied if 1 + h 0 + h 2 0 =(k 1)! + 2h k For k = <p> Consider y 0 = y; y (0) = 1 (5.1.4) and let [~y 0 ] = <ref> [1; 2] </ref>. Then (5.1.3) on (5.1.4) with [~y 0 ] = [1; 2] gives 1 + [0; h 0 ] + [0; h 2 0 =(k 1)!] + [0; h k which is satisfied if 1 + h 0 + h 2 0 =(k 1)! + 2h k For k = 1 and 3, (5.1.5) holds for h 0 0:5 and h <p> Now, let [~y 0 ] = <ref> [1; 8] </ref>. The inclusion (5.1.3) holds if 1 + h 0 + h 2 0 =(k 1)! + 8h k For k = 1 and 3, (5.1.6) holds for h 0 0:875 and h 0 1:48, respectively. Here, we can compute larger stepsizes with wider a priori bounds. <p> Depending on the tolerance, we can afford wider a priori bounds. For example, suppose that Algorithm II uses Taylor series of order k = 15. Then, LEPUS is given by (h 14 0 =15!)w ([~y 0 ]). With h 0 = 0:63 and [~y 0 ] = <ref> [1; 2] </ref>, LEPUS 1:2 fi 10 15 , and with h 0 = 1:48 and [~y 0 ] = [1; 8], LEPUS 1:3 fi 10 9 . If the tolerance is 10 8 , we can use h 0 = 1:48 and [~y 0 ] = [1; 8]. <p> Then, LEPUS is given by (h 14 0 =15!)w ([~y 0 ]). With h 0 = 0:63 and [~y 0 ] = [1; 2], LEPUS 1:2 fi 10 15 , and with h 0 = 1:48 and [~y 0 ] = <ref> [1; 8] </ref>, LEPUS 1:3 fi 10 9 . If the tolerance is 10 8 , we can use h 0 = 1:48 and [~y 0 ] = [1; 8]. Consider y 0 = y; y (0) = 1 (5.1.7) and let [~y 0 ] = [0:5; 1:5]. <p> [~y 0 ] = [1; 2], LEPUS 1:2 fi 10 15 , and with h 0 = 1:48 and [~y 0 ] = <ref> [1; 8] </ref>, LEPUS 1:3 fi 10 9 . If the tolerance is 10 8 , we can use h 0 = 1:48 and [~y 0 ] = [1; 8]. Consider y 0 = y; y (0) = 1 (5.1.7) and let [~y 0 ] = [0:5; 1:5]. For k = 1, we obtain from (5.1.3) the constant enclosure method: 1 + [0; h 0 ][1:5; 0:5] [0:5; 1:5]; Chapter 5. <p> We write the template function Appendix B. A Validated Object-Oriented Solver 137 template &lt;class YTYPE&gt; void VDPtemplate (YTYPE *yp, const YTYPE *y) - yp <ref> [1] </ref> = MU*(1-sqr (y [0]))*y [1] - y [0]; which is used by FADBAD/TADIFF and IADOL-C to store the computation graph, and by VNODE to create a function for computing the right side. Then we derive a class VDP from ODE NUMERIC. <p> We write the template function Appendix B. A Validated Object-Oriented Solver 137 template &lt;class YTYPE&gt; void VDPtemplate (YTYPE *yp, const YTYPE *y) - yp <ref> [1] </ref> = MU*(1-sqr (y [0]))*y [1] - y [0]; which is used by FADBAD/TADIFF and IADOL-C to store the computation graph, and by VNODE to create a function for computing the right side. Then we derive a class VDP from ODE NUMERIC.
Reference: [2] <author> G. Alefeld and J. Herzberger. </author> <title> Introduction to Interval Computations. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: and [b 1 ] such that [a] [a 1 ] and [b] [b 1 ], we have [a] ffi [b] [a 1 ] ffi [b 1 ] ; ffi 2 f; ; fl; =g : Although interval addition and multiplication are associative, the distributive law does not hold in general <ref> [2, pp. 3-5] </ref>. That is, we can easily find three intervals [a], [b], and [c], for which [a]([b] + [c]) 6= [a][b] + [a][c]: However, for any three intervals [a], [b], and [c], the subdistributive law [a] ([b] + [c]) [a] [b] + [a] [c] ; does hold. <p> For [a] and [b] 2 IR, j [a] + [b]j j [a]j + j [b]j ; (2.1.1) w ([a] [b]) = w ([a]) + w ([b]) ; (2.1.3) w ([a] [b]) j [a]j w ([b]) + w ([a]) j [b]j (2.1.5) Chapter 2. Preliminaries 10 <ref> [2, pp. 14-17] </ref>. <p> Let [A] and [B] 2 IR nfin . Then j [A] + [B]j j [A]j + j [B]j ; (2.2.5) w ([A] [B]) = w ([A]) + w ([B]) ; (2.2.7) w ([A] [B]) j [A]j w ([B]) + w ([A]) j [B]j (2.2.9) <ref> [2, pp. 125-126] </ref>. Let the components of [B] be symmetric intervals. Then w ([A] [B]) = j [A]j w ([B]) and (2.2.10) for any [B 0 ] with w ([B 0 ]) = w ([B]). <p> f ([a]): If f satisfies a Lipschitz condition on D R n , then for any [a] D, q (R (f ; [a]); f ([a])) c 1 kw ([a])k (2.3.12) for some constant c 1 0 independent of [a], where q (; ) is defined by (2.2.2), [50, p. 24], <ref> [2] </ref>. Mean-value form If f : R n ! R is continuously differentiable on D R n and [a] D, then for any y and b 2 [a], [50, p. 47]. The expression f (b) + f 0 ([a])([a] b) is called the mean-value form of f . <p> Example Let A = B 1 1 1 A and [r] = B <ref> [1; 2] </ref> 1 A : The QR-factorization of A is A = &gt; &lt; p 0 @ 2 1 C 9 &gt; ; &gt; &lt; p 0 @ 0 1 C 9 &gt; ; Consider the set The parallelepiped specified by [r] (see Figure 3.3 (a)) is mapped by A into <p> An Interval Hermite-Obreschkoff Method 65 point matrix is more expensive than enclosing the inverse of a floating-point approximation to an orthogonal matrix. However, we can still enclose the inverse of an arbitrary point matrix in O (n 3 ) operations <ref> [2] </ref>. Lohner's method has 2 matrix-matrix multiplications, while the IHO method has 6 matrix-matrix multiplications. To summarize, in the IHO method, we reduce the work for generating Jacobians, but increase the number of matrix operations. Suppose that N n 2 . <p> Chapter 5. A Taylor Series Method for Validation 68 Before we consider how to implement a method based on (5.1.3), we illustrate this approach with a few examples. Consider y 0 = y; y (0) = 1 (5.1.4) and let [~y 0 ] = <ref> [1; 2] </ref>. Then (5.1.3) on (5.1.4) with [~y 0 ] = [1; 2] gives 1 + [0; h 0 ] + [0; h 2 0 =(k 1)!] + [0; h k which is satisfied if 1 + h 0 + h 2 0 =(k 1)! + 2h k For k = <p> Consider y 0 = y; y (0) = 1 (5.1.4) and let [~y 0 ] = <ref> [1; 2] </ref>. Then (5.1.3) on (5.1.4) with [~y 0 ] = [1; 2] gives 1 + [0; h 0 ] + [0; h 2 0 =(k 1)!] + [0; h k which is satisfied if 1 + h 0 + h 2 0 =(k 1)! + 2h k For k = 1 and 3, (5.1.5) holds for h 0 0:5 and h <p> Depending on the tolerance, we can afford wider a priori bounds. For example, suppose that Algorithm II uses Taylor series of order k = 15. Then, LEPUS is given by (h 14 0 =15!)w ([~y 0 ]). With h 0 = 0:63 and [~y 0 ] = <ref> [1; 2] </ref>, LEPUS 1:2 fi 10 15 , and with h 0 = 1:48 and [~y 0 ] = [1; 8], LEPUS 1:3 fi 10 9 . If the tolerance is 10 8 , we can use h 0 = 1:48 and [~y 0 ] = [1; 8].
Reference: [3] <author> S. Balay, W. D. Gropp, L. C. McInnes, and B. F. Smith. </author> <title> Parallelism in object-oriented numerical software libraries. In Erlend Arge, Are Magnus Bruaset, </title> <editor> and Hans Petter Langtangen, editors, </editor> <booktitle> Modern Software Tools in Scientific Computing, </booktitle> <pages> pages 163-202. </pages> <publisher> Birkhauser, </publisher> <address> Boston, </address> <year> 1997. </year> <note> See http://www.mcs.anl.gov/petsc/. </note>
Reference-contexts: B.4 Choice of Language: C++ versus Fortran 90 We have chosen C++ [20] over Fortran 90 [47] to implement VNODE. Procedural languages like C or Fortran 77 can be used to implement an object-oriented design <ref> [3] </ref>. However, using a language that supports object-oriented programming usually reduces the effort for implementing object-oriented software.
Reference: [4] <author> H. Bauch and W. Kimmel. </author> <title> Solving ordinary initial value problems with guaranteed bounds. </title> <journal> Z. angew. Math. Mech., </journal> <volume> 69:T110-T112, </volume> <year> 1989. </year>
Reference-contexts: We also consider the 17 Chapter 3. Taylor Series Methods for IVPs for ODEs 18 wrapping effect in generating interval Taylor coefficients and the overestimation in one step of ITS methods. Surveys of Taylor series and other interval methods can be found in <ref> [4] </ref>, [14], [15], [51], [54], [60], [70], and [71]. These papers give a "high-level" description of existing methods.
Reference: [5] <author> Claus Bendsten and Ole Stauning. FADBAD, </author> <title> a flexible C++ package for automatic differentiation using the forward and backward methods. </title> <type> Technical Report 1996-x5-94, </type> <institution> Department of Mathematical Modelling, Technical University of Denmark, DK-2800, Lyngby, Denmark, </institution> <month> August </month> <year> 1996. </year> <note> FADBAD is available at http://www.imm.dtu.dk/fadbad.html. </note>
Reference-contexts: Alternatively, the Jacobians in (3.2.14) can be computed by differentiating the code list of the corresponding f [i] , <ref> [5] </ref>, [6]. Chapter 3. Taylor Series Methods for IVPs for ODEs 26 Wrapping Effect in the Direct Method If we use the direct method to compute the enclosures [y j ], we might obtain unacceptably large interval vectors. This can be seen from the following considerations [60]. <p> We measure the work by the number of floating-point operations. However, the time spent on memory operations may not be insignificant for the following reasons. * The packages for automatic differentiation are often implemented through oper ator overloading <ref> [5] </ref>, [6], [25], which may involve many memory allocations and deallocations. * In generating Taylor coefficients, there may be a significant overhead caused by reading and storing the Taylor coefficients, f [i] , and their Jacobians [22]. <p> The FADBAD/TADIFF <ref> [5] </ref>, [6] and IADOL-C [31] packages compute @f [i] =@y by differentiating the code list of f [i] (IADOL-C is an interval version of ADOL-C [25]). We also assume that the cost of evaluating @f [i] =@y is roughly n times the cost of evaluating f [i] , [22]. <p> The underlying interval-arithmetic and automatic differentiation packages are PROFIL/BIAS [38] and FADBAD/TADIFF <ref> [5] </ref>, [6], respectively (see xB.4.1 and xB.4.2). 8.2 Observed Orders In this section, we determine empirically the error constants and orders of the ITS and IHO methods on a scalar (x8.2.1) and two-dimensional (x8.2.2) nonlinear problem. <p> These are the FADBAD/TADIFF <ref> [5] </ref>, [6] and IADOL-C [31] packages. They are written in C++ and implement AD through operator overloading. TADIFF and FADBAD are two different packages. TADIFF can generate Taylor coefficients with respect to time.
Reference: [6] <author> Claus Bendsten and Ole Stauning. TADIFF, </author> <title> a flexible C++ package for automatic differentiation using Taylor series. </title> <type> Technical Report 1997-x5-94, </type> <institution> Department of 140 Bibliography 141 Mathematical Modelling, Technical University of Denmark, DK-2800, Lyngby, Den-mark, </institution> <month> April </month> <year> 1997. </year> <note> TADIFF is available at http://www.imm.dtu.dk/fadbad.html. </note>
Reference-contexts: Alternatively, the Jacobians in (3.2.14) can be computed by differentiating the code list of the corresponding f [i] , [5], <ref> [6] </ref>. Chapter 3. Taylor Series Methods for IVPs for ODEs 26 Wrapping Effect in the Direct Method If we use the direct method to compute the enclosures [y j ], we might obtain unacceptably large interval vectors. This can be seen from the following considerations [60]. <p> We measure the work by the number of floating-point operations. However, the time spent on memory operations may not be insignificant for the following reasons. * The packages for automatic differentiation are often implemented through oper ator overloading [5], <ref> [6] </ref>, [25], which may involve many memory allocations and deallocations. * In generating Taylor coefficients, there may be a significant overhead caused by reading and storing the Taylor coefficients, f [i] , and their Jacobians [22]. <p> The FADBAD/TADIFF [5], <ref> [6] </ref> and IADOL-C [31] packages compute @f [i] =@y by differentiating the code list of f [i] (IADOL-C is an interval version of ADOL-C [25]). We also assume that the cost of evaluating @f [i] =@y is roughly n times the cost of evaluating f [i] , [22]. Chapter 4. <p> The underlying interval-arithmetic and automatic differentiation packages are PROFIL/BIAS [38] and FADBAD/TADIFF [5], <ref> [6] </ref>, respectively (see xB.4.1 and xB.4.2). 8.2 Observed Orders In this section, we determine empirically the error constants and orders of the ITS and IHO methods on a scalar (x8.2.1) and two-dimensional (x8.2.2) nonlinear problem. <p> These are the FADBAD/TADIFF [5], <ref> [6] </ref> and IADOL-C [31] packages. They are written in C++ and implement AD through operator overloading. TADIFF and FADBAD are two different packages. TADIFF can generate Taylor coefficients with respect to time.
Reference: [7] <author> M. Berz and K. Makino. </author> <title> Verified integration of ODEs and flows using differential algebraic methods on high-order Taylor models. </title> <booktitle> Reliable Computing, </booktitle> <volume> 4 </volume> <pages> 361-369, </pages> <year> 1998. </year>
Reference-contexts: The main obstacle in the second phase is how to reduce the so-called "wrapping effect." Currently, Lohner's QR-factorization method is the standard scheme for reducing it. Recently, Berz and Makino <ref> [7] </ref> proposed a method based on high-order Taylor series expansions with respect to time and the initial conditions that substantially reduces Chapter 1. Introduction 4 the wrapping effect (see also [8]). Their approach uses Taylor polynomials with real floating-point coefficients and a guaranteed error bound for the remainder term. <p> The reason for this pessimistic result is that by using intervals, we treat each of the components of the solution of (6.1.8-6.1.9) independently, while the second component of the true solution depends on the first one. The approach of Berz <ref> [7] </ref> uses multivariate high-order Taylor series with respect to time and the initial conditions to keep functional dependencies. As a result, his method is a higher order method with respect to the propagated enclosures. However, it requires arithmetic with Taylor polynomials, which involves significantly more work and memory. <p> The method used for verified integration of ODEs is based on high-order Taylor polynomials with respect to time and the initial conditions. The wrapping effect is reduced by establishing functional dependency between initial and final conditions (see <ref> [7] </ref>). For that purpose, the computations are carried out with Taylor polynomials with real floating-point coefficients and a guaranteed error bound for the remainder term. Thus, the arithmetic operations and standard functions are executed with such Taylor polynomials as operands. Although the approach described in [7] reduces the wrapping effect substantially, <p> initial and final conditions (see <ref> [7] </ref>). For that purpose, the computations are carried out with Taylor polynomials with real floating-point coefficients and a guaranteed error bound for the remainder term. Thus, the arithmetic operations and standard functions are executed with such Taylor polynomials as operands. Although the approach described in [7] reduces the wrapping effect substantially, working with polynomials is significantly more expensive than working with intervals. Appendix B. A Validated Object-Oriented Solver 127 B.3 Object-Oriented Concepts Since our goal is to build a flexible, easy-to-use, and easy-to-extend package, we have chosen an object-oriented approach in designing VNODE.
Reference: [8] <author> Martin Berz. </author> <title> COSY INFINITY version 8 reference manual. </title> <type> Technical Report MSUCL-1088, </type> <institution> National Superconducting Cyclotron Lab., Michigan State University, East Lansing, Mich., </institution> <year> 1997. </year> <note> COSY INFINITY is available at http://www.beamtheory.nscl.msu.edu/cosy/. </note>
Reference-contexts: Recently, Berz and Makino [7] proposed a method based on high-order Taylor series expansions with respect to time and the initial conditions that substantially reduces Chapter 1. Introduction 4 the wrapping effect (see also <ref> [8] </ref>). Their approach uses Taylor polynomials with real floating-point coefficients and a guaranteed error bound for the remainder term. Then, the arithmetic operations and standard functions are executed with such Taylor polynomials as operands, thus establishing a functional dependency between initial and final conditions. <p> Now, let [~y 0 ] = <ref> [1; 8] </ref>. The inclusion (5.1.3) holds if 1 + h 0 + h 2 0 =(k 1)! + 8h k For k = 1 and 3, (5.1.6) holds for h 0 0:875 and h 0 1:48, respectively. Here, we can compute larger stepsizes with wider a priori bounds. <p> Then, LEPUS is given by (h 14 0 =15!)w ([~y 0 ]). With h 0 = 0:63 and [~y 0 ] = [1; 2], LEPUS 1:2 fi 10 15 , and with h 0 = 1:48 and [~y 0 ] = <ref> [1; 8] </ref>, LEPUS 1:3 fi 10 9 . If the tolerance is 10 8 , we can use h 0 = 1:48 and [~y 0 ] = [1; 8]. Consider y 0 = y; y (0) = 1 (5.1.7) and let [~y 0 ] = [0:5; 1:5]. <p> [~y 0 ] = [1; 2], LEPUS 1:2 fi 10 15 , and with h 0 = 1:48 and [~y 0 ] = <ref> [1; 8] </ref>, LEPUS 1:3 fi 10 9 . If the tolerance is 10 8 , we can use h 0 = 1:48 and [~y 0 ] = [1; 8]. Consider y 0 = y; y (0) = 1 (5.1.7) and let [~y 0 ] = [0:5; 1:5]. For k = 1, we obtain from (5.1.3) the constant enclosure method: 1 + [0; h 0 ][1:5; 0:5] [0:5; 1:5]; Chapter 5. <p> Currently, there are three available packages for computing guaranteed bounds on the solution of an IVP for an ODE: AWA [44], ADIODES [69] and COSY INFINITY <ref> [8] </ref>. We briefly summarize each in turn. AWA is an implementation of Lohner's method (x3.2.5) and the constant enclosure approach (x3.1). This package is written in Pascal-XSC [37], an extension of Pascal for scientific computing.
Reference: [9] <author> Martin Berz, Christian Bischof, and George F. Corliss, </author> <title> editors. Computational Differentiation: Techniques, Applications, and Tools. </title> <publisher> SIAM, </publisher> <address> Philadelphia, Penn., </address> <year> 1996. </year>
Reference-contexts: Rall [58] describes in detail algorithms for automatic differentiation and generation of Taylor coefficients. He also considers applications of automatic differentiation, including applications to ordinary differential equations. Two books containing papers and extensive bibliographies on automatic differentiation are <ref> [9] </ref> and [23]. Since we need point and interval Taylor coefficients, we briefly describe the idea of their recursive generation.
Reference: [10] <author> G. Birkhoff and R. S. Varga. </author> <title> Discretization errors for well-set Cauchy problems: I. </title> <journal> J. Math. and Phys., </journal> <volume> 44 </volume> <pages> 1-23, </pages> <year> 1965. </year>
Reference-contexts: If z is complex with Re (z) &lt; 0, the following results are known: * if p = q, then jR p;q (z)j &lt; 1, and jR p;q (z)j ! 1 as jzj ! 1 <ref> [10] </ref>; * if q = p + 1 or q = p + 2, then jR p;q (z)j &lt; 1, and R p;q (z) ! 0 as jzj ! 1 [18]; and * if q &gt; p and z 2 R, z &lt; 0, then jR p;q (z)j &lt; 1, and <p> Chapter 8. Numerical Results 96 8.3 Interval Hermite-Obreschkoff versus Interval Taylor Series Methods 8.3.1 Constant Coefficient Problems Scalar Problem: Constant Stepsizes We integrated y 0 = 10y; (8.3.1) first with y (0) = 1 and then with y (0) 2 [0:9; 1:1] for t 2 <ref> [0; 10] </ref>. (At t = 10, the true solution of (8.3.1) with y (0) = 1 is e 100 3:7 fi 10 44 .) To avoid possible stepsize reductions in Algorithm I, we computed a priori enclosures on each step by [~y j ] = [e 10h y In Algorithm II, <p> 10 2 8:8 fi 10 3 0:7 4:0 fi 10 1 1:3 fi 10 45 3:2 fi 10 45 3:5 fi 10 6 1:0 fi 10 2 6:3 fi 10 3 Table 8.6: ITS (17) and IHO (8; 8) on y 0 = 10y, y (0) = 1, t 2 <ref> [0; 10] </ref>. h Excess Reductions Time ITS IHO IHO/ITS Q 8;8 (10h) ITS IHO 0:3 8:0 fi 10 48 1:5 fi 10 52 1:8 fi 10 5 1:9 fi 10 5 2:3 fi 10 2 1:4 fi 10 2 0:5 7:9 fi 10 41 1:9 fi 10 48 2:4 fi 10 <p> 2 8:3 fi 10 3 0:7 2:5 fi 10 1 1:4 fi 10 45 5:5 fi 10 45 3:5 fi 10 6 1:0 fi 10 2 6:3 fi 10 3 Table 8.7: ITS (17) and IHO (8; 8) on y 0 = 10y, y (0) 2 [0:9; 1:1], t 2 <ref> [0; 10] </ref>. Chapter 8. Numerical Results 98 (a) (b) Variable Stepsizes We integrated (8.3.1) with y (0) = 1 for t 2 [0; 100] with the stepsize selection scheme from x6.2. We used an absolute tolerance of 10 10 . <p> Numerical Results 110 Example 3 Lorenz system We integrated y 0 y 0 y 0 y (0) = (15; 15; 36) T ; t 2 <ref> [0; 10] </ref>; where oe = 10, ae = 28, and fi = 8=3, with the ITS (17) and IHO (8; 8) methods and used a constant enclosure method in Algorithm I. The input stepsizes for Algorithm I are 0:01; 0:05; 0:1.
Reference: [11] <author> Grady Booch. </author> <title> Object-Oriented Analysis and Design. </title> <publisher> The Benjamin/Cummings Publishing Company Inc., Rational, </publisher> <address> Santa Clara, California, 2nd edition, </address> <year> 1994. </year>
Reference-contexts: In [43], there is also an example of how to construct an object-oriented ODE solver. In this section, we review some object-oriented concepts supported in C++. A good discussion of object-oriented concepts, analysis, and design can be found in <ref> [11] </ref>. An excellent book on advanced C++ styles and idioms is [12]. A study of nonprocedural paradigms for numerical analysis, including object-oriented ones, is presented in [72].
Reference: [12] <author> James O. Coplien. </author> <title> Advanced C++ Programming Styles and Idioms. </title> <type> Addison-Wesley, </type> <institution> AT&T Bell Laboratories, </institution> <year> 1992. </year>
Reference-contexts: However, for the examples in the next two subsections, we use such optimal bounds. Chapter 8. Numerical Results 91 8.2.1 Nonlinear Scalar Problem We integrated y 0 = y 2 ; y (0) = 1 on <ref> [0; 12] </ref> with an ITS method with k = 7 and k = 11 and with an IHO method with p = q = 3 and p = q = 5, respectively (k = p + q + 1). <p> 3:1 fi 10 2 0:60 2:9 fi 10 4 2:1 fi 10 5 1:0 fi 10 2 7:4 fi 10 4 2:0 fi 10 2 2:1 fi 10 2 Table 8.1: ITS (7) and IHO (3; 3) on y 0 = y 2 , y (0) = 1, t 2 <ref> [0; 12] </ref>. h Excess Excess/h 11 Time ITS IHO ITS IHO ITS IHO 0:20 1:5 fi 10 10 5:4 fi 10 13 7:3 fi 10 3 2:6 fi 10 5 1:2 fi 10 1 9:6 fi 10 2 0:40 3:5 fi 10 7 3:9 fi 10 9 8:3 fi 10 3 <p> 4:8 fi 10 2 0:60 3:5 fi 10 5 1:3 fi 10 6 9:6 fi 10 3 3:6 fi 10 4 4:1 fi 10 2 3:3 fi 10 2 Table 8.2: ITS (11) and IHO (5; 5) on y 0 = y 2 , y (0) = 1, t 2 <ref> [0; 12] </ref>. Chapter 8. Numerical Results 93 k ch r 7 (1:04fi10 2 ) fi h 7:18 (8:27fi10 4 ) fi h 7:61 Table 8.3: Error constants and orders of the ITS and IHO methods on y 0 = y 2 , y (0) = 1, t 2 [0; 12]. <p> t 2 <ref> [0; 12] </ref>. Chapter 8. Numerical Results 93 k ch r 7 (1:04fi10 2 ) fi h 7:18 (8:27fi10 4 ) fi h 7:61 Table 8.3: Error constants and orders of the ITS and IHO methods on y 0 = y 2 , y (0) = 1, t 2 [0; 12]. The excess and stepsizes used in the least squares fits are from Tables 8.1 (k = 7) and 8.2 (k = 11). (c) ITS (7), IHO (3; 3) (d) ITS (11), IHO (5; 5) Chapter 8. <p> In this section, we review some object-oriented concepts supported in C++. A good discussion of object-oriented concepts, analysis, and design can be found in [11]. An excellent book on advanced C++ styles and idioms is <ref> [12] </ref>. A study of nonprocedural paradigms for numerical analysis, including object-oriented ones, is presented in [72]. Data Abstraction In the object model, a software system can be viewed as a collection of objects that interact with each other to achieve a desired functionality.
Reference: [13] <author> G. F. Corliss and R. Rihm. </author> <title> Validating an a priori enclosure using high-order Taylor series. </title> <editor> In G. Alefeld and A. Frommer, editors, </editor> <booktitle> Scientific Computing, Computer Arithmetic, and Validated Numerics, </booktitle> <pages> pages 228-238. </pages> <publisher> Akademie Verlag, </publisher> <address> Berlin, </address> <year> 1996. </year>
Reference-contexts: case of the more general Hermite-Obreschkoff methods, the method we propose is an implicit method with predictor and corrector phases. * We have devised a method for validating existence and uniqueness of the solution based on the Taylor series approach proposed by Moore [50] and revisited by Corliss and Rihm <ref> [13] </ref>. <p> One can obtain better methods by using polynomial enclosures [45] or more terms in the Taylor series for validation [50, pp. 100-103], <ref> [13] </ref>, [52]. We do not discuss the polynomial enclosure method in this thesis, but propose in Chapter 5 a Taylor series method for validating existence and uniqueness. In x8.4, we show by numerical experiments that our Taylor series method for validation enables larger stepsizes than the constant enclosure method. <p> In x8.3.2, we study empirically the amount of work per step on Van der Pol's equation. Chapter 5 A Taylor Series Method for Validation We introduce a Taylor series method that is based on the validation test suggested by Moore [50, pp. 100-103] (see also <ref> [13] </ref> and [52]) for proving existence and uniqueness of the solution. Our goal is to obtain a method that validates existence and uniqueness with the supplied stepsize, if possible, or a stepsize that is not much smaller than the supplied one. <p> If k1 X (t t j ) i f [i] (y j ) + (t t j ) k f [k] ([~y j ]) [~y j ] (5.1.1) for t 2 [t j ; t j+1 ], it can be shown <ref> [13] </ref> that the problem y 0 (t) = f (y), y (t j ) = y j has a unique solution y (t; t j ; y j ) 2 y j + i=1 For an interval [y j ], the condition (5.1.1) translates to [y j ] + i=1 To
Reference: [14] <author> George F. Corliss. </author> <title> Survey of interval algorithms for ordinary differential equations. </title> <journal> Appl. Math. Comput., </journal> <volume> 31 </volume> <pages> 112-120, </pages> <year> 1989. </year>
Reference-contexts: We also consider the 17 Chapter 3. Taylor Series Methods for IVPs for ODEs 18 wrapping effect in generating interval Taylor coefficients and the overestimation in one step of ITS methods. Surveys of Taylor series and other interval methods can be found in [4], <ref> [14] </ref>, [15], [51], [54], [60], [70], and [71]. These papers give a "high-level" description of existing methods.
Reference: [15] <author> George F. Corliss. </author> <title> Guaranteed error bounds for ordinary differential equations. </title> <editor> In M. Ainsworth, J. Levesley, W. A. Light, and M. Marletta, editors, </editor> <title> Theory of Numer Bibliography 142 ics in Ordinary and Partial Differential Equations, </title> <address> pages 1-76. </address> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: We also consider the 17 Chapter 3. Taylor Series Methods for IVPs for ODEs 18 wrapping effect in generating interval Taylor coefficients and the overestimation in one step of ITS methods. Surveys of Taylor series and other interval methods can be found in [4], [14], <ref> [15] </ref>, [51], [54], [60], [70], and [71]. These papers give a "high-level" description of existing methods.
Reference: [16] <author> G. Darboux. </author> <title> Sur les developpements en serie des fonctions d'une seule variable. </title> <journal> J. des Mathematique pures et appl., </journal> <pages> pages 291-312, 1876. </pages> <editor> 3eme serie, t. </editor> <booktitle> II. </booktitle>
Reference-contexts: by parts, we find 1 (1) (p+q) 0 q X (1) i c i g i (1) i=0 p;q If y (t) is the solution to the IVP y 0 = f (y); y (t j ) = y j ; (4.1.5) 1 This derivation is sometimes attributed to Darboux <ref> [16] </ref> and Hermite [28]. Chapter 4.
Reference: [17] <author> Viktor K. Decyk, Charles D. Norton, and Boleslaw K. Szymanski. </author> <title> Expressing object-oriented concepts in Fortran 90. </title> <journal> ACM Fortran Forum, </journal> <volume> 16(1) </volume> <pages> 13-18, </pages> <month> April </month> <year> 1997. </year>
Reference-contexts: The features of C++ (e.g., data abstraction, operator overloading, inheritance, and polymorphism) allow the goals in xB.1 to be achieved in a relatively simple way. Inheritance and polymorphism can be simulated in Fortran 90 <ref> [17] </ref>, but this is cumbersome. B.5 The VNODE package B.5.1 Structure From an object-oriented perspective, it is useful to think of a numerical problem as an object containing all the information necessary to compute its solution.
Reference: [18] <author> B. L. Ehle. </author> <title> On Pade approximations to the exponential function and A-stable methods for the numerical solution of initial value problems. </title> <journal> SIAM J. Math. Anal., </journal> <volume> 4 </volume> <pages> 671-680, </pages> <year> 1973. </year>
Reference-contexts: if p = q, then jR p;q (z)j &lt; 1, and jR p;q (z)j ! 1 as jzj ! 1 [10]; * if q = p + 1 or q = p + 2, then jR p;q (z)j &lt; 1, and R p;q (z) ! 0 as jzj ! 1 <ref> [18] </ref>; and * if q &gt; p and z 2 R, z &lt; 0, then jR p;q (z)j &lt; 1, and R p;q (z) ! 0 as jzj ! 1 [73] (see also [42, pp. 236-237]). Consider (4.3.5) and (4.3.11).
Reference: [19] <author> P. Eijgenraam. </author> <title> The Solution of Initial Value Problems Using Interval Arithmetic. </title> <publisher> Mathematical Centre Tracts No. 144. Stichting Mathematisch Centrum, </publisher> <address> Amsterdam, </address> <year> 1981. </year>
Reference-contexts: Significant developments in the area of validated solutions of IVPs for ODEs are the interval methods of Moore [48], [49], [50], Kruckeberg [40], Eijgenraam <ref> [19] </ref>, and Lohner [1], [44], [46]. All these methods are based on Taylor series. One reason for the popularity of the Taylor series approach is the simple form of the error term. <p> The computation of a tight enclosure is usually based on Taylor series plus remainder, the mean-value theorem, and various interval transformations. The main difficulty in the first phase is how to validate existence and uniqueness with a given stepsize. The constant enclosure method <ref> [19] </ref> is the most commonly used method for validation [44], [69]. However, the stepsizes allowed by this method are restricted to "Euler steps"; thus, reducing the efficiency of any method using it. <p> The constant enclosure method <ref> [19, pp. 59-67] </ref>, [44, pp. 27-31] for validating existence and uniqueness of the solution is based on the application of the Picard-Lindelof operator (T y)(t) = y j + t j to an appropriate set of functions and the Banach fixed-point theorem. Theorem 3.1 Banach fixed-point theorem. <p> Let L j = k@f ([~y j ])=@yk : It can be shown that the Picard-Lindelof operator is a contraction on U in the exponential norm with ff j &gt; L j , which implies fl = L j =ff j &lt; 1, <ref> [19, pp. 66-67] </ref> (see also [44, pp. 27-29]). Therefore, if (3.1.4) holds, and we can compute @f ([~y j ])=@y, then T has a unique fixed point in U . <p> (3.2.3), y j+1 = ^y j + i=1 j f [i] (^y j ) + h k + I + i=1 j J f [i] ; y j ; ^y j ) (3.2.4) This formula is the basis of the interval Taylor series methods of Moore [48], [49], [50], Eijgenraam <ref> [19] </ref>, Lohner [1], [44], [46], and Rihm [61] (see also [52]). <p> That is, by evaluating the Jacobian of f [i] on the interval [y j ]. As a result, the overestimation from the second line in (3.2.4) is of order O (h j kw ([y j ])k 2 ), <ref> [19, pp. 87-90] </ref>. This may be a major difficulty for problems with interval initial conditions, but should be insignificant for point initial conditions or interval initial conditions with small widths, provided that the widths of the computed enclosures remain sufficiently small throughout the computation. <p> We define local and global excess by * j = q (U j ; y (t j ; t j1 ; U j1 )) and (6.1.1) 75 Chapter 6. Estimating and Controlling the Excess 76 respectively <ref> [19, p. 87, p. 100] </ref>, [71], where q (; ) is the Hausdorff distance between two sets given by (2.2.1). 6.1.1 Controlling the Global Excess Similar to the standard numerical methods for IVPs for ODEs, our approach in VNODE is to allow the user to specify a tolerance Tol. <p> We try to achieve (6.1.3) by controlling the local excess per unit step (LEPUS) [71]. That is, we require * j h j1 T ol (6.1.4) on each step. Eijgenraam shows <ref> [19, p. 115] </ref> that fl j r=1 where ff is a constant depending on the problem. This constant may be negative since the logarithmic norm is used in its definition [19, p. 46]. <p> That is, we require * j h j1 T ol (6.1.4) on each step. Eijgenraam shows [19, p. 115] that fl j r=1 where ff is a constant depending on the problem. This constant may be negative since the logarithmic norm is used in its definition <ref> [19, p. 46] </ref>. Using (6.1.4), we obtain from (6.1.5) that fl j &gt; &gt; &lt; e ff (t j t 1 ) (t j t 0 )T ol; if ff &gt; 0; (6.1.6) Therefore, by controlling LEPUS, we can obtain a bound for the global excess. <p> Eijgenraam shows an example for which the overestimation on each step is at least ch j kw ([y j ])k 2 , for some constant c &gt; 0 <ref> [19, pp. 127-128] </ref>. <p> Thus, we compare methods with truncation errors of the same order. * If necessary, both methods use Lohner's QR-factorization technique to reduce the wrapping effect. The ITS method with the QR-factorization is essentially Lohner's method. * In the experiments with a variable stepsize control, we use Eijgenraam's method <ref> [19, pp. 129-136] </ref> for selecting initial stepsize. * The implementation of the constant enclosure method (in Algorithm I) is as described in [19, pp. 59-67]. <p> The ITS method with the QR-factorization is essentially Lohner's method. * In the experiments with a variable stepsize control, we use Eijgenraam's method [19, pp. 129-136] for selecting initial stepsize. * The implementation of the constant enclosure method (in Algorithm I) is as described in <ref> [19, pp. 59-67] </ref>. This implementation uses the Jacobian of f for com puting an initial guess for the a priori enclosure. * We compiled VNODE with the GNU C++ compiler version 2.7.2 on a Sun Ultra 2/2170 workstation with an 168 MHz UltraSPARC CPU. <p> Further studies may be necessary. New developments on stepsize selection for standard and validated ODE methods might be appropriate for considerations in a validated solver; see for example [26] and [36]. There has not been a comprehensive study of order control heuristics. Eijgenraam <ref> [19, pp. 129-136] </ref> describes the only order selection scheme known to the author. Some insights into the problem of order control are given in [50, pp. 100-118] and [70]. To develop an order control strategy based on the amount of work per step, we need to estimate this work.
Reference: [20] <author> Margaret A. Ellis and B. Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: 2:1 fi 10 6 1:3 fi 10 12 2:1 fi 10 6 3:5 fi 10 12 5:5 fi 10 1 4:5 fi 10 1 Table 8.10: ITS (17) and IHO (8; 8) on y 0 = t (1 y) + (1 t)e t , y (0) = 1, t 2 <ref> [0; 20] </ref>. Chapter 8. <p> fi 10 6 6:3 fi 10 13 2:1 fi 10 6 2:6 fi 10 12 5:5 fi 10 1 4:5 fi 10 1 Table 8.11: ITS (17) and IHO (8; 8) on y 0 = t (1 y) + (1 t)e t , y (0) 2 [0:999; 1:001], t 2 <ref> [0; 20] </ref>. h Excess Max Excess Time ITS IHO ITS IHO ITS IHO 0:3 8:1 fi 10 4 8:1 fi 10 4 8:1 fi 10 4 8:1 fi 10 4 9:4 fi 10 1 8:1 fi 10 1 0:5 1:0 fi 10 +7 8:4 fi 10 4 1:0 fi 10 +7 <p> fi 10 +7 8:4 fi 10 4 1:0 fi 10 +7 8:4 fi 10 4 5:6 fi 10 1 4:8 fi 10 1 Table 8.12: ITS (17) and IHO (8; 8) on y 0 = t (1 y) + (1 t)e t , y (0) 2 [0:999; 1:001], t 2 <ref> [0; 20] </ref>, QR-factorization. Chapter 8. Numerical Results 108 Example 2 Two-Body Problem We integrated the two-body problem y 0 y 0 y 0 y 1 1 + y 2 3=2 4 = (y 2 2 ) y (0) = (1; 0; 0; 1) T ; t 2 [0; 20] with the <p> 1:001], t 2 <ref> [0; 20] </ref>, QR-factorization. Chapter 8. Numerical Results 108 Example 2 Two-Body Problem We integrated the two-body problem y 0 y 0 y 0 y 1 1 + y 2 3=2 4 = (y 2 2 ) y (0) = (1; 0; 0; 1) T ; t 2 [0; 20] with the ITS (17) and IHO (8; 8) methods. We used a constant enclosure method in Algorithm I and input stepsizes 0:1, 0:15, 0:2 to this method. For input stepsize 0:1 to the validation procedure, the IHO method produces slightly better enclosures for slightly less work, Table 8.13. <p> Numerical Results 112 Example 4 Van der Pol's equation We integrated Van der Pol's equation, written as a system, y 0 y 0 1 )y 2 y 1 ; (8.3.7) with y (0) = (2; 0) T ; (8.3.8) for t 2 <ref> [0; 20] </ref>, where = 5. We used the ITS (11) and IHO (5; 5) methods and tolerances 10 7 ; 10 8 ; : : : ; 10 12 . <p> Chapter 8. Numerical Results 116 8.4 Taylor Series versus Constant Enclosure Method We integrated the following problems, which we denote by P1, P2, P3, and P4, P1: (8.3.6) with y (0) = 1, for t 2 <ref> [0; 20] </ref>; P2: y 0 2 = y 1 , with y (0) = (0; 1) T , for t 2 [0; 100]; P3: (8.3.2) with y (0) = (1; 1) T , for t 2 [0; 50]; and P4: (8.3.9) with y (0) = (0; 0; 0) T , for <p> Without it, programming interval-arithmetic expressions is cumbersome. Both C++ and Fortran 90 provide operator overloading. This feature is used to build interval-arithmetic libraries like PROFIL/BIAS [38] (C++) and INTLIB (Fortran 90) [34]. B.4 Choice of Language: C++ versus Fortran 90 We have chosen C++ <ref> [20] </ref> over Fortran 90 [47] to implement VNODE. Procedural languages like C or Fortran 77 can be used to implement an object-oriented design [3]. However, using a language that supports object-oriented programming usually reduces the effort for implementing object-oriented software.
Reference: [21] <author> W. H. Enright, T. E. Hull, and B. Lindberg. </author> <title> Comparing numerical methods for stiff systems of ODEs. </title> <journal> BIT, </journal> <volume> 15 </volume> <pages> 10-48, </pages> <year> 1975. </year>
Reference-contexts: Example 5 Stiff DETEST Problem D1 We integrated the Stiff DETEST problem D1 <ref> [21] </ref>, y 0 y 0 y 0 with y (0) = (0; 0; 0) T ; for t 2 [0; 400]: (8.3.10) Here, we used the ITS (17) and IHO (8; 8) methods, Taylor series for validation, and a variable stepsize control with tolerances 10 6 ; 10 7 ; : <p> A part of such a methodology should be an estimate of the amount of work. It may be possible to express it as a number of function and Jaco-bian evaluations. Then, we may compare validated methods in a framework similar to DETEST [30] or Stiff DETEST <ref> [21] </ref>. Appendix A Number of Operations for Generating Taylor Coefficients We obtain formulas for the number of arithmetic operations for generating one Taylor coefficient and k Taylor coefficients for the solution to y 0 = f (y), y (t 0 ) = y 0 .
Reference: [22] <author> Andreas Griewank. </author> <title> ODE solving via automatic differentiation and rational prediction. </title> <editor> In D. F. Griffiths and G. A. Watson, editors, </editor> <booktitle> Numerical Analysis 1995, volume 344 of Pitman Research Notes in Mathematics Series. </booktitle> <publisher> Addison-Wesley Longman Ltd, </publisher> <year> 1995. </year>
Reference-contexts: In standard numerical methods, Hermite-Obreschkoff methods are known to be suitable for stiff systems <ref> [22] </ref>, [24], [77], [78], but in the interval case, they still have a restriction on the stepsize. <p> Chapter 4 An Interval Hermite-Obreschkoff Method In this chapter, we derive an interval Hermite-Obreschkoff (IHO) method and compare it with the "standard" interval Taylor series methods. Hermite-Obreschkoff methods are usually considered for computing an approximate solution of a stiff problem <ref> [22] </ref>, [24], [77], [78]. Here, we are not interested in obtaining a method that is targeted specifically to solving stiff problems|our purpose is to obtain a general-purpose method that produces better enclosures at a smaller cost than the explicit validated methods based on Taylor series. <p> The system (4.1.11) defines the point (q; p) Hermite-Obreschkoff method <ref> [22] </ref>, [24], [27, p. 277], [77], [78]. Remarks 1. If p &gt; 0 and q = 0, we obtain an explicit Taylor series formula: y j+1 = i=0 j f [i] (y j ) + p+1 (p + 1)! Chapter 4. An Interval Hermite-Obreschkoff Method 41 2. <p> reasons. * The packages for automatic differentiation are often implemented through oper ator overloading [5], [6], [25], which may involve many memory allocations and deallocations. * In generating Taylor coefficients, there may be a significant overhead caused by reading and storing the Taylor coefficients, f [i] , and their Jacobians <ref> [22] </ref>. <p> We also assume that the cost of evaluating @f [i] =@y is roughly n times the cost of evaluating f [i] , <ref> [22] </ref>. Chapter 4. An Interval Hermite-Obreschkoff Method 64 For simplicity, suppose that f contains only arithmetic operations.
Reference: [23] <author> Andreas Griewank and George F. Corliss, </author> <title> editors. Automatic Differentiation of Algorithms: Theory, Implementation, and Application. </title> <publisher> SIAM, </publisher> <address> Philadelphia, Penn., </address> <year> 1991. </year> <note> Bibliography 143 </note>
Reference-contexts: Rall [58] describes in detail algorithms for automatic differentiation and generation of Taylor coefficients. He also considers applications of automatic differentiation, including applications to ordinary differential equations. Two books containing papers and extensive bibliographies on automatic differentiation are [9] and <ref> [23] </ref>. Since we need point and interval Taylor coefficients, we briefly describe the idea of their recursive generation. Denote the ith Taylor coefficient of u (t) evaluated at some point t j by (u j ) i = i! where u (i) (t) is the ith derivative of u (t).
Reference: [24] <author> Andreas Griewank, George F. Corliss, Petra Henneberger, Gabriella Kirlinger, Flo-rain A. Potra, and Hans J. Stetter. </author> <title> High-order stiff ODE solvers via automatic differentiation and rational prediction. </title> <booktitle> In Lecture Notes in Comput. Sci., </booktitle> <volume> 1196, </volume> <pages> pages 114-125. </pages> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1997. </year>
Reference-contexts: In standard numerical methods, Hermite-Obreschkoff methods are known to be suitable for stiff systems [22], <ref> [24] </ref>, [77], [78], but in the interval case, they still have a restriction on the stepsize. <p> Chapter 4 An Interval Hermite-Obreschkoff Method In this chapter, we derive an interval Hermite-Obreschkoff (IHO) method and compare it with the "standard" interval Taylor series methods. Hermite-Obreschkoff methods are usually considered for computing an approximate solution of a stiff problem [22], <ref> [24] </ref>, [77], [78]. Here, we are not interested in obtaining a method that is targeted specifically to solving stiff problems|our purpose is to obtain a general-purpose method that produces better enclosures at a smaller cost than the explicit validated methods based on Taylor series. <p> The system (4.1.11) defines the point (q; p) Hermite-Obreschkoff method [22], <ref> [24] </ref>, [27, p. 277], [77], [78]. Remarks 1. If p &gt; 0 and q = 0, we obtain an explicit Taylor series formula: y j+1 = i=0 j f [i] (y j ) + p+1 (p + 1)! Chapter 4. An Interval Hermite-Obreschkoff Method 41 2.
Reference: [25] <author> Andreas Griewank, David Juedes, and Jean Utke. ADOL-C, </author> <title> a package for the automatic differentiation of algorithms written in C/C++. </title> <journal> ACM Trans. Math. Software, </journal> <volume> 22(2) </volume> <pages> 131-167, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: We measure the work by the number of floating-point operations. However, the time spent on memory operations may not be insignificant for the following reasons. * The packages for automatic differentiation are often implemented through oper ator overloading [5], [6], <ref> [25] </ref>, which may involve many memory allocations and deallocations. * In generating Taylor coefficients, there may be a significant overhead caused by reading and storing the Taylor coefficients, f [i] , and their Jacobians [22]. <p> The FADBAD/TADIFF [5], [6] and IADOL-C [31] packages compute @f [i] =@y by differentiating the code list of f [i] (IADOL-C is an interval version of ADOL-C <ref> [25] </ref>). We also assume that the cost of evaluating @f [i] =@y is roughly n times the cost of evaluating f [i] , [22]. Chapter 4. An Interval Hermite-Obreschkoff Method 64 For simplicity, suppose that f contains only arithmetic operations. <p> FADBAD and TADIFF are not optimized to handle large and sparse systems. Also, they perform all the work in the main memory. The IADOL-C package is an extension of ADOL-C <ref> [25] </ref> that allows generic data types. ADOL-C can compute Taylor coefficients by using the forward mode and their Jacobians by applying the reverse mode [67] to these coefficients. The basic data type of ADOL-C is double.
Reference: [26] <author> Kjell Gustafsson, Michael Lundh, and Gustaf Soderlind. </author> <title> A PI stepsize control for the numerical solution of ordinary differential equations. </title> <journal> BIT, </journal> <volume> 28(2) </volume> <pages> 270-287, </pages> <year> 1988. </year>
Reference-contexts: It worked well for our tests, but we have not performed a thorough empirical investigation. Further studies may be necessary. New developments on stepsize selection for standard and validated ODE methods might be appropriate for considerations in a validated solver; see for example <ref> [26] </ref> and [36]. There has not been a comprehensive study of order control heuristics. Eijgenraam [19, pp. 129-136] describes the only order selection scheme known to the author. Some insights into the problem of order control are given in [50, pp. 100-118] and [70].
Reference: [27] <author> E. Hairer, S. P. Norsett, and G. Wanner. </author> <title> Solving Ordinary Differential Equations I. Nonstiff Problems. </title> <note> Springer-Verlag, 2nd revised edition, </note> <year> 1991. </year>
Reference-contexts: The system (4.1.11) defines the point (q; p) Hermite-Obreschkoff method [22], [24], <ref> [27, p. 277] </ref>, [77], [78]. Remarks 1. If p &gt; 0 and q = 0, we obtain an explicit Taylor series formula: y j+1 = i=0 j f [i] (y j ) + p+1 (p + 1)! Chapter 4. An Interval Hermite-Obreschkoff Method 41 2.
Reference: [28] <author> Ch. Hermite. Extrait d'une lettre de M. Ch. Hermite a M. Borchardt sur la formule d'interpolation de Lagrange. J. de Crelle, 84(70):70, 1878. Oeuvres, tome III, p. </author> <month> 432-443. </month>
Reference-contexts: Method Development * Taylor series has been the only effective approach for implementing interval methods for IVPs for ODEs. We have developed an interval Hermite-Obreschkoff (IHO) method for computing tight enclosures of the solution. Validated methods based on the Hermite-Obreschkoff formula <ref> [28] </ref>, [55], [56] have not been derived or considered before. <p> find 1 (1) (p+q) 0 q X (1) i c i g i (1) i=0 p;q If y (t) is the solution to the IVP y 0 = f (y); y (t j ) = y j ; (4.1.5) 1 This derivation is sometimes attributed to Darboux [16] and Hermite <ref> [28] </ref>. Chapter 4.
Reference: [29] <author> T. E. Hull and W. H. Enright. </author> <title> A structure for programs that solve ordinary differential equations. </title> <type> Technical Report 66, </type> <institution> Department of Computer Science, University of Toronto, </institution> <month> May </month> <year> 1974. </year>
Reference-contexts: First, in x7.1, we specify the ODE problem. Then, in x7.2, we describe one step of an integration procedure. A problem can be integrated by a repeated execution of the code implementing one step. The structure that we propose in x7.2 is somewhat similar to the one discussed in <ref> [29] </ref>. 7.1 Problem Specification As in the classical methods, we have to specify the problem we want to integrate. A minimum set of parameters is: n | number of equations; f | function for computing the right side; t 0 | initial point; 82 Chapter 7.
Reference: [30] <author> T. E. Hull, W. H. Enright, B. M. Fellen, and A. E. Sedgwick. </author> <title> Comparing numerical methods for ordinary differential equations. </title> <journal> SIAM J. on Numerical Analysis, </journal> <volume> 9(4) </volume> <pages> 603-637, </pages> <month> December </month> <year> 1972. </year>
Reference-contexts: A part of such a methodology should be an estimate of the amount of work. It may be possible to express it as a number of function and Jaco-bian evaluations. Then, we may compare validated methods in a framework similar to DETEST <ref> [30] </ref> or Stiff DETEST [21]. Appendix A Number of Operations for Generating Taylor Coefficients We obtain formulas for the number of arithmetic operations for generating one Taylor coefficient and k Taylor coefficients for the solution to y 0 = f (y), y (t 0 ) = y 0 .
Reference: [31] <author> Ronald Van Iwaarden. IADOL-C, </author> <type> personal communications, </type> <year> 1997. </year> <note> IADOL-C is available through the author. E-mail vaniwaar@metsci.com. </note>
Reference-contexts: The FADBAD/TADIFF [5], [6] and IADOL-C <ref> [31] </ref> packages compute @f [i] =@y by differentiating the code list of f [i] (IADOL-C is an interval version of ADOL-C [25]). We also assume that the cost of evaluating @f [i] =@y is roughly n times the cost of evaluating f [i] , [22]. Chapter 4. <p> These are the FADBAD/TADIFF [5], [6] and IADOL-C <ref> [31] </ref> packages. They are written in C++ and implement AD through operator overloading. TADIFF and FADBAD are two different packages. TADIFF can generate Taylor coefficients with respect to time. <p> Since IADOL-C replaces only the double data type of ADOL-C, IADOL-C inherits all the functionality of ADOL-C. However, it was reported that the operator overloading, in IADOL-C, for a basic data type incurs about a three times speed penalty over ADOL-C <ref> [31] </ref>. This appears to be a phenomenon of the C++ compilers rather than the AD package [31]. The ADOL-C package records the computation graph on a so-called tape. This tape Appendix B. A Validated Object-Oriented Solver 130 is stored in the main memory, but, when necessary, is paged to disk. <p> However, it was reported that the operator overloading, in IADOL-C, for a basic data type incurs about a three times speed penalty over ADOL-C <ref> [31] </ref>. This appears to be a phenomenon of the C++ compilers rather than the AD package [31]. The ADOL-C package records the computation graph on a so-called tape. This tape Appendix B. A Validated Object-Oriented Solver 130 is stored in the main memory, but, when necessary, is paged to disk.
Reference: [32] <author> L. W. Jackson. </author> <title> Interval arithmetic error-bounding algorithms. </title> <journal> SIAM J. Numer. Anal., </journal> <volume> 12(2) </volume> <pages> 223-238, </pages> <year> 1975. </year> <note> Bibliography 144 </note>
Reference-contexts: Chapter 3. Taylor Series Methods for IVPs for ODEs 23 The rotated rectangle is wrapped at t = 4 n, where n = 1; : : : ; 4. Jackson <ref> [32] </ref> gives a definition of wrapping. Definition 3.1 Let T 2 R nfin , [x] 2 IR n , and c 2 R n . Then the wrapping of the parallelepiped P = T x + c j x 2 [x] is the tightest interval vector containing P .
Reference: [33] <author> David Juedes. </author> <title> A taxonomy of automatic differentiation tools. </title> <editor> In Andreas Griewank and George F. Corliss, editors, </editor> <title> Automatic Differentiation of Algorithms: Theory, </title> <booktitle> Implementation, and Application, </booktitle> <pages> pages 315-329. </pages> <publisher> SIAM, </publisher> <address> Philadelphia, Penn., </address> <year> 1991. </year>
Reference-contexts: A Validated Object-Oriented Solver 129 4. efficiency. In this section, we discuss each in turn. B.4.1 Software for Automatic Generation of Interval Taylor Coefficients Although packages for automatic differentiation (AD) are available (see for example <ref> [33] </ref> and [79]), to date, only two free packages for automatic generation of interval Taylor coefficients for the solution of an ODE and the Jacobians of these coefficients are known to the author. These are the FADBAD/TADIFF [5], [6] and IADOL-C [31] packages.
Reference: [34] <author> R. B. Kearfott. </author> <title> INTERVAL ARITHMETIC: A Fortran 90 module for an interval data type. </title> <journal> ACM Trans. Math. Software, </journal> <volume> 22(4) </volume> <pages> 385-392, </pages> <year> 1996. </year>
Reference-contexts: To program interval operations without explicit function calls, we have to use a language that supports operator overloading. Without it, programming interval-arithmetic expressions is cumbersome. Both C++ and Fortran 90 provide operator overloading. This feature is used to build interval-arithmetic libraries like PROFIL/BIAS [38] (C++) and INTLIB (Fortran 90) <ref> [34] </ref>. B.4 Choice of Language: C++ versus Fortran 90 We have chosen C++ [20] over Fortran 90 [47] to implement VNODE. Procedural languages like C or Fortran 77 can be used to implement an object-oriented design [3]. <p> B.4.2 Interval Arithmetic Packages The most popular and free interval-arithmetic packages are PROFIL/BIAS [38], written in C++, and INTLIB [35], written in Fortran 77 and available with a Fortran 90 interface <ref> [34] </ref>. The Fortran 90 version of INTLIB uses operator overloading. For references and comments on other available packages, see for example [34] or [38]. Recently, an interval extension of the Gnu Fortran compiler was reported [65], where intervals are supported as an intrinsic data type. <p> Arithmetic Packages The most popular and free interval-arithmetic packages are PROFIL/BIAS [38], written in C++, and INTLIB [35], written in Fortran 77 and available with a Fortran 90 interface <ref> [34] </ref>. The Fortran 90 version of INTLIB uses operator overloading. For references and comments on other available packages, see for example [34] or [38]. Recently, an interval extension of the Gnu Fortran compiler was reported [65], where intervals are supported as an intrinsic data type. PROFIL/BIAS seems to be the fastest interval package. In comparison with other such packages, including INTLIB, PROFIL/BIAS is about one order of magnitude faster [38].
Reference: [35] <author> R. B. Kearfott, M. Dawande, K. Du, and C. Hu. </author> <title> Algorithm 737: INTLIB: A portable Fortran 77 interval standard function library. </title> <journal> ACM Trans. Math. Softw., </journal> <volume> 20(4) </volume> <pages> 447-459, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: VNODE with these AD packages is based on the INTERVAL data type from the PROFIL/BIAS package, which we discuss in xB.4.2 and xB.4.3. B.4.2 Interval Arithmetic Packages The most popular and free interval-arithmetic packages are PROFIL/BIAS [38], written in C++, and INTLIB <ref> [35] </ref>, written in Fortran 77 and available with a Fortran 90 interface [34]. The Fortran 90 version of INTLIB uses operator overloading. For references and comments on other available packages, see for example [34] or [38].
Reference: [36] <author> Monika Kerbl. </author> <title> Stepsize strategies for inclusion algorithms for ODE's. </title> <editor> In E. Kaucher, S. M. Markov, and G. Mayer, editors, </editor> <title> Computer Arithmetic, Scientific Computation, and Mathematical Modelling, </title> <journal> IMACS Annals on Computing and Appl. Math. </journal> <volume> 12. </volume> <pages> J.C. </pages> <publisher> Baltzer, </publisher> <address> Basel, </address> <year> 1991. </year>
Reference-contexts: It worked well for our tests, but we have not performed a thorough empirical investigation. Further studies may be necessary. New developments on stepsize selection for standard and validated ODE methods might be appropriate for considerations in a validated solver; see for example [26] and <ref> [36] </ref>. There has not been a comprehensive study of order control heuristics. Eijgenraam [19, pp. 129-136] describes the only order selection scheme known to the author. Some insights into the problem of order control are given in [50, pp. 100-118] and [70].
Reference: [37] <author> Rudi Klatte, Ulrich Kulisch, Michael Neaga, Dietmar Ratz, and Christian Ullrich. Pascal-XSC: </author> <title> Language Reference with Examples. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: We briefly summarize each in turn. AWA is an implementation of Lohner's method (x3.2.5) and the constant enclosure approach (x3.1). This package is written in Pascal-XSC <ref> [37] </ref>, an extension of Pascal for scientific computing. ADIODES is a C++ implementation of a solver using the constant enclosure method in Algorithm I and Lohner's method in Algorithm II. The stepsizes in both ADIODES and AWA is restricted to Euler steps by Algorithm I.
Reference: [38] <author> O. Knuppel. </author> <title> PROFIL/BIAS a fast interval library. </title> <booktitle> Computing, </booktitle> <address> 53(3-4):277-287, </address> <year> 1994. </year> <note> PROFIL/BIAS is available at http://www.ti3.tu-harburg.de/Software/PROFIL/Profil.texinfo 1.html. </note>
Reference-contexts: The underlying interval-arithmetic and automatic differentiation packages are PROFIL/BIAS <ref> [38] </ref> and FADBAD/TADIFF [5], [6], respectively (see xB.4.1 and xB.4.2). 8.2 Observed Orders In this section, we determine empirically the error constants and orders of the ITS and IHO methods on a scalar (x8.2.1) and two-dimensional (x8.2.2) nonlinear problem. <p> To program interval operations without explicit function calls, we have to use a language that supports operator overloading. Without it, programming interval-arithmetic expressions is cumbersome. Both C++ and Fortran 90 provide operator overloading. This feature is used to build interval-arithmetic libraries like PROFIL/BIAS <ref> [38] </ref> (C++) and INTLIB (Fortran 90) [34]. B.4 Choice of Language: C++ versus Fortran 90 We have chosen C++ [20] over Fortran 90 [47] to implement VNODE. Procedural languages like C or Fortran 77 can be used to implement an object-oriented design [3]. <p> Currently, VNODE is configured with FADBAD/TADIFF, but we have also used IADOL-C. VNODE with these AD packages is based on the INTERVAL data type from the PROFIL/BIAS package, which we discuss in xB.4.2 and xB.4.3. B.4.2 Interval Arithmetic Packages The most popular and free interval-arithmetic packages are PROFIL/BIAS <ref> [38] </ref>, written in C++, and INTLIB [35], written in Fortran 77 and available with a Fortran 90 interface [34]. The Fortran 90 version of INTLIB uses operator overloading. For references and comments on other available packages, see for example [34] or [38]. <p> The most popular and free interval-arithmetic packages are PROFIL/BIAS <ref> [38] </ref>, written in C++, and INTLIB [35], written in Fortran 77 and available with a Fortran 90 interface [34]. The Fortran 90 version of INTLIB uses operator overloading. For references and comments on other available packages, see for example [34] or [38]. Recently, an interval extension of the Gnu Fortran compiler was reported [65], where intervals are supported as an intrinsic data type. PROFIL/BIAS seems to be the fastest interval package. In comparison with other such packages, including INTLIB, PROFIL/BIAS is about one order of magnitude faster [38]. <p> for example [34] or <ref> [38] </ref>. Recently, an interval extension of the Gnu Fortran compiler was reported [65], where intervals are supported as an intrinsic data type. PROFIL/BIAS seems to be the fastest interval package. In comparison with other such packages, including INTLIB, PROFIL/BIAS is about one order of magnitude faster [38]. Also, PROFIL/BIAS is easy-to-use, and provides matrix and vector operations and essential routines, for example, guaranteed linear equation solvers and optimization routines. For efficiency, it uses the rounding mode of the processor on the machines on which it is installed. <p> Each interval addition in this loop involves two changes of the rounding Appendix B. A Validated Object-Oriented Solver 132 mode. In modern RISC architectures, rounding mode switches cost nearly the same or even more than floating-point operations <ref> [38] </ref>, [65]. The approach of PROFIL/BIAS is to minimize these switches. Suppose that we want to compute in PROFIL/BIAS C = A + B, where A, B, and C are vectors of the same dimensions.
Reference: [39] <author> Fred T. Krogh. </author> <title> On testing a subroutine for the numerical integration of ordinary differential equations. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 20(4) </volume> <pages> 545-562, </pages> <month> October </month> <year> 1973. </year>
Reference-contexts: Here, we knew how to compute good a priori bounds in Algorithm I for large stepsizes, but this is rarely the case. Chapter 8. Numerical Results 105 8.3.2 Nonlinear Problems Example 1 We integrated <ref> [39] </ref> y 0 = t (1 y) + (1 t)e t ; (8.3.6) with constant stepsizes 0:2; 0:3; 0:4; and 0:5.
Reference: [40] <author> F. Kruckeberg. </author> <title> Ordinary differential equations. In Eldon Hansen, editor, </title> <booktitle> Topics in Interval Analysis, </booktitle> <pages> pages 91-97. </pages> <publisher> Clarendon Press, Oxford, </publisher> <year> 1969. </year>
Reference-contexts: Significant developments in the area of validated solutions of IVPs for ODEs are the interval methods of Moore [48], [49], [50], Kruckeberg <ref> [40] </ref>, Eijgenraam [19], and Lohner [1], [44], [46]. All these methods are based on Taylor series. One reason for the popularity of the Taylor series approach is the simple form of the error term.
Reference: [41] <author> Ulrich W. Kulisch and Willard L. Miranker. </author> <title> Computer Arithmetic in Theory and Practice. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1981. </year> <note> Bibliography 145 </note>
Reference-contexts: Interval arithmetic is often called a machine, or rounded, interval arithmetic. A discussion of its properties can be found in <ref> [41] </ref>. 2.3 Interval-Valued Functions Let f : R n ! R be a continuous function on D R n . We consider functions whose representations contain only a finite number of constants, variables, arithmetic operations, and standard functions (sin, cos, log, exp, etc.).
Reference: [42] <author> J. D. Lambert. </author> <title> Computational Methods in Ordinary Differential Equations. </title> <publisher> John Wiley & Sons, </publisher> <year> 1977. </year>
Reference-contexts: 2, then jR p;q (z)j &lt; 1, and R p;q (z) ! 0 as jzj ! 1 [18]; and * if q &gt; p and z 2 R, z &lt; 0, then jR p;q (z)j &lt; 1, and R p;q (z) ! 0 as jzj ! 1 [73] (see also <ref> [42, pp. 236-237] </ref>). Consider (4.3.5) and (4.3.11). For the ITS method, jT k1 (h)j &lt; 1 when h is in the stability region of T k1 (z).
Reference: [43] <author> Hans Petter Langtangen. Diffpack. </author> <type> Technical report, </type> <institution> SINTEF, Oslo, Norway, </institution> <month> June </month> <year> 1996. </year> <note> See http://www.oslo.sintef.no/diffpack/reports/. </note>
Reference-contexts: This is not the first object-oriented design of an ODE solver. The Godess project [57] offers a generic ODE solver that implements traditional methods for IVPs for ODEs. Another successful package is Diffpack <ref> [43] </ref>, which is devised for solving partial differential equations. In [43], there is also an example of how to construct an object-oriented ODE solver. In this section, we review some object-oriented concepts supported in C++. A good discussion of object-oriented concepts, analysis, and design can be found in [11]. <p> This is not the first object-oriented design of an ODE solver. The Godess project [57] offers a generic ODE solver that implements traditional methods for IVPs for ODEs. Another successful package is Diffpack <ref> [43] </ref>, which is devised for solving partial differential equations. In [43], there is also an example of how to construct an object-oriented ODE solver. In this section, we review some object-oriented concepts supported in C++. A good discussion of object-oriented concepts, analysis, and design can be found in [11]. An excellent book on advanced C++ styles and idioms is [12].
Reference: [44] <author> Rudolf J. Lohner. </author> <title> Einschlieung der Losung gewohnlicher Anfangs- und Randw-ertaufgaben und Anwendungen. </title> <type> PhD thesis, </type> <institution> Universitat Karlsruhe, </institution> <year> 1988. </year> <note> AWA is available at ftp://iamk4515.mathematik.uni-karlsruhe.de/pub/awa/. </note>
Reference-contexts: Significant developments in the area of validated solutions of IVPs for ODEs are the interval methods of Moore [48], [49], [50], Kruckeberg [40], Eijgenraam [19], and Lohner [1], <ref> [44] </ref>, [46]. All these methods are based on Taylor series. One reason for the popularity of the Taylor series approach is the simple form of the error term. <p> The main difficulty in the first phase is how to validate existence and uniqueness with a given stepsize. The constant enclosure method [19] is the most commonly used method for validation <ref> [44] </ref>, [69]. However, the stepsizes allowed by this method are restricted to "Euler steps"; thus, reducing the efficiency of any method using it. The main obstacle in the second phase is how to reduce the so-called "wrapping effect." Currently, Lohner's QR-factorization method is the standard scheme for reducing it. <p> The constant enclosure method [19, pp. 59-67], <ref> [44, pp. 27-31] </ref> for validating existence and uniqueness of the solution is based on the application of the Picard-Lindelof operator (T y)(t) = y j + t j to an appropriate set of functions and the Banach fixed-point theorem. Theorem 3.1 Banach fixed-point theorem. <p> Let L j = k@f ([~y j ])=@yk : It can be shown that the Picard-Lindelof operator is a contraction on U in the exponential norm with ff j &gt; L j , which implies fl = L j =ff j &lt; 1, [19, pp. 66-67] (see also <ref> [44, pp. 27-29] </ref>). Therefore, if (3.1.4) holds, and we can compute @f ([~y j ])=@y, then T has a unique fixed point in U . <p> = ^y j + i=1 j f [i] (^y j ) + h k + I + i=1 j J f [i] ; y j ; ^y j ) (3.2.4) This formula is the basis of the interval Taylor series methods of Moore [48], [49], [50], Eijgenraam [19], Lohner [1], <ref> [44] </ref>, [46], and Rihm [61] (see also [52]). <p> Series Methods for IVPs for ODEs 30 y (t; t j ; [y j ]) t j t j+1 contains y (t j+1 ; t j ; [y j ]) and the local excess. 3.2.5 Lohner's Method We derive Lohner's method from (3.2.4) in a different way than in [1], <ref> [44] </ref>, and [46]. We show how [y 1 ] and [y 2 ] are computed and then give the algorithm for any [y j ]. <p> Furthermore, we want to avoid as many stepsize reductions in this method as possible. Usually, a Taylor series method for validation enables larger stepsizes than the constant enclosure method, which has been used in the past <ref> [44] </ref>, [69]. As we pointed out in x3.1, the constant enclosure method restricts the stepsizes to Euler steps. We also combine better algorithms for computing tight enclosures, such as Lohner's method and the IHO method, with our algorithm for validating existence and uniqueness. <p> This observation confirms the theory in x4.3.1. Chapter 8. Numerical Results 99 control with T ol = 10 10 . Two-Dimensional Problem We compare the ITS (17) and IHO (8; 8) methods on the system y 0 = By = B 1 2 1 A y (8.3.2) <ref> [44] </ref>. This system is interesting because the solution components tend to zero rapidly, but still, we have to deal with the wrapping effect. <p> In addition to an interval-arithmetic package, a major component of a validated solver is the module for automatic generation of interval Taylor coefficients (see xB.4). Currently, there are three available packages for computing guaranteed bounds on the solution of an IVP for an ODE: AWA <ref> [44] </ref>, ADIODES [69] and COSY INFINITY [8]. We briefly summarize each in turn. AWA is an implementation of Lohner's method (x3.2.5) and the constant enclosure approach (x3.1). This package is written in Pascal-XSC [37], an extension of Pascal for scientific computing.
Reference: [45] <author> Rudolf J. Lohner. </author> <title> Step size and order control in the verified solution of IVP with ODE's, </title> <booktitle> 1995. SciCADE'95 International Conference on Scientific Computation and Differential Equations, </booktitle> <institution> Stanford University, Calif., </institution> <month> March 28 - April 1, </month> <year> 1995. </year>
Reference-contexts: The inclusion in (3.1.6) can be easily verified. However, a serious disadvantage of the method is that the stepsize is restricted to Euler steps, even when high-order methods are used in Algorithm II to tighten the a priori enclosure. One can obtain better methods by using polynomial enclosures <ref> [45] </ref> or more terms in the Taylor series for validation [50, pp. 100-103], [13], [52]. We do not discuss the polynomial enclosure method in this thesis, but propose in Chapter 5 a Taylor series method for validating existence and uniqueness.
Reference: [46] <author> Rudolph J. Lohner. </author> <title> Enclosing the solutions of ordinary initial and boundary value problems. </title> <editor> In Edgar W. Kaucher, Ulrich W. Kulisch, and Christian Ullrich, editors, </editor> <booktitle> Computer Arithmetic: Scientific Computation and Programming Languages, </booktitle> <pages> pages 255-286. </pages> <booktitle> Wiley-Teubner Series in Computer Science, </booktitle> <address> Stuttgart, </address> <year> 1987. </year>
Reference-contexts: Significant developments in the area of validated solutions of IVPs for ODEs are the interval methods of Moore [48], [49], [50], Kruckeberg [40], Eijgenraam [19], and Lohner [1], [44], <ref> [46] </ref>. All these methods are based on Taylor series. One reason for the popularity of the Taylor series approach is the simple form of the error term. <p> ^y j + i=1 j f [i] (^y j ) + h k + I + i=1 j J f [i] ; y j ; ^y j ) (3.2.4) This formula is the basis of the interval Taylor series methods of Moore [48], [49], [50], Eijgenraam [19], Lohner [1], [44], <ref> [46] </ref>, and Rihm [61] (see also [52]). <p> for IVPs for ODEs 30 y (t; t j ; [y j ]) t j t j+1 contains y (t j+1 ; t j ; [y j ]) and the local excess. 3.2.5 Lohner's Method We derive Lohner's method from (3.2.4) in a different way than in [1], [44], and <ref> [46] </ref>. We show how [y 1 ] and [y 2 ] are computed and then give the algorithm for any [y j ].
Reference: [47] <author> M. Metcalf and J. Reid. </author> <title> Fortran 90 Explained. </title> <publisher> Oxford University Press, Oxford, </publisher> <address> England, </address> <year> 1990. </year>
Reference-contexts: Without it, programming interval-arithmetic expressions is cumbersome. Both C++ and Fortran 90 provide operator overloading. This feature is used to build interval-arithmetic libraries like PROFIL/BIAS [38] (C++) and INTLIB (Fortran 90) [34]. B.4 Choice of Language: C++ versus Fortran 90 We have chosen C++ [20] over Fortran 90 <ref> [47] </ref> to implement VNODE. Procedural languages like C or Fortran 77 can be used to implement an object-oriented design [3]. However, using a language that supports object-oriented programming usually reduces the effort for implementing object-oriented software.
Reference: [48] <author> Ramon E. Moore. </author> <title> The automatic analysis and control of error in digital computation based on the use of interval numbers. </title> <editor> In Louis B. Rall, editor, </editor> <booktitle> Error in Digital Computation, </booktitle> <volume> Vol. I, </volume> <pages> pages 61-130. </pages> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1965. </year>
Reference-contexts: Significant developments in the area of validated solutions of IVPs for ODEs are the interval methods of Moore <ref> [48] </ref>, [49], [50], Kruckeberg [40], Eijgenraam [19], and Lohner [1], [44], [46]. All these methods are based on Taylor series. One reason for the popularity of the Taylor series approach is the simple form of the error term. <p> Then from (3.2.1) and (3.2.3), y j+1 = ^y j + i=1 j f [i] (^y j ) + h k + I + i=1 j J f [i] ; y j ; ^y j ) (3.2.4) This formula is the basis of the interval Taylor series methods of Moore <ref> [48] </ref>, [49], [50], Eijgenraam [19], Lohner [1], [44], [46], and Rihm [61] (see also [52]).
Reference: [49] <author> Ramon E. Moore. </author> <title> Automatic local coordinate transformations to reduce the growth of error bounds in interval computation of solutions of ordinary differential equations. </title> <editor> In Louis B. Rall, editor, </editor> <booktitle> Error in Digital Computation, </booktitle> <volume> Vol. II, </volume> <pages> pages 103-140. </pages> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1965. </year>
Reference-contexts: Significant developments in the area of validated solutions of IVPs for ODEs are the interval methods of Moore [48], <ref> [49] </ref>, [50], Kruckeberg [40], Eijgenraam [19], and Lohner [1], [44], [46]. All these methods are based on Taylor series. One reason for the popularity of the Taylor series approach is the simple form of the error term. <p> from (3.2.1) and (3.2.3), y j+1 = ^y j + i=1 j f [i] (^y j ) + h k + I + i=1 j J f [i] ; y j ; ^y j ) (3.2.4) This formula is the basis of the interval Taylor series methods of Moore [48], <ref> [49] </ref>, [50], Eijgenraam [19], Lohner [1], [44], [46], and Rihm [61] (see also [52]).
Reference: [50] <author> Ramon E. Moore. </author> <title> Interval Analysis. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1966. </year> <note> Bibliography 146 </note>
Reference-contexts: Significant developments in the area of validated solutions of IVPs for ODEs are the interval methods of Moore [48], [49], <ref> [50] </ref>, Kruckeberg [40], Eijgenraam [19], and Lohner [1], [44], [46]. All these methods are based on Taylor series. One reason for the popularity of the Taylor series approach is the simple form of the error term. <p> methods can be viewed as a special case of the more general Hermite-Obreschkoff methods, the method we propose is an implicit method with predictor and corrector phases. * We have devised a method for validating existence and uniqueness of the solution based on the Taylor series approach proposed by Moore <ref> [50] </ref> and revisited by Corliss and Rihm [13]. <p> Two intervals [a] and [b] are equal if a Let [a] and [b] 2 IR and ffi 2 f+; ; fl; =g. The interval-arithmetic operations are defined <ref> [50, pp. 8-9] </ref> by [a] ffi [b] = fx ffi y j x 2 [a] ; y 2 [b]g ; 0 =2 [b] when ffi = =; which can be written in the equivalent form (we omit fl in the notation): [a] + [b] = a + b ; a + <p> Preliminaries 9 We also define the following quantities for intervals <ref> [50] </ref>: * width w ([a]) = a a * midpoint m ([a]) = (a + a * magnitude j [a]j = max fjaj; ja The interval-arithmetic operations are inclusion monotone. <p> (f ; [a]) f ([a]): If f satisfies a Lipschitz condition on D R n , then for any [a] D, q (R (f ; [a]); f ([a])) c 1 kw ([a])k (2.3.12) for some constant c 1 0 independent of [a], where q (; ) is defined by (2.2.2), <ref> [50, p. 24] </ref>, [2]. Mean-value form If f : R n ! R is continuously differentiable on D R n and [a] D, then for any y and b 2 [a], [50, p. 47]. <p> Mean-value form If f : R n ! R is continuously differentiable on D R n and [a] D, then for any y and b 2 [a], <ref> [50, p. 47] </ref>. The expression f (b) + f 0 ([a])([a] b) is called the mean-value form of f . Mathematically, f M is not uniquely defined, but it is uniquely determined by the code list of f 0 and the choice of b. <p> Similar results apply to functions from R n to R n . Integration Let f : D ! R n be a continuous function on D R and [a] D. Then, Z a Chapter 2. Preliminaries 15 2.4 Automatic Generation of Taylor Coefficients Moore <ref> [50, pp. 107-130] </ref> presents a method for efficient generation of Taylor coefficients. Rall [58] describes in detail algorithms for automatic differentiation and generation of Taylor coefficients. He also considers applications of automatic differentiation, including applications to ordinary differential equations. <p> i (v j ) i ; (2.4.15) i X (u j ) r (v j ) ir ; and (2.4.16) u j = v j (u j ) i r=1 v j ir : (2.4.17) Similar formulas can be derived for the generation of Taylor coefficients for the standard functions <ref> [50, p. 114] </ref>. Consider the autonomous differential system y 0 (t) = f (y); y (t j ) = y j : (2.4.18) We introduce the sequence of functions f [0] (y) = y; (2.4.19) 1 @y Chapter 2. <p> arithmetic operations in the code list of f is N , then the number of arithmetic operations required for the generation of k Taylor coefficients is between N k and N k (k 1)=2, depending on the ratio of additions, multiplications, and divisions in the code list for f , <ref> [50, pp. 111-112] </ref> (see also Appendix A). Let y (t j ) = y j 2 [y j ]. <p> One can obtain better methods by using polynomial enclosures [45] or more terms in the Taylor series for validation <ref> [50, pp. 100-103] </ref>, [13], [52]. We do not discuss the polynomial enclosure method in this thesis, but propose in Chapter 5 a Taylor series method for validating existence and uniqueness. <p> (3.2.1) and (3.2.3), y j+1 = ^y j + i=1 j f [i] (^y j ) + h k + I + i=1 j J f [i] ; y j ; ^y j ) (3.2.4) This formula is the basis of the interval Taylor series methods of Moore [48], [49], <ref> [50] </ref>, Eijgenraam [19], Lohner [1], [44], [46], and Rihm [61] (see also [52]). Before we explain how (3.2.4) can be used, we consider in x3.2.1 a major difficulty in interval methods: the wrapping effect. 3.2.1 The Wrapping Effect The wrapping effect is clearly illustrated by Moore's example [50], y 0 y <p> Moore [48], [49], <ref> [50] </ref>, Eijgenraam [19], Lohner [1], [44], [46], and Rihm [61] (see also [52]). Before we explain how (3.2.4) can be used, we consider in x3.2.1 a major difficulty in interval methods: the wrapping effect. 3.2.1 The Wrapping Effect The wrapping effect is clearly illustrated by Moore's example [50], y 0 y 0 (3.2.5) The solution of (3.2.5) with an initial condition y 0 is given by y (t) = A (t)y 0 , where A (t) = B cos t sin t 1 A : Let y 0 2 [y 0 ]. <p> Thus, at each step, the enclosing rectangles become larger and larger, but the set fA (t)y 0 j y 0 2 [y 0 ] ; t &gt; t 0 g remains a rectangle of the same size. Moore <ref> [50, p. 134] </ref> showed that at t = 2, the interval inclusion is inflated by a factor of e 2 535, as the stepsize approaches zero. Chapter 3. <p> number of operations, and c f 0 is the ratio of multiplications and divisions to additions and subtractions in these N operations, then to generate k coefficients f [i] , i = 1; : : : ; k, we need c f N k 2 + O (N k) operations <ref> [50, pp. 111-112] </ref> (see Appendix A). Let Ops f [i] be the number of arithmetic operations in the code list for evaluating f [i] from the already computed Taylor coefficients. <p> In x8.3.2, we study empirically the amount of work per step on Van der Pol's equation. Chapter 5 A Taylor Series Method for Validation We introduce a Taylor series method that is based on the validation test suggested by Moore <ref> [50, pp. 100-103] </ref> (see also [13] and [52]) for proving existence and uniqueness of the solution. Our goal is to obtain a method that validates existence and uniqueness with the supplied stepsize, if possible, or a stepsize that is not much smaller than the supplied one. <p> If the solution is enclosed by a parallelepiped, as in the direct method (see x3.2.2), there is a large overestimation, which increases with the steps taken. Constant Stepsizes We integrated (8.3.2) on <ref> [0; 50] </ref> first with an initial condition y (0) = (1; 1) T and then with an initial condition y (0) 2 ([0:9; 1:1]; [0:1; 0:1]) T . We Chapter 8. <p> 10 2 8:3 fi 10 2 3:4 3:0 fi 10 10 6:4 fi 10 22 2:1 fi 10 32 6:3 fi 10 5 4:4 fi 10 2 7:4 fi 10 2 Table 8.8: ITS (17) and IHO (8; 8) on (8.3.2), y (0) = (1; 1) T , t 2 <ref> [0; 50] </ref>, Q (hB) = fl 8;8 k Q 8;8 (hB) k. Chapter 8. <p> 8:1 fi 10 2 3:4 1:7 fi 10 10 3:5 fi 10 22 2:1 fi 10 32 6:3 fi 10 5 4:5 fi 10 2 7:2 fi 10 2 Table 8.9: ITS (17) and IHO (8; 8) on (8.3.2), y (0) 2 ([0:9; 1:1]; [0:1; 0:1]) T , t 2 <ref> [0; 50] </ref>, Q (hB) = fl 8;8 k Q 8;8 (hB) k. Variable Stepsizes We integrated (8.3.2) with y (0) = (1; 1) T for t 2 [0; 400] with a variable step control with T ol = 10 11 . <p> P2, P3, and P4, P1: (8.3.6) with y (0) = 1, for t 2 [0; 20]; P2: y 0 2 = y 1 , with y (0) = (0; 1) T , for t 2 [0; 100]; P3: (8.3.2) with y (0) = (1; 1) T , for t 2 <ref> [0; 50] </ref>; and P4: (8.3.9) with y (0) = (0; 0; 0) T , for t 2 [0; 50]. <p> y 0 2 = y 1 , with y (0) = (0; 1) T , for t 2 [0; 100]; P3: (8.3.2) with y (0) = (1; 1) T , for t 2 <ref> [0; 50] </ref>; and P4: (8.3.9) with y (0) = (0; 0; 0) T , for t 2 [0; 50]. For all of these tests, we used order k = 17 for the ITS method and p = q = 8 for the IHO method, and LEPUS error control with T ol = 10 10 . <p> There has not been a comprehensive study of order control heuristics. Eijgenraam [19, pp. 129-136] describes the only order selection scheme known to the author. Some insights into the problem of order control are given in <ref> [50, pp. 100-118] </ref> and [70]. To develop an order control strategy based on the amount of work per step, we need to estimate this work.
Reference: [51] <author> Ramon E. Moore. </author> <title> A survey of interval methods for differential equations. </title> <booktitle> In Proceedings of the 23rd Conference on Decision and Control (Las Vegas, </booktitle> <year> 1984), </year> <pages> pages 1529-1535. </pages> <publisher> IEEE, </publisher> <year> 1984. </year>
Reference-contexts: We also consider the 17 Chapter 3. Taylor Series Methods for IVPs for ODEs 18 wrapping effect in generating interval Taylor coefficients and the overestimation in one step of ITS methods. Surveys of Taylor series and other interval methods can be found in [4], [14], [15], <ref> [51] </ref>, [54], [60], [70], and [71]. These papers give a "high-level" description of existing methods.
Reference: [52] <author> N. S. Nedialkov, K. R. Jackson, and G. F. Corliss. </author> <title> Validated solutions of initial value problems for ordinary differential equations. </title> <journal> Appl. Math. Comp., </journal> <note> (To appear). Available at http://www.cs.toronto.edu/NA/reports.html. </note>
Reference-contexts: We denote the ith interval Taylor coefficient of y (t) at t j by [y j ] i = f [i] ([y j ]). Chapter 3 Taylor Series Methods for IVPs for ODEs In most validated methods for IVPs for ODEs, each integration step consists of two phases <ref> [52] </ref>: Algorithm I: Compute a stepsize h j and an a priori enclosure [~y j ] of the solution such that y (t; t j ; y j ) is guaranteed to exist for all t 2 [t j ; t j+1 ] and all y j 2 [y j ], <p> Surveys of Taylor series and other interval methods can be found in [4], [14], [15], [51], [54], [60], [70], and [71]. These papers give a "high-level" description of existing methods. A more detailed discussion of Taylor series methods can be found in <ref> [52] </ref>. 3.1 Validating Existence and Uniqueness of the Solution: The Constant Enclosure Method Suppose that at t j we have an enclosure [y j ] of y (t j ; t 0 ; [y 0 ]). <p> One can obtain better methods by using polynomial enclosures [45] or more terms in the Taylor series for validation [50, pp. 100-103], [13], <ref> [52] </ref>. We do not discuss the polynomial enclosure method in this thesis, but propose in Chapter 5 a Taylor series method for validating existence and uniqueness. In x8.4, we show by numerical experiments that our Taylor series method for validation enables larger stepsizes than the constant enclosure method. Chapter 3. <p> [i] (^y j ) + h k + I + i=1 j J f [i] ; y j ; ^y j ) (3.2.4) This formula is the basis of the interval Taylor series methods of Moore [48], [49], [50], Eijgenraam [19], Lohner [1], [44], [46], and Rihm [61] (see also <ref> [52] </ref>). <p> In x8.3.2, we study empirically the amount of work per step on Van der Pol's equation. Chapter 5 A Taylor Series Method for Validation We introduce a Taylor series method that is based on the validation test suggested by Moore [50, pp. 100-103] (see also [13] and <ref> [52] </ref>) for proving existence and uniqueness of the solution. Our goal is to obtain a method that validates existence and uniqueness with the supplied stepsize, if possible, or a stepsize that is not much smaller than the supplied one. <p> Appendix B. A Validated Object-Oriented Solver 126 B.2 Background The area of computing validated solutions of IVPs for ODEs is not as developed as the area of computing approximate solutions. Some of the difficulties that arise in interval methods are discussed in Chapter 3 and <ref> [52] </ref>. With respect to the tools involved, a validated solver is inherently more complex than a classical ODE solver. In addition to an interval-arithmetic package, a major component of a validated solver is the module for automatic generation of interval Taylor coefficients (see xB.4).
Reference: [53] <author> Arnold Neumaier. </author> <title> Interval Methods for Systems of Equations. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: Preliminaries 12 Addition of interval matrices is associative, but multiplication of interval matrices is not associative in general <ref> [53, pp. 80-81] </ref>. Also, the distributive law does not hold in general for interval matrices [53, p. 79]. <p> Preliminaries 12 Addition of interval matrices is associative, but multiplication of interval matrices is not associative in general [53, pp. 80-81]. Also, the distributive law does not hold in general for interval matrices <ref> [53, p. 79] </ref>. <p> If, in addition, f 0 satisfies a Lipschitz condition on D, then for any [a] D, 2 for some constant c 2 0 independent of [a], <ref> [53, pp. 55-56] </ref>. Therefore, the mean-value evaluation is quadratically convergent in the sense that the distance between R (f ; [a]) and f M ([a] ; b) approaches zero as the square of kw ([a])k, as kw ([a])k approaches zero.
Reference: [54] <author> K. L. E. Nickel. </author> <title> Using interval methods for the numerical solution of ODE's. </title> <journal> Z. angew. Math. Mech., </journal> <volume> 66 </volume> <pages> 513-523, </pages> <year> 1986. </year>
Reference-contexts: We also consider the 17 Chapter 3. Taylor Series Methods for IVPs for ODEs 18 wrapping effect in generating interval Taylor coefficients and the overestimation in one step of ITS methods. Surveys of Taylor series and other interval methods can be found in [4], [14], [15], [51], <ref> [54] </ref>, [60], [70], and [71]. These papers give a "high-level" description of existing methods.
Reference: [55] <author> N. Obreschkoff. </author> <title> Neue Quadraturformeln. </title> <journal> Abh. Preuss. Akad. Wiss. Math. Nat. Kl., </journal> <volume> 4, </volume> <year> 1940. </year>
Reference-contexts: Method Development * Taylor series has been the only effective approach for implementing interval methods for IVPs for ODEs. We have developed an interval Hermite-Obreschkoff (IHO) method for computing tight enclosures of the solution. Validated methods based on the Hermite-Obreschkoff formula [28], <ref> [55] </ref>, [56] have not been derived or considered before.
Reference: [56] <author> N. Obreschkoff. </author> <title> Sur le quadrature mecaniques. </title> <journal> Spisanie Bulgar. Akad. Nauk. (Journal of the Bulgarian Academy of Sciences), </journal> <volume> 65 </volume> <pages> 191-289, </pages> <year> 1942. </year>
Reference-contexts: Method Development * Taylor series has been the only effective approach for implementing interval methods for IVPs for ODEs. We have developed an interval Hermite-Obreschkoff (IHO) method for computing tight enclosures of the solution. Validated methods based on the Hermite-Obreschkoff formula [28], [55], <ref> [56] </ref> have not been derived or considered before.
Reference: [57] <author> Hans Olson. </author> <title> Documentation of the structure of Godess. </title> <type> Technical report, </type> <institution> Computer Science, Lund Institute of Technology, S-221 00 Lund, Sweden, </institution> <month> November </month> <year> 1995. </year>
Reference-contexts: Appendix B. A Validated Object-Oriented Solver 127 B.3 Object-Oriented Concepts Since our goal is to build a flexible, easy-to-use, and easy-to-extend package, we have chosen an object-oriented approach in designing VNODE. This is not the first object-oriented design of an ODE solver. The Godess project <ref> [57] </ref> offers a generic ODE solver that implements traditional methods for IVPs for ODEs. Another successful package is Diffpack [43], which is devised for solving partial differential equations. In [43], there is also an example of how to construct an object-oriented ODE solver.
Reference: [58] <author> Louis B. Rall. </author> <title> Automatic Differentiation: Techniques and Applications, </title> <booktitle> volume 120 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: Integration Let f : D ! R n be a continuous function on D R and [a] D. Then, Z a Chapter 2. Preliminaries 15 2.4 Automatic Generation of Taylor Coefficients Moore [50, pp. 107-130] presents a method for efficient generation of Taylor coefficients. Rall <ref> [58] </ref> describes in detail algorithms for automatic differentiation and generation of Taylor coefficients. He also considers applications of automatic differentiation, including applications to ordinary differential equations. Two books containing papers and extensive bibliographies on automatic differentiation are [9] and [23]. <p> These Jacobians can be computed by a forward (TADIFF) or a reverse mode (IADOL-C) of automatic differentiation <ref> [58] </ref>, sparsity may or may not be exploited, and different packages may implement the same method differently; for example, with a tape in ADOL-C or using only the main memory as in TADIFF. <p> They are written in C++ and implement AD through operator overloading. TADIFF and FADBAD are two different packages. TADIFF can generate Taylor coefficients with respect to time. Then, FADBAD can be used to compute Jacobians of Taylor coefficients by applying the forward mode of AD <ref> [58] </ref> to these coefficients. FADBAD and TADIFF are not optimized to handle large and sparse systems. Also, they perform all the work in the main memory. The IADOL-C package is an extension of ADOL-C [25] that allows generic data types.
Reference: [59] <author> A. Ralston. </author> <title> A First Course in Numerical Analysis. </title> <publisher> McGraw-Hill, </publisher> <address> New York, 2nd edition, </address> <year> 1978. </year>
Reference-contexts: However, R p;q (z) is a rational Pade approximation to e z (see for example <ref> [59] </ref>).
Reference: [60] <author> Robert Rihm. </author> <title> Interval methods for initial value problems in ODEs. </title> <editor> In Jurgen Herzberger, editor, </editor> <booktitle> Topics in Validated Computations: Proceedings of the IMACS-GAMM International Workshop on Validated Computations, University of Olden Bibliography 147 burg, Elsevier Studies in Computational Mathematics, </booktitle> <pages> pages 173-207. </pages> <publisher> Elsevier, </publisher> <address> Am-sterdam, New York, </address> <year> 1994. </year>
Reference-contexts: We also consider the 17 Chapter 3. Taylor Series Methods for IVPs for ODEs 18 wrapping effect in generating interval Taylor coefficients and the overestimation in one step of ITS methods. Surveys of Taylor series and other interval methods can be found in [4], [14], [15], [51], [54], <ref> [60] </ref>, [70], and [71]. These papers give a "high-level" description of existing methods. <p> we use the mean-value evaluation (2.3.13) for computing the enclosures of the ranges R f [i] ; [y j ] , i = 1; : : : ; k1, instead of the direct evaluation f [i] ([y j ]), we can often obtain enclosures with smaller widths than in (3.2.2) <ref> [60] </ref>. By applying the mean-value theorem to f [i] at some ^y j 2 [y j ], we have f [i] (y j ) = f [i] (^y j ) + J f [i] ; y j ; ^y j (y j ^y j ); (3.2.3) Chapter 3. <p> Chapter 3. Taylor Series Methods for IVPs for ODEs 26 Wrapping Effect in the Direct Method If we use the direct method to compute the enclosures [y j ], we might obtain unacceptably large interval vectors. This can be seen from the following considerations <ref> [60] </ref>.
Reference: [61] <author> Robert Rihm. </author> <title> On a class of enclosure methods for initial value problems. </title> <journal> Computing, </journal> <volume> 53 </volume> <pages> 369-377, </pages> <year> 1994. </year>
Reference-contexts: i=1 j f [i] (^y j ) + h k + I + i=1 j J f [i] ; y j ; ^y j ) (3.2.4) This formula is the basis of the interval Taylor series methods of Moore [48], [49], [50], Eijgenraam [19], Lohner [1], [44], [46], and Rihm <ref> [61] </ref> (see also [52]).
Reference: [62] <author> Arch D. Robinson. </author> <title> C++ gets faster for scientific computing. </title> <journal> Computers in Physics, </journal> <volume> 10(5) </volume> <pages> 458-462, </pages> <month> Sep/Oct </month> <year> 1996. </year>
Reference-contexts: Here, we discuss an important performance problem: the pairwise evaluation of arithmetic expression with arguments of array types (e.g., matrices and vectors). More detailed treatment of this and other problems can be found in <ref> [62] </ref>, [75], and [76]. In C++, executing overloaded arithmetic operations between array data types creates temporaries, which can introduce a significant overhead, particularly for small objects.
Reference: [63] <author> J. Rohn. </author> <title> NP-hardness results for linear algebraic problems with interval data. </title> <editor> In J. Herzberger, editor, </editor> <booktitle> Topics in Validated Computations, volume 5 of Studies in Computational Mathematics, </booktitle> <pages> pages 463-471, </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1994. </year>
Reference-contexts: However, it is easier to compute the enclosure of the inverse of a point matrix than of an interval matrix. In fact, computing a tight enclosure of the inverse of an interval matrix is NP hard in general <ref> [63] </ref>. 4. In (4.1.27), we intersect ^y (0) j+1; [ffi j+1 ] and [y j+1 ].
Reference: [64] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: It is realized either by a complete containment of an object Y within another object X or by a pointer from X to Y. The notation in these figures is similar to that suggested in <ref> [64] </ref>. In the next two subsections, we list the problem and method classes and provide brief explanations. Here, we do not discuss the classes for generating Taylor coefficients in VNODE. A detailed description of VNODE will be given in the documentation of the code at http://www.cs.toronto.edu/NA.
Reference: [65] <author> Michael J. Schulte, Vitaly Zelov, Ahmet Akkas, and James Craig Burley. </author> <title> The interval-enhanced GNU Fortran compiler. Reliable Computing, </title> <note> (Submitted), Octo-ber 1998. </note>
Reference-contexts: The Fortran 90 version of INTLIB uses operator overloading. For references and comments on other available packages, see for example [34] or [38]. Recently, an interval extension of the Gnu Fortran compiler was reported <ref> [65] </ref>, where intervals are supported as an intrinsic data type. PROFIL/BIAS seems to be the fastest interval package. In comparison with other such packages, including INTLIB, PROFIL/BIAS is about one order of magnitude faster [38]. <p> Each interval addition in this loop involves two changes of the rounding Appendix B. A Validated Object-Oriented Solver 132 mode. In modern RISC architectures, rounding mode switches cost nearly the same or even more than floating-point operations [38], <ref> [65] </ref>. The approach of PROFIL/BIAS is to minimize these switches. Suppose that we want to compute in PROFIL/BIAS C = A + B, where A, B, and C are vectors of the same dimensions.
Reference: [66] <author> Lawrence F. Shampine. </author> <title> Numerical solution of ordinary differential equations. </title> <publisher> Chap-man & Hall, </publisher> <address> New York, </address> <year> 1994. </year>
Reference: [67] <author> B. Speelpenning. </author> <title> Compiling Fast Partial Derivatives of Functions Given by Algorithms. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> January </month> <year> 1980. </year>
Reference-contexts: Also, they perform all the work in the main memory. The IADOL-C package is an extension of ADOL-C [25] that allows generic data types. ADOL-C can compute Taylor coefficients by using the forward mode and their Jacobians by applying the reverse mode <ref> [67] </ref> to these coefficients. The basic data type of ADOL-C is double. To use a new data type in IADOL-C, the user has to overload the arithmetic and comparison operations and the standard functions for that data type. Then, using IADOL-C is essentially the same as using ADOL-C.
Reference: [68] <author> H. Spreuer and E. Adams. </author> <title> On the existence and the verified determination of homoclinic and heteroclinic orbits of the origin for the Lorenz system. </title> <journal> Computing Suppl., </journal> <volume> 9 </volume> <pages> 233-246, </pages> <year> 1993. </year> <note> Bibliography 148 </note>
Reference-contexts: There are situations when guaranteed bounds are desired or needed. For example, a guaranteed bound of the solution could be used to prove a theorem <ref> [68] </ref>. Also, some calculations may be critical to the safety or reliability of a system. Therefore, it may be necessary or desirable to ensure that the true solution is within the computed bounds.
Reference: [69] <author> Ole Stauning. </author> <title> Automatic validation of numerical solutions. </title> <type> Technical Report IMM-PHD-1997-36, </type> <institution> IMM, Lyngby, Denmark, </institution> <month> October </month> <year> 1997. </year> <note> ADIODES is available at http://www.imm.dtu.dk/~os/ADIODES.tar.gz. </note>
Reference-contexts: The main difficulty in the first phase is how to validate existence and uniqueness with a given stepsize. The constant enclosure method [19] is the most commonly used method for validation [44], <ref> [69] </ref>. However, the stepsizes allowed by this method are restricted to "Euler steps"; thus, reducing the efficiency of any method using it. The main obstacle in the second phase is how to reduce the so-called "wrapping effect." Currently, Lohner's QR-factorization method is the standard scheme for reducing it. <p> Furthermore, we want to avoid as many stepsize reductions in this method as possible. Usually, a Taylor series method for validation enables larger stepsizes than the constant enclosure method, which has been used in the past [44], <ref> [69] </ref>. As we pointed out in x3.1, the constant enclosure method restricts the stepsizes to Euler steps. We also combine better algorithms for computing tight enclosures, such as Lohner's method and the IHO method, with our algorithm for validating existence and uniqueness. <p> In addition to an interval-arithmetic package, a major component of a validated solver is the module for automatic generation of interval Taylor coefficients (see xB.4). Currently, there are three available packages for computing guaranteed bounds on the solution of an IVP for an ODE: AWA [44], ADIODES <ref> [69] </ref> and COSY INFINITY [8]. We briefly summarize each in turn. AWA is an implementation of Lohner's method (x3.2.5) and the constant enclosure approach (x3.1). This package is written in Pascal-XSC [37], an extension of Pascal for scientific computing.
Reference: [70] <author> Hans J. Stetter. </author> <title> Algorithms for the inclusion of solutions of ordinary initial value problems. </title> <editor> In Jaram ir Vosmansky and Milos Zlamal, editors, </editor> <booktitle> Equadiff 6: Proceedings of the International Conference on Differential Equations and Their Applications (Brno, 1985), volume 1192 of Lecture Notes in Mathematics, </booktitle> <pages> pages 85-94. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: We also consider the 17 Chapter 3. Taylor Series Methods for IVPs for ODEs 18 wrapping effect in generating interval Taylor coefficients and the overestimation in one step of ITS methods. Surveys of Taylor series and other interval methods can be found in [4], [14], [15], [51], [54], [60], <ref> [70] </ref>, and [71]. These papers give a "high-level" description of existing methods. <p> There has not been a comprehensive study of order control heuristics. Eijgenraam [19, pp. 129-136] describes the only order selection scheme known to the author. Some insights into the problem of order control are given in [50, pp. 100-118] and <ref> [70] </ref>. To develop an order control strategy based on the amount of work per step, we need to estimate this work.
Reference: [71] <author> Hans J. Stetter. </author> <title> Validated solution of initial value problems for ODEs. </title> <editor> In Christian Ullrich, editor, </editor> <booktitle> Computer Arithmetic and Self-Validating Numerical Methods, </booktitle> <pages> pages 171-187. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Taylor Series Methods for IVPs for ODEs 18 wrapping effect in generating interval Taylor coefficients and the overestimation in one step of ITS methods. Surveys of Taylor series and other interval methods can be found in [4], [14], [15], [51], [54], [60], [70], and <ref> [71] </ref>. These papers give a "high-level" description of existing methods. <p> We define local and global excess by * j = q (U j ; y (t j ; t j1 ; U j1 )) and (6.1.1) 75 Chapter 6. Estimating and Controlling the Excess 76 respectively [19, p. 87, p. 100], <ref> [71] </ref>, where q (; ) is the Hausdorff distance between two sets given by (2.2.1). 6.1.1 Controlling the Global Excess Similar to the standard numerical methods for IVPs for ODEs, our approach in VNODE is to allow the user to specify a tolerance Tol. <p> We try to achieve (6.1.3) by controlling the local excess per unit step (LEPUS) <ref> [71] </ref>. That is, we require * j h j1 T ol (6.1.4) on each step. Eijgenraam shows [19, p. 115] that fl j r=1 where ff is a constant depending on the problem. This constant may be negative since the logarithmic norm is used in its definition [19, p. 46].
Reference: [72] <author> Stephen J. Sullivan and Benjamon G. Zorn. </author> <title> Numerical analysis using nonprocedural paradigms. </title> <journal> ACM TOMS, </journal> <volume> 21(3) </volume> <pages> 267-298, </pages> <month> Sept </month> <year> 1995. </year>
Reference-contexts: A good discussion of object-oriented concepts, analysis, and design can be found in [11]. An excellent book on advanced C++ styles and idioms is [12]. A study of nonprocedural paradigms for numerical analysis, including object-oriented ones, is presented in <ref> [72] </ref>. Data Abstraction In the object model, a software system can be viewed as a collection of objects that interact with each other to achieve a desired functionality. An object is an instance of a class, which defines the structure and behavior of its objects.
Reference: [73] <author> R. S. Varga. </author> <title> On higher order stable implicit methods for solving parabolic differential equations. </title> <journal> J. Math. and Phys., </journal> <volume> 40 </volume> <pages> 220-231, </pages> <year> 1961. </year>
Reference-contexts: = p + 2, then jR p;q (z)j &lt; 1, and R p;q (z) ! 0 as jzj ! 1 [18]; and * if q &gt; p and z 2 R, z &lt; 0, then jR p;q (z)j &lt; 1, and R p;q (z) ! 0 as jzj ! 1 <ref> [73] </ref> (see also [42, pp. 236-237]). Consider (4.3.5) and (4.3.11). For the ITS method, jT k1 (h)j &lt; 1 when h is in the stability region of T k1 (z).
Reference: [74] <author> T. Veldhuizen. </author> <title> Expression templates. C++ Report, </title> <booktitle> 7(5) </booktitle> <pages> 26-31, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Furthermore, this execution introduces three loops. Clearly, it would be better to compute this sum in one loop without temporaries. In Fortran 90, mathematical arrays are represented as elementary types and optimization is possible at the compiler level. Because of better optimizing compilers and template techniques <ref> [74] </ref>, [76], C++ is becoming more competitive for scientific computing. A good technique for reducing the overhead in the pairwise evaluation of expressions involving arrays is to use expression templates [74]. The expression template technique is based on performing compile-time transformation of the code using templates. <p> Because of better optimizing compilers and template techniques <ref> [74] </ref>, [76], C++ is becoming more competitive for scientific computing. A good technique for reducing the overhead in the pairwise evaluation of expressions involving arrays is to use expression templates [74]. The expression template technique is based on performing compile-time transformation of the code using templates. With this technique, expressions containing vectors and matrices can be evaluated in a single pass without allocating temporaries. For example, with expression templates, it is possible to achieve a loop fusion [74], allowing the above <p> use expression templates <ref> [74] </ref>. The expression template technique is based on performing compile-time transformation of the code using templates. With this technique, expressions containing vectors and matrices can be evaluated in a single pass without allocating temporaries. For example, with expression templates, it is possible to achieve a loop fusion [74], allowing the above sum to be evaluated in a single loop: for ( int i = 1; i &lt;= N; i++ ) However, executing this loop in interval arithmetic may not be the best solution for the following reason.
Reference: [75] <author> T. Veldhuizen. </author> <title> Scientific computing: C++ versus Fortran. </title> <journal> Dr. Dobb's Journal, </journal> <volume> 34, </volume> <month> November </month> <year> 1997. </year>
Reference-contexts: Here, we discuss an important performance problem: the pairwise evaluation of arithmetic expression with arguments of array types (e.g., matrices and vectors). More detailed treatment of this and other problems can be found in [62], <ref> [75] </ref>, and [76]. In C++, executing overloaded arithmetic operations between array data types creates temporaries, which can introduce a significant overhead, particularly for small objects.
Reference: [76] <author> T. L. Veldhuizen and M. E. Jernigan. </author> <title> Will C++ be faster than Fortran? In Proceedings of the 1st International Scientific Computing in Object-Oriented Parallel Environments (ISCOPE'97), </title> <booktitle> Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year> <note> Bibliography 149 </note>
Reference-contexts: Here, we discuss an important performance problem: the pairwise evaluation of arithmetic expression with arguments of array types (e.g., matrices and vectors). More detailed treatment of this and other problems can be found in [62], [75], and <ref> [76] </ref>. In C++, executing overloaded arithmetic operations between array data types creates temporaries, which can introduce a significant overhead, particularly for small objects. <p> Furthermore, this execution introduces three loops. Clearly, it would be better to compute this sum in one loop without temporaries. In Fortran 90, mathematical arrays are represented as elementary types and optimization is possible at the compiler level. Because of better optimizing compilers and template techniques [74], <ref> [76] </ref>, C++ is becoming more competitive for scientific computing. A good technique for reducing the overhead in the pairwise evaluation of expressions involving arrays is to use expression templates [74]. The expression template technique is based on performing compile-time transformation of the code using templates.
Reference: [77] <author> G. Wanner. </author> <title> On the integration of stiff differential equations. </title> <type> Technical report, </type> <institution> Universite de Geneve, Section de Mathematique, </institution> <address> 1211 Geneve 24th, Suisse, </address> <month> October </month> <year> 1976. </year>
Reference-contexts: In standard numerical methods, Hermite-Obreschkoff methods are known to be suitable for stiff systems [22], [24], <ref> [77] </ref>, [78], but in the interval case, they still have a restriction on the stepsize. <p> Chapter 4 An Interval Hermite-Obreschkoff Method In this chapter, we derive an interval Hermite-Obreschkoff (IHO) method and compare it with the "standard" interval Taylor series methods. Hermite-Obreschkoff methods are usually considered for computing an approximate solution of a stiff problem [22], [24], <ref> [77] </ref>, [78]. Here, we are not interested in obtaining a method that is targeted specifically to solving stiff problems|our purpose is to obtain a general-purpose method that produces better enclosures at a smaller cost than the explicit validated methods based on Taylor series. <p> The system (4.1.11) defines the point (q; p) Hermite-Obreschkoff method [22], [24], [27, p. 277], <ref> [77] </ref>, [78]. Remarks 1. If p &gt; 0 and q = 0, we obtain an explicit Taylor series formula: y j+1 = i=0 j f [i] (y j ) + p+1 (p + 1)! Chapter 4. An Interval Hermite-Obreschkoff Method 41 2.
Reference: [78] <author> G. Wanner. </author> <title> On the integration of stiff differential equations. In Proceedings of the Colloquium on Numerical Analysis, </title> <journal> volume 37 of Internat. Ser. Numer. Math., </journal> <pages> pages 209-226, </pages> <address> Basel, 1977. </address> <publisher> Birkhauser. </publisher>
Reference-contexts: In standard numerical methods, Hermite-Obreschkoff methods are known to be suitable for stiff systems [22], [24], [77], <ref> [78] </ref>, but in the interval case, they still have a restriction on the stepsize. <p> Chapter 4 An Interval Hermite-Obreschkoff Method In this chapter, we derive an interval Hermite-Obreschkoff (IHO) method and compare it with the "standard" interval Taylor series methods. Hermite-Obreschkoff methods are usually considered for computing an approximate solution of a stiff problem [22], [24], [77], <ref> [78] </ref>. Here, we are not interested in obtaining a method that is targeted specifically to solving stiff problems|our purpose is to obtain a general-purpose method that produces better enclosures at a smaller cost than the explicit validated methods based on Taylor series. <p> The system (4.1.11) defines the point (q; p) Hermite-Obreschkoff method [22], [24], [27, p. 277], [77], <ref> [78] </ref>. Remarks 1. If p &gt; 0 and q = 0, we obtain an explicit Taylor series formula: y j+1 = i=0 j f [i] (y j ) + p+1 (p + 1)! Chapter 4. An Interval Hermite-Obreschkoff Method 41 2.
Reference: [79] <author> Wenhong Yang and George Corliss. </author> <title> Bibliography of computational differentiation. </title> <editor> In Martin Berz, Christian H. Bischof, George F. Corliss, and Andreas Griewank, editors, </editor> <title> Computational Differentiation: Techniques, </title> <booktitle> Applications, and Tools, </booktitle> <pages> pages 393-418. </pages> <publisher> SIAM, </publisher> <address> Philadelphia, Penn., </address> <year> 1996. </year>
Reference-contexts: A Validated Object-Oriented Solver 129 4. efficiency. In this section, we discuss each in turn. B.4.1 Software for Automatic Generation of Interval Taylor Coefficients Although packages for automatic differentiation (AD) are available (see for example [33] and <ref> [79] </ref>), to date, only two free packages for automatic generation of interval Taylor coefficients for the solution of an ODE and the Jacobians of these coefficients are known to the author. These are the FADBAD/TADIFF [5], [6] and IADOL-C [31] packages.
References-found: 79

