URL: http://polaris.cs.uiuc.edu/reports/1497.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/polaris/rep2.html
Root-URL: http://www.cs.uiuc.edu
Title: Parallelism in Loops Containing Recurrences  
Author: Bill Pottenger 
Date: June 12, 1996  
Abstract-found: 0
Intro-found: 1
Reference: [BDE + 96] <author> William Blume, Ramon Doallo, Rudolf Eigenmann, John Grout, Jay Hoeflinger, Thomas Lawrence, Jaejin Lee, David Padua, Yunheung Paek, William Pottenger, Lawrence Rauchwerger, and Peng Tu. </author> <title> Advanced Program Restructuring for High-Performance 2 128 bytes on the Challenge 7 Computers with Polaris. </title> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercom--puting Res. & Dev., </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Extensive analysis of Grand Challenge codes from NCSA, codes from the SPEC CFP95 Benchmark Suite, and codes from the Perfect Club Suite, has revealed the presence of a number of loops in which recurrences prevent DOALL parallelization. During a recent review of the Polaris restructurer <ref> [BDE + 96] </ref> approximately 500 loops from programs in the aforementioned test suite were identified as serial. Of these, approximately 35% involve an explicitly coded recurrence, reduction, or induction for which Polaris was unable to determine a parallel form.
Reference: [PCMR94] <author> D. Pryor, S. Cuccaro, M. Mascagni, and M. Robinson. </author> <title> Implementation of a Portable and Reproducible Parallel Pseudorandom Number Generator. </title> <publisher> IEEE, </publisher> <year> 1994. </year>
Reference-contexts: This section of code has an explicit recurrence relation of the form a i = a i103 + 1 a i250 mod 2 31 1. It is an implementation of a lagged-Fibonacci pseudorandom number generator with recursion parameters of (103, 250) <ref> [PCMR94] </ref>. The conditional subtraction performs a modulo operation which results in an integer in the range [0; 2 31 2], a member of the representative residue class [0; 2 31 2].
Reference: [PE95] <author> Bill Pottenger and Rudolf Eigenmann. </author> <title> Idiom Recognition in the Polaris Parallelizing Compiler. </title> <booktitle> Proceedings of the 9th ACM International Conference on Supercomputing, </booktitle> <address> Barcelona, Spain, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: Nonetheless, there are many cases where symbolic techniques such as this have been successfully employed <ref> [PE95] </ref>. For this particular recurrence, partial hoisting was employed to break the dependence arcs in two of the enclosing loops. Simply put, the computation of the pseudorandom numbers was hoisted out of inner loops and placed in an outer loop. <p> Polaris has the ability to recognize and transform additive reductions into a parallel form. However, the current reduction recognition pass does not recognize max or min reductions. Nonetheless, the transformation is straightforward, and is pictured below based on the technique employing expanded reductions <ref> [PE95] </ref>: do j = 1, procs rxm e (j) = 0.0 enddo do parallel k = 2, n-1 do i = 2, n-1 rxm e (thread-num ()) = max (rxm e (thread-num ()),abs (rx (i, k))) rym e (thread-num ()) = max (rym e (thread-num ()),abs (ry (i, k))) enddo enddo
Reference: [Pot94] <author> William Morton Pottenger. </author> <title> Induction Variable Substitution and Reduction Recognition in the Polaris Parallelizing Compiler. </title> <type> Master's thesis, </type> <institution> Univ of Illinois at Urbana-Champaign, Cntr for Supercomputing Res & Dev, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: In the following section, several techniques will be presented which have proven effective in the parallelization of loops containing recurrences. 2 Techniques for Parallelizing Recurrences 2.1 Symbolic Computation of Closed Form <ref> [Pot94] </ref> includes a survey of symbolic techniques for determining closed forms for recurrences involving scalar induction variables.
Reference: [Tu95] <author> Peng Tu. </author> <title> Automatic Array Privatization and Demand-Driven Symbolic Analysis. </title> <type> PhD thesis, </type> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <month> May </month> <year> 1995. </year> <month> 8 </month>
Reference-contexts: These were handled by explicitly synchronizing access to ireg. 2.3 Overlapping Loop Execution using Semi-private Variables Another interesting transformation involved what we have termed semi-private variables. The priva-tization of variables often allows dependence arcs to be broken <ref> [Tu95] </ref>. In SU2COR do60 a pattern occurs in which a variable is private from a certain program point in a loop to the end of the loop. Consider the following example: DO K=1,N DO J=1,N = . . . A (J,I-1) . . .
References-found: 5

