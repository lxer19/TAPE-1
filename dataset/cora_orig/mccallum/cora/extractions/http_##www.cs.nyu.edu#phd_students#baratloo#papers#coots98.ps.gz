URL: http://www.cs.nyu.edu/phd_students/baratloo/papers/coots98.ps.gz
Refering-URL: http://www.cs.nyu.edu/phd_students/baratloo/html/publications.html
Root-URL: http://www.cs.nyu.edu
Title: Filterfresh: Hot Replication of Java RMI Server Objects  
Author: Arash Baratloo P. Emerald Chung Yennun Huang Sampath Rangarajan Shalini Yajnik 
Address: New York University, 251 Mercer Street 600 Mountain Avenue New York, NY 10012 Murray Hill, NJ 07974  
Affiliation: Department of Computer Science Lucent Technologies Bell Laboratories  
Abstract: This paper presents the design and implementation of a Java package called Fil-terfresh for building replicated fault-tolerant servers. Maintaining the correctness and integrity of replicated servers is supported by a GroupManager object instantiated with each replica to form a logical group. The Group Managers use a Group Membership algorithm to maintain a consistent group view and a Reliable Multicast mechanism to communicate with other Group Managers. We then demonstrate how Filterfresh can be integrated into the Java RMI facilities. First we use the GroupManager class to construct a fault-tolerant RMI registry called FT Registry|a group of replicated RMI registry servers. Second, we describe our implementation of the FT Unicast|a client-side mechanism that tolerates and masks server failures below the stub layer, transparent to the client. We also present initial performance results, and discuss how general purpose RMI servers can be made highly available using the Filterfresh package. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Beedubail, A. Karmarkar, A. Guri-jala, W. Marti, and U. Pooch. </author> <title> An Algorithm for Supporting Fault Tolerant Objects in Distributed Object-Oriented Operating Systems. </title> <booktitle> In Proc. Fourth International Workshop on Object-Oriented Operating Systems, </booktitle> <year> 1995. </year>
Reference-contexts: Based on the success of such systems, same mechanisms are used in Orbix+ISIS [9] and Elec-tra [13] for adding fault-tolerance to CORBA, in the work proposed by <ref> [1] </ref> for adding fault-tolerance to other Object-Oriented systems, and in systems such as [12, 14] in providing fault-tolerant distributed Name Servers. Our challenge here is to integrate such mechanisms into the Java RMI system with minimal changes while staying 100% Pure Java.
Reference: [2] <author> K. Birman, A. Schiper and P. Stephen-son. </author> <title> Light-weight Causal and Atomic Group Multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <month> August </month> <year> 1991. </year>
Reference-contexts: Therefore, in the absent of process crashes, every group operation is atomic and group members observe the events in the same order. The multicast protocol that we implemented can be categorized as ack-based since messages require explicit acknowledgement. See <ref> [2, 10, 16, 11] </ref> for other protocols that are not ack-based but provide the same semantics.
Reference: [3] <author> K. Birman and R. Van Renesse. </author> <title> Reliable Distributed Computing with ISIS Toolkit, </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: To achieve this, we adopted the hot replication scheme, i.e., updates to any node are reliably propagated to all other nodes, and changes are made consistently on all sites. This approach ensures that the registry data sets are strongly synchronized. We use the virtual synchrony model <ref> [3] </ref> to implement FT Registry, our group of replicated RMI registry servers. Virtual synchrony and its underlying process group operations are provided by toolkits such as Isis [3] and Transis [6], in Java middle-ware systems such as iBus [15], and in operating systems such as Amoeba [11] for building fault-tolerant applications. <p> This approach ensures that the registry data sets are strongly synchronized. We use the virtual synchrony model <ref> [3] </ref> to implement FT Registry, our group of replicated RMI registry servers. Virtual synchrony and its underlying process group operations are provided by toolkits such as Isis [3] and Transis [6], in Java middle-ware systems such as iBus [15], and in operating systems such as Amoeba [11] for building fault-tolerant applications.
Reference: [4] <author> N. Brown, C. Kindel. </author> <title> Distributed Component Object Model Protocol - DCOM/1.0. </title> <type> Internet Draft, </type> <year> 1996. </year>
Reference-contexts: 1 Introduction Distributed object technologies have become popular in developing distributed applications. Among these, object technologies fl baratloo@cs.nyu.edu. This work was done while the author was a summer intern at Bell Laboratories. y emerald,yen,sampath,shalini@research.bell labs.com. such as CORBA [17], DCOM <ref> [4] </ref>, and Java Remote Method Invocation (RMI) [22, 20] are the most popular. Although these middle-ware platforms ease the development of distributed applications, they do not directly improve the reliability of these applications.
Reference: [5] <author> T. Chandra, V. Hadzilacos and S. Toueg. </author> <title> Impossibility of group membership in asynchronous systems. </title> <type> Technical Report 95-1533, </type> <institution> Computer Science Department, Cornell University, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: It is well known that it is impossible to have a deterministic, correct and terminating algorithm to achieve consensus [7] in the presence of even a single failure and to build reliable failure detectors <ref> [5] </ref>. In the presence of these negative results, this protocol guarantees correctness if and when it terminates|that is, it will block until a consistent state can be constructed.
Reference: [6] <author> D. Dolev, D. Malki, and R. </author> <title> Strong. A Framework for Partitionable Membership Service. </title> <booktitle> In Proc. of the 15th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1996. </year>
Reference-contexts: This approach ensures that the registry data sets are strongly synchronized. We use the virtual synchrony model [3] to implement FT Registry, our group of replicated RMI registry servers. Virtual synchrony and its underlying process group operations are provided by toolkits such as Isis [3] and Transis <ref> [6] </ref>, in Java middle-ware systems such as iBus [15], and in operating systems such as Amoeba [11] for building fault-tolerant applications.
Reference: [7] <author> M. Fischer, N. Lynch and M. Peterson. </author> <title> Impossibility of Distributed Consensus with One Faulty Process. </title> <journal> Journal of the ACM, </journal> <month> April </month> <year> 1985. </year>
Reference-contexts: Notice that the process of constructing a new group view will block until enough surviving group members can be found. It is well known that it is impossible to have a deterministic, correct and terminating algorithm to achieve consensus <ref> [7] </ref> in the presence of even a single failure and to build reliable failure detectors [5]. In the presence of these negative results, this protocol guarantees correctness if and when it terminates|that is, it will block until a consistent state can be constructed.
Reference: [8] <author> S. Hirano, Y. Yasu, and H. Igarashi. </author> <title> Performance Evaluation of Popular Distributed Object Technologies for Java. </title> <booktitle> In Proc. of ACM Workshop on Java for High-Performance Network Computing, </booktitle> <year> 1998. </year>
Reference-contexts: We attribute some of this to inefficient Java threads implementation under Linux. For example, we found that threads blocked on user inputs are never preempted|the work around seemed to have been expensive. Furthermore, we used object serialization for constructing low-level control messages, and as reported in <ref> [8] </ref>, there is a high overhead associated with object serialization due to inefficient buffering and copying of the data. Considering that we sacrificed efficiency for simplicity in choosing the multicast algorithm, the GroupManager class shows reasonable scalability.
Reference: [9] <institution> IONA Technologies. </institution> <note> http://www--usa.iona.com/Press/PR/Isis.html. </note>
Reference-contexts: Based on the success of such systems, same mechanisms are used in Orbix+ISIS <ref> [9] </ref> and Elec-tra [13] for adding fault-tolerance to CORBA, in the work proposed by [1] for adding fault-tolerance to other Object-Oriented systems, and in systems such as [12, 14] in providing fault-tolerant distributed Name Servers.
Reference: [10] <author> W. Jia. </author> <title> Implementation of a Reliable Multicast Protocol. Software Practices and Experience, </title> <month> July </month> <year> 1997. </year>
Reference-contexts: Therefore, in the absent of process crashes, every group operation is atomic and group members observe the events in the same order. The multicast protocol that we implemented can be categorized as ack-based since messages require explicit acknowledgement. See <ref> [2, 10, 16, 11] </ref> for other protocols that are not ack-based but provide the same semantics.
Reference: [11] <author> M. Kaashoek. </author> <title> Group Communication in Distributed Computer Systems. </title> <type> Ph.D Thesis, </type> <institution> Vrije Universiteit, Netherlands, </institution> <year> 1992. </year>
Reference-contexts: Virtual synchrony and its underlying process group operations are provided by toolkits such as Isis [3] and Transis [6], in Java middle-ware systems such as iBus [15], and in operating systems such as Amoeba <ref> [11] </ref> for building fault-tolerant applications. <p> Therefore, in the absent of process crashes, every group operation is atomic and group members observe the events in the same order. The multicast protocol that we implemented can be categorized as ack-based since messages require explicit acknowledgement. See <ref> [2, 10, 16, 11] </ref> for other protocols that are not ack-based but provide the same semantics. <p> However, a client application can, at any time, initiate a reset group view operation by invoking the public method resetView (). Once a GroupManager object enters a reset view mode it blocks all other operations until a new view is installed. Our reset view protocol is based on <ref> [11] </ref>. It runs in two phases. The first phase of the protocol determines a new group view, i.e. establishes which members are non-faulty and chooses the group leader; the second phase of the protocol brings the members up-to-date, and then installs the view determined in the first phase.
Reference: [12] <author> M. Kaashoek, A. Tanenbaum, and K. Verstoep. </author> <title> Using Group Communication to Implement a Fault-Tolerant Directory Service. </title> <booktitle> In Proc. of the 13th International Conference on Distributed Computing Systems, </booktitle> <year> 1993. </year>
Reference-contexts: Based on the success of such systems, same mechanisms are used in Orbix+ISIS [9] and Elec-tra [13] for adding fault-tolerance to CORBA, in the work proposed by [1] for adding fault-tolerance to other Object-Oriented systems, and in systems such as <ref> [12, 14] </ref> in providing fault-tolerant distributed Name Servers. Our challenge here is to integrate such mechanisms into the Java RMI system with minimal changes while staying 100% Pure Java. Our FT Registry, in addition to being able to tolerate failures itself, provides the building block for fault-tolerant RMI application servers.
Reference: [13] <author> S. Maffeis. </author> <title> Adding Group Communication and Fault-Tolerance to CORBA. </title> <booktitle> In Proceeding of USENIX Conference on Object-Oriented Technologies, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Based on the success of such systems, same mechanisms are used in Orbix+ISIS [9] and Elec-tra <ref> [13] </ref> for adding fault-tolerance to CORBA, in the work proposed by [1] for adding fault-tolerance to other Object-Oriented systems, and in systems such as [12, 14] in providing fault-tolerant distributed Name Servers.
Reference: [14] <author> S. Maffeis. </author> <title> A Fault-Tolerant CORBA Name Server. </title> <booktitle> In Proc. of Symposium on Reliable Distributed Systems, </booktitle> <year> 1996. </year>
Reference-contexts: Based on the success of such systems, same mechanisms are used in Orbix+ISIS [9] and Elec-tra [13] for adding fault-tolerance to CORBA, in the work proposed by [1] for adding fault-tolerance to other Object-Oriented systems, and in systems such as <ref> [12, 14] </ref> in providing fault-tolerant distributed Name Servers. Our challenge here is to integrate such mechanisms into the Java RMI system with minimal changes while staying 100% Pure Java. Our FT Registry, in addition to being able to tolerate failures itself, provides the building block for fault-tolerant RMI application servers.
Reference: [15] <author> S. Maffeis. </author> <title> iBus The Java Intranet Software Bus. </title> <address> http://www.softwired.ch/ibus.htm. </address>
Reference-contexts: We use the virtual synchrony model [3] to implement FT Registry, our group of replicated RMI registry servers. Virtual synchrony and its underlying process group operations are provided by toolkits such as Isis [3] and Transis [6], in Java middle-ware systems such as iBus <ref> [15] </ref>, and in operating systems such as Amoeba [11] for building fault-tolerant applications.
Reference: [16] <author> L. Moser, P. Melliar-Smith, D. Agarwal, R. Budhia and C. Lingley-Papadopou-los. Totem: </author> <title> A Fault-Tolerant Multicast Group Communication System". </title> <journal> Communications of the ACM, </journal> <volume> vol. 39, no. 4, </volume> <pages> pp. 54-63, </pages> <month> April, </month> <year> 1996. </year>
Reference-contexts: Therefore, in the absent of process crashes, every group operation is atomic and group members observe the events in the same order. The multicast protocol that we implemented can be categorized as ack-based since messages require explicit acknowledgement. See <ref> [2, 10, 16, 11] </ref> for other protocols that are not ack-based but provide the same semantics.
Reference: [17] <author> Object Management Group. </author> <title> The Common Object Request Broker: </title> <booktitle> Architecture and Specification 2.1, </booktitle> <year> 1997. </year>
Reference-contexts: 1 Introduction Distributed object technologies have become popular in developing distributed applications. Among these, object technologies fl baratloo@cs.nyu.edu. This work was done while the author was a summer intern at Bell Laboratories. y emerald,yen,sampath,shalini@research.bell labs.com. such as CORBA <ref> [17] </ref>, DCOM [4], and Java Remote Method Invocation (RMI) [22, 20] are the most popular. Although these middle-ware platforms ease the development of distributed applications, they do not directly improve the reliability of these applications.
Reference: [18] <author> F. Schneider. </author> <title> Implementing Fault-Tolerant Services Using the State Machine Approach: A Tutorial. </title> <journal> ACM Computing Surveys, </journal> <month> December </month> <year> 1990. </year>
Reference-contexts: Second, the RMI registry becomes a single point of failure. We address both problems by providing a replicated registry service, and by maintaining a consistent state among all replicas through the state machine approach <ref> [18] </ref>. Our implementation consists of the FTRegistry interface, and LocateFTRegistry and FTRegistryImpl classes. We also extends the standard interface by introducing the multiBind () method. The multiBind () method is a mechanism for multiple replicas to register under the same name.
Reference: [19] <author> R. Stevens. </author> <title> UNIX Network Programming, </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: The atomicity assures that that an event is either seen by all group members or none. The total ordering assures that all group members observe the events in the same relative order. The protocol assumes an unreliable point-to-point message delivery. The communication is implemented with UDP <ref> [19] </ref>. UDP datagrams are unreliable, and hence, appropriate mechanisms such as acknowledgement, retries, and timeouts are provided at a higher level to ensure correct group operations. We chose UDP as opposed to other protocols, such as TCP, for three reasons.
Reference: [20] <author> Sun Microsystems. </author> <title> Remote Method Invocation Specification, </title> <note> 1997. http://java.sun.com/products/jdk/1.2/ docs/guide/rmi/index.html. </note>
Reference-contexts: 1 Introduction Distributed object technologies have become popular in developing distributed applications. Among these, object technologies fl baratloo@cs.nyu.edu. This work was done while the author was a summer intern at Bell Laboratories. y emerald,yen,sampath,shalini@research.bell labs.com. such as CORBA [17], DCOM [4], and Java Remote Method Invocation (RMI) <ref> [22, 20] </ref> are the most popular. Although these middle-ware platforms ease the development of distributed applications, they do not directly improve the reliability of these applications. As a result, application developers have to implement their own mechanisms to improve the reliability and availability of their applications.
Reference: [21] <author> Y. Wang, Y. Huang, K. Vo, E. Chung and C. Kintala. </author> <title> Checkpoint and its applications. </title> <booktitle> In Proceedings of the 25th IEEE Fault Tolerant Computing Symposium, </booktitle> <month> June </month> <year> 1995. </year>
Reference: [22] <author> A. Wollrath, R. Riggs and J. Waldo. </author> <title> A Distributed Object Model for the Java System. </title> <journal> USENIX Journal, </journal> <month> Fall </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Distributed object technologies have become popular in developing distributed applications. Among these, object technologies fl baratloo@cs.nyu.edu. This work was done while the author was a summer intern at Bell Laboratories. y emerald,yen,sampath,shalini@research.bell labs.com. such as CORBA [17], DCOM [4], and Java Remote Method Invocation (RMI) <ref> [22, 20] </ref> are the most popular. Although these middle-ware platforms ease the development of distributed applications, they do not directly improve the reliability of these applications. As a result, application developers have to implement their own mechanisms to improve the reliability and availability of their applications. <p> The RMI architecture consists of three layers as shown in Figure 1: the stub/skeleton layer, the remote reference layer (RRL) and the transport layer <ref> [22] </ref>. On the server side, for an interface to be invoked remotely, it has to be derived from the Remote class. The object that implements this interface may derive from the UnicastRemoteObject class of the RMI package. The current UnicastRemoteObject uses TCP for low-level transport.
References-found: 22

