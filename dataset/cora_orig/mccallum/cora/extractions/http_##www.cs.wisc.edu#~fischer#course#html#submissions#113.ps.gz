URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/113.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/
Root-URL: http://www.cs.wisc.edu
Title: Word count (detex paper.tex j wc -w) excluding main text. A New Framework for Elimination-Based
Author: Vugranam Sreedhar Guang Gao Yong-fong Lee Correspondence: Vugranam C. Sreedhar 
Keyword: Subject: Data flow analysis, incremental analysis, iterated dominance frontiers.  
Address: 11000 Wolfe Road, MS 42U5 Cupertino, California 95014-0678  CA 95014.  Santa Clara, CA 95052-8119  
Affiliation: California Language Lab  School of Computer Science, McGill University, Montreal, Canada. Currently at HP Company, Cupertino,  School of Computer Science, McGill University, Montreal, Canada. Intel Corporation,  
Note: appendices 5453. This extended abstract contains 12.5 pages of main text, including figures. Figures occupy approximately 3 pages. The rest are bibliography and appendices, which are included as supplementary materials. The major points of the paper can be understood from the 13.5 pages of the  
Email: email: sreedhar@cup.hp.com  
Phone: tel: (408) 447-5475  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Burke, M. </author> <title> An interval-based approach to exhaustive and incremental interprocedural data-flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems 12, </journal> <month> 3 (July </month> <year> 1990), </year> <pages> 341-395. </pages>
Reference-contexts: Although not described in this paper, we can easily extend our framework to interprocedural setting similar to Burke's <ref> [1] </ref>. Incremental analyses have many applications in program development environments (e.g. Matlab) and aggressive optimizing compilers, especially those performing interprocedural optimizations. One reason why incremental analysis has not paved its way into production compilers is due to the complex nature of existing methods. <p> See [18, 17] for more details. 12 Burke proposes a method for elimination-based incremental data flow analysis that uses interval graphs for updating and propagating data flow solutions <ref> [1] </ref>. His approach can only handle structural changes (to flowgraphs) that do not modify the depth-first spanning tree of the flowgraph. Marlowe and Ryder propose a hybrid incremental method that combines iterative and elimination methods [10]. They first identify strongly connected components in the flowgraph.
Reference: [2] <author> Burke, M. G., and Ryder, B. G. </author> <title> A critical analysis of incremental iterative data flow analysis algorithms. </title> <journal> IEEE Transactions on Software Engineering 16, </journal> <month> 7 (July </month> <year> 1990), </year> <pages> 723-728. </pages>
Reference-contexts: 1 Introduction There are two classical approaches to incremental data flow analysis: one based on iterative methods [11] and the other based on elimination methods [16, 3]. Marlowe and others have extensively studied the relative merits of one approach over the other <ref> [9, 14, 10, 2] </ref>. Marlowe has also proposed a hybrid scheme that combines the two approaches [10, 9]. In this paper we propose a new approach to incremental data flow analysis.
Reference: [3] <author> Carroll, M., and Ryder, B. G. </author> <title> Incremental data flow update via attribute and dominator updates. </title> <booktitle> In ACM SIGPLAN-SIGACT Symposium on the Principles of Programming Languages (January 1988), </booktitle> <pages> pp. 274-284. </pages>
Reference-contexts: 1 Introduction There are two classical approaches to incremental data flow analysis: one based on iterative methods [11] and the other based on elimination methods <ref> [16, 3] </ref>. Marlowe and others have extensively studied the relative merits of one approach over the other [9, 14, 10, 2]. Marlowe has also proposed a hybrid scheme that combines the two approaches [10, 9]. In this paper we propose a new approach to incremental data flow analysis. <p> To incrementally update data flow solutions we use simple properties of dominance frontiers and iterated dominance frontiers. Previous work that is most relevant to ours is due to Carroll and Ryder <ref> [3] </ref>. We will first give a detailed comparison of our approach with theirs, and then compare ours with other related work. Carroll and Ryder's method is based on the reduce and borrow concept for updating data flow solutions [3]. <p> that is most relevant to ours is due to Carroll and Ryder <ref> [3] </ref>. We will first give a detailed comparison of our approach with theirs, and then compare ours with other related work. Carroll and Ryder's method is based on the reduce and borrow concept for updating data flow solutions [3]. They reduce a monotone data flow problem to an attributed (dominator) tree problem, and then borrow the well-known Reps's attribute update algorithm for updating data flow solutions [12, 13].
Reference: [4] <author> Choi, J. D., Sarkar, V., and Schonberg, E. </author> <title> Incremental computation of static single assignment form. </title> <type> Unpublished manuscript, </type> <year> 1994. </year>
Reference-contexts: previous elimination-based incremental algorithms, our algorithm can handle arbitrary non structural and structural program changes, including irreducibility, within the same framework. * We also developed a simple incremental algorithm for maintaining the dominance frontier relation | which can be used beyond the scope of this paper (e.g., incremental SSA form <ref> [4] </ref>). Although not described in this paper, we can easily extend our framework to interprocedural setting similar to Burke's [1]. Incremental analyses have many applications in program development environments (e.g. Matlab) and aggressive optimizing compilers, especially those performing interprocedural optimizations.
Reference: [5] <author> Cytron, R., Ferrante, J., Rosen, B. K., Wegman, M. N., and Zadeck, F. K. </author> <title> Efficiently computing static single assignment form and control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems 13, </journal> <month> 4 (October </month> <year> 1991), </year> <pages> 452-490. </pages>
Reference-contexts: Our approach uses simple properties of iterated dominance frontiers to update data flow solutions. Since Iterated dominance frontiers have been used in production compilers for constructing SSA form <ref> [5] </ref>, we expect that our method can be more easily implemented in production optimizing compilers. In Section 3 we outline our eager elimination method. In Section 4 we lay the foundation of our approach to incremental data flow analysis. <p> Let p 2 Children (w), then the new DF (w) is given by the following formula <ref> [17, 5] </ref>. <p> DF up (p) = fqjq 2 DF (p) and q:level idom (p):levelg DF (w) = DF local (w) [ [ p2Children (w) DF up (p) (2) Notice that the above formula is equivalent to the one given by Cytron et al. for (exhaustively) computing the dominance frontiers of all nodes <ref> [5] </ref>.
Reference: [6] <author> Graham, S. L., and Wegman, M. </author> <title> A fast and usually linear algorithm for global flow analysis. </title> <journal> Journal of the ACM 23, </journal> <month> 1 (January </month> <year> 1976), </year> <pages> 172-202. </pages>
Reference-contexts: They reduce a monotone data flow problem to an attributed (dominator) tree problem, and then borrow the well-known Reps's attribute update algorithm for updating data flow solutions [12, 13]. They use the Graham-Wegman elimination method as a starting point for mapping data flow problems to attributed dominator tree problems <ref> [6] </ref>. They decorate each node in the dominator tree with its (1) initial flow equation, (2) final flow equation, and (3) correct solution. These decorations are treated as attributes of the dominator tree. Once they construct an attributed dominator tree, they modify Reps's algorithm for updating the attributes [12, 13].
Reference: [7] <author> Kam, J. B., and Ullman, J. D. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> Journal of the ACM 23, </journal> <month> 1 (January </month> <year> 1976), </year> <pages> 158-171. </pages>
Reference: [8] <author> Kildall, G. A. </author> <title> A unified approach to global program optimization. </title> <booktitle> In Conference Record of the First ACM Symposium on Principles of Programming Languages (Boston, </booktitle> <address> Massachusetts, </address> <year> 1973), </year> <journal> ACM SIGACT and SIGPLAN, </journal> <pages> pp. 194-206. </pages>
Reference: [9] <author> Marlowe, T. J. </author> <title> Data Flow Analysis and Incremental Iteration. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <address> New Brunswick, New Jersey, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: 1 Introduction There are two classical approaches to incremental data flow analysis: one based on iterative methods [11] and the other based on elimination methods [16, 3]. Marlowe and others have extensively studied the relative merits of one approach over the other <ref> [9, 14, 10, 2] </ref>. Marlowe has also proposed a hybrid scheme that combines the two approaches [10, 9]. In this paper we propose a new approach to incremental data flow analysis. <p> Marlowe and others have extensively studied the relative merits of one approach over the other [9, 14, 10, 2]. Marlowe has also proposed a hybrid scheme that combines the two approaches <ref> [10, 9] </ref>. In this paper we propose a new approach to incremental data flow analysis. It is based on our eager elimination method that uses DJ graphs for solving a system of data flow equations [20, 17]. <p> It is important to remember that all incremental algorithms rely on having correct solutions at all nodes prior to incremental changes. Once a change is effected, incremental algorithms will update (ideally) only those solutions that are affected due to the change <ref> [9] </ref>. Let us use ff F y to denote the data flow solution at each node y prior to an incremental change. That is, ff F y is the final flow solution at y before the change.
Reference: [10] <author> Marlowe, T. J., and Ryder, B. G. </author> <title> An efficient hybrid algorithm for incremental data flow analysis. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages (January 1990), ACM SIGACT and SIGPLAN, </booktitle> <pages> pp. 184-196. </pages>
Reference-contexts: 1 Introduction There are two classical approaches to incremental data flow analysis: one based on iterative methods [11] and the other based on elimination methods [16, 3]. Marlowe and others have extensively studied the relative merits of one approach over the other <ref> [9, 14, 10, 2] </ref>. Marlowe has also proposed a hybrid scheme that combines the two approaches [10, 9]. In this paper we propose a new approach to incremental data flow analysis. <p> Marlowe and others have extensively studied the relative merits of one approach over the other [9, 14, 10, 2]. Marlowe has also proposed a hybrid scheme that combines the two approaches <ref> [10, 9] </ref>. In this paper we propose a new approach to incremental data flow analysis. It is based on our eager elimination method that uses DJ graphs for solving a system of data flow equations [20, 17]. <p> His approach can only handle structural changes (to flowgraphs) that do not modify the depth-first spanning tree of the flowgraph. Marlowe and Ryder propose a hybrid incremental method that combines iterative and elimination methods <ref> [10] </ref>. They first identify strongly connected components in the flowgraph. Then they use iteration within individual components but propagate data flow information among components using an elimination-like method.
Reference: [11] <author> Pollock, L., and Soffa, M. L. </author> <title> An incremental version of iterative data flow analysis. </title> <journal> IEEE Transactions on Software Engineering 11, </journal> <month> 4 (April </month> <year> 1989). </year>
Reference-contexts: 1 Introduction There are two classical approaches to incremental data flow analysis: one based on iterative methods <ref> [11] </ref> and the other based on elimination methods [16, 3]. Marlowe and others have extensively studied the relative merits of one approach over the other [9, 14, 10, 2]. Marlowe has also proposed a hybrid scheme that combines the two approaches [10, 9].
Reference: [12] <author> Reps, T. </author> <title> Optimal-time incremental semantic analysis for syntax-directed editors. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages (January 1982), ACM SIGACT and SIGPLAN. </booktitle> <pages> 13 </pages>
Reference-contexts: Carroll and Ryder's method is based on the reduce and borrow concept for updating data flow solutions [3]. They reduce a monotone data flow problem to an attributed (dominator) tree problem, and then borrow the well-known Reps's attribute update algorithm for updating data flow solutions <ref> [12, 13] </ref>. They use the Graham-Wegman elimination method as a starting point for mapping data flow problems to attributed dominator tree problems [6]. They decorate each node in the dominator tree with its (1) initial flow equation, (2) final flow equation, and (3) correct solution. <p> They decorate each node in the dominator tree with its (1) initial flow equation, (2) final flow equation, and (3) correct solution. These decorations are treated as attributes of the dominator tree. Once they construct an attributed dominator tree, they modify Reps's algorithm for updating the attributes <ref> [12, 13] </ref>. Reps's original algorithm can only handle updates to attributed parse trees, which are derived from attribute grammars. Since dominator trees are not parse trees, Carroll and Ryder generalize Reps's algorithm in order to handle arbitrary trees. <p> Since dominator trees are not parse trees, Carroll and Ryder generalize Reps's algorithm in order to handle arbitrary trees. Reps's original algorithm can handle updates only if the dependence graph of the attributed tree is acyclic <ref> [12, 13] </ref>. Carroll and Ryder show that if the original flowgraph is reducible then the dependence graph of the attributed dominator tree is also acyclic. <p> To ensure optimality the attributes are propagated on a projected graph of the dependence graph, called the sub-ordinate and superior characteristic graph <ref> [12, 13] </ref>. Carroll and Ryder show how to construct these characteristic graphs for the attributed dominator problem, and use them for updating and propagating the final data flow solutions. The sub-parse tree replacement in Reps's algorithm corresponds to restructuring of the dominator tree in Carroll and Ryder's method.
Reference: [13] <author> Reps, T., Teitelbaum, T., and Demers, A. </author> <title> Incremental context-dependent analysis for language-based editors. </title> <journal> ACM Transactions on Programming Languages and Systems 5, </journal> <month> 3 (July </month> <year> 1983), </year> <pages> 449-477. </pages>
Reference-contexts: Carroll and Ryder's method is based on the reduce and borrow concept for updating data flow solutions [3]. They reduce a monotone data flow problem to an attributed (dominator) tree problem, and then borrow the well-known Reps's attribute update algorithm for updating data flow solutions <ref> [12, 13] </ref>. They use the Graham-Wegman elimination method as a starting point for mapping data flow problems to attributed dominator tree problems [6]. They decorate each node in the dominator tree with its (1) initial flow equation, (2) final flow equation, and (3) correct solution. <p> They decorate each node in the dominator tree with its (1) initial flow equation, (2) final flow equation, and (3) correct solution. These decorations are treated as attributes of the dominator tree. Once they construct an attributed dominator tree, they modify Reps's algorithm for updating the attributes <ref> [12, 13] </ref>. Reps's original algorithm can only handle updates to attributed parse trees, which are derived from attribute grammars. Since dominator trees are not parse trees, Carroll and Ryder generalize Reps's algorithm in order to handle arbitrary trees. <p> Since dominator trees are not parse trees, Carroll and Ryder generalize Reps's algorithm in order to handle arbitrary trees. Reps's original algorithm can handle updates only if the dependence graph of the attributed tree is acyclic <ref> [12, 13] </ref>. Carroll and Ryder show that if the original flowgraph is reducible then the dependence graph of the attributed dominator tree is also acyclic. <p> To ensure optimality the attributes are propagated on a projected graph of the dependence graph, called the sub-ordinate and superior characteristic graph <ref> [12, 13] </ref>. Carroll and Ryder show how to construct these characteristic graphs for the attributed dominator problem, and use them for updating and propagating the final data flow solutions. The sub-parse tree replacement in Reps's algorithm corresponds to restructuring of the dominator tree in Carroll and Ryder's method.
Reference: [14] <author> Ryder, B. G., Marlowe, T. G., and Paull, M. C. </author> <title> Conditions for incremental iteration: Examples and counterexamples. </title> <booktitle> Science of Computer Programming 11, </booktitle> <month> 1 (October </month> <year> 1988), </year> <pages> 1-15. </pages>
Reference-contexts: 1 Introduction There are two classical approaches to incremental data flow analysis: one based on iterative methods [11] and the other based on elimination methods [16, 3]. Marlowe and others have extensively studied the relative merits of one approach over the other <ref> [9, 14, 10, 2] </ref>. Marlowe has also proposed a hybrid scheme that combines the two approaches [10, 9]. In this paper we propose a new approach to incremental data flow analysis.
Reference: [15] <author> Ryder, B. G., and Paull, M. C. </author> <title> Elimination algorithms for data flow analysis. </title> <journal> ACM Computing Surveys 18, </journal> <month> 3 (September </month> <year> 1986), </year> <pages> 277-316. </pages>
Reference-contexts: This is again true for DJ graphs|a DJ graph is constructed only for the reachable portion of the flowgraph. Therefore, 1 We mainly follow Ryder and Paull's notation in <ref> [15] </ref> to express data flow equations. 2 Note that a flowgraph does not need to be connected; that is, some nodes may not be reachable from the START node. 3 We will assume that START is a distinguished start node with no incoming edges. 1 whenever we use the phrase "a
Reference: [16] <author> Ryder, B. G., and Paull, M. C. </author> <title> Incremental data-flow analysis algorithms. </title> <journal> ACM Transactions on Programming Languages and Systems 10, </journal> <month> 1 (January </month> <year> 1988), </year> <pages> 1-50. </pages>
Reference-contexts: 1 Introduction There are two classical approaches to incremental data flow analysis: one based on iterative methods [11] and the other based on elimination methods <ref> [16, 3] </ref>. Marlowe and others have extensively studied the relative merits of one approach over the other [9, 14, 10, 2]. Marlowe has also proposed a hybrid scheme that combines the two approaches [10, 9]. In this paper we propose a new approach to incremental data flow analysis.
Reference: [17] <author> Sreedhar, V. C. </author> <title> Efficient Program Analyses Using DJ Graphs. </title> <type> PhD thesis, </type> <institution> School of Computer Science, McGill University, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: Marlowe has also proposed a hybrid scheme that combines the two approaches [10, 9]. In this paper we propose a new approach to incremental data flow analysis. It is based on our eager elimination method that uses DJ graphs for solving a system of data flow equations <ref> [20, 17] </ref>. A novel aspect of our incremental method is that we found a surprisingly simple relation between (iterated) dominance frontiers and incremental data flow analysis. At the heart of our framework is the DJ graph representation [19, 21, 17]. <p> A novel aspect of our incremental method is that we found a surprisingly simple relation between (iterated) dominance frontiers and incremental data flow analysis. At the heart of our framework is the DJ graph representation <ref> [19, 21, 17] </ref>. A DJ graph is just the dominator tree of a flowgraph augmented with join edges from the flowgraph (see Figure 1). A flowgraph edge is a join edge (J edge) if it has no corresponding edge in the dominator tree. <p> A flowgraph edge is a join edge (J edge) if it has no corresponding edge in the dominator tree. A dominator tree edge is called a D edge. We have successfully used DJ graphs for solving a number of problems <ref> [19, 21, 20, 17] </ref>. In this paper we demonstrate its application to incrementally updating data flow information. The major contributions in this paper are as follows: * Our algorithm is conceptually very simple. <p> This convention applies to other properties as well. 2 3 Exhaustive Eager Elimination Method: An Overview Our exhaustive eager elimination consists of two phases: (1) bottom-up DJ graph reduction and variable elimination, called the elimination phase; and (2) top-down propagation of data flow solutions, called the propagation phase <ref> [20, 17] </ref>. Elimination Phase Unlike previous elimination methods, which typically reduces a flowgraph to a single node, we reduce the DJ graph of a flowgraph to its dominator tree in a bottom-up fashion, ordered by the levels of nodes on the dominator tree. <p> We can easily show that if an SCC contains more than one node, then all the nodes will be at the same level in the DF graph <ref> [17] </ref>. Next we describe how to construct the final flow equations for all affected nodes. The projection graph P roj (y) helps provide an ordering in which we can update the final flow equations at the affected nodes. <p> Let p 2 Children (w), then the new DF (w) is given by the following formula <ref> [17, 5] </ref>. <p> But, unlike Carroll and Ryder's method, we use simple properties of dominance frontiers and iterated dominance frontiers for updating the final data flow solutions, and these properties are valid for both reducible and irreducible flowgraphs. 13 Surprisingly, representative edges are related to dominance frontiers. See <ref> [18, 17] </ref> for more details. 12 Burke proposes a method for elimination-based incremental data flow analysis that uses interval graphs for updating and propagating data flow solutions [1]. His approach can only handle structural changes (to flowgraphs) that do not modify the depth-first spanning tree of the flowgraph.
Reference: [18] <author> Sreedhar, V. C., and Gao, G. R. </author> <title> An elimination-based approach to incremental data flow analysis. </title> <type> Tech. Rep. ACAPS Memo 94, </type> <institution> McGill University, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: Correctness proofs and complexity analysis are given in <ref> [18] </ref>, which is made available on our web site: http:""www-acaps.cs.mcgill.ca/~sreedhar/pubs.html. 9 Conclusion and Related Work In this paper we proposed a new approach for incremental data flow analysis based on elimination methods. To incrementally update data flow solutions we use simple properties of dominance frontiers and iterated dominance frontiers. <p> But, unlike Carroll and Ryder's method, we use simple properties of dominance frontiers and iterated dominance frontiers for updating the final data flow solutions, and these properties are valid for both reducible and irreducible flowgraphs. 13 Surprisingly, representative edges are related to dominance frontiers. See <ref> [18, 17] </ref> for more details. 12 Burke proposes a method for elimination-based incremental data flow analysis that uses interval graphs for updating and propagating data flow solutions [1]. His approach can only handle structural changes (to flowgraphs) that do not modify the depth-first spanning tree of the flowgraph.
Reference: [19] <author> Sreedhar, V. C., and Gao, G. R. </author> <title> A linear time algorithm for placing -nodes. </title> <note> In ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (January 1995). A longer version to appear in Journal of Programming Languages. </note>
Reference-contexts: A novel aspect of our incremental method is that we found a surprisingly simple relation between (iterated) dominance frontiers and incremental data flow analysis. At the heart of our framework is the DJ graph representation <ref> [19, 21, 17] </ref>. A DJ graph is just the dominator tree of a flowgraph augmented with join edges from the flowgraph (see Figure 1). A flowgraph edge is a join edge (J edge) if it has no corresponding edge in the dominator tree. <p> A flowgraph edge is a join edge (J edge) if it has no corresponding edge in the dominator tree. A dominator tree edge is called a D edge. We have successfully used DJ graphs for solving a number of problems <ref> [19, 21, 20, 17] </ref>. In this paper we demonstrate its application to incrementally updating data flow information. The major contributions in this paper are as follows: * Our algorithm is conceptually very simple.
Reference: [20] <author> Sreedhar, V. C., Gao, G. R., and Lee, Y. </author> <title> Efficient data flow analysis using DJ graphs: Elimination methods revisited. </title> <type> Tech. Rep. ACAPS Memo 93, </type> <institution> McGill University, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: Marlowe has also proposed a hybrid scheme that combines the two approaches [10, 9]. In this paper we propose a new approach to incremental data flow analysis. It is based on our eager elimination method that uses DJ graphs for solving a system of data flow equations <ref> [20, 17] </ref>. A novel aspect of our incremental method is that we found a surprisingly simple relation between (iterated) dominance frontiers and incremental data flow analysis. At the heart of our framework is the DJ graph representation [19, 21, 17]. <p> A flowgraph edge is a join edge (J edge) if it has no corresponding edge in the dominator tree. A dominator tree edge is called a D edge. We have successfully used DJ graphs for solving a number of problems <ref> [19, 21, 20, 17] </ref>. In this paper we demonstrate its application to incrementally updating data flow information. The major contributions in this paper are as follows: * Our algorithm is conceptually very simple. <p> This convention applies to other properties as well. 2 3 Exhaustive Eager Elimination Method: An Overview Our exhaustive eager elimination consists of two phases: (1) bottom-up DJ graph reduction and variable elimination, called the elimination phase; and (2) top-down propagation of data flow solutions, called the propagation phase <ref> [20, 17] </ref>. Elimination Phase Unlike previous elimination methods, which typically reduces a flowgraph to a single node, we reduce the DJ graph of a flowgraph to its dominator tree in a bottom-up fashion, ordered by the levels of nodes on the dominator tree. <p> Once we determine the solution for the root node, we propagate this information in a top-down fashion on the dominator tree to compute the solution for every other node. The complete algorithm for eager elimination is given in <ref> [20] </ref>. Handling Irreducibility In our exhaustive eager elimination method, irreducibility is detected at level i whenever we cannot apply any of the E rules, but there are still J edges (originating at the level) to be eliminated. <p> Equations H F 3 and H F 4 are mutually recursive. Once their closure is determined, their final flow equations will be expressed in terms of only variable O 1 on the RHS <ref> [20] </ref>.
Reference: [21] <author> Sreedhar, V. C., Gao, G. R., and Lee, Y. </author> <title> Incremental computation of dominator trees. </title> <booktitle> In ACM SIGPLAN Workshop on Intermediate Representation (in conjunction with the ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages) (January 1995). Also appears in SIGPLAN Notices Volume 30, </booktitle> <volume> Number 4, </volume> <year> 1995. </year>
Reference-contexts: A novel aspect of our incremental method is that we found a surprisingly simple relation between (iterated) dominance frontiers and incremental data flow analysis. At the heart of our framework is the DJ graph representation <ref> [19, 21, 17] </ref>. A DJ graph is just the dominator tree of a flowgraph augmented with join edges from the flowgraph (see Figure 1). A flowgraph edge is a join edge (J edge) if it has no corresponding edge in the dominator tree. <p> A flowgraph edge is a join edge (J edge) if it has no corresponding edge in the dominator tree. A dominator tree edge is called a D edge. We have successfully used DJ graphs for solving a number of problems <ref> [19, 21, 20, 17] </ref>. In this paper we demonstrate its application to incrementally updating data flow information. The major contributions in this paper are as follows: * Our algorithm is conceptually very simple. <p> In <ref> [21] </ref> we gave a simple algorithm for updating the dominator tree of a flowgraph. A brief introduction to our incremental dominator algorithm is given in the next section. Here we will use that result for updating the DF graph. <p> For both the insertion and the deletion case, we can determine the exact set of affected nodes when x ! y is updated, even prior to restructuring the DJ graph <ref> [21] </ref>. In this paper we will use the notation DomAffected (y) to represent the (exact) set of affected nodes when x ! y is updated [21]. In [21] we showed, for the insertion case, that the new immediate dominator of all the nodes that are DomAffected is nca (x; y), the <p> the deletion case, we can determine the exact set of affected nodes when x ! y is updated, even prior to restructuring the DJ graph <ref> [21] </ref>. In this paper we will use the notation DomAffected (y) to represent the (exact) set of affected nodes when x ! y is updated [21]. In [21] we showed, for the insertion case, that the new immediate dominator of all the nodes that are DomAffected is nca (x; y), the nearest common ancestor of x and y on the dominator tree. <p> case, we can determine the exact set of affected nodes when x ! y is updated, even prior to restructuring the DJ graph <ref> [21] </ref>. In this paper we will use the notation DomAffected (y) to represent the (exact) set of affected nodes when x ! y is updated [21]. In [21] we showed, for the insertion case, that the new immediate dominator of all the nodes that are DomAffected is nca (x; y), the nearest common ancestor of x and y on the dominator tree. For the deletion case, a single node does not immediately dominate all the affected nodes. <p> For the deletion case, a single node does not immediately dominate all the affected nodes. But we can still determine the new immediate dominators of the affected nodes prior to restructuring the DJ graph <ref> [21] </ref>. 6.2 Updating Dominance Frontiers: Insertion of an Edge In this section we give a simple algorithm for updating the dominance frontiers of all the nodes that are possibly affected (i.e., in DFAffectedI (y)), when an edge x ! y is inserted in the flowgraph. 11 The key question to ask <p> In <ref> [21] </ref> we argued that a node w 2 DomAffected (y) will move up in the dominator tree after the DJ graph is updated. When this happens, the dominance frontiers of all nodes that dominate node w or x prior to updating will possibly be affected. <p> Once we have determined the set of possibly affected nodes, next we update the dominance frontiers of these affected nodes. For this we will first update the DJ graph using the algorithm given in <ref> [21] </ref>. Next, for each node w 2 DFAffectedI (y), we will recompute DF (w) in a bottom-up fashion on the new DJ graph as follows: Let w be a node in DFAffectedI (y) and assume that the dominance frontiers of all the child nodes of w are correct. <p> Let us insert an edge from node 2 to node 5. The resulting flowgraph and the updated DJ graph are shown in Figure 5. Using the algorithm given in <ref> [21] </ref>, the set DomAffected (5) is f5; 7g, and nca (2; 5) = 1. Next we compute the DFAffectedI (5). This set contains any node that dominates some node in f2g [ DomAffected (5) (i.e., 2, 5, and 7), and is itself strictly dominated by nca (2; 5) (i.e., 1).
References-found: 21

