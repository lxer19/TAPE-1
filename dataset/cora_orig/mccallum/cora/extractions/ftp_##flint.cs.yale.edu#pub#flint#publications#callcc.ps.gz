URL: ftp://flint.cs.yale.edu/pub/flint/publications/callcc.ps.gz
Refering-URL: http://daffy.cs.yale.edu/users/shao-zhong/papers.html
Root-URL: http://www.cs.yale.edu
Email: fshao,trifonovg@cs.yale.edu  
Title: Type-Directed Continuation Allocation  
Author: Zhong Shao and Valery Trifonov 
Address: New Haven, CT 06520-8285  
Affiliation: Dept. of Computer Science Yale University  
Abstract: Suppose we translate two different source languages, L 1 and L 2 , into the same intermediate language; can they safely interoperate in the same address space and under the same runtime system? If L 1 supports first-class continuations (call/cc) and L 2 does not, can L 2 programs call arbitrary L 1 functions? Would the fact of possibly calling L 1 impose restrictions on the implementation strategy of L 2 ? Can we compile L 1 functions that do not invoke call/cc using more efficient techniques borrowed from the L 2 implementation? Our view is that the implementation of a common intermediate language ought to support the so-called pay-as-you-go efficiency: first-order monomorphic functions should be compiled as efficiently as in C and assembly languages, even though they may be passed to arbitrary polymorphic functions that support advanced control primitives (e.g. call/cc). In this paper, we present a typed intermediate language with effect and resource annotations, ensuring the safety of inter-language calls while allowing the compiler to choose continuation allocation strategies.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Bruggeman, O. Waddell, and K. Dybvig. </author> <title> Representing control in the presence of one-shot continuations. </title> <booktitle> In Proc. ACM SIGPLAN '96 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 99107, </pages> <address> New York, June 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: This allows the view of external functions as effect-polymorphic without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations <ref> [2, 8, 22, 1] </ref>, monads and modular interpreters [30, 12, 29, 13], typed intermediate languages [7, 26, 20, 17, 16, 3], and foreign function call interface [9, 18]. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. <p> Our system limits the quantification over a finite set of resourcesthis allows us to take advantage of the effect-resource relationship to support advanced compilation strategies. Efficient call/cc. Many people have worked on designing various strategies to support efficient implementation of first-class continuations <ref> [2, 8, 22, 1] </ref>. To support a reasonably efficient call/cc, compilers today mostly use stack chunks (a linked list of smaller stacks) [2, 8] or they simply heap allocate all activation records [22]. <p> The techniques presented in this paper provide opportunities to support both efficient call/cc and interoperability with code that use sequential stacks. Threads. Implementing threads does not necessarily require first-class continuations but only an equivalent of one-shot continuations <ref> [1] </ref>. A finer distinction between these classes of continuations is useful, however the issues of incorporating linearity in the type system to ensure safety in the presence of one-shot continua tions are beyond the scope of this paper. Monads and modular interpreters.
Reference: [2] <author> W. D. Clinger, A. H. Hartheimer, and E. M. </author> <title> Ost. Implementation strategies for continuations. </title> <booktitle> In 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 124131, </pages> <address> New York, June 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: This allows the view of external functions as effect-polymorphic without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations <ref> [2, 8, 22, 1] </ref>, monads and modular interpreters [30, 12, 29, 13], typed intermediate languages [7, 26, 20, 17, 16, 3], and foreign function call interface [9, 18]. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. <p> Our system limits the quantification over a finite set of resourcesthis allows us to take advantage of the effect-resource relationship to support advanced compilation strategies. Efficient call/cc. Many people have worked on designing various strategies to support efficient implementation of first-class continuations <ref> [2, 8, 22, 1] </ref>. To support a reasonably efficient call/cc, compilers today mostly use stack chunks (a linked list of smaller stacks) [2, 8] or they simply heap allocate all activation records [22]. <p> Efficient call/cc. Many people have worked on designing various strategies to support efficient implementation of first-class continuations [2, 8, 22, 1]. To support a reasonably efficient call/cc, compilers today mostly use stack chunks (a linked list of smaller stacks) <ref> [2, 8] </ref> or they simply heap allocate all activation records [22]. Both of these representations are incompatible with those used by traditional languages such as C and C++ where activation records are allocated on a sequential stack. First-class continuations thus always impose restrictions and interoperability challenges to the underlying compiler.
Reference: [3] <author> A. Dimock, R. Muller, F. Turbak, and J. B. Wells. </author> <title> Strongly typed flow-directed representation transformations. </title> <booktitle> In Proc. 1997 ACM SIGPLAN International Conference on Functional Programming (ICFP'97), </booktitle> <pages> pages 1124. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters [30, 12, 29, 13], typed intermediate languages <ref> [7, 26, 20, 17, 16, 3] </ref>, and foreign function call interface [9, 18]. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. The idea of using effect-based type systems to support language interoperation was first proposed by Gifford and Lucassen [5, 6]. <p> Typed intermediate languages. Typed intermediate languages have received much attention lately, especially in the HOT (i.e., higher-order and typed) language community. However, recent work <ref> [7, 14, 21, 17, 3, 16, 15] </ref> has mostly focused on the theoretical foundations and general language design issues. The type system in this paper focused on the problem of compiling multiple source languages into a common typed intermediate format.
Reference: [4] <author> C. Flanagan, A. Sabry, B. F. Duba, and M. Felleisen. </author> <title> The essence of compiling with continuations. </title> <booktitle> In Proc. ACM SIGPLAN '93 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 237247, </pages> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: only if r; ; ` e e : We will also use the function TypeOf with the same arguments, returning the type only. 4.2 Dynamic Semantics The operational semantics of RL (Figure 4) is defined by means of a variant of the tail-call-safe C a EK machine (Flanagan et al. <ref> [4] </ref>). The machine configuration is a tuple he; E; O; i where e is the current term to be evaluated, E is the environment mapping variables to machine values, O is a heap of objects (closures), and is a tuple of machine resources.
Reference: [5] <author> D. Gifford and J. Lucassen. </author> <title> Integrating functional and imperative programming. </title> <booktitle> In 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <address> New York, </address> <month> August </month> <year> 1986. </year> <note> ACM Press. </note>
Reference-contexts: In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. The idea of using effect-based type systems to support language interoperation was first proposed by Gifford and Lucassen <ref> [5, 6] </ref>. Along this direction, many researchers have worked on various kinds of effect systems and effect inference algorithms [10, 11, 23, 24, 28]. The main novelty of our effect system is that we imposed a resource-based upper-bound to the effect variables.
Reference: [6] <author> D. K. Gifford et al. </author> <title> FX-87 reference manual. </title> <type> Technical Report MIT/LCS/TR-407, </type> <institution> M.I.T. Laboratory for Computer Science, </institution> <month> September </month> <year> 1987. </year>
Reference-contexts: This allows the view of external functions as effect-polymorphic without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference <ref> [6, 10, 11, 23, 24] </ref>, efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters [30, 12, 29, 13], typed intermediate languages [7, 26, 20, 17, 16, 3], and foreign function call interface [9, 18]. <p> In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. The idea of using effect-based type systems to support language interoperation was first proposed by Gifford and Lucassen <ref> [5, 6] </ref>. Along this direction, many researchers have worked on various kinds of effect systems and effect inference algorithms [10, 11, 23, 24, 28]. The main novelty of our effect system is that we imposed a resource-based upper-bound to the effect variables.
Reference: [7] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 130141, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters [30, 12, 29, 13], typed intermediate languages <ref> [7, 26, 20, 17, 16, 3] </ref>, and foreign function call interface [9, 18]. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. The idea of using effect-based type systems to support language interoperation was first proposed by Gifford and Lucassen [5, 6]. <p> Typed intermediate languages. Typed intermediate languages have received much attention lately, especially in the HOT (i.e., higher-order and typed) language community. However, recent work <ref> [7, 14, 21, 17, 3, 16, 15] </ref> has mostly focused on the theoretical foundations and general language design issues. The type system in this paper focused on the problem of compiling multiple source languages into a common typed intermediate format.
Reference: [8] <author> R. Hieb, R. K. Dybvig, and C. Bruggeman. </author> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In Proc. ACM SIGPLAN '90 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 6677, </pages> <address> New York, 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Some of these features may impose implementation restrictions; for example, a practical implementation of first-class continuations (as in SML/NJ or Scheme) often requires the use of advanced stack representations <ref> [8] </ref> or heap-based activation records [22]. However in some cases stack-based allocation may be more efficient, and ideally we would like to have a compiler that can take advantage of it as long as this does not interfere with the semantic correctness of first-class continuations. <p> Only the invocations of ML functions that do not capture continuations should be allowed in safe-C functions. Any activation record that can potentially be captured as part of a first-class continuation should always be allocated on the heap (or using some fancy stack-chunk based representations <ref> [8] </ref>). It should be possible to use stack allocation for activation records of ML functions when they are guaranteed not to be captured with a first-class continuation. The selection of allocation strategy should be decoupled from the actual function call. <p> This allows the view of external functions as effect-polymorphic without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations <ref> [2, 8, 22, 1] </ref>, monads and modular interpreters [30, 12, 29, 13], typed intermediate languages [7, 26, 20, 17, 16, 3], and foreign function call interface [9, 18]. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. <p> Our system limits the quantification over a finite set of resourcesthis allows us to take advantage of the effect-resource relationship to support advanced compilation strategies. Efficient call/cc. Many people have worked on designing various strategies to support efficient implementation of first-class continuations <ref> [2, 8, 22, 1] </ref>. To support a reasonably efficient call/cc, compilers today mostly use stack chunks (a linked list of smaller stacks) [2, 8] or they simply heap allocate all activation records [22]. <p> Efficient call/cc. Many people have worked on designing various strategies to support efficient implementation of first-class continuations [2, 8, 22, 1]. To support a reasonably efficient call/cc, compilers today mostly use stack chunks (a linked list of smaller stacks) <ref> [2, 8] </ref> or they simply heap allocate all activation records [22]. Both of these representations are incompatible with those used by traditional languages such as C and C++ where activation records are allocated on a sequential stack. First-class continuations thus always impose restrictions and interoperability challenges to the underlying compiler.
Reference: [9] <author> L. Huelsbergen. </author> <title> A portable C interface for Standard ML of New Jersey. </title> <type> Technical memorandum, </type> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, NJ, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters [30, 12, 29, 13], typed intermediate languages [7, 26, 20, 17, 16, 3], and foreign function call interface <ref> [9, 18] </ref>. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. The idea of using effect-based type systems to support language interoperation was first proposed by Gifford and Lucassen [5, 6]. <p> Foreign function call interface. The interoperability problem addressed in this paper has much in common with frameworks for multi-lingual programming, such as ILU, CORBA [27], and Microsoft's COM [19]. It also relates to the foreign function call interfaces in most existing compilers <ref> [9, 18] </ref>. Although these work do address many of the low-level problems, such as converting data representations between languages or passing information to remote processes, their implementations do not provide any safety guarantees (or if they do, they would require external programs run in a separate address space).
Reference: [10] <author> P. Jouvelot and D. K. Gifford. </author> <title> Reasoning about continuations with control effects. </title> <booktitle> In Proc. ACM SIGPLAN '89 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 218226. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: This allows the view of external functions as effect-polymorphic without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference <ref> [6, 10, 11, 23, 24] </ref>, efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters [30, 12, 29, 13], typed intermediate languages [7, 26, 20, 17, 16, 3], and foreign function call interface [9, 18]. <p> Effect systems. The idea of using effect-based type systems to support language interoperation was first proposed by Gifford and Lucassen [5, 6]. Along this direction, many researchers have worked on various kinds of effect systems and effect inference algorithms <ref> [10, 11, 23, 24, 28] </ref>. The main novelty of our effect system is that we imposed a resource-based upper-bound to the effect variables. Effect variables in all previous effect systems are always universally quantified without any upper bounds, so they can be instantiated into any effect expressions.
Reference: [11] <author> P. Jouvelot and D. K. Gifford. </author> <title> Algebraic reconstruction of types and effects. </title> <booktitle> In Eighteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 303310, </pages> <address> New York, Jan 1991. </address> <publisher> ACM Press. </publisher>
Reference-contexts: This allows the view of external functions as effect-polymorphic without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference <ref> [6, 10, 11, 23, 24] </ref>, efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters [30, 12, 29, 13], typed intermediate languages [7, 26, 20, 17, 16, 3], and foreign function call interface [9, 18]. <p> Effect systems. The idea of using effect-based type systems to support language interoperation was first proposed by Gifford and Lucassen [5, 6]. Along this direction, many researchers have worked on various kinds of effect systems and effect inference algorithms <ref> [10, 11, 23, 24, 28] </ref>. The main novelty of our effect system is that we imposed a resource-based upper-bound to the effect variables. Effect variables in all previous effect systems are always universally quantified without any upper bounds, so they can be instantiated into any effect expressions.
Reference: [12] <author> J. Launchbury and S. Peyton Jones. </author> <title> Lazy functional state threads. </title> <booktitle> In Proc. ACM SIGPLAN '94 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 2435, </pages> <address> New York, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: the view of external functions as effect-polymorphic without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters <ref> [30, 12, 29, 13] </ref>, typed intermediate languages [7, 26, 20, 17, 16, 3], and foreign function call interface [9, 18]. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. <p> Monads and modular interpreters. The idea of using resources and effects to characterize the run-time configuration of a function is inspired by recent work on monad-based interactions and modular interpreters <ref> [30, 12, 29, 13] </ref>. Unlike in the monadic approach, our system provides a way of switching the runtime context horizontally from one to another via the use r (e) construct. Typed intermediate languages.
Reference: [13] <author> S. Liang, P. Hudak, and M. Jones. </author> <title> Monad transformers and modular interpreters. </title> <booktitle> In Proc. 22rd Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 333343. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: the view of external functions as effect-polymorphic without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters <ref> [30, 12, 29, 13] </ref>, typed intermediate languages [7, 26, 20, 17, 16, 3], and foreign function call interface [9, 18]. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. <p> Monads and modular interpreters. The idea of using resources and effects to characterize the run-time configuration of a function is inspired by recent work on monad-based interactions and modular interpreters <ref> [30, 12, 29, 13] </ref>. Unlike in the monadic approach, our system provides a way of switching the runtime context horizontally from one to another via the use r (e) construct. Typed intermediate languages.
Reference: [14] <author> G. Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1995. </year> <note> Tech Report CMU-CS-95-226. </note>
Reference-contexts: Typed intermediate languages. Typed intermediate languages have received much attention lately, especially in the HOT (i.e., higher-order and typed) language community. However, recent work <ref> [7, 14, 21, 17, 3, 16, 15] </ref> has mostly focused on the theoretical foundations and general language design issues. The type system in this paper focused on the problem of compiling multiple source languages into a common typed intermediate format.
Reference: [15] <author> G. Morrisett, D. Walker, K. Crary, and N. Glew. </author> <title> From system F to typed assembly language. </title> <booktitle> In Proc. 25rd Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, page (to appear). </booktitle> <publisher> ACM Press, </publisher> <year> 1998. </year>
Reference-contexts: Typed intermediate languages. Typed intermediate languages have received much attention lately, especially in the HOT (i.e., higher-order and typed) language community. However, recent work <ref> [7, 14, 21, 17, 3, 16, 15] </ref> has mostly focused on the theoretical foundations and general language design issues. The type system in this paper focused on the problem of compiling multiple source languages into a common typed intermediate format.
Reference: [16] <author> S. Peyton Jones, J. Launchbury, M. Shields, and A. Tolmach. </author> <title> Bridging the gulf: a common intermediate language for ML and Haskell. </title> <booktitle> In Proc. 25rd Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, page (to appear). </booktitle> <publisher> ACM Press, </publisher> <year> 1998. </year>
Reference-contexts: without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters [30, 12, 29, 13], typed intermediate languages <ref> [7, 26, 20, 17, 16, 3] </ref>, and foreign function call interface [9, 18]. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. The idea of using effect-based type systems to support language interoperation was first proposed by Gifford and Lucassen [5, 6]. <p> Typed intermediate languages. Typed intermediate languages have received much attention lately, especially in the HOT (i.e., higher-order and typed) language community. However, recent work <ref> [7, 14, 21, 17, 3, 16, 15] </ref> has mostly focused on the theoretical foundations and general language design issues. The type system in this paper focused on the problem of compiling multiple source languages into a common typed intermediate format. <p> The effect system described in this paper is also very general and useful for static program analysis: because it supports effect polymorphism, effect information is accurately propagated through high-order functions. This is clearly much more informative than the single one-bit (or N-bit) information seen in the simple monad-based calculus <ref> [16, 25] </ref>. There are many hard problems that must be solved in order to support a safe and fine-grained interoperation between ML and safe-C, for instance, the interactions between garbage collection and explicit memory allocation, between type-safe and unsafe language features etc.
Reference: [17] <author> S. Peyton Jones and E. Meijer. Henk: </author> <title> a typed intermediate language. </title> <booktitle> In Proc. 1997 ACM SIGPLAN Workshop on Types in Compilation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters [30, 12, 29, 13], typed intermediate languages <ref> [7, 26, 20, 17, 16, 3] </ref>, and foreign function call interface [9, 18]. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. The idea of using effect-based type systems to support language interoperation was first proposed by Gifford and Lucassen [5, 6]. <p> Typed intermediate languages. Typed intermediate languages have received much attention lately, especially in the HOT (i.e., higher-order and typed) language community. However, recent work <ref> [7, 14, 21, 17, 3, 16, 15] </ref> has mostly focused on the theoretical foundations and general language design issues. The type system in this paper focused on the problem of compiling multiple source languages into a common typed intermediate format.
Reference: [18] <author> S. Peyton Jones, T. Nordin, and A. Reid. Green card: </author> <title> a foreign-language interface for Haskell. </title> <note> Available at http://www.dcs.gla.ac.uk:80/ simonpj/green-card.ps.gz, </note> <year> 1997. </year>
Reference-contexts: work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters [30, 12, 29, 13], typed intermediate languages [7, 26, 20, 17, 16, 3], and foreign function call interface <ref> [9, 18] </ref>. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. The idea of using effect-based type systems to support language interoperation was first proposed by Gifford and Lucassen [5, 6]. <p> Foreign function call interface. The interoperability problem addressed in this paper has much in common with frameworks for multi-lingual programming, such as ILU, CORBA [27], and Microsoft's COM [19]. It also relates to the foreign function call interfaces in most existing compilers <ref> [9, 18] </ref>. Although these work do address many of the low-level problems, such as converting data representations between languages or passing information to remote processes, their implementations do not provide any safety guarantees (or if they do, they would require external programs run in a separate address space).
Reference: [19] <author> D. Rogerson. </author> <title> Inside COM: Microsoft's Component Object Model. </title> <publisher> Microsoft Press, </publisher> <year> 1997. </year>
Reference-contexts: We plan to incorporate the resource and effect annotations into our FLINT intermediate language [21]. Foreign function call interface. The interoperability problem addressed in this paper has much in common with frameworks for multi-lingual programming, such as ILU, CORBA [27], and Microsoft's COM <ref> [19] </ref>. It also relates to the foreign function call interfaces in most existing compilers [9, 18].
Reference: [20] <author> Z. Shao. </author> <title> An overview of the FLINT/ML compiler. </title> <booktitle> In Proc. 1997 ACM SIGPLAN Workshop on Types in Compilation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: In addition to providing safety, making resource handling explicit also opens new opportunities for code optimization beyond what a foreign function call mechanism can offer. A common intermediate language like FLINT <ref> [20, 21] </ref> will likely support a very rich set of features to accommodate multiple source languages. <p> without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters [30, 12, 29, 13], typed intermediate languages <ref> [7, 26, 20, 17, 16, 3] </ref>, and foreign function call interface [9, 18]. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. The idea of using effect-based type systems to support language interoperation was first proposed by Gifford and Lucassen [5, 6].
Reference: [21] <author> Z. Shao. </author> <title> Typed common intermediate format. </title> <booktitle> In Proc. 1997 USENIX Conference on Domain Specific Languages, </booktitle> <pages> pages 89102, </pages> <month> October </month> <year> 1997. </year>
Reference-contexts: For instance a language that does not use call/cc should not have to be implemented using heap-based allocation of activation records. Our solution is to ensure safety by using a common typed intermediate language <ref> [21] </ref> into which all of the source languages are translated. <p> In addition to providing safety, making resource handling explicit also opens new opportunities for code optimization beyond what a foreign function call mechanism can offer. A common intermediate language like FLINT <ref> [20, 21] </ref> will likely support a very rich set of features to accommodate multiple source languages. <p> Typed intermediate languages. Typed intermediate languages have received much attention lately, especially in the HOT (i.e., higher-order and typed) language community. However, recent work <ref> [7, 14, 21, 17, 3, 16, 15] </ref> has mostly focused on the theoretical foundations and general language design issues. The type system in this paper focused on the problem of compiling multiple source languages into a common typed intermediate format. <p> The type system in this paper focused on the problem of compiling multiple source languages into a common typed intermediate format. We plan to incorporate the resource and effect annotations into our FLINT intermediate language <ref> [21] </ref>. Foreign function call interface. The interoperability problem addressed in this paper has much in common with frameworks for multi-lingual programming, such as ILU, CORBA [27], and Microsoft's COM [19]. It also relates to the foreign function call interfaces in most existing compilers [9, 18].
Reference: [22] <author> Z. Shao and A. W. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 150161, </pages> <address> New York, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Some of these features may impose implementation restrictions; for example, a practical implementation of first-class continuations (as in SML/NJ or Scheme) often requires the use of advanced stack representations [8] or heap-based activation records <ref> [22] </ref>. However in some cases stack-based allocation may be more efficient, and ideally we would like to have a compiler that can take advantage of it as long as this does not interfere with the semantic correctness of first-class continuations. <p> This allows the view of external functions as effect-polymorphic without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations <ref> [2, 8, 22, 1] </ref>, monads and modular interpreters [30, 12, 29, 13], typed intermediate languages [7, 26, 20, 17, 16, 3], and foreign function call interface [9, 18]. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. <p> Our system limits the quantification over a finite set of resourcesthis allows us to take advantage of the effect-resource relationship to support advanced compilation strategies. Efficient call/cc. Many people have worked on designing various strategies to support efficient implementation of first-class continuations <ref> [2, 8, 22, 1] </ref>. To support a reasonably efficient call/cc, compilers today mostly use stack chunks (a linked list of smaller stacks) [2, 8] or they simply heap allocate all activation records [22]. <p> Efficient call/cc. Many people have worked on designing various strategies to support efficient implementation of first-class continuations [2, 8, 22, 1]. To support a reasonably efficient call/cc, compilers today mostly use stack chunks (a linked list of smaller stacks) [2, 8] or they simply heap allocate all activation records <ref> [22] </ref>. Both of these representations are incompatible with those used by traditional languages such as C and C++ where activation records are allocated on a sequential stack. First-class continuations thus always impose restrictions and interoperability challenges to the underlying compiler.
Reference: [23] <author> J.-P. Talpin and P. Jouvelot. </author> <title> Polymorphic type, region, and effect inference. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(3), </volume> <year> 1992. </year>
Reference-contexts: ! Int) ! Int add1 = h H x : Int: @ succ xi H : Int ! Int in @ applyToInt H [;] add1 : 8t S: (Int ! Int) ! Int H ; The translation infers polymorphic effect types using a simplified version 2 of standard effect inference <ref> [23] </ref>. The resource annotations are fixed by the source language; the type of an external SL function in an HL program is annotated with the SL resources. In the code produced after translation the external functions are coerced to match the resources of HL using automatically generated wrappers. <p> This allows the view of external functions as effect-polymorphic without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference <ref> [6, 10, 11, 23, 24] </ref>, efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters [30, 12, 29, 13], typed intermediate languages [7, 26, 20, 17, 16, 3], and foreign function call interface [9, 18]. <p> Effect systems. The idea of using effect-based type systems to support language interoperation was first proposed by Gifford and Lucassen [5, 6]. Along this direction, many researchers have worked on various kinds of effect systems and effect inference algorithms <ref> [10, 11, 23, 24, 28] </ref>. The main novelty of our effect system is that we imposed a resource-based upper-bound to the effect variables. Effect variables in all previous effect systems are always universally quantified without any upper bounds, so they can be instantiated into any effect expressions.
Reference: [24] <author> J.-P. Talpin and P. Jouvelot. </author> <title> The type and effect discipline. Information and Computation, </title> <address> 111(2):245296, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: This allows the view of external functions as effect-polymorphic without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference <ref> [6, 10, 11, 23, 24] </ref>, efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters [30, 12, 29, 13], typed intermediate languages [7, 26, 20, 17, 16, 3], and foreign function call interface [9, 18]. <p> Effect systems. The idea of using effect-based type systems to support language interoperation was first proposed by Gifford and Lucassen [5, 6]. Along this direction, many researchers have worked on various kinds of effect systems and effect inference algorithms <ref> [10, 11, 23, 24, 28] </ref>. The main novelty of our effect system is that we imposed a resource-based upper-bound to the effect variables. Effect variables in all previous effect systems are always universally quantified without any upper bounds, so they can be instantiated into any effect expressions.
Reference: [25] <author> D. Tarditi. </author> <title> Design and Implementation of Code Optimizations for a Type-Directed Compiler for Standard ML. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1996. </year> <note> Tech Report CMU-CS-97-108. </note>
Reference-contexts: The effect system described in this paper is also very general and useful for static program analysis: because it supports effect polymorphism, effect information is accurately propagated through high-order functions. This is clearly much more informative than the single one-bit (or N-bit) information seen in the simple monad-based calculus <ref> [16, 25] </ref>. There are many hard problems that must be solved in order to support a safe and fine-grained interoperation between ML and safe-C, for instance, the interactions between garbage collection and explicit memory allocation, between type-safe and unsafe language features etc.
Reference: [26] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In Proc. ACM SIGPLAN '96 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 181192. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters [30, 12, 29, 13], typed intermediate languages <ref> [7, 26, 20, 17, 16, 3] </ref>, and foreign function call interface [9, 18]. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. The idea of using effect-based type systems to support language interoperation was first proposed by Gifford and Lucassen [5, 6].
Reference: [27] <author> The Object Management Group. </author> <title> The common object request broker: Architecture and specifications (CORBA). Revision 1.2., Object Management Group (OMG), Framingham, </title> <address> MA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: We plan to incorporate the resource and effect annotations into our FLINT intermediate language [21]. Foreign function call interface. The interoperability problem addressed in this paper has much in common with frameworks for multi-lingual programming, such as ILU, CORBA <ref> [27] </ref>, and Microsoft's COM [19]. It also relates to the foreign function call interfaces in most existing compilers [9, 18].
Reference: [28] <author> M. Tofte and J.-P. Talpin. </author> <title> Implementation of the typed call-by-value -calculus using a stack of regions. </title> <booktitle> In Proc. 21st Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 188201. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: Effect systems. The idea of using effect-based type systems to support language interoperation was first proposed by Gifford and Lucassen [5, 6]. Along this direction, many researchers have worked on various kinds of effect systems and effect inference algorithms <ref> [10, 11, 23, 24, 28] </ref>. The main novelty of our effect system is that we imposed a resource-based upper-bound to the effect variables. Effect variables in all previous effect systems are always universally quantified without any upper bounds, so they can be instantiated into any effect expressions.
Reference: [29] <author> P. Wadler. </author> <title> The essence of functional programming (invited talk). </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <address> New York, Jan 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: the view of external functions as effect-polymorphic without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters <ref> [30, 12, 29, 13] </ref>, typed intermediate languages [7, 26, 20, 17, 16, 3], and foreign function call interface [9, 18]. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. <p> Monads and modular interpreters. The idea of using resources and effects to characterize the run-time configuration of a function is inspired by recent work on monad-based interactions and modular interpreters <ref> [30, 12, 29, 13] </ref>. Unlike in the monadic approach, our system provides a way of switching the runtime context horizontally from one to another via the use r (e) construct. Typed intermediate languages.
Reference: [30] <author> P. Wadler. </author> <title> How to declare an imperative (invited talk). </title> <booktitle> In International Logic Programming Symposium, </booktitle> <address> Portland, Oregon, December 1995. </address> <publisher> MIT Press. </publisher>
Reference-contexts: the view of external functions as effect-polymorphic without restricting their actual implementations. 6 Related Work and Conclusions The work presented in this paper is mainly inspired by recent research on effect inference [6, 10, 11, 23, 24], efficient implementation of first-class continuations [2, 8, 22, 1], monads and modular interpreters <ref> [30, 12, 29, 13] </ref>, typed intermediate languages [7, 26, 20, 17, 16, 3], and foreign function call interface [9, 18]. In the following, we briefly explain the relationship of these work with our resource-based approach. Effect systems. <p> Monads and modular interpreters. The idea of using resources and effects to characterize the run-time configuration of a function is inspired by recent work on monad-based interactions and modular interpreters <ref> [30, 12, 29, 13] </ref>. Unlike in the monadic approach, our system provides a way of switching the runtime context horizontally from one to another via the use r (e) construct. Typed intermediate languages.
References-found: 30

