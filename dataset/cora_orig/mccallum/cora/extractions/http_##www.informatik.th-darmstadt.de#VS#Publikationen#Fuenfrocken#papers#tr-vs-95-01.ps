URL: http://www.informatik.th-darmstadt.de/VS/Publikationen/Fuenfrocken/papers/tr-vs-95-01.ps
Refering-URL: http://www.informatik.th-darmstadt.de/~fuenf/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: fmattern, fuenfg@isa.informatik.th-darmstadt.de  
Title: A Non-Blocking Lightweight Implementation of Causal Order Message Delivery  
Author: Friedemann Mattern and Stefan Funfrocken 
Address: Alexanderstr. 10, D 64283 Darmstadt, Germany  
Affiliation: Department of Computer Science, Technical University of Darmstadt,  
Abstract: Technical Report No. TR-VS-95-01 March 1995 
Abstract-found: 1
Intro-found: 1
Reference: [AB92] <author> Acharya A., Badrinath B., </author> <title> Recording Distributed Snapshots Based on Causal Order of Message Delivery. </title> <journal> Information Processing Letters 44, </journal> <year> 1992, </year> <pages> pp. 317-321 </pages>
Reference-contexts: broadcasts may be found in the collection of papers on the Isis System [BR94]. purposes: Consistent snapshot generation: compute the global state of a distributed system in such a way that it does not show an "effect" (i.e., the receipt of a message) without showing its "cause" (i.e., its sending) <ref> [AB92, AV94] </ref>. Observing distributed systems: display a sequence of events of a distributed computation which respects their causal dependencies (e.g., where the receipt of a message is never observed before its sending) [SM94].
Reference: [AV94] <author> Alagar S., Venkatesan S., </author> <title> An Optimal Algorithm for Distributed Snapshots with Causal Message Ordering. </title> <journal> Information Processing Letters 50, </journal> <year> 1994, </year> <pages> pp. 311-316 </pages>
Reference-contexts: broadcasts may be found in the collection of papers on the Isis System [BR94]. purposes: Consistent snapshot generation: compute the global state of a distributed system in such a way that it does not show an "effect" (i.e., the receipt of a message) without showing its "cause" (i.e., its sending) <ref> [AB92, AV94] </ref>. Observing distributed systems: display a sequence of events of a distributed computation which respects their causal dependencies (e.g., where the receipt of a message is never observed before its sending) [SM94].
Reference: [BJ87] <author> Birman K., Joseph T., </author> <title> Reliable Communication in the Presence of Failures, </title> <journal> ACM Trans. on Computer Systems 5, </journal> <year> 1987, </year> <pages> pp. 47-76 </pages>
Reference-contexts: Protocols which guarantee this behavior are implementations of the so-called causal order message delivery property. The use of causal order in message delivery was introduced in <ref> [BJ87] </ref>, where also protocols for broadcasts are presented. Specific algorithms for point-to-point communications were later given in [SES89] and [RST91]. <p> The causal order delivery protocols described in this and the next section can, in some sense, be viewed as generalizations of these two principles. A first implementation of causal broadcasts was described by Birman and Joseph <ref> [BJ87] </ref> in the context of the Isis system [BR94]. Isis originally realized causal broadcasts by conceptually piggybacking all causally preceding broadcast messages on each message [BJ87], but then applying some optimizations which trim the piggybacked causal history in an effective way. <p> A first implementation of causal broadcasts was described by Birman and Joseph <ref> [BJ87] </ref> in the context of the Isis system [BR94]. Isis originally realized causal broadcasts by conceptually piggybacking all causally preceding broadcast messages on each message [BJ87], but then applying some optimizations which trim the piggybacked causal history in an effective way. More recent versions of Isis are based on vector time, which represents a substantial improvement because of the reduced overhead [BSS91].
Reference: [BR94] <author> Birman K., van Renesse R. (eds.), </author> <title> Reliable Distributed Computing with the Isis Toolkit, </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1994 </year>
Reference-contexts: Specific algorithms for point-to-point communications were later given in [SES89] and [RST91]. The causal order property is useful, among other things 1 , for the following 1 Applications of causal broadcasts may be found in the collection of papers on the Isis System <ref> [BR94] </ref>. purposes: Consistent snapshot generation: compute the global state of a distributed system in such a way that it does not show an "effect" (i.e., the receipt of a message) without showing its "cause" (i.e., its sending) [AB92, AV94]. <p> The causal order delivery protocols described in this and the next section can, in some sense, be viewed as generalizations of these two principles. A first implementation of causal broadcasts was described by Birman and Joseph [BJ87] in the context of the Isis system <ref> [BR94] </ref>. Isis originally realized causal broadcasts by conceptually piggybacking all causally preceding broadcast messages on each message [BJ87], but then applying some optimizations which trim the piggybacked causal history in an effective way.
Reference: [BSS91] <author> Birman K., Schiper A., Stephenson P., </author> <title> Lightweight Causal and Atomic Group Multicast, </title> <journal> ACM Trans. on Computer Systems, </journal> <month> 9(3) (August </month> <year> 1991), </year> <pages> 272-314 </pages>
Reference-contexts: More recent versions of Isis are based on vector time, which represents a substantial improvement because of the reduced overhead <ref> [BSS91] </ref>. For causal order delivery of point-to-point messages, one could of course also piggyback the whole causal history on each message. However, in that case a so-called conservative solution is used in the Isis system, where the sender is blocked until reception of the message is acknowledged [BSS91]. (The same "synchronous" <p> the reduced overhead <ref> [BSS91] </ref>. For causal order delivery of point-to-point messages, one could of course also piggyback the whole causal history on each message. However, in that case a so-called conservative solution is used in the Isis system, where the sender is blocked until reception of the message is acknowledged [BSS91]. (The same "synchronous" implementation is also used for broadcasts in situations where piggybacking is too costly.) Kearns et al. [KK89] presented a protocol to ensure point-to-point causal order message delivery in a distributed system with a single server, to which messages from all other processes (so-called clients) are delivered in
Reference: [CMT94] <author> Charron-Bost B., Mattern F., Tel G., </author> <title> Synchronous, Asynchronous, and Causally Ordered Communication. </title> <note> Submitted to Distributed Computing, </note> <year> 1994 </year>
Reference-contexts: A computation exhibiting this "triangle inequation", which is a stronger property than the more local FIFO property along single communication channels, is called a causally ordered computation <ref> [CMT94] </ref>. Protocols which guarantee this behavior are implementations of the so-called causal order message delivery property. The use of causal order in message delivery was introduced in [BJ87], where also protocols for broadcasts are presented. Specific algorithms for point-to-point communications were later given in [SES89] and [RST91]. <p> Note that the causal order property trivially implies the FIFO property (s ~ s 0 ) ^ (r ~ r 0 ) ^ (s s 0 ) ) r r 0 as a special case. In <ref> [CMT94] </ref> it is shown that causally ordered computations fall between synchronous computations (i.e., computations where communication is always synchronous) and FIFO computations (i.e., computations where communication between two processes respects the FIFO property). <p> One way to implement FIFO on asynchronous systems is to resort to synchronous communication and block the sender until an acknowledgement from the destination process is received. This works because computations with synchronous communications are always causally ordered <ref> [CMT94] </ref>. A better and also well-known solution to guarantee FIFO message delivery consists in using sequence numbers on each communication channel. The delivery of messages with higher sequence numbers, which arrive too early at the destination process, can be delayed until all messages with lower sequence numbers have arrived. <p> In fact, protocols which implement synchronous message transmission on top of asynchronous systems (such as the above mentioned "wait and acknowledge" scheme) do guarantee causal order message delivery in a natural way because messages which are "virtually instantaneous" cannot be overtaken by a chain of other messages <ref> [CMT94] </ref>. In general, however, one would probably not be happy with such a protocol since an application which executes without problems using a traditional non-blocking causal order delivery protocol might deadlock when running on such a simulated synchronous system. <p> Figure 7 and Fig. 8 show two possible computations, both contain so-called crowns (i.e., substructures of k corresponding send-receive events s i ; r i such that s 1 r 2 ; s 2 r 3 ; ; s k1 r k ; s k r 1 , see <ref> [CMT94] </ref>). Figure 7 can be generated by the buffer protocol in the following way: First, the initial sends of each process are executed and messages e, c, a are inserted into the receivers' input buffers.
Reference: [Fid88] <author> Fidge C., </author> <title> Timestamps in Message-Passing Systems that Preserve the Partial Ordering. </title> <booktitle> Proc. 11th Autralian Computer Science Conf., </booktitle> <institution> University of Queensland, </institution> <year> 1988, </year> <pages> pp. 55-66 </pages>
Reference-contexts: Taking the componentwise maximum when receiving a message from another client thus incorporates indirect knowledge, reflecting the fact that causality is transitive. This is the same principle the so-called vector timestamps are based on <ref> [Fid88, Mat88] </ref>, and in fact message-count-vectors are only a slight variant of vector timestamps. Delaying the receipt of a message until all causally preceding messages have arrived is a canonical extension of the sequence number method to guarantee FIFO delivery.
Reference: [KK89] <author> Kearns P., Koodalattupuram B., </author> <title> Immediate Ordered Service in Distributed Systems. </title> <booktitle> Proc. 9th International Conference on Distributed Computing Systems, </booktitle> <address> Newport Beach, California, </address> <month> June 5-9, </month> <year> 1989, </year> <pages> pp. 611-618 </pages>
Reference-contexts: Fair distributed resource allocation management: requests for a resource should be satisfied in the (causal) order they were issued by the processes <ref> [KK89] </ref>. Garbage collection in distributed systems: Here, reference counters must be updated in a causally consistent way, otherwise non-garbage objects may be identified as being garbage [TM93]. <p> However, in that case a so-called conservative solution is used in the Isis system, where the sender is blocked until reception of the message is acknowledged [BSS91]. (The same "synchronous" implementation is also used for broadcasts in situations where piggybacking is too costly.) Kearns et al. <ref> [KK89] </ref> presented a protocol to ensure point-to-point causal order message delivery in a distributed system with a single server, to which messages from all other processes (so-called clients) are delivered in causal order. The protocol uses message-count-vectors which are located at each process and which are piggybacked on each message.
Reference: [Lam78] <author> Lamport L., </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <booktitle> Comm. of the ACM 21 (7), </booktitle> <year> 1978, </year> <pages> pp. 558-565 </pages>
Reference-contexts: Furthermore, indirect dependencies among events are caused by transitivity (e.g., by chains of messages). This gives rise to the following definition of a general causality relation, denoted by '', among all events of a distributed computation (originally called "happened before" by Lamport <ref> [Lam78] </ref>): Definition: The causality relation is the smallest transitive relation that satisfies the following two properties for any two events a; b: If a i b, then a b.
Reference: [Mat88] <author> Mattern F., </author> <title> Virtual Time and Global States of Distributed Systems. </title> <editor> In: Cosnard M. et al. (eds.): </editor> <booktitle> Proc. Workshop on Parallel and Distributed Algorithms, </booktitle> <address> Bonas, France, </address> <year> 1988, </year> <pages> pp. 215-226. </pages> <note> (Reprinted in: </note> <author> Z. Yang, T.A. Marsland (eds.), </author> <title> Global States and Time in Distributed Systems, </title> <publisher> IEEE, </publisher> <year> 1994, </year> <pages> pp. 123-133) </pages>
Reference-contexts: Taking the componentwise maximum when receiving a message from another client thus incorporates indirect knowledge, reflecting the fact that causality is transitive. This is the same principle the so-called vector timestamps are based on <ref> [Fid88, Mat88] </ref>, and in fact message-count-vectors are only a slight variant of vector timestamps. Delaying the receipt of a message until all causally preceding messages have arrived is a canonical extension of the sequence number method to guarantee FIFO delivery.
Reference: [RST91] <author> Raynal M., Schiper A., Toueg S., </author> <title> The Causal Ordering Abstraction and a Simple Way to Implement it. </title> <journal> Information Processing Letters 39, </journal> <year> 1991, </year> <pages> pp. 343-350 </pages>
Reference-contexts: Protocols which guarantee this behavior are implementations of the so-called causal order message delivery property. The use of causal order in message delivery was introduced in [BJ87], where also protocols for broadcasts are presented. Specific algorithms for point-to-point communications were later given in [SES89] and <ref> [RST91] </ref>. <p> A slight variant which uses integer matrices of size n fi n (instead of at most n vectors of length n in each message) was later given by Raynal, Schiper, and Toueg <ref> [RST91] </ref>. In this protocol, each process i has such a matrix M i . When a process i sends a message to process j, it increments M i [i; j] and attaches M i to the message. <p> A Non-Causally Ordered Execution of the First Program In order to compare our "buffer protocol" to the classical point-to-point causal order delivery protocol based on dependency matrices <ref> [SES89, RST91] </ref>, consider the following distributed program with three processes: P 1 : send x to P 3 ; ... send y to P 2 ;... P 2 : receive; ... send z to P 3 ;... P 3 : receive; ... receive;... asynchronous system.
Reference: [SES89] <author> Schiper A., Eggli J., Sandoz A., </author> <title> A New Algorithm to Implement Causal Ordering. </title> <editor> In: J.-C. Bermond, M. Raynal (eds.), </editor> <booktitle> Distributed Algorithms, Vol. 392 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989, </year> <pages> pp. 219-232 </pages>
Reference-contexts: Protocols which guarantee this behavior are implementations of the so-called causal order message delivery property. The use of causal order in message delivery was introduced in [BJ87], where also protocols for broadcasts are presented. Specific algorithms for point-to-point communications were later given in <ref> [SES89] </ref> and [RST91]. <p> Such a general point-to-point causal order delivery protocol would use n vectors of length n (where n is the total number of processes) at each process and in each message. In fact, the implementation of causal order presented by Schiper at al. <ref> [SES89] </ref>, which was found independently of Kearn's more restrictive solution, is based on this idea. A slight variant which uses integer matrices of size n fi n (instead of at most n vectors of length n in each message) was later given by Raynal, Schiper, and Toueg [RST91]. <p> A Non-Causally Ordered Execution of the First Program In order to compare our "buffer protocol" to the classical point-to-point causal order delivery protocol based on dependency matrices <ref> [SES89, RST91] </ref>, consider the following distributed program with three processes: P 1 : send x to P 3 ; ... send y to P 2 ;... P 2 : receive; ... send z to P 3 ;... P 3 : receive; ... receive;... asynchronous system.
Reference: [SM94] <author> Schwarz R., Mattern F., </author> <title> Detecting Causal Relationships in Distributed Computations: In Search of the Holy Grail. </title> <booktitle> Distributed Computing 7 (3), </booktitle> <year> 1994, </year> <pages> pp. 149-174 </pages>
Reference-contexts: Observing distributed systems: display a sequence of events of a distributed computation which respects their causal dependencies (e.g., where the receipt of a message is never observed before its sending) <ref> [SM94] </ref>. Fair distributed resource allocation management: requests for a resource should be satisfied in the (causal) order they were issued by the processes [KK89]. Garbage collection in distributed systems: Here, reference counters must be updated in a causally consistent way, otherwise non-garbage objects may be identified as being garbage [TM93].
Reference: [TM93] <author> Tel G., Mattern F., </author> <title> The Derivation of Distributed Termination Detection Algorithms from Garbage Collection Schemes, </title> <journal> ACM Trans. on Prog. Lang. Sys. </journal> <volume> 15 (1), </volume> <year> 1993, </year> <pages> pp. 1-35 </pages>
Reference-contexts: Fair distributed resource allocation management: requests for a resource should be satisfied in the (causal) order they were issued by the processes [KK89]. Garbage collection in distributed systems: Here, reference counters must be updated in a causally consistent way, otherwise non-garbage objects may be identified as being garbage <ref> [TM93] </ref>. In order to precisely define the causal order property and to be able to prove the correctness of the algorithm described in later sections, we need a more abstract notion of a distributed computation.
References-found: 14

