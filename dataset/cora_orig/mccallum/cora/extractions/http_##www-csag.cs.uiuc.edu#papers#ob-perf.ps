URL: http://www-csag.cs.uiuc.edu/papers/ob-perf.ps
Refering-URL: http://www-csag.cs.uiuc.edu/papers/index.html
Root-URL: http://www.cs.uiuc.edu
Email: fo-zimmer,achieng@cs.uiuc.edu  
Title: Performance of OmniBroker, an Implementation of CORBA 2.0  
Author: Oolan Zimmer and Andrew Chien 
Affiliation: Department of Computer Science, University of Illinois at Urbana-Champaign  
Abstract: February 1, 1998 Concurrent Systems Architecture Group Technical Report, 2/1998 Available from http://www-csag.cs.uiuc.edu Abstract OmniBroker is a freely available CORBA 2.0-compliant object request broker. We examine the performance of OmniBroker on a single machine and two machines connected with 10 Mb Ethernet to determine OmniBroker's suitability for adaptation to higher-performance networks. The measured null invocation times were 577 us loopback and 757 us remote. We found that OmniBroker invocations had a nearly constant 350 us of additional latency over sockets benchmarks using similar size messages. Using a profiler, we found that OmniBroker spent most of its time in the sockets layer, with only 259 us / invocation of overhead processing invocations. We conclude that the larger figure 350 us send+receive overhead is more accurate and that OmniBroker will probably not perform better than this amount without substantial reengineering.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aniruddha Gokhale and Douglas Schmidt. </author> <title> Measuring the performance of communication mid-dleware on high-speed networks. </title> <booktitle> In ACM SIGCOMM, </booktitle> <year> 1996. </year>
Reference-contexts: While this is an extremely extensible pattern, it is also not noted for its performance. IIOP marshaling and unmarshaling code that is similar in design to this has been analyzed in <ref> [1] </ref>. 2.4 Sockets Usage The reactor classes are shared between client and server. <p> The parameter types of arrays and sequences of double-precision floating-point numbers was chosen to minimize marshaling and unmarshaling overhead. Thus, we are given a "best-case" view of the OmniBroker runtime system. Since the un/marshaling code is similar to that examined in <ref> [1] </ref>, we expect un/marshaling of more complex data types to have similar performance problems. In addition to the OmniBroker tests, we implemented a sockets ping-pong test. We used this to determine sockets latency for various message sizes, and thus to independently measure the layer underneath OmniBroker.
Reference: [2] <author> Marc Laukien and Use Seimet. </author> <title> OmniBroker User Manual. </title> <booktitle> Object-Oriented Concepts, </booktitle> <month> Septem-ber </month> <year> 1997. </year>
Reference-contexts: 1 Introduction Distributed object systems are becoming increasingly important and are being used in wider applications. Despite the proliferation of higher-performance networks, however, most distributed objects and middleware products are focused on features to the exclusion of performance. OmniBroker <ref> [2] </ref> is one of a few CORBA-compliant ORBs that is written for reasonable efficiency and has freely-available source code. In this paper, we examine some of the performance characteristics of Omni-Broker to determine its suitability for adaptation to higher-speed networks.
Reference: [3] <author> Rational Software. </author> <title> Getting Ahead with Visual Quantify. </title> <note> Available online. http://www.rational.com/support/solutions/visualq/4.0/. </note>
Reference-contexts: These times are quite close to the null invocation times. 3.2.3 Sockets performance round-trip time. The two-way local invocation is about 350 us above the sockets round-trip time for small parameter/message sizes. This additional overhead appears to be constant with respect to parameter size. 3.2.4 Profiler Results Visual Quantify <ref> [3] </ref> was used to analyze the client and server running the local two-way array test. The profiler gathered wall time for the sockets functions and CPU time for the non-sockets functions.
Reference: [4] <author> Douglas Schmidt. </author> <title> Reactor an object behavioral pattern for event demultiplexing and event handler dispatching. </title> <booktitle> In First Pattern Languages of Programs, </booktitle> <year> 1994. </year>
Reference-contexts: This is substantially larger than most of the other ORB's available in source code form. However, the ORB is reasonably structured and uses design patterns, making analysis reasonable. The ORB uses the reactor pattern <ref> [4] </ref> for handling network communication. While the reactor should encapsulate all sockets usage, it does not. There are branches of methods in the IIOP protocol objects that use sockets directly.
Reference: [5] <author> M. Schroeder and M. Burrows. </author> <title> Peformance of firefly RPC. </title> <editor> In John Ousterhout, editor, </editor> <booktitle> Proceedings of the 12th ACM Symposium on Operating Systems Principles (SIGOPS '89), </booktitle> <pages> pages 83-90, </pages> <address> Litchfield Park, AZ, USA, </address> <month> December </month> <year> 1989. </year> <note> ACM Press. 9 </note>
References-found: 5

