URL: ftp://rievaulx.dur.ac.uk/pub/tech-reports/1988/4-88.ps.gz
Refering-URL: http://www.dur.ac.uk/~dcs0www/tech-reports.html
Root-URL: 
Title: A KnowledgeBased System for Software Maintenance  
Author: F.W. Calliss, M. Khalil, M. Munro and M. Ward 
Address: Durham, England DH1 3LE  
Affiliation: Center for Software Maintenance University of Durham  
Abstract: A description of an Intelligent, Knowledge-Based maintenance tool, being developed by the Centre for Software Maintenance at the University of Durham is described. The tool is intended to help reduce the amount of time spent on analysing code. Code analysis is performed when a programmer is familiarising himself with a piece of code, and when the eects of a proposed moditcation of the code is being assessed.
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> First Software Maintenance Workshop Notes, </institution> <note> 8 th -9 th September 1987 eds. </note> <author> Munro, M. and Calliss, F.W. </author> <title> Centre for Software Maintenance, </title> <institution> University of Durham, Durham. </institution>
Reference-contexts: This project is contning itself to the more realistic goal of a maintainer's assistant. The proposed tool will concentrate in the area of code analysis, this is because code analysis is perceived as the most time consuming activity in maintenance, Petzold <ref> [1] </ref> indicated that in a breakdown of maintenance tasks code analysis was seen to take up 47% of the time.
Reference: [2] <author> Back, R. J. R. </author> <title> Correctness Preserving Program Retnements, </title> <publisher> Mathematical Centre Tracts 131, Math-ematisch Centrum 1980. </publisher>
Reference-contexts: Also associated with any program is a logical formula which encapsulates the initial conditions under which the program is guaranteed to terminate in a state which satistes a given tnal conditions. These formulae are called weakest preconditions in [7]. Their value lies in the fact proved in <ref> [2] </ref> for iterative programs and extended in [23] to recursive programs that two programs are equivalent if and only if they have equivalent weakest preconditions.
Reference: [3] <author> Bauer, F. L. </author> <title> Programming as an Evolutionary Process, </title> <booktitle> in [12], </booktitle> <address> pp.153-182, </address> <year> 1976. </year>
Reference-contexts: The formal system is independent of any particular programming language and allows the inclusion of arbitrary specitcations as statements in a program. Hence it can be used to prove that a program is equivalent to a given specitcation. Program transformations are used in program development in <ref> [3, 4, 10, 11] </ref>. However their methods cannot cope with general specitcations or with transforming programs into specitcations.
Reference: [4] <author> Bauer, F.L. </author> <title> Program Development By Stepwise Transformations the Project CIP, </title> <booktitle> in [13], </booktitle> <month> pp.237-266 </month> <year> 1979. </year>
Reference-contexts: The formal system is independent of any particular programming language and allows the inclusion of arbitrary specitcations as statements in a program. Hence it can be used to prove that a program is equivalent to a given specitcation. Program transformations are used in program development in <ref> [3, 4, 10, 11] </ref>. However their methods cannot cope with general specitcations or with transforming programs into specitcations.
Reference: [5] <author> Calliss, F.W., </author> <title> Problems With Automatic Restructurerers, </title> <journal> SIGPLAN Notices, </journal> <volume> vol. 23, no. 3, pp.13-21, </volume> <month> March </month> <year> 1988. </year>
Reference-contexts: Restructuring is the process of taking a program text, shuing the pieces of code around to produce a logically equivalent program which conforms to some given programming criteria. This only tackles one small part of the maintenance task and even then can present new problems <ref> [5] </ref>. By far the largest part of the maintenance programmers job involves program analysisthe study of the source code in order to try and work out what the program is supposed to do and which other pieces of code are aected and how.
Reference: [6] <author> Calliss, F.W. and Cornelius, B.J., </author> <title> Dynamic Data Flow Analysis of C Programs, </title> <booktitle> in Proceedings of the 21 st Hawaii International Conference on SS, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1988. </year>
Reference-contexts: Some work has already been carried out in this area at Durham with the development of interactive cross referencers <ref> [6, 19] </ref>. * Using the above information to determine the eects of a proposed moditcation (for instance to de termine which modules will be aected via the control and data ow from a modited module). 2.1 The Knowledge Bases Much of the knowledge is based on the concept of program plans. <p> part of the present project, but is an idea for a follow on project dealing with binding sections of documentation to sections of the code. 2.1.5 Other Tools The internal representation is in a particularly suitable form for interpretive execution including debugging using dynamic data ow analysis (see for example <ref> [6] </ref>) and other tools.
Reference: [7] <author> Dijkstra, E. </author> <title> A Discipline of Programming, </title> <booktitle> PrenticeHall Int, </booktitle> <address> New York 1972. </address>
Reference-contexts: Also associated with any program is a logical formula which encapsulates the initial conditions under which the program is guaranteed to terminate in a state which satistes a given tnal conditions. These formulae are called weakest preconditions in <ref> [7] </ref>. Their value lies in the fact proved in [2] for iterative programs and extended in [23] to recursive programs that two programs are equivalent if and only if they have equivalent weakest preconditions.
Reference: [8] <author> Fenton, M. </author> <title> Developing in DataFlex, Book 2, Reports and other outputs, B.E.M. Microsystems 1986. </title>
Reference-contexts: This method is used in [23] to introduce the exit from the middle of a loop, recursive procedures with parameters and local variables, functions and expressions with side eects. These transformations are used in [24] which takes a published program (from <ref> [8] </ref>) which was written in such a way that the structure and eect of the program are very hard to discern.
Reference: [9] <author> Foster, J. and Munro, M., </author> <title> A Documentation Method Based on Cross-Referencing, </title> <booktitle> in Proceedings Conference on Software Maintenance-1987, </booktitle> <address> Austin, </address> <publisher> Texas IEEE Computer Society Press, </publisher> <address> Washington D.C., pp.181-185, </address> <month> September </month> <year> 1987. </year> <month> 5 </month>
Reference: [10] <author> Griths, M. </author> <title> Program Production by Successive Transformation, </title> <booktitle> in [12], </booktitle> <month> pp.125-152 </month> <year> 1979. </year>
Reference-contexts: The formal system is independent of any particular programming language and allows the inclusion of arbitrary specitcations as statements in a program. Hence it can be used to prove that a program is equivalent to a given specitcation. Program transformations are used in program development in <ref> [3, 4, 10, 11] </ref>. However their methods cannot cope with general specitcations or with transforming programs into specitcations.
Reference: [11] <author> Griths, M. </author> <title> Development of the Schorr-Waite Algorithm, </title> <booktitle> in [13], </booktitle> <month> pp.464-471 </month> <year> 1979. </year>
Reference-contexts: The formal system is independent of any particular programming language and allows the inclusion of arbitrary specitcations as statements in a program. Hence it can be used to prove that a program is equivalent to a given specitcation. Program transformations are used in program development in <ref> [3, 4, 10, 11] </ref>. However their methods cannot cope with general specitcations or with transforming programs into specitcations.
Reference: [12] <author> Bauer, F. L. and Samelson, K. (Eds), </author> <title> Language Hierarchies and Interfaces, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 46, </volume> <publisher> Springer Verlag 1976. </publisher>
Reference: [13] <editor> Goos, G. and Hartmanis, H. (Eds), </editor> <booktitle> Program Construction, Lecture Notes in Computer Science, </booktitle> <volume> Volume 69, </volume> <publisher> Springer Verlag 1979. </publisher>
Reference: [14] <author> Johnson, W.L. and Soloway, E., </author> <title> PROUST, </title> <journal> Byte, vol.10, </journal> <volume> no.4, </volume> <month> April </month> <year> 1985, </year> <month> pp.179-190. </month>
Reference-contexts: The lack of success of plan based systems such as PROUST <ref> [14, 15] </ref> and the Programmer's Apprentice [21] has led us to consider dierent solutions to the problem of understanding code. From some preliminary studies, the use of program transformations seems to have great potential in the area of program comprehension as well as program development.
Reference: [15] <author> Johnson, W.L. and Soloway, E., </author> <title> PROUST: Knowledge-Based Program Understanding, </title> <booktitle> in Proceedings Conference on Software Maintenance-1985, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <address> Washington DC., </address> <month> November </month> <year> 1985, </year> <note> pp.369-380. Also in Readings in Artitcial Intelligence and Software Engineering. </note>
Reference-contexts: The lack of success of plan based systems such as PROUST <ref> [14, 15] </ref> and the Programmer's Apprentice [21] has led us to consider dierent solutions to the problem of understanding code. From some preliminary studies, the use of program transformations seems to have great potential in the area of program comprehension as well as program development.
Reference: [16] <author> Letovsky, S., </author> <title> Cognitive Processes in Program Comprehension, </title> <booktitle> in Proceedings of the Conference on Empirical Studies of Programmers, </booktitle> <year> 1986. </year>
Reference-contexts: We will discuss each of these in turn. 2.1.1 Maintenance Knowledge This will be knowledge about how maintenance programmers do their work. This knowledge will have to be elicited from expert maintainers using knowledge elicitation techniques similar to those described by Letovsky and Soloway <ref> [16, 17, 18] </ref> in their work on delocalised plans.
Reference: [17] <author> Letovsky, S. and Soloway, E., </author> <title> Strategies for Documenting Delocalized Plans, </title> <booktitle> in Proceedings of the Conference on Software Maintenance 1985, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <address> Washington DC., pp.144-151, </address> <month> November </month> <year> 1985. </year>
Reference-contexts: We will discuss each of these in turn. 2.1.1 Maintenance Knowledge This will be knowledge about how maintenance programmers do their work. This knowledge will have to be elicited from expert maintainers using knowledge elicitation techniques similar to those described by Letovsky and Soloway <ref> [16, 17, 18] </ref> in their work on delocalised plans.
Reference: [18] <author> Letovsky, S. and Soloway, E., </author> <title> Delocalized Plans and Program Comprehension, </title> <journal> IEEE Software, vol.3, no.3, </journal> <volume> pp.41-49, </volume> <month> May </month> <year> 1986. </year>
Reference-contexts: We will discuss each of these in turn. 2.1.1 Maintenance Knowledge This will be knowledge about how maintenance programmers do their work. This knowledge will have to be elicited from expert maintainers using knowledge elicitation techniques similar to those described by Letovsky and Soloway <ref> [16, 17, 18] </ref> in their work on delocalised plans.
Reference: [19] <author> Munro, M. and Robson, D., </author> <title> An Interactive Cross Reference Tool for use in Software Maintenance, </title> <booktitle> in Proceedings of the 20 th Hawaii International Conference on System Sciences, Vol.II, Software, </booktitle> <editor> ed. Shriver, B.D., </editor> <publisher> Western Periodicals Company, </publisher> <address> California. pp.64-70. </address>
Reference-contexts: Some work has already been carried out in this area at Durham with the development of interactive cross referencers <ref> [6, 19] </ref>. * Using the above information to determine the eects of a proposed moditcation (for instance to de termine which modules will be aected via the control and data ow from a modited module). 2.1 The Knowledge Bases Much of the knowledge is based on the concept of program plans.
Reference: [20] <author> Munro, M. and Ward, M., </author> <title> Intelligent Program Analysis Tools for Maintaining Software, </title> <booktitle> Alvey Directorate. </booktitle>
Reference-contexts: Various transformations to the program to reveal its structure and enable its eect to be summarised as a specitcation. 3.1 Preventive Maintenance This theoretical underpinning gives us the contdence to apply transformations to a program which is not (as yet) understood, as is shown in <ref> [20, 25] </ref>. In general, maintenance programmers are reluctant to make large changes to the source code of any program they are maintainingleast of all one which has yet to be understood fully, preferring instead to make additions and patches.
Reference: [21] <author> Rich, C., </author> <title> A Formal Representation for Plans in the Programmer's Apprentice, </title> <booktitle> in Proceedings of the Seventh International Joint Conference on Artitcial Intelligence, IJCAI, </booktitle> <address> Vancouver, </address> <note> August 24 th -28 th 1981, pp.1044-1053. Also in Readings in Artitcial Intelligence and Software Engineering. </note>
Reference-contexts: The lack of success of plan based systems such as PROUST [14, 15] and the Programmer's Apprentice <ref> [21] </ref> has led us to consider dierent solutions to the problem of understanding code. From some preliminary studies, the use of program transformations seems to have great potential in the area of program comprehension as well as program development.
Reference: [22] <author> Seviora, R.E., </author> <title> Knowledge-Based Program Debugging Systems, </title> <journal> IEEE Software, vol.4, no.3, </journal> <volume> pp.20-32, </volume> <month> May </month> <year> 1987. </year>
Reference-contexts: The danger with plan based tools is that the number of plans needed is so large, that for computing purposes it can be regarded as intnite. The plan library alone could take up all of the available on-line storage and still want more <ref> [22, 26] </ref>.For this reason the proposed tool will make use of plans, but will not be dependent on them.
Reference: [23] <author> Ward, M., </author> <title> Proving Program Retnements and Transformations, </title> <type> D.Phil Thesis, </type> <institution> Oxford University, </institution> <year> 1986. </year>
Reference-contexts: to achieve a desired eect (eg Can you move this piece of code to here?, Can you eliminate the two copies of this statement?, Please transform this recursive procedure into an equivalent iterative form). 3 Theoretical Foundation The proposed system will be based on a formal system developed by Ward <ref> [23, 24] </ref> in which it is possible to prove that two versions of a program are equivalent. The formal system is independent of any particular programming language and allows the inclusion of arbitrary specitcations as statements in a program. <p> These formulae are called weakest preconditions in [7]. Their value lies in the fact proved in [2] for iterative programs and extended in <ref> [23] </ref> to recursive programs that two programs are equivalent if and only if they have equivalent weakest preconditions. Thus proving the transformation of a program to a dierent form amounts to proving the equivalence of two formulaefor which all the apparatus of mathematical logic is available. <p> We can then prove the equivalence of two programs using the new constructs by proving that their detnitional transformations are equivalent. This method is used in <ref> [23] </ref> to introduce the exit from the middle of a loop, recursive procedures with parameters and local variables, functions and expressions with side eects.
Reference: [24] <author> Ward, M., </author> <title> Transforming a Program into a Specitcation, </title> <type> Comnputer Science Technical Report, 88/1, </type> <institution> University of Durham, </institution> <address> England. </address> <note> Being reviewed for publication. </note>
Reference-contexts: to achieve a desired eect (eg Can you move this piece of code to here?, Can you eliminate the two copies of this statement?, Please transform this recursive procedure into an equivalent iterative form). 3 Theoretical Foundation The proposed system will be based on a formal system developed by Ward <ref> [23, 24] </ref> in which it is possible to prove that two versions of a program are equivalent. The formal system is independent of any particular programming language and allows the inclusion of arbitrary specitcations as statements in a program. <p> This method is used in [23] to introduce the exit from the middle of a loop, recursive procedures with parameters and local variables, functions and expressions with side eects. These transformations are used in <ref> [24] </ref> which takes a published program (from [8]) which was written in such a way that the structure and eect of the program are very hard to discern.
Reference: [25] <author> Ward, M. Calliss, F.W. and Munro, M., </author> <title> The Use of Transformations in The Maintainer's Assistant Comnputer Science Technical Report, </title> <type> 88/9, </type> <institution> University of Durham, </institution> <address> England. </address> <note> Being reviewed for publication. </note>
Reference-contexts: Various transformations to the program to reveal its structure and enable its eect to be summarised as a specitcation. 3.1 Preventive Maintenance This theoretical underpinning gives us the contdence to apply transformations to a program which is not (as yet) understood, as is shown in <ref> [20, 25] </ref>. In general, maintenance programmers are reluctant to make large changes to the source code of any program they are maintainingleast of all one which has yet to be understood fully, preferring instead to make additions and patches.
Reference: [26] <author> Waters, </author> <title> R.C., The Programmer's Apprentice: A Session with KBEmacs, </title> <journal> IEEE Transactions on Software Engineering, vol.11, no.11, </journal> <volume> pp.1296-1320, </volume> <month> November </month> <year> 1981. </year> <note> Also in Readings in Artitcial Intelligence and Software Engineering. 6 </note>
Reference-contexts: The danger with plan based tools is that the number of plans needed is so large, that for computing purposes it can be regarded as intnite. The plan library alone could take up all of the available on-line storage and still want more <ref> [22, 26] </ref>.For this reason the proposed tool will make use of plans, but will not be dependent on them.
References-found: 26

