URL: http://www.cs.ucsb.edu/~schauser/papers/96-ipps.ps
Refering-URL: http://www.cs.ucsb.edu/~schauser/papers/
Root-URL: http://www.cs.ucsb.edu
Email: fschauser,chriss, ferguson,kolanog@cs.ucsb.edu  
Title: Exploiting the Capabilities of Communications Co-processors  
Author: Klaus E. Schauser, Chris J. Scheiman, J. Mitchell Ferguson, and Paul Z. Kolano 
Address: Santa Barbara, CA 93106  
Affiliation: Department of Computer Science University of California, Santa Barbara  
Abstract: Communications co-processors (CCPs) have become commonplace in modern MPPs and networks of workstations. These co-processors provide dedicated hardware support for fast communication. In this paper we study how to exploit the capabilities of CCPs for executing user level message handlers. We show, in the context of Active Messages and Split-C, that we can move message handling code to the co-processor thus freeing the main processor for computational work. We address the important issues that arise, such as synchronization, and the limited computational power and flexibility of CCPs. We have implemented co-processor versions of both Active Messages and Split-C. These implementations, developed on the Meiko CS-2, provide us with an excellent experimental platform to evaluate the benefits of a communications co-processor architecture. 
Abstract-found: 1
Intro-found: 1
Reference: [BCL + 95] <author> E. A. Brewer, F. T. Chong, L. T. Liu, S. D. Sharma, and J. Kubiatowicz. </author> <title> Remote Queues: Exposing Message Queues for Optimization and Atomicity. </title> <booktitle> In 7th Annual Symposium on Parallel Algorithms and Architectures, </booktitle> <month> July </month> <year> 1995. </year>
Reference-contexts: This scheme, which is described in more detail in [SSFK95], essentially implements a remote queue <ref> [BCL + 95] </ref> of depth one. In the second implementation of Active Messages, the CCP is used both on the sending and the receiving side. In this implementation, the main processor is no longer involved in the reception of messages. <p> Active Messages have been ported to a wide variety of machines, including the Ncube/2, CM-5 [vECGS92], the Paragon [LC95], Meiko CS-2 [SS95], Alewife <ref> [BCL + 95] </ref>, IBM SP-2 [CGvE95], a cluster of HP workstations connected by FDDI [Mar94], and a cluster of SparcStations connected by ATM [vEBBV95]. These last few implementations make use of a co-processor. In most of these implementations, the co-processor is used to implement the Remote Queue abstraction [BCL + 95]. <p> [SS95], Alewife <ref> [BCL + 95] </ref>, IBM SP-2 [CGvE95], a cluster of HP workstations connected by FDDI [Mar94], and a cluster of SparcStations connected by ATM [vEBBV95]. These last few implementations make use of a co-processor. In most of these implementations, the co-processor is used to implement the Remote Queue abstraction [BCL + 95]. The main processors can enqueue an outgoing message or dequeue an incoming message at user-level, while the co-processor manages the queue and protocol handling. The FDDI implementation uses a Medusa interface card, which enqueues and dequeues data, but is not programmable.
Reference: [BGSP94] <author> U. Bruening, W. K. Giloi, and W. Schroeder-Preikschat. </author> <title> Latency Hiding in Message-Passing Architectures. </title> <booktitle> In Eighth International Parallel Processing Symposium, </booktitle> <month> April </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Many modern parallel architectures, including networks of workstations, contain dedicated communications co-processors (CCPs) to support fast communication. Examples of architectures with CCPs include the Intel Paragon [PR94], Manna <ref> [BGSP94] </ref>, Meiko CS-2 [HM93], Flash [Kea94], Typhoon [RLW94], and cluster of workstations connected via ATM networks [vEBBV95]. These co-processors provide the protection, reliability, and protocol handling needed for communication, thus freeing the main processor for computational work.
Reference: [CDG + 93] <author> D. E. Culler, A. Dusseau, S. C. Golstein, A. Krish-namurthy, S. Lumetta, T. von Eicken, and K. Yelick. </author> <title> Parallel Programming in Split-C. </title> <booktitle> In Proc. of Supercomputing, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: Although they are quite primitive, Active Messages have become an important communication layer because of their efficiency. The small overhead and low latency facilitates building more complicated communication layers [TM94] and makes it a desirable target for high-level language compilers <ref> [CGSvE93, CDG + 93] </ref>. Over the past several years Active Messages have been implemented on many different hardware platforms. Several of these architectures have a communications co-processor, which is used to support reliable and protected communication. <p> So far only the Meiko CS-2 and the Intel Paragon have been used to run user level message handlers on the co-processor [KNW95, SS95]. 2.2 Split-C Split-C is a simple parallel extension of the C programming language <ref> [CDG + 93] </ref>. Split-C follows the SPMD model of computation: a single thread of computation is started on each processor. Both the parallelism and data layout is explicit and is specified by the programmer.
Reference: [CGSvE93] <author> D. E. Culler, S. C. Goldstein, K. E. Schauser, and T. von Eicken. </author> <title> TAM A Compiler Controlled Threaded Abstract Machine. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18, </volume> <month> July </month> <year> 1993. </year>
Reference-contexts: Although they are quite primitive, Active Messages have become an important communication layer because of their efficiency. The small overhead and low latency facilitates building more complicated communication layers [TM94] and makes it a desirable target for high-level language compilers <ref> [CGSvE93, CDG + 93] </ref>. Over the past several years Active Messages have been implemented on many different hardware platforms. Several of these architectures have a communications co-processor, which is used to support reliable and protected communication.
Reference: [CGvE95] <author> C.-C. Chang, C. Grzegorz, and T. von Eicken. </author> <title> Performance of Active Messages on the SP-2. </title> <institution> Cornell University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: Active Messages have been ported to a wide variety of machines, including the Ncube/2, CM-5 [vECGS92], the Paragon [LC95], Meiko CS-2 [SS95], Alewife [BCL + 95], IBM SP-2 <ref> [CGvE95] </ref>, a cluster of HP workstations connected by FDDI [Mar94], and a cluster of SparcStations connected by ATM [vEBBV95]. These last few implementations make use of a co-processor. In most of these implementations, the co-processor is used to implement the Remote Queue abstraction [BCL + 95].
Reference: [HM93] <author> M. Homewood and M. McLaren. </author> <title> Meiko CS-2 Interconnect Elan-Elite Design. </title> <booktitle> In Proc. of Hot Interconnects, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Many modern parallel architectures, including networks of workstations, contain dedicated communications co-processors (CCPs) to support fast communication. Examples of architectures with CCPs include the Intel Paragon [PR94], Manna [BGSP94], Meiko CS-2 <ref> [HM93] </ref>, Flash [Kea94], Typhoon [RLW94], and cluster of workstations connected via ATM networks [vEBBV95]. These co-processors provide the protection, reliability, and protocol handling needed for communication, thus freeing the main processor for computational work. <p> In the case of the Meiko CS-2, the co-processor provides features which we can exploit to further optimize this basic implementation. This is described in the next two sections. 4 The Meiko CS-2 Architecture The Meiko CS-2 consists of Sparc based nodes connected via a fat tree communication network <ref> [HM93] </ref>. It runs a slightly enhanced version of the Solaris 2.3 operating system on every node, and thus closely resembles a cluster of workstations connected by a fast network.
Reference: [Kea94] <author> J. Kuskin and et. al. </author> <title> The Stanford FLASH Multiprocessor. </title> <booktitle> In Proc. of the 21st International Symposium on Computer Architecture, </booktitle> <month> April </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Many modern parallel architectures, including networks of workstations, contain dedicated communications co-processors (CCPs) to support fast communication. Examples of architectures with CCPs include the Intel Paragon [PR94], Manna [BGSP94], Meiko CS-2 [HM93], Flash <ref> [Kea94] </ref>, Typhoon [RLW94], and cluster of workstations connected via ATM networks [vEBBV95]. These co-processors provide the protection, reliability, and protocol handling needed for communication, thus freeing the main processor for computational work.
Reference: [KNW95] <author> A. Krishnamurthy, J. Neefe, and R. Wang. </author> <title> Towards Designing and Evaluating Network Interface Support: A Case Study. </title> <institution> UC Berkeley, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: Since some communication co-processors can execute arbitrary code, it may be desirable for these co-processors to perform the message handling. In this paper we study how to exploit the capabilities of CCPs for executing user level message handlers. Executing message handlers on the co-processor provides a number of benefits <ref> [SS95, KNW95] </ref>. Since the co-processor is fully dedicated to communication, it is likely to serve incoming messages faster than the main processor. <p> Several of these architectures have a communications co-processor, which is used to support reliable and protected communication. So far only the Meiko CS-2 and the Intel Paragon have been used to run user level message handlers on the co-processor <ref> [KNW95, SS95] </ref>. 2.2 Split-C Split-C is a simple parallel extension of the C programming language [CDG + 93]. Split-C follows the SPMD model of computation: a single thread of computation is started on each processor. Both the parallelism and data layout is explicit and is specified by the programmer. <p> We have to ensure mutually exclusive access if we allow both the main and co-processor to update the same counter. Implementing this with locks can be quite expensive. As proposed by <ref> [KNW95] </ref>, a more efficient solution is to split the counter in two counters, using one counter for the main processor increments and the other for the co-processor decrements. This solves the synchronization problem. <p> Split-C has been ported to a number of machines, including the CM-5, Paragon, SP-1, SP-2, and networks of workstations. An interesting implementation is a recent prototype version of Split-C implemented on the Paragon, using the co-processor for message handling <ref> [KNW95] </ref>. By using the co-processor on the receiving side to handle requests, they provide a speed up of 25% for read/write operations. 7 Conclusions In this paper we have studied how to exploit the capabilities of communications co-processors present in modern parallel architectures.
Reference: [LC95] <author> L. T. Liu and D. E. Culler. </author> <title> Evaluation of the Intel Paragon on Active Message Communication. </title> <booktitle> In Proceedings of Intel Supercomputer Users Group Conference, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: Active Messages have been ported to a wide variety of machines, including the Ncube/2, CM-5 [vECGS92], the Paragon <ref> [LC95] </ref>, Meiko CS-2 [SS95], Alewife [BCL + 95], IBM SP-2 [CGvE95], a cluster of HP workstations connected by FDDI [Mar94], and a cluster of SparcStations connected by ATM [vEBBV95]. These last few implementations make use of a co-processor. <p> Similarly, the Myrinet LANai co-processor is used for both Active Messages [MLMC95] and Illinois Fast Messages [PLC95]. An interesting Active Message implementation from our perspective is a version for the Paragon <ref> [LC95] </ref>, which uses a standard Intel i860 as a CCP. They, too, implement Active Messages and Split-C in order to test the use of the CCP. Split-C shares its origin with Active Messages, and most implementations of the language are based on them.
Reference: [Mar94] <author> R. P. Martin. HPAM: </author> <title> An Active Message Layer for a Network of HP Workstations. </title> <booktitle> In Proc. of Hot Interconnects II, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: Active Messages have been ported to a wide variety of machines, including the Ncube/2, CM-5 [vECGS92], the Paragon [LC95], Meiko CS-2 [SS95], Alewife [BCL + 95], IBM SP-2 [CGvE95], a cluster of HP workstations connected by FDDI <ref> [Mar94] </ref>, and a cluster of SparcStations connected by ATM [vEBBV95]. These last few implementations make use of a co-processor. In most of these implementations, the co-processor is used to implement the Remote Queue abstraction [BCL + 95].
Reference: [MLMC95] <author> R. Martin, L. T. Liu, V. Makhija, and D. E. Culler. </author> <title> Lanai Active Messages. </title> <note> Online at http://now.cs.berkeley.edu/AM/lam release.html, </note> <month> September </month> <year> 1995. </year>
Reference-contexts: U-NET, a fast user-level communication layer on ATM networks, is implemented using FORE ATM cards, containing i960 processors that run specialized firmware. Similarly, the Myrinet LANai co-processor is used for both Active Messages <ref> [MLMC95] </ref> and Illinois Fast Messages [PLC95]. An interesting Active Message implementation from our perspective is a version for the Paragon [LC95], which uses a standard Intel i860 as a CCP. They, too, implement Active Messages and Split-C in order to test the use of the CCP.
Reference: [PLC95] <author> S. Pakin, M. Lauria, and A. Chien. </author> <title> High Performance Messaging on Workstations: Illinois Fast Messages (FM) for Myrinet. </title> <booktitle> In Supercomputing, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: U-NET, a fast user-level communication layer on ATM networks, is implemented using FORE ATM cards, containing i960 processors that run specialized firmware. Similarly, the Myrinet LANai co-processor is used for both Active Messages [MLMC95] and Illinois Fast Messages <ref> [PLC95] </ref>. An interesting Active Message implementation from our perspective is a version for the Paragon [LC95], which uses a standard Intel i860 as a CCP. They, too, implement Active Messages and Split-C in order to test the use of the CCP.
Reference: [PR94] <author> P. Pierce and G. Regnier. </author> <title> The Paragon implementation of the NX message passing interface. </title> <booktitle> In Proceedings of the Scalable High-Performance Computing Conference, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Many modern parallel architectures, including networks of workstations, contain dedicated communications co-processors (CCPs) to support fast communication. Examples of architectures with CCPs include the Intel Paragon <ref> [PR94] </ref>, Manna [BGSP94], Meiko CS-2 [HM93], Flash [Kea94], Typhoon [RLW94], and cluster of workstations connected via ATM networks [vEBBV95]. These co-processors provide the protection, reliability, and protocol handling needed for communication, thus freeing the main processor for computational work.
Reference: [RLW94] <author> S. K. Reinhardt, J. R. Larus, and D. A. Wood. Tempest and Typhoon: </author> <title> User-Level Shared Memory. </title> <booktitle> In Proceedings the 21st Annual International Symposium on Computer Architecture, </booktitle> <month> April </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Many modern parallel architectures, including networks of workstations, contain dedicated communications co-processors (CCPs) to support fast communication. Examples of architectures with CCPs include the Intel Paragon [PR94], Manna [BGSP94], Meiko CS-2 [HM93], Flash [Kea94], Typhoon <ref> [RLW94] </ref>, and cluster of workstations connected via ATM networks [vEBBV95]. These co-processors provide the protection, reliability, and protocol handling needed for communication, thus freeing the main processor for computational work.
Reference: [SS95] <author> K. E. Schauser and C. J. Scheiman. </author> <title> Experience with Active Messages on the Meiko CS-2. </title> <booktitle> In 9th International Parallel Processing Symposium, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: Since some communication co-processors can execute arbitrary code, it may be desirable for these co-processors to perform the message handling. In this paper we study how to exploit the capabilities of CCPs for executing user level message handlers. Executing message handlers on the co-processor provides a number of benefits <ref> [SS95, KNW95] </ref>. Since the co-processor is fully dedicated to communication, it is likely to serve incoming messages faster than the main processor. <p> Several of these architectures have a communications co-processor, which is used to support reliable and protected communication. So far only the Meiko CS-2 and the Intel Paragon have been used to run user level message handlers on the co-processor <ref> [KNW95, SS95] </ref>. 2.2 Split-C Split-C is a simple parallel extension of the C programming language [CDG + 93]. Split-C follows the SPMD model of computation: a single thread of computation is started on each processor. Both the parallelism and data layout is explicit and is specified by the programmer. <p> Active Messages have been ported to a wide variety of machines, including the Ncube/2, CM-5 [vECGS92], the Paragon [LC95], Meiko CS-2 <ref> [SS95] </ref>, Alewife [BCL + 95], IBM SP-2 [CGvE95], a cluster of HP workstations connected by FDDI [Mar94], and a cluster of SparcStations connected by ATM [vEBBV95]. These last few implementations make use of a co-processor.
Reference: [SSFK95] <author> K. Schauser, C. Scheiman, J. Ferguson, and P. Kolano. </author> <title> Exploiting the Capabilities of Communications Co-processors. </title> <type> Technical report, </type> <institution> UC Santa Barbara, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: This scheme, which is described in more detail in <ref> [SSFK95] </ref>, essentially implements a remote queue [BCL + 95] of depth one. In the second implementation of Active Messages, the CCP is used both on the sending and the receiving side. In this implementation, the main processor is no longer involved in the reception of messages. <p> Sampleb is the sample sort algorithm, but optimized with bulk store operations. Shell is the shell sort algorithm using bulk reads. Wator is a simulation program that models fish moving in a current; it uses a number of operations, including reads. For more information regarding our benchmarks, see <ref> [SSFK95] </ref>.
Reference: [TM94] <author> L. W. Tucker and A. Mainwaring. </author> <title> CMMD: Active Messages on the CM-5. </title> <journal> Parallel Computing, </journal> <volume> 20(4), </volume> <month> April </month> <year> 1994. </year>
Reference-contexts: In many forms of communication, when a message arrives, there is some action that must be performed to incorporate the data into the on-going computation. For example, this is the case with Active Messages, RPC, and tagged send & receive <ref> [TM94] </ref>. A message may match a tag, insert an item on a queue, increment a variable, or store something in memory. Executing these handler functions on the main processor incurs a high overhead, as the main processor must either use expensive interrupts or poll frequently for incoming messages. <p> Although they are quite primitive, Active Messages have become an important communication layer because of their efficiency. The small overhead and low latency facilitates building more complicated communication layers <ref> [TM94] </ref> and makes it a desirable target for high-level language compilers [CGSvE93, CDG + 93]. Over the past several years Active Messages have been implemented on many different hardware platforms. Several of these architectures have a communications co-processor, which is used to support reliable and protected communication.
Reference: [vEBBV95] <author> T. von Eicken, A. Basu, V. Buch, and W. Vogels. U-Net: </author> <title> A User-Level Network Interface for Parallel and Distributed Computing. </title> <booktitle> In Proc. Symposium on Operating Systems Principles, </booktitle> <year> 1995. </year>
Reference-contexts: 1 Introduction Many modern parallel architectures, including networks of workstations, contain dedicated communications co-processors (CCPs) to support fast communication. Examples of architectures with CCPs include the Intel Paragon [PR94], Manna [BGSP94], Meiko CS-2 [HM93], Flash [Kea94], Typhoon [RLW94], and cluster of workstations connected via ATM networks <ref> [vEBBV95] </ref>. These co-processors provide the protection, reliability, and protocol handling needed for communication, thus freeing the main processor for computational work. In many forms of communication, when a message arrives, there is some action that must be performed to incorporate the data into the on-going computation. <p> Active Messages have been ported to a wide variety of machines, including the Ncube/2, CM-5 [vECGS92], the Paragon [LC95], Meiko CS-2 [SS95], Alewife [BCL + 95], IBM SP-2 [CGvE95], a cluster of HP workstations connected by FDDI [Mar94], and a cluster of SparcStations connected by ATM <ref> [vEBBV95] </ref>. These last few implementations make use of a co-processor. In most of these implementations, the co-processor is used to implement the Remote Queue abstraction [BCL + 95].
Reference: [vECGS92] <author> T. von Eicken, D. E. Culler, S. C. Goldstein, and K. E. Schauser. </author> <title> Active Messages: a Mechanism for Integrated Communication and Computation. </title> <booktitle> In Proc. of the 19th International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: In this paper, we evaluate the handling of messages by the co-processor in the context of Active Messages and Split-C. Active Messages associate with each message a handler function, which is executed on the receiving processor upon arrival of the message <ref> [vECGS92] </ref>. In order to evaluate our approach under large parallel applications, we also implemented Split-C, a simple parallel extension of the C programming language. Using Split-C gives us access to a large set of parallel programs. <p> Section 5 evaluates the performance of our Split-C library implementation. Section 6 discusses related work. Finally, Section 7 summarizes our experiences and concludes. 2 Active Messages and Split-C Active Messages provide a universal communications architecture which is frequently used by compiler and library writers <ref> [vECGS92] </ref>. Split-C is a C-based parallel language which makes use of Active Messages. <p> Active Messages have been ported to a wide variety of machines, including the Ncube/2, CM-5 <ref> [vECGS92] </ref>, the Paragon [LC95], Meiko CS-2 [SS95], Alewife [BCL + 95], IBM SP-2 [CGvE95], a cluster of HP workstations connected by FDDI [Mar94], and a cluster of SparcStations connected by ATM [vEBBV95]. These last few implementations make use of a co-processor.
References-found: 19

