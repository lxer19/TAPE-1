URL: http://www.cs.wisc.edu/wpis/papers/tr840.ps
Refering-URL: http://www.cs.wisc.edu/wpis/papers/
Root-URL: http://www.cs.wisc.edu
Title: Detecting Program Components With Equivalent Behaviors  
Author: WUU YANG, SUSAN HORWITZ, and THOMAS REPS 
Keyword: Categories and Subject Descriptors: D.3.4 [Programming Languages]: Processors compilers, interpreters, optimization; E.1 [Data Structures] graphs General Terms: Algorithms, Theory Additional Key Words and Phrases: coarsest partition, control dependence, data congruence, data dependence, data-flow analysis, execution behavior, program dependence graph, program representation graph, sequence congruence, static-single-assignment form, termination  
Address: Wisconsin Madison  
Affiliation: University of  
Abstract: The execution behavior of a program component is defined as the sequence of values produced at the component during program execution. This paper presents an efficient algorithm for detecting program components in one or more programs that exhibit identical execution behaviors. The algorithm operates on a new graph representation for programs that combines features of static-single-assignment forms and program dependence graphs. The result provides insight into the relationship between execution behaviors and (control and flow) dependences in the program. The algorithm, called the Sequence-Congruence Algorithm, is applicable to programs written in a language that includes scalar variables and constants, assignment statements, conditional statements, and while-loops. The Sequence-Congruence Algorithm can be used as the basis for an algorithm for integrating program variants. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Aho, A., Hopcroft, J.E., and Ullman, J., </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1974). </address>
Reference-contexts: Definition. 4 Vertices are data-congruent if they are in the same class after the first pass of partitioning. hhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 9 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh The initial partition is B <ref> [1] </ref>, B [2], ..., B [p] WAITING := - 1, 2,..., p - q := p while WAITING do select and delete an integer i from WAITING for each type m of edge do FOLLOWER := for each vertex u in B [i] do FOLLOWER := FOLLOWER m-successor (u) od for
Reference: 2. <author> Aho, A., Sethi, R., and Ullman, J., </author> <booktitle> Compilers: Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1986). </address>
Reference-contexts: Definition. 4 Vertices are data-congruent if they are in the same class after the first pass of partitioning. hhhhhhhhhhhhhhhhhhhhhhhhhhhhh - 9 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh The initial partition is B [1], B <ref> [2] </ref>, ..., B [p] WAITING := - 1, 2,..., p - q := p while WAITING do select and delete an integer i from WAITING for each type m of edge do FOLLOWER := for each vertex u in B [i] do FOLLOWER := FOLLOWER m-successor (u) od for each j
Reference: 3. <author> Alpern, B., </author> <type> Personal communication, </type> <month> September </month> <year> 1988. </year>
Reference-contexts: property that holds for slices of program dependence graphs the Feasibility Lemma of [12].) For instance, if non-live f vertices were required in PRGs, the example given above would be hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 7 It has been recognized by others that variable renaming is not necessary for all uses of SSA forms <ref> [3] </ref>. - 21 - L 1 x := 1 if p then x := 2 fi a := f if (a) Its slice with respect to L 2 would correspond to the fragment a := 0 if p then x := 2 fi L 2 x := 3 + a However,
Reference: 4. <author> Alpern, B., Wegman, M.N., and Zadeck, F.K., </author> <title> Detecting equality of variables in programs, pp. </title> <booktitle> 1-11 in Conference Record of the Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), </year> <booktitle> ACM, </booktitle> <address> New York (1988). </address>
Reference-contexts: These graphs are called program representation graphs in this paper to distinguish them from other related representations. As explained in Section 3, program representation graphs combine features of static-single-assignment forms [15,4,5,14] and program dependence graphs [11,6,9]. The Sequence-Congruence Algorithm is based on an idea of <ref> [4] </ref> for finding equivalence classes of program components by first optimistically grouping possibly equivalent components in an initial partition and then finding the coarsest partition consistent with the initial partition. However, in refining the initial partition, the algorithm of [4] considers only flow dependences among program components. <p> The Sequence-Congruence Algorithm is based on an idea of <ref> [4] </ref> for finding equivalence classes of program components by first optimistically grouping possibly equivalent components in an initial partition and then finding the coarsest partition consistent with the initial partition. However, in refining the initial partition, the algorithm of [4] considers only flow dependences among program components. It is shown in [4] that components in the same partition produce the same values at certain moments during execution. <p> However, in refining the initial partition, the algorithm of <ref> [4] </ref> considers only flow dependences among program components. It is shown in [4] that components in the same partition produce the same values at certain moments during execution. In contrast, the Sequence-Congruence Algorithm given in this paper considers control dependences as well as flow dependences and can detect components whose execution behaviors are identical. <p> In contrast, the Sequence-Congruence Algorithm given in this paper considers control dependences as well as flow dependences and can detect components whose execution behaviors are identical. A further point of contrast between our work and that of <ref> [4] </ref> concerns the idea of applying partitioning to more than one program simultaneously. This idea was not studied in [4], and the semantic property proved there concerning congruent vertices does not characterize the result of applying the algorithm to multiple programs simultaneously. The algorithm from [4] is essentially the first phase <p> A further point of contrast between our work and that of <ref> [4] </ref> concerns the idea of applying partitioning to more than one program simultaneously. This idea was not studied in [4], and the semantic property proved there concerning congruent vertices does not characterize the result of applying the algorithm to multiple programs simultaneously. The algorithm from [4] is essentially the first phase of our Sequence-Congruence Algorithm, and our first result (the Data-Congruence Lemma) establishes a semantic property of vertices in the <p> our work and that of <ref> [4] </ref> concerns the idea of applying partitioning to more than one program simultaneously. This idea was not studied in [4], and the semantic property proved there concerning congruent vertices does not characterize the result of applying the algorithm to multiple programs simultaneously. The algorithm from [4] is essentially the first phase of our Sequence-Congruence Algorithm, and our first result (the Data-Congruence Lemma) establishes a semantic property of vertices in the same equivalence class when the algorithm is applied to multiple programs. <p> After the second pass of partitioning, the final partition is &lt;A0, B0&gt;, &lt;A1&gt;, &lt;B1&gt;, &lt;A2, B2&gt;, &lt;A3, B3&gt;, and &lt;A4, B4&gt;. Note that A1 and B1 are no longer in the same class; thus, A 1 and B 1 are data hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 4 Our terminology differs from that of <ref> [4] </ref>: our concept of data-congruence is similar to that of congruence in [4]; our concept of sequence-congruence is a new concept that does not appear in [4]. - 10 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Pass 1: Add an if-edge from every if predicate to each associated f if vertex. <p> Note that A1 and B1 are no longer in the same class; thus, A 1 and B 1 are data hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 4 Our terminology differs from that of <ref> [4] </ref>: our concept of data-congruence is similar to that of congruence in [4]; our concept of sequence-congruence is a new concept that does not appear in [4]. - 10 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Pass 1: Add an if-edge from every if predicate to each associated f if vertex. Add a while-edge from every while predicate to each associated f exit vertex. <p> B1 are no longer in the same class; thus, A 1 and B 1 are data hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 4 Our terminology differs from that of <ref> [4] </ref>: our concept of data-congruence is similar to that of congruence in [4]; our concept of sequence-congruence is a new concept that does not appear in [4]. - 10 - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Pass 1: Add an if-edge from every if predicate to each associated f if vertex. Add a while-edge from every while predicate to each associated f exit vertex. The starting partition is based on the operators in the vertices as stated in the text. <p> Since a vertex enclosed in a loop may be executed repeatedly, a vertex is active at a moment t (defined below) if the appropriate value produced at the vertex is available for use at t <ref> [4] </ref>. Definition. <p> RELATION TO PREVIOUS WORK Program representation graphs combine features of both program dependence graphs [11,6,9] and static-single-assignment forms [4,14,5] (especially the value graph associated with an SSA form <ref> [4] </ref>). Although program dependence graphs contain no f vertices they do contain additional data-dependence edges not found in program representation graphs. For example, the program dependence graphs used in [9] contain def-order dependence edges. <p> The Sequence-Congruence Algorithm is based on an idea of <ref> [4] </ref> for finding equivalence classes of program components by first optimistically grouping possibly equivalent components in an initial partition (of an SSA form's value graph) and then finding the coarsest partition of the graph's vertices that is consistent with the initial partition. The algorithm of [4] considers only flow dependences among <p> based on an idea of <ref> [4] </ref> for finding equivalence classes of program components by first optimistically grouping possibly equivalent components in an initial partition (of an SSA form's value graph) and then finding the coarsest partition of the graph's vertices that is consistent with the initial partition. The algorithm of [4] considers only flow dependences among program components. The property established in [4] shows that components of a single program in the same partition produce the same values at certain moments during execution. <p> The algorithm of <ref> [4] </ref> considers only flow dependences among program components. The property established in [4] shows that components of a single program in the same partition produce the same values at certain moments during execution. Stated using our terminology: If two data-congruent components are both active at some moment, they have produced the same values. In contrast to [4], our Sequence-Congruence Algorithm has two important <p> The property established in <ref> [4] </ref> shows that components of a single program in the same partition produce the same values at certain moments during execution. Stated using our terminology: If two data-congruent components are both active at some moment, they have produced the same values. In contrast to [4], our Sequence-Congruence Algorithm has two important properties: (1) By considering control dependences as well as data dependences, it is able to detect components with equivalent execution behaviors, and (2) it is able to do so even if the components are in different programs. The algorithm of [4] is essentially the <p> In contrast to <ref> [4] </ref>, our Sequence-Congruence Algorithm has two important properties: (1) By considering control dependences as well as data dependences, it is able to detect components with equivalent execution behaviors, and (2) it is able to do so even if the components are in different programs. The algorithm of [4] is essentially the first pass of our Sequence-Congruence Algorithm. An important difference is that our algorithm can be applied to one or more programs.
Reference: 5. <author> Cytron, R., Ferrante, J., Rosen, B.K., Wegman, M.N., and Zadeck, K., </author> <title> An efficient method of computing static single assignment form, pp. </title> <booktitle> 25-35 in Conference Record of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Aus-tin, TX, </address> <month> Jan. </month> <pages> 11-13, </pages> <address> 1989), </address> <publisher> ACM, </publisher> <address> New York, NY (1989). </address>
Reference: 6. <author> Ferrante, J., Ottenstein, K., and Warren, J., </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Transactions on Programming Languages and Systems 9(3) pp. </journal> <month> 319-349 (July </month> <year> 1987). </year>
Reference-contexts: The program dependence graph defined in <ref> [6] </ref> introduced the additional feature of an explicit representation for control dependences. The program representation graph, defined below, has edges that represent control dependences and one kind of data dependence, called flow dependence.
Reference: 7. <author> Hopcroft, </author> <title> J.E., An n log n algorithm for minimizing the states of a finite automaton, </title> <booktitle> The Theory of Machines and Computations, </booktitle> <pages> pp. </pages> <month> 189-196 </month> <year> (1971). </year>
Reference-contexts: The partitioning algorithm in Figure 2 is adapted from [4,1], which is based on an algorithm of <ref> [7] </ref> for minimizing a finite state machine. The m-successors of a vertex u are the vertices v such that there is an edge u fi v of type m.
Reference: 8. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> Integrating non-interfering versions of programs, </title> <type> Technical Report 690, </type> <institution> Department of Computer Sciences, University of WisconsinMadison (March 1987). </institution>
Reference-contexts: The flow dependence edges of a program representation graph are computed using data-flow analysis. For the restricted language considered in this paper, the necessary computations can be defined in a syntax-directed manner (see <ref> [8] </ref>). The imported variables of a program P, denoted by Imp P , are the variables that might be used before being defined in P, i.e., the variables for which there are Initialize vertices in the PRG of P. Textually different programs may have isomorphic program representation graphs.
Reference: 9. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> Integrating non-interfering versions of programs, pp. </title> <booktitle> 133-145 in Conference Record of the 15th ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), </year> <booktitle> ACM, </booktitle> <address> New York (1988). </address>
Reference-contexts: The reason for our interest in detecting components of different programs that have identical execution behaviors is that such information is fundamental to our algorithm for automatic program integration <ref> [9] </ref>. <p> One of the key issues in program integration is how to determine whether a component of a variant has the same execution behavior as the corresponding component of Base. The integration algorithm of <ref> [9] </ref> compares program slices as a safe way of determining whether two program components have identical hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 The slice of a program with respect to a program component c is (roughly) all the statements and predicates in the program that can potentially affect the values produced at c during program <p> with unrestricted flow of control are given in [6,5]; however, for our restricted language, control dependence edges can be determined in a simpler fashion: Except for the extra control dependence edge incident on a f enter vertex, the control dependence edges merely reflect the nesting structure of the program (see <ref> [9] </ref>.) A flow dependence edge from a vertex u to a vertex v, denoted by u fi f v, means that the value produced at u may be used at v. <p> It is not unreasonable to expect that vertices with the same operators, equivalent operands, and equivalent controlling predicates will have the same execution behaviors. This expectation is confirmed by the Sequence-Congruence Theorem, which is proved in Section 4.2. hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 3 In the program dependence graphs of <ref> [9] </ref>, the control dependence edge from a while predicate to itself is omitted. However, such edges are needed for the Sequence-Congruence Algorithm, so they are included in program representation graphs. - 7 - The Sequence-Congruence Algorithm consists of two passes. <p> Although program dependence graphs contain no f vertices they do contain additional data-dependence edges not found in program representation graphs. For example, the program dependence graphs used in <ref> [9] </ref> contain def-order dependence edges. We have shown elsewhere that PRGs and the program dependence graphs of [9] are equivalent program representations in the sense that two programs have isomorphic PRGs if and only if their program dependence graphs are isomorphic [17]. <p> Although program dependence graphs contain no f vertices they do contain additional data-dependence edges not found in program representation graphs. For example, the program dependence graphs used in <ref> [9] </ref> contain def-order dependence edges. We have shown elsewhere that PRGs and the program dependence graphs of [9] are equivalent program representations in the sense that two programs have isomorphic PRGs if and only if their program dependence graphs are isomorphic [17]. In essence, the f vertices of program representation graphs introduce extra flow dependence edges that substitute for def-order dependence edges. <p> For example, the same PRG represents not only the program shown above, but also a version of the program in which L 1 comes after the if statement (but before L 2 ). As shown elsewhere [17], PRGs and the program dependence graphs of <ref> [9] </ref> are equivalent program representations in the sense that two programs have isomorphic PRGs if and only if their program dependence graphs are isomorphic. <p> Our work on program representation graphs and the Sequence-Congruence Algorithm has been motivated by the desire to improve our techniques for automatic program integration <ref> [9] </ref>. <p> One of the key issues of program integration is to determine whether the execution behavior of a program component in one of the variants differs from that of the corresponding component in the base program. In the integration algorithm of <ref> [9] </ref>, this is done by finding corresponding program components whose slices are not isomorphic. The justification for this approach is found in [12] where (for the same language considered in this paper) it is shown that program components with isomorphic slices have identical execution behaviors. <p> We have devised a new algorithm for program integration, described in [16], that makes use of the Sequence-Congruence Algorithm. This algorithm has several advantages when compared with the integration algorithm described in <ref> [9] </ref>. One advantage concerns the ability of users to rename variables: because the algorithm from [9] detects changed execution behavior by comparing program slices, all program elements that depend on a variable whose name has been changed will be considered to have different execution behavior. <p> We have devised a new algorithm for program integration, described in [16], that makes use of the Sequence-Congruence Algorithm. This algorithm has several advantages when compared with the integration algorithm described in <ref> [9] </ref>. One advantage concerns the ability of users to rename variables: because the algorithm from [9] detects changed execution behavior by comparing program slices, all program elements that depend on a variable whose name has been changed will be considered to have different execution behavior. This increases the likelihood that the integration algorithm will report that two users' modifications are in conflict. <p> Thus, a second advantage of the new integration algorithm is that it can accommodate a limited class of meaning-preserving structural changes and not report some of the spurious conflicts that would be reported by the algorithm from <ref> [9] </ref>. ACKNOWLEDGEMENTS. Thanks are due to Bowen Alpern for his participation in early discussions that led to the results reported in this paper. - 23 -
Reference: 10. <author> Kuck, D. J., Muraoka, Y., and Chen, S. C., </author> <title> On the number of operations simultaneously executable in FORTRAN-like programs and their resulting speed-up, </title> <journal> IEEE Transactions on Computers C-21, </journal> <pages> pp. </pages> <month> 1293-1310 (December </month> <year> 1972). </year>
Reference-contexts: Both assignments to x at L 1 and L 2 can reach the use of x at L 3 . - 4 - Different definitions of program dependence graphs have been given, depending on the intended application; nevertheless, they are all variations on a theme introduced in <ref> [10] </ref>, and share the common feature of having an explicit representation of data dependences. The program dependence graph defined in [6] introduced the additional feature of an explicit representation for control dependences.
Reference: 11. <author> Kuck, D.J., Kuhn, R.H., Leasure, B., Padua, D.A., and Wolfe, M., </author> <title> Dependence graphs and compiler optimizations, pp. </title> <booktitle> 207-218 in Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Williamsburg, VA, </address> <month> January 26-28, </month> <year> 1981), </year> <booktitle> ACM, </booktitle> <address> New York (1981). </address>
Reference: 12. <author> Reps, T. and Yang, W., </author> <title> The semantics of program slicing, </title> <type> Technical Report 777, </type> <institution> Department of Computer Sciences, </institution> <note> University of WisconsinMadison (June 1988). </note>
Reference-contexts: We wished to have the property that any slice of a PRG would be (isomorphic to) the PRG of some program. (This corresponds to a similar property that holds for slices of program dependence graphs the Feasibility Lemma of <ref> [12] </ref>.) For instance, if non-live f vertices were required in PRGs, the example given above would be hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 7 It has been recognized by others that variable renaming is not necessary for all uses of SSA forms [3]. - 21 - L 1 x := 1 if p then x := <p> In the integration algorithm of [9], this is done by finding corresponding program components whose slices are not isomorphic. The justification for this approach is found in <ref> [12] </ref> where (for the same language considered in this paper) it is shown that program components with isomorphic slices have identical execution behaviors. The Sequence-Congruence Algorithm given in this paper provides a different method for determining whether program components in two programs have different execution behaviors.
Reference: 13. <author> Reps, T. and Yang, W., </author> <title> The semantics of program slicing and program integration, pp. </title> <booktitle> 360-374 in Proceedings of the Colloquium on Current Issues in Programming Languages, </booktitle> <address> (Barcelona, Spain, March 13-17, </address> <year> 1989), </year> <booktitle> Lecture Notes in Computer Science Vol. </booktitle> <volume> 352, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (March 1989). </address>
Reference: 14. <author> Rosen, B., Wegman, M.N., and Zadeck, F.K., </author> <title> Global value numbers and redundant computations, pp. </title> <booktitle> 12-27 in Conference Record of the Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), </year> <booktitle> ACM, </booktitle> <address> New York (1988). </address>
Reference: 15. <author> Shapiro, R. M. and Saint, H., </author> <title> The representation of algorithms, </title> <institution> Technical Reprot CA-7002-1432, Massachusetts Computer Associates (February 1970). </institution>
Reference: 16. <author> Yang, W., Horwitz, S., and Reps, T., </author> <title> A new program integration algorithm, </title> <type> Technical Report 899, </type> <institution> Department of Computer Sciences, University of Wisconsin, Madison, </institution> <note> WI (December 1989). </note>
Reference-contexts: It can be shown that the Sequence-Congruence Algorithm finds larger equivalence classes than the method based on comparing program slices. A new algorithm for automatic program integration that makes use of the Sequence-Congruence Algorithm is described in <ref> [16] </ref>. The remainder of this paper is organized into four sections, as follows: Section 2 describes the programming language under consideration in this paper. Section 3 defines program representation graphs. Section 4 presents the Sequence-Congruence Algorithm and justifies the algorithm. <p> It is easy to see that the equivalence classes found by the Sequence-Congruence Algorithm are strictly larger than those found by comparing slices. We have devised a new algorithm for program integration, described in <ref> [16] </ref>, that makes use of the Sequence-Congruence Algorithm. This algorithm has several advantages when compared with the integration algorithm described in [9].
Reference: 17. <author> Yang, W., Horwitz, S., and Reps, T., </author> <title> The semantic properties of program representation graphs, </title> <note> Technical Report (in preparation), </note> <institution> Department of Computer Sciences, University of Wisconsin, Madison, WI (1989). </institution>
Reference-contexts: Textually different programs may have isomorphic program representation graphs. However, we have shown that if two programs have isomorphic program representation graphs, then the programs are semantically equivalent <ref> [17] </ref>: THEOREM. (EQUIVALENCE THEOREM FOR PROGRAM REPRESENTATION GRAPHS). Suppose P and Q are programs for which R P is isomorphic to R Q . <p> For example, the program dependence graphs used in [9] contain def-order dependence edges. We have shown elsewhere that PRGs and the program dependence graphs of [9] are equivalent program representations in the sense that two programs have isomorphic PRGs if and only if their program dependence graphs are isomorphic <ref> [17] </ref>. In essence, the f vertices of program representation graphs introduce extra flow dependence edges that substitute for def-order dependence edges. There are two main differences between our PRGs and (the value graphs of) SSA forms: (1) PRGs contain control dependence edges, whereas SSA forms do not. <p> For example, the same PRG represents not only the program shown above, but also a version of the program in which L 1 comes after the if statement (but before L 2 ). As shown elsewhere <ref> [17] </ref>, PRGs and the program dependence graphs of [9] are equivalent program representations in the sense that two programs have isomorphic PRGs if and only if their program dependence graphs are isomorphic. <p> if (x ) just after the if statement, it does not correspond to the program a := 0 if p then x := 2 fi By excluding non-live f statements from PRGs, infeasible slices do not arise; every slice of a PRG is (isomorphic to) the PRG of some program <ref> [17] </ref>.
References-found: 17

