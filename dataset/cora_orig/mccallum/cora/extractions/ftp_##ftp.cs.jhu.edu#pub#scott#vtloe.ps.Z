URL: ftp://ftp.cs.jhu.edu/pub/scott/vtloe.ps.Z
Refering-URL: http://www.cs.jhu.edu/tech-report/reports93.html
Root-URL: http://www.cs.jhu.edu
Email: honsell@uduniv.cineca.it  iam@cs.stanford.edu  scott@cs.jhu.edu  clt@sail.stanford.edu  
Title: A Variable Typed Logic of Effects  
Author: Furio Honsell Ian A. Mason Scott Smith Carolyn Talcott F. Honsell, I. Mason, S. Smith and C. Talcott 
Date: 24 September 1993  
Note: Copyright c 1993 by  Information Computation Pre-galley Final (C1249)  
Affiliation: Udine University  Stanford University  Johns Hopkins University  Stanford University  
Abstract: In this paper we introduce a variable typed logic of effects inspired by the variable type systems of Feferman for purely functional languages. VTLoE (Variable Typed Logic of Effects) is introduced in two stages. The first stage is the first-order theory of individuals built on assertions of equality (operational equivalence a la Plotkin), and contextual assertions. The second stage extends the logic to include classes and class membership. The logic we present provides an expressive language for defining and studying properties of programs including program equivalences, in a uniform framework. The logic combines the features and benefits of equational calculi as well as program and specification logics. In addition to the usual first-order formula constructions, we add contextual assertions. Contextual assertions generalize Hoare's triples in that they can be nested, used as assumptions, and their free variables may be quantified. They are similar in spirit to program modalities in dynamic logic. We use the logic to establish the validity of the Meyer Sieber examples in an operational setting. The theory allows for the construction of inductively defined sets and derivation of the corresponding induction principles. We hope that classes may serve as a starting point for studying semantic notions of type. Nave attempts to represent ML types as classes fail in sense that ML inference rules are not valid. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Abadi, M., Pierce, B., and Plotkin, G. </author> <year> (1991). </year> <title> Faithful ideal models for recursive polymorphic types. </title> <journal> International Journal of Foundations of Computer Science, </journal> <volume> 2(1) </volume> <pages> 1-21. </pages>
Reference-contexts: ) : (set (x; y); Nil) V (3) i&lt;n : (x i ; t i ) ) (( : (e; t a ! t b ) ^ : (e a ; t a )) ) ( : (app (e; e a ); t b ) The principle of type faithfulness <ref> (Abadi et al., 1991) </ref> e a ~ = e b ) (( i&lt;n ^ : (x i ; t i ) ) : (e b ; t ))) is also a desirable property.
Reference: <author> Abramsky, S. </author> <year> (1990). </year> <title> The lazy lambda calculus. </title> <editor> In Turner, D., editor, </editor> <booktitle> Research Topics in Functional Programming. </booktitle> <publisher> Addison-Wesley. </publisher>
Reference: <author> Abramsky, S. </author> <year> (1991). </year> <title> Domain theory in logical form. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51(1) </volume> <pages> 1-77. </pages>
Reference: <author> Agha, G., Mason, I. A., Smith, S. F., and Talcott, C. L. </author> <year> (1993). </year> <title> A foundation for actor computation. </title> <note> submitted to the journal of functional programming. </note>
Reference-contexts: This is just one way of doing the bookkeeping for the symbolic evaluation. This kind of hygiene can also be taken care of automatically by introducing schematic variables with associated substitutions (c.f. (Talcott, 1991)). This symbolic or parametric reduction of contexts is explored in more detail in <ref> (Agha et al., 1993) </ref>. The following two lemmas are key in developing methods for reasoning about contextual assertions, and illustrate the basic ideas in reasoning about computation with contextual assertions.
Reference: <author> Apt, K. </author> <year> (1981). </year> <title> Ten years of Hoare's logic: A survey-part I. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4 </volume> <pages> 431-483. </pages>
Reference-contexts: This model uses a categorical notion called relational parametricity to capture locality. Full abstraction for this model remains an open problem. In recent years various systems for reasoning about properties of programs written in general programming languages have been proposed, most notably Hoare's logic <ref> (Apt, 1981) </ref>, Dynamic logic (Harel, 1984), Reynolds Specification Logic (Reynolds, 1982), Moggi's metalanguage for computational monads (Moggi, 1991), and Pitt's Evaluation Logic (Pitts, 1990).
Reference: <author> Bloom, B. </author> <year> (1990). </year> <title> Can LCF be topped? Information and Computation, </title> <booktitle> 87 </booktitle> <pages> 264-301. </pages>
Reference: <author> Crank, E. and Felleisen, M. </author> <year> (1991). </year> <title> Parameter-passing and the lambda-calculus. </title> <booktitle> In Proceedings of the 18th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 233-245. </pages>
Reference: <author> Damas, L. </author> <year> (1985). </year> <title> Type Assignment in Programming Languages. </title> <type> PhD thesis, </type> <institution> Edinburgh University. </institution>
Reference: <author> Egidi, L., Honsell, F., and Ronchi della Rocca, S. </author> <year> (1992). </year> <title> Operational, denotational and logical descriptions: a case study. </title> <journal> Fundamenta Informaticae, </journal> <volume> 16(2) </volume> <pages> 149-170. </pages>
Reference: <author> Feferman, S. </author> <year> (1975). </year> <title> A language and axioms for explicit mathematics. </title> <booktitle> In Algebra and Logic, volume 450 of Springer Lecture Notes in Mathematics, </booktitle> <pages> pages 87-139. </pages> <publisher> Springer Verlag. </publisher>
Reference: <author> Feferman, S. </author> <year> (1979). </year> <title> Constructive theories of functions and classes. </title> <booktitle> In Logic Colloquium '78, </booktitle> <pages> pages 159-224. </pages> <publisher> North-Holland. </publisher>
Reference: <author> Feferman, S. </author> <year> (1985). </year> <title> A theory of variable types. </title> <journal> Revista Colombiana de Matematicas, </journal> <volume> 19 </volume> <pages> 95-105. </pages>
Reference: <author> Feferman, S. </author> <year> (1990). </year> <title> Polymorphic typed lambda-calculi in a type-free axiomatic framework. </title> <booktitle> In Logic and Computation, volume 106 of Contemporary Mathematics, </booktitle> <pages> pages 101-136. </pages>
Reference-contexts: At the other end of the spectrum there is the function space that corresponds to those operations that return appropriate values without even enlarging memory, let alone altering existing memory. It was hoped that classes would serve as a starting point for studying semantic notions of type. <ref> (Feferman, 1990) </ref> proposes an explanation of ML types in the variable type framework. This gives a natural semantics to ML type expressions, but there are problems with polymorphism, even in the purely functional case. <p> Classes vs Types 5.5.1. The Functional Case <ref> (Feferman, 1990) </ref> proposes an explanation of ML types in the variable type framework. This gives a natural semantics to ML type expressions, but there are problems with poly-morphism, even in the purely functional case. The collection of classes is much too rich to be considered a type system.
Reference: <author> A.M.S., Providence R. I. 59 Felleisen, M. </author> <year> (1987). </year> <title> The Calculi of Lambda-v-cs Conversion: A Syntactic Theory of Control and State in Imperative Higher-Order Programming Languages. </title> <type> PhD thesis, </type> <institution> Indiana University. </institution>
Reference: <author> Felleisen, M. </author> <year> (1993). </year> <type> Personal communication. </type>
Reference-contexts: The assertion, (mk.iii), expresses the totality of mk. The mk delay axiom, (mk.iv), asserts that the time of allocation has no discernable effect on the resulting cell. In a world with control effects evaluation of e 0 must be free of them for this principle to be valid <ref> (Felleisen, 1993) </ref>.
Reference: <author> Felleisen, M. and Friedman, D. </author> <year> (1986). </year> <title> Control operators, the SECD-machine, and the -calculus. </title> <editor> In Wirsing, M., editor, </editor> <booktitle> Formal Description of Programming Concepts III, </booktitle> <pages> pages 193-217. </pages> <publisher> North-Holland. </publisher>
Reference-contexts: ): The set of redexes, E r , is defined as E r = app (V; V) + n2N Reduction contexts identify the subexpression of an expression that is to be evaluated next, they correspond to the standard reduction strategy (left-first, call-by-value) of (Plotkin, 1975) and were first introduced in <ref> (Felleisen and Friedman, 1986) </ref>. Definition (R): The set of reduction contexts, R, is the subset of C defined by R = f*g + app (R; E ) + app (V; R ) + n;m2N We let R range over R.
Reference: <author> Felleisen, M. and Friedman, D. P. </author> <year> (1989). </year> <title> A syntactic theory of sequential state. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 243-287. </pages>
Reference: <author> Felleisen, M. and Hieb, R. </author> <year> (1992). </year> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 103 </volume> <pages> 235-271. </pages>
Reference-contexts: A Little History The fact that one can present a syntactic reduction system for this, and related, imperative -calculi was discovered independently by three people in 1986-1987: Carolyn Talcott (Mason and Talcott, 1991a), Matthias Felleisen and Robert Hieb <ref> (Felleisen and Hieb, 1992) </ref>. As well as being conceptually elegant, it has also provided the necessary tools for several key results and proofs. It provided the basis for an elegant revision of (Felleisen, 1987; Felleisen and Friedman, 1989) that was later published in (Felleisen and Hieb, 1992). <p> Talcott, 1991a), Matthias Felleisen and Robert Hieb <ref> (Felleisen and Hieb, 1992) </ref>. As well as being conceptually elegant, it has also provided the necessary tools for several key results and proofs. It provided the basis for an elegant revision of (Felleisen, 1987; Felleisen and Friedman, 1989) that was later published in (Felleisen and Hieb, 1992). Other notable successful uses of the technique is the type soundness proof, via subject reduction, of the imperative ML type system (Felleisen and Wright, 1991). The analysis of parameter passing in Algol (Crank and Felleisen, 1991; Weeks and Felleisen, 1993). <p> Another nice property that is easily established using (ciu) is that reduction preserves operational equivalence: Lemma (eval): ; e 7! 0 ; e 0 ) [e] ~ = 0 [e 0 ]. This property is the basis of the calculi found in <ref> (Felleisen and Hieb, 1992) </ref>. 2.3.3.
Reference: <author> Felleisen, M. and Wright, A. K. </author> <year> (1991). </year> <title> A syntactic approach to type soundness. </title> <institution> Technical Report Rice COMP TR91-160, Rice University Computer Science Department. </institution>
Reference-contexts: It provided the basis for an elegant revision of (Felleisen, 1987; Felleisen and Friedman, 1989) that was later published in (Felleisen and Hieb, 1992). Other notable successful uses of the technique is the type soundness proof, via subject reduction, of the imperative ML type system <ref> (Felleisen and Wright, 1991) </ref>. The analysis of parameter passing in Algol (Crank and Felleisen, 1991; Weeks and Felleisen, 1993). The analysis of reduction calculi for Scheme-like languages (Sabry and Felleisen, 1993; Fields and Sabry, 1993).
Reference: <author> Fields, J. and Sabry, A. </author> <year> (1993). </year> <title> Reasoning about explicit and implicit representations of state. </title> <booktitle> In ACM Sigplan Workshop on State in Programming Languages. </booktitle> <address> YaleU/DCS/RR-968. </address>
Reference: <author> German, S., Clarke, E., and Halpern, J. </author> <year> (1989). </year> <title> Reasoning about procedures as parameters in the language L4. </title> <journal> Information and Computation, </journal> <volume> 83(3). </volume>
Reference-contexts: It may also be productive to examine both the system and the results obtained concerning L4 in the paper <ref> (German et al., 1989) </ref>. (C) It may be productive to study contextual assertions in the simpler simply typed calculus making use of Milner's context lemma.
Reference: <author> Halpern, J., Meyer, A. R., and Trakhtenbrot, B. A. </author> <year> (1983). </year> <title> The semantics of local storage, </title> <booktitle> or what makes the free-list free? In 11th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 245-257. </pages>
Reference: <author> Halpern, J., Meyer, A. R., and Trakhtenbrot, B. A. </author> <year> (1984). </year> <title> From denotational to operational and axiomatic semantics for ALGOL-like languages: An overview. </title> <editor> In Clarke, E. and Kozen, D., editors, </editor> <booktitle> Logics of Programs, Proceedings 1983, volume 164 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <address> Berlin. </address>
Reference: <author> Harel, D. </author> <year> (1984). </year> <title> Dynamic logic. </title> <editor> In Gabbay, D. and Guenthner, G., editors, </editor> <booktitle> Handbook of Philosophical Logic, </booktitle> <volume> Vol. II, </volume> <pages> pages 497-604. </pages> <address> D. </address> <publisher> Reidel. </publisher>
Reference-contexts: This model uses a categorical notion called relational parametricity to capture locality. Full abstraction for this model remains an open problem. In recent years various systems for reasoning about properties of programs written in general programming languages have been proposed, most notably Hoare's logic (Apt, 1981), Dynamic logic <ref> (Harel, 1984) </ref>, Reynolds Specification Logic (Reynolds, 1982), Moggi's metalanguage for computational monads (Moggi, 1991), and Pitt's Evaluation Logic (Pitts, 1990).
Reference: <author> Honsell, F., Mason, I. A., Smith, S. F., and Talcott, C. L. </author> <year> (1993). </year> <title> A theory of classes for a functional language with effects. </title> <booktitle> In Proceedings of CSL92, volume ??? of Lecture Notes in Computer Science, </booktitle> <publisher> pages ???-??? Springer, </publisher> <address> Berlin. </address>
Reference-contexts: Part II is independent of part III, while much of part III is orthogonal to part II. Earlier versions of part II of this paper appeared as (Mason and Talcott, 1992b). Earlier versions of part III of this paper appeared as <ref> (Honsell et al., 1993) </ref>. 1.1.1. Part I In our language atoms, references and lambda abstractions are all first class values and as such are storable. This has several consequences.
Reference: <author> Howe, D. </author> <year> (1989). </year> <title> Equality in the lazy lambda calculus. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science. IEEE. </booktitle>
Reference: <author> Jim, T. and Meyer, A. </author> <year> (1991). </year> <title> Full abstraction and the context lemma. </title> <booktitle> In Theoretical Aspects of Computer Science, Lecture Notes in Computer Science volume 526. </booktitle> <publisher> Springer-Verlag. </publisher>
Reference: <author> Jouvelot, P. and Gifford, D. K. </author> <year> (1991). </year> <title> Algebraic reconstruction of types and effects. </title> <booktitle> In Conference Record of the 18th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 303-310. </pages>
Reference: <author> Landin, P. J. </author> <year> (1964). </year> <title> The mechanical evaluation of expressions. </title> <journal> Computer Journal, </journal> <volume> 6 </volume> <pages> 308-320. </pages> <note> 60 Leroy, </note> <author> X. and Wies, P. </author> <year> (1990). </year> <title> Polymorphic type inference and assignment. </title> <booktitle> In Proceedings of the 18th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 291-302. </pages> <publisher> ACM. </publisher>
Reference-contexts: We give two versions of such a combinator, the first is written in the simply typed lambda calculus with ML reference primitives. The second is an untyped version written in the language we study in the sequel. These combinators are essentially identical to the one suggested by Landin <ref> (Landin, 1964) </ref>. Version 1: Suppose that in the type environment we can establish . g : ! t .
Reference: <author> Lucassen, J. M. </author> <year> (1987). </year> <title> Types and Effects, towards the integration of functional and imperative programming. </title> <type> PhD thesis, </type> <institution> MIT. </institution> <note> Also available as LCS TR-408. </note>
Reference: <author> Lucassen, J. M. and Gifford, D. K. </author> <year> (1988). </year> <title> Polymorphic effect systems. </title> <booktitle> In 16th annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 47-57. </pages>
Reference: <author> Manna, Z. and Waldinger, R. </author> <year> (1981). </year> <title> Problematic features of programming languages. </title> <journal> Acta Informatica, </journal> <volume> 16 </volume> <pages> 371-426. </pages>
Reference: <author> Mason, I. A. </author> <year> (1986a). </year> <title> Equivalence of first order Lisp programs: Proving properties of destructive programs via transformation. </title> <booktitle> In First Annual Symposium on Logic in Computer Science. IEEE. </booktitle>
Reference-contexts: We will examine it in more detail shortly (x3.10). It was first studied in <ref> (Mason, 1986a) </ref>. 3.5. Caveats 3.5.1.
Reference: <author> Mason, I. A. </author> <year> (1986b). </year> <title> The Semantics of Destructive Lisp. </title> <type> PhD thesis, </type> <institution> Stanford University. </institution> <note> Also available as CSLI Lecture Notes No. </note> <month> 5, </month> <title> Center for the Study of Language and Information, </title> <publisher> Stanford University. </publisher>
Reference: <author> Mason, I. A. </author> <year> (1988). </year> <title> Verification of programs that destructively manipulate data. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 10 </volume> <pages> 177-210. </pages>
Reference: <author> Mason, I. A. and Talcott, C. L. </author> <year> (1989). </year> <title> Axiomatizing operational equivalence in the presence of side effects. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science. IEEE. </booktitle>
Reference: <author> Mason, I. A. and Talcott, C. L. </author> <year> (1991a). </year> <title> Equivalence in functional languages with effects. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 287-327. </pages>
Reference-contexts: We also discuss some of the subtleties that arise due to the presence of mutable data. Most of the results in this part are from <ref> (Mason and Talcott, 1991a) </ref>. (II) In part two we describe the first order aspects of our logic of effects, and provide examples of their use. <p> In general it is very difficult to establish the operational equivalence of expressions. Thus it is desirable to have a simpler characterization of operational equivalence, one that limits the class of contexts (or observations) that must be considered. In <ref> (Mason and Talcott, 1991a) </ref> we used this approach to establish a useful characterization of operational equivalence. This characterization reduces the number of contexts that need to be considered. The class of contexts that need to be considered correspond naturally to states of an abstract machine. <p> The semantics is given operationally in terms of a single step reduction relation. We shall be somewhat terse in this section. For a more leisurely treatment see <ref> (Mason and Talcott, 1991a) </ref>. 2.1. <p> A Little History The fact that one can present a syntactic reduction system for this, and related, imperative -calculi was discovered independently by three people in 1986-1987: Carolyn Talcott <ref> (Mason and Talcott, 1991a) </ref>, Matthias Felleisen and Robert Hieb (Felleisen and Hieb, 1992). As well as being conceptually elegant, it has also provided the necessary tools for several key results and proofs. <p> This latter property is called (ciu) equivalence and is a weak form of extensionality. 3 Theorem (ciu): e 0 ~ = e 1 , (8; ; R)(FV ([R [e i ]]) = ; ) ([R [e 1 ]])) A proof of (ciu) appears in <ref> (Mason and Talcott, 1991a) </ref>, below we give a simpler proof. Using this theorem we can easily establish, for example, the validity of the let-rules of the lambda-c calculus (Moggi, 1989) (see also (Talcott, 1993) where these laws are established for a language with control abstractions).
Reference: <author> Mason, I. A. and Talcott, C. L. </author> <year> (1991b). </year> <title> Program transformation for configuring components. </title> <booktitle> In ACM/IFIP Symposium on Partial Evaluation and Semantics-based Program Manipulation. </booktitle>
Reference-contexts: Lemma (5.1): 5 ) letfx := mk (u)gseq (app (q; 5 ); letfu := get (x)g [[ 5 ]]) Lambda abstractions with local store, such as 5 , are objects in the sense of <ref> (Mason and Talcott, 1991b) </ref>. In that paper several principles for establishing operational equivalence were presented and used. The invariance theorem (inv) is typical of these principles. It provides a general method for establishing invariant properties.
Reference: <author> Mason, I. A. and Talcott, C. L. </author> <year> (1992a). </year> <title> Inferring the equivalence of functional programs that mutate data. </title> <journal> Theoretical Computer Science, </journal> <volume> 105(2) </volume> <pages> 167-215. </pages>
Reference-contexts: They are similar in spirit to program modalities in dynamic and evaluation logic. Using contextual assertions we can express the axioms concerning the effects of mk and set simply and elegantly. This improves the complete system (for quantifier/recursion free expressions) presented in <ref> (Mason and Talcott, 1992a) </ref> where the corresponding rules had complicated side-conditions. The logic is a partial term logic with variables ranging over values. The characterization of operational equivalence allows for a natural notion of satisfaction of first order formulas relative to a memory state and assignment of values to variables. <p> The analysis of reduction calculi for Scheme-like languages (Sabry and Felleisen, 1993; Fields and Sabry, 1993). In 1987 Ian Mason realized that it provided the ideal notion of a normal form and symbolic evaluation needed in the completeness result presented in <ref> (Mason and Talcott, 1992a) </ref>. The approach Felleisen et al take is a reduction system on expressions of the form [e], while we adopt a slightly more complex reduction system on pairs of the form ; e. <p> In our language the example and the equivalence translates to: Definition (ex 1 ): ex 1 = letfx := mk (t)gapp (p; nil) Theorem (1): ex 1 ~ = app (p; nil) This equivalence is an instance of a more general garbage collection principle isolated in the system <ref> (Mason and Talcott, 1992a) </ref>. This principle allows for the elimination of garbage | cells no longer accessible from the program text.
Reference: <author> Mason, I. A. and Talcott, C. L. </author> <year> (1992b). </year> <title> References, local variables and operational reasoning. </title> <booktitle> In Seventh Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 186-197. </pages> <publisher> IEEE. </publisher>
Reference-contexts: We give an extended example of the use of VTLoE in specifying and verifying a program. Part II is independent of part III, while much of part III is orthogonal to part II. Earlier versions of part II of this paper appeared as <ref> (Mason and Talcott, 1992b) </ref>. Earlier versions of part III of this paper appeared as (Honsell et al., 1993). 1.1.1. Part I In our language atoms, references and lambda abstractions are all first class values and as such are storable. This has several consequences.
Reference: <author> Meyer, A. R. and Sieber, K. </author> <year> (1988). </year> <title> Towards fully abstract semantics for local variables: Preliminary report. </title> <booktitle> In 15th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 191-208. </pages>
Reference-contexts: Even when references are only allowed to contain numbers they are troublesome from a denotational point of view as illustrated by the absence of fully abstract models. For example, in <ref> (Meyer and Sieber, 1988) </ref> they give a series of seven examples of programs that are operationally equivalent (according to the intended semantics of block-structured Algol-like programs) but which are not given equivalent denotations in traditional denotational semantics. <p> Declarations of a local variable x in a block, begin new x; : : : end, is represented by letfx := mk (t)ge where e represents the block body. The contents operation of <ref> (Meyer and Sieber, 1988) </ref> is get (x), the assignment operation, x := v, is set (x; v), and equality on program variables is eq. 4.1. Example 1 The following block is equivalent to P . begin new x; P end The intuitive justification for this is simple. <p> Aknowledgements The authors wish to thank Matthias Felleisen, John Greiner, Takayasu Ito, Arthur Lent and the two anonymous referees for there thoughtful comments, corrections and criticisms of an earlier draft of this paper. We also thank Carl Gunter for pointing out <ref> (Meyer and Sieber, 1988) </ref> to us when he visited Stanford in 1992. Finally we would also like to aknowledge a debt to Solomon Feferman. This research was partially supported by DARPA contract NAG2-703, NSF grants CCR-8917606, CCR-8915663, and CCR-9109070, and Italian grant CNR-Stanford N.89.00002.26.
Reference: <author> Milner, R. </author> <year> (1977). </year> <title> Fully abstract models of typed -calculi. </title> <journal> Theoretical Computer Science, </journal> <volume> 4 </volume> <pages> 1-22. </pages>
Reference: <author> Moggi, E. </author> <year> (1989). </year> <title> Computational lambda-calculus and monads. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science. IEEE. </booktitle>
Reference-contexts: Using this theorem we can easily establish, for example, the validity of the let-rules of the lambda-c calculus <ref> (Moggi, 1989) </ref> (see also (Talcott, 1993) where these laws are established for a language with control abstractions). <p> Then e fl 7! e non-trivially, hence :(# ; e) for any . iii 3.7. Axioms for Proofs We established in x2 the validity of the let-rules of the lambda-c calculus <ref> (Moggi, 1989) </ref> as valid equations concerning operational equivalence.
Reference: <author> Moggi, E. </author> <year> (1991). </year> <title> Notions of computation and monads. </title> <journal> Information and Computation, </journal> <volume> 93(1). </volume>
Reference-contexts: Full abstraction for this model remains an open problem. In recent years various systems for reasoning about properties of programs written in general programming languages have been proposed, most notably Hoare's logic (Apt, 1981), Dynamic logic (Harel, 1984), Reynolds Specification Logic (Reynolds, 1982), Moggi's metalanguage for computational monads <ref> (Moggi, 1991) </ref>, and Pitt's Evaluation Logic (Pitts, 1990). All are program logics of the exogenous kind, i.e. programs appear in formulas. 2 Hoare's logic is quite weak in the sense that it cannot express termination of programs, nor their equivalence.
Reference: <author> Morris, J. H. </author> <year> (1968). </year> <title> Lambda calculus models of programming languages. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology. </institution> <note> 61 O'Hearn, </note> <author> P. and Tennent, R. </author> <year> (1992). </year> <title> Semantics of Local Variables. </title> <type> Technical Report ECS-LFCS-92-192, </type> <institution> Laboratory for foundations of computer science, University of Edinburgh. </institution>
Reference-contexts: A state has three components: the current instruction, the current continuation, and the current state of memory. Their syntactic counterparts are redexes, reduction contexts, and memory contexts respectively. We define the operational equivalence relation and study its general properties. Our definition extends the equivalence relations defined in <ref> (Morris, 1968) </ref> and (Plotkin, 1975). In general it is very difficult to establish the operational equivalence of expressions. Thus it is desirable to have a simpler characterization of operational equivalence, one that limits the class of contexts (or observations) that must be considered. <p> Operational 2 equivalence formalizes the notion of equivalence as black-boxes. Treating programs as black boxes requires only observing what effects and values they produce, and not how they produce them. Our definition extends the extensional equivalence relations defined by <ref> (Morris, 1968) </ref> and (Plotkin, 1975) to computation over memory structures.
Reference: <author> O'Hearn, P. and Tennent, R. </author> <year> (1993a). </year> <title> Relational Parametricity and Local Variables. </title> <booktitle> In Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 171-184. </pages>
Reference: <author> O'Hearn, P. and Tennent, R. </author> <year> (1993b). </year> <title> Semantic Analysis of Specification Logic, Part 2. Information and Computation, </title> ?:?-? <editor> Olderog, E. </editor> <year> (1984). </year> <title> Hoare's logic for programs with procedures-what has been accomplished. </title> <editor> In Clarke, E. and Kozen, D., editors, </editor> <booktitle> Logics of Programs, Proceedings 1983, volume 164 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <address> Berlin. </address>
Reference: <author> Ong, C.-H. </author> <year> (1988). </year> <title> The Lazy Lambda Calculus: An investigation into the Foundations of Functional Programming. </title> <type> PhD thesis, </type> <institution> Imperial College, University of London. </institution>
Reference: <author> Pitts, A. M. </author> <year> (1990). </year> <title> Evaluation logic. In IVth Higher-Order Workshop, Banff, </title> <booktitle> volume 283 of Workshops in Computing. </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In recent years various systems for reasoning about properties of programs written in general programming languages have been proposed, most notably Hoare's logic (Apt, 1981), Dynamic logic (Harel, 1984), Reynolds Specification Logic (Reynolds, 1982), Moggi's metalanguage for computational monads (Moggi, 1991), and Pitt's Evaluation Logic <ref> (Pitts, 1990) </ref>. All are program logics of the exogenous kind, i.e. programs appear in formulas. 2 Hoare's logic is quite weak in the sense that it cannot express termination of programs, nor their equivalence. Dynamic logic can express termination but not equivalence, while the opposite is true for Specification logic.
Reference: <author> Pitts, A. M. and Stark, I. </author> <year> (1993). </year> <title> On the observable properties of higher order functions that dynamically create local names. </title> <booktitle> In ACM Sigplan Workshop on State in Programming Languages. </booktitle> <address> YaleU/DCS/RR-968. </address>
Reference: <author> Plotkin, G. </author> <year> (1975). </year> <title> Call-by-name, call-by-value and the lambda-v-calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159. </pages>
Reference-contexts: The second stage extends the logic to include classes and class membership. The logic we present provides an expressive language for defining constraints and for studying properties and program equivalences, in a uniform framework. Our atomic formulas express the (operational or observational) equivalence of programs a la Plotkin <ref> (Plotkin, 1975) </ref>. Neither Hoare's logic nor Dynamic logic incorporate this ability, or make use of such equivalences (e.g. by replacing one piece of program text by another without altering the overall meaning). The logic combines the features and benefits of equational calculi and program and specification logics. <p> Their syntactic counterparts are redexes, reduction contexts, and memory contexts respectively. We define the operational equivalence relation and study its general properties. Our definition extends the equivalence relations defined in (Morris, 1968) and <ref> (Plotkin, 1975) </ref>. In general it is very difficult to establish the operational equivalence of expressions. Thus it is desirable to have a simpler characterization of operational equivalence, one that limits the class of contexts (or observations) that must be considered. <p> Definition (E r ): The set of redexes, E r , is defined as E r = app (V; V) + n2N Reduction contexts identify the subexpression of an expression that is to be evaluated next, they correspond to the standard reduction strategy (left-first, call-by-value) of <ref> (Plotkin, 1975) </ref> and were first introduced in (Felleisen and Friedman, 1986). Definition (R): The set of reduction contexts, R, is the subset of C defined by R = f*g + app (R; E ) + app (V; R ) + n;m2N We let R range over R. <p> Operational 2 equivalence formalizes the notion of equivalence as black-boxes. Treating programs as black boxes requires only observing what effects and values they produce, and not how they produce them. Our definition extends the extensional equivalence relations defined by (Morris, 1968) and <ref> (Plotkin, 1975) </ref> to computation over memory structures.
Reference: <author> Reynolds, J. </author> <year> (1982). </year> <title> Idealized ALGOL and its specification logic. </title> <editor> In Neel, D., editor, </editor> <booktitle> Tools and Notions for Program Construction, </booktitle> <pages> pages 121-161. </pages> <publisher> Cambridge University Press. </publisher>
Reference-contexts: Full abstraction for this model remains an open problem. In recent years various systems for reasoning about properties of programs written in general programming languages have been proposed, most notably Hoare's logic (Apt, 1981), Dynamic logic (Harel, 1984), Reynolds Specification Logic <ref> (Reynolds, 1982) </ref>, Moggi's metalanguage for computational monads (Moggi, 1991), and Pitt's Evaluation Logic (Pitts, 1990). All are program logics of the exogenous kind, i.e. programs appear in formulas. 2 Hoare's logic is quite weak in the sense that it cannot express termination of programs, nor their equivalence.
Reference: <author> Reynolds, J. C. </author> <year> (1978). </year> <title> Syntactic control of interference. </title> <booktitle> In Conference record of the 5th annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 39-46. </pages>
Reference: <author> Sabry, A. and Felleisen, M. </author> <year> (1993). </year> <title> Reasoning about programs in continuation-passing style. </title> <journal> Lisp and Symbolic Computation, </journal> 6(3/4):287-358. 
Reference: <author> Sieber, K. </author> <year> (1985). </year> <title> A partial correctness logic for programs (in an Algol-like language). </title> <editor> In Parikh, R., editor, </editor> <booktitle> Logics of Programs, volume 193 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <address> Berlin. </address>
Reference: <author> Smith, S. F. </author> <year> (1988). </year> <title> Partial Objects in Type Theory. </title> <type> PhD thesis, </type> <institution> Cornell University. </institution> <note> Available as TR 88-938. </note>
Reference: <author> Smith, S. F. </author> <year> (1992). </year> <title> From operational to denotational semantics. </title> <booktitle> In MFPS 1991, volume 598 of Lecture Notes in Computer Science, </booktitle> <pages> pages 54-76. </pages> <publisher> Springer-Verlag. </publisher>
Reference: <author> Talcott, C. </author> <year> (1991). </year> <title> A theory of binding structures and its applications to rewriting. </title> <note> Theoretical Computer Science, to appear. </note>
Reference-contexts: This is just one way of doing the bookkeeping for the symbolic evaluation. This kind of hygiene can also be taken care of automatically by introducing schematic variables with associated substitutions (c.f. <ref> (Talcott, 1991) </ref>). This symbolic or parametric reduction of contexts is explored in more detail in (Agha et al., 1993). The following two lemmas are key in developing methods for reasoning about contextual assertions, and illustrate the basic ideas in reasoning about computation with contextual assertions.
Reference: <author> Talcott, C. L. </author> <year> (1985). </year> <title> The essence of Rum: A theory of the intensional and extensional aspects of Lisp-type computation. </title> <type> PhD thesis, </type> <institution> Stanford University. </institution>
Reference: <author> Talcott, C. L. </author> <year> (1993). </year> <title> A theory for program and data specification. </title> <journal> Theoretical Computer Science, </journal> <volume> 104 </volume> <pages> 129-159. </pages> <note> 62 Tofte, </note> <author> M. </author> <year> (1988). </year> <title> Operational Semantics and Polymorphic Type Inference. </title> <type> PhD thesis, </type> <institution> Edinburgh University. </institution>
Reference-contexts: These systems are two sorted theories of operations and classes initially developed for the formalization of constructive mathematics (Feferman, 1975; Fe-ferman, 1979) and later applied to the study of purely functional languages (Feferman, 1985; Feferman, 1990). A similar extension incorporating non-local control effects was introduced in <ref> (Talcott, 1993) </ref>. VTLoE (Variable Type Logic of Effects) is introduced in two stages. The first stage is the first-order theory of individuals built on assertions of equality (operational equivalence), and contextual assertions. The second stage extends the logic to include classes and class membership. <p> The underlying logic is classical. Consequently we concentrate on the properties of contextual assertions and their uses. 1.1.3. Part III Using methods of (Feferman, 1975; Feferman, 1990) and <ref> (Talcott, 1993) </ref>, we extend our theory to include a general theory of classifications (classes for short). We extend the syntax to include class terms (either class variables, class constants, or comprehension terms). We extend the set of formulas to include class membership and quantification over classes. <p> Using this theorem we can easily establish, for example, the validity of the let-rules of the lambda-c calculus (Moggi, 1989) (see also <ref> (Talcott, 1993) </ref> where these laws are established for a language with control abstractions). <p> To establish (2) take v 0 = u 0 + n, v 1 = u 1 , w = nil. y 40 Part III: Classes 5. Adding Classes to the Language Using methods of (Feferman, 1975; Feferman, 1990) and <ref> (Talcott, 1993) </ref>, we extend our theory to include a general theory of classifications (classes for short). With the introduction of classes, principles such as structural induction, as well as principles accounting for the effects of an expression can easily be expressed. <p> Using Classes In this section we give an extended example of the use of VTLoE in specifying and verifying a program. 6.1. Class Fixed Points and Induction The definitions and results in this subsection are taken from <ref> (Talcott, 1993) </ref> where more details, proofs, and examples can be found. Here we focus on minimum fixed points. A similar development can be carried our for maximum fixed points.
Reference: <author> Tofte, M. </author> <year> (1990). </year> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89 </volume> <pages> 1-34. </pages>
Reference-contexts: The logic combines the features and benefits of equational calculi and program and specification logics. The theory allows for the construction of inductively defined sets and derivation of the corresponding induction principles. Classes can be used to express, inter alia, the non-expansiveness of terms <ref> (Tofte, 1990) </ref>. Other effects can also be represented within the system.

References-found: 61

