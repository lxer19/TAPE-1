URL: http://www.ri.cmu.edu/afs/cs/user/rwh/public/www/papers/til-mlrisc/tic98.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/rwh/public/www/papers.html
Root-URL: 
Title: How Generic is a Generic Back End? Using MLRISC as a Back End for the
Author: Andrew Bernard Robert Harper, and Peter Lee 
Note: MLRISC, relative to a custom back end.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: We describe the integration of MLRISC, a "generic" compiler back end, with TIL, a type-directed compiler for Standard ML. The TIL run-time system uses a form of type information to enable partially tag-free garbage collection. We show how we propagate this information through the final phases of the compiler, even though the back end is unaware of the existence of this information. Additionally, we identify the characteristics of MLRISC that enable us to use it with TIL and suggest ways in which it might better support our compiler. Preliminary performance measurements show that we pay a significant cost for using 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: principles, techniques, tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Type environments supply type information for variables whose types cannot be resolved at compile time (e.g., polymorphic variables). For example, in Figure 2, the type of x is polymorphic and thus cannot be statically determined by the compiler|x could take the value 3, "three", <ref> [1, 1, 1] </ref>, or any of a number of values that have distinct representations at run time. A type environment for f has the caller pass an explicit representation of x's type so that both the run-time system and f can operate on it [18] [10]. <p> Liveness analysis has the added benefit of minimizing storage retained during garbage collection. This, in turn, enhances performance by reducing the load on the collector and also enables certain programs to terminate that would not otherwise [16]. Our liveness analysis is based on well-understood data-flow techniques <ref> [1] </ref>. Note that the call-site liveness analysis must be at least as precise as the register-allocation liveness analysis for this technique to work.
Reference: 2. <author> Andrew W. Appel. </author> <title> A runtime system. </title> <booktitle> Lisp and Symbolic Computation 3, </booktitle> <pages> pages 343-380, </pages> <year> 1990. </year>
Reference-contexts: A Trace Table for Call #2 of Figure 4 and Tiger [3]. Our compiler differs from other compilers using MLRISC [4] <ref> [2] </ref> [3], however, in that TIL does not use dynamic tag bits to distinguish heap pointers from other word-sized values. In MLRISC, as in RTL, local storage locations are identified by numbered pseudo registers. Pseudo registers are transparently mapped to machine registers or spilled to the stack by MLRISC.
Reference: 3. <author> Andrew W. Appel. </author> <title> Modern Compiler Implementation in ML. </title> <publisher> Cambridge University Press, </publisher> <year> 1998. </year>
Reference-contexts: A Trace Table for Call #2 of Figure 4 and Tiger <ref> [3] </ref>. Our compiler differs from other compilers using MLRISC [4] [2] [3], however, in that TIL does not use dynamic tag bits to distinguish heap pointers from other word-sized values. In MLRISC, as in RTL, local storage locations are identified by numbered pseudo registers. <p> A Trace Table for Call #2 of Figure 4 and Tiger <ref> [3] </ref>. Our compiler differs from other compilers using MLRISC [4] [2] [3], however, in that TIL does not use dynamic tag bits to distinguish heap pointers from other word-sized values. In MLRISC, as in RTL, local storage locations are identified by numbered pseudo registers. Pseudo registers are transparently mapped to machine registers or spilled to the stack by MLRISC.
Reference: 4. <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of new jersey. </title> <booktitle> In Third International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 1-13. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: A Trace Table for Call #2 of Figure 4 and Tiger [3]. Our compiler differs from other compilers using MLRISC <ref> [4] </ref> [2] [3], however, in that TIL does not use dynamic tag bits to distinguish heap pointers from other word-sized values. In MLRISC, as in RTL, local storage locations are identified by numbered pseudo registers. Pseudo registers are transparently mapped to machine registers or spilled to the stack by MLRISC. <p> Our work attests that MLRISC is "generic enough" to be reused as the back end of our compiler, even though TIL is substantially different from Standard ML of New Jersey <ref> [4] </ref>, the compiler for which MLRISC was originally developed. Reuse has attendant costs, however, and the most significant of these appear to be related to the speed of compilation.
Reference: 5. <author> Andrew W. Appel et al. </author> <title> The national compiler infrastructure project. </title>
Reference-contexts: We also suggest additional features not found in MLRISC that would have made our job easier, or would have resulted in more efficient code generation. We speculate that our experience may be of use to designers of other generic back-ends <ref> [5] </ref> [6]. We divide the relevant features into two classes: those that are essential to the propagation of type information, and those that can enhance performance or simplify translation when using type-directed techniques.
Reference: 6. <author> Robert P. Wilson et al. </author> <title> SUIF: An infrastructure for research on parallelizing and optimizing compilers. </title> <type> Technical report, </type> <institution> Computer Systems Laboratory, Stanford University. </institution>
Reference-contexts: We also suggest additional features not found in MLRISC that would have made our job easier, or would have resulted in more efficient code generation. We speculate that our experience may be of use to designers of other generic back-ends [5] <ref> [6] </ref>. We divide the relevant features into two classes: those that are essential to the propagation of type information, and those that can enhance performance or simplify translation when using type-directed techniques.
Reference: 7. <author> Lal George. </author> <type> Personal Communication. </type>
Reference-contexts: Thus, for a given call site we can resolve a conflicting register assignment by choosing the trace value of the pseudo register that is live across the call site <ref> [7] </ref>, as there can be only one. value for machine register 4 at call #3 depends on the run-time contents of pseudo-register t1: if t1 is greater than zero, then machine register 4 will be overwritten by the result of call #2. <p> Because the lifetime of the temporary is only between the rewritten instruction and the store (or load), we can assume that it will never be live across a call site <ref> [7] </ref>, and thus need not be traced. Although such a temporary will never be traced, the stack slot containing the original value still might be traced if it is live across the call site in question.
Reference: 8. <author> Lal George. MLRISC: </author> <title> Customizable and reusable code generators. </title> <type> Technical report, </type> <institution> Bell Labs, </institution> <month> December </month> <year> 1996. </year> <note> submitted to PLDI. </note>
Reference-contexts: In Figure 6, we show a trace table for call #2|notice that the trace values of stack slots saving callee-save registers depend on the dynamic caller's trace table (these slots are given trace status callee n). 3 MLRISC MLRISC <ref> [8] </ref> is a generic compiler back end developed by Lal George at Bell Laboratories. MLRISC is "generic" in the sense that it can be used to compile many different programming languages.
Reference: 9. <author> Lal George and Andrew W. Appel. </author> <title> Iterated register coalescing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 18(3) </volume> <pages> 300-324, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: procedure at the address formed by evaluating expres sion addr. copy dst, src Copy the registers listed in src into the corresponding registers listed in dst; this is a "parallel" operation: no register can appear more than once in the union of src and dst. copy state ments are coalesced <ref> [9] </ref> by MLRISC whenever possible. mv dst, exp Move the result of evaluating expression exp into register dst. jmp addr Jump to the code at the address formed by evaluating expres sion addr. ret Return from the current procedure. store32 addr, exp Store the result of evaluating expression exp as a <p> The shape of the mapping to machine registers can also present problems to the implementor. MLRISC maps each pseudo register to at most one machine register <ref> [9] </ref>; thus, when an unspilled pseudo register is live across a call site, we can always precisely identify which machine register it is mapped to.
Reference: 10. <author> Robert Harper and Greg Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Conference Record of the 22nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 130-141. </pages> <publisher> ACM, </publisher> <month> Jan-uary </month> <year> 1995. </year>
Reference-contexts: The universal availability of type information permits TIL to check types after any phase of compilation|this helps to ensure the correctness of compiler optimizations during development. Type information also allows TIL to perform additional optimizations that are not directly available to conventional compilers [13] <ref> [10] </ref>. A principal benefit of type-directed compilation is that it facilitates sound tag-free garbage collection [18]. Sound garbage collection requires that the heap pointers used by an executing program be identified unambiguously. Tag-free garbage collection permits these heap pointers to be identified without perturbing the run-time representations of values. <p> A type environment for f has the caller pass an explicit representation of x's type so that both the run-time system and f can operate on it [18] <ref> [10] </ref>. Type environments are needed only for functions such as f where complete type information is not available at compile time. A type environment is a record of values that encode properties of types that are important to the run-time system.
Reference: 11. <author> Robert Harper and Chris Stone. </author> <title> A type-theroretic interpretation of standard ML. </title> <type> Technical report, </type> <institution> Carnegie Mellon University, </institution> <year> 1997. </year> <note> submitted for publication. </note>
Reference-contexts: HIL is an explicitly-typed refinement of the SML programming language, including the module system; a detailed discussion of HIL is beyond the scope of this paper (see Harper and Stone <ref> [11] </ref> for further details). HIL is translated to MIL (Mid-level Intermediate Language) by the phase splitter, which is responsible for eliminating modules and breaking abstraction barriers. <p> the use of conditionals in certain RISC architectures (e.g., the Alpha), it cannot f: mv gp, reg pv ; set global pointer mv sp, sub (reg sp, const frame) ; alloc frame store32 add (reg sp, li 0), reg ra ; save return address copy [cs1, cs2, cs3, cs4, cs5], <ref> [11, 12, 13, 14, 15] </ref> ; save callee save copy [_tenv1, x, n, l, l2], [16, 17, 18, 19, 20] ; get arguments store32 add (reg sp, const _tenv1_offset), reg _tenv1 ; save type environment copy [16], [l] ; _t1 &lt;- length (l) mv pv, label "length" call reg pv ; <p> 17, 18, 19], [_tenv1, x, n, _t2] ; _t3 &lt;- g (x, n, _t2) mv pv, label "g" call reg pv ; (call #3) mv gp, reg pv ; set global pointer copy [_t3], [0] copy [0], [_t3] mv ra, add (reg sp, li 0), ; restore return address copy <ref> [11, 12, 13, 14, 15] </ref>, [cs1, cs2, cs3, cs4, cs5] ; restore callee save mv sp, add (reg sp, const frame) ; dealloc frame ret ; return Fig. 7.
Reference: 12. <author> Greg Morrisett, David Walker, Karl Crary, and Neal Glew. </author> <title> From system F to typed assembly language. </title> <booktitle> In Conference Record of the 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 85-97. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1998. </year>
Reference-contexts: A compiler back end could itself be type directed|both Typed Assembly Language <ref> [12] </ref> and Proof-Carrying Code [14] [15] encode variable type information at the assembly-language level|although this is not common practice, and, as a matter of fact, MLRISC is not type directed. TIL translates a source program through a succession of typed intermediate languages until it arrives at conventional assembly code. <p> the use of conditionals in certain RISC architectures (e.g., the Alpha), it cannot f: mv gp, reg pv ; set global pointer mv sp, sub (reg sp, const frame) ; alloc frame store32 add (reg sp, li 0), reg ra ; save return address copy [cs1, cs2, cs3, cs4, cs5], <ref> [11, 12, 13, 14, 15] </ref> ; save callee save copy [_tenv1, x, n, l, l2], [16, 17, 18, 19, 20] ; get arguments store32 add (reg sp, const _tenv1_offset), reg _tenv1 ; save type environment copy [16], [l] ; _t1 &lt;- length (l) mv pv, label "length" call reg pv ; <p> 17, 18, 19], [_tenv1, x, n, _t2] ; _t3 &lt;- g (x, n, _t2) mv pv, label "g" call reg pv ; (call #3) mv gp, reg pv ; set global pointer copy [_t3], [0] copy [0], [_t3] mv ra, add (reg sp, li 0), ; restore return address copy <ref> [11, 12, 13, 14, 15] </ref>, [cs1, cs2, cs3, cs4, cs5] ; restore callee save mv sp, add (reg sp, const frame) ; dealloc frame ret ; return Fig. 7.
Reference: 13. <author> J. Gregory Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon Univer--sity, </institution> <month> December </month> <year> 1995. </year> <note> Published as CMU Technical Report CMU-CS-95-226. </note>
Reference-contexts: 1 Introduction We describe how we integrated MLRISC, a "generic" compiler back end, with TIL, a type-directed compiler for the Standard ML (SML) programming language. A type-directed compiler uses variable type information to guide successive translations between intermediate languages <ref> [13] </ref>. Type-directed compilers rely on complete variable type information for most or all phases of compilation| thus, types are preserved by intermediate code transformations during each phase. <p> The universal availability of type information permits TIL to check types after any phase of compilation|this helps to ensure the correctness of compiler optimizations during development. Type information also allows TIL to perform additional optimizations that are not directly available to conventional compilers <ref> [13] </ref> [10]. A principal benefit of type-directed compilation is that it facilitates sound tag-free garbage collection [18]. Sound garbage collection requires that the heap pointers used by an executing program be identified unambiguously. Tag-free garbage collection permits these heap pointers to be identified without perturbing the run-time representations of values. <p> RTL is not a typed intermediate language, but RTL does annotate pseudo registers with trace values; these are similar to, but distinct from, run-time trace values (the latter are a translation of the former). There are actually two versions of the TIL compiler: TIL1 [17] <ref> [13] </ref> is the first-generation compiler; its successor is called TILT. We will refer to the TIL compiler when the discussion applies to either compiler interchangeably. Both compilers share a common RTL language: the back end of TIL1 translates RTL directly to assembly language. <p> RTL pseudo registers are tagged with trace values that represent a degenerated form of type information that is tailored to the run-time system. Figure 1 is a depiction of the intermediate languages used in TILT; see Morrisett <ref> [13] </ref> for a description of the intermediate languages used in TIL1. SML Abstract Syntax HIL MIL RTL MLRISC Assembly Language Fig. 1. Intermediate Languages in TILT 2.1 HIL and MIL The TILT elaborator translates programs from abstract syntax to HIL (High-level Intermediate Language). <p> A Translation of the code in Figure 2 to RTL run time for dynamic type dispatch and tag-free garbage collection <ref> [13] </ref>. In TIL, the main ramification for the back end is that the run-time system uses a simple form of type information to reclaim storage. The TIL run-time system uses a tracing, copying garbage collector to reclaim unused values in the heap. <p> the use of conditionals in certain RISC architectures (e.g., the Alpha), it cannot f: mv gp, reg pv ; set global pointer mv sp, sub (reg sp, const frame) ; alloc frame store32 add (reg sp, li 0), reg ra ; save return address copy [cs1, cs2, cs3, cs4, cs5], <ref> [11, 12, 13, 14, 15] </ref> ; save callee save copy [_tenv1, x, n, l, l2], [16, 17, 18, 19, 20] ; get arguments store32 add (reg sp, const _tenv1_offset), reg _tenv1 ; save type environment copy [16], [l] ; _t1 &lt;- length (l) mv pv, label "length" call reg pv ; <p> 17, 18, 19], [_tenv1, x, n, _t2] ; _t3 &lt;- g (x, n, _t2) mv pv, label "g" call reg pv ; (call #3) mv gp, reg pv ; set global pointer copy [_t3], [0] copy [0], [_t3] mv ra, add (reg sp, li 0), ; restore return address copy <ref> [11, 12, 13, 14, 15] </ref>, [cs1, cs2, cs3, cs4, cs5] ; restore callee save mv sp, add (reg sp, const frame) ; dealloc frame ret ; return Fig. 7. <p> A general discussion of the performance of type-directed run-time architectures is beyond the scope of this paper, but see Tarditi et al. [17] and Morrisett <ref> [13] </ref>. A potential performance problem that is directly related to the use of ML-RISC as a back end for TIL concerns the constraints that our techniques impose on a back end to simplify trace table generation.
Reference: 14. <author> George C. Necula. </author> <title> Proof-carrying code. </title> <booktitle> In Conference Record of the 24th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. ACM, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: A compiler back end could itself be type directed|both Typed Assembly Language [12] and Proof-Carrying Code <ref> [14] </ref> [15] encode variable type information at the assembly-language level|although this is not common practice, and, as a matter of fact, MLRISC is not type directed. TIL translates a source program through a succession of typed intermediate languages until it arrives at conventional assembly code. <p> the use of conditionals in certain RISC architectures (e.g., the Alpha), it cannot f: mv gp, reg pv ; set global pointer mv sp, sub (reg sp, const frame) ; alloc frame store32 add (reg sp, li 0), reg ra ; save return address copy [cs1, cs2, cs3, cs4, cs5], <ref> [11, 12, 13, 14, 15] </ref> ; save callee save copy [_tenv1, x, n, l, l2], [16, 17, 18, 19, 20] ; get arguments store32 add (reg sp, const _tenv1_offset), reg _tenv1 ; save type environment copy [16], [l] ; _t1 &lt;- length (l) mv pv, label "length" call reg pv ; <p> 17, 18, 19], [_tenv1, x, n, _t2] ; _t3 &lt;- g (x, n, _t2) mv pv, label "g" call reg pv ; (call #3) mv gp, reg pv ; set global pointer copy [_t3], [0] copy [0], [_t3] mv ra, add (reg sp, li 0), ; restore return address copy <ref> [11, 12, 13, 14, 15] </ref>, [cs1, cs2, cs3, cs4, cs5] ; restore callee save mv sp, add (reg sp, const frame) ; dealloc frame ret ; return Fig. 7.
Reference: 15. <author> George C. Necula and Peter Lee. </author> <title> The design and implementation of a certifying compiler. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implemantation, </booktitle> <address> New York, 1998. </address> <publisher> ACM Press. </publisher>
Reference-contexts: A compiler back end could itself be type directed|both Typed Assembly Language [12] and Proof-Carrying Code [14] <ref> [15] </ref> encode variable type information at the assembly-language level|although this is not common practice, and, as a matter of fact, MLRISC is not type directed. TIL translates a source program through a succession of typed intermediate languages until it arrives at conventional assembly code. <p> the use of conditionals in certain RISC architectures (e.g., the Alpha), it cannot f: mv gp, reg pv ; set global pointer mv sp, sub (reg sp, const frame) ; alloc frame store32 add (reg sp, li 0), reg ra ; save return address copy [cs1, cs2, cs3, cs4, cs5], <ref> [11, 12, 13, 14, 15] </ref> ; save callee save copy [_tenv1, x, n, l, l2], [16, 17, 18, 19, 20] ; get arguments store32 add (reg sp, const _tenv1_offset), reg _tenv1 ; save type environment copy [16], [l] ; _t1 &lt;- length (l) mv pv, label "length" call reg pv ; <p> 17, 18, 19], [_tenv1, x, n, _t2] ; _t3 &lt;- g (x, n, _t2) mv pv, label "g" call reg pv ; (call #3) mv gp, reg pv ; set global pointer copy [_t3], [0] copy [0], [_t3] mv ra, add (reg sp, li 0), ; restore return address copy <ref> [11, 12, 13, 14, 15] </ref>, [cs1, cs2, cs3, cs4, cs5] ; restore callee save mv sp, add (reg sp, const frame) ; dealloc frame ret ; return Fig. 7.
Reference: 16. <author> Zhong Shao and Andrew W. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In Conference on Lisp and Functional programming, </booktitle> <month> June 94. </month>
Reference-contexts: gp, reg pv ; set global pointer mv sp, sub (reg sp, const frame) ; alloc frame store32 add (reg sp, li 0), reg ra ; save return address copy [cs1, cs2, cs3, cs4, cs5], [11, 12, 13, 14, 15] ; save callee save copy [_tenv1, x, n, l, l2], <ref> [16, 17, 18, 19, 20] </ref> ; get arguments store32 add (reg sp, const _tenv1_offset), reg _tenv1 ; save type environment copy [16], [l] ; _t1 &lt;- length (l) mv pv, label "length" call reg pv ; (call #1) mv gp, reg pv ; set global pointer copy [_t1], [0] bcc cmp <p> li 0), reg ra ; save return address copy [cs1, cs2, cs3, cs4, cs5], [11, 12, 13, 14, 15] ; save callee save copy [_tenv1, x, n, l, l2], [16, 17, 18, 19, 20] ; get arguments store32 add (reg sp, const _tenv1_offset), reg _tenv1 ; save type environment copy <ref> [16] </ref>, [l] ; _t1 &lt;- length (l) mv pv, label "length" call reg pv ; (call #1) mv gp, reg pv ; set global pointer copy [_t1], [0] bcc cmp (le, reg _t1, li 0), _L1 ; if _t1&lt;=0 goto _L1 copy [16], [l] ; _t2 &lt;- hd (l) mv pv, <p> _tenv1_offset), reg _tenv1 ; save type environment copy <ref> [16] </ref>, [l] ; _t1 &lt;- length (l) mv pv, label "length" call reg pv ; (call #1) mv gp, reg pv ; set global pointer copy [_t1], [0] bcc cmp (le, reg _t1, li 0), _L1 ; if _t1&lt;=0 goto _L1 copy [16], [l] ; _t2 &lt;- hd (l) mv pv, label "hd" call reg pv ; (call #2) mv gp, reg pv ; set global pointer copy [_t2], [0] jmp label _L2 ; goto _L2 _L1: _L2: copy [16, 17, 18, 19], [_tenv1, x, n, _t2] ; _t3 &lt;- g (x, n, <p> cmp (le, reg _t1, li 0), _L1 ; if _t1&lt;=0 goto _L1 copy [16], [l] ; _t2 &lt;- hd (l) mv pv, label "hd" call reg pv ; (call #2) mv gp, reg pv ; set global pointer copy [_t2], [0] jmp label _L2 ; goto _L2 _L1: _L2: copy <ref> [16, 17, 18, 19] </ref>, [_tenv1, x, n, _t2] ; _t3 &lt;- g (x, n, _t2) mv pv, label "g" call reg pv ; (call #3) mv gp, reg pv ; set global pointer copy [_t3], [0] copy [0], [_t3] mv ra, add (reg sp, li 0), ; restore return address copy <p> All other machine registers are given the trace value no. Liveness analysis has the added benefit of minimizing storage retained during garbage collection. This, in turn, enhances performance by reducing the load on the collector and also enables certain programs to terminate that would not otherwise <ref> [16] </ref>. Our liveness analysis is based on well-understood data-flow techniques [1]. Note that the call-site liveness analysis must be at least as precise as the register-allocation liveness analysis for this technique to work.
Reference: 17. <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL : A type-directed optimizing compiler for ML. </title> <booktitle> In Proceedingsof the ACM SIGPLAN Conference on Programming Language Design and Implemantation, </booktitle> <pages> pages 181-192, </pages> <address> New York, May21-24 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: RTL is not a typed intermediate language, but RTL does annotate pseudo registers with trace values; these are similar to, but distinct from, run-time trace values (the latter are a translation of the former). There are actually two versions of the TIL compiler: TIL1 <ref> [17] </ref> [13] is the first-generation compiler; its successor is called TILT. We will refer to the TIL compiler when the discussion applies to either compiler interchangeably. Both compilers share a common RTL language: the back end of TIL1 translates RTL directly to assembly language. <p> gp, reg pv ; set global pointer mv sp, sub (reg sp, const frame) ; alloc frame store32 add (reg sp, li 0), reg ra ; save return address copy [cs1, cs2, cs3, cs4, cs5], [11, 12, 13, 14, 15] ; save callee save copy [_tenv1, x, n, l, l2], <ref> [16, 17, 18, 19, 20] </ref> ; get arguments store32 add (reg sp, const _tenv1_offset), reg _tenv1 ; save type environment copy [16], [l] ; _t1 &lt;- length (l) mv pv, label "length" call reg pv ; (call #1) mv gp, reg pv ; set global pointer copy [_t1], [0] bcc cmp <p> cmp (le, reg _t1, li 0), _L1 ; if _t1&lt;=0 goto _L1 copy [16], [l] ; _t2 &lt;- hd (l) mv pv, label "hd" call reg pv ; (call #2) mv gp, reg pv ; set global pointer copy [_t2], [0] jmp label _L2 ; goto _L2 _L1: _L2: copy <ref> [16, 17, 18, 19] </ref>, [_tenv1, x, n, _t2] ; _t3 &lt;- g (x, n, _t2) mv pv, label "g" call reg pv ; (call #3) mv gp, reg pv ; set global pointer copy [_t3], [0] copy [0], [_t3] mv ra, add (reg sp, li 0), ; restore return address copy <p> However, because TILT and TIL1 use the same RTL intermediate language, we can use MLRISC as a back end for the TIL1 compiler: in Table 5, we present the relative execution times of some of the benchmark programs from Tarditi et al. <ref> [17] </ref>. These measurements show that by using MLRISC as a back end for TIL1, we introduce a significant amount of overhead into the generated code. We believe that this overhead is due to complications in the translation of RTL code to MLRISC code, and is not due to MLRISC itself. <p> This workstation has a 175MHz Alpha 21064 processor with 8k primary instruction and data caches and a 2mb unified secondary cache. Each figure is the arithmetic mean of ten consecutive runs of the corresponding program. See Tarditi et al. <ref> [17] </ref> for descriptions of the benchmark programs. We made one change to MLRISC for the purpose of benchmarking: MLRISC ordinarily generates floating-point arithmetic instructions with the sud flags set in the instruction word. <p> A general discussion of the performance of type-directed run-time architectures is beyond the scope of this paper, but see Tarditi et al. <ref> [17] </ref> and Morrisett [13]. A potential performance problem that is directly related to the use of ML-RISC as a back end for TIL concerns the constraints that our techniques impose on a back end to simplify trace table generation.
Reference: 18. <author> Andrew Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proceedings 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Type information also allows TIL to perform additional optimizations that are not directly available to conventional compilers [13] [10]. A principal benefit of type-directed compilation is that it facilitates sound tag-free garbage collection <ref> [18] </ref>. Sound garbage collection requires that the heap pointers used by an executing program be identified unambiguously. Tag-free garbage collection permits these heap pointers to be identified without perturbing the run-time representations of values. <p> A type environment for f has the caller pass an explicit representation of x's type so that both the run-time system and f can operate on it <ref> [18] </ref> [10]. Type environments are needed only for functions such as f where complete type information is not available at compile time. A type environment is a record of values that encode properties of types that are important to the run-time system. <p> gp, reg pv ; set global pointer mv sp, sub (reg sp, const frame) ; alloc frame store32 add (reg sp, li 0), reg ra ; save return address copy [cs1, cs2, cs3, cs4, cs5], [11, 12, 13, 14, 15] ; save callee save copy [_tenv1, x, n, l, l2], <ref> [16, 17, 18, 19, 20] </ref> ; get arguments store32 add (reg sp, const _tenv1_offset), reg _tenv1 ; save type environment copy [16], [l] ; _t1 &lt;- length (l) mv pv, label "length" call reg pv ; (call #1) mv gp, reg pv ; set global pointer copy [_t1], [0] bcc cmp <p> cmp (le, reg _t1, li 0), _L1 ; if _t1&lt;=0 goto _L1 copy [16], [l] ; _t2 &lt;- hd (l) mv pv, label "hd" call reg pv ; (call #2) mv gp, reg pv ; set global pointer copy [_t2], [0] jmp label _L2 ; goto _L2 _L1: _L2: copy <ref> [16, 17, 18, 19] </ref>, [_tenv1, x, n, _t2] ; _t3 &lt;- g (x, n, _t2) mv pv, label "g" call reg pv ; (call #3) mv gp, reg pv ; set global pointer copy [_t3], [0] copy [0], [_t3] mv ra, add (reg sp, li 0), ; restore return address copy
References-found: 18

