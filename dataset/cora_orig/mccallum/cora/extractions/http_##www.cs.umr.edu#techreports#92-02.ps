URL: http://www.cs.umr.edu/techreports/92-02.ps
Refering-URL: http://www.cs.umr.edu/techreports/
Root-URL: 
Title: FAULT-TOLERANT CONCURRENT BRANCH AND BOUND ALGORITHM DERIVED FROM PROGRAM VERIFICATION  
Author: Hanan Lutfiyya, Aggie Sun and Bruce McMillin 
Keyword: Executable Assertions, Formal Methods, Branch Bound, Concurrent Program Verification, Fault Tolerance.  
Note: This work was supported in part by the National Science Foundation under Grant Numbers MIP-8909749 and CDA-8820714, and in part by the AMOCO Faculty Development Program.  
Address: Rolla, Missouri 65401  
Affiliation: Department of Computer Science University of Missouri at Rolla  
Pubnum: CSC 92-002  
Email: ff@cs.umr.edu  
Date: January 12, 1992  
Abstract: The process of showing that a program satisfies some particular properties with respect to its specification is called program verification. Axiomatic semantics is a verification method that makes assertions describing properties about the states of the program. There exists a transformation from the assertions of the verification proof of a program to executable assertions. These executable assertions may be embedded in the program to create a fault-tolerant program. While this approach has been applied to the sequential programming environment, the distributed programming environment presents special challenges. This paper focuses on applying concurrent programming axiomatic proof systems to generate executable assertions in a distributed environment using distributed branch and bound as a model problem. 
Abstract-found: 1
Intro-found: 1
Reference: [ApRo81] <author> Apt, R. and Roever, </author> <title> W ``A Proof System for Communicating Sequential Processes'', </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2, 3, </volume> <year> 1981, </year> <pages> 359-385. </pages> -- -- 
Reference: [Hoar69] <author> Hoare, C. </author> <title> ``An Axiomatic Basis for Computer Programming'', </title> <journal> Communications of the ACM, </journal> <volume> 12, 10, </volume> <year> 1969, </year> <pages> 576-583. </pages>
Reference: [Hoar78] <author> Hoare, C. </author> <title> ``Communicating Sequential processes'', </title> <journal> Communications of the ACM, </journal> <volume> 21, </volume> <year> 1978, </year> <pages> 666-677. </pages>
Reference: [HoMc91] <author> Hong, C., and McMillin, B., </author> <title> ``Fault-Tolerant Matrix Multiplication with One-Iteration Fault Latency,'' </title> <booktitle> Proceedings of the 15th International COMPSAC, </booktitle> <month> September, </month> <year> 1991. </year>
Reference: [KoSt74] <author> Kohler, W., and Steiglitz, K., </author> <title> ``Characterization and Theoretical Comparison of Branch-and-Bound Algorithms for Permutation Problems,'' </title> <journal> Journal of the ACM, vo. </journal> <volume> 21, no. 1, </volume> <year> 1974, </year> <pages> pp. 140-156. </pages>
Reference: [Lamp77] <author> Lamport, L. </author> <title> ``Proving the Correctness of Multiprocess Programs'' IEEE Transactions on Software Engineering, </title> <booktitle> SE-3,2 (1977), </booktitle> <pages> pp. 125-143. </pages>
Reference: [LaMG91] <author> Larangeria, L., Malek, M., and Jenevein, J., </author> <title> ``On Tolerating Faults in Naturally Redundant Algorithms,'' </title> <booktitle> Tenth Symposium on Reliable Distributed Systems, </booktitle> <year> 1991, </year> <pages> pp. 118-127. </pages>
Reference-contexts: Call F F 6 In this section the concept of a naturally redundant algorithm is generally defined and then it will be seen why the redundancy implies consistency. Definition 7.1 <ref> [LaMG91] </ref>: If a given algorithm A maps an input vector X = (x 0 , x 1 , . . . x N-1 ) to an out put vector Y = (y 0 , y 1 , . . . y N-1 ) and the redundancy relation -"y i , y <p> It is thus desirable, that the correct intermediate calculations could be recovered before they are communicated to other processors. This motivates the definition of algorithms that can be divided in phases that are themselves naturally redundant. Definition 7.2 <ref> [LaMG91] </ref>: An algorithm A is called phase-wise naturally redundant algorithm if: (a) Algorithm A can be divided in phases such that the output vector of one phase is the input vector for the following phase; (b) The output vector of each phase satisfies the redundancy relation.
Reference: [LaSP82] <author> Lamport, L., Shostack, R. and Pease, M., </author> <title> ``The Byzantine General's Problem,'' </title> <journal> ACM Transaction on Programming Language Systems, </journal> <volume> vol. 4, </volume> <month> July </month> <year> 1982, </year> <pages> pp. 382-401. </pages>
Reference-contexts: This case is coined the ``silent worker'' scenario. One way of testing the postcondi-tion would be for each process to broadcast its perception the best solution to all other processes. One way of ensuring the consistency condition would be to use the Byzantine General's algorithm <ref> [LaSP82] </ref>. This is clearly infeasible. Instead a verification round (or stage) is used to check the validity of the solution.
Reference: [LeGr81] <author> Levin, G.M and Gries, </author> <title> David ``A Proof Technique for Communicating Sequential Process,'' </title> <journal> Acta Information, </journal> <volume> 15, </volume> <year> 1981, </year> <pages> 281-302. </pages>
Reference: [LuMc91a] <author> Lutfiyya, H. and McMillin, B. </author> <title> ``Formal Generation Of Executable Assertions For A Fault-Tolerant Parallel Bitonic Sort,'' </title> <institution> UMR Department of Computer Science Technical Report CSC-91-12, </institution> <month> August, </month> <year> 1991. </year>
Reference: [LuMc91b] <author> Lutfiyya, H. and McMillin, B. </author> <title> ``Formal Generation Of Executable Assertions For A Fault-Tolerant Parallel Matrix Relaxation,'' </title> <institution> UMR Department of Computer Science Technical Report CSC-91-13, </institution> <month> October, </month> <year> 1991. </year>
Reference: [LuMc91c] <author> Lutfiyya, H. and McMillin, B. </author> <title> ``Comparison of Three Axiomatic Systems for CSP,'' </title> <institution> UMR Department of Computer Science Technical Report CSC-91-07, </institution> <month> August, </month> <year> 1991. </year>
Reference: [LuMc92] <author> Lutfiyya, H. and McMillin, B. </author> <title> ``An Algorithm For Generating Executable Assertions For Fault-Tolerance,'' </title> <institution> UMR Department of Computer Science Technical Report CSC-92-1, </institution> <month> January, </month> <year> 1992. </year>
Reference-contexts: Assertions that use only local variables limit the operational fault-tolerant environment to having each node check only itself. Treating global variables affords us inter-node diagnosability. The transformation can be done algorithmically <ref> [LuMc92] </ref>. But, this results in fault-tolerant programs in which the run-times are significantly increased for the non fault-tolerant version of the program. This tradeoff between speed and reliability is not justifiable for many applications. Therefore, it becomes necessary to examine heuristic means for reducing the runtime execution.
Reference: [McNi88] <author> McMillin, B. and Ni, L., </author> <title> ``Executable Assertion Development for the Distributed Parallel Environment,'' </title> <booktitle> Proceedings of the 12th International COMPSAC, </booktitle> <address> Chicago, IL, </address> <month> October </month> <year> 1988, </year> <pages> pp. 284-291. </pages>
Reference: [McNi88a] <author> McMillin, B. and Ni, L., </author> <title> ``A Reliable Parallel Algorithm for Relaxation Labeling,'' Parallel Processing for Computer Vision and Display, </title> <editor> P. M. Dew, R. A. Earnshaw, and T. R. Heywood, eds., Addi-son-Wesley, </editor> <year> 1989, </year> <pages> pp. 190-209. </pages>
Reference: [McNi89] <author> McMillin, B. and Ni, L., </author> <title> ``Reliable Distributed Sorting Through The Application-oriented Fault Tolerance Paradigm,'' </title> <booktitle> 9th ICDS, </booktitle> <year> 1989, </year> <pages> pp. 508-515. </pages>
Reference: [Mili81] <author> Mili, A. </author> <title> ``Self-Checking Programs: An Axiomatisation of Program Validation by Executable Assertions,'' </title> <booktitle> 11th Annual Int'l Symp. on Fault-Tolerant Computing, </booktitle> <year> 1981, </year> <pages> pp 118-120. </pages>
Reference: [Mili85] <author> Mili, A. </author> <title> ``Towards a Theory of Forward Recovery,'' </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-13, no. 1, </volume> <month> January </month> <year> 1987, </year> <pages> pp. 23-31. </pages>
Reference-contexts: The natural redundancy nature of program variables provides recovery from errors in future states of program execution. Natural redundancy allows for a forward recovery approach <ref> [Mili85] </ref>, since there is no need of backtracking the computation to restore a correct value of an erroneous output vector component. Earlier we discussed that consistency provides that any two processors executing the same executable assertion reach the same conclusion and for strengthing executable assertions based on progress and feasibility.
Reference: [Quin88] <author> Quinn, M. J., </author> <title> Designing Efficient Algorithms for Parallel Computers, </title> <publisher> McGraw Hill, </publisher> <year> 1988, </year> <pages> pp. 185-195. </pages>
Reference: [ScSc84] <author> Schlichting, R., and Schneider, F., </author> <title> ``Using Message Passing For Distributed Programming: Proof Rules and Disciplines,'' </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 6, No. 3, </volume> <month> July </month> <year> 1984, </year> <pages> pp. 402-431. </pages>
Reference: [Soun84] <author> Soundararahan, </author> <title> N ``Axiomatic Semantics of Communicating Sequential Processes,'' </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6, 4, </volume> <year> 1984, </year> <pages> 647-662. </pages> -- -- 
Reference: [SuMc91] <author> Sun, A. and McMillin, B. </author> `` <note> Application-Oriented Fault-Tolerant Parallel Branch&Bound '' UMR Department of Computer Science Technical Report CSC-91-014, </note> <month> September, </month> <year> 1991. </year>
Reference-contexts: One way of ensuring the consistency condition would be to use the Byzantine General's algorithm [LaSP82]. This is clearly infeasible. Instead a verification round (or stage) is used to check the validity of the solution. This is handled efficiently by the following procedure, that is called the verification stage <ref> [SuMc91] </ref>: if "i [i, s current, T, P] s current then ERROR! The verification stage consists of resolving the puzzle by redistributing the initial states to different workers and restricting the workers to communicate within disjoint sets of workers. <p> Each verification round allows for each process to recompute the solution in different ways. Thus, if there is a discrepancy in the values received in the different rounds then there is an error. For full details of the fault-tolerant algorithm using verification rounds see <ref> [SuMc91] </ref>. This section describes the development of the assertions necessary to cover the progress and feasibility constraints for Application-Oriented Fault Tolerance. Each assertions was developed based on the definitions of the problem and the behavior they exhibit as defined by the verification proof. <p> Experimentation on the parallel fault-tolerant algorithm shows that the amount of overhead was mainly caused by the verification stage, as expected. However, the fault-tolerant algorithm is efficient. Experimentation results are presented in <ref> [SuMc91] </ref>. This paper has shown how to translate a verification proof into a fault-tolerant algorithm using the model of a branch and bound problem. This problem showed how executable assertions are related to the intermediate assertions of a verification proof.
Reference: [YaCh75] <author> Yau, S. S. and Cheung R. C. </author> <title> ``Design of Self-Checking Software,'' </title> <booktitle> Proc. Int'l Conf. on Reliability Software, </booktitle> <month> April </month> <year> 1975, </year> <pages> pp 450-457. </pages> -- --
References-found: 23

