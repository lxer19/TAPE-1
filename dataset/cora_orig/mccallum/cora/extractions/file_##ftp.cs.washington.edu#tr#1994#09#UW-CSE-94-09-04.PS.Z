URL: file://ftp.cs.washington.edu/tr/1994/09/UW-CSE-94-09-04.PS.Z
Refering-URL: http://www.cs.washington.edu/research/projects/lis/chinook/www/publications.html
Root-URL: 
Title: Scheduling Issues in the Co-Synthesis of Reactive Real-Time Systems 1  
Author: Pai Chou, Elizabeth Walkup, Gaetano Borriello 
Date: April 20, 1994  
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Pubnum: Technical Report 94-09-04  
Abstract: 1 An edited version of ths report appears in IEEE Micro, August 1994. 2 This work was supported by an NSF Graduate Fellowship (Walkup), a PYI Award (MIP-8858782), and by the ARPA/CSTO Microsystems Program under an ONR monitored contract (N00014-91-J-4041). The authors' email addresses are fchou,walkup,gaetanog@cs.washington.edu. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Richard Gerber and Seongsoo Hong. </author> <title> Semantics-based compiler transformations for enhanced schedulability. </title> <booktitle> In Proceedings of the Real Time Systems Symposium, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: In practice, designers often must tune their programs manually even when a real-time kernel is used. A few recent techniques such as that of Gerber and Hong <ref> [1] </ref> attempt to gain better control over observable events by applying compiler analysis. However, they do not handle all important classes of deterministic timing constraints. Process-based real-time models often make assumptions that may not be reasonable for reactive systems.
Reference: [2] <author> R. De Simone F. </author> <title> Boussinot. </title> <booktitle> The Esterel language. Proceedings of the IEEE, </booktitle> <volume> 79(9), </volume> <month> September </month> <year> 1991. </year>
Reference-contexts: Interleaving concurrent I/O transactions is often necessary for reactive systems. Scheduling Issues in the Co-Synthesis of Reactive Real-Time Systems 3 Reactive systems require a different programming model from the process-based real-time model. Among the most widely known specification languages for reactive systems are Esterel <ref> [2] </ref> and StateCharts [3]. Both provide constructs for concurrency and watchdog-style preemption. Both also define simulation semantics for real-time behavior on an idealized machine, (i.e., one that is "much faster" than the speed of its environment) but of course there is no guarantee that this will be the case.
Reference: [3] <author> D. Harel. StateCharts: </author> <title> a visual formalism for complex systems. </title> <journal> Science of Programming, </journal> <volume> 8, </volume> <year> 1987. </year>
Reference-contexts: Interleaving concurrent I/O transactions is often necessary for reactive systems. Scheduling Issues in the Co-Synthesis of Reactive Real-Time Systems 3 Reactive systems require a different programming model from the process-based real-time model. Among the most widely known specification languages for reactive systems are Esterel [2] and StateCharts <ref> [3] </ref>. Both provide constructs for concurrency and watchdog-style preemption. Both also define simulation semantics for real-time behavior on an idealized machine, (i.e., one that is "much faster" than the speed of its environment) but of course there is no guarantee that this will be the case.
Reference: [4] <author> Donald E. Thomas and Philip R. Moorby. </author> <title> The Verilog Hardware Description Language. </title> <publisher> Kluwer Academic, </publisher> <year> 1991. </year>
Reference-contexts: Scheduling Issues in the Co-Synthesis of Reactive Real-Time Systems 4 2.1 High-Level Specification The input supplied by the user is a high-level description of the system. Currently, we support the Verilog hardware description language <ref> [4] </ref>. It contains a structural section and a behavioral section. The structural description instantiates the processor (s) and the devices used in the system. Chinook automatically connects the pins of the devices to the processor, by synthesizing appropriate glue logic as necessary.
Reference: [5] <author> Pai Chou, Ross Ortega, and Gaetano Borriello. </author> <booktitle> Synthesis of hardware/software interface in microcontroller-based systems. In Proceedings of the International Conference on Computer Aided Design, </booktitle> <month> November </month> <year> 1992. </year>
Reference-contexts: If a processor has general-purpose I/O ports, Chinook will attempt to use them because they incur minimal hardware and software cost. A greedy algorithm <ref> [5] </ref> attempts to use the same I/O port to service those devices that are not active at the same time. If there are not enough I/O ports to service all the devices, then multiplexing hardware is synthesized along with the driver routines. <p> This paper addresses the performance problem; bandwidth issues of port alocation and memory mapping are handled by the algorithm described in Chou et al <ref> [5] </ref>. Different processors with different speeds, instruction sets, and I/O ports will require different variations on the software routines.
Reference: [6] <author> Pai Chou and Gaetano Borriello. </author> <title> Software scheduling in the co-synthesis of reactive real-time systems. </title> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: We can schedule this mode by first transforming the parallel loops into an outer loop with a parallel body, so that the body of the loop can be scheduled using known techniques <ref> [6] </ref>. Here we describe the transformation step called rate matching. <p> The scheduling problem can be formulated as a graph, where the vertices represent operations, and the edges represent timing constraints similar to relative scheduling [7]. Our scheduling algorithm <ref> [6] </ref> calls the Bellman-Ford single-source longest path algorithm as a subroutine both to check feasibility and to assign start times of the operations.
Reference: [7] <author> David C. Ku and Giovanni De Micheli. </author> <title> Relative scheduling under timing constraints: algorithms for high-level synthesis of digital circuits. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 11(6), </volume> <month> June </month> <year> 1992. </year> <title> Scheduling Issues in the Co-Synthesis of Reactive Real-Time Systems 16 </title>
Reference-contexts: The scheduling problem can be formulated as a graph, where the vertices represent operations, and the edges represent timing constraints similar to relative scheduling <ref> [7] </ref>. Our scheduling algorithm [6] calls the Bellman-Ford single-source longest path algorithm as a subroutine both to check feasibility and to assign start times of the operations.
Reference: [8] <author> Gaetano Borriello. </author> <title> A New Interface Specification Methodology and its Application to Transducer Synthesis. </title> <type> PhD thesis, </type> <institution> University of California, </institution> <month> May </month> <year> 1988. </year> <note> Report No. UCB/CSD 88/430. </note>
Reference-contexts: The problem of determining a good implementation of the driver so that it meets timing constraints imposed by the device and makes efficient use of hardware resources - can be posed as a combined scheduling and partitioning problem. Previous work in the field of interface synthesis <ref> [8] </ref> considered the problem of generating glue logic to interconnect devices whose interfaces are specified by timing diagrams.
Reference: [9] <author> B. W. Kernighan and S. Lin. </author> <title> An efficient heuristic procedure for partitioning graphs. </title> <journal> The Bell System Technical Journal, </journal> <month> February </month> <year> 1970. </year>
Reference-contexts: If so, then there is no need to partition the events between hardware and software. However, when we must partition the events we will rely upon a Kernighan-Lin-style <ref> [9] </ref> iterative improvement algorithm on top of a max-flow/min-cut-based partitioning technique in the spirit of Bui et al [10]. Details of this algorithm are provided in Walkup and Borriello [11].
Reference: [10] <author> T.N. Bui, S. Chaudhuri, F.T. Leighton, and M. Sipser. </author> <title> Graph bisection algoritms with good average case behavior. </title> <journal> Combinatorica, </journal> <volume> 7(2), </volume> <year> 1987. </year>
Reference-contexts: If so, then there is no need to partition the events between hardware and software. However, when we must partition the events we will rely upon a Kernighan-Lin-style [9] iterative improvement algorithm on top of a max-flow/min-cut-based partitioning technique in the spirit of Bui et al <ref> [10] </ref>. Details of this algorithm are provided in Walkup and Borriello [11]. The input to the min-cut algorithm consists of a graph with weighted edges and two distinguished nodes, the source and the sink.
Reference: [11] <author> Elizabeth A. Walkup and Gaetano Borriello. </author> <title> Automatic synthesis of device drivers for embedded systems. </title> <type> Technical report, </type> <institution> University of Washington, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: However, when we must partition the events we will rely upon a Kernighan-Lin-style [9] iterative improvement algorithm on top of a max-flow/min-cut-based partitioning technique in the spirit of Bui et al [10]. Details of this algorithm are provided in Walkup and Borriello <ref> [11] </ref>. The input to the min-cut algorithm consists of a graph with weighted edges and two distinguished nodes, the source and the sink.
Reference: [12] <author> Edward Solari. ISA and ESA, </author> <title> Theory and Operation. </title> <address> Annabooks, </address> <year> 1992. </year>
Reference: [13] <author> Bruce Gladstone. </author> <title> Specification of timing in a digital system. </title> <booktitle> ASIC and EDA, </booktitle> <pages> pages 46-52, </pages> <month> August </month> <year> 1993. </year> <title> Acknowledgements This work was supported by an NSF Graduate Fellowship (Walkup), a PYI Award (MIP-8858782), and by the DARPA/CSTO Microsystems Program under an ONR monitored contract (N00014-91-J-4041). </title>
References-found: 13

