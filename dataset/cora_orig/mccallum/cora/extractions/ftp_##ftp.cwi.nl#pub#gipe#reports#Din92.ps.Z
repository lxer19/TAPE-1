URL: ftp://ftp.cwi.nl/pub/gipe/reports/Din92.ps.Z
Refering-URL: http://www.progsoc.uts.edu.au/~geldridg/cpp/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: OBJECT-ORIENTED PROGRAMMING: INHERITANCE TO ADOPTION  An Abstract  
Author: by T. B. Dinesh 
Degree: Of a thesis submitted in partial fulfillment of the requirements for the Doctor of Philosophy degree in Computer Science in the Graduate College of The  Thesis supervisors: Professor Arthur C. Fleck Professor Paul Klint  
Date: May 1992  
Affiliation: University of Iowa  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> P. </author> <title> America. Inheritance and subtyping in a parallel object-oriented language. </title> <booktitle> In Proceedings of Conference on European Conference on Object-Oriented Programming, </booktitle> <pages> pages 234-242, </pages> <year> 1987. </year>
Reference-contexts: The apparent polymorphism also illustrates that inheritance does preserve algorithmic abstraction, as is the case with parametric polymorphism and therefore a careful statement of contract compliance <ref> [43, 1] </ref> is demanded over the general subtyping rules. In this thesis, we consider only subtype conformance that can be realized using type signatures. In general, inheritance (subclass) does not imply a subtype relation, as demonstrated by [54, 17], since inheritance does not require a contravariance rule. <p> Type, as used in this thesis, is more general than a class as it considers type conformance using signatures and it is possible that objects of several different classes conform to the same type. Definition 1.3.1 The conformance or subtype relation is defined as <ref> [9, 1] </ref>: The type t is a subtype of if, for each method of there is a corresponding method t of t , such that * and t have the same name. * and t have the same number of arguments. * The ith parameter type of is a subtype of <p> "[" ELEMENTS "]" -&gt; SET "[" "]" -&gt; SET ELEMENT -&gt; ELEMENTS ELEMENTS "," ELEMENT -&gt; ELEMENTS In order to define equations over list functions, we need list variables: exports sorts SET ELEMENT context-free syntax "[" -ELEMENT ","-* "]" -&gt; SET variables "Elts"[123] -&gt; -ELEMENT ","-* "i" -&gt; ELEMENT equations <ref> [1] </ref> [Elts1, i, Elts2, i, Elts3] = [Elts1, i, Elts2, Elts3] Elts1, Elts2, and Elts3 are list variables, ranging over list of zero or more ELEMENTs separated by commas. <p> fleftg NAT "&gt;" NAT ! BOOL NAT ! INT variables Nat-con [09 0 ]fl ! NAT-CON hiddens context-free functions gt "(" NAT ";" NAT ")" ! BOOL NAT "==" NAT ! NAT variables n [09]fl ! NAT-CON c [09]fl ! CHAR x [09]fl ! CHARfl y [09]fl ! CHAR+ equations <ref> [1] </ref> nat-con ("0" y ) = nat-con (y ) [3] Nat + 0 = Nat 152 [7] 1 + 4 = 5 [8] 1 + 5 = 6 [9] 1 + 6 = 7 [13] 2 + 1 = 3 [14] 2 + 2 = 4 [15] 2 + 3 =
Reference: [2] <author> H. P. Barendregt. </author> <title> The lambda calculus, its syntax and semantics. </title> <publisher> North Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1984. </year> <note> 2-nd revised edition. </note>
Reference-contexts: 0, 1, 2, and returns a natural number, defined as (the symbol ) follows 1 : F self:n:if n = 0 then 1 else n fl (self (n 1)): The fixed-point of F is the factorial function defined by f act Y F where Y is the call-by-value fixpoint operator <ref> [57, 2, 46] </ref>, (i.e., F f act = f act). <p> = 3 then 3 else if n = 0 then 1 else n fl (f (n 1)); how may the user specify this function as an "incremental modification" of fact's specification? What is meant by incremental modification is that, the structure of 1 For -calculus and denotational semantics we use <ref> [57, 2, 27] </ref> 15 f and f act are the same except for the additional condition, if n = 3 then 3 else if , and the goal is to specify f by just specifying this difference.
Reference: [3] <author> J. Bergstra, J. Heering, and P. Klint. </author> <title> Algebraic definition of a simple programming language. </title> <type> Report CS-R8504, </type> <institution> Centrum voor Wiskunde en Informatica (CWI), </institution> <address> Amsterdam, </address> <year> 1985. </year>
Reference-contexts: The specification of value environment is similar to traditional value environments specification <ref> [3, 29] </ref>. The utility of the value environment is different, however, since in an object oriented language, the only interesting environment during program execution is the one associated with self. <p> variables Nat-con [09 0 ]fl ! NAT-CON hiddens context-free functions gt "(" NAT ";" NAT ")" ! BOOL NAT "==" NAT ! NAT variables n [09]fl ! NAT-CON c [09]fl ! CHAR x [09]fl ! CHARfl y [09]fl ! CHAR+ equations [1] nat-con ("0" y ) = nat-con (y ) <ref> [3] </ref> Nat + 0 = Nat 152 [7] 1 + 4 = 5 [8] 1 + 5 = 6 [9] 1 + 6 = 7 [13] 2 + 1 = 3 [14] 2 + 2 = 4 [15] 2 + 3 = 5 [19] 2 + 7 = 9 [20] 2
Reference: [4] <author> J. Bergstra, J. Heering, and P. Klint, </author> <title> editors. Algebraic Specification. </title> <publisher> ACM Press Frontier Series. The ACM Press in co-operation with Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The language EOOL presented in Chapter 6 is an Eiffel [43] like language, but forces inherited types [17] to behave like subtypes using the ideas described in Chapter 4. 5.2 ASF+SDF ASF, an acronym for Algebraic Specification Formalism, <ref> [4, 30] </ref> is a formalism supporting modularization and conditional equations. The ASF system, is able to generate rewriting systems from the specification, and to execute them. <p> A sentence according to an SDF grammar is mapped uniquely on an abstract syntax tree [28], and constitutes a term over the signature. Equations over these terms may have positive or negative conditions <ref> [4, p.306] </ref> giving rise to the quasi-initial models introduced by Kaplan [35]. For a complete description of the ASF+SDF formalism see [4, 31]. Specifying in the ASF+SDF formalism is supported by the ASF+SDF system [37] [31, Chapter 5]. <p> Equations over these terms may have positive or negative conditions [4, p.306] giving rise to the quasi-initial models introduced by Kaplan [35]. For a complete description of the ASF+SDF formalism see <ref> [4, 31] </ref>. Specifying in the ASF+SDF formalism is supported by the ASF+SDF system [37] [31, Chapter 5]. This system is able to generate parsers from ASF+SDF specifications and to derive term rewriting systems for specifications in ASF+SDF, thus allowing to execute ASF+SDF specifications.
Reference: [5] <author> A. Black, N. Hutchinson, E. Jul, and H. Levy. </author> <title> Object structure in the emerald system. </title> <booktitle> In Proceedings of Conference on Object Oriented Programming, Systems and Languages, </booktitle> <pages> pages 78-86, </pages> <year> 1986. </year>
Reference: [6] <author> K. Bruce. </author> <title> Private Communication. Electronic mail, </title> <year> 1991. </year>
Reference-contexts: Instead he preferred the implementation oriented view of using the message passing 43 mechanism to send the receiver of a message as the first argument of the method, thereby obtaining the desired recursion. Bruce <ref> [6] </ref>, Kamin and Reddy [34] have shown that these two different views of the object are equivalent. Mitchell's model is extended here by providing for super and also providing for the notion of templates. <p> Objects can therefore be extended, only by accessing the template generator which cannot exist as a first class entity in the system. As also noted by Kim Bruce <ref> [6] </ref>, "myclass" in Cook's semantics cannot be extended and therefore Cook's semantics cannot model the class notion of SmallTalk, but does model the class notion of languages like Eiffel where the classes are only available as "object generating things".
Reference: [7] <author> K. B. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design, static typing and semantics. </title> <type> Technical Report CS-92-01, </type> <institution> Williams College, </institution> <address> Williamstown, MA 01267, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Cardelli [9] used it to mean subtypes (substitutability in all contexts), while Bruce <ref> [7] </ref> uses it to identify a little more relaxed relation that need not be just subtypes, but inherited types [17]. <p> Chapter 4 adopts the general idea of Chapter 3 to the restricted context of the language Eiffel. A more restricted language that only identifies "inherited types" <ref> [17, 7] </ref> as subtypes is considered in detail in Chapter 6. Chapter 5 gives an algebraic specification of a subset of the mechanisms developed in Chapter 2 using ASF+SDF. <p> The objective for defining the language is to discuss the utility of certain flexible features and the resulting type checking problems, that typically arise in object oriented languages due to bounded and F-bounded quantification of the type expressions <ref> [7] </ref>. The language is flexibly defined so that certain techniques can be discussed that cannot be modeled by some of the accepted semantics [15, 51] that attempted to describe [26] and are usually not permitted [43, 58]. <p> This language has thus become the infamous example for many theoreticians working on developing type-safe object-oriented languages <ref> [7, 11] </ref>, ever since Cook illustrated [16] these type-checking holes and made a proposal of removing the "extra flexibility" that Eiffel provides in favor of the safety of type-checking. <p> There are many Object-Oriented Programming Languages (OOPL) that have surfaced in the recent years [20, 26, 53, 59, 36, 58, 43, 5, 19, 38, 12, 61, 48]. Although many of these languages are used for programming in the large, the kernel of these languages is generally small <ref> [32, 50, 11, 7] </ref>. The semantic mechanisms of these languages have been studied mostly in a denotational setting [15, 18, 33, 32, 7, 51]. Although this research has produced interesting constructions for the denotational semantics community, among the community of programmers the mechanisms are still understood using informal terms. <p> Although many of these languages are used for programming in the large, the kernel of these languages is generally small [32, 50, 11, 7]. The semantic mechanisms of these languages have been studied mostly in a denotational setting <ref> [15, 18, 33, 32, 7, 51] </ref>. Although this research has produced interesting constructions for the denotational semantics community, among the community of programmers the mechanisms are still understood using informal terms. <p> We provide for renaming instead of super not only to keep the language simple, but also since this is less confusing for a user as to which method is referred to in a long inheritance chain. Bruce <ref> [7] </ref> notes that understanding 119 inheritance as being equivalent to textual substitution breaks down due to the presence of the keyword super. Here we indicate that this intuitive understanding can be aided by eliminating the keyword super while maintaing the expressivity provided by super (through renaming as in Eiffel). <p> Other alternative adopting and/or adapting techniques should be studied, that relax the adoptability conditions according to different needs (Appendix C). The practicality of the techniques suggested in Chapter 3 should also be studied in its most general sense. The work done by Cardelli, Mitchell and Bruce <ref> [10, 13, 7] </ref> appears to be the direction to go in understanding the limitations of the proposal in Chapter 3. A better understanding of how this can be achieved when the subtype hierarchies and subclass hierarchies are completely separate is necessary. <p> hiddens context-free functions gt "(" NAT ";" NAT ")" ! BOOL NAT "==" NAT ! NAT variables n [09]fl ! NAT-CON c [09]fl ! CHAR x [09]fl ! CHARfl y [09]fl ! CHAR+ equations [1] nat-con ("0" y ) = nat-con (y ) [3] Nat + 0 = Nat 152 <ref> [7] </ref> 1 + 4 = 5 [8] 1 + 5 = 6 [9] 1 + 6 = 7 [13] 2 + 1 = 3 [14] 2 + 2 = 4 [15] 2 + 3 = 5 [19] 2 + 7 = 9 [20] 2 + 8 = 10 [21] 2 +
Reference: [8] <author> P. Canning, W. Cook, W. Hill, J. Mitchell, and W. Olthoff. </author> <title> F-bounded quantification for object-oriented programming. </title> <booktitle> In Proceedings of Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <year> 1989. </year>
Reference-contexts: ";" NAT ")" ! BOOL NAT "==" NAT ! NAT variables n [09]fl ! NAT-CON c [09]fl ! CHAR x [09]fl ! CHARfl y [09]fl ! CHAR+ equations [1] nat-con ("0" y ) = nat-con (y ) [3] Nat + 0 = Nat 152 [7] 1 + 4 = 5 <ref> [8] </ref> 1 + 5 = 6 [9] 1 + 6 = 7 [13] 2 + 1 = 3 [14] 2 + 2 = 4 [15] 2 + 3 = 5 [19] 2 + 7 = 9 [20] 2 + 8 = 10 [21] 2 + 9 = 11 [25] 3 +
Reference: [9] <author> L. Cardelli. </author> <title> Semantics of multiple inheritance. In Semantics of Datatypes, </title> <publisher> LNCS 173, </publisher> <pages> pages 51-68, </pages> <year> 1984. </year>
Reference-contexts: Cardelli <ref> [9] </ref> used it to mean subtypes (substitutability in all contexts), while Bruce [7] uses it to identify a little more relaxed relation that need not be just subtypes, but inherited types [17]. <p> Type, as used in this thesis, is more general than a class as it considers type conformance using signatures and it is possible that objects of several different classes conform to the same type. Definition 1.3.1 The conformance or subtype relation is defined as <ref> [9, 1] </ref>: The type t is a subtype of if, for each method of there is a corresponding method t of t , such that * and t have the same name. * and t have the same number of arguments. * The ith parameter type of is a subtype of <p> A point at (3, 4) is specified by the class in Example 2.3. The self reference in the class definition is captured by the abstracted self variable (second equation of the translation function and as formalized in <ref> [9] </ref> and [15]): 23 class Circle subclass of Point meth radius = 5 meth distFromOrig = max ((super.distFromOrig self.radius),0) Example 3: Class Circle modifies distFromOrig Point self. 2 6 6 6 6 6 4 y 7! 4; distF romOrig 7! sqrt (self:x 2 + self:y 2 ); closerT oOrig 7! p:(self:distF <p> This development is a generalized semantics of inheritance, delegation and recursive templates. 2.8 Related work The notion of objects being fixed points of mutually recursive functions over self was explained by Cardelli <ref> [9] </ref>. The notion of inheritance was made clear by Reddy [51] and Cook [15] who showed that inheritance required the redefinition of self, and also explained the meaning of super to refer to a parent's method. <p> One the results of using delegation in an inheritance based language is to accommodate some of the useful "inherited types" [17] as subtypes (Chapter 6). Subtype definition is usually restricted to the contravariance of method argument types <ref> [9] </ref> as explained in Chapter 1. <p> This can be achieved by manipulating the message passing mechanism. The message passing mechanism, which applies the appropriate method of the object (that receives the message) to the arguments, is usually a simple record field selection <ref> [9] </ref>, but in our case this action is manipulable by the user to a certain extent and in a prescribed manner. A small object-oriented language that defines the basic characteristics of a typical object-oriented language (similar to [43, 58]) is described. <p> The method conformance is defined by the contravariance of the arguments and the covariance of the results <ref> [9] </ref>: f : C ! D 0 f : C 0 ! D 0 () C 0 C ^ D D 0 We sometimes abbreviate "covariance of argument types of the methods" to just covariance and similarly contravariance, as this results in no confusion. Types could be specified separately. <p> "==" NAT ! NAT variables n [09]fl ! NAT-CON c [09]fl ! CHAR x [09]fl ! CHARfl y [09]fl ! CHAR+ equations [1] nat-con ("0" y ) = nat-con (y ) [3] Nat + 0 = Nat 152 [7] 1 + 4 = 5 [8] 1 + 5 = 6 <ref> [9] </ref> 1 + 6 = 7 [13] 2 + 1 = 3 [14] 2 + 2 = 4 [15] 2 + 3 = 5 [19] 2 + 7 = 9 [20] 2 + 8 = 10 [21] 2 + 9 = 11 [25] 3 + 4 = 7 [26] 3 +
Reference: [10] <author> L. Cardelli. </author> <title> Typeful programming. </title> <type> Technical report, </type> <month> DEC, May </month> <year> 1989. </year>
Reference-contexts: Other alternative adopting and/or adapting techniques should be studied, that relax the adoptability conditions according to different needs (Appendix C). The practicality of the techniques suggested in Chapter 3 should also be studied in its most general sense. The work done by Cardelli, Mitchell and Bruce <ref> [10, 13, 7] </ref> appears to be the direction to go in understanding the limitations of the proposal in Chapter 3. A better understanding of how this can be achieved when the subtype hierarchies and subclass hierarchies are completely separate is necessary.
Reference: [11] <author> L. Cardelli. </author> <title> Typed foundations of object-oriented programming. </title> <note> Technical Report To appear, DEC Systems Research Center, </note> <year> 1992. </year>
Reference-contexts: Although delegation allows us to redefine arbitrarily method labels in this manner, in a statically-typed context this flexibility makes it hard to analyze the type of an expression. In such cases, it would help to differentiate between instance variables and methods and allow only updating of instance variables <ref> [11] </ref>. 2.5 Templates and inheritance The class construct of language C 1 (Section 2.2) is restrictive in expressivity since it can only define a unique object instance, and an update facility was looked 30 at in Section 2.4.3 which increased the expressivity by allowing other objects like the one defined by <p> This language has thus become the infamous example for many theoreticians working on developing type-safe object-oriented languages <ref> [7, 11] </ref>, ever since Cook illustrated [16] these type-checking holes and made a proposal of removing the "extra flexibility" that Eiffel provides in favor of the safety of type-checking. <p> There are many Object-Oriented Programming Languages (OOPL) that have surfaced in the recent years [20, 26, 53, 59, 36, 58, 43, 5, 19, 38, 12, 61, 48]. Although many of these languages are used for programming in the large, the kernel of these languages is generally small <ref> [32, 50, 11, 7] </ref>. The semantic mechanisms of these languages have been studied mostly in a denotational setting [15, 18, 33, 32, 7, 51]. Although this research has produced interesting constructions for the denotational semantics community, among the community of programmers the mechanisms are still understood using informal terms.
Reference: [12] <author> L. Cardelli, J. Donahue, L. Galssman, M. Jordan, B. Kalsow, and G. Nelson. </author> <type> Modula-3 report. Technical Report SRC-31, </type> <institution> DEC Systems Research Center, </institution> <year> 1988. </year> <month> 203 </month>
Reference-contexts: Before considering the effects of mixing these two in detail (in the next section), we formulate the idea of passing self as first argument here. This idea has been used by the people who have implemented object-oriented languages <ref> [52, 12] </ref> as noted in [47, 33]. Although the constructions using the explicit fixpoint operator seemed elegant for the case of inheritance, as we have noted above, it looses its elegancy for delegation. A simpler translation can be obtained for delegation that encompasses the expressivity of the constructions of inheritance.
Reference: [13] <author> L. Cardelli and J. Mitchell. </author> <title> Operations on records. </title> <booktitle> In Proceedings of the Fifth Conference on Mathematical Foundations of Programming Language Semantics, </booktitle> <year> 1989. </year>
Reference-contexts: Other alternative adopting and/or adapting techniques should be studied, that relax the adoptability conditions according to different needs (Appendix C). The practicality of the techniques suggested in Chapter 3 should also be studied in its most general sense. The work done by Cardelli, Mitchell and Bruce <ref> [10, 13, 7] </ref> appears to be the direction to go in understanding the limitations of the proposal in Chapter 3. A better understanding of how this can be achieved when the subtype hierarchies and subclass hierarchies are completely separate is necessary. <p> [09]fl ! NAT-CON c [09]fl ! CHAR x [09]fl ! CHARfl y [09]fl ! CHAR+ equations [1] nat-con ("0" y ) = nat-con (y ) [3] Nat + 0 = Nat 152 [7] 1 + 4 = 5 [8] 1 + 5 = 6 [9] 1 + 6 = 7 <ref> [13] </ref> 2 + 1 = 3 [14] 2 + 2 = 4 [15] 2 + 3 = 5 [19] 2 + 7 = 9 [20] 2 + 8 = 10 [21] 2 + 9 = 11 [25] 3 + 4 = 7 [26] 3 + 5 = 8 [27] 3 +
Reference: [14] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: CHAR x [09]fl ! CHARfl y [09]fl ! CHAR+ equations [1] nat-con ("0" y ) = nat-con (y ) [3] Nat + 0 = Nat 152 [7] 1 + 4 = 5 [8] 1 + 5 = 6 [9] 1 + 6 = 7 [13] 2 + 1 = 3 <ref> [14] </ref> 2 + 2 = 4 [15] 2 + 3 = 5 [19] 2 + 7 = 9 [20] 2 + 8 = 10 [21] 2 + 9 = 11 [25] 3 + 4 = 7 [26] 3 + 5 = 8 [27] 3 + 6 = 9 [31] 4 +
Reference: [15] <author> W. Cook. </author> <title> Denotational semantics of inheritance. </title> <type> Technical Report CS-89-33, </type> <institution> Brown University, </institution> <year> 1989. </year>
Reference-contexts: This provides a way of relaxing the contravariance rule in many subtype definitions while avoiding run-time type errors. 1.4 Thesis overview The constructions given for inheritance <ref> [15, 51] </ref> seem to be restrictive and we suggest thinking of delegation as a more useful mechanism even for "inheritance based languages". <p> For this introduction, we construct an example based on <ref> [15] </ref> which generalizes the notion of object in object oriented programming to accept natural numbers as messages (an infinite number of messages). <p> These methods may be defined in a mutually recursive manner, using self to refer to other methods and, in a delta, super (Section 2.2) to refer to methods of the parent. We begin with the compositional model of inheritance, as given by Cook <ref> [15] </ref>. Changes are then introduced which incrementally work toward achieving delegation and inheritance in a general setting. The concepts of delegation and inheritance are widely used in the object-oriented community [60], since they enable reuse of existing code without modifying it. <p> The presentation of the chapter begins with the semantic constructions of inheritance as given by Cook <ref> [15] </ref> and discusses the changes necessary to extend the language to facilitate delegation, templates, and the mix of both delegation and templates, as shown below. <p> point by using both updating and templates) H H Hj C 2 , Adds delegation (movable point, using updating) C 3 , Adds templates (movable point, using template) C 1 , Inheritance with simple classes (point and circle example) The presentation uses simple examples, based on examples given by Cook <ref> [15] </ref>, which demonstrate the use of delegation and templates for creating other objects like self. <p> The definitions for inheritance used in this section are from Cook <ref> [15] </ref>. 2.2.1 Basic definitions Definition 2.2.1 A record is a finite mapping from a set of labels into a set of values. <p> A point at (3, 4) is specified by the class in Example 2.3. The self reference in the class definition is captured by the abstracted self variable (second equation of the translation function and as formalized in [9] and <ref> [15] </ref>): 23 class Circle subclass of Point meth radius = 5 meth distFromOrig = max ((super.distFromOrig self.radius),0) Example 3: Class Circle modifies distFromOrig Point self. 2 6 6 6 6 6 4 y 7! 4; distF romOrig 7! sqrt (self:x 2 + self:y 2 ); closerT oOrig 7! p:(self:distF romOrig &lt; <p> We then explain how the desired semantics can be achieved, in a simple manner. The need for an additional level of recursion when an object definition itself is recursive is illustrated by Cook <ref> [15, page 26] </ref>. Consider a class of points with a movex method, that defines MovablePoint (the examples of MovablePoint and MovableCircle are borrowed from [15], but simplified and adopted to our context). 32 The movex method creates a point just like itself, but with a different x value. <p> The need for an additional level of recursion when an object definition itself is recursive is illustrated by Cook [15, page 26]. Consider a class of points with a movex method, that defines MovablePoint (the examples of MovablePoint and MovableCircle are borrowed from <ref> [15] </ref>, but simplified and adopted to our context). 32 The movex method creates a point just like itself, but with a different x value. <p> The inherited movex method in MovableCircle will return a MovablePoint, which is not a modified self, as this results in loss of information (radius in this case). The recursion of the MovablePoint is opened up further by explicitly defining template as a generator <ref> [15] </ref>. Assuming that we have such a translation function properly defined, we get: MovablePoint make-self.a.b.self.super. 2 6 6 6 4 y 7! b; movex 7! p:Y (make-self (p:x; self:y)) 3 7 7 7 using which one could define (Y ((Y MovablePoint)(2,3)) ) as the desired movable point. <p> The above constructions are a simplified version of <ref> [15] </ref>. These simple mechanisms are sufficient to describe delegation. These are also sufficient to describe inheritance of non-recursive objects. However, the delegation semantics is more appropriate to model object-oriented languages since incremental changes to self can be specified in a natural manner. <p> This development is a generalized semantics of inheritance, delegation and recursive templates. 2.8 Related work The notion of objects being fixed points of mutually recursive functions over self was explained by Cardelli [9]. The notion of inheritance was made clear by Reddy [51] and Cook <ref> [15] </ref> who showed that inheritance required the redefinition of self, and also explained the meaning of super to refer to a parent's method. Mitchell [47], however, could not use these mechanisms to explain the updating of instance variables. <p> Section 3.7 discusses the issue of extending a type hierarchy without modifying its code. Section 3.8 uses this flexible message passing mechanism to let the user harness subtype information. 3.2 A small language In the familiar semantics of inheritance <ref> [15] </ref> [51], an object is literally "fixed" during its creation by taking the fixed-point of its generator (Section 2.3). <p> The language is flexibly defined so that certain techniques can be discussed that cannot be modeled by some of the accepted semantics <ref> [15, 51] </ref> that attempted to describe [26] and are usually not permitted [43, 58]. However, the language does not provide the templates facility (classes as first class objects) that was discussed in Section 2.7. The denotational semantics is expressed using -calculus as in Chapter 2. <p> Also we do not provide for the ability to recursively specify a class, in order to keep the semantics simple. All objects in this system have the same form, including those that are formed using delegation. In Cook's mechanism <ref> [15] </ref>, the form of an object is not the same as that of an object modifier (wrapper) and this results in (b ; c) having a different form than b, but the same form as c. <p> Although many of these languages are used for programming in the large, the kernel of these languages is generally small [32, 50, 11, 7]. The semantic mechanisms of these languages have been studied mostly in a denotational setting <ref> [15, 18, 33, 32, 7, 51] </ref>. Although this research has produced interesting constructions for the denotational semantics community, among the community of programmers the mechanisms are still understood using informal terms. <p> The instance variable declarations also insist that an initial value be specified (IEXP). The initialization of instance variables simplifies the definition of "new", as the only way an instance of a class can be created is by using "new ID". Thus we can work around the argument type translation <ref> [15] </ref> needed otherwise, during inheritance (Section 5.5). For simplicity, we keep the initialization expression (IEXP) trivial. A method definition consists of a method name, formal arguments and a method body (COMM). <p> The mechanisms we have provided are a generalization of all these facilities which includes those of inheritance as in SmallTalk [26] (given by [51] and <ref> [15] </ref>). We have concluded that in the presence of delegation and templates, every object needs to be paired with its template. We have used [15] semantics of inheritance to discuss what the semantics of delegation should be. <p> The mechanisms we have provided are a generalization of all these facilities which includes those of inheritance as in SmallTalk [26] (given by [51] and <ref> [15] </ref>). We have concluded that in the presence of delegation and templates, every object needs to be paired with its template. We have used [15] semantics of inheritance to discuss what the semantics of delegation should be. The resulting mechanisms use a more familiar interpretation of message passing than that developed in [15], and we have also shown the inadequacy of the constructions of [15] to accommodate both delegation and recursive templates found in object-oriented <p> We have used <ref> [15] </ref> semantics of inheritance to discuss what the semantics of delegation should be. The resulting mechanisms use a more familiar interpretation of message passing than that developed in [15], and we have also shown the inadequacy of the constructions of [15] to accommodate both delegation and recursive templates found in object-oriented programming languages. <p> We have used <ref> [15] </ref> semantics of inheritance to discuss what the semantics of delegation should be. The resulting mechanisms use a more familiar interpretation of message passing than that developed in [15], and we have also shown the inadequacy of the constructions of [15] to accommodate both delegation and recursive templates found in object-oriented programming languages. We then considered a class based language that provides for delegation in a limited manner (SOOL | Section 3.2) to only allow for updating of self. <p> [09]fl ! CHAR+ equations [1] nat-con ("0" y ) = nat-con (y ) [3] Nat + 0 = Nat 152 [7] 1 + 4 = 5 [8] 1 + 5 = 6 [9] 1 + 6 = 7 [13] 2 + 1 = 3 [14] 2 + 2 = 4 <ref> [15] </ref> 2 + 3 = 5 [19] 2 + 7 = 9 [20] 2 + 8 = 10 [21] 2 + 9 = 11 [25] 3 + 4 = 7 [26] 3 + 5 = 8 [27] 3 + 6 = 9 [31] 4 + 1 = 5 [32] 4 +
Reference: [16] <author> W. Cook. </author> <title> A proposal for making eiffel type-safe. </title> <booktitle> In Proceedings of Conference on European Conference on Object-Oriented Programming, </booktitle> <pages> pages 57-73, </pages> <year> 1989. </year>
Reference-contexts: The result being that even though the programs are statically type checked as correct, say by Eiffel [43], they can fail at runtime when subtype means substitutability in all contexts. Cook remarks, in his proposal to make Eiffel type-safe <ref> [16] </ref>, that the "contravariance rule has the unfortunate effect of making argument type redefinition almost useless, since it is usually not very useful to allow a redefined method to accept a larger class of arguments". <p> Practical limitations of such a subtype definition were discussed in Section 1.3 and are illustrated by Eiffel's [43] decision to allow the flexibility of defining inherited types as subtypes, at the risk of complicating the language [44] in order to avoid the resulting type insecurities <ref> [16] </ref>. In this chapter, we present a flexible message passing mechanism that allows an accommodation of covariance of method argument types (Section 1.3), when desired. This facility will also illustrate when covariance might be desired, and its peculiarities. <p> This language has thus become the infamous example for many theoreticians working on developing type-safe object-oriented languages [7, 11], ever since Cook illustrated <ref> [16] </ref> these type-checking holes and made a proposal of removing the "extra flexibility" that Eiffel provides in favor of the safety of type-checking. The Eiffel designers, however, have not forsaken this flexibility as they believe that this flexibility provides for the most natural evolution of software systems. <p> We advocate them as "desirable" by considering system evolution, efficiency and upwards compatibility of the existing Eiffel programs. The introduction of the first proposal, from William Cook <ref> [16] </ref>, notes that 1 : Statically type-correct Eiffel programs may produce run-time errors because (1) attributes may be redeclared during inheritance, invalidating assignments in the superclass, (2) a formal method argument type may be restricted in violation of the contravariance of function types, and (3) two applications of a generic class <p> Here, we propose another interpretation for Eiffel programs and a compile time translation that would enable Eiffel programs to become type-safe and give a flexible interpretation to 1 Text from Cook's paper <ref> [16] </ref> is indented. 70 many problem cases, while maintaining substitutability once type-checked. Our goal is to give an interpretation that is upwards compatible with the dynamic semantics of Eiffel, i.e., we suggest an alternate behavior only where the current Eiffel semantics would lead to a runtime error. <p> Thus, zpoint would not be a subtype of point and since this is a natural manner in which classes seem to evolve <ref> [43, 16, 17] </ref> subtype hierarchy should in general be separate from inheritance hierarchy (For example, as in our case here). Chapters 3, 4 and 6 discuss other techniques to help enforce these hierarchies to correspond. <p> uses the selftype information. 135 6.2 Dynamic semantics with adoption A program evaluated without proper compensation for relaxing contravariance for "selftype" arguments, will evaluate with the possibility of not understanding some messages (in-spite of it being type-checked) and is therefore comparable to the earlier implementations of Eiffel, as discussed in <ref> [16] </ref>. Using type information for providing alternate behavior has also been popularized, in the name of multi-methods [36, 25], but the resulting semantics of such process is complementary to what can be achieved through adoption. Also the process of adoption need not add the over-head of type-checking during run-time. <p> This discussion, in turn, gives some insight to when covariance would be appropriate. Finally, a technique to modify an entire hierarchy without modifying the existing code is discussed. In Chapter 4 we consider the examples provided by Cook <ref> [16] </ref> to show the type holes in Eiffel, and suggest an alternate way of resolving these problems using the general framework of Chapter 3. Cook's proposal to make Eiffel type-safe has been basically to eliminate the flexibility of Eiffel for most part. <p> A program evaluated at the EOOL-eval level will evaluate (with the possibility of not understanding some messages, in-spite of it being type-checked) 191 without the adoption semantics and is therefore comparable to the earlier implementations of Eiffel, as discussed in <ref> [16] </ref>. The adoption semantics is presented in Section C.2.3. C.2.1 The essential syntax This section introduces a language syntax that is similar to that in Section C.1.1 and Section 5.3.
Reference: [17] <author> W. Cook, W. Hill, and P. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Proceedings of 19th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <year> 1990. </year>
Reference-contexts: Cardelli [9] used it to mean subtypes (substitutability in all contexts), while Bruce [7] uses it to identify a little more relaxed relation that need not be just subtypes, but inherited types <ref> [17] </ref>. <p> In this thesis, we consider only subtype conformance that can be realized using type signatures. In general, inheritance (subclass) does not imply a subtype relation, as demonstrated by <ref> [54, 17] </ref>, since inheritance does not require a contravariance rule. The message passing paradigm facilitates a simple algorithm for selecting the target method dynamically. Selection of the method to be invoked is not affected by all the arguments of the method, but by only one (the target object). <p> Chapter 4 adopts the general idea of Chapter 3 to the restricted context of the language Eiffel. A more restricted language that only identifies "inherited types" <ref> [17, 7] </ref> as subtypes is considered in detail in Chapter 6. Chapter 5 gives an algebraic specification of a subset of the mechanisms developed in Chapter 2 using ASF+SDF. <p> The MovablePoint and MovableCircle examples are revisited to observe the effect of delegation and "new self class ( )" (or make-self) on the templates. 40 Another argument, map, is needed to properly initialize the parameters <ref> [17] </ref>. <p> Bruce [6], Kamin and Reddy [34] have shown that these two different views of the object are equivalent. Mitchell's model is extended here by providing for super and also providing for the notion of templates. The notion of templates (or classes) adds an additional level of recursion <ref> [17] </ref> in Cook's semantics but extending classes in an analogous manner of extending objects is not possible. <p> The mechanisms presented in this chapter provide for SmallTalk like facilities, as desired by Cook, with updating of instance variables as desired by Mitchell. 44 2.8.1 Cook's and Mitchell's semantics The semantic mechanisms for Inheritance, of Cook, as in <ref> [17] </ref> and those for delegation, of Mitchell, as in [47] are two special cases of the mechanisms given in the previous section. We have generalized Mitchell's semantics, in Section 2.6, by providing for the notion of super and in the previous section by providing for templates. <p> can use the arguments for equivalence as given by [34], who compares Reddy's mechanisms [51] (which uses fixed point operators) and Kamin's [33] mechanisms which in turn are those used by Cook and Mitchell, respectively. 8 By saying "Cook's semantics", we are referring to the section on class inheritance of <ref> [17] </ref> | which also involves the modification of recursive templates. 45 SmallTalk and SELF have many capabilities that cannot be modeled by the mechanisms provided by Cook. <p> A controlled use of delegation provides the needed expressivity and flexibility, while maintaining the desirable properties of inheritance found in class based languages. One the results of using delegation in an inheritance based language is to accommodate some of the useful "inherited types" <ref> [17] </ref> as subtypes (Chapter 6). Subtype definition is usually restricted to the contravariance of method argument types [9] as explained in Chapter 1. <p> Also, note that this form of delegation is only possible since our delegation operator is associative. We can identify the class of "inherited types" <ref> [17] </ref>, as subtypes that fall into this category where the message can be interpreted by the receiver if the message is not understood by the argument (if the user so desires). <p> These languages do not have side-effects, with the interpretation discussed in section 5.7 and can therefore be classified as functional object oriented programming languages. The language EOOL presented in Chapter 6 is an Eiffel [43] like language, but forces inherited types <ref> [17] </ref> to behave like subtypes using the ideas described in Chapter 4. 5.2 ASF+SDF ASF, an acronym for Algebraic Specification Formalism, [4, 30] is a formalism supporting modularization and conditional equations. The ASF system, is able to generate rewriting systems from the specification, and to execute them. <p> ) . z Example 16: Providing for type declarations As a result the program will not type check, according to the rules discussed in Section 5.4.3, since the result of movex is a point which does not understand z. 5.6.2 Using "selftype" A well understood problem in object oriented programming <ref> [43, 17, 47, 49] </ref>, is that inheritance of code will, in general, require certain type declarations concerning the type of self be specialized accordingly. <p> The commonly used 122 technique is to provide a type declaration facility that can be used to specialize the type information - Eiffel [43] provides for declaration by association (Chapter 4), Palsberg and Schwartzbach [49] discuss the safety of specializing all type declarations accordingly, and Cook et. al. <ref> [17] </ref> have discussed the notion of F-bounded types that arise in the presence of inheritance. In effect all of them discuss the techniques for specializing subclass type declarations which here can be abstracted by the notion of "selftype". <p> Thus, zpoint would not be a subtype of point and since this is a natural manner in which classes seem to evolve <ref> [43, 16, 17] </ref> subtype hierarchy should in general be separate from inheritance hierarchy (For example, as in our case here). Chapters 3, 4 and 6 discuss other techniques to help enforce these hierarchies to correspond. <p> The use of "selftype" in this manner results in the so-called inherited types <ref> [17] </ref> when the class gets inherited. The conformance relation, similar to that of Eiffel, is realized in module EOOL-sub (Appendix C.1.4). <p> It is well understood that inheritance does not lead to subtypes, but to the so called inherited types <ref> [17] </ref>. We finish with a case of study analysis of this view. Since the language Eiffel provided for the use of inherited types as subtypes [43], we consider a language (EOOL) similar to Eiffel in that subclasses are subtypes. <p> The use of "selftype" in this manner results in the so called inherited types <ref> [17] </ref> when the class gets inherited.
Reference: [18] <author> W. Cook and J. Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In Proceedings of Conference on Object Oriented Programming, Systems and Languages, </booktitle> <pages> pages 433-443, </pages> <year> 1989. </year>
Reference-contexts: Although many of these languages are used for programming in the large, the kernel of these languages is generally small [32, 50, 11, 7]. The semantic mechanisms of these languages have been studied mostly in a denotational setting <ref> [15, 18, 33, 32, 7, 51] </ref>. Although this research has produced interesting constructions for the denotational semantics community, among the community of programmers the mechanisms are still understood using informal terms.
Reference: [19] <author> B. J. Cox. </author> <title> Object Oriented Programming. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: ("0" y ) = nat-con (y ) [3] Nat + 0 = Nat 152 [7] 1 + 4 = 5 [8] 1 + 5 = 6 [9] 1 + 6 = 7 [13] 2 + 1 = 3 [14] 2 + 2 = 4 [15] 2 + 3 = 5 <ref> [19] </ref> 2 + 7 = 9 [20] 2 + 8 = 10 [21] 2 + 9 = 11 [25] 3 + 4 = 7 [26] 3 + 5 = 8 [27] 3 + 6 = 9 [31] 4 + 1 = 5 [32] 4 + 2 = 6 [33] 4 +
Reference: [20] <author> O.-J. Dahl and K. Nygaard. </author> <title> Simula an algol-based simulation language. </title> <journal> Commun. ACM, </journal> <volume> 9(9) </volume> <pages> 671-678, </pages> <year> 1966. </year>
Reference-contexts: ) [3] Nat + 0 = Nat 152 [7] 1 + 4 = 5 [8] 1 + 5 = 6 [9] 1 + 6 = 7 [13] 2 + 1 = 3 [14] 2 + 2 = 4 [15] 2 + 3 = 5 [19] 2 + 7 = 9 <ref> [20] </ref> 2 + 8 = 10 [21] 2 + 9 = 11 [25] 3 + 4 = 7 [26] 3 + 5 = 8 [27] 3 + 6 = 9 [31] 4 + 1 = 5 [32] 4 + 2 = 6 [33] 4 + 3 = 7 [37] 4 +
Reference: [21] <author> S. Danforth and C. Tomlinson. </author> <title> Type theories and object-oriented programming. </title> <journal> ACM Computing Surveys, </journal> <volume> 20(1) </volume> <pages> 29-72, </pages> <year> 1988. </year>
Reference-contexts: Nat 152 [7] 1 + 4 = 5 [8] 1 + 5 = 6 [9] 1 + 6 = 7 [13] 2 + 1 = 3 [14] 2 + 2 = 4 [15] 2 + 3 = 5 [19] 2 + 7 = 9 [20] 2 + 8 = 10 <ref> [21] </ref> 2 + 9 = 11 [25] 3 + 4 = 7 [26] 3 + 5 = 8 [27] 3 + 6 = 9 [31] 4 + 1 = 5 [32] 4 + 2 = 6 [33] 4 + 3 = 7 [37] 4 + 7 = 11 [38] 4 +
Reference: [22] <author> A. v. </author> <title> Deursen. An algebraic specification for the static semantics of Pascal. </title> <editor> In J. v. Leeuwen, editor, </editor> <booktitle> Conference Proceedings of Computing Science in the Netherlands, CSN'91, </booktitle> <pages> pages 150-164. </pages> <address> SION, </address> <year> 1991. </year>
Reference-contexts: A typical layout definition is: exports lexical syntax [ "t"n] -&gt; LAYOUT "%%" ~["n]* ""n" -&gt; LAYOUT A space, tab, or new line is a layout symbol, as well as everything between 1 This section is included for completeness and is borrowed with permission of van Duersen <ref> [22] </ref> 88 two consecutive percent signs and a new line. If tokens of sort LAYOUT are detected in a text, they are ignored. Secondly, variable declarations are treated as declarations of lexical syntax.
Reference: [23] <author> A. C. Fleck. </author> <title> A proposal for the comparison of types in pascal and associated semantic models. </title> <journal> Computer Languages, </journal> <volume> 9(2) </volume> <pages> 71-87, </pages> <year> 1984. </year>
Reference-contexts: The basic strategy for the algorithm is to assume the intended subtype relationship and proceed by checking the associated type environments. This is similar to the idea used for checking the structural similarity of Pascal records by Fleck <ref> [23] </ref>. A list of assumed subtypes is maintained as necessary (SUBTYPES*). Note that the list comprises of only ID &lt; ID assumptions, since we are interested in a lattice of types that results from the class definitions, like in [39].
Reference: [24] <author> G. Ghelli. </author> <title> Private Communication. Electronic mail, </title> <year> 1991. </year>
Reference-contexts: The following classes describe the specification of Booleans and Naturals in this language. The class bool and nat are slightly modified versions of Ghelli's <ref> [24] </ref>.
Reference: [25] <author> G. Ghelli. </author> <title> A static type system for message passing. </title> <booktitle> In Proceedings of Conference on Object Oriented Programming, Systems and Languages, </booktitle> <pages> pages 129-145, </pages> <month> November </month> <year> 1991. </year> <note> Also in SIGPLAN notices, 26(11). </note>
Reference-contexts: This selection rule together with dynamic binding, we claim, has led to incomplete operational semantics in languages like Eiffel. Thus a proper (in the sense of completeness) interpretation of message passing is necessary for proper static type checking. Several alternatives have been considered <ref> [58, 36, 25] </ref>. The adoption mechanism suggested in this thesis provides for an orthogonal approach that accommodates for some desirable cases that cannot be handled by other techniques. Type denotes a collection of objects that share the same externally 9 observable behavior. <p> Loosing the monotonicity of the type correctness of a class is not only very confusing to the system developers, but also prevents evolution of the system as advocated. It has been noted by others <ref> [36, 25] </ref> that the most desirable solution to this issue is to reinterpret the semantics of message passing, which allows the user to indicate the method to be executed for the potentially problematic cases. <p> Using type information for providing alternate behavior has also been popularized, in the name of multi-methods <ref> [36, 25] </ref>, but the resulting semantics of such process is complementary to what can be achieved through adoption. Also the process of adoption need not add the over-head of type-checking during run-time. <p> = 5 [8] 1 + 5 = 6 [9] 1 + 6 = 7 [13] 2 + 1 = 3 [14] 2 + 2 = 4 [15] 2 + 3 = 5 [19] 2 + 7 = 9 [20] 2 + 8 = 10 [21] 2 + 9 = 11 <ref> [25] </ref> 3 + 4 = 7 [26] 3 + 5 = 8 [27] 3 + 6 = 9 [31] 4 + 1 = 5 [32] 4 + 2 = 6 [33] 4 + 3 = 7 [37] 4 + 7 = 11 [38] 4 + 8 = 12 [39] 4 + <p> The introduction of the syntax again is to indicate the potential clarity of separation between the type-checking aspects and the evaluation aspects involved in the process of adoption. Using type information for providing alternate behavior has also been popularized, in the name of multi-methods <ref> [36, 25] </ref>, but the resulting semantics of such a process is complementary to what can be achieved through adoption. Also the process of adoption does not add the overhead of type-checking during run-time.
Reference: [26] <author> A. Goldberg and D. Robson. </author> <title> SmallTalk 80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1983. </year>
Reference-contexts: introduction of the language Simula, it was not until the development of the language SmallTalk <ref> [26] </ref> that object oriented programming itself was popularized. SmallTalk is the first language that is developed in a purely object oriented manner, although the notion of classes and inheritance slightly differed from that of Simula. <p> The notion of inheritance is similar to delegation except that inheritance is used in the context of extending classes, which define templates for object instantiation <ref> [26] </ref>. This interpretation of inheritance gives it a static structure, where as delegation carries with it an ability to specify incremental changes to existing objects at runtime, an effect better understood by thinking of delegation as a mechanism to use classes as objects with an ability to "inherit" dynamically. <p> Now this is provided by a metaclass whose recursive structure can be explained by using a metametaclass ... ad infinitum as done in <ref> [26] </ref>. In a language that supports delegation, the need for making a new object like self, is much less than the need for the ability to return itself or an ability to use self as a delegator or a delegatee. <p> This notion corresponds with languages claiming inheritance as their fundamental mechanism [58, 43, 53] and those that claim delegation as their fundamental mechanism [41, 59]. Languages like SmallTalk <ref> [26] </ref> have provision for both inheritance and delegation in this sense, as noted by [55]. <p> Our mechanisms are general enough to model these, with slight variations of 1 and by forgetting the effect of aliasing of variable names ("side-effect" aspects) since we are modeling in a functional programming context. 46 CHAPTER 3 FLEXIBLE SUBTYPING AND INHERITANCE 3.1 Introduction The inheritance mechanisms of SmallTalk <ref> [26] </ref> and its derivatives can be considered as rigid since class specification can only be extended in one direction. <p> The language is flexibly defined so that certain techniques can be discussed that cannot be modeled by some of the accepted semantics [15, 51] that attempted to describe <ref> [26] </ref> and are usually not permitted [43, 58]. However, the language does not provide the templates facility (classes as first class objects) that was discussed in Section 2.7. The denotational semantics is expressed using -calculus as in Chapter 2. <p> With these additions to the syntax, we hope be able to write 128 programs that resemble those of conventional object-oriented languages that use assignments and statements <ref> [43, 26] </ref>. <p> Templates and some form of inheritance are distinct features an object-oriented language must provide, as emphasized by [56] by comparing their individual works (DELEGATION [41], SELF [59] and [55]). The mechanisms we have provided are a generalization of all these facilities which includes those of inheritance as in SmallTalk <ref> [26] </ref> (given by [51] and [15]). We have concluded that in the presence of delegation and templates, every object needs to be paired with its template. We have used [15] semantics of inheritance to discuss what the semantics of delegation should be. <p> = 6 [9] 1 + 6 = 7 [13] 2 + 1 = 3 [14] 2 + 2 = 4 [15] 2 + 3 = 5 [19] 2 + 7 = 9 [20] 2 + 8 = 10 [21] 2 + 9 = 11 [25] 3 + 4 = 7 <ref> [26] </ref> 3 + 5 = 8 [27] 3 + 6 = 9 [31] 4 + 1 = 5 [32] 4 + 2 = 6 [33] 4 + 3 = 7 [37] 4 + 7 = 11 [38] 4 + 8 = 12 [39] 4 + 9 = 13 [43] 5 +
Reference: [27] <author> M. J. C. Gordon. </author> <title> The Denotational Description of Programming Languages: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> New York/Heidelberg/Berlin, </address> <year> 1979. </year>
Reference-contexts: = 3 then 3 else if n = 0 then 1 else n fl (f (n 1)); how may the user specify this function as an "incremental modification" of fact's specification? What is meant by incremental modification is that, the structure of 1 For -calculus and denotational semantics we use <ref> [57, 2, 27] </ref> 15 f and f act are the same except for the additional condition, if n = 3 then 3 else if , and the goal is to specify f by just specifying this difference. <p> = 7 [13] 2 + 1 = 3 [14] 2 + 2 = 4 [15] 2 + 3 = 5 [19] 2 + 7 = 9 [20] 2 + 8 = 10 [21] 2 + 9 = 11 [25] 3 + 4 = 7 [26] 3 + 5 = 8 <ref> [27] </ref> 3 + 6 = 9 [31] 4 + 1 = 5 [32] 4 + 2 = 6 [33] 4 + 3 = 7 [37] 4 + 7 = 11 [38] 4 + 8 = 12 [39] 4 + 9 = 13 [43] 5 + 4 = 9 [44] 5 +
Reference: [28] <author> J. Heering, P. Hendriks, P. Klint, and J. Rekers. </author> <title> The syntax definition formalism SDF reference manual. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(11) </volume> <pages> 43-75, </pages> <year> 1989. </year> <month> 204 </month>
Reference-contexts: The ASF system, is able to generate rewriting systems from the specification, and to execute them. SDF, Syntax Definition Formalism, has been developed <ref> [28] </ref> to support the definition of lexical, context-free and abstract syntax at the same time, and parsers can be incrementally generated from it. These two formalisms have been combined into one algebraic specification 87 formalism called ASF+SDF 1 . <p> The ASF part takes care of the (conditional) equations, while the SDF part provides complete syntactic freedom for the specifier. A sentence according to an SDF grammar is mapped uniquely on an abstract syntax tree <ref> [28] </ref>, and constitutes a term over the signature. Equations over these terms may have positive or negative conditions [4, p.306] giving rise to the quasi-initial models introduced by Kaplan [35]. For a complete description of the ASF+SDF formalism see [4, 31].
Reference: [29] <author> J. Heering and P. Klint. </author> <title> PICO revisited. </title> <editor> In J. Bergstra, J. Heering, and P. Klint, editors, </editor> <title> Algebraic Specification, </title> <publisher> ACM Press Frontier Series, </publisher> <pages> pages 359-379. </pages> <note> The ACM Press in co-operation with Addison-Wesley, 1989. Chapter 9. </note>
Reference-contexts: The specification of value environment is similar to traditional value environments specification <ref> [3, 29] </ref>. The utility of the value environment is different, however, since in an object oriented language, the only interesting environment during program execution is the one associated with self.
Reference: [30] <author> P. Hendriks. </author> <title> ASF system user's guide. </title> <type> Report CS-R8823, </type> <institution> Centrum voor Wiskunde en Informatica (CWI), </institution> <address> Amsterdam, </address> <year> 1988. </year> <title> Extended abstract in: </title> <booktitle> Conference Proceedings of Computing Science in the Netherlands, </booktitle> <volume> CSN'88 1, </volume> <pages> pp. 83-94, </pages> <month> SION </month> <year> (1988). </year>
Reference-contexts: The language EOOL presented in Chapter 6 is an Eiffel [43] like language, but forces inherited types [17] to behave like subtypes using the ideas described in Chapter 4. 5.2 ASF+SDF ASF, an acronym for Algebraic Specification Formalism, <ref> [4, 30] </ref> is a formalism supporting modularization and conditional equations. The ASF system, is able to generate rewriting systems from the specification, and to execute them.
Reference: [31] <author> P. Hendriks. </author> <title> Implementation of Modular Algebraic Specifications. </title> <type> PhD thesis, </type> <institution> University of Amsterdam, </institution> <year> 1991. </year>
Reference-contexts: Equations over these terms may have positive or negative conditions [4, p.306] giving rise to the quasi-initial models introduced by Kaplan [35]. For a complete description of the ASF+SDF formalism see <ref> [4, 31] </ref>. Specifying in the ASF+SDF formalism is supported by the ASF+SDF system [37] [31, Chapter 5]. This system is able to generate parsers from ASF+SDF specifications and to derive term rewriting systems for specifications in ASF+SDF, thus allowing to execute ASF+SDF specifications. <p> Equations over these terms may have positive or negative conditions [4, p.306] giving rise to the quasi-initial models introduced by Kaplan [35]. For a complete description of the ASF+SDF formalism see [4, 31]. Specifying in the ASF+SDF formalism is supported by the ASF+SDF system [37] <ref> [31, Chapter 5] </ref>. This system is able to generate parsers from ASF+SDF specifications and to derive term rewriting systems for specifications in ASF+SDF, thus allowing to execute ASF+SDF specifications. Moreover, it can generate syntax-directed editors for modules in the specification as well as for terms over the signature. <p> = 3 [14] 2 + 2 = 4 [15] 2 + 3 = 5 [19] 2 + 7 = 9 [20] 2 + 8 = 10 [21] 2 + 9 = 11 [25] 3 + 4 = 7 [26] 3 + 5 = 8 [27] 3 + 6 = 9 <ref> [31] </ref> 4 + 1 = 5 [32] 4 + 2 = 6 [33] 4 + 3 = 7 [37] 4 + 7 = 11 [38] 4 + 8 = 12 [39] 4 + 9 = 13 [43] 5 + 4 = 9 [44] 5 + 5 = 10 [45] 5 +
Reference: [32] <author> A. V. Hense. </author> <title> Denotational semantics of an object oriented language with explicit wrappers. </title> <type> Technical Report A 11/90, </type> <institution> Universitat des Saarlandes, </institution> <year> 1990. </year>
Reference-contexts: There are many Object-Oriented Programming Languages (OOPL) that have surfaced in the recent years [20, 26, 53, 59, 36, 58, 43, 5, 19, 38, 12, 61, 48]. Although many of these languages are used for programming in the large, the kernel of these languages is generally small <ref> [32, 50, 11, 7] </ref>. The semantic mechanisms of these languages have been studied mostly in a denotational setting [15, 18, 33, 32, 7, 51]. Although this research has produced interesting constructions for the denotational semantics community, among the community of programmers the mechanisms are still understood using informal terms. <p> Although many of these languages are used for programming in the large, the kernel of these languages is generally small [32, 50, 11, 7]. The semantic mechanisms of these languages have been studied mostly in a denotational setting <ref> [15, 18, 33, 32, 7, 51] </ref>. Although this research has produced interesting constructions for the denotational semantics community, among the community of programmers the mechanisms are still understood using informal terms. <p> = 4 [15] 2 + 3 = 5 [19] 2 + 7 = 9 [20] 2 + 8 = 10 [21] 2 + 9 = 11 [25] 3 + 4 = 7 [26] 3 + 5 = 8 [27] 3 + 6 = 9 [31] 4 + 1 = 5 <ref> [32] </ref> 4 + 2 = 6 [33] 4 + 3 = 7 [37] 4 + 7 = 11 [38] 4 + 8 = 12 [39] 4 + 9 = 13 [43] 5 + 4 = 9 [44] 5 + 5 = 10 [45] 5 + 6 = 11 [49] 6 +
Reference: [33] <author> S. Kamin. </author> <title> Inheritance in smalltalk-80: A denotational definition. </title> <booktitle> In Proceedings of 15th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 80-87, </pages> <year> 1988. </year>
Reference-contexts: Before considering the effects of mixing these two in detail (in the next section), we formulate the idea of passing self as first argument here. This idea has been used by the people who have implemented object-oriented languages [52, 12] as noted in <ref> [47, 33] </ref>. Although the constructions using the explicit fixpoint operator seemed elegant for the case of inheritance, as we have noted above, it looses its elegancy for delegation. A simpler translation can be obtained for delegation that encompasses the expressivity of the constructions of inheritance. <p> The subclass of construct is a special case of the 1 operator. With this reduction, we can use the arguments for equivalence as given by [34], who compares Reddy's mechanisms [51] (which uses fixed point operators) and Kamin's <ref> [33] </ref> mechanisms which in turn are those used by Cook and Mitchell, respectively. 8 By saying "Cook's semantics", we are referring to the section on class inheritance of [17] | which also involves the modification of recursive templates. 45 SmallTalk and SELF have many capabilities that cannot be modeled by the <p> Although many of these languages are used for programming in the large, the kernel of these languages is generally small [32, 50, 11, 7]. The semantic mechanisms of these languages have been studied mostly in a denotational setting <ref> [15, 18, 33, 32, 7, 51] </ref>. Although this research has produced interesting constructions for the denotational semantics community, among the community of programmers the mechanisms are still understood using informal terms. <p> With the above rules, the other method will at most have the argument type to be point: meth other:natural (pt:point) pt.test0 ().x 144 CHAPTER 7 CONCLUSIONS 7.1 Summary Among the implementors of object-oriented languages, it is known <ref> [52, 33, 47] </ref> that the receiver of the message can be used as the first argument of an object's methods to access its other methods. We have used this idea to develop the semantics of delegation with recursive templates. Delegation without templates is provided for in [47]. <p> = 5 [19] 2 + 7 = 9 [20] 2 + 8 = 10 [21] 2 + 9 = 11 [25] 3 + 4 = 7 [26] 3 + 5 = 8 [27] 3 + 6 = 9 [31] 4 + 1 = 5 [32] 4 + 2 = 6 <ref> [33] </ref> 4 + 3 = 7 [37] 4 + 7 = 11 [38] 4 + 8 = 12 [39] 4 + 9 = 13 [43] 5 + 4 = 9 [44] 5 + 5 = 10 [45] 5 + 6 = 11 [49] 6 + 1 = 7 [50] 6 +
Reference: [34] <author> S. Kamin and U. Reddy. </author> <title> Equivalence of abstract and implementation semantics of inheritance. </title> <note> In Submitted for Publication. </note> <year> 1992. </year>
Reference-contexts: Equivalence of these two different ways of viewing an object (effects t and t i ) is discussed by Kamin and Reddy <ref> [34] </ref>. With this prelude to help understand object, class, inheritance and delegation in a general setting, we proceed to describe what objects are in object oriented programming. Unlike f act, objects typically understand a finite number of messages and for each message a function, better known as "method", is defined. <p> Instead he preferred the implementation oriented view of using the message passing 43 mechanism to send the receiver of a message as the first argument of the method, thereby obtaining the desired recursion. Bruce [6], Kamin and Reddy <ref> [34] </ref> have shown that these two different views of the object are equivalent. Mitchell's model is extended here by providing for super and also providing for the notion of templates. <p> Thus, the only means of modifying a template is by using the subclass of construct. The subclass of construct is a special case of the 1 operator. With this reduction, we can use the arguments for equivalence as given by <ref> [34] </ref>, who compares Reddy's mechanisms [51] (which uses fixed point operators) and Kamin's [33] mechanisms which in turn are those used by Cook and Mitchell, respectively. 8 By saying "Cook's semantics", we are referring to the section on class inheritance of [17] | which also involves the modification of recursive templates.
Reference: [35] <author> S. Kaplan. </author> <title> Positive/negative conditional rewriting. </title> <editor> In S. Kaplan and J.-P. Jouannaud, editors, </editor> <booktitle> Proceedings of the First International Workshop on Conditional Term Rewriting Systems, volume 308 of Lecture Notes in Computer Science, </booktitle> <pages> pages 129-143. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: A sentence according to an SDF grammar is mapped uniquely on an abstract syntax tree [28], and constitutes a term over the signature. Equations over these terms may have positive or negative conditions [4, p.306] giving rise to the quasi-initial models introduced by Kaplan <ref> [35] </ref>. For a complete description of the ASF+SDF formalism see [4, 31]. Specifying in the ASF+SDF formalism is supported by the ASF+SDF system [37] [31, Chapter 5].
Reference: [36] <author> S. E. Keene. </author> <title> Object-oriented programming in Common Lisp : a programmer's guide to CLOS. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1989. </year>
Reference-contexts: This selection rule together with dynamic binding, we claim, has led to incomplete operational semantics in languages like Eiffel. Thus a proper (in the sense of completeness) interpretation of message passing is necessary for proper static type checking. Several alternatives have been considered <ref> [58, 36, 25] </ref>. The adoption mechanism suggested in this thesis provides for an orthogonal approach that accommodates for some desirable cases that cannot be handled by other techniques. Type denotes a collection of objects that share the same externally 9 observable behavior. <p> The language Eiffel [43] requires covariance, while Trellis [53] and several others, require contravariance. It is well understood that contravariance is safe, while covariance is desirable in practice for certain tasks. Languages like CLOS <ref> [36] </ref> provide a compromise by multiple method dispatching wherein methods 57 class line: Line var p := new point var q := new point methsamelen (aline) ...compute Manhattan lengths of self and aline, and compare ... <p> Loosing the monotonicity of the type correctness of a class is not only very confusing to the system developers, but also prevents evolution of the system as advocated. It has been noted by others <ref> [36, 25] </ref> that the most desirable solution to this issue is to reinterpret the semantics of message passing, which allows the user to indicate the method to be executed for the potentially problematic cases. <p> Using type information for providing alternate behavior has also been popularized, in the name of multi-methods <ref> [36, 25] </ref>, but the resulting semantics of such process is complementary to what can be achieved through adoption. Also the process of adoption need not add the over-head of type-checking during run-time. <p> The introduction of the syntax again is to indicate the potential clarity of separation between the type-checking aspects and the evaluation aspects involved in the process of adoption. Using type information for providing alternate behavior has also been popularized, in the name of multi-methods <ref> [36, 25] </ref>, but the resulting semantics of such a process is complementary to what can be achieved through adoption. Also the process of adoption does not add the overhead of type-checking during run-time.
Reference: [37] <author> P. Klint. </author> <title> Lazy scanner generation for modular regular grammars. </title> <type> Report CS-R9158, </type> <institution> Centrum voor Wiskunde en Informatica (CWI), </institution> <address> Amsterdam, </address> <year> 1991. </year>
Reference-contexts: Equations over these terms may have positive or negative conditions [4, p.306] giving rise to the quasi-initial models introduced by Kaplan [35]. For a complete description of the ASF+SDF formalism see [4, 31]. Specifying in the ASF+SDF formalism is supported by the ASF+SDF system <ref> [37] </ref> [31, Chapter 5]. This system is able to generate parsers from ASF+SDF specifications and to derive term rewriting systems for specifications in ASF+SDF, thus allowing to execute ASF+SDF specifications. Moreover, it can generate syntax-directed editors for modules in the specification as well as for terms over the signature. <p> = 9 [20] 2 + 8 = 10 [21] 2 + 9 = 11 [25] 3 + 4 = 7 [26] 3 + 5 = 8 [27] 3 + 6 = 9 [31] 4 + 1 = 5 [32] 4 + 2 = 6 [33] 4 + 3 = 7 <ref> [37] </ref> 4 + 7 = 11 [38] 4 + 8 = 12 [39] 4 + 9 = 13 [43] 5 + 4 = 9 [44] 5 + 5 = 10 [45] 5 + 6 = 11 [49] 6 + 1 = 7 [50] 6 + 2 = 8 [51] 6 +
Reference: [38] <author> B. Kristensen, O. Madsen, B. Pedersen, and K. Nygaard. </author> <title> The beta programming language. </title> <editor> In Shriver and Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 7-48. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1987. </year>
Reference-contexts: Some languages do not require the contravariance of parameters, even though they emphasize static type-checkability (Eiffel [43] and BETA <ref> [38] </ref>). <p> = 10 [21] 2 + 9 = 11 [25] 3 + 4 = 7 [26] 3 + 5 = 8 [27] 3 + 6 = 9 [31] 4 + 1 = 5 [32] 4 + 2 = 6 [33] 4 + 3 = 7 [37] 4 + 7 = 11 <ref> [38] </ref> 4 + 8 = 12 [39] 4 + 9 = 13 [43] 5 + 4 = 9 [44] 5 + 5 = 10 [45] 5 + 6 = 11 [49] 6 + 1 = 7 [50] 6 + 2 = 8 [51] 6 + 3 = 9 153 [55] 6
Reference: [39] <author> D. Lea. </author> <title> Technical note: Techniques for representing class sytems as type systems. Mailing list: </title> <address> objecttypes@daimi.aau.dk, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: A list of assumed subtypes is maintained as necessary (SUBTYPES*). Note that the list comprises of only ID &lt; ID assumptions, since we are interested in a lattice of types that results from the class definitions, like in <ref> [39] </ref>. The Boolean function "assumed in " checks if the SUBTYPE list already has the given assumption (Equations [A0] to [A3]). <p> = 11 [25] 3 + 4 = 7 [26] 3 + 5 = 8 [27] 3 + 6 = 9 [31] 4 + 1 = 5 [32] 4 + 2 = 6 [33] 4 + 3 = 7 [37] 4 + 7 = 11 [38] 4 + 8 = 12 <ref> [39] </ref> 4 + 9 = 13 [43] 5 + 4 = 9 [44] 5 + 5 = 10 [45] 5 + 6 = 11 [49] 6 + 1 = 7 [50] 6 + 2 = 8 [51] 6 + 3 = 9 153 [55] 6 + 7 = 13 [56] 6
Reference: [40] <author> G. Leavens and W. Weihl. </author> <title> Reasoning about object-oriented programs that use subtypes. </title> <booktitle> In Proceedings of Conference on Object Oriented Programming, Systems and Languages/European Conference on Object-Oriented Programming, </booktitle> <pages> pages 212-223, </pages> <year> 1990. </year>
Reference-contexts: Type Integer nume: ! IntBase assume IntBase eq: Integer ! Boolean prod: Integer ! Integer Type Fraction nume: ! IntBase denom: ! IntBase eq: Fraction ! Boolean prod: Fraction ! Fraction If the intention is to assert that Fraction is a subtype of Integer 4 , a default 4 Leavens <ref> [40] </ref> constructs Integer as a subtype of Fraction. However, since Integer forgets attributes of Fraction, the subtype consideration in our object-oriented 64 interpretation for the denom message should be provided for the arguments of eq and prod. This can be done by considering the default denom value to be 1.
Reference: [41] <author> H. Lieberman. </author> <title> Using prototypical objects to implement shared behavior in object oriented systems. </title> <booktitle> In Proceedings of Conference on Object Oriented Programming, Systems and Languages, </booktitle> <year> 1986. </year> <month> 205 </month>
Reference-contexts: Dynamic binding of self-reference realizes sharing and reusability by allowing the 17 resources of an ancestor to be part of the extended identity of different delegating objects at different points of execution <ref> [41] </ref>. The notion of inheritance is similar to delegation except that inheritance is used in the context of extending classes, which define templates for object instantiation [26]. <p> This notion corresponds with languages claiming inheritance as their fundamental mechanism [58, 43, 53] and those that claim delegation as their fundamental mechanism <ref> [41, 59] </ref>. Languages like SmallTalk [26] have provision for both inheritance and delegation in this sense, as noted by [55]. <p> This can be described as a form of delegation <ref> [41] </ref> [59], as indicated by Mitchell. In our generalized notion of delegation (as noted in Section 2.4), any object can delegate to any other object. Therefore, when an object is passed as an argument of a message, it can delegate to a specified object in that context. <p> To elaborate, (self*x = apt*x), compares the value returned by (self*x) with that of apt's x value (apt*x), and "&" is the Boolean "and" operation. The move method specifies a replacement object that is a modification of self by providing replacement behavior <ref> [41] </ref> for x and y methods. The replacement behavior specifies a replacement method x defined as the "old x value" + i. <p> We have used this idea to develop the semantics of delegation with recursive templates. Delegation without templates is provided for in [47]. Templates and some form of inheritance are distinct features an object-oriented language must provide, as emphasized by [56] by comparing their individual works (DELEGATION <ref> [41] </ref>, SELF [59] and [55]). The mechanisms we have provided are a generalization of all these facilities which includes those of inheritance as in SmallTalk [26] (given by [51] and [15]).
Reference: [42] <author> O. Madsen, B. Magnusson, and B. Moller-Pedersen. </author> <title> Strong typing of object-oriented languages revisited. </title> <booktitle> In Proceedings of Conference on Object Oriented Programming, Systems and Languages, </booktitle> <pages> pages 140-149, </pages> <year> 1990. </year>
Reference: [43] <author> B. Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Consider the trivialized POINT and ColoredPOINT example in an Eiffel <ref> [43] </ref> like language: class POINT exports x, y, print method print is return = "POINT" class ColoredPOINT inherits POINT redefines print as prt exports x, y, c, print method print is return = "Colored"#prt () - # is string concatenation Even though ColoredPOINT behaves like POINT, we cannot conclude that ColoredPOINT <p> The apparent polymorphism also illustrates that inheritance does preserve algorithmic abstraction, as is the case with parametric polymorphism and therefore a careful statement of contract compliance <ref> [43, 1] </ref> is demanded over the general subtyping rules. In this thesis, we consider only subtype conformance that can be realized using type signatures. In general, inheritance (subclass) does not imply a subtype relation, as demonstrated by [54, 17], since inheritance does not require a contravariance rule. <p> Some languages do not require the contravariance of parameters, even though they emphasize static type-checkability (Eiffel <ref> [43] </ref> and BETA [38]). <p> Some languages do not require the contravariance of parameters, even though they emphasize static type-checkability (Eiffel [43] and BETA [38]). The redefinition rule, for redefining a method of the superclass in Eiffel <ref> [43, page 263] </ref>, is paraphrased here as: An attribute, a function result or a formal routine argument declared in a class may be redeclared with a new type in a descendant class, provided the new type conforms to the original one. <p> Note that the emphasized words imply a covariance of arguments, unlike the 12 contravariant type rule in the subtype definition. The result being that even though the programs are statically type checked as correct, say by Eiffel <ref> [43] </ref>, they can fail at runtime when subtype means substitutability in all contexts. <p> In this chapter, we have differentiated inheritance as a facility to extend or modify behavior of a template, while delegation is a facility to extend or modify the behavior of an object. This notion corresponds with languages claiming inheritance as their fundamental mechanism <ref> [58, 43, 53] </ref> and those that claim delegation as their fundamental mechanism [41, 59]. Languages like SmallTalk [26] have provision for both inheritance and delegation in this sense, as noted by [55]. <p> Subtype definition is usually restricted to the contravariance of method argument types [9] as explained in Chapter 1. Practical limitations of such a subtype definition were discussed in Section 1.3 and are illustrated by Eiffel's <ref> [43] </ref> decision to allow the flexibility of defining inherited types as subtypes, at the risk of complicating the language [44] in order to avoid the resulting type insecurities [16]. <p> A small object-oriented language that defines the basic characteristics of a typical object-oriented language (similar to <ref> [43, 58] </ref>) is described. This language is a functional language with updatable instance variables (but no aliasing) and some predefined types like Booleans and Natural numbers. <p> The language is flexibly defined so that certain techniques can be discussed that cannot be modeled by some of the accepted semantics [15, 51] that attempted to describe [26] and are usually not permitted <ref> [43, 58] </ref>. However, the language does not provide the templates facility (classes as first class objects) that was discussed in Section 2.7. The denotational semantics is expressed using -calculus as in Chapter 2. Later (Chapter 5) we specify and develop the initial algebra semantics of such a 49 language. <p> A subtype hierarchy is created by explicitly specifying the subtype of relations. The peculiarities and the flexibility of the language is illustrated by several examples in the following sections. 3.4 Flexible subtyping First we consider the problem of "covariance or contravariance?" for method arguments. The language Eiffel <ref> [43] </ref> requires covariance, while Trellis [53] and several others, require contravariance. It is well understood that contravariance is safe, while covariance is desirable in practice for certain tasks. <p> These languages do not have side-effects, with the interpretation discussed in section 5.7 and can therefore be classified as functional object oriented programming languages. The language EOOL presented in Chapter 6 is an Eiffel <ref> [43] </ref> like language, but forces inherited types [17] to behave like subtypes using the ideas described in Chapter 4. 5.2 ASF+SDF ASF, an acronym for Algebraic Specification Formalism, [4, 30] is a formalism supporting modularization and conditional equations. <p> ) . z Example 16: Providing for type declarations As a result the program will not type check, according to the rules discussed in Section 5.4.3, since the result of movex is a point which does not understand z. 5.6.2 Using "selftype" A well understood problem in object oriented programming <ref> [43, 17, 47, 49] </ref>, is that inheritance of code will, in general, require certain type declarations concerning the type of self be specialized accordingly. <p> The commonly used 122 technique is to provide a type declaration facility that can be used to specialize the type information - Eiffel <ref> [43] </ref> provides for declaration by association (Chapter 4), Palsberg and Schwartzbach [49] discuss the safety of specializing all type declarations accordingly, and Cook et. al. [17] have discussed the notion of F-bounded types that arise in the presence of inheritance. <p> Thus, zpoint would not be a subtype of point and since this is a natural manner in which classes seem to evolve <ref> [43, 16, 17] </ref> subtype hierarchy should in general be separate from inheritance hierarchy (For example, as in our case here). Chapters 3, 4 and 6 discuss other techniques to help enforce these hierarchies to correspond. <p> With these additions to the syntax, we hope be able to write 128 programs that resemble those of conventional object-oriented languages that use assignments and statements <ref> [43, 26] </ref>. <p> It is well understood that inheritance does not lead to subtypes, but to the so called inherited types [17]. We finish with a case of study analysis of this view. Since the language Eiffel provided for the use of inherited types as subtypes <ref> [43] </ref>, we consider a language (EOOL) similar to Eiffel in that subclasses are subtypes. We then use the ideas developed in Chapter 3 to adopt the orphan objects created in the process of identifying subclasses and subtypes. <p> = 7 [26] 3 + 5 = 8 [27] 3 + 6 = 9 [31] 4 + 1 = 5 [32] 4 + 2 = 6 [33] 4 + 3 = 7 [37] 4 + 7 = 11 [38] 4 + 8 = 12 [39] 4 + 9 = 13 <ref> [43] </ref> 5 + 4 = 9 [44] 5 + 5 = 10 [45] 5 + 6 = 11 [49] 6 + 1 = 7 [50] 6 + 2 = 8 [51] 6 + 3 = 9 153 [55] 6 + 7 = 13 [56] 6 + 8 = 14 [57] 6
Reference: [44] <author> B. Meyer. </author> <title> Static typing for Eiffel. USENET comp.object, </title> <month> July </month> <year> 1990. </year>
Reference-contexts: Practical limitations of such a subtype definition were discussed in Section 1.3 and are illustrated by Eiffel's [43] decision to allow the flexibility of defining inherited types as subtypes, at the risk of complicating the language <ref> [44] </ref> in order to avoid the resulting type insecurities [16]. In this chapter, we present a flexible message passing mechanism that allows an accommodation of covariance of method argument types (Section 1.3), when desired. This facility will also illustrate when covariance might be desired, and its peculiarities. <p> The Eiffel designers, however, have not forsaken this flexibility as they believe that this flexibility provides for the most natural evolution of software systems. Instead, the Eiffel designers have developed a complex set of type-checking rules inorder to provide for the complete check of the whole system <ref> [44, 45] </ref> The main problem we see in this is that such "system validity checking" effectively defeats the advocated flexibility of the language, since adding a new class to the evolving system could result in a type error in a class that was 69 type-checked as "OK" earlier. <p> The first proposal to make Eiffel type-safe has been basically to eliminate the flexibility of Eiffel for most part. The second proposal, from Bertrand Meyer <ref> [44] </ref>, is a clarification that Eiffel can be type-checked with all its features if subtyping does not imply substitutability in all contexts. <p> = 8 [27] 3 + 6 = 9 [31] 4 + 1 = 5 [32] 4 + 2 = 6 [33] 4 + 3 = 7 [37] 4 + 7 = 11 [38] 4 + 8 = 12 [39] 4 + 9 = 13 [43] 5 + 4 = 9 <ref> [44] </ref> 5 + 5 = 10 [45] 5 + 6 = 11 [49] 6 + 1 = 7 [50] 6 + 2 = 8 [51] 6 + 3 = 9 153 [55] 6 + 7 = 13 [56] 6 + 8 = 14 [57] 6 + 9 = 15 [61] 7
Reference: [45] <author> B. Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: The type-checking of Eiffel has thus evolved to be a very complex process, which involves system validity as a whole <ref> [45, chapter 22] </ref>. The versions of Eiffel implementations available to date have not been able to provide for such thorough checking. <p> The Eiffel designers, however, have not forsaken this flexibility as they believe that this flexibility provides for the most natural evolution of software systems. Instead, the Eiffel designers have developed a complex set of type-checking rules inorder to provide for the complete check of the whole system <ref> [44, 45] </ref> The main problem we see in this is that such "system validity checking" effectively defeats the advocated flexibility of the language, since adding a new class to the evolving system could result in a type error in a class that was 69 type-checked as "OK" earlier. <p> = 9 [31] 4 + 1 = 5 [32] 4 + 2 = 6 [33] 4 + 3 = 7 [37] 4 + 7 = 11 [38] 4 + 8 = 12 [39] 4 + 9 = 13 [43] 5 + 4 = 9 [44] 5 + 5 = 10 <ref> [45] </ref> 5 + 6 = 11 [49] 6 + 1 = 7 [50] 6 + 2 = 8 [51] 6 + 3 = 9 153 [55] 6 + 7 = 13 [56] 6 + 8 = 14 [57] 6 + 9 = 15 [61] 7 + 4 = 11 [62] 7
Reference: [46] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: 0, 1, 2, and returns a natural number, defined as (the symbol ) follows 1 : F self:n:if n = 0 then 1 else n fl (self (n 1)): The fixed-point of F is the factorial function defined by f act Y F where Y is the call-by-value fixpoint operator <ref> [57, 2, 46] </ref>, (i.e., F f act = f act). <p> Requirements are outlined for a type checking system that could control the nature and extent of manipulations of the message passing mechanism, with facilities of the language. This is similar to adding the required coercion functions by the type-checker during compilation in languages like Pascal <ref> [46] </ref>. Particular instances where some of the restrictions found in statically type checkable object oriented languages, could be relaxed are identified and discussed. This discussion, in turn, gives some insight to when covariance would be appropriate.
Reference: [47] <author> J. Mitchell. </author> <title> Towards a typed foundation for method specialization and inheritance. </title> <booktitle> In Proceedings of 19th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1990. </year>
Reference-contexts: Before considering the effects of mixing these two in detail (in the next section), we formulate the idea of passing self as first argument here. This idea has been used by the people who have implemented object-oriented languages [52, 12] as noted in <ref> [47, 33] </ref>. Although the constructions using the explicit fixpoint operator seemed elegant for the case of inheritance, as we have noted above, it looses its elegancy for delegation. A simpler translation can be obtained for delegation that encompasses the expressivity of the constructions of inheritance. <p> The notion of inheritance was made clear by Reddy [51] and Cook [15] who showed that inheritance required the redefinition of self, and also explained the meaning of super to refer to a parent's method. Mitchell <ref> [47] </ref>, however, could not use these mechanisms to explain the updating of instance variables. He noticed that, considering objects as fixed points a-priori is too strong and does not allow for any modifications whatsoever. <p> The mechanisms presented in this chapter provide for SmallTalk like facilities, as desired by Cook, with updating of instance variables as desired by Mitchell. 44 2.8.1 Cook's and Mitchell's semantics The semantic mechanisms for Inheritance, of Cook, as in [17] and those for delegation, of Mitchell, as in <ref> [47] </ref> are two special cases of the mechanisms given in the previous section. We have generalized Mitchell's semantics, in Section 2.6, by providing for the notion of super and in the previous section by providing for templates. Thus by not using super and templates, our mechanisms specialize to Mitchell's. <p> Our 48 semantics is an extension of Mitchell's <ref> [47] </ref>, where the necessary recursion is obtained by using a message passing mechanism (called messager) which passes the receiver of the message as the first argument to the method (as in Section 2.6). This can be described as a form of delegation [41] [59], as indicated by Mitchell. <p> In this language, we do not have instance variables that affect the state of the objects (no side-affects), but do have a controlled form of delegation that enables a method to return modified self by providing a replacement behavior for instance variables <ref> [47] </ref>. Also we do not provide for the ability to recursively specify a class, in order to keep the semantics simple. All objects in this system have the same form, including those that are formed using delegation. <p> ) . z Example 16: Providing for type declarations As a result the program will not type check, according to the rules discussed in Section 5.4.3, since the result of movex is a point which does not understand z. 5.6.2 Using "selftype" A well understood problem in object oriented programming <ref> [43, 17, 47, 49] </ref>, is that inheritance of code will, in general, require certain type declarations concerning the type of self be specialized accordingly. <p> With the above rules, the other method will at most have the argument type to be point: meth other:natural (pt:point) pt.test0 ().x 144 CHAPTER 7 CONCLUSIONS 7.1 Summary Among the implementors of object-oriented languages, it is known <ref> [52, 33, 47] </ref> that the receiver of the message can be used as the first argument of an object's methods to access its other methods. We have used this idea to develop the semantics of delegation with recursive templates. Delegation without templates is provided for in [47]. <p> We have used this idea to develop the semantics of delegation with recursive templates. Delegation without templates is provided for in <ref> [47] </ref>. Templates and some form of inheritance are distinct features an object-oriented language must provide, as emphasized by [56] by comparing their individual works (DELEGATION [41], SELF [59] and [55]).
Reference: [48] <author> S. M. Omohundro. </author> <title> Sather. </title> <type> Eiffel Outlook, </type> <year> 1991. </year>
Reference: [49] <author> J. Palsberg and M. Schwartzbach. </author> <booktitle> What is type-safe code reuse? In Proceedings of Conference on European Conference on Object-Oriented Programming, </booktitle> <year> 1991. </year>
Reference-contexts: Basically, the user has thus specialized the class P1 to the context of C1 by the redeclaration of the attribute a. This kind of specialization is automatically done in <ref> [49] </ref>. <p> ) . z Example 16: Providing for type declarations As a result the program will not type check, according to the rules discussed in Section 5.4.3, since the result of movex is a point which does not understand z. 5.6.2 Using "selftype" A well understood problem in object oriented programming <ref> [43, 17, 47, 49] </ref>, is that inheritance of code will, in general, require certain type declarations concerning the type of self be specialized accordingly. <p> The commonly used 122 technique is to provide a type declaration facility that can be used to specialize the type information - Eiffel [43] provides for declaration by association (Chapter 4), Palsberg and Schwartzbach <ref> [49] </ref> discuss the safety of specializing all type declarations accordingly, and Cook et. al. [17] have discussed the notion of F-bounded types that arise in the presence of inheritance. <p> This example thus indicates that, although it might lead to a natural way of specializing super class definition by using "selftype" for argument declaration, one should be cautious reusing super class methods. An extreme way of handling this kind of specialization can be seen in <ref> [49] </ref>, where all mention of "point" would be read as "zpoint" in the class zpoint. Although this would render such cases type safe, it would force specialization when not intended. <p> = 5 [32] 4 + 2 = 6 [33] 4 + 3 = 7 [37] 4 + 7 = 11 [38] 4 + 8 = 12 [39] 4 + 9 = 13 [43] 5 + 4 = 9 [44] 5 + 5 = 10 [45] 5 + 6 = 11 <ref> [49] </ref> 6 + 1 = 7 [50] 6 + 2 = 8 [51] 6 + 3 = 9 153 [55] 6 + 7 = 13 [56] 6 + 8 = 14 [57] 6 + 9 = 15 [61] 7 + 4 = 11 [62] 7 + 5 = 12 [63] 7
Reference: [50] <author> J. Palsberg and M. Schwartzback. </author> <title> Static typing for object-oriented programming. </title> <type> Technical Report Aarhus University, </type> <institution> Computer Science Department, </institution> <year> 1991. </year>
Reference-contexts: There are many Object-Oriented Programming Languages (OOPL) that have surfaced in the recent years [20, 26, 53, 59, 36, 58, 43, 5, 19, 38, 12, 61, 48]. Although many of these languages are used for programming in the large, the kernel of these languages is generally small <ref> [32, 50, 11, 7] </ref>. The semantic mechanisms of these languages have been studied mostly in a denotational setting [15, 18, 33, 32, 7, 51]. Although this research has produced interesting constructions for the denotational semantics community, among the community of programmers the mechanisms are still understood using informal terms. <p> = 6 [33] 4 + 3 = 7 [37] 4 + 7 = 11 [38] 4 + 8 = 12 [39] 4 + 9 = 13 [43] 5 + 4 = 9 [44] 5 + 5 = 10 [45] 5 + 6 = 11 [49] 6 + 1 = 7 <ref> [50] </ref> 6 + 2 = 8 [51] 6 + 3 = 9 153 [55] 6 + 7 = 13 [56] 6 + 8 = 14 [57] 6 + 9 = 15 [61] 7 + 4 = 11 [62] 7 + 5 = 12 [63] 7 + 6 = 13 [67] 8
Reference: [51] <author> U. Reddy. </author> <title> Objects as closures: Abstract semantics of object-oriented languages. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 289-297, </pages> <year> 1988. </year>
Reference-contexts: This provides a way of relaxing the contravariance rule in many subtype definitions while avoiding run-time type errors. 1.4 Thesis overview The constructions given for inheritance <ref> [15, 51] </ref> seem to be restrictive and we suggest thinking of delegation as a more useful mechanism even for "inheritance based languages". <p> This development is a generalized semantics of inheritance, delegation and recursive templates. 2.8 Related work The notion of objects being fixed points of mutually recursive functions over self was explained by Cardelli [9]. The notion of inheritance was made clear by Reddy <ref> [51] </ref> and Cook [15] who showed that inheritance required the redefinition of self, and also explained the meaning of super to refer to a parent's method. Mitchell [47], however, could not use these mechanisms to explain the updating of instance variables. <p> Thus, the only means of modifying a template is by using the subclass of construct. The subclass of construct is a special case of the 1 operator. With this reduction, we can use the arguments for equivalence as given by [34], who compares Reddy's mechanisms <ref> [51] </ref> (which uses fixed point operators) and Kamin's [33] mechanisms which in turn are those used by Cook and Mitchell, respectively. 8 By saying "Cook's semantics", we are referring to the section on class inheritance of [17] | which also involves the modification of recursive templates. 45 SmallTalk and SELF have <p> Section 3.7 discusses the issue of extending a type hierarchy without modifying its code. Section 3.8 uses this flexible message passing mechanism to let the user harness subtype information. 3.2 A small language In the familiar semantics of inheritance [15] <ref> [51] </ref>, an object is literally "fixed" during its creation by taking the fixed-point of its generator (Section 2.3). <p> The language is flexibly defined so that certain techniques can be discussed that cannot be modeled by some of the accepted semantics <ref> [15, 51] </ref> that attempted to describe [26] and are usually not permitted [43, 58]. However, the language does not provide the templates facility (classes as first class objects) that was discussed in Section 2.7. The denotational semantics is expressed using -calculus as in Chapter 2. <p> Consider a line class 2 (Example 3.4) of type Line, which uses the point defined earlier, with Line defined as: Type Line p: ! Point q: ! Point samelen: Line ! Boolean Lets say, that the Manhattan length <ref> [51] </ref> is not the desired semantics for computing the length of a line object (line object is an instance of class line). An Iowan attempts to fix this problem by defining a subclass of line class by computing the length, using the Iowa definition. <p> Although many of these languages are used for programming in the large, the kernel of these languages is generally small [32, 50, 11, 7]. The semantic mechanisms of these languages have been studied mostly in a denotational setting <ref> [15, 18, 33, 32, 7, 51] </ref>. Although this research has produced interesting constructions for the denotational semantics community, among the community of programmers the mechanisms are still understood using informal terms. <p> The mechanisms we have provided are a generalization of all these facilities which includes those of inheritance as in SmallTalk [26] (given by <ref> [51] </ref> and [15]). We have concluded that in the presence of delegation and templates, every object needs to be paired with its template. We have used [15] semantics of inheritance to discuss what the semantics of delegation should be. <p> = 7 [37] 4 + 7 = 11 [38] 4 + 8 = 12 [39] 4 + 9 = 13 [43] 5 + 4 = 9 [44] 5 + 5 = 10 [45] 5 + 6 = 11 [49] 6 + 1 = 7 [50] 6 + 2 = 8 <ref> [51] </ref> 6 + 3 = 9 153 [55] 6 + 7 = 13 [56] 6 + 8 = 14 [57] 6 + 9 = 15 [61] 7 + 4 = 11 [62] 7 + 5 = 12 [63] 7 + 6 = 13 [67] 8 + 1 = 9 [68] 8
Reference: [52] <author> J. Rees and N. Adams. </author> <title> T, a dialect of lisp, or lambda: the ultimate software tool. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 114-122, </pages> <year> 1982. </year>
Reference-contexts: Before considering the effects of mixing these two in detail (in the next section), we formulate the idea of passing self as first argument here. This idea has been used by the people who have implemented object-oriented languages <ref> [52, 12] </ref> as noted in [47, 33]. Although the constructions using the explicit fixpoint operator seemed elegant for the case of inheritance, as we have noted above, it looses its elegancy for delegation. A simpler translation can be obtained for delegation that encompasses the expressivity of the constructions of inheritance. <p> With the above rules, the other method will at most have the argument type to be point: meth other:natural (pt:point) pt.test0 ().x 144 CHAPTER 7 CONCLUSIONS 7.1 Summary Among the implementors of object-oriented languages, it is known <ref> [52, 33, 47] </ref> that the receiver of the message can be used as the first argument of an object's methods to access its other methods. We have used this idea to develop the semantics of delegation with recursive templates. Delegation without templates is provided for in [47].
Reference: [53] <author> C. Schaffert, T. Coope, B. Bullis, M. Kilian, and C. Wilpolt. </author> <title> An introduction to trellis/owl. </title> <booktitle> In Proceedings of Conference on Object Oriented Programming, Systems and Languages, </booktitle> <pages> pages 9-16, </pages> <year> 1986. </year>
Reference-contexts: In this chapter, we have differentiated inheritance as a facility to extend or modify behavior of a template, while delegation is a facility to extend or modify the behavior of an object. This notion corresponds with languages claiming inheritance as their fundamental mechanism <ref> [58, 43, 53] </ref> and those that claim delegation as their fundamental mechanism [41, 59]. Languages like SmallTalk [26] have provision for both inheritance and delegation in this sense, as noted by [55]. <p> The peculiarities and the flexibility of the language is illustrated by several examples in the following sections. 3.4 Flexible subtyping First we consider the problem of "covariance or contravariance?" for method arguments. The language Eiffel [43] requires covariance, while Trellis <ref> [53] </ref> and several others, require contravariance. It is well understood that contravariance is safe, while covariance is desirable in practice for certain tasks.
Reference: [54] <author> A. Snyder. </author> <title> Inheritance and the development of encapsulated software components. </title> <editor> In Shriver and Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 165-188. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1987. </year>
Reference-contexts: In this thesis, we consider only subtype conformance that can be realized using type signatures. In general, inheritance (subclass) does not imply a subtype relation, as demonstrated by <ref> [54, 17] </ref>, since inheritance does not require a contravariance rule. The message passing paradigm facilitates a simple algorithm for selecting the target method dynamically. Selection of the method to be invoked is not affected by all the arguments of the method, but by only one (the target object).
Reference: [55] <author> L. A. Stein. </author> <title> Delegation is inheritance. </title> <booktitle> In Proceedings of Conference on Object Oriented Programming, Systems and Languages, </booktitle> <pages> pages 138-146, </pages> <year> 1987. </year>
Reference-contexts: Mitchell's model is extended here by providing for super and also providing for the notion of templates. The notion of templates (or classes) adds an additional level of recursion [17] in Cook's semantics but extending classes in an analogous manner of extending objects is not possible. Stein <ref> [55] </ref> has shown that accommodating templates as first class objects (classes | like in SmallTalk), will blur the difference between delegation and inheritance, and also makes delegation a special case of inheritance and has thereby demonstrated the power of classes as first class objects (and the notion of metaclass) in SmallTalk. <p> This notion corresponds with languages claiming inheritance as their fundamental mechanism [58, 43, 53] and those that claim delegation as their fundamental mechanism [41, 59]. Languages like SmallTalk [26] have provision for both inheritance and delegation in this sense, as noted by <ref> [55] </ref>. <p> Delegation without templates is provided for in [47]. Templates and some form of inheritance are distinct features an object-oriented language must provide, as emphasized by [56] by comparing their individual works (DELEGATION [41], SELF [59] and <ref> [55] </ref>). The mechanisms we have provided are a generalization of all these facilities which includes those of inheritance as in SmallTalk [26] (given by [51] and [15]). We have concluded that in the presence of delegation and templates, every object needs to be paired with its template. <p> 11 [38] 4 + 8 = 12 [39] 4 + 9 = 13 [43] 5 + 4 = 9 [44] 5 + 5 = 10 [45] 5 + 6 = 11 [49] 6 + 1 = 7 [50] 6 + 2 = 8 [51] 6 + 3 = 9 153 <ref> [55] </ref> 6 + 7 = 13 [56] 6 + 8 = 14 [57] 6 + 9 = 15 [61] 7 + 4 = 11 [62] 7 + 5 = 12 [63] 7 + 6 = 13 [67] 8 + 1 = 9 [68] 8 + 2 = 10 [69] 8 +
Reference: [56] <author> L. A. Stein, H. Lieberman, and D. Ungar. </author> <title> A shared view of sharing: Treaty of Orlando. </title> <editor> In W. Kim and F. Lochovsky, editors, </editor> <booktitle> Object-Oriented Concepts, Databases and Applications, Frontier Series, </booktitle> <pages> pages 31-48. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year> <month> 206 </month>
Reference-contexts: The treaty of Orlando <ref> [56] </ref> emphasizes this issue by identifying these (called empathy and template respectively) as distinct features that object-oriented programs must provide. In this section, we illustrate the difference between these using examples and attempt to defend the existence of both. <p> (i 1 i t 1 ) 1 0 (i 2 i t 1 ) ((i 1 i t 1 ) 1 (i 2 i t 1 )) id id id id 7 "If an object may not gain or loose attributes once it is defined, we call the template strict" <ref> [56, page 38] </ref>. 39 The ability to create objects using one's template can be added to the domain of expressions (language C 4 ): E ::= j new self class (E 1 ; E n ) with the following translation: hhclass I 0 (I 1 ; I n ) M ii <p> Stein, Lieberman and Ungar <ref> [56] </ref> have later agreed that some form of delegation and templates are two necessary facilities that an object-oriented language must provide, since these model orthogonal issues. <p> since a fract prod will in no way be able to send a FracBugdenom message to its argument. 3.7 Altering hierarchies Another haunting problem with current inheritance hierarchies is the lack of the ability to modify an entire hierarchy by a client, without resorting to modification of the existing code <ref> [56] </ref>. This arises in such cases as when a black and white terminal is changed to a color terminal, resulting in the entire hierarchy of shapes needing the addition of color attributes which are usually orthogonal to the existing attributes. <p> The subclassing mechanism allows one to specialize an existing class by some additive extensions. However, there is no mechanism to specialize a given hierarchy in a similar manner. From Treaty of Orlando <ref> [56] </ref> we quote: "no existing object-oriented language provides a mechanism for this that does not require the modification of previously existing code. Yet conceptually, we should be able to perform these changes by some sort of additive extension". In this section, some progress is made towards this. <p> The above solution works fine only for simple color attributes and attributes that use self. However for attributes that use super, like in the case of a display method <ref> [56] </ref> which needs to use the display method of shape in order to display a colored shape, the solution may not be satisfactory. To correct this, we separate the methods of color prototype into overridable methods, like simple attributes, and the non-overridable methods, like the display method. <p> We have used this idea to develop the semantics of delegation with recursive templates. Delegation without templates is provided for in [47]. Templates and some form of inheritance are distinct features an object-oriented language must provide, as emphasized by <ref> [56] </ref> by comparing their individual works (DELEGATION [41], SELF [59] and [55]). The mechanisms we have provided are a generalization of all these facilities which includes those of inheritance as in SmallTalk [26] (given by [51] and [15]). <p> 12 [39] 4 + 9 = 13 [43] 5 + 4 = 9 [44] 5 + 5 = 10 [45] 5 + 6 = 11 [49] 6 + 1 = 7 [50] 6 + 2 = 8 [51] 6 + 3 = 9 153 [55] 6 + 7 = 13 <ref> [56] </ref> 6 + 8 = 14 [57] 6 + 9 = 15 [61] 7 + 4 = 11 [62] 7 + 5 = 12 [63] 7 + 6 = 13 [67] 8 + 1 = 9 [68] 8 + 2 = 10 [69] 8 + 3 = 11 [73] 8 +
Reference: [57] <author> J. E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1977. </year>
Reference-contexts: 0, 1, 2, and returns a natural number, defined as (the symbol ) follows 1 : F self:n:if n = 0 then 1 else n fl (self (n 1)): The fixed-point of F is the factorial function defined by f act Y F where Y is the call-by-value fixpoint operator <ref> [57, 2, 46] </ref>, (i.e., F f act = f act). <p> = 3 then 3 else if n = 0 then 1 else n fl (f (n 1)); how may the user specify this function as an "incremental modification" of fact's specification? What is meant by incremental modification is that, the structure of 1 For -calculus and denotational semantics we use <ref> [57, 2, 27] </ref> 15 f and f act are the same except for the additional condition, if n = 3 then 3 else if , and the goal is to specify f by just specifying this difference. <p> Although the examples demonstrate the utility of delegation for updating objects, in Chapter 3 delegation is used in a more general sense. 18 2.2 A language with inheritance We assume a knowledge of -calculus <ref> [57] </ref>, which we use to give the semantics of the languages we define. The semantics of the constructs are given by a translation to -calculus. <p> The semantics of the constructs are given by a translation to -calculus. We consider the -calculus with syntax for records, conditionals and "let" declarations (initialized definition of new names <ref> [57, page 226] </ref>) and some primitive domains (eg., Booleans, Identifiers, Naturals) and their operations [57, page 156]. The general convention in -calculus is that application (F 1 F 2 below) associates to the left, while abstraction (I:F ) associates to the right. <p> The semantics of the constructs are given by a translation to -calculus. We consider the -calculus with syntax for records, conditionals and "let" declarations (initialized definition of new names [57, page 226]) and some primitive domains (eg., Booleans, Identifiers, Naturals) and their operations <ref> [57, page 156] </ref>. The general convention in -calculus is that application (F 1 F 2 below) associates to the left, while abstraction (I:F ) associates to the right. <p> 13 [43] 5 + 4 = 9 [44] 5 + 5 = 10 [45] 5 + 6 = 11 [49] 6 + 1 = 7 [50] 6 + 2 = 8 [51] 6 + 3 = 9 153 [55] 6 + 7 = 13 [56] 6 + 8 = 14 <ref> [57] </ref> 6 + 9 = 15 [61] 7 + 4 = 11 [62] 7 + 5 = 12 [63] 7 + 6 = 13 [67] 8 + 1 = 9 [68] 8 + 2 = 10 [69] 8 + 3 = 11 [73] 8 + 7 = 15 [74] 8 +
Reference: [58] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: This selection rule together with dynamic binding, we claim, has led to incomplete operational semantics in languages like Eiffel. Thus a proper (in the sense of completeness) interpretation of message passing is necessary for proper static type checking. Several alternatives have been considered <ref> [58, 36, 25] </ref>. The adoption mechanism suggested in this thesis provides for an orthogonal approach that accommodates for some desirable cases that cannot be handled by other techniques. Type denotes a collection of objects that share the same externally 9 observable behavior. <p> In this chapter, we have differentiated inheritance as a facility to extend or modify behavior of a template, while delegation is a facility to extend or modify the behavior of an object. This notion corresponds with languages claiming inheritance as their fundamental mechanism <ref> [58, 43, 53] </ref> and those that claim delegation as their fundamental mechanism [41, 59]. Languages like SmallTalk [26] have provision for both inheritance and delegation in this sense, as noted by [55]. <p> A small object-oriented language that defines the basic characteristics of a typical object-oriented language (similar to <ref> [43, 58] </ref>) is described. This language is a functional language with updatable instance variables (but no aliasing) and some predefined types like Booleans and Natural numbers. <p> The language is flexibly defined so that certain techniques can be discussed that cannot be modeled by some of the accepted semantics [15, 51] that attempted to describe [26] and are usually not permitted <ref> [43, 58] </ref>. However, the language does not provide the templates facility (classes as first class objects) that was discussed in Section 2.7. The denotational semantics is expressed using -calculus as in Chapter 2. Later (Chapter 5) we specify and develop the initial algebra semantics of such a 49 language.
Reference: [59] <author> D. Ungar and R. B. Smith. </author> <title> Self: The power of simplicity. </title> <booktitle> In Proceedings of Conference on Object Oriented Programming, Systems and Languages, </booktitle> <pages> pages 227-242, </pages> <year> 1987. </year>
Reference-contexts: This notion corresponds with languages claiming inheritance as their fundamental mechanism [58, 43, 53] and those that claim delegation as their fundamental mechanism <ref> [41, 59] </ref>. Languages like SmallTalk [26] have provision for both inheritance and delegation in this sense, as noted by [55]. <p> This can be described as a form of delegation [41] <ref> [59] </ref>, as indicated by Mitchell. In our generalized notion of delegation (as noted in Section 2.4), any object can delegate to any other object. Therefore, when an object is passed as an argument of a message, it can delegate to a specified object in that context. <p> We have used this idea to develop the semantics of delegation with recursive templates. Delegation without templates is provided for in [47]. Templates and some form of inheritance are distinct features an object-oriented language must provide, as emphasized by [56] by comparing their individual works (DELEGATION [41], SELF <ref> [59] </ref> and [55]). The mechanisms we have provided are a generalization of all these facilities which includes those of inheritance as in SmallTalk [26] (given by [51] and [15]). We have concluded that in the presence of delegation and templates, every object needs to be paired with its template.
Reference: [60] <author> P. Wegner. </author> <title> Dimensions of object-based language design. </title> <booktitle> In Proceedings of Conference on Object Oriented Programming, Systems and Languages, </booktitle> <year> 1987. </year>
Reference-contexts: We begin with the compositional model of inheritance, as given by Cook [15]. Changes are then introduced which incrementally work toward achieving delegation and inheritance in a general setting. The concepts of delegation and inheritance are widely used in the object-oriented community <ref> [60] </ref>, since they enable reuse of existing code without modifying it. The key feature of delegation is that "self-reference" in an ancestor dynamically denotes the delegating object, not the ancestor, thereby allowing the ancestor's behavior to be part of the extended identity of the delegating object.
Reference: [61] <author> N. Wirth. </author> <title> The programming language oberon. </title> <journal> Software Practice and Experience, </journal> <volume> 18 </volume> <pages> 671-690, </pages> <year> 1988. </year>
Reference-contexts: 9 [44] 5 + 5 = 10 [45] 5 + 6 = 11 [49] 6 + 1 = 7 [50] 6 + 2 = 8 [51] 6 + 3 = 9 153 [55] 6 + 7 = 13 [56] 6 + 8 = 14 [57] 6 + 9 = 15 <ref> [61] </ref> 7 + 4 = 11 [62] 7 + 5 = 12 [63] 7 + 6 = 13 [67] 8 + 1 = 9 [68] 8 + 2 = 10 [69] 8 + 3 = 11 [73] 8 + 7 = 15 [74] 8 + 8 = 16 [75] 8 +
References-found: 61

