URL: http://www.cs.virginia.edu/~nr/pubs/thesis.ps.gz
Refering-URL: http://www.cs.virginia.edu/~nr/
Root-URL: http://www.cs.virginia.edu
Title: A RETARGETABLE DEBUGGER  
Author: Norman Ramsey 
Degree: A DISSERTATION PRESENTED TO THE FACULTY  IN CANDIDACY FOR THE DEGREE OF DOCTOR OF PHILOSOPHY RECOMMENDED FOR ACCEPTANCE BY THE DEPARTMENT OF COMPUTER SCIENCE  
Date: January 1993  
Affiliation: OF PRINCETON UNIVERSITY  
Abstract-found: 0
Intro-found: 1
Reference: <author> Adams, Evan and Steven S. Muchnick. </author> <year> 1986 </year> <month> (July). </month> <title> Dbxtool: A window-based symbolic debugger for Sun workstations. </title> <journal> Software|Practice & Experience, </journal> <volume> 16(7) </volume> <pages> 653-669. </pages> <institution> Adobe Systems Incorporated. </institution> <year> 1985. </year> <title> PostScript Language Reference Manual. </title> <address> Reading, Ma: </address> <publisher> Addison-Wesley. Adobe Systems Incorporated. </publisher> <year> 1990. </year> <title> PostScript Language Reference Manual. Second edition. </title> <address> Reading, Ma: </address> <publisher> Addison-Wesley. American National Standard Institute, Inc. </publisher> <year> 1990. </year> <title> American National Standards for Information Systems, Programming Language C ANSI X3.159-1989. </title> <address> New York. </address>
Reference-contexts: Figure 1 3 shows a traditional Unix debugger, dbx, debugging a target process. dbx uses kernel support, typically the ptrace system call, to control its target. The meaning and usage of ptrace differ among different versions of Unix <ref> (Adams and Muchnick 1986) </ref>. dbx gets its symbol-table information from the object file for the target program, where it is stored in a machine-dependent, language-dependent format. <p> Topaz provides completely reliable, available debugging support; Section 6.5 compares it and ldb. Other approaches to debugging support include system calls <ref> (Adams and Muchnick 1986) </ref>, as depicted in Figure 1, controlling processes through the file system (Killian 1984), and running the target and debugger in 6 CHAPTER 1. INTRODUCTION the same address space (Aral, Gertner, and Schaffer 1989). The relative merits of these approaches are discussed in Chapter 6. <p> Each of these debuggers implements expression evaluation from scratch. One drawback is that the debugger and compiler are likely to implement different languages. dbx implements only a subset of C; for example, it omits assignment operators like += <ref> (Adams and Muchnick 1986) </ref>. The ups documentation lists some details of ANSI C that it gets wrong; for example, ups cannot correctly call procedures that return floating-point or structured values. <p> The debugger starts and stops the child and reads and writes its memory and registers by calling ptrace. ptrace also provides support for intercepting signals delivered to the target process. Most vendors have found it necessary to improve on ptrace <ref> (Adams and Muchnick 1986) </ref>. One extension makes it possible for the debugger to refer to registers without knowing their locations in kernel data structures, somewhat like an abstract memory. <p> The specification of the context is generated automatically from the nub's symbol table. An alternative that reduces the debugger's dependence on nub data structures is to provide an abstraction giving access to registers in a way that is independent of those data structures <ref> (Adams and Muchnick 1986) </ref>. Such an extra layer of abstraction does not make sense for ldb, because the nub has no purpose other than to support debugging, and therefore there is no reason to make the debugger independent of its data structures.
Reference: <author> Appel, Andrew W. </author> <year> 1989 </year> <month> (February). </month> <title> Simple generational garbage collection and fast allocation. </title> <journal> Software|Practice & Experience, </journal> <volume> 19(2) </volume> <pages> 171-183. </pages> . <year> 1990. </year> <title> A runtime system. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3 </volume> <pages> 343-380. </pages> . <year> 1992. </year> <title> Compiling with Continuations. </title> <publisher> Cambridge: Cambridge University Press. </publisher>
Reference-contexts: The new version increases the heap in proportion to the amount of live data; previously the increase was of fixed size. The proportion can be adjusted dynamically to trade off speed and space usage <ref> (Appel 1989) </ref>, reducing execution time by 37-50%. These adjustments combine to make ldb's current interpreter read large symbol tables six times faster than the original. Measurements taken by program-counter sampling indicate that it still spends about 30% of its time in garbage collection and 30% in lexical analysis.
Reference: <author> Aral, Ziya, Ilya Gertner, and Greg Schaffer. </author> <year> 1989 </year> <month> (May). </month> <title> Efficient debugging primitives for multiprocessors. </title> <booktitle> Proceedings of Third International Conference on Architectural Support for Programming Languages and Operating Systems, in a special issue of SIGPLAN Notices, </booktitle> <volume> 24 </volume> <pages> 87-95. </pages>
Reference-contexts: The DICE debugger cooperates with an incremental compiler as part of an integrated environment (Fritzson 1983). Even if the compiler and debugger are separate, the debugger may run in the same address space as the linker, sharing its data structures <ref> (Aral, Gertner, and Schaffer 1989) </ref>. Other debuggers, like VAX DEBUG (Beander 1983) and dbx (Linton 1990), are completely separate tools that communicate with both compiler and linker only through symbol-table information. <p> Other approaches to debugging support include system calls (Adams and Muchnick 1986), as depicted in Figure 1, controlling processes through the file system (Killian 1984), and running the target and debugger in 6 CHAPTER 1. INTRODUCTION the same address space <ref> (Aral, Gertner, and Schaffer 1989) </ref>. The relative merits of these approaches are discussed in Chapter 6. Work on the performance of debuggers for sequential programs has focussed on breakpoints. Two kinds of breakpoint implementations are in common use. <p> Both authors suggest that the best performance is obtained by code patching. Performance is more critical in debugging parallel programs, because perturbing the execution of a single processor may change the behavior of an entire program. In a parallel-programming environment, debugging work can be o*oaded onto a second processor <ref> (Aral, Gertner, and Schaffer 1989) </ref>. Alternatively, monitoring and logging can be done by a special-purpose coprocessor (Gorlick 1991). All these approaches use either branch or coprocessor instructions to transfer control from target to debugging code without kernel intervention, avoiding the overhead of trap handling and context switching.
Reference: <author> Balzer, Robert M. </author> <year> 1969. </year> <title> EXDAMS|EXtendable Debugging and Monitoring System. </title> <booktitle> In AFIPS Proceedings Spring Joint Computer Conference, </booktitle> <pages> pages 567-580, </pages> <address> Arlington, VA. </address> <publisher> AFIPS Press. </publisher>
Reference-contexts: An early debugger based on this technique ran the program to completion, then worked with the log to give the illusion of interactive debugging with time travel <ref> (Balzer 1969) </ref>. Logging cost can be reduced by taking periodic checkpoints; time travel is implemented by executing forward from a previous checkpoint.
Reference: <author> Bates, Peter C. and Jack C. Wileden. </author> <year> 1983 </year> <month> (December). </month> <title> High-level debugging of distributed systems: The behavioral abstraction approach. </title> <journal> Journal of Systems and Software, </journal> <volume> 3(4) </volume> <pages> 255-264. </pages> <note> 167 168 REFERENCES Baudinet, </note> <author> Marianne and David MacQueen. </author> <year> 1985 </year> <month> (December). </month> <title> Tree pattern matching for ML (extended abstract). </title> <type> Unpublished manuscript, </type> <institution> AT&T Bell Laboratories. </institution>
Reference: <author> Beander, Bert. </author> <year> 1983 </year> <month> (August). </month> <title> VAX DEBUG: An interactive, symbolic, multilingual debugger. </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging, in SIGPLAN Notices, </booktitle> <volume> 18(8) </volume> <pages> 173-179. </pages>
Reference-contexts: A debugger should work with programs written in more than one language. Each language has its own rules for resolving names, representing values, evaluating expressions, etc. Support for different languages may require re-implementation in the debugger <ref> (Beander 1983) </ref>. A debugger must be able to set breakpoints and to step through the execution of a program. Doing so may require information about the target's instruction set, for example to compute control-flow information. ldb solves only some of these problems. <p> Even if the compiler and debugger are separate, the debugger may run in the same address space as the linker, sharing its data structures (Aral, Gertner, and Schaffer 1989). Other debuggers, like VAX DEBUG <ref> (Beander 1983) </ref> and dbx (Linton 1990), are completely separate tools that communicate with both compiler and linker only through symbol-table information. <p> One unresolved question is how to manage name spaces different from C's, particularly in languages that support overloading. Support for multiple languages simultaneously is more difficult. Some debuggers require the user to choose a language <ref> (Beander 1983) </ref>; others identify symbols as belonging to a particular language (Linton 1990). Some procedures may belong to more than one language at a time, for example, a procedure might be written in a high-level language that is compiled to C, like Modula-3 or C++.
Reference: <author> Bentley, Jon. </author> <year> 1988. </year> <title> More Programming Pearls: Confessions of a Coder. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley. </publisher>
Reference-contexts: The cheapest, fastest, and most reliable parts of a computer system are those that aren't there. |Gordon Bell <ref> (Bentley 1988, page 62) </ref> 154 CHAPTER 10. RETARGETING LDB Chapter 11 Evaluation There is no single insight that makes it easy to implement a debugger; success is determined by the cumulative effect of many engineering decisions. This chapter reviews those decisions to judge which work and which do not.
Reference: <author> Birrell, Andrew D. </author> <year> 1991. </year> <title> An introduction to programming with threads. </title> <editor> In Nelson, Greg, editor, </editor> <title> Systems Programming with Modula-3, </title> <booktitle> chapter 4, </booktitle> <pages> pages 88-118. </pages> <address> Engle-wood Cliffs, NJ: </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: Modula-3 provides concurrency in the form of multiple threads. Threads are synchronized through the use of mutexes and condition variables <ref> (Birrell 1991) </ref>. Lampson and Redell (1980) describe a similar model of concurrency. When connected to a target program, ldb uses two threads; one responds to commands typed by the user, and one responds to events delivered from the debug nub. <p> Exceptions are usually handled by the user interface, which prints messages describing the problem. In Modula-3, it is common to define types with methods that are not implemented, for example, Thread.Closure <ref> (Birrell 1991, Section 4.3) </ref>. Correct programs do not create instances of such types; they create instances of proper subtypes, which implement the methods. There is no standard term used to refer to the supertypes that are used only to define subtypes, not to create objects.
Reference: <author> Brooks, Gary, Gilbert J. Hansen, and Steve Simmons. </author> <year> 1992 </year> <month> (July). </month> <title> A new approach to debugging optimized code. </title> <booktitle> ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 27(7) </volume> <pages> 1-11. </pages>
Reference-contexts: Other compilers and debuggers use stopping points placed at coarser and finer granularities, like source-line numbers (Linton 1990) and expressions <ref> (Brooks, Hansen, and Simmons 1992) </ref>. Figure 3 shows fib.c's stopping points. In each procedure, stopping points are numbered in order of increasing object-code location.
Reference: <author> Bruegge, Bernd. </author> <year> 1985 </year> <month> (September). </month> <title> Adaptability and Portability of Symbolic Debuggers. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University. </institution>
Reference-contexts: A debugger could also simulate the effect of the overwritten instruction and resume execution at the succeeding instruction. Finally, some machines have special hardware that supports resumption after a break instruction <ref> (Bruegge 1985) </ref>. The single-stepping implementation of a breakpoint must handle unexpected events. When the machine is single stepped, the debugger expects the target to execute one instruction and notify the debugger of its execution.
Reference: <author> Cargill, Thomas A. </author> <year> 1983 </year> <month> (August). </month> <title> The Blit debugger. </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging, in SIGPLAN Notices, </booktitle> <volume> 18(8) </volume> <pages> 190-200. </pages> . <year> 1986 </year> <month> (January). </month> <title> The feel of Pi. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 62-71, </pages> <address> Denver, </address> <publisher> CO. </publisher>
Reference-contexts: Although 160 CHAPTER 11. EVALUATION it is easy to argue in favor of many of these features, ldb's primary objective is to provide basic debugging in a retargetable way. The feature that its users miss most is source-code display, although other debuggers have been successful without implementing such display <ref> (Cargill 1983) </ref>. ldb's overall performance is worse than that of dbx or gdb, primarily because reading PostScript symbol tables is slow. As described in Section 4.7, ldb takes 5 to 15 seconds to start on programs of 10,000 to 100,000 lines.
Reference: <author> Caswell, Deborah and David Black. </author> <year> 1990 </year> <month> (January). </month> <title> Implementing a Mach debugger for multithreaded applications. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 25-39, </pages> <address> Washington, DC. </address>
Reference-contexts: The relative merits of these approaches are discussed in Chapter 6. Work on the performance of debuggers for sequential programs has focussed on breakpoints. Two kinds of breakpoint implementations are in common use. One is based on traps and single stepping <ref> (Caswell and Black 1990) </ref>, one on patching the code of the target program (Digital 1975). Kessler (1990) describes a fast implementation of code breakpoints; Wahbe (1992) describes simulations of four implementations of data breakpoints. Both authors suggest that the best performance is obtained by code patching. <p> Second, when execution is resumed, I must be executed once, but subsequent attempts to execute I must return control to the debugger. To get control at an instruction I, a debugger can overwrite I with a trap instruction, then handle the resulting trap <ref> (Caswell and Black 1990) </ref>, or it can overwrite I with an instruction that branches to debugging code (Digital 1975). To resume execution, there is a wider range of choices. <p> <ref> (Caswell and Black 1990) </ref>, or it can overwrite I with an instruction that branches to debugging code (Digital 1975). To resume execution, there is a wider range of choices. A debugger can return the overwritten instruction to memory, execute it by single stepping the target machine, and re-plant the breakpoint (Caswell and Black 1990). Single stepping can be avoided by transforming the overwritten instruction so that it can be correctly executed out of line (Digital 1975; Kessler 1990). A debugger could also simulate the effect of the overwritten instruction and resume execution at the succeeding instruction.
Reference: <author> Chow, Fred C. and John L. Hennessy. </author> <year> 1990 </year> <month> (October). </month> <title> The priority-based coloring approach to register allocation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 501-536. </pages>
Reference-contexts: To make ldb work with compilers that do move variables, the code would have to be reinstated. Moving variables is necessary to make best use of caller-save registers; variables may appear in different registers or in memory depending on the value of the program counter <ref> (Chow and Hennessy 1990) </ref>. Such changing locations could be computed easily by 4.7. DISCUSSION 55 PostScript procedures, provided that the program counter were included in the abstract memory available to the PostScript. <p> Generalizing ldb's current approach would be a mistake because the current approach assumes that registers are saved and restored at every call. Caller-save registers are more effective when some saves and restores can be eliminated, e.g., by splitting the live ranges of variables <ref> (Chow and Hennessy 1990) </ref>. For example, a variable may be moved from a register to memory and stay in memory over a span of several calls. When the variable is restored, it need not be restored to the register it occupied before the call.
Reference: <author> Clinger, William D. and Jonathan Rees. </author> <year> 1991 </year> <month> (July-September). </month> <title> Revised 4 report on the algorithmic language Scheme. LISP Pointers, </title> <publisher> IV(3):1-55. </publisher>
Reference-contexts: One advantage of using an interpreted language is that it provides a representation that is easy for people to read and for tools to manipulate; bytecode and machine code are inappropriate. Designing a new language is best avoided, so I considered PostScript, Scheme <ref> (Clinger and Rees 1991) </ref>, FORTH (Moore 1974), and Tcl (Ousterhout 1990). The latter two offer too few data types. Although most of the benefits of using PostScript would also be obtained with Scheme, there are a number of reasons to prefer PostScript.
Reference: <author> Clinger, William D. </author> <year> 1990 </year> <month> (June). </month> <title> How to read floating-point numbers accurately. </title> <booktitle> Proceedings of the SIGPLAN'90 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 25(6) </volume> <pages> 92-101. </pages>
Reference: <author> Cormack, Gordon V. </author> <year> 1988 </year> <month> (May). </month>
Reference-contexts: The effect is to branch to DebugNub_saveregs, which saves the remaining registers. This technique makes the nub independent of the undocumented format that the kernel uses to save the registers on the user stack <ref> (Cormack 1988) </ref>. The definition of save_pc for the 68020 is #define save_pc (PC) (DebugNub_context.pc = (PC)) The implementation of DebugNub_saveregs uses the 68020's moveml instruction to save the data and address registers and fmovemx to save the floating-point registers. <p> The other operating systems save this state in user space, but they do not make all of it accessible to signal handlers. I can identify no technical reason why not. Such access would simplify ldb's debug nub, as well as other applications that need the state, like user-level threads <ref> (Cormack 1988) </ref>. In addition to the PostScript interpreter, some of the techniques used in ldb should have applications beyond debugging.
Reference: <editor> A micro-kernel for concurrency in C. </editor> <booktitle> Software|Practice & Experience, </booktitle> <volume> 18(5) </volume> <pages> 485-491. </pages> <note> REFERENCES 169 Crawford, </note> <author> Richard H., Ronald A. Olsson, W. Wilson Ho, and Christopher E. Wee. </author> <year> 1992 </year> <month> (April). </month> <title> Semantic issues in the design of languages for debugging. </title> <booktitle> In Proceedings of the International Conference on Computer Languages, </booktitle> <pages> pages 252-261, </pages> <address> Oak-land, CA. </address>
Reference-contexts: Chapter 11 identifies good and bad aspects of ldb's design, makes some suggestions about designing related tools, discusses how the techniques might be used elsewhere, and suggests some directions for future research. The reader familiar with an earlier version of ldb <ref> (Ramsey and Hanson 1992) </ref> is directed especially to Sections 6.4.1 and 7.6, which describe how ldb calls procedures in the target, to Chapter 7, which describes more general breakpoints, and to Chapter 8, which describes a model of stack-frame layout used to eliminate some machine-dependent stack-walking code. 10 CHAPTER 1. <p> Other compilers and debuggers use stopping points placed at coarser and finer granularities, like source-line numbers (Linton 1990) and expressions <ref> (Brooks, Hansen, and Simmons 1992) </ref>. Figure 3 shows fib.c's stopping points. In each procedure, stopping points are numbered in order of increasing object-code location. <p> debug nub strips special arguments like --pause-- so they are not visible to the user's program, as I can see by looking at argv. ldb fib (stopped) &gt; p argv [0] char * argv [0] = (0xf7fffa84) "fib" ldb fib (stopped) &gt; p argv [1] char * argv [1] = <ref> (0xf7fffa92) </ref> "12" ldb fib (stopped) &gt; p argv [2] char * argv [2] = (null) ldb fib (stopped) &gt; The p command prints the result of evaluating an expression. <p> PRINTING VALUES 47 The placement of elements on the page is computed by a prettyprinter supplied with the Modula-3 library <ref> (Kalsow and Muller 1992) </ref>. The prettyprinter's procedures are available as PostScript operators, and the printing procedures use these operators to print text. <p> The increase in symbol-table size varies widely with the program. The table for lcc, a large program that uses few library procedures, is only 5% larger with external symbols 4.7. DISCUSSION 53 included. The table for agrep, a 6,000-line string matcher <ref> (Wu and Manber 1992) </ref>, is 46% larger. The table for notangle, a 600-line macro processor (Ramsey 1992), is 3.5 times larger. lcc's standard implementation of the symbol-table functions, which supports dbx, is about 300 lines of C. The support for ldb is about 1,000 lines. <p> The table for lcc, a large program that uses few library procedures, is only 5% larger with external symbols 4.7. DISCUSSION 53 included. The table for agrep, a 6,000-line string matcher (Wu and Manber 1992), is 46% larger. The table for notangle, a 600-line macro processor <ref> (Ramsey 1992) </ref>, is 3.5 times larger. lcc's standard implementation of the symbol-table functions, which supports dbx, is about 300 lines of C. The support for ldb is about 1,000 lines. <p> More ambitious linkers might take over some of the work done by the compiler, for example determining the locations of all variables at link time <ref> (Wall 1992) </ref>. Supporting such linkers might require extensions to the existing linker state, not just a re-implementation, although the existing implementation can be used if the linker can be modified to generate both a linker table and a top-level dictionary. <p> I/O accounts for only 26% of the added time. Overhead is higher for lcc because lcc uses a large header file containing many type definitions that must appear in the symbol table. When lcc compiles noweb, a 1000-line literate-programming tool <ref> (Ramsey 1992) </ref>, compilation time 56 CHAPTER 4. POSTSCRIPT SYMBOL TABLES increases by 80%; the corresponding increase for stabs is 13%. I/O accounts for only 37% of the added time. <p> If the language were polymorphic, such functions could be used with data structures of different types. An extended language could include operations that control the debugger, such as planting or removing breakpoints or stopping for a dialog with the user <ref> (Crawford et al. 1992) </ref>. <p> Typically the file can be read or written to manipulate the target's address space; other operations are performed using the ioctl system call. The Plan 9 operating system provides similar support, except that it uses a collection of files for control, instead of ioctl operations on a single file <ref> (Pike et al. 1992) </ref>. Because Plan 9 can mount such files remotely, they form a remote-debugging facility. If ldb used existing run-time support for debugging, the accidental differences in support between machines and vendors would introduce unnecessary retargeting effort. Adding machine-independent support to existing kernels might be even more burdensome. <p> TTD has demonstrated that a datagram-oriented network interface is suitable. An interface representing processes as files would also be suitable, provided those files could be mounted remotely on other computers, as in Plan 9 <ref> (Pike et al. 1992) </ref>. The cost of interacting with the nub can be measured by having ldb interpret a PostScript procedure that fetches from the same location 1000 times; each fetch requires one request and one reply. <p> Since the PostScript code that calls procedures is generated by the expression-evaluation server, such a solution is tantamount to requiring the expression server to use continuation-passing style <ref> (Appel 1992) </ref>, which would complicate its implementation. ldb hides the necessary event handlers, making the PostScript procedure-call operator look like any other operator: it can complete execution normally by returning a value, or it can fail by raising an exception. <p> For example, ldb's user-level events could correspond to the "primitive events" input to a dataflow machine (Olsson, Crawford, and Ho 1991). It might be useful to formalize the semantics of ldb's breakpoint commands using a language designed to describe debugging <ref> (Crawford et al. 1992) </ref>. A formal definition would provide a basis on 7.7. DISCUSSION 109 which to judge the correctness of other implementations of the commands. <p> For each call site, the compiler may make non-preserved registers either saved by caller or scratch. The official calling sequences for ldb's four targets do not prescribe treatment for registers saved by callers. lcc may spill temporary registers across calls <ref> (Fraser and Hanson 1992) </ref>, but it never places source-level variables in such registers, so ldb can present a complete source-level view of a stack frame without restoring them. The register classifications are used to subdivide the machine-dependent parts of stack walking. <p> Restricted calling sequences need not degrade performance; DEC has a calling sequence that meets these requirements without affecting performance <ref> (Digital 1992, Section 3) </ref>. The SPARC keeps information about saved registers both on the stack and in register windows. In general, the SPARC process context includes the state of some number of register windows, a number given by the operating system when it delivers a signal. <p> RETARGETING LDB Calling sequences can be specified to make stack-walking easy <ref> (Digital 1992) </ref>. Such specifications have two characteristics: they identify every kind of frame that might appear on the stack, and they place restrictions on entry and exit sequences so the intermediate states discussed in Section 8.4 can easily be identified. <p> It is most often used for debugging C programs of about 10,000 lines, including lcc, the expression server, and an experimental linker <ref> (Fernandez, Fraser, and Hanson 1992) </ref>. It is also used to debug itself. The features that its users like best are the abilities to connect to a running process and to continue debugging that process even if the debugger fails (Chapter 6). <p> A more reasonable solution to the problem of intermediate states in procedure calls is to restrict calling sequences and instruction scheduling to make it easy to identify the steps <ref> (Digital 1992) </ref>. Such restrictions need not have an adverse impact on performance. The retargeting cost could be further reduced by having compilers emit labels identifying the steps. The implementation should follow the strategy ldb uses for register-save information.
Reference: <author> DeTreville, John. </author> <year> 1986 </year> <month> (March). </month> <title> Designing Loupe: A Modula-2+ debugger. </title> <type> Unpublished manuscript, </type> <institution> DEC Systems Research Center. Digital Equipment Corporation. </institution> <year> 1975. </year> <title> DDT|Dynamic Debugging Technique. </title> <institution> Maynard, MA. Digital Equipment Corporation. </institution> <year> 1992 </year> <month> (October). </month> <title> Open VMS Calling Standard. Order Number AA-PQY2A-TK. </title> <address> Maynard, MA. </address>
Reference-contexts: The cost of the change was slight; some PostScript procedures, as shown in Section 4.4, must now sign-extend integer values before using them. ldb's locations are similar to but simpler than the "locatives" provided by DEC SRC's Loupe debugger for Modula-2+ <ref> (DeTreville 1986) </ref>. Locatives include a length as well as a location, and they use bit-level rather than byte-level granularity.
Reference: <author> Ellis, Margaret A. and Bjarne Stroustrup. </author> <year> 1990. </year> <title> The Annotated C++ Reference Manual. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley. </publisher>
Reference-contexts: Implementors of debuggers are not the only ones to benefit from careful specification of calling sequences. Stack walking can be used to implement exception handling in languages like C++ <ref> (Ellis and Stroustrup 1990) </ref>, Ada (US DoD 1983) and Modula-3, which permit any active procedure to handle an exception.
Reference: <author> Feldman, Stuart I. and Channing B. Brown. </author> <year> 1988 </year> <month> (May). </month> <title> IGOR: A system for program debugging via reversible execution. </title> <booktitle> Proceedings of the ACM SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, in SIGPLAN Notices, </booktitle> <volume> 24(1) </volume> <pages> 112-123. </pages>
Reference-contexts: Logging cost can be reduced by taking periodic checkpoints; time travel is implemented by executing forward from a previous checkpoint. The compiler may transform the source to generate appropriate checkpointing code (Tolmach and Appel 1990), or the checkpointing may be done by the run-time system, using virtual memory operations <ref> (Feldman and Brown 1988) </ref>. In addition to checkpointing internal state, the program may have to log significant external events like input. Recent work on parallel and distributed debugging emphasizes program visualization and event matching as well as time travel (Miller and LeBlanc 1988; Miller and McDowell 1991).
Reference: <author> Fernandez, Mary F., Christopher W. Fraser, and David R. Hanson. </author> <year> 1992 </year> <month> (November). </month> <title> Retargetable link-time code generation. </title> <type> Unpublished manuscript, </type> <institution> Department of Computer Science, Princeton University. </institution>
Reference-contexts: It is most often used for debugging C programs of about 10,000 lines, including lcc, the expression server, and an experimental linker <ref> (Fernandez, Fraser, and Hanson 1992) </ref>. It is also used to debug itself. The features that its users like best are the abilities to connect to a running process and to continue debugging that process even if the debugger fails (Chapter 6).
Reference: <author> Fraser, Christopher W. and David R. Hanson. </author> <year> 1982 </year> <month> (April). </month> <title> A machine-independent linker. </title> <journal> Software|Practice & Experience, </journal> <volume> 12(4) </volume> <pages> 351-366. </pages> . <year> 1991a </year> <month> (September). </month>
Reference-contexts: The executable file is sufficient because debugging information is read-only. If a machine-independent linker were used, such access could be done without machine-dependent code <ref> (Fraser and Hanson 1982) </ref>. Even if standard, machine-dependent formats were used, the gain in efficiency might warrant the extra retargeting effort. One potential benefit of putting special support in the linker is that debugging information could be encoded more compactly.
Reference: <editor> A code generation interface for ANSI C. </editor> <booktitle> Software|Practice & Experience, </booktitle> <volume> 21(9) </volume> <pages> 963-988. </pages> . <year> 1991b </year> <month> (October). </month>
Reference-contexts: This thesis describes techniques for building retargetable debuggers. These techniques are used in the design and implementation of ldb, a prototype retargetable debugger. ldb is a source-level debugger like gdb or dbx (Linton 1990). It can be used with C programs compiled with lcc <ref> (Fraser and Hanson 1991b) </ref>, a retargetable compiler that generates code for the MIPS, Motorola 68020, SPARC, and VAX architectures. Like gdb and dbx, ldb lets users set and remove breakpoints, start and stop programs, evaluate expressions, and make assignments to variables. <p> MIPS lcc does not generate dbx symbol-table information, so times cannot be compared to those for dbx. lcc is faster than many other C compilers <ref> (Fraser and Hanson 1991b) </ref>, so the relative costs of generating PostScript symbol tables might be lower if a different compiler were used. The savings realized by lazy top-level dictionaries varies with the size of the program.
Reference: <editor> A retargetable compiler for ANSI C. </editor> <booktitle> SIGPLAN Notices, </booktitle> <volume> 26(10) </volume> <pages> 29-43. </pages> . <year> 1992 </year> <month> (January). </month> <title> Simple register spilling in a retargetable compiler. </title> <journal> Software|Practice & Experience, </journal> 22(1):85-99. 
Reference-contexts: Chapter 11 identifies good and bad aspects of ldb's design, makes some suggestions about designing related tools, discusses how the techniques might be used elsewhere, and suggests some directions for future research. The reader familiar with an earlier version of ldb <ref> (Ramsey and Hanson 1992) </ref> is directed especially to Sections 6.4.1 and 7.6, which describe how ldb calls procedures in the target, to Chapter 7, which describes more general breakpoints, and to Chapter 8, which describes a model of stack-frame layout used to eliminate some machine-dependent stack-walking code. 10 CHAPTER 1. <p> Other compilers and debuggers use stopping points placed at coarser and finer granularities, like source-line numbers (Linton 1990) and expressions <ref> (Brooks, Hansen, and Simmons 1992) </ref>. Figure 3 shows fib.c's stopping points. In each procedure, stopping points are numbered in order of increasing object-code location. <p> debug nub strips special arguments like --pause-- so they are not visible to the user's program, as I can see by looking at argv. ldb fib (stopped) &gt; p argv [0] char * argv [0] = (0xf7fffa84) "fib" ldb fib (stopped) &gt; p argv [1] char * argv [1] = <ref> (0xf7fffa92) </ref> "12" ldb fib (stopped) &gt; p argv [2] char * argv [2] = (null) ldb fib (stopped) &gt; The p command prints the result of evaluating an expression. <p> PRINTING VALUES 47 The placement of elements on the page is computed by a prettyprinter supplied with the Modula-3 library <ref> (Kalsow and Muller 1992) </ref>. The prettyprinter's procedures are available as PostScript operators, and the printing procedures use these operators to print text. <p> The increase in symbol-table size varies widely with the program. The table for lcc, a large program that uses few library procedures, is only 5% larger with external symbols 4.7. DISCUSSION 53 included. The table for agrep, a 6,000-line string matcher <ref> (Wu and Manber 1992) </ref>, is 46% larger. The table for notangle, a 600-line macro processor (Ramsey 1992), is 3.5 times larger. lcc's standard implementation of the symbol-table functions, which supports dbx, is about 300 lines of C. The support for ldb is about 1,000 lines. <p> The table for lcc, a large program that uses few library procedures, is only 5% larger with external symbols 4.7. DISCUSSION 53 included. The table for agrep, a 6,000-line string matcher (Wu and Manber 1992), is 46% larger. The table for notangle, a 600-line macro processor <ref> (Ramsey 1992) </ref>, is 3.5 times larger. lcc's standard implementation of the symbol-table functions, which supports dbx, is about 300 lines of C. The support for ldb is about 1,000 lines. <p> More ambitious linkers might take over some of the work done by the compiler, for example determining the locations of all variables at link time <ref> (Wall 1992) </ref>. Supporting such linkers might require extensions to the existing linker state, not just a re-implementation, although the existing implementation can be used if the linker can be modified to generate both a linker table and a top-level dictionary. <p> I/O accounts for only 26% of the added time. Overhead is higher for lcc because lcc uses a large header file containing many type definitions that must appear in the symbol table. When lcc compiles noweb, a 1000-line literate-programming tool <ref> (Ramsey 1992) </ref>, compilation time 56 CHAPTER 4. POSTSCRIPT SYMBOL TABLES increases by 80%; the corresponding increase for stabs is 13%. I/O accounts for only 37% of the added time. <p> If the language were polymorphic, such functions could be used with data structures of different types. An extended language could include operations that control the debugger, such as planting or removing breakpoints or stopping for a dialog with the user <ref> (Crawford et al. 1992) </ref>. <p> Typically the file can be read or written to manipulate the target's address space; other operations are performed using the ioctl system call. The Plan 9 operating system provides similar support, except that it uses a collection of files for control, instead of ioctl operations on a single file <ref> (Pike et al. 1992) </ref>. Because Plan 9 can mount such files remotely, they form a remote-debugging facility. If ldb used existing run-time support for debugging, the accidental differences in support between machines and vendors would introduce unnecessary retargeting effort. Adding machine-independent support to existing kernels might be even more burdensome. <p> TTD has demonstrated that a datagram-oriented network interface is suitable. An interface representing processes as files would also be suitable, provided those files could be mounted remotely on other computers, as in Plan 9 <ref> (Pike et al. 1992) </ref>. The cost of interacting with the nub can be measured by having ldb interpret a PostScript procedure that fetches from the same location 1000 times; each fetch requires one request and one reply. <p> Since the PostScript code that calls procedures is generated by the expression-evaluation server, such a solution is tantamount to requiring the expression server to use continuation-passing style <ref> (Appel 1992) </ref>, which would complicate its implementation. ldb hides the necessary event handlers, making the PostScript procedure-call operator look like any other operator: it can complete execution normally by returning a value, or it can fail by raising an exception. <p> For example, ldb's user-level events could correspond to the "primitive events" input to a dataflow machine (Olsson, Crawford, and Ho 1991). It might be useful to formalize the semantics of ldb's breakpoint commands using a language designed to describe debugging <ref> (Crawford et al. 1992) </ref>. A formal definition would provide a basis on 7.7. DISCUSSION 109 which to judge the correctness of other implementations of the commands. <p> For each call site, the compiler may make non-preserved registers either saved by caller or scratch. The official calling sequences for ldb's four targets do not prescribe treatment for registers saved by callers. lcc may spill temporary registers across calls <ref> (Fraser and Hanson 1992) </ref>, but it never places source-level variables in such registers, so ldb can present a complete source-level view of a stack frame without restoring them. The register classifications are used to subdivide the machine-dependent parts of stack walking. <p> Restricted calling sequences need not degrade performance; DEC has a calling sequence that meets these requirements without affecting performance <ref> (Digital 1992, Section 3) </ref>. The SPARC keeps information about saved registers both on the stack and in register windows. In general, the SPARC process context includes the state of some number of register windows, a number given by the operating system when it delivers a signal. <p> RETARGETING LDB Calling sequences can be specified to make stack-walking easy <ref> (Digital 1992) </ref>. Such specifications have two characteristics: they identify every kind of frame that might appear on the stack, and they place restrictions on entry and exit sequences so the intermediate states discussed in Section 8.4 can easily be identified. <p> It is most often used for debugging C programs of about 10,000 lines, including lcc, the expression server, and an experimental linker <ref> (Fernandez, Fraser, and Hanson 1992) </ref>. It is also used to debug itself. The features that its users like best are the abilities to connect to a running process and to continue debugging that process even if the debugger fails (Chapter 6). <p> A more reasonable solution to the problem of intermediate states in procedure calls is to restrict calling sequences and instruction scheduling to make it easy to identify the steps <ref> (Digital 1992) </ref>. Such restrictions need not have an adverse impact on performance. The retargeting cost could be further reduced by having compilers emit labels identifying the steps. The implementation should follow the strategy ldb uses for register-save information.
Reference: <author> Fritzson, Peter. </author> <year> 1983 </year> <month> (December). </month> <title> Symbolic debugging through incremental compilation in an integrated environment. </title> <journal> Journal of Systems and Software, </journal> <volume> 3(4) </volume> <pages> 285-294. </pages>
Reference-contexts: In some experimental systems, the compiler and debugger are tightly coupled. DEC SRC's Vulcan debugger executes in the same address space as the compiler, sharing its annotated abstract syntax trees. The DICE debugger cooperates with an incremental compiler as part of an integrated environment <ref> (Fritzson 1983) </ref>. Even if the compiler and debugger are separate, the debugger may run in the same address space as the linker, sharing its data structures (Aral, Gertner, and Schaffer 1989). <p> Another approach to expression evaluation uses the original compiler to translate the expression into machine code, places the code in the target address space, and executes it <ref> (Fritzson 1983) </ref>. This approach guarantees that the debugger and compiler implement the same language, and it avoids interpretation.
Reference: <author> Golan, Michael and David R. Hanson. </author> <year> 1993 </year> <month> (January). </month> <title> DUEL | A very high-level debugging language. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 109-120, </pages> <address> San Diego, CA. </address>
Reference-contexts: Work not related to displays has considered programmable user interfaces, simplifying the manipulation and exploration of target events (Olsson, Crawford, and Ho 1991) and of target data <ref> (Golan and Hanson 1993) </ref>. The problem of debugging optimized code has been addressed from several viewpoints.
Reference: <author> Gorlick, Michael M. </author> <year> 1991 </year> <month> (December). </month> <title> The flight recorder: An architectural aid for system monitoring. </title> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, in SIGPLAN Notices, </booktitle> <volume> 26(12) </volume> <pages> 175-183. </pages> <address> 170 REFERENCES Gramlich, Wayne C. </address> <year> 1983 </year> <month> (August). </month> <title> Debugging methodology (session summary). </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging, in SIGPLAN Notices, </booktitle> 18(8):1-3. 
Reference-contexts: In a parallel-programming environment, debugging work can be o*oaded onto a second processor (Aral, Gertner, and Schaffer 1989). Alternatively, monitoring and logging can be done by a special-purpose coprocessor <ref> (Gorlick 1991) </ref>. All these approaches use either branch or coprocessor instructions to transfer control from target to debugging code without kernel intervention, avoiding the overhead of trap handling and context switching. The authors with working implementations describe performance improvements of three orders of magnitude.
Reference: <author> Griswold, Ralph E. and Madge T. Griswold. </author> <year> 1990. </year> <title> The Icon Programming Language. Second edition. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: The bottom of the table shows the sizes of the generators used to transform instruction specifications and PostScript operator specifications into Modula-3 code, as described in Appendix B and Section 9.1.2. The generators are written in Icon <ref> (Griswold and Griswold 1990) </ref>. expensive on the MIPS. The MIPS calling sequence uses no frame pointer, so it impossible to walk the stack unless the frame size of each procedure is known.
Reference: <author> Hennessy, John L. </author> <year> 1982 </year> <month> (July). </month> <title> Symbolic debugging of optimized code. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(4) </volume> <pages> 323-344. </pages>
Reference: <author> Holzmann, Gerard J. </author> <year> 1991. </year> <title> Design and Validation of Computer Protocols. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall. Intel Corporation. </publisher> <year> 1986 </year> <month> (April). </month> <title> 80386 data sheet. </title> <address> Santa Clara, CA. </address>
Reference-contexts: The same lock prevents race conditions on the nub, which might be caused by two different threads trying to fetch at the same time, for example. 82 CHAPTER 6. THE DEBUG NUB The message level of the nub protocol is described by a PROMELA specification <ref> (Holzmann 1991) </ref>. PROMELA tools have been used to validate the protocol, making sure that neither side ever sends a message that the other is not expecting. 6.3 Illustrating the nub protocol The debugger's first interaction with the nub illustrates the nub protocol.
Reference: <author> Kalsow, Bill and Eric Muller. </author> <year> 1992 </year> <month> (June). </month> <note> SRC Modula-3. DEC Systems Research Center. Version 2.07. Available by anonymous ftp from Internet host gatekeeper.dec.com. </note>
Reference-contexts: PRINTING VALUES 47 The placement of elements on the page is computed by a prettyprinter supplied with the Modula-3 library <ref> (Kalsow and Muller 1992) </ref>. The prettyprinter's procedures are available as PostScript operators, and the printing procedures use these operators to print text.
Reference: <author> Kane, Gerry. </author> <year> 1988. </year> <title> MIPS RISC Architecture. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: On the MIPS, such a pointer is the first argument to the function: #define STORE_CALLB (RES) (argbuild [0] = RES) PREPARE CALL (mdata) is used only on the MIPS, which requires that the first two arguments be passed in floating-point registers when they are of floating types <ref> (Kane 1988, page D-22) </ref>. mdata encodes the types of the first two arguments. PREPARE CALL takes 10 lines of C with asm (...) to decode mdata and to put the arguments in the right registers. REGISTER ARGS is a list of the arguments passed in registers.
Reference: <author> Kessler, Peter B. </author> <year> 1990 </year> <month> (June). </month> <title> Fast breakpoints: </title> <booktitle> Design and implementation. Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 25(6) </volume> <pages> 78-84. </pages>
Reference: <author> Killian, T. J. </author> <year> 1984. </year> <title> Processes as files. </title> <booktitle> In Proceedings of the Summer USENIX Conference, </booktitle> <pages> pages 203-207, </pages> <address> Salt Lake City. </address>
Reference-contexts: Topaz provides completely reliable, available debugging support; Section 6.5 compares it and ldb. Other approaches to debugging support include system calls (Adams and Muchnick 1986), as depicted in Figure 1, controlling processes through the file system <ref> (Killian 1984) </ref>, and running the target and debugger in 6 CHAPTER 1. INTRODUCTION the same address space (Aral, Gertner, and Schaffer 1989). The relative merits of these approaches are discussed in Chapter 6. Work on the performance of debuggers for sequential programs has focussed on breakpoints. <p> A third approach uses special files to support debugging. These files, one for each running process, usually appear in a directory called /proc; the debugger opens a file and then uses normal file-system operations to control the process <ref> (Killian 1984) </ref>. Typically the file can be read or written to manipulate the target's address space; other operations are performed using the ioctl system call.
Reference: <author> Knuth, Donald E. </author> <year> 1973. </year> <booktitle> The Art of Computer Programming. Volume 1, Fundamental Algorithms. Second edition. </booktitle> <address> Reading, MA: </address> <publisher> Addison-Wesley. </publisher>
Reference: <author> Lampson, Butler W. and David D. Redell. </author> <year> 1980 </year> <month> (February). </month> <title> Experience with processes and monitors in Mesa. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 105-117. </pages>
Reference: <author> Larus, James R. </author> <year> 1990 </year> <month> (September). </month> <title> SPIM S20: A MIPS R2000 simulator. </title> <type> Technical Report 966, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI. </institution>
Reference: <author> Leblang, David B. and Robert P. Chase, J. </author> <year> 1984 </year> <month> (May). </month> <title> Computer-aided software engineering in a distributed workstation environment. </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Symposium on Practical Software Development Environments, in SIGPLAN Notices, </booktitle> <volume> 19(5) </volume> <pages> 104-112. </pages> <note> REFERENCES 171 Linton, </note> <author> Mark A. </author> <year> 1990 </year> <month> (June). </month> <title> The evolution of Dbx. </title> <booktitle> In Proceedings of the Summer USENIX Conference, </booktitle> <pages> pages 211-220, </pages> <address> Anaheim, CA. </address>
Reference-contexts: If 54 CHAPTER 4. POSTSCRIPT SYMBOL TABLES ldb is compiled for use with dbx, the relocation and debugging symbols occupy twice as much space as the object code. If reliable configuration management is available <ref> (Leblang and Chase 1984) </ref>, debugging information can safely be stored in separate files. Despite current practice, debugging information could be put in the object code without requiring special support in the linker.
Reference: <author> Liskov, Barbara H. and Alan Snyder. </author> <year> 1979 </year> <month> (November). </month> <title> Exception handling in CLU. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5(6):546-558. </volume> <editor> Miller, Barton and Thomas LeBlanc, editors. </editor> <year> 1988 </year> <month> (May). </month> <booktitle> ACM SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging. Available as SIGPLAN Notices 24(1), </booktitle> <month> January, </month> <year> 1989. </year> <editor> Miller, Barton and Charles McDowell, editors. </editor> <year> 1991 </year> <month> (May). </month> <booktitle> ACM/ONR Workshop on Parallel and Distributed Debugging. Available as SIGPLAN Notices 26(12), </booktitle> <month> December, </month> <year> 1991. </year> <institution> MIPS Computer Systems. </institution> <year> 1989 </year> <month> (May). </month> <title> MIPS Assembly Language Programmer's Guide. </title> <address> Mountain View, CA. </address>
Reference: <author> Moore, C. H. </author> <year> 1974. </year> <title> FORTH: A new way to program a mini-computer. </title> <journal> Astron. Astrophys. </journal> <volume> Suppl., 15 </volume> <pages> 497-511. </pages>
Reference-contexts: REPRESENTING DEBUGGING INFORMATION IN POSTSCRIPT 37 4.1 Representing debugging information in PostScript ldb uses PostScript (Adobe 1985) to represent symbol-table information. Although PostScript is a language for printers, it has no linguistic support for printing and imaging; it is a general-purpose, stack-based programming language similar in spirit to FORTH <ref> (Moore 1974) </ref>. The printing and imaging support comes from an extensive collection of built-in operators. The software on graphics workstations is analogous; the hardware provides special operations to support graphics, but there is no linguistic support for graphics. <p> One advantage of using an interpreted language is that it provides a representation that is easy for people to read and for tools to manipulate; bytecode and machine code are inappropriate. Designing a new language is best avoided, so I considered PostScript, Scheme (Clinger and Rees 1991), FORTH <ref> (Moore 1974) </ref>, and Tcl (Ousterhout 1990). The latter two offer too few data types. Although most of the benefits of using PostScript would also be obtained with Scheme, there are a number of reasons to prefer PostScript.
Reference: <author> Myers, Brad Allan. </author> <year> 1980 </year> <month> (June). </month> <title> Displaying data structures for interactive debugging. </title> <type> Technical Report CSL-80-7, </type> <institution> Xerox PARC, </institution> <address> Palo Alto, </address> <publisher> CA. </publisher> <editor> Nelson, Greg, editor. </editor> <year> 1991. </year> <title> Systems Programming with Modula-3. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: Other possibilities are to use the display to draw pictures of the data structures in the target program <ref> (Myers 1980) </ref> or to visualize the execution of the target program (Miller and McDowell 1991, Session 2). Work not related to displays has considered programmable user interfaces, simplifying the manipulation and exploration of target events (Olsson, Crawford, and Ho 1991) and of target data (Golan and Hanson 1993). <p> Such a facility would be helpful to a user trying to write a specialized printing procedure for a complex linked data structure, for example. The fast turnaround provided by interpretation would be equally helpful if data were displayed using another method, for example by drawing pictures on the screen <ref> (Myers 1980) </ref>. Picture-drawing procedures could be put into PostScript using the compact operator specifications shown above, and the standalone PostScript interpreter could be used interactively to experiment with ways of displaying data.
Reference: <author> Olsson, Ronald A., Richard H. Crawford, and W. Wilson Ho. </author> <year> 1991 </year> <month> (February). </month> <title> A dataflow approach to event-based debugging. </title> <journal> Software|Practice & Experience, </journal> <volume> 21(2) </volume> <pages> 209-229. </pages>
Reference-contexts: Work not related to displays has considered programmable user interfaces, simplifying the manipulation and exploration of target events <ref> (Olsson, Crawford, and Ho 1991) </ref> and of target data (Golan and Hanson 1993). The problem of debugging optimized code has been addressed from several viewpoints. <p> For example, ldb's user-level events could correspond to the "primitive events" input to a dataflow machine <ref> (Olsson, Crawford, and Ho 1991) </ref>. It might be useful to formalize the semantics of ldb's breakpoint commands using a language designed to describe debugging (Crawford et al. 1992). A formal definition would provide a basis on 7.7. DISCUSSION 109 which to judge the correctness of other implementations of the commands. <p> It can be used as a basis for improving the way debugging is done. Many improvements proposed for debugging would be considered part of ldb's user interface, including direct-manipulation interfaces (Cargill 1986; Russell 1992) and programmability and support for events <ref> (Olsson, Crawford, and Ho 1991) </ref>. ldb is designed to debug more than one process simultaneously, although the current user interface can manipulate at most one at a time.
Reference: <author> Oppen, Derek C. </author> <year> 1980 </year> <month> (October). </month> <title> Prettyprinting. </title> <journal> ACM Transacations on Programming Languages and Systems, </journal> <volume> 2(4) </volume> <pages> 465-483. </pages>
Reference-contexts: The expression-server code converts types and symbols to a representation as a stream of C tokens. I used ldb's PostScript interpreter interactively to debug the code, experimenting until it was producing the stream of tokens I expected. ldb uses a prettyprinter to print values <ref> (Oppen 1980) </ref>. Because the prettyprinter uses a backtracking algorithm to produce output, it is difficult to predict the output's appearance. Recompiling, re-linking, and restarting the debugger after each change in the prettyprinting procedures would have been unacceptably slow.
Reference: <author> Ousterhout, John K. </author> <year> 1990 </year> <month> (January). </month> <title> Tcl: An embeddable command language. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 133-146, </pages> <address> Washington, DC. </address>
Reference-contexts: Designing a new language is best avoided, so I considered PostScript, Scheme (Clinger and Rees 1991), FORTH (Moore 1974), and Tcl <ref> (Ousterhout 1990) </ref>. The latter two offer too few data types. Although most of the benefits of using PostScript would also be obtained with Scheme, there are a number of reasons to prefer PostScript. <p> STRENGTHS 157 It might be useful for a debugger to send an editor a command that displays a particular source location, for example. A similar role has been proposed for Tcl <ref> (Ousterhout 1990) </ref>, but Tcl has only one data type, the string. Tcl has awkward quoting conventions because of its dual roles as programming language and interactive command language. PostScript has a richer set of types, and its postfix syntax is easy for programs to generate.
Reference: <author> Pike, Rob, Dave Presotto, Ken Thompson, Howard Trickey, and Phil Winterbottom. </author> <year> 1992 </year> <month> (Septem-ber). </month> <title> The use of name spaces in Plan 9. </title> <booktitle> In SIGOPS European Workshop on Distributed Systems, </booktitle> <address> Mont Saint-Michel. </address>
Reference-contexts: Typically the file can be read or written to manipulate the target's address space; other operations are performed using the ioctl system call. The Plan 9 operating system provides similar support, except that it uses a collection of files for control, instead of ioctl operations on a single file <ref> (Pike et al. 1992) </ref>. Because Plan 9 can mount such files remotely, they form a remote-debugging facility. If ldb used existing run-time support for debugging, the accidental differences in support between machines and vendors would introduce unnecessary retargeting effort. Adding machine-independent support to existing kernels might be even more burdensome. <p> TTD has demonstrated that a datagram-oriented network interface is suitable. An interface representing processes as files would also be suitable, provided those files could be mounted remotely on other computers, as in Plan 9 <ref> (Pike et al. 1992) </ref>. The cost of interacting with the nub can be measured by having ldb interpret a PostScript procedure that fetches from the same location 1000 times; each fetch requires one request and one reply.
Reference: <author> Ramsey, Norman and David R. Hanson. </author> <year> 1992 </year> <month> (July). </month> <title> A retargetable debugger. </title> <booktitle> ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 27(7) </volume> <pages> 22-31. </pages>
Reference-contexts: Chapter 11 identifies good and bad aspects of ldb's design, makes some suggestions about designing related tools, discusses how the techniques might be used elsewhere, and suggests some directions for future research. The reader familiar with an earlier version of ldb <ref> (Ramsey and Hanson 1992) </ref> is directed especially to Sections 6.4.1 and 7.6, which describe how ldb calls procedures in the target, to Chapter 7, which describes more general breakpoints, and to Chapter 8, which describes a model of stack-frame layout used to eliminate some machine-dependent stack-walking code. 10 CHAPTER 1. <p> The table for lcc, a large program that uses few library procedures, is only 5% larger with external symbols 4.7. DISCUSSION 53 included. The table for agrep, a 6,000-line string matcher (Wu and Manber 1992), is 46% larger. The table for notangle, a 600-line macro processor <ref> (Ramsey 1992) </ref>, is 3.5 times larger. lcc's standard implementation of the symbol-table functions, which supports dbx, is about 300 lines of C. The support for ldb is about 1,000 lines. <p> I/O accounts for only 26% of the added time. Overhead is higher for lcc because lcc uses a large header file containing many type definitions that must appear in the symbol table. When lcc compiles noweb, a 1000-line literate-programming tool <ref> (Ramsey 1992) </ref>, compilation time 56 CHAPTER 4. POSTSCRIPT SYMBOL TABLES increases by 80%; the corresponding increase for stabs is 13%. I/O accounts for only 37% of the added time.
Reference: <author> Ramsey, Norman. </author> <year> 1992 </year> <month> (August). </month> <title> Literate-programming tools need not be complex. </title> <type> Technical Report CS-TR-351-91, </type> <institution> Department of Computer Science, Princeton University. </institution> <note> Submitted to IEEE Software. 172 REFERENCES Redell, </note> <author> David D., Yogen K. Dalal, Thomas R. Horsley, Hugh C. Lauer, William C. Lynch, </author> <note> Paul R. </note>
Reference-contexts: Chapter 11 identifies good and bad aspects of ldb's design, makes some suggestions about designing related tools, discusses how the techniques might be used elsewhere, and suggests some directions for future research. The reader familiar with an earlier version of ldb <ref> (Ramsey and Hanson 1992) </ref> is directed especially to Sections 6.4.1 and 7.6, which describe how ldb calls procedures in the target, to Chapter 7, which describes more general breakpoints, and to Chapter 8, which describes a model of stack-frame layout used to eliminate some machine-dependent stack-walking code. 10 CHAPTER 1. <p> The table for lcc, a large program that uses few library procedures, is only 5% larger with external symbols 4.7. DISCUSSION 53 included. The table for agrep, a 6,000-line string matcher (Wu and Manber 1992), is 46% larger. The table for notangle, a 600-line macro processor <ref> (Ramsey 1992) </ref>, is 3.5 times larger. lcc's standard implementation of the symbol-table functions, which supports dbx, is about 300 lines of C. The support for ldb is about 1,000 lines. <p> I/O accounts for only 26% of the added time. Overhead is higher for lcc because lcc uses a large header file containing many type definitions that must appear in the symbol table. When lcc compiles noweb, a 1000-line literate-programming tool <ref> (Ramsey 1992) </ref>, compilation time 56 CHAPTER 4. POSTSCRIPT SYMBOL TABLES increases by 80%; the corresponding increase for stabs is 13%. I/O accounts for only 37% of the added time.
Reference: <author> McJones, Hal G. Murray, and Stephen C. Purcell. </author> <year> 1980 </year> <month> (February). </month> <title> Pilot: An operating system for a personal computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 81-92. </pages>
Reference: <author> Redell, David D. </author> <year> 1989 </year> <month> (January). </month> <title> Experience with Topaz TeleDebugging. </title> <booktitle> Proceedings of the ACM SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, in SIGPLAN Notices, </booktitle> <volume> 24(1) </volume> <pages> 35-44. </pages>
Reference-contexts: could be built on top of ldb's PostScript symbol tables and abstract memories, but it, like the expression server, would need detailed knowledge of the contents of the symbol tables; it would not be isolated from the details of C. ldb's nub interface is derived from the Topaz TeleDebug protocol <ref> (Redell 1989) </ref>. Topaz provides completely reliable, available debugging support; Section 6.5 compares it and ldb. Other approaches to debugging support include system calls (Adams and Muchnick 1986), as depicted in Figure 1, controlling processes through the file system (Killian 1984), and running the target and debugger in 6 CHAPTER 1. <p> Another makes it possible to debug all processes running on the same machine as the debugger, not just child processes of the debugger. 77 78 CHAPTER 6. THE DEBUG NUB The Topaz teledebugging protocol, TTD, shows another approach to run-time debugging support <ref> (Redell 1989) </ref>. Every Topaz kernel includes two "teledebug servers," one for debugging user processes and one for the kernel. The debugger selects a target process or kernel and manipulates it by sending special packets over the network. <p> then copies them to the context, and it has an indirect addressing mode that enables it to jump to the saved program counter using a single instruction. 6.5 Discussion Of existing operating-system support for debugging, ldb's nub interface most resembles the Topaz TeleDebug protocol, TTD, from which it is derived <ref> (Redell 1989) </ref>. Some of the virtues of TTD have been sacrificed to avoid kernel changes and to improve retargetability. <p> To debug the kernel, the nub would have to use fewer kernel services; for example, it would be better for it to accept packets directly from the network device driver than to use a high-level abstraction like reliable byte streams <ref> (Redell 1989) </ref>. There is nothing in the nub protocol, however, that precludes kernel debugging. ldb's nub is more complex than TTD in that it supports procedure call. <p> TTD has solved this problem by associating a set of flavors with each trap 104 CHAPTER 7. BREAKPOINTS AND EVENTS and enabling users to delete breakpoints by flavor <ref> (Redell 1989) </ref>. Doing so in ldb would require extending the trapped-memory methods and the nub to keep track of the flavors of traps as well as their addresses. The presence of trap instructions in target memory has no effect on the abstract memory exported by the nub. <p> At the operating-system level, ldb confirms that treating all debugging as remote debugging is as practical and efficient as using the operating system to mediate all interactions between debugger and target <ref> (Redell 1989) </ref>. Both techniques are much less efficient than running the debugger and target in the same address space. ldb suggests that implementing procedure call in the user space of the target process, not in the debugger, reduces retargeting effort.
Reference: <author> Rogers, Anne and Kai Li. </author> <year> 1992 </year> <month> (September). </month> <title> Software support for speculative loads. </title> <booktitle> Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, in SIGPLAN Notices, </booktitle> <volume> 27(9) </volume> <pages> 38-50. </pages>
Reference: <author> Russell, Mark. </author> <year> 1992. </year> <title> ups. ups is a graphical, source-level debugger for C. </title> <note> It is available for anonymous ftp from host unix.hensa.ac.uk (129.12.21.7), </note> <editor> in /misc/unix/ups/ups-2.45.tar.Z. </editor> <title> The author's email address is mtr@ukc.ac.uk. Silicon Graphics, </title> <publisher> Inc. </publisher> <year> 1991. </year> <title> Graphics Library Programming Guide. Document Number 007-1210-040. </title> <address> Mountain View, CA. </address>
Reference-contexts: Other debuggers use different strategies; for example, dbx keeps tables of files and line numbers sorted by object-code location, then does linear searches through these tables (Linton 1990). ups identifies the function containing the source location, then does a linear search through a set of line numbers <ref> (Russell 1992) </ref>. ldb uses the anchor-symbol technique to find locations bound by the linker; the steps therein are summarized in Table 1. The locations of the anchor symbols are provided by the linker table's anchormap; the PostScript procedures that compute the locations appear in symbol-table entries. <p> There are several alternatives to compiling expressions into a general-purpose language; interpreting abstract syntax, as gdb does, compiling to a special intermediate code, as ups <ref> (Russell 1992) </ref> does, or interpreting an existing compiler's intermediate code. <p> DISCUSSION 141 back ends, is over 16,000 lines of C <ref> (Russell 1992) </ref>. PostScript is probably simpler to implement than an interpreter for abstract syntax, which would have to handle the control operators and data types of the source language.
Reference: <author> Stallman, Richard M. and Roland H. Pesch. </author> <year> 1991. </year> <title> Using GDB: A guide to the GNU source-level debugger, GDB version 4.0. </title> <type> Technical report, </type> <institution> Free Software Foundation, </institution> <address> Cambridge, MA. </address>
Reference-contexts: Much of the debugger has to be re-implemented for each new machine, so debuggers that work with a variety of machines, operating systems, and languages can get unwieldy. For example, GNU's gdb <ref> (Stallman and Pesch 1991) </ref> is 150,000 lines of C, and at least 57,000 of those lines are machine dependent. Because retargeting debuggers is hard, improvements to debuggers may be lost unless they are re-implemented as users move to new machines. <p> This information is placed in the object file in a machine-dependent format. ldb is like these debuggers, but it eliminates retargeting effort by its use of PostScript symbol tables. gdb 4.0 <ref> (Stallman and Pesch 1991) </ref> supports 20 different target machines and many different versions of Unix, but of its more than 150,000 lines, over 47,000 are noted in the documentation as machine-dependent. Another 10,000 lines deal with machine-dependent object code formats like a.out and COFF.
Reference: <author> Steele, Guy L., J and Jon L. White. </author> <year> 1990 </year> <month> (June). </month> <title> How to print floating-point numbers accurately. </title> <booktitle> Proceedings of the SIGPLAN'90 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 25(6) </volume> <pages> 112-126. </pages> <institution> Sun Microsystems. </institution> <year> 1990a. </year> <title> Network Programming. Part number 800-3850-10, revision A. </title> <institution> Mountain View, CA. Sun Microsystems. </institution> <year> 1990b </year> <month> (January). </month> <title> UNIX Programmer's manual, Sun Release 4.1, Section 1. Mountain View, CA. The manual page for ld describes shared libraries. </title>
Reference: <author> Swinehart, Daniel. C., Polle T. Zellweger, Richard J. Beach, and Robert. B. Hagmann. </author> <year> 1986 </year> <month> (Octo-ber). </month> <title> A structural view of the Cedar programming environment. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(4) </volume> <pages> 419-490. </pages>
Reference-contexts: By contrast, the Cedar debugger uses a language-level approach; it manipulates a "Cedar abstract machine," whose basic operations resemble those of the Cedar programming language <ref> (Swinehart et al. 1986, Section 6.4) </ref>. The abstract machine's interface to Cedar data is used by programs other than the debugger, including a user-interface tool that lets users manipulate fields (including procedures) of records chosen dynamically. <p> About 20 lines were added to the back end to provide register-save information; those lines include code for all four targets. 4.7 Discussion Linking decisions may sometimes be postponed until run time. For example, some environments use a dynamic linker that links all programs into a single address space <ref> (Swinehart et al. 1986) </ref>. Some versions of Unix support shared libraries in which the locations of library procedures are not determined until such procedures are called (Sun 1990b). ldb could support such linkers by basing its linker state on linker-dependent, run-time information, not the static linker table it now uses.
Reference: <author> Tolmach, Andrew P. and Andrew W. Appel. </author> <year> 1990 </year> <month> (June). </month> <title> Debugging Standard ML without reverse engineering. </title> <booktitle> In ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 1-12, </pages> <address> Nice, France. </address> <institution> US Department of Defense. </institution> <year> 1983. </year> <title> The Ada Programming Language Reference Manual. US Government Printing Office. ANSI/MILSTD 1815A. REFERENCES 173 Wahbe, </title> <editor> Robert. </editor> <year> 1992 </year> <month> (September). </month> <title> Efficient data breakpoints. </title> <booktitle> Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, in SIGPLAN Notices, </booktitle> <volume> 27(9) </volume> <pages> 200-212. </pages>
Reference-contexts: Logging cost can be reduced by taking periodic checkpoints; time travel is implemented by executing forward from a previous checkpoint. The compiler may transform the source to generate appropriate checkpointing code <ref> (Tolmach and Appel 1990) </ref>, or the checkpointing may be done by the run-time system, using virtual memory operations (Feldman and Brown 1988). In addition to checkpointing internal state, the program may have to log significant external events like input.
Reference: <author> Waite, William M. </author> <year> 1986 </year> <month> (May). </month> <title> The cost of lexical analysis. </title> <journal> Software|Practice & Experience, </journal> <volume> 16(5) </volume> <pages> 473-488. </pages>
Reference-contexts: Standard techniques exist for implementing fast lexical analysis, but those techniques use unsafe language features <ref> (Waite 1986) </ref>. Modula-3 offers a buffered-stream abstraction which is safe, but not fast enough. This abstraction has several implementations, which provide input from different sources, including files and strings. <p> The TokenStream interface improves speed by using other techniques besides fast search. It avoids making a procedure call for every character, eliminates unnecessary allocations, and avoids copying characters except when necessary <ref> (Waite 1986) </ref>. It also reduces synchronization overhead; clients must explicitly acquire a lock before calling procedures in the TokenStream interface, instead of having each procedure acquire and release the lock, as with readers.
Reference: <author> Wall, David W. </author> <year> 1992. </year> <title> Experience with a software-defined machine architecture. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(3) </volume> <pages> 299-338. </pages>
Reference-contexts: More ambitious linkers might take over some of the work done by the compiler, for example determining the locations of all variables at link time <ref> (Wall 1992) </ref>. Supporting such linkers might require extensions to the existing linker state, not just a re-implementation, although the existing implementation can be used if the linker can be modified to generate both a linker table and a top-level dictionary.
Reference: <author> Weiser, Mark, Alan Demers, and Carl Hauser. </author> <year> 1989 </year> <month> (December). </month> <title> The portable common runtime approach to interoperability. </title> <booktitle> Proceedings of the 12th Symposium on Operating Systems Principles, in Operating Systems Review, </booktitle> <volume> 23(5) </volume> <pages> 114-122. </pages>
Reference-contexts: A similar technique is used to support debugging in the PCedar environment; the linker dynamically generates a synthetic a.out file containing dbx debugging symbols that represent the state of the dynamically linked program <ref> (Weiser, Demers, and Hauser 1989) </ref>. ldb's symbol tables might change if the linker could be modified. One possibility would be to put the debugging information in the same file as the object code as current Unix linkers do for dbx.
Reference: <author> Welch, Terry A. </author> <year> 1984 </year> <month> (June). </month> <title> A technique for high-performance data compression. </title> <journal> IEEE Computer, </journal> <volume> 17(6) </volume> <pages> 8-19. </pages>
Reference-contexts: Comparing raw sizes is slightly unfair because the PostScript is encoded in ASCII whereas the stabs have a compact binary encoding. Compressing the PostScript files gives a plausible estimate of the space they would require given a binary encoding; if each PostScript file is compressed by Unix compress <ref> (Welch 1984) </ref>, lcc's files occupy 0.79M, still twice the size of the dbx stabs. This savings could be realized by using an I/O library that includes compression.
Reference: <author> Wu, Sun and Udi Manber. </author> <year> 1992 </year> <month> (October). </month> <title> Fast text searching allowing errors. </title> <journal> Communications of the ACM, </journal> <volume> 35(10) </volume> <pages> 83-91. </pages>
Reference-contexts: The increase in symbol-table size varies widely with the program. The table for lcc, a large program that uses few library procedures, is only 5% larger with external symbols 4.7. DISCUSSION 53 included. The table for agrep, a 6,000-line string matcher <ref> (Wu and Manber 1992) </ref>, is 46% larger. The table for notangle, a 600-line macro processor (Ramsey 1992), is 3.5 times larger. lcc's standard implementation of the symbol-table functions, which supports dbx, is about 300 lines of C. The support for ldb is about 1,000 lines.
Reference: <author> Zellweger, Polle T. </author> <year> 1984. </year> <title> Interactive Source-Level Debugging of Optimized Programs. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley. </institution> <note> Available from Xerox PARC as CSL Technical Report 84-5. </note>
Reference: <author> Zurawski, Larry W. and Ralph E. Johnson. </author> <year> 1991 </year> <month> (April). </month> <title> Debugging optimized code with expected behavior. </title> <type> Unpublished manuscript. </type> <note> Available by anonymous ftp from st.cs.uiuc.edu in /pub/papers. 174 REFERENCES </note>
References-found: 62

