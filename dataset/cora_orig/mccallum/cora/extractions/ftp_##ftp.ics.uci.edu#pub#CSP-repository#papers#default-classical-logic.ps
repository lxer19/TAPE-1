URL: ftp://ftp.ics.uci.edu/pub/CSP-repository/papers/default-classical-logic.ps
Refering-URL: http://www.ics.uci.edu/~mlearn/MLPapers.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: rachelb@cs.technion.ac.il  dechter@ics.uci.edu  
Title: Default reasoning using classical logic  
Author: Rachel Ben-Eliyahu Rina Dechter 
Note: Most of this work was done while the first author was a graduate student at the  
Date: May 17, 1995  
Address: Haifa 32000, Israel  Irvine, California 92717  Los Angeles, California, USA.  
Affiliation: Computer Science Department Technion Israel institute of technology  Information Computer Science University of California  Cognitive Systems Laboratory, Computer Science Department, University of California,  
Abstract-found: 0
Intro-found: 1
Reference: [BE93] <author> Rachel Ben-Eliyahu. </author> <title> Nonmonotonic reasoning in classical logic. </title> <type> PhD thesis, </type> <institution> University of California, Los-Angeles, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: In fact, we can show that the index variable's range can be bounded further by the maximal length of an acyclic path in any strongly connected component in G ;S <ref> [BE93] </ref>. The strongly connected components of a directed graph are a partition of its set of nodes such that for each subset C in the partition and for each x; y 2 C, there are directed paths from x to y and from y to x in G.
Reference: [BED91] <author> Rachel Ben-Eliyahu and Rina Dechter. </author> <title> Default logic, propositional logic and constraints. </title> <booktitle> In AAAI-91: Proceedings of the 9th national conference on artificial intelligence, </booktitle> <pages> pages 379-385, </pages> <address> Anaheim, CA, USA, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: We have also shown that there an interesting relationship between the translation presented in this paper and what is called Clark's predicate completion [Cla78]. A preliminary version of this work appears in <ref> [BED91] </ref>. There have been attempts in the past to relate default logic to other forms of nonmonotonic reasoning systems, such as autoepistemic logic, circumscription, and TMS [Kon88, MT89, Eth87b, JK90].
Reference: [BED94] <author> Rachel Ben-Eliyahu and Rina Dechter. </author> <title> Propositional semantics for disjunctive logic programs. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <volume> 12 </volume> <pages> 53-87, </pages> <year> 1994. </year> <title> A short version in JICSLP-92: </title> <booktitle> Pro 51 ceedings of the 1992 joint international conference and symposium on logic programming. </booktitle>
Reference-contexts: The above example can easily be generalized to a proof of the following theorem, which was proved independently by Fages [Fag92] and in our previous work <ref> [BED94] </ref>: Theorem 7.2 Let be a normal acyclic propositional logic program. Then M is a model for COM P () iff fI P jP 2 M g is a model for P . <p> Also, Elkan [Elk90] has shown that stable models of a logic program with no classical negation can be represented as models of propositional logic. Thus our work extends his results for the full power of default logic. In <ref> [BED94] </ref>, we used a technique similar to the one presented here for computing stable models of disjunctive logic programs. We have also shown that there an interesting relationship between the translation presented in this paper and what is called Clark's predicate completion [Cla78].
Reference: [BF87] <author> N. Bidoit and C. Froidevaux. </author> <title> Minimalism subsumes default logic and circumscription in stratified logic programming. </title> <booktitle> In LICS-87: Proceedings of the IEEE symposium on logic in computer science, </booktitle> <pages> pages 89-97, </pages> <address> Ithaca, NY, USA, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: Most importantly, it has been shown that logic programs with classical negation and with "negation by default" can be embedded very naturally in default logic, and thus default logic provides semantics for logic programs <ref> [GL91, BF87] </ref>. However, while knowledge can be specified in a natural way in default logic, the concept of extension as presented by Reiter is quite tricky. Moreover, as Reiter has shown, there is no procedure that computes extensions of an arbitrary default theory. <p> For an overview of this field, see [KH92]. One of the most prominent semantics for logic programs is stable model semantics <ref> [GL91, Fin89, BF87] </ref>. Gelfond and Lifschitz [GL91] have shown how stable model semantics can be naturally generalized to the class of extended logic programs, in which two types of negation | classical negation and negation by default | are used. <p> They have shown that each extension of such a default theory corresponds to an answer set of its twin logic program. A similar idea was introduced by Bidoit and Froidevaux <ref> [BF87] </ref>. The above discussion suggests concluding that any algorithm that computes extensions of a default theory will also compute answer sets of logic programs under stable model semantics.
Reference: [CL87] <author> Chin-Liang Chang and Richard Char-Tung Lee. </author> <title> Symbolic Logic and Mechanical Theorem Proving. </title> <publisher> Academic Press, INC, </publisher> <year> 1987. </year>
Reference-contexts: In meta-interpretations we assign truth values to clauses rather then to propositional atoms, with the intuition that a clause is assigned the truth value true iff it 9 A clause c 1 subsumes a clause c 2 iff c 1 c 2 . c 2 is called a subsumed clause <ref> [CL87, Chapter 5] </ref>. 10 It is clear that this method will not generate all the tautologies, but these exceptions are easy to detect and handle.
Reference: [Cla78] <author> Keith L. Clark. </author> <title> Negation as failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Databases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Clark <ref> [Cla78] </ref> made one of the first attempts to give meaning to logic programs with negated atoms in a rule's body ("normal programs"). He shows how each normal program can be associated with a first-order theory COM P (), called its completion. <p> In [BED94], we used a technique similar to the one presented here for computing stable models of disjunctive logic programs. We have also shown that there an interesting relationship between the translation presented in this paper and what is called Clark's predicate completion <ref> [Cla78] </ref>. A preliminary version of this work appears in [BED91]. There have been attempts in the past to relate default logic to other forms of nonmonotonic reasoning systems, such as autoepistemic logic, circumscription, and TMS [Kon88, MT89, Eth87b, JK90].
Reference: [Dec90] <author> Rina Dechter. </author> <title> Enhancement schemes for constraint processing: Backjumping, learning, and cutset decomposition. </title> <journal> Artificial Intelligence, </journal> <volume> 41 </volume> <pages> 273-312, </pages> <year> 1990. </year>
Reference-contexts: These include the induced width, w fl (also called tree width), the 32 size of the cycle-cutset, the depth of a depth-first-search spanning tree of this graph, and the size of the non-separable components <ref> [Fre85, DP88, Dec90] </ref>. It can be shown that the worst-case complexity of deciding consistency is polynomially bounded by any one of these parameters. Since these parameters can be bounded easily by a simple processing of the graph, they can be used for bounding the complexity ahead of time. <p> For instance, when the constraint graph is a tree, satisfiability can be answered in linear time. In the sequel we will focus on two specific CSP techniques: tree-clustering [DP89] and cycle-cutset decomposition <ref> [Dec90] </ref>. The tree-clustering scheme has a tree-building phase and a query-processing phase. The complexity of the former is exponentially dependent on the sparseness of the constraint graph, while the complexity of the latter is always linear in the size of the database generated by the tree-building preprocessing phase. <p> If no solution is found, we have to try another instantiation of the cycle-cutset variables, and so on. Clearly, the complexity of this approach is exponentially bounded by the size of the cycle-cutset that is used. For more details on this method, see <ref> [Dec90] </ref>. <p> Proof: Satisfiability of a theory whose constraint graph has a cycle-cutset of cardinality k can be solved in time O (n2 k ), where n is the number of letters in the theory <ref> [Dec90] </ref>. The interaction graph of a default theory with a closure S is isomorph to the constraint graph of P ;S . Now, let be a 2-DT with a closure S.
Reference: [DP88] <author> Rina Dechter and Judea Pearl. </author> <title> Network-based heuristics for constraint satisfaction problems. </title> <journal> Artificial Intelligence, </journal> <volume> 34 </volume> <pages> 1-38, </pages> <year> 1988. </year>
Reference-contexts: These include the induced width, w fl (also called tree width), the 32 size of the cycle-cutset, the depth of a depth-first-search spanning tree of this graph, and the size of the non-separable components <ref> [Fre85, DP88, Dec90] </ref>. It can be shown that the worst-case complexity of deciding consistency is polynomially bounded by any one of these parameters. Since these parameters can be bounded easily by a simple processing of the graph, they can be used for bounding the complexity ahead of time.
Reference: [DP89] <author> Rina Dechter and Judea Pearl. </author> <title> Tree clustering for constraint networks. </title> <journal> Artificial Intelligence, </journal> <volume> 38 </volume> <pages> 353-366, </pages> <year> 1989. </year>
Reference-contexts: For instance, when the constraint graph is a tree, satisfiability can be answered in linear time. In the sequel we will focus on two specific CSP techniques: tree-clustering <ref> [DP89] </ref> and cycle-cutset decomposition [Dec90]. The tree-clustering scheme has a tree-building phase and a query-processing phase. <p> C Tree-clustering for default reasoning The tree-clustering scheme <ref> [DP89] </ref> has a tree-building phase and a query-processing phase. The first phase of tree-clustering is restated for propositional theories in Figure 5. It uses the triangulation algorithm, which transforms any graph into a chordal 23 graph by adding edges to it [TY84]. The triangulation algorithm consists of two steps: 1. <p> As a result, for classes having a bounded induced width, this method is tractable. Once the tree is built it always allows an efficient query-answering process, that is, the cost of answering many types of queries is linear in the size of the tree generated <ref> [DP89] </ref>.
Reference: [Elk90] <author> Charles Elkan. </author> <title> A rational reconstruction of nonmonotonic truth maintenance systems. </title> <journal> Artificial Intelligence, </journal> <volume> 43 </volume> <pages> 219-234, </pages> <year> 1990. </year>
Reference-contexts: Clauses from P I (W ) will get index 0, and this way the well-foundedness of the positive integers will induce well-foundedness on the clauses. The following theorem conveys this idea. Elkan <ref> [Elk90] </ref> used a similar technique in order to ensure that the justifications supporting a node in a TMS are non-circular. <p> Related results for autoepistemic logic were reported in [MT91], where it was shown that the question of an atom's membership in every expansion of an autoepistemic theory is reducible to propositional provability. Also, Elkan <ref> [Elk90] </ref> has shown that stable models of a logic program with no classical negation can be represented as models of propositional logic. Thus our work extends his results for the full power of default logic.
Reference: [Eth87a] <author> David W. Etherington. </author> <title> Formalizing nonmonotonic reasoning systems. </title> <journal> Artificial Intelligence, </journal> <volume> 31 </volume> <pages> 41-85, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Researchers in artificial intelligence have found Reiter's default logic [Rei80] 1 attractive and have used it widely for declarative representations of problems in a variety of areas, including diagnostic reasoning [Rei87], theory of speech acts [Per87], natural language processing [Mer88], and inheritance hierarchies with exceptions <ref> [Eth87a] </ref>. Most importantly, it has been shown that logic programs with classical negation and with "negation by default" can be embedded very naturally in default logic, and thus default logic provides semantics for logic programs [GL91, BF87]. <p> Moreover, our method introduces a deterministic algo rithm for computing extensions of any finite propositional default theory, 1 In this paper, when we mention "default logic" we mean "Reiter's default logic". 3 while previous algorithms 2 (e. g. <ref> [KS91, Sti90, JK90, Eth87a] </ref>) produce an extension only for certain subsets of all default theories. Our translation is exponential in general. However, there is a significant sublanguage which we call 2-default theories (2-DT), for which our translation is tractable. <p> Our translation is exponential in general. However, there is a significant sublanguage which we call 2-default theories (2-DT), for which our translation is tractable. The class 2-DT includes the so-called network default theories | the default-logic version of inheritance networks <ref> [Eth87a] </ref> and the class of disjunction-free default theories, in which formulas with disjunction are forbidden. It has been shown [GL91] that the class of disjunction-free default theories can embed extended logic programs; answer sets of the latter coincide with extensions of the former. <p> If many individuals share a group of common properties, an abstraction of those properties is created, and all those individuals can then "inherit" from that abstraction. Inheritance from multiple classes is also allowed. For more information on this subject, see <ref> [Eth87a] </ref> or [Tou84]. Etherington ([Eth87a]) proposed a subclass of default theories, called network default theories, as suitable for providing formal semantics and a notion of sound inference for inheritance networks. Definition 1.2 (network default theory) [Eth87a] A default theory is a network theory iff it satisfies the following conditions: 1. <p> Inheritance from multiple classes is also allowed. For more information on this subject, see <ref> [Eth87a] </ref> or [Tou84]. Etherington ([Eth87a]) proposed a subclass of default theories, called network default theories, as suitable for providing formal semantics and a notion of sound inference for inheritance networks. Definition 1.2 (network default theory) [Eth87a] A default theory is a network theory iff it satisfies the following conditions: 1.
Reference: [Eth87b] <author> David W. Etherington. </author> <title> Relating default logic and circumscription. </title> <booktitle> In IJCAI-87: Proceedings of the 10th international joint conference on artificial intelligence, </booktitle> <pages> pages 489-494, </pages> <address> Detroit, MI, USA, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: A preliminary version of this work appears in [BED91]. There have been attempts in the past to relate default logic to other forms of nonmonotonic reasoning systems, such as autoepistemic logic, circumscription, and TMS <ref> [Kon88, MT89, Eth87b, JK90] </ref>. We believe that embedding default logic in classical logic is just as valuable since classical logic is a well understood formalism supported by a large body of computational knowledge.
Reference: [Fag92] <author> Francois Fages. </author> <title> Consistency of clark's completion and existence of stable models. </title> <booktitle> Methods of Logic in Computer Science, </booktitle> <volume> 2, </volume> <month> April </month> <year> 1992. </year>
Reference-contexts: The above example can easily be generalized to a proof of the following theorem, which was proved independently by Fages <ref> [Fag92] </ref> and in our previous work [BED94]: Theorem 7.2 Let be a normal acyclic propositional logic program. Then M is a model for COM P () iff fI P jP 2 M g is a model for P .
Reference: [Fin89] <author> Kit Fine. </author> <title> The justification of negation as failure. </title> <journal> Logic, Methodol--ogy and Philosophy of Science, </journal> <volume> 8 </volume> <pages> 263-301, </pages> <year> 1989. </year>
Reference-contexts: For an overview of this field, see [KH92]. One of the most prominent semantics for logic programs is stable model semantics <ref> [GL91, Fin89, BF87] </ref>. Gelfond and Lifschitz [GL91] have shown how stable model semantics can be naturally generalized to the class of extended logic programs, in which two types of negation | classical negation and negation by default | are used.
Reference: [Fre85] <author> E.C. Freuder. </author> <title> A sufficient condition for backtrack-bounded search. </title> <journal> Journal of the ACM, </journal> <volume> 32(4) </volume> <pages> 755-761, </pages> <year> 1985. </year>
Reference-contexts: These include the induced width, w fl (also called tree width), the 32 size of the cycle-cutset, the depth of a depth-first-search spanning tree of this graph, and the size of the non-separable components <ref> [Fre85, DP88, Dec90] </ref>. It can be shown that the worst-case complexity of deciding consistency is polynomially bounded by any one of these parameters. Since these parameters can be bounded easily by a simple processing of the graph, they can be used for bounding the complexity ahead of time.
Reference: [GL91] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Classical negation in logic programs and disjunctive databases. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 365-385, </pages> <year> 1991. </year>
Reference-contexts: Most importantly, it has been shown that logic programs with classical negation and with "negation by default" can be embedded very naturally in default logic, and thus default logic provides semantics for logic programs <ref> [GL91, BF87] </ref>. However, while knowledge can be specified in a natural way in default logic, the concept of extension as presented by Reiter is quite tricky. Moreover, as Reiter has shown, there is no procedure that computes extensions of an arbitrary default theory. <p> The class 2-DT includes the so-called network default theories | the default-logic version of inheritance networks [Eth87a] and the class of disjunction-free default theories, in which formulas with disjunction are forbidden. It has been shown <ref> [GL91] </ref> that the class of disjunction-free default theories can embed extended logic programs; answer sets of the latter coincide with extensions of the former. Therefore, techniques developed for finding extensions for 2-DT are applicable for computing logic programs as well. <p> For an overview of this field, see [KH92]. One of the most prominent semantics for logic programs is stable model semantics <ref> [GL91, Fin89, BF87] </ref>. Gelfond and Lifschitz [GL91] have shown how stable model semantics can be naturally generalized to the class of extended logic programs, in which two types of negation | classical negation and negation by default | are used. <p> For an overview of this field, see [KH92]. One of the most prominent semantics for logic programs is stable model semantics [GL91, Fin89, BF87]. Gelfond and Lifschitz <ref> [GL91] </ref> have shown how stable model semantics can be naturally generalized to the class of extended logic programs, in which two types of negation | classical negation and negation by default | are used.
Reference: [Got92] <author> Georg Gottlob. </author> <title> Complexity results for nonmonotonic logics. </title> <journal> The Journal of Logic and Computation, </journal> <volume> 2(3) </volume> <pages> 397-425, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Moreover, as Reiter has shown, there is no procedure that computes extensions of an arbitrary default theory. Recent research indicates that the complexity of answering basic queries on propositional default logic is very high ( p p complete <ref> [Sti92, Got92] </ref>), and that even for very simple propositional default theories, the problem is NP-hard [KS91, Sti90]. In this paper we show how we can confront these difficulties by translating default theories into classical propositional theories. <p> In this paper we focus on propositional default logic. It has been shown that the coherence problem is P 2 -complete for this class and remains so even if restricted to semi-normal default theories <ref> [Sti92, Got92] </ref>. Membership and entailment for the class of normal propositional default theories were shown to be P 2 -complete and P 2 -complete, respectively, even if T is restricted to contain a single literal [Sti92, Got92]. <p> 2 -complete for this class and remains so even if restricted to semi-normal default theories <ref> [Sti92, Got92] </ref>. Membership and entailment for the class of normal propositional default theories were shown to be P 2 -complete and P 2 -complete, respectively, even if T is restricted to contain a single literal [Sti92, Got92]. In this paper we will show subclasses for which these tasks are easier 5 . It has been shown that the subclass 2-DT of all default theories is pow erful enough to embed both inheritance networks and logic programs.
Reference: [JK90] <author> Ulrich Junker and Kurt Konolige. </author> <title> Computing the extensions of autoepistemic and default logics with a TMS. </title> <booktitle> In AAAI-90: Proceedings of the 8th national conference on artificial intelligence, </booktitle> <pages> pages 278-283, </pages> <address> Boston, MA, </address> <year> 1990. </year>
Reference-contexts: Moreover, our method introduces a deterministic algo rithm for computing extensions of any finite propositional default theory, 1 In this paper, when we mention "default logic" we mean "Reiter's default logic". 3 while previous algorithms 2 (e. g. <ref> [KS91, Sti90, JK90, Eth87a] </ref>) produce an extension only for certain subsets of all default theories. Our translation is exponential in general. However, there is a significant sublanguage which we call 2-default theories (2-DT), for which our translation is tractable. <p> A preliminary version of this work appears in [BED91]. There have been attempts in the past to relate default logic to other forms of nonmonotonic reasoning systems, such as autoepistemic logic, circumscription, and TMS <ref> [Kon88, MT89, Eth87b, JK90] </ref>. We believe that embedding default logic in classical logic is just as valuable since classical logic is a well understood formalism supported by a large body of computational knowledge.
Reference: [KH92] <editor> R.A. Kowalski and C.J. Hogger. </editor> <booktitle> Logic programming. </booktitle> <editor> In Stuart C. Shapiro, editor, </editor> <booktitle> Encyclopedia of Artificial Intelligence, </booktitle> <pages> pages 873-891. </pages> <publisher> John Wiley & Sons, </publisher> <address> 2nd edition, </address> <year> 1992. </year>
Reference-contexts: This negation was generally interpreted as "negation by default", not classical negation, resulting in a grounded predicate being considered false iff it can not be proved from the program. For an overview of this field, see <ref> [KH92] </ref>. One of the most prominent semantics for logic programs is stable model semantics [GL91, Fin89, BF87].
Reference: [Kon88] <author> Kurt Konolige. </author> <title> On the relation between default and autoepistemic logic. </title> <journal> Artificial Intelligence, </journal> <volume> 35 </volume> <pages> 343-382, </pages> <year> 1988. </year>
Reference-contexts: A preliminary version of this work appears in [BED91]. There have been attempts in the past to relate default logic to other forms of nonmonotonic reasoning systems, such as autoepistemic logic, circumscription, and TMS <ref> [Kon88, MT89, Eth87b, JK90] </ref>. We believe that embedding default logic in classical logic is just as valuable since classical logic is a well understood formalism supported by a large body of computational knowledge.
Reference: [KS91] <author> Henry A. Kautz and Bart Selman. </author> <title> Hard problems for simple default logics. </title> <journal> Artificial Intelligence, </journal> <volume> 49 </volume> <pages> 243-279, </pages> <year> 1991. </year>
Reference-contexts: Recent research indicates that the complexity of answering basic queries on propositional default logic is very high ( p p complete [Sti92, Got92]), and that even for very simple propositional default theories, the problem is NP-hard <ref> [KS91, Sti90] </ref>. In this paper we show how we can confront these difficulties by translating default theories into classical propositional theories. <p> Moreover, our method introduces a deterministic algo rithm for computing extensions of any finite propositional default theory, 1 In this paper, when we mention "default logic" we mean "Reiter's default logic". 3 while previous algorithms 2 (e. g. <ref> [KS91, Sti90, JK90, Eth87a] </ref>) produce an extension only for certain subsets of all default theories. Our translation is exponential in general. However, there is a significant sublanguage which we call 2-default theories (2-DT), for which our translation is tractable. <p> Section 7 contains concluding remarks, and missing proofs appear in the appendix. Before moving on, we would like to clarify a subtle but important point. Some of the decision problems we discuss here have been proven to be NP-complete or co-NP-complete for some subsets of all propositional default theories <ref> [KS91, Sti90] </ref>. This means, almost by definition, that there actually exists a polynomial translation from these subsets to propositional theories such that queries on the translated default theories are answerable by solving satisfiability of the corresponding classical theories. The consequences of the work presented here goes beyond this initial observation. <p> The above theorem shows that there is a direct connection between the complexity of the translation and the cyclicity of the default theory translated, since for acyclic theories p = l = 1. The complexity results obtained by Kautz and Selman <ref> [KS91] </ref> and Still-man [Sti90] for default logic show that the satisfiability problem is polyno-mially reducible to deciding extension existence and membership in a subset of the class 2-DT, and that entailment in propositional logic is polynomially reducible to entailment for a subset of the class 2-DT. <p> Thus, as the number of time slots (n) grows, the time complexity for answering queries about coherence, set-membership, and set-entailment using the tree-clustering method grows linearly. Note that according to Selman and Kautz's classification <ref> [KS91] </ref>, this family of theories belongs to a class for which the complexity of answering such queries is NP-hard. The cycle-cutset algorithm is another method that exploits the structure of the constraint graph.
Reference: [Lee67] <author> Char-Tung Lee. </author> <title> A completeness theorem and a Computer Program for finding theorems derivable from given axioms. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <year> 1967. </year>
Reference: [Mer88] <author> Robert E. Mercer. </author> <title> Using default logic to derive natural language presupposition. </title> <editor> In Randy Goebel, editor, </editor> <booktitle> proceedings of the 7th biennial conference of the canadian society for computational studies of intelligence (CSCSI), </booktitle> <pages> pages 14-21. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Researchers in artificial intelligence have found Reiter's default logic [Rei80] 1 attractive and have used it widely for declarative representations of problems in a variety of areas, including diagnostic reasoning [Rei87], theory of speech acts [Per87], natural language processing <ref> [Mer88] </ref>, and inheritance hierarchies with exceptions [Eth87a]. Most importantly, it has been shown that logic programs with classical negation and with "negation by default" can be embedded very naturally in default logic, and thus default logic provides semantics for logic programs [GL91, BF87].
Reference: [Moo85] <author> Robert C. Moore. </author> <title> Semantical consideration on nonmonotonic logic. </title> <journal> Artificial Intelligence, </journal> <volume> 25 </volume> <pages> 75-94, </pages> <year> 1985. </year> <month> 53 </month>
Reference-contexts: The work presented here can also be viewed as an attempt to provide default logic with semantics that are in the spirit of the semantics of Moore's autoepistemic logic <ref> [Moo85] </ref>. The concepts of meta-interpretation and model for a default theory are in some sense parallel to the notions of propositional interpretation of an autoepistemic theory (AET) and autoepistemic model of an AET [Moo85, Section 3]. <p> The concepts of meta-interpretation and model for a default theory are in some sense parallel to the notions of propositional interpretation of an autoepistemic theory (AET) and autoepistemic model of an AET <ref> [Moo85, Section 3] </ref>.
Reference: [MR72] <author> Eliana Minicozzi and Ray Reiter. </author> <title> A note on linear resolution strate-gies in consequence-finding. </title> <journal> Artificial Intelligence, </journal> <volume> 3 </volume> <pages> 175-180, </pages> <year> 1972. </year>
Reference-contexts: There are some improvements to that method (see for example <ref> [MR72] </ref>), but it is clear that the general problem is NP-hard since it also solves satisfiability. Nevertheless, for special cases such as size-2 clauses, the prime implicates can be computed in O (n 3 ) time.
Reference: [MT89] <author> Wiktor Marek and Miroslaw Truszczynski. </author> <title> Relating autoepistemic and default logic. </title> <editor> In Ronald J. Brachman, Hector J. Levesque, and Raymond Reiter, editors, </editor> <booktitle> KR-89: Proceedings of the first international conference on principles of knowledge representation and reasoning, </booktitle> <pages> pages 276-288, </pages> <address> San Mateo, CA, 1989. </address> <publisher> Morgan Kaouf-mann. </publisher>
Reference-contexts: A preliminary version of this work appears in [BED91]. There have been attempts in the past to relate default logic to other forms of nonmonotonic reasoning systems, such as autoepistemic logic, circumscription, and TMS <ref> [Kon88, MT89, Eth87b, JK90] </ref>. We believe that embedding default logic in classical logic is just as valuable since classical logic is a well understood formalism supported by a large body of computational knowledge.
Reference: [MT91] <author> Wiktor Marek and Miroslaw Truszczynski. </author> <title> Computing intersection of autoepistemic expansions. </title> <booktitle> In Logic programming and non-monotonic reasoning: Proceedings of the 1st international workshop, </booktitle> <pages> pages 37-50, </pages> <address> Washington, DC, USA, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Using constraint satisfaction techniques, we have identified tractable subclasses of 2-DT. We have shown how problems in temporal reasoning can 40 be solved efficiently using the tree clustering algorithm. Related results for autoepistemic logic were reported in <ref> [MT91] </ref>, where it was shown that the question of an atom's membership in every expansion of an autoepistemic theory is reducible to propositional provability. Also, Elkan [Elk90] has shown that stable models of a logic program with no classical negation can be represented as models of propositional logic.
Reference: [Per87] <author> C. Raymond Perrault. </author> <title> An application of default logic to speech act theory. </title> <type> Technical Report CSLI-87-90, </type> <institution> SRI International, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Researchers in artificial intelligence have found Reiter's default logic [Rei80] 1 attractive and have used it widely for declarative representations of problems in a variety of areas, including diagnostic reasoning [Rei87], theory of speech acts <ref> [Per87] </ref>, natural language processing [Mer88], and inheritance hierarchies with exceptions [Eth87a]. Most importantly, it has been shown that logic programs with classical negation and with "negation by default" can be embedded very naturally in default logic, and thus default logic provides semantics for logic programs [GL91, BF87].
Reference: [RdK87] <author> Raymond Reiter and Johan de Kleer. </author> <title> Foundations of assumption-based truth maintenance systems: Preliminary report. </title> <booktitle> In The national conference on AI, </booktitle> <pages> pages 183-188, </pages> <address> Seattle,WA, </address> <month> July </month> <year> 1987. </year>
Reference-contexts: However, when the theory is finite, we can compute a set that will represent the logical closure by using the notion of prime implicates as presented by Reiter and de Kleer <ref> [RdK87] </ref>. 8 Two formulas ff; fi are equivalent iff ff j= fi and fi j= ff. 12 Definition 2.1 A prime implicate of a set T of clauses is a clause c such that 1.
Reference: [Rei] <author> Ray Reiter. </author> <type> Personal communication, </type> <year> 1992. </year>
Reference-contexts: for some ordering E = S 1 i=0 E i . (Note the ap pearance of E in the formula for E i+1 .) Many tasks on a default theory may be formulated using one of the following queries: 4 Empty justifications are equivalent to the identically true proposition true <ref> [Rei] </ref>. 5 Coherence: Does have an extension? If so, find one.
Reference: [Rei80] <author> Raymond Reiter. </author> <title> A logic for default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13 </volume> <pages> 81-132, </pages> <year> 1980. </year>
Reference-contexts: 1 Introduction Researchers in artificial intelligence have found Reiter's default logic <ref> [Rei80] </ref> 1 attractive and have used it widely for declarative representations of problems in a variety of areas, including diagnostic reasoning [Rei87], theory of speech acts [Per87], natural language processing [Mer88], and inheritance hierarchies with exceptions [Eth87a]. <p> is clear that it is sufficient to consider a finite number of such subsets, this brute-force algorithm is extremely expensive. 3 See Section 5.1 for details. 4 1.1 Default logic, inheritance networks, and logic pro- grams 1.1.1 Reiter's default logic We begin with a brief introduction to Reiter's default logic <ref> [Rei80] </ref>. Let L be a first-order language over a countable alphabet. A default theory is a pair = (D; W ), where D is a set of defaults and W is a set of closed well-formed formulas (wff) in L. <p> Intuitively, an extension is a maximal set of formulas that is deducible from W using the defaults in D. Let E fl denote the logical closure of E in L. We use the following definition of an extension: Definition 1.1 (extension) <ref> [Rei80, Theorem 2.1] </ref> Let E L be a set of closed wffs, and let (D; W ) be a closed default theory. Define 1. <p> In order to give the reader a feel for this translation, we will present three default theories considered in Reiter's original paper on default logic <ref> [Rei80] </ref>, and for each theory we will provide the corresponding propositional theory. We will explain, without delving into technical details, the principle behind our mapping. <p> We will explain, without delving into technical details, the principle behind our mapping. Example 1.3 Consider the following default theory <ref> [Rei80, Example 2.3] </ref> D = : C ; :C ; W = ; This theory has two extensions: f:Cg fl and f:Dg fl . We will now show how this result is realized using our translation. <p> In M 2 , I :D is true and I :C is false. M 1 corresponds to the extension f:Cg fl and M 2 corresponds to the extension f:Dg fl . Example 1.4 Consider the following default theory <ref> [Rei80, Example 2.2] </ref> D = : C ; :E : E This theory has one extension: f:D; :F g fl . We will now show how this result realized using our translation. This time we use the vocabulary fI :C ; I :D ; I :E ; I :F g. <p> This model corresponds to the extension f:D; :F g fl . Example 1.5 Consider the following default theory <ref> [Rei80, page 91,Example 2.6] </ref>: :A ; W = ; We will translate this theory as follows: :I :A I :A The first formula constrains that the default rule should be satisfied.
Reference: [Rei87] <author> Raymond Reiter. </author> <title> A theory of diagnosis from first principles. </title> <journal> Artificial Intelligence, </journal> <volume> 32 </volume> <pages> 57-95, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Researchers in artificial intelligence have found Reiter's default logic [Rei80] 1 attractive and have used it widely for declarative representations of problems in a variety of areas, including diagnostic reasoning <ref> [Rei87] </ref>, theory of speech acts [Per87], natural language processing [Mer88], and inheritance hierarchies with exceptions [Eth87a].
Reference: [Sti90] <author> Jonathan Stillman. </author> <title> It's not my default: The complexity of membership problems in restricted propositional default logics. </title> <booktitle> In AAAI-90: Proceedings of the 8th national conference on artificial intelligence, </booktitle> <pages> pages 571-578, </pages> <address> Boston, MA, USA, </address> <year> 1990. </year>
Reference-contexts: Recent research indicates that the complexity of answering basic queries on propositional default logic is very high ( p p complete [Sti92, Got92]), and that even for very simple propositional default theories, the problem is NP-hard <ref> [KS91, Sti90] </ref>. In this paper we show how we can confront these difficulties by translating default theories into classical propositional theories. <p> Moreover, our method introduces a deterministic algo rithm for computing extensions of any finite propositional default theory, 1 In this paper, when we mention "default logic" we mean "Reiter's default logic". 3 while previous algorithms 2 (e. g. <ref> [KS91, Sti90, JK90, Eth87a] </ref>) produce an extension only for certain subsets of all default theories. Our translation is exponential in general. However, there is a significant sublanguage which we call 2-default theories (2-DT), for which our translation is tractable. <p> Section 7 contains concluding remarks, and missing proofs appear in the appendix. Before moving on, we would like to clarify a subtle but important point. Some of the decision problems we discuss here have been proven to be NP-complete or co-NP-complete for some subsets of all propositional default theories <ref> [KS91, Sti90] </ref>. This means, almost by definition, that there actually exists a polynomial translation from these subsets to propositional theories such that queries on the translated default theories are answerable by solving satisfiability of the corresponding classical theories. The consequences of the work presented here goes beyond this initial observation. <p> The above theorem shows that there is a direct connection between the complexity of the translation and the cyclicity of the default theory translated, since for acyclic theories p = l = 1. The complexity results obtained by Kautz and Selman [KS91] and Still-man <ref> [Sti90] </ref> for default logic show that the satisfiability problem is polyno-mially reducible to deciding extension existence and membership in a subset of the class 2-DT, and that entailment in propositional logic is polynomially reducible to entailment for a subset of the class 2-DT.
Reference: [Sti92] <author> Jonathan Stillman. </author> <title> The complexity of propositional default logics. </title> <booktitle> In AAAI-92: Proceedings of the 10th national conference on artificial intelligence, </booktitle> <pages> pages 794-799, </pages> <address> San Jose, CA, </address> <year> 1992. </year> <month> 54 </month>
Reference-contexts: Moreover, as Reiter has shown, there is no procedure that computes extensions of an arbitrary default theory. Recent research indicates that the complexity of answering basic queries on propositional default logic is very high ( p p complete <ref> [Sti92, Got92] </ref>), and that even for very simple propositional default theories, the problem is NP-hard [KS91, Sti90]. In this paper we show how we can confront these difficulties by translating default theories into classical propositional theories. <p> In this paper we focus on propositional default logic. It has been shown that the coherence problem is P 2 -complete for this class and remains so even if restricted to semi-normal default theories <ref> [Sti92, Got92] </ref>. Membership and entailment for the class of normal propositional default theories were shown to be P 2 -complete and P 2 -complete, respectively, even if T is restricted to contain a single literal [Sti92, Got92]. <p> 2 -complete for this class and remains so even if restricted to semi-normal default theories <ref> [Sti92, Got92] </ref>. Membership and entailment for the class of normal propositional default theories were shown to be P 2 -complete and P 2 -complete, respectively, even if T is restricted to contain a single literal [Sti92, Got92]. In this paper we will show subclasses for which these tasks are easier 5 . It has been shown that the subclass 2-DT of all default theories is pow erful enough to embed both inheritance networks and logic programs.
Reference: [Tar72] <author> Robert Tarjan. </author> <title> Depth-first search and linear graph algorithms. </title> <journal> SIAM Journal on Computing, </journal> <volume> 1 </volume> <pages> 146-160, </pages> <year> 1972. </year>
Reference-contexts: The strongly connected components can be identified in linear time <ref> [Tar72] </ref>. Note that, as also implied by Theorem 3.21, if the default theory is acyclic, we do not need any indexing. We summarize all the above discussions with an algorithm for computing P ;S for a finite default theory and a closure of , S.
Reference: [Tou84] <author> David S. Touretzky. </author> <title> Implicit ordering of defaults in inheritance systems. </title> <booktitle> In AAAI-84: Proceedings of the 2nd national conference on artificial intelligence, </booktitle> <pages> pages 322-325, </pages> <address> Austin,TX, </address> <year> 1984. </year>
Reference-contexts: If many individuals share a group of common properties, an abstraction of those properties is created, and all those individuals can then "inherit" from that abstraction. Inheritance from multiple classes is also allowed. For more information on this subject, see [Eth87a] or <ref> [Tou84] </ref>. Etherington ([Eth87a]) proposed a subclass of default theories, called network default theories, as suitable for providing formal semantics and a notion of sound inference for inheritance networks. Definition 1.2 (network default theory) [Eth87a] A default theory is a network theory iff it satisfies the following conditions: 1.
Reference: [TY84] <author> Robert E. Tarjan and M. Yannakakis. </author> <title> Simple linear-time algorithms to test chordality of graphs, test acyclicity of hypergraphs and selectively reduce acyclic hypergraphs. </title> <journal> SIAM Journal on Computing, </journal> <volume> 13(3) </volume> <pages> 566-579, </pages> <year> 1984. </year> <month> 55 </month>
Reference-contexts: C Tree-clustering for default reasoning The tree-clustering scheme [DP89] has a tree-building phase and a query-processing phase. The first phase of tree-clustering is restated for propositional theories in Figure 5. It uses the triangulation algorithm, which transforms any graph into a chordal 23 graph by adding edges to it <ref> [TY84] </ref>. The triangulation algorithm consists of two steps: 1. Select an ordering for the nodes (various heuristics for good orderings are available). 2. Fill in edges recursively between any two nonadjacent nodes that are connected via nodes higher up in the ordering.
References-found: 37

