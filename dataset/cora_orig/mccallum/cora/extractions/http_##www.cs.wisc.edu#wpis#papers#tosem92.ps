URL: http://www.cs.wisc.edu/wpis/papers/tosem92.ps
Refering-URL: http://www.cs.wisc.edu/wpis/papers/
Root-URL: http://www.cs.wisc.edu
Title: A Program Integration Algorithm that Accommodates Semantics-Preserving Transformations  
Author: WUU YANG, SUSAN HORWITZ, and THOMAS REPS 
Keyword: General Terms: Algorithms, Design Additional Key Words and Phrases: coarsest partition, control dependence, data dependence, data-flow analysis, flow dependence, program dependence graph, program integration, program representation graph, static-single-assignment form  
Address: WisconsinMadison  
Affiliation: University of  
Abstract: Given a program Base and two variants, A and B, each created by modifying separate copies of Base, the goal of program integration is to determine whether the modifications interfere, and if they do not, to create an integrated program that includes both sets of changes as well as the portions of Base preserved in both variants. Text-based integration techniques, such as the one used by the UNIX diff3 utility, are obviously unsatisfactory because one has no guarantees about how the execution behavior of the integrated program relates to the behaviors of Base, A, and B. The first program-integration algorithm to provide such guarantees was developed by Horwitz, Prins, and Reps. However, a limitation of that algorithm is that it incorporates no notion of semantics-preserving transformations. This limitation causes the algorithm to be overly conservative in its definition of interference. For example, if one variant changes the way a computation is performed (without changing the values computed) while the other variant adds code that uses the result of the computation, the algorithm would classify those changes as interfering. This paper describes a new integration algorithm that is able to accommodate semantics-preserving transformations. Categories and Subject Descriptors: D.2.2 [Software Engineering]: Tools and Techniques programmer workbench; D.2.3 [Software Engineering]: Coding program editors; D.2.6 [Software Engineering]: Programming Environments; D.2.7 [Software Engineering]: Distribution and Maintenance enhancement, restructuring, version control; D.2.9 [Software Engineering]: Management programming teams, software configuration management; D.3.4 [Programming Languages]: Processors compilers, interpreters, optimization; E.1 [Data Structures] graphs 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Aho, A., Hopcroft, J.E., and Ullman, J., </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1974). </address>
Reference-contexts: The flow dependence edge incident on a f exit vertex is assigned type flow exit . hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh The basic partitioning algorithm: The initial partition is B <ref> [1] </ref>, B [2], ..., B [p] WAITING := - 1, 2,..., p - q := p while WAITING do select and delete an integer i from WAITING for each edge type m do FOLLOWER := for each vertex u in B [i] do FOLLOWER := FOLLOWER m-successor (u) od for each
Reference: 2. <author> Aho, A., Sethi, R., and Ullman, J., </author> <booktitle> Compilers: Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1986). </address>
Reference-contexts: The language does not include input statements; however, a program can use a variable before assigning to it, in which case the variable's value comes from the initial state. We assume a standard operational semantics for sequential execution of the corresponding flowchart (control flow graph <ref> [2] </ref>): at any moment there is a single locus of control together with a global execution state mapping program variables to values; the execution of each assignment statement, output statement, or predicate passes control to a single successor; the execution of each assignment state ment changes the global execution state. (2) <p> The flow dependence edge incident on a f exit vertex is assigned type flow exit . hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh The basic partitioning algorithm: The initial partition is B [1], B <ref> [2] </ref>, ..., B [p] WAITING := - 1, 2,..., p - q := p while WAITING do select and delete an integer i from WAITING for each edge type m do FOLLOWER := for each vertex u in B [i] do FOLLOWER := FOLLOWER m-successor (u) od for each j such
Reference: 3. <author> Allen, F.E. and Cocke, J.A., </author> <title> A catalogue of optimizing transformations, pp. 1-30 in Design and Optimization of Compilers, </title> <editor> ed. R. Rustin,Prentice-Hall, </editor> <address> Englewood Cliffs, NJ (1972). </address>
Reference: 4. <author> Alpern, B., Wegman, M.N., and Zadeck, F.K., </author> <title> Detecting equality of variables in programs, pp. </title> <booktitle> 1-11 in Conference Record of the Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, Janu-ary 13-15, </address> <year> 1988), (1988). </year>
Reference-contexts: This section describes one such algorithm that we developed, which is called the Sequence-Congruence Algorithm. The Sequence-Congruence Algorithm was inspired by an idea of Alpern, Wegman, and Zadeck for extending value numbering to work in the presence of conditional statements and loops <ref> [4] </ref>; however, our results are quite different. The Alpern-Wegman-Zadeck algorithm finds what they call congruent program components by first optimistically grouping possibly congruent components in an initial partition and then finding the coarsest partition consistent with the initial partition. <p> A further point of contrast between our work and that of <ref> [4] </ref> concerns the idea of applying partitioning to more than one program simultaneously. <p> However, because addition is commutative, T3 and T7 could be placed in a single equivalence class, which then also makes it possible for T4 and T8 to be members of a single equivalence class. A simple enhancement to the basic partitioning algorithm extends it to handle commutative operators <ref> [4] </ref>.
Reference: 5. <author> Berzins, V., </author> <title> On merging software extensions, </title> <note> Acta Informatica 23 pp. </note> <month> 607-619 </month> <year> (1986). </year>
Reference-contexts: Comparison With Related Work In addition to the HPR algorithm [12], there has been previous work on integrating functions <ref> [5] </ref>, logic programs [15], and specifications [8]. Different models of integration have been used in each case. In Berzins's work on integrating functions, variants A and B are merged without regard to Base.
Reference: 6. <author> Cytron, R., Ferrante, J., Rosen, B.K., Wegman, M.N., and Zadeck, K., </author> <title> An efficient method of computing static single assignment form, pp. </title> <booktitle> 25-35 in Conference Record of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Austin, TX, </address> <month> Jan. </month> <pages> 11-13, </pages> <year> 1989), (1989). </year>
Reference: 7. <author> Downey, P.J., Sethi, R., and Tarjan, R.E., </author> <title> Variations on the common subexpression problem, </title> <journal> JACM 27(4) pp. </journal> <month> 758-771 </month> <year> (1980). </year>
Reference: 8. <author> Feather, </author> <title> M.S., Detecting interference when merging specification evolutions, </title> <type> Unpublished report, </type> <institution> Information Sciences Institute, University of Southern California, Marina del Rey, </institution> <address> CA (1989). </address>
Reference-contexts: Comparison With Related Work In addition to the HPR algorithm [12], there has been previous work on integrating functions [5], logic programs [15], and specifications <ref> [8] </ref>. Different models of integration have been used in each case. In Berzins's work on integrating functions, variants A and B are merged without regard to Base.
Reference: 9. <author> Ferrante, J., Ottenstein, K., and Warren, J., </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Transactions on Programming Languages and Systems 9(3) pp. </journal> <month> 319-349 (July </month> <year> 1987). </year> <journal> ACM Transactions on Software Engineering and Methodology Vol 1, </journal> <volume> No 3, </volume> <pages> July 1992 pp 310-354 - 36 </pages> - 
Reference-contexts: Relevant work on program-optimization and transformation techniques for graph representations similar to PRGs includes [22], <ref> [9] </ref>, and [21]. APPENDIX. PROOF OF THE INTEGRATION THEOREM This appendix gives the detailed proof of the integration theorem stated in Section 5.
Reference: 10. <author> Hopcroft, </author> <title> J.E., An n log n algorithm for minimizing the states of a finite automaton, </title> <booktitle> The Theory of Machines and Computations, </booktitle> <pages> pp. </pages> <month> 189-196 </month> <year> (1971). </year>
Reference-contexts: Given an initial partition of a graph's vertices, there exists a coarsest refinement of the initial partition that is stable, which can be computed by a variation of an algorithm due to Hopcroft <ref> [10] </ref>. The Sequence-Congruence Algorithm uses this technique to partition components of one or more PRGs. The algorithm consists of two partitioning passes. Vertices that have different operators are put into different initial partitions. <p> The two partitioning passes of the Sequence-Congruence Algorithm both use the basic partitioning algorithm shown in Figure 4. This algorithm is adapted from [4,1], which in turn is based on an algorithm of <ref> [10] </ref> for minimizing a finite state machine. This algorithm finds the coarsest stable partition of a graph's vertices (i.e., a partition that is compatible with a given initial partition and the edges in the graph).
Reference: 11. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> On the suitability of dependence graphs for representing programs, </title> <institution> Department of Computer Sciences, </institution> <note> University of WisconsinMadison (August 1988). </note>
Reference-contexts: If the merged graph is infeasible (does not correspond to any program), the algorithm reports interference. Determining whether a Program Dependence Graph is feasible has been shown to be NP-complete <ref> [11] </ref>; a similar result can be shown for Program Representation Graphs. The crux of the problem is finding an order for each predicate's control children. However, we expect that, for graphs created by merging the Program Representation Graphs of actual programs, problematic cases will rarely arise.
Reference: 12. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Transactions on Programming Languages and Systems 11(3) pp. </journal> <month> 345-387 (July </month> <year> 1989). </year>
Reference-contexts: The first algorithm that meets the above requirements (i.e., the first algorithm for semantics-based program integration) was given by Horwitz, Prins, and Reps in <ref> [12] </ref>; that algorithm is referred to hereafter as the HPR algorithm. The HPR algorithm represents a fundamental advance over text-based program-integration algorithms and provides the first step in the creation of a theoretical foundation for building a program-integration tool. However, there is room for improvement. <p> However, we expect that, for graphs created by merging the Program Representation Graphs of actual programs, problematic cases will rarely arise. We have explored ways of reducing the search space, in the belief that a backtracking method for solving the remaining step will behave satisfactorily <ref> [12] </ref>. 4.7. An Example Integration the Sequence-Congruence Algorithm (to be discussed in Section 6) were used for Step (1) of the new integration algorithm; (2) the graph fragments ChangedComps A , ChangedComps B , and Preserved; and (3) the merged graph. <p> For instance, if it is asserted that two components have equivalent behavior, the technique of congruence closure [7,17] can merge the equivalence classes to which the two components belong and propagate the effects to combine other equivalence classes. 7. Comparison With Related Work In addition to the HPR algorithm <ref> [12] </ref>, there has been previous work on integrating functions [5], logic programs [15], and specifications [8]. Different models of integration have been used in each case. In Berzins's work on integrating functions, variants A and B are merged without regard to Base.
Reference: 13. <author> Horwitz, S. and Reps, T., </author> <title> Efficient comparison of program slices, </title> <type> Technical Report 982, </type> <institution> Department of Computer Sciences, University of WisconsinMadison (December 1990). </institution>
Reference-contexts: the components of one or more programs into equivalence classes can be done using the Sequence-Congruence Algorithm in worst-case time O (N log N) (where N is the sum of the programs' sizes); such a partitioning requires worst-case time O (N 2 ) using the program slice comparison technique of <ref> [13] </ref>.
Reference: 14. <author> Kuck, D.J., Kuhn, R.H., Leasure, B., Padua, D.A., and Wolfe, M., </author> <title> Dependence graphs and compiler optimizations, pp. </title> <booktitle> 207-218 in Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Williamsburg, VA, </address> <month> January 26-28, </month> <year> 1981), (1981). </year>
Reference: 15. <author> Lakhotia, A. and Sterling, L., </author> <title> Composing recursive logic programs with clausal join, </title> <journal> New Generation Computing 6(2) pp. </journal> <month> 211-225 </month> <year> (1988). </year>
Reference-contexts: Comparison With Related Work In addition to the HPR algorithm [12], there has been previous work on integrating functions [5], logic programs <ref> [15] </ref>, and specifications [8]. Different models of integration have been used in each case. In Berzins's work on integrating functions, variants A and B are merged without regard to Base. <p> Similarly, Lakhotia and Sterling's 1-1 join operation is a two-way merge. However, in their work there is no notion of interference, and the characterization of the semantic properties of the merged program was left as an open question in <ref> [15] </ref>. Feather's work on integrating specifications does take Base into account, but although the integration algorithm preserves syntactic modifications, it does not guarantee any semantic properties of the integrated specification.
Reference: 16. <author> Loveman, D. B., </author> <title> Program Improvement by Source-to-Source Transformation, </title> <journal> JACM 20(1) pp. </journal> <month> 121-145 (Janu-ary </month> <year> 1977). </year>
Reference: 17. <author> Nelson, G. and Oppen, </author> <title> D.C., Fast decision procedures based on congruence closure, </title> <journal> JACM 27(2) pp. </journal> <month> 356-364 (April </month> <year> 1980). </year>
Reference: 18. <author> Ottenstein, K.J. and Ottenstein, L.M., </author> <title> The program dependence graph in a software development environment, </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> April 23-25, </month> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 177-184 (May </month> <year> 1984). </year>
Reference: 19. <author> Reps, T. and Yang, W., </author> <title> The semantics of program slicing, </title> <type> Technical Report 777, </type> <institution> Department of Computer Sciences, </institution> <note> University of WisconsinMadison (June 1988). </note>
Reference-contexts: The Sequence-Congruence Algorithm is not the first to address the problem of equivalent execution behaviors; for example, it is shown in <ref> [19] </ref> that two components with isomorphic slices have equivalent execution behaviors (the slice of a program with respect to a program component c is, roughly, all the statements and predicates in the program that can potentially affect the values produced at c during program execution).
Reference: 20. <author> Reps, T. and Yang, W., </author> <title> The semantics of program slicing and program integration, pp. </title> <booktitle> 360-374 in Proceedings of the Colloquium on Current Issues in Programming Languages, </booktitle> <address> (Barcelona, Spain, March 13-17, </address> <year> 1989), </year> <booktitle> Lecture Notes in Computer Science Vol. </booktitle> <volume> 352, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (March 1989). </address>
Reference-contexts: It is, in general, undecidable to identify congruent vertices exactly; the new integration algorithm can use any safe congruence-testing algorithm (i.e., one that identifies a subset of the exact set of congruent pairs of vertices). For example, comparing program slices is a safe congruence-testing algorithm <ref> [20] </ref>. Our investigation of appropriate congruence-testing algorithms led to the development of the Sequence-Congruence Algorithm, which will be described in Section 6. One advantage of the new integration algorithm is that it can easily exploit additional facts about program semantics.
Reference: 21. <author> Rich, C., </author> <title> Inspection methods in programming: cliches and plans, </title> <journal> A.I. </journal> <volume> Memo No. 1005, </volume> <booktitle> Artificial Intelligence Laboratory, </booktitle> <publisher> M.I.T., </publisher> <address> Cambridge, MA (December 1987). </address>
Reference-contexts: Relevant work on program-optimization and transformation techniques for graph representations similar to PRGs includes [22], [9], and <ref> [21] </ref>. APPENDIX. PROOF OF THE INTEGRATION THEOREM This appendix gives the detailed proof of the integration theorem stated in Section 5.
Reference: 22. <author> Rosen, B., Wegman, M.N., and Zadeck, F.K., </author> <title> Global value numbers and redundant computations, pp. </title> <booktitle> 12-27 in Conference Record of the Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), (1988). </year>
Reference-contexts: Relevant work on program-optimization and transformation techniques for graph representations similar to PRGs includes <ref> [22] </ref>, [9], and [21]. APPENDIX. PROOF OF THE INTEGRATION THEOREM This appendix gives the detailed proof of the integration theorem stated in Section 5.
Reference: 23. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year>
Reference: 24. <author> Yang, W., Horwitz, S., and Reps, T., </author> <title> Detecting program components with equivalent behaviors, </title> <type> Technical Report 840, </type> <institution> Department of Computer Sciences, University of Wisconsin, Madison, </institution> <address> WI (April 1989). </address>
Reference-contexts: Because the new integration algorithm can be used with any safe congruence-testing algorithm, this paper actually describes a class of integration algorithms that accommodate semantics-preserving transformations. One congruence-testing algorithm is given in Section 6; the correctness of this algorithm is proved fully in <ref> [24] </ref>. The remainder of the paper is organized into six sections, as follows. Section 2 summarizes and contrasts the techniques used by the HPR algorithm and the integration algorithm from this paper. Section 3 defines the graph representation of programs used by the new integration algorithm.
Reference: 25. <author> Yang, W., </author> <title> A new algorithm for semantics-based program integration, </title> <type> Ph.D. Thesis, </type> <institution> Department of Computer Sciences, University of Wisconsin, Madison, WI (1990). </institution>
Reference-contexts: THEOREM. (Sequence-Congruence Theorem). Program components that are in the same final partition determined by the Sequence-Congruence Algorithm have equivalent execution behaviors. For the sake of brevity, the proof of the theorem is not included in this paper; full details can be found in <ref> [25] </ref>. (A rough outline of the proof is as follows: Suppose the theorem is not correct. Then there are program components that are in the same final partition but have inequivalent execution behaviors. <p> ACM Transactions on Software Engineering and Methodology Vol 1, No 3, July 1992 pp 310-354 - 25 - We have shown that when the Sequence-Congruence Algorithm is used for congruence testing, the new integration algorithm is strictly better than the HPR algorithm in the following sense <ref> [25] </ref>: (1) The new algorithm succeeds whenever the HPR algorithm succeeds. (2) The integrated program produced by the new algorithm satisfies the integration criteria stated in Section 1. (3) There are integration problems on which the new algorithm succeeds while the HPR algorithm reports interference.
Reference: 26. <author> Yang, W., Horwitz, S., and Reps, T., </author> <title> A program integration algorithm that accommodates semantics-preserving transformations, pp. </title> <booktitle> 133-143 in Proceedings of the Fourth Symposium on Software Development Environments, </booktitle> <address> (Irvine, CA, </address> <month> December 3-5, </month> <year> 1990), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1990). </address> <note> ACM Transactions on Software Engineering and Methodology Vol 1, No 3, July 1992 pp 310-354 </note>
Reference-contexts: Yang, IBM Corporation, Research Triangle Park, NC 27709 S. Horwitz and T. Reps, Computer Sciences Department, Univ. of Wisconsin, 1210 W. Dayton St., Madison, WI 53706. A preliminary version of this paper appeared in the Proceedings of the Fourth ACM SIGSOFT Symposium on Software Development Environments <ref> [26] </ref>. ACM Transactions on Software Engineering and Methodology Vol 1, No 3, July 1992 pp 310-354 - 2 - program that includes the changes introduced in the variants as well as the portions of Base that are preserved in both variants.
References-found: 26

