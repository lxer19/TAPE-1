URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-zidoum.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Email: Email  pf@info.fundp.ac.be  
Title: Schema-Guided Synthesis of Constraint Logic Programs  
Author: Hamza Zidoum, Pierre Flener, and Brahim Hnich 
Note: to:  
Abstract: By focusing on the family of assignment problems (such as graph colouring, n-Queens, etc), we show how to adapt D.R. Smith's Kids approach for the synthesis of constraint programs, rather than applicative Refine programs with explicit constraint propagation and pruning code. Synthesis is guided by a global search program schema and can be fully automated with little effort, due to some innovative ideas. CLP(Sets) programs are equivalent in expressiveness to our input specifications. After optimisations, the synthesised programs would be competitive with hand-crafted ones. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Ambert, B. Legeard, and E. Legros. </author> <title> Programmation en logique avec contraintes sur ensembles et multi-ensembles hereditairement finis. </title> <booktitle> Techniques et Sciences Informatiques 15(3) </booktitle> <pages> 297-328, </pages> <year> 1996. </year>
Reference-contexts: Since our synthesis is fully automatic, starting from short and elegant specifications, our approach thus seems viable. Our specification language is equivalent in its high expressiveness to the CLP (Sets) programming languages (such as CLP S <ref> [1] </ref>, Cojunto [5]); we thus do not aim at synthesising CLP (Sets) programs, but rather at alternative ways of compiling them.
Reference: [2] <author> D. Diaz and Ph. Codognet. </author> <title> A minimal extension of the WAM for clp(FD). </title> <editor> In D.S. Warren (ed), </editor> <booktitle> Proc. of ICLP'93, </booktitle> <pages> pp. 774-790. </pages> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: 6.0 10 [Runtime (ms)] Synthesised LP Synthesised clp (FD) (a) n-Queens 10 20 30 40 Number of regions 2.0 4.0 6.0 10 [Runtime (ms)] Synthesised clp (FD) Synthesised LP (b) Graph Colouring 7 Benchmarks In the following table, we first compare our synthesised CLP programs (run under clp (F D) <ref> [2] </ref>) with the (standard) logic program counterparts (also run under clp (F D)) of Kids-synthesised Refine programs (with hand-derived filters). <p> We chose Finite Domains (FD) as constraint domain because of the well-known high performance of CLP (FD). Map Colouring (France) Hamiltonian Path 8-Queens Synthesised CLP (FD) programs 27,150 ms 50 ms 100 ms Synthesised LP programs overflow 527 ms 3260 ms Hand-crafted CLP (FD) programs <ref> [2] </ref> 5,230 ms 20 ms 30 ms Table 1: Benchmarks We also compare our synthesised CLP (FD) programs with hand-crafted CLP (FD) programs.
Reference: [3] <author> Y. Deville and P. Van Hentenryck. </author> <title> Construction of CLP programs. In D.R. </title> <editor> Brough (ed), </editor> <booktitle> Logic Programming: New Frontiers, </booktitle> <pages> pp. 112-135, </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1992. </year>
Reference-contexts: Very few works deal with the synthesis and transformation of CLP programs. The authors of [8] show the possibility of synthesising steadfast CLP programs, however they do not exhibit such a synthesis method. A manual and informal method for constructing CLP programs from specifications is given in <ref> [3] </ref>. We here outline a completely automatic and formal method for synthesis, and leave optimising transformations for future work. Schema-guided synthesis of CLP programs is also based on a global search schema. We use particular cases of that general schema to instantiate its place-holders.
Reference: [4] <author> P. Flener, K.-K. Lau, and M. Ornaghi. </author> <title> Correct-schema-guided synthesis of steadfast programs. </title> <editor> In M. Lowry and Y. Ledru (eds), </editor> <booktitle> Proc. of ASE'97, </booktitle> <pages> pp. 153-160. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1997. </year>
Reference-contexts: ; C 2 i 2 M : member (hR 1 ; R 2 i; A) ! C 1 6= C 2 (S colour ) where member is a primitive (with the usual meaning). 3 A Global Search Program Schema for CLP Let us first recall a definition of (program) schemas <ref> [4] </ref>: Definition 3.1 (Program Schemas) A program schema for a programming methodology M is a couple hT; Ai, where template T is an open program showing the (problem-independent) data-flow and control-flow of programs constructed according to M , and axioms A constrain the (problem-dependent) programs for the open relations in T <p> This can be generalised to open programs, the correctness criterion being then called steadfastness <ref> [4] </ref>. <p> Second, prove that P r is steadfast wrt to S r and S rgs . 2 4 Schema Particularisations In theory, one could use the global search schema in a way analogous to the way the divide-and-conquer schema was used in <ref> [9, 4] </ref> to guide synthesis, namely by following a strategy of (a) arbitrarily choosing programs for some of the open relations (satisfying the axioms of course) from a pool of frequently used such programs, (b) propagating their concrete specifications across the axioms to set up concrete specifications for the remaining open <p> Also note that we have thus hand-synthesised in advance programs for the relations defined by the particularisation: some of these syntheses were trivial, for the others we used a divide-and-conquer schema for guidance <ref> [9, 4] </ref>. <p> The synthesised programs are not small (minimum 33 atoms, in a very expressive programming language), and making them steadfast reusable components for a programming-in-the-large approach by embedding their whole development in a framework-based approach <ref> [4] </ref> should not be too difficult. The results presented in this paper are however not just a simple transcription of the Kids approach from Refine to CLP, but they also reflect new ideas, as indicated all over this paper.
Reference: [5] <author> C. Gervet. </author> <title> Interval propagation to reason about sets: Definition and implementation of a practical language. </title> <booktitle> Constraints 1(3) </booktitle> <pages> 191-244, </pages> <year> 1997. </year>
Reference-contexts: Since our synthesis is fully automatic, starting from short and elegant specifications, our approach thus seems viable. Our specification language is equivalent in its high expressiveness to the CLP (Sets) programming languages (such as CLP S [1], Cojunto <ref> [5] </ref>); we thus do not aim at synthesising CLP (Sets) programs, but rather at alternative ways of compiling them. Comparing execution times is however still meaningless because of the prototypical nature of CLP (Sets) compilers (which sort-of normalise the programs into Prolog programs and add constraint-solving code in Prolog).
Reference: [6] <author> I. Kraan, D. Basin, and A. Bundy. </author> <title> Middle-out reasoning for logic program synthesis. </title> <editor> In D.S. Warren (ed), </editor> <booktitle> Proc. of ICLP'93, </booktitle> <pages> pp. 441-455. </pages> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Computing such a substitution often involves second-order semi-unification, which is decidable but NP-complete in general, though linear in the case of higher-order patterns <ref> [6] </ref>, where all predicate variables (such as the P i and Q i ) apply to distinct variables only, which is the case here.
Reference: [7] <author> J. Jaffar and M.J. Maher. </author> <title> Constraint logic programming: A survey. </title> <journal> J. of Logic Programming 19-20:503-582, </journal> <year> 1994. </year>
Reference-contexts: Instead of synthesising Refine programs, our work concentrates on synthesising constraint (logic) programs. Constraint Logic Programming (CLP) <ref> [7] </ref> is a programming paradigm especially suited for solving combinatorial problems, thanks to its double reasoning: the symbolic reasoning expresses the logic properties of the problem, while the constraint satisfaction reasoning (over several computational domains, such as reals, booleans, finite domains, sets, . . . ) uses constraint propagation to keep <p> CLP languages contain a decision procedure, called SAT , which checks whether a constraint store is satisfiable <ref> [7] </ref>. This last axiom sets up a necessary condition that constrain must establish. Given the left-hand side of the implication, such a condition can be derived using automated theorem proving (ATP) technology, as shown in [9, 10] for instance.
Reference: [8] <author> K.-K. Lau and M. Ornaghi. </author> <title> A formal approach to deductive synthesis of constraint logic programs. </title> <editor> In J.W. Lloyd (ed), </editor> <booktitle> Proc. of ILPS'95, </booktitle> <pages> pp. 543-557. </pages> <publisher> The MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: In this paper, we only deal with decision problems, since optimisation problems can be treated as simple extensions of decision problems, namely by adding a cost domain and a cost function. Very few works deal with the synthesis and transformation of CLP programs. The authors of <ref> [8] </ref> show the possibility of synthesising steadfast CLP programs, however they do not exhibit such a synthesis method. A manual and informal method for constructing CLP programs from specifications is given in [3].
Reference: [9] <author> D.R. Smith. </author> <title> Top-down synthesis of divide-and-conquer algorithms. </title> <booktitle> Artificial Intelligence 27(1) </booktitle> <pages> 43-96, </pages> <year> 1985. </year>
Reference-contexts: This last axiom sets up a necessary condition that constrain must establish. Given the left-hand side of the implication, such a condition can be derived using automated theorem proving (ATP) technology, as shown in <ref> [9, 10] </ref> for instance. Of course, we are not interested in too weak such a condition, such as the trivial solution true, but rather in a stronger one. <p> Second, prove that P r is steadfast wrt to S r and S rgs . 2 4 Schema Particularisations In theory, one could use the global search schema in a way analogous to the way the divide-and-conquer schema was used in <ref> [9, 4] </ref> to guide synthesis, namely by following a strategy of (a) arbitrarily choosing programs for some of the open relations (satisfying the axioms of course) from a pool of frequently used such programs, (b) propagating their concrete specifications across the axioms to set up concrete specifications for the remaining open <p> Also note that we have thus hand-synthesised in advance programs for the relations defined by the particularisation: some of these syntheses were trivial, for the others we used a divide-and-conquer schema for guidance <ref> [9, 4] </ref>.
Reference: [10] <author> D.R. Smith. </author> <title> The structure and design of global search algorithms. </title> <type> Technical Report KES.U.87.12, </type> <institution> Kestrel Institute, </institution> <year> 1988. </year>
Reference-contexts: 1 Introduction This work is inspired by D.R. Smith's research on synthesising global search programs (in the Refine language) from first-order logic specifications (also in Refine) <ref> [10, 11, 12] </ref>. The basic idea of global search is to represent and manipulate sets of candidate solutions. <p> We use particular cases of that general schema to instantiate its place-holders. Although we are still working on it, we think that the number of these particular cases will be small (but probably more than the seven like for Kids <ref> [10, 11, 12] </ref>). In this paper, we only tackle the family of assignment problems. <p> This last axiom sets up a necessary condition that constrain must establish. Given the left-hand side of the implication, such a condition can be derived using automated theorem proving (ATP) technology, as shown in <ref> [9, 10] </ref> for instance. Of course, we are not interested in too weak such a condition, such as the trivial solution true, but rather in a stronger one. <p> then necessary at synthesis time! Also note that the derivation of the output condition of constrain depends on the calling context of constrain, namely that it is invoked after split: this gives rise to rather effective (namely incremental) constraint-posing code [and stands in contrast to Smith's calling-context-independent derivation of filters <ref> [10, 11] </ref> and cuts [12], which thus tend to be non-incremental]. (Sentences between [. . . ] are for understanding the differences with Smith's work.) Notice that constrain just poses constraints on the search space, the actual solutions being enumerated by generate once all constraints have been posed, because we use <p> However, in general this puts heavy demands on ATP technology, and in particular this turns out much more difficult for the global search schema than for the divide-and-conquer one <ref> [10] </ref>. Fortunately, a very large percentage of global search programs falls into one of seven families identified by Smith, each representing a particular case of the global search schema (in the sense that programs for all its open relations are adequately chosen in advance), here called a particularisation. <p> We here investigate the family of assignment problems, which amounts to enumerating mappings from a finite list into a finite integer interval, other families enumerating permutations of a given list, sublists of (given or bounded) length k over a given list, sequences over a given list, etc <ref> [10] </ref>. Definition 4.1 (Particularisations) A particularisation of the global search schema is a set of formulas defining D, , satisfies, O init , O extr , O split , and O constr , such that the axioms A 1 to A 3 are satisfied. <p> We hope to replicate this effort for the other six families of global search problems identified by Smith <ref> [10] </ref>. The synthesised programs are not small (minimum 33 atoms, in a very expressive programming language), and making them steadfast reusable components for a programming-in-the-large approach by embedding their whole development in a framework-based approach [4] should not be too difficult.
Reference: [11] <author> D.R. Smith. kids: </author> <title> A semiautomatic program development system. </title> <journal> IEEE Trans. Software Engineering 16(9) </journal> <pages> 1024-1043, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction This work is inspired by D.R. Smith's research on synthesising global search programs (in the Refine language) from first-order logic specifications (also in Refine) <ref> [10, 11, 12] </ref>. The basic idea of global search is to represent and manipulate sets of candidate solutions. <p> We use particular cases of that general schema to instantiate its place-holders. Although we are still working on it, we think that the number of these particular cases will be small (but probably more than the seven like for Kids <ref> [10, 11, 12] </ref>). In this paper, we only tackle the family of assignment problems. <p> then necessary at synthesis time! Also note that the derivation of the output condition of constrain depends on the calling context of constrain, namely that it is invoked after split: this gives rise to rather effective (namely incremental) constraint-posing code [and stands in contrast to Smith's calling-context-independent derivation of filters <ref> [10, 11] </ref> and cuts [12], which thus tend to be non-incremental]. (Sentences between [. . . ] are for understanding the differences with Smith's work.) Notice that constrain just poses constraints on the search space, the actual solutions being enumerated by generate once all constraints have been posed, because we use
Reference: [12] <author> D.R. Smith. </author> <title> Towards the synthesis of constraint propagation algorithms. </title> <editor> In Y. Deville (ed), </editor> <booktitle> Proc. of LOPSTR'93, </booktitle> <pages> pp. 1-9, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <month> 8 </month>
Reference-contexts: 1 Introduction This work is inspired by D.R. Smith's research on synthesising global search programs (in the Refine language) from first-order logic specifications (also in Refine) <ref> [10, 11, 12] </ref>. The basic idea of global search is to represent and manipulate sets of candidate solutions. <p> We use particular cases of that general schema to instantiate its place-holders. Although we are still working on it, we think that the number of these particular cases will be small (but probably more than the seven like for Kids <ref> [10, 11, 12] </ref>). In this paper, we only tackle the family of assignment problems. <p> time! Also note that the derivation of the output condition of constrain depends on the calling context of constrain, namely that it is invoked after split: this gives rise to rather effective (namely incremental) constraint-posing code [and stands in contrast to Smith's calling-context-independent derivation of filters [10, 11] and cuts <ref> [12] </ref>, which thus tend to be non-incremental]. (Sentences between [. . . ] are for understanding the differences with Smith's work.) Notice that constrain just poses constraints on the search space, the actual solutions being enumerated by generate once all constraints have been posed, because we use a constraint language. 3.3 <p> This shows that at least one order of magnitude is gained in efficiency by switching from an ordinary symbolic language to a constraint one (a comparison with the more recent SpecWare and PlanWare <ref> [12] </ref> systems of Kestrel Institute is underway). We chose Finite Domains (FD) as constraint domain because of the well-known high performance of CLP (FD).
References-found: 12

