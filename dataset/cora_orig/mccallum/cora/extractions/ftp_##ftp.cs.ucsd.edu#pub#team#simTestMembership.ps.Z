URL: ftp://ftp.cs.ucsd.edu/pub/team/simTestMembership.ps.Z
Refering-URL: http://www.cs.ucsd.edu/users/flaviu/publications.html
Root-URL: http://www.cs.ucsd.edu
Email: fgalvarez, flaviug@cs.ucsd.edu  
Title: Simulation-based Test of Synchronous and Asynchronous Fault-tolerant Group Membership Services  
Author: Guillermo A. Alvarez Flaviu Cristian 
Keyword: Technical areas: Software Testing, Fault-Tolerance, Real-Time Systems  
Address: La Jolla, CA 920930114, USA  
Affiliation: Department of Computer Science and Engineering University of California, San Diego  
Abstract: We address the problem of gaining assurance on the correctness of fault-tolerant and real-time distributed protocols. We validate implementations of two group membership protocols by running a centralized simulation of the distributed system, and testing whether they satisfy the safety and timeliness properties prescribed by their specifications. Our testing environment performs deterministic experiments that include both normal workloads and failures injected into the execution, to test the behavior of the protocols under the failure scenarios they are supposed to tolerate. The protocols assume different system models, and depend on quite different sets of underlying services. Even though their specifications contain properties that can not be evaluated accurately in a distributed platform, our testing environment overcomes this limitation. The tests performed uncovered several flaws in the implementations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Alvarez and F. Cristian. </author> <title> A centralized simulation approach to testing distributed fault-tolerant protocols. </title> <type> Technical Report CS95-458, </type> <institution> CS Dept., Univ. of California-San Diego, </institution> <month> December </month> <year> 1995. </year> <note> Available via anonymous ftp at cs.ucsd.edu as /pub/galvarez/papers/failsim.ps.Z. </note>
Reference-contexts: The most viable approaches test implementations by subjecting them to experiments that include both normal workloads and failures injected into the execution, to test the service's behavior under the failure scenarios it is supposed to tolerate [10, 2, 15, 13]. However, we have found <ref> [1] </ref> that testing protocol properties on distributed platforms presents considerable difficulties; among them, we can This work was partially supported by the Air Force Office of Scientific Research. 1 cite the inaccessibility of the global state of the system, the occurrence of unwanted failures, and the lack of control over the <p> Our approach to experimental validation is based on performing a set of well-designed experiments on the implementation under test, and verifying that the properties of the specification hold at every time during them. We designed and implemented a tool based on a centralized simulator <ref> [1] </ref>, that executes all the processes of the distributed system in a single address space. This centralization is transparent for the processes under test, that run the same uninstrumented code that would be used in the real distributed system. <p> Cesium <ref> [1] </ref> is a testing environment that allows the tester to perform deterministic experiments on a fault-tolerant, real-time protocol implementation, while verifying that it satisfies its specification at every time during the experiments. <p> Thus, Cesium 3 introduces no timing perturbation in the execution being observed. No spurious failures ever occur as the protocol executes in a totally controlled simulation environment. We proved in <ref> [1] </ref> that Cesium can execute exactly the set of runs that can occur in the real system being simulated. We also proved that Cesium tests exactly the safety and timeliness properties of the protocol implementation|only real violations are reported, and no violation can occur without being detected. <p> In contrast, Cesium can evaluate all these properties exactly, as we prove in <ref> [1] </ref>. 4.2 Experiments with the three-round protocol We performed four experiment sets on our implementation of the three-round protocol, with a varying number of nodes ranging from three to ten, and choosing random subsets of the nodes for crashes, performance failures, and communication partitions (experiments were repeatable by using the same
Reference: [2] <author> J. Arlat, A. Costes, Y. Crouzet, J.-C. Laprie, and D. Powell. </author> <title> Fault injection and dependability evaluation of fault-tolerant systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 42(8) </volume> <pages> 913-23, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: The most viable approaches test implementations by subjecting them to experiments that include both normal workloads and failures injected into the execution, to test the service's behavior under the failure scenarios it is supposed to tolerate <ref> [10, 2, 15, 13] </ref>. <p> However, it resulted in useless message traffic. We detected this problem by examining the traces generated by our experiments. After these errors were fixed, subsequent executions of our experiment sets did not detect any more problems. 5 Related work The Messaline tool <ref> [2] </ref> uses hardware-level fault injection as an alternative to analytical modeling, to evaluate the dependability and fail-silence properties of the Delta-4 fault-tolerant architecture. Echtle and Chen [12] describe heuristics for achieving control path coverage by manipulating the messages exchanged between tasks. <p> In probabilistic approaches that run a large number of random experiments to determine statistical measures (like <ref> [2, 14, 16] </ref>) it is usually difficult to establish a correspondence between the low-level faults injected and the failures observed at the level of the protocol under test.
Reference: [3] <author> E. Brewer, C. Dellarocas, A. Colbrook, and W. Weihl. Proteus: </author> <title> A high-performance parallel-architecture simulator. </title> <booktitle> In Proceedings of the 1992 ACM SIGMETRICS, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: Testing performed on distributed platforms [10, 12, 15, 16] is subject to the limitations discussed in Section 3 and 4 for coordination and property testing. Regarding simulators, Proteus <ref> [3] </ref> and Tango [9] are centralized simulators of MIMD parallel architectures. Even though they are well suited for debugging and performance evaluation, they can not simulate the occurrence of any fault, and do not provide support for timely testing of protocol properties.
Reference: [4] <author> S. Budkowski. </author> <title> Estelle development toolset (EDT). </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 25(1) </volume> <pages> 63-82, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Even though they are well suited for debugging and performance evaluation, they can not simulate the occurrence of any fault, and do not provide support for timely testing of protocol properties. Furthermore, they assume a fixed set of L-services, and require that the code under test be instrumented. EDT <ref> [4] </ref> simulates the execution of specifications written in the Estelle language; the tester has access to the global state, and safety properties can be tested. Estelle's time semantics is not well suited for the evaluation of hard real-time properties, as relevant events can be arbitrarily late.
Reference: [5] <author> F. Cristian. </author> <title> A rigorous approach to fault-tolerant programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(1):23-31, </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: Cesium is based on a centralized simulator of distributed executions, that multiplexes all the processes of the distributed system being simulated in a single address space. The tester forces the occurrence of failures during the execution by invoking either Cesium primitives, or failure operations <ref> [5] </ref> written for the particular failure semantics of the protocol under test. The workload and the injected failures are supervised by a centralized task, the driver, that controls the progress of the experiment by monitoring the global state of the system.
Reference: [6] <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> <volume> 4 </volume> <pages> 175-187, </pages> <year> 1991. </year> <month> 11 </month>
Reference-contexts: A group membership service provides each client process with a view of the nodes that are correct and connected to it. This paper reports the experimental evaluation of the correctness and fault-tolerance of two implementations of group membership protocols. One of these protocols <ref> [6] </ref> is for synchronous (hard real-time) systems, and the other [8] is for asynchronous systems, where network partitions can occur and there is no bound in communication delays. For each protocol, we list the properties that it must satisfy. <p> The workload and the injected failures are supervised by a centralized task, the driver, that controls the progress of the experiment by monitoring the global state of the system. The protocol under test, in general, depends upon other lower-level services (l-services). For example, the synchronous membership protocol <ref> [6] </ref> tested in this paper depends on clocks internally synchronized within a maximum deviation of *, on an unreliable datagram service, and on a synchronous atomic broadcast service. The tester provides the code for the driver, the protocol under test, and the necessary l-servers. <p> Furthermore, we assume that the testing code can be activated as a result of an arriving message or a timer's expiration|just as the protocol under test. 3 Synchronous group membership We performed several testing experiments on an implementation of the attendance list synchronous group membership protocol <ref> [6] </ref>. The attendance list protocol ensures that every correct processor perceives the same sequence of failures and restarts in the system, which result in the formation of successive groups. <p> The details, analysis, and pseudocode of the attendance list protocol can be found in <ref> [6] </ref>. 3.1 Properties of the synchronous service Table 1 shows the set of properties that every correct implementation of the protocol must satisfy. Properties with names of the form SM s are safety properties, and those with names of the form SM t are timeliness properties. <p> We spotted this problem when examining the execution traces for our experiments|as the spurious rounds did not result in upcalls to the driver. * In the pseudocode of <ref> [6] </ref>, each s-server checks at membership confirmation time whether it has received a timely attendance list or not.
Reference: [7] <author> F. Cristian. </author> <title> Understanding fault-tolerant distributed systems. </title> <journal> Communications of ACM, </journal> <volume> 34(2) </volume> <pages> 56-78, </pages> <month> Feb </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Distributed fault-tolerant group services such as group membership, atomic broadcast, and clock synchronization, allow a set of processors to cooperate despite the occurrence of component failures <ref> [7] </ref>. These services are basic building blocks for the development of dependable applications, for they exhibit a well-defined behavior when failures occur|either masking them completely, or degrading the quality of service in a predictable way. Real-time services must, in addition, deliver the correct results within bounded time intervals.
Reference: [8] <author> F. Cristian and F. Schmuck. </author> <title> Agreeing on processor-group membership in asynchronous distributed systems. </title> <type> Technical Report CSE95-428, </type> <institution> Dept. of Computer Science and Engineering, University of California, </institution> <address> San Diego, </address> <year> 1995. </year> <note> Also available by anonymous ftp from cs.ucsd.edu/pub/team/asyncmembership.ps.Z. </note>
Reference-contexts: This paper reports the experimental evaluation of the correctness and fault-tolerance of two implementations of group membership protocols. One of these protocols [6] is for synchronous (hard real-time) systems, and the other <ref> [8] </ref> is for asynchronous systems, where network partitions can occur and there is no bound in communication delays. For each protocol, we list the properties that it must satisfy. <p> of SM s s , had the execution been allowed to proceed.) We repeated all of the three experiment sets after correcting each error, and there were no property violations for our final version. 4 Asynchronous group membership The three-round with partition detection group membership protocol was originally presented in <ref> [8] </ref>. The three-round protocol assumes the timed asynchronous system model. Every participating node has a hardware clock that drifts from real time at a bounded rate. Local clocks need not be synchronized. The protocol depends upon an unreliable datagram service for communication. <p> The detailed pseudocode of the three-round protocol can be found in <ref> [8] </ref>. 4.1 Properties of the asynchronous service Table 2 lists the properties satisfied by the asynchronous membership service. We assume that group identifiers can be totally ordered. As before, J and D denote the maximum delays to form a new group as a result of a join and a partition.
Reference: [9] <author> H. Davis, S. Goldschmidt, and J. Hennessy. </author> <title> Tango: A multiprocessor simulation and tracing system. </title> <booktitle> In Proceedings of the 1991 Int'l. Conf. on Parallel Processing, </booktitle> <month> August </month> <year> 1991. </year>
Reference-contexts: Testing performed on distributed platforms [10, 12, 15, 16] is subject to the limitations discussed in Section 3 and 4 for coordination and property testing. Regarding simulators, Proteus [3] and Tango <ref> [9] </ref> are centralized simulators of MIMD parallel architectures. Even though they are well suited for debugging and performance evaluation, they can not simulate the occurrence of any fault, and do not provide support for timely testing of protocol properties.
Reference: [10] <author> S. Dawson, F. Jahanian, T. Mitton, and T. Tung. </author> <title> Testing of fault-tolerant and real-time distributed systems via protocol fault injection. </title> <booktitle> In Proceedings of the 26th International Symposium on Fault-Tolerant Computing, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: The most viable approaches test implementations by subjecting them to experiments that include both normal workloads and failures injected into the execution, to test the service's behavior under the failure scenarios it is supposed to tolerate <ref> [10, 2, 15, 13] </ref>. <p> In probabilistic approaches that run a large number of random experiments to determine statistical measures (like [2, 14, 16]) it is usually difficult to establish a correspondence between the low-level faults injected and the failures observed at the level of the protocol under test. The SockPFI/Orchestra tool <ref> [10] </ref> inserts an additional layer below the layer under test by reimplementing the standard socket interface, and can simulate communication failures by filtering and altering the messages that pass through the test layer. <p> Orchestra does not 10 address the problem of coordinating the separate injection agents to coerce the execution into hard--to-reach states, provides no mechanism for testing safety properties, and will in general introduce timing perturbations in the execution. Testing performed on distributed platforms <ref> [10, 12, 15, 16] </ref> is subject to the limitations discussed in Section 3 and 4 for coordination and property testing. Regarding simulators, Proteus [3] and Tango [9] are centralized simulators of MIMD parallel architectures.
Reference: [11] <author> D. Dolev, J. Halpern, and R. </author> <title> Strong. On the possibility and impossibility of achieving clock synchronization. </title> <journal> Journal of Computer and System Science, </journal> <volume> 32(2) </volume> <pages> 230-250, </pages> <year> 1986. </year>
Reference-contexts: In general, it is not possible to determine the exact interval of real time during which a real distributed system is stable. There are several reasons for that. First, it is impossible to have perfectly synchronized local clocks in a distributed system <ref> [11] </ref>. Clocks can be synchronized within a maximum deviation *, that depends on the communication uncertainty of the datagram service, the number of nodes, and the interval between successive clock synchronizations. Typical values for * are in the order of several milliseconds.
Reference: [12] <author> K. Echtle and Y. Chen. </author> <title> Evaluation of deterministic fault injection for fault-tolerant protocol testing. </title> <booktitle> In Proceedings of the 21rd International Symposium on Fault-Tolerant Computing, </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: After these errors were fixed, subsequent executions of our experiment sets did not detect any more problems. 5 Related work The Messaline tool [2] uses hardware-level fault injection as an alternative to analytical modeling, to evaluate the dependability and fail-silence properties of the Delta-4 fault-tolerant architecture. Echtle and Chen <ref> [12] </ref> describe heuristics for achieving control path coverage by manipulating the messages exchanged between tasks. A similar approach has been followed by Tao et al [18] to validate software-implemented mechanisms in the Voltan distributed system. <p> Orchestra does not 10 address the problem of coordinating the separate injection agents to coerce the execution into hard--to-reach states, provides no mechanism for testing safety properties, and will in general introduce timing perturbations in the execution. Testing performed on distributed platforms <ref> [10, 12, 15, 16] </ref> is subject to the limitations discussed in Section 3 and 4 for coordination and property testing. Regarding simulators, Proteus [3] and Tango [9] are centralized simulators of MIMD parallel architectures.
Reference: [13] <author> K. Echtle and M. Leu. </author> <title> Test of fault tolerant distributed systems by fault injection. </title> <booktitle> In Proc. of the IEEE Workshop on Fault-Tolerant Parallel and Distributed Systems, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: The most viable approaches test implementations by subjecting them to experiments that include both normal workloads and failures injected into the execution, to test the service's behavior under the failure scenarios it is supposed to tolerate <ref> [10, 2, 15, 13] </ref>.
Reference: [14] <author> K. Goswami and R. Iyer. </author> <title> Simulation of software behavior under hardware faults. </title> <booktitle> In Proceedings of the 23rd International Symposium on Fault-Tolerant Computing, </booktitle> <address> Toulouse, France, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: In probabilistic approaches that run a large number of random experiments to determine statistical measures (like <ref> [2, 14, 16] </ref>) it is usually difficult to establish a correspondence between the low-level faults injected and the failures observed at the level of the protocol under test. <p> EDT [4] simulates the execution of specifications written in the Estelle language; the tester has access to the global state, and safety properties can be tested. Estelle's time semantics is not well suited for the evaluation of hard real-time properties, as relevant events can be arbitrarily late. Finally, Depend <ref> [14] </ref> simulates the occurrence of hardware faults by executing a user-provided graph representation of the program under test. 6 Conclusions We described the experimental validation of two group membership protocol implementations. The protocols were tested by executing them under fully controlled conditions in a centralized simulation environment.
Reference: [15] <author> S. Han, K. Shin, and H. Rosenberg. Doctor: </author> <title> An integrated software fault injection environment for distributed real-time systems. </title> <booktitle> In Proceedings of the International Computer Performance and Dependability Symposium, </booktitle> <publisher> Erlangen, </publisher> <address> Germany, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: The most viable approaches test implementations by subjecting them to experiments that include both normal workloads and failures injected into the execution, to test the service's behavior under the failure scenarios it is supposed to tolerate <ref> [10, 2, 15, 13] </ref>. <p> Echtle and Chen [12] describe heuristics for achieving control path coverage by manipulating the messages exchanged between tasks. A similar approach has been followed by Tao et al [18] to validate software-implemented mechanisms in the Voltan distributed system. Fiat [16] and Doctor <ref> [15] </ref> rely on a central process to control fault injection and monitoring agents at each participating node. <p> Orchestra does not 10 address the problem of coordinating the separate injection agents to coerce the execution into hard--to-reach states, provides no mechanism for testing safety properties, and will in general introduce timing perturbations in the execution. Testing performed on distributed platforms <ref> [10, 12, 15, 16] </ref> is subject to the limitations discussed in Section 3 and 4 for coordination and property testing. Regarding simulators, Proteus [3] and Tango [9] are centralized simulators of MIMD parallel architectures.
Reference: [16] <author> Z. Segall, D. Vrsalovic, D. Siewiorek, D. Yaskin, J. Kownacki, J. Barton, R. Dancey, A. Robin-son, and T. Lin. FIAT: </author> <title> Fault-injection based automated testing environment. </title> <booktitle> In Proceedings of the 18th International Symposium on Fault-Tolerant Computing, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: Echtle and Chen [12] describe heuristics for achieving control path coverage by manipulating the messages exchanged between tasks. A similar approach has been followed by Tao et al [18] to validate software-implemented mechanisms in the Voltan distributed system. Fiat <ref> [16] </ref> and Doctor [15] rely on a central process to control fault injection and monitoring agents at each participating node. <p> In probabilistic approaches that run a large number of random experiments to determine statistical measures (like <ref> [2, 14, 16] </ref>) it is usually difficult to establish a correspondence between the low-level faults injected and the failures observed at the level of the protocol under test. <p> Orchestra does not 10 address the problem of coordinating the separate injection agents to coerce the execution into hard--to-reach states, provides no mechanism for testing safety properties, and will in general introduce timing perturbations in the execution. Testing performed on distributed platforms <ref> [10, 12, 15, 16] </ref> is subject to the limitations discussed in Section 3 and 4 for coordination and property testing. Regarding simulators, Proteus [3] and Tango [9] are centralized simulators of MIMD parallel architectures.
Reference: [17] <author> Sun Microsystems, Inc. </author> <title> The Java Language Specification, V1.0 Beta, </title> <month> August </month> <year> 1996. </year> <note> Available at http://java.sun.com/doc/language specification.html. </note>
Reference-contexts: The tester provides the code for the driver, the protocol under test, and the necessary l-servers. This code is written in the Java programming language <ref> [17] </ref>, augmented with extensions for multithreaded event-driven programming. The driver runs as a centralized task, thus eliminating the limitations of distributed testing agents. The servers of the protocol under test (s-servers) are distributed among the participating simulated processors; the l-servers can be a mix of distributed and centralized simulations.
Reference: [18] <author> S. Tao, P. Ezhilchelvan, and R. Shrivastava. </author> <title> Focused fault injection of software implemented fault tolerance mechanisms of Voltan TMR nodes. </title> <journal> Distributed Systems Engineering, </journal> <volume> 2(1) </volume> <pages> 39-49, </pages> <month> March </month> <year> 1995. </year> <month> 12 </month>
Reference-contexts: Echtle and Chen [12] describe heuristics for achieving control path coverage by manipulating the messages exchanged between tasks. A similar approach has been followed by Tao et al <ref> [18] </ref> to validate software-implemented mechanisms in the Voltan distributed system. Fiat [16] and Doctor [15] rely on a central process to control fault injection and monitoring agents at each participating node.
References-found: 18

