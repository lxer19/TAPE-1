URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/user/tcm/www/tcm_papers/miss_predict_TR.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/user/tcm/www/Papers.html
Root-URL: 
Title: Predicting Data Cache Misses in Non-Numeric Applications Through Correlation Profiling  
Author: Todd C. Mowry Chi-Keung Luk 
Note: This work is supported by grants from the Natural Sciences and Engineering Research Council of Canada, and by a grant from IBM Canada's Centre for Advanced Studies. Todd C. Mowry is partially supported by a Faculty Development Award from IBM. Chi-Keung Luk is partially supported by a Canadian Commonwealth Fellowship.  
Address: Pittsburgh, PA 15213  Toronto, Toronto, Ontario, Canada, M5S 3G4  
Affiliation: School of Computer Science Carnegie Mellon University  Department of Computer Science, University of  
Date: September 1997  
Pubnum: CMU-CS-97-175  
Abstract: An abbreviated version of this paper will appear in the proceedings of the 30th International Symposium on Microarchitecture, Research Triangle Park, North Carolina, December 1-3, 1997. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. G. Abraham and B. R. Rau. </author> <title> Predicting load latencies using cache profiling. </title> <type> Technical Report HPL-94-110, </type> <institution> Hewlett-Packard Company, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: VOID create bintree (BTNODE* root, ...)f ... subdiv bintree (root, ...); create bintree (root!btn [0], ...); create bintree (root!btn <ref> [1] </ref>, ...); ... ... <p> In a follow-up study <ref> [1] </ref>, they also report the improvement in effective cache miss ratio. In contrast with this earlier work, our study has focused on correlation profiling, which is a novel technique that provides superior prediction accuracy relative to summary profiling.
Reference: [2] <author> S. G. Abraham, R. A. Sugumar, D. Windheiser, B. R. Rau, and R. Gupta. </author> <title> Predictability of load/store instruction latencies. </title> <booktitle> In MICRO-26, </booktitle> <pages> pages 139-152, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: The current state-of-the-art approach for dealing with intermediate miss ratios is to treat all static memory references with miss ratios above or below a certain threshold as though they always miss or always hit, respectively <ref> [2] </ref>. However, this all-or-nothing strategy will fail to hide latency when references are predicted to hit but actually miss, and will induce unnecessary overhead when references are predicted to miss but actually hit. <p> We would also like to point that these numbers do not represent the limit of what correlation can achieve. For example, with an 8KB primary data cache, correlation profiling offers a 10% speedup over summary profiling in the case of eqntott. 7 Related Work Abraham et al. <ref> [2] </ref> investigated using summary profiling to associate a single latency tolerance strategy (i.e. either attempt to tolerate the latency or not) with each profiled load. They used this approach to reduce 19 Memory Parameters for the MIPS R10000 Simulator Primary Instr and Data Caches 32KB, 2-way set-assoc.
Reference: [3] <author> G. Ammons, T. Ball, and J. Larus. </author> <title> Exploiting hardware performance counters with flow and context sensitive profiling. </title> <booktitle> In PLDI'97, </booktitle> <month> June </month> <year> 1997. </year>
Reference: [4] <author> P. Chang, E. Hao, T. Yeh, and Y. Patt. </author> <title> Branch classification: a new mechanism for improving branch predictor performance. </title> <booktitle> In MICRO-27, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: Note that 1 (X=Y means X misses out of Y dynamic references.) analogous forms of all three types of correlation profiling have been explored previously in the context of branch prediction <ref> [4, 10, 15, 16] </ref> 1.2 Objectives and Overview The goal of this paper is to determine whether correlation profiling can predict data cache misses more accurately in non-numeric codes than summary profiling, and if so, can we translate this into significant performance improvements by applying software-based latency tolerance techniques with greater <p> The three forms of correlation explored in this study (control-flow, self, and global) were inspired by earlier work on using correlation to enhance branch prediction accuracies <ref> [4, 10, 15, 16] </ref>.
Reference: [5] <author> K.D. Cooper, M.W. Hall, and K. Kennedy. </author> <title> A methodology for procedure cloning. </title> <journal> Computer Languages, </journal> <volume> 19(2), </volume> <month> April </month> <year> 1993. </year> <month> 21 </month>
Reference-contexts: This is good news, since control-flow correlation profiling is the easiest case to exploit in practice by using procedure cloning <ref> [5] </ref> to distinguish call-chain dependent behavior. 6 Applying Correlation Profiling to Prefetching To demonstrate the practicality of correlation profiling, we used both summary and correlation profiling to guide the manual insertion of prefetch instructions into three applications: (eqntott, tsp, and raytrace). <p> In the case of correlation profiling, we used procedure cloning <ref> [5] </ref> to isolate different dynamic instances of a static reference, and adapted the prefetching strategy accordingly with respect to the call sites.
Reference: [6] <author> M. Horowitz, M. Martonosi, T. C. Mowry, and M. D. Smith. </author> <title> Informing memory operations: Providing memory performance feedback in modern processors. </title> <booktitle> In ISCA'96, </booktitle> <pages> pages 260-270, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Rather than settling for this sub-optimal performance, we would prefer to predict dynamic hits and misses more accurately. 1.1.1 Correlation Profiling By exposing caching behavior directly to the user, informing memory operations <ref> [6] </ref> enable new classes of lightweight profiling tools which can collect more sophisticated information than simply the per-reference miss ratios. <p> Although we rely on simulation to capture our profiling information in this study, correlation profiling is a practical technique since it could be performed with relatively little overhead using informing memory operations <ref> [6] </ref>. The remainder of this paper is organized as follows. We begin in Section 2 by discussing the three different types of history information that we use for correlation profiling, and in Section 3 we present a qualitative analysis of the expected performance benefits.
Reference: [7] <author> C.-K. Luk and T. C. Mowry. </author> <title> Compiler-based prefetching for recursive data structures. </title> <booktitle> In Proceed ings of the Seventh International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 222-233, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: To further tolerate latency, a number of promising software-based techniques have been proposed. For example, the compiler can tolerate modest latencies by scheduling non-blocking loads early relative to when their results are consumed [12], and can tolerate larger latencies by inserting prefetch instructions <ref> [7, 9] </ref>. While these software-based techniques provide latency-hiding benefits, they also typically incur runtime overheads. For example, aggressive scheduling of non-blocking loads increases register lifetimes which can lead to spilling, and software-controlled prefetching requires additional instructions to compute prefetch addresses and launch the prefetches themselves.
Reference: [8] <institution> MIPS Technologies Inc. </institution> <note> R10000 Microprocessor User's Manual, Version 1.1, </note> <year> 1996. </year>
Reference-contexts: We assumed that V L = 0:1 when deciding whether to insert prefetches, 3 and we performed fully-detailed simulations of a processor similar to the MIPS R10000 <ref> [8] </ref> (details of the memory hierarchy are shown in Figure 23 (a)). 3 We assume an average prefetch overhead (V ) of two cycles, and an average miss latency (L) of 20 cycles. 18 (a) Miss ratio distribution of correlation-profiled load references (b) CP L due to correlation-profiled loads (c) Overall
Reference: [9] <author> T. C. Mowry, M. S. Lam, and A. Gupta. </author> <title> Design and evaluation of a compiler algorithm for prefetching. </title> <booktitle> In ASPLOS-V, </booktitle> <pages> pages 62-73, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: To further tolerate latency, a number of promising software-based techniques have been proposed. For example, the compiler can tolerate modest latencies by scheduling non-blocking loads early relative to when their results are consumed [12], and can tolerate larger latencies by inserting prefetch instructions <ref> [7, 9] </ref>. While these software-based techniques provide latency-hiding benefits, they also typically incur runtime overheads. For example, aggressive scheduling of non-blocking loads increases register lifetimes which can lead to spilling, and software-controlled prefetching requires additional instructions to compute prefetch addresses and launch the prefetches themselves. <p> Therefore to maximize overall performance, we would like to apply a latency-tolerance technique only to the precise set of dynamic references that would suffer misses. While previous work has addressed this problem for numeric codes <ref> [9] </ref>, this paper focuses on the more difficult but important case of isolating dynamic miss instances in non-numeric applications. 1.1 Predicting Data Cache Misses in Non-Numeric Codes To overcome the compiler's inability to analyze data locality in non-numeric codes, we can instead make use of profiling information.
Reference: [10] <author> S. Pan, K. So, and J. Rahmeh. </author> <title> Improving the accuracy of dynamic branch prediction using branch correlation. </title> <booktitle> In ASPLOS-V, </booktitle> <pages> pages 76-84, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Note that 1 (X=Y means X misses out of Y dynamic references.) analogous forms of all three types of correlation profiling have been explored previously in the context of branch prediction <ref> [4, 10, 15, 16] </ref> 1.2 Objectives and Overview The goal of this paper is to determine whether correlation profiling can predict data cache misses more accurately in non-numeric codes than summary profiling, and if so, can we translate this into significant performance improvements by applying software-based latency tolerance techniques with greater <p> In this case, we might expect a strong correlation between whether htab [i] (the list head pointer) misses and whether subsequent accesses to curr!data (the list elements) also miss. Similarly, if the same entry is accessed twice within a short interval (e.g., htab <ref> [10] </ref>), the fact that the head pointer hits is a strong indicator that the list elements (e.g., A!data and B!data) will also hit. <p> The three forms of correlation explored in this study (control-flow, self, and global) were inspired by earlier work on using correlation to enhance branch prediction accuracies <ref> [4, 10, 15, 16] </ref>.
Reference: [11] <author> A. Rogers, M. Carlisle, J. Reppy, and L. Hendren. </author> <title> Supporting dynamic data structures on distributed memory machines. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 17(2), </volume> <month> March </month> <year> 1995. </year>
Reference-contexts: prefetching as a specific case study. 4.1 Experimental Methodology We measured the impact of correlation profiling on the following 22 non-numeric applications: the entire SPEC95 integer benchmark suite, the additional integer benchmarks contained in the SPEC92 suite, uniprocessor versions of two graphics applications from SPLASH-2 [14], eight applications from Olden <ref> [11] </ref> (a suite of pointer-intensive benchmarks), and the standard UNIX utility awk. Table 1 briefly summarizes these applications, including the input data sets that were run to completion in each case, and Table 2 shows some relevant dynamic statistics of these applications.
Reference: [12] <author> A. Rogers and K. Li. </author> <title> Software support for speculative loads. </title> <booktitle> In ASPLOS-V, </booktitle> <pages> pages 38-50, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: To further tolerate latency, a number of promising software-based techniques have been proposed. For example, the compiler can tolerate modest latencies by scheduling non-blocking loads early relative to when their results are consumed <ref> [12] </ref>, and can tolerate larger latencies by inserting prefetch instructions [7, 9]. While these software-based techniques provide latency-hiding benefits, they also typically incur runtime overheads.
Reference: [13] <author> M. D. Smith. </author> <title> Tracing with pixie. </title> <type> Technical Report CSL-TR-91-497, </type> <institution> Stanford University, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: We compiled each application with -O2 optimization using the standard MIPS C compilers under IRIX 5.3. We used the MIPS pixie utility <ref> [13] </ref> to instrument these binaries, and piped the resulting trace into our detailed performance simulator.
Reference: [14] <author> S. C. Woo, M. Ohara, E. Torrie, J. P. Singh, and A. Gupta. </author> <title> The SPLASH-2 programs: Characterization and methodological considerations. </title> <booktitle> In ISCA'95, </booktitle> <pages> pages 24-38, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: we will focus on software-controlled prefetching as a specific case study. 4.1 Experimental Methodology We measured the impact of correlation profiling on the following 22 non-numeric applications: the entire SPEC95 integer benchmark suite, the additional integer benchmarks contained in the SPEC92 suite, uniprocessor versions of two graphics applications from SPLASH-2 <ref> [14] </ref>, eight applications from Olden [11] (a suite of pointer-intensive benchmarks), and the standard UNIX utility awk. Table 1 briefly summarizes these applications, including the input data sets that were run to completion in each case, and Table 2 shows some relevant dynamic statistics of these applications.
Reference: [15] <author> T.-Y. Yeh and Y. Patt. </author> <title> A comparison of dynamic branch predictors that use two levels of branch history. </title> <booktitle> In ISCA'93, </booktitle> <pages> pages 257-266, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Note that 1 (X=Y means X misses out of Y dynamic references.) analogous forms of all three types of correlation profiling have been explored previously in the context of branch prediction <ref> [4, 10, 15, 16] </ref> 1.2 Objectives and Overview The goal of this paper is to determine whether correlation profiling can predict data cache misses more accurately in non-numeric codes than summary profiling, and if so, can we translate this into significant performance improvements by applying software-based latency tolerance techniques with greater <p> The three forms of correlation explored in this study (control-flow, self, and global) were inspired by earlier work on using correlation to enhance branch prediction accuracies <ref> [4, 10, 15, 16] </ref>.
Reference: [16] <author> C. Young and M. Smith. </author> <title> Improving the accuracy of static branch prediction using branch correlation. </title> <booktitle> In ASPLOS-VI, </booktitle> <pages> pages 232-241, </pages> <month> October </month> <year> 1994. </year> <month> 22 </month>
Reference-contexts: Note that 1 (X=Y means X misses out of Y dynamic references.) analogous forms of all three types of correlation profiling have been explored previously in the context of branch prediction <ref> [4, 10, 15, 16] </ref> 1.2 Objectives and Overview The goal of this paper is to determine whether correlation profiling can predict data cache misses more accurately in non-numeric codes than summary profiling, and if so, can we translate this into significant performance improvements by applying software-based latency tolerance techniques with greater <p> The three forms of correlation explored in this study (control-flow, self, and global) were inspired by earlier work on using correlation to enhance branch prediction accuracies <ref> [4, 10, 15, 16] </ref>.
References-found: 16

