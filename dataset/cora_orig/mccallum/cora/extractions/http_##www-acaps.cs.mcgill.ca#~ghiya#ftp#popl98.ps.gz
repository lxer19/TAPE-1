URL: http://www-acaps.cs.mcgill.ca/~ghiya/ftp/popl98.ps.gz
Refering-URL: http://www.csd.uu.se/~thomasl/wpo/alias-papers.html
Root-URL: 
Email: fghiya,hendreng@cs.mcgill.ca  
Phone: (514) 398-4657/398-7391  
Title: Putting Pointer Analysis to Work  
Author: Rakesh Ghiya and Laurie J. Hendren 
Address: Montreal, Quebec, CANADA H3A 2A7  
Affiliation: School of Computer Science, McGill University  
Note: To appear in Proceedings of the Twenty Fifth ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, San Diego, California, January 19-21, 1998. c fl1998 ACM (see notice below).  
Abstract: This paper addresses the problem of how to apply pointer analysis to a wide variety of compiler applications. We are not presenting a new pointer analysis. Rather, we focus on putting two existing pointer analyses, points-to analysis and connection analysis, to work. We demonstrate that the fundamental problem is that one must be able to compare the memory locations read/written via pointer indirections, at different program points, and one must also be able to summarize the effect of pointer references over regions in the program. It is straightforward to compute read/write sets for indirections involving stack-directed pointers using points-to information. However, for heap-directed pointers we show that one needs to introduce the notion of anchor handles into the connection analysis and then express read/write sets to the heap with respect to these anchor handles. Based on the read/write sets we show how to extend traditional optimizations like common subexpres-sion elimination, loop-invariant removal and location-invariant removal to include pointer references. We also demonstrate the use of our information on more advanced techniques such as array dependence testing and program understanding. We have implemented our techniques in our McCAT C compiler, and we demonstrate examples of applying our methods on a set of pointer-intensive C benchmarks, as well as present concrete empirical data on the improvements achieved. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers | Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley Pub. Co., </publisher> <address> Reading, Mass., corrected edition, </address> <year> 1988. </year>
Reference-contexts: In the following sections we assume that we are working with the Simple representation of a C program using the McCAT compiler [15]. 3.1 Scalar Optimizations We have used the algorithms from <ref> [1] </ref> to implement the LIR and CSE optimizations. Our implementation is more powerful due to improved read/write information. Further, it extends these optimizations to include read pointer expressions, globals and address exposed variables (variables whose address has been taken). <p> Such temporaries end up having long lifetimes, causing the register allocator to introduce spills, and perform worse than original. while ( (curr_box != 0) ) - temp_14 = (&(*curr_box).coord); i = temp_14 [0]; temp_15 = temp_14; /* CSE */ j = temp_15 <ref> [1] </ref>; temp_16 = temp_14; /* CSE */ k = temp_16 [2]; ... /* statements deleted */ curr_box = (*curr_box).next_box; - while ( (list != 0) ) - temp_43 = (*list).patient; temp_44 = (*temp_43).time_left; if ((temp_44 == 0)) - ... /* statements deleted */ temp_57 = temp_43; /* CSE */ (*temp_57).time_left =
Reference: [2] <author> J. Auslander, M. Philipose, C. Chambers, S. J. Eggers, and B. N. Bershad. </author> <title> Fast, effective dynamic compilation. </title> <booktitle> In Proc. of the ACM SIGPLAN '96 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 149-159, </pages> <address> Philadelphia, Penn., </address> <month> May </month> <year> 1996. </year>
Reference-contexts: end up having long lifetimes, causing the register allocator to introduce spills, and perform worse than original. while ( (curr_box != 0) ) - temp_14 = (&(*curr_box).coord); i = temp_14 [0]; temp_15 = temp_14; /* CSE */ j = temp_15 [1]; temp_16 = temp_14; /* CSE */ k = temp_16 <ref> [2] </ref>; ... /* statements deleted */ curr_box = (*curr_box).next_box; - while ( (list != 0) ) - temp_43 = (*list).patient; temp_44 = (*temp_43).time_left; if ((temp_44 == 0)) - ... /* statements deleted */ temp_57 = temp_43; /* CSE */ (*temp_57).time_left = 10; temp_58 = temp_43; /* CSE */ temp_59 = (*temp_58).time; <p> Also one can avoid prefetching fields that are reported to be not used, thus reducing the prefetch overhead. Similarly read only field accesses can be considered as run time constants, which is a very useful information in a dynamic compilation context <ref> [2] </ref>. Another direct application of connection information is identification of potential memory leaks. When a heap-directed pointer p is updated, and no other live pointer is connected to it, the heap storage accessible from p will become inaccessible by the program.
Reference: [3] <author> T. M. Austin, S. E. Breach, and G. S. Sohi. </author> <title> Efficient detection of all pointer and array access errors. </title> <booktitle> In Proc. of the ACM SIGPLAN '94 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 290-301, </pages> <address> Orlando, Flor., </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Biology D-Arrays & Lists sim Comput. Biology D-Arrays & Lists eigen Eigenvalues D-Arrays Table 1: Benchmark Descriptions Irvine [18] and Wisconsin <ref> [3] </ref> benchmark suites. A brief description of the benchmarks is provided in Table 1. The table also summarizes the principal data structures used by the benchmarks. Here S-Array denotes a statically allocated array, D-Array denotes a dynamically allocated array, and D-linked list denotes a doubly-linked list.
Reference: [4] <author> D. Callahan, S. Carr, and K. Kennedy. </author> <title> Improv ing register allocation for subscripted variables. </title> <booktitle> In Proc. of the SIGPLAN '90 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 53-65, </pages> <address> White Plains, N. Y., </address> <month> June </month> <year> 1990. </year>
Reference-contexts: The latter two are included because they cannot be register-promoted in the absence of alias information. We have also implemented another optimization we call location-invariant removal (LcIR), which is similar in spirit to the scalar replacement technique proposed for array references <ref> [4] </ref>. Any memory reference that accesses the same memory location in all iterations of a loop is considered to be location invariant. For example, the pointer access r-&gt;i in Figure 6 (a) is location invariant as the origin pointer r is not written inside the loop.
Reference: [5] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proc. of the SIGPLAN '90 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <address> White Plains, N. Y., </address> <month> June </month> <year> 1990. </year>
Reference: [6] <author> J.-D. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conf. Rec. of the Twentieth Ann. ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <address> Charleston, South Carolina, </address> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: In this section we concentrate on summarizing methods that use the results of pointer analysis. Landi et al. [20] and Choi et al. <ref> [6] </ref>, proposed approaches for computing side-effect information (read/write sets) in the presence of pointers. These approaches use stack-based alias analysis.
Reference: [7] <author> K. D. Cooper and J. Lu. </author> <title> Register promotion in C pro grams. </title> <booktitle> In Proc. of the ACM SIGPLAN '97 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 308-319, </pages> <address> Las Vegas, Nev., </address> <month> Jun. </month> <year> 1997. </year>
Reference-contexts: In terms of using the improved read/write sets from pointer analysis, for other analyses and transformations, the most relevant related work is of Wilson and Lam [33], Shapiro and Horwitz [28], and Cooper and Lu <ref> [7] </ref>. Wilson and Lam used pointer analysis results for loop parallelization. Shapiro and Horwitz study the effects of various flow-insensitive pointer analyses on the efficiency and precision of other analyses like live variable analysis and GMOD analysis, but not on actual program transformations.
Reference: [8] <author> A. Deutsch. </author> <title> A storeless model of aliasing and its ab stractions using finite representations of right-regular equivalence relations. </title> <booktitle> In Proc. of the 1992 Intl. Conf. on Computer Languages, </booktitle> <pages> pages 2-13, </pages> <address> Oakland, Calif., </address> <month> Apr. </month> <year> 1992. </year>
Reference: [9] <author> A. Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In Proc. of the ACM SIG-PLAN '94 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 230-241, </pages> <address> Orlando, Flor., </address> <month> June </month> <year> 1994. </year>
Reference: [10] <author> M. Emami, R. Ghiya, and L. J. Hendren. </author> <title> Context sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proc. of the ACM SIG-PLAN '94 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256, </pages> <address> Orlando, Flor., </address> <month> June </month> <year> 1994. </year>
Reference-contexts: In this section we concentrate on summarizing methods that use the results of pointer analysis. Landi et al. [20] and Choi et al. [6], proposed approaches for computing side-effect information (read/write sets) in the presence of pointers. These approaches use stack-based alias analysis. With a points-to representation <ref> [10, 26, 31, 33] </ref>, where all locations have names, computing read/write sets is quite straightforward and only slight modifications of standard transformations are needed as shown in section 2.1. We assume that other compilers with points-to analyses have similar applications.
Reference: [11] <author> R. Ghiya. </author> <title> Putting Pointer Analysis to Work. </title> <type> PhD thesis, </type> <institution> School of Computer Science, McGill University, </institution> <month> November </month> <year> 1997. </year> <note> In Preparation. </note>
Reference-contexts: Thus the main idea is that instead of creating an anchor for each pointer with respect to which the function call can access the heap, we just create two anchors to represent all the needed anchors. Further implementation details about anchor-augmented connection analysis can be found in <ref> [11] </ref>. 2.2.4 Analysis Efficiency We have evaluated the efficiency of our analyses with respect to a set of 16 C benchmark programs, drawn from the SPEC92, SPLASH-2 [34], Olden [25], Pgm Description Data Structures alvinn SPEC92 C Program S-Arrays water Molecular Dynamics S-Arrays & Lists health Health Care Simul. <p> Finally, when moving a pointer reference for loop or location invariant removal, we guard the invariant statements with the loop condition when necessary, in order to preserve program semantics (example in Figure 7 (d)). Further implementation details for the above optimizations can be found in <ref> [11] </ref>. while (p != NULL) - S: r-&gt;i = r-&gt;i + p-&gt;i; T: p = p-&gt;next; - while (p != NULL) - S: tr = tr + p-&gt;i; T: p = p-&gt;next; - (a) (b) 3.2 Experimental Results for Scalar Opti mizations In this subsection, we study the experimental results obtained <p> The programmer can be warned of a potential memory leak at the given statement. 4 Related Work As summarized in the introduction, a considerable amount of work has been done on the problem of pointer analysis itself, and a detailed description can be found in <ref> [11] </ref>. In this section we concentrate on summarizing methods that use the results of pointer analysis. Landi et al. [20] and Choi et al. [6], proposed approaches for computing side-effect information (read/write sets) in the presence of pointers. These approaches use stack-based alias analysis.
Reference: [12] <author> R. Ghiya and L. J. Hendren. </author> <title> Connection analysis: A practical interprocedural heap analysis for C. </title> <journal> Intl. J. of Parallel Programming, </journal> <volume> 24(6), </volume> <pages> pages 547-578, </pages> <year> 1996. </year>
Reference: [13] <author> R. Ghiya and L. J. Hendren. </author> <title> Is it a tree, a DAG, or a cyclic graph? a shape analysis for heap-directed pointers in C. </title> <booktitle> In Conf. Rec. of the 23rd ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 1-15, </pages> <address> St. Petersburg, Flor., </address> <month> Jan. </month> <year> 1996. </year>
Reference: [14] <author> V. A. Guarna, Jr. </author> <title> A technique for analyzing pointer and structure references in parallel restructuring compilers. </title> <booktitle> In Proc. of the 1988 Intl. Conf. on Parallel Processing, </booktitle> <volume> volume II, </volume> <pages> pages 212-220, </pages> <address> St. Charles, Ill., </address> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: More directly related to this paper are methods that use the results of heap analysis. Work in this area has been primarily focused on dependence analysis and parallelization. The important approaches include: techniques using path expressions to name locations [22], using syntax trees to name locations <ref> [14] </ref>, extending k-limited graphs with location names [17]; and dependence testing based on access paths and theorem proving [18].
Reference: [15] <author> L. Hendren, C. Donawa, M. Emami, G. Gao, Justiani, and B. Sridharan. </author> <title> Designing the McCAT compiler based on a family of structured intermediate representations. </title> <booktitle> In Proc. of the 5th Intl. Work. on Languages and Compilers for Parallel Computing, number 757 in Lec. Notes in Comp. Sci., </booktitle> <pages> pages 406-420, </pages> <address> New Haven, Conn., </address> <month> Aug. </month> <year> 1992. </year> <note> Springer-Verlag. Publ. in 1993. </note>
Reference-contexts: We have also built a program-understanding tool, that displays the summary read/write information to the user via Web browsers. In the following sections we assume that we are working with the Simple representation of a C program using the McCAT compiler <ref> [15] </ref>. 3.1 Scalar Optimizations We have used the algorithms from [1] to implement the LIR and CSE optimizations. Our implementation is more powerful due to improved read/write information. Further, it extends these optimizations to include read pointer expressions, globals and address exposed variables (variables whose address has been taken).
Reference: [16] <author> L. J. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Trans. on Parallel and Distrib. Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> Jan. </month> <year> 1990. </year>
Reference: [17] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence anal ysis for pointer variables. </title> <booktitle> In Proc. of the SIGPLAN '89 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 28-40, </pages> <address> Portland, Ore., </address> <month> Jun. </month> <year> 1989. </year>
Reference-contexts: Work in this area has been primarily focused on dependence analysis and parallelization. The important approaches include: techniques using path expressions to name locations [22], using syntax trees to name locations [14], extending k-limited graphs with location names <ref> [17] </ref>; and dependence testing based on access paths and theorem proving [18]. These approaches attempt to perform very accurate analysis, and reason about different parts of the same data structure (for example, determining if x-&gt;left->right possibly refers to the same location as x-&gt;right->right or not).
Reference: [18] <author> J. Hummel, L. J. Hendren, and A. Nicolau. </author> <title> A general data dependence test for dynamic, pointer-based data structures. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 218-229, </pages> <address> Orlando, Flor., </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Biology D-Arrays & Lists sim Comput. Biology D-Arrays & Lists eigen Eigenvalues D-Arrays Table 1: Benchmark Descriptions Irvine <ref> [18] </ref> and Wisconsin [3] benchmark suites. A brief description of the benchmarks is provided in Table 1. The table also summarizes the principal data structures used by the benchmarks. Here S-Array denotes a statically allocated array, D-Array denotes a dynamically allocated array, and D-linked list denotes a doubly-linked list. <p> Work in this area has been primarily focused on dependence analysis and parallelization. The important approaches include: techniques using path expressions to name locations [22], using syntax trees to name locations [14], extending k-limited graphs with location names [17]; and dependence testing based on access paths and theorem proving <ref> [18] </ref>. These approaches attempt to perform very accurate analysis, and reason about different parts of the same data structure (for example, determining if x-&gt;left->right possibly refers to the same location as x-&gt;right->right or not).
Reference: [19] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximate algo rithm for interprocedural pointer aliasing. </title> <booktitle> In Proc. of the ACM SIGPLAN '92 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <address> San Francisco, Calif., </address> <month> Jun. </month> <year> 1992. </year>
Reference: [20] <author> W. Landi, B. G. Ryder, and S. Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proc. of the ACM SIGPLAN '93 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 56-67, </pages> <address> Albuquerque, N. Mex., </address> <month> Jun. </month> <year> 1993. </year>
Reference-contexts: In this section we concentrate on summarizing methods that use the results of pointer analysis. Landi et al. <ref> [20] </ref> and Choi et al. [6], proposed approaches for computing side-effect information (read/write sets) in the presence of pointers. These approaches use stack-based alias analysis.
Reference: [21] <author> C. Lapkowski and L. J. Hendren. </author> <title> Extended SSA num bering: Introducing SSA properties to languages with multi-level pointers. </title> <booktitle> In Proceedings of CASCON'96, </booktitle> <address> Toronto, Ontario, </address> <month> Nov. </month> <year> 1996. </year>
Reference-contexts: Note that the points-to information about which indirect references/function calls can access the heap, enables us to reduce the number of anchor handles generated. We use extended SSA numbers <ref> [21] </ref> to further reduce the number of anchor handles required. Although conceptually one requires a new anchor handle for each indirect reference to the heap, in fact, anchor handles can often be reused.
Reference: [22] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts be tween structure accesses. </title> <booktitle> In Proc. of the SIGPLAN '88 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <address> Atlanta, Georgia, </address> <month> Jun. </month> <year> 1988. </year>
Reference-contexts: More directly related to this paper are methods that use the results of heap analysis. Work in this area has been primarily focused on dependence analysis and parallelization. The important approaches include: techniques using path expressions to name locations <ref> [22] </ref>, using syntax trees to name locations [14], extending k-limited graphs with location names [17]; and dependence testing based on access paths and theorem proving [18].
Reference: [23] <author> J. R. Larus and E. Schnarr. EEL: </author> <title> Machine independent executable editing. </title> <booktitle> In Proc. of the ACM SIGPLAN '95 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 291-300, </pages> <address> La Jolla, Calif., </address> <month> Jun. </month> <year> 1995. </year>
Reference-contexts: The run time was calculated as the sum of the system and user time reported by the time utility. Also the run time was averaged over three runs of the program. We collected the first two statistics using the EEL <ref> [23] </ref> based QPT2 tool from Jim Larus, which instruments the program executable to give exact counts. However, note that run time reported is not from the QPT2-instrumented versions of the executables. The comparison of the above statistics is presented in Table 5.
Reference: [24] <author> C.-K. Luk and T. C. Mowry. </author> <title> Compiler-based prefetch ing for recursive data structures. </title> <booktitle> In Proc. of the Seventh Intl. Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 222-233, </pages> <address> Cambridge, Mass., </address> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: Further, clicking at a function prototype or a function call, takes one to the function body. The reader can use this tool by visiting the Web page http://www-acaps.cs.mcgill.ca/~ghiya/info.html. The summary read/write information can also be used to guide data prefetching for recursive heap data structures <ref> [24] </ref>, as it indicates which fields are potentially accessed with respect to a pointer, inside a function or a loop. So prefetch instructions can be placed for these fields at function/loop entry. Also one can avoid prefetching fields that are reported to be not used, thus reducing the prefetch overhead.
Reference: [25] <author> A. Rogers, M. C. Carlisle, J. H. Reppy, and L. J. Hendren. </author> <title> Supporting dynamic data structures on distributed-memory machines. </title> <journal> ACM Trans. on Pro gramming Languages and Systems, </journal> <volume> 17(2) </volume> <pages> 233-263, </pages> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: Further implementation details about anchor-augmented connection analysis can be found in [11]. 2.2.4 Analysis Efficiency We have evaluated the efficiency of our analyses with respect to a set of 16 C benchmark programs, drawn from the SPEC92, SPLASH-2 [34], Olden <ref> [25] </ref>, Pgm Description Data Structures alvinn SPEC92 C Program S-Arrays water Molecular Dynamics S-Arrays & Lists health Health Care Simul.
Reference: [26] <author> E. Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proc. of the ACM SIGPLAN '95 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 13-22, </pages> <address> La Jolla, Calif., </address> <month> Jun. </month> <year> 1995. </year>
Reference-contexts: In this section we concentrate on summarizing methods that use the results of pointer analysis. Landi et al. [20] and Choi et al. [6], proposed approaches for computing side-effect information (read/write sets) in the presence of pointers. These approaches use stack-based alias analysis. With a points-to representation <ref> [10, 26, 31, 33] </ref>, where all locations have names, computing read/write sets is quite straightforward and only slight modifications of standard transformations are needed as shown in section 2.1. We assume that other compilers with points-to analyses have similar applications.
Reference: [27] <author> M. Sagiv, T. Reps, and R. Wilhelm. </author> <title> Solving shape analysis problems in languages with destructive updating. </title> <booktitle> In Conf. Rec. of the 23rd ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 16-31, </pages> <address> St. Petersburg, Flor., </address> <month> Jan. </month> <year> 1996. </year>
Reference: [28] <author> M. Shapiro and S. Horwitz. </author> <title> The effects of the precision of pointer analysis. </title> <booktitle> In Proceedings of the 1997 Static Analysis Symposium, </booktitle> <address> Paris, France, </address> <month> Sep. </month> <year> 1997. </year>
Reference-contexts: In terms of using the improved read/write sets from pointer analysis, for other analyses and transformations, the most relevant related work is of Wilson and Lam [33], Shapiro and Horwitz <ref> [28] </ref>, and Cooper and Lu [7]. Wilson and Lam used pointer analysis results for loop parallelization. Shapiro and Horwitz study the effects of various flow-insensitive pointer analyses on the efficiency and precision of other analyses like live variable analysis and GMOD analysis, but not on actual program transformations.
Reference: [29] <author> M. Shapiro and S. Horwitz. </author> <title> Fast and accurate flow insensitive points-to analysis. </title> <booktitle> In Conf. Rec. of the 24th ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <address> Paris, France, </address> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: An interesting observation is that our context-sensitive pointer analyses are quite efficient for moderate size benchmarks. This indicates that if interesting sections of larger programs can be identified using linear analyses <ref> [29, 31] </ref>, precise information for these sections can be obtained efficiently. We are presently experimenting with this approach to efficiently analyze large programs. Another observation is that the average number of anchor handles generated per indirect reference is about 0.50 for most of the benchmarks.
Reference: [30] <author> R. M. Stallman. </author> <title> Using and Porting GNU CC. Cam bridge, </title> <address> Mass., </address> <month> Jun. </month> <year> 1992. </year> <note> Available via anonymous ftp from prep.ai.mit.edu. </note>
Reference-contexts: For example, the CSE transformations shown in Figure 8 (a) can also be performed without any pointer analysis information (in fact gcc does so). In order to measure the additional benefits of our analyses over a state-of-the-art optimizing compiler, we have compared our results with the GNU C compiler <ref> [30] </ref> (gcc version 2.7.2) working at the highest level of optimization (with -O3 flag). Since our transformations are source-to-source and are performed at the Simple intermediate representation, we performed the following experiment.
Reference: [31] <author> B. Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Conf. Rec. of the 23rd ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <address> St. Petersburg, Flor., </address> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: An interesting observation is that our context-sensitive pointer analyses are quite efficient for moderate size benchmarks. This indicates that if interesting sections of larger programs can be identified using linear analyses <ref> [29, 31] </ref>, precise information for these sections can be obtained efficiently. We are presently experimenting with this approach to efficiently analyze large programs. Another observation is that the average number of anchor handles generated per indirect reference is about 0.50 for most of the benchmarks. <p> In this section we concentrate on summarizing methods that use the results of pointer analysis. Landi et al. [20] and Choi et al. [6], proposed approaches for computing side-effect information (read/write sets) in the presence of pointers. These approaches use stack-based alias analysis. With a points-to representation <ref> [10, 26, 31, 33] </ref>, where all locations have names, computing read/write sets is quite straightforward and only slight modifications of standard transformations are needed as shown in section 2.1. We assume that other compilers with points-to analyses have similar applications.
Reference: [32] <author> X. Tang, R. Ghiya, L. J. Hendren, and G. R. Gao. </author> <title> Heap analysis and optimizations for threaded programs. </title> <booktitle> In Proc. of the 1997 Conf. on Parallel Archi tectures and Compilation Techniques (PACT'97), </booktitle> <address> San Francisco, Calif., </address> <month> Nov. </month> <year> 1997. </year>
Reference-contexts: We have also studied the effects of our optimizations in the context of parallelized programs for the EARTH-MANNA multithreaded architecture. Here pointer references mostly involve remote memory accesses. So applying LIR, LcIR and CSE to such references results in even better savings, giving upto 25% speedup <ref> [32] </ref>. 3.3 Improving Array Dependence Tests Scientific applications written in C also use arrays as principal data structures. However, unlike FORTRAN, these arrays are mostly implemented using pointers to dynamically-allocated storage. Further even statically-allocated arrays are often passed as pointer parameters.
Reference: [33] <author> R. P. Wilson and M. S. Lam. </author> <title> Efficient context-sensitive pointer analysis for C programs. </title> <booktitle> In Proc. of the ACM SIGPLAN '95 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <address> La Jolla, Calif., </address> <month> Jun. </month> <year> 1995. </year>
Reference-contexts: In this section we concentrate on summarizing methods that use the results of pointer analysis. Landi et al. [20] and Choi et al. [6], proposed approaches for computing side-effect information (read/write sets) in the presence of pointers. These approaches use stack-based alias analysis. With a points-to representation <ref> [10, 26, 31, 33] </ref>, where all locations have names, computing read/write sets is quite straightforward and only slight modifications of standard transformations are needed as shown in section 2.1. We assume that other compilers with points-to analyses have similar applications. <p> In terms of using the improved read/write sets from pointer analysis, for other analyses and transformations, the most relevant related work is of Wilson and Lam <ref> [33] </ref>, Shapiro and Horwitz [28], and Cooper and Lu [7]. Wilson and Lam used pointer analysis results for loop parallelization.
Reference: [34] <author> S. C. Woo, M. Ohara, E. Torrie, J. P. Shingh, and A. Gupta. </author> <title> The SPLASH-2 programs: Characterization and methodological considerations. </title> <booktitle> In Proc. of the 22nd Ann. Intl. Symp. on Computer Architecture, </booktitle> <pages> pages 24-36, </pages> <address> Santa Margherita Ligure, Italy, </address> <month> Jun. </month> <year> 1995. </year>
Reference-contexts: Further implementation details about anchor-augmented connection analysis can be found in [11]. 2.2.4 Analysis Efficiency We have evaluated the efficiency of our analyses with respect to a set of 16 C benchmark programs, drawn from the SPEC92, SPLASH-2 <ref> [34] </ref>, Olden [25], Pgm Description Data Structures alvinn SPEC92 C Program S-Arrays water Molecular Dynamics S-Arrays & Lists health Health Care Simul.
Reference: [35] <author> S. Zhang, B. G. Ryder, and W. Landi. </author> <title> Program decom position for pointer aliasing: A step towards practical analyses. </title> <booktitle> In Proceedings of the 4th Symposium on the Foundations of Software Engineering, </booktitle> <month> October </month> <year> 1996. </year>
References-found: 35

