URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-92-32.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Email: Daniel.Edelson@inria.fr  daniel@cse.ucsc.edu.  
Title: Fault Interpretation: Fine-Grain Monitoring of Page Accesses  
Author: Daniel R. Edelson 
Note: This work was performed while the author was visiting INRIA. The author's most recent affiliation is:  
Date: 9 November 1992  
Address: Rocquencourt B.P. 105 78153 Le Chesnay CEDEX FRANCE  Cruz CA 95064,  
Affiliation: INRIA Project SOR  Computer and Information Science, University of California, Santa  
Abstract: This paper presents a technique for obtaining fine-grain information about page accesses from standard virtual memory hardware and Unix operating system software. This can be used to monitor all user-mode accesses to specified regions of the address space of a process. Application code can intervene before and/or after an access occurs, permitting a wide variety of semantics to be associated with memory pages. The technique facilitates implementing complex replication or consistency protocols on transparent distributed shared memory and persistent memory. The technique can also improve the efficiency of certain generational and incremental garbage collection algorithms. This paper presents our implementation and suggest several others. Efficiency measurements show faults to be about three orders of magnitude more expensive than normal memory accesses, but two orders of magnitude less expensive than page faults. Information about how to obtain the code via anonymous ftp appears at the end of the paper. 
Abstract-found: 1
Intro-found: 1
Reference: [AEL88] <author> Andrew W. Appel, John R. Ellis, and Kai Li. </author> <title> Real-time concurrent collection on stock multiprocessors. </title> <booktitle> In Proc. PLDI '88, </booktitle> <pages> pages 11-20, </pages> <month> July </month> <year> 1988. </year> <title> SIGPLAN Not. </title> <type> 23(7). </type>
Reference-contexts: The technique has been encapsulated in a library called F I for Fault Interpretation. We discuss a number of applications for this technique including garbage collection and consistency/replication protocols for transparent distributed shared memory. Virtual memory page protection has been used for similar reasons before <ref> [AEL88, AL91, DWH + 90] </ref>. The difference with our approach is that most other techniques unprotect a protected page when a fault occurs. For some period of time thereafter, there is no monitoring of how many times and at what addresses the page is accessed. <p> To avoid annoying pauses, the collector does its work in short chunks. Incremental garbage collectors are often concurrent, in which case protected pages of memory can serve as medium grain synchronization mechanism between the collector and the application <ref> [AEL88] </ref>. 3.2.1 Incremental Mark-and-Sweep Collection Incremental mark-and-sweep garbage collection has been implemented previously using virtual memory page protection [BDS91]. The normal implementation provides one bit of information per page: there was or was not a fault. Pages on which a fault occurred must be entirely rescanned.
Reference: [AL91] <author> Andrew W. Appel and Kai Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In ASPLOS Inter. Conf. Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 96-107, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year> <title> SIGPLAN Not. </title> <type> 26(4). </type>
Reference-contexts: The technique has been encapsulated in a library called F I for Fault Interpretation. We discuss a number of applications for this technique including garbage collection and consistency/replication protocols for transparent distributed shared memory. Virtual memory page protection has been used for similar reasons before <ref> [AEL88, AL91, DWH + 90] </ref>. The difference with our approach is that most other techniques unprotect a protected page when a fault occurs. For some period of time thereafter, there is no monitoring of how many times and at what addresses the page is accessed. <p> By and large, they are architecture specific and require reading the state of the CPU when the fault occurs. Thus, this technique is less portable and less general than those discussed by Appel <ref> [AL91] </ref>. Nonetheless, it has several uses and may let some programs run more efficiently. 4.1 Code Modification When the signal handler is invoked after a fault, it determines what instruction has faulted. <p> This also requires being able to restart the instruction following the faulted instruction. One advantage of this is the interpreter can take advantage of extra information. For example, if the fault page is also mapped without protection elsewhere in the address space <ref> [AL91, Wil92] </ref>, the interpreter can use that version to avoid needing to unprotect and re-protect the page. 4.4 Parallelization The F I code is currently sequential. However, the majority of it could be parallelized. There are two main issues that must be resolved. <p> Then, on the N th iteration, the handler unprotects the page and the instruction completes successfully. The time for protect+fault+unprotect was obtained by protecting a page, faulting, and unprotecting the page, all in a loop. This is a test whose efficiency is also measured in <ref> [AL91] </ref> and is repeated here to provide a baseline for comparison. The time for fault interpret is the time to interpret a fault, i.e. to access a protected page and have the application's notify function informed that the access has occurred, while finishing with the page still protected.
Reference: [ANS89] <author> ANSI X3.159-1989, </author> <year> 1989. </year> <title> American national standard for the C programming language. </title>
Reference-contexts: The same arguments are passed except that the flags indicate post-access. 6. F I returns the page to its previous protection state and resumes the application. The application continues with the instruction following the one that caused the fault. The library is written in C <ref> [ANS89, ISO90] </ref> using Unix system call extensions. It can also be compiled as C++ code.
Reference: [Bak78] <author> H. G. Baker. </author> <title> List processing in real time on a serial computer. </title> <journal> Communications of the ACM, </journal> <volume> 21(4) </volume> <pages> 280-294, </pages> <month> April </month> <year> 1978. </year> <month> 17 </month>
Reference-contexts: However, if scanning objects is relatively expensive, then remembering several stored addresses may improve efficiency. 3.2 Incremental Garbage Collection Incremental garbage collection is a family of algorithms in which the collector never stops the application for an extended period of time. The first such algorithm was Baker's copying collector <ref> [Bak78] </ref> with many other algorithms based on it. To avoid annoying pauses, the collector does its work in short chunks.
Reference: [BDS91] <author> Hans-J. Boehm, Alan J. Demers, and Scott Shenker. </author> <title> Mostly parallel garbage collection. </title> <booktitle> In Proc. PLDI '91, </booktitle> <pages> pages 157-164. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1991. </year> <title> SIGPLAN Not. </title> <type> 26(6). </type>
Reference-contexts: Incremental garbage collectors are often concurrent, in which case protected pages of memory can serve as medium grain synchronization mechanism between the collector and the application [AEL88]. 3.2.1 Incremental Mark-and-Sweep Collection Incremental mark-and-sweep garbage collection has been implemented previously using virtual memory page protection <ref> [BDS91] </ref>. The normal implementation provides one bit of information per page: there was or was not a fault. Pages on which a fault occurred must be entirely rescanned. This is another case in which fault interpretation can provide finer granularity information, possibly increasing the efficiency of the algorithm.
Reference: [Cyp90] <author> Cypress Semiconductor. </author> <title> SPARC risc users guide, </title> <year> 1990. </year>
Reference-contexts: It may not be possible to implement this functionality on all RISC architectures. We have implemented it on the SPARC processor <ref> [Cyp90, Sun87] </ref>. 2 Then, the faulting instruction is restarted; it succeeds because the page is unprotected. Control returns immediately to the F I library, which notifies the application again, re-protects the page, and resumes the application at the next instruction.
Reference: [DWH + 90] <author> Alan Demers, Mark Weiser, Barry Hayes, Hans Boehm, Daniel Bobrow, and Scott Shenker. </author> <title> Combining generational and conservative garbage collection: Framework and implementations. </title> <booktitle> In Proc. POPL '90, </booktitle> <pages> pages 261-269. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: The technique has been encapsulated in a library called F I for Fault Interpretation. We discuss a number of applications for this technique including garbage collection and consistency/replication protocols for transparent distributed shared memory. Virtual memory page protection has been used for similar reasons before <ref> [AEL88, AL91, DWH + 90] </ref>. The difference with our approach is that most other techniques unprotect a protected page when a fault occurs. For some period of time thereafter, there is no monitoring of how many times and at what addresses the page is accessed. <p> this technique include: write-detection in generational or incremental garbage collection, and consistency/replication protocols for shared memory. 8 3.1 Generational Garbage Collection The idea behind generational garbage collection (GC) is that some objects are likely to remain reachable for the immediate future, thus, attempting to reclaim their memory is not worthwhile. <ref> [DWH + 90, LH83, Moo84] </ref>. Typically, young objects are expected to become garbage relatively soon [Ung84], therefore, the garbage collector concentrates its effort on the young objects. A garbage collection of the young objects (the younger generation) requires locating all pointers to young objects. <p> Other collectors do not attempt to locate each individual pointer, but rather identify the set of pages that might contain such pointers, the remembered pages. During garbage collection, every object on a remembered page is scanned for back pointers. This has been implemented using page protection <ref> [DWH + 90] </ref>. The garbage collector write-protects all of the older-generation pages. Every fault indicates that there has been an assignment to an older generation object; the page is added to the remembered set. Upon collection, the remembered pages are scanned for back pointers.
Reference: [ISO90] <institution> ISO 9899-1990, </institution> <year> 1990. </year> <title> International standard for the C programming language. </title>
Reference-contexts: The same arguments are passed except that the flags indicate post-access. 6. F I returns the page to its previous protection state and resumes the application. The application continues with the instruction following the one that caused the fault. The library is written in C <ref> [ANS89, ISO90] </ref> using Unix system call extensions. It can also be compiled as C++ code.
Reference: [LH83] <author> Henry Lieberman and Carl Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> Communications of the ACM, </journal> <volume> 26(6) </volume> <pages> 419-429, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: this technique include: write-detection in generational or incremental garbage collection, and consistency/replication protocols for shared memory. 8 3.1 Generational Garbage Collection The idea behind generational garbage collection (GC) is that some objects are likely to remain reachable for the immediate future, thus, attempting to reclaim their memory is not worthwhile. <ref> [DWH + 90, LH83, Moo84] </ref>. Typically, young objects are expected to become garbage relatively soon [Ung84], therefore, the garbage collector concentrates its effort on the young objects. A garbage collection of the young objects (the younger generation) requires locating all pointers to young objects.
Reference: [LH89] <author> Kai Li and Paul Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: phase has terminated, the pages that had between 1 and N faults can be serviced very quickly because the addresses of the writes have been saved. 3.3 Consistency and Replication Control F I can be used to implement arbitrary replication and consistency protocols on top of transparent distributed shared memory <ref> [LH89] </ref>. The contribution of F I is the ability to execute application code before and after memory pages are accessed. This code might, for example, implement a voting algorithm [Lon88]. The consistency protocol runs transparently; the client accesses the memory with normal load and store instructions.
Reference: [Lon88] <author> Darrell D. E. </author> <title> Long. The Management of Replication in a Distributed System. </title> <type> Ph.D. dissertation, </type> <institution> University of California at San Diego, </institution> <month> August </month> <year> 1988. </year>
Reference-contexts: The contribution of F I is the ability to execute application code before and after memory pages are accessed. This code might, for example, implement a voting algorithm <ref> [Lon88] </ref>. The consistency protocol runs transparently; the client accesses the memory with normal load and store instructions. One possible implementation is the following. Shared memory pages are replicated on all the participating sites.
Reference: [Mak89] <author> Mesaac Mounchili Makpangou. </author> <title> Protocoles de communication et programmation par objets : l'exemple de SOS. </title> <type> PhD thesis, </type> <institution> Universite Paris VI, Paris (France), </institution> <month> February </month> <year> 1989. </year>
Reference-contexts: RW-RW means successive calls to mprotect always grant full access to the page. RO-RW means successive calls to mprotect alternate between restricting access and restoring access. 15 time for a network message for a relatively fast protocol such as UDP is on the order of 1.5ms <ref> [Mak89] </ref>, fault handling should not be the bottleneck in implementing distributed shared memory. Lastly, we observe that disk and network latencies do not scale with processor speeds, whereas fault handling latency does increase with faster CPUs, subject to memory access time.
Reference: [Moo84] <author> David Moon. </author> <title> Garbage collection in a large LISP system. </title> <booktitle> In Symp. Lisp and Functional Programming, </booktitle> <pages> pages 235-246. </pages> <publisher> ACM, </publisher> <year> 1984. </year>
Reference-contexts: this technique include: write-detection in generational or incremental garbage collection, and consistency/replication protocols for shared memory. 8 3.1 Generational Garbage Collection The idea behind generational garbage collection (GC) is that some objects are likely to remain reachable for the immediate future, thus, attempting to reclaim their memory is not worthwhile. <ref> [DWH + 90, LH83, Moo84] </ref>. Typically, young objects are expected to become garbage relatively soon [Ung84], therefore, the garbage collector concentrates its effort on the young objects. A garbage collection of the young objects (the younger generation) requires locating all pointers to young objects.
Reference: [Sun87] <author> Sun Microsystems, Inc. </author> <title> The SPARC architecture manual, </title> <booktitle> 1987. </booktitle> <volume> Part No. </volume> <month> 800-11399-07. </month>
Reference-contexts: It may not be possible to implement this functionality on all RISC architectures. We have implemented it on the SPARC processor <ref> [Cyp90, Sun87] </ref>. 2 Then, the faulting instruction is restarted; it succeeds because the page is unprotected. Control returns immediately to the F I library, which notifies the application again, re-protects the page, and resumes the application at the next instruction.
Reference: [Ung84] <author> David Ungar. </author> <title> Generation Scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In ACM SIG-PLAN/SIGSOFT Symp. Practical Software Development Environments, </booktitle> <pages> pages 157-167. </pages> <publisher> ACM, </publisher> <month> April </month> <year> 1984. </year> <title> SIGPLAN Not. </title> <type> 19(2). </type>
Reference-contexts: Typically, young objects are expected to become garbage relatively soon <ref> [Ung84] </ref>, therefore, the garbage collector concentrates its effort on the young objects. A garbage collection of the young objects (the younger generation) requires locating all pointers to young objects.
Reference: [Wil92] <author> Paul Wilson, </author> <year> 1992. </year> <type> Personal communication. 19 </type>
Reference-contexts: This also requires being able to restart the instruction following the faulted instruction. One advantage of this is the interpreter can take advantage of extra information. For example, if the fault page is also mapped without protection elsewhere in the address space <ref> [AL91, Wil92] </ref>, the interpreter can use that version to avoid needing to unprotect and re-protect the page. 4.4 Parallelization The F I code is currently sequential. However, the majority of it could be parallelized. There are two main issues that must be resolved.
References-found: 16

