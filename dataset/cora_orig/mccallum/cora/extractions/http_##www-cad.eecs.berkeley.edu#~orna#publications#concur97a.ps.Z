URL: http://www-cad.eecs.berkeley.edu/~orna/publications/concur97a.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~orna/pub.html
Root-URL: 
Email: Email: ftah,orna,sriramrg@eecs.berkeley.edu  
Title: Fair Simulation  
Author: Thomas A. Henzinger Orna Kupferman Sriram K. Rajamani 
Note: This research was supported in part by the ONR YIP award N00014-95-1-0520, by the NSF CAREER award CCR-9501708, by the NSF grant CCR-9504469, by the AFOSR contract F49620-93-1-0056, by the ARO MURI grant DAAH-04-96-1-0341, by the ARPA grant NAG2-892, and by the SRC contract 95-DC-324.036.  
Date: February 10, 1998  
Address: Berkeley, CA 94720-1770, U.S.A.  
Affiliation: EECS Department, University of California,  
Abstract: The simulation preorder for labeled transition systems is defined locally as a game that relates states with their immediate successor states. Simulation enjoys many appealing properties. First, simulation has a fully abstract semantics: system S simulates system I iff every computation tree embedded in the unrolling of I can be embedded also in the unrolling of S. Second, simulation has a logical characterization: S simulates I iff every universal branching-time formula satisfied by S is satisfied also by I. It follows that simulation is a suitable notion of implementation, and it is the coarsest abstraction of a system that preserves universal branching-time properties. Third, based on its local definition, simulation between finite-state systems can be checked in polynomial time. Finally, simulation implies trace-containment, which cannot be defined locally and requires polynomial space for verification. Hence simulation is widely used both in manual and in automatic verification. Liveness assumptions about transition systems are typically modeled using fairness constraints. Existing notions of simulation for fair transition systems, however, are not local, and as a result, many appealing properties of the simulation preorder are lost. We extend the local definition of simulation to account for fairness: system S fairly simulates system I iff in the simulation game, there is a strategy that matches with each fair computation of I a fair computation of S. Our definition enjoys a fully abstract semantics and has a logical characterization: S fairly simulates I iff every fair computation tree embedded in the unrolling of I can be embedded also in the unrolling of S or, equivalently, iff every Fair-8AFMC formula satisfied by S is satisfied also by I (8AFMC is the universal fragment of the alternation-free -calculus). The locality of the definition leads us to a polynomial-time algorithm for checking fair simulation for finite-state systems with weak and strong fairness constraints. Finally, fair simulation implies fair trace-containment, and is therefore useful as an efficiently-computable local criterion for proving linear-time abstraction hierarchies. 
Abstract-found: 1
Intro-found: 1
Reference: [AL91] <author> M. Abadi, L. Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82 </volume> <pages> 253-284, </pages> <year> 1991. </year>
Reference-contexts: trace-based specification: in automatic verification, simulation is widely used as an efficiently-computable sufficient condition for trace-containment [CPS93, Hoj96]; in manual verification, trace-containment is most naturally proved by exhibiting local witnesses such as simulation relations or refinement mappings (a restricted form of simulation relations) [Lam83, LT87, Lyn96, DP97]. 1 1 In <ref> [AL91] </ref>, it is shown that if auxiliary observable variables may be added to a system, then simulation is not only a sound proof technique but also complete for proving trace-containment. 1 State-transition systems describe only the safe behaviors of programs. <p> It is easy to see that S 9-simulates I. Indeed, the relation that maps each state in I to the set of states in S that agree with its observation 2 Using a similar proof technique, Lamport and others <ref> [Lam83, AL91] </ref> suggest a restricted, functional version of simulation, called refinement mapping. There, every computation of I is related to exactly one computation of S; thus, 9-simulation coincides with 8-simulation. 2 is an 9-simulation. <p> Particularly popular is a functional version of simulation: the simulation S is a refinement mapping if whenever S (w 1 ; w 2 ) and S (w 1 ; w 0 2 ), then w 2 = w 0 2 <ref> [AL91] </ref>. If S is a refinement mapping, then S is a 8-simulation iff S is an 9-simulation. Our definition of fair simulation Recall the simulation game of the protagonist K 2 against the adversary K 1 .
Reference: [ASB + 94] <author> A. Aziz, V. Singhal, F. Balarin, R.K. Brayton, A.L. Sangiovanni-Vincentelli. </author> <title> Equivalences for fair Kripke structures. </title> <booktitle> In Int. Colloq. Automata, Languages, and Programming, </booktitle> <publisher> LNCS 820. Springer, </publisher> <year> 1994. </year>
Reference-contexts: It is not so obvious how to generalize the branching framework of simulation to account for fairness. Indeed, several proposals can be found in the literature. The definition suggested by Grumberg and Long [GL94], and used among others by <ref> [ASB + 94, KV96] </ref>, rests on the motivation that S fairly simulates I iff every Fair-8CTL ? formula that holds for S holds also for I (the universal path quantifier of Fair-8CTL ? ranges over fair computations only). <p> This definition, however, is neither robust (Fair-8CTL induces a weaker preorder <ref> [ASB + 94] </ref>, and Fair-8AFMC, as we show here, induces a stronger one) nor can it be checked efficiently (it is complete for PSPACE [KV96]). <p> By contrast, 9-similarity is not the coarsest abstraction that preserves Fair-8CTL: there are two Buchi structures K 1 and K 2 , such that K 1 satisfies every 8CTL formula satisifed by K 2 , but K 2 does not 9-simulate K 1 <ref> [ASB + 94] </ref>.
Reference: [BBLS92] <author> S. Bensalem, A. Bouajjani, C. Loiseaux, J. Sifakis. </author> <title> Property-preserving simulations. In Computer-aided Verification, </title> <publisher> LNCS 663, </publisher> <pages> 260-273. </pages> <publisher> Springer, </publisher> <year> 1992. </year>
Reference-contexts: robust: for universal branching temporal logics (where only universal path quantification is allowed) such as 8CTL (the universal fragment of Computation Tree Logic), 8CTL ? , and 8AFMC (the universal fragment of the alternation free -calculus), S simulates I iff every formula that holds for S holds also for I <ref> [BBLS92, GL94] </ref>. Second, unlike trace-containment, the definition of simulation is local, as the relation between two states is based only on their successor states. <p> The temporal-logic view. The three branching-time logics 8CTL, 8CTL ? , and 8AFMC are the fragments of CTL, CTL fl , and the alternation-free -calculus that do not contain existential path quantifiers <ref> [BBLS92, GL94] </ref>. It is well-known that K 2 simulates K 1 iff for every formula of 8CTL (or 8CTL ? or 8AFMC), if K 2 satisfies , then K 1 satisfies . It follows that similarity is the coarsest abstraction that preserves any of these three logics.
Reference: [BKO87] <author> J.A. Bergstra, J.W. Klop, </author> <title> E.R. Olderog. Failures without chaos: a new process semantics for fair abstraction. </title> <booktitle> In Formal Description Techniques III, </booktitle> <pages> pp. 77-103. </pages> <publisher> Elsevier, </publisher> <year> 1987. </year>
Reference-contexts: In the degenerate case of deterministic systems, fair simulation coincides with fair trace-containment. We note that in process algebra, several other preorders and equivalences on state-transition systems have been extended to account for fairness, including failure preorders <ref> [BKO87] </ref> and testing preorders [Hen87, BRV95, NC95].
Reference: [BP96] <author> B. Bloom, R. Paige. </author> <title> Transformational design and implementation of a new efficient solution to the ready simulation problem. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 24 </volume> <pages> 189-220, </pages> <year> 1996. </year>
Reference-contexts: Second, unlike trace-containment, the definition of simulation is local, as the relation between two states is based only on their successor states. As a result, it can be checked in polynomial time (quadratic in both S and I) whether S simulates I <ref> [CPS93, BP96] </ref>, and a witnessing relation for simulation can be computed using a symbolic fixpoint procedure [HHK95]. <p> The problem of checking if K 2 simulates K 1 can be solved in time O ((jW 1 j + jW 2 j) (jR 1 j + jR 2 j)) <ref> [BP96, HHK95] </ref>. If K 2 simulates K 1 , then K 2 trace-contains K 1 . If K 1 and K 2 are both deterministic, then similarity coincides with trace-containment. The following three alternative definitions of similarity are equivalent to the definition above. The game-theoretic view. <p> Further, due to monotonicity (Proposition 3.1), ^ S has to be an init-fair simulation as well. The maximal simulation from K 1 to K 2 can be constructed in time O ((jW 1 j + jW 2 j) (jR 1 j + jR 2 j)) <ref> [BP96, HHK95] </ref>. Hence, it is left to find an algorithm that efficiently checks, given a relation S W 1 fi W 2 , if S is an init-fair simulation from K 1 to K 2 .
Reference: [BRV95] <author> E. Brinksma, A. Rensink, W. Vogler. </author> <title> Fair testing. </title> <journal> In Concurrency Theory, </journal> <volume> LNCS 962, </volume> <pages> pp. 313-327. </pages> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: In the degenerate case of deterministic systems, fair simulation coincides with fair trace-containment. We note that in process algebra, several other preorders and equivalences on state-transition systems have been extended to account for fairness, including failure preorders [BKO87] and testing preorders <ref> [Hen87, BRV95, NC95] </ref>.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. In Computer-aided Verification, </title> <publisher> LNCS 818, </publisher> <pages> pp. 142-155. </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: Hence, I j= '. Our definition of Fair-9AFMC is very similar to the automata-theoretic characterization of the alternation-free -calculus. Indeed, a convincing sat-tree of K for can be viewed as a run of an alternating tree automaton for on K <ref> [BVW94] </ref>. We also note that for the Fair-9AFMC formulas that correspond to the existential fragment of Fair-CTL, our definition coincides with the usual semantics for Fair-CTL [CES86].
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal-logic specifications. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 8 </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: Indeed, a convincing sat-tree of K for can be viewed as a run of an alternating tree automaton for on K [BVW94]. We also note that for the Fair-9AFMC formulas that correspond to the existential fragment of Fair-CTL, our definition coincides with the usual semantics for Fair-CTL <ref> [CES86] </ref>. Fair simulation and Fair-9AFMC Before we show that fair simulation and Fair-9AFMC induce the same relation on fair structures, we demonstrate that this is not the case for 9-simulation. Consider again the fair structures from Figure 1. We saw that the Fair-9AFMC formula ' is satisfied in I.
Reference: [CPS93] <author> R.J. Cleaveland, J. Parrow, B. Steffen. </author> <title> The Concurrency Workbench: a semantics-based tool for the verification of finite-state systems. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 15 </volume> <pages> 36-72, </pages> <year> 1993. </year>
Reference-contexts: Second, unlike trace-containment, the definition of simulation is local, as the relation between two states is based only on their successor states. As a result, it can be checked in polynomial time (quadratic in both S and I) whether S simulates I <ref> [CPS93, BP96] </ref>, and a witnessing relation for simulation can be computed using a symbolic fixpoint procedure [HHK95]. <p> The locality advantage is so compelling as to make simulation useful also to researchers that favor trace-based specification: in automatic verification, simulation is widely used as an efficiently-computable sufficient condition for trace-containment <ref> [CPS93, Hoj96] </ref>; in manual verification, trace-containment is most naturally proved by exhibiting local witnesses such as simulation relations or refinement mappings (a restricted form of simulation relations) [Lam83, LT87, Lyn96, DP97]. 1 1 In [AL91], it is shown that if auxiliary observable variables may be added to a system, then simulation
Reference: [DP97] <author> W. Damm and A. Pnueli. </author> <title> Verifying Out-of-Order Executions. </title> <booktitle> In Proc. of the IFIP Conference on Correct Hardware Design, </booktitle> <address> CHARME, </address> <year> 1997. </year>
Reference-contexts: simulation useful also to researchers that favor trace-based specification: in automatic verification, simulation is widely used as an efficiently-computable sufficient condition for trace-containment [CPS93, Hoj96]; in manual verification, trace-containment is most naturally proved by exhibiting local witnesses such as simulation relations or refinement mappings (a restricted form of simulation relations) <ref> [Lam83, LT87, Lyn96, DP97] </ref>. 1 1 In [AL91], it is shown that if auxiliary observable variables may be added to a system, then simulation is not only a sound proof technique but also complete for proving trace-containment. 1 State-transition systems describe only the safe behaviors of programs.
Reference: [DHWT91] <author> D.L. Dill, A.J. Hu, H. Wong-Toi. </author> <title> Checking for language inclusion using simulation relations. In Computer-aided Verification, </title> <publisher> LNCS 575, </publisher> <pages> pp. 255-265. </pages> <publisher> Springer, </publisher> <year> 1991. </year>
Reference-contexts: In manual verification, by Lynch and others [LT87, Lyn96], usually a stronger notion of fair simulation is used, which we call 8-simulation (see also <ref> [DHWT91] </ref>): for each fair computation of I, every related computation of S is required to be fair. 2 Again, this definition is neither robust (no logical characterization is known) nor can it be checked efficiently (it is NP-complete [Hoj96]). <p> addition, 9-similarity does not preserve Fair-8AFMC: as we show in Section 5, there are two Buchi structures K 1 and K 2 , and a Fair-8AFMC formula , such that K 2 9-simulates K 1 , and K 2 satisfies , but K 1 does not satisfy . 7 8-simulation <ref> [LT87, DHWT91] </ref>. A binary relation S W 1 fi W 2 is a 8-simulation of K 1 by K 2 if the following two conditions hold: 1. S is a simulation of K 1 by K 2 . 2.
Reference: [EJ88] <author> E.A. Emerson, C. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proc. Symp. Foundations of Computer Science, </booktitle> <pages> pp. 328-337. </pages> <publisher> IEEE, </publisher> <year> 1988. </year>
Reference: [GL94] <author> O. Grumberg, D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 16 </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: robust: for universal branching temporal logics (where only universal path quantification is allowed) such as 8CTL (the universal fragment of Computation Tree Logic), 8CTL ? , and 8AFMC (the universal fragment of the alternation free -calculus), S simulates I iff every formula that holds for S holds also for I <ref> [BBLS92, GL94] </ref>. Second, unlike trace-containment, the definition of simulation is local, as the relation between two states is based only on their successor states. <p> Robustness with respect to LTL, and PSPACE-completeness extend to the fair case. It is not so obvious how to generalize the branching framework of simulation to account for fairness. Indeed, several proposals can be found in the literature. The definition suggested by Grumberg and Long <ref> [GL94] </ref>, and used among others by [ASB + 94, KV96], rests on the motivation that S fairly simulates I iff every Fair-8CTL ? formula that holds for S holds also for I (the universal path quantifier of Fair-8CTL ? ranges over fair computations only). <p> The temporal-logic view. The three branching-time logics 8CTL, 8CTL ? , and 8AFMC are the fragments of CTL, CTL fl , and the alternation-free -calculus that do not contain existential path quantifiers <ref> [BBLS92, GL94] </ref>. It is well-known that K 2 simulates K 1 iff for every formula of 8CTL (or 8CTL ? or 8AFMC), if K 2 satisfies , then K 1 satisfies . It follows that similarity is the coarsest abstraction that preserves any of these three logics. <p> It follows that similarity is the coarsest abstraction that preserves any of these three logics. Previous definitions of fair simulation In the literature, we find several extensions of similarity that account for fairness constraints. In particular, the following two extensions have been studied and used extensively. 9-simulation <ref> [GL94] </ref>. A binary relation S W 1 fi W 2 is an 9-simulation of K 1 by K 2 if the following two conditions hold: 1. If S (w 1 ; w 2 ), then L 1 (w 1 ) = L 2 (w 2 ). 2. <p> K 1 is complete for PSPACE [KV96]. 9-similarity is the coarsest abstraction that preserves Fair-8CTL ? , where the universal path quantifiers range over the fair runs only: K 2 9-simulates K 1 iff for every formula of Fair-8CTL ? , if K 2 satisfies , then K 1 satisfies <ref> [GL94] </ref>. By contrast, 9-similarity is not the coarsest abstraction that preserves Fair-8CTL: there are two Buchi structures K 1 and K 2 , such that K 1 satisfies every 8CTL formula satisifed by K 2 , but K 2 does not 9-simulate K 1 [ASB + 94]. <p> There are two Buchi structures K 1 and K 2 such that K 2 fairly simulates K 1 , but K 2 does not 8-simulate K 1 . Fair trace containment is weaker than 9-simulation <ref> [GL94] </ref>. However, for deterministic structures, all the definitons of fair similarity collapse and coincide with trace containment. <p> Indeed, for every fair run of K 1 , we can produce an S-matching fair run of K 2 . Finally, Propositon 3.4 and the well known fact that trace containment is strictly weaker than 9-simulation <ref> [GL94] </ref>, lead to the following proposition. Proposition 3.5 There are two Buchi structures K 1 and K 2 , such that K 2 init-9-simulates K 1 , but K 2 does not 9-simulate K 1 . It follows (see Table 1) that only fair simulation enjoys both monotonicity and init-sensitivity.
Reference: [Hen87] <author> M.C.B. Hennessy. </author> <title> An algebraic theory of fair asynchronous communicating processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 49 </volume> <pages> 121-143, </pages> <year> 1987. </year> <month> 22 </month>
Reference-contexts: In the degenerate case of deterministic systems, fair simulation coincides with fair trace-containment. We note that in process algebra, several other preorders and equivalences on state-transition systems have been extended to account for fairness, including failure preorders [BKO87] and testing preorders <ref> [Hen87, BRV95, NC95] </ref>.
Reference: [HHK95] <author> M.R. Henzinger, T.A. Henzinger, P.W. Kopke. </author> <title> Computing simulations on finite and infinite graphs. </title> <booktitle> In Proc. Symp. Foundations of Computer Science, </booktitle> <pages> pp. 453-462. </pages> <publisher> IEEE, </publisher> <year> 1995. </year>
Reference-contexts: As a result, it can be checked in polynomial time (quadratic in both S and I) whether S simulates I [CPS93, BP96], and a witnessing relation for simulation can be computed using a symbolic fixpoint procedure <ref> [HHK95] </ref>. <p> The problem of checking if K 2 simulates K 1 can be solved in time O ((jW 1 j + jW 2 j) (jR 1 j + jR 2 j)) <ref> [BP96, HHK95] </ref>. If K 2 simulates K 1 , then K 2 trace-contains K 1 . If K 1 and K 2 are both deterministic, then similarity coincides with trace-containment. The following three alternative definitions of similarity are equivalent to the definition above. The game-theoretic view. <p> Further, due to monotonicity (Proposition 3.1), ^ S has to be an init-fair simulation as well. The maximal simulation from K 1 to K 2 can be constructed in time O ((jW 1 j + jW 2 j) (jR 1 j + jR 2 j)) <ref> [BP96, HHK95] </ref>. Hence, it is left to find an algorithm that efficiently checks, given a relation S W 1 fi W 2 , if S is an init-fair simulation from K 1 to K 2 .
Reference: [Hoj96] <author> R. Hojati. </author> <title> A BDD-based Environment for Formal Verification of Hardware Systems. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, </institution> <year> 1996. </year>
Reference-contexts: The locality advantage is so compelling as to make simulation useful also to researchers that favor trace-based specification: in automatic verification, simulation is widely used as an efficiently-computable sufficient condition for trace-containment <ref> [CPS93, Hoj96] </ref>; in manual verification, trace-containment is most naturally proved by exhibiting local witnesses such as simulation relations or refinement mappings (a restricted form of simulation relations) [Lam83, LT87, Lyn96, DP97]. 1 1 In [AL91], it is shown that if auxiliary observable variables may be added to a system, then simulation <p> This definition, however, is neither robust (Fair-8CTL induces a weaker preorder [ASB + 94], and Fair-8AFMC, as we show here, induces a stronger one) nor can it be checked efficiently (it is complete for PSPACE [KV96]). Following <ref> [Hoj96] </ref>, we call the Grumberg-Long version of fair simulation 9-simulation, because it can be defined as simulation where each fair computation of I is related to some fair computation of S. <p> notion of fair simulation is used, which we call 8-simulation (see also [DHWT91]): for each fair computation of I, every related computation of S is required to be fair. 2 Again, this definition is neither robust (no logical characterization is known) nor can it be checked efficiently (it is NP-complete <ref> [Hoj96] </ref>). While both 9-simulation and 8-simulation are sufficient conditions for fair trace-containment, they do not provide any computational advantage (indeed, algorithms for checking 9-simulation use subroutines for checking fair trace-containment). <p> For vacuous constraints F 1 and F 2 , 8-similarity coincides with similarity. For Buchi or Streett constraints F 1 and F 2 , the problem of checking whether K 2 8-simulates K 1 is NP-complete <ref> [Hoj96] </ref>. 8-simulation is widely used for proving abstraction hierarchies of distributed protocols [Lyn96]. <p> Checking if a given relation is an 9-simulation is PSPACE-complete [KV96]. Checking if a given relation is a 8-simulation can be done in PTIME, but because of lack of monotonicity, finding a good candidate relation is hard (NP-complete <ref> [Hoj96] </ref>).
Reference: [KV96] <author> O. Kupferman, M.Y. Vardi. </author> <title> Verification of fair transition systems. In Computer-aided Verification, </title> <publisher> LNCS 1102, </publisher> <pages> pp. 372-381. </pages> <publisher> Springer, </publisher> <year> 1996. </year>
Reference-contexts: It is not so obvious how to generalize the branching framework of simulation to account for fairness. Indeed, several proposals can be found in the literature. The definition suggested by Grumberg and Long [GL94], and used among others by <ref> [ASB + 94, KV96] </ref>, rests on the motivation that S fairly simulates I iff every Fair-8CTL ? formula that holds for S holds also for I (the universal path quantifier of Fair-8CTL ? ranges over fair computations only). <p> This definition, however, is neither robust (Fair-8CTL induces a weaker preorder [ASB + 94], and Fair-8AFMC, as we show here, induces a stronger one) nor can it be checked efficiently (it is complete for PSPACE <ref> [KV96] </ref>). Following [Hoj96], we call the Grumberg-Long version of fair simulation 9-simulation, because it can be defined as simulation where each fair computation of I is related to some fair computation of S. <p> For Buchi or Streett constraints F 1 and F 2 , the problem of checking if K 2 9-simulates K 1 is complete for PSPACE <ref> [KV96] </ref>. 9-similarity is the coarsest abstraction that preserves Fair-8CTL ? , where the universal path quantifiers range over the fair runs only: K 2 9-simulates K 1 iff for every formula of Fair-8CTL ? , if K 2 satisfies , then K 1 satisfies [GL94]. <p> It follows (see Table 1) that only fair simulation enjoys both monotonicity and init-sensitivity. Checking if a given relation is an 9-simulation is PSPACE-complete <ref> [KV96] </ref>. Checking if a given relation is a 8-simulation can be done in PTIME, but because of lack of monotonicity, finding a good candidate relation is hard (NP-complete [Hoj96]).
Reference: [KV98] <author> O. Kupferman, M.Y. Vardi. </author> <title> Weak alternating automata and tree automata emptiness. </title> <booktitle> In Proc. 30th ACM Symposium on Theory of Computing, </booktitle> <year> 1998. </year>
Reference-contexts: It is easy to see that the protagonist has a winning strategy iff the intersection of A S and A F is nonempty. Since checking the nonemptiness of a Streett tree automaton with n states and f pairs requires time O (n (2f+1) f !) <ref> [KV98] </ref>, the theorem below follows.
Reference: [Lam83] <author> L. Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 5 </volume> <pages> 190-222, </pages> <year> 1983. </year>
Reference-contexts: simulation useful also to researchers that favor trace-based specification: in automatic verification, simulation is widely used as an efficiently-computable sufficient condition for trace-containment [CPS93, Hoj96]; in manual verification, trace-containment is most naturally proved by exhibiting local witnesses such as simulation relations or refinement mappings (a restricted form of simulation relations) <ref> [Lam83, LT87, Lyn96, DP97] </ref>. 1 1 In [AL91], it is shown that if auxiliary observable variables may be added to a system, then simulation is not only a sound proof technique but also complete for proving trace-containment. 1 State-transition systems describe only the safe behaviors of programs. <p> It is easy to see that S 9-simulates I. Indeed, the relation that maps each state in I to the set of states in S that agree with its observation 2 Using a similar proof technique, Lamport and others <ref> [Lam83, AL91] </ref> suggest a restricted, functional version of simulation, called refinement mapping. There, every computation of I is related to exactly one computation of S; thus, 9-simulation coincides with 8-simulation. 2 is an 9-simulation. <p> There is evidence that most practical specifications fairly simulate their implementations. In particular, since fair simulation is implied by 8-simulation, the fair simulation condition can be used as an efficient check to verify distributed protocols that have been verified using 8-simulation <ref> [Lam83, LS93, Lyn96] </ref>. * In the degenerate case of vacuous fairness constraints, fair simulation coincides with simulation. In the degenerate case of deterministic systems, fair simulation coincides with fair trace-containment.
Reference: [LS93] <author> N.A. Lynch, R. Segala. </author> <title> A Comparison of Simulation Techniques and Algebraic Techniques for Verifying Concurrent Systems. </title> <type> Technical Report MIT/LCS/TM-499, </type> <institution> Massachusetts Institute Technology, </institution> <year> 1993. </year>
Reference-contexts: There is evidence that most practical specifications fairly simulate their implementations. In particular, since fair simulation is implied by 8-simulation, the fair simulation condition can be used as an efficient check to verify distributed protocols that have been verified using 8-simulation <ref> [Lam83, LS93, Lyn96] </ref>. * In the degenerate case of vacuous fairness constraints, fair simulation coincides with simulation. In the degenerate case of deterministic systems, fair simulation coincides with fair trace-containment.
Reference: [LT87] <author> N.A. Lynch, </author> <title> M.R. Tuttle. Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proc. Symp. Principles of Distributed Computing, </booktitle> <pages> pp. 137-151. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: simulation useful also to researchers that favor trace-based specification: in automatic verification, simulation is widely used as an efficiently-computable sufficient condition for trace-containment [CPS93, Hoj96]; in manual verification, trace-containment is most naturally proved by exhibiting local witnesses such as simulation relations or refinement mappings (a restricted form of simulation relations) <ref> [Lam83, LT87, Lyn96, DP97] </ref>. 1 1 In [AL91], it is shown that if auxiliary observable variables may be added to a system, then simulation is not only a sound proof technique but also complete for proving trace-containment. 1 State-transition systems describe only the safe behaviors of programs. <p> Following [Hoj96], we call the Grumberg-Long version of fair simulation 9-simulation, because it can be defined as simulation where each fair computation of I is related to some fair computation of S. In manual verification, by Lynch and others <ref> [LT87, Lyn96] </ref>, usually a stronger notion of fair simulation is used, which we call 8-simulation (see also [DHWT91]): for each fair computation of I, every related computation of S is required to be fair. 2 Again, this definition is neither robust (no logical characterization is known) nor can it be checked <p> addition, 9-similarity does not preserve Fair-8AFMC: as we show in Section 5, there are two Buchi structures K 1 and K 2 , and a Fair-8AFMC formula , such that K 2 9-simulates K 1 , and K 2 satisfies , but K 1 does not satisfy . 7 8-simulation <ref> [LT87, DHWT91] </ref>. A binary relation S W 1 fi W 2 is a 8-simulation of K 1 by K 2 if the following two conditions hold: 1. S is a simulation of K 1 by K 2 . 2.
Reference: [Lyn96] <author> N.A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: simulation useful also to researchers that favor trace-based specification: in automatic verification, simulation is widely used as an efficiently-computable sufficient condition for trace-containment [CPS93, Hoj96]; in manual verification, trace-containment is most naturally proved by exhibiting local witnesses such as simulation relations or refinement mappings (a restricted form of simulation relations) <ref> [Lam83, LT87, Lyn96, DP97] </ref>. 1 1 In [AL91], it is shown that if auxiliary observable variables may be added to a system, then simulation is not only a sound proof technique but also complete for proving trace-containment. 1 State-transition systems describe only the safe behaviors of programs. <p> Following [Hoj96], we call the Grumberg-Long version of fair simulation 9-simulation, because it can be defined as simulation where each fair computation of I is related to some fair computation of S. In manual verification, by Lynch and others <ref> [LT87, Lyn96] </ref>, usually a stronger notion of fair simulation is used, which we call 8-simulation (see also [DHWT91]): for each fair computation of I, every related computation of S is required to be fair. 2 Again, this definition is neither robust (no logical characterization is known) nor can it be checked <p> There is evidence that most practical specifications fairly simulate their implementations. In particular, since fair simulation is implied by 8-simulation, the fair simulation condition can be used as an efficient check to verify distributed protocols that have been verified using 8-simulation <ref> [Lam83, LS93, Lyn96] </ref>. * In the degenerate case of vacuous fairness constraints, fair simulation coincides with simulation. In the degenerate case of deterministic systems, fair simulation coincides with fair trace-containment. <p> For vacuous constraints F 1 and F 2 , 8-similarity coincides with similarity. For Buchi or Streett constraints F 1 and F 2 , the problem of checking whether K 2 8-simulates K 1 is NP-complete [Hoj96]. 8-simulation is widely used for proving abstraction hierarchies of distributed protocols <ref> [Lyn96] </ref>.
Reference: [Mil71] <author> R. Milner. </author> <title> An algebraic definition of simulation between programs. </title> <booktitle> In Proc. Int. Joint Conf. Artificial Intelligence, </booktitle> <pages> pp. 481-489. </pages> <publisher> British Computer Society, </publisher> <year> 1971. </year>
Reference-contexts: The notion of tree-containment is equivalent to the notion of simulation, as defined by Milner <ref> [Mil71] </ref>: S tree-contains I iff S simulates I; that is, we can relate each state of I to a state of S so that two related states i and s agree on their observations and every successor of i is related to some successor of s. <p> Simulation A binary relation S W 1 fi W 2 is a simulation of K 1 by K 2 if the following two conditions hold <ref> [Mil71] </ref>: 1. If S (w 1 ; w 2 ), then L 1 (w 1 ) = L 2 (w 2 ). 2.
Reference: [NC95] <author> V. Natarajan, R. Cleaveland. </author> <title> Divergence and fair testing. </title> <booktitle> In Int. Colloq. Automata, Languages, and Programming, </booktitle> <volume> LNCS 944, </volume> <pages> pp. 648-659. </pages> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: In the degenerate case of deterministic systems, fair simulation coincides with fair trace-containment. We note that in process algebra, several other preorders and equivalences on state-transition systems have been extended to account for fairness, including failure preorders [BKO87] and testing preorders <ref> [Hen87, BRV95, NC95] </ref>.
Reference: [Pnu85] <author> A. Pnueli. </author> <title> Linear and branching structures in the semantics and logics of reactive systems. </title> <booktitle> In Int. Colloq. Automata, Languages, and Programming, </booktitle> <publisher> LNCS, </publisher> <pages> pp. 15-32. </pages> <publisher> Springer, </publisher> <year> 1985. </year>
Reference-contexts: In tree-based satisfaction, we require that every branching property (i.e., every property of computation trees) which holds for the specification holds also for the implementation <ref> [Pnu85] </ref>. If we represent the implementation I and the specification S using state-transition systems, then the formal relation that captures trace-based satisfaction is trace-containment: S trace-contains I iff it is possible to generate by S every sequence of observations that can be generated by I.
Reference: [PR89] <author> A. Pnueli, R. Rosner. </author> <title> On the synthesis of a reactive module. </title> <booktitle> In Proc. Symp. Principles of Programming Languages, </booktitle> <pages> pp. 179-190. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: The algorithm reduces the fair-similarity problem to the nonemptiness problem of tree automata. Known results about tree automata <ref> [Rab70, PR89] </ref> then imply that in Condition 2. above, if a required strategy exists, then there exists a finite-state strategy; that is, a strategy produced by a finite-state machine. <p> The problem of checking the existence of a winning strategy (and the synthesis of such a strategy <ref> [Rab70, PR89] </ref>) can be reduced to the nonemptiness problem for tree automata. We first define finite automata over words and trees formally. Word automata.
Reference: [Rab70] <author> M.O. Rabin. </author> <title> Weakly definable relations and special automata. </title> <booktitle> In Proc. Symp. Mathematical Logic and Foundations of Set Theory, </booktitle> <pages> pp. 1-23. </pages> <publisher> Elsevier, </publisher> <year> 1970. </year>
Reference-contexts: The algorithm reduces the fair-similarity problem to the nonemptiness problem of tree automata. Known results about tree automata <ref> [Rab70, PR89] </ref> then imply that in Condition 2. above, if a required strategy exists, then there exists a finite-state strategy; that is, a strategy produced by a finite-state machine. <p> The problem of checking the existence of a winning strategy (and the synthesis of such a strategy <ref> [Rab70, PR89] </ref>) can be reduced to the nonemptiness problem for tree automata. We first define finite automata over words and trees formally. Word automata. <p> Let A 1 and A 2 be tree automata that accept all fair trace-trees of K 1 and K 2 , respectively. By Proposition 2.4, the language of A 1 is not contained in the language of A 2 . Hence, by <ref> [Rab70] </ref>, there is a regular tree (i.e., a tree with only finitely many distinct subtrees) that is accepted by A 1 and not accepted by A 2 . This tree can be encoded by a Fair-9AFMC formula such that K 1 j= and K 2 6j= .
Reference: [Saf88] <author> S. Safra. </author> <title> On the complexity of !-automata. </title> <booktitle> In Proc. Symp. Foundations of Computer Science, </booktitle> <pages> pp. 319-327. </pages> <publisher> IEEE, </publisher> <year> 1988. </year>
Reference-contexts: For vacuous constraints F 1 and F 2 , fair trace-containment coincides with trace-containment. For Buchi or Streett constraints F 1 and F 2 , the problem of checking if K 2 fairly trace-contains K 1 is complete for PSPACE <ref> [SVW87, Saf88] </ref>. Simulation A binary relation S W 1 fi W 2 is a simulation of K 1 by K 2 if the following two conditions hold [Mil71]: 1. If S (w 1 ; w 2 ), then L 1 (w 1 ) = L 2 (w 2 ). 2.
Reference: [SM73] <author> L.J. Stockmeyer, A.R. Meyer. </author> <title> Word problems requiring exponential time. </title> <booktitle> In Proc. Theory of Computing, </booktitle> <pages> pp. 1-9. </pages> <publisher> ACM, </publisher> <year> 1973. </year>
Reference-contexts: The notion of trace-containment is robust with respect to linear temporal logics such as LTL, in the sense that S trace-contains I iff every LTL formula that holds for S holds also for I. Unfortunately, it is difficult to check trace-containment (complete for PSPACE <ref> [SM73] </ref>), and we are unlikely to find an efficient algorithm. The formal relation that captures tree-based satisfaction is tree-containment: S tree-contains I iff it is possible to embed in the unrolling of S every tree of observations that can be embedded in the unrolling of I. <p> The problem of checking if K 2 trace-contains K 1 is complete for PSPACE <ref> [SM73] </ref>. The fair structure K 2 fairly trace-contains the fair structure K 1 if every fair trace of K 1 is also a fair trace of K 2 . For vacuous constraints F 1 and F 2 , fair trace-containment coincides with trace-containment.
Reference: [SVW87] <author> A.P. Sistla, M.Y. Vardi, P. Wolper. </author> <title> The complementation problem for Buchi automata with applications to temporal logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 49 </volume> <pages> 217-237, </pages> <year> 1987. </year> <month> 23 </month>
Reference-contexts: For vacuous constraints F 1 and F 2 , fair trace-containment coincides with trace-containment. For Buchi or Streett constraints F 1 and F 2 , the problem of checking if K 2 fairly trace-contains K 1 is complete for PSPACE <ref> [SVW87, Saf88] </ref>. Simulation A binary relation S W 1 fi W 2 is a simulation of K 1 by K 2 if the following two conditions hold [Mil71]: 1. If S (w 1 ; w 2 ), then L 1 (w 1 ) = L 2 (w 2 ). 2.
References-found: 30

