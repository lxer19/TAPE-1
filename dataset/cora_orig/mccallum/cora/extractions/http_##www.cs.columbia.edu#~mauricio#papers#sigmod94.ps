URL: http://www.cs.columbia.edu/~mauricio/papers/sigmod94.ps
Refering-URL: http://www.cs.columbia.edu/~mauricio/
Root-URL: 
Title: Predictive Dynamic Load Balancing of Parallel and Distributed Rule and Query Processing  
Author: Hasanat M. Dewan Salvatore J. Stolfo Mauricio Hernandez Jae-Jun Hwang 
Address: New York, NY 10027 CUCS-025-94  
Affiliation: Department of Computer Science Columbia University,  
Abstract: This paper appeared in the Proceedings of the 1994 ACM SIGMOD Conference.) Abstract Expert Databases are environments that support the processing of rule programs against a disk resident database. They occupy a position intermediate between active and deductive databases, with respect to the level of abstraction of the underlying rule language. The operational semantics of the rule language influences the problem solving strategy, while the architecture of the processing environment determines efficiency and scalability. In this paper, we present elements of the PARADISER architecture and its kernel rule language, PARULEL. The PARADISER environment provides support for parallel and distributed evaluation of rule programs, as well as static and dynamic load balancing protocols that predictively balance a computation at runtime. This combination of features results in a scalable database rule and complex query processing architecture. We validate our claims by analyzing the performance of the system for two realistic test cases. In particular, we show how the performance of a parallel implementation of transitive closure is significantly improved by predictive dynamic load balancing. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and E. Simon. </author> <title> Fundamental properties of deterministic and nondeterministic extensions of datalog fl . Journal of Theoretical Computer Science, </title> <year> 1991. </year>
Reference-contexts: This last point is the focus of this paper. 3 The PARULEL Language Here, we review the main features of PARULEL to lay the groundwork for our subsequent discussion. 3.1 Syntax PARULEL syntax is derived from OPS5, while its operational semantics resemble those of Datalog :fl <ref> [1, 5] </ref>. (As in Datalog :fl , PARULEL is capable of set-oriented updates involving all rule actions that do not conflict according to certain criteria. The relationship between PARULEL and Datalog :fl is discussed at length in [5]).
Reference: [2] <author> D.A. </author> <title> Brant and D.P. Miranker. Index Support for Rule Activation. </title> <booktitle> In To appear in the proceedings of ACM-SIGMOD, Intl. Conf. on the Management of Data, </booktitle> <year> 1993. </year>
Reference-contexts: Recent work in expert databases <ref> [2, 13] </ref> addresses the problem of efficiently determining the set of active (or instantiated) rules using various indexing techniques. However, the associated match algorithm, namely "lazy match", uses a rather restrictive semantics for generating instances.
Reference: [3] <author> G. Copeland, W. Alexander, E. Boughter, and T. Keller. </author> <title> Data Placement in Bubba. </title> <booktitle> In Proceedings of the ACM SIGMOD 1988, Intl. Conf. on the Management of Data. </booktitle> <publisher> ACM Press, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction A considerable body of prior work has been done to achieve high performance, complex query processing over large databases by parallel and distributed processing <ref> [3, 18, 21, 9] </ref>. We study this problem in the context of rule program processing, in which production rules comprising an expert database application are evaluated against a large database of facts stored in an RDBMS. <p> In this Section, we outline the process which achieves that end. In the last decade, many researchers have focused on developing database machine architectures for fast execution of complex SPJ queries. Many of these efforts have resulted in the development of efficient parallel join algorithms for shared-nothing multiprocessor environments <ref> [3, 10, 18] </ref>. These algorithms are parallel versions of sort-merge or hash-based joins previously developed for centralized uniprocessor database machines. While there are many subtle differences, they all assume a homogeneous ensemble of processors, which do not exhibit performance variations over time.
Reference: [4] <author> H. M. Dewan. </author> <title> Runtime Reorganization of Parallel and Distributed Expert Database Systems. </title> <type> 11 Technical report, </type> <institution> Department of Computer Sci--ence, Columbia University, </institution> <month> April </month> <year> 1994. </year> <type> Ph.D. Thesis. </type>
Reference-contexts: The PARADISER environment provides these facilities for PARULEL programs. The task partitioning and load balancing techniques used in PARADISER has been the subject of other reports <ref> [8, 4, 6] </ref>. Here we provide an outline appropriate for the present paper. 4.1 Memory Model The database support for PARULEL programs is provided by an RDBMS, rather than the LISP environment of typical AI rule languages such as OPS5. <p> We represent the processing potential of the available processing sites by a vector of "loading weights". To handle skewed distributions we generalize the copy-and-constrain scheme as follows. For each rule, a restricted relation and an RA that selects that relation are chosen heuristically <ref> [4] </ref> at compile time. The database environment is configured automatically by the runtime system to maintain statistics on the RA of each rule by means of appropriately defined triggers. Discrete frequency distributions (DFDs) are maintained by the triggers that are installed for each RA. <p> For this purpose, a high level scheduler is needed to schedule different join tasks over the processors concurrently, whenever possible. This algorithm is the subject of a forthcoming report <ref> [4] </ref> that analyzes the performance and design issues in the parallel processing of rule languages over a fully distributed database architecture. 7 Conclusion We believe this architecture provides a sufficiently rich model for general balanced processing of rules or queries in a parallel and distributed environment.
Reference: [5] <author> H. M. Dewan, D. Ohsie, S.J. Stolfo, O. Wolfson, and S. DaSilva. </author> <title> Incremental Database Rule Processing in PARADISER. </title> <journal> Journal of Intelligent Information Systems, </journal> <volume> 1:2, </volume> <month> October </month> <year> 1992. </year>
Reference-contexts: It is often stated that asynchronous evaluation schemes are more efficient over synchronous schemes for this very reason. However, asynchrony also leads to database and inference concurrency control problems that we seek to entirely avoid <ref> [5] </ref>. There is a limited amount of work that addresses the workload partitioning problem for knowledge-base systems. Existing work may be broadly characterized as static, compile time analyses that attempt to intelligently guess about runtime behavior, and to schedule a number of relational queries accordingly. <p> This last point is the focus of this paper. 3 The PARULEL Language Here, we review the main features of PARULEL to lay the groundwork for our subsequent discussion. 3.1 Syntax PARULEL syntax is derived from OPS5, while its operational semantics resemble those of Datalog :fl <ref> [1, 5] </ref>. (As in Datalog :fl , PARULEL is capable of set-oriented updates involving all rule actions that do not conflict according to certain criteria. The relationship between PARULEL and Datalog :fl is discussed at length in [5]). <p> The relationship between PARULEL and Datalog :fl is discussed at length in <ref> [5] </ref>). PARULEL programs consist of "object-level" production rules, "metarules" for a programmable operational semantics, and a database of facts.
Reference: [6] <author> H.M. Dewan and S.J. Stolfo. </author> <title> System Reorganization and Load Balancing of Parallel Database Rule Processing. </title> <booktitle> In Proceedings of the 7th International Symposium on Methodologies for Intelligent Systems (ISMIS-93), </booktitle> <pages> pages 186-197, </pages> <address> Trondheim, Nor-way, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: The evaluation of a PARULEL program is carried out within PARADISER (PARAllel and DIStributed Environment for Rules). Both the PARULEL language and the PARADISER architecture have been detailed elsewhere <ref> [20, 6, 7] </ref>. For completeness, we include brief descriptions in subsequent sections. The contribution of this paper is a description of the implementation and measured performance of two applications written in PARULEL. <p> The PARADISER environment provides these facilities for PARULEL programs. The task partitioning and load balancing techniques used in PARADISER has been the subject of other reports <ref> [8, 4, 6] </ref>. Here we provide an outline appropriate for the present paper. 4.1 Memory Model The database support for PARULEL programs is provided by an RDBMS, rather than the LISP environment of typical AI rule languages such as OPS5. <p> In this paradigm, rules are replicated with additional constraints attached to each copy. Such restricted rules can be matched in parallel, thus providing a speedup <ref> [16, 6] </ref>. <p> The database environment is configured automatically by the runtime system to maintain statistics on the RA of each rule by means of appropriately defined triggers. Discrete frequency distributions (DFDs) are maintained by the triggers that are installed for each RA. The weighted range splitting (WRS) algorithm, initially reported in <ref> [6] </ref>, embodies a technique for both static and dynamic workload assignment. <p> Thus, the choice of PDLB protocol is crucial for minimizing this overhead. In previous work <ref> [6] </ref>, we have shown, through isoeffi-ciency analysis, that the family of PDLB protocols we consider have some members with slow-growing isoeffi-ciency functions. <p> New weights are computed as a function of the weights in the k previous cycles, where k is a system tuning parameter. The exact algorithm for weight adjustment has been reported elsewhere <ref> [6, 8] </ref>. Here we mention that the adjusted loading weights are used as a measure of predicted future resource requirements at each site.
Reference: [7] <author> H.M. Dewan and S.J. Stolfo. </author> <title> The Distributed Evaluation of Rules in PARADISER. </title> <note> Technical Report In Preparation, </note> <institution> Department of Computer Science, Columbia University, </institution> <month> May (expected) </month> <year> 1994. </year>
Reference-contexts: The evaluation of a PARULEL program is carried out within PARADISER (PARAllel and DIStributed Environment for Rules). Both the PARULEL language and the PARADISER architecture have been detailed elsewhere <ref> [20, 6, 7] </ref>. For completeness, we include brief descriptions in subsequent sections. The contribution of this paper is a description of the implementation and measured performance of two applications written in PARULEL.
Reference: [8] <author> H.M. Dewan, S.J. Stolfo, and L. Woodbury. </author> <title> Scalable Parallel and Distributed Expert Database Systems with Predictive Load Balancing. </title> <journal> J. Parallel and Distrib. Computing, </journal> <note> special issue on scalable systems, 1994. Submitted. </note>
Reference-contexts: The PARADISER environment provides these facilities for PARULEL programs. The task partitioning and load balancing techniques used in PARADISER has been the subject of other reports <ref> [8, 4, 6] </ref>. Here we provide an outline appropriate for the present paper. 4.1 Memory Model The database support for PARULEL programs is provided by an RDBMS, rather than the LISP environment of typical AI rule languages such as OPS5. <p> New weights are computed as a function of the weights in the k previous cycles, where k is a system tuning parameter. The exact algorithm for weight adjustment has been reported elsewhere <ref> [6, 8] </ref>. Here we mention that the adjusted loading weights are used as a measure of predicted future resource requirements at each site.
Reference: [9] <author> D. DeWitt and J. Gray. </author> <title> Parallel Database Systems: The Future of High Performance Database Systems. </title> <booktitle> In Communications of the ACM. ACM, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction A considerable body of prior work has been done to achieve high performance, complex query processing over large databases by parallel and distributed processing <ref> [3, 18, 21, 9] </ref>. We study this problem in the context of rule program processing, in which production rules comprising an expert database application are evaluated against a large database of facts stored in an RDBMS.
Reference: [10] <author> Tandem Performance Group. </author> <title> A Benchmark of Non-Stop SQL on the Debit Credit Transactin. </title> <booktitle> In Proceedings of the ACM SIGMOD 1988, Intl. Conf. on the Management of Data. </booktitle> <publisher> ACM Press, </publisher> <year> 1988. </year>
Reference-contexts: In this Section, we outline the process which achieves that end. In the last decade, many researchers have focused on developing database machine architectures for fast execution of complex SPJ queries. Many of these efforts have resulted in the development of efficient parallel join algorithms for shared-nothing multiprocessor environments <ref> [3, 10, 18] </ref>. These algorithms are parallel versions of sort-merge or hash-based joins previously developed for centralized uniprocessor database machines. While there are many subtle differences, they all assume a homogeneous ensemble of processors, which do not exhibit performance variations over time.
Reference: [11] <author> E.N. Hanson. </author> <title> Rule condition testing and action execution in Ariel. </title> <booktitle> In In proceedings of ACM-SIGMOD, Intl. Conf. on the Management of Data, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: We focus instead on disk-based systems coupled with distributed and parallel processing for scalability. Related work occurs in the general class of database rule processing systems under the deductive, active, or expert database labels. The work in active databases <ref> [11, 12, 21, 23] </ref> tends to emphasize rule systems that provide the means for accomplishing internal database tasks such as database constraint maintenance, while deductive databases [14, 17, 22] are suited to building knowledge-based applications that have natural expression in logic.
Reference: [12] <author> D.R. McCarthy and U. Dayal. </author> <title> The architecture of an active database management system. </title> <booktitle> In In proceedings of ACM-SIGMOD, Intl. Conf. on the Management of Data, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: We focus instead on disk-based systems coupled with distributed and parallel processing for scalability. Related work occurs in the general class of database rule processing systems under the deductive, active, or expert database labels. The work in active databases <ref> [11, 12, 21, 23] </ref> tends to emphasize rule systems that provide the means for accomplishing internal database tasks such as database constraint maintenance, while deductive databases [14, 17, 22] are suited to building knowledge-based applications that have natural expression in logic.
Reference: [13] <author> D.P. Miranker, D. Brant, B. Lofaso, and D. Gad-bois. </author> <title> On the Performance of Lazy Matching in Production Systems. </title> <booktitle> In Proceedings of the 1990 National Conference on Artificial Intelligence, </booktitle> <pages> pages 685-692, </pages> <year> 1990. </year>
Reference-contexts: Recent work in expert databases <ref> [2, 13] </ref> addresses the problem of efficiently determining the set of active (or instantiated) rules using various indexing techniques. However, the associated match algorithm, namely "lazy match", uses a rather restrictive semantics for generating instances.
Reference: [14] <author> K. Morris, J.D. Ullman, and A. Van Gelder. </author> <title> Design Overview of the NAIL! System. </title> <booktitle> In Proceedings of the third Intl. Conference on Logic Programming, </booktitle> <pages> pages 554-568, </pages> <year> 1986. </year>
Reference-contexts: The work in active databases [11, 12, 21, 23] tends to emphasize rule systems that provide the means for accomplishing internal database tasks such as database constraint maintenance, while deductive databases <ref> [14, 17, 22] </ref> are suited to building knowledge-based applications that have natural expression in logic. Recent work in expert databases [2, 13] addresses the problem of efficiently determining the set of active (or instantiated) rules using various indexing techniques.
Reference: [15] <author> D. Neiman. </author> <title> Issues in the Design and Control of Parallel Rule-Firing Production Systems. </title> <type> PhD thesis, </type> <institution> University of Massachusetts, Amherst, Computer Science Dept., </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: Most of the existing work that addresses the dynamic workload partitioning problem for distributed rule or query processing can be characterized as static, compile time analyses that attempt to intelligently guess about runtime behavior. There also exists work on purely run-time scheduling of asynchronous parallel rule firing systems <ref> [15] </ref>, where load balancing is essentially unnecessary. In the latter, asynchronous parallel execution of rules is made possible by a data locking protocol suited to rule processing. There is a centralized lock manager for this purpose.
Reference: [16] <author> A. Pasik. </author> <title> Improving Production System Performance on Parallel Architectures by Creating Constrained Copies of Rules. </title> <type> Technical Report CUCS-313-87, </type> <institution> Department of Computer Science, Columbia University, </institution> <year> 1987. </year>
Reference-contexts: In this paradigm, rules are replicated with additional constraints attached to each copy. Such restricted rules can be matched in parallel, thus providing a speedup <ref> [16, 6] </ref>.
Reference: [17] <author> R. Ramakrishnan, P. Seshadri, D. Srivastave, and S. Sudarshan. </author> <title> An Overview of CORAL. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Wisconsin-Madison, </institution> <year> 1989. </year>
Reference-contexts: The work in active databases [11, 12, 21, 23] tends to emphasize rule systems that provide the means for accomplishing internal database tasks such as database constraint maintenance, while deductive databases <ref> [14, 17, 22] </ref> are suited to building knowledge-based applications that have natural expression in logic. Recent work in expert databases [2, 13] addresses the problem of efficiently determining the set of active (or instantiated) rules using various indexing techniques.
Reference: [18] <author> D.A. Schneider and D.J. DeWitt. </author> <title> A Performance Evaluation of Four Parallel Join Algorithms in a Shared-Nothing Multiprocessor Environment. </title> <booktitle> In Proceedings of the ACM SIGMOD 1989, Intl. Conf. on the Management of Data. </booktitle> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction A considerable body of prior work has been done to achieve high performance, complex query processing over large databases by parallel and distributed processing <ref> [3, 18, 21, 9] </ref>. We study this problem in the context of rule program processing, in which production rules comprising an expert database application are evaluated against a large database of facts stored in an RDBMS. <p> In this Section, we outline the process which achieves that end. In the last decade, many researchers have focused on developing database machine architectures for fast execution of complex SPJ queries. Many of these efforts have resulted in the development of efficient parallel join algorithms for shared-nothing multiprocessor environments <ref> [3, 10, 18] </ref>. These algorithms are parallel versions of sort-merge or hash-based joins previously developed for centralized uniprocessor database machines. While there are many subtle differences, they all assume a homogeneous ensemble of processors, which do not exhibit performance variations over time.
Reference: [19] <author> S. Stolfo, D.P. Miranker, and R. Mills. </author> <title> A Simple Processing Scheme to Extract and Load Balance Implicit Parallelism in the Concurrent Match of Production Rules. </title> <booktitle> In Proc. of the AFIPS Symposium on Fifth Generation Computing, </booktitle> <year> 1985. </year>
Reference-contexts: The PARULEL language has parallel, set-oriented execution semantics and a programmable conflict resolution capability through the use of programmer specified metarules, as well as a "context" mechanism to group rules into structured modules for control. The task partitioning problem is addressed as follows. We use the copy-and-constrain <ref> [19] </ref> technique as the basic partitioning tool for data reduction, and compute a number of restricted versions of the original rule program that are applied in parallel to reduced databases. <p> and the RHS of PARULEL rules may be expressed as relational Select-Project-Join (SPJ) queries, rule matching and rule firing translates into a series of SPJ queries to form rule instances, followed by a series of updates on the database, respectively. 4.2 Rule Matching in Parallel We use the copy-and-constrain paradigm <ref> [19, 25] </ref> as the basic mechanism for matching rules in parallel. In this paradigm, rules are replicated with additional constraints attached to each copy. Such restricted rules can be matched in parallel, thus providing a speedup [16, 6].
Reference: [20] <author> S. J. Stolfo, H.M. Dewan, and O. Wolfson. </author> <title> The PARULEL parallel rule language. </title> <booktitle> In Proceedings of the IEEE International Conference on Parallel Processing, pages II:36-45. IEEE, </booktitle> <year> 1991. </year>
Reference-contexts: The evaluation of a PARULEL program is carried out within PARADISER (PARAllel and DIStributed Environment for Rules). Both the PARULEL language and the PARADISER architecture have been detailed elsewhere <ref> [20, 6, 7] </ref>. For completeness, we include brief descriptions in subsequent sections. The contribution of this paper is a description of the implementation and measured performance of two applications written in PARULEL.
Reference: [21] <author> M. Stonebraker and G. Kemnitz. </author> <title> The POSTGRES next-generation DBMS. </title> <booktitle> In Communications of the ACM, </booktitle> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: 1 Introduction A considerable body of prior work has been done to achieve high performance, complex query processing over large databases by parallel and distributed processing <ref> [3, 18, 21, 9] </ref>. We study this problem in the context of rule program processing, in which production rules comprising an expert database application are evaluated against a large database of facts stored in an RDBMS. <p> We focus instead on disk-based systems coupled with distributed and parallel processing for scalability. Related work occurs in the general class of database rule processing systems under the deductive, active, or expert database labels. The work in active databases <ref> [11, 12, 21, 23] </ref> tends to emphasize rule systems that provide the means for accomplishing internal database tasks such as database constraint maintenance, while deductive databases [14, 17, 22] are suited to building knowledge-based applications that have natural expression in logic.
Reference: [22] <author> S. Tsur and C. Zaniolo. </author> <title> LDL: </title> <booktitle> A logic-based data-language. </booktitle> <pages> pages 33-41, </pages> <year> 1986. </year> <booktitle> In proc. Intl. Conference on Very Large Databases. </booktitle>
Reference-contexts: The work in active databases [11, 12, 21, 23] tends to emphasize rule systems that provide the means for accomplishing internal database tasks such as database constraint maintenance, while deductive databases <ref> [14, 17, 22] </ref> are suited to building knowledge-based applications that have natural expression in logic. Recent work in expert databases [2, 13] addresses the problem of efficiently determining the set of active (or instantiated) rules using various indexing techniques.
Reference: [23] <author> J. Widom, R.J. Cochrane, and B.G. Lindsay. </author> <title> Implementing set-oriented production rules as an extension to Starburst. </title> <booktitle> 1991. In proc. 17th Intl. Conference on Very Large Databases. </booktitle>
Reference-contexts: We focus instead on disk-based systems coupled with distributed and parallel processing for scalability. Related work occurs in the general class of database rule processing systems under the deductive, active, or expert database labels. The work in active databases <ref> [11, 12, 21, 23] </ref> tends to emphasize rule systems that provide the means for accomplishing internal database tasks such as database constraint maintenance, while deductive databases [14, 17, 22] are suited to building knowledge-based applications that have natural expression in logic.
Reference: [24] <author> J.L. Wolf, D.M. Dias, P.S. Yu, and J. Turek. </author> <title> Comparative Performance of Parallel Join Algorithms. </title> <booktitle> In First Intl. Conference on Parallel and Distributed Systems, </booktitle> <pages> pages 78-88. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: While there are many subtle differences, they all assume a homogeneous ensemble of processors, which do not exhibit performance variations over time. Another class of parallel join algorithms have been described in the literature to address the problems introduced when data skew is present <ref> [24] </ref>. However, in this case as in the previous ones, the underlying processing resources are assumed to be homogeneous and time-invariant.
Reference: [25] <author> O. Wolfson and A. Ozeri. </author> <title> A New Paradigm for Parallel and Distributed Rule-processing. </title> <booktitle> In Proc. ACM-SIGMOD, </booktitle> <year> 1990. </year> <month> 12 </month>
Reference-contexts: and the RHS of PARULEL rules may be expressed as relational Select-Project-Join (SPJ) queries, rule matching and rule firing translates into a series of SPJ queries to form rule instances, followed by a series of updates on the database, respectively. 4.2 Rule Matching in Parallel We use the copy-and-constrain paradigm <ref> [19, 25] </ref> as the basic mechanism for matching rules in parallel. In this paradigm, rules are replicated with additional constraints attached to each copy. Such restricted rules can be matched in parallel, thus providing a speedup [16, 6].
References-found: 25

