URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1993/GIT-CC-93-60.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.93.html
Root-URL: 
Email: calvert@cc.gatech.edu  
Title: Leads-to Properties and the But-not-yet Operator  
Author: Ken Calvert 
Date: October 1993  
Address: Atlanta, Georgia 30032-0280  Atlanta, Georgia 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  College of Computing Georgia Institute of Technology  
Pubnum: GIT-CC-93/60  
Abstract: We define a predicate transformer, in terms of which finite disjunctions of leads-to properties can be rewritten as single leads-to properties. Although disjunctions of leads-to properties do not typically arise naturally in progress specifications, an example shows how they may be introduced through the use of nested implications of leads-to properties; such implications allow subtle dependencies between a program's progress and that of its environment to be conveniently specified. After introducing the predicate transformer, which is called the but-not-yet operator, we show how to define a single leads-to property equivalent to a given disjunction of two leads-to properties. An alternative definition of the but-not-yet operator is shown to be equivalent to the first, and some properties of the operator are proved. Finally, the predicate transformer is generalized to any finite number of arguments. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Kenneth L. Calvert. </author> <title> Module composition and refinement: Extending the lam-shankar theory. </title> <type> Technical Report GIT-CC-91/58, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <year> 1991. </year>
Reference-contexts: In a compositional theory of program specifications|one in which composition preserves all temporal properties of each component|such a property expresses the dependence of a program's progress on that of its environment. (Such a theory is described, for example, in <ref> [1, 2] </ref>.) In other words, (x ; y) ) (p ; q) is a weaker specification than p ; q, but when a program known to satisfy that specification is placed in an environment where only behaviors satisfying x ; y can occur, the resulting system satisfies p ; q.
Reference: [2] <author> Kenneth L. Calvert. </author> <title> Module composition and refinement with applications to protocol conversion. In Proceedings XII Symposium on Protocol Specification, Testing, and Verification, </title> <address> Orlando, Florida. </address> <publisher> North-Holland, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: In a compositional theory of program specifications|one in which composition preserves all temporal properties of each component|such a property expresses the dependence of a program's progress on that of its environment. (Such a theory is described, for example, in <ref> [1, 2] </ref>.) In other words, (x ; y) ) (p ; q) is a weaker specification than p ; q, but when a program known to satisfy that specification is placed in an environment where only behaviors satisfying x ; y can occur, the resulting system satisfies p ; q.
Reference: [3] <author> Kenneth L. Calvert. </author> <title> Specifying progress properties with leads-to. </title> <type> Technical Report GIT-CC-92/59, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: Indeed, it can be shown that any positive boolean combination of elementary properties is propositionally equivalent to a property in the form of a conjunction of (simple) implications <ref> [3] </ref>. However, it is also not clear how to prove such disjunctions of leads-to properties. It turns out that a straightforward extension to the UNITY proof rules for leads-to [4] is adequate for proving simple implications; moreover, it is not necessary to prove disjunctions. <p> For any set of sequences with property (fl): h8 ff : ff 2 : ff j= p 0 ; q 0 _ . . . _ p N ; q N i A proof of Theorem 2, along with additional details, may be found in <ref> [3] </ref>. 7 Discussion The results presented here can be used to show that complex dependencies amoung progress properties can be represented by specifications expressed using only conjunctions and simple implications of leads-to properties.
Reference: [4] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: In recent years it has been demonstrated that a wide range of properties useful in practice can be specified using a few simple temporal forms <ref> [4, 5, 6, 7, 8] </ref>. <p> Leads-to properties are useful for specification of progress, i.e. asserting that a program will do something. Simple, easy-to-use proof systems, which allow elementary leads-to properties to be established for particular programs, are well known <ref> [4] </ref>. A property of the form (x ; y) ) (p ; q) means that every behavior of the program that satisfies x ; y also satisfies p ; q. <p> However, it is also not clear how to prove such disjunctions of leads-to properties. It turns out that a straightforward extension to the UNITY proof rules for leads-to <ref> [4] </ref> is adequate for proving simple implications; moreover, it is not necessary to prove disjunctions. <p> The advantage of stating specifications in this restricted form is that only a few small extensions to the simple and elegant proof rules for leads-to (e.g., as in <ref> [4] </ref>) are required to obtain a complete proof system for such properties. Acknowledgement This paper has benefitted from helpful comments by J. R. Rao and Ted Herman.
Reference: [5] <author> Simon S. Lam and A. Udaya Shankar. </author> <title> A relational notation for state transition systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(7) </volume> <pages> 755-775, </pages> <month> July </month> <year> 1990. </year> <month> 11 </month>
Reference-contexts: In recent years it has been demonstrated that a wide range of properties useful in practice can be specified using a few simple temporal forms <ref> [4, 5, 6, 7, 8] </ref>.
Reference: [6] <author> Leslie Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Transactions on Pro--gramming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 190-222, </pages> <year> 1983. </year>
Reference-contexts: In recent years it has been demonstrated that a wide range of properties useful in practice can be specified using a few simple temporal forms <ref> [4, 5, 6, 7, 8] </ref>.
Reference: [7] <author> Leslie Lamport. </author> <title> A temporal logic of actions. </title> <type> Technical Report Research Report 57, </type> <institution> DEC Systems Research Center, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: In recent years it has been demonstrated that a wide range of properties useful in practice can be specified using a few simple temporal forms <ref> [4, 5, 6, 7, 8] </ref>.
Reference: [8] <author> Zohar Manna and Amir Pnueli. </author> <title> Temporal Logic of Reactive and Concurrent Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: In recent years it has been demonstrated that a wide range of properties useful in practice can be specified using a few simple temporal forms <ref> [4, 5, 6, 7, 8] </ref>.
Reference: [9] <author> Jan Pachl. </author> <title> A simple proof of a completeness result for leads-to in the unity logic. </title> <journal> Information Processing Letters, </journal> <volume> 41 </volume> <pages> 35-38, </pages> <year> 1992. </year>
Reference-contexts: denote this predicate by p ff q and define it as follows: 3 (p ff q):s = h9 ff; i; n :: ff 2 ^ ff [i] = s ^ n i ^ (A similar predicate was defined by Pachl in proving completeness of the UNITY proof rules for leads-to <ref> [9] </ref>.) Henceforth let p, q, x and y be arbitrary fixed state predicates, and let P , X and W stand for the following leads-to properties: P = p ; q def W = (((p ff q) ^ x) _ ((x ff y) ^ p)) ; (q _ y) We shall
Reference: [10] <author> Beverly A. Sanders. </author> <title> A predicate transformer approach to knowledge and knowledge-based protocols. </title> <type> Technical Report 181, </type> <institution> Eidgenossische Technische Hochschule Zurich, Institut fur Computersysteme, </institution> <month> September </month> <year> 1992. </year> <month> 12 </month>
Reference-contexts: Evidently false satisfies both of these, and is the strongest predicate to do so. 2 A similar argument proves [false ff q false] (26) The predicate p ff false corresponds to the strongest stable predicate weaker than p, which has been named (in the context of UNITY) sst:p by Sanders <ref> [10] </ref>. We turn now to monotonicity properties. The first of these is that ff is monotonic in its first argument, i.e. [x ) y] ) [x ff q ) y ff q] (27) Proof of (27).
References-found: 10

