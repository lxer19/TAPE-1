URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-190.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Title: Detecting Deadlocks in the Ada accept...do and select Constructs  
Author: Stephen P. Masticola 
Abstract: We describe the representation of Ada programs containing the select and accept-do constructs, for use in safe and accurate static detection of deadlock in polynomial time. We describe a sync hypergraph program representation, which encompasses remote procedures including synchronization, conditional entries and entry calls, and else clauses and timeouts. We present a corresponding execution model for the sync hypergraph abstraction of Ada programs, and give constraints on valid deadlock cycles based on this execution model. We give full details of a deadlock detection algorithm, including lattice frameworks for deadlock cycle detection and proof of worst-case polynomial time bounds for convergence. As an intermediate step, we compute an approximate "can't happen together" (CHT ) relation between rendezvous statements. This CHT relation has applications in other areas, notably in detection of unexecutable statements and in intertask data flow analysis. 
Abstract-found: 1
Intro-found: 1
Reference: [AHU74] <author> Aho, A. V., Hopcroft, J. E., and Ullman, J. D. </author> <title> The design and analysis of computer algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachussetts, </address> <year> 1974. </year> <note> ISBN 0-201-00029-6. </note>
Reference-contexts: Step 3 can then be done in constant time. The strong components of CallG may be found in time proportional to the number of nodes and edges of CallG <ref> [AHU74] </ref>; step 4 thus takes O (jSigsj 4 ) in the worst case. Step 5 can then be done via a simple scan of E call , in O (jSigsj 4 ) time.
Reference: [ANSI83] <author> American National Standards Institute. </author> <title> "ANSI/MIL-STD 1815A (1983) reference manual for the Ada programming language." </title> <institution> United States Government Printing Office, </institution> <address> Washington DC, </address> <year> 1983. </year>
Reference-contexts: The purpose of this document is to elaborate on some issues in representation of the program, and to describe in full detail the deadlock algorithm and its worst-case time complexity bounds. Notation. Notation used in this paper is listed in Appendix A. 5 2 Accept...do construct. Ada <ref> [ANSI83] </ref> has features that allow the rendezvous to act as a type of "remote procedure call". The task entry (or accept) acts as the body of the called procedure, and the signaling task acts as the caller. <p> The else clause will typically not include any coordinations with other tasks. However, <ref> [ANSI83] </ref> does not rule out this possibility, so it must be considered for the sake of completeness.
Reference: [CS88] <author> Callahan, D. and Subhlok, J. </author> <title> "Static analysis of low-level synchronization." </title> <booktitle> SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <year> 1988, </year> <pages> 100-111. </pages>
Reference-contexts: All head nodes may execute at the same time. 14 (a) The nodes in D must represent statements whose instances can happen together. (b) All nodes in D are co-executable in the sense of Callahan and Subhlok <ref> [CS88] </ref>. In the presence of accept-do statements, we have new information on co-executability of the nodes in D. <p> All head nodes may execute at the same time. (a) The nodes in D must represent statements whose instances can happen together. (b) All nodes in D are co-executable in the sense of Callahan and Subhlok <ref> [CS88] </ref>. This implies Equation (7): X y2Sigs [Scope set (D; y) SigN set (D; y)] (jEj jDj): 4. <p> This form of analysis is called B4 analysis, and is closely related to the SCPreserved analysis in loopless programs performed by Callahan and Subhlok <ref> [CS88] </ref>. More recently, Duesterwald and Soffa [DS91], [Dues91] formulated a before analysis of Ada like programs; our analysis is similar to theirs in principle, although they use a different graph representation and execution model. <p> However, [DS91] represents recursion and process creation, while we require that subroutines be fully inlined and all processes created at the start of the program. While we find little or no use of recursive process creation in practice, we hope to eliminate these restrictions in future research. Lastly, while <ref> [CS88] </ref> and [DS91] presented their analyses as sets of data flow equations, we present B4 more formally here as a lattice framework, and derive its convergence time and accuracy properties based on lattice-theoretic arguments. 6.1.1 B4 lattice framework.
Reference: [DS91] <author> Duesterwald, E. and Soffa, M. L. </author> <title> "Concurrency analysis in the presence of procedures using a data-flow framework." </title> <booktitle> ACM Symposium on Testing, Analysis and Verification (TAV4), </booktitle> <address> Vancouver, </address> <month> October </month> <year> 1991, </year> <pages> 36-48. </pages>
Reference-contexts: This form of analysis is called B4 analysis, and is closely related to the SCPreserved analysis in loopless programs performed by Callahan and Subhlok [CS88]. More recently, Duesterwald and Soffa <ref> [DS91] </ref>, [Dues91] formulated a before analysis of Ada like programs; our analysis is similar to theirs in principle, although they use a different graph representation and execution model. Our sync hypergraphs extend their representation by including the accept-do construct, selective wait, and conditional entry calls 3 . <p> Our sync hypergraphs extend their representation by including the accept-do construct, selective wait, and conditional entry calls 3 . Though [Dues91] proposes to eliminate spurious sync edges using their ordering relation, they do not mention doing so iteratively, or in combination with other refinements. However, <ref> [DS91] </ref> represents recursion and process creation, while we require that subroutines be fully inlined and all processes created at the start of the program. While we find little or no use of recursive process creation in practice, we hope to eliminate these restrictions in future research. Lastly, while [CS88] and [DS91] <p> <ref> [DS91] </ref> represents recursion and process creation, while we require that subroutines be fully inlined and all processes created at the start of the program. While we find little or no use of recursive process creation in practice, we hope to eliminate these restrictions in future research. Lastly, while [CS88] and [DS91] presented their analyses as sets of data flow equations, we present B4 more formally here as a lattice framework, and derive its convergence time and accuracy properties based on lattice-theoretic arguments. 6.1.1 B4 lattice framework.
Reference: [Dues91] <author> Duesterwald, E. </author> <title> "Static concurrency analysis in the presence of procedures." </title> <type> Technical Report 91-6, </type> <institution> Department of Computer Science, University of Pittsburgh, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: This form of analysis is called B4 analysis, and is closely related to the SCPreserved analysis in loopless programs performed by Callahan and Subhlok [CS88]. More recently, Duesterwald and Soffa [DS91], <ref> [Dues91] </ref> formulated a before analysis of Ada like programs; our analysis is similar to theirs in principle, although they use a different graph representation and execution model. Our sync hypergraphs extend their representation by including the accept-do construct, selective wait, and conditional entry calls 3 . Though [Dues91] proposes to eliminate <p> and Soffa [DS91], <ref> [Dues91] </ref> formulated a before analysis of Ada like programs; our analysis is similar to theirs in principle, although they use a different graph representation and execution model. Our sync hypergraphs extend their representation by including the accept-do construct, selective wait, and conditional entry calls 3 . Though [Dues91] proposes to eliminate spurious sync edges using their ordering relation, they do not mention doing so iteratively, or in combination with other refinements. However, [DS91] represents recursion and process creation, while we require that subroutines be fully inlined and all processes created at the start of the program.
Reference: [Floy62] <author> Floyd, R. </author> <title> "Algorithm 97: shortest path." </title> <journal> Communications of the ACM, </journal> <volume> 5:6, </volume> <month> June </month> <year> 1962, </year> <month> 345. </month>
Reference: [Hec77] <author> Hecht, M. S. </author> <title> "Flow analysis of computer programs." </title> <publisher> Elsevier North-Holland, </publisher> <address> New York, </address> <year> 1977. </year> <note> ISBN 0-444-00210-3. </note>
Reference-contexts: S1 S2 b 29 b e S3 S1' S3' 30 5 Lattice frameworks and properties for deadlock detection. A lattice framework <ref> [Hec77] </ref> is a quadruple D = (G; L; F; M ) where G = (N; E) is a graph, L is a lattice, F is a set of monotone functions L ! L such that F is closed under meet and composition, and M is a mapping function E ! F <p> Lemma 9 If a lattice L has a finite height h, and is used in a monotone data flow framework D = (G; L; F; M ) where G = (N; E), then the worklist iterative algorithm <ref> [Hec77] </ref> applied to D where each node in N has an initial value of ? terminates after no more than hjN j 2 dlog 2 (jN j)e meet operations and hjN j 2 edge function evaluations in the worst case.
Reference: [KU76] <author> Kam, J. B. and Ullman, J. D. </author> <title> "Global data flow analysis and iterative algorithms." </title> <journal> Journal of the ACM, </journal> <volume> 23:1, </volume> <month> January </month> <year> 1976, </year> <pages> 158-171. </pages>
Reference-contexts: However, they allow us to reduce the asymptotic upper bound on the complexity of the 35 lattice problems used in deadlock detection. 5.4 Kam-Ullman "rapid" problems in irreducible graphs. Kam and Ullman <ref> [KU76] </ref> describe a version of Kildall's iterative node-listing algorithm which halts in at most d (G) + 3 iterations over the nodes of a graph G, where d (G) is the loop connectedness of G, or the largest number of back edges found in any cycle-free path in G (with respect <p> Lemma 11 Given a rapid lattice framework D = (G; L; F; M ) where G = (V; E) is a general graph, Kildall's algorithm converges in O (jV jjEj) edge function evaluations and O (jV j 2 log (jV j)) meet operations. Proof: From Theorem 2 of <ref> [KU76] </ref>, Kildall's algorithm halts in no more than d (G) + 2 iterations on a rapid problem. In the initialization step of Kildall's algorithm, the edge functions into each node are initially evaluated and a meet of the edges into each node is taken.
Reference: [LC91] <author> Long, D. L. and Clarke, L. A. </author> <title> "Data flow analysis of concurrent systems that use the rendezvous model of synchronization." </title> <booktitle> In Proceedings of the Symposium on Testing, Analysis, and Verification (TAV4), </booktitle> <month> October 119 </month> <year> 1991, </year> <pages> 21-35. </pages>
Reference-contexts: This may indicate either an infinite wait anomaly involving the control ancestors of n, or the situation that n is unreachable in control flow. The second additional use of CHT is in data flow analysis involving communications between tasks <ref> [LC91] </ref>. For example, consider reaching definitions analysis. If two tasks do not share memory, then definitions can propagate directly between them only through the parameters of a rendezvous. The rendezvous cannot occur if the corresponding signaling and accept-in nodes can't happen together.
Reference: [LT79] <author> Lengauer, T. and Tarjan, R. E. </author> <title> "A fast algorithm for finding dominators in a flowgraph." </title> <journal> ACM Trans. Prog. Lang. and Syst., </journal> <volume> 1:1, </volume> <month> July </month> <year> 1979, </year> <pages> 121-141. </pages>
Reference-contexts: Deriving the dominator tree of G takes time O (mff (m; n)) <ref> [LT79] </ref>. From these, the path expressions of the dominator strong components of G must be found by applying the algorithm recursively to each component. <p> Proof: The dominator and postdominator trees of a flow graph can be found in time O (jEj log (jN j)) by the simpler algorithm of <ref> [LT79] </ref>. From this, the initial pairs (n n ; n x ) 2 S 59 may be constructed in O (jN j 2 ), by traversal of these trees. 5 We ignore pairs of nodes which are in the same partition.
Reference: [MR90] <author> Masticola, S. P. and Ryder, B. G. </author> <title> "Static infinite wait anomaly detection in polynomial time." </title> <institution> LCSR-TR-141, Laboratory for Computer Science Research, Rutgers University, </institution> <year> 1990. </year>
Reference-contexts: 1 Introduction. In <ref> [MR90] </ref>, we described a program representation and a polynomial time algorithm for approximate detection of deadlock anomalies in a subset of Ada programs. This initial subset included statically declared tasks and message-passing rendezvous. <p> The &lt;statement&gt; can itself contain signaling and accept statements. Thus, task entries can be nested within each other. For obvious reasons, inner and outer nested entries cannot rendezvous with the same task. Note that, when the [do &lt;statement&gt;] part is omitted, the accept construct behaves exactly as described in <ref> [MR90] </ref>. Thus, the behavior of the accept...do construct actually includes the behavior of the accept without its do part. 2.1 Sync hypergraphs. We utilize a representation of the program called a sync hypergraph to detect deadlock in programs containing accept-do constructs. <p> This gives us a way to recursively construct the nodes and control edges where embedded synchronization is present. In the degenerate case where x has no synchronization, x may be represented by a single directed edge. (The original sync graph structure of <ref> [MR90] </ref> collapses x, a i , and a o into a single node a in this case.) 2.1.2 Representing synchronization. Synchronization is represented by hyperedges, or edges with three endpoints. The general format of a hyperedge is (s; a i ; a o ). <p> A signaling statement s can coordinate with an accept statement a containing a procedure block x. If x contains synchronization, then execution can advance through x without advancing past s. The previous execution model cannot represent this type of execution wave motion. We augment the execution model of <ref> [MR90] </ref> with a new ENGAGED state. The model of rendezvous changes as follows: * Initially, the execution wave contains one control successor of the beginning node x for each task. <p> Naturally, the question arises: Given the new execution model, are deadlocks and starvation still the only possible types of infinite wait anomalies? The answer is yes; the proof is identical to that of Theorem 1 of <ref> [MR90] </ref>. 2.3.2 Deadlocks involving hyperedges. A deadlock is characterized by a group of tasks that mutually wait on each other. Consider a subset D of the head nodes of deadlocked tasks in an execution wave. <p> In cycle detection, we use the concept of a hyperedge cycle location graph, or HCLG, corresponding to the sync hypergraph. The HCLG can be constructed so that any cycles must satisfy constraint 1 of <ref> [MR90] </ref>, i.e., that any cycle that enters a task should traverse at least one control edge in that task. Such a construction eliminates cycles which are spurious under constraint 1. split into engage and disengage nodes, s e and s d respectively. Edges between tasks correspond to sync hyperedges. <p> Interactions in mode (c) have some node in x 0 as a head node, and traverse (a o ; s d ). s i o T1 T2 s i o d T2 11 2.5 Scope depth and feasible deadlocks. In <ref> [MR90] </ref>, constraint 2 states that no two head nodes of a deadlock cycle may rendezvous with each other. Constraint 4 says that there must be some way to execute the nodes of the deadlock so that no node outside the deadlock can break the deadlock. <p> If E is anomalous, then we can substitute in Equation (2) to obtain Accept?(E; y) ) SigN set (E; y) = 0: (5) This implies the original constraint 2 of <ref> [MR90] </ref>, that no pair of head nodes in a deadlocked execution wave (and hence a deadlock cycle) can rendezvous. We would like to derive from Equation (1) and Equation (3) those conditions which can be checked given only knowledge of the deadlock cycle and the total number of active tasks. <p> We examine the constraints of <ref> [MR90] </ref> one by one to determine whether they hold, and how they are changed, by the new model of synchronization. 1 1 The original constraints are in italics; changes are in plain typeface. 13 1. Each node in D is transitively coupled to all others in D. <p> When a path enters a task in the HCLG, it cannot exit the task without traversing at least one edge corresponding to a control edge in the sync hypergraph. (c) The path leaves u via a sync edge and does not re-enter u. Section 3.1.1 of <ref> [MR90] </ref> shows that, in straight-line code without conditional branching, any cycle which enters a task more than once corresponds to one which enters the task only once. <p> Furthermore, q cannot be the return node r (which could rendezvous with x). By Theorem 1 of <ref> [MR90] </ref>, q must be a starved node, or a head node of a deadlock cycle, or transitively connected to a starved task or a deadlock. 2 Lemma 54 If any valid deadlock cycle includes the return node of a call body as a head node, then the cycle must also include
Reference: [MR91a] <author> Marlowe, T. J. and Ryder, B. G. </author> <title> "Properties of data flow frameworks: a unified model." </title> <journal> Acta Informatica 28:2, </journal> <year> 1991, </year> <pages> 121-164. </pages>
Reference-contexts: Proof: Direct from Lemmas 4 and 5. 2 Lemma 8 Nondecreasing functions are 1-semibounded. Proof: A function is 1-semibounded if, for all x; y 2 L, f (y) w y u x u f (x) <ref> [MR91a] </ref>. If f is nondecreasing, then f (y) w y w y u x u f (x). 2 5.2.2 Convergence time for iterative lattice problems. <p> Therefore, mapping the data flow problem to the path expression will require O (m 2 ) meet operations and edge function applications, when the data flow problem is k-bounded and that k is constant in m and n. 1-semiboundedness implies 2-boundedness <ref> [MR91a] </ref>. Therefore, the lemma holds. 2 We note that Tarjan's methods may have high overhead costs, and are not frequently used in practice. <p> This may permit both speed and space optimization, depending on the implementation of the rendezvous. 97 7 Signaling count lattice framework. We define a signaling count lattice framework in which the functions correspond to edges in the HCLG <ref> [MR91a] </ref>. A signaling node count summary SigCnt is either: * A vector of nonnegative integers of length jSigsj, such that the y'th element of the vector is not more than some constant k y , or; * The distinguished top element SigCnt &gt; .
Reference: [MR91b] <author> Masticola, S. P. and Ryder, B. G. </author> <title> "A model of Ada programs for static deadlock detection in polynomial time." </title> <booktitle> 1991 ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <address> Santa Cruz, CA, </address> <month> May </month> <year> 1991, </year> <month> 91-102. </month> <journal> Also ACM SIGPLAN Notices 26:12, </journal> <month> December </month> <year> 1991, </year> <pages> 97-107. </pages>
Reference-contexts: 1 Introduction. In [MR90], we described a program representation and a polynomial time algorithm for approximate detection of deadlock anomalies in a subset of Ada programs. This initial subset included statically declared tasks and message-passing rendezvous. Later, in <ref> [MR91b] </ref>, we gave further methods to increase the size of the subset of programs that our algorithm could handle, by adding remote procedure calls, conditional entry calls, select statements, and delay alternatives to the set of Ada constructs we could represent.
Reference: [Saxe77] <author> Saxena, A. </author> <title> "Static detection of deadlocks." </title> <institution> CU-CS-122-77, Dept. of Computer Science, University of Colorado at Boulder, </institution> <year> 1977. </year>
Reference-contexts: To resolve the problem of nested critical section calls, we can move up one level of abstraction and examine the critical section call graph of the program, following a construction developed by Saxena <ref> [Saxe77] </ref> for binary semaphores.
Reference: [Tarj81a] <author> Tarjan, R. E. </author> <title> "A unified approach to path problems." </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 28:3, </volume> <month> July </month> <year> 1981, </year> <pages> 577-593. </pages>
Reference-contexts: We may make the same statement if we initialize all v n to &gt;, in which case each v n will be monotonically nonincreasing during the execution of the worklist algorithm. 2 5.3 Tarjan's path problem methods. Tarjan <ref> [Tarj81a] </ref> gives an algorithm for solving global flow analysis problems which are represented as instances of the all pairs path expression problem.
Reference: [Tarj81b] <author> Tarjan, R. E. </author> <title> "Fast algorithms for solving path problems." </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 28:3, </volume> <month> July </month> <year> 1981, </year> <pages> 594-614. </pages>
Reference-contexts: The result for each vertex 2 We use Tarjan's notation system in this section. 34 v of G is a solution to the data flow problem at v. Constructing the set of path expressions in a general graph takes O (mff (m; n)+t) time <ref> [Tarj81b] </ref>, where m = jV j, n = jEj, t is the time required to find the path expressions for the dominator strong components of G, and ff is the inverse Ackermann function. Deriving the dominator tree of G takes time O (mff (m; n)) [LT79].
Reference: [Zade84] <author> Zadeck, F. K. </author> <title> "Incremental data flow analysis in a structured program editor." </title> <booktitle> ACM SIGPLAN '84 Symposium on Compiler Construction. In ACM SIGPLAN Notices, </booktitle> <address> 19:6, </address> <month> June </month> <year> 1984, </year> <pages> 132-143. 120 </pages>
Reference-contexts: Lemma 71 The total time for solution of a SigCnt lattice problem using Tarjan's path expression algorithm is O (jN j 2 jSigsj) in the worst case. 101 Proof: Direct from Lemmas 10, 66, 68 and 69. 2 A similar node-splitting operation is used by Zadeck <ref> [Zade84] </ref> to prove that a class of lattice frameworks O (jN j + jEj), assuming that the time to perform a meet operation is constant.
References-found: 17

