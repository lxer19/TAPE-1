URL: http://geyer.lcs.mit.edu/~jchapin/6853/Papers/waldo-distributed.ps
Refering-URL: http://geyer.lcs.mit.edu/~jchapin/6853/readinglist.html
Root-URL: 
Email: email addresses: jim.waldo@east.sun.com geoff.wyant@east.sun.com ann.wollrath@east.sun.com sam.kendall@east.sun.com  
Title: A Note on Distributed Computing  
Author: Jim Waldo Geoff Wyant Ann Wollrath Sam Kendall 
Address: 2550 Garcia Avenue Mountain View, CA 94043  
Affiliation: M/S 29-01  
Date: November 1994  
Pubnum: SMLI TR-94-29  
Abstract: We argue that objects that interact in a distributed system need to be dealt with in ways that are intrinsically different from objects that interact in a single address space. These differences are required because distributed systems require that the programmer be aware of latency, have a different model of memory access, and take into account issues of concurrency and partial failure. We look at a number of distributed systems that have attempted to paper over the distinction between local and remote objects, and show that such systems fail to support basic requirements of robustness and reliability. These failures have been masked in the past by the small size of the distributed systems that have been built. In the enterprise-wide distributed systems foreseen in the near future, however, such a masking will be impossible. We conclude by discussing what is required of both systems-level and application-level programmers and designers if one is to take distribution seriously. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> The Object Management Group. </author> <title> Common Object Request Broker: Architecture and Specification. OMG Document Number 91.12.1 (1991). </title>
Reference-contexts: While this view can most recently be seen in such works as the Object Management Groups Common Object Request Broker Architecture (CORBA) <ref> [1] </ref>, it has a history that includes such research systems as Arjuna [2], Emerald [3], and Clouds [4]. In such systems, an object, whether local or remote, is defined in terms of a set of interfaces declared in an interface definition language. <p> They look at the programming interfaces and decide that the problem is that the programming model is not close enough to whatever programming model is currently in vogue (messages in the 1970s [7], [8], procedure calls in the 1980s [9], [10], [11], and objects in the 1990s <ref> [1] </ref>, [2]). A furious bout of language and protocol design takes place and a new distributed computing paradigm is announced that is compliant with the latest programming model. After several years, the percentage of distributed applications is discovered not to have increased significantly, and the cycle begins anew. <p> The alternative is to explain the difference between local and remote access, making the programmer aware that remote address space access is very different from local access. Even if some of the pain is taken away by using an interface definition language like that specified in <ref> [1] </ref> and having it generate an intelligent language mapping for operation invocation on distributed objects, the programmer aware of the difference will not make the mistake of using pointers for cross-address space access. The programmer will know it is incorrect.
Reference: [2] <author> [Parrington, Graham D. </author> <title> Reliable Distributed Programming in C++: The Arjuna Approach. </title> <booktitle> USENIX 1990 C++ Conference Proceedings (1991). </booktitle>
Reference-contexts: While this view can most recently be seen in such works as the Object Management Groups Common Object Request Broker Architecture (CORBA) [1], it has a history that includes such research systems as Arjuna <ref> [2] </ref>, Emerald [3], and Clouds [4]. In such systems, an object, whether local or remote, is defined in terms of a set of interfaces declared in an interface definition language. The implementation of the object is independent of the interface and hidden from other objects. <p> They look at the programming interfaces and decide that the problem is that the programming model is not close enough to whatever programming model is currently in vogue (messages in the 1970s [7], [8], procedure calls in the 1980s [9], [10], [11], and objects in the 1990s [1], <ref> [2] </ref>). A furious bout of language and protocol design takes place and a new distributed computing paradigm is announced that is compliant with the latest programming model. After several years, the percentage of distributed applications is discovered not to have increased significantly, and the cycle begins anew.
Reference: [3] <author> Black, A., N. Hutchinson, E. Jul, H. Levy, and L. Carter. </author> <title> Distribution and Abstract Types in Emerald. </title> <journal> IEEE Transactions on Software Engineering SE-13, </journal> <volume> no. 1, </volume> <month> (January </month> <year> 1987). </year>
Reference-contexts: While this view can most recently be seen in such works as the Object Management Groups Common Object Request Broker Architecture (CORBA) [1], it has a history that includes such research systems as Arjuna [2], Emerald <ref> [3] </ref>, and Clouds [4]. In such systems, an object, whether local or remote, is defined in terms of a set of interfaces declared in an interface definition language. The implementation of the object is independent of the interface and hidden from other objects.
Reference: [4] <author> Dasgupta, P., R. J. Leblanc, and E. Spafford. </author> <title> The Clouds Project: Designing and Implementing a Fault Tolerant Distributed Operating System. </title> <institution> Georgia Institute of Technology Technical Report GIT-ICS-85/29. </institution> <year> (1985). </year>
Reference-contexts: While this view can most recently be seen in such works as the Object Management Groups Common Object Request Broker Architecture (CORBA) [1], it has a history that includes such research systems as Arjuna [2], Emerald [3], and Clouds <ref> [4] </ref>. In such systems, an object, whether local or remote, is defined in terms of a set of interfaces declared in an interface definition language. The implementation of the object is independent of the interface and hidden from other objects. <p> These are the sorts of objects, for example, that appear to be the basis of systems such as Spring [16] or Clouds <ref> [4] </ref>. These objects have some of the characteristics of distributed objects, such as increased latency in comparison to local objects and the need for a different model of memory access.
Reference: [5] <author> Microsoft Corporation. </author> <title> Object Linking and Embedding Programmers Reference. version 1. </title> <publisher> Microsoft Press, </publisher> <year> 1992. </year>
Reference-contexts: What is needed is a variety of implementation techniques, ranging from same-address- space implementations like Microsofts Object Linking and Embedding <ref> [5] </ref> to typical network RPC; different needs for speed, security, reliability, and object co-location can be met by using the right glue implementation. Writing a distributed application in this model proceeds in three phases.
Reference: [6] <author> Linton, Mark. </author> <note> A Taste of Fresco. Tutorial given at the 8th Annual X Technical Conference (January 1994). </note>
Reference-contexts: Also during the second phase, the right set of interfaces to export to various clientssuch as other applicationscan be chosen. There is obviously tremendous exibility here for the application developer. This seems to be the sort of development scenario that is being advocated in systems like Fresco <ref> [6] </ref>, which claim that the decision to make an object local or remote can be put off until after initial system implementation. The final phase is to test with real bullets (e.g., networks being partitioned, machines going down).
Reference: [7] <author> Jaayeri, M., C. Ghezzi, D. Hoffman, D. Middleton, and M. Smotherman. CSP/80: </author> <title> A Language for Communicating Sequential Processes. </title> <booktitle> Proceedings: Distributed Computing CompCon (Fall 1980). </booktitle>
Reference-contexts: They look at the programming interfaces and decide that the problem is that the programming model is not close enough to whatever programming model is currently in vogue (messages in the 1970s <ref> [7] </ref>, [8], procedure calls in the 1980s [9], [10], [11], and objects in the 1990s [1], [2]). A furious bout of language and protocol design takes place and a new distributed computing paradigm is announced that is compliant with the latest programming model.
Reference: [8] <author> Cook, Robert. </author> <title> MOD- A Language for Distributed Processing. </title> <booktitle> Proceedings of the 1st International Conference on Distributed Computing Systems (October 1979). </booktitle>
Reference-contexts: They look at the programming interfaces and decide that the problem is that the programming model is not close enough to whatever programming model is currently in vogue (messages in the 1970s [7], <ref> [8] </ref>, procedure calls in the 1980s [9], [10], [11], and objects in the 1990s [1], [2]). A furious bout of language and protocol design takes place and a new distributed computing paradigm is announced that is compliant with the latest programming model.
Reference: [9] <author> Birrell, A. D. and B. J. Nelson. </author> <title> Implementing Remote Procedure Calls. </title> <journal> ACM Transactions on Computer Systems 2 (1978). </journal>
Reference-contexts: They look at the programming interfaces and decide that the problem is that the programming model is not close enough to whatever programming model is currently in vogue (messages in the 1970s [7], [8], procedure calls in the 1980s <ref> [9] </ref>, [10], [11], and objects in the 1990s [1], [2]). A furious bout of language and protocol design takes place and a new distributed computing paradigm is announced that is compliant with the latest programming model.
Reference: [10] <author> Hutchinson, N. C., L. L. Peterson, M. B. Abott, and S. OMalley. </author> <title> RPC in the x-Kernel: Evaluating New Design Techniques. </title> <booktitle> Proceedings of the Twelfth Symposium on Operating Systems Principles 23, </booktitle> <volume> no. </volume> <month> 5 </month> <year> (1989). </year>
Reference-contexts: They look at the programming interfaces and decide that the problem is that the programming model is not close enough to whatever programming model is currently in vogue (messages in the 1970s [7], [8], procedure calls in the 1980s [9], <ref> [10] </ref>, [11], and objects in the 1990s [1], [2]). A furious bout of language and protocol design takes place and a new distributed computing paradigm is announced that is compliant with the latest programming model.
Reference: [11] <author> Zahn, L., T. Dineen, P. Leach, E. Martin, N. Mishkin, J. Pato, and G. Wyant. </author> <title> Network Computing Architecture. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: They look at the programming interfaces and decide that the problem is that the programming model is not close enough to whatever programming model is currently in vogue (messages in the 1970s [7], [8], procedure calls in the 1980s [9], [10], <ref> [11] </ref>, and objects in the 1990s [1], [2]). A furious bout of language and protocol design takes place and a new distributed computing paradigm is announced that is compliant with the latest programming model.
Reference: [12] <author> Schroeder, Michael D. </author> <title> A State-of-the-Art Distributed System: Computing with BOB. In Distributed Systems, </title> <editor> 2nd ed., S. Mullender, ed., </editor> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: Arguments from efficiency seem to have gone out of style in software 1. We are not the first to notice these differences; indeed, they are clearly stated in <ref> [12] </ref>. 6 engineering, since in the past such concerns have always been answered by speed increases in the underlying hardware. <p> A central problem in distributed computing is insuring that the state of the 2. In fact, authors such as Schroeder <ref> [12] </ref> and Hadzilacos and Toueg [13] take partial failure and concurrency to be the defining problems of distributed computing. 8 whole system is consistent after such a failure; this is a problem that simply does not occur in local computing.
Reference: [13] <author> Hadzilacos, Vassos and Sam Toueg. </author> <title> Fault-Tolerant Broadcasts and Related Problems. In Distributed Systems, </title> <editor> 2nd ed., S. Mullendar, ed., </editor> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: A central problem in distributed computing is insuring that the state of the 2. In fact, authors such as Schroeder [12] and Hadzilacos and Toueg <ref> [13] </ref> take partial failure and concurrency to be the defining problems of distributed computing. 8 whole system is consistent after such a failure; this is a problem that simply does not occur in local computing.
Reference: [14] <author> Walsh, D., B. Lyon, G. Sager, J. M. Chang, D. Goldberg, S. Kleiman, T. Lyon, R. Sandberg, and P. Weiss. </author> <title> Overview of the SUN Network File System. </title> <booktitle> Proceedings of the Winter Usenix Conference (1985). </booktitle>
Reference-contexts: NFS , Suns distributed computing file system <ref> [14] </ref>, [15] is an example of a non- distributed application programer interface (API) (open, read, write, close, etc.) re-implemented in a distributed way.
Reference: [15] <author> Sandberg, R., D. Goldberg, S. Kleiman, D. Walsh, and B. Lyon. </author> <title> Design and Implementation of the SUN Network File System. </title> <booktitle> Proceedings of the Summer Usenix Conference (1985). </booktitle>
Reference-contexts: NFS , Suns distributed computing file system [14], <ref> [15] </ref> is an example of a non- distributed application programer interface (API) (open, read, write, close, etc.) re-implemented in a distributed way.

References-found: 15

