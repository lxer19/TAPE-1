URL: http://www.cs.utah.edu/~cs606/papers/ieeebook92.ps
Refering-URL: http://www.cs.utah.edu/~cs606/
Root-URL: 
Email: e-mail: mak@sor.inria.fr,  F  
Phone: tel.: +33 (1) 39-63-52-93, fax: +33 (1) 39 63 53 30  telex: 697 033  
Title: Fragmented Objects for Distributed Abstractions Keywords: Distributed objects, object oriented programming, distributed abstractions, fragmented objects,
Author: Mesaac Makpangou Yvon Gourhant Jean-Pierre Le Narzul Marc Shapiro 
Date: October 1, 1991  
Address: B.P. 105, 78153 Rocquencourt Cedex, France  
Affiliation: INRIA,  
Abstract: Fragmented Objects (FOs) extend the object concept to a distributed environment. The abstract view of a FO is a single, shared object, of which the distribution is hidden to clients. In the concrete view the FO designer controls (if wished) the distribution of data and function and of the communication between fragments. FO programming is supported by the FOG language, an extension of C++, and by a toolbox of predefined FOs. The FOG compiler ensures distributed type-safety of both the external and internal interfaces, verifies the encapsulation of FO instances, and automatically generates whatever coercions are necessary for marshalling/unmarshalling between layers. Currently, the toolbox contains mainly classes of primitive FOs such as RPC and multicast communication channels. We present the basic fragmented object concepts, the toolbox of predefined FOs, the FOG language and its compiler. We also present an example of a distributed application, the SOS Naming Service, structured as FOs. Finally, we point out the benefits of the FO approach. fl This paper is submitted for publication in the IEEE Software journal. It will also appear in a IEEE Computer Society text. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> Architecture Projects Management Limited. </editor> <title> An engineer's introduction to the architecture. </title> <type> Technical Report TR.03.02, ANSA, </type> <address> Cambridge (United Kingdom), </address> <month> March </month> <year> 1989. </year>
Reference-contexts: 1 Introduction The object-oriented programming methodology is increasingly recognized of primary interest for structuring large, extensible, flexible, long-life software. It is natural to try to extend it to distributed applications. Some proposed extensions include support for either client/server remote invocation (as in ANSA <ref> [1] </ref>) or for the shared object model (as in Orca [2] or Comandos [12]). Both models permit an application object to transparently access another, shared, possibly remote, object. The network is transparent both for the clients and for the designer of a shared object. <p> This is appropriate for statically-configured services (e.g., the SOS Naming Service presented in Section 4). For added flexibility, one would use a system-defined binder, such as ANSA's Trader <ref> [1] </ref>, which maintains mappings of interface descriptions to 7 servers. An ANSA client interfaces to a distributed service using a stub. At binding time, the stub contacts the Trader with an interface description; this returns a server connection. Thereafter, the stub encapsulates that connection. <p> In this section, we present them and point out some of their limitations. 5.2.1 The Client/Server Model The better-known model is the client/server remote invocation, where the server is seen as a remote object accessed via a stub at the client's location. Thus ANSA <ref> [1] </ref> supports remote object invocation. An ANSA client interfaces to a distributed service using a stub, a placeholder object for a remote server, automatically generated from an interface description.
Reference: [2] <author> Henri E. Bal and Andrew S. Tanenbaum. </author> <title> Distributed programming with shared data. </title> <booktitle> In Proceedings of ICCL, </booktitle> <pages> pages 82-91, </pages> <address> Miami, FL, </address> <month> October </month> <year> 1988. </year> <title> IEEE, Computer Society Press. 13 The SOS Distributed Object Manager, the SOS Naming Service, and communication protocols are structured as FOs. </title> <type> 25 </type>
Reference-contexts: It is natural to try to extend it to distributed applications. Some proposed extensions include support for either client/server remote invocation (as in ANSA [1]) or for the shared object model (as in Orca <ref> [2] </ref> or Comandos [12]). Both models permit an application object to transparently access another, shared, possibly remote, object. The network is transparent both for the clients and for the designer of a shared object. Such distribution transparency simplifies the use and the implementation of a shared object. <p> Stub generation is one of the functions of the FOG compiler; FOs are a a superset of the client/server model. 23 5.2.2 The Shared Object Model Orca and Comandos support distributed shared objects, giving the illusion of a single global object space. In Orca <ref> [2] </ref>, shared objects are dynamically replicated under the control of the Orca run-time. All the replicas of a shared object form a single object. Orca ensures transparent access to the replicas and executes a consistency-preservation protocol among them.
Reference: [3] <author> Jean-Pierre Ban^atre, Michel Ban^atre, and Florimond Ployette. </author> <title> The concept of multi-function: a general structuring tool for distributed operating system. </title> <booktitle> In The 6th International Conference on Distributed Computer Systems, </booktitle> <pages> pages 478-485, </pages> <address> Cambridge, Mass. (USA), </address> <month> May </month> <year> 1986. </year> <note> IEEE. </note>
Reference-contexts: Other systems supporting a similar model are Emerald [10] and Amber [6]. 5.2.3 Other FO Approaches Gothic's fragmented objects [4] are based on "multi-functions" <ref> [3] </ref>, a par-allelized generalization of procedures to N callers and P callees. Although we use the same name, our FO model differs from Gothic in three ways. First, we focus on distributed, rather than parallel, computations.
Reference: [4] <author> Jean-Pierre Ban^atre, Michel Ban^atre, and Florimond Ployette. </author> <title> An overview of the Gothic distributed operating system. </title> <institution> Rapport de recherche 504, INRIA, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: But is is also possible for knowledgeable designers to exercise more fine control, based on protection, efficiency or fault-tolerance criteria, deciding how and where to place data and function. Other systems supporting a similar model are Emerald [10] and Amber [6]. 5.2.3 Other FO Approaches Gothic's fragmented objects <ref> [4] </ref> are based on "multi-functions" [3], a par-allelized generalization of procedures to N callers and P callees. Although we use the same name, our FO model differs from Gothic in three ways. First, we focus on distributed, rather than parallel, computations.
Reference: [5] <author> A. D. Birrell and B. J. Nelson. </author> <title> Implementing Remote Procedure Calls. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(1), </volume> <month> February </month> <year> 1984. </year>
Reference-contexts: It may hold local data, and process computations locally, or else forward them for processing to remote fragments. Remote communication entails marshalling/unmarshalling invocation parameters into/from a communication message. A stub is special case of a proxy, performing no local processing, and reduced to the communication function <ref> [5] </ref>. 3 A method is a procedure associated with an object. In C++, methods are also called member functions. 4 We allow different clients to see different interfaces to the same FO. 5 2.2 Fragments The concrete representation of a FO is fragmented onto several address spaces.
Reference: [6] <author> Jeffrey S. Chase, Franz G. Amador, Edward D. Lazowska, Henry M. Levy, and Richard J. Littlefield. </author> <title> The Amber system: Parallel programming on a network of multiprocessors. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 147-158, </pages> <address> Litchfield Park, Arizona USA, </address> <month> December </month> <year> 1989. </year> <note> ACM. </note>
Reference-contexts: But is is also possible for knowledgeable designers to exercise more fine control, based on protection, efficiency or fault-tolerance criteria, deciding how and where to place data and function. Other systems supporting a similar model are Emerald [10] and Amber <ref> [6] </ref>. 5.2.3 Other FO Approaches Gothic's fragmented objects [4] are based on "multi-functions" [3], a par-allelized generalization of procedures to N callers and P callees. Although we use the same name, our FO model differs from Gothic in three ways. First, we focus on distributed, rather than parallel, computations.
Reference: [7] <author> David R. Cheriton and Timothy P. Mann. </author> <title> Decentralizing a global naming service for improved performance and fault tolerance. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(2) </volume> <pages> 147-183, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: The second, of type Tree, actually manages the distributed Name Space. The Tree FO is discussed in Section 4.1. Section 4.2 presents the Name-Service FO. 4.1 The Tree FO The tree is decomposed into multiple partitions according a per-server partitioning, similar to the one of V-system <ref> [7] </ref>, in which each part is a vertical slice, starting at the root of the tree. Each partition, managed by a tree-Fragment, is made of nodes and leaves associated with info data. The set of treeFragments constitute the Tree FO (see Figure 7).
Reference: [8] <author> Yvon Gourhant and Marc Shapiro. FOG/C++: </author> <title> a fragmented-object generator. </title> <booktitle> In C++ Conference, </booktitle> <pages> pages 63-74, </pages> <address> San Francisco, CA (USA), </address> <month> April </month> <year> 1990. </year> <booktitle> Usenix. </booktitle>
Reference-contexts: f == in addition to the interface inherited from channel public: == parallel remote procedure call prpc (in message, out, multiResult); == deferred parallel remote procedure call psend (in message, out multiResult); g; 3.2 FOG Language We have defined a language extension to C++ [16], called FOG (Fragmented Object Generator) <ref> [8] </ref>. It provides features for the designer to specify class groups, group interfaces, client interfaces, accesses to connective objects, and how a client binds to an FO. It is essentially a declarative interface language. <p> To explain the FOG language, we return to the replicated file example. 7 For simplicity, the declarations presented in this paper take some liberties with the exact FOG syntax. 11 details can be found in <ref> [8] </ref>.
Reference: [9] <author> Sabine Habert. </author> <title> Gestion d'objets et migration dans les systemes repartis. </title> <type> PhD thesis, </type> <institution> Universite Paris-6, Pierre-et-Marie-Curie, Paris (France), </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: A binding has three steps. In the first step, a name lookup (similar to ANSA's Trader lookup) yields a provider object for the named interface. In the second step, the binding request is forwarded, by the distributed object manager <ref> [9, 15] </ref>, to a particular method of the provider.
Reference: [10] <author> Norman C. Hutchinson. </author> <title> Emerald: An object-based language for distributed programming. </title> <type> Technical Report 87-01-01, </type> <institution> Department of Computer Science, University of Washington, </institution> <address> Seattle, WA (USA), </address> <month> January </month> <year> 1987. </year>
Reference-contexts: But is is also possible for knowledgeable designers to exercise more fine control, based on protection, efficiency or fault-tolerance criteria, deciding how and where to place data and function. Other systems supporting a similar model are Emerald <ref> [10] </ref> and Amber [6]. 5.2.3 Other FO Approaches Gothic's fragmented objects [4] are based on "multi-functions" [3], a par-allelized generalization of procedures to N callers and P callees. Although we use the same name, our FO model differs from Gothic in three ways.
Reference: [11] <author> Mesaac Mounchili Makpangou. </author> <title> Protocoles de communication et programma-tion par objets : l'exemple de SOS. </title> <type> PhD thesis, </type> <institution> Universite Paris VI, Paris (France), </institution> <month> February </month> <year> 1989. </year>
Reference-contexts: These predefined FOs can be used as connective objects. We first describe briefly the current contents of this toolkit. Then, we present some ongoing work. 3.1.1 Communication Channels Currently, the toolkit contains mainly communication channels <ref> [11] </ref>. A channel object offers to the designer of its associated FO (i.e., the FO using it as connective object), a well-defined interface to communicate with one another, through their group interface.
Reference: [12] <author> Comandos Project. </author> <title> Comandos | construction and management of distributed office systems. Final report on the global architecture, Esprit project 834, </title> <month> September </month> <year> 1987. </year>
Reference-contexts: It is natural to try to extend it to distributed applications. Some proposed extensions include support for either client/server remote invocation (as in ANSA [1]) or for the shared object model (as in Orca [2] or Comandos <ref> [12] </ref>). Both models permit an application object to transparently access another, shared, possibly remote, object. The network is transparent both for the clients and for the designer of a shared object. Such distribution transparency simplifies the use and the implementation of a shared object. <p> The decision to create new replicas, or to migrate the object on to the sites where the object is frequently used, is made automatically by the Orca run-time, based on statistics of recent access. The Comandos <ref> [12] </ref> approach is opposite to ours: in Comandos, shared objects are not fragmented; instead, address spaces are fragmented across sites. When an activity requests access to a remote shared object, its address space "diffuses" over to the site of this object.
Reference: [13] <author> Karsten Schwan and Win Bo. </author> <title> Topologies|distributed objects on multicom-puters. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(2) </volume> <pages> 111-157, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: First, we focus on distributed, rather than parallel, computations. Second, we give the designer full control over the distribution, rather than only the automatic mechanisms provided by the Gothic system. Third, we support multiple client interfaces, whereas Gothic enforces a single global interface to a fragmented object. Topologies <ref> [13] </ref> bear some similarities to our FOs. They allow programmers to define distributed shared objects on a message-passing multicom-puter. Topologies bear a close resemblance to the primitive communication objects of our FO toolkit. The reference describes only communication-oriented Topologies, and seems to lack our general concept of fragmented 24 objects.
Reference: [14] <author> Marc Shapiro. </author> <title> Structure and encapsulation in distributed systems: the Proxy Principle. </title> <booktitle> In The 6th International Conference on Distributed Computer Systems, </booktitle> <pages> pages 198-204, </pages> <address> Cambridge, Mass. (USA), </address> <month> May </month> <year> 1986. </year> <journal> IEEE. </journal> <volume> 26 </volume>
Reference-contexts: The interface of the fragment offers transparency of the distribution to a client. A method of the fragment interface can be entirely implemented by the fragment itself, or it can trigger invocations to other fragments. 2 An interface fragment is called a proxy in <ref> [14] </ref>. It may hold local data, and process computations locally, or else forward them for processing to remote fragments. Remote communication entails marshalling/unmarshalling invocation parameters into/from a communication message.
Reference: [15] <author> Marc Shapiro, Yvon Gourhant, Sabine Habert, Laurence Mosseri, Michel Ruf--fin, and Celine Valot. </author> <title> SOS: An object-oriented operating system | assessment and perspectives. </title> <journal> Computing Systems, </journal> <volume> 2(4) </volume> <pages> 287-338, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: However, to facilitate their job, designers may choose existing policies from a toolkit of predefined FOs, implementing various distributed abstractions: e.g., communication protocols, synchronization facilities, and sharing policies. The fragmented object concept and tools were first implemented as part of the SOS, a distributed object-support operating system <ref> [15] </ref>, which we do not present here. We are currently in the process of porting them to Unix. This paper has two goals. First, it presents the FO concept, and tools to support it. Second, it identifies the benefits of structuring distributed applications as fragmented objects. <p> A binding has three steps. In the first step, a name lookup (similar to ANSA's Trader lookup) yields a provider object for the named interface. In the second step, the binding request is forwarded, by the distributed object manager <ref> [9, 15] </ref>, to a particular method of the provider.
Reference: [16] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. Number ISBN 0-201-12078-X. </title> <publisher> Addison Wesley, </publisher> <year> 1985. </year> <month> 27 </month>
Reference-contexts: group communication class multiChannel : channel f == in addition to the interface inherited from channel public: == parallel remote procedure call prpc (in message, out, multiResult); == deferred parallel remote procedure call psend (in message, out multiResult); g; 3.2 FOG Language We have defined a language extension to C++ <ref> [16] </ref>, called FOG (Fragmented Object Generator) [8]. It provides features for the designer to specify class groups, group interfaces, client interfaces, accesses to connective objects, and how a client binds to an FO. It is essentially a declarative interface language.
References-found: 16

