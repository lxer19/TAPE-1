URL: http://www.cs.man.ac.uk/~kung-kiu/pub/lopstr95.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: lau@intellektik.informatik.th-darmstadt.de  kung-kiu@cs.man.ac.uk)  ornaghi@hermes.mc.dsi.unimi.it  
Phone: 2  
Title: Towards An Object-Oriented Methodology for Deductive Synthesis of Logic Programs  
Author: Kung-Kiu Lau and Mario Ornaghi 
Note: (or  
Address: Alexanderstr. 10, D-64283 Darmstadt, Germany  Milano, Via Comelico 39/41, Milano, Italy  
Affiliation: 1 Fachgebiet Intellektik, Fachbereich Informatik Technische Hochschule Darmstadt  Dipartimento di Scienze dell'Informazione Universita' degli studi di  
Abstract: Quality software must be reusable, extensible, and reliable. Object-oriented programming purports to achieve these attributes by the use of classes and inheritance (informally). In this paper, we show how our existing approach to deductive synthesis of logic programs can serve as the basis for an object-oriented methodology for formal program development that achieves reusability, extensibility and correctness (formally). 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Bertoni, G. Mauri and P. Miglioli. </author> <title> On the power of model theory in specifying abstract data types and in capturing their recursiveness. </title> <note> Fundamenta Informaticae VI(2):127-170, </note> <year> 1983. </year>
Reference-contexts: We endow frameworks with isoinitial semantics <ref> [1, 8, 14] </ref>. It is closely related to initial semantics used in algebraic ADTs [17]. In initial semantics the intended models are initial models, whereas in isoinitial semantics they are isoinitial models. We choose isoinitial semantics because the existence of an isoinitial model corresponds to the existence of steadfast programs.
Reference: 2. <author> A. Brogi, P. Mancarella, D. Pedreschi and F. Turini. </author> <title> Modular logic programming. </title> <journal> ACM TOPLAS 16(4) </journal> <pages> 1361-1398, </pages> <year> 1994. </year>
Reference-contexts: Our characterisation of modularity and reusability is not only different from that in conventional object-oriented programming, but also from that in modular logic programming, e.g. <ref> [2, 4] </ref>. In the latter, composition is not performed in the context of a framework, and there is no notion of parametric correctness corresponding to steadfastness. Consequently, the notion of correct reusability is also missing there.
Reference: 3. <author> K.M. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design, static typing and semantics. </title> <editor> J. </editor> <booktitle> Functional Programming 4(2) </booktitle> <pages> 127-206, </pages> <year> 1994. </year> <title> Special issue: Type systems for object-oriented programming. </title>
Reference-contexts: Moreover, open frameworks can be composed with closed frameworks, giving rise to a hierarchy of frameworks. We believe such a hierarchy is a better semantic characterisation of type inheritance than the usual inheritance (and multiple inheritance) mechanisms in object-oriented programming which can be very unwieldy (see e.g. <ref> [3] </ref>). Our methodology is similar in spirit to, but different in substance from, existing work on modular or object-oriented program construction. Basically, we have raised modularity and reusability to the semantic level.
Reference: 4. <author> M. Bugliesi, E. Lamma and P. Mello. </author> <title> Modularity in logic programming. </title> <journal> J. Logic Programming 19,20:443-502, </journal> <note> 1994. Special issue: Ten years of logic programming. </note>
Reference-contexts: Our characterisation of modularity and reusability is not only different from that in conventional object-oriented programming, but also from that in modular logic programming, e.g. <ref> [2, 4] </ref>. In the latter, composition is not performed in the context of a framework, and there is no notion of parametric correctness corresponding to steadfastness. Consequently, the notion of correct reusability is also missing there.
Reference: 5. <author> C.C. Chang and H.J. Keisler. </author> <title> Model Theory. </title> <publisher> North-Holland, </publisher> <year> 1973. </year>
Reference-contexts: It can be stated in terms of specification frameworks as 5 Here, for the sake of simplicity, we assume that the intersection of the signatures of C and F () coincides with . 6 See e.g. <ref> [5] </ref>. follows: in a closed framework C, a program P for computing r, specified by (the adequate definition) 8 (r (x) $ R (x)), is correct wrt the specification iff P 's minimum Herbrand model is isomorphic to the intended model of C (restricted to the signature of P ).
Reference: 6. <author> Y. Deville and K.K. Lau. </author> <title> Logic program synthesis. </title> <journal> J. Logic Programming 19,20:321-350, </journal> <note> 1994. Special issue: Ten years of logic programming. </note>
Reference-contexts: A survey can be found in <ref> [6] </ref>. Example 2.
Reference: 7. <author> J. </author> <title> Functional Programming 4(2), 1994. Special issue: Type systems for object-oriented programming. </title>
Reference-contexts: Reliability results from the ability to monitor assertions and invariants contained in classes. However, at present, there is no single standard (formal) characterisation of object-oriented programming (see <ref> [7] </ref>), so we shall adopt the common view of object-oriented programming, as expressed in e.g. [13, 16] (based on imperative programming).
Reference: 8. <author> K.K. Lau and M. Ornaghi. </author> <title> On specification frameworks and deductive synthesis of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. LOPSTR 94 and META 94 , Lecture Notes in Computer Science 883, </booktitle> <pages> pages 104-121, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: We endow frameworks with isoinitial semantics <ref> [1, 8, 14] </ref>. It is closely related to initial semantics used in algebraic ADTs [17]. In initial semantics the intended models are initial models, whereas in isoinitial semantics they are isoinitial models. We choose isoinitial semantics because the existence of an isoinitial model corresponds to the existence of steadfast programs.
Reference: 9. <author> K.K. Lau, M. Ornaghi and S.- A. </author> <title> Tarnlund. The halting problem for deductive synthesis of logic programs. </title> <editor> In P. van Hentenryck, editor, </editor> <booktitle> Proc. 11 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 665-683, </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: A detailed description of our approach, including criteria for correctness and for determining when to halt the synthesis process (with a totally correct program), can be found in <ref> [9] </ref>. Here we give a brief overview of its key elements that are relevant to this paper. 2.1 Specification Frameworks A framework is a first-order theory that embodies all the relevant knowledge of the problem domain of interest.
Reference: 10. <author> K.K. Lau, M. Ornaghi and S.- A. </author> <title> Tarnlund. Steadfast logic programs. </title> <note> Submitted to J. Logic Programming. </note>
Reference-contexts: The parameters of that belong to will be called framework-parameters, to distinguish them from those that do not belong to , which we will call 7 A more abstract, model-theoretic characterisation, can be found in <ref> [10] </ref>. program-parameters. The programs for computing framework-parameters can be supplied only after the instantiation F () [ C by a closed framework C, while those for the program-parameters can be supplied either before or after such an instantiation. Note that, in a closed framework, an open program has only program-parameters. <p> Example 7. Let LIST 1 (Elem 1 ; 1 ) = (LIST (Elem; )), where is a signature morphism renaming the symbols of LIST . In LIST 1 (Elem 1 ; 1 ) we can 9 For instance, we have considered this in <ref> [10] </ref>. define: X Y $ 9B (XjB = Y )_ We can prove that is a partial ordering (by using the p-axioms). Therefore LIST [LIST 1 ] satisfies the required proof obligation, and is a framework that inherits the sorting programs.
Reference: 11. <author> F.G. McCabe. </author> <title> L& O: Logic and Objects. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: Our methodology is similar in spirit to, but different in substance from, existing work on modular or object-oriented program construction. Basically, we have raised modularity and reusability to the semantic level. Our characterisation of object-oriented programming is different from that used in object-oriented logic programming, e.g. <ref> [11, 15] </ref>, where the conventional notions of object-oriented programming are imported virtually wholesale, at the syntactic level. Our characterisation of modularity and reusability is not only different from that in conventional object-oriented programming, but also from that in modular logic programming, e.g. [2, 4].
Reference: 12. <author> B. Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Object-oriented programming is very much seen as the standard bearer of the software industry nowadays, because it purports to achieve the key attributes of any quality software: reusability, extensibility, and reliability (see e.g. <ref> [12, 13] </ref>). Object-oriented programming achieves reusability and extensibility by using a class as the basic modular unit, and a mechanism called inheritance to define new classes from existing ones. Reliability results from the ability to monitor assertions and invariants contained in classes.
Reference: 13. <author> B. Meyer. </author> <title> Eiffel the Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Object-oriented programming is very much seen as the standard bearer of the software industry nowadays, because it purports to achieve the key attributes of any quality software: reusability, extensibility, and reliability (see e.g. <ref> [12, 13] </ref>). Object-oriented programming achieves reusability and extensibility by using a class as the basic modular unit, and a mechanism called inheritance to define new classes from existing ones. Reliability results from the ability to monitor assertions and invariants contained in classes. <p> Reliability results from the ability to monitor assertions and invariants contained in classes. However, at present, there is no single standard (formal) characterisation of object-oriented programming (see [7]), so we shall adopt the common view of object-oriented programming, as expressed in e.g. <ref> [13, 16] </ref> (based on imperative programming). In an object-oriented system, the basic modular unit is a class, which describes an implementation of an abstract data type (ADT), including a set of procedures, called methods, that implement operations on the ADT.
Reference: 14. <author> P. Miglioli, U. Moscato and M. Ornaghi. </author> <title> Abstract parametric classes and abstract data types defined by classical and constructive logical methods. </title> <journal> J. Symb. Comp. </journal> <volume> 18 </volume> <pages> 41-81, </pages> <year> 1994. </year>
Reference-contexts: We endow frameworks with isoinitial semantics <ref> [1, 8, 14] </ref>. It is closely related to initial semantics used in algebraic ADTs [17]. In initial semantics the intended models are initial models, whereas in isoinitial semantics they are isoinitial models. We choose isoinitial semantics because the existence of an isoinitial model corresponds to the existence of steadfast programs.
Reference: 15. <author> C.D.S. Moss. </author> <title> Prolog++ The Power of Object-Oriented and Logic Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Our methodology is similar in spirit to, but different in substance from, existing work on modular or object-oriented program construction. Basically, we have raised modularity and reusability to the semantic level. Our characterisation of object-oriented programming is different from that used in object-oriented logic programming, e.g. <ref> [11, 15] </ref>, where the conventional notions of object-oriented programming are imported virtually wholesale, at the syntactic level. Our characterisation of modularity and reusability is not only different from that in conventional object-oriented programming, but also from that in modular logic programming, e.g. [2, 4].
Reference: 16. <author> J. Palsberg and M.I. Schwartzbach. </author> <title> Object-Oriented Type Systems. </title> <publisher> Wiley, </publisher> <year> 1994. </year>
Reference-contexts: Reliability results from the ability to monitor assertions and invariants contained in classes. However, at present, there is no single standard (formal) characterisation of object-oriented programming (see [7]), so we shall adopt the common view of object-oriented programming, as expressed in e.g. <ref> [13, 16] </ref> (based on imperative programming). In an object-oriented system, the basic modular unit is a class, which describes an implementation of an abstract data type (ADT), including a set of procedures, called methods, that implement operations on the ADT.
Reference: 17. <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: We endow frameworks with isoinitial semantics [1, 8, 14]. It is closely related to initial semantics used in algebraic ADTs <ref> [17] </ref>. In initial semantics the intended models are initial models, whereas in isoinitial semantics they are isoinitial models. We choose isoinitial semantics because the existence of an isoinitial model corresponds to the existence of steadfast programs. <p> The obligation (a) is rather restrictive; it can be avoided by using signature morphisms. We do not have the space to present them here. They have been introduced in the algebraic approach (see e.g. <ref> [17] </ref>) and can be used in our approach, essentially in the same way. Now, let F () = D [ P () be an adequate open framework and C be an adequate closed framework that defines all the parameters .
References-found: 17

