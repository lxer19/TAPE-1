URL: http://www.cs.nyu.edu/phd_students/sachs/thesisproposal.ps.gz
Refering-URL: http://www.cs.nyu.edu/phd_students/sachs/oldresearch.html
Root-URL: http://www.cs.nyu.edu
Title: Expressive and Extensible Synchronization Mechanisms for a Concurrent Multi-dispatch Object-Oriented Language  
Author: Jay Sachs 
Date: September 26, 1995  
Abstract-found: 0
Intro-found: 1
Reference: [ACM87] <editor> ACM/SIGPLAN. </editor> <booktitle> Proceedings of OOPSLA '87, </booktitle> <address> New York, </address> <month> De-cember </month> <year> 1987. </year>
Reference: [ACM93] <editor> ACM/SIGPLAN. </editor> <booktitle> Proceedings of OOPSLA '93, </booktitle> <address> New York, </address> <month> Oc-tober </month> <year> 1993. </year>
Reference: [Ada93] <institution> Ada 9X Rationale. Intermetrics, Inc., </institution> <address> Cambridge, MA, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: Such languages are termed singly-dispatched, referring to the use of a single parameter that controls dynamic dispatch. It is not necessary for this parameter to be implicit; Ada9X, for example, makes this controlling argument explicit, although it is still singly-dispatched <ref> [Ada93] </ref>. Single dispatch can be implemented efficiency as an array lookup followed by an indirect function call. This efficiency in part accounts for the overwhelming prevalence of single dispatch as the mechanism for polymorphism in object-oriented languages. <p> Single dispatch can be modestly extended to dispatch based on more than one parameter, all of which are subtypes of some common type. We then have several choices on which to define the specific function invoked <ref> [Ada93] </ref>: * All controlled parameters must be same type; if not, a runtime error occurs. * The programmer selects a controlling parameter via a special declara tion. * All controlled parameters must share the same code for the operation, e.g., the dispatch tables (or their equivalent) point to same code body.
Reference: [Ame91] <author> Pierre America. </author> <title> Issues in the design of a parallel object-oriented language. In A parallel object-oriented language: design and semantic foundations. </title> <publisher> CWI, </publisher> <year> 1991. </year>
Reference-contexts: Modularity and encapsulation Modules and ADTs can be thought of as giving protection at the syntactic level; modules cannot access the internals of other modules. Objects, however, give protection at the semantic level; objects cannot access the internals of other objects, yielding a finer granularity <ref> [Ame91] </ref>. Execution model The execution of a program in sequential object-oriented languages have the following characteristics [Ame91]: 1. Execution starts with exactly one active object. 2. Object execution blocks after sending a message; execution re sumes when the result (s) arrive. 3. <p> Objects, however, give protection at the semantic level; objects cannot access the internals of other objects, yielding a finer granularity <ref> [Ame91] </ref>. Execution model The execution of a program in sequential object-oriented languages have the following characteristics [Ame91]: 1. Execution starts with exactly one active object. 2. Object execution blocks after sending a message; execution re sumes when the result (s) arrive. 3. <p> In object-oriented systems, America has identified the following non-exclusive potential sources of concurrency (and hence nondeterminism) <ref> [Ame91] </ref>: * Introduce the notion of processes and concurrency orthogonally to the object-oriented model. This requires that the programmer expect interaction between concurrent processes at all points of execution. <p> Even in languages without explicit bodies, where synchronization constraints are decentralized, code reuse by inheritance is difficult to achieve. Some language designers have opted to exclude inheritance from their language entirely <ref> [Ame91] </ref>. As a guiding example, suppose we have a bounded_buffer class, with methods put () and get (). We consider four potential derivations from this class, which we will identify by the new method added in the derived class: 1. get_rear (), which returns the most recent item added.
Reference: [BI93] <author> Andrew P. Black and Mark P. Immel. </author> <title> Encapsulating plurality. </title> <booktitle> In Nierstrasz [Nie93b], </booktitle> <pages> pages 57-79. </pages>
Reference-contexts: Notably, we must address the issues of encapsulation of synchronization mechanisms, irrespective of their impact on the type system. Another significant issue is the choice of module granularity. A natural unit might be the object level; units consisting of groups of objects have been proposed such as the gaggle <ref> [BI93] </ref> and domains [Nie87]. Questions raised: 1. What synchronization information, if any, is appropriate to include in the public interfaces of objects to support reusability and modularity? 2. What is an appropriate granularity of modularity to provide reusable components and to make optimal use of system resources? 3.
Reference: [Cha92] <author> Craig Chambers. </author> <title> Object-oriented multi-methods in Cecil. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> ECOOP '92 European Conference on Object-Oriented Programming, number 615 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Polymorphic functions for which multiple arguments control dynamic dispatch are called multi-methods. The specific function called by the invocation of a 3 multi-method is the function defined for the "most specific" of the control-ling arguments. Various criteria for determining specificity and methods of resolving ambiguity have been proposed <ref> [MHH91, Kee89, Cha92] </ref>. However, current implementations of multi-dispatch require non-constant time runtime overhead for resolution; unlike single dispatch, a simple table lookup is not sufficient. Incorporating multi-dispatch into a language has significant consequences for encapsulation.
Reference: [Cha93] <author> Craig Chambers. </author> <title> Predicate classes. </title> <booktitle> In Nierstrasz [Nie93b], </booktitle> <pages> pages 268-296. </pages>
Reference-contexts: It seems a natural step to extend method specialization and dynamic dispatch based on this enhanced notion of subtype. Polymorphism would necessarily be dependent on the state of the object (s) involved, since this state is what governs the synchronization mechanisms. Predicate classes <ref> [Cha93] </ref> are one possible basis for such state-dependent types. Questions raised: 1. How should synchronization mechanisms affect the type of objects? 2. What effects should synchronization constraints have on dynamic dis patch? 3. <p> I will start with the assumption that object-level and method-level synchronization are both effective, i.e., neither "overrides" the other, and plan to determine if either subsumes the other. As synchronization conditions typically depend on the state of the objects, state-driven dispatching such as found in predicate classes <ref> [Cha93] </ref> may provide a basis for the design of concurrency constraints in a multi-dispatch system. Specifically, I propose to: * investigate synchronization mechanisms suitable for a concurrent multi-dispatch object-oriented language. This may or may not involve reflection and meta-objects.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: Object-oriented languages extend ADTs by 1 granting membership to operations as well as data. The characteristics and benefits of the object-oriented approach include: Polymorphism Many object-oriented languages provide inclusion polymor-phism <ref> [CW85] </ref>, in which a typed reference to an object may in fact refer to one of several different types; the actual operations executed are determined by the type of the object referred to, not the type of the reference.
Reference: [Fer89] <author> Jacques Ferber. </author> <title> Computational reflection in class based object oriented languages. </title> <booktitle> In Proceedings of OOPSLA '89, </booktitle> <pages> pages 317-326, </pages> <address> New York, </address> <month> October </month> <year> 1989. </year> <pages> ACM/SIGPLAN. </pages>
Reference-contexts: As meta-objects are themselves objects, they also have a meta-object; this infinite tower of meta-objects is in practice implemented via lazy construction. An alternative approach to incorporating reflection in object-oriented systems modeled by message passing is to reify messages as first-class objects <ref> [Fer89] </ref>. In such systems, method calls are strictly equivalent to passed messages, which are themselves first-class objects; by invoking appropriate methods of the specialized message objects, one has access to the execution model from within that program.
Reference: [Kee89] <author> Sonya E. Keene. </author> <title> Object Oriented Programming in CLOS. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Polymorphic functions for which multiple arguments control dynamic dispatch are called multi-methods. The specific function called by the invocation of a 3 multi-method is the function defined for the "most specific" of the control-ling arguments. Various criteria for determining specificity and methods of resolving ambiguity have been proposed <ref> [MHH91, Kee89, Cha92] </ref>. However, current implementations of multi-dispatch require non-constant time runtime overhead for resolution; unlike single dispatch, a simple table lookup is not sufficient. Incorporating multi-dispatch into a language has significant consequences for encapsulation.
Reference: [KL89] <author> Dennis G. Kafura and Keung Hae Lee. </author> <title> Inheritance in actor based concurrent object-oriented languages. </title> <editor> In Stephen Cook, editor, </editor> <booktitle> Proceedings of ECOOP'89, BCS Workshop Series, </booktitle> <pages> pages 131-145. </pages> <publisher> Cambridge University Press, </publisher> <month> July </month> <year> 1989. </year> <month> 12 </month>
Reference-contexts: This cannot be accommodated by a change or addition of states. 4. lock () and unlock (), "mixed-in" via multiple inheritance from a Lock class. lock () locks an object, preventing other method calls, until the unlock () method is invoked. A solution to derivation 1 was presented in <ref> [KL89] </ref>. A more comprehensive solution, addressing all four derivations, was presented in [MTY93]; this solution, however, is complex, involving separation of synchronization and operation code and includes several orthogonal synchronization mechanisms, making it somewhat unwieldy and intractable in practise.
Reference: [LW93] <author> Barbara Liskov and Jeannette Wing. </author> <title> A new definition of the subtype relation. </title> <booktitle> In Nierstrasz [Nie93b], </booktitle> <pages> pages 118-141. </pages>
Reference-contexts: Given this definition, the invocation of a function on subtype (s) of its expected argument (s) is type-safe. Other definitions of subtyping have been proposed that strengthen the notion of substitution safety, based on behavioral subtyping <ref> [WZ88, LW93] </ref>. Considering the interface of an object to be its "contract" as a server to client objects [Mey88], it is plausible to consider synchronization constraints as part of the interface, since such mechanisms in part determine when a method may be invoked.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object Oriented Software Construction. </title> <publisher> Pren-tice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Other definitions of subtyping have been proposed that strengthen the notion of substitution safety, based on behavioral subtyping [WZ88, LW93]. Considering the interface of an object to be its "contract" as a server to client objects <ref> [Mey88] </ref>, it is plausible to consider synchronization constraints as part of the interface, since such mechanisms in part determine when a method may be invoked. Nierstrasz has proposed regular types [Nie93a] for capturing partial synchronization information in the type system.
Reference: [MGNS91] <author> Mesaac Makpangou, Yvon Gourhant, Jean-Pierre Le Narzul, and Marc Shapiro. </author> <title> Structuring distributed applications as fractured objects. </title> <institution> Rapport de Recherche 1404, INRIA, </institution> <address> Le Chesnay Cedex, France, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: Another consideration is object location, and the related issues of object mobility and process mobility. In a distributed or parallel system, it is natural to consider each object to be located at a specific node, although one proposal has been made to fracture objects across nodes in a system <ref> [MGNS91] </ref>. Questions raised: 1. What governs the creation and termination of threads? 2. Are threads a kind of object, i.e., first class and unified? 3. Where are method invocations executed? Is this location controllable by the programmer? 4.
Reference: [MHH91] <author> Warwick B. Mugridge, John Hamer, and John G. Hosking. </author> <title> Multi-methods in a statically-typed programming language. </title> <editor> In Pierre America, editor, </editor> <booktitle> ECOOP '91 European Conference on Object-Oriented Programming, number 512 in Lecture Notes in Computer Science, </booktitle> <pages> pages 308-324. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Polymorphic functions for which multiple arguments control dynamic dispatch are called multi-methods. The specific function called by the invocation of a 3 multi-method is the function defined for the "most specific" of the control-ling arguments. Various criteria for determining specificity and methods of resolving ambiguity have been proposed <ref> [MHH91, Kee89, Cha92] </ref>. However, current implementations of multi-dispatch require non-constant time runtime overhead for resolution; unlike single dispatch, a simple table lookup is not sufficient. Incorporating multi-dispatch into a language has significant consequences for encapsulation.
Reference: [MPW92] <author> Robin Milner, Joachim Parrow, and David Walker. </author> <title> A calculus of mobile processes I. </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-40, </pages> <year> 1992. </year>
Reference-contexts: for modularity and encapsulation in concurrent multi-dispatch object-oriented languages, with a particular interest in the impact these have on the type system. * design a concurrent multi-dispatch object-oriented language including multi-threaded objects and inheritance. * provide a formal basis for such a language, either via a translation to Milner's -calculus <ref> [MPW92] </ref> or an extension thereof. * implement a significant subset of the language in a uniprocessor simu lation. * code several representative applications in the language, demonstrating its expressiveness and extensibility. 11
Reference: [MTY93] <author> Satoshi Matsuoka, Kenjiro Taura, and Akinori Yonezawa. </author> <title> Highly efficient and encapsulated re-use of synchronization code in concurrent object-oriented languages. </title> <booktitle> In Proceedings of OOP-SLA '93 [ACM93]. </booktitle>
Reference-contexts: A solution to derivation 1 was presented in [KL89]. A more comprehensive solution, addressing all four derivations, was presented in <ref> [MTY93] </ref>; this solution, however, is complex, involving separation of synchronization and operation code and includes several orthogonal synchronization mechanisms, making it somewhat unwieldy and intractable in practise. Also, it does not consider synchronization issues when objects are themselves multi-threaded. <p> A consequence of this is that we should be able to define synchronization mechanisms at the method level, in addition to the object level. Object-level synchronization mechanisms are those mechanisms based on the state of one 10 particular object. These including guard clauses, enable-sets, and transition states <ref> [MTY93] </ref>. Such mechanisms should be reusable if not inheritable. Method-level synchronization can be described as defining synchronization constraints over interactions of objects.
Reference: [MWIY91] <author> Satoshi Matsuoka, Takuo Watanbe, Yuuji Ichisugi, and Akinori Yonezawa. </author> <title> Object-oriented concurrent reflective architectures. </title> <editor> In Mario Tokore et.al., editor, </editor> <booktitle> Proceedings of the Workshop on Object-Based Concurrent Programming, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Reflection, and specifically meta-objects, can be used for monitoring and profiling operations, dynamically maintaining a continuously active system, debugging, and exception handling. Reflection has also shown promise as a 4 mechanism for providing synchronization in concurrent languages <ref> [MWIY91, MY90] </ref>. 3 Concurrency The source of increased computational power of a concurrent system over a sequential system is the nondeterminism present in the concurrent system; a deterministic system is effectively serialized, and thus offers no improvement over a sequential system.
Reference: [MY90] <author> Satoshi Matsuoka and Akinori Yonezawa. </author> <title> Metalevel solution to inheritance anomaly in concurrent object-oriented langagues. </title> <booktitle> In Proceedings of OOPSLA/ECOOP '90, </booktitle> <address> New York, </address> <month> October </month> <year> 1990. </year> <booktitle> ACM/SIGPLAN. Submitted to OOPSLA/ECOOP '90 Workshop on Reflection and Metalevel Architectures in Object-Oriented Languages. </booktitle>
Reference-contexts: Reflection, and specifically meta-objects, can be used for monitoring and profiling operations, dynamically maintaining a continuously active system, debugging, and exception handling. Reflection has also shown promise as a 4 mechanism for providing synchronization in concurrent languages <ref> [MWIY91, MY90] </ref>. 3 Concurrency The source of increased computational power of a concurrent system over a sequential system is the nondeterminism present in the concurrent system; a deterministic system is effectively serialized, and thus offers no improvement over a sequential system. <p> Also, it does not consider synchronization issues when objects are themselves multi-threaded. A different approach using meta-objects in a reflective system was suggested in <ref> [MY90] </ref>. Questions raised: 7 1. What synchronization mechanisms are appropriate to facilitate code reuse and sharing? 2. Is inheritance an appropriate mechanism in concurrent object-oriented languages for reuse and code sharing? If not, what is? 3.
Reference: [MY93] <author> Satoshi Matsuoka and Akinori Yonezawa. </author> <title> Analysis of inheritance anomaly in object-oriented concurrent programming languages. 13 In Gul Agha, </title> <editor> Peter Wegner, and Akinori Yonezawa, editors, </editor> <booktitle> Re--search Directions in Concurrent Object-Oriented Programming, </booktitle> <pages> pages 107-150. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1993. </year>
Reference-contexts: In a concurrent system, especially a multi-dispatch system, what efficient algorithms can be used to implement dynamic dispatch, since objects may reside at different nodes? 3.2 Inheritance and code reuse Several researchers have noted interference between inheritance and concur-rency mechanisms in object-oriented languages. This inheritance anomaly 6 <ref> [MY93] </ref> is readily apparent in those languages in which objects are active: the explicit procedure that determine an object's overall synchronization behavior usually requires complete redefinition in derived classes in order to account for new and modified methods.
Reference: [Nie87] <author> Oscar Nierstrasz. </author> <title> Active objects in Hybrid. </title> <booktitle> In Proceedings of OOPSLA '87 [ACM87], </booktitle> <pages> pages 243-253. </pages>
Reference-contexts: Another significant issue is the choice of module granularity. A natural unit might be the object level; units consisting of groups of objects have been proposed such as the gaggle [BI93] and domains <ref> [Nie87] </ref>. Questions raised: 1. What synchronization information, if any, is appropriate to include in the public interfaces of objects to support reusability and modularity? 2. What is an appropriate granularity of modularity to provide reusable components and to make optimal use of system resources? 3.
Reference: [Nie93a] <author> Oscar Nierstrasz. </author> <title> Regular types for active objects. </title> <booktitle> In Proceedings of OOPSLA '93 [ACM93], </booktitle> <pages> pages 1-15. </pages>
Reference-contexts: Considering the interface of an object to be its "contract" as a server to client objects [Mey88], it is plausible to consider synchronization constraints as part of the interface, since such mechanisms in part determine when a method may be invoked. Nierstrasz has proposed regular types <ref> [Nie93a] </ref> for capturing partial synchronization information in the type system. It seems a natural step to extend method specialization and dynamic dispatch based on this enhanced notion of subtype.
Reference: [Nie93b] <editor> Oscar M. Nierstrasz, editor. </editor> <booktitle> ECOOP '93 - Object-Oriented Programming, number 707 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [US87] <author> David Ungar and Randall B. Smith. </author> <title> Self: The power of simplicity. </title> <booktitle> In Proceedings of OOPSLA '87 [ACM87], </booktitle> <pages> pages 227-241. </pages>
Reference-contexts: I suggest a more powerful alternative: * Allow objects and methods to be active. Processes are encapsulated in both objects and methods, though not every object or method need be active. This can be expedited through union of the object and closure concepts <ref> [US87] </ref>. By focusing on object interaction, we can observe that in a concurrent system, synchronization depends on state of the system, not just state of any one specific object. This is especially apropos to a multi-dispatch system, where no distinguished (i.e. controlling) object exists in any method invocation.
Reference: [WZ88] <author> Peter Wegner and Stanley B. Zdonik. </author> <title> Inheritance as an incremental modification mechanism or What like is and isn't like. </title> <editor> In G. Goos and H. Hartmanis, editors, </editor> <booktitle> ECOOP '88 European Conference on Object-Oriented Programming, number 322 in Lecture Notes in Computer Science, </booktitle> <pages> pages 55-77. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Given this definition, the invocation of a function on subtype (s) of its expected argument (s) is type-safe. Other definitions of subtyping have been proposed that strengthen the notion of substitution safety, based on behavioral subtyping <ref> [WZ88, LW93] </ref>. Considering the interface of an object to be its "contract" as a server to client objects [Mey88], it is plausible to consider synchronization constraints as part of the interface, since such mechanisms in part determine when a method may be invoked.
Reference: [Yon91] <author> Akinori Yonezawa. </author> <title> Panel: What is an object? In Mario Tokoro, </title> <editor> Oscar Nierstrasz, and Peter Wegner, editors, </editor> <booktitle> Object-based concurrent computing : ECOOP '91 workshop, number 612 in Lecture Notes in Computer Science, </booktitle> <pages> page 264. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <month> 14 </month>
Reference-contexts: If synchronization information is part of an object's interface, how well does inheritance function as a subtyping mechanism? 3.3 Modularity and encapsulation Yonezawa has remarked that "objects can model entities very well, but not the relationship among them" <ref> [Yon91] </ref>. In a sequential system, only one object is active at any given moment; hence the potential interactions among objects is strictly limited. The introduction of a new object or class in a sequential system should not affect the interactions of the other objects.
References-found: 26

