URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1994/TR39.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Email: Email: -grichard, singhal-@cis.ohio-state.edu  
Title: Abstract: Distributed applications typically consist of a group of processes executing on processors which share
Author: Golden G. Richard III Mukesh Singhal 
Keyword: Message passing, distributed process recovery, complete process recovery, vector  
Address: Columbus, OH 43210  
Affiliation: Department of Computer and Information Science The Ohio State University  
Note: time,  
Abstract: This paper presents a comprehensive technique for complete process recovery in distributed systems. By complete recovery we mean the restoration of a consistent system state as well as proper handling of lost, duplicate, and delayed messages resulting from the failure and restoration of the system to a consistent state. Message handling has often been treated casually in previous recovery techniques. In constrast, our recovery techniques directly address message handling issues. We classify the message types which a recovery mechanism must deal with to motivate our message-handling techniques. The use of vector time allows us to reduce the overhead associated with recovery and helps expedite the recovery process after a failure. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Bhargava, S. R. Lian, </author> <title> "Independent Checkpointing and Concurrent Rollback for Recovery in Distributed Systems - An Optimistic Approach," </title> <booktitle> Proc. of the 7th Symp. on Reliable Distributed Systems , Columbus, </booktitle> <address> OH, </address> <pages> pp. 3-12, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Synchronous checkpointing alone does not guarantee that lost messages will be avoided nor does it necessarily provide a mechanism for dealing with delayed messages. Asynchronous checkpointing (e.g., <ref> [ 1, 28] </ref>) requires no interaction between processes during checkpointing. Processes periodically (and independently) take process checkpoints on stable storage. After a failure, processes communicate to choose a globally consistent set of local checkpoints. This set is used to restore the system to a consistent state. <p> Duplicate messages are handled directly and delayed messages are handled implicitly because of the coordination at the time of failure. Lost messages are not addressed. Their techniques have O (N 2 ) and O (N 3 ) message complexity. Bhargava and Lian's <ref> [ 1] </ref> recovery technique uses a two-phase rollback algorithm. It minimizes overhead during normal execution and is therefore appropriate for environments where failure is infrequent. In the worst case, processes may have to roll back to the beginning of execution.
Reference: [2] <author> D. Briatico, A. Ciuffoletti, L. Simoncini, </author> <title> "A Distributed Domino-Effect Free Recovery Algorithm," </title> <booktitle> 4th Symposium on Reliability in Distributed Software and Database Systems , Silver Springs, Maryland, </booktitle> <pages> pp. 207-215, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: All these techniques ([ 9], [10], and [11]) allow nondeterministic processes since they do not rely on message logging/replay. Silva and Silva [ 18] present a non-blocking synchronous checkpointing scheme which uses limited logging to eliminate lost messages. Techniques by Venkatesh et al. [ 26] and Briatico et al. <ref> [ 2] </ref> allow processes to take independent checkpoints but make processes take additional checkpoints as necessary (synchronously with message reception) to ensure that no orphan or lost messages exist in the global checkpoint set.
Reference: [3] <author> F. Cristian, F. Jahanian, </author> <title> "A Timestamp-Based Checkpointing Protocol for Long-Lived Distributed Computations," </title> <booktitle> Proc. of the 10th Symp. on Reliable Distributed Systems, Pisa, Italy, </booktitle> <pages> pp. 12-20, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: To minimize the amount of lost work due to a failure, the global checkpoint is advanced periodically. Processes collect globally consistent checkpoints either by explicit communication during checkpointing (e.g., [9, 10, 11]) or by scheduling checkpointing events based on synchronized processor clocks which simulate a 4 global clock (e.g., <ref> [3, 15, 24] </ref>). When the system is restored to a consistent state, the global state may contain lost messages. For example, in Figure 1, when the processor executing process k fails, the system is restored to a consistent state corresponding to (C1, C1', C1''). <p> When a process fails and recovers, it utilizes the antecedence graph and communicates with other processes in order to regenerate a consistent state. The recovery method is complex, but non-failed processes need not rollback. Ramanathan and Shin [ 15], Tong et al. [ 24], and Cristian and Jahanian <ref> [3] </ref> discuss recovery using synchronized physical clocks.
Reference: [4] <author> E. N. Elnozahy, W. Zwaenpoel, "Manetho: </author> <title> Transparent Rollback-Recovery with Low Overhead, Limited Rollback, and Fast Output Commit," </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. 41, no. 5, </volume> <pages> pp. 526-531, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Handling of non-orphan messages is delegated to the communication system. Johnson [ 7] introduces a technique which allows processes to commit states to stable storage as needed to ensure fast output to the outside world and which handles both deterministic and nondeterministic processes. Elnozahy and Zwaenpoel <ref> [ 4] </ref> discuss the Manetho rollback recovery protocol, which is based on antecedence graphs . When a process fails and recovers, it utilizes the antecedence graph and communicates with other processes in order to regenerate a consistent state. The recovery method is complex, but non-failed processes need not rollback.
Reference: [5] <author> C. J. Fidge, </author> <title> "Timestamps in Message-Passing Systems that Preserve the Partial Ordering," </title> <journal> Australian Computer Science Communications , vol. </journal> <volume> 10, no. 1, </volume> <pages> pp. 56-66, </pages> <month> February </month> <year> 1988. </year>
Reference: [6] <author> D. B. Johnson, W. Zwaenpoel, </author> <title> "Recovery in Distributed Systems Using Optimistic Message Logging and Checkpointing," </title> <journal> Journal of Algorithms , No. </journal> <volume> 11, </volume> <pages> pp. 462-491, </pages> <year> 1990. </year>
Reference-contexts: Venkatesan's [25] recovery techniques require processes to pessimistically log the sender ID of messages that are received. Upon failure, a process recovers by requesting that lost messages be resent. Non-failed processors need not roll back. Johnson and Zwaenpoel <ref> [ 6] </ref> present an optimistic message logging and checkpointing method for message-passing systems based on a central server which monitors the logging progress of 1 Our terminology differs from that of Strom and Yemini; they define lost message in a broad way that includes both orphans and the messages we define
Reference: [7] <author> D. B. Johnson, </author> <title> "Efficient Transparent Optimistic Rollback Recovery for Distributed Application Programs," </title> <booktitle> Proc. of the 12th Symp. on Reliable Distributed Systems , Princeton, NJ, </booktitle> <pages> pp. 86-95, </pages> <month> October </month> <year> 1993. </year> <month> 29 </month>
Reference-contexts: Handling of non-orphan messages is delegated to the communication system. Johnson <ref> [ 7] </ref> introduces a technique which allows processes to commit states to stable storage as needed to ensure fast output to the outside world and which handles both deterministic and nondeterministic processes. Elnozahy and Zwaenpoel [ 4] discuss the Manetho rollback recovery protocol, which is based on antecedence graphs .
Reference: [8] <author> T. Y. Juang, S. Venkatesan, </author> <title> "Crash Recovery With Little Overhead," </title> <booktitle> IEEE 11th Intl. Conf. on Distributed Computing Systems, </booktitle> <year> 1991. </year>
Reference-contexts: In the worst case, O (2 N ) process rollbacks may occur, though orphan, duplicate, and lost messages are handled 1 . Strom et al. [ 23] discuss enhancements to this work which potentially reduce logging overhead. Juang and Venkatesan <ref> [ 8] </ref> describe methods for recovering processes which attach very little (or no) additional information to each application message. Establishment of a consistent global state is accomplished via a coordinated effort at recovery time.
Reference: [9] <author> J. L. Kim, T. Park, </author> <title> "An Efficient Protocol for Checkpointing Recovery in Distributed Systems," </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> vol. 4, no. 8, </volume> <pages> pp. 955-960, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: To minimize the amount of lost work due to a failure, the global checkpoint is advanced periodically. Processes collect globally consistent checkpoints either by explicit communication during checkpointing (e.g., <ref> [9, 10, 11] </ref>) or by scheduling checkpointing events based on synchronized processor clocks which simulate a 4 global clock (e.g., [3, 15, 24]). When the system is restored to a consistent state, the global state may contain lost messages. <p> Koo and Toueg's [ 10] recovery technique uses synchronous checkpointing. They assume that lost messages are handled by the communication system, while our technique processes messages correctly without this assumption. The synchronous checkpointing technique of Kim and Park <ref> [ 9] </ref> has a more relaxed coordination phase, resulting in less runtime overhead than that in 25 [10]. Leu and Bhargava [ 11] introduce a synchronous checkpointing technique which permits simultaneous execution by multiple processes and does not require FIFO channels. Non-orphan message-handling is not addressed directly.
Reference: [10] <author> R. Koo, S. Toueg, </author> <title> "Checkpointing and Rollback Recovery for Distributed Systems," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. SE-13, no. 1, </volume> <pages> pp. 23-31, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: To minimize the amount of lost work due to a failure, the global checkpoint is advanced periodically. Processes collect globally consistent checkpoints either by explicit communication during checkpointing (e.g., <ref> [9, 10, 11] </ref>) or by scheduling checkpointing events based on synchronized processor clocks which simulate a 4 global clock (e.g., [3, 15, 24]). When the system is restored to a consistent state, the global state may contain lost messages. <p> Introducing message logging to minimize the domino effect does not guarantee proper message handling unless additional mechanisms are used. Many existing recovery techniques address only consistent state restoration or address message-handling issues casually. For example, Koo and Toueg <ref> [ 10] </ref> delegate responsibility for handling lost messages to the communication system. In some cases, this assumes far too much about the capabilities of the underlying communication system. To simplify message handling, we classify the message types which arise during failure and recovery. <p> This allows much faster recovery, especially if the number of processors involved is large. In addition, our message-handling techniques are more comprehensive (in particular, lost messages of the type depicted in Figure 9 are problematic for the technique described in [14]). Koo and Toueg's <ref> [ 10] </ref> recovery technique uses synchronous checkpointing. They assume that lost messages are handled by the communication system, while our technique processes messages correctly without this assumption. <p> They assume that lost messages are handled by the communication system, while our technique processes messages correctly without this assumption. The synchronous checkpointing technique of Kim and Park [ 9] has a more relaxed coordination phase, resulting in less runtime overhead than that in 25 <ref> [10] </ref>. Leu and Bhargava [ 11] introduce a synchronous checkpointing technique which permits simultaneous execution by multiple processes and does not require FIFO channels. Non-orphan message-handling is not addressed directly. All these techniques ([ 9], [10], and [11]) allow nondeterministic processes since they do not rely on message logging/replay. <p> has a more relaxed coordination phase, resulting in less runtime overhead than that in 25 <ref> [10] </ref>. Leu and Bhargava [ 11] introduce a synchronous checkpointing technique which permits simultaneous execution by multiple processes and does not require FIFO channels. Non-orphan message-handling is not addressed directly. All these techniques ([ 9], [10], and [11]) allow nondeterministic processes since they do not rely on message logging/replay. Silva and Silva [ 18] present a non-blocking synchronous checkpointing scheme which uses limited logging to eliminate lost messages.
Reference: [11] <author> P-J. Leu, B. Bhargava, </author> <title> "Concurrent Robust Checkpointing and Recovery in Distributed Systems," </title> <booktitle> Proc. of the 4th Intl. Symp. on Data Engineering, </booktitle> <address> Los Angeles, CA, </address> <pages> pp. 154-163, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: To minimize the amount of lost work due to a failure, the global checkpoint is advanced periodically. Processes collect globally consistent checkpoints either by explicit communication during checkpointing (e.g., <ref> [9, 10, 11] </ref>) or by scheduling checkpointing events based on synchronized processor clocks which simulate a 4 global clock (e.g., [3, 15, 24]). When the system is restored to a consistent state, the global state may contain lost messages. <p> They assume that lost messages are handled by the communication system, while our technique processes messages correctly without this assumption. The synchronous checkpointing technique of Kim and Park [ 9] has a more relaxed coordination phase, resulting in less runtime overhead than that in 25 [10]. Leu and Bhargava <ref> [ 11] </ref> introduce a synchronous checkpointing technique which permits simultaneous execution by multiple processes and does not require FIFO channels. Non-orphan message-handling is not addressed directly. All these techniques ([ 9], [10], and [11]) allow nondeterministic processes since they do not rely on message logging/replay. <p> Leu and Bhargava [ 11] introduce a synchronous checkpointing technique which permits simultaneous execution by multiple processes and does not require FIFO channels. Non-orphan message-handling is not addressed directly. All these techniques ([ 9], [10], and <ref> [11] </ref>) allow nondeterministic processes since they do not rely on message logging/replay. Silva and Silva [ 18] present a non-blocking synchronous checkpointing scheme which uses limited logging to eliminate lost messages.
Reference: [12] <author> K. Li, J. F. Naughton, J. S. Plank, </author> <title> "Checkpointing Multicomputer Applications," </title> <booktitle> Proc. of the 10th Symp. on Reliable Distributed Systems, Pisa, Italy, </booktitle> <pages> pp. 2-11, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Wang and Fuchs [ 29] introduce a lazy checkpointing protocol which potentially allows some inconsistent checkpoint sets (in order to reduce the overhead associated with consistent checkpointing), but avoids the domino effect. Li, Naughton, and Plank <ref> [ 12] </ref> introduce a synchronous checkpointing technique for multicomputers, based on a central checkpoint coordinator, which does address message-handling issues. Their technique is not applicable to distributed systems in general since it relies on properties of multicomputer message routing, in particular, a deterministic, deadlock-free routing function.
Reference: [13] <author> F. Mattern, </author> <title> "Virtual Time and Global States of Distributed Systems," </title> <booktitle> Parallel and Distributed Algorithms , pp. </booktitle> <pages> 215-226, </pages> <publisher> North-Holland, </publisher> <year> 1989, </year>
Reference: [14] <author> S. L. Peterson, P. Kearns, </author> <title> "Rollback Based on Vector Time," </title> <booktitle> Proc. of the 12th Symp. on Reliable Distributed Systems , Princeton, NJ, </booktitle> <pages> pp. 68-77, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Note that execution forward from the checkpoint by j will not cause retransmission of m . If process j examines the timestamp of the recovery initiation message from i which initiated j 's rollback <ref> [14] </ref>, j can detect that message m needs to be resent. <p> The techniques are particularly effective when communication is localized. 8 Related Work Only Peterson and Kearns <ref> [ 14] </ref> have previously used vector time to coordinate process rollback after a failure. Our technique uses broadcast rather than token-passing on a ring of processors to allow processes to perform concurrent rollback/recovery in response to a failure. <p> This allows much faster recovery, especially if the number of processors involved is large. In addition, our message-handling techniques are more comprehensive (in particular, lost messages of the type depicted in Figure 9 are problematic for the technique described in <ref> [14] </ref>). Koo and Toueg's [ 10] recovery technique uses synchronous checkpointing. They assume that lost messages are handled by the communication system, while our technique processes messages correctly without this assumption.
Reference: [15] <author> P. Ramanathan, K. G. Shin, </author> <title> "Use of Common Time Base for Checkpointing and Rollback Recovery in a Distributed System," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> vol. 19, no. 6, </volume> <pages> pp. 571-583, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: To minimize the amount of lost work due to a failure, the global checkpoint is advanced periodically. Processes collect globally consistent checkpoints either by explicit communication during checkpointing (e.g., [9, 10, 11]) or by scheduling checkpointing events based on synchronized processor clocks which simulate a 4 global clock (e.g., <ref> [3, 15, 24] </ref>). When the system is restored to a consistent state, the global state may contain lost messages. For example, in Figure 1, when the processor executing process k fails, the system is restored to a consistent state corresponding to (C1, C1', C1''). <p> When a process fails and recovers, it utilizes the antecedence graph and communicates with other processes in order to regenerate a consistent state. The recovery method is complex, but non-failed processes need not rollback. Ramanathan and Shin <ref> [ 15] </ref>, Tong et al. [ 24], and Cristian and Jahanian [3] discuss recovery using synchronized physical clocks.
Reference: [16] <author> G. Richard, M. Singhal, </author> <title> "Using Logging and Asynchronous Checkpointing to Implement Recoverable Distributed Shared Memory," </title> <booktitle> Proc. of the 12th Symp. on Reliable Distributed Systems, </booktitle> <address> Princeton, NJ, </address> <pages> pp. 58-67, </pages> <month> October </month> <year> 1993. </year>
Reference: [17] <author> R. D. Schlichting, F. B. Schneider, </author> <title> "Fail-stop Processors: An Approach to Designing Faulttolerant Computing Systems," </title> <journal> ACM Trans. on Computer Systems , vol. </journal> <volume> 1, no. 3, </volume> <pages> pp. 222-238, </pages> <month> August </month> <year> 1982. </year>
Reference-contexts: The processors share neither a physical memory nor a common (global) clock. Processors communicate solely by exchanging messages. The network is assumed to provide fault-free, FIFO communication with finite message delay between the processors. Processors are assumed to exhibit failstop <ref> [ 17] </ref> failure semantics; that is, they stop functioning when they fail without generating spurious or incorrect messages. A checkpoint/restore mechanism, capable of saving and restoring the state of processes executing on the processors, is assumed to exist. Timeouts or some alternative mechanism is used to detect processor failures.
Reference: [18] <author> L. Silva, J. Silva, </author> <title> "Global Checkpointing for Distributed Programs," </title> <booktitle> Proc. 11th Symp. on Reliable Distributed Systems , pp. </booktitle> <pages> 155-162, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Non-orphan message-handling is not addressed directly. All these techniques ([ 9], [10], and [11]) allow nondeterministic processes since they do not rely on message logging/replay. Silva and Silva <ref> [ 18] </ref> present a non-blocking synchronous checkpointing scheme which uses limited logging to eliminate lost messages.
Reference: [19] <author> M. Singhal, A. Kshemkalyani, </author> <title> "An Efficient Implementation of Vector Clocks," </title> <journal> Information Processing Letters , pp. </journal> <pages> 47-52, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Singhal and Kshem- kalyani present techniques in <ref> [ 19] </ref> which can significantly reduce the overhead associated with vector time maintenance by transferring only portions of the vector timestamp which have changed since the last communication.
Reference: [20] <author> A. P. Sistla, J. L. Welch, </author> <title> "Efficient Distributed Recovery Using Message Logging," </title> <booktitle> Proc. of the 8th Annual ACM Symp. on Principles of Distributed Computing , August 1989. </booktitle>
Reference-contexts: No other process need roll back. The drawback of pessimistic logging is the potential negative effect on performance during normal system execution, since messages must be forced to stable storage as they are received. Optimistic message logging (e.g., <ref> [ 20, 22] </ref>) takes a more aggressive approach to the problem. As messages are received, they are logged to volatile storage and are periodically flushed to a stable log. <p> Duplicates can be suppressed at the receiving end by having each process track the highest state number seen directly from every other process in the system. To accomplish this, each process i maintains a vector DVi which tracks i 's direct dependency on 19 other processes <ref> [20] </ref>. DVi is initially set to all zeros. Each time process i receives a message m from a process j , DVi [j] is set to the maximum of DVi [j] and m.TS [j]. <p> Wang and Fuchs [ 28] present an unsynchronized checkpointing technique with an aggressive checkpoint reclamation algorithm. Their technique is susceptible to the domino effect since checkpoints are not coordinated, but nondeterministic processes are permitted. 26 Sistla and Welch's <ref> [ 20] </ref> recovery algorithms initiate a recovery phase after processor failure which involves all processes exchanging information about the extent of their respective logged states. Processes then rollback and replay messages to achieve the maximum possible globally consistent state.
Reference: [21] <author> S. H. Son, A. K. Agrawala, </author> <title> "Distributed Checkpointing for Globally Consistent States of Databases," </title> <journal> IEEE Trans. on Software Engineering , vol. </journal> <volume> 15, no. 10, </volume> <month> October </month> <year> 1989. </year>
Reference: [22] <author> R. E. Strom, S. Yemini, </author> <title> "Optimistic Recovery in Distributed Systems," </title> <journal> ACM Trans. on Computer Systems , vol. </journal> <volume> 3, no. 3, </volume> <pages> pp. 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: No other process need roll back. The drawback of pessimistic logging is the potential negative effect on performance during normal system execution, since messages must be forced to stable storage as they are received. Optimistic message logging (e.g., <ref> [ 20, 22] </ref>) takes a more aggressive approach to the problem. As messages are received, they are logged to volatile storage and are periodically flushed to a stable log. <p> Intelligent log processing allows messages lost by processes other than the failed process to be recovered without retransmission. For clarity, we assume that each processor executes a single process. Processor failure and process failure are, therefore, synonymous in what follows. Making each processor a recovery unit <ref> [ 22] </ref> allows this restriction to be removed easily. <p> Bhargava and Lian's [ 1] recovery technique uses a two-phase rollback algorithm. It minimizes overhead during normal execution and is therefore appropriate for environments where failure is infrequent. In the worst case, processes may have to roll back to the beginning of execution. Strom and Yemini's <ref> [22] </ref> technique is based on optimistic message logging and tolerates failure of an arbitrary number of processors. In the worst case, O (2 N ) process rollbacks may occur, though orphan, duplicate, and lost messages are handled 1 .
Reference: [23] <author> R. E. Strom, D. Bacon, S. Yemini, </author> <title> "Volatile Logging in n-Fault-Tolerant Distributed Systems," </title> <booktitle> Proc. IEEE Int'l. Symposium on Fault Tolerant Computing, </booktitle> <pages> pp. 44-49, </pages> <year> 1988. </year>
Reference-contexts: Strom and Yemini's [22] technique is based on optimistic message logging and tolerates failure of an arbitrary number of processors. In the worst case, O (2 N ) process rollbacks may occur, though orphan, duplicate, and lost messages are handled 1 . Strom et al. <ref> [ 23] </ref> discuss enhancements to this work which potentially reduce logging overhead. Juang and Venkatesan [ 8] describe methods for recovering processes which attach very little (or no) additional information to each application message. Establishment of a consistent global state is accomplished via a coordinated effort at recovery time.
Reference: [24] <author> Z. Tong, R. Kain, W. Tsai, </author> <title> "Rollback Recovery in Distributed Systems Using Loosely Synchronized Clocks," </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> vol. 3, no. 2, </volume> <pages> pp. 246-251, </pages> <month> March </month> <year> 1992. </year> <month> 30 </month>
Reference-contexts: To minimize the amount of lost work due to a failure, the global checkpoint is advanced periodically. Processes collect globally consistent checkpoints either by explicit communication during checkpointing (e.g., [9, 10, 11]) or by scheduling checkpointing events based on synchronized processor clocks which simulate a 4 global clock (e.g., <ref> [3, 15, 24] </ref>). When the system is restored to a consistent state, the global state may contain lost messages. For example, in Figure 1, when the processor executing process k fails, the system is restored to a consistent state corresponding to (C1, C1', C1''). <p> When a process fails and recovers, it utilizes the antecedence graph and communicates with other processes in order to regenerate a consistent state. The recovery method is complex, but non-failed processes need not rollback. Ramanathan and Shin [ 15], Tong et al. <ref> [ 24] </ref>, and Cristian and Jahanian [3] discuss recovery using synchronized physical clocks.
Reference: [25] <author> S. Venkatesan, </author> <title> "Optimistic Crash Recovery Without Rolling Back Non-Faulty Processors," </title> <type> Tech Report IS-92-813-A, </type> <institution> University of Texas at Dallas, </institution> <year> 1992. </year>
Reference-contexts: Juang and Venkatesan [ 8] describe methods for recovering processes which attach very little (or no) additional information to each application message. Establishment of a consistent global state is accomplished via a coordinated effort at recovery time. Venkatesan's <ref> [25] </ref> recovery techniques require processes to pessimistically log the sender ID of messages that are received. Upon failure, a process recovers by requesting that lost messages be resent. Non-failed processors need not roll back.
Reference: [26] <author> K. Venkatesh, T. Radhakrishnan, H. F. Li, </author> <title> "Optimal Checkpointing and Local Recording for Domino-Free Rollback Recovery," </title> <journal> Information Processing Letters, </journal> <pages> pp. 295-303, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Non-orphan message-handling is not addressed directly. All these techniques ([ 9], [10], and [11]) allow nondeterministic processes since they do not rely on message logging/replay. Silva and Silva [ 18] present a non-blocking synchronous checkpointing scheme which uses limited logging to eliminate lost messages. Techniques by Venkatesh et al. <ref> [ 26] </ref> and Briatico et al. [ 2] allow processes to take independent checkpoints but make processes take additional checkpoints as necessary (synchronously with message reception) to ensure that no orphan or lost messages exist in the global checkpoint set.
Reference: [27] <author> Z. Wojcik, B. Wojcik, </author> <title> "Fault Tolerant Distributed Computing Using Atomic Send-Receive Checkpoints," </title> <booktitle> Proc. of the 2nd IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pp. 215-222, </pages> <year> 1990. </year>
Reference-contexts: Their technique is not applicable to distributed systems in general since it relies on properties of multicomputer message routing, in particular, a deterministic, deadlock-free routing function. This allows delayed messages to be flushed more quickly than in general purpose, fully-connected networks of distributed processors. Wojcik and Wojcik's <ref> [ 27] </ref> recovery technique is synchronous, but avoids blocking during checkpointing by having the sender and receiver balance the messages which have been sent and received. Wang and Fuchs [ 28] present an unsynchronized checkpointing technique with an aggressive checkpoint reclamation algorithm.
Reference: [28] <author> Y-M. Wang, W. K. Fuchs, </author> <title> "Optimistic Message Logging for Independent Checkpointing in Message-Passing Systems," </title> <booktitle> Proc. of the 11th Symp. on Reliable Distributed Systems, </booktitle> <pages> pp. 147-154, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Synchronous checkpointing alone does not guarantee that lost messages will be avoided nor does it necessarily provide a mechanism for dealing with delayed messages. Asynchronous checkpointing (e.g., <ref> [ 1, 28] </ref>) requires no interaction between processes during checkpointing. Processes periodically (and independently) take process checkpoints on stable storage. After a failure, processes communicate to choose a globally consistent set of local checkpoints. This set is used to restore the system to a consistent state. <p> Wojcik and Wojcik's [ 27] recovery technique is synchronous, but avoids blocking during checkpointing by having the sender and receiver balance the messages which have been sent and received. Wang and Fuchs <ref> [ 28] </ref> present an unsynchronized checkpointing technique with an aggressive checkpoint reclamation algorithm.
Reference: [29] <author> Y-M. Wang, W. K. Fuchs, </author> <title> "Lazy Checkpoint Coordination for Bounding Rollback Propagation," </title> <booktitle> Proc. of the 12th Symp. on Reliable Distributed Systems , Princeton, NJ, </booktitle> <pages> pp. 78-85, </pages> <month> October </month> <year> 1993. </year> <month> 31 </month>
Reference-contexts: Techniques by Venkatesh et al. [ 26] and Briatico et al. [ 2] allow processes to take independent checkpoints but make processes take additional checkpoints as necessary (synchronously with message reception) to ensure that no orphan or lost messages exist in the global checkpoint set. Wang and Fuchs <ref> [ 29] </ref> introduce a lazy checkpointing protocol which potentially allows some inconsistent checkpoint sets (in order to reduce the overhead associated with consistent checkpointing), but avoids the domino effect.
References-found: 29

