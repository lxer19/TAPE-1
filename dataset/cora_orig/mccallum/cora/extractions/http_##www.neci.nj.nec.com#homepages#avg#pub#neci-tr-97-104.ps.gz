URL: http://www.neci.nj.nec.com/homepages/avg/pub/neci-tr-97-104.ps.gz
Refering-URL: http://www.neci.nj.nec.com/homepages/avg/webpub/node5.html
Root-URL: 
Email: avg@research.nj.nec.com  csilvers@theory.stanford.edu  
Title: Computational Evaluation of Hot Queues  
Author: Andrew V. Goldberg Craig Silverstein 
Note: Supported by the Department of Defense, with partial support from NSF Award CCR-9357849, with matching funds from IBM, Schlumberger Foundation, Shell Foundation, and Xerox Corporation.  
Address: 4 Independence Way Princeton, NJ 08540  Stanford, CA 94305  
Affiliation: NEC Research Institute  Computer Science Department Stanford University  
Abstract: Technical report #97-104 NEC Research Institute, Inc. June 1997 Abstract The heap-on-top (hot) priority queue data structure [6] improves on the best known times for Dijkstra's shortest path algorithm. It also has very good practical performance and is robust over a wide range of graph types. The heart of Dijkstra's algorithm is a monotone priority queue, that is, a priority queue where no element on the queue ever becomes smaller than the most recently extracted element. In this paper, we show that the hot queue implementation of monotone priority queues is competitive in a more general context. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. K. Ahuja, K. Mehlhorn, J. B. Orlin, and R. E. Tarjan. </author> <title> Faster Algorithms for the Shortest Path Problem. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 37(2) </volume> <pages> 213-223, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in [3, 10, 12]. Alternative implementations of priority queues use buckets (e.g. <ref> [1, 5, 7, 8] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [2] for a related data structure. Heaps are particularly efficient when the number of elements on the heap is small.
Reference: [2] <author> P. Van Emde Boas, R. Kaas, and E. Zijlstra. </author> <title> Design and Implementation of an Efficient Priority Queue. </title> <journal> Math. Systems Theory, </journal> <volume> 10 </volume> <pages> 99-127, </pages> <year> 1977. </year>
Reference-contexts: The fastest implementations of heaps are described in [3, 10, 12]. Alternative implementations of priority queues use buckets (e.g. [1, 5, 7, 8]). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See <ref> [2] </ref> for a related data structure. Heaps are particularly efficient when the number of elements on the heap is small. Bucket-based priority queues are particularly efficient when the maximum event duration C is small.
Reference: [3] <author> G. S. Brodal. </author> <title> Worst-Case Efficient Priority Queues. </title> <booktitle> In Proc. 7th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 52-58, </pages> <year> 1996. </year>
Reference-contexts: In this paper we deal with monotone priority queues. Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in <ref> [3, 10, 12] </ref>. Alternative implementations of priority queues use buckets (e.g. [1, 5, 7, 8]). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [2] for a related data structure.
Reference: [4] <author> R. Brown. </author> <title> Calandar Queues: A Fast O(1) Priority Queue Implementation for the Simulation Event Set Problem. </title> <journal> Comm. ACM, </journal> <volume> 31 </volume> <pages> 1220-1227, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction A priority queue is a data structure that maintains a set of elements and supports operations insert, decrease-key, and extract-min. Priority queues are fundamental data structures with many applications. Typical applications include graph algorithms (e.g. [10]) and event simulation (e.g. <ref> [4] </ref>). An important subclass of priority queues used in applications such as event simulation and in Dijkstra's shortest path algorithm [9] is the class of monotone priority queues.
Reference: [5] <author> B. V. Cherkassky, A. V. Goldberg, and T. Radzik. </author> <title> Shortest Paths Algorithms: Theory and Experimental Evaluation. </title> <journal> Math. Prog., </journal> <volume> 73 </volume> <pages> 129-174, </pages> <year> 1996. </year> <title> Table 5: The performance on monotone simulation as the number of decrease-key operations grows, with a large queue size. We show results for large C since D must be less than C. The demo algorithm, which is heap-based, could not support the large value of K, so no results are shown for it. </title>
Reference-contexts: Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in [3, 10, 12]. Alternative implementations of priority queues use buckets (e.g. <ref> [1, 5, 7, 8] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [2] for a related data structure. Heaps are particularly efficient when the number of elements on the heap is small.
Reference: [6] <author> B. V. Cherkassky, A. V. Goldberg, and C. Silverstein. Buckets, </author> <title> Heaps, Lists, and Monotone Priority Queues. </title> <type> Technical Report 96-070, </type> <institution> NEC Research Institute, Princeton, NJ, </institution> <year> 1996. </year> <note> To appear in SODA 97. </note>
Reference-contexts: Furthermore, some of the work done in bucket-based implementations can be amortized over elements in the buckets, yielding better bounds if the number of elements is large. In this sense, heaps and buckets complement each other. Heap-on-top queues (hot queues) <ref> [6] </ref> combine the multi-level bucket data structure of Denardo and Fox [7] and a heap. These queues use the heap instead of buckets when buckets would be sparsely occupied. The resulting implementation takes advantage of the best performance features of both data structures. <p> In particular, implementations of Dijkstra's shortest path algorithm produce balanced operation sequences. 3 Multi-Level Buckets In this section we describe the k-level bucket data structure of Denardo and Fox [7]. Our description follows that of <ref> [6] </ref>. Consider a bucket structure B that contains k levels of buckets, where k is a positive integer. Except for the top level, a level contains an array of buckets. The top level contains infinitely many buckets. <p> For k = 2, the bound is O ( C). The best bound of O log log C is obtained for k = d log C log log C e. Remark. The k-level bucket data structure uses fi (kC 1=k ) space. 4 Hot Queues A hot queue <ref> [6] </ref> uses a heap H and a multi-level bucket structure B. Intuitively, the hot queue data structure works like the multi-level bucket data structure, except we do not expand a bucket containing less than t elements, where t is a parameter set to optimize performance. <p> Return u. Correctness of the hot queue operations follows from the correctness of the multi-level bucket operations, Lemma 3.1, and the observation that if u is in H and v is in B but not in H, then (u) &lt; (v). The following theorem is proved in <ref> [6] </ref>. 6 Theorem 4.1 Let I (N ), D (N ), F (N ), and X (N ) be the time bounds for heap insert, decrease-key, find-min, and extract-min operations. <p> In our figures, we refer to the implementation as follows: * demo: the demo implementation, * heap: our implementation of 4-heaps, * bck2: our implementation of 2-level buckets, * hotq2: our implementation of 2-level hot queues. 7 Our implementation of multi-level buckets and hot queues is described in detail in <ref> [6] </ref>. That paper also indicats which values of the tunable parameters of the hot queue implementation worked best for the Dijkstra tests. Surprisingly, the same parameter values proved best for the additional tests of the current study. <p> The heap algorithm starts to perform slightly better than the other two as n | and C | grow. The difference, however, is small. 6.4 Dijkstra-Based Tests For completeness, we also show the Dijkstra results, in Figures 7, 8, and 9, without comment. See <ref> [6] </ref> for a detailed discussion of these results. 11 Table 3: The performance on event simulation as the queue size grows. The heap-based demo algorithm cannot support large values of K since the heap size is directly proportional to K. 7 Conclusion In [6], hot queues have been shown to be <p> See <ref> [6] </ref> for a detailed discussion of these results. 11 Table 3: The performance on event simulation as the queue size grows. The heap-based demo algorithm cannot support large values of K since the heap size is directly proportional to K. 7 Conclusion In [6], hot queues have been shown to be fast and robust when used in Dijkstra's algorithm. In the current paper, we have seen that hot queues are equally effective for several other applications that use a priority queue, such as sorting and event simulation.
Reference: [7] <author> E. V. Denardo and B. L. Fox. </author> <title> Shortest-Route Methods: 1. Reaching, Pruning, </title> <journal> and Buckets. Oper. Res., </journal> <volume> 27 </volume> <pages> 161-186, </pages> <year> 1979. </year>
Reference-contexts: Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in [3, 10, 12]. Alternative implementations of priority queues use buckets (e.g. <ref> [1, 5, 7, 8] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [2] for a related data structure. Heaps are particularly efficient when the number of elements on the heap is small. <p> In this sense, heaps and buckets complement each other. Heap-on-top queues (hot queues) [6] combine the multi-level bucket data structure of Denardo and Fox <ref> [7] </ref> and a heap. These queues use the heap instead of buckets when buckets would be sparsely occupied. The resulting implementation takes advantage of the best performance features of both data structures. <p> In particular, implementations of Dijkstra's shortest path algorithm produce balanced operation sequences. 3 Multi-Level Buckets In this section we describe the k-level bucket data structure of Denardo and Fox <ref> [7] </ref>. Our description follows that of [6]. Consider a bucket structure B that contains k levels of buckets, where k is a positive integer. Except for the top level, a level contains an array of buckets. The top level contains infinitely many buckets.
Reference: [8] <author> R. B. Dial. </author> <title> Algorithm 360: Shortest Path Forest with Topological Ordering. </title> <journal> Comm. ACM, </journal> <volume> 12 </volume> <pages> 632-633, </pages> <year> 1969. </year>
Reference-contexts: Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in [3, 10, 12]. Alternative implementations of priority queues use buckets (e.g. <ref> [1, 5, 7, 8] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [2] for a related data structure. Heaps are particularly efficient when the number of elements on the heap is small.
Reference: [9] <author> E. W. Dijkstra. </author> <title> A Note on Two Problems in Connexion with Graphs. </title> <journal> Numer. Math., </journal> <volume> 1 </volume> <pages> 269-271, </pages> <year> 1959. </year>
Reference-contexts: Priority queues are fundamental data structures with many applications. Typical applications include graph algorithms (e.g. [10]) and event simulation (e.g. [4]). An important subclass of priority queues used in applications such as event simulation and in Dijkstra's shortest path algorithm <ref> [9] </ref> is the class of monotone priority queues. Intuitively, a priority queue is monotone if at any time keys of elements on the queue are at least as big as the key of the most recent element extracted from the queue. In this paper we deal with monotone priority queues.
Reference: [10] <author> M. L. Fredman and R. E. Tarjan. </author> <title> Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 34 </volume> <pages> 596-615, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction A priority queue is a data structure that maintains a set of elements and supports operations insert, decrease-key, and extract-min. Priority queues are fundamental data structures with many applications. Typical applications include graph algorithms (e.g. <ref> [10] </ref>) and event simulation (e.g. [4]). An important subclass of priority queues used in applications such as event simulation and in Dijkstra's shortest path algorithm [9] is the class of monotone priority queues. <p> In this paper we deal with monotone priority queues. Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in <ref> [3, 10, 12] </ref>. Alternative implementations of priority queues use buckets (e.g. [1, 5, 7, 8]). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [2] for a related data structure.
Reference: [11] <author> C. McGeoch. </author> <title> Towards an Experimental Method for Algorithm Simulation. </title> <journal> INFORMS J. Comp., </journal> <volume> 8 </volume> <pages> 1-15, </pages> <year> 1996. </year> <title> 14 Table 6: Sorting tests. The sort keys are integers in the range 1 to n, where n is the number of elements being sorted. </title>
Reference-contexts: This allows us to use word shift operations when computing bucket array indices. Our study compares six implementations of monotone priority queues: k-ary heaps, with k=4; 2- and 3-level buckets; and 2- and 3-level hot queues; and (for calibration purposes) a simple heap-based demo algorithm by Cathy McGeoch <ref> [11] </ref>. Some of these have parameters to tune, and the results we show are for the best parameter values we tested. We do not show results for 3-level algorithms because the results never significantly differ from those of the 2-level implementations.
Reference: [12] <author> M. </author> <title> Thorup. On RAM Priority Queues. </title> <booktitle> In Proc. 7th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 59-67, </pages> <year> 1996. </year> <title> 15 Table 7: The performance for Dijkstra's algorithms on long grids. Table 8: The performance for Dijkstra's algorithms on random graphs. 16 Table 9: The performance for Dijkstra's algorithms on graphs with many decrease-key operations. </title> <type> 17 </type>
Reference-contexts: In this paper we deal with monotone priority queues. Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in <ref> [3, 10, 12] </ref>. Alternative implementations of priority queues use buckets (e.g. [1, 5, 7, 8]). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [2] for a related data structure.
References-found: 12

