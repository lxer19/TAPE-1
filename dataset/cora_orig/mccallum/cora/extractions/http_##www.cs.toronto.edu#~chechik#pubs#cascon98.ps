URL: http://www.cs.toronto.edu/~chechik/pubs/cascon98.ps
Refering-URL: http://www.cs.toronto.edu/~chechik/projects.html
Root-URL: http://www.cs.toronto.edu
Title: SC(R) 3 Towards Usability of Formal Methods  
Author: Marsha Chechik 
Affiliation: University of Toronto Department of Computer Science  
Abstract: This paper gives an overview of SC(R) 3 a toolset designed to increase the usability of formal methods for software development. Formal requirements are specified in SC(R) 3 in an easy to use and review format, and then used in checking requirements for correctness and in verifying consistency between annotated code and requirements. In this paper we discuss motivations behind this work, describe several tools which are part of SC(R) 3 , and illustrate their operation on an example of a Cruise Control system.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ruth Abraham. </author> <title> "Evaluating Generalized Tabular Expressions in Software Documentation". </title> <type> CRL Technical Report 267, </type> <institution> McMaster University, </institution> <month> February </month> <year> 1997. </year>
Reference-contexts: SCR* performs checks to ensure that the tables are complete and consistent. Tool-building is not limited to the SCR community. For example, David Par-nas and his colleagues are working on methods and tools to document programs using tables <ref> [22, 20, 23, 1] </ref>, and a group at Odyssey Research Associates are developing Tablewise a tool to reason about decision tables [14]. However, none of these tools are aimed at using tabular requirements once they have been created.
Reference: [2] <author> Joanne M. Atlee and Michael A. Buck-ley. </author> <title> "A Logic-Model Semantics for SCR Software Requirements". </title> <booktitle> In Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: The verification effort yielded a number of errors, most of which could be traced back to the original specification [15]. We found no errors in the mode transition table because this table has been analyzed earlier by Atlee and her colleagues <ref> [2] </ref> 3 .
Reference: [3] <author> M. Chechik. </author> <title> "Automatic Analysis of Consistency between Requirements and Designs". </title> <type> PhD thesis, </type> <institution> University of Mary-land, College Park, Maryland, </institution> <month> December </month> <year> 1996. </year>
Reference-contexts: However, this code will likely require some hand-tuning, e.g., because it is too slow, or might even have to be rewritten from scratch. Mathematically precise software requirements, like SCR, can be used to reason about correctness of implementations. SC (R) 3 incorporates a tool called cord <ref> [3] </ref> that takes specially annotated source code and an SCR specification and checks for the correspondence between them. cord uses data-flow analysis instead of exhaustive state enumeration to enable effective verification in low-degree polynomial time. <p> These changes involve local (rather than invariant) information and therefore are relatively easy to specify. The annotations, described in detail in <ref> [3] </ref>, are of three types. Initial annotations indicate the starting states of the program. They unconditionally assign values to variables and correspond to initialization information specified in the requirements. <p> The entire process of code verification with SC (R) 3 is depicted in Figure 5. Here, tools (sac and cord) and artifacts are represented by ellipses and boxes, respectively. 4.2 Analysis Analysis done by cord is described in detail elsewhere <ref> [3] </ref>. In this section, we give a quick summary of this process. cord checks that transitions implemented in the code are exactly the same as those specified in the requirements.
Reference: [4] <author> M. Chechik and M. Cwirko-Godyski. </author> <title> "Cruise Control System: A Case-Study in 14 Using SCR in Development and Verifica--tion of Event-Driven Systems". </title> <type> Technical report, </type> <institution> University of Toronto, </institution> <month> June </month> <year> 1998. </year> <note> (in preparation). </note>
Reference-contexts: Thus, Property 1 is translated into CTL as AG (CC = Cruise ! AX ((PIgnition & Ignition) ! CC = Off)) We extended gensmv to translate condition tables of controlled variables into the SMV modeling language <ref> [4] </ref>. This way, we are able to reason about the entire SC (R) 3 specification. 3.2 Counter-examples During verification of CTL properties, SMV explores all possible behaviors of the model and either declares that the property holds or gives a counter-example.
Reference: [5] <author> M. </author> <title> Chechik and V.S. Sudha. "Checking Consistency between Source Code and Annotations". </title> <type> CSRG Technical Report 373, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1998. </year>
Reference-contexts: That is, "the analysis is as good as the annotations". Although annotations are easy to insert, we found ourselves frequently making mistakes, and also noticed that code maintenance greatly reduces the correspondence between the code and the annotations. Thus, the SC (R) 3 toolset includes a tool called sac <ref> [5] </ref> designed to check that the code is annotated correctly. To use the tool, the programmer creates a list of correspondences between variables in the requirements and the code.
Reference: [6] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. "Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: The language for specifying these properties in SC (R) 3 is an extension of CTL (Computational Tree Logic). CTL is a branching-time temporal logic <ref> [6] </ref> which allows quantification over some or all possible futures. CTL formulae are defined recursively: all propositional formulae are 5 in CTL; if f and g are in CTL, so are f (nega-tion), f & g (conjunction), and f j g (disjunction). <p> We chose to use model-checking <ref> [6] </ref> to perform these checks. A symbolic model-checker SMV developed by McMillan [17], uses state exploration to check if temporal properties hold in a finite-state model. However, we first needed to translate the behavioral specifications of SCR into a format accepted by SMV, which is done using a tool gensmv.
Reference: [7] <author> E.M. Clarke and J. Wing. </author> <title> "Formal Methods: State of the Art and Future Directions". </title> <journal> ACM Computing Surveys, </journal> <volume> 28(4) </volume> <pages> 626-643, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: Although case-studies (e.g. <ref> [7] </ref>) have shown applicability and effectiveness of formal methods for various industrial-size systems, this perception still remains. Currently, most research in formal methods concentrates on improving modeling languages and tool support to be able to specify and verify larger and more complex problems (e.g. [13, 16]).
Reference: [8] <author> Patrick Cousot and Radhia Cousot. </author> <title> "Static Determination of Dynamic Properties of Generalized Type Unions". </title> <journal> SIG-PLAN Notices, </journal> <volume> 12(3), </volume> <month> March </month> <year> 1977. </year>
Reference-contexts: A next generation of cord is currently being developed. For finite types, this version of the tool will be able to handle more interesting operations, like addition and comparison. 11 It will also be able to approximate infinite types and perform operations on them using abstract interpretation <ref> [8] </ref>. This will allow us to analyze code directly rather than using annotations. 4.3 Checking the Cruise Control System We have implemented the Cruise Control system in C with an Xlib interface.
Reference: [9] <author> Anthony Hall. </author> <title> "Seven Myths of Formal Methods". </title> <journal> IEEE Software, </journal> <pages> pages 11-19, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The primary reason for this resistance is the perception of software developers regarding the applicability of formal methods these methods are considered to be hard (require a level of math ematical sophistication beyond that possessed by many software developers), expensive, and not relevant for "real" software systems <ref> [9] </ref>. Although case-studies (e.g. [7]) have shown applicability and effectiveness of formal methods for various industrial-size systems, this perception still remains. Currently, most research in formal methods concentrates on improving modeling languages and tool support to be able to specify and verify larger and more complex problems (e.g. [13, 16]).
Reference: [10] <author> C. Heitmeyer, R. Jeffords, and B. Labaw. </author> <title> "Automated Consistency Checking of Requirements Specifications". </title> <journal> Transactions on Software Engineering and Methodology, </journal> <year> 1996. </year>
Reference-contexts: Tools were developed to check mode tables of SCR for correctness with respect to global properties using model-checking [24] and theorem-proving [19]. A group at the Naval Research Lab developed an industrial-quality tool called SCR* which allows specifying and reasoning about complex systems using SCR <ref> [10] </ref>. SCR* performs checks to ensure that the tables are complete and consistent. Tool-building is not limited to the SCR community.
Reference: [11] <author> K. Heninger. </author> <title> "Software Requirements for the A-7E Aircraft". </title> <type> Technical Report NRL Report 3876, </type> <institution> Naval Research Laboratory, </institution> <address> Washington, DC, </address> <year> 1978. </year>
Reference-contexts: We are interested in specifying and verifying event-driven systems, and chose SCR (Software 1 Cost Reduction) to be the requirements nota-tion used in our project. The SCR requirements notation was developed by a research group at the Naval Research Laboratory as part of the Software Cost Reduction project <ref> [11, 12] </ref>. This notation specifies event-driven systems as communicating state machines which move between states as the environment changes. The functional part of the system requirements describes the values of the system's output variables as a function of the system's input (event) and internal state.
Reference: [12] <author> K. Heninger. </author> <title> "Specifying Software Requirements for Complex Systems: New Techniques and Their Applications". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):2-12, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: We are interested in specifying and verifying event-driven systems, and chose SCR (Software 1 Cost Reduction) to be the requirements nota-tion used in our project. The SCR requirements notation was developed by a research group at the Naval Research Laboratory as part of the Software Cost Reduction project <ref> [11, 12] </ref>. This notation specifies event-driven systems as communicating state machines which move between states as the environment changes. The functional part of the system requirements describes the values of the system's output variables as a function of the system's input (event) and internal state.
Reference: [13] <author> G.J. Holzmann. </author> <title> "The Model Checker SPIN". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 23(5) </volume> <pages> 279-295, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: Although case-studies (e.g. [7]) have shown applicability and effectiveness of formal methods for various industrial-size systems, this perception still remains. Currently, most research in formal methods concentrates on improving modeling languages and tool support to be able to specify and verify larger and more complex problems (e.g. <ref> [13, 16] </ref>). However, to facilitate a wide-spread use of formal methods, another, complimentary approach is necessary: to improve usability of the methods and the tools and to demonstrate the cost-effectiveness of applying them to software systems.
Reference: [14] <author> D. N. Hoover and Zewei Chen. "Table-Wise: </author> <title> A Decision Table Tool". </title> <editor> In John Rushby, editor, </editor> <booktitle> Proceedings of COMPASS'95, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Tool-building is not limited to the SCR community. For example, David Par-nas and his colleagues are working on methods and tools to document programs using tables [22, 20, 23, 1], and a group at Odyssey Research Associates are developing Tablewise a tool to reason about decision tables <ref> [14] </ref>. However, none of these tools are aimed at using tabular requirements once they have been created.
Reference: [15] <author> James Kirby. </author> <title> "Example NRL/SCR Software Requirements for an Automobile Cruise Control and Monitoring System". </title> <type> Technical report, </type> <institution> Wang Institute of Graduate Studies, </institution> <month> October </month> <year> 1988. </year> <note> Revision 2.0 by Skip Osborne and Aaron Temin. </note>
Reference-contexts: Sections 3 and 4 outline techniques to analyze the consistency of the requirements and the correspondence between the code and the requirements, respectively. In Section 5 we summarize our work and outline future research directions. 2 Requirements of Cruise Control System A Cruise Control system specified by Jim Kirby <ref> [15] </ref> is responsible for keeping an automobile traveling at a certain speed. The driver accelerates to the desired speed and then presses a button on the steering wheel to activate the cruise control. <p> Monitored variables in our case study indicate the state of the ignition, brake, and acceleration, the buttons operating the cruise control system, and the speed of the car. Table 2 shows some monitored variables and the 1 The value of THRESHOLD is not specified in <ref> [15] </ref>. <p> We feel that both options should be turned on on a fast machine with a limited amount of memory, whereas just --reorder should be turned on on a slower machine. The verification effort yielded a number of errors, most of which could be traced back to the original specification <ref> [15] </ref>. We found no errors in the mode transition table because this table has been analyzed earlier by Atlee and her colleagues [2] 3 .
Reference: [16] <author> R. P. </author> <title> Kurshan. </title> <booktitle> "COSPAN". In Proceedings of CAV'96, </booktitle> <year> 1996. </year>
Reference-contexts: Although case-studies (e.g. [7]) have shown applicability and effectiveness of formal methods for various industrial-size systems, this perception still remains. Currently, most research in formal methods concentrates on improving modeling languages and tool support to be able to specify and verify larger and more complex problems (e.g. <ref> [13, 16] </ref>). However, to facilitate a wide-spread use of formal methods, another, complimentary approach is necessary: to improve usability of the methods and the tools and to demonstrate the cost-effectiveness of applying them to software systems.
Reference: [17] <author> K.L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic, </publisher> <year> 1993. </year>
Reference-contexts: We chose to use model-checking [6] to perform these checks. A symbolic model-checker SMV developed by McMillan <ref> [17] </ref>, uses state exploration to check if temporal properties hold in a finite-state model. However, we first needed to translate the behavioral specifications of SCR into a format accepted by SMV, which is done using a tool gensmv.
Reference: [18] <author> S. Owre, N. Shankar, and J. Rushby. </author> <title> "User Guide for the PVS Specification and Verification System (Draft)". </title> <type> Technical report, </type> <institution> Computer Science Lab, SRI International, </institution> <address> Menlo Park, CA, </address> <year> 1993. </year>
Reference-contexts: In order to use model-checking effectively, we had to reduce the expressive power of our input logic, which may not be feasible for many applications. We recognize that more sophisticated verification might be necessary and are planning to experiment with using a theorem-prover, e.g. PVS <ref> [18] </ref>, to check complex type-checking and timing properties of systems. Code verification in SC (R) 3 is done via a static-analysis tool cord. Although effective in finding errors in our case studies, cord is still a prototype tool in need of major improvements.
Reference: [19] <author> Sam Owre, John Rushby, and Natarajan Shankar. </author> <title> "Integration in PVS: Tables, Types, and Model Checking". </title> <booktitle> In Proceedings of the Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS'97), </booktitle> <volume> LNCS 1217, </volume> <pages> pages 366-383, </pages> <month> April </month> <year> 1997. </year>
Reference-contexts: Table structure makes specifications easy to write and review and allows for high-yield mechanical analysis. Tools were developed to check mode tables of SCR for correctness with respect to global properties using model-checking [24] and theorem-proving <ref> [19] </ref>. A group at the Naval Research Lab developed an industrial-quality tool called SCR* which allows specifying and reasoning about complex systems using SCR [10]. SCR* performs checks to ensure that the tables are complete and consistent. Tool-building is not limited to the SCR community.
Reference: [20] <author> David Lorge Parnas and Jan Madey. </author> <title> "Functional Documents for Computer Systems". </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 25 </volume> <pages> 41-61, </pages> <year> 1995. </year>
Reference-contexts: SCR* performs checks to ensure that the tables are complete and consistent. Tool-building is not limited to the SCR community. For example, David Par-nas and his colleagues are working on methods and tools to document programs using tables <ref> [22, 20, 23, 1] </ref>, and a group at Odyssey Research Associates are developing Tablewise a tool to reason about decision tables [14]. However, none of these tools are aimed at using tabular requirements once they have been created.
Reference: [21] <author> D.L. Parnas. </author> <title> "Some Theorems We Should Prove". </title> <booktitle> In Proceedings of 1993 International Conference on HOL Theorem Proving and Its Applications, </booktitle> <address> Vancouver, BC, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Researchers have long been advocating using mathematically-precise ("formal") specifications in software projects <ref> [21] </ref>. These specifications aid in removing errors early in the software lifecycle and can be reused in a variety of ways: as a reference point during system design and during development of test cases, as documentation during maintenance, etc.
Reference: [22] <author> D.L. Parnas, J. Madey, and M. Iglewski. </author> <title> "Precise Documentation of Well-Structured Programs". </title> <journal> IEEE Transactions on Software Engineering, </journal> 20(12) 948-976, December 1994. 
Reference-contexts: SCR* performs checks to ensure that the tables are complete and consistent. Tool-building is not limited to the SCR community. For example, David Par-nas and his colleagues are working on methods and tools to document programs using tables <ref> [22, 20, 23, 1] </ref>, and a group at Odyssey Research Associates are developing Tablewise a tool to reason about decision tables [14]. However, none of these tools are aimed at using tabular requirements once they have been created.
Reference: [23] <author> Dennis K. Peters and David Lorge Par-nas. </author> <title> "Using Test Oracles Generated from Program Documentation". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 24(3) </volume> <pages> 161-173, </pages> <month> March </month> <year> 1998. </year> <month> 15 </month>
Reference-contexts: SCR* performs checks to ensure that the tables are complete and consistent. Tool-building is not limited to the SCR community. For example, David Par-nas and his colleagues are working on methods and tools to document programs using tables <ref> [22, 20, 23, 1] </ref>, and a group at Odyssey Research Associates are developing Tablewise a tool to reason about decision tables [14]. However, none of these tools are aimed at using tabular requirements once they have been created.
Reference: [24] <author> Tirumale Sreemani and Joanne M. Atlee. </author> <title> "Feasibility of Model Checking Software Requirements: A Case Study". </title> <booktitle> In Proceedings of COMPASS'96, </booktitle> <address> Gaithersburg, Maryland, </address> <month> June </month> <year> 1996. </year> <month> 16 </month>
Reference-contexts: Table structure makes specifications easy to write and review and allows for high-yield mechanical analysis. Tools were developed to check mode tables of SCR for correctness with respect to global properties using model-checking <ref> [24] </ref> and theorem-proving [19]. A group at the Naval Research Lab developed an industrial-quality tool called SCR* which allows specifying and reasoning about complex systems using SCR [10]. SCR* performs checks to ensure that the tables are complete and consistent. Tool-building is not limited to the SCR community. <p> In this section, we briefly describe gensmv, outline counter-example facilities of SMV and SC (R) 3 , and present results of verification of the Cruise Control system. 6 3.1 Translating SCR Specifica- tions gensmv <ref> [24] </ref> was developed at the University of Waterloo to reason about mode transition tables. Before translating SCR specifications, gensmv details the mode transition tables with information derived from environmental assumptions. <p> SMV uses binary decision diagrams (BDDs) to quickly manipulate logical expressions. Unfortunately, the size of the BDDs is extremely sensitive to the order of the variables used to build them <ref> [24] </ref>. SMV has an option 2 --reorder that allows it to heuristically compute and use a "better" variable reordering which is typically very effective. However, even with reordering turned on, SMV took a long time to verify the Cruise Control specification (26487.25 seconds of user time).
References-found: 24

