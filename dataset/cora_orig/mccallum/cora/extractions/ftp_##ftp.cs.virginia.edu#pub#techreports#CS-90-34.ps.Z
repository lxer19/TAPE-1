URL: ftp://ftp.cs.virginia.edu/pub/techreports/CS-90-34.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Abstract: Highly Concurrent Cache Coherence Protocols Craig Williams,Paul F. Reynolds, Jr. Technical Report No. CS-90-34 December 1990 
Abstract-found: 1
Intro-found: 1
Reference: [AdH90] <author> S. V. Adve and M. D. Hill, </author> <title> Weak Ordering --- A New Definition, </title> <booktitle> Proc. of the 17th International Symp. Computer Architecture, </booktitle> <year> 1990, </year> <pages> 2-11. </pages>
Reference-contexts: Since pipelining is an important technique for reducing effective memory latency in multiprocessors, researchers have proposed enforcing a weaker form of sequential consistency allowing some pipelin-ing by relaxing ordering constraints between synchronization points <ref> [AdH90, DSB86] </ref>. With the exception of these protocols, we know of no protocols that allow operations on shared variables to be pipelined. Delta-cache protocols allow most operations to be pipelined and enforce the stronger, original form of sequential consistency.
Reference: [Aga88] <author> A. Agarwal, et al., </author> <title> An Evaluation of Directory Schemes for Cache Coherence, </title> <booktitle> Proc. of the 15th International Symp. Computer Architecture, </booktitle> <year> 1988, </year> <pages> 280-289. </pages>
Reference-contexts: Since each message need not go to every PE and need not consume all the machine's bandwidth, the network can handle multiple messages concurrently, resulting in improved scalability over the snoopy protocols. Some protocols are directory/snoopy hybrids, e.g., the limited directory protocols proposed by Agarwal, et al., <ref> [Aga88] </ref> and several protocols for multiple bus or hybrid bus/MIN architectures, such as the protocol proposed by Algudady, et al., [ADT90] and the DASH [Len90], VMP-MC [CGB89], and Aquarius [CaD90] protocols. 3 Directory protocols are so named because they maintain a directory for each block listing the loca-tion of all copies <p> The focus of much of the subsequent work on directory protocols has been on improving the scalability of the directory representation <ref> [Aga88, ArB84, CKA91, GWM90, Jam90, LiY90, OKN90, SiH91, Ste89, ThD91] </ref>. Although reducing the space complexity of the directory representation is an important problem, our focus is different: on improving the scalability of cache coherence protocols by increasing their concurrency.
Reference: [ADT90] <author> M. S. Algudady, C. R. Das and M. J. Thazhuthaveetil, </author> <title> A Write Update Cache Coherence Protocol for Min-Based Multiprocessors with Accessibility Based Split Caches, </title> <booktitle> Proc. Supercomputing '90, </booktitle> <address> New York, New York, </address> <month> November </month> <year> 1990, </year> <pages> 544-553. </pages>
Reference-contexts: Some protocols are directory/snoopy hybrids, e.g., the limited directory protocols proposed by Agarwal, et al., [Aga88] and several protocols for multiple bus or hybrid bus/MIN architectures, such as the protocol proposed by Algudady, et al., <ref> [ADT90] </ref> and the DASH [Len90], VMP-MC [CGB89], and Aquarius [CaD90] protocols. 3 Directory protocols are so named because they maintain a directory for each block listing the loca-tion of all copies of the block. The first directory protocol, due to Tang [Tan76], specified a single centralized directory.
Reference: [ArB84] <author> J. Archibald and J. L. Baer, </author> <title> An Economical Solution to the Cache Coherence Problem, </title> <booktitle> Proc. 11th International Symp. Computer Architecture, </booktitle> <year> 1984, </year> <pages> 355-362. </pages>
Reference-contexts: The focus of much of the subsequent work on directory protocols has been on improving the scalability of the directory representation <ref> [Aga88, ArB84, CKA91, GWM90, Jam90, LiY90, OKN90, SiH91, Ste89, ThD91] </ref>. Although reducing the space complexity of the directory representation is an important problem, our focus is different: on improving the scalability of cache coherence protocols by increasing their concurrency.
Reference: [ArB86] <author> J. Archibald and J. L. Baer, </author> <title> Cache Coherence Protocols: Evaluation Using a Multiprocessor Simulation Model, </title> <journal> ACM Transactions on Computer Systems 4,4 (November 1986), </journal> <pages> 273-298. </pages>
Reference-contexts: Snoopy protocols can be either write-invalidate (e.g., Goodman's write-once protocol [Goo86] and the Berkeley ownership protocol [Kat85]) or write-update (the DEC Firefly and Xerox Dragon protocols described by Archibald and Baer <ref> [ArB86] </ref>), but existing directory protocols are almost exclusively write-invalidate protocols. The exception, the CMU PLUS cache protocol [BiR90], ensures only a weak form of cache coherence. In particular, the protocol permits PE's to observe writes by other PE's in an inconsistent order.
Reference: [Awe85] <author> B. Awerbuch, </author> <title> Complexity of Network Synchronization, </title> <journal> J. ACM 32,4 (October 1985), </journal> <pages> 804-423. </pages>
Reference-contexts: It is based on a form of synchronization we call local synchrony (the name is due to Ray R. Wagner, Jr.). Local synchrony has been used by Awerbuch to support execution of SIMD graph algorithms on asynchronous networks <ref> [Awe85] </ref>, by Gibbons to support barrier synchronization [Gib89], and by Ranade in emulating a CRCW-PRAM [Ran87, RBJ88]. Ranade's emulation maintains the velocity invariant and is thus an isotach network. It uses the velocity invariant to support efficient combining of operations within the ICN.
Reference: [BMR89] <author> S. J. Baylor, K. P. McAuliffe and B. D. Rathi, </author> <title> Cache Coherence Protocols for MIN-Based Multiprocessors, </title> <type> RC 15221, </type> <institution> IBM Research Report, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: In choosing to focus on hardware protocols, we do not dismiss the benefits of using static information in reducing the cost of cache coherence. Several software/hardware hybrid protocols that use static information about variable access patterns to improve hardware protocols have been proposed <ref> [BMR89, BCZ90, LiY91] </ref>, and we see uses for such static information in delta-cache protocols. Hardware protocols are typically classified as either snoopy or directory protocols. A snoopy protocol ensures cache coherence by broadcasting an update or invalidation when a cache block is written.
Reference: [BaR89] <author> S. J. Baylor and B. D. Rathi, </author> <title> A Study of the Memory Reference Behavior of Engineering/Scientific Applications in Parallel Processors, </title> <booktitle> ICPP, </booktitle> <year> 1989, </year> <month> I-78-82. </month>
Reference-contexts: Eliminating the memory copy allows an optimization for the special case in which only the owner has a cache copy. Studies of parallel programs suggest this case occurs frequently in actual applications <ref> [BaR89, EgK88] </ref>. The owner can detect whether it has the only cache copy because it maintains DIR. If DIR is empty, the owner does not use a update policy, but instead executes all operations on V locally.
Reference: [BCZ90] <author> J. K. Bennett, J. B. Carter and W. Zwaenepoel, </author> <title> Adaptive Software Cache Management for Distributed Shared Memory Architectures, </title> <booktitle> Proc. 17th Annual International Symp. on Computer Architecture, </booktitle> <month> May, </month> <year> 1990, </year> <pages> 1125-1135?. </pages>
Reference-contexts: In choosing to focus on hardware protocols, we do not dismiss the benefits of using static information in reducing the cost of cache coherence. Several software/hardware hybrid protocols that use static information about variable access patterns to improve hardware protocols have been proposed <ref> [BMR89, BCZ90, LiY91] </ref>, and we see uses for such static information in delta-cache protocols. Hardware protocols are typically classified as either snoopy or directory protocols. A snoopy protocol ensures cache coherence by broadcasting an update or invalidation when a cache block is written.
Reference: [BiR90] <author> R. Bisiani and M. Ravishankar, </author> <title> PLUS: A Distributed Shared-Memory System, </title> <booktitle> Proc. 17th ISCA, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: Snoopy protocols can be either write-invalidate (e.g., Goodman's write-once protocol [Goo86] and the Berkeley ownership protocol [Kat85]) or write-update (the DEC Firefly and Xerox Dragon protocols described by Archibald and Baer [ArB86]), but existing directory protocols are almost exclusively write-invalidate protocols. The exception, the CMU PLUS cache protocol <ref> [BiR90] </ref>, ensures only a weak form of cache coherence. In particular, the protocol permits PE's to observe writes by other PE's in an inconsistent order.
Reference: [CaD90] <author> M. Carlton and A. Despain, </author> <title> Multiple-Bus Shared-Memory System: Aquarius Project, </title> <journal> IEEE Computer 23,6 (June 1990), </journal> <pages> 80-83. </pages>
Reference-contexts: Because snoopy protocols rely on broadcasting, they scale poorly. The ICN, typically but not necessarily a shared bus, becomes saturated with only a few PE's. Researchers are exploring ways to delay this saturation point by assuming multiple buses arranged hierarchically [CGB89, HaH89, Wil87] or in a grid <ref> [CaD90, GoW88] </ref>. This approach is promising for programs with access patterns that allow most broadcasts to be restricted to a local cluster of PE's. Directory protocols represent a more general approach to the scalability problem. These protocols do not require broadcasting. <p> Some protocols are directory/snoopy hybrids, e.g., the limited directory protocols proposed by Agarwal, et al., [Aga88] and several protocols for multiple bus or hybrid bus/MIN architectures, such as the protocol proposed by Algudady, et al., [ADT90] and the DASH [Len90], VMP-MC [CGB89], and Aquarius <ref> [CaD90] </ref> protocols. 3 Directory protocols are so named because they maintain a directory for each block listing the loca-tion of all copies of the block. The first directory protocol, due to Tang [Tan76], specified a single centralized directory.
Reference: [CeF78] <author> L. M. Censier and P. Feautrier, </author> <title> A New Solution to Coherence Problems in Multicache Systems, </title> <journal> IEEE Trans. on Computers, </journal> <month> December </month> <year> 1978, </year> <pages> 1112-1118. </pages>
Reference-contexts: The first directory protocol, due to Tang [Tan76], specified a single centralized directory. Censier and Feautrier improved on this protocol by distributing the directory so that the directory for each block is located in the MM containing the memory copy of that block <ref> [CeF78] </ref>. The directory for each block in Censier and Feautrier's protocol is a bit vector of length n, where n is the number of PE's and bit k of a block's vector is set if PE k holds a copy of that block. <p> Although reducing the space complexity of the directory representation is an important problem, our focus is different: on improving the scalability of cache coherence protocols by increasing their concurrency. For simplicity, we assume the bit vector representation proposed by Censier and Feautrier <ref> [CeF78] </ref>, but delta-cache protocols are compatible with the more scalable linked-list directory representation proposed for the Alewife machine [CKA91] or with the similar, hardware-supported representation discussed by Simoni and Horowitz [SiH91]. In addition to being classified as directory or snoopy protocols, hardware protocols are also classified as write-update or write-invalidate. <p> The traditional definition of memory coherence is that a memory is coherent if a load operation on a shared variable returns the value written by the latest store operation on the same variable <ref> [CeF78] </ref>. Dubois, Scheurich, and Briggs have noted problems with this definition of coherence, in particular, difficulty applying the concept of latest store to systems that do not broadcast cache updates [DSB86]. They propose adopting sequential consistency as an alternative correctness criterion for cache protocols.
Reference: [CKA91] <author> D. Chaiken, J. Kubiatowicz and A. Agarwal, </author> <title> LimitLeSS Directories: A Scalable Cache Coherence Scheme, </title> <booktitle> 4th ASPLOS, </booktitle> <month> April, </month> <year> 1991, </year> <pages> 224-234. </pages>
Reference-contexts: The focus of much of the subsequent work on directory protocols has been on improving the scalability of the directory representation <ref> [Aga88, ArB84, CKA91, GWM90, Jam90, LiY90, OKN90, SiH91, Ste89, ThD91] </ref>. Although reducing the space complexity of the directory representation is an important problem, our focus is different: on improving the scalability of cache coherence protocols by increasing their concurrency. <p> For simplicity, we assume the bit vector representation proposed by Censier and Feautrier [CeF78], but delta-cache protocols are compatible with the more scalable linked-list directory representation proposed for the Alewife machine <ref> [CKA91] </ref> or with the similar, hardware-supported representation discussed by Simoni and Horowitz [SiH91]. In addition to being classified as directory or snoopy protocols, hardware protocols are also classified as write-update or write-invalidate. A write-update protocol maintains coherence by keeping all copies of the same block up-to-date.
Reference: [ChV88] <author> H. Cheong and A. Veidenbaum, </author> <booktitle> Proc. 15th International Symp. Computer Architecture, </booktitle> <year> 1988. </year>
Reference-contexts: Hardware protocols manage caches dynamically without direction from the programmer. They require run-time communication to maintain memory coherence, but, for this reason, are less conservative than software protocols <ref> [ChV88, MiB89] </ref>, protocols that depend on the programmer or compiler to manage caches with little or no hardware support. In choosing to focus on hardware protocols, we do not dismiss the benefits of using static information in reducing the cost of cache coherence.
Reference: [CGB89] <author> D. R. Cheriton, H. A. Goosen and P. D. Boyle, </author> <title> Multi-Level Shared Caching Techniques for Scalability in VMP-MC, </title> <booktitle> Proc. 16th ISCA, </booktitle> <month> June </month> <year> 1989, </year> <pages> 16-24. </pages>
Reference-contexts: Because snoopy protocols rely on broadcasting, they scale poorly. The ICN, typically but not necessarily a shared bus, becomes saturated with only a few PE's. Researchers are exploring ways to delay this saturation point by assuming multiple buses arranged hierarchically <ref> [CGB89, HaH89, Wil87] </ref> or in a grid [CaD90, GoW88]. This approach is promising for programs with access patterns that allow most broadcasts to be restricted to a local cluster of PE's. Directory protocols represent a more general approach to the scalability problem. These protocols do not require broadcasting. <p> Some protocols are directory/snoopy hybrids, e.g., the limited directory protocols proposed by Agarwal, et al., [Aga88] and several protocols for multiple bus or hybrid bus/MIN architectures, such as the protocol proposed by Algudady, et al., [ADT90] and the DASH [Len90], VMP-MC <ref> [CGB89] </ref>, and Aquarius [CaD90] protocols. 3 Directory protocols are so named because they maintain a directory for each block listing the loca-tion of all copies of the block. The first directory protocol, due to Tang [Tan76], specified a single centralized directory.
Reference: [DuB82] <author> M. Dubois and F. A. Briggs, </author> <title> Effects of Cache Coherency in Multiprocessors, </title> <journal> IEEE Trans. on Computers 31(November 1982), </journal> <pages> 1083-1099. </pages>
Reference-contexts: In parallel with a performance study of the isotach network, we expect to study the performance of delta-cache protocols using a workload model, e.g. the model proposed by Dubois and Briggs <ref> [DuB82] </ref>, leaving the cost of communication as a parameter.
Reference: [DSB86] <author> M. Dubois, C. Scheurich and F. Briggs, </author> <title> Memory Access Buffering in Multiprocessors, </title> <booktitle> Proc. 13th International Symp. Computer Architecture, </booktitle> <year> 1986, </year> <pages> 434-442. </pages>
Reference-contexts: Dubois, Scheurich, and Briggs have noted problems with this definition of coherence, in particular, difficulty applying the concept of latest store to systems that do not broadcast cache updates <ref> [DSB86] </ref>. They propose adopting sequential consistency as an alternative correctness criterion for cache protocols. An execution is sequentially consistent if it is equivalent to a serial execution in which the operations issued by each process are executed in the order specified by the program [Lam79]. <p> Since pipelining is an important technique for reducing effective memory latency in multiprocessors, researchers have proposed enforcing a weaker form of sequential consistency allowing some pipelin-ing by relaxing ordering constraints between synchronization points <ref> [AdH90, DSB86] </ref>. With the exception of these protocols, we know of no protocols that allow operations on shared variables to be pipelined. Delta-cache protocols allow most operations to be pipelined and enforce the stronger, original form of sequential consistency.
Reference: [EgK88] <author> S. Eggers and R. Katz, </author> <title> A Characterization of Sharing in Parallel Programs and Its Application to Coherency Protocol Evaluation, </title> <booktitle> Proc. 15th International Symp. Computer Architecture, </booktitle> <month> May </month> <year> 1988, </year> <pages> 373-382. </pages>
Reference-contexts: relative merits of write-update and write-invalidate protocols, at least for bus-based protocols involving a small number of PE's, depend on several factors: block size, cache size, the probability of an access being a write, and the extent to which accesses by different processes to the same block are 4 interleaved <ref> [EgK88, EgK89] </ref>. Write-update protocols can waste bandwidth by sending updates to PE's that no longer need to access the updated block. On the other hand, write-invalidate protocols may invalidate actively accessed copies of a block. <p> Eliminating the memory copy allows an optimization for the special case in which only the owner has a cache copy. Studies of parallel programs suggest this case occurs frequently in actual applications <ref> [BaR89, EgK88] </ref>. The owner can detect whether it has the only cache copy because it maintains DIR. If DIR is empty, the owner does not use a update policy, but instead executes all operations on V locally.
Reference: [EgK89] <author> S. Eggers and R. Katz, </author> <title> Evaluating the Performance of Four Snooping Cache Coherency Protocols, </title> <booktitle> Proc. 16th International Symp. Computer Architecture, </booktitle> <year> 1989, </year> <pages> 2-15. </pages>
Reference-contexts: relative merits of write-update and write-invalidate protocols, at least for bus-based protocols involving a small number of PE's, depend on several factors: block size, cache size, the probability of an access being a write, and the extent to which accesses by different processes to the same block are 4 interleaved <ref> [EgK88, EgK89] </ref>. Write-update protocols can waste bandwidth by sending updates to PE's that no longer need to access the updated block. On the other hand, write-invalidate protocols may invalidate actively accessed copies of a block.
Reference: [Gib89] <author> P. B. Gibbons, </author> <title> The Asynchronous PRAM: A Semi-Synchronous Model for Shared Memory MIMD Machines, </title> <type> 89-062, </type> <institution> International Computer Science Institute, Berkeley, California, </institution> <month> 42 December, </month> <year> 1989. </year>
Reference-contexts: It is based on a form of synchronization we call local synchrony (the name is due to Ray R. Wagner, Jr.). Local synchrony has been used by Awerbuch to support execution of SIMD graph algorithms on asynchronous networks [Awe85], by Gibbons to support barrier synchronization <ref> [Gib89] </ref>, and by Ranade in emulating a CRCW-PRAM [Ran87, RBJ88]. Ranade's emulation maintains the velocity invariant and is thus an isotach network. It uses the velocity invariant to support efficient combining of operations within the ICN.
Reference: [Goo86] <author> J. R. Goodman, </author> <title> Using Cache Memory to Reduce Processor-Memory Traffic, </title> <booktitle> 10th ISCA, </booktitle> <month> June </month> <year> 1986, </year> <pages> 124-131. </pages>
Reference-contexts: As directory protocols, they avoid the limitations on scalability implied by broadcasting. Although the write-invalidate vs. write-update and snoopy vs. directory alternatives are in theory independent [Ste90], write-update directory protocols are unusual. Snoopy protocols can be either write-invalidate (e.g., Goodman's write-once protocol <ref> [Goo86] </ref> and the Berkeley ownership protocol [Kat85]) or write-update (the DEC Firefly and Xerox Dragon protocols described by Archibald and Baer [ArB86]), but existing directory protocols are almost exclusively write-invalidate protocols. The exception, the CMU PLUS cache protocol [BiR90], ensures only a weak form of cache coherence.
Reference: [GoW88] <author> J. R. Goodman and P. Woest, </author> <title> The Wisconsin Multicube: A New Large-Scale Cache-Coherent Multiprocessor, </title> <booktitle> Proc. 15th International Conf. Computer Architecture, </booktitle> <year> 1988, </year> <pages> 422-431. </pages>
Reference-contexts: Because snoopy protocols rely on broadcasting, they scale poorly. The ICN, typically but not necessarily a shared bus, becomes saturated with only a few PE's. Researchers are exploring ways to delay this saturation point by assuming multiple buses arranged hierarchically [CGB89, HaH89, Wil87] or in a grid <ref> [CaD90, GoW88] </ref>. This approach is promising for programs with access patterns that allow most broadcasts to be restricted to a local cluster of PE's. Directory protocols represent a more general approach to the scalability problem. These protocols do not require broadcasting.
Reference: [GWM90] <author> A. Gupta, W. Weber and T. Mowry, </author> <title> Reducing Memory and Traffic Requirements for Scalable Directory-Based Cache Coherence Schemes, </title> <booktitle> Proc. 1990 ICPP, </booktitle> <month> August </month> <year> 1990, </year> <month> I-312-I-321. </month>
Reference-contexts: The focus of much of the subsequent work on directory protocols has been on improving the scalability of the directory representation <ref> [Aga88, ArB84, CKA91, GWM90, Jam90, LiY90, OKN90, SiH91, Ste89, ThD91] </ref>. Although reducing the space complexity of the directory representation is an important problem, our focus is different: on improving the scalability of cache coherence protocols by increasing their concurrency.
Reference: [HaH89] <author> S. Haridi and E. Hagersten, </author> <title> The Cache Coherence Protocol of the Data Diffusion Machine, </title> <booktitle> Proc. PARLE 89 1(1989), </booktitle> <pages> 1-18, </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Because snoopy protocols rely on broadcasting, they scale poorly. The ICN, typically but not necessarily a shared bus, becomes saturated with only a few PE's. Researchers are exploring ways to delay this saturation point by assuming multiple buses arranged hierarchically <ref> [CGB89, HaH89, Wil87] </ref> or in a grid [CaD90, GoW88]. This approach is promising for programs with access patterns that allow most broadcasts to be restricted to a local cluster of PE's. Directory protocols represent a more general approach to the scalability problem. These protocols do not require broadcasting.
Reference: [Jam90] <author> D. V. James, et al., </author> <title> Scalable Coherent Interface, </title> <booktitle> Computer 23,6 (June 1990), </booktitle> <pages> 74-77. </pages>
Reference-contexts: The focus of much of the subsequent work on directory protocols has been on improving the scalability of the directory representation <ref> [Aga88, ArB84, CKA91, GWM90, Jam90, LiY90, OKN90, SiH91, Ste89, ThD91] </ref>. Although reducing the space complexity of the directory representation is an important problem, our focus is different: on improving the scalability of cache coherence protocols by increasing their concurrency.
Reference: [KMR86] <author> A. Karlin, M. S. Manasse, L. Rudolph and D. D. Sleater, </author> <title> Competitive Snoopy Caching, </title> <booktitle> Proc. 27th Annual Symp. on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1986, </year> <pages> 244-254. </pages>
Reference-contexts: A write-invalidate protocol uses invalidation in place of updating. In a write-invalidate protocol a PE must obtain exclusive access rights to a block before it can write the block. Whenever any copy of a block is written all other copies are invalidated. Some protocols, e.g., read broadcast protocols <ref> [KMR86] </ref>, are write-invalidate/write-update hybrids.
Reference: [Kat85] <author> R. Katz, et al., </author> <title> Implementing a Cache Consistency Protocol, </title> <booktitle> Proc. 12th Annual International Symp. on Computer Architecture, </booktitle> <month> June </month> <year> 1985, </year> <pages> 276-283. </pages>
Reference-contexts: As directory protocols, they avoid the limitations on scalability implied by broadcasting. Although the write-invalidate vs. write-update and snoopy vs. directory alternatives are in theory independent [Ste90], write-update directory protocols are unusual. Snoopy protocols can be either write-invalidate (e.g., Goodman's write-once protocol [Goo86] and the Berkeley ownership protocol <ref> [Kat85] </ref>) or write-update (the DEC Firefly and Xerox Dragon protocols described by Archibald and Baer [ArB86]), but existing directory protocols are almost exclusively write-invalidate protocols. The exception, the CMU PLUS cache protocol [BiR90], ensures only a weak form of cache coherence.
Reference: [Lam78] <author> L. Lamport, </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System, </title> <journal> Comm. ACM 21,7 (July 1978), </journal> <pages> 558-565. </pages>
Reference-contexts: In the logical time system we use in this paper, each logical time is a 3-tuple (pulse,tick,tock) of integers. Logical times are lexicographically ordered. An isotach network implements a logical time system that differs from others <ref> [Lam78, Mat88] </ref> in that it relates communication time with communication distance. In an isotach network, each message is received DIST pulses after it is emitted, where DIST is the number of switches through which the message is routed.
Reference: [Lam79] <author> L. Lamport, </author> <title> How to Make a Multiprocessor Computer That Correctly Executes Multiprocessor Programs, </title> <journal> IEEE Trans. on Computers 28(1979), </journal> <pages> 690-691. </pages>
Reference-contexts: They propose adopting sequential consistency as an alternative correctness criterion for cache protocols. An execution is sequentially consistent if it is equivalent to a serial execution in which the operations issued by each process are executed in the order specified by the program <ref> [Lam79] </ref>. Sequential consistency, and thus memory coherence, can be ensured in systems with caches by prohibiting pipelining of accesses to shared variables [ScD87].
Reference: [Len90] <author> D. Lenoski, et al., </author> <title> The Directory-Based Cache Coherence Protocol for the DASH Multiprocessor, </title> <booktitle> Proc. 17th International Symp. Computer Architecture, </booktitle> <year> 1990, </year> <pages> 148-159. </pages>
Reference-contexts: Some protocols are directory/snoopy hybrids, e.g., the limited directory protocols proposed by Agarwal, et al., [Aga88] and several protocols for multiple bus or hybrid bus/MIN architectures, such as the protocol proposed by Algudady, et al., [ADT90] and the DASH <ref> [Len90] </ref>, VMP-MC [CGB89], and Aquarius [CaD90] protocols. 3 Directory protocols are so named because they maintain a directory for each block listing the loca-tion of all copies of the block. The first directory protocol, due to Tang [Tan76], specified a single centralized directory.
Reference: [Li89] <author> K. Li and P. Hudak, </author> <title> Memory Coherency in Shared Virtual Memory Systems, </title> <journal> ACM TOCS 7,4 (November 1989), </journal> <pages> 321-359. </pages>
Reference-contexts: so that it migrates the hot copy adaptively; extending the techniques for enforcing version consistency described in an earlier paper [WiR89] to systems with caches; and exploring the applicability of the protocols and migration algorithm to the related problem of implementing a virtual shared memory on a distributed memory machine <ref> [Li89] </ref>. 41
Reference: [LiY90] <author> D. J. Lilja and P. Yew, </author> <title> A Compiler-Assisted Directory-Based Cache Coherence Scheme, </title> <type> CSRD 990, </type> <institution> Center for Supercomputing Research and Development, University of Illinois at Urbana-Champaign, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: The focus of much of the subsequent work on directory protocols has been on improving the scalability of the directory representation <ref> [Aga88, ArB84, CKA91, GWM90, Jam90, LiY90, OKN90, SiH91, Ste89, ThD91] </ref>. Although reducing the space complexity of the directory representation is an important problem, our focus is different: on improving the scalability of cache coherence protocols by increasing their concurrency.
Reference: [LiY91] <author> D. J. Lilja and P. Yew, </author> <title> Combining Hardware and Software Cache Coherence Strategies, </title> <booktitle> Proc. 1991 Conf. on Supercomputing, </booktitle> <address> Cologne, Germany, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: In choosing to focus on hardware protocols, we do not dismiss the benefits of using static information in reducing the cost of cache coherence. Several software/hardware hybrid protocols that use static information about variable access patterns to improve hardware protocols have been proposed <ref> [BMR89, BCZ90, LiY91] </ref>, and we see uses for such static information in delta-cache protocols. Hardware protocols are typically classified as either snoopy or directory protocols. A snoopy protocol ensures cache coherence by broadcasting an update or invalidation when a cache block is written.
Reference: [Mat88] <author> F. Mattern, </author> <title> Virtual Time and Global States of Distributed Systems, </title> <booktitle> Parallel and Distributed Algorithms, </booktitle> <year> 1988, </year> <pages> 215-226. </pages>
Reference-contexts: In the logical time system we use in this paper, each logical time is a 3-tuple (pulse,tick,tock) of integers. Logical times are lexicographically ordered. An isotach network implements a logical time system that differs from others <ref> [Lam78, Mat88] </ref> in that it relates communication time with communication distance. In an isotach network, each message is received DIST pulses after it is emitted, where DIST is the number of switches through which the message is routed.
Reference: [MiB89] <author> S. L. Min and J. Baer, </author> <title> A Timestamp-based Cache Coherence Scheme, </title> <booktitle> Int. Conf. on Parallel Processing 1(1989), </booktitle> <pages> 23-32. </pages>
Reference-contexts: Hardware protocols manage caches dynamically without direction from the programmer. They require run-time communication to maintain memory coherence, but, for this reason, are less conservative than software protocols <ref> [ChV88, MiB89] </ref>, protocols that depend on the programmer or compiler to manage caches with little or no hardware support. In choosing to focus on hardware protocols, we do not dismiss the benefits of using static information in reducing the cost of cache coherence.
Reference: [OKN90] <author> B. W. OKrafka and A. R. </author> <title> Newton, An Empirical Evaluation of Two Memory-Efficient Methods, </title> <booktitle> Proc. 17th International Symp. Computer Architecture, </booktitle> <year> 1990, </year> <pages> 138-147. </pages>
Reference-contexts: The focus of much of the subsequent work on directory protocols has been on improving the scalability of the directory representation <ref> [Aga88, ArB84, CKA91, GWM90, Jam90, LiY90, OKN90, SiH91, Ste89, ThD91] </ref>. Although reducing the space complexity of the directory representation is an important problem, our focus is different: on improving the scalability of cache coherence protocols by increasing their concurrency.
Reference: [Pap86] <author> C. Papadimitriou, </author> <title> Database Concurrency Control, </title> <publisher> Computer Science Press, </publisher> <year> 1986. </year>
Reference-contexts: In a previous paper [WiR89], we considered the problem of con-currency control in systems without caches. We adapted the definition of serializability, the standard correctness criterion in database concurrency control <ref> [Pap86] </ref>, to parallel programs and proposed serial-izability as the correctness criterion for concurrency control mechanisms for parallel programs. An execution of a parallel program is serializable if operations on shared variables appear to be executed in an order consistent with the program.
Reference: [Ran87] <author> A. G. Ranade, </author> <title> How to Emulate Shared Memory, </title> <booktitle> IEEE Annual Symp. on Foundations of Computer Science, </booktitle> <address> Los Angeles, </address> <year> 1987, </year> <pages> 185-194. </pages>
Reference-contexts: Wagner, Jr.). Local synchrony has been used by Awerbuch to support execution of SIMD graph algorithms on asynchronous networks [Awe85], by Gibbons to support barrier synchronization [Gib89], and by Ranade in emulating a CRCW-PRAM <ref> [Ran87, RBJ88] </ref>. Ranade's emulation maintains the velocity invariant and is thus an isotach network. It uses the velocity invariant to support efficient combining of operations within the ICN. Our implementation of an isotach network is based on the exchange by neighboring switches of control signals called tokens.
Reference: [RBJ88] <author> A. G. Ranade, S. N. Bhatt and S. L. Johnson, </author> <title> The Fluent Abstract Machine, </title> <type> Tech. Rep. 573, </type> <institution> Yale University, Dept. of Computer Science, </institution> <month> January, </month> <year> 1988. </year>
Reference-contexts: Wagner, Jr.). Local synchrony has been used by Awerbuch to support execution of SIMD graph algorithms on asynchronous networks [Awe85], by Gibbons to support barrier synchronization [Gib89], and by Ranade in emulating a CRCW-PRAM <ref> [Ran87, RBJ88] </ref>. Ranade's emulation maintains the velocity invariant and is thus an isotach network. It uses the velocity invariant to support efficient combining of operations within the ICN. Our implementation of an isotach network is based on the exchange by neighboring switches of control signals called tokens.
Reference: [RWW89] <author> P. F. Reynolds, Jr., C. Williams and R. R. Wagner, Jr., </author> <title> Parallel Operations, </title> <type> Tech. Rep. 89-16, </type> <institution> University of Virginia, Department of Computer Science, </institution> <month> December, </month> <year> 1989. </year>
Reference-contexts: Delta-cache protocols are based on a new type of interconnection network (ICN) called the isotach network <ref> [RWW89] </ref>. An isotach network implements a logical time system that relates communication time to communication distance. Each message in an isotach network progresses towards its destination at the same rate: one switch per logical time unit. <p> Isotach networks are feasible. The principal difference between isotach networks and more typical ICN's is that each switch in an isotach network applies a standard list-merge algorithm to the operations arriving on its inputs. We originally proposed isotach networks to support a logically synchronous multicast <ref> [RWW89] </ref> and later proposed using the network as the basis for concurrency control in systems without caches [WiR89]. This paper extends our work to systems with caches. <p> This correctness criterion is the basis for a simple proof of delta-cache protocols. Section 3 describes the iso-tach network. We defined the isotach network in other reports <ref> [RWW89, WiR89] </ref>. For completeness, we summarize the description here. Section 4 describes a general delta-cache protocol and two specific protocols based on different patterns for propagating updates. Section 5 concludes the paper with a discussion of ongoing and future work. 6 2.
Reference: [ScD87] <author> C. Scheurich and M. Dubois, </author> <title> Correct Memory Operation of Cache-Based Multiprocessors, </title> <booktitle> Proc. 14th Int. Symp. Computer Architecture, </booktitle> <month> June </month> <year> 1987, </year> <pages> 234-243. 43 </pages>
Reference-contexts: Sequential consistency, and thus memory coherence, can be ensured in systems with caches by prohibiting pipelining of accesses to shared variables <ref> [ScD87] </ref>. Since pipelining is an important technique for reducing effective memory latency in multiprocessors, researchers have proposed enforcing a weaker form of sequential consistency allowing some pipelin-ing by relaxing ordering constraints between synchronization points [AdH90, DSB86].
Reference: [SiH91] <author> R. Simoni and M. Horowitz, </author> <title> Modeling the Performance of Limited Pointer Directories for Cache Coherence, </title> <booktitle> 18th ISCA, </booktitle> <year> 1991, </year> <pages> 309-318. </pages>
Reference-contexts: The focus of much of the subsequent work on directory protocols has been on improving the scalability of the directory representation <ref> [Aga88, ArB84, CKA91, GWM90, Jam90, LiY90, OKN90, SiH91, Ste89, ThD91] </ref>. Although reducing the space complexity of the directory representation is an important problem, our focus is different: on improving the scalability of cache coherence protocols by increasing their concurrency. <p> For simplicity, we assume the bit vector representation proposed by Censier and Feautrier [CeF78], but delta-cache protocols are compatible with the more scalable linked-list directory representation proposed for the Alewife machine [CKA91] or with the similar, hardware-supported representation discussed by Simoni and Horowitz <ref> [SiH91] </ref>. In addition to being classified as directory or snoopy protocols, hardware protocols are also classified as write-update or write-invalidate. A write-update protocol maintains coherence by keeping all copies of the same block up-to-date. Whenever any copy of a block is written, all copies of the block are updated.
Reference: [Ste89] <author> P. Stenstrom, </author> <title> A Cache Consistency Protocol for Multiprocessors with Multistage Networks, </title> <booktitle> Proc. 16th International Symp. Computer Architecture, </booktitle> <month> May </month> <year> 1989, </year> <pages> 407-415. </pages>
Reference-contexts: The focus of much of the subsequent work on directory protocols has been on improving the scalability of the directory representation <ref> [Aga88, ArB84, CKA91, GWM90, Jam90, LiY90, OKN90, SiH91, Ste89, ThD91] </ref>. Although reducing the space complexity of the directory representation is an important problem, our focus is different: on improving the scalability of cache coherence protocols by increasing their concurrency. <p> Because the invalidate policy cannot support multiple readers and writers, delta-cache protocols use the update policy. A disadvantage of the update policy is the cost of distributing cache updates. Several schemes to reduce this cost on equidistant networks <ref> [Ste89] </ref> are compatible with isotach networks. For simplicity, we assume each process executes on its own processor and each cache block contains exactly one variable. Thus we use the terms cache block and variable interchangeably.
Reference: [Ste90] <author> P. Stenstrom, </author> <title> A Survey of Cache Coherence Schemes for Multiprocessors, </title> <booktitle> Computer 23,6 (June 1990), </booktitle> <pages> 12-25. </pages>
Reference-contexts: As update protocols, delta-cache protocols attain the high concurrency of write-update protocols. As directory protocols, they avoid the limitations on scalability implied by broadcasting. Although the write-invalidate vs. write-update and snoopy vs. directory alternatives are in theory independent <ref> [Ste90] </ref>, write-update directory protocols are unusual. Snoopy protocols can be either write-invalidate (e.g., Goodman's write-once protocol [Goo86] and the Berkeley ownership protocol [Kat85]) or write-update (the DEC Firefly and Xerox Dragon protocols described by Archibald and Baer [ArB86]), but existing directory protocols are almost exclusively write-invalidate protocols.
Reference: [Tan76] <author> C. K. Tang, </author> <title> Cache Design in the Tightly Coupled Multiprocessor System, </title> <booktitle> AFIPS Conf. Preceedings National Computer Conference, </booktitle> <year> 1976, </year> <pages> 749-753. </pages>
Reference-contexts: The first directory protocol, due to Tang <ref> [Tan76] </ref>, specified a single centralized directory. Censier and Feautrier improved on this protocol by distributing the directory so that the directory for each block is located in the MM containing the memory copy of that block [CeF78].
Reference: [ThD91] <author> M. Thapar and B. Delagi, </author> <title> Scalable Cache Coherence for Large Shared Memory Multiprocessors, </title> <booktitle> Computer Architecture News 19,1 (March 1991), </booktitle> <pages> 114-119. </pages>
Reference-contexts: The focus of much of the subsequent work on directory protocols has been on improving the scalability of the directory representation <ref> [Aga88, ArB84, CKA91, GWM90, Jam90, LiY90, OKN90, SiH91, Ste89, ThD91] </ref>. Although reducing the space complexity of the directory representation is an important problem, our focus is different: on improving the scalability of cache coherence protocols by increasing their concurrency.
Reference: [WiR89] <author> C. Williams and P. F. Reynolds, Jr., </author> <title> On Variables as Access Sequences in Parallel Asynchronous Computations, </title> <type> Tech. Rep. 89-17, </type> <institution> University of Virginia, Department of Computer Science, </institution> <month> December, </month> <year> 1989. </year>
Reference-contexts: We originally proposed isotach networks to support a logically synchronous multicast [RWW89] and later proposed using the network as the basis for concurrency control in systems without caches <ref> [WiR89] </ref>. This paper extends our work to systems with caches. In a delta-cache protocol, each cache block is out of phase with memory and with other copies of the same block by a known number of pulses of logical time. <p> Finally, delta-cache protocols are compatible with techniques for executing atomic actions accessing multiple variables in different locations without operations on locks <ref> [WiR89] </ref>. To the extent other protocols support atomicity, they require writers to obtain exclusive access rights to the accessed block. This paper is organized as follows. <p> This correctness criterion is the basis for a simple proof of delta-cache protocols. Section 3 describes the iso-tach network. We defined the isotach network in other reports <ref> [RWW89, WiR89] </ref>. For completeness, we summarize the description here. Section 4 describes a general delta-cache protocol and two specific protocols based on different patterns for propagating updates. Section 5 concludes the paper with a discussion of ongoing and future work. 6 2. <p> Delta-cache protocols allow most operations to be pipelined and enforce the stronger, original form of sequential consistency. We view the cache coherence problem as just one aspect of the larger problem of controlling con-currency in parallel computations. In a previous paper <ref> [WiR89] </ref>, we considered the problem of con-currency control in systems without caches. We adapted the definition of serializability, the standard correctness criterion in database concurrency control [Pap86], to parallel programs and proposed serial-izability as the correctness criterion for concurrency control mechanisms for parallel programs. <p> Operations in an isochron must be issued as a batch, so operations with data dependencies cannot be executed in the same isochron. We have proposed techniques based on isochrons together with access sequences and split operations, defined below, to support a broad class of atomic actions <ref> [WiR89] </ref>. The techniques extend to systems with caches managed by delta-cache protocols. A major benefit of the techniques is that they do not require operations on locks. <p> This technique, called the scheduling isochron technique, works for atomic actions with access sets that can be determined at the beginning of execution of the atomic action. We have proposed variations on the technique for atomic actions with data dependent access sets <ref> [WiR89] </ref>. Both the scheduling isochron technique and the techniques for executing data dependent atomic actions extend to systems with caches. We describe here how to use the scheduling isochron technique with the late cache protocol. The technique can be similarly extended to other delta-cache protocols. <p> on a per block or per reference basis; extending the topologies on which delta-cache protocols are feasible; identifying more scalable directory representations compatible with the protocols; changing the migration algorithm so that it migrates the hot copy adaptively; extending the techniques for enforcing version consistency described in an earlier paper <ref> [WiR89] </ref> to systems with caches; and exploring the applicability of the protocols and migration algorithm to the related problem of implementing a virtual shared memory on a distributed memory machine [Li89]. 41

References-found: 47

