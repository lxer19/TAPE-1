URL: http://www.daimi.aau.dk/~tamtoft/Papers/LOMAPS14.ps.Z
Refering-URL: http://www.daimi.aau.dk/~tamtoft/papers.html
Root-URL: http://www.daimi.aau.dk
Email: e-mail:fhrnielson,fnielson,tamtoftg@daimi.aau.dk  
Title: Polymorphic Subtyping for Effect Analysis: the Static Semantics  
Author: Hanne Riis Nielson Flemming Nielson Torben Amtoft 
Address: Denmark  
Affiliation: Computer Science Department, Aarhus University,  
Abstract: The integration of polymorphism (in the style of the ML let-construct), subtyping, and effects (modelling assignment or communication) into one common type system has proved remarkably difficult. One line of research has succeeded in integrating polymorphism and sub-typing; adding effects in a straightforward way results in a semantically unsound system. Another line of research has succeeded in integrating polymorphism, effects, and subeffecting; adding subtyping in a straightforward way invalidates the construction of the inference algorithm. This paper integrates all of polymorphism, effects, and subtyping into an annotated type and effect system for Concurrent ML and shows that the resulting system is a conservative extension of the ML type system. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> T. Amtoft, F. Nielson, H.R. Nielson: </author> <title> Type and behaviour reconstruction for higher-order concurrent programs. </title> <note> To appear in Journal of Functional Programming, </note> <year> 1997. </year>
Reference-contexts: A more ambitious analysis is the approach of [15] to let annotated type and effect systems extract terms of a process algebra from programs with communication; this involves polymorphism and subeffecting but the algorithmic issues are non-trivial [12] (presumably because the inference system is expressed without using constraints); <ref> [1] </ref> presents an algorithm that is sound as well as complete, but which generates constraints that are not guaranteed to have best solutions. Finally we should mention [22] where effects are incorporated into ML types in order to deal with region inference. A step forward.
Reference: 2. <author> T. Amtoft, F. Nielson, H.R. Nielson, J. Ammann: </author> <title> Polymorphic subtypes for effect analysis: the dynamic semantics. </title> <booktitle> This volume of SLNCS, </booktitle> <year> 1997. </year>
Reference-contexts: Finally, we show that the system is a "conservative extension" of the usual type system for Standard ML. The formal demonstration of semantic soundness, as well as the construction of the inference algorithm, are dealt with in companion papers <ref> [2, 13] </ref>. 2 Inference System The fragment of Concurrent ML [17, 16] we have chosen for illustrating our approach has expressions (e 2 Exp) and constants (c 2 Con) given by the following syntax: e ::= c j x j fn x ) e j e 1 e 2 j let <p> Proof. See Appendix A. 2.5 Proof Normalisation It turns out that the proof of semantic soundness <ref> [2] </ref> is complicated by the presence of the non-syntax directed rules (sub), (gen) and (ins) of Figure 2. This motivates trying to normalise general inference trees into a more manageable shape 5 ; to this end we define the notions of "normalised" and "strongly nor-malised" inference trees.
Reference: 3. <author> L. Damas and R. Milner: </author> <title> Principal type-schemes for functional programs. </title> <booktitle> In Proc. of POPL '82. </booktitle> <publisher> ACM Press, </publisher> <year> 1982. </year>
Reference-contexts: State of the art. One of the pioneering papers in the area is [10] that developed the first polymorphic type inference and algorithm for the applicative fragment of ML; a shorter presentation for the typed -calculus with let is given in <ref> [3] </ref>. Since then many papers have studied how to integrate subtyping. A number of early papers did so by mainly focusing on the typed -calculus and only briefly dealing with let [11, 5]. Later papers have treated polymorphism in full generality [18, 8].
Reference: 4. <author> Y.-C. Fuh and P. Mishra: </author> <title> Polymorphic subtype inference: closing the theory-practice gap. </title> <booktitle> In Proc. TAPSOFT '89. </booktitle> <volume> SLNCS 352, </volume> <year> 1989. </year>
Reference-contexts: Later papers have treated polymorphism in full generality [18, 8]. A key ingredient in these approaches is the simplification of the enormous set of constraints into something manageable <ref> [4, 18] </ref>. Already ML necessitates an incorporation of imperative effects due to the presence of ref-types.
Reference: 5. <author> Y.-C. Fuh and P. Mishra: </author> <title> Type inference with subtypes. </title> <journal> Theoretical Computer Science, </journal> <volume> 73, </volume> <year> 1990. </year>
Reference-contexts: Since then many papers have studied how to integrate subtyping. A number of early papers did so by mainly focusing on the typed -calculus and only briefly dealing with let <ref> [11, 5] </ref>. Later papers have treated polymorphism in full generality [18, 8]. A key ingredient in these approaches is the simplification of the enormous set of constraints into something manageable [4, 18]. Already ML necessitates an incorporation of imperative effects due to the presence of ref-types.
Reference: 6. <author> F. Henglein: </author> <title> Type inference with polymorphic recursion. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 253-289, </pages> <year> 1993. </year>
Reference-contexts: The rule for conditional is unable to keep track of which branch is chosen, therefore an upper approximation of the branches is taken. We then have separate rules for subtyping, instantiation and generalisa-tion and we shall explain their side conditions shortly. 3 Even though this is undecidable in general <ref> [6] </ref> one might allow polymorphic recursion in the annotations as in [7] or [22]. (con) C; A ` c : TypeOf (c) & ; (id) C; A ` x : A (x) & ; C; A [x : t 1 ] ` e : t 2 & b (app) (C 1
Reference: 7. <author> F. Henglein and C. Mossin: </author> <title> Polymorphic binding-time analysis. </title> <booktitle> In Proc. ESOP '94, </booktitle> <pages> pages 287-301. </pages> <address> SLNCS 788, </address> <year> 1994. </year>
Reference-contexts: In the area of static program analysis, annotated type and effect systems have been used as the basis for control flow analysis [20] and binding time analysis <ref> [14, 7] </ref>. These papers typically make use of a polymorphic type system with subtyping and no effects, or a non-polymorphic type system with effects and subtyping. <p> We then have separate rules for subtyping, instantiation and generalisa-tion and we shall explain their side conditions shortly. 3 Even though this is undecidable in general [6] one might allow polymorphic recursion in the annotations as in <ref> [7] </ref> or [22]. (con) C; A ` c : TypeOf (c) & ; (id) C; A ` x : A (x) & ; C; A [x : t 1 ] ` e : t 2 & b (app) (C 1 [ C 2 ); A ` e 1 e 2 :
Reference: 8. <author> M.P. Jones: </author> <title> A theory of qualified types. </title> <booktitle> In Proc. ESOP '92, </booktitle> <pages> pages 287-306. </pages> <address> SLNCS 582, </address> <year> 1992. </year>
Reference-contexts: Since then many papers have studied how to integrate subtyping. A number of early papers did so by mainly focusing on the typed -calculus and only briefly dealing with let [11, 5]. Later papers have treated polymorphism in full generality <ref> [18, 8] </ref>. A key ingredient in these approaches is the simplification of the enormous set of constraints into something manageable [4, 18]. Already ML necessitates an incorporation of imperative effects due to the presence of ref-types. <p> This presents a major step forward in generalising the subeffecting approach of [19] and in admitting effects into the subtyping approaches of <ref> [18, 8] </ref>. The development is not only applicable to Concurrent ML (with communication) but also Standard ML (with references) and similar settings. The essence of Concurrent ML. <p> Finally 1 the type of fork indicates that the argument may have any behaviour whatsoever, in particular this means that e in fork (fn dummy ) e) may create new channels without this being recorded in the overall effect 2 . Following the approach of <ref> [18, 8] </ref> we will incorporate the effects of [19, 15] by defining a type inference system with judgements of the form C; A ` e : oe & b where C is a constraint set, A is an environment i.e. a list [x 1 : oe 1 ; ; x n <p> The overall structure of the type inference system of Figure 2 is very close to those of <ref> [18, 8] </ref> with a few components from [19, 15] thrown in; the novel ideas of our approach only show up as carefully constructed side conditions for some of the rules.
Reference: 9. <author> X. Leroy and P. Weis: </author> <title> Polymorphic type inference and assignment. </title> <booktitle> In Proc. POPL '91, </booktitle> <pages> pages 291-302. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: effects, that is the system employs subeffecting. - [19] can be considered a refinement of [23] in that effects also record the region in which a reference cell is created (or a read/write operation performed); this information enables one to "mask" effects which have taken place in "inaccessible" regions. - <ref> [9] </ref> presents a somewhat alternative view: here focus is not on detecting creation of reference cells but rather to detect their use; this means that if an identifier occurs free in a function closure then all variables in its type have to be "examined".
Reference: 10. <author> R. Milner: </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer Systems, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: This will facilitate modular proofs of correctness while at the same time allowing the inference algorithms to generate syntax-free constraints that can be solved efficiently. State of the art. One of the pioneering papers in the area is <ref> [10] </ref> that developed the first polymorphic type inference and algorithm for the applicative fragment of ML; a shorter presentation for the typed -calculus with let is given in [3]. Since then many papers have studied how to integrate subtyping.
Reference: 11. <author> J.C. Mitchell: </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(3), </volume> <year> 1991. </year>
Reference-contexts: Since then many papers have studied how to integrate subtyping. A number of early papers did so by mainly focusing on the typed -calculus and only briefly dealing with let <ref> [11, 5] </ref>. Later papers have treated polymorphism in full generality [18, 8]. A key ingredient in these approaches is the simplification of the enormous set of constraints into something manageable [4, 18]. Already ML necessitates an incorporation of imperative effects due to the presence of ref-types.
Reference: 12. <author> F. Nielson and H.R. Nielson: </author> <title> Constraints for polymorphic behaviours for Concur--rent ML. </title> <booktitle> In Proc. </booktitle> <address> CCL'94. SLNCS 845, </address> <year> 1994. </year>
Reference-contexts: A more ambitious analysis is the approach of [15] to let annotated type and effect systems extract terms of a process algebra from programs with communication; this involves polymorphism and subeffecting but the algorithmic issues are non-trivial <ref> [12] </ref> (presumably because the inference system is expressed without using constraints); [1] presents an algorithm that is sound as well as complete, but which generates constraints that are not guaranteed to have best solutions.
Reference: 13. <author> F. Nielson, H.R. Nielson, T. Amtoft: </author> <title> Polymorphic subtypes for effect analysis: the algorithm. </title> <booktitle> This volume of SLNCS, </booktitle> <year> 1997. </year>
Reference-contexts: Finally, we show that the system is a "conservative extension" of the usual type system for Standard ML. The formal demonstration of semantic soundness, as well as the construction of the inference algorithm, are dealt with in companion papers <ref> [2, 13] </ref>. 2 Inference System The fragment of Concurrent ML [17, 16] we have chosen for illustrating our approach has expressions (e 2 Exp) and constants (c 2 Con) given by the following syntax: e ::= c j x j fn x ) e j e 1 e 2 j let
Reference: 14. <author> H.R. Nielson and F. Nielson: </author> <title> Automatic binding analysis for a typed -calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 10 </volume> <pages> 139-176, </pages> <year> 1988. </year>
Reference-contexts: In the area of static program analysis, annotated type and effect systems have been used as the basis for control flow analysis [20] and binding time analysis <ref> [14, 7] </ref>. These papers typically make use of a polymorphic type system with subtyping and no effects, or a non-polymorphic type system with effects and subtyping.
Reference: 15. <author> H.R. Nielson and F. Nielson: </author> <title> Higher-order concurrent programs with finite communication topology. </title> <booktitle> In Proc. POPL'94, </booktitle> <pages> pages 84-97. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: These papers typically make use of a polymorphic type system with subtyping and no effects, or a non-polymorphic type system with effects and subtyping. A more ambitious analysis is the approach of <ref> [15] </ref> to let annotated type and effect systems extract terms of a process algebra from programs with communication; this involves polymorphism and subeffecting but the algorithmic issues are non-trivial [12] (presumably because the inference system is expressed without using constraints); [1] presents an algorithm that is sound as well as complete, <p> The role of the b-component is to express the dynamic effect that takes place when the function is applied or the delayed communication synchronised. Motivated by [19] and (a simplified version of) <ref> [15] </ref> the syntax of effects, or behaviours, (b 2 Beh) is given by: b ::= ft chang j fi j ; j b 1 [ b 2 Apart from the presence of behaviour variables (denoted fi) a behaviour can thus be viewed as a set of "atomic" behaviours each of form <p> Following the approach of [18, 8] we will incorporate the effects of <ref> [19, 15] </ref> by defining a type inference system with judgements of the form C; A ` e : oe & b where C is a constraint set, A is an environment i.e. a list [x 1 : oe 1 ; ; x n : oe n ] of typing assumptions for <p> The overall structure of the type inference system of Figure 2 is very close to those of [18, 8] with a few components from <ref> [19, 15] </ref> thrown in; the novel ideas of our approach only show up as carefully constructed side conditions for some of the rules. Concentrating on the "overall picture" we thus have rather straightforward axioms for constants and identifiers; here A (x) denotes the rightmost entry for x in A. <p> The system developed here includes no causality concerning the temporal order of effects; in the future we hope to incorporate aspects of the causality information for the communication structure of Concurrent ML <ref> [15] </ref>. Another (and harder) goal is to incorporate decidable fragments of polymorphic recursion. Finally, it should prove interesting to apply these ideas also to strongly typed languages with object-oriented features. Acknowledgement.
Reference: 16. <author> P. Panangaden and J.H. Reppy: </author> <title> The essence of Concurrent ML. In ML with Con-currency: Design, Analysis, Implementation and Application (editor: Flemming Nielson), </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Finally, we show that the system is a "conservative extension" of the usual type system for Standard ML. The formal demonstration of semantic soundness, as well as the construction of the inference algorithm, are dealt with in companion papers [2, 13]. 2 Inference System The fragment of Concurrent ML <ref> [17, 16] </ref> we have chosen for illustrating our approach has expressions (e 2 Exp) and constants (c 2 Con) given by the following syntax: e ::= c j x j fn x ) e j e 1 e 2 j let x = e 1 in e 2 j rec f
Reference: 17. <author> J.H. Reppy: </author> <title> Concurrent ML: Design, application and semantics. </title> <booktitle> In Proc. Functional Programming, Concurrency, Simulation and Automated Reasoning, </booktitle> <pages> pages 165-198. </pages> <address> SLNCS 693, </address> <year> 1993. </year>
Reference-contexts: Finally, we show that the system is a "conservative extension" of the usual type system for Standard ML. The formal demonstration of semantic soundness, as well as the construction of the inference algorithm, are dealt with in companion papers [2, 13]. 2 Inference System The fragment of Concurrent ML <ref> [17, 16] </ref> we have chosen for illustrating our approach has expressions (e 2 Exp) and constants (c 2 Con) given by the following syntax: e ::= c j x j fn x ) e j e 1 e 2 j let x = e 1 in e 2 j rec f <p> The non-sequential constructors are send and receive: rather than actually enabling a communication they create delayed communications which are first-class entities that can be passed around freely. This leads to a very powerful programming discipline (in particular in the presence of choose and wrap) as is discussed in <ref> [17] </ref>. The non-sequential base functions are channel for allocating new communication channels, fork for spawning new processes, and sync for synchronising delayed communications; examples of their use are given in the Introduction. Remark. We stated in the Introduction that our development is widely applicable. <p> Except for the presence of a b-component in t 1 ! b t 2 and t com b this is much the same type structure that is actually used in Concurrent ML <ref> [17] </ref>. The role of the b-component is to express the dynamic effect that takes place when the function is applied or the delayed communication synchronised.
Reference: 18. <author> G.S. Smith: </author> <title> Polymorphic inference with overloading and subtyping. </title> <booktitle> In SLNCS 668, Proc. TAPSOFT '93, </booktitle> <year> 1993. </year> <title> Also see: Principal Type Schemes for Functional Programs with Overloading and Subtyping: </title> <booktitle> Science of Computer Programming 23, </booktitle> <pages> pp. 197-226, </pages> <year> 1994. </year>
Reference-contexts: Since then many papers have studied how to integrate subtyping. A number of early papers did so by mainly focusing on the typed -calculus and only briefly dealing with let [11, 5]. Later papers have treated polymorphism in full generality <ref> [18, 8] </ref>. A key ingredient in these approaches is the simplification of the enormous set of constraints into something manageable [4, 18]. Already ML necessitates an incorporation of imperative effects due to the presence of ref-types. <p> Later papers have treated polymorphism in full generality [18, 8]. A key ingredient in these approaches is the simplification of the enormous set of constraints into something manageable <ref> [4, 18] </ref>. Already ML necessitates an incorporation of imperative effects due to the presence of ref-types. <p> This presents a major step forward in generalising the subeffecting approach of [19] and in admitting effects into the subtyping approaches of <ref> [18, 8] </ref>. The development is not only applicable to Concurrent ML (with communication) but also Standard ML (with references) and similar settings. The essence of Concurrent ML. <p> Finally 1 the type of fork indicates that the argument may have any behaviour whatsoever, in particular this means that e in fork (fn dummy ) e) may create new channels without this being recorded in the overall effect 2 . Following the approach of <ref> [18, 8] </ref> we will incorporate the effects of [19, 15] by defining a type inference system with judgements of the form C; A ` e : oe & b where C is a constraint set, A is an environment i.e. a list [x 1 : oe 1 ; ; x n <p> The overall structure of the type inference system of Figure 2 is very close to those of <ref> [18, 8] </ref> with a few components from [19, 15] thrown in; the novel ideas of our approach only show up as carefully constructed side conditions for some of the rules. <p> The type inference system. 2.2 Subtyping Rule (sub) generalises the subeffecting rule of [19] by incorporating subtyping and extends the subtyping rule of <ref> [18] </ref> to deal with effects. To do this we associate two kinds of judgements with a constraint set: the relations C ` b 1 b 2 and C ` t 1 t 2 are defined by the rules and axioms of Figure 3. <p> The identity substitution is denoted Id and we sometimes write Inv (S) = Dom (S) [ Ran (S) for the set of variables that are involved in the substitution S. Rule (ins) is much as in <ref> [18] </ref> and merely says that to take an instance of a type scheme we must ensure that the constraints are satisfied; this is expressed using the notion of solvability: Definition 1. <p> A type t is trivially solvable from C, and an environment A is solvable from C if for all x in Dom (A) it holds that A (x) is solvable from C. Except for the well-formedness requirement (explained later), rule (gen) seems close to the corresponding rule in <ref> [18] </ref>: clearly we cannot generalise over variables free in the global type assumptions or global constraint set, and as in effect systems (e.g. [19]) we cannot generalise over variables visible in the effect. Furthermore, as in [18] solvability is imposed to ensure that we do not create type schemes that have <p> the well-formedness requirement (explained later), rule (gen) seems close to the corresponding rule in <ref> [18] </ref>: clearly we cannot generalise over variables free in the global type assumptions or global constraint set, and as in effect systems (e.g. [19]) we cannot generalise over variables visible in the effect. Furthermore, as in [18] solvability is imposed to ensure that we do not create type schemes that have no instances; this condition ensures that the expressions let x = e 1 in e 2 and let x = e 1 in (x;e 2 ) are going to be equivalent in the type system.
Reference: 19. <author> J.P. Talpin and P. Jouvelot: </author> <title> The type and effect discipline. </title> <journal> Information and Computation, </journal> <volume> 111, </volume> <year> 1994. </year>
Reference-contexts: Effects may be approximated by larger effects, that is the system employs subeffecting. - <ref> [19] </ref> can be considered a refinement of [23] in that effects also record the region in which a reference cell is created (or a read/write operation performed); this information enables one to "mask" effects which have taken place in "inaccessible" regions. - [9] presents a somewhat alternative view: here focus is <p> This method is quite powerful but unfortunately it fails to be a conservative extension of ML (cf. Sect. 2.6): some purely applicative programs which are typeable in ML may be untypeable in this system. The surveys in <ref> [19, section 11] </ref> and in [23, section 5] show that many of these systems are incomparable, in the sense that for any two approaches it will often be the case that there are programs which are accepted by one of them but not by the other, and vice versa. <p> This presents a major step forward in generalising the subeffecting approach of <ref> [19] </ref> and in admitting effects into the subtyping approaches of [18, 8]. The development is not only applicable to Concurrent ML (with communication) but also Standard ML (with references) and similar settings. The essence of Concurrent ML. <p> id over a newly created channel. (To be able to execute one would need to fork a process that could read over the same channel.) This program is of interest because it will be rejected by a system using subeffecting only, whereas it will be accepted in the systems of <ref> [19] </ref> and [21]. We shall see that we will be able to type this program in our system as well! 2 2.1 Annotated Types To prepare for the type inference system we must clarify the syntax of types, effects, type schemes, and constraints. <p> The role of the b-component is to express the dynamic effect that takes place when the function is applied or the delayed communication synchronised. Motivated by <ref> [19] </ref> and (a simplified version of) [15] the syntax of effects, or behaviours, (b 2 Beh) is given by: b ::= ft chang j fi j ; j b 1 [ b 2 Apart from the presence of behaviour variables (denoted fi) a behaviour can thus be viewed as a set <p> Following the approach of [18, 8] we will incorporate the effects of <ref> [19, 15] </ref> by defining a type inference system with judgements of the form C; A ` e : oe & b where C is a constraint set, A is an environment i.e. a list [x 1 : oe 1 ; ; x n : oe n ] of typing assumptions for <p> The overall structure of the type inference system of Figure 2 is very close to those of [18, 8] with a few components from <ref> [19, 15] </ref> thrown in; the novel ideas of our approach only show up as carefully constructed side conditions for some of the rules. Concentrating on the "overall picture" we thus have rather straightforward axioms for constants and identifiers; here A (x) denotes the rightmost entry for x in A. <p> The type inference system. 2.2 Subtyping Rule (sub) generalises the subeffecting rule of <ref> [19] </ref> by incorporating subtyping and extends the subtyping rule of [18] to deal with effects. <p> Except for the well-formedness requirement (explained later), rule (gen) seems close to the corresponding rule in [18]: clearly we cannot generalise over variables free in the global type assumptions or global constraint set, and as in effect systems (e.g. <ref> [19] </ref>) we cannot generalise over variables visible in the effect. <p> be typed. (It is interesting to point out that if one changed the applied occurrence of f in the program to the expression fn z =&gt; f z then subeffecting would suffice for generalising over ff y and hence would allow to type the self-application of id.) The system of <ref> [19] </ref> does not have subtyping but nevertheless the application of id to itself is typeable [19, section 11, the case (id4 id4)]. <p> of f in the program to the expression fn z =&gt; f z then subeffecting would suffice for generalising over ff y and hence would allow to type the self-application of id.) The system of [19] does not have subtyping but nevertheless the application of id to itself is typeable <ref> [19, section 11, the case (id4 id4)] </ref>.
Reference: 20. <author> Y.-M. Tang: </author> <title> Control flow analysis by effect systems and abstract interpretation. </title> <type> PhD thesis, </type> <institution> Ecoles des Mines de Paris, </institution> <year> 1994. </year>
Reference-contexts: In the area of static program analysis, annotated type and effect systems have been used as the basis for control flow analysis <ref> [20] </ref> and binding time analysis [14, 7]. These papers typically make use of a polymorphic type system with subtyping and no effects, or a non-polymorphic type system with effects and subtyping.
Reference: 21. <author> M. Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89 </volume> <pages> 1-34, </pages> <year> 1990. </year>
Reference-contexts: A key ingredient in these approaches is the simplification of the enormous set of constraints into something manageable [4, 18]. Already ML necessitates an incorporation of imperative effects due to the presence of ref-types. A pioneering paper in the area is <ref> [21] </ref> that develops a distinction between imperative and applicative type variables: for creation of a reference cell we demand that its type contain imperative variables only; and one is not allowed to generalise over imperative variables unless the expression in question is non-expansive (i.e. does not expand the store) which will <p> The problem of typing ML with references (but without subtyping) has lead to a number of attempts to improve upon <ref> [21] </ref>; this includes the following: - [23] is similar in spirit to [21] in that one is not allowed to generalise over a type variable if a reference cell has been created with a type containing this variable; to trace such variables the type system is augmented with effects. <p> The problem of typing ML with references (but without subtyping) has lead to a number of attempts to improve upon <ref> [21] </ref>; this includes the following: - [23] is similar in spirit to [21] in that one is not allowed to generalise over a type variable if a reference cell has been created with a type containing this variable; to trace such variables the type system is augmented with effects. <p> a newly created channel. (To be able to execute one would need to fork a process that could read over the same channel.) This program is of interest because it will be rejected by a system using subeffecting only, whereas it will be accepted in the systems of [19] and <ref> [21] </ref>. We shall see that we will be able to type this program in our system as well! 2 2.1 Annotated Types To prepare for the type inference system we must clarify the syntax of types, effects, type schemes, and constraints. <p> Thus the two branches of the conditional can both be given type ff x ! ; ff x . Also in the approach of <ref> [21] </ref> one can generalise over ff y and hence type the self-application of id. <p> We refer to <ref> [21] </ref> for the details. 2 2.4 Properties of the Inference System We now list a few basic properties of the inference system that we shall use later. Fact 8. For all constants c of Figure 1, the type scheme TypeOf (c) is closed, well-formed and solvable from ;. Fact 9.
Reference: 22. <author> M. Tofte and L. Birkedal: </author> <title> Region-annotated types and type schemes, </title> <note> 1996. Submitted for publication. </note>
Reference-contexts: Finally we should mention <ref> [22] </ref> where effects are incorporated into ML types in order to deal with region inference. A step forward. In this paper we take an important step towards integrating polymorphism, subtyping, and effects into one common type system. <p> We then have separate rules for subtyping, instantiation and generalisa-tion and we shall explain their side conditions shortly. 3 Even though this is undecidable in general [6] one might allow polymorphic recursion in the annotations as in [7] or <ref> [22] </ref>. (con) C; A ` c : TypeOf (c) & ; (id) C; A ` x : A (x) & ; C; A [x : t 1 ] ` e : t 2 & b (app) (C 1 [ C 2 ); A ` e 1 e 2 : t 1
Reference: 23. <author> A.K. Wright: </author> <title> Typing references by effect inference. </title> <booktitle> In Proc. ESOP '92, </booktitle> <pages> pages 473-491. </pages> <address> SLNCS 582, </address> <year> 1992. </year>
Reference-contexts: The problem of typing ML with references (but without subtyping) has lead to a number of attempts to improve upon [21]; this includes the following: - <ref> [23] </ref> is similar in spirit to [21] in that one is not allowed to generalise over a type variable if a reference cell has been created with a type containing this variable; to trace such variables the type system is augmented with effects. <p> Effects may be approximated by larger effects, that is the system employs subeffecting. - [19] can be considered a refinement of <ref> [23] </ref> in that effects also record the region in which a reference cell is created (or a read/write operation performed); this information enables one to "mask" effects which have taken place in "inaccessible" regions. - [9] presents a somewhat alternative view: here focus is not on detecting creation of reference cells <p> This method is quite powerful but unfortunately it fails to be a conservative extension of ML (cf. Sect. 2.6): some purely applicative programs which are typeable in ML may be untypeable in this system. The surveys in [19, section 11] and in <ref> [23, section 5] </ref> show that many of these systems are incomparable, in the sense that for any two approaches it will often be the case that there are programs which are accepted by one of them but not by the other, and vice versa. <p> This then suffices for typing the application of id to itself. Now consider a system with subeffecting only (as in <ref> [23] </ref>): then for the type of f to match that of the locally defined function we have to give f the type ff x ! b ff x where b = fff y chang.
References-found: 23

