URL: http://www.cs.utoronto.ca/~cogrobo/constraint.ps.Z
Refering-URL: http://www.cs.utoronto.ca/~cogrobo/
Root-URL: 
Email: email: @ai.toronto.edu reiter@ai.toronto.edu  
Title: State Constraints Revisited  
Author: Fangzhen Lin and Ray Reiter 
Note: 1 To appear in the Journal of Logic and Computation. Special Issue on Actions and Processes. 1994. 2 Fellow of the Canadian Institute for Advanced Research  
Date: March 10, 1994  
Address: Toronto, Canada M5S 1A4  
Affiliation: Department of Computer Science University of Toronto  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Andrew B. Baker. </author> <title> Nonmonotonic reasoning in the framework of the situation calculus. </title> <journal> Artificial Intelligence, </journal> <volume> 49 </volume> <pages> 5-23, </pages> <year> 1991. </year>
Reference-contexts: Several solutions have been proposed in the literature (cf. Baker <ref> [1] </ref>, Lin and Shoham [11], and others.), most of them based on circumscription (McCarthy [13]). There seems to be a consensus that these different minimization semantics turn out to be equivalent for determinate actions (cf. Costello [3], Kartha [7]). This section defines precisely the minimization policy used in this paper.
Reference: [2] <author> Keith L. Clark. </author> <title> Negation as failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logics and Databases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: The assumption we need for solving this problem for this particular example is that every condition that prevents a robot from executing paint (x; y) is implied by the axioms. Thus in this case, we have, by simple predicate completion (Clark <ref> [2] </ref>): P oss (paint (x; y); s) nearby (x; s) ^ haspaint (y; s): (5) One might expect that formally, this can be done by minimizing :P oss, as in (Lifschitz [8]). Unfortunately, in the general case, the minimization is not straightforward, especially in the presence of the frame problem. <p> (8x 1 ; :::; x n ; s):P oss (A (x 1 ; :::; x n ); s) QC : Now, without loss of generality, suppose that the only necessary condition axiom for A in D nec is: Then we obtain the following action precondition axiom by predicate completion (Clark <ref> [2] </ref>) of P oss: P oss (A (x 1 ; :::; x n ); s) A ^ QC ; (22) where the big conjunction ranges over the state constraints in D qual . Let D pre be the set of action precondition axioms thus obtained.
Reference: [3] <author> Tom Costello. </author> <title> Solutions to the ramification problem. </title> <booktitle> In Working Papers for 2nd Symposium on Logical Formalizations of Commonsense Reasoning, </booktitle> <pages> pages 32-39, </pages> <address> Austin, Texas, </address> <year> 1993. </year>
Reference-contexts: Several solutions have been proposed in the literature (cf. Baker [1], Lin and Shoham [11], and others.), most of them based on circumscription (McCarthy [13]). There seems to be a consensus that these different minimization semantics turn out to be equivalent for determinate actions (cf. Costello <ref> [3] </ref>, Kartha [7]). This section defines precisely the minimization policy used in this paper. It is based on the one in (Lin and Shoham [11]). There are however some differences. First, in (Lin and Shoham [11]), the minimization is done with respect to a fixed action.
Reference: [4] <author> Jeff Finger. </author> <title> Exploiting Constraints in Design Synthesis. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Stanford University, Stanford, </institution> <address> CA, </address> <year> 1986. </year>
Reference-contexts: The same assumption is implicitly made in (Ginsberg and Smith [5]). The qualification problem gets complicated when not all axioms about P oss are explicitly given as in (2). Traditionally, state constraints are considered to yield indirect effects of actions, and are the sources of the ramification problem (Finger <ref> [4] </ref>). However, as we shall see, many state constraints are in fact implicit axioms 2 about P oss. These state constraints complicate the qualification problem in much the same way as indirect effects do for the frame problem. Imagine an ancient kingdom where yellow is reserved for the emperor.
Reference: [5] <author> Matthew L. Ginsberg and David E. Smith. </author> <title> Reasoning about action II: the qualification problem. </title> <journal> Artificial Intelligence, </journal> <volume> 35 </volume> <pages> 311-342, </pages> <year> 1988. </year>
Reference-contexts: Rather, they are implicit axioms about action preconditions. Such constraints relate to the qualification problem in much the same way as indirect effects do to the ramification problem. We later learned that the same observation had been made by Ginsberg and Smith <ref> [5] </ref>. We also discovered that other kinds of state constraints arise; these are related to the formalization of strategic or control information. This paper is devoted to describing our results along these lines, focusing on those constraints relevant to indirect effects and action preconditions. <p> In general, we shall assume that one first has to have the necessary frame axioms before one can compute P oss. We shall see the motivation behind this assumption later. The same assumption is implicitly made in (Ginsberg and Smith <ref> [5] </ref>). The qualification problem gets complicated when not all axioms about P oss are explicitly given as in (2). Traditionally, state constraints are considered to yield indirect effects of actions, and are the sources of the ramification problem (Finger [4]). <p> Moreover, reversing their roles leads to counterintuitive results. In the following, we shall call those indirect-effect yielding state constraints ramification constraints, and those yielding action preconditions qualification constraints. As in (Ginsberg and Smith <ref> [5] </ref>), we shall explicitly distinguish these two kinds of constraints. In summary, ramification constraints cause complications, traditionally called the ramification problem, to the frame problem. Qualification constraints cause a symmetric problem to the qualification problem. In the next section we present our version of the situation calculus. <p> This highlights the difference between our solution to the qualification problem and that of (Ginsberg and Smith <ref> [5] </ref>). In [5], action qualifications are never stored, and have to be computed each time an action is attempted. Finally, notice that the background axioms for Corollary 9 include D qual , the original qualification constraints relativised to states inaccessible from S 0 . <p> This highlights the difference between our solution to the qualification problem and that of (Ginsberg and Smith <ref> [5] </ref>). In [5], action qualifications are never stored, and have to be computed each time an action is attempted. Finally, notice that the background axioms for Corollary 9 include D qual , the original qualification constraints relativised to states inaccessible from S 0 . <p> There are several reasons why we don't want to list action preconditions explicitly: 1. This does not entirely eliminate the need for the constraints because we still have to check that the initial state satisfies the constraint (Corollary 9). 2. As Ginsberg and Smith argued in <ref> [5] </ref>, there are both computational and episte mological reasons why listing action preconditions explicitly won't work. 3. Generating preconditions from state constraints results in a modular and generic theory.
Reference: [6] <author> Cordell C. Green. </author> <title> Application of theorem proving to problem solving. </title> <booktitle> In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI-69), </booktitle> <pages> pages 219-239, </pages> <year> 1969. </year> <month> 26 </month>
Reference-contexts: For example, for AI planning applications, one is concerned with deriving entailments of the form (9s):S 0 s ^ G (s) where G (s) defines a goal state (Green <ref> [6] </ref>, Reiter [20]). In database applications (Reiter [21]), one is concerned with querying a database following an update transaction sequence T.
Reference: [7] <author> G. Neelakantan Kartha. </author> <title> Soundness and completeness theorems for three formal-izations of action. </title> <booktitle> In Working Papers for 2nd Symposium on Logical Formalizations of Commonsense Reasoning, </booktitle> <pages> pages 85-93, </pages> <address> Austin, Texas, </address> <year> 1993. </year>
Reference-contexts: Several solutions have been proposed in the literature (cf. Baker [1], Lin and Shoham [11], and others.), most of them based on circumscription (McCarthy [13]). There seems to be a consensus that these different minimization semantics turn out to be equivalent for determinate actions (cf. Costello [3], Kartha <ref> [7] </ref>). This section defines precisely the minimization policy used in this paper. It is based on the one in (Lin and Shoham [11]). There are however some differences. First, in (Lin and Shoham [11]), the minimization is done with respect to a fixed action.
Reference: [8] <author> Vladimir Lifschitz. </author> <title> Formal theories of action. </title> <booktitle> In Proceedings of the Tenth International Joint Conference on Artificial Intelligence (IJCAI-87), </booktitle> <pages> pages 966-972, </pages> <year> 1987. </year>
Reference-contexts: Thus in this case, we have, by simple predicate completion (Clark [2]): P oss (paint (x; y); s) nearby (x; s) ^ haspaint (y; s): (5) One might expect that formally, this can be done by minimizing :P oss, as in (Lifschitz <ref> [8] </ref>). Unfortunately, in the general case, the minimization is not straightforward, especially in the presence of the frame problem. In particular, which do we solve first: the frame problem or the qualification problem? The answer in [8] is that we should solve the qualification problem first. <p> expect that formally, this can be done by minimizing :P oss, as in (Lifschitz <ref> [8] </ref>). Unfortunately, in the general case, the minimization is not straightforward, especially in the presence of the frame problem. In particular, which do we solve first: the frame problem or the qualification problem? The answer in [8] is that we should solve the qualification problem first. However, if the axioms about P oss all have the form (2), which was implicitly assumed in [8], the order does not really matter. <p> In particular, which do we solve first: the frame problem or the qualification problem? The answer in <ref> [8] </ref> is that we should solve the qualification problem first. However, if the axioms about P oss all have the form (2), which was implicitly assumed in [8], the order does not really matter. In general, we shall assume that one first has to have the necessary frame axioms before one can compute P oss. We shall see the motivation behind this assumption later. The same assumption is implicitly made in (Ginsberg and Smith [5]).
Reference: [9] <author> Vladimir Lifschitz. </author> <title> Frames in the space of situations. </title> <journal> Artificial Intelligence, </journal> <volume> 46 </volume> <pages> 365-376, </pages> <year> 1990. </year>
Reference-contexts: To motivate our minimization policy, consider a language with a single action, and only two states: the initial one S i , and the resulting state after the action is performed S r (cf. Lifschitz <ref> [9, 10] </ref>). For every fluent F , we replace F by two predicates F i and F r .
Reference: [10] <author> Vladimir Lifschitz. </author> <title> Restricted monotonicity. </title> <booktitle> In Proceedings of the Eleventh National Conference on Artificial Intelligence (AAAI-93), </booktitle> <year> 1993. </year>
Reference-contexts: To motivate our minimization policy, consider a language with a single action, and only two states: the initial one S i , and the resulting state after the action is performed S r (cf. Lifschitz <ref> [9, 10] </ref>). For every fluent F , we replace F by two predicates F i and F r .
Reference: [11] <author> Fangzhen Lin and Yoav Shoham. </author> <title> Provably correct theories of action: Preliminary report. </title> <booktitle> In Proceedings of the Ninth National Conference on Artificial Intelligence (AAAI-91), </booktitle> <address> Anaheim, CA, </address> <year> 1991. </year>
Reference-contexts: Several solutions have been proposed in the literature (cf. Baker [1], Lin and Shoham <ref> [11] </ref>, and others.), most of them based on circumscription (McCarthy [13]). There seems to be a consensus that these different minimization semantics turn out to be equivalent for determinate actions (cf. Costello [3], Kartha [7]). This section defines precisely the minimization policy used in this paper. <p> There seems to be a consensus that these different minimization semantics turn out to be equivalent for determinate actions (cf. Costello [3], Kartha [7]). This section defines precisely the minimization policy used in this paper. It is based on the one in (Lin and Shoham <ref> [11] </ref>). There are however some differences. First, in (Lin and Shoham [11]), the minimization is done with respect to a fixed action. The minimization here is for all actions simultaneously. Secondly, the axioms 5 in (Lin and Shoham [11]) do not deal with P oss predicate. <p> Costello [3], Kartha [7]). This section defines precisely the minimization policy used in this paper. It is based on the one in (Lin and Shoham <ref> [11] </ref>). There are however some differences. First, in (Lin and Shoham [11]), the minimization is done with respect to a fixed action. The minimization here is for all actions simultaneously. Secondly, the axioms 5 in (Lin and Shoham [11]) do not deal with P oss predicate. <p> It is based on the one in (Lin and Shoham <ref> [11] </ref>). There are however some differences. First, in (Lin and Shoham [11]), the minimization is done with respect to a fixed action. The minimization here is for all actions simultaneously. Secondly, the axioms 5 in (Lin and Shoham [11]) do not deal with P oss predicate. Reflecting our decision to solve the frame problem first, our minimization policy shall fix P oss. <p> At this point, the given qualification constraints are discarded in favour of the action precondition axioms. We justified step 1 semantically by appealing to the minimization policy of (Lin and Shoham <ref> [11] </ref>). Step 2 we justified by simple Clark predicate completion.
Reference: [12] <editor> John McCarthy. </editor> <booktitle> Epistemological problems of Artificial Intelligence. In IJCAI-77, </booktitle> <pages> pages 1038-1044. </pages> <address> Cambridge, MA, </address> <year> 1977. </year>
Reference-contexts: Normally, no absolute guarantee will exist. For example, in order to do paint (x; y), the block x must be clear, the paint must not be frozen, etc. This dilemma is an instance of what has traditionally been called the qualification problem (McCarthy <ref> [12] </ref>). The assumption we need for solving this problem for this particular example is that every condition that prevents a robot from executing paint (x; y) is implied by the axioms.
Reference: [13] <author> John McCarthy. </author> <title> Applications of circumscription to formalizing commonsense knowledge. </title> <journal> Artificial Intelligence, </journal> <volume> 28 </volume> <pages> 89-118, </pages> <year> 1986. </year>
Reference-contexts: Several solutions have been proposed in the literature (cf. Baker [1], Lin and Shoham [11], and others.), most of them based on circumscription (McCarthy <ref> [13] </ref>). There seems to be a consensus that these different minimization semantics turn out to be equivalent for determinate actions (cf. Costello [3], Kartha [7]). This section defines precisely the minimization policy used in this paper. It is based on the one in (Lin and Shoham [11]).
Reference: [14] <author> John-Jules Ch. Meyer. </author> <title> A different approach to deontic logic: Deontic logic viewed as a variant of dynamic logic. </title> <journal> Notre Dame Journal of Formal Logic, </journal> <volume> 29 </volume> <pages> 109-136, </pages> <year> 1988. </year>
Reference: [15] <author> John-Jules Ch. Meyer, Hans Weigand, and Roel Wieringa. </author> <title> A specification language for static, dynamic and deontic integrity constraints. </title> <editor> In J. Demetrovics and B. Thalheim, editors, </editor> <booktitle> Proceedings of 2nd Symposium on Mathematical Fundamentals of Data-base systems, </booktitle> <pages> pages 347-366, </pages> <year> 1989. </year> <note> LNCS 364. </note>
Reference: [16] <author> Edwin P.D. Pednault. </author> <title> Synthesizing plans that contain actions with context-dependent effects. </title> <journal> Computational Intelligence, </journal> <volume> 4 </volume> <pages> 356-372, </pages> <year> 1988. </year>
Reference-contexts: Having explicit successor state axioms is desirable for two reasons. First, as shown by Reiter [20], successor state axioms are computationally appealing in that they allow regression (Waldinger [25], Pednault <ref> [16] </ref>, and others), a property we shall shortly exploit. Secondly, it is clear that having a set of successor state axioms completely formalizes the effects of actions on the fluents. <p> To formulate the lemma, we first require the concept of the regression of a formula : R D ss [], the regression of under the set of successor state axioms D ss (cf. Waldinger [25], Pednault <ref> [16] </ref>, and Reiter [20]), is the result of substituting F (t 1 ; :::; t n ; ff; ) for every subformula F (t 1 ; :::; t n ; do (ff; )) mentioned by , where this substitution is performed for every fluent F mentioned by .
Reference: [17] <author> Javier Pinto. </author> <title> Temporal Reasoning in the Situation Calculus. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Toronto, Toronto, Canada, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: In this case, if D ss are the corresponding successor state axioms, then the equivalent monotonic theory is [ D una [ D ss [ D ram : Clearly, this procedure is not guaranteed to terminate. Pinto <ref> [17] </ref> studies some simple classes of state constraints for which a set of successor state axioms can be effectively computed. Here, we shall only consider some examples.
Reference: [18] <author> Javier Pinto and Raymond Reiter. </author> <title> Extending the situation calculus with event occurrences. </title> <booktitle> In Second Symposium on Logical Formalizations of Commonsense Reasoning, </booktitle> <year> 1993. </year>
Reference-contexts: If S 2 S, and A 2 A, then do (A; S) 2 S, where A is the domain of actions in the model. That is, is categorical for the sort situation. These axioms have their origin in (Reiter [19, 22]). Similar axioms are used in (Pinto and Reiter <ref> [18] </ref>). The following proposition summarizes some simple consequences of . All proofs are given in the appendix.
Reference: [19] <author> Raymond Reiter. </author> <title> A simple solution to the frame problem (sometimes). </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Toronto. </institution> <note> In preparation. </note>
Reference-contexts: S 0 2 S. 2. If S 2 S, and A 2 A, then do (A; S) 2 S, where A is the domain of actions in the model. That is, is categorical for the sort situation. These axioms have their origin in (Reiter <ref> [19, 22] </ref>). Similar axioms are used in (Pinto and Reiter [18]). The following proposition summarizes some simple consequences of . All proofs are given in the appendix.
Reference: [20] <author> Raymond Reiter. </author> <title> The frame problem in the situation calculus: a simple solution (sometimes) and a completeness result for goal regression. </title> <editor> In Vladimir Lifschitz, editor, </editor> <booktitle> Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <pages> pages 418-420. </pages> <publisher> Academic Press, </publisher> <address> San Diego, CA, </address> <year> 1991. </year>
Reference-contexts: motivated syntactic procedure which, given [ D una [ D ram [ D ef , computes a certain monotonic theory and we show that, under suitable circumstances, this monotonic theory is logically equivalent to the above minimal model nonmonotonic theory. 5 How to Compute Successor State Axioms (Some times) In <ref> [20] </ref> Reiter shows how to address the frame problem in the absence of state constraints. The idea there was to use the given effect axioms to compute a set of explanation closure axioms (Schubert [23]). <p> These have a particularly simple and computationally useful form, as we shall describe below. In other words, when all the effect axioms are in hand, <ref> [20] </ref> provides a conceptually and computationally simple solution to the frame problem. Unfortunately, this solution to the frame problem no longer applies in the presence of ramification state constraints. <p> This is the intuition behind the approach to the frame problem of this section. Given an axiomatization [ D una [ D ram [ D ef as described above, our task is to generate a successor state axiom (Reiter <ref> [20] </ref>) for each fluent F (x 1 ; :::; x n ; s): P oss (a; s) F (x 1 ; :::; x n ; do (a; s)) F ; (14) where F is a simple state formula whose free variables are among s; a; x 1 ; :::; x n <p> Having explicit successor state axioms is desirable for two reasons. First, as shown by Reiter <ref> [20] </ref>, successor state axioms are computationally appealing in that they allow regression (Waldinger [25], Pednault [16], and others), a property we shall shortly exploit. Secondly, it is clear that having a set of successor state axioms completely formalizes the effects of actions on the fluents. <p> we find a single negative effect axiom for F : [ D una [ D ef [ D ram j= Now if F ( :F ) is indeed the most general condition under which F will be true (false) in situation do (a; s), then the argument given in (Reiter <ref> [20] </ref>) yields the following successor state axiom for F : P oss (a; s) F (x 1 ; :::; x n ; do (a; s)) [ F _ (F (x 1 ; :::; x n ; s) ^ : :F )]: But how are we to know when we have determined <p> Suppose further that: 1. The following consistency condition (Reiter <ref> [20] </ref>) holds for each F : D una j= (8s; a; x 1 ; :::; x n ):( F ^ :F ): (18) 2. <p> For example, for AI planning applications, one is concerned with deriving entailments of the form (9s):S 0 s ^ G (s) where G (s) defines a goal state (Green [6], Reiter <ref> [20] </ref>). In database applications (Reiter [21]), one is concerned with querying a database following an update transaction sequence T. <p> First, we treat an important special case. If D ram = ;, then the elementary syntactic manipulations in (Reiter <ref> [20] </ref>) are provably correct with respect to our minimal model semantics: 3 Corollary 4 [Correctness of Successor State Axioms in the Absence of State Constraints (Reiter [20])] Suppose D ram = ;, and without loss of generality, for each fluent F , suppose that D ef contains exactly one positive effect <p> First, we treat an important special case. If D ram = ;, then the elementary syntactic manipulations in (Reiter <ref> [20] </ref>) are provably correct with respect to our minimal model semantics: 3 Corollary 4 [Correctness of Successor State Axioms in the Absence of State Constraints (Reiter [20])] Suppose D ram = ;, and without loss of generality, for each fluent F , suppose that D ef contains exactly one positive effect axiom for F as given by (15), and exactly one negative effect axiom for F as given by (16). <p> Then the successor state axiom defined in (Reiter <ref> [20] </ref>) for F is exactly (17). <p> To formulate the lemma, we first require the concept of the regression of a formula : R D ss [], the regression of under the set of successor state axioms D ss (cf. Waldinger [25], Pednault [16], and Reiter <ref> [20] </ref>), is the result of substituting F (t 1 ; :::; t n ; ff; ) for every subformula F (t 1 ; :::; t n ; do (ff; )) mentioned by , where this substitution is performed for every fluent F mentioned by . <p> First determine, using the given effect axioms and ramification constraints, a set of successor state axioms. This is done by computing a set of new effect axioms using the old ones and the constraints, then completing the resulting set of effect axioms using the method of (Reiter <ref> [20] </ref>). There is a sufficient condition (Theorem 3) for determining when enough new effect axioms have been determined. At this point, the given ramification constraints are discarded in favour of the successor state axioms. 19 2. <p> Suppose further that: 22 1. The following consistency condition (Reiter <ref> [20] </ref>) holds for each F : D una j= (8s; a; x 1 ; :::; x n ):( F ^ :F ): (25) 2.
Reference: [21] <author> Raymond Reiter. </author> <title> On specifying database updates. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1992. </year> <month> KRR-TR-92-3. </month>
Reference-contexts: For example, for AI planning applications, one is concerned with deriving entailments of the form (9s):S 0 s ^ G (s) where G (s) defines a goal state (Green [6], Reiter [20]). In database applications (Reiter <ref> [21] </ref>), one is concerned with querying a database following an update transaction sequence T. <p> Normally, the state do (T; S 0 ) will be known to be accessible from S 0 , which is to say, the preconditions for "executing" the transaction sequence T will be known to be true (Reiter <ref> [21] </ref> calls such states legal states). For both these settings (planning problems, database query eval uation), the entailments of interest are relativised only to situations accessible from S 0 . <p> These are what are called static integrity constraints in database theory. (See (Reiter <ref> [21] </ref>) for a situation calculus treatment of database updates.) It is particularly interesting that other kinds of formulas can also be used to constrain action preconditions.
Reference: [22] <author> Raymond Reiter. </author> <title> Proving properties of states in the situation calculus. </title> <journal> Artificial Intelligence, </journal> <volume> 64 </volume> <pages> 337-351, </pages> <year> 1993. </year>
Reference-contexts: The last axiom is second order induction. It amounts to the domain closure axiom that every situation has to be obtained from the initial one by repeatly applying the function do. For a discussion of the use of induction in the situation calculus, see (Reiter <ref> [22] </ref>). In reality, an action is not always executable in every situation. To formalize this, we use a binary predicate P oss (a; s). We write s &lt; s 0 if s 0 can be obtained from s by a sequence of executable actions. <p> S 0 2 S. 2. If S 2 S, and A 2 A, then do (A; S) 2 S, where A is the domain of actions in the model. That is, is categorical for the sort situation. These axioms have their origin in (Reiter <ref> [19, 22] </ref>). Similar axioms are used in (Pinto and Reiter [18]). The following proposition summarizes some simple consequences of . All proofs are given in the appendix. <p> Here, we shall only consider some examples. Before doing so, we prove a lemma to facilitate the proof of condition (19), which will normally require induction on situations (Reiter <ref> [22] </ref>), using Proposition 1. The lemma we are about to present "precomputes" the induction proof, reducing the theorem proving task (19) to a very simple entailment using only unique names axioms for actions.
Reference: [23] <author> Len K. Schubert. </author> <title> Monotonic solution to the frame problem in the situation calculus: an efficient method for worlds with fully specified actions. In H.E. </title> <editor> Kyberg, R.P. Loui, and G.N. Carlson, editors, </editor> <booktitle> Knowledge Representation and Defeasible Reasoning, </booktitle> <pages> pages 23-67. </pages> <publisher> Kluwer Academic Press, </publisher> <address> Boston, MA, </address> <year> 1990. </year>
Reference-contexts: The idea there was to use the given effect axioms to compute a set of explanation closure axioms (Schubert <ref> [23] </ref>). On the assumption that the given effect axioms completely describe the causal laws of the domain being axiomatized, these explanation closure axioms can be seen intuitively to have the force of frame axioms.
Reference: [24] <author> Steven Shapiro. </author> <title> First-Order Solutions to the Frame Problem. M.Sc. </title> <type> thesis, </type> <institution> Department of Computer Science, University of Toronto, Toronto, Canada, </institution> <year> 1993. </year>
Reference-contexts: For instance, if we have the following successor state axiom: P oss (a; s) [F (do (a; s)) (:F (s) ^ a = f lip) _ (F (s) ^ a 6= f lip)]; 3 This was shown independently for propositional fluents by Steven Shapiro <ref> [24] </ref>. 11 then the regression of F (do (flip; S 0 )) is (:F (S 0 ) ^ f lip = f lip) _ (F (S 0 ) ^ f lip 6= f lip); and the regression of (8s)(9a):F (s) :F (do (a; s)) is (8s)(9a):F (s) :[(:F (s) ^ a
Reference: [25] <author> Richard Waldinger. </author> <title> Achieving several goals simultaneously. </title> <editor> In E. Elcock and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <pages> pages 94-136. </pages> <publisher> Ellis Horwood, </publisher> <address> Edin-burgh, Scotland, </address> <year> 1977. </year> <month> 28 </month>
Reference-contexts: Having explicit successor state axioms is desirable for two reasons. First, as shown by Reiter [20], successor state axioms are computationally appealing in that they allow regression (Waldinger <ref> [25] </ref>, Pednault [16], and others), a property we shall shortly exploit. Secondly, it is clear that having a set of successor state axioms completely formalizes the effects of actions on the fluents. <p> To formulate the lemma, we first require the concept of the regression of a formula : R D ss [], the regression of under the set of successor state axioms D ss (cf. Waldinger <ref> [25] </ref>, Pednault [16], and Reiter [20]), is the result of substituting F (t 1 ; :::; t n ; ff; ) for every subformula F (t 1 ; :::; t n ; do (ff; )) mentioned by , where this substitution is performed for every fluent F mentioned by .
References-found: 25

