URL: ftp://ftp.cs.washington.edu/tr/1993/12/UW-CSE-93-12-08.PS.Z
Refering-URL: http://www.cs.washington.edu/research/compiler/papers.d/dylink.html
Root-URL: 
Title: Faster Dynamic Linking for SPARC V8 and System V.4 worth retuning dynamic linker implementations. This
Author: David Keppel and Stephen Russell 
Note: tors make it  
Date: 93-12-08  
Affiliation: University of Washington  
Pubnum: Technical Report  
Abstract: off of a register. In the best case, the overhead of calling a dynamically linked instruction is reduced from four instructions with a register indirect to a single instruction and no register indirect. The paper also discusses issues and techniques that may be useful for other systems that perform dynamic using similar techniques. This note also briefly considers dynamic relinking. 
Abstract-found: 1
Intro-found: 1
Reference: [CAK + 81] <author> D. D. Chamberlin, M. M. Astrahan, W. F. King, R. Alorie, J. W. Mehl, T. G. Price, M. Schkolnick, P. Grif-fiths Selinger, D. R. Slutz, B. W. Wade, and R. A. Yost. </author> <title> Support for Repetitive Transactions and Ad Hoc Queries in System R. </title> <journal> ACM Transactions on Databse Systems, </journal> <volume> 6(1) </volume> <pages> 70-94, </pages> <month> March </month> <year> 1981. </year>
Reference-contexts: that a running program can delete outdated versions of code and replace them with Please address correspondence to the first author at the University of Washington, Department of CS&E, FR-35; Seattle, Washington 98195. new versions [SF89]; and so that user commands can be translated to native code and executed efficiently <ref> [CAK + 81, SR85, Hol87, NG87] </ref>. Dynamic linking is implemented many ways. Here, we are concerned with the case where a programmer writes a caller that makes use of a called routine. The compiler does not produce a direct call to the called routine.
Reference: [GLDW87] <author> Robert A. Gingell, Meng Lee, Xuong T. Dang, and Mary S. Weeks. </author> <title> Shared Libraries in SunOS. </title> <booktitle> Summer USENIX, </booktitle> <pages> pages 131-145, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Dynamic linking <ref> [GLDW87, Sab90, See90, HO91] </ref> introduces new code in to a running program.
Reference: [HO91] <author> W. Wilson Ho and Rondald A Ols-son. </author> <title> An Approach to Genuine Dynamic Linking. </title> <journal> Software-Practice and Experience, </journal> <volume> 21(4) </volume> <pages> 375-390, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Dynamic linking <ref> [GLDW87, Sab90, See90, HO91] </ref> introduces new code in to a running program.
Reference: [Hol87] <author> Gerard J. Holzmann. </author> <title> PICO A Picture Editor. </title> <journal> AT&T Technical Journal, </journal> <volume> 66(2) </volume> <pages> 2-13, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: that a running program can delete outdated versions of code and replace them with Please address correspondence to the first author at the University of Washington, Department of CS&E, FR-35; Seattle, Washington 98195. new versions [SF89]; and so that user commands can be translated to native code and executed efficiently <ref> [CAK + 81, SR85, Hol87, NG87] </ref>. Dynamic linking is implemented many ways. Here, we are concerned with the case where a programmer writes a caller that makes use of a called routine. The compiler does not produce a direct call to the called routine.
Reference: [KK92] <author> James Kempf and Peter B. Kessler. </author> <title> Cross-Address Space Dynamic Linking. </title> <booktitle> IEEE Proceedings of the International Workshop on Objeect-Orientation in Operating Systems (IWOOOS), </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: The DLT is a fixed distance from the application's call instruction. 2 There is one DLT entry for each function that can be dynamically linked. Logically, each dynamically-linkable function is as 1 Systems can sometimes arrange to have a dynamically-linked image shared among processes that use the same linkages <ref> [KK92, NH93] </ref>. 2 Some other systems use a fixed offset from a base register that points to the data segment. signed a number i and calls to routine i jump to the i'th DLT entry.
Reference: [NG87] <author> David Notkin and William G. Gris-wold. </author> <title> Enhancement through Extension: The Extension Interpreter. </title> <booktitle> Pro-cedings of the ACM SIGPLAN '87 Symposium on Interpreters and Interpretive Techniques, </booktitle> <pages> pages 45-55, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: that a running program can delete outdated versions of code and replace them with Please address correspondence to the first author at the University of Washington, Department of CS&E, FR-35; Seattle, Washington 98195. new versions [SF89]; and so that user commands can be translated to native code and executed efficiently <ref> [CAK + 81, SR85, Hol87, NG87] </ref>. Dynamic linking is implemented many ways. Here, we are concerned with the case where a programmer writes a caller that makes use of a called routine. The compiler does not produce a direct call to the called routine.
Reference: [NH93] <author> Michael N. Nelson and Graham Hamil-ton. </author> <title> Higher Performance Dynamic Linking Through Caching. </title> <type> Technical Report TR-93-15, </type> <institution> Sun Micorsystems Laboratories Inc., </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: The DLT is a fixed distance from the application's call instruction. 2 There is one DLT entry for each function that can be dynamically linked. Logically, each dynamically-linkable function is as 1 Systems can sometimes arrange to have a dynamically-linked image shared among processes that use the same linkages <ref> [KK92, NH93] </ref>. 2 Some other systems use a fixed offset from a base register that points to the data segment. signed a number i and calls to routine i jump to the i'th DLT entry.
Reference: [Sab90] <editor> Marc Sabatella. </editor> <booktitle> Issues in Shared Libraries Design. USENIX Summer Conference Proceedings, </booktitle> <pages> pages 11-23, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Dynamic linking <ref> [GLDW87, Sab90, See90, HO91] </ref> introduces new code in to a running program.
Reference: [See90] <author> Donn Seeley. </author> <title> Shared Libraries as Objects. </title> <booktitle> USENIX Summer Conference Proceedings, </booktitle> <pages> pages 25-37, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Dynamic linking <ref> [GLDW87, Sab90, See90, HO91] </ref> introduces new code in to a running program.
Reference: [SF89] <author> M. E. Segal and O. Frieder. </author> <title> Dynamic Program Updating: A Software Maintenance Technique for Minimizing Software Downtime. Software Maintenance: </title> <journal> Research and Practice, </journal> <volume> 1 </volume> <pages> 59-79, </pages> <year> 1989. </year>
Reference-contexts: library; so that an application will get a library specific to the machine [Sys90]; so that a running program can delete outdated versions of code and replace them with Please address correspondence to the first author at the University of Washington, Department of CS&E, FR-35; Seattle, Washington 98195. new versions <ref> [SF89] </ref>; and so that user commands can be translated to native code and executed efficiently [CAK + 81, SR85, Hol87, NG87]. Dynamic linking is implemented many ways. Here, we are concerned with the case where a programmer writes a caller that makes use of a called routine. <p> is needed, however, since the call to the first instruction can be in range of the branch, while the second instruction might be out of range. 4 Relinking In some circumstances, it is useful to be able to unlink dynamically-linked code and link in a new version of that code <ref> [SF89] </ref>, or move the existing code to e.g., reduce cache conflicts. This dynamic change of the linkage bindings is called relinking. An "obvious" way to implement relinking is to first unlink the old version, then use the existing dynamic linker mechanism to link to the new code.
Reference: [SPA90] <institution> System V Application Binary Interface SPARC Processor Supplement. Prentice-Hall, </institution> <year> 1990. </year>
Reference-contexts: System V.4 [Sys90] running on SPARC V8 [SPA91] processors uses a code table <ref> [SPA90] </ref>. The call overhead is typically low with today's applications and processors. However the overhead may grow as dynamic linking is used more widely and as processor architectures are more deeply pipelined and perform more speculative execution. <p> The remaining words make up the DLT entries. Each DLT entry is initialized with code that loads a register with an entry number and transfers to the start of segment. A typical DLT entry is <ref> [SPA90] </ref>: sethi .-DLT, %g1 // Function number ba,a DLT // Call dynamic linker nop Suppose that this DLT entry corresponds to the routine foo. The dynamic linker maps foo in to memory and initializes foo's DLT as above. <p> Moreover, calls to dynamically-linked code have worse cache locality because only three of the four table entries are used frequently. Larger DLT entries thus cause cache fragmentation. 3 3 A further problem is that the SPARC ABI allows at most 3 words per DLT entry <ref> [SPA90] </ref>. 3.3 Variation 3 Compacting Using the cache space/fragmentation observation noted in the preceding section, we would like to make each DLT entry smaller. We can do so if the jmpl in each entry is followed by the sethi of the following dynamic link table entry.
Reference: [SPA91] <institution> The SPARC Architecture Manual Version 8. Technical Report Sun Microsys-tems Part Number 800-1399-12, Sun Microsystems, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: In contrast, using an address table either forces all calls to transfer via the indirect table, or requires linker support so that calls to statically-linked routines can use a fast calling sequence, while dynamically-linked calls can indirect via the address table. System V.4 [Sys90] running on SPARC V8 <ref> [SPA91] </ref> processors uses a code table [SPA90]. The call overhead is typically low with today's applications and processors. However the overhead may grow as dynamic linking is used more widely and as processor architectures are more deeply pipelined and perform more speculative execution.
Reference: [SR85] <author> Michael Stonebraker and Lawrence A. Rowe. </author> <title> The Design of POSTGRES. </title> <type> Technical Report Memoradum No. </type> <institution> UCB/ERL 85/95, Electronics Research Laboratory, University of California, Berkeley, </institution> <month> 15 November </month> <year> 1985. </year>
Reference-contexts: that a running program can delete outdated versions of code and replace them with Please address correspondence to the first author at the University of Washington, Department of CS&E, FR-35; Seattle, Washington 98195. new versions [SF89]; and so that user commands can be translated to native code and executed efficiently <ref> [CAK + 81, SR85, Hol87, NG87] </ref>. Dynamic linking is implemented many ways. Here, we are concerned with the case where a programmer writes a caller that makes use of a called routine. The compiler does not produce a direct call to the called routine.
Reference: [Sys90] <institution> System V Application Binary Interface. Prentice-Hall, </institution> <year> 1990. </year>
Reference-contexts: It is used for a number of reasons: to re duce the disk space needed to store a compiled program; so that each time a program is run it will get the latest version of some library; so that an application will get a library specific to the machine <ref> [Sys90] </ref>; so that a running program can delete outdated versions of code and replace them with Please address correspondence to the first author at the University of Washington, Department of CS&E, FR-35; Seattle, Washington 98195. new versions [SF89]; and so that user commands can be translated to native code and executed <p> In contrast, using an address table either forces all calls to transfer via the indirect table, or requires linker support so that calls to statically-linked routines can use a fast calling sequence, while dynamically-linked calls can indirect via the address table. System V.4 <ref> [Sys90] </ref> running on SPARC V8 [SPA91] processors uses a code table [SPA90]. The call overhead is typically low with today's applications and processors. However the overhead may grow as dynamic linking is used more widely and as processor architectures are more deeply pipelined and perform more speculative execution.
References-found: 14

