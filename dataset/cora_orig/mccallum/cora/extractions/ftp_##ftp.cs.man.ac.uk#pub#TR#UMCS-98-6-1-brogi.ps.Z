URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-brogi.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Title: The use of renaming in composing general programs  
Author: Antonio Brogi, Simone Contiero, Franco Turini 
Keyword: Composition, reuse, transformation.  
Address: Corso Italia 40, 56125 Pisa, Italy  
Affiliation: Dipartimento di Informatica, Universita di Pisa  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K. R. Apt. </author> <title> Logic programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 493-574. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year> <title> Vol. </title> <publisher> B. </publisher>
Reference-contexts: A renaming substitution is defined as a set of pairs fp 0 1 =p 1 ; :::; p 0 h =p h g where fp 1 ; :::; p h g and fp 0 h g are disjoint sets of predicate symbols. Moreover: 8i; j 2 <ref> [1; h] </ref> : (i 6= j =) p i 6= p j ). <p> Consider for instance the programs: P: Q: Likes (x,y) &lt;- : Bitter (y). Likes (Bob,y) &lt;- Sour (y). Hates (x,y) &lt;- Sour (y). 1 We shall use the standard terminology and notation of logic programming <ref> [1] </ref>. A literal is an atom or its negation, and a (general) query is a finite conjunction of literals. A general clause is a clause of the form A L where A is an atom and L is a query. A general program is a finite set of general clauses.
Reference: [2] <author> K. R. Apt and R. Bol. </author> <title> Logic Programming and Negation: A Survey. </title> <journal> Journal of Logic Programming, </journal> <volume> 19-20:9-71, </volume> <year> 1994. </year>
Reference-contexts: A general clause is a clause of the form A L where A is an atom and L is a query. A general program is a finite set of general clauses. Following <ref> [2] </ref>, we consider a universal language in which all programs and queries are written, and we denote by ground (P ) the fully instantiated version of program P . 2 The set of predicate symbols occurring in a program expression E is defined as the set of predicate symbols occurring in
Reference: [3] <author> J. A. Bergstra, J. Heering, and P. Klint. </author> <title> Module Algebra. </title> <journal> Journal of the ACM, </journal> <volume> 37(2) </volume> <pages> 335-372, </pages> <year> 1990. </year>
Reference-contexts: Adopting an algebraic approach for defining the semantics of module and module compositions, Bergstra et al. <ref> [3] </ref> introduced a renaming operator for combining different signatures. However, the kind of renaming they proposed is "permutative", that is, if a is replaced by b, then b is replaced by a.
Reference: [4] <author> A. Brogi, S. Contiero, and F. Turini. </author> <title> Composing General Logic Programs. </title> <editor> In J. Dix, U. Furbach, and A. Nerode, editors, </editor> <booktitle> Proceedings of LPNMR'97, number 1265 in LNAI, </booktitle> <pages> pages 273-288. </pages> <publisher> Springer Verlag, </publisher> <year> 1997. </year>
Reference-contexts: More precisely, we choose logic-based programming for specifying the components and a set of meta-level composition operations on logic programs as the gluing (part of the) meta-language. In previous work <ref> [4, 5] </ref> we have shown the use of a basic set of meta-level operations on logic programs for mastering the complexity of designing complex systems. <p> To analyse the importance of renaming for component-based programming, we will consider renaming as a basic meta-level operation on components, and formally define its meaning as a program transformation operation. More precisely, we will introduce the renaming operator in the context of the family of composition operations presented in <ref> [4] </ref>, and we shall focus our discussion on some examples to illustrate the expressive power of renaming. <p> The same consideration applies to compositions of general programs, where in addition the orthogonal aspects of compositionality and non-monotonicity must be reconciled. A compositional semantics for general program expressions containing [, " and OE operations has been defined in <ref> [4] </ref> in terms of three-valued logic. Fitting [8] proposed to use a three-valued logic [11] to formalise the meaning of general programs. Three-valued logic models the idea that a query can yield three possible outcomes: success, failure, and divergence. <p> A compositional semantics for program expressions has been defined in <ref> [4] </ref> by inductively extending the definition of so that its first argument is an arbitrary general program expression. <p> More precisely, each program expression E is -equivalent to the transformed general program o (E), as stated by the following proposition. Proposition <ref> [4] </ref> Let E be a general program expression. Then for any three-valued Herbrand interpretation I : (E)(I ) = (o (E))(I): It is possible to show that the above proposition extends to the case in which general program expressions may include the renaming operator. <p> By virtue of the above equivalence result, the three-valued semantics of general program expressions can be then related <ref> [4] </ref> to various operational semantics for general programs proposed in the literature. 6 Concluding remarks The concept of renaming has been widely studied and employed in mathematics and computer science for different purposes, including program composition. <p> From an implementation viewpoint, the transformation o for the renaming operation has been developed in SICStus Prolog. This actually enriches, in a practical applicability perspective, the toolkit for composing general logic programs described in <ref> [4] </ref>.
Reference: [5] <author> A. Brogi, P. Mancarella, D. Pedreschi, and F. Turini. </author> <title> Modular Logic Programming. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(4) </volume> <pages> 1361-1398, </pages> <year> 1994. </year>
Reference-contexts: More precisely, we choose logic-based programming for specifying the components and a set of meta-level composition operations on logic programs as the gluing (part of the) meta-language. In previous work <ref> [4, 5] </ref> we have shown the use of a basic set of meta-level operations on logic programs for mastering the complexity of designing complex systems.
Reference: [6] <author> A. Brogi and F. Turini. </author> <title> Fully abstract compositional semantics for an algebra of logic programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 149(2) </volume> <pages> 201-229, </pages> <year> 1995. </year>
Reference-contexts: It is however important to define an abstract semantics of program compositions, besides this transformational semantics, so as to characterise the intended meaning of each composition without the need of referring to the corresponding transformed program. Brogi and Turini showed <ref> [6] </ref> the need of resorting to higher-order semantics in order to define compositional semantics for definite programs with non-trivial sets of composition operations. The same consideration applies to compositions of general programs, where in addition the orthogonal aspects of compositionality and non-monotonicity must be reconciled.
Reference: [7] <author> S. Etalle and F. Teusink. </author> <title> A Compositional Semantics for Normal Open Programs. </title> <editor> In M. Maher, editor, </editor> <booktitle> Proc. of JICSLP 96, </booktitle> <pages> pages 468-482, </pages> <year> 1996. </year>
Reference-contexts: They also showed that the idea of splitting can be applied for proving properties of simple program compositions, like a conservative extension property for a program P extended by rules whose heads do not occur in P . Etalle and Teusink <ref> [7] </ref> and Verbaeten et al. [13] studied the problems of defining compositional semantics for general logic programs. Etalle and Teusink [7] define a compositional semantics for general programs by means of a first-order unfolding operator. <p> Etalle and Teusink <ref> [7] </ref> and Verbaeten et al. [13] studied the problems of defining compositional semantics for general logic programs. Etalle and Teusink [7] define a compositional semantics for general programs by means of a first-order unfolding operator. Such a semantics is applied for composing "open" general programs by considering the union of programs as the only composition operation.
Reference: [8] <author> M. </author> <title> Fitting. A Kriple-Kleene semantics for general logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 295-312, </pages> <year> 1985. </year>
Reference-contexts: The same consideration applies to compositions of general programs, where in addition the orthogonal aspects of compositionality and non-monotonicity must be reconciled. A compositional semantics for general program expressions containing [, " and OE operations has been defined in [4] in terms of three-valued logic. Fitting <ref> [8] </ref> proposed to use a three-valued logic [11] to formalise the meaning of general programs. Three-valued logic models the idea that a query can yield three possible outcomes: success, failure, and divergence. Fitting [8] also defined a three-valued immediate consequence operator , which given a general program P and a three-valued <p> Fitting <ref> [8] </ref> proposed to use a three-valued logic [11] to formalise the meaning of general programs. Three-valued logic models the idea that a query can yield three possible outcomes: success, failure, and divergence. Fitting [8] also defined a three-valued immediate consequence operator , which given a general program P and a three-valued interpretation 5 I yields a three-valued interpretation.
Reference: [9] <author> M. Gelfond and V. Lifschitz. </author> <title> Classical negation in logic programming and disjunctive databases. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 365-385, </pages> <year> 1991. </year>
Reference-contexts: To the best of our knowledge, only a few papers have been devoted to discuss the problems of composing general logic programs. Lifschitz and Turner [12] investigated the idea of splitting a logic program into parts in the context of the answer set semantics <ref> [9] </ref>. The basic idea is that, in many cases, a program 7 can be divided into a "bottom" part and a "top" part, such that the latter does not refer to predicates defined in the former.
Reference: [10] <author> P. Hill. </author> <title> A Module System for Systematic Software Development: Design and Implementation. </title> <editor> In A. Brogi and P. Hill, editors, </editor> <booktitle> Proc. of LOCOS97: Workshop on Logic Based Composition of Software, </booktitle> <address> Leuven, </address> <year> 1997. </year>
Reference-contexts: Namely, in contrast with our naming policy, predicate definitions cannot be spread over different programs. The use of parameterisation proposed by Hill <ref> [10] </ref> for typed logic-based languages shares some of the objectives of our work. Hill considered two kinds of parameters: "open" parameters to support code linking, and "renaming" parameters to support code reuse. <p> Hill considered two kinds of parameters: "open" parameters to support code linking, and "renaming" parameters to support code reuse. As we have shown, both these mechanisms can be expressed in our setting, and the main differences between our work vs. <ref> [10] </ref> are to consider a family of composition operations vs. only one module composition operation, and the use of untyped vs. typed programs. From an implementation viewpoint, the transformation o for the renaming operation has been developed in SICStus Prolog.
Reference: [11] <author> S.C. Kleene. </author> <title> Introduction to Metamathematics. </title> <publisher> van Nostrand, </publisher> <address> New York, </address> <year> 1952. </year>
Reference-contexts: A compositional semantics for general program expressions containing [, " and OE operations has been defined in [4] in terms of three-valued logic. Fitting [8] proposed to use a three-valued logic <ref> [11] </ref> to formalise the meaning of general programs. Three-valued logic models the idea that a query can yield three possible outcomes: success, failure, and divergence.
Reference: [12] <author> V. Lifschitz and H. Turner. </author> <title> Splitting a logic program. </title> <editor> In Pascal Van Entenryck, editor, </editor> <booktitle> Proc. 11th International Conference on Logic Programming, </booktitle> <pages> pages 23-37. </pages> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: To the best of our knowledge, only a few papers have been devoted to discuss the problems of composing general logic programs. Lifschitz and Turner <ref> [12] </ref> investigated the idea of splitting a logic program into parts in the context of the answer set semantics [9].
Reference: [13] <author> S. Verbaeten, M. Denecker, and D. De Schreye. </author> <title> Compositionality of normal logic programs. </title> <editor> In J. Maluszynski, editor, </editor> <booktitle> Logic Programming, Proceedings of the 1997 International Symposium, </booktitle> <pages> pages 371-395, </pages> <month> October </month> <year> 1997. </year> <month> 8 </month>
Reference-contexts: They also showed that the idea of splitting can be applied for proving properties of simple program compositions, like a conservative extension property for a program P extended by rules whose heads do not occur in P . Etalle and Teusink [7] and Verbaeten et al. <ref> [13] </ref> studied the problems of defining compositional semantics for general logic programs. Etalle and Teusink [7] define a compositional semantics for general programs by means of a first-order unfolding operator. <p> Etalle and Teusink [7] define a compositional semantics for general programs by means of a first-order unfolding operator. Such a semantics is applied for composing "open" general programs by considering the union of programs as the only composition operation. Verbaeten et al. <ref> [13] </ref> present several results on the compositionality of general logic programs by generalising the well-founded semantics of logic programming.
References-found: 13

