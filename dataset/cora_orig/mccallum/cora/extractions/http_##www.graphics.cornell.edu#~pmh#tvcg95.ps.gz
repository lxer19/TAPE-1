URL: http://www.graphics.cornell.edu/~pmh/tvcg95.ps.gz
Refering-URL: http://www.cs.wustl.edu/~pmh/research.html
Root-URL: 
Title: Collision Detection for Interactive Graphics Applications  
Author: Philip M. Hubbard 
Keyword: Index items: collision detection, time-critical computing, real-time performance, interaction, four dimensions, approximation.  
Affiliation: Program of Computer Graphics Cornell University  
Note: IEEE Transactions on Visualization and Computer Graphics, 1(3), Sept. 1995, pp. 218-230  
Abstract: Collision detection and response are important for interactive graphics applications such as vehicle simulators and virtual reality. Unfortunately, previous collision-detection algorithms are too slow for interactive use. This paper presents a new algorithm for rigid or articulated objects that meets performance goals through a form of time-critical computing. The algorithm supports progressive refinement, detecting collisions between successively tighter approximations to object surfaces as the application allows it more processing time. The algorithm uses simple four-dimensional geometry to approximate motion, and hierarchies of spheres to approximate three-dimensional surfaces at multiple resolutions. In a sample application, the algorithm allows interactive performance that is not possible with a good previous algorithm. In particular, the new algorithm provides acceptable accuracy while maintaining a steady and high frame rate, which in some cases improves on the previous algorithm's rate by more than two orders of magnitude. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Baraff. </author> <title> Coping with friction for non-penetrating rigid body simulation. </title> <booktitle> In Proceedings of SIGGRAPH '91, published as Computer Graphics, </booktitle> <volume> 25(4) </volume> <pages> 31-40, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: The response algorithm corrects the behavior of the objects that would penetrate. Both parts of a collision-handling algorithm pose interesting problems, but this paper focuses on detection algorithms. For a discussion of response algorithms, see the work of Baraff <ref> [1] </ref>. Despite the wealth of literature on detection algorithms, no published algorithms adequately address the needs of interactive applications, such as vehicle simulators or virtual reality. To work in an interactive application, a detection algorithm must satisfy two criteria. <p> Thus, a 3D bound on O's position at t is a sphere of radius (M=2)t 2 centered at x (0) + _ x (0)t. A 4D bound on O's position over all times t 2 <ref> [ 0; 1 ] </ref> is the structure whose cross section at t is that sphere. To better understand this 4D structure, consider an analogy in one less dimension: O is now in R 2 , and a structure that bounds O's movement over time has three dimensions. <p> Due to the factor of t 2 present in the definition, the bounding structure is a parabolic horn. Note that it is a conservative bound on O's position over time, in that O cannot be outside the horn for t 2 <ref> [ 0; 1 ] </ref>. An extension of this idea covers an object, O, that is not merely a point. As it moves, O will rotate around a point, y (t), which for physically based motion is O's center of mass. <p> Knowledge that only certain directions are possible allows part of a hypertrapezoid to be trimmed away, tightening the bound it represents. Say the application knows that for t 2 <ref> [ 0; 1 ] </ref> the acceleration vector x (t) will lie in a hemisphere around O, that is, the application knows a vector d 2 R 3 such that x (t) d 0 t 2 [ 0; 1 ]: This sort of limit arises when O moves away from a particular <p> Say the application knows that for t 2 <ref> [ 0; 1 ] </ref> the acceleration vector x (t) will lie in a hemisphere around O, that is, the application knows a vector d 2 R 3 such that x (t) d 0 t 2 [ 0; 1 ]: This sort of limit arises when O moves away from a particular direction, for example, if O is avoiding an obstructing wall. <p> 2 <ref> [ 0; 1 ] </ref>: This sort of limit arises when O moves away from a particular direction, for example, if O is avoiding an obstructing wall. This relationship between x (t) and d leads to the inequality (x (t) [x (0) + _ x (0)t]) d 0; t 2 [ 0; 1 ]: (2) The proof is almost identical to the proof of Inequality 1. To appreciate the significance of Inequality 2, think of d as the outward-pointing normal vector for a 3D plane that passes through c (t) = x (0) + _ x (0)t. <p> The set of 3D planes defined by c (t) and d for all t 2 <ref> [ 0; 1 ] </ref> are cross sections of a 4D cutting plane. A hypertrapezoid teamed with a cutting plane is a complete space-time bound. Fig. 5 shows an example. The algorithms that use space-time bounds assume that M and d will be provided by the application program. <p> all faces thus consists of three subsets: F ff = ff j face f is normal to axis ffg; ff 2 fx; y; zg: These sets are important for the following reason: if two hypertrapezoids, T 1 and T 2 , intersect for the first time at t i 2 <ref> [0; 1] </ref>, then there must be an intersection at t i between a face of T 1 in F ff and a face of T 2 in the same F ff , for some ff 2 fx; y; zg. The proof of this assertion is messy but straightforward. <p> Recall from Section 4 that a hypertrapezoid is defined by linear interpolation, so an appropriate point is p (t) = p + ( ^ p p) t; t 2 <ref> [ 0; 1 ] </ref>; (3) where p and ^ p are points on the face at t = 0 and t = 1, respectively. <p> Given r (t), any point on the intersection between p 1 and P 2 is i (t; k) = r (t) + km for some t 2 <ref> [ 0; 1 ] </ref> and k 2 R. Some points i (t; k) do not correspond to real intersections between f 1 and P 2 .
Reference: [2] <author> L. Bergman, H. Fuchs, E. Grant, and S. Spach. </author> <title> Image rendering by adaptive refinement. </title> <booktitle> In Proceedings of SIGGRAPH '86, published as Computer Graphics, </booktitle> <volume> 20(4) </volume> <pages> 29-37, </pages> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: T. Rhodes Hall, Cornell University, Ithaca, NY 14853-3801. Email address: pmh@graphics.cornell.edu. This approach is analogous, in essence, to rendering at multiple levels of quality, as explored by Bergman et al. <ref> [2] </ref>, Funkhouser and Sequin [8], and Maciel and Shirley [17]. The success of these rendering techniques suggests the value of this approach in collision detection.
Reference: [3] <author> J. Canny. </author> <title> Collision detection for moving polyhedra. </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence, </journal> <volume> 8(2) </volume> <pages> 200-209, </pages> <month> Mar. </month> <year> 1986. </year>
Reference-contexts: Furthermore, the algorithms that most nearly solve all three impose restrictions on the shapes or motion of objects, making these algorithms unsuitable for interactive applications. To eliminate the fixed-timestep weakness, some algorithms use 4D geometry, the fourth dimension being simulation time. Canny <ref> [3] </ref>, for example, derives functions of a time variable that express how convex polyhedra change over time; the roots of these functions denote collisions. Duff [6] uses interval analysis to quickly identify and refine the regions in space and time that could contain collisions.
Reference: [4] <author> J. D. Cohen, M. C. Lin, D. Manocha, and M. K. Ponamgi. I-COLLIDE: </author> <title> An interactive and exact collision detection system for large-scale environments. </title> <booktitle> In Proceedings of the 1995 Symposium on Interactive 3D Graphics (Monterey, California), </booktitle> <pages> pages 189-196, </pages> <year> 1995. </year>
Reference-contexts: Cohen et al. <ref> [4] </ref> use simple spatial sorting to find intersections between bounding boxes; this sorting exploits interframe coherence to reduce its workload. Although these algorithms do not address the fixed-timestep or pair-processing weaknesses, they are flexible enough to handle motion that is not fully pre-specified.
Reference: [5] <author> R. K. Culley and K. G. Kempf. </author> <title> A collision detection algorithm based on velocity and distance bounds. </title> <booktitle> In Proceedings 1986 IEEE International Conference on Robotics and Automation, </booktitle> <pages> pages 1064-1069, </pages> <year> 1986. </year>
Reference-contexts: Some researchers address the fixed-timestep weakness without assuming fully pre-specified motion. Culley and Kempf <ref> [5] </ref> use bounds on velocity and distance to increase t d when collisions cannot occur. Their technique cannot handle nonlinear motion, nor does it address the all-pairs weakness, but the idea inspired the concept of space-time bounds, to be introduced in Section 4.
Reference: [6] <author> T. Duff. </author> <title> Interval arithmetic and recursive subdivision for implicit functions and constructive solid geometry. </title> <booktitle> In Proceedings of SIG-GRAPH '92, published as Computer Graphics, </booktitle> <volume> 26(2) </volume> <pages> 131-138, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: To eliminate the fixed-timestep weakness, some algorithms use 4D geometry, the fourth dimension being simulation time. Canny [3], for example, derives functions of a time variable that express how convex polyhedra change over time; the roots of these functions denote collisions. Duff <ref> [6] </ref> uses interval analysis to quickly identify and refine the regions in space and time that could contain collisions. This approach is one of the few to address all three weaknesses. Unfortunately, it assumes that objects' motions over time are fully known in advance. <p> This empirical evidence suggests that the projection method effectively eliminates the all-pairs weakness in practice. 5.2.2 The Subdivision Method An alternative way to find face intersections is to use an approach similar to Duff's algorithm <ref> [6] </ref>. This approach subdivides space and time much like a 4D octree. The subdivisions are isothetic 4D cubes, so the algorithm can efficiently determine which faces intersect each cube. The algorithm subdivides recursively, the base case being cubes that intersect a small number, n b , of faces. <p> The narrow phase therefore provides progressive refinement, allowing the application to control the balance between accuracy and speed through its choice of the number of levels descended. 2 Minimum temporal resolution is common in detection algorithms from the literature. Interval-analysis techniques <ref> [6, 27] </ref> provide the best alternative: at their deepest level of subdivision, they find small intervals of time that definitely contain collisions, although the exact instants of the collisions within those intervals are unknown. 12 Hierarchical algorithms are common in computer graphics, so it is important to note how this approach
Reference: [7] <author> A. Foisy, V. Hayward, and S. Aubry. </author> <title> The use of awareness in collision prediction. </title> <booktitle> In Proceedings of the 1990 IEEE International Conference on Robotics and Automation, </booktitle> <pages> pages 338-343, </pages> <year> 1990. </year>
Reference-contexts: Culley and Kempf [5] use bounds on velocity and distance to increase t d when collisions cannot occur. Their technique cannot handle nonlinear motion, nor does it address the all-pairs weakness, but the idea inspired the concept of space-time bounds, to be introduced in Section 4. Foisy et al. <ref> [7] </ref> use 4D structures somewhat similar to space-time bounds to solve the fixed-timestep weakness. Their approach also addresses the all-pairs weakness in some|but not all| situations. Lin et al. [16] use similar 4D analysis in concert with an efficient technique for tracking the distance between two convex polyhedra.
Reference: [8] <author> T. A. Funkhouser and C. H. Sequin. </author> <title> Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments. </title> <booktitle> In Proceedings of SIGGRAPH '93, published as Computer Graphics Proceedings, Annual Conference Series, </booktitle> <pages> pages 247-254, </pages> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: T. Rhodes Hall, Cornell University, Ithaca, NY 14853-3801. Email address: pmh@graphics.cornell.edu. This approach is analogous, in essence, to rendering at multiple levels of quality, as explored by Bergman et al. [2], Funkhouser and Sequin <ref> [8] </ref>, and Maciel and Shirley [17]. The success of these rendering techniques suggests the value of this approach in collision detection. All these ideas are elements of time-critical computing, which stresses that the time an algorithm spends producing its results can be as important as the correctness of those results.
Reference: [9] <author> A. Garcia-Alonso, N. Serrano, and J. Flaquer. </author> <title> Solving the collision detection problem. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 14(3) </volume> <pages> 36-43, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: An advantage of BSP trees is that for rigid objects, the structure of a tree can be optimized to improve performance; Naylor [19] describes several optimization techniques. To accelerate their pair-processing algorithm, Garcia-Alonso et al. <ref> [9] </ref> associate a precomputed regular grid with each object; as objects rotate, however, the grids lose some of their efficiency. Sclaroff and Pentland [24] present a pair-processing algorithm that approximates surfaces with deformed superquadrics.
Reference: [10] <author> J. A. Goldak, X. Yu, A. Knight, and L. Dong. </author> <title> Constructing discrete medial axis of 3-D objects. </title> <journal> International Journal of Computational Geometry and Applications, </journal> <volume> 1(3) </volume> <pages> 327-339, </pages> <year> 1991. </year>
Reference-contexts: The most successful algorithm for building sphere-trees uses medial-axis surfaces. A medial-axis surface corresponds to the "skeleton" of an object. Building the exact medial-axis surface for a 3D polyhedron is difficult, but Goldak et al. <ref> [10] </ref> describe an algorithm that produces a satisfactory approximation. This algorithm distributes points on the outer surface of the object and computes the Voronoi diagram [21] for the points; the vertices of the Voronoi diagram that are inside the object lie on its medial-axis surface.
Reference: [11] <author> J. Goldsmith and J. Salmon. </author> <title> Automatic creation of object hierarchies for ray tracing. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 7(5) </volume> <pages> 14-20, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: An algorithm that builds an octree representation of an object [23] can also build a sphere-tree, by circumscribing each occupied octant with a sphere. The resolution of the resulting sphere-tree increases with depth; even so, sphere-trees produced this way tend to fit an object loosely. Goldsmith and Salmon <ref> [11] </ref> present an algorithm that builds efficient bounding hierarchies for ray tracing. Optimizing a hierarchy for ray-object intersections does not directly promote the tightness needed for object-object collisions, however. O'Rourke and Badler [20] fit spheres inside a polyhedron by attaching them to a subset of its vertices.
Reference: [12] <author> P. S. Heckbert and M. </author> <title> Garland. Multiresolution modeling for fast rendering. </title> <booktitle> In Proceedings of Graphics Interface '94, </booktitle> <pages> pages 43-50, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Multiresolution modeling is a difficult topic in general, as Heckbert and Garland <ref> [12] </ref> discuss in the context of rendering. For collision detection, the particular challenge is making each level fit the object tightly; tightness is necessary because the application could stop the detection and invoke collision response on the colliding spheres at any level.
Reference: [13] <author> P. M. Hubbard. </author> <title> Interactive collision detection. </title> <booktitle> In Proceedings of the 1993 IEEE Symposium on Research Frontiers in Virtual Reality, </booktitle> <pages> pages 24-31, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: Important advances would be systems that integrate time-critical algorithms for multiple tasks, and studies to determine what approximations users find most appropriate for particular tasks. 17 11 Acknowledgements A preliminary, abbreviated version of this paper appeared at the IEEE Symposium on Research Frontiers in Virtual Reality <ref> [13] </ref>. This research was conducted as part of the author's doctoral studies at Brown University. The guidance of John "Spike" Hughes was essential to the completion of this work, and Andy van Dam and the rest of the Brown Computer Graphics Group also made important contributions.
Reference: [14] <author> P. M. Hubbard. </author> <title> Collision Detection for Interactive Graphics Applications. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Brown University, </institution> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: Section 4 introduces space-time bounds, and their use in the detection algorithm is developed in Sections 5 and 6. Section 7 describes sphere-trees, and Section 8 sketches an algorithm that builds sphere-trees automatically. Some aspects of the latter topic are subtle, so we omit details that appear elsewhere <ref> [14] </ref>; the current paper thus emphasizes the overall structure of the detection algorithm. Section 9 discusses the performance of the algorithm. <p> , such that j x (t)j M holds until some future time|say, t = 1|then the unknown x (t) is subject to the following inequality: jx (t) [x (0) + _ x (0)t]j 2 This assertion is related to Taylor's theorem; a proof is not difficult and it appears elsewhere <ref> [14] </ref>. Inequality 1 is important for its geometric interpretation. It states that the unknown position x (t) will be within a distance (M=2)t 2 from the known position x (0) + _ x (0)t. <p> This worst case should be uncommon, however, and the subdivision method is usually efficient in practice. 5.2.3 Comparison To compare the projection and subdivision methods, we ran empirical tests. The tests involved various distributions of hypertrapezoids, as detailed elsewhere <ref> [14] </ref>. The current section presents only the results for randomly distributed hypertrapezoids, which, in a sense, approximate the "average" case. We conducted 200 tests, each involving a different set of 100 hypertrapezoids. <p> from Equation 3), then the point i (t; k) is inside that half-space only if [i (t; k) p (t)] n 0: This inequality can be solved for k in terms of t because both i (t; k) and p (t) are linear functions of t; complete details appear elsewhere <ref> [14] </ref>. The result is a set of constraint half-planes in the t-k plane. The pairs, (t; k), within the intersection of these half-planes satisfy the constraints and correspond to real intersection points i (t; k). The face-plane intersection algorithm must find the earliest such point. <p> This section gives an overview of techniques for building tight sphere-trees; more details appear elsewhere <ref> [14] </ref>. The literature contains few references on tight hierarchies. An algorithm that builds an octree representation of an object [23] can also build a sphere-tree, by circumscribing each occupied octant with a sphere. <p> This algorithm is a hybrid, which uses Turk's uniform space subdivision [29] to find pairs of objects whose bounding cubes intersect, and then uses BSP trees [28] to process each pair. A complete description of the tests appears elsewhere <ref> [14] </ref>; this section presents highlights of the results. The first set of tests compare space-time bounds to Turk's algorithm. The test program generates random configurations of isothetic cubes and applies forces to make them move.
Reference: [15] <author> R. S. Kennedy, N. E. Lane, M. G. Lilienthal, K. S. Berbaum, and L. J. Hettinger. </author> <title> Profile analysis of simulator sickness symptoms: Application to virtual environment systems. Presence, </title> <type> 1(3), </type> <month> Summer </month> <year> 1992. </year>
Reference-contexts: After each accuracy improvement, the algorithm allows itself to be interrupted by the application program. The application thus has the flexibility to degrade accuracy when speed is important, for example, to avoid latency, which may give users a feeling of motion sickness <ref> [15] </ref>. fl Copyright 1995, IEEE. All rights reserved. Personal use of this material is permitted.
Reference: [16] <author> M. C. Lin, D. Manocha, and J. F. Canny. </author> <title> Fast collision detection between geometric models. </title> <type> Technical Report TR93-004, </type> <institution> Department of Computer Science, The University of North Carolina at Chapel Hill, </institution> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: Foisy et al. [7] use 4D structures somewhat similar to space-time bounds to solve the fixed-timestep weakness. Their approach also addresses the all-pairs weakness in some|but not all| situations. Lin et al. <ref> [16] </ref> use similar 4D analysis in concert with an efficient technique for tracking the distance between two convex polyhedra. The algorithm incorporates extensions for nonconvex objects, but the authors do not analyze the performance of the algorithm in practice.
Reference: [17] <author> P. W. C. Maciel and P. Shirley. </author> <title> Visual navigation of large environments using textured clusters. </title> <booktitle> In Proceedings of the 1995 Symposium on Interactive 3D Graphics (Monterey, California), </booktitle> <pages> pages 95-102, </pages> <year> 1995. </year>
Reference-contexts: T. Rhodes Hall, Cornell University, Ithaca, NY 14853-3801. Email address: pmh@graphics.cornell.edu. This approach is analogous, in essence, to rendering at multiple levels of quality, as explored by Bergman et al. [2], Funkhouser and Sequin [8], and Maciel and Shirley <ref> [17] </ref>. The success of these rendering techniques suggests the value of this approach in collision detection. All these ideas are elements of time-critical computing, which stresses that the time an algorithm spends producing its results can be as important as the correctness of those results.
Reference: [18] <author> M. P. Moore and J. Wilhelms. </author> <title> Collision detection and response for computer animation. </title> <booktitle> In Proceedings of SIGGRAPH '88, published as Computer Graphics, </booktitle> <volume> 22(4) </volume> <pages> 289-298, </pages> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: The algorithm incorporates extensions for nonconvex objects, but the authors do not analyze the performance of the algorithm in practice. Space subdivision is a popular way to mitigate the all-pairs weakness (although (N 2 ) worst cases still exist for some object shapes). The algorithms of Moore and Wilhems <ref> [18] </ref>, Shaffer and Herb [25] and Smith et al. [26] exemplify the use of octrees by many researchers.
Reference: [19] <author> B. F. Naylor. </author> <title> Constructing good partitioning trees. </title> <booktitle> In Proceedings of Graphics Interface '93, </booktitle> <pages> pages 181-191, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: An advantage of BSP trees is that for rigid objects, the structure of a tree can be optimized to improve performance; Naylor <ref> [19] </ref> describes several optimization techniques. To accelerate their pair-processing algorithm, Garcia-Alonso et al. [9] associate a precomputed regular grid with each object; as objects rotate, however, the grids lose some of their efficiency. Sclaroff and Pentland [24] present a pair-processing algorithm that approximates surfaces with deformed superquadrics. <p> For these tests, one algorithm uses sphere-trees and the other uses BSP trees. A preprocessor builds both data structures before the start of the tests. To make the BSP trees more efficient, the preprocessor minimizes the number of extra nodes created by faces that straddle partitioning planes; Naylor <ref> [19] </ref> discusses other ways to optimize BSP trees. The "ships" in these tests are shaped like lamps, as in Fig. 10. The sphere-trees have a fourth, more accurate level of spheres not shown in Fig. 10, and these spheres store the lamp's polygons, allowing a fifth level of exact detection.
Reference: [20] <author> J. O'Rourke and N. Badler. </author> <title> Decomposition of three-dimensional objects into spheres. </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence, </journal> <volume> PAMI-1(3):295-305, </volume> <month> July </month> <year> 1979. </year>
Reference-contexts: Goldsmith and Salmon [11] present an algorithm that builds efficient bounding hierarchies for ray tracing. Optimizing a hierarchy for ray-object intersections does not directly promote the tightness needed for object-object collisions, however. O'Rourke and Badler <ref> [20] </ref> fit spheres inside a polyhedron by attaching them to a subset of its vertices. This approach produces tightly-fitting sets of spheres, but it offers little control over the resolution of a set, and it does not link multiple sets into a hierarchy.
Reference: [21] <author> F. P. Preparata and M. I. Shamos. </author> <title> Computational Geometry: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> New York, New York, </address> <year> 1985. </year>
Reference-contexts: The algorithm applies these ideas as it finds intersections between all the 2D segments. It finds these segment intersections by using the technique of Bentley and Ottmann <ref> [21] </ref>. This technique sweeps a line across the ff-t plane (from t = 0 to t = 1), reporting every intersection it finds. The broad phase needs the earliest (lowest t) segment intersection that corresponds to a real face intersection, so sweeping stops as soon it finds this intersection. <p> The pairs, (t; k), within the intersection of these half-planes satisfy the constraints and correspond to real intersection points i (t; k). The face-plane intersection algorithm must find the earliest such point. Finding this point is an example of a two-variable linear-programming problem. Preparata and Shamos <ref> [21] </ref> describe a solution to this problem. <p> Measuring the looseness of spheres around a nonconvex object is a nontrivial problem. The best approach we have found measures the Hausdorff distance <ref> [21] </ref> from each sphere to the object's surface, but there seems to be no way to measure this distance without making approximations. Simulated annealing does improve the accuracy of octree-based sphere-trees in many cases, but it is slow and it sometimes produces highly irregular distributions of spheres. <p> Building the exact medial-axis surface for a 3D polyhedron is difficult, but Goldak et al. [10] describe an algorithm that produces a satisfactory approximation. This algorithm distributes points on the outer surface of the object and computes the Voronoi diagram <ref> [21] </ref> for the points; the vertices of the Voronoi diagram that are inside the object lie on its medial-axis surface. Each such vertex defines a sphere that touches the object's outer surface at four points.
Reference: [22] <author> W. H. Press, S. A. Teukolsky, W. T. Vetterling, and B. P. Flannery. </author> <title> Numerical Recipes in C. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, England, 2nd edition, </address> <year> 1992. </year> <month> 18 </month>
Reference-contexts: One algorithm starts with an octree-based sphere-tree and tightens the spheres around the object. This tightening is a constrained minimization problem: minimize the looseness of the spheres while maintaining conservative coverage of the object. One way to solve such a problem is to apply simulated annealing <ref> [22] </ref>. In this context, simulated annealing repeatedly proposes random changes to the spheres, and accepts all changes that produce a tighter fit; it also accepts some changes that 13 loosen the fit, to avoid local minima. Measuring the looseness of spheres around a nonconvex object is a nontrivial problem. <p> Space-time bounds are sometimes slower when the terminating collision occurs almost immediately; in these cases, estimating future collisions 14 provides no advantage so the overhead of space-time bounds is a penalty. The "overall" graph suggests that the ODE solver (a fourth-order Runge-Kutta method <ref> [22] </ref>) is a bottleneck; the "overall" speedups could be closer to the "detection-only" speedups given a faster ODE solver. The speedups from Fig. 11 reflect performance over many frames. For interactive applications, it is also important that each individual frame be fast.
Reference: [23] <author> H. Samet and R. E. Webber. </author> <title> Hierarchical data structures and algorithms for computer graphics, part I: Fundamentals. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 8(3) </volume> <pages> 48-68, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: This section gives an overview of techniques for building tight sphere-trees; more details appear elsewhere [14]. The literature contains few references on tight hierarchies. An algorithm that builds an octree representation of an object <ref> [23] </ref> can also build a sphere-tree, by circumscribing each occupied octant with a sphere. The resolution of the resulting sphere-tree increases with depth; even so, sphere-trees produced this way tend to fit an object loosely. Goldsmith and Salmon [11] present an algorithm that builds efficient bounding hierarchies for ray tracing.
Reference: [24] <author> S. Sclaroff and A. Pentland. </author> <title> Generalized implicit functions for computer graphics. </title> <booktitle> In Proceedings of SIGGRAPH '91, published as Computer Graphics, </booktitle> <volume> 25(4) </volume> <pages> 247-250, </pages> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: To accelerate their pair-processing algorithm, Garcia-Alonso et al. [9] associate a precomputed regular grid with each object; as objects rotate, however, the grids lose some of their efficiency. Sclaroff and Pentland <ref> [24] </ref> present a pair-processing algorithm that approximates surfaces with deformed superquadrics. The authors do not demonstrate that their approach works for a wide variety of surfaces, but they are the first authors to show that approximation can make collision detection more efficient.
Reference: [25] <author> C. A. Shaffer and G. M. Herb. </author> <title> A real-time robot arm collision avoidance system. </title> <journal> IEEE Transactions on Robotics and Automation, </journal> <volume> 8(2) </volume> <pages> 149-160, </pages> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: Space subdivision is a popular way to mitigate the all-pairs weakness (although (N 2 ) worst cases still exist for some object shapes). The algorithms of Moore and Wilhems [18], Shaffer and Herb <ref> [25] </ref> and Smith et al. [26] exemplify the use of octrees by many researchers. <p> First, the new approach avoids work inherent in algorithms that use octree hierarchies, for example, the algorithm of Shaffer and Herb <ref> [25] </ref>. At every frame, these algorithms incur the cost of rebuilding the octree or of moving objects between octants. Sphere-trees, in contrast, transform the same way as rigid objects, due to the rotational invariance of spheres; sphere-trees can thus be built once by a preprocess.
Reference: [26] <author> A. Smith, Y. Kitamura, H. Takemura, and F. Kishino. </author> <title> A simple and efficient method for accurate collision detection among deformable objects in arbitrary motion. </title> <booktitle> In Proceedings of the IEEE Virtual Reality Annual International Symposium, </booktitle> <pages> pages 136-145, </pages> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: Space subdivision is a popular way to mitigate the all-pairs weakness (although (N 2 ) worst cases still exist for some object shapes). The algorithms of Moore and Wilhems [18], Shaffer and Herb [25] and Smith et al. <ref> [26] </ref> exemplify the use of octrees by many researchers.
Reference: [27] <author> J. M. Snyder, A. R. Woodbury, K. Fleischer, B. Currin, and A. H. Barr. </author> <title> Interval methods for multi-point collisions between time-dependent curved surfaces. </title> <booktitle> In Proceedings of SIGGRAPH '93, published as Computer Graphics Proceedings, Annual Conference Series, </booktitle> <pages> pages 321-334, </pages> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: This approach is one of the few to address all three weaknesses. Unfortunately, it assumes that objects' motions over time are fully known in advance. Thus, an interactive application cannot use this algorithm. Recent advances in interval analysis, such as the work of Snyder et al. <ref> [27] </ref>, still retain this disadvantage. <p> The narrow phase therefore provides progressive refinement, allowing the application to control the balance between accuracy and speed through its choice of the number of levels descended. 2 Minimum temporal resolution is common in detection algorithms from the literature. Interval-analysis techniques <ref> [6, 27] </ref> provide the best alternative: at their deepest level of subdivision, they find small intervals of time that definitely contain collisions, although the exact instants of the collisions within those intervals are unknown. 12 Hierarchical algorithms are common in computer graphics, so it is important to note how this approach
Reference: [28] <author> W. C. Thibault and B. F. Naylor. </author> <title> Set operations on polyhedra using binary space partitioning trees. </title> <booktitle> In Proceedings of SIGGRAPH '87, published as Computer Graphics, </booktitle> <volume> 21(4) </volume> <pages> 153-162, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Although these algorithms do not address the fixed-timestep or pair-processing weaknesses, they are flexible enough to handle motion that is not fully pre-specified. Turk's algorithm and the Cohen et al. algorithm, in particular, are efficient because of their low overhead. 3 Thibault and Naylor <ref> [28] </ref> show how binary space partitioning (BSP) trees address the pair-processing weakness for polyhedral objects. An advantage of BSP trees is that for rigid objects, the structure of a tree can be optimized to improve performance; Naylor [19] describes several optimization techniques. <p> This algorithm is a hybrid, which uses Turk's uniform space subdivision [29] to find pairs of objects whose bounding cubes intersect, and then uses BSP trees <ref> [28] </ref> to process each pair. A complete description of the tests appears elsewhere [14]; this section presents highlights of the results. The first set of tests compare space-time bounds to Turk's algorithm. The test program generates random configurations of isothetic cubes and applies forces to make them move.
Reference: [29] <author> G. Turk. </author> <title> Interactive collision detection for molecular graphics. </title> <type> Technical Report TR90-014, </type> <institution> Department of Computer Science, The University of North Carolina at Chapel Hill, </institution> <month> Jan. </month> <year> 1990. </year> <month> 19 </month>
Reference-contexts: Space subdivision is a popular way to mitigate the all-pairs weakness (although (N 2 ) worst cases still exist for some object shapes). The algorithms of Moore and Wilhems [18], Shaffer and Herb [25] and Smith et al. [26] exemplify the use of octrees by many researchers. Turk <ref> [29] </ref> presents a simpler technique that divides space uniformly; while Turk's application was molecular modeling using spheres, the approach works for the bounding spheres or boxes of arbitrary objects, efficiently reducing the number of objects whose surfaces must be tested for intersection (by some other method). <p> It is also important to remember that this time occurs in preprocessing, before an application begins running. 9 Performance To evaluate the detection algorithm empirically, we tested it against one of the best previous algorithms. This algorithm is a hybrid, which uses Turk's uniform space subdivision <ref> [29] </ref> to find pairs of objects whose bounding cubes intersect, and then uses BSP trees [28] to process each pair. A complete description of the tests appears elsewhere [14]; this section presents highlights of the results. The first set of tests compare space-time bounds to Turk's algorithm.
References-found: 29

