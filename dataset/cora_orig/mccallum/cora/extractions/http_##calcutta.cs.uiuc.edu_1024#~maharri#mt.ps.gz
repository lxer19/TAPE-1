URL: http://calcutta.cs.uiuc.edu:1024/~maharri/mt.ps.gz
Refering-URL: http://sal.cs.uiuc.edu/~nachum/papers/
Root-URL: http://www.cs.uiuc.edu
Title: ORDERED CONSTRUCTION OF COMBINATORIAL OBJECTS  
Author: BY MITCHELL ALAN HARRIS 
Degree: 1986 THESIS Submitted in partial fulfillment of the requirements for the degree of Master of Science in Computer Science in the Graduate College of the  
Address: 1998 Urbana, Illinois  
Affiliation: A.B., Cornell University,  University of Illinois at Urbana-Champaign,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G. E. Andrews. </author> <title> The Theory of Partitions. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1976. </year>
Reference-contexts: For S n and A n , we have to sum over all partitions of n. The number of partitions of n is O p n (see Andrews <ref> [1] </ref> for a full treatment). Computing the cycle structure and corresponding generating function term is linear in the number of distinct parts of a partition (since that is the form of the partition we compute from).
Reference: [2] <author> F. Bergeron. </author> <title> Algorithms for the sequential generation of combinatorial structures. </title> <journal> Discrete and Applied Mathematics, </journal> <volume> 24(1-3):29-35, </volume> <year> 1989. </year>
Reference-contexts: For directed graphs, we consider the group on (restricted) ordered pairs, called S <ref> [2] </ref> n . Again, since this is induced by permutations on the points, we look at the generic cycle structure of integer partitions. <p> This also accounts for cycles of even length here because a directed edge will not match itself after halfway through the cycling as an unordered edge would. So the complete equation is: S <ref> [2] </ref> X 0 Y 1 k (k1)e k Y x k i&lt;j 2 (i;j)e i e j 1 To account for loops (self-directed edges), an extra factor Q e k k is needed. This is then the cycle index for the unrestricted ordered pair group, denoted S 2 n . <p> functions for families of graphs and digraphs are as follows with some simplification of exponents (all product ranges are from 1 to n): X S (2) X X 0 Y 1 k=2i+1 ie 2i+1 Y (x i x i1 Y x k i&lt;j (i;j)e i e j 1 X S <ref> [2] </ref> X X 0 Y 1 k ke 2 k i&lt;j 2 (i;j)e i e j 1 X S 2 X X 0 Y 1 k ke 2 k i&lt;j 2 (i;j)e i e j 1 So now that we have a generating function for these different types of graphs, what <p> Unrestricted relations on n objects are counted by S 2 n [1 + x], the unrestricted directed graphs. Irreflexive relations 45 (or equivalently reflexive) are counted by S (2) n [1 + x], the directed graphs with no self-loops. Symmetric, irreflexive relations are counted by S <ref> [2] </ref> Connected graphs (directed or undirected) can be enumerated by considering that any graph is a multiset of its components. <p> Joyal [9] gave a general method for constructions, and both Bergeron <ref> [2] </ref> and Zimmermann [18] expanded upon them. Several systems have been developed: Nijenhuis and Wilf [12] in Fortran, Skiena [17] in Mathematica, and Bergeron [2]. Paul Zimmermann [18] has written a Maple package for random generation according to the grammar of construction which in effect gives algorithms for ordered generation. <p> Joyal [9] gave a general method for constructions, and both Bergeron <ref> [2] </ref> and Zimmermann [18] expanded upon them. Several systems have been developed: Nijenhuis and Wilf [12] in Fortran, Skiena [17] in Mathematica, and Bergeron [2]. Paul Zimmermann [18] has written a Maple package for random generation according to the grammar of construction which in effect gives algorithms for ordered generation. His work forms the starting point for the work reported here. <p> His work forms the starting point for the work reported here. The above operations for enumeration of combinatorial objects (+, , fi, Seq, Cyc, Dih, Set, Bag, I n , C n , D n , A n , S n , S <ref> [2] </ref> , S (2) , S 2 , Conn, UGrf, DSGrf, and DGrf) and for construction (+, , fi, Seq) have been implemented as a library of C++ classes and is available by contacting the author at e-mail address maharri@cs.uiuc.edu. 54 6.2 Uses Sequential construction of combinatorial objects has many uses.
Reference: [3] <author> G. Butler. </author> <title> Fundamental Algorithms for Permutation Groups. </title> <booktitle> Number 559 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: For an arbitrary permutation group, we can compute the cycle index naively by listing all the group elements and adding its appropriate generating function term, using basic group algorithms as in Butler <ref> [3] </ref> and permutation algorithms in Nijenhuis and Wilf [12]. This naive algorithm is as good as we can get; Goldberg [7] has shown this problem to be NP-complete. <p> Since the two permutations generate Sym (n), their images in the permutations on graphs will generate all the graph isomorphisms. Instead of trying to calculate all these permutations, all that is needed is to determine the orbits induced by the graph permutations, with an elementary algorithm (see <ref> [3] </ref>). 37 For example, to enumerate the non-isomorphic graphs of size four, take the set of four vertices labeled 0, 1, 2, and 3.
Reference: [4] <author> N. Chomsky and M. Schutzenberger. </author> <booktitle> The Algebraic Theory of Context-Free Languages, </booktitle> <pages> pages 118-161. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1963. </year>
Reference-contexts: Operation running time graph O p connected O Table 4.2: Running time of graph and connected operators 48 Chapter 5 Power Series, Languages, and Semirings 5.1 Definition The connection between power series and languages began with Chomsky and Schutzenberger <ref> [4] </ref>; they note the relation between the words in a language and formal power series. Kuich and Salomaa [10] describe rational and algebraic power series and their respective relation to regular and context-free languages.
Reference: [5] <author> R. L. Davis. </author> <title> The number of structures of finite relations. </title> <journal> Proceedings of the American Mathematical Society, </journal> <volume> 4 </volume> <pages> 486-495, </pages> <year> 1953. </year>
Reference-contexts: Relations with given properties can be counted (as in Davis <ref> [5] </ref>). Unrestricted relations on n objects are counted by S 2 n [1 + x], the unrestricted directed graphs. Irreflexive relations 45 (or equivalently reflexive) are counted by S (2) n [1 + x], the directed graphs with no self-loops.
Reference: [6] <author> P. Flajolet, B. Salvy, and P. Zimmermann. </author> <title> Automatic average-case analysis of algorithms. </title> <type> Technical Report 1233, </type> <institution> INRIA, Rocquencourt, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: As we will show, this very general problem is not so trivial, is interesting in its own right, and even practical. Flajolet and Zimmermann <ref> [6, 18] </ref> have defined a calculus for the description of general classes of combinatorial structures. They use this calculus both to enumerate the structures, that is to calculate the number of objects of a given size, and to uniformly generate random examples of a given size. <p> The object z is a constant symbol (or equivalently an atom) standing for an object of size or weight one. The object 1 is a constant of weight 0 whose concatenation yields the original. The basic objects and operations on structures are in Table 2.1, extended from Zimmermann's work <ref> [18, 6] </ref>. There are two interpretations of atoms, labeled and unlabeled, which lead to two uses of the constructors. <p> Only the first three correspondences are obvious; the combinatorial explanation of the rest will be shown in the next chapter. These equations can be found in Zimmermann's papers <ref> [6, 18] </ref>; a new derivation of them is given here. A good example of the connections among the constructor, the generating function, and the corresponding class of combinatorial objects is the Fibonacci sequence.
Reference: [7] <author> L. A. Goldberg. </author> <title> Automating Polya theory: The computational complexity of the cycle index polynomial. </title> <journal> Information and Computation, </journal> <volume> 105 </volume> <pages> 268-288, </pages> <year> 1993. </year>
Reference-contexts: This naive algorithm is as good as we can get; Goldberg <ref> [7] </ref> has shown this problem to be NP-complete.
Reference: [8] <author> F. Harary and E. M. Palmer. </author> <title> Graphical Enumeration. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1973. </year> <month> 62 </month>
Reference-contexts: For the more common families of groups, we can compute the cycle index as follows (fol lowing Harary and Palmer <ref> [8] </ref>): * Identity group I n . Sometimes called E n , this is the trivial group whose permutation group is defined by the single permutation (0)(1) : : :(n 1) whose generating term is x n 1 . <p> Only odd cycles are equivalent to an even number of transpositions, so a permutation is odd if it has an odd number of even cycles. Using this, we can take the cycle index for S n and account for even cycles. This is summarized in Table 3.1 (following <ref> [8] </ref>) where (n) is the set of integer partitions of n: he 1 ; e 2 ; : : : ; e n i 2 (n); n = k=1 ke k . <p> by C 4 [x + y] = 1 1 + s 2 = 1 = x 4 + x 3 y + 2x 2 y 2 + xy 3 + y 4 : Combinatorially this is equivalent to the cycles on four points of two colors. 23 Harary and Palmer <ref> [8] </ref> show that operations on permutation groups yield operations on the cycle index. The direct product of two groups gives the product of the two generating functions. The lexicographic composition (or wreath product) of two groups gives the composition of their generating functions. <p> First, we will analyze them alone, and then in the context of other classes of objects. Similar to the basic labeled structures above, labeled graphs are fairly simple objects to enumerate and construct (see <ref> [8, Chap 1.1] </ref>). For an undirected graph on n vertices, there are n possible edges, and therefore 2 ( n 2 ) graphs. These are then simple to unrank; an ordering of subsets of n gives a ranking for the graphs. Enumeration of unlabeled graphs is not so obvious.
Reference: [9] <author> A. Joyal. </author> <title> Une theorie combinatoire des series formelles. </title> <booktitle> Advances in Mathematics, </booktitle> <address> 42(1):1--82, </address> <year> 1981. </year>
Reference-contexts: Joyal <ref> [9] </ref> gave a general method for constructions, and both Bergeron [2] and Zimmermann [18] expanded upon them. Several systems have been developed: Nijenhuis and Wilf [12] in Fortran, Skiena [17] in Mathematica, and Bergeron [2].
Reference: [10] <editor> W. Kuich and A. Salomaa. Semirings, </editor> <booktitle> Automata, Languages, volume 5 of EATCS Monographs in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: Kuich and Salomaa <ref> [10] </ref> describe rational and algebraic power series and their respective relation to regular and context-free languages. The transition from the polynomial enumerating function for a class to the construction of grammars for the class is possible because of their similar algebraic structure: they are both semirings. <p> Both formal power series and languages are semirings. Formal power series over N (for enumeration) form a semiring. Languages form a non-commutative semiring in the following manner (following Kuich and Salomaa <ref> [10] </ref>): Let S be the set of sets of tuples over a finite alphabet, + is disjoint union of sets of tuples, with 0 = ; the empty set, fi is concatenation of sets of tuples, where concatenation of two tuples is the first followed by the second, concatenation of two
Reference: [11] <author> D. J. Lehmann. </author> <title> Algebraic structures for transitive closure. </title> <journal> Theoretical Computer Science, </journal> <volume> 4 </volume> <pages> 59-76, </pages> <year> 1977. </year>
Reference-contexts: states, x 1 as the start state, a transition from state x j to x i with edge label A ij = t if x i ! x j t, and b i is either null if x i is not a final state or * if it is 51 <ref> [11] </ref> showed that Gaussian elimination on systems of linear equations over semirings can solve this system in O . This algorithm is identical to Kleene's algorithm for closure over regular languages.
Reference: [12] <author> A. Nijenhuis and H. S. Wilf. </author> <title> Combinatorial Algorithms. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: For an arbitrary permutation group, we can compute the cycle index naively by listing all the group elements and adding its appropriate generating function term, using basic group algorithms as in Butler [3] and permutation algorithms in Nijenhuis and Wilf <ref> [12] </ref>. This naive algorithm is as good as we can get; Goldberg [7] has shown this problem to be NP-complete. <p> Point-to-point multiplication of polynomials (the Hadamard product) is fi (n), similar to the elementary operations. The operation of computing the kth power of a power series can be accomplished in fi n 2 log k by using repeated squaring. We can modify an fi algorithm by Nijenhuis and Wilf <ref> [12] </ref> to compute the kth power. Their algorithm computes g (x) = (1 + f (x)) k . <p> Here again, a polynomial interpretation is just a homomorphism of letters to variables, the coefficients being positive integers that count the number of derivations. 53 Chapter 6 Conclusion 6.1 Previous Work and Implementations Most other work in construction of combinatorial objects (Reingold, Nievergelt, and Deo [13] and Nijenhuis and Wilf <ref> [12] </ref>) concentrates on the optimal algorithms for sequential construction of permutations, gray codes, and integer partitions. Joyal [9] gave a general method for constructions, and both Bergeron [2] and Zimmermann [18] expanded upon them. Several systems have been developed: Nijenhuis and Wilf [12] in Fortran, Skiena [17] in Mathematica, and Bergeron <p> Nievergelt, and Deo [13] and Nijenhuis and Wilf <ref> [12] </ref>) concentrates on the optimal algorithms for sequential construction of permutations, gray codes, and integer partitions. Joyal [9] gave a general method for constructions, and both Bergeron [2] and Zimmermann [18] expanded upon them. Several systems have been developed: Nijenhuis and Wilf [12] in Fortran, Skiena [17] in Mathematica, and Bergeron [2]. Paul Zimmermann [18] has written a Maple package for random generation according to the grammar of construction which in effect gives algorithms for ordered generation. His work forms the starting point for the work reported here. <p> Either suitable constructions for these objects out of the above operations may be discovered, or new operations for them may be formulated that will fit into this framework. Nijenhuis and Wilf <ref> [12] </ref> considered the set of useful tasks in combinatorial construction on an ordered set of objects to be: * ranking given an object in the set, determine the integer (the rank) specifying that object. * unranking given an integer, construct the corresponding object. * sequencing given an object, construct the `next' <p> By incrementing in a ripple-carry counter, the amortized cost is fi (n). Efficient next algorithms could be made for all the above objects. Nijenhuis and Wilf <ref> [12] </ref> give a number of examples for this, notably the Trotter algorithm for permutations. For an exhaustive survey of permutation algorithms, see Sedgewick [15].
Reference: [13] <author> E. M. Reingold, J. Nievergelt, and N. Deo. </author> <title> Combinatorial Algorithms: Theory and Practice. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood CLiffs, NJ, </address> <year> 1977. </year>
Reference-contexts: Here again, a polynomial interpretation is just a homomorphism of letters to variables, the coefficients being positive integers that count the number of derivations. 53 Chapter 6 Conclusion 6.1 Previous Work and Implementations Most other work in construction of combinatorial objects (Reingold, Nievergelt, and Deo <ref> [13] </ref> and Nijenhuis and Wilf [12]) concentrates on the optimal algorithms for sequential construction of permutations, gray codes, and integer partitions. Joyal [9] gave a general method for constructions, and both Bergeron [2] and Zimmermann [18] expanded upon them.
Reference: [14] <author> A. Salomaa and M. Soittola. </author> <title> Automata-Theoretic Aspects of Formal Power Series. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Note that only the b i are constants in the semiring. 2 Note the notational ambiguity: the class of CFGs is be specified by a regular language. 52 Following Salomaa and Soittola <ref> [14] </ref>, this system of equations also has a solution by closure. It is not necessarily terminating as for regular languages, but it is convergent and so can be computed up to an arbitrary precision, i.e. to an arbitrary word length.
Reference: [15] <author> R. Sedgewick. </author> <title> Permutation generation methods. </title> <journal> Computing Surveys, </journal> <volume> 9 </volume> <pages> 137-164, </pages> <year> 1977. </year>
Reference-contexts: By incrementing in a ripple-carry counter, the amortized cost is fi (n). Efficient next algorithms could be made for all the above objects. Nijenhuis and Wilf [12] give a number of examples for this, notably the Trotter algorithm for permutations. For an exhaustive survey of permutation algorithms, see Sedgewick <ref> [15] </ref>.
Reference: [16] <author> C. C. Sims. </author> <title> Abstract Algebra: A Computational Approach. </title> <publisher> John Wiley and Sons, Inc., </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: Indeed, any permutation preserving adjacency is an allowable isomorphism. This naturally leads to the use of groups; namely, the symmetric group of all permutations acting on the n vertices. 35 4.1 Graph Enumeration by Coset Enumeration For example, following Sims <ref> [16] </ref>, to enumerate the non-isomorphic graphs of size three, take the set of three vertices labeled 1, 2, and 3.
Reference: [17] <author> S. Skiena. </author> <title> Implementing Discrete Mathematics: Combinatorics and Graph Theory with Mathematica. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Joyal [9] gave a general method for constructions, and both Bergeron [2] and Zimmermann [18] expanded upon them. Several systems have been developed: Nijenhuis and Wilf [12] in Fortran, Skiena <ref> [17] </ref> in Mathematica, and Bergeron [2]. Paul Zimmermann [18] has written a Maple package for random generation according to the grammar of construction which in effect gives algorithms for ordered generation. His work forms the starting point for the work reported here.
Reference: [18] <author> P. Zimmermann. Gaa: </author> <title> A package for the random generation of combinatorial structures. </title> <journal> MapleTech, </journal> <volume> 1(1) </volume> <pages> 38-46, </pages> <year> 1994. </year> <month> 63 </month>
Reference-contexts: As we will show, this very general problem is not so trivial, is interesting in its own right, and even practical. Flajolet and Zimmermann <ref> [6, 18] </ref> have defined a calculus for the description of general classes of combinatorial structures. They use this calculus both to enumerate the structures, that is to calculate the number of objects of a given size, and to uniformly generate random examples of a given size. <p> The object z is a constant symbol (or equivalently an atom) standing for an object of size or weight one. The object 1 is a constant of weight 0 whose concatenation yields the original. The basic objects and operations on structures are in Table 2.1, extended from Zimmermann's work <ref> [18, 6] </ref>. There are two interpretations of atoms, labeled and unlabeled, which lead to two uses of the constructors. <p> Only the first three correspondences are obvious; the combinatorial explanation of the rest will be shown in the next chapter. These equations can be found in Zimmermann's papers <ref> [6, 18] </ref>; a new derivation of them is given here. A good example of the connections among the constructor, the generating function, and the corresponding class of combinatorial objects is the Fibonacci sequence. <p> Joyal [9] gave a general method for constructions, and both Bergeron [2] and Zimmermann <ref> [18] </ref> expanded upon them. Several systems have been developed: Nijenhuis and Wilf [12] in Fortran, Skiena [17] in Mathematica, and Bergeron [2]. Paul Zimmermann [18] has written a Maple package for random generation according to the grammar of construction which in effect gives algorithms for ordered generation. <p> Joyal [9] gave a general method for constructions, and both Bergeron [2] and Zimmermann <ref> [18] </ref> expanded upon them. Several systems have been developed: Nijenhuis and Wilf [12] in Fortran, Skiena [17] in Mathematica, and Bergeron [2]. Paul Zimmermann [18] has written a Maple package for random generation according to the grammar of construction which in effect gives algorithms for ordered generation. His work forms the starting point for the work reported here.
References-found: 18

