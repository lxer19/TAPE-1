URL: http://www.iro.umontreal.ca/~larosem/papers/etos.ps.gz
Refering-URL: http://www.iro.umontreal.ca/~larosem/
Root-URL: http://www.iro.umontreal.ca
Email: ffeeley,larosemg@iro.umontreal.ca  
Title: Compiling Erlang to Scheme  
Author: Marc Feeley and Martin Larose 
Address: C.P. 6128 succursale centre-ville Montreal H3C 3J7, Canada  
Affiliation: Universite de Montreal  
Abstract: The programming languages Erlang and Scheme have many common features, yet the performance of the current implementations of Erlang appears to be below that of good implementations of Scheme. This disparity has prompted us to investigate the translation of Erlang to Scheme. Our intent is to reuse the mature compilation technology of current Scheme compilers to quickly implement an efficient Erlang compiler. In this paper we describe the design and implementation of the Etos Er-lang to Scheme compiler and compare its performance to other systems. The Scheme code produced by Etos is compiled by the Gambit-C Scheme to C compiler and the resulting C code is finally compiled by gcc. One might think that the many stages of this compilation pipeline would lead to an inefficient compiler but in fact, on most of our benchmark programs, Etos outperforms all currently available implementations of Erlang, including the Hipe native code compiler. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. L. Armstrong. </author> <title> The development of erlang. </title> <booktitle> In Proceedings of the International Conference on Functional Programming, </booktitle> <pages> pages 196-203, </pages> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Section 2 and Sections 3 briefly describe these languages (a complete description can be found in [3] and [16, 7]). There is growing interest in Erlang in industry but due to its "in-house" development there is a limited choice of compilers. As the implementors of these compilers freely admit <ref> [1] </ref>, "Performance has always been a major problem".
Reference: 2. <author> J. L. Armstrong, B. O. Dacker, S. R. Virding, and M. C. Williams. </author> <title> Implementing a functional language for highly parallel real-time applications. </title> <booktitle> In Proceedings of Software Engineering for Telecommunication Switching Systems, </booktitle> <address> Florence, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: We have compared Etos version 1.4 [9] with three other Erlang compilers: Hipe version 0.27 [17], an extension of the JAM bytecode compiler that selectively compiles bytecodes to native code; - BEAM/C version 4.5.2 [14], compiles Erlang code to C using a register ma chine as intermediate; JAM version 4.4.1 <ref> [2] </ref>, a bytecode compiler for a stack machine. 11.3 Execution Time The measurements were made on a Sun UltraSparc 143 MHz with 122 Mb of memory. Each benchmark program was run 5 times and the average was taken after removing the best and worse times.
Reference: 3. <author> J. L. Armstrong, S. R. Virding, C. Wikstrom, and M. C. Williams. </author> <title> Concurrent Programming in Erlang. </title> <publisher> Prentice Hall, </publisher> <address> second edition, </address> <year> 1996. </year>
Reference-contexts: Scheme shares many similarities with Erlang: "mostly" functional programming style, mandatory tail-call optimization, dynamic typing, automatic memory management, similar data types (symbols, lists, vectors, etc). Section 2 and Sections 3 briefly describe these languages (a complete description can be found in <ref> [3] </ref> and [16, 7]). There is growing interest in Erlang in industry but due to its "in-house" development there is a limited choice of compilers. As the implementors of these compilers freely admit [1], "Performance has always been a major problem".
Reference: 4. <author> Lennart Augustsson. </author> <title> Compiling Pattern Matching. </title> <editor> In Jean-Pierre Jouannaud, editor, </editor> <booktitle> Conference on Functional Programming Languages and Computer Architecture, Nancy, France, </booktitle> <volume> LNCS 201, </volume> <pages> pages 368-381. </pages> <publisher> Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: In the actual implementation of the pattern matching constructs, the patterns are analyzed to detect common tests and factor them out so that they are only executed once (using a top-down, left-right pattern matching technique similar to <ref> [4] </ref>).
Reference: 5. <author> D. Boucher. Lalr-scm. </author> <note> Available at ftp.iro.umontreal.ca in pub/parallele/boucherd. </note>
Reference-contexts: A compact representation is possible in Gambit-C by using bytevectors (arrays of 8, 16 and 32 bit integers). 7 Front End To ensure compatibility with existing Erlang compilers, Etos' parser specification was derived from the one for the JAM interpreter and processed by our own Scheme parser generator <ref> [8, 5] </ref>. The original parser constructs a parse tree built of tuples. Because Etos needs to attach semantic information on the nodes of the parse tree, a conversion phase was added to extend the tree nodes with additional fields.
Reference: 6. <author> W. Clinger. </author> <title> Proper Tail Recursion and Space Efficiency. </title> <booktitle> In Proceedings of the Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 174-185, </pages> <address> Montreal, June 1998. </address> <publisher> ACM Press. </publisher>
Reference-contexts: It is an expression-based language with garbage-collection and so promotes the functional programming style (but side-effects on variables and data-structures are permitted). The language requires that tail-recursion be implemented properly <ref> [6] </ref>. Several builtin data types are available, all of which are first-class and have indefinite extent: boolean, character, string, symbol, list, vector (one dimensional array), procedure (of fixed or variable arity), port (file handle), number (unlimited precision integers and rationals (i.e. exact numbers), and floating point and complex numbers).
Reference: 7. <editor> W. Clinger and J. Rees [editors]. </editor> <title> Revised 4 Report on the Algorithmic Language Scheme. </title> <journal> Lisp Pointers, </journal> <volume> 4(3) </volume> <pages> 1-55, </pages> <month> July-September </month> <year> 1991. </year>
Reference-contexts: Scheme shares many similarities with Erlang: "mostly" functional programming style, mandatory tail-call optimization, dynamic typing, automatic memory management, similar data types (symbols, lists, vectors, etc). Section 2 and Sections 3 briefly describe these languages (a complete description can be found in [3] and <ref> [16, 7] </ref>). There is growing interest in Erlang in industry but due to its "in-house" development there is a limited choice of compilers. As the implementors of these compilers freely admit [1], "Performance has always been a major problem". <p> Etos is written in standard Scheme <ref> [7] </ref> and the generated programs conform fairly closely to the standard. It is clear however that better performance can be achieved if non-standard features of the target Scheme implementation are exploited.
Reference: 8. <author> D. Dube. SILex, </author> <title> user manual. </title> <note> Available at ftp.iro.umontreal.ca in pub/parallele. </note>
Reference-contexts: A compact representation is possible in Gambit-C by using bytevectors (arrays of 8, 16 and 32 bit integers). 7 Front End To ensure compatibility with existing Erlang compilers, Etos' parser specification was derived from the one for the JAM interpreter and processed by our own Scheme parser generator <ref> [8, 5] </ref>. The original parser constructs a parse tree built of tuples. Because Etos needs to attach semantic information on the nodes of the parse tree, a conversion phase was added to extend the tree nodes with additional fields.
Reference: 9. <author> M. Feeley. </author> <note> Etos version 1.4. Compiler available at ftp.iro.umontreal.ca in pub/parallele/etos/etos-1.4. </note>
Reference-contexts: Finally, when the stack cache overflows (because of repeated calls to call/cc or because of a deep recursion), the garbage collector is called to move all reachable frames from the stack cache to the heap. We have compared Etos version 1.4 <ref> [9] </ref> with three other Erlang compilers: Hipe version 0.27 [17], an extension of the JAM bytecode compiler that selectively compiles bytecodes to native code; - BEAM/C version 4.5.2 [14], compiles Erlang code to C using a register ma chine as intermediate; JAM version 4.4.1 [2], a bytecode compiler for a stack
Reference: 10. <author> M. Feeley. </author> <note> Gambit-C version 2.7a, user manual. Compiler available at ftp.iro.umontreal.ca in pub/parallele/gambit/gambit-2.7. </note>
Reference-contexts: Creates 20 processes which send messages in fairly random patterns. - tak (1000 repetitions): Recursive integer arithmetic Takeuchi function. Cal culates tak (18,12,6). 11.2 Erlang Compilers Etos was coupled with the Gambit-C Scheme compiler version 2.7a <ref> [10] </ref>. We will first briefly describe the Gambit-C compiler. The Gambit programming system combines an interpreter and a compiler fully compliant to R 4 RS and IEEE specifications. The Gambit-C compiler translates Scheme programs to portable C code which can run on a wide variety of platforms.
Reference: 11. <author> M. Feeley. </author> <title> Polling efficiently on stock hardware. </title> <booktitle> In Proceedings of the Functional Programming and Computer Architecture Conference, </booktitle> <pages> pages 179-187, </pages> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Gambit-C represents lists using 3 word long pairs as opposed to 2 words on the other systems. Allocation is longer and the GC has more data to copy. 2. Gambit-C guarantees that interrupts are checked at bound intervals <ref> [11] </ref> which is not the case for the other systems. For example, the code generated by Gambit-C for the function app (the most time consuming function of the nrev benchmark) tests interrupts twice as often as Hipe (i.e. on function entry and return). 3.
Reference: 12. <author> M. Feeley, J. Miller, G. Rozas, and J. Wilson. </author> <title> Compiling Higher-Order Languages into Fully Tail-Recursive Portable C. </title> <type> Technical Report 1078, </type> <institution> Departement d'informatique et de recherche operationelle, Universite de Montreal, </institution> <year> 1997. </year>
Reference-contexts: The technique used by Gambit-C to implement proper tail-recursion in C imposes an overhead on function returns as well as calls between modules. For nrev the overhead is high because most of the time is spent in a tight non-tail recursive function. Independent experiments <ref> [12] </ref> have shown that this kind of program can be sped up by a factor of two to four when native code is generated instead of C. Finally ring and stable manipulate processes. Here we see a divergence in the results.
Reference: 13. <author> P. H. Hartel, M. Feeley, M. Alt, L. Augustsson, P. Baumann, M. Beemster, E. Chail-loux, C. H. Flood, W. Grieskamp, J. H. G. Van Groningen, K. Hammond, B. Haus-man, M. Y. Ivory, R. E. Jones, J. Kamperman, P. Lee, X. Leroy, R. D. Lins, S. Loosemore, N. Rojemo, M. Serrano, J.-P. Talpin, J. Thackray, S. Thomas, P. Walters, P. Weis, and P. Wentworth. </author> <title> Benchmarking implementations of functional languages with "Pseudoknot", a float-intensive benchmark. </title> <journal> Journal of Functional Programming, </journal> <volume> 6(4) </volume> <pages> 621-655, </pages> <year> 1996. </year>
Reference-contexts: As the implementors of these compilers freely admit [1], "Performance has always been a major problem". On the other hand there are many implementations of Scheme available [18] and the good compilers appear to generate faster code than the Erlang compilers available from Ericsson (for example Hartel et al. <ref> [13] </ref> have shown that the "pseudoknot" benchmark compiled with Ericsson's BEAM/C 6.0.4 is about 5 times slower than when compiled with the Gambit-C 2.3 Scheme compiler). <p> (5000 repetitions): Compresses and uncompresses a 38 byte string with the Huffman encoder. length (100000 repetitions): Tail recursive function that returns the length of a 2000 element list. - nrev (20000 repetitions): Naive reverse of a 100 element list. - pseudoknot (3 repetitions): Floating-point intensive application taken from molecular biology <ref> [13] </ref>. - qsort (50000 repetitions): Sorts 50 integers using the Quicksort algorithm. ring (100 repetitions): Creates a ring of 10 processes which pass around a token 100000 times. smith (30 repetitions): Matches a DNA sequence of length 32 to 100 other sequences of length 32.
Reference: 14. <author> B. Hausman. </author> <title> Turbo Erlang: approaching the speed of C. </title> <editor> In Evan Tick and Gian-carlo Succi, editors, </editor> <booktitle> Implementations of Logic Programming Systems, </booktitle> <pages> pages 119-135. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference-contexts: We have compared Etos version 1.4 [9] with three other Erlang compilers: Hipe version 0.27 [17], an extension of the JAM bytecode compiler that selectively compiles bytecodes to native code; - BEAM/C version 4.5.2 <ref> [14] </ref>, compiles Erlang code to C using a register ma chine as intermediate; JAM version 4.4.1 [2], a bytecode compiler for a stack machine. 11.3 Execution Time The measurements were made on a Sun UltraSparc 143 MHz with 122 Mb of memory.
Reference: 15. <author> R. Hieb, R. K. Dybvig, and C. Bruggeman. </author> <title> Representing control in the presence of first-class continuations. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(6) </volume> <pages> 66-77, </pages> <year> 1990. </year>
Reference-contexts: Characters and strings are represented using the Uni-code character set (i.e. 16 bit characters). Floating point numbers are boxed and have 64 bits of precision (like the other Erlang compilers used). The implementation of continuations uses an efficient lazy copying strategy similar to <ref> [15] </ref> but of a finer granularity. Continuation frames are allocated in a small area called the "stack cache". This area is managed like a stack (i.e. LIFO allocation) except when the call/cc procedure is called. All frames in the stack cache upon entry to call/cc can no longer be deallocated.
Reference: 16. <institution> IEEE Standard for the Scheme Programming Language. IEEE Standard 1178-1990, IEEE, </institution> <address> New York, </address> <year> 1991. </year>
Reference-contexts: Scheme shares many similarities with Erlang: "mostly" functional programming style, mandatory tail-call optimization, dynamic typing, automatic memory management, similar data types (symbols, lists, vectors, etc). Section 2 and Sections 3 briefly describe these languages (a complete description can be found in [3] and <ref> [16, 7] </ref>). There is growing interest in Erlang in industry but due to its "in-house" development there is a limited choice of compilers. As the implementors of these compilers freely admit [1], "Performance has always been a major problem".
Reference: 17. <author> E. Johansson, C. Jonsson, T. Lindgren, J. Bevemyr, and H. Millroth. </author> <title> A pragmatic approach to compilation of Erlang. </title> <type> UPMAIL Technical Report 136, </type> <institution> Uppsala University, Sweden, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: We have compared Etos version 1.4 [9] with three other Erlang compilers: Hipe version 0.27 <ref> [17] </ref>, an extension of the JAM bytecode compiler that selectively compiles bytecodes to native code; - BEAM/C version 4.5.2 [14], compiles Erlang code to C using a register ma chine as intermediate; JAM version 4.4.1 [2], a bytecode compiler for a stack machine. 11.3 Execution Time The measurements were made on
Reference: 18. <institution> The Internet Scheme Repository. </institution> <note> http://www.cs.indiana.edu/scheme-repository. </note>
Reference-contexts: There is growing interest in Erlang in industry but due to its "in-house" development there is a limited choice of compilers. As the implementors of these compilers freely admit [1], "Performance has always been a major problem". On the other hand there are many implementations of Scheme available <ref> [18] </ref> and the good compilers appear to generate faster code than the Erlang compilers available from Ericsson (for example Hartel et al. [13] have shown that the "pseudoknot" benchmark compiled with Ericsson's BEAM/C 6.0.4 is about 5 times slower than when compiled with the Gambit-C 2.3 Scheme compiler).
Reference: 19. <author> Gerald Jay Sussman and Guy Lewis Steele Jr. </author> <title> SCHEME, an interpreter for extended lambda calculus. AI Memo 349, </title> <address> Mass. </address> <institution> Inst. of Technology, Artificial Intelligence Laboratory, </institution> <address> Cambridge, Mass., </address> <month> December </month> <year> 1975. </year>
Reference-contexts: Scheme is a lexically scoped dialect of Lisp (invented by Sussman and Steele in 1975 <ref> [19] </ref> and enhanced regularly since then) which is both small and expressive. It is an expression-based language with garbage-collection and so promotes the functional programming style (but side-effects on variables and data-structures are permitted). The language requires that tail-recursion be implemented properly [6].
References-found: 19

