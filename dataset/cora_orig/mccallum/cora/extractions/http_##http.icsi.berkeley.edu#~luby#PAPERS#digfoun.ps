URL: http://http.icsi.berkeley.edu/~luby/PAPERS/digfoun.ps
Refering-URL: http://http.icsi.berkeley.edu/~luby/
Root-URL: http://http.icsi.berkeley.edu
Email: Email: byers@icsi.berkeley.edu  Email: luby@icsi.berkeley.edu  Email: michaelm@pa.dec.com  Email: rege@icsi.berkeley.edu  
Title: A Digital Fountain Approach to Reliable Distribution of Bulk Data  
Author: John W. Byers Michael Luby Michael Mitzenmacher Ashutosh Rege 
Address: Palo Alto, California.  
Note: Research supported in part by National Science Foundation operating grant NCR-9416101.  Research supported in part by National Science Foundation operating grant NCR-9416101.  Research supported in part by National Science Foundation operating grant NCR-9416101.  
Affiliation: UC Berkeley and International Computer Science Institute, Berkeley, California.  International Computer Science Institute, Berkeley, California.  Digital Systems Research Center,  International Computer Science Institute, Berkeley, California.  
Pubnum: TR-98-013  
Abstract: The proliferation of applications that must reliably distribute bulk data to a large number of autonomous clients motivates the design of new multicast and broadcast protocols. We describe an ideal, fully scalable protocol for these applications that we call a digital fountain. A digital fountain allows any number of heterogeneous clients to acquire bulk data with optimal efficiency at times of their choosing. Moreover, no feedback channels are needed to ensure reliable delivery, even in the face of high loss rates. We develop a protocol that closely approximates a digital fountain using a new class of erasure codes that for large block sizes are orders of magnitude faster than standard erasure codes. We provide performance measurements that demonstrate the feasibility of our approach and discuss the design, implementation and performance of an experimental system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Acharya, M. Franklin, and S. Zdonik, </author> <title> "Dissemination Based Data Delivery Using Broadcast Disks," </title> <journal> IEEE Personal Communications, </journal> <month> December </month> <year> 1995, </year> <pages> pp. 50-60. 21 </pages>
Reference-contexts: Their approach also does not enable receivers to join the session dynamically. To eliminate the need for retransmission and to allow receivers to access data asynchronously, the use of a data carousel or broadcast disk approach can ensure full reliability <ref> [1] </ref>. In a data carousel approach, the source repeatedly loops through transmission of all data packets. Receivers may join the stream at any time, then listen until they receive all distinct packets comprising the transmission.
Reference: [2] <author> A. Bestavros. </author> <title> "AIDA-based real-time fault-tolerant broadcast disks." </title> <booktitle> In Procedings of the 16th IEEE Real-Time System Symposium, </booktitle> <year> 1996. </year>
Reference: [3] <author> S. Bhattacharyya, J. F. Kurose, D. Towsley, and R. Nagarajan, </author> <title> "Efficient Rate-Controlled Bulk Data Transfer using Multiple Multicast Groups", </title> <booktitle> In Proc. of INFO-COM '98, </booktitle> <address> San Francisco, </address> <month> April </month> <year> 1998. </year>
Reference-contexts: Recently, Bhattacharyya et al. show that a general transmission scheme exists that realizes the one level property for any arbitrary set of layered transmission rates <ref> [3] </ref>. For example, Table 5 demonstrates a simple sending pattern for the rate organization previously described with 4 layers, 4 source data packets, and a stretch factor of 2. Our sending pattern satisfies the One Level Property.
Reference: [4] <author> J. Blomer, M. Kalfane, M. Karpinski, R. Karp, M. Luby, and D. Zuckerman, </author> <title> "An XOR-Based Erasure-Resilient Coding Scheme," </title> <type> ICSI Technical Report No. </type> <institution> TR-95-048, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: In this section, we compare the efficiency of Tornado codes with standard codes that have been previously proposed for network applications [6, 20, 22, 23, 24, 25]. The erasure code listed in Tables 2 and 3 as Cauchy <ref> [4] </ref> is a standard implementations of Reed-Solomon erasure codes based on Cauchy matrices. (We note that the Cauchy implementation, available at [8], is faster for larger values of k than the implementation of Reed-Solomon codes based on Vandermonde matrices by Rizzo [22].) The Tornado Z codes were designed as described earlier
Reference: [5] <author> S. Floyd, V. Jacobson, C. G. Liu, S. McCanne, and L. Zhang, </author> <title> "A Reliable Multi-cast Framework for Light-Weight Sessions and Application Level Framing." </title> <booktitle> In ACM SIGCOMM '95, </booktitle> <pages> pp. 342-356, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: More sophisticated solutions that address these limitations by using techniques such as local repair, polling, or the use of a hierarchy have been proposed <ref> [5, 10, 15, 16, 27] </ref>, but these solutions as yet appear inadequate [19]. Moreover, whereas adaptive retransmission-based solutions are at best unscalable and inefficient on terrestrial networks, they are unworkable on satellite networks, where the back channel typically has high latency and limited capacity, if it is available at all.
Reference: [6] <author> J. </author> <title> Gemmell, "ECSRM Erasure Correcting Scalable Reliable Multicast," </title> <institution> Microsoft Research Technical Report MS-TR-97-20, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: The problems with solutions based on adaptive retransmission have led many researchers to consider applying Forward Error Correction based on erasure codes 1 to reliable multicast <ref> [6, 17, 18, 20, 22, 23, 24, 25] </ref>. <p> In this section, we compare the efficiency of Tornado codes with standard codes that have been previously proposed for network applications <ref> [6, 20, 22, 23, 24, 25] </ref>.
Reference: [7] <author> C. Huitema, </author> <title> "The Case for Packet Level FEC." </title> <booktitle> In Proc. of IFIP 5th Int'l Workshop on Protocols for High Speed Networks, </booktitle> <institution> Sophia Antipolis, France, </institution> <month> October </month> <year> 1996. </year>
Reference-contexts: Their work, and the work of many other authors, focus on erasure codes based on Reed-Solomon codes <ref> [7, 16, 17, 18, 22, 23, 24] </ref>. The limitation of these codes is that encoding and decoding times are slow on large block sizes, effectively limiting k to small values for practical applications.
Reference: [8] <institution> Cauchy-based Reed-Solomon codes. </institution> <note> Available at http://www.icsi.berkeley.edu/~luby. </note>
Reference-contexts: The erasure code listed in Tables 2 and 3 as Cauchy [4] is a standard implementations of Reed-Solomon erasure codes based on Cauchy matrices. (We note that the Cauchy implementation, available at <ref> [8] </ref>, is faster for larger values of k than the implementation of Reed-Solomon codes based on Vandermonde matrices by Rizzo [22].) The Tornado Z codes were designed as described earlier in this section. The implementations were not carefully optimized, so their running times could be improved by constant factors.
Reference: [9] <author> V. Jacobson, "pathchar", </author> <note> available at http://www-nrg.ee.lbl.gov/pathchar. </note>
Reference-contexts: The server and clients were on three different subnets, located at Berkeley, CMU and Cornell. There were 16 hops on the path from Berkeley to CMU, and the bottleneck bandwidth (obtained by using mtrace and pathchar <ref> [9] </ref>) was 8 Mb/s with an RTT of 60 ms. There were 17 hops on the path from Berkeley to Cornell, and the bottleneck bandwidth was 9.3 Mb/s with an RTT of 87 ms. Base layer bandwidth was set at rates ranging from 64 Kb/sec to 512 Kb/sec.
Reference: [10] <author> J. C. Lin and S. Paul, "RMTP: </author> <title> A Reliable Multicast Transport Protocol." </title> <booktitle> In IEEE INFOCOM '96, </booktitle> <pages> pp. 1414-1424, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: More sophisticated solutions that address these limitations by using techniques such as local repair, polling, or the use of a hierarchy have been proposed <ref> [5, 10, 15, 16, 27] </ref>, but these solutions as yet appear inadequate [19]. Moreover, whereas adaptive retransmission-based solutions are at best unscalable and inefficient on terrestrial networks, they are unworkable on satellite networks, where the back channel typically has high latency and limited capacity, if it is available at all.
Reference: [11] <author> M. Luby, M. Mitzenmacher, A. Shokrollahi, D. Spielman, and V. Stemann, </author> <title> "Practical Loss-Resilient Codes." </title> <booktitle> In Proceedings of the 29 th ACM Symposium on Theory of Computing, </booktitle> <year> 1997. </year>
Reference-contexts: As detailed in subsequent sections, the encoding and decoding processing times for standard Reed-Solomon erasure codes are prohibitive even for moderate values of k and n. The alternative we propose is to avoid this cost by using the much faster Tornado codes <ref> [11] </ref>. As always, there is a tradeoff associated with using one code in place of another. The main drawback of using Tornado codes is that the decoder requires slightly more than k of the transmitted packets to reconstruct the source data. <p> We first outline how these codes differ from traditional Reed-Solomon erasure codes. Then we give a specific example of a Tornado code based on <ref> [11, 12] </ref> and compare its performance to a standard Reed-Solomon code. <p> In fact, designing the proper structure for the system of equations so that the number of additional packets and the coding times are simultaneously small is a difficult challenge <ref> [11, 12] </ref>. For Tornado codes, the equations have the form y 3 = x 1 x 4 x 7 , where is bitwise exclusive-or. <p> We specify the code by specifying the random graphs to place between consecutive levels. The mathematics behind this code, which we call Tornado Z, is described in <ref> [11, 12] </ref> and will not be covered here. This code has 16,000 source data nodes and 16,000 redundant nodes. The code uses three levels; the number of nodes in the levels are 16,000, 8,000 and 8,000 respectively. <p> The graph G 2 helps prevent small cycles in G 1 from halting progress during decoding. The second layer uses a graph with a specific distribution, designed using a linear programming tool discussed in <ref> [11, 12] </ref>. The linear program is used to find graphs that have low decoding inefficiency. In this graph, all of the 8,000 nodes on the left have degree 12.
Reference: [12] <author> M. Luby, M. Mitzenmacher, and A. Shokrollahi, </author> <title> "Analysis of Random Processes via And-Or Tree Evaluation." </title> <booktitle> In Proceedings of the 9 th Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <month> January </month> <year> 1998. </year>
Reference-contexts: We first outline how these codes differ from traditional Reed-Solomon erasure codes. Then we give a specific example of a Tornado code based on <ref> [11, 12] </ref> and compare its performance to a standard Reed-Solomon code. <p> In fact, designing the proper structure for the system of equations so that the number of additional packets and the coding times are simultaneously small is a difficult challenge <ref> [11, 12] </ref>. For Tornado codes, the equations have the form y 3 = x 1 x 4 x 7 , where is bitwise exclusive-or. <p> We specify the code by specifying the random graphs to place between consecutive levels. The mathematics behind this code, which we call Tornado Z, is described in <ref> [11, 12] </ref> and will not be covered here. This code has 16,000 source data nodes and 16,000 redundant nodes. The code uses three levels; the number of nodes in the levels are 16,000, 8,000 and 8,000 respectively. <p> The graph G 2 helps prevent small cycles in G 1 from halting progress during decoding. The second layer uses a graph with a specific distribution, designed using a linear programming tool discussed in <ref> [11, 12] </ref>. The linear program is used to find graphs that have low decoding inefficiency. In this graph, all of the 8,000 nodes on the left have degree 12.
Reference: [13] <author> N. F. Maxemchuk, </author> <title> Dispersity Routing in Store and Forward Networks. </title> <type> Ph. D. thesis, </type> <institution> University of Pennsylvania, </institution> <month> May </month> <year> 1975. </year>
Reference-contexts: The key property of a digital fountain is that the source data can be reconstructed intact from any subset of the encoding packets equal in total length to the source data. The digital fountain concept is similar to ideas found in the seminal works of Maxemchuk <ref> [13, 14] </ref> and Rabin [21]. Our approach is to construct better approximations of a digital fountain as a basis for protocols that perform reliable distribution of bulk data. We emphasize that the digital fountain concept is quite general and can be applied in diverse network environments. <p> Those packets that experience congestion are delayed, but the destination can recover the data once a sufficient number of packets arrive, irrespective of the paths they took. This application dates back to the seminal works on dispersity routing by Max-emchuk <ref> [13, 14] </ref> and information dispersal by Rabin [21]. Both suggested using standard erasure codes. We expect Tornado codes will lead to improved practical dispersity routing schemes. Another application for which the Tornado code approximation might be useful arises in the context of mirrored data.
Reference: [14] <author> N. F. Maxemchuk, </author> <title> "Dispersity Routing." </title> <booktitle> Proceedings of ICC '75, </booktitle> <address> San Francisco, CA, </address> <pages> pp. 41-10 - 41-13, </pages> <year> 1975. </year>
Reference-contexts: The key property of a digital fountain is that the source data can be reconstructed intact from any subset of the encoding packets equal in total length to the source data. The digital fountain concept is similar to ideas found in the seminal works of Maxemchuk <ref> [13, 14] </ref> and Rabin [21]. Our approach is to construct better approximations of a digital fountain as a basis for protocols that perform reliable distribution of bulk data. We emphasize that the digital fountain concept is quite general and can be applied in diverse network environments. <p> Those packets that experience congestion are delayed, but the destination can recover the data once a sufficient number of packets arrive, irrespective of the paths they took. This application dates back to the seminal works on dispersity routing by Max-emchuk <ref> [13, 14] </ref> and information dispersal by Rabin [21]. Both suggested using standard erasure codes. We expect Tornado codes will lead to improved practical dispersity routing schemes. Another application for which the Tornado code approximation might be useful arises in the context of mirrored data.
Reference: [15] <author> S. McCanne, V. Jacobson, and M. Vetterli, </author> <title> "Receiver-driven Layered Multicast." </title> <booktitle> In Proc. of ACM SIGCOMM '96, </booktitle> <pages> pp. 117-130, </pages> <year> 1996. </year>
Reference-contexts: More sophisticated solutions that address these limitations by using techniques such as local repair, polling, or the use of a hierarchy have been proposed <ref> [5, 10, 15, 16, 27] </ref>, but these solutions as yet appear inadequate [19]. Moreover, whereas adaptive retransmission-based solutions are at best unscalable and inefficient on terrestrial networks, they are unworkable on satellite networks, where the back channel typically has high latency and limited capacity, if it is available at all. <p> Our implementation is designed for the Internet using a protocol built on top of IP Multicast. We have drawn on existing techniques to handle receiver heterogeneity and congestion control using 15 layered multicast <ref> [15, 18, 25] </ref>. We emphasize that the purpose of developing this system is to demonstrate the feasibility of using Tornado codes in actual systems, and not to create a completely functional multicast protocol for deployment. <p> Then we describe the experimental setup and performance results of our system. 7.1 Layering Across Multiple Multicast Groups The congestion control approach we employ follows the lead of other authors who advocate layered multicast <ref> [15, 18, 25] </ref>. The main idea underlying this approach is to enable the source to transmit data across multiple multicast groups, thereby allowing the receivers to subscribe to an appropriate subset of these layers.
Reference: [16] <author> C. K. Miller, </author> <title> "Reliable Multicast Protocols: A Practical View." </title> <booktitle> In Proc. of the 22nd Annual Conference on Local Computer Networks (LCN '97), </booktitle> <year> 1997. </year>
Reference-contexts: More sophisticated solutions that address these limitations by using techniques such as local repair, polling, or the use of a hierarchy have been proposed <ref> [5, 10, 15, 16, 27] </ref>, but these solutions as yet appear inadequate [19]. Moreover, whereas adaptive retransmission-based solutions are at best unscalable and inefficient on terrestrial networks, they are unworkable on satellite networks, where the back channel typically has high latency and limited capacity, if it is available at all. <p> Their work, and the work of many other authors, focus on erasure codes based on Reed-Solomon codes <ref> [7, 16, 17, 18, 22, 23, 24] </ref>. The limitation of these codes is that encoding and decoding times are slow on large block sizes, effectively limiting k to small values for practical applications.
Reference: [17] <author> J. Nonnenmacher and E. W. Biersack, </author> <title> "Reliable Multicast: Where to Use Forward Error Correction." </title> <booktitle> In Proc. of IFIP 5th Int'l Workshop on Protocols for High Speed Networks, </booktitle> <pages> pp. 134-148, </pages> <institution> Sophia Antipolis, France, </institution> <month> October </month> <year> 1996. </year> <editor> Chapman and Hall. </editor> <volume> 22 </volume>
Reference-contexts: The problems with solutions based on adaptive retransmission have led many researchers to consider applying Forward Error Correction based on erasure codes 1 to reliable multicast <ref> [6, 17, 18, 20, 22, 23, 24, 25] </ref>. <p> Their work, and the work of many other authors, focus on erasure codes based on Reed-Solomon codes <ref> [7, 16, 17, 18, 22, 23, 24] </ref>. The limitation of these codes is that encoding and decoding times are slow on large block sizes, effectively limiting k to small values for practical applications.
Reference: [18] <author> J. </author> <title> Nonnenmacher and E.W. Biersack, "Asynchronous Multicast Push: AMP." </title> <booktitle> In Proc. of International Conference on Computer Communications, </booktitle> <address> Cannes, France, </address> <month> November </month> <year> 1997. </year>
Reference-contexts: The problems with solutions based on adaptive retransmission have led many researchers to consider applying Forward Error Correction based on erasure codes 1 to reliable multicast <ref> [6, 17, 18, 20, 22, 23, 24, 25] </ref>. <p> Their work, and the work of many other authors, focus on erasure codes based on Reed-Solomon codes <ref> [7, 16, 17, 18, 22, 23, 24] </ref>. The limitation of these codes is that encoding and decoding times are slow on large block sizes, effectively limiting k to small values for practical applications. <p> We refer to the ratio n=k as the stretch factor of an erasure code. While this finite stretch factor limits the extent to which erasure codes can approximate a digital fountain, a reasonable approximation proposed by other researchers (e.g., <ref> [18, 22, 23, 25] </ref>), is to set n to be a multiple of k, then repeatedly cycle through transmission of the n encoding packets. <p> Our implementation is designed for the Internet using a protocol built on top of IP Multicast. We have drawn on existing techniques to handle receiver heterogeneity and congestion control using 15 layered multicast <ref> [15, 18, 25] </ref>. We emphasize that the purpose of developing this system is to demonstrate the feasibility of using Tornado codes in actual systems, and not to create a completely functional multicast protocol for deployment. <p> Then we describe the experimental setup and performance results of our system. 7.1 Layering Across Multiple Multicast Groups The congestion control approach we employ follows the lead of other authors who advocate layered multicast <ref> [15, 18, 25] </ref>. The main idea underlying this approach is to enable the source to transmit data across multiple multicast groups, thereby allowing the receivers to subscribe to an appropriate subset of these layers.
Reference: [19] <author> J. Nonnenmacher, M. Lacher, M. Jung, G. Carl, </author> <title> and E.W. Biersack, "How Bad is Reliable Multicast Without Local Recovery?" In Proc. </title> <booktitle> of INFOCOM '98, </booktitle> <address> San Francisco, </address> <month> April </month> <year> 1998. </year>
Reference-contexts: More sophisticated solutions that address these limitations by using techniques such as local repair, polling, or the use of a hierarchy have been proposed [5, 10, 15, 16, 27], but these solutions as yet appear inadequate <ref> [19] </ref>. Moreover, whereas adaptive retransmission-based solutions are at best unscalable and inefficient on terrestrial networks, they are unworkable on satellite networks, where the back channel typically has high latency and limited capacity, if it is available at all.
Reference: [20] <author> J. Nonnenmacher, E. W. Biersack, and D. Towsley, </author> <title> "Parity-Based Loss Recovery for Reliable Multicast Transmission." </title> <booktitle> In Proc. of ACM SIGCOMM '97, </booktitle> <year> 1997. </year>
Reference-contexts: The problems with solutions based on adaptive retransmission have led many researchers to consider applying Forward Error Correction based on erasure codes 1 to reliable multicast <ref> [6, 17, 18, 20, 22, 23, 24, 25] </ref>. <p> number of retransmissions, as a single retransmission of redundant data can potentially benefit many receivers simultaneously. (In other applications, such as real-time video, retransmission may also be undesirable due to timing constraints; we emphasize that we are not considering real-time applications here.) The recent work of Nonnenmacher, Biersack and Towsley <ref> [20] </ref> defines a hybrid approach to reliable multicast, coupling requests for retransmission with transmission of redundant codewords, and quantifies the benefits of this approach in practice. Their work, and the work of many other authors, focus on erasure codes based on Reed-Solomon codes [7, 16, 17, 18, 22, 23, 24]. <p> Recall Reed-Solomon codes have encoding times proportional to k`P and decoding times proportional to keP . As a result, Reed-Solomon codes can only be applied in practice when k and ` are relatively small. (Values used in <ref> [20, 23, 25, 24] </ref> have k and ` ranging from 8 to 256.) In contrast, there are families of Tornado codes that have encoding and decoding times that are proportional to (k + `) ln (1=*)P with decoding inefficiency 1 + *. <p> In this section, we compare the efficiency of Tornado codes with standard codes that have been previously proposed for network applications <ref> [6, 20, 22, 23, 24, 25] </ref>. <p> But another approach, described in the introduction, is the method of interleaving suggested in <ref> [20, 22, 23, 24] </ref>. Interleaved codes are constructed as follows: suppose K + L encoding packets are to be produced from K file packets. Partition the K file packets into blocks of length k, so that there are B = K=k blocks in total. <p> The results we give can be interpolated to provide intuition for performance at intermediate rates of loss. For 13 channels with very low loss rates, such as the 1% loss rates studied in <ref> [20] </ref>, interleaved codes and Tornado have generally comparable performance. experienced for any of the receivers averaged over 100 trials. In these figures, p refers to the probability a packet is lost at each receiver.
Reference: [21] <author> M. O. Rabin, </author> <title> "Efficient Dispersal of Information for Security, Load Balancing, and Fault Tolerance." </title> <journal> In Journal of the ACM, </journal> <volume> Volume 38, </volume> <pages> pp. 335-348, </pages> <year> 1989. </year>
Reference-contexts: The digital fountain concept is similar to ideas found in the seminal works of Maxemchuk [13, 14] and Rabin <ref> [21] </ref>. Our approach is to construct better approximations of a digital fountain as a basis for protocols that perform reliable distribution of bulk data. We emphasize that the digital fountain concept is quite general and can be applied in diverse network environments. <p> Those packets that experience congestion are delayed, but the destination can recover the data once a sufficient number of packets arrive, irrespective of the paths they took. This application dates back to the seminal works on dispersity routing by Max-emchuk [13, 14] and information dispersal by Rabin <ref> [21] </ref>. Both suggested using standard erasure codes. We expect Tornado codes will lead to improved practical dispersity routing schemes. Another application for which the Tornado code approximation might be useful arises in the context of mirrored data.
Reference: [22] <author> L. </author> <title> Rizzo, "Effective Erasure Codes for Reliable Computer Communication Protocols." </title> <booktitle> In Computer Communication Review, </booktitle> <month> April </month> <year> 1997. </year>
Reference-contexts: The problems with solutions based on adaptive retransmission have led many researchers to consider applying Forward Error Correction based on erasure codes 1 to reliable multicast <ref> [6, 17, 18, 20, 22, 23, 24, 25] </ref>. <p> Their work, and the work of many other authors, focus on erasure codes based on Reed-Solomon codes <ref> [7, 16, 17, 18, 22, 23, 24] </ref>. The limitation of these codes is that encoding and decoding times are slow on large block sizes, effectively limiting k to small values for practical applications. <p> We refer to the ratio n=k as the stretch factor of an erasure code. While this finite stretch factor limits the extent to which erasure codes can approximate a digital fountain, a reasonable approximation proposed by other researchers (e.g., <ref> [18, 22, 23, 25] </ref>), is to set n to be a multiple of k, then repeatedly cycle through transmission of the n encoding packets. <p> In this section, we compare the efficiency of Tornado codes with standard codes that have been previously proposed for network applications <ref> [6, 20, 22, 23, 24, 25] </ref>. <p> code listed in Tables 2 and 3 as Cauchy [4] is a standard implementations of Reed-Solomon erasure codes based on Cauchy matrices. (We note that the Cauchy implementation, available at [8], is faster for larger values of k than the implementation of Reed-Solomon codes based on Vandermonde matrices by Rizzo <ref> [22] </ref>.) The Tornado Z codes were designed as described earlier in this section. The implementations were not carefully optimized, so their running times could be improved by constant factors. All experiments were benchmarked on a Sun 167 MHz UltraSPARC 1 with 64 megabytes of RAM running Solaris 2.5.1. <p> But another approach, described in the introduction, is the method of interleaving suggested in <ref> [20, 22, 23, 24] </ref>. Interleaved codes are constructed as follows: suppose K + L encoding packets are to be produced from K file packets. Partition the K file packets into blocks of length k, so that there are B = K=k blocks in total.
Reference: [23] <author> L. Rizzo and L. Vicisano, </author> <title> "A Reliable Multicast data Distribution Protocol Based on Software FEC Techniques." </title> <booktitle> In Proc. of HPCS '97, </booktitle> <address> Greece, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: The problems with solutions based on adaptive retransmission have led many researchers to consider applying Forward Error Correction based on erasure codes 1 to reliable multicast <ref> [6, 17, 18, 20, 22, 23, 24, 25] </ref>. <p> Their work, and the work of many other authors, focus on erasure codes based on Reed-Solomon codes <ref> [7, 16, 17, 18, 22, 23, 24] </ref>. The limitation of these codes is that encoding and decoding times are slow on large block sizes, effectively limiting k to small values for practical applications. <p> Receivers may join the stream at any time, then listen until they receive all distinct packets comprising the transmission. Clearly, the reception overhead at a receiver, measured in terms of unnecessary receptions, can be extremely high using this approach. As shown in <ref> [23, 24] </ref>, adding redundant codewords to the carousel can dramatically reduce reception overhead. These papers advocate adding a fixed amount of redundancy to blocks of the transmission using Reed-Solomon codes. <p> We refer to the ratio n=k as the stretch factor of an erasure code. While this finite stretch factor limits the extent to which erasure codes can approximate a digital fountain, a reasonable approximation proposed by other researchers (e.g., <ref> [18, 22, 23, 25] </ref>), is to set n to be a multiple of k, then repeatedly cycle through transmission of the n encoding packets. <p> Recall Reed-Solomon codes have encoding times proportional to k`P and decoding times proportional to keP . As a result, Reed-Solomon codes can only be applied in practice when k and ` are relatively small. (Values used in <ref> [20, 23, 25, 24] </ref> have k and ` ranging from 8 to 256.) In contrast, there are families of Tornado codes that have encoding and decoding times that are proportional to (k + `) ln (1=*)P with decoding inefficiency 1 + *. <p> In this section, we compare the efficiency of Tornado codes with standard codes that have been previously proposed for network applications <ref> [6, 20, 22, 23, 24, 25] </ref>. <p> But another approach, described in the introduction, is the method of interleaving suggested in <ref> [20, 22, 23, 24] </ref>. Interleaved codes are constructed as follows: suppose K + L encoding packets are to be produced from K file packets. Partition the K file packets into blocks of length k, so that there are B = K=k blocks in total. <p> Of course, using a large stretch factor provides more flexibility, but it slows decoding time and increases the space requirements for decoding. 3 For these reasons, we typically choose a stretch factor c = 2 as compared to c = 8 used in <ref> [23, 24] </ref>, although using larger stretch factors with Tornado codes is certainly feasible.
Reference: [24] <author> E. Schooler and J. </author> <title> Gemmell, "Using multicast FEC to solve the midnight madness problem," </title> <institution> Microsoft Research Technical Report MS-TR-97-25, </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: 1 Introduction A natural solution for software companies that plan to efficiently disseminate new software over the Internet to millions of users simultaneously is multicast or broadcast transmission <ref> [24] </ref>. These transmissions must be fully reliable, have low network overhead, and support vast numbers of receivers with heterogeneous characteristics. Other activities that have similar requirements include distribution of popular images, database replication and popular web site access. <p> The problems with solutions based on adaptive retransmission have led many researchers to consider applying Forward Error Correction based on erasure codes 1 to reliable multicast <ref> [6, 17, 18, 20, 22, 23, 24, 25] </ref>. <p> Their work, and the work of many other authors, focus on erasure codes based on Reed-Solomon codes <ref> [7, 16, 17, 18, 22, 23, 24] </ref>. The limitation of these codes is that encoding and decoding times are slow on large block sizes, effectively limiting k to small values for practical applications. <p> Receivers may join the stream at any time, then listen until they receive all distinct packets comprising the transmission. Clearly, the reception overhead at a receiver, measured in terms of unnecessary receptions, can be extremely high using this approach. As shown in <ref> [23, 24] </ref>, adding redundant codewords to the carousel can dramatically reduce reception overhead. These papers advocate adding a fixed amount of redundancy to blocks of the transmission using Reed-Solomon codes. <p> Recall Reed-Solomon codes have encoding times proportional to k`P and decoding times proportional to keP . As a result, Reed-Solomon codes can only be applied in practice when k and ` are relatively small. (Values used in <ref> [20, 23, 25, 24] </ref> have k and ` ranging from 8 to 256.) In contrast, there are families of Tornado codes that have encoding and decoding times that are proportional to (k + `) ln (1=*)P with decoding inefficiency 1 + *. <p> In this section, we compare the efficiency of Tornado codes with standard codes that have been previously proposed for network applications <ref> [6, 20, 22, 23, 24, 25] </ref>. <p> But another approach, described in the introduction, is the method of interleaving suggested in <ref> [20, 22, 23, 24] </ref>. Interleaved codes are constructed as follows: suppose K + L encoding packets are to be produced from K file packets. Partition the K file packets into blocks of length k, so that there are B = K=k blocks in total. <p> Of course, using a large stretch factor provides more flexibility, but it slows decoding time and increases the space requirements for decoding. 3 For these reasons, we typically choose a stretch factor c = 2 as compared to c = 8 used in <ref> [23, 24] </ref>, although using larger stretch factors with Tornado codes is certainly feasible.
Reference: [25] <author> L. Vicisano, L. Rizzo, and J. Crowcroft. </author> <title> "TCP-like congestion control for layered mul-ticast data transfer." </title> <booktitle> In Proc. of INFOCOM '98, </booktitle> <address> San Francisco, </address> <month> April </month> <year> 1998. </year>
Reference-contexts: The problems with solutions based on adaptive retransmission have led many researchers to consider applying Forward Error Correction based on erasure codes 1 to reliable multicast <ref> [6, 17, 18, 20, 22, 23, 24, 25] </ref>. <p> The performance of the prototype bears out the simulation results, and it also demonstrates the interoperability of this work with the layered multicast techniques of <ref> [25] </ref>. We conclude with additional research directions for the digital fountain approach. 2 Requirements for an Ideal Protocol We recall an example application in which millions of clients want to download a new release of software over the course of several days. <p> We refer to the ratio n=k as the stretch factor of an erasure code. While this finite stretch factor limits the extent to which erasure codes can approximate a digital fountain, a reasonable approximation proposed by other researchers (e.g., <ref> [18, 22, 23, 25] </ref>), is to set n to be a multiple of k, then repeatedly cycle through transmission of the n encoding packets. <p> Recall Reed-Solomon codes have encoding times proportional to k`P and decoding times proportional to keP . As a result, Reed-Solomon codes can only be applied in practice when k and ` are relatively small. (Values used in <ref> [20, 23, 25, 24] </ref> have k and ` ranging from 8 to 256.) In contrast, there are families of Tornado codes that have encoding and decoding times that are proportional to (k + `) ln (1=*)P with decoding inefficiency 1 + *. <p> In this section, we compare the efficiency of Tornado codes with standard codes that have been previously proposed for network applications <ref> [6, 20, 22, 23, 24, 25] </ref>. <p> Our implementation is designed for the Internet using a protocol built on top of IP Multicast. We have drawn on existing techniques to handle receiver heterogeneity and congestion control using 15 layered multicast <ref> [15, 18, 25] </ref>. We emphasize that the purpose of developing this system is to demonstrate the feasibility of using Tornado codes in actual systems, and not to create a completely functional multicast protocol for deployment. <p> Then we describe the experimental setup and performance results of our system. 7.1 Layering Across Multiple Multicast Groups The congestion control approach we employ follows the lead of other authors who advocate layered multicast <ref> [15, 18, 25] </ref>. The main idea underlying this approach is to enable the source to transmit data across multiple multicast groups, thereby allowing the receivers to subscribe to an appropriate subset of these layers. <p> Thus, a receiver at subscription level i would receive bandwidth proportional to 2B i , for i 1. The protocol we use is based on the scheme described in recent work of Vicisano, Rizzo and Crowcroft <ref> [25] </ref> that proposes the following two novel ideas, summarized here briefly: * Congestion control is achieved by the use of synchronization points (SP's) that are specially marked packets in the stream. <p> These features are particularly important in the context of a digital fountain in which receiver-to-source and inter-receiver communication are undesirable. Moreover, the work of <ref> [25] </ref> demonstrates how to set transmission rates and the interarrival time between SP's so that the resulting congestion control policy is TCP-friendly, and shares bandwidth in a comparable way to point-to-point TCP connections. We refer the reader to [25] for further details. 7.2 Scheduling Packet Transmissions Across Multiple Multicast Groups As <p> Moreover, the work of <ref> [25] </ref> demonstrates how to set transmission rates and the interarrival time between SP's so that the resulting congestion control policy is TCP-friendly, and shares bandwidth in a comparable way to point-to-point TCP connections. We refer the reader to [25] for further details. 7.2 Scheduling Packet Transmissions Across Multiple Multicast Groups As described earlier, a receiver at level i subscribes to all layers 0 through i. <p> When running the layered protocol, we used 4 layers. In our initial experiments, in some cases we witnessed loss rates over the course of the transmission of over 20% rates that are admittedly far higher than the congestion control techniques of <ref> [25] </ref> were intended to handle. To generate even higher loss rates that might arise in other environments, such as mobile wireless networks, the base layer rate was set artificially high, causing a router along the path to drop packets persistently.
Reference: [26] <author> M. Yajnik, J. Kurose, and D. Towsley, </author> <title> "Packet Loss Correlation in the MBone Multicast Network." </title> <booktitle> In Proceedings of IEEE Global Internet '96, </booktitle> <address> London, </address> <month> November </month> <year> 1996. </year>
Reference-contexts: This effect is completely avoided by using Tornado codes. 14 6.4 Trace-Driven Simulations To study the impact of bursty loss patterns on the relative performance of Reed-Solomon and Tornado code approaches, we perform a similar comparison using publicly available MBone trace data collected by Yajnik, Kurose, and Towsley <ref> [26] </ref>. In these traces, between six and twenty clients from the US and abroad subscribed to MBone broadcasts each of roughly an hour in length and reported which packets they received.
Reference: [27] <author> R. Yavatkar, J. Griffoen and M. Sudan, </author> <title> "A Reliable Dissemination Protocol for Interactive Collaborative Applications." </title> <booktitle> In Proceedings of ACM Multimedia '95, </booktitle> <address> San Francisco, </address> <year> 1995, </year> <pages> pp. 333-344. 23 </pages>
Reference-contexts: More sophisticated solutions that address these limitations by using techniques such as local repair, polling, or the use of a hierarchy have been proposed <ref> [5, 10, 15, 16, 27] </ref>, but these solutions as yet appear inadequate [19]. Moreover, whereas adaptive retransmission-based solutions are at best unscalable and inefficient on terrestrial networks, they are unworkable on satellite networks, where the back channel typically has high latency and limited capacity, if it is available at all.
References-found: 27

