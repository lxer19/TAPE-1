URL: http://charm.cs.uiuc.edu/version2/papers/DaggerLatencyISCIS93.ps
Refering-URL: http://charm.cs.uiuc.edu/version2/papers/DaggerLatencyISCIS93.html
Root-URL: http://www.cs.uiuc.edu
Email: fgursoy,kaleg@cs.uiuc.edu  
Title: Tolerating Latency with Dagger  
Author: Attila Gursoy and L.V.Kale 
Address: Urbana IL 61801, USA  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract: The communication latency is a major issue that must be dealt with in parallel computing. The parallel computation model therefore must provide the ability to tolerate such latencies. Communication using blocking receives is the commonly used mechanism in parallel programming today. Message driven execution is an alternate mechanism which does not use receive style statements at all. The message driven execution style promotes the overlap of computation and communication: Programs written in this style exhibit increased latency tolerance. However, they are often difficult to develop and debug. We present a coordination language called Dagger to alleviate this problem. The language has a mechanism which is called expect, that replaces the receive statement. It has been implemented in the Charm parallel programming system, and runs programs portably on a variety of parallel machines.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G.Agha, </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press. </publisher> <year> 1986. </year>
Reference-contexts: The Dagger version tolerates the increase in the latency as well as any computational delay occurring in other processors (A processor might be waiting for a reply from another one which might be busy to reply immediately). 7. RELATED WORK The original Actor model as described in <ref> [1] </ref> is purely message driven. The issue of synchronization within an actor was addressed in [10] which proposed the enable set construct. The enable construct is analogous to our expect statement.
Reference: [2] <author> W.Dally, and et al. </author> <title> "The J-Machine: A Fine-Grain Concurrent Computer", </title> <booktitle> In IFIP Congress, </booktitle> <year> 1989. </year>
Reference-contexts: Dealing with this latency is therefore a major objective in parallel processing. On the hardware side, this is being addressed by designing architectures that reduce the latency to the minimum. The ALLCACHE architecture of the KSR-1 machine, and the message-processor architecture of J-Machine <ref> [2] </ref> are examples of these attempts as well as the continuous evolution of communication hardware in the traditional architectures of Intel and NCUBE machines. However, physical reality dictates that remote access will always be significantly slower than local access. Software techniques for tolerating latency are therefore essential.
Reference: [3] <author> S.Frolund, G.Agha, </author> <title> "Activation of Concurrent Objects by Message Sets", </title> <type> Internal Report, </type> <institution> University of Illinois at Urbana-Champaign. </institution>
Reference-contexts: The enable construct is analogous to our expect statement. However, there is no analogue of a when-block viz. a computation block that can be executed only when a specific group of messages have arrived. A more recent paper <ref> [3] </ref> supports much more complex model which subsumes synchronization of multiple actors depending on message sets. It should be noted that Dagger/Charm provides a programming model that differs from Actors in many ways. The discussion above only focuses on how they deal with message driven execution.
Reference: [4] <author> T.von Eicken, D.E.Culler, S.C.Goldstein, K.E. Schauser, </author> <title> "Active Messages: a Mechanism for Integrated Communication and Computation", </title> <booktitle> Proceedings of the 19 th Int'l Symposium on Computer Architecture, </booktitle> <address> Australia, </address> <month> May </month> <year> 1992, </year> <month> pp256-266. </month>
Reference-contexts: It should be noted that Dagger/Charm provides a programming model that differs from Actors in many ways. The discussion above only focuses on how they deal with message driven execution. Recent work on Active messages <ref> [4] </ref> also deals with message driven execution and split phase transactions. The split-C language based on this employs polling for arrival of messages. However the TAM compiler built on Active messages has some similarities to Dagger.
Reference: [5] <author> A.S.Grimshaw, </author> <title> Mentat : An Object Oriented Macro Data Flow System, UIUCDCS-R-88-1440, </title> <type> Ph.D Thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: Counters and flags for synchronizing on arrival of multiple messages are explicitly maintained. However, TAM is meant as the back end for a data flow compiler as opposed to a language meant application programmer. So these inconveniences may not be of much consequences. Macro data flow <ref> [5] </ref> approaches share with us the objective of message driven execution and local synchronization. However, much of the past work in this area has aimed at special purpose hardware.
Reference: [6] <author> A.Gursoy, L.V.Kale, "Dagger: </author> <title> combining the benefits of synchronous and asynchronous communication styles", </title> <type> Report 93-3, </type> <institution> Parallel Programming Laboratory, Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Another example is a client-server type of computation. Client processes may send multiple requests concurrently to a server dag. The server dag performs the same computation for different requests concurrently. This type of computations are supported by the reference number mechanism. Details about these features can be found in <ref> [6] </ref>. 5.1. Preliminary Performance Results In this section we present some preliminary performance results obtained by using programs written in Dagger language. Global reduction operations (such as finding maximum) are very common in many scientific applications.
Reference: [7] <author> A.Gursoy, L.V.Kale, </author> <title> "Simulating message driven programs",Report 93-9, Parallel Programming Laboratory, </title> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: In addition to communication latency, dagger message handling overhead (matching and queueing messages, scheduling when-blocks) is included in simulation time. The details of the simulation and the abstract parallel machine model can be found in <ref> [7] </ref>. 2 [For correct simulation] a variable defined in one when-block must not be used or defined in an incomparable block. 6 1000 3000 1 2 4 8 16 32 64 128 256 time (ms) number of processors (a) Concurrent Reductions blocking-receive 3 3 3 3 3 Dagger + + +
Reference: [8] <author> L.V.Kale, </author> <title> "The Chare Kernel parallel programming language and system", </title> <booktitle> Proceedings of the International Conference on Parallel Processing, </booktitle> <volume> Vol II, </volume> <month> Aug </month> <year> 1990, </year> <month> pp17-25. </month>
Reference-contexts: In addition to that, split-phase style of programming that it requires complicates the flow of control. We propose a coordination language called Dagger which retains the benefits of the message-driven execution, while reducing the complexity of the resultant programs. Dagger programs run on top of Charm <ref> [8] </ref> which is a message-driven system. Dagger allows specification of processes in terms of dependences between messages and pieces of computations. These dependences form a partial order 1 which clarifies the flow of control. <p> Many parallel applications contain sufficient parallelism to exploit this fact. Therefore, the ability of tolerating these latencies is an important issue in a parallel programming language. 3. CHARM A MESSAGE DRIVEN SYSTEM Charm <ref> [8] </ref> is a machine independent parallel programming system. Programs written using this system will run unchanged on MIMD machines with or without a shared memory. The programs are written in C with a few syntactic extensions.
Reference: [9] <author> E.Kornkven, </author> <title> "Overlapping Computation and Communication in an Implementation of A Data Parallel Language", </title> <type> Report 92-4, </type> <institution> Parallel Programming Laboratory, Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> Oct </month> <year> 1992. </year>
Reference-contexts: Macro data flow [5] approaches share with us the objective of message driven execution and local synchronization. However, much of the past work in this area has aimed at special purpose hardware. Our experience with using Dagger as back-end for a compiler for a data parallel language <ref> [9] </ref> indicates that the dagger might provide more convenient intermediate language than macro data flow. 7 8. CONCLUSION The communication latency and other delays in remote responses are a major source of inefficiency of parallel computations. Therefore dealing this latency is essential in parallel computing.
Reference: [10] <author> C.Tomlinson, V.Singh, </author> <title> "Inheritance and Synchronization with Enabled-Sets", </title> <booktitle> ACM OOPSLA 1989 , pp103-112. </booktitle>
Reference-contexts: RELATED WORK The original Actor model as described in [1] is purely message driven. The issue of synchronization within an actor was addressed in <ref> [10] </ref> which proposed the enable set construct. The enable construct is analogous to our expect statement. However, there is no analogue of a when-block viz. a computation block that can be executed only when a specific group of messages have arrived.
Reference: [11] <institution> The CHARM(3.0) programming language manual, Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana, IL, </institution> <year> 1992. </year> <month> 8 </month>
Reference-contexts: Entry-point definitions start with an entry name, a message name, followed by a block of C statements and Charm system calls. Details about these systems calls (such as CreateChare, SendMsg), and other features of the system (information sharing abstract data types) can be found in <ref> [11] </ref>. The Charm runtime system is message driven.
References-found: 11

