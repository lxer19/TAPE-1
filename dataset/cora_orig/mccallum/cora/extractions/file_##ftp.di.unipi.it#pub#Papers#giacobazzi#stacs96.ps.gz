URL: file://ftp.di.unipi.it/pub/Papers/giacobazzi/stacs96.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: giaco@di.unipi.it  
Title: "Optimal" Collecting Semantics for Analysis in a Hierarchy of Logic Program Semantics  
Author: Roberto Giacobazzi 
Address: Corso Italia 40, 56125 Pisa, Italy  
Affiliation: Dipartimento di Informatica, Universita di Pisa  
Abstract: In this paper we apply abstract interpretation to systematically derive, compose and compare semantics according to their expressive power. The main results are: (1) a definition of a hierarchy of collecting semantics, including well known semantics for logic programs, where semantics can be related to each other by abstract interpretation; (2) a characterization of collecting and abstract semantics in terms of collecting and abstract models for a program; (3) a correspondence between collecting and abstract models providing a "logical" interpretation of the typical loss of precision of abstract interpretation-based analysis; (4) a systematic approach to derive and compose collecting semantics in a lattice-theoretic environment; (5) a constructive characterization for the "best" collecting semantics for analysis. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> K. R. Apt. </author> <title> Introduction to logic programming. </title> <editor> In J. van Leeuwen, ed., </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> vol. B, </volume> <pages> pp. 495-574. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: This view of collecting semantics is particularly appealing in logic programming, where for instance the distinction between declarative and procedural reading of programs identifies precisely this space of collecting semantics. 2 Preliminaries In the following, we will assume familiarity with the standard notions of logic programming (e.g. see <ref> [1] </ref>), abstract interpretation ([11, 12]) and lattice theory. Let A and B be sets. Set isomorphism is denoted ~ = . The isomorphism - : A ! B is denoted A ~ = - B. The powerset of A is denoted by -(A).
Reference: 2. <author> T. Armstrong, K. Marriott, P. Schachte, and H. Stndergaard. </author> <title> Boolean functions for dependency analysis: algebraic properties and efficient representation. </title> <editor> In B. Le Char-lier, ed., </editor> <booktitle> Proc. SAS'94 , LNCS 864, </booktitle> <pages> pp. 266-280, </pages> <year> 1994. </year>
Reference-contexts: By Galois insertion it is easy to prove that if M a 2 A and fl (M a ) is a collecting model, then M a is always an abstract model. Example 4.3 The domain Def (see <ref> [2] </ref>) of positive Boolean functions whose models are closed under intersection, was proposed by Marriott and Stndergaard as an abstract domain for ground dependency analysis. Def is a set of propositional formulae constructed using the connectives ! and ^, and ordered by implication. <p> Def is a set of propositional formulae constructed using the connectives ! and ^, and ordered by implication. In Def , the formula y ^ (x $ z ) means that y is ground, and x is ground iff z is ground (cf. <ref> [2] </ref>). We denote Def the corresponding property on -(Atom).
Reference: 3. <author> R. Barbuti, M. Codish, R. Giacobazzi, and M. Maher. </author> <title> Oracle semantics for PROLOG. </title> <booktitle> In Proc. ALP'92 , LNCS 632, </booktitle> <pages> pp. 100-114, </pages> <year> 1992. </year> <note> To appear in Inf. & Comp.. </note>
Reference-contexts: SLD, with arbitrary elements . 0 denotes the first element of the trace . s 2 State s 2 T P (SLD) c s ! 2 T P (SLD ) It is a common practice in logic program semantics to restrict the interest to AND-compositional execution traces only (e.g., in <ref> [3, 15, 23] </ref>). Intuitively a set of traces is AND-compositional if the execution trace of any (possibly non-atomic) goal can be reconstructed by composing traces for atomic goals in the set. The inductive definition of the set E of AND-compositional execution traces for atomic goals is in Table 1. <p> This semantics has been recently used in <ref> [3] </ref> to model Prolog depth-first search. * The sequence abstraction ff fl is obtained by approximating finite traces by the pair of their initial and final states in a clause-like form: ff fl : -(T & P (SLD )) ! -(Clause) is such that ff fl (X ) = fh b
Reference: 4. <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A general framework for semantics-based bottom-up abstract interpretation of logic programs. </title> <journal> TOPLAS, </journal> <volume> 15(1) </volume> <pages> 133-181, </pages> <year> 1993. </year>
Reference-contexts: This semantics has been successfully considered as a base semantics for abstraction, and applied to static program analysis in <ref> [4, 8] </ref>. Clark's semantics instead has mostly a theoretical interest, being fully abstract wrt. the "more abstract" notion of correct answers for a program ([15]). However, as we will show in Section 6, this simpler semantics may provide a sound basis for analysis of non-trivial program properties. <p> Example 6.6 Most of the (bottom-up) abstract interpretations designed for success pattern approximation are based on the abstraction of s collecting semantics (e.g., <ref> [4, 8] </ref>). However, notice that the property Def is extendible to Clark's semantics and Def ffiT s P ffi Def = Def ffiT c P ffiinstffi Def , i.e., s collecting semantics is (too) concrete wrt. Def . <p> By Theorem 6.7, and because Def is strictly more abstract than Sharing , the best semantics for aliasing analysis in logic programs is strictly more abstract than s and strictly more concrete than Clark's semantics. 7 Related works In logic programming, the most related works are <ref> [4, 10, 13, 16, 19] </ref>. [19] firstly applied a notion of core semantics to build collecting semantics. The approach however was neither oriented to a systematic design of semantics nor provided with a model-theoretic interpretation for collecting and abstract semantics. <p> The approach however was neither oriented to a systematic design of semantics nor provided with a model-theoretic interpretation for collecting and abstract semantics. While [13] firstly observed that H is an abstract interpretation of a more concrete backward semantics, <ref> [4] </ref> firstly characterized abstract models for program analysis based (only) on s semantics. In [16] H, Clark's and s semantics are related, providing a model-theoretic interpretation for s-models. <p> In [16] H, Clark's and s semantics are related, providing a model-theoretic interpretation for s-models. We combine and extend those approaches in the first part of the paper, introducing a generic notion of collecting semantics for logic programs. This includes some results in <ref> [4, 16] </ref> as a special case of some of the results in Section 3. Moreover, by using abstract interpretation, we can systematically derive and compare collecting semantics, and constructively define "optimal" collecting semantics for analysis.
Reference: 5. <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> A compositional semantics for logic programs. </title> <journal> TCS , 122(1-2):3-47, </journal> <year> 1994. </year>
Reference-contexts: This abstraction induces a semantics which is equivalent to the compositional semantics for partial answers in <ref> [5, 17] </ref>. This semantics has been used for compositional analysis of modular logic programs in [9]. The semantics for call patterns in [17] can also be derived by further approximating partial answers.
Reference: 6. <author> A. Batarekh and V. S. Subrahmanian. </author> <title> Topological model set deformations. </title> <journal> Funda-menta Informatic, </journal> <volume> 12 </volume> <pages> 357-400, </pages> <year> 1989. </year>
Reference-contexts: If M a is an abstract model of P , then fl (M a ) is a collecting model of P . Under the previous hypothesis: an abstract interpretation is an abstract model iff its concretization is a collecting model. In this case, is a model deformation <ref> [6] </ref>, i.e., maps collecting models into collecting models: if M is a model for P then M v (M ), and (M ) is also a model for P. 5 Systematic design of systems of collecting semantics The only constraint we have on collecting semantics is that they have to include
Reference: 7. <author> M. Bruynooghe. </author> <title> A practical framework for the abstract interpretation of logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 10 </volume> <pages> 91-124, </pages> <year> 1991. </year>
Reference-contexts: for instance, it is often the case that collecting interpretations are derived by abstracting SLD resolution, without providing any corresponding model-theoretic interpretation, and the collecting semantics turn out to be often too far from the intended logical meaning of the program: its Herbrand model (e.g., see the operational framework in <ref> [7] </ref>, or the denotational one in [19]). In this paper we introduce a new approach to collecting semantics design and analysis, and apply it to the case of logic programs.
Reference: 8. <author> M. Codish, D. Dams, and E. Yardeni. </author> <title> Bottom-up abstract interpretation of logic programs. </title> <journal> TCS , 124(1) </journal> <pages> 93-126, </pages> <year> 1994. </year>
Reference-contexts: This semantics has been successfully considered as a base semantics for abstraction, and applied to static program analysis in <ref> [4, 8] </ref>. Clark's semantics instead has mostly a theoretical interest, being fully abstract wrt. the "more abstract" notion of correct answers for a program ([15]). However, as we will show in Section 6, this simpler semantics may provide a sound basis for analysis of non-trivial program properties. <p> Example 6.6 Most of the (bottom-up) abstract interpretations designed for success pattern approximation are based on the abstraction of s collecting semantics (e.g., <ref> [4, 8] </ref>). However, notice that the property Def is extendible to Clark's semantics and Def ffiT s P ffi Def = Def ffiT c P ffiinstffi Def , i.e., s collecting semantics is (too) concrete wrt. Def .
Reference: 9. <author> M. Codish, S. Debray, and R. Giacobazzi. </author> <title> Compositional analysis of modular logic programs. </title> <booktitle> In ACM POPL '93 , pp. </booktitle> <pages> 451-464, </pages> <year> 1993. </year>
Reference-contexts: This abstraction induces a semantics which is equivalent to the compositional semantics for partial answers in [5, 17]. This semantics has been used for compositional analysis of modular logic programs in <ref> [9] </ref>. The semantics for call patterns in [17] can also be derived by further approximating partial answers. Recall that an atom a 2 Atom is a call pattern for a goal G in a program P if G c ! fl a j b 2 T P (SLD ).
Reference: 10. <author> M. Comini and G. Levi. </author> <title> An algebraic theory of observables. </title> <editor> In M. Bruynooghe, ed., </editor> <booktitle> Proc. </booktitle> <pages> ILPS'94 , pp. 172-186, </pages> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Model completeness specifies that, from core semantics viewpoint, T and T 0 are equivalent. Notice that the condition T ffiff = ffffiT 0 is stronger than T = ffffiT 0 ffifl (see [13]). Note also that model completeness corresponds precisely to compatibility between semantics and observations in <ref> [10] </ref>. Proposition 3.5 Let P be a program and hC ; T i fl ff be a model complete collecting semantics. <p> By Theorem 6.7, and because Def is strictly more abstract than Sharing , the best semantics for aliasing analysis in logic programs is strictly more abstract than s and strictly more concrete than Clark's semantics. 7 Related works In logic programming, the most related works are <ref> [4, 10, 13, 16, 19] </ref>. [19] firstly applied a notion of core semantics to build collecting semantics. The approach however was neither oriented to a systematic design of semantics nor provided with a model-theoretic interpretation for collecting and abstract semantics. <p> Moreover, by using abstract interpretation, we can systematically derive and compare collecting semantics, and constructively define "optimal" collecting semantics for analysis. The approach is general enough to include also different semantics like Heyting's semantics, semantics for call patterns etc. Independently, <ref> [10] </ref> also applied abstract interpretation to derive semantics by abstraction from SLD trees, similarly to Section 5. The main difference with our approach is that [10] does not consider a core semantics in concrete semantic definitions. <p> The approach is general enough to include also different semantics like Heyting's semantics, semantics for call patterns etc. Independently, <ref> [10] </ref> also applied abstract interpretation to derive semantics by abstraction from SLD trees, similarly to Section 5. The main difference with our approach is that [10] does not consider a core semantics in concrete semantic definitions. Core semantics is here a key notion in order to extend to collecting and abstract semantics many of the (desirable) properties of the standard semantics of logic programs, like its simplicity and its model-theoretic interpretation.
Reference: 11. <author> P. & R. Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In ACM POPL'77 , pp. </booktitle> <pages> 238-252, </pages> <year> 1977. </year>
Reference: 12. <author> P. & R. Cousot. </author> <title> Systematic design of program analysis frameworks. </title> <booktitle> In ACM POPL'79 pp. </booktitle> <pages> 269-282, </pages> <year> 1979. </year>
Reference-contexts: It is well known (e.g., <ref> [12] </ref>) that in any Galois insertion (B; ff; A; fl), flffiff 2 uco (B), and flffiff (B) ~ = ff A. Throughout, , and Var will respectively denote a set of function symbols, a set of predicate symbols and a denumerable set of variables, defining a first-order language L. <p> Given a Galois insertion (B; ff; A; fl), Cousot & Cousot in <ref> [12] </ref> proved that it is always possible to associate with any operator T : B ! B , an operator which is the best correct approximation of T in A: namely the function ffffiT ffifl. <p> It is known that (C ; ff ; A; fl ) is a Galois insertion <ref> [12] </ref>. Definition 4.1 Let S = hC ; T i and X be collecting semantics such that S fl * ) ff X . A property on X is extendible to S iff ffffiffifl 2 uco (C ). ffffiffifl is the induced property on S. <p> It is well known that for a property on a collecting semantics hC ; T i, the best correct abstract interpretation is hA; ff ffiT ffifl i where A ~ = (C ) (cf. <ref> [12] </ref>). Definition 4.2 [abstract model-theoretic semantics] Let P be a logic program and hC ; T ; ; A; T a i be an abstract interpretation.
Reference: 13. <author> P. & R. Cousot. </author> <title> Abstract interpretation and applications to logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2-3):103-179, </volume> <year> 1992. </year>
Reference-contexts: It is straightforward to prove that the sequential composition of model complete collecting semantics is model complete. Model completeness specifies that, from core semantics viewpoint, T and T 0 are equivalent. Notice that the condition T ffiff = ffffiT 0 is stronger than T = ffffiT 0 ffifl (see <ref> [13] </ref>). Note also that model completeness corresponds precisely to compatibility between semantics and observations in [10]. Proposition 3.5 Let P be a program and hC ; T i fl ff be a model complete collecting semantics. <p> By Theorem 6.7, and because Def is strictly more abstract than Sharing , the best semantics for aliasing analysis in logic programs is strictly more abstract than s and strictly more concrete than Clark's semantics. 7 Related works In logic programming, the most related works are <ref> [4, 10, 13, 16, 19] </ref>. [19] firstly applied a notion of core semantics to build collecting semantics. The approach however was neither oriented to a systematic design of semantics nor provided with a model-theoretic interpretation for collecting and abstract semantics. <p> The approach however was neither oriented to a systematic design of semantics nor provided with a model-theoretic interpretation for collecting and abstract semantics. While <ref> [13] </ref> firstly observed that H is an abstract interpretation of a more concrete backward semantics, [4] firstly characterized abstract models for program analysis based (only) on s semantics. In [16] H, Clark's and s semantics are related, providing a model-theoretic interpretation for s-models.
Reference: 14. <author> P. & R. Cousot. </author> <title> Inductive definitions, semantics and abstract interpretation. </title> <booktitle> In ACM POPL'92 , pp. </booktitle> <pages> 83-94, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction The definition of an appropriate concrete semantics being able to model those program properties of interest, is a key point in abstract interpretation ([11]) and semantic-based dataflow analysis. As shown in <ref> [14] </ref>, the choice of the operational semantics is usually the most appropriate one, as it is always possible to derive more abstract semantics (e.g., the denotational semantics) by abstract interpretation.
Reference: 15. <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative modeling of the operational behavior of logic languages. </title> <journal> TCS , 69(3) </journal> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: It is well known that a Herbrand interpretation M is a Herbrand model iff T P (M ) M ([1]). H-models are therefore the Herbrand models of the program. s semantics has been introduced in <ref> [15] </ref> in order to provide a fully abstract description of computed answer substitutions of logic programs. This semantics has been successfully considered as a base semantics for abstraction, and applied to static program analysis in [4, 8]. <p> i respectively, where T s fi fi C = h b 2 P ; b 0 &lt;&lt; C I P (I ) = h# fi fi # 2 Sub; b# 2 I It is easy to prove that H is an abstract interpretation of the (more concrete) s semantics in <ref> [15] </ref>, where (-(Atom) ; ground; -(Atom ; ) ; fl g ) is a Galois insertion with fl g = I :fA j ground (A) I g, and T P = groungffiT s P ffifl g . <p> SLD, with arbitrary elements . 0 denotes the first element of the trace . s 2 State s 2 T P (SLD) c s ! 2 T P (SLD ) It is a common practice in logic program semantics to restrict the interest to AND-compositional execution traces only (e.g., in <ref> [3, 15, 23] </ref>). Intuitively a set of traces is AND-compositional if the execution trace of any (possibly non-atomic) goal can be reconstructed by composing traces for atomic goals in the set. The inductive definition of the set E of AND-compositional execution traces for atomic goals is in Table 1.
Reference: 16. <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A model-theoretic reconstruction of the operational semantics of logic programs. </title> <journal> Inf. & Comp., </journal> <volume> 102(1) </volume> <pages> 86-113, </pages> <year> 1993. </year>
Reference-contexts: Indeed, inst 2 uco (-(Atom)), naturally inducing a Galois insertion. In particular, hinst (-(Atom)); T c P i is a collecting semantics and T c P ffiinst = instffiT s P (cf. <ref> [16] </ref>). Clark's semantics is model complete, i.e. groundffiT c P = T P ffiground (cf. [16]), and therefore by composition, s semantics is also model complete. Heyting's semantics for logic programs has been introduced in [20] to provide an intuitionistic (constructive) interpretation for definite clause programs. <p> Indeed, inst 2 uco (-(Atom)), naturally inducing a Galois insertion. In particular, hinst (-(Atom)); T c P i is a collecting semantics and T c P ffiinst = instffiT s P (cf. <ref> [16] </ref>). Clark's semantics is model complete, i.e. groundffiT c P = T P ffiground (cf. [16]), and therefore by composition, s semantics is also model complete. Heyting's semantics for logic programs has been introduced in [20] to provide an intuitionistic (constructive) interpretation for definite clause programs. <p> By Theorem 6.7, and because Def is strictly more abstract than Sharing , the best semantics for aliasing analysis in logic programs is strictly more abstract than s and strictly more concrete than Clark's semantics. 7 Related works In logic programming, the most related works are <ref> [4, 10, 13, 16, 19] </ref>. [19] firstly applied a notion of core semantics to build collecting semantics. The approach however was neither oriented to a systematic design of semantics nor provided with a model-theoretic interpretation for collecting and abstract semantics. <p> While [13] firstly observed that H is an abstract interpretation of a more concrete backward semantics, [4] firstly characterized abstract models for program analysis based (only) on s semantics. In <ref> [16] </ref> H, Clark's and s semantics are related, providing a model-theoretic interpretation for s-models. We combine and extend those approaches in the first part of the paper, introducing a generic notion of collecting semantics for logic programs. <p> In [16] H, Clark's and s semantics are related, providing a model-theoretic interpretation for s-models. We combine and extend those approaches in the first part of the paper, introducing a generic notion of collecting semantics for logic programs. This includes some results in <ref> [4, 16] </ref> as a special case of some of the results in Section 3. Moreover, by using abstract interpretation, we can systematically derive and compare collecting semantics, and constructively define "optimal" collecting semantics for analysis.
Reference: 17. <author> M. Gabbrielli and M. C. Meo. </author> <title> Fixpoint semantics for partial computed answer substitutions and call patterns. </title> <booktitle> In Proc. ALP'92 , LNCS 632, </booktitle> <pages> pp. 84-99, </pages> <year> 1992. </year>
Reference-contexts: This abstraction induces a semantics which is equivalent to the compositional semantics for partial answers in <ref> [5, 17] </ref>. This semantics has been used for compositional analysis of modular logic programs in [9]. The semantics for call patterns in [17] can also be derived by further approximating partial answers. <p> This abstraction induces a semantics which is equivalent to the compositional semantics for partial answers in [5, 17]. This semantics has been used for compositional analysis of modular logic programs in [9]. The semantics for call patterns in <ref> [17] </ref> can also be derived by further approximating partial answers. Recall that an atom a 2 Atom is a call pattern for a goal G in a program P if G c ! fl a j b 2 T P (SLD ). <p> corresponding abstraction maps traces into binary clauses in BClause: ff Call : -(T & P (SLD)) ! -(BClause) where ff Call (X ) = fh a j h ! fl a j b 2 X g, and induces a semantics which is equivalent to the semantics for call patterns in <ref> [17] </ref>. * The success abstraction ff s : -(T & P (SLD)) ! -(Atom) approximates any finite successful trace with its initial state, while non-successful traces are simply ignored: ff s (X ) = fh j h ! fl fl 2 X g.
Reference: 18. <author> D. Jacobs and A. Langen. </author> <title> Static analysis of logic programs for independent AND parallelism. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2-3):291-314, </volume> <year> 1992. </year>
Reference-contexts: Def . The more simple Clark's semantics can be equivalently used as a base semantics for Def (see Example 6.8 below). This is not true for Sharing (see <ref> [18] </ref>), a domain for aliasing analysis, because the abstraction inst which relates Clark's and s semantics, may introduce new sharings which are not produced by the program.
Reference: 19. <author> N. D. Jones and H. Stndergaard. </author> <title> A semantics-based framework for the abstract interpretation of Prolog. </title> <editor> In S. Abramsky and C. Hankin, eds., </editor> <booktitle> Abstract Interpretation of Declarative Languages, </booktitle> <pages> pp. 123-142. </pages> <publisher> Ellis Horwood Ltd, </publisher> <year> 1987. </year>
Reference-contexts: case that collecting interpretations are derived by abstracting SLD resolution, without providing any corresponding model-theoretic interpretation, and the collecting semantics turn out to be often too far from the intended logical meaning of the program: its Herbrand model (e.g., see the operational framework in [7], or the denotational one in <ref> [19] </ref>). In this paper we introduce a new approach to collecting semantics design and analysis, and apply it to the case of logic programs. <p> By Theorem 6.7, and because Def is strictly more abstract than Sharing , the best semantics for aliasing analysis in logic programs is strictly more abstract than s and strictly more concrete than Clark's semantics. 7 Related works In logic programming, the most related works are <ref> [4, 10, 13, 16, 19] </ref>. [19] firstly applied a notion of core semantics to build collecting semantics. The approach however was neither oriented to a systematic design of semantics nor provided with a model-theoretic interpretation for collecting and abstract semantics. <p> Theorem 6.7, and because Def is strictly more abstract than Sharing , the best semantics for aliasing analysis in logic programs is strictly more abstract than s and strictly more concrete than Clark's semantics. 7 Related works In logic programming, the most related works are [4, 10, 13, 16, 19]. <ref> [19] </ref> firstly applied a notion of core semantics to build collecting semantics. The approach however was neither oriented to a systematic design of semantics nor provided with a model-theoretic interpretation for collecting and abstract semantics.
Reference: 20. <author> R. Kemp and G. Ringwood. </author> <title> Reynolds and Heyting models of logic programs. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, Queen Mary and Westfield College, </institution> <year> 1991. </year>
Reference-contexts: Clark's semantics is model complete, i.e. groundffiT c P = T P ffiground (cf. [16]), and therefore by composition, s semantics is also model complete. Heyting's semantics for logic programs has been introduced in <ref> [20] </ref> to provide an intuitionistic (constructive) interpretation for definite clause programs. Given that, for definite clause programs, classical and intuitionistic logic agree, we can easily observe that Heyting's semantics, if compared with Herbrand's semantics, defines itself a collecting semantics.
Reference: 21. <author> A. Mycroft and F. Nielson. </author> <title> Strong abstract interpretation using power domains. </title> <editor> In J. Daz, ed., </editor> <booktitle> Proc. ICALP'83 , LNCS 154, </booktitle> <pages> pp. 536-547. </pages> <year> 1983. </year>
Reference-contexts: These semantics are usually derived by abstraction from an operational semantics of the language, or derived by a simple concretization process based on a powerset construction, collecting sets of denotations (e.g. in <ref> [21] </ref>). Therefore, the relation between collecting semantics and the underlying, more abstract, standard semantics becomes purely artificial and it is often meaningless.
Reference: 22. <author> B. Steffen. </author> <title> Optimal data flow analysis via observational equivalence. </title> <booktitle> In Proc. MFCS'89 , LNCS 379, </booktitle> <pages> pp. 492-502, </pages> <year> 1989. </year>
Reference-contexts: Note that if hC ; T i ' hC 0 ; T 0 i then C ~ = C 0 . Moreover, let hC ; T i be a collecting semantics, we follow <ref> [22] </ref> 1 by defining an observation as an element in O (S) = fX j X 2 0 & X / Sg. It is immediate to prove that S ' X iff O (S) = O (X ). Equivalent collecting semantics allow the same set of possible observations. <p> Thus, the fixpoints of the operator T provide only a partial characterization of the class of collecting models for a program. An interpretation M such that T (M ) v C M will be called a reachable collecting model . 1 <ref> [22] </ref> defines an observation for a semantics hC ; T i as a complete lattice isomorphic to an upper closure of C .
Reference: 23. <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> JACM , 23(4) </journal> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: This system includes well known semantics for logic programs, and provides a "logical" notion of model for programs at different levels of abstraction. In the following inst (ground ) is a function mapping any syntactic object to the set of its (ground) instances. Herbrand's semantics in <ref> [23] </ref>, denoted H, is a pair h-(Atom ; ); T P i where for each program P and I 2 -(Atom ; ): T P (I ) = fh 2 Atom ; j h b 2 ground (P ); b I g. <p> SLD, with arbitrary elements . 0 denotes the first element of the trace . s 2 State s 2 T P (SLD) c s ! 2 T P (SLD ) It is a common practice in logic program semantics to restrict the interest to AND-compositional execution traces only (e.g., in <ref> [3, 15, 23] </ref>). Intuitively a set of traces is AND-compositional if the execution trace of any (possibly non-atomic) goal can be reconstructed by composing traces for atomic goals in the set. The inductive definition of the set E of AND-compositional execution traces for atomic goals is in Table 1.
References-found: 23

