URL: http://www.cs.brandeis.edu/~mairson/Papers/am97-abs.ps.gz
Refering-URL: http://www.cs.brandeis.edu/~mairson/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: asperti@cs.unibo.it  mairson@cs.brandeis.edu  
Title: Parallel beta reduction is not elementary recursive or in general, O(K (n)) where K (n)
Author: Andrea Asperti Harry G. Mairson 
Note: O(2 2 2 n  Partially supported by Esprit WG-21836 CONFER-2. Supported by ONR Grant N00014-93-1-1015, NSF Grant CCR-9619638, and the Tyson Foundation.  
Address: Via di Mura Anteo Zamboni 40127 Bologna, Italy  Waltham, Massachusetts 02254  
Affiliation: Dipartimento di Scienze dell'Informazione  Computer Science Department Brandeis University  
Abstract: We analyze the inherent complexity of implementing Levy's notion of optimal evaluation for the -calculus, where similar redexes are contracted in one step via so-called parallel fi-reduction. Optimal evaluation was finally realized by Lamping, who introduced a beautiful graph reduction technology for sharing evaluation contexts dual to the sharing of values. His pioneering insights have been modified and improved in subsequent implementations of optimal reduction. We prove that the cost of parallel fi-reduction is not bounded by any Kalmar-elementary recursive function. Not merely do we establish that the parallel fi-step cannot be a unit-cost operation, we demonstrate that the time complexity of implementing a sequence of n par A key insight, essential to the establishment of this nonelementary lower bound, is that any simply-typed -term can be reduced to normal form in a number of parallel fi-steps that is only polynomial in the length of the explicitly-typed term. The result follows from Statman's theorem that deciding equivalence of typed -terms is not elementary recursive. The main theorem gives a lower bound on the work that must be done by any technology that implements Levy's notion of optimal reduction. However, in the significant case of Lamping's solution, we make some important remarks addressing how work done by fi-reduction is translated into equivalent work carried out by his bookkeeping nodes. In particular, we identify the computational paradigms of superposition of values and of higher-order sharing, appealing to compelling analogies with quantum mechanics and SIMD-parallelism. allel fi-steps is not bounded as O(2 n ), O(2 2 n
Abstract-found: 1
Intro-found: 1
Reference: [Asp96] <author> Andrea Asperti. </author> <title> On the complexity of beta-reduction. </title> <booktitle> 1996 ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 110-118. </pages>
Reference-contexts: A fundamental and unresolved question about this sharing technology, proposed by Lamping and offered in modified form by others, is to understand the computational complexity of sharing as a function of the "real work" of fi-reduction. In recent years, various papers <ref> [Asp96, LM96, LM97] </ref> have begun to address this issue. This question concerning algorithm analysis only begs more global questions that one can pose about the inherent complexity of optimal evaluation and parallel fi-reduction by any implementation technology. <p> The real work of the computation becomes communication, performing the -expansion on the lists, and communicating the function to different processors. 6.2 Higher-order sharing Higher-order sharing constructs enormous networks of sharing nodes. A well-understood use of sharing appears in <ref> [Asp96, LM96] </ref>, where a linear number of sharing nodes is used to simulate an exponential number of function applications.
Reference: [AG97] <author> Andrea Asperti and Stefano Guerrini. </author> <title> The Optimal Implementation of Functional Programming Languages. </title> <institution> Cambridge Tracts in Theoretical Computer Science, Cambridge University Press. </institution> <note> To appear. </note>
Reference-contexts: The Main Theorem also gives bounds on the complexity of cut elimination in multiplicative-exponential linear logic (mell), and in particular, an understanding of the "linear logic without boxes" formalism in [GAL92b]. In proof nets for linear logic (see, for example, <ref> [Laf95, AG97] </ref>), the times and par connectives of linear logic play essentially the same role as apply and nodes in -calculus; the programming synchronization implemented by the closure has its counterpart in proof net boxes.
Reference: [vEB90] <author> Peter van Emde Boas. </author> <title> Machine models and simulation. </title> <booktitle> Handbook of Theoretical Computer Science, volume A, </booktitle> <pages> pp. 1-66. </pages> <publisher> North Holland, </publisher> <year> 1990. </year>
Reference-contexts: parallel fi-steps could indeed be implemented at time cost K ` (jEj); we would then have shown that dtime [K `+1 (jxj)] dtime [K ` (jEj)]: But the time hierarchy theorem from complexity theory (see, e.g., [HU79]) tells us that this implied conclusion is 1 A "first class" machine model <ref> [vEB90] </ref> is any computational model equal to the power of a Turing Machine, modulo polynomial slowdown. For example, register machines with a logarithmic cost criterion are first-class; counter machines are not. false, since jEj is polynomial in n; at least K ` (n) time steps are necessary. <p> set of closed -terms E n : Bool, where jE n j = O (n log (c) n) for any integer c &gt; 0, such that E n normalizes in O (jE n j) parallel fi-steps, and the time needed to implement the parallel fi-steps, on any first-class machine model <ref> [vEB90] </ref>, grows as (K ` (n)) for any fixed integer ` 0.
Reference: [Dys79] <author> Freeman Dyson. </author> <title> Disturbing the Universe. </title> <publisher> Harper and Row, </publisher> <year> 1979. </year>
Reference-contexts: thousand words| so please never draw one that isn't. [Hoa85] But as Richard Feynman and Julian Schwinger showed in the history of quantum electrodynamics, a picture can indeed be worth ten thousand equations: Feynman was able to diagramatically work out calculations that seemed interminable by more formal means (see, e.g., <ref> [Dys79, Sch94] </ref>). Lamping's graphs give insight into the inherent process of optimal reduction that transcends the particularities of his implementation technology.
Reference: [FS91] <author> Gudmund S. Frandsen and Carl Sturtivant. </author> <title> What is an efficient implementation of the -calculus? 1991 ACM Conference on Functional Programming and Computer Architecture (J. </title> <editor> Hughes, ed.), </editor> <volume> LNCS 523, </volume> <pages> pp. 289-312. </pages>
Reference-contexts: The corollary answers a question raised by Frandsen and Sturtivant in <ref> [FS91] </ref>, who exhibited a set of -terms where b 5p, and conjectured that a set of -terms existed where b = (2 p ). In [LM96] a set of terms was constructed where b = (2 2 p ).
Reference: [Gan69] <author> Robin Gandy. </author> <title> An early proof of normalization by A. </title> <editor> M. Turing. To H. B. </editor> <booktitle> Curry: Essays in Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <editor> (J. P. Seldin and J. R. Hindley, </editor> <booktitle> eds.), </booktitle> <pages> pp. 453-455. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: The bound on the reduction is, if one counts parallel fi-reduction of families, merely linear in the length of the initial term. We observe finally that the proof of Theorem 3.9 shows a great similarity to an early proof of normalization due to Alan Turing <ref> [Gan69] </ref>. Define the index of a redex (E !t F ) t to be ! t ; Turing's simple observation was that, aside from the copying of ex-istant redexes, the fi-reduction of redexes with index ! t can only construct new redexes of index or index t .
Reference: [GLT89] <author> Jean-Yves Girard, Yves Lafont, and Paul Taylor. </author> <title> Proofs and Types. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science, </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: Normalization then follows by a straightforward induction on types alone. This contrasts with the familiar proof based on the idea of reducibility (see, e.g., <ref> [HS87, GLT89, Tai67] </ref>). 3 0 is relative to if all redexes in 0 are in the same family of some redex in , see ([Levy78], Def. 4.4.1). 4 Simulating generic elementary-time bounded computa tion Now that we know that the normal form of a simply-typed -term can be computed in a
Reference: [GAL92a] <author> Georges Gonthier, Martin Abadi, and Jean-Jacques Levy. </author> <title> The geometry of optimal lambda reduction. </title> <booktitle> 1992 ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 15-26. </pages>
Reference-contexts: Lamping introduced a beautiful graph reduc tion technology for sharing evaluation contexts dual to the sharing of values. His pioneering insights have been modified and improved in subsequent implementations of optimal reduction, most notably by Asperti, and by Gonthier, Abadi, and Levy <ref> [GAL92a] </ref>. Lamping's sharing nodes allow a single, shared representation of a redex family, and thus provide a means to implement Levy's notion of parallel reduction. The varied implementations of this graph reduction framework differ in the underlying bookkeeping technology used to control interactions between sharing nodes.
Reference: [GAL92b] <author> Georges Gonthier, Martin Abadi, and Jean-Jacques Levy. </author> <title> Linear logic without boxes. </title> <booktitle> 1992 IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pp. 223-234. </pages>
Reference-contexts: A reinterpretation of the main theorem gives bounds on the complexity of cut elimination in multiplicative-exponential linear logic (mell), and in particular, an understanding of the "linear logic without boxes" formalism in <ref> [GAL92b] </ref>, since that logic is a close analogue of simply-typed lambda calculus. In the significant case of Lamping's solution, we can also make some important remarks addressing how work done by fi-reduction is translated into equivalent work carried out by his bookkeeping nodes. <p> In [LM96] a set of terms was constructed where b = (2 2 p ). The Main Theorem also gives bounds on the complexity of cut elimination in multiplicative-exponential linear logic (mell), and in particular, an understanding of the "linear logic without boxes" formalism in <ref> [GAL92b] </ref>. In proof nets for linear logic (see, for example, [Laf95, AG97]), the times and par connectives of linear logic play essentially the same role as apply and nodes in -calculus; the programming synchronization implemented by the closure has its counterpart in proof net boxes.
Reference: [Gue96] <author> Stefano Guerrini. </author> <title> Theoretical and practical issues of optimal implementations of functional languages. </title> <type> Ph. D. Thesis, </type> <institution> Universita di Pisa, </institution> <year> 1996. </year>
Reference: [HS87] <author> J. Roger Hindley and Jonathan P. Seldin. </author> <title> Introduction to Combinators and Lambda Calculus. </title> <publisher> Cambridge University Press, </publisher> <year> 1987. </year>
Reference-contexts: Normalization then follows by a straightforward induction on types alone. This contrasts with the familiar proof based on the idea of reducibility (see, e.g., <ref> [HS87, GLT89, Tai67] </ref>). 3 0 is relative to if all redexes in 0 are in the same family of some redex in , see ([Levy78], Def. 4.4.1). 4 Simulating generic elementary-time bounded computa tion Now that we know that the normal form of a simply-typed -term can be computed in a
Reference: [Hoa85] <author> Charles Antony Richard Hoare. </author> <booktitle> The Mathematics of Programming. Inaugural Lecture, </booktitle> <publisher> Oxford University. Clarendon Press, </publisher> <month> October </month> <year> 1985. </year>
Reference-contexts: It is equally inappropriate for a professional programmer. Confucius is often quoted as saying that a picture is worth ten thousand words| so please never draw one that isn't. <ref> [Hoa85] </ref> But as Richard Feynman and Julian Schwinger showed in the history of quantum electrodynamics, a picture can indeed be worth ten thousand equations: Feynman was able to diagramatically work out calculations that seemed interminable by more formal means (see, e.g., [Dys79, Sch94]).
Reference: [HU79] <author> John E. Hopcroft and Jeffrey D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison Wesley, </publisher> <year> 1979. </year>
Reference-contexts: Suppose that the jEj parallel fi-steps could indeed be implemented at time cost K ` (jEj); we would then have shown that dtime [K `+1 (jxj)] dtime [K ` (jEj)]: But the time hierarchy theorem from complexity theory (see, e.g., <ref> [HU79] </ref>) tells us that this implied conclusion is 1 A "first class" machine model [vEB90] is any computational model equal to the power of a Turing Machine, modulo polynomial slowdown. <p> Were a parallel fi-step implemented in unit cost, we would have shown that ptime equals dtime [2 n ], contradicting the time hierarchy theorem (see, e.g., <ref> [HU79] </ref>). In fact, for any integer ` 0, we can construct generic reductions of this kind for dtime [K ` (n)]. The consequence is that the cost of a sequence of n parallel fi-steps is not bounded by any of the Kalmar-elementary recursive functions K ` (n).
Reference: [Kal43] <institution> Laszlo Kalmar. Egyszeru pelda eldonthetetlen aritmetikai problemara (Ein einfaches Beispiel fur ein unentsheidbares arithmetisches Problem). </institution> <note> Matematikai es fizikai lapok 50, </note> <year> 1943, </year> <pages> pp. 1-23. </pages> <note> Hungarian with German abstract. </note>
Reference-contexts: Definition 1.2 We define the Kalmar-elementary functions K ` (n) as K 0 (n) = n, and K t+1 (n) = 2 K t (n) <ref> [Kal43] </ref>. Dually, we define the iterated logarithm functions log (m) (n) as log (0) (n) = n, and log (c+1) (n) = log (log (c) (n)). Main Theorem.
References-found: 14

