URL: http://pertsserver.cs.uiuc.edu/papers/DeL98.ps
Refering-URL: http://pertsserver.cs.uiuc.edu/papers/
Root-URL: http://www.cs.uiuc.edu
Title: An Open Environment for Real-Time Applications  
Author: Z. Deng Jane W.-S. Liu L. Zhang S. Mouna A. Frei 
Date: July 16, 1998  
Address: Urbana, IL 61801  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract: This paper describes an open system architecture that allows independently developed hard real-time applications to run together and supports their reconfiguration at run-time. In the open system, each real-time application is executed by a server. At the lower level, the OS scheduler schedules all the servers on the EDF basis. At the upper level, the server scheduler of each server schedules the ready jobs of the application executed by the server according to the algorithm chosen for the application. The paper describes the two-level CPU scheduling scheme used by the open system and the design and implementation of a uniprocessor open system within the framework of the Windows NT operating system. The implementation consists of three key components: the two-level hierarchical kernel scheduler, common system service providers, and real-time application programming interface. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Spuri and G. Buttazzo, </author> <title> "Scheduling Aperiodic Tasks in Dynamic Priority Systems", </title> <booktitle> Real-Time Systems, </booktitle> <volume> vol. 10, </volume> <pages> pp. 179-210, </pages> <year> 1996. </year>
Reference-contexts: The algorithms have different names (e.g., total bandwidth server <ref> [1] </ref>, constant utilization server [2], proportional resource sharing [4], weighted fair queueing [5] and virtual clock [6] algorithms), but are identical in essence. They all provide tasks (e.g., streams of computations or data transmissions) on a processor (i.e., a CPU or data link) a fine-grain processor sharing environment. <p> The lower level scheduler provided by the operating system is called OS scheduler. This scheduler maintains all the servers in the system. The server S 0 of non-real-time applications is a total bandwidth server <ref> [1] </ref>. Depending on the characteristics of the real-time application A k (k 1), its server is either a constant utilization server [2] or a total bandwidth server. These types of servers are similar. <p> Maintenance rules for constant utilization servers and servers of nonpreemp-tive applications can be found in the appendix.) The algorithm governing the server budget replenishment differs slightly from the total bandwidth server algorithm in <ref> [1] </ref>.
Reference: [2] <author> Z. Deng, J. W.-S. Liu, J. Sun, </author> <title> "A Scheme for Scheduling Hard Real-Time Applications in Open System Environment", </title> <booktitle> Proceedings of 9th Euromicro Workshop on Real-Time Systems, </booktitle> <pages> pp. 191-199, </pages> <month> June </month> <year> 1997. </year> <month> 39 </month>
Reference-contexts: The kernel scheduler implements the two-level hierarchical scheduling scheme described in <ref> [2, 3] </ref>. The scheme was developed specifically for the purpose of scheduling multi-threaded real-time and non-real-time applications running concurrently in an open system. 1 This term is used to avoid overloading the term server, which is a more common name for a service provider. <p> The algorithms have different names (e.g., total bandwidth server [1], constant utilization server <ref> [2] </ref>, proportional resource sharing [4], weighted fair queueing [5] and virtual clock [6] algorithms), but are identical in essence. They all provide tasks (e.g., streams of computations or data transmissions) on a processor (i.e., a CPU or data link) a fine-grain processor sharing environment. <p> This scheduler maintains all the servers in the system. The server S 0 of non-real-time applications is a total bandwidth server [1]. Depending on the characteristics of the real-time application A k (k 1), its server is either a constant utilization server <ref> [2] </ref> or a total bandwidth server. These types of servers are similar. Such a server is characterized by its size U , which is the fractional processor bandwidth allocated to the server. A server has two additional parameters, budget and deadline; the parameters are initially zero. <p> The correctness of the acceptance test used by the OS scheduler is supported by the two theorems stated below. They give sufficient conditions under which a real-time application A k with required capacity k is schedulable in the open system. Their proofs can be found in <ref> [2, 3] </ref>. 4.1 Theoretical Foundation When the system contains no global resources and no application has nonpreemptable sections, Theorem 1 is applicable, and all real-time applications can be executed by constant utilization servers.
Reference: [3] <author> Z. Deng, J. W.-S. Liu, </author> <title> "Scheduling Real-Time Applications in an Open Environment", </title> <booktitle> Pro--ceedings of IEEE 18th Real-Time Systems Symposium, </booktitle> <pages> pp. 308-319, </pages> <month> December </month> <year> 1997. </year>
Reference-contexts: The kernel scheduler implements the two-level hierarchical scheduling scheme described in <ref> [2, 3] </ref>. The scheme was developed specifically for the purpose of scheduling multi-threaded real-time and non-real-time applications running concurrently in an open system. 1 This term is used to avoid overloading the term server, which is a more common name for a service provider. <p> The correctness of the acceptance test used by the OS scheduler is supported by the two theorems stated below. They give sufficient conditions under which a real-time application A k with required capacity k is schedulable in the open system. Their proofs can be found in <ref> [2, 3] </ref>. 4.1 Theoretical Foundation When the system contains no global resources and no application has nonpreemptable sections, Theorem 1 is applicable, and all real-time applications can be executed by constant utilization servers.
Reference: [4] <author> I. Stoica, H. Abdel-Wahab, K. Jeffay, S. Baruah, J. Gehrke, and C. Plaxton, </author> <title> "A Proportional Share Resource Allocation Algorithm for Real-Time, Time-Shared Systems", </title> <booktitle> Proceedings of IEEE 17th Real-Time Systems Symposium, </booktitle> <pages> pp. 288-299, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: The algorithms have different names (e.g., total bandwidth server [1], constant utilization server [2], proportional resource sharing <ref> [4] </ref>, weighted fair queueing [5] and virtual clock [6] algorithms), but are identical in essence. They all provide tasks (e.g., streams of computations or data transmissions) on a processor (i.e., a CPU or data link) a fine-grain processor sharing environment. <p> The former is surely to incur also in a system that uses the one-level, proportional share resource allocation scheme proposed by Stocia, et al. <ref> [4] </ref>, which also provides timing isolation. We are extending our simulation study to include a comparison with that scheme.
Reference: [5] <author> A. Demers, S. Keshav, and S. Shenker, </author> <title> "Analysis and Simulation of a Fair Queueing Algorithm," </title> <booktitle> Proc. ACM SIGCOMM'89, </booktitle> <pages> pp. 3-12. </pages>
Reference-contexts: The algorithms have different names (e.g., total bandwidth server [1], constant utilization server [2], proportional resource sharing [4], weighted fair queueing <ref> [5] </ref> and virtual clock [6] algorithms), but are identical in essence. They all provide tasks (e.g., streams of computations or data transmissions) on a processor (i.e., a CPU or data link) a fine-grain processor sharing environment.
Reference: [6] <author> L. Zhang, "VirtualClock: </author> <title> A New Traffic Control Algorithm for Packet-Switched Networks," </title> <journal> ACM Transaction on Computer Systems, </journal> <volume> Vol. 9, No. 2, </volume> <pages> pp. 101-124, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: The algorithms have different names (e.g., total bandwidth server [1], constant utilization server [2], proportional resource sharing [4], weighted fair queueing [5] and virtual clock <ref> [6] </ref> algorithms), but are identical in essence. They all provide tasks (e.g., streams of computations or data transmissions) on a processor (i.e., a CPU or data link) a fine-grain processor sharing environment.
Reference: [7] <author> C. L. Liu and J. W. Layland, </author> <title> "Scheduling Algorithms for Multiprogramming in a Hard Real Time Environment," </title> <journal> in J. Assoc. Comput. Mach., </journal> <volume> vol. 20(1), </volume> <pages> pp. 46-61, </pages> <year> 1973. </year>
Reference: [8] <author> J. Y.-T. Leung and J. Whitehead, </author> <title> "On the Complexity of Fixed-Priority Scheduling of Periodic Real-Time Tasks," </title> <journal> Performance Evaluation, </journal> <volume> vol. 2, </volume> <pages> pp. 237-250, </pages> <year> 1982. </year>
Reference: [9] <author> Al Mok, </author> <title> "Fundamental Design Problems of Distributed Systems for the Hard Real-Time Environment", </title> <type> Ph.D. Thesis, </type> <institution> MIT, Department of EE and CS, MIT/LCS/TR-297, </institution> <month> May </month> <year> 1983. </year>
Reference-contexts: In addition to the processor, the system also contains resources. A resource is global if it is shared by more than one application and is local if it is used by only one application. Global resource contentions among applications are controlled by the nonpreemptable critical section (NPS) protocol <ref> [9] </ref>. According to the NPS protocol, whenever a job requests a global resource, the request is always granted. For as long as a job holds a global resource, the job is nonpreemptable.
Reference: [10] <author> S. Sommer, J.Potter, </author> <title> "Operating System Extension for Dynamic Real-Time Applications", </title> <booktitle> Proceedings of IEEE 17th Real-Time Systems Symposium, </booktitle> <pages> pp. 45-50, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: In contrast, our open system allows any mixture of scheduling algorithms to be used at the same time. Moreover, the open system provides each admitted multi-threaded real-time application with both processor bandwidth and timing guarantees. Sommer, et al. <ref> [10] </ref> implemented an execution environment, called the Dreams System, for hard real-time applications on Windows NT. The Dreams system supports periodic tasks that may be admitted and deleted at run-time. All ready threads are scheduled according to the EDF algorithm.
Reference: [11] <author> H. Tokuda, T. Nakajima, P. Rao, </author> <title> "Real-Time Mach: Towards a Predictable Real-Time System", </title> <booktitle> Proceedings of the Usenix Mach Workshop, </booktitle> <pages> pp. 73-82, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The two-level scheduler in the open system uses the total bandwidth server and constant utilization server algorithms. There have been many research efforts in building real-time extensions to general purpose operating systems. Real-Time Mach <ref> [11] </ref> extends Mach to support both periodic tasks and aperiodic tasks. Scheduling algorithms provided by Real-Time Mach include RM (rate monotonic), RM with Deferrable Server, RM with Sporadic Server, Fixed Priority and Round Robin [11]. However, at any time, all ready threads are scheduled by a single scheduling algorithm. <p> Real-Time Mach <ref> [11] </ref> extends Mach to support both periodic tasks and aperiodic tasks. Scheduling algorithms provided by Real-Time Mach include RM (rate monotonic), RM with Deferrable Server, RM with Sporadic Server, Fixed Priority and Round Robin [11]. However, at any time, all ready threads are scheduled by a single scheduling algorithm. The admission control mechanism used in Real-Time Mach is based on the processor reservation method [13]. Each real-time task makes a reservation for a certain fraction of the processor bandwidth when requesting admission.
Reference: [12] <author> B. Carpenter, M. Roman, N. Vasilatos, M. Zimmerman, </author> <title> "The RTX Real-Time Subsystem for Windows NT", </title> <booktitle> The USENIX Windows NT Workshop Proceedings, </booktitle> <pages> pp. 33-37, </pages> <month> Auguest </month> <year> 1997. </year>
Reference-contexts: The Dreams system supports periodic tasks that may be admitted and deleted at run-time. All ready threads are scheduled according to the EDF algorithm. The Dream system provides timing guarantees to every real-time task that passes its acceptance test, as long as no task overruns. RTX <ref> [12] </ref> developed by VenturCom Inc. is a real-time subsystem of Windows NT. It is a kernel-mode execution environment for Win32 compatible tasks and threads that have hard real-time requirements. The RTX subsystem schedules real-time threads using a priority-driven algorithm and controls priority inversions.
Reference: [13] <author> C. W. Mercer, S Savage, H Tokuda, </author> <title> "Processor Capacity Reserves: Operating System Sup--port for Multimedia Applications", </title> <booktitle> Proceedings of the IEEE International Conference on Multimedia Computing and Systems, </booktitle> <month> May </month> <year> 1994 </year>
Reference-contexts: However, at any time, all ready threads are scheduled by a single scheduling algorithm. The admission control mechanism used in Real-Time Mach is based on the processor reservation method <ref> [13] </ref>. Each real-time task makes a reservation for a certain fraction of the processor bandwidth when requesting admission. The operating system guarantees each admitted task the reserved 3 fraction of processor bandwidth, but does not guarantee the timing constraints of the task. <p> It uses real-time threads to service hardware and software interrupts, and thus it provides deterministic interrupt response and dispatch latencies. RTX does not provide any admission control mechanism. Mercer proposed the processor reservation model to support both hard real-time and multimedia applications <ref> [13] </ref>. In a system based on this model, the operating system maintains and enforces a processor reserve for each real-time task in the system. Mercer uses processor reserves as a means to monitor and control the processor usage of each activity. <p> Thus, the processor time the service provider requires to perform any service is charged to the requesting application. This idea is borrowed from Mercer, et al. <ref> [13] </ref>. Upon initialization, the operating system creates a passive server to execute each service provider in the system.
Reference: [14] <author> B. Sprunt, L. Sha, and J. P. Lehoczky, </author> <title> "Aperiodic Task Scheduling for Hard Real-Time Systems," Real-Time Systems: </title> <journal> The International Journal of Time-Critical Computing Systems, </journal> <volume> vol. 1, </volume> <pages> pp. 27-60, </pages> <year> 1989. </year>
Reference-contexts: The schedulability of other real-time applications in the system is not affected. 21 7 Real-Time Application Programming Interface (RTAPI) Our open system supports periodic tasks and aperiodic tasks, as well as several types of periodic servers <ref> [14] </ref>, i.e., special kinds of periodic tasks used to execute aperiodic tasks. It provides two categories of RTAPI functions for real-time applications. The first one deals with the creation, admission and termination of real-time applications, as well as task and server specification.
Reference: [15] <author> J. W.-S. Liu, J. L. Redondo, Z. Deng, T. S. Tia, R. Bettati, A. Silberman, M. Storch, R. Ha, W. K. Shih, "PERTS: </author> <title> A Prototyping Environment for Real-Time Systems", </title> <booktitle> Proceedings of IEEE 14th Real-Time Systems Symposium, </booktitle> <pages> pp. 184-188, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: the open system that use nonzero scheduling quantum, the tasks marked by stars (fl) have large release jitters. (Their release jitters are large enough so that the scheduling quantum size, instead of the jitter factors, determines the server size.) The schedulability of the closed system is validated by PERTS tools <ref> [15] </ref> 5 . The required capacity of each application is also derived by the PERTS tools. The schedulability of the open system is verified by having each application pass the acceptance test used in the open system.
Reference: [16] <author> H. Custer, </author> <title> "Inside Windows NT", </title> <publisher> Microsoft Press, </publisher> <year> 1993. </year> <month> 41 </month>
Reference-contexts: Total code size of RTAPI is about 600 lines of C code, and that of communication SSP is about 800 lines of C code. This section describes the implementation of two-level kernel scheduler. 26 Thereafter, we use the object model and terminology found in Window NT literature, such as <ref> [16] </ref>. In particular, the term object refers to both a data structure that defines a class of objects and an instance of the class. 8.1 Kernel Scheduling Objects In Windows NT operating system, kernel threads are the basic scheduling entities.
References-found: 16

