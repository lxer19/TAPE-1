URL: http://www.daimi.aau.dk/~andrzej/papers/AC.ps.Z
Refering-URL: http://www.daimi.aau.dk/~andrzej/papers/
Root-URL: http://www.daimi.aau.dk
Email: andrzej+@cs.cmu.edu  (danvy@diku.dk, andrzej@diku.dk).  
Title: Abstracting Control  
Author: Olivier Danvy Andrzej Filinski Daniel P. Friedman), 
Note: The core of this work was developed  This work has benefited from visits to the  (thanks to Carolyn L. Talcott), In-diana University (thanks to  (thanks to David A. Schmidt) during the academic year 1989-1990.  
Address: Pittsburgh, PA 15213, USA  Denmark  
Affiliation: School of Computer Science Carnegie Mellon University  at DIKU, the Computer Science department at the University of Copenhagen,  Computer Science departments of Stanford University  and Kansas State University  
Abstract: The last few years have seen a renewed interest in continuations for expressing advanced control structures in programming languages, and new models such as Abstract Continuations have been proposed to capture these dimensions. This article investigates an alternative formulation, exploiting the latent expressive power of the standard continuation-passing style (CPS) instead of introducing yet other new concepts. We build on a single foundation: abstracting control as a hierarchy of continuations, each one modeling a specific language feature as acting on nested evaluation contexts. We show how iterating the continuation-passing conversion allows us to specify a wide range of control behavior. For example, two conversions yield an abstraction of Prolog-style backtracking. A number of other constructs can likewise be expressed in this framework; each is defined independently of the others, but all are arranged in a hierarchy making any interactions between them explicit. This approach preserves all the traditional results about CPS, e.g., its evaluation order independence. Accordingly, our semantics is directly implementable in a call-by-value language such as Scheme or ML. Furthermore, because the control operators denote simple, typable lambda-terms in CPS, they themselves can be statically typed. Contrary to intuition, the iterated CPS transformation does not yield huge results: except where explicitly needed, all continuations beyond the first one disappear due to the extensionality principle (j-reduction). Besides presenting a new motivation for control operators, this paper also describes an improved conversion into applicative-order CPS. The conversion operates in one pass by performing all administrative reductions at translation time; interestingly, it can be expressed very concisely using the new control operators. The paper also presents some examples of nondeterministic programming in direct style. 
Abstract-found: 1
Intro-found: 1
Reference: [Abelson & Sussman 85] <author> Harold Abelson and Gerald Jay Sussman with Julie Sussman: </author> <title> Structure and Interpretation of Computer Programs, </title> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Massachusetts (1985) </address>
Reference-contexts: In fact, as noted in section 1, j-reduction permits us to write virtually all of the semantics in ordinary CPS style, involving the meta-continuation only for expressing the denotations of flip and fail. As a more complex example, we may consider the problem presented in <ref> [Abelson & Sussman 85, pp 254-255] </ref>: generating all triples of distinct positive integers i, j and k less than or equal to a given integer n that sum to a given integer s.
Reference: [Aho, Hopcroft, & Ullman 74] <author> Alfred V. Aho, John E. Hopcroft, Jeffrey D. Ullman: </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley (1974) </publisher>
Reference-contexts: ends or failures correspond to discarding the current branch of control: (define flip (lambda () (shift c (begin (c #t) (c #f) (fail))))) (define fail (lambda () (shift c "no"))) As an example, let us consider the implementation of a nondeterministic finite automaton for recognizing languages denoted by regular expressions <ref> [Aho, Hopcroft, & Ullman 74] </ref>. While conceptually simple, this application demonstrates the essence of choice and failure in a traditional setting. We will represent the sequence of input symbols as a list. If the automaton recognizes a prefix of this sequence, it returns the remainder; otherwise, it fails.
Reference: [Appel & Jim 89] <author> Andrew W. Appel, Trevor Jim: </author> <title> Continuation-Passing, Closure-Passing Style, </title> <booktitle> proceedings of the Sixteenth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages pp 293-302, </booktitle> <address> Austin, </address> <note> Texas (January 1989) </note>
Reference-contexts: Alternatively, it translates terms of a Scheme-like language (i.e., -calculus + escape) into standard CPS. Such a conversion has a practical interest for compiling, from [Steele 78] to <ref> [Appel & Jim 89] </ref>, and thus constitutes a significant example of using shift/reset: even the pure CPS translation is expressed naturally using the new control operators. As with all meta-circular definitions, we need to bootstrap it. <p> Relations between direct and continuation semantics were investigated in [Reynolds 74], together with their congruence [Sethi & Tang 80]. Continuation-passing style was made popular in [Steele & Sussman 76], and conversion to CPS has become a common device for compiling Scheme [Steele 78] and more recently ML programs <ref> [Appel & Jim 89] </ref>. Programming with continuations has appeared as an intriguing possibility offered by control operators such as Landin's J, Reynolds's escape, and call-with-current-continuation in Scheme.
Reference: [Barendregt 85] <author> Hendrick P. Barendregt: </author> <title> The Lambda Calculus, Its Syntax and Semantics, revised edition, </title> <booktitle> Studies in Logic and the Foundations of Mathematics, </booktitle> <volume> Vol. 103, </volume> <publisher> North-Holland (1985) </publisher>
Reference-contexts: Confusing all the i is type incorrect since it discards type information. However, this description can be transliterated into Scheme as a definitional interpreter. Inductive combinators can be expressed without ellipses using combinatory logic and Church numerals <ref> [Barendregt 85] </ref>: 0 = KI s.t. n M N = M (M (. . . (M n For example, we can define the family of regular dupli cating combinators: W n = n (BW )K such that W n M N = M N . . .
Reference: [Danvy & Malmkjaer 88] <author> Olivier Danvy, Karoline Malm-kjaer: </author> <title> Intensions and Extensions in a Reflective Tower, </title> <booktitle> proceedings of the 1988 ACM Conference on Lisp and Functional Programming pp 327-341, </booktitle> <address> Snowbird, Utah (July 1988) </address>
Reference-contexts: is comparable to the continuation-passing counterpart of the valuation function in a traditional continuation semantics for Scheme though there are infinitely many contexts: Exp ! Env ! Cont ! MCont ! Ans where MCont = Cont fl in [Wand & Friedman 88] and MCont = (Cont fi Env) fl in <ref> [Danvy & Malmkjaer 88] </ref>. Finally reifying continuations and composing them [Malm-kjaer 89] pushes and pops continuations off the meta-continuation, dynamically, which necessitates reflexive types. This is not the case for our description, and thus computation never goes up and down in the tower.
Reference: [Danvy & Filinski 89] <author> Olivier Danvy, Andrzej Filinski: </author> <title> A Functional Abstraction of Typed Contexts, </title> <institution> DIKU Rapport 89/12, DIKU, University of Copenhagen, Copen-hagen, </institution> <note> Denmark (August 1989) </note>
Reference-contexts: Thus, the entire semantics need not be cluttered up to describe composable continuations. Also, the static nature of the translation into CPS induces a naturally static type system for the language. This aspect is treated in more depth in <ref> [Danvy & Filinski 89] </ref>. <p> In contrast, our approach is fundamentally hierarchic rather than being based on any particular discipline of programming. In fact, our development is similar to what Strachey and Wadsworth proposed in their original report [footnote 11]: to associate a continuation with each embedding context. <ref> [Danvy & Filinski 89] </ref> investigates abstracting control in one delimited context, as in section 1 and 2. It also presents a number of examples and a static type system. [Danvy 89] contrasts imperative and functional abstractions of control by modeling them with the cancellator and with the Curry combinators, respectively.
Reference: [Danvy 89] <author> Olivier Danvy: </author> <title> Programming with Tighter Control, pp 10-29 of the BIGRE journal, No 65 on Putting Scheme to Work, </title> <editor> Andre Pic, Michel Briand, and Jean Bezivin (eds.), </editor> <address> Brest, France (July 1989) </address>
Reference-contexts: It also presents a number of examples and a static type system. <ref> [Danvy 89] </ref> contrasts imperative and functional abstractions of control by modeling them with the cancellator and with the Curry combinators, respectively.
Reference: [Felleisen et al. 87] <author> Matthias Felleisen, Daniel P. Friedman, Bruce Duba, John Merrill: </author> <title> Beyond Continuations, </title> <type> Technical Report No 216, </type> <institution> Computer Science Department, Indiana University, Bloomington, </institution> <note> Indiana (February 1987) </note>
Reference-contexts: Introduction Strachey and Wadsworth's continuations were a breakthrough in understanding imperative constructs of programming languages. They gave a clear and unambiguous semantics to a wide class of control operations such as escapes and coroutines. In recent years, however, there has been a growing interest in a class of control operators <ref> [Felleisen et al. 87] </ref> [Felleisen 88] which do not seem to fit into this framework. The point of these new operators is to abstract control with regular procedures that do not escape when they are applied. <p> However, some progress has been made towards a more declarative view of them, based on a category-theoretical duality between values and continuations [Filinski 89]. Recent trends in investigating first-class continuations require the ability of composing them <ref> [Felleisen et al. 87] </ref>. This has been explored in GL [Johnson 87], where continuations were composed in the semantic equations. Unfortunately this makes the semantics order-dependent, comparably to converting a meta-circular interpreter containing shift and reset only once.
Reference: [Felleisen 88] <author> Matthias Felleisen: </author> <title> The Theory and Practice of First-Class Prompts, </title> <booktitle> proceedings of the Fifteenth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages pp 180-190, </booktitle> <address> San Diego, California (January 1988) </address>
Reference-contexts: They gave a clear and unambiguous semantics to a wide class of control operations such as escapes and coroutines. In recent years, however, there has been a growing interest in a class of control operators [Felleisen et al. 87] <ref> [Felleisen 88] </ref> which do not seem to fit into this framework. The point of these new operators is to abstract control with regular procedures that do not escape when they are applied. <p> Shift also differs from escape by not duplicating the current continuation. For example, we have 1 + h10 + c: c (c 100)i ) 1 + (10 + (10 + 100)) ) 121 While the effects of these operators are very similar to operators control and prompt of <ref> [Felleisen 88] </ref>, there is a significant semantical difference between shift/reset and control/prompt: the context abstracted by shift is determined statically by the program text, while control captures the context up to the nearest dynamically enclosing prompt. In general, this leads to different behavior. <p> The approach is changed in [Johnson & Duggan 88], where continuations are composed by appending their representation, precisely as with the control operator in [Felleisen et al. 88]. Further, since a continuation represents a context, context delimiters have been introduced in <ref> [Felleisen 88] </ref> as prompts. In our framework, a prompt naturally is the direct style counterpart of initializing the continuation of a CPS program with the identity function.
Reference: [Felleisen et al. 88] <author> Matthias Felleisen, Mitchell Wand, Daniel P. Friedman, Bruce F. Duba: </author> <title> Abstract Continuations: A Mathematical Semantics for Handling Full Functional Jumps, </title> <booktitle> proceedings of the 1988 ACM Conference on Lisp and Functional Programming pp 52-62, </booktitle> <address> Snowbird, Utah (July 1988) </address>
Reference-contexts: The point of these new operators is to abstract control with regular procedures that do not escape when they are applied. This approach encourages seeing not only procedures as the computational counterpart of functions but extending this view to continuations as well. However, the published semantic descriptions, <ref> [Felleisen et al. 88] </ref> do not actually represent continuations as functions but as concatenable sequences of activation frames, losing the inherent simplicity of the original functional formalism. <p> Unfortunately this makes the semantics order-dependent, comparably to converting a meta-circular interpreter containing shift and reset only once. The approach is changed in [Johnson & Duggan 88], where continuations are composed by appending their representation, precisely as with the control operator in <ref> [Felleisen et al. 88] </ref>. Further, since a continuation represents a context, context delimiters have been introduced in [Felleisen 88] as prompts. In our framework, a prompt naturally is the direct style counterpart of initializing the continuation of a CPS program with the identity function.
Reference: [Filinski 89] <author> Andrzej Filinski: </author> <title> Declarative Continuations: An Investigation of Duality in Programming Language Semantics, </title> <booktitle> proceedings of the Summer Conference on Category Theory and Computer Science, Lecture Notes in Computer Science No 389 pp 224-249, </booktitle> <editor> D. H. Pitt, D. E. Rydeheard, P. Dybjer, A. M. Pitts, & A. Poigne (eds.), </editor> <publisher> Springer-Verlag, </publisher> <address> Manchester, UK (September 1989) </address>
Reference-contexts: First-class continuations have been investigated mainly as powerful, but unstructured devices requiring a deep intuition and operational skill [Friedman, Haynes, & Kohlbecker 84] [Haynes & Friedman 87]. However, some progress has been made towards a more declarative view of them, based on a category-theoretical duality between values and continuations <ref> [Filinski 89] </ref>. Recent trends in investigating first-class continuations require the ability of composing them [Felleisen et al. 87]. This has been explored in GL [Johnson 87], where continuations were composed in the semantic equations.
Reference: [Fischer 72] <author> Michael J. Fischer: </author> <title> Lambda Calculus Schemata, proceedings of the ACM conference Proving assertions about programs pp 104-109, </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. </volume> <pages> 7, </pages> <note> No 1 and SIGACT News, No 14 (January 1972) </note>
Reference-contexts: a semantic specification. 5 Comparison with Related Work The idea of representing "the rest of the computation" as a function or a procedure has occurred more or less independently in [van Wijngaarden 66] for transforming Algol 60 programs to eliminate all labels, in [Mazurkiewicz 71] for proving algorithms, and in <ref> [Fischer 72] </ref> to prove the generality of a deletion implementation strategy, based on adding a functional argument and transforming returns into calls [Morris 72]. Continuations were presented as a device for formalizing control flow in the denota-tional specification of programming languages with jumps [Strachey & Wadsworth 74].
Reference: [Friedman, Haynes, & Kohlbecker 84] <author> Daniel P. Friedman, Christopher T. Haynes, Eugene Kohlbecker: </author> <title> Programming with Continuations, </title> <booktitle> NATO ASI Series, </booktitle> <volume> Vol. </volume> <month> F8, </month> <title> Program Transformation and Programming Environments pp 263-274, </title> <editor> P. Pepper (ed.), </editor> <publisher> Springer-Verlag Berlin Heidelberg (1984) </publisher>
Reference-contexts: First-class continuations have been investigated mainly as powerful, but unstructured devices requiring a deep intuition and operational skill <ref> [Friedman, Haynes, & Kohlbecker 84] </ref> [Haynes & Friedman 87]. However, some progress has been made towards a more declarative view of them, based on a category-theoretical duality between values and continuations [Filinski 89]. Recent trends in investigating first-class continuations require the ability of composing them [Felleisen et al. 87].
Reference: [Haynes & Friedman 87] <author> Christopher T. Haynes, Daniel P. Friedman: </author> <title> Embedding Continuations in Procedural Objects, </title> <journal> TOPLAS, </journal> <volume> Vol. </volume> <pages> 9, </pages> <note> No 4 pp 582-598 (October 1987) Preliminary version: Constraining Control, proceedings of the 12th ACM Symposium on Principles of Programming Languages pp 245-254 (January 1985) </note>
Reference-contexts: First-class continuations have been investigated mainly as powerful, but unstructured devices requiring a deep intuition and operational skill [Friedman, Haynes, & Kohlbecker 84] <ref> [Haynes & Friedman 87] </ref>. However, some progress has been made towards a more declarative view of them, based on a category-theoretical duality between values and continuations [Filinski 89]. Recent trends in investigating first-class continuations require the ability of composing them [Felleisen et al. 87].
Reference: [Johnson 87] <author> Gregory F. Johnson: </author> <title> GL A Denotational Testbed with Continuations and Partial Continuations as First-Class Objects, </title> <booktitle> proceedings of the SIGPLAN'87 Symposium on Interpreters and Interpretive Techniques pp 154-176, </booktitle> <address> Saint-Paul, Minnesota (June 1987) </address>
Reference-contexts: However, some progress has been made towards a more declarative view of them, based on a category-theoretical duality between values and continuations [Filinski 89]. Recent trends in investigating first-class continuations require the ability of composing them [Felleisen et al. 87]. This has been explored in GL <ref> [Johnson 87] </ref>, where continuations were composed in the semantic equations. Unfortunately this makes the semantics order-dependent, comparably to converting a meta-circular interpreter containing shift and reset only once.
Reference: [Johnson & Duggan 88] <author> Gregory F. Johnson, Dominic Dug-gan: </author> <title> Stores and Partial Continuations as First-Class Objects in a Language and its Environment, </title> <booktitle> proceedings of the Fifteenth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages pp 158-168, </booktitle> <address> San Diego, California (January 1988) </address>
Reference-contexts: This has been explored in GL [Johnson 87], where continuations were composed in the semantic equations. Unfortunately this makes the semantics order-dependent, comparably to converting a meta-circular interpreter containing shift and reset only once. The approach is changed in <ref> [Johnson & Duggan 88] </ref>, where continuations are composed by appending their representation, precisely as with the control operator in [Felleisen et al. 88]. Further, since a continuation represents a context, context delimiters have been introduced in [Felleisen 88] as prompts.
Reference: [Malmkjaer 89] <author> Karoline Malmkjaer: </author> <title> On some Semantic As--pects of the Reflective Tower, </title> <booktitle> proceedings of the 4th Conference on Mathematical Foundations of Programming Semantics, Lecture Notes in Computer Science No ??, Michael Main, </booktitle> <editor> Austin Melton, Michael Mislove, and David Schmidt (eds.), </editor> <publisher> Springer-Verlag, </publisher> <address> New Or-leans, Louisiana (April 1989) </address>
Reference: [Mazurkiewicz 71] <author> Antoni W. Mazurkiewicz: </author> <title> Proving Algorithms by Tail Functions, </title> <journal> Information and Control Vol. </journal> <note> 18 pp 220-226 (1971) </note>
Reference-contexts: de rive an instruction set for implementing a semantic specification. 5 Comparison with Related Work The idea of representing "the rest of the computation" as a function or a procedure has occurred more or less independently in [van Wijngaarden 66] for transforming Algol 60 programs to eliminate all labels, in <ref> [Mazurkiewicz 71] </ref> for proving algorithms, and in [Fischer 72] to prove the generality of a deletion implementation strategy, based on adding a functional argument and transforming returns into calls [Morris 72].
Reference: [Mellish & Hardy 84] <author> Chris Mellish, Steve Hardy: </author> <title> Integrating Prolog in the POPLOG Environment, in Implementations of PROLOG, </title> <editor> John A. </editor> <publisher> Campbell (ed.) </publisher> <pages> pp 147-162, </pages> <publisher> Ellis Horwood (1984) </publisher>
Reference-contexts: This ensures an automatic consistency between the two methods of language definition. 3 An Application: Nondeterministic Programming It is well-known that continuation passing-style can be used to simulate backtracking in, e.g., Prolog programs <ref> [Mellish & Hardy 84] </ref>. In this "downward success" model of nondeterministic execution, alternatives at choice points are considered in sequence. However, such an approach requires the entire program to be expressed with explicit success continuations, complicating its structure considerably.
Reference: [Miller 87] <author> James S. Miller: MultiScheme: </author> <title> A Parallel Processing System Based on MIT Scheme, </title> <type> PhD thesis, </type> <month> MIT/LCS/TR-402 (September </month> <year> 1987) </year>
Reference-contexts: Of course, extended continuation-passing style is in general more verbose than plain continuation-passing style. This suggests introducing new control operators to retain the ability of expressing programs in direct style, mirroring the rationale for including call-with-current-continuation in Scheme [Rees & Clinger 86] <ref> [Miller 87, appendix A] </ref>. We will show how such control operators can in fact be systematically added to an applicative order -calculus. Sections 1 and 2 investigate extended continuation--passing style and how to convert direct terms in the basic case of one delimited context.
Reference: [Milne & Strachey 76] <author> Robert E. Milne, Christopher Stra-chey: </author> <title> A Theory of Programming Language Semantics, </title> <publisher> Chapman and Hall, London, and John Wiley, </publisher> <address> New York (1976) </address>
Reference-contexts: Does this mean that control operators substantially more powerful than jumps are indeed beyond the limit of a traditional continuation semantics? In the following, we present a denotational "standard semantics" <ref> [Milne & Strachey 76] </ref>, where continuations are represented with functions and control is abstracted with procedures, and where programs have natural, purely functional counterparts.
Reference: [Moggi 89] <author> Eugenio Moggi: </author> <title> Computational Lambda-calculus and Monads, </title> <booktitle> proceedings of 4th Conference on Logic in Computer Science pp 14-23, IEEE (1989). </booktitle>
Reference-contexts: On the other hand, having a limited number of contexts may correspond to a computational reality. Again, this is left for further research. Finally, there appear to be some deep connections between our development and the monad-based computational -calculus described in <ref> [Moggi 89] </ref>. One would expect the generalized notion of continuation presented here to be expressible as a suitable monad structure over the -calculus. Furthermore, the ability to compose and reset continuations in turn seems sufficient to encode any such structure as an instance of the ECPS formalism.
Reference: [Morris 72] <author> James H. Morris Jr.: </author> <title> A Bonus from van Wijn-gaarden's Device, </title> <journal> Communications of the ACM Vol. </journal> <volume> 15, No 8, </volume> <month> p 773 (August </month> <year> 1972) </year>
Reference-contexts: procedure has occurred more or less independently in [van Wijngaarden 66] for transforming Algol 60 programs to eliminate all labels, in [Mazurkiewicz 71] for proving algorithms, and in [Fischer 72] to prove the generality of a deletion implementation strategy, based on adding a functional argument and transforming returns into calls <ref> [Morris 72] </ref>. Continuations were presented as a device for formalizing control flow in the denota-tional specification of programming languages with jumps [Strachey & Wadsworth 74]. This device was characterized as yielding language specifications independent of the evaluation order of the defining language [Reynolds 72] [Plotkin 75].
Reference: [Plotkin 75] <author> Gordon Plotkin: </author> <title> Call-by-Name, Call-by-Value, and the -calculus, </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. </volume> <pages> 1 pp 125-159 (1975) </pages>
Reference-contexts: Continuations were presented as a device for formalizing control flow in the denota-tional specification of programming languages with jumps [Strachey & Wadsworth 74]. This device was characterized as yielding language specifications independent of the evaluation order of the defining language [Reynolds 72] <ref> [Plotkin 75] </ref>. Relations between direct and continuation semantics were investigated in [Reynolds 74], together with their congruence [Sethi & Tang 80].
Reference: [Rees & Clinger 86] <editor> Jonathan Rees, William Clinger (eds.): </editor> <title> Revised 3 Report on the Algorithmic Language Scheme, </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. </volume> <pages> 21, </pages> <note> No 12 pp 37-79 (December 1986) </note>
Reference-contexts: Of course, extended continuation-passing style is in general more verbose than plain continuation-passing style. This suggests introducing new control operators to retain the ability of expressing programs in direct style, mirroring the rationale for including call-with-current-continuation in Scheme <ref> [Rees & Clinger 86] </ref> [Miller 87, appendix A]. We will show how such control operators can in fact be systematically added to an applicative order -calculus. Sections 1 and 2 investigate extended continuation--passing style and how to convert direct terms in the basic case of one delimited context.
Reference: [Reynolds 72] <author> John Reynolds: </author> <title> Definitional Interpreters for Higher-Order Programming Languages, </title> <booktitle> proceedings 25th ACM National Conference pp 717-740, </booktitle> <address> New York (1972) </address>
Reference-contexts: Very importantly, however, it inherits the characteristic, syntactically restricted form of a -calculus without nested function applications. As such, it still yields semantic specifications where the evaluation order of the defined language is independent of the evaluation order of the defining one <ref> [Reynolds 72] </ref>. Of course, extended continuation-passing style is in general more verbose than plain continuation-passing style. This suggests introducing new control operators to retain the ability of expressing programs in direct style, mirroring the rationale for including call-with-current-continuation in Scheme [Rees & Clinger 86] [Miller 87, appendix A]. <p> Continuations were presented as a device for formalizing control flow in the denota-tional specification of programming languages with jumps [Strachey & Wadsworth 74]. This device was characterized as yielding language specifications independent of the evaluation order of the defining language <ref> [Reynolds 72] </ref> [Plotkin 75]. Relations between direct and continuation semantics were investigated in [Reynolds 74], together with their congruence [Sethi & Tang 80]. <p> The translation can still be improved by generalizing Reynolds's concept of serious and trivial terms <ref> [Reynolds 72] </ref>: a n-trivial term is a term that does not need to be passed the nth, n + 1st, etc. continuations because it does not use them but merely transmits them unchanged. Such a term need not be translated further.
Reference: [Reynolds 74] <author> John Reynolds: </author> <title> On the Relation between Direct and Continuation Semantics, </title> <booktitle> 2nd Colloquium on Automata, Languages and Programming, Lecture Notes in Computer Science No 14 pp 141-156, </booktitle> <publisher> Springer-Verlag, </publisher> <editor> Jacques Loeckx (ed.), </editor> <booktitle> Saarbrucken, </booktitle> <address> West Ger-many (July 1974) </address>
Reference-contexts: This device was characterized as yielding language specifications independent of the evaluation order of the defining language [Reynolds 72] [Plotkin 75]. Relations between direct and continuation semantics were investigated in <ref> [Reynolds 74] </ref>, together with their congruence [Sethi & Tang 80]. Continuation-passing style was made popular in [Steele & Sussman 76], and conversion to CPS has become a common device for compiling Scheme [Steele 78] and more recently ML programs [Appel & Jim 89].
Reference: [Sethi & Tang 80] <author> Ravi Sethi, Adrian Tang: </author> <title> Constructing Call-by-Value Continuation Semantics, </title> <journal> Journal of the ACM, </journal> <volume> Vol. </volume> <pages> 27, </pages> <note> No 3 pp 580-597 (July 1980) </note>
Reference-contexts: Also, the static nature of the translation into CPS induces a naturally static type system for the language. This aspect is treated in more depth in [Danvy & Filinski 89]. Let us finally point out the congruence relation <ref> [Sethi & Tang 80] </ref> between the meta-continuation semantics and an ordinary continuation semantics: E mc [[E]]ae mc fl = fl (E c [[E]]ae c ) completely analogous to the traditional congruence between continuation and direct semantics: E c [[E]]ae c = (E d [[E]]ae d ) where ae d and ae <p> This device was characterized as yielding language specifications independent of the evaluation order of the defining language [Reynolds 72] [Plotkin 75]. Relations between direct and continuation semantics were investigated in [Reynolds 74], together with their congruence <ref> [Sethi & Tang 80] </ref>. Continuation-passing style was made popular in [Steele & Sussman 76], and conversion to CPS has become a common device for compiling Scheme [Steele 78] and more recently ML programs [Appel & Jim 89].
Reference: [Sitaram & Felleisen 90] <author> Dorai Sitaram, Matthias Felleisen: </author> <title> Control Delimiters and their Hierarchies, </title> <note> to appear in Lisp and Symbolic Computation, </note> <institution> Rice University, </institution> <address> Hous-ton, Texas (June 1989) </address>
Reference-contexts: In fact, F- coincides operationally with shift 1 for the simple case of one delimited context, just like static and dynamic scoping agree when the latter is used in a controlled way. <ref> [Sitaram & Felleisen 90] </ref> proposes a hierarchy of control operators. In that framework, specialized operators are defined within the language using control and prompt. Using them instead of the general primitives control and prompt realizes the hierarchy.
Reference: [Smith 82] <author> Brian C. Smith: </author> <title> Reflection and Semantics in a Procedural Language, </title> <type> PhD thesis, </type> <address> MIT/LCS/TR-272, </address> <publisher> MIT, </publisher> <address> Cambridge, Massachusetts (January 1982) </address>
Reference-contexts: It also stresses the duality between sharing data structures and sharing control when constructing these data structures. 2 Abstracting control and evaluating a term in a series of embedded contexts can be related to computational reflection and the reflective tower <ref> [Smith 82] </ref>. Leaving aside the fact that a reflective tower addresses all the elements of the computational field and not only control, our contexts correspond to the levels in the reflective tower.
Reference: [Steele & Sussman 76] <author> Guy L. Steele Jr., Gerald J. Suss-man: </author> <title> Lambda, the Ultimate Imperative, </title> <journal> MIT-AIL, </journal> <volume> AI Memo No 353, </volume> <publisher> Cambridge, </publisher> <address> Massachusetts (March 1976) </address>
Reference-contexts: This device was characterized as yielding language specifications independent of the evaluation order of the defining language [Reynolds 72] [Plotkin 75]. Relations between direct and continuation semantics were investigated in [Reynolds 74], together with their congruence [Sethi & Tang 80]. Continuation-passing style was made popular in <ref> [Steele & Sussman 76] </ref>, and conversion to CPS has become a common device for compiling Scheme [Steele 78] and more recently ML programs [Appel & Jim 89]. Programming with continuations has appeared as an intriguing possibility offered by control operators such as Landin's J, Reynolds's escape, and call-with-current-continuation in Scheme.
Reference: [Steele 78] <author> Guy L. Steele Jr.: RABBIT: </author> <title> A Compiler for SCHEME, </title> <address> MIT-AIL, AI-TR-474, Cambridge, </address> <month> Mas-sachusetts (May </month> <year> 1978) </year>
Reference-contexts: The problem is that the constructed terms contain many fi- and j-redexes, which must usually be post-reduced in a separate pass <ref> [Steele 78] </ref>. However, it is possible to avoid building them at all, by performing the reduction directly in conjunction with the translation. The key is to represent continuations in the converted terms as semantic functions operating on pieces of abstract syntax, rather than as syntactic terms. <p> Alternatively, it translates terms of a Scheme-like language (i.e., -calculus + escape) into standard CPS. Such a conversion has a practical interest for compiling, from <ref> [Steele 78] </ref> to [Appel & Jim 89], and thus constitutes a significant example of using shift/reset: even the pure CPS translation is expressed naturally using the new control operators. As with all meta-circular definitions, we need to bootstrap it. <p> Relations between direct and continuation semantics were investigated in [Reynolds 74], together with their congruence [Sethi & Tang 80]. Continuation-passing style was made popular in [Steele & Sussman 76], and conversion to CPS has become a common device for compiling Scheme <ref> [Steele 78] </ref> and more recently ML programs [Appel & Jim 89]. Programming with continuations has appeared as an intriguing possibility offered by control operators such as Landin's J, Reynolds's escape, and call-with-current-continuation in Scheme.
Reference: [Stoy 81] <author> Joseph E. Stoy: </author> <title> The Congruence of Two Programming Language Definitions, </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. </volume> <pages> 13 pp 151-174 (1981) </pages>
Reference-contexts: and an ordinary continuation semantics: E mc [[E]]ae mc fl = fl (E c [[E]]ae c ) completely analogous to the traditional congruence between continuation and direct semantics: E c [[E]]ae c = (E d [[E]]ae d ) where ae d and ae c are related in the usual way <ref> [Stoy 81] </ref>. In particular, results concerning recursion and the problem of nontermination can be carried over directly. 2 Metacircular Interpreters and Compilers The traditional CPS translation equations of the last section, while simple, tend to produce unnecessarily large results.
Reference: [Strachey & Wadsworth 74] <author> Christopher Strachey, Christo-pher P. Wadsworth: </author> <title> Continuations: A Mathematical Semantics for Handling Full Jumps, </title> <type> Technical Monograph PRG-11, </type> <institution> Oxford University Computing Laboratory, Programming Research Group, </institution> <address> Oxford, England (1974) </address>
Reference-contexts: Continuations were presented as a device for formalizing control flow in the denota-tional specification of programming languages with jumps <ref> [Strachey & Wadsworth 74] </ref>. This device was characterized as yielding language specifications independent of the evaluation order of the defining language [Reynolds 72] [Plotkin 75]. Relations between direct and continuation semantics were investigated in [Reynolds 74], together with their congruence [Sethi & Tang 80].
Reference: [van Wijngaarden 66] <author> Adriaan van Wijngaarden: </author> <title> Recursive Definition of Syntax and Semantics, in Formal Language Description Languages for Computer Programming pp 13-24, </title> <editor> T. B. Steel Jr. (ed.), </editor> <publisher> North-Holland (1966) </publisher>
Reference-contexts: (BBB)C)g = g:n (B (CBC)B)g As usual, defining combinators makes it possible to de rive an instruction set for implementing a semantic specification. 5 Comparison with Related Work The idea of representing "the rest of the computation" as a function or a procedure has occurred more or less independently in <ref> [van Wijngaarden 66] </ref> for transforming Algol 60 programs to eliminate all labels, in [Mazurkiewicz 71] for proving algorithms, and in [Fischer 72] to prove the generality of a deletion implementation strategy, based on adding a functional argument and transforming returns into calls [Morris 72].
Reference: [Wand & Friedman 88] <author> Mitchell Wand, Daniel P. Friedman: </author> <title> The Mystery of the Tower Revealed: A Non-Reflective Description of the Reflective Tower, </title> <journal> Volume 1, </journal> <note> Issue 1 of Lisp and Symbolic Computation (May 1988) </note>
Reference-contexts: as treated in Pavel Curtis's (Algorithms) of Lisp Pointers II-3/4. valuation function is comparable to the continuation-passing counterpart of the valuation function in a traditional continuation semantics for Scheme though there are infinitely many contexts: Exp ! Env ! Cont ! MCont ! Ans where MCont = Cont fl in <ref> [Wand & Friedman 88] </ref> and MCont = (Cont fi Env) fl in [Danvy & Malmkjaer 88]. Finally reifying continuations and composing them [Malm-kjaer 89] pushes and pops continuations off the meta-continuation, dynamically, which necessitates reflexive types.
References-found: 36

