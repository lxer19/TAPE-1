URL: http://osl-www.cs.umass.edu/~stefanov/adaptive.ps
Refering-URL: http://www.cs.umass.edu/~stefanov/
Root-URL: 
Title: Adaptive Compilation for Complex Uniprocessor Hardware  
Author: Katja Daumueller and Darko Stefanovic 
Date: December 1994  
Abstract-found: 0
Intro-found: 1
Reference: [Bak91] <author> Henry G. Baker. </author> <title> Precise instruction scheduling without a precise machine model. </title> <journal> ACM Computer Architecture News, </journal> <volume> 19(2) </volume> <pages> 4-8, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: The proposed compiler can invoke the architecture simulation tool and obtain a timing prediction for a code sequence (or larger fragment) under consideration (See Figure 1, solid arrows). Whenever the hardware is designed to allow it, the compiler can directly execute the code sequence <ref> [Bak91] </ref> and obtain a timing measurement (Figure 1, broken arrows). Finally, the compiler can use profiling data from the execution of complete programs. The preceding criteria are based on some form of black-box performance prediction.
Reference: [BCKT89] <author> Preston Briggs, Keith D. Cooper, Ken Kennedy, and Linda Torczon. </author> <title> Coloring heuristics for register allocation. </title> <booktitle> In Proceedings of the ACM SIGPLAN 89 Conference on Programming Language Design and Implementation., </booktitle> <pages> pages 275-284, </pages> <year> 1989. </year>
Reference-contexts: We want to find out if it is possible to determine this structure exploratively. In particular, adaptive search techniques (also known as learning) may be used to this end. 2 Related Work In the literature, some approaches deal with register allocation <ref> [Cha82, BCKT89, CH90, San90, Project Description 7 CK91] </ref>, some with instruction scheduling [GM86, GR90, War90, BR91] and some try to perform register allocation and instruction scheduling simultaneously or try to integrate it best [Kar84, Mor91, BEH91, PF91, BHE91]. <p> If there does not exist any node with degree less than k, spill code has to be inserted, and the process has to be repeated with a new graph. The algorithm runs in time linear in the size of the expression tree. Briggs et al. <ref> [BCKT89] </ref> improve this method by removing the nodes in a special sequence and applying another criterion. After all nodes have been removed, k-coloring is applied to the nodes in the order they had been taken out of the graph.
Reference: [BEH91] <author> David G. Bradlee, Susan J. Eggers, and Robert R. Henry. </author> <title> Integrating register allocation and instruction scheduling for RISCs. </title> <booktitle> In Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems., </booktitle> <pages> pages 122-131, </pages> <address> Santa Clara, California, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: be used to this end. 2 Related Work In the literature, some approaches deal with register allocation [Cha82, BCKT89, CH90, San90, Project Description 7 CK91], some with instruction scheduling [GM86, GR90, War90, BR91] and some try to perform register allocation and instruction scheduling simultaneously or try to integrate it best <ref> [Kar84, Mor91, BEH91, PF91, BHE91] </ref>. Two approaches were found where the machine was described with parameters or with a model language [BEH91, BR91]. 2.1 Register allocation Concerning register allocation, in all of the approaches, heuristics are applied, because otherwise the problem would be intractable. <p> Two approaches were found where the machine was described with parameters or with a model language <ref> [BEH91, BR91] </ref>. 2.1 Register allocation Concerning register allocation, in all of the approaches, heuristics are applied, because otherwise the problem would be intractable. One basic approach [Cha82] (Chaitin's algorithm), for example, builds an interference graph, where each edge represents an interference between two live ranges. <p> The approach is restricted in that it cannot handle register variables, and it is assumed that all operations decrease the number of registers by one. For our purposes, this approach would be too restrictive because delays are only allowed for loads and not for e.g. branches. Bradlee et al. <ref> [BEH91] </ref> compare what benefit coupled scheduling of register allocation and instruction scheduling has. It investigates three algorithms, of which the first completely separates register allocation and instruction scheduling. The second emulates communication by encouraging the scheduler to keep register pressure at a level conducive to good register allocation. <p> In the mapping from the intermediate representation to the machine code, some C code has to be written by the user. For Project Description 11 instruction scheduling and register allocation, the three algorithms of <ref> [BEH91] </ref> are implemented. A common heuristic for scheduling is again the maximum distance heuristic, where the node with the maximum distance along any path from the instruction node to a leaf node in the code DAG is scheduled.
Reference: [BHE91] <author> David G. Bradlee, Robert R. Henry, and Susan J. Eggers. </author> <title> The Marion system for retargetable instruction scheduling. </title> <booktitle> In PLDI [PLD91], </booktitle> <pages> pages 229-240. </pages>
Reference-contexts: be used to this end. 2 Related Work In the literature, some approaches deal with register allocation [Cha82, BCKT89, CH90, San90, Project Description 7 CK91], some with instruction scheduling [GM86, GR90, War90, BR91] and some try to perform register allocation and instruction scheduling simultaneously or try to integrate it best <ref> [Kar84, Mor91, BEH91, PF91, BHE91] </ref>. Two approaches were found where the machine was described with parameters or with a model language [BEH91, BR91]. 2.1 Register allocation Concerning register allocation, in all of the approaches, heuristics are applied, because otherwise the problem would be intractable. <p> Modifications on the third algorithm are suggested which could yield improvements, but the conclusion is that expensive approaches like the third one which closely couple register allocation and instruction scheduling, are unnecessary. Finally, Bradlee et al. <ref> [BHE91] </ref> discuss a retargetable code generator (Marion) which uses a description language for RISCs. The description language describes kinds of registers, stages of the pipeline and specific constraints on instructions in the pipeline. <p> It will be possible to elaborate the descriptions in a modular way. There have been several proposed languages with a similar purpose, and ours will most closely resemble the machine description language in the Marion system <ref> [BHE91] </ref>, but it will not include a compiler writer's virtual machine, as we do not want to constrain the range of compiling strategies. 4.2 Hardware implementation An existing hardware implementation may be analysed to obtain a hardware description, or the description can serve as the specification for hardware synthesis.
Reference: [BR91] <author> David Bernstein and Michael Rodeh. </author> <title> Global instruction scheduling for superscalar machines. </title> <booktitle> In PLDI [PLD91], </booktitle> <pages> pages 241-255. </pages>
Reference-contexts: In particular, adaptive search techniques (also known as learning) may be used to this end. 2 Related Work In the literature, some approaches deal with register allocation [Cha82, BCKT89, CH90, San90, Project Description 7 CK91], some with instruction scheduling <ref> [GM86, GR90, War90, BR91] </ref> and some try to perform register allocation and instruction scheduling simultaneously or try to integrate it best [Kar84, Mor91, BEH91, PF91, BHE91]. <p> Two approaches were found where the machine was described with parameters or with a model language <ref> [BEH91, BR91] </ref>. 2.1 Register allocation Concerning register allocation, in all of the approaches, heuristics are applied, because otherwise the problem would be intractable. One basic approach [Cha82] (Chaitin's algorithm), for example, builds an interference graph, where each edge represents an interference between two live ranges. <p> The scheduling algorithm is done before and after the register allocation phase. Bernstein and Rodeh <ref> [BR91] </ref> aim at global (intra-loop) scheduling, which uses the control and data dependence information summarized in a Program Dependence Graph, to move instructions beyond basic block boundaries.
Reference: [CH90] <author> Fred Chow and John L. Hennessy. </author> <title> The priority-based coloring approach to register allocation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 501-536, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: We want to find out if it is possible to determine this structure exploratively. In particular, adaptive search techniques (also known as learning) may be used to this end. 2 Related Work In the literature, some approaches deal with register allocation <ref> [Cha82, BCKT89, CH90, San90, Project Description 7 CK91] </ref>, some with instruction scheduling [GM86, GR90, War90, BR91] and some try to perform register allocation and instruction scheduling simultaneously or try to integrate it best [Kar84, Mor91, BEH91, PF91, BHE91]. <p> This approach avoids spilling in many cases, because it removes nodes out of the graph in a certain order, and it only assigns spill code at the end of the coloring process. The algorithm of Chow and Hennessy <ref> [CH90] </ref> also uses coloring as a central paradigm. The algorithm uses a priority function, which assigns values for every live range in a basic block. If a live range interferes with one of highest priority which was just assigned, it needs to be split. The algorithm runs before code generation.
Reference: [Cha82] <author> G.J. Chaitin. </author> <title> Register allocation and spilling via graph coloring. </title> <booktitle> In Proceedings of the SIGPLAN 82 Symposium on Compiler Construction SIGPLAN Notices., </booktitle> <volume> volume 17, </volume> <month> June </month> <year> 1982. </year>
Reference-contexts: We want to find out if it is possible to determine this structure exploratively. In particular, adaptive search techniques (also known as learning) may be used to this end. 2 Related Work In the literature, some approaches deal with register allocation <ref> [Cha82, BCKT89, CH90, San90, Project Description 7 CK91] </ref>, some with instruction scheduling [GM86, GR90, War90, BR91] and some try to perform register allocation and instruction scheduling simultaneously or try to integrate it best [Kar84, Mor91, BEH91, PF91, BHE91]. <p> Two approaches were found where the machine was described with parameters or with a model language [BEH91, BR91]. 2.1 Register allocation Concerning register allocation, in all of the approaches, heuristics are applied, because otherwise the problem would be intractable. One basic approach <ref> [Cha82] </ref> (Chaitin's algorithm), for example, builds an interference graph, where each edge represents an interference between two live ranges. Chaitin's allocator attempts to color the graph in k colors, where k is the number of registers available.
Reference: [CK91] <author> David Callahan and Brian Koblenz. </author> <title> Register allocation via hierarchical graph coloring. </title> <booktitle> In PLDI [PLD91], </booktitle> <pages> pages 192-203. </pages>
Reference-contexts: The algorithm runs before code generation. If spilling is necessary, registers are always spilled to their home locations. The claims around this algorithm are that it uses less memory and processing overhead than Chaitin's approach, and suffers rarely from worse allocation due to its higher granularity. Callahan and Koblenz <ref> [CK91] </ref> give another approach for register allocation. The argumentation is that longer pipelines and longer latencies between the time an operation is issued and the time it Project Description 8 is available will bring significance to the placement of spill code.
Reference: [GM86] <author> Philip B. Gibbons and Steven S. Muchnick. </author> <title> Efficient instruction scheduling for a pipelined architecture. </title> <booktitle> In Proceedings of the ACM SIGPLAN 86 Conference on Programming Language Design and Implementation., </booktitle> <pages> pages 11-16, </pages> <year> 1986. </year>
Reference-contexts: In particular, adaptive search techniques (also known as learning) may be used to this end. 2 Related Work In the literature, some approaches deal with register allocation [Cha82, BCKT89, CH90, San90, Project Description 7 CK91], some with instruction scheduling <ref> [GM86, GR90, War90, BR91] </ref> and some try to perform register allocation and instruction scheduling simultaneously or try to integrate it best [Kar84, Mor91, BEH91, PF91, BHE91]. <p> Pure instruction scheduling algorithms, however, may not result in optimal register allocation, and spill code could be introduced. 2.2 Instruction scheduling The technique of Gibbons and Muchnick <ref> [GM86] </ref> reduces the number of pipeline interlocks significantly, and runs in time O (n 2 ) for a basic block of n instructions. This is implemented by sweeping down a dag whose nodes are instructions within one basic block. <p> In order to exploit the assumed or observed structure of the large problem space intelligently, heuristics are used. Heuristics are often expressed as ad hoc rules with intuitive justification, such as the rule for alternating low-conflict and high-conflict instructions in RISC scheduling <ref> [GM86] </ref>. Such rules tend to be hardwired into the optimization algorithms with unclear separation between the mechanisms and the policies, between rules for correctness and rules for optimality.
Reference: [GR90] <author> M.C. Golumbic and V. Rainish. </author> <title> Instruction scheduling beyond basic blocks. </title> <journal> IBM Journal Research Development., </journal> <volume> 34(1) </volume> <pages> 93-97, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: In particular, adaptive search techniques (also known as learning) may be used to this end. 2 Related Work In the literature, some approaches deal with register allocation [Cha82, BCKT89, CH90, San90, Project Description 7 CK91], some with instruction scheduling <ref> [GM86, GR90, War90, BR91] </ref> and some try to perform register allocation and instruction scheduling simultaneously or try to integrate it best [Kar84, Mor91, BEH91, PF91, BHE91]. <p> As a lookahead is too expensive, heuristics are used. Information for these heuristics can be kept in the node, e.g., length of the longest path from the instruction to a leaf node. Improvements for global instruction scheduling for pipeline processors are described by Golumbic and Rainish <ref> [GR90] </ref>. A number of structural transformations of loops and branches are introduced, for example exchanging if and then parts of conditional statements because one branch has a delay which cannot be filled by the corresponding if or then block.
Reference: [IAS + ] <author> Arthur Ieumwananonthachai, Akiko N. Aizawa, Steven R. Schwartz, Benjamin W. Wah, and Jerry C. Yan. </author> <title> Intelligent process mapping through systematic improvement of heuristics. </title>
Reference-contexts: It will be largely generic in nature, operating without an understanding of the meaning of the heuristics. There is a considerable body of work in machine learning; some of the newer techniques can, with appropriate modification, be used in the compiler optimization problems <ref> [LM88, IAS + ] </ref>.
Reference: [Kar84] <author> Michael Karr. </author> <title> Code generation by coagulation. </title> <booktitle> In Proceedings of the SIGPLAN 84 Symposium on Compiler Construction SIGPLAN Notices., </booktitle> <volume> volume 19, </volume> <pages> pages 1-12, </pages> <month> June </month> <year> 1984. </year> <note> Bibliography 21 </note>
Reference-contexts: be used to this end. 2 Related Work In the literature, some approaches deal with register allocation [Cha82, BCKT89, CH90, San90, Project Description 7 CK91], some with instruction scheduling [GM86, GR90, War90, BR91] and some try to perform register allocation and instruction scheduling simultaneously or try to integrate it best <ref> [Kar84, Mor91, BEH91, PF91, BHE91] </ref>. Two approaches were found where the machine was described with parameters or with a model language [BEH91, BR91]. 2.1 Register allocation Concerning register allocation, in all of the approaches, heuristics are applied, because otherwise the problem would be intractable. <p> Attempts to have interactions between the register allocation and instruction scheduling phase are made in several papers. Karr <ref> [Kar84] </ref> introduces a coagulating code-generator, which has a tight coupling of register allocation, instruction selection and code optimizations. It makes use of profiling the code.
Reference: [LM88] <author> Kai-Fu Lee and Sanjoy Mahajan. </author> <title> A pattern classification approach to evaluation function learning. </title> <journal> Artificial Intelligence, </journal> <volume> 36 </volume> <pages> 1-25, </pages> <year> 1988. </year>
Reference-contexts: It will be largely generic in nature, operating without an understanding of the meaning of the heuristics. There is a considerable body of work in machine learning; some of the newer techniques can, with appropriate modification, be used in the compiler optimization problems <ref> [LM88, IAS + ] </ref>. <p> Once training is complete, the weighted features are used by the heuristic scheduler to select the next instruction by locally evaluating an evaluation function for each admissible instruction. We anticipate, based on reported performance on tasks of similar complexity in game playing <ref> [LM88] </ref>, that with a good choice of simple heuristics, learning can be effective. The comparison will need to be made with hand-written schedulers and, where possible, with results of optimal scheduling.
Reference: [Mas87] <author> Henry Massalin. </author> <title> Supperoptimizer A look at the smallest program. </title> <booktitle> In Proceedings of the Second International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 122-126, </pages> <address> Palo Alto, California, </address> <year> 1987. </year>
Reference-contexts: For example, it is clear that optimal instruction scheduling of n instructions may require testing n! code sequences in the worst case. Although there has been work on optimal compilation through exhaustive search (for instruction selection <ref> [Mas87] </ref>), it appears necessary in many cases to restrict the search. In order to exploit the assumed or observed structure of the large problem space intelligently, heuristics are used.
Reference: [Mor91] <author> W.G. Morris. CCG: </author> <title> A prototype coagulating code generator. </title> <booktitle> In PLDI [PLD91], </booktitle> <pages> pages 45-58. </pages>
Reference-contexts: be used to this end. 2 Related Work In the literature, some approaches deal with register allocation [Cha82, BCKT89, CH90, San90, Project Description 7 CK91], some with instruction scheduling [GM86, GR90, War90, BR91] and some try to perform register allocation and instruction scheduling simultaneously or try to integrate it best <ref> [Kar84, Mor91, BEH91, PF91, BHE91] </ref>. Two approaches were found where the machine was described with parameters or with a model language [BEH91, BR91]. 2.1 Register allocation Concerning register allocation, in all of the approaches, heuristics are applied, because otherwise the problem would be intractable. <p> If nodes on the endpoints of the arcs do not agree, minor cost repairs are undertaken, such as inserting copy instructions or revising storage allocation. Morris <ref> [Mor91] </ref> augments this method by improving the register allocation, code ordering, general storage allocation and by substantially simplifying cohabitation (occurrences the compiler has allocated to the same storage, but which have intersecting live ranges) resolution. This approach is close to our approach in that it considers profiling information.
Reference: [PF91] <author> Todd A. Proebsting and Charles N. Fischer. </author> <title> Linear-time, optimal code scheduling for delayed-load architectures. </title> <booktitle> In PLDI [PLD91], </booktitle> <pages> pages 256-267. </pages>
Reference-contexts: be used to this end. 2 Related Work In the literature, some approaches deal with register allocation [Cha82, BCKT89, CH90, San90, Project Description 7 CK91], some with instruction scheduling [GM86, GR90, War90, BR91] and some try to perform register allocation and instruction scheduling simultaneously or try to integrate it best <ref> [Kar84, Mor91, BEH91, PF91, BHE91] </ref>. Two approaches were found where the machine was described with parameters or with a model language [BEH91, BR91]. 2.1 Register allocation Concerning register allocation, in all of the approaches, heuristics are applied, because otherwise the problem would be intractable. <p> This approach is close to our approach in that it considers profiling information. It does not, however, deal with architectural constraints, and only allows the profiling information to be used in one heuristic. Proebsting and Fischer <ref> [PF91] </ref> introduce an algorithm which optimizes register allocation as well as instruction scheduling for pipeline architectures with load delays of one; for higher delays, the algorithm serves as a good heuristic.
Reference: [PLD91] <institution> Proceedings of the ACM SIGPLAN 91 Conference on Programming Language Design and Implementation., Toronto, </institution> <address> Ontario, Canada, </address> <month> June </month> <year> 1991. </year>
Reference: [San90] <author> Vatsa Santhaman. </author> <title> Register allocation across procedure and module boundaries. </title> <booktitle> In Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation., </booktitle> <year> 1990. </year>
Reference-contexts: We want to find out if it is possible to determine this structure exploratively. In particular, adaptive search techniques (also known as learning) may be used to this end. 2 Related Work In the literature, some approaches deal with register allocation <ref> [Cha82, BCKT89, CH90, San90, Project Description 7 CK91] </ref>, some with instruction scheduling [GM86, GR90, War90, BR91] and some try to perform register allocation and instruction scheduling simultaneously or try to integrate it best [Kar84, Mor91, BEH91, PF91, BHE91]. <p> Final spill decisions are made according to control flow information (e.g., where along the tile tree should the variable be spilled) and using statistics. The algorithm claims to have superior performance with inline expansion and procedure calls. Santhaman <ref> [San90] </ref> describes a method for compiling programs using interprocedural register allocation. A strategy for handling programs built from multiple modules is presented, as well as algorithms for global variable promotion and register spill code motion. The approach uses profiling information.
Reference: [War90] <author> H.S. Waren. </author> <title> Instruction scheduling for the IBM RISC System/6000 processor. </title> <journal> IBM Journal Research Development., </journal> <volume> 34(1) </volume> <pages> 85-92, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: In particular, adaptive search techniques (also known as learning) may be used to this end. 2 Related Work In the literature, some approaches deal with register allocation [Cha82, BCKT89, CH90, San90, Project Description 7 CK91], some with instruction scheduling <ref> [GM86, GR90, War90, BR91] </ref> and some try to perform register allocation and instruction scheduling simultaneously or try to integrate it best [Kar84, Mor91, BEH91, PF91, BHE91]. <p> A number of structural transformations of loops and branches are introduced, for example exchanging if and then parts of conditional statements because one branch has a delay which cannot be filled by the corresponding if or then block. Waren <ref> [War90] </ref> describes a scheduling algorithm in basic blocks on the IBM RS/6000 processor, which is designed to use arithmetic units as efficiently as possible.
References-found: 19

