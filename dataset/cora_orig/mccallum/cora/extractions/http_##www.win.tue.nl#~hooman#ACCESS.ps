URL: http://www.win.tue.nl/~hooman/ACCESS.ps
Refering-URL: http://www.win.tue.nl/~hooman/ACCESS.html
Root-URL: http://www.win.tue.nl
Email: e-mail: wsinjh@win.tue.nl  
Title: Verifying Part of the ACCESS.bus Protocol using PVS  
Author: Jozef Hooman 
Address: P.O. Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Dept. of Mathematics and Computing Science Eindhoven University of Technology  
Abstract: Based on a compositional framework for the formal specification of distributed real-time systems, we present a method for protocol verification. To be able to deal with realistic examples, the method is supported by the interactive proof checker PVS. In this paper we illustrate our approach by a protocol of the ACCESS.bus which is used for the communication between a computer host and its peripheral devices (e.g., keyboards, mice, joysticks, etc.). The bus supports dynamic reconfiguration while the system is operating. We specify and verify a safety property and a real-time progress property of this industrial example. 
Abstract-found: 1
Intro-found: 1
Reference: [ACC94] <institution> ACCESS.bus TM , Specifications Version 2.2. Sunnyvale, California, </institution> <year> 1994. </year>
Reference-contexts: The PVS system contains an interactive proof checker 1 PVS is free available, see WWW page http://www.csl.sri.com/sri-csl-pvs.html 2 with, for instance, induction rules, automatic rewriting, and powerful decision procedures. The first four steps of the method described above, supported by PVS, are applied to a part of the ACCESS.bus <ref> [ACC94] </ref>. ACCESS.bus is used for the communication between a computer host and its peripheral devices, such as keyboards, mice, joysticks, modems, monitors and printers. The ACCESS.bus protocol includes a physical layer and several software layers, including a base protocol, device driver interface, and several specific device protocols. <p> This, however, is not sufficient to prove top_level1. If two devices have the same identification string, they obtain the same address, and if they send their Reset messages simultaneously, then none of them will receive it and both can start sending data from the same address. The documentation <ref> [ACC94] </ref> does not give a solution for this case, but it seems reasonable to assume that the probability that this situation occurs is very small. To avoid reasoning with probabilities, we assume here that the situation can be neglected, i.e. that simultaneous resets do not occur, as expressed by not_sim_reset. <p> The main aim here was to investigate the support of the interactive theorem prover PVS for our protocol verification method. An important part of the work described here concerns the tranformation from an informal description <ref> [ACC94] </ref> into a formal specification. In this paper we have extracted the essential points needed to prove a few properties, ignoring irrelevant implementation details, thus clarifying the protocol and making assumptions for its correctness explicit. <p> For instance, to show the safety property (devices in data mode have different addresses) we had to introduce an assumption about the impossibility of simultanous Reset messages. Further we have slightly generalized the formulation in <ref> [ACC94] </ref> by introducing timing constants instead of concrete numbers and by deriving constraints on these constants that ensure correctness of the protocol. Since the step from informal document to formal specification is crucial, we have tried to define our specifications close to the informal formulation.
Reference: [BPV94] <author> D. Bosscher, I. Polak, and F. Vaandrager. </author> <title> Verification of an audio control protocol. </title> <booktitle> In Formal Techniques in Real-Time and Fault-Tolerant Systems, </booktitle> <pages> pages 170-192. </pages> <note> LNCS 863, </note> <year> 1994. </year>
Reference-contexts: We also mention the specification language TLA (Temporal Logic of Actions) which has been applied to a large number of examples. See, e.g., the specification and the hierarchically structured proof of a Byzantine generals algorithm [LM94]. Another nice example of protocol verification can be found in <ref> [BPV94] </ref> where an industrial protocol is specified and verified based on timed I/O automata. Acknowledgements The ACCESS.bus protocol has been proposed by Ron Koymans (Philips Research, Eindhoven) to a number of academic researchers as an example of an 14 industrial protocol.
Reference: [GCR94] <author> S. Gerhart, D. Craigen, and T. Ralston. </author> <title> Experience with formal methods in critical systems. </title> <journal> IEEE Software, </journal> <volume> 11(1) </volume> <pages> 21-39, </pages> <year> 1994. </year>
Reference-contexts: The protocol has real-time aspects and allows dynamic reconfiguration. Recent overviews on industrial applications of formal methods can be found in [Rus93] and <ref> [GCR94] </ref>. The main aim here was to investigate the support of the interactive theorem prover PVS for our protocol verification method. An important part of the work described here concerns the tranformation from an informal description [ACC94] into a formal specification.
Reference: [Hoa69] <author> C.A.R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) 576-580,583, </volume> <year> 1969. </year>
Reference-contexts: This means that in a rule for a compound programming construct only the specifications of its components are used. Compositionality makes it possible to verify design steps during the process of top-down system development. A large number of compositional proof systems have been developed, for instance, for sequential systems <ref> [Hoa69] </ref>, untimed systems [Zwi89, PJ91], and real-time systems [Hoo91]. The only programming construct used in this paper is parallel composition. Under certain conditions we have the following compositional rule. Rule 1 (Parallel Composition).
Reference: [Hoo91] <author> J. Hooman. </author> <title> Specification and Compositional Verification of Real-Time Systems. </title> <publisher> LNCS 558, Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction In previous work we have addressed the formal specification and verification of distributed real-time systems (see, e.g., <ref> [Hoo91] </ref>). A framework based on Hoare triples has been applied to several examples such as a water level monitoring system [Hoo93] and a chemical batch processing system [Hoo94c]. <p> Compositionality makes it possible to verify design steps during the process of top-down system development. A large number of compositional proof systems have been developed, for instance, for sequential systems [Hoa69], untimed systems [Zwi89, PJ91], and real-time systems <ref> [Hoo91] </ref>. The only programming construct used in this paper is parallel composition. Under certain conditions we have the following compositional rule. Rule 1 (Parallel Composition). <p> spec 2 P 1 kP 2 sat spec 1 ^ spec 2 The main restriction on the application of this rule is that the specification spec i of process P i should only refer to the observable actions of process P i itself, for i = 1; 2 (see, e.g., <ref> [Hoo91, Hoo94c] </ref> for more details). We also need a consequence rule to weaken a specification. Rule 2 (Consequence).
Reference: [Hoo93] <author> J. Hooman. </author> <title> A compositional approach to the design of hybrid systems. </title> <booktitle> In Workshop on Theory of Hybrid Systems, </booktitle> <pages> pages 121-148. </pages> <note> LNCS 736, </note> <year> 1993. </year>
Reference-contexts: 1 Introduction In previous work we have addressed the formal specification and verification of distributed real-time systems (see, e.g., [Hoo91]). A framework based on Hoare triples has been applied to several examples such as a water level monitoring system <ref> [Hoo93] </ref> and a chemical batch processing system [Hoo94c]. In the current paper we only consider the basic ideas behind this formalism and concentrate on the application of such a method to protocol verification.
Reference: [Hoo94a] <author> J. Hooman. </author> <title> Compositional verification of a distributed real-time arbitration protocol. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 6(2) </volume> <pages> 173-205, </pages> <year> 1994. </year>
Reference-contexts: The correctness of this step is based on compositionality of the parallel composition rule. The method described above has been used to specify and verify a distributed real-time arbitration protocol <ref> [Hoo94a] </ref> in our Hoare-style framework. This protocol is inspired by an algorithm of the IEEE 896 Futurebus specification. In [ZH95] the first four steps of the method have been applied to an atomic broadcast protocol which involves both real-time and fault-tolerance.
Reference: [Hoo94b] <author> J. Hooman. </author> <title> Correctness of real time systems by construction. </title> <booktitle> In Formal Techniques in Real-Time and Fault-Tolerant Systems, </booktitle> <pages> pages 19-40. </pages> <note> LNCS 863, </note> <year> 1994. </year>
Reference-contexts: In the ACCESS.bus example we have not worked out step five of our approach in which a program for the components is derived. An example of program derivation by means of PVS can be found in <ref> [Hoo94b] </ref> where a mixed formalism, in which programs and assertional specifications are combined, has been defined in the PVS specification language.
Reference: [Hoo94c] <author> J. Hooman. </author> <title> Extending Hoare logic to real-time. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6(6A):801-825, </volume> <year> 1994. </year>
Reference-contexts: 1 Introduction In previous work we have addressed the formal specification and verification of distributed real-time systems (see, e.g., [Hoo91]). A framework based on Hoare triples has been applied to several examples such as a water level monitoring system [Hoo93] and a chemical batch processing system <ref> [Hoo94c] </ref>. In the current paper we only consider the basic ideas behind this formalism and concentrate on the application of such a method to protocol verification. Essentially, we use an assertional method in which a system is characterized by expressing its properties in a particular logic. <p> spec 2 P 1 kP 2 sat spec 1 ^ spec 2 The main restriction on the application of this rule is that the specification spec i of process P i should only refer to the observable actions of process P i itself, for i = 1; 2 (see, e.g., <ref> [Hoo91, Hoo94c] </ref> for more details). We also need a consequence rule to weaken a specification. Rule 2 (Consequence).
Reference: [LM94] <author> L. Lamport and S. Merz. </author> <title> Specifying and verifying fault-tolerant systems. </title> <booktitle> In Formal Techniques in Real-Time and Fault-Tolerant Systems, </booktitle> <pages> pages 41-76. </pages> <note> LNCS 863, </note> <year> 1994. </year>
Reference-contexts: We also mention the specification language TLA (Temporal Logic of Actions) which has been applied to a large number of examples. See, e.g., the specification and the hierarchically structured proof of a Byzantine generals algorithm <ref> [LM94] </ref>. Another nice example of protocol verification can be found in [BPV94] where an industrial protocol is specified and verified based on timed I/O automata.
Reference: [LR93] <author> P. Lincoln and J. Rushby. </author> <title> The formal verification of an algorithm for interactive consistency under a hybrid fault model. </title> <booktitle> In Computer Aided Verification '93, </booktitle> <pages> pages 292-304. </pages> <publisher> LNCS 697, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Related to the work described here is the use of PVS [ORS92] and its predecessor EHDM for a number of applications, such as an interactive convergence clock synchronization algorithm [RvH93], a Byzantine fault-tolerant clock synchronization [Sha93], and an algorithm for interactive consistency <ref> [LR93] </ref>. We also mention the specification language TLA (Temporal Logic of Actions) which has been applied to a large number of examples. See, e.g., the specification and the hierarchically structured proof of a Byzantine generals algorithm [LM94].
Reference: [ORS92] <author> S. Owre, J. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <booktitle> In 11th Conference on Automated Deduction, volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 748-752. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: One should have a tool to construct proofs, to discharge simple verification conditions automatically, and to check proofs mechanically (e.g., after small changes in the specifications). Therefore we investigate the use of the verification system PVS 1 (Prototype Verification System) <ref> [ORS92] </ref> for our method. The PVS specification language is a strongly-typed higher-order logic. Specifications can be structured into a hierarchy of theories. There are a number of built-in theories (e.g., reals, lists, sets, ordering relations, etc.) and a mechanism for automatically generating theories for abstract datatypes. <p> An example of program derivation by means of PVS can be found in [Hoo94b] where a mixed formalism, in which programs and assertional specifications are combined, has been defined in the PVS specification language. Related to the work described here is the use of PVS <ref> [ORS92] </ref> and its predecessor EHDM for a number of applications, such as an interactive convergence clock synchronization algorithm [RvH93], a Byzantine fault-tolerant clock synchronization [Sha93], and an algorithm for interactive consistency [LR93].
Reference: [PJ91] <author> P. Pandya and M. Joseph. </author> <title> P-A logic a compositional proof system for distributed programs. </title> <journal> Distributed Computing, </journal> <volume> 4(4), </volume> <year> 1991. </year>
Reference-contexts: Compositionality makes it possible to verify design steps during the process of top-down system development. A large number of compositional proof systems have been developed, for instance, for sequential systems [Hoa69], untimed systems <ref> [Zwi89, PJ91] </ref>, and real-time systems [Hoo91]. The only programming construct used in this paper is parallel composition. Under certain conditions we have the following compositional rule. Rule 1 (Parallel Composition).
Reference: [Rus93] <author> J. Rushby. </author> <title> Formal methods and the certification of critical systems. </title> <type> Technical Report CSL-93-7, </type> <institution> SRI International, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: The protocol has real-time aspects and allows dynamic reconfiguration. Recent overviews on industrial applications of formal methods can be found in <ref> [Rus93] </ref> and [GCR94]. The main aim here was to investigate the support of the interactive theorem prover PVS for our protocol verification method. An important part of the work described here concerns the tranformation from an informal description [ACC94] into a formal specification.
Reference: [RvH93] <author> J. Rushby and F. von Henke. </author> <title> Formal verification of algorithms for critical systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(1) </volume> <pages> 13-23, </pages> <year> 1993. </year>
Reference-contexts: Related to the work described here is the use of PVS [ORS92] and its predecessor EHDM for a number of applications, such as an interactive convergence clock synchronization algorithm <ref> [RvH93] </ref>, a Byzantine fault-tolerant clock synchronization [Sha93], and an algorithm for interactive consistency [LR93]. We also mention the specification language TLA (Temporal Logic of Actions) which has been applied to a large number of examples. See, e.g., the specification and the hierarchically structured proof of a Byzantine generals algorithm [LM94].
Reference: [Sha93] <author> N. Shankar. </author> <title> Verification of real-time systems using PVS. </title> <booktitle> In Computer Aided Verification '93, </booktitle> <pages> pages 280-291. </pages> <publisher> LNCS 697, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Related to the work described here is the use of PVS [ORS92] and its predecessor EHDM for a number of applications, such as an interactive convergence clock synchronization algorithm [RvH93], a Byzantine fault-tolerant clock synchronization <ref> [Sha93] </ref>, and an algorithm for interactive consistency [LR93]. We also mention the specification language TLA (Temporal Logic of Actions) which has been applied to a large number of examples. See, e.g., the specification and the hierarchically structured proof of a Byzantine generals algorithm [LM94].
Reference: [ZH95] <author> P. Zhou and J. Hooman. </author> <title> Formal specification and compositional verification of an atomic broadcast protocol. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 9(2) </volume> <pages> 119-145, </pages> <year> 1995. </year>
Reference-contexts: The correctness of this step is based on compositionality of the parallel composition rule. The method described above has been used to specify and verify a distributed real-time arbitration protocol [Hoo94a] in our Hoare-style framework. This protocol is inspired by an algorithm of the IEEE 896 Futurebus specification. In <ref> [ZH95] </ref> the first four steps of the method have been applied to an atomic broadcast protocol which involves both real-time and fault-tolerance. Whereas these examples have been verified manually, it is clear that the application of our formal method to large realistic systems requires some form of mechanical support.
Reference: [Zwi89] <author> J. Zwiers. </author> <title> Compositionality, Concurrency and Partial Correctness. </title> <publisher> LNCS 321, Springer-Verlag, </publisher> <year> 1989. </year> <title> This article was processed using the L A T E X macro package with LLNCS style 15 </title>
Reference-contexts: Compositionality makes it possible to verify design steps during the process of top-down system development. A large number of compositional proof systems have been developed, for instance, for sequential systems [Hoa69], untimed systems <ref> [Zwi89, PJ91] </ref>, and real-time systems [Hoo91]. The only programming construct used in this paper is parallel composition. Under certain conditions we have the following compositional rule. Rule 1 (Parallel Composition).
References-found: 18

