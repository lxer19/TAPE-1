URL: http://www.cs.wisc.edu/wpis/papers/tr1382.ps
Refering-URL: http://www.cs.wisc.edu/wpis/html/
Root-URL: http://www.cs.wisc.edu
Title: Interprocedural Path Profiling  
Author: David Melski Thomas Reps 
Keyword: Categories and Subject Descriptors: C.4 [Computer Systems Organization]: Performance of Systems| measurement techniques; D.2.2 [Software Engineering]: Tools and Techniques|programmer workbench; D.2.5 [Software Engineering]: Testing and Debugging|diagnostics; tracing G.2.2 [Discrete Mathematics]: Graph Theory|graph algorithms; path and circuit problems General Terms: Algorithms, Measurement Additional Key Words: Control-flow graph, instruction tracing, instrumentation, profiling, algebraic path problem, valid path  
Date: September 1, 1998  
Abstract: In path profiling, a program is instrumented with code that counts the number of times particular path fragments of the program are executed. This paper extends the intraprocedural path-profiling technique of Ball and Larus to collect information about inter procedural paths (i.e., paths that may cross procedure boundaries). Interprocedural path profiling is complicated by the need to account for a procedure's calling context. To handle this complication, we generalize the "path-naming" scheme of the Ball-Larus instrumentation algorithm. In the Ball-Larus work, each edge is labeled with a number, and the "name" of a path is the sum of the numbers on the edges of the path. Our instrumentation technique uses an edge-labeling scheme that is in much the same spirit, but to handle the calling-context problem, edges are labeled with functions instead of values. In effect, the edge-functions allow edges to be numbered differently depending on the calling context. A key step in the process of creating the proper edge functions is related to a method proposed by Sharir and Pnueli for solving context-sensitive interprocedural dataflow-analysis problems. Some of the machinery that we develop to handle the calling-context problem for purposes of in-terprocedural path profiling suggests other variants of both intraprocedural and interprocedural path profiling, as well as a variety of hybrid intra-/interprocedural schemes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: Figure 18 (c) illustrates this transformation. The graph that results from performing these transformations is acyclic. Once the graph has been modified, 8 If the control-flow graph is not reducible, then the graph can be transformed to make it reducible (see, for example, Aho et al. <ref> [1] </ref>). P 9 P 6 The original program is shown in Figure 4; the instrumentation collects an interprocedural piecewise profile. The instrumented version of the function pow and the global declaration of profile is shown in Figure 16.
Reference: [2] <author> G. Ammons, T. Ball, and J. Larus. </author> <title> Exploiting hardware performance counters with flow and context sensitive profiling. </title> <booktitle> In PLDI'97, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: Interprocedural path profiling is complicated by the need to account for a procedure's calling context. There are really two issues: * What is meant by a procedure's "calling context"? Previous work by Ammons et al. <ref> [2] </ref> investigated a hybrid intra-/interprocedural scheme that collects separate intraprocedural profiles for a procedure's different calling contexts.
Reference: [3] <author> G. Ammons and J. Larus. </author> <title> Improving data-flow analysis with path profiles. </title> <booktitle> In Proc. of the ACM SIGPLAN 98 Conf. on Program. Lang. Design and Implementation, </booktitle> <month> June </month> <year> 1998. </year>
Reference-contexts: Information ascertained from interprocedural path profiling could be used to drive partial inlining, either for interprocedural trace scheduling or for an interprocedural extension of the work of Ammons et al. on path-qualified dataflow analysis <ref> [3] </ref>. * There are also several applications in software maintenance: 2 Reps et al. [14] showed that when different runs of a program produce different path profiles, the differences in the path profiles can be used to identify paths in the program along which control diverges in the two runs.
Reference: [4] <author> L. O. Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <month> May </month> <year> 1994. </year> <type> (DIKU report 94/19). </type>
Reference-contexts: Another possibility is to turn each indirect procedure call through a procedure variable fp into an if-then-else chain that has a separate (direct) procedure call for each possible value of fp. Well-known techniques (e.g., such as flow insensitive points-to analysis <ref> [4, 18, 16] </ref>) can be used to obtain a reasonable (but still conservative) estimate of the values that fp may take on. A Proof of Theorem 4.1 Before restating Theorem 4.1, we review some definitions. Let the graph G and the context-free grammar CF be a context-free DAG.
Reference: [5] <author> T. Ball. </author> <title> Efficiently counting program events. </title> <booktitle> In TOPLAS 1994, </booktitle> <year> 1994. </year>
Reference-contexts: Several additional techniques are employed to reduce the runtime overheads incurred. These exploit the fact that there is actually a certain amount of flexibility in the placement of the increment statements <ref> [5, 6] </ref>. 2.2 Supergraph As in many interprocedural program-analysis problems, we work with an interprocedural control-flow graph called a supergraph. <p> Recall that in the Ball-Larus technique, there is some flexibility in the placement of increment statements; this is used to push the increment statements to infrequently executed edges <ref> [5] </ref>.
Reference: [6] <author> T. Ball and J. Larus. </author> <title> Efficient path profiling. </title> <booktitle> In MICRO 1996, </booktitle> <year> 1996. </year>
Reference-contexts: A path profile for a given run of a program consists of a count of how often each observable path was executed. This paper extends the intraprocedural path-profiling technique of Ball and Larus <ref> [6] </ref> to collect information about inter procedural paths (i.e., paths that may cross procedure boundaries). Interprocedural path profiling is complicated by the need to account for a procedure's calling context. <p> Several additional techniques are employed to reduce the runtime overheads incurred. These exploit the fact that there is actually a certain amount of flexibility in the placement of the increment statements <ref> [5, 6] </ref>. 2.2 Supergraph As in many interprocedural program-analysis problems, we work with an interprocedural control-flow graph called a supergraph.
Reference: [7] <author> Thomas Ball, Peter Mataga, and Mooly Sagiv. </author> <title> Edge profiling versus path profiling: The showdown. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <address> New York, NY, </address> <month> January </month> <year> 1998. </year> <note> ACM Press. </note>
Reference-contexts: Note that an oddball path is likely to be an infrequently-executed (i.e., cold) path, and thus cannot be found by techniques that are used to estimate hot paths from edge profiles <ref> [7] </ref>. Profiling could be used to allow a debugger to report the last path (or last several paths) executed before a breakpoint or program crash. This would provide a nice complement to other information provided by the debugger, such as the current call stack.
Reference: [8] <author> D. Callahan. </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 47-56, </pages> <address> New York, NY, 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: a same-level valid path if and only if the string formed by concatenating the labels of p's edges is derived from the non-terminal SLVP in the following context-free grammar: 2 This is similar to the assumptions that are made in much of the work on context-sensitive interprocedural dataflow analysis, e.g., <ref> [17, 8, 11, 10, 15] </ref>. SLVP ::= ( i SLVP ) i SLVP for 1 i NumCallSites SLVP ::= ( P SLVP ) P SLVP for each procedure P SLVP ::= e SLVP SLVP ::= * Here, * denotes the empty string.
Reference: [9] <author> G.A. Kildall. </author> <title> A unified approach to global program optimization. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 194-206, </pages> <address> New York, NY, 1973. </address> <publisher> ACM Press. </publisher> <pages> 49 </pages>
Reference-contexts: Each edge v ! w of the graph is labeled with a function f v!w 2 F . Kildall showed that the meet-over-all-paths solution to a distributive, backwards dataflow-analysis problem is given by the maximal fixed point of the following equations <ref> [9] </ref>: val [v] = u f v!w (val [w]) for v 6=Exit w2succ (v) (12) val [Exit ] = c (13) For a DAG, finding the quantity numPaths [v] amounts to a technique for summing over all paths between v and Exit , where each path contributes a value of one
Reference: [10] <author> J. Knoop and B. Steffen. </author> <title> The interprocedural coincidence theorem. </title> <booktitle> In International Conference on Compiler Construction, </booktitle> <pages> pages 125-140, </pages> <year> 1992. </year>
Reference-contexts: a same-level valid path if and only if the string formed by concatenating the labels of p's edges is derived from the non-terminal SLVP in the following context-free grammar: 2 This is similar to the assumptions that are made in much of the work on context-sensitive interprocedural dataflow analysis, e.g., <ref> [17, 8, 11, 10, 15] </ref>. SLVP ::= ( i SLVP ) i SLVP for 1 i NumCallSites SLVP ::= ( P SLVP ) P SLVP for each procedure P SLVP ::= e SLVP SLVP ::= * Here, * denotes the empty string.
Reference: [11] <author> W. Landi and B.G. Ryder. </author> <title> Pointer induced aliasing: A problem classification. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <address> New York, NY, </address> <month> January </month> <year> 1991. </year> <note> ACM Press. </note>
Reference-contexts: a same-level valid path if and only if the string formed by concatenating the labels of p's edges is derived from the non-terminal SLVP in the following context-free grammar: 2 This is similar to the assumptions that are made in much of the work on context-sensitive interprocedural dataflow analysis, e.g., <ref> [17, 8, 11, 10, 15] </ref>. SLVP ::= ( i SLVP ) i SLVP for 1 i NumCallSites SLVP ::= ( P SLVP ) P SLVP for each procedure P SLVP ::= e SLVP SLVP ::= * Here, * denotes the empty string.
Reference: [12] <author> R. Muth and S. Debray. </author> <title> Partial inlining. </title> <type> (Unpublished technical summary). </type>
Reference-contexts: The profiling techniques presented in this paper have a number of applications: * There are several possible applications in program optimization, in conjunction with the partial-inlining technique of Muth and Debray <ref> [12] </ref>. This allows inlining of only a selected path or paths of a procedure P at a call site on P ; residual procedures are generated to handle the cases when the infrequently executed pieces of P are needed at the expanded call site.
Reference: [13] <author> G. Ramalingam. </author> <title> Bounded Incremental Computation. </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: For a more general discussion of the relationship between algebraic path problems and dataflow-analysis problems, see <ref> [13] </ref>.) We now review the appropriate part of Sharir and Pnueli's work [17], with some rephrasing of their work to describe backwards dataflow-analysis problems instead of forwards dataflow-analysis problems. We then show how their functions are related to our functions.
Reference: [14] <author> T. Reps, T. Ball, M. Das, and J. Larus. </author> <title> The use of program profiling for software maintenance with applications to the year 2000 problem. </title> <editor> In M. Jazayeri and H. Schauer, editors, </editor> <booktitle> Proc. of ESEC/FSE '97: Sixth European Softw. Eng. Conf. and Fifth ACM SIGSOFT Symp. on the Found. of Softw. Eng., volume 1301 of Lecture Notes in Computer Science, </booktitle> <pages> pages 432-449. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Information ascertained from interprocedural path profiling could be used to drive partial inlining, either for interprocedural trace scheduling or for an interprocedural extension of the work of Ammons et al. on path-qualified dataflow analysis [3]. * There are also several applications in software maintenance: 2 Reps et al. <ref> [14] </ref> showed that when different runs of a program produce different path profiles, the differences in the path profiles can be used to identify paths in the program along which control diverges in the two runs.
Reference: [15] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reachability. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <address> New York, NY, </address> <year> 1995. </year> <note> ACM Press. Available at "http://www.cs.wisc.edu/wpis/papers/popl95.ps". </note>
Reference-contexts: a same-level valid path if and only if the string formed by concatenating the labels of p's edges is derived from the non-terminal SLVP in the following context-free grammar: 2 This is similar to the assumptions that are made in much of the work on context-sensitive interprocedural dataflow analysis, e.g., <ref> [17, 8, 11, 10, 15] </ref>. SLVP ::= ( i SLVP ) i SLVP for 1 i NumCallSites SLVP ::= ( P SLVP ) P SLVP for each procedure P SLVP ::= e SLVP SLVP ::= * Here, * denotes the empty string.
Reference: [16] <author> M. Shapiro and S. Horwitz. </author> <title> Fast and accurate flow-insensitive points-to analysis. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <year> 1997. </year>
Reference-contexts: Another possibility is to turn each indirect procedure call through a procedure variable fp into an if-then-else chain that has a separate (direct) procedure call for each possible value of fp. Well-known techniques (e.g., such as flow insensitive points-to analysis <ref> [4, 18, 16] </ref>) can be used to obtain a reasonable (but still conservative) estimate of the values that fp may take on. A Proof of Theorem 4.1 Before restating Theorem 4.1, we review some definitions. Let the graph G and the context-free grammar CF be a context-free DAG.
Reference: [17] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 7, </volume> <pages> pages 189-234. </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: This involves labeling edges with functions instead of values. (A key step in the process of creating the proper edge functions has an interesting connection to a method proposed by Sharir and Pnueli <ref> [17] </ref> for solving context-sensitive interprocedural dataflow-analysis problems.) * Some of the machinery that we develop to handle the calling-context problem for purposes of inter procedural path profiling suggests other variants of both intraprocedural and interprocedural path profiling, as well as a variety of hybrid intra-/interprocedural schemes. <p> a same-level valid path if and only if the string formed by concatenating the labels of p's edges is derived from the non-terminal SLVP in the following context-free grammar: 2 This is similar to the assumptions that are made in much of the work on context-sensitive interprocedural dataflow analysis, e.g., <ref> [17, 8, 11, 10, 15] </ref>. SLVP ::= ( i SLVP ) i SLVP for 1 i NumCallSites SLVP ::= ( P SLVP ) P SLVP for each procedure P SLVP ::= e SLVP SLVP ::= * Here, * denotes the empty string. <p> Similarly, each edge e of each procedure P is assigned a linear function e that, when given a value for numPaths [Exit P ], returns the Ball-Larus value for e. The functions are similar to the functions of Sharir and Pnueli's functional approach to interproce-dural dataflow analysis <ref> [17] </ref>. In their work, the function v summarizes how dataflow facts at a vertex v are related to the dataflow facts at the entry vertex Entry P . <p> We then show that our scheme for assigning functions to vertices is similar to Sharir and Pnueli's functional approach to interprocedural dataflow analysis <ref> [17] </ref>. A distributive, backwards dataflow-analysis problem includes a semi-lattice L with meet operator u, a set F of distributive functions from L to L, a graph G, and a dataflow fact c associated with the exit vertex Exit of G. <p> For a more general discussion of the relationship between algebraic path problems and dataflow-analysis problems, see [13].) We now review the appropriate part of Sharir and Pnueli's work <ref> [17] </ref>, with some rephrasing of their work to describe backwards dataflow-analysis problems instead of forwards dataflow-analysis problems. We then show how their functions are related to our functions. <p> For an exit vertex Exit P , P is the identity function: 5 Exit P = id : (16) 4 Information flows counter to the direction of control-flow graph edges in a backwards dataflow-analysis problem. 5 According to <ref> [17] </ref>, this equation should be Exit P v id. <p> Equation (20) does not have a direct analog in <ref> [17] </ref>, however, GExit P could be thought of as a vertex that generates a constant dataflow fact.
Reference: [18] <author> B. Steensgaard. </author> <title> Points-to analysis in almost-linear time. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <year> 1996. </year> <month> 50 </month>
Reference-contexts: Another possibility is to turn each indirect procedure call through a procedure variable fp into an if-then-else chain that has a separate (direct) procedure call for each possible value of fp. Well-known techniques (e.g., such as flow insensitive points-to analysis <ref> [4, 18, 16] </ref>) can be used to obtain a reasonable (but still conservative) estimate of the values that fp may take on. A Proof of Theorem 4.1 Before restating Theorem 4.1, we review some definitions. Let the graph G and the context-free grammar CF be a context-free DAG.
References-found: 18

