URL: http://www.eecs.umich.edu/mistic/papers/mhasan/Paper1.ps
Refering-URL: http://www.eecs.umich.edu/mistic/publications.html
Root-URL: http://www.cs.umich.edu
Email: carlosm@eecs.umich.edu  
Title: Process Compilation of Thin Film Microdevices  
Author: M. Hasanuzzaman and C. H. Mastrangelo 
Address: Ann Arbor, MI 48109-2122, USA (313)-763-7162, FAX:(313)-747-1781,  
Affiliation: Center for Integrated Sensors and Circuits Department of Electrical Engineering and Computer Science University of Michigan,  
Abstract: 1 This paper describes a systematic method for the automatic generation of fabrication processes of thin film devices. The method uses a partially ordered set (poset) representation of device topology describing the order between its various components in the form of a directed acyclic graph. The sequence in which these components are fabricated is determined from the poset linear extensions, and the component sequence is expanded into a corresponding process flow. The graph-theoretic synthesis method is powerful enough to establish existence and multiplicity of flows thus creating a design space D suitable for optimization. The cardi-nality kDk for a device with N components is large with a worst case kDk (N 1)! yielding in general a combinatorial explosion of solutions. The number of solutions is controlled through a-priori estimates of kDk and condensation of the device graph. The method has been implemented in the computer program MISTIC (Michigan Synthesis Tools for Integrated Circuits) which calculates specific process parameters using an internal database of process modules and materials. Currently MISTIC includes process modules for deposition, lithography, etching, ion implantation, coupled simultaneous diffusions, and reactive growth. The compilation procedure was applied to several device structures. For a double metal twin-well BiCMOS structure, the compiler generated 168 complete process flows. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. M. Sze, </author> <title> VLSI Technology. </title> <address> New York: </address> <publisher> McGraw-Hill, </publisher> <year> 1988. </year>
Reference-contexts: Ever since this design methodology was established, increasingly more sophisticated simulation tools have been developed. Current state-of-the-art simulation tools such as SUPREM <ref> [1] </ref>, SIMPL [2], and MEMCAD [3] take a description of the fabrication process flow as input and generate accurate two- and three-dimensional representation of thin-film devices. <p> by a temperature cycle at temperature T n and t n duration is h (u n+1 ; u n ; T n ) = n+1 u 2 B (T n ) (u n+1 u n ) = t n where B and B=A are the quadratic and linear rate constants <ref> [1] </ref>. For other type of reactions, Eq. (40) has the general form u n+1 = f (u n ; T n ; t n ) (41) Therefore interacting reactive growth steps are solved simultaneously to achieve all the desired thicknesses at the process end. <p> The gaussian straggle is the cumulative Dt product of all successive steps (fi T ) i = ji and D i (T j ) is the diffusion coefficient for the i th diffused layer <ref> [1] </ref> D i (T j ) (D i ) 0 e kT j (49) where we have assumed a simple Ahrrenius form for D. The buildup of (fi T ) i occurs in small increments distributed throughout the process as in Eq. (48).
Reference: [2] <author> K. Lee, </author> <title> SIMPL-2 simulated profiles from the layout version 2. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <year> 1985. </year>
Reference-contexts: Ever since this design methodology was established, increasingly more sophisticated simulation tools have been developed. Current state-of-the-art simulation tools such as SUPREM [1], SIMPL <ref> [2] </ref>, and MEMCAD [3] take a description of the fabrication process flow as input and generate accurate two- and three-dimensional representation of thin-film devices.
Reference: [3] <author> S. D. Senturia, R. M. Harris, and et. al, </author> <title> "A computer-aided design system for microelectrome-chanical systems (MEMCAD)," </title> <journal> IEEE J. Micro-electromechanical Syst., </journal> <volume> vol. 1, </volume> <pages> pp. 3-13, </pages> <year> 1992. </year>
Reference-contexts: Ever since this design methodology was established, increasingly more sophisticated simulation tools have been developed. Current state-of-the-art simulation tools such as SUPREM [1], SIMPL [2], and MEMCAD <ref> [3] </ref> take a description of the fabrication process flow as input and generate accurate two- and three-dimensional representation of thin-film devices. While process simulators are essential for rapid device development, these tools are used for design verification and, in general, do not provide matching to desired device specifications.
Reference: [4] <author> J. S. Wenstrand, H. Iwai, and R. W. Dutton, </author> <title> "A manufacturing oriented environment for synthesis of fabrication processes," </title> <booktitle> in ICCAD-89, IEEE International Conference on CAD, </booktitle> <pages> pp. 276-379, </pages> <year> 1989. </year>
Reference-contexts: Typically, a satisfactory design is arrived after many iterations and weeks of intensive simulation. The iterative nature of the simulation-based design methodology represents an increasing burden on designers as process complexity grows <ref> [4, 5] </ref>. For example, complex processes such as BiCMOS require 200-700 steps with a correspondingly large number of interactions which must be considered when making any changes. These changes in term depend on the process modules and laboratory resources available. <p> The output of the flow generator is a flow with all the instructions necessary to fabricate the sample. The parameters of the flow are next determined. The parameter calculator interacts with six other submodules performing many of the functions outlined in <ref> [4] </ref>. First specific etchants are selected for all etching steps. The device outline and the list of materials which are exposed during and after each etch is calculated.
Reference: [5] <author> C.-Y. Fu, N. H. Chang, and K.-K. Lin, </author> <title> "Smart integrated circuit processing," </title> <journal> IEEE Trans. Semic. Manuf., </journal> <volume> vol. 2, </volume> <pages> pp. 151-158, </pages> <year> 1989. </year>
Reference-contexts: Typically, a satisfactory design is arrived after many iterations and weeks of intensive simulation. The iterative nature of the simulation-based design methodology represents an increasing burden on designers as process complexity grows <ref> [4, 5] </ref>. For example, complex processes such as BiCMOS require 200-700 steps with a correspondingly large number of interactions which must be considered when making any changes. These changes in term depend on the process modules and laboratory resources available.
Reference: [6] <author> D. S. Boning, M. B. McIlrath, P. Penfield, and E. M. Sachs, </author> <title> "A general semiconductor process modeling framework," </title> <journal> IEEE Trans. Semic. Manuf., </journal> <volume> vol. 5, </volume> <pages> pp. 266-280, </pages> <year> 1992. </year> <pages> Page 19 </pages>
Reference-contexts: This state abstraction is commonly used in process modeling frameworks <ref> [6] </ref>. We shall soon demonstrate that n is related to device complexity and the number of layers. For example, the fabrication process shown in Figure 1 consists of 12 operations performed in sequence with 11 intermediate states.
Reference: [7] <author> F. Harary, R. Z. Norman, and D. Cartwright, </author> <title> Structural Models: An Introduction to the Theory of Directed Graphs. </title> <address> New York: </address> <publisher> Wiley, </publisher> <year> 1965. </year>
Reference-contexts: A receiver vertex is one that has outdegree zero and in-degree &gt; 0, and a sink is a vertex which can be reached order. by all of the rest. The device graph is rooted <ref> [7] </ref> since every element is in term connected to the source vertex representing the common substrate. The graph receiver vertices correspond to the device topmost components. Receiver vertices are in terms connected to a unique vacuum level sink c 1 which is usually omitted. <p> The approximate kDk is then [34] kDk (N=2 + 1) This bound is suitable for M small. The maximum M occurs when T is a total order isomorphic to an upper triangular matrix of ones <ref> [7] </ref> with M = N 2 =2. For large M , a less expensive upper estimate of kDk is found by relaxing some of the order constraints as follows. From the transitive closure matrix T a position restrictor matrix R can be defined.
Reference: [8] <author> G. D. Battista and R. Tamassia, </author> <title> "Algorithms for plane representations of acyclic digraphs," </title> <journal> Theor. Comp. Sci., </journal> <volume> vol. 61, </volume> <pages> pp. 175-198, </pages> <year> 1988. </year>
Reference-contexts: Receiver vertices are in terms connected to a unique vacuum level sink c 1 which is usually omitted. In general, the device graph has no loops therefore is acyclic. Acyclic digraphs with a single root and sink are known as st-graphs <ref> [8] </ref> and play a central role in VLSI routing problems [9, 10].
Reference: [9] <author> R. Tamassia and J. Vitter, </author> <title> "Parallel transitive closure and point location in planar structures," </title> <journal> Siam J. Comput., </journal> <volume> vol. 20, </volume> <pages> pp. 708-725, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: In general, the device graph has no loops therefore is acyclic. Acyclic digraphs with a single root and sink are known as st-graphs [8] and play a central role in VLSI routing problems <ref> [9, 10] </ref>. While components c i are organized in a plane, in general, the device graph is not planar if diffused layers are present because, in general, no order may be established between diffusions which share the same physical space without prior knowledge of diffusion conditions. <p> These sorting algorithms are based on (a) sequential generation of permutations [50, 21, 51, 52, 53, 54], (b) finding directed paths in acyclic graphs [55, 56, 57], and (c) triangulation of its adjacency matrix [58]. Efficient parallel computation algorithms <ref> [59, 9, 60, 61] </ref> have also been developed. Since most device graphs contain a large number of vertices, it is neccessary to use an algorithm which does not generate any redundant information. We have adopted a modification of a sequential algorithm due to Steiner [54].
Reference: [10] <author> P. Rosenstiehl and R. E. Tarjan, </author> <title> "Rectilinear planar layouts and bipolar orientations of planar graphs," </title> <journal> Discrete Comp. Geom., </journal> <volume> vol. 1, </volume> <pages> pp. 343-353, </pages> <year> 1986. </year>
Reference-contexts: In general, the device graph has no loops therefore is acyclic. Acyclic digraphs with a single root and sink are known as st-graphs [8] and play a central role in VLSI routing problems <ref> [9, 10] </ref>. While components c i are organized in a plane, in general, the device graph is not planar if diffused layers are present because, in general, no order may be established between diffusions which share the same physical space without prior knowledge of diffusion conditions.
Reference: [11] <author> B. Dushnik and E. W. Miller, </author> <title> "Partially ordered sets," </title> <journal> Am. J. Math., </journal> <volume> vol. 63, </volume> <pages> pp. 600-610, </pages> <year> 1941. </year>
Reference-contexts: At this point we shall impose the additional restriction that the device digraph has no cycles. This is not a severe restriction since any nvertex digraph with cycles can be expanded into an (n + 1)vertex acyclic digraph. Acyclic directed graphs are representations of partially ordered sets or posets <ref> [11, 12, 13, 14, 15, 16] </ref>. A poset is a combinatorial object consisting of a set of elements and a partial order between them. In the acyclic digraph, the arcs represent a partial order between the device components. The poset is compactly stored in the digraph adjacency matrix A (d).
Reference: [12] <author> P. C. Fishburn, </author> <title> Interval Orders and Interval Graphs. </title> <address> New York: </address> <publisher> Wiley, </publisher> <year> 1985. </year>
Reference-contexts: At this point we shall impose the additional restriction that the device digraph has no cycles. This is not a severe restriction since any nvertex digraph with cycles can be expanded into an (n + 1)vertex acyclic digraph. Acyclic directed graphs are representations of partially ordered sets or posets <ref> [11, 12, 13, 14, 15, 16] </ref>. A poset is a combinatorial object consisting of a set of elements and a partial order between them. In the acyclic digraph, the arcs represent a partial order between the device components. The poset is compactly stored in the digraph adjacency matrix A (d).
Reference: [13] <author> L. </author> <title> Budach, Algebraic and Topological Properties of Finite Partially Ordered Sets. Leipzig: </title> <publisher> Teubner, </publisher> <year> 1988. </year>
Reference-contexts: At this point we shall impose the additional restriction that the device digraph has no cycles. This is not a severe restriction since any nvertex digraph with cycles can be expanded into an (n + 1)vertex acyclic digraph. Acyclic directed graphs are representations of partially ordered sets or posets <ref> [11, 12, 13, 14, 15, 16] </ref>. A poset is a combinatorial object consisting of a set of elements and a partial order between them. In the acyclic digraph, the arcs represent a partial order between the device components. The poset is compactly stored in the digraph adjacency matrix A (d).
Reference: [14] <author> I. </author> <title> Rival, Ordered Sets. </title> <address> Boston: </address> <publisher> Kluwer, </publisher> <year> 1981. </year>
Reference-contexts: At this point we shall impose the additional restriction that the device digraph has no cycles. This is not a severe restriction since any nvertex digraph with cycles can be expanded into an (n + 1)vertex acyclic digraph. Acyclic directed graphs are representations of partially ordered sets or posets <ref> [11, 12, 13, 14, 15, 16] </ref>. A poset is a combinatorial object consisting of a set of elements and a partial order between them. In the acyclic digraph, the arcs represent a partial order between the device components. The poset is compactly stored in the digraph adjacency matrix A (d).
Reference: [15] <author> I. </author> <title> Rival, Algorithms and Order. </title> <publisher> Dordrecht: Kluwer, </publisher> <year> 1989. </year>
Reference-contexts: At this point we shall impose the additional restriction that the device digraph has no cycles. This is not a severe restriction since any nvertex digraph with cycles can be expanded into an (n + 1)vertex acyclic digraph. Acyclic directed graphs are representations of partially ordered sets or posets <ref> [11, 12, 13, 14, 15, 16] </ref>. A poset is a combinatorial object consisting of a set of elements and a partial order between them. In the acyclic digraph, the arcs represent a partial order between the device components. The poset is compactly stored in the digraph adjacency matrix A (d).
Reference: [16] <author> W. T. Trotter, </author> <title> Combinatorics and Partially Ordered Sets. </title> <publisher> Baltimore: Johns Hopkins University Press, </publisher> <year> 1992. </year>
Reference-contexts: At this point we shall impose the additional restriction that the device digraph has no cycles. This is not a severe restriction since any nvertex digraph with cycles can be expanded into an (n + 1)vertex acyclic digraph. Acyclic directed graphs are representations of partially ordered sets or posets <ref> [11, 12, 13, 14, 15, 16] </ref>. A poset is a combinatorial object consisting of a set of elements and a partial order between them. In the acyclic digraph, the arcs represent a partial order between the device components. The poset is compactly stored in the digraph adjacency matrix A (d).
Reference: [17] <author> R. A. Brualdy and H. J. Ryser, </author> <title> Combinatorial Matrix Theory. </title> <address> New York: </address> <publisher> Cambridge Univ. Press, </publisher> <year> 1991. </year>
Reference-contexts: Boolean matrices <ref> [17] </ref> are manipulated in much the same way as real matrices using Boolean AND, OR, and NOT operations, and they hold a number of useful properties [18, 19]. The Hadamard element product C = A fi B (7) is defined such that c i;j = a i;j b i;j .
Reference: [18] <author> K. H. Kim, </author> <title> Boolean Matrix Theory and Applications. </title> <address> New York: </address> <publisher> M. Dekker, </publisher> <year> 1982. </year>
Reference-contexts: Boolean matrices [17] are manipulated in much the same way as real matrices using Boolean AND, OR, and NOT operations, and they hold a number of useful properties <ref> [18, 19] </ref>. The Hadamard element product C = A fi B (7) is defined such that c i;j = a i;j b i;j . Boolean matrices are idempotent under the Hadamard product since A fi A = A. <p> In general, the number of devices (or topologies) that can be fabricated with n layers of m different ma terials is approximately ( 2=n) m n 2 (n+1) 2 =4+n (28) Equation (28) is a modification of the formula obtained in <ref> [18, 42, 43, 44, 45, 46, 47] </ref> for unlabeled graphs. This number is very large but finite. Another interesting property of posets that may prove useful in VLSI technology is their ability to be stored as polynomials [48, 49].
Reference: [19] <author> R. A. Brualdy and H. J. Ryser, </author> <title> A Survey of Finite Mathematics. </title> <address> New York: </address> <publisher> Cambridge Univ. Press, </publisher> <year> 1991. </year>
Reference-contexts: Boolean matrices [17] are manipulated in much the same way as real matrices using Boolean AND, OR, and NOT operations, and they hold a number of useful properties <ref> [18, 19] </ref>. The Hadamard element product C = A fi B (7) is defined such that c i;j = a i;j b i;j . Boolean matrices are idempotent under the Hadamard product since A fi A = A. <p> Therefore each N -rook configuration is a singular dis tinct representative (S.D.R) of matrix R [36]. The number of S.D.R's and r N (R) in a Boolean matrix kS:D:Rk = r N (R) = per (R) (23) is equal to the permanent, per (R), of matrix R <ref> [37, 19, 38] </ref>. The permanent is a scalar quantity that often appears in many enumeration and combinatorial problems. For square matrices, the permanent is calculated as a `plus-only' determinant [39]. The evaluation of per (R) requires in general N ! steps. Fortunately there exists an upper bound for per ().
Reference: [20] <author> A. Kaufmann, </author> <title> Graphs, Dynamic Programming, and Finite Games. </title> <address> New York: </address> <publisher> Academic Press, </publisher> <year> 1967. </year>
Reference-contexts: The Hadamard element product C = A fi B (7) is defined such that c i;j = a i;j b i;j . Boolean matrices are idempotent under the Hadamard product since A fi A = A. Hadamard products are useful to compare two device graphs <ref> [20] </ref> hence determine their process compatibility. The specific form of A is dependent on the component and vertex labeling. Thus the device matrix A is not unique since the component labeling is arbitrary. Two distinct matrices A and A 0 which represent the same device structure are isomorphic.
Reference: [21] <author> D. E. Knuth and J. L. Szwarcfiter, </author> <title> "A structured program to generate all topological sorting arrangements," </title> <journal> Information Processing Letters, </journal> <volume> vol. 2, </volume> <pages> pp. 153-157, </pages> <year> 1974. </year>
Reference-contexts: The component sequence S ( and flow F ) is found by "stretching" the two-dimensional device graph into a linear chain or linear extension. Figure 5 shows a few linear extensions for the graph of Figure 4. This proce dure is known as topological sorting <ref> [21] </ref> and has many applications in computer science. The existence of F is thus assured by the existence of a linear extension in the device graph. Page 4 Theorem 1 (Fundamental) Let d be a device of c i components with order O represented by an acyclic directed graph. <p> PROCESS FLOW CONSTRUCTION The first step in the construction of flow F consists of finding linear extensions of the condensed device graph. For finite graphs, the topological sort of its vertices can be performed in several ways. These sorting algorithms are based on (a) sequential generation of permutations <ref> [50, 21, 51, 52, 53, 54] </ref>, (b) finding directed paths in acyclic graphs [55, 56, 57], and (c) triangulation of its adjacency matrix [58]. Efficient parallel computation algorithms [59, 9, 60, 61] have also been developed.
Reference: [22] <author> E. Szpilrajn, "Sur l'extension de l'ordre partiel," </author> <title> Fund. </title> <journal> Math, </journal> <volume> vol. 60, </volume> <pages> pp. 175-186, </pages> <year> 1930. </year>
Reference-contexts: Proof: Under the conditions stated above, the existence of a process flow is essentially assured by that of the linear extension of the digraph poset. The existence of linear extensions was established by a well known theorem of Szpilrajn <ref> [22] </ref>. The fundamental theorem assures the existence of F in the topological sense. It does not assure the existence of selective . We shall show later that good approximations for can be reached.
Reference: [23] <author> N. Linial, </author> <title> "Hard enumeration problems in geometry and combinatorics," </title> <journal> SIAM. J. Alg. Disc. Meth., </journal> <volume> vol. 7, </volume> <pages> pp. 331-335, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: This quantity is used to introduce reduction techniques and additional constraints if kDk is too large before the sequencing of the components is attempted. A suitable measure of kDk is the number of linear extensions. The enumeration and generation of linear extensions has been studied extensively <ref> [23, 24, 25, 26, 27, 28] </ref>. For the general case, the generation all linear extensions is an NP-complete problem [29]. <p> A suitable measure of kDk is the number of linear extensions. The enumeration and generation of linear extensions has been studied extensively [23, 24, 25, 26, 27, 28]. For the general case, the generation all linear extensions is an NP-complete problem [29]. It is well known <ref> [23] </ref> that the the number of linear extensions for a graph with N vertices is n = kDk = N ! vol (B (T )) (15) where B (T ) is an N -dimensional convex polytope imbedded within the unit hypercube, and vol () is the polytope volume.
Reference: [24] <author> S. G. Mohanty, </author> <title> Lattice Path Countings and Applications. </title> <address> New York: </address> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: This quantity is used to introduce reduction techniques and additional constraints if kDk is too large before the sequencing of the components is attempted. A suitable measure of kDk is the number of linear extensions. The enumeration and generation of linear extensions has been studied extensively <ref> [23, 24, 25, 26, 27, 28] </ref>. For the general case, the generation all linear extensions is an NP-complete problem [29].
Reference: [25] <author> I. </author> <title> Rival, "Linear extensions of finite ordered sets," </title> <journal> Annals of Discrete Mathematics, </journal> <volume> vol. 23, </volume> <pages> pp. 355-370, </pages> <year> 1984. </year>
Reference-contexts: This quantity is used to introduce reduction techniques and additional constraints if kDk is too large before the sequencing of the components is attempted. A suitable measure of kDk is the number of linear extensions. The enumeration and generation of linear extensions has been studied extensively <ref> [23, 24, 25, 26, 27, 28] </ref>. For the general case, the generation all linear extensions is an NP-complete problem [29].
Reference: [26] <author> G. R. Brightwell, </author> <title> "Linear extensions of infinite posets," </title> <journal> Discrete Mathematics, </journal> <volume> vol. 70, </volume> <pages> pp. 113-136, </pages> <year> 1988. </year>
Reference-contexts: This quantity is used to introduce reduction techniques and additional constraints if kDk is too large before the sequencing of the components is attempted. A suitable measure of kDk is the number of linear extensions. The enumeration and generation of linear extensions has been studied extensively <ref> [23, 24, 25, 26, 27, 28] </ref>. For the general case, the generation all linear extensions is an NP-complete problem [29].
Reference: [27] <author> M. Pouzet and I. </author> <title> Rival, "Which ordered sets have a complete linear extension?," Can. </title> <journal> J. Math., </journal> <volume> vol. </volume> <pages> XXXIII, pp. 1245-1254, </pages> <year> 1981. </year>
Reference-contexts: This quantity is used to introduce reduction techniques and additional constraints if kDk is too large before the sequencing of the components is attempted. A suitable measure of kDk is the number of linear extensions. The enumeration and generation of linear extensions has been studied extensively <ref> [23, 24, 25, 26, 27, 28] </ref>. For the general case, the generation all linear extensions is an NP-complete problem [29].
Reference: [28] <author> V. Bouchitte and M. Habib, </author> <title> "NP-completeness properties about linear extensions," </title> <booktitle> Order, </booktitle> <volume> vol. 4, </volume> <pages> pp. 143-154, </pages> <year> 1987. </year>
Reference-contexts: This quantity is used to introduce reduction techniques and additional constraints if kDk is too large before the sequencing of the components is attempted. A suitable measure of kDk is the number of linear extensions. The enumeration and generation of linear extensions has been studied extensively <ref> [23, 24, 25, 26, 27, 28] </ref>. For the general case, the generation all linear extensions is an NP-complete problem [29]. <p> The polytope faces are hyperplanes defined by M constraints of T (ie. the number of ones in T ), and 2N constraints from the hypercube faces. It has been shown that computing this volume is an NP-complete <ref> [28, 29] </ref> process. Therefore counting the linear extensions exactly [30] is computationally equivalent to finding D through topological sorting. The volume however can be determined approximately at much smaller expense by several methods. The most common is the Monte Carlo technique [31, 32].
Reference: [29] <author> G. R. Brightwell and P. Winkler, </author> <title> "Counting linear extensions is NP-complete," </title> <booktitle> in Proceedings of the Twenty Third Annual ACM Symposium, Theory of Computing, </booktitle> <pages> pp. 175-181, </pages> <year> 1991. </year>
Reference-contexts: A suitable measure of kDk is the number of linear extensions. The enumeration and generation of linear extensions has been studied extensively [23, 24, 25, 26, 27, 28]. For the general case, the generation all linear extensions is an NP-complete problem <ref> [29] </ref>. <p> The polytope faces are hyperplanes defined by M constraints of T (ie. the number of ones in T ), and 2N constraints from the hypercube faces. It has been shown that computing this volume is an NP-complete <ref> [28, 29] </ref> process. Therefore counting the linear extensions exactly [30] is computationally equivalent to finding D through topological sorting. The volume however can be determined approximately at much smaller expense by several methods. The most common is the Monte Carlo technique [31, 32].
Reference: [30] <author> M. D. Atkinson and H. W. Chang, </author> <title> "Computing the number of mergings with constraints," </title> <journal> Information Processing Letters, </journal> <volume> vol. 24, </volume> <pages> pp. 289-292, </pages> <year> 1987. </year>
Reference-contexts: The polytope faces are hyperplanes defined by M constraints of T (ie. the number of ones in T ), and 2N constraints from the hypercube faces. It has been shown that computing this volume is an NP-complete [28, 29] process. Therefore counting the linear extensions exactly <ref> [30] </ref> is computationally equivalent to finding D through topological sorting. The volume however can be determined approximately at much smaller expense by several methods. The most common is the Monte Carlo technique [31, 32]. <p> Therefore different gaps for the same layer can be etched at different times. This is in fact required for a large number of device processes. Since the deposition operator order is fixed by the layer order, this procedure is equivalent to merging of two ordered sets <ref> [30] </ref>. The insertion of g i;k in F takes place according to the matrix order. The procedure uses the same topological sorting but now with the additional constraint that each g i;k must operate on the corresponding layer.
Reference: [31] <author> M. Dyer, A. Frieze, and R. Kannan, </author> <title> "A random polynomial time algorithm for approximating the volume of convex bodies," </title> <booktitle> in Proceedings of the Twenty First Annual ACM Symposium, Theory of Computing, </booktitle> <pages> pp. 375-381, </pages> <year> 1989. </year>
Reference-contexts: Therefore counting the linear extensions exactly [30] is computationally equivalent to finding D through topological sorting. The volume however can be determined approximately at much smaller expense by several methods. The most common is the Monte Carlo technique <ref> [31, 32] </ref>. In graphs with a large number of nodes the volume of the polytope can be quite small; hence Monte Carlo techniques are computationally ineffective due to the high accuracy requirement at the lower range in vol ().
Reference: [32] <author> D. Applegate and R. Kannan, </author> <title> "Sampling and integration of near log-concave functions," </title> <booktitle> in Proceedings of the Twenty Third Annual ACM Symposium, Theory of Computing, </booktitle> <pages> pp. 156-163, </pages> <year> 1991. </year>
Reference-contexts: Therefore counting the linear extensions exactly [30] is computationally equivalent to finding D through topological sorting. The volume however can be determined approximately at much smaller expense by several methods. The most common is the Monte Carlo technique <ref> [31, 32] </ref>. In graphs with a large number of nodes the volume of the polytope can be quite small; hence Monte Carlo techniques are computationally ineffective due to the high accuracy requirement at the lower range in vol ().
Reference: [33] <author> S. W. Director and G. D.Hatchel, </author> <title> "The simpli-cial approximation approach to design centering," </title> <journal> IEEE Trans. Cir. Syst., </journal> <volume> vol. CAS-24, </volume> <pages> pp. 363-372, </pages> <year> 1977. </year>
Reference-contexts: A computationally efficient lower bound for vol () is found approximating the polytope volume by that of the largest hypersphere that will fit inside it <ref> [33] </ref>. Each of the M + 2N bounding hyperplanes has the form v T where v k is a unit vector pointing outward to hyper-plane k, and b k is a measure of the unit distance from the origin.
Reference: [34] <author> H. S. M. Coxeter, </author> <title> Regular Polytopes. </title> <address> New York: </address> <publisher> Dover, </publisher> <year> 1973. </year>
Reference-contexts: The approximate kDk is then <ref> [34] </ref> kDk (N=2 + 1) This bound is suitable for M small. The maximum M occurs when T is a total order isomorphic to an upper triangular matrix of ones [7] with M = N 2 =2.
Reference: [35] <author> V. Bryant, </author> <title> Aspects of Combinatorics. </title> <address> New York: </address> <publisher> Cambridge Univ. Press, </publisher> <year> 1993. </year>
Reference-contexts: q fl q 3 7 2 6 q q fl fl fl q 3 7 2 6 q q fl fl q fl 3 7 (21) The enumeration of these configurations is a classical problem in combinatorics quantified by the N th coefficient of the rook polynomial r N (R) <ref> [35] </ref>. Thus kDk r N (R) (22) Since components are more constrained in T than in R, then r N is an upper bound for kDk. The position restrictor matrix has an additional combinatorial interpretation. Components c i belong to the device set d.
Reference: [36] <author> M. Marcus, </author> <title> A Survey of Finite Mathematics. </title> <address> New York: </address> <publisher> Dover, </publisher> <year> 1993. </year>
Reference-contexts: Each configuration in R is a set of distinct fc ff ; :::; c fi g where each c i belongs to a particular group (column). Therefore each N -rook configuration is a singular dis tinct representative (S.D.R) of matrix R <ref> [36] </ref>. The number of S.D.R's and r N (R) in a Boolean matrix kS:D:Rk = r N (R) = per (R) (23) is equal to the permanent, per (R), of matrix R [37, 19, 38]. The permanent is a scalar quantity that often appears in many enumeration and combinatorial problems.
Reference: [37] <author> M. Marcus and H. </author> <title> Minc, A Survey of Matrix Theory and Matrix Inequalities. </title> <address> New York: </address> <publisher> Dover, </publisher> <year> 1992. </year> <pages> Page 20 </pages>
Reference-contexts: Therefore each N -rook configuration is a singular dis tinct representative (S.D.R) of matrix R [36]. The number of S.D.R's and r N (R) in a Boolean matrix kS:D:Rk = r N (R) = per (R) (23) is equal to the permanent, per (R), of matrix R <ref> [37, 19, 38] </ref>. The permanent is a scalar quantity that often appears in many enumeration and combinatorial problems. For square matrices, the permanent is calculated as a `plus-only' determinant [39]. The evaluation of per (R) requires in general N ! steps. Fortunately there exists an upper bound for per ().
Reference: [38] <author> W. Wan-di, </author> <title> "Permutations with restricted posi-tions and k-permanent," </title> <journal> Acta Math. Appl. Sinica, </journal> <volume> vol. 6, </volume> <pages> pp. 177-182, </pages> <year> 1983. </year>
Reference-contexts: Therefore each N -rook configuration is a singular dis tinct representative (S.D.R) of matrix R [36]. The number of S.D.R's and r N (R) in a Boolean matrix kS:D:Rk = r N (R) = per (R) (23) is equal to the permanent, per (R), of matrix R <ref> [37, 19, 38] </ref>. The permanent is a scalar quantity that often appears in many enumeration and combinatorial problems. For square matrices, the permanent is calculated as a `plus-only' determinant [39]. The evaluation of per (R) requires in general N ! steps. Fortunately there exists an upper bound for per ().
Reference: [39] <author> H. </author> <title> Minc, Permanents. </title> <address> Reading: </address> <publisher> Addison-Wesley, </publisher> <year> 1978. </year>
Reference-contexts: The permanent is a scalar quantity that often appears in many enumeration and combinatorial problems. For square matrices, the permanent is calculated as a `plus-only' determinant <ref> [39] </ref>. The evaluation of per (R) requires in general N ! steps. Fortunately there exists an upper bound for per ().
Reference: [40] <author> N. Alon, J. H. Spencer, and P. Erdos, </author> <title> The Probabilistic Method. </title> <address> New York: </address> <publisher> Wiley, </publisher> <year> 1992. </year>
Reference-contexts: For square matrices, the permanent is calculated as a `plus-only' determinant [39]. The evaluation of per (R) requires in general N ! steps. Fortunately there exists an upper bound for per (). The quantity kDk r N (r) = per (R) i=1 is known as Bergman's bound <ref> [40] </ref> for the permanent, and b i is the number of ones in row i of R. This bound is computationally inexpensive and can be calculated in N steps. Simpler estimates of per () are found as follows. <p> Then the first column and row are deleted from matrix T , and the procedure is repeated recursively on the reduced matrix. The permanent is approximately per (R) i=1 and it is essentially a reduced factorial measure of the component combinations. This estimate reported in <ref> [41, 40] </ref> is known as the Lazyman's permanent. In practice the bound of Eq. (24) offers the most accuracy at the lowest computational cost. GRANULARITY CONTROL THROUGH CONDENSATION In practice, if kDk &gt; 10 4 , further simplifications are necessary to find D in a reasonable time.
Reference: [41] <author> B. Gogoi, R. Yuen, and C. H. Mastrangelo, </author> <title> "The automatic synthesis of planar fabrication process flows for surface micromachined devices," </title> <booktitle> in MEMS 94, International Conference on Microelec-tromechanical Systems, </booktitle> <pages> pp. 153-157, </pages> <year> 1994. </year>
Reference-contexts: Then the first column and row are deleted from matrix T , and the procedure is repeated recursively on the reduced matrix. The permanent is approximately per (R) i=1 and it is essentially a reduced factorial measure of the component combinations. This estimate reported in <ref> [41, 40] </ref> is known as the Lazyman's permanent. In practice the bound of Eq. (24) offers the most accuracy at the lowest computational cost. GRANULARITY CONTROL THROUGH CONDENSATION In practice, if kDk &gt; 10 4 , further simplifications are necessary to find D in a reasonable time.
Reference: [42] <author> D. J. Kleitman and B. L. Rothschild, </author> <title> "Asymptotic enumeration of partial orders on a finite set," </title> <journal> Trans. Amer. Math. Soc., </journal> <volume> vol. 205, </volume> <pages> pp. 205-221, </pages> <year> 1975. </year>
Reference-contexts: In general, the number of devices (or topologies) that can be fabricated with n layers of m different ma terials is approximately ( 2=n) m n 2 (n+1) 2 =4+n (28) Equation (28) is a modification of the formula obtained in <ref> [18, 42, 43, 44, 45, 46, 47] </ref> for unlabeled graphs. This number is very large but finite. Another interesting property of posets that may prove useful in VLSI technology is their ability to be stored as polynomials [48, 49].
Reference: [43] <author> D. J. Kleitman and B. L. Rothschild, </author> <title> "The number of finite topologies," </title> <journal> Proc. Amer. Math. Soc., </journal> <volume> vol. 25, </volume> <pages> pp. 276-282, </pages> <year> 1970. </year>
Reference-contexts: In general, the number of devices (or topologies) that can be fabricated with n layers of m different ma terials is approximately ( 2=n) m n 2 (n+1) 2 =4+n (28) Equation (28) is a modification of the formula obtained in <ref> [18, 42, 43, 44, 45, 46, 47] </ref> for unlabeled graphs. This number is very large but finite. Another interesting property of posets that may prove useful in VLSI technology is their ability to be stored as polynomials [48, 49].
Reference: [44] <author> R. L. Davis, </author> <title> "The number of structures of finite relations," </title> <journal> Proc. Amer. Math. Soc., </journal> <volume> vol. 4, </volume> <pages> pp. 486-495, </pages> <year> 1953. </year>
Reference-contexts: In general, the number of devices (or topologies) that can be fabricated with n layers of m different ma terials is approximately ( 2=n) m n 2 (n+1) 2 =4+n (28) Equation (28) is a modification of the formula obtained in <ref> [18, 42, 43, 44, 45, 46, 47] </ref> for unlabeled graphs. This number is very large but finite. Another interesting property of posets that may prove useful in VLSI technology is their ability to be stored as polynomials [48, 49].
Reference: [45] <author> K. K. Butler, </author> <title> "The number of partially ordered sets," </title> <journal> J. Comb. Theor., </journal> <volume> vol. 13, </volume> <pages> pp. 276-289, </pages> <year> 1972. </year>
Reference-contexts: In general, the number of devices (or topologies) that can be fabricated with n layers of m different ma terials is approximately ( 2=n) m n 2 (n+1) 2 =4+n (28) Equation (28) is a modification of the formula obtained in <ref> [18, 42, 43, 44, 45, 46, 47] </ref> for unlabeled graphs. This number is very large but finite. Another interesting property of posets that may prove useful in VLSI technology is their ability to be stored as polynomials [48, 49].
Reference: [46] <author> F. Harary, </author> <title> "The number of linear, directed, rooted and connected graphs," </title> <journal> Trans. Amer. Math. Soc., </journal> <volume> vol. 78, </volume> <pages> pp. 445-463, </pages> <year> 1955. </year>
Reference-contexts: In general, the number of devices (or topologies) that can be fabricated with n layers of m different ma terials is approximately ( 2=n) m n 2 (n+1) 2 =4+n (28) Equation (28) is a modification of the formula obtained in <ref> [18, 42, 43, 44, 45, 46, 47] </ref> for unlabeled graphs. This number is very large but finite. Another interesting property of posets that may prove useful in VLSI technology is their ability to be stored as polynomials [48, 49].
Reference: [47] <author> M. H. El-Zahar, </author> <title> "Enumeration of ordered sets," in Algorithms and Order (I. Rival, </title> <publisher> ed.), </publisher> <pages> pp. 327-352, </pages> <address> Dordrecht: </address> <publisher> Kluwer, </publisher> <year> 1989. </year>
Reference-contexts: In general, the number of devices (or topologies) that can be fabricated with n layers of m different ma terials is approximately ( 2=n) m n 2 (n+1) 2 =4+n (28) Equation (28) is a modification of the formula obtained in <ref> [18, 42, 43, 44, 45, 46, 47] </ref> for unlabeled graphs. This number is very large but finite. Another interesting property of posets that may prove useful in VLSI technology is their ability to be stored as polynomials [48, 49].
Reference: [48] <author> J. Neggers, </author> <title> "Representations of finite partially ordered sets," </title> <journal> J. Combin., </journal> <volume> vol. 3, </volume> <pages> pp. 113-133, </pages> <year> 1978. </year>
Reference-contexts: This number is very large but finite. Another interesting property of posets that may prove useful in VLSI technology is their ability to be stored as polynomials <ref> [48, 49] </ref>. This fact may prove useful as a compact means for describing complex device topology. PROCESS FLOW CONSTRUCTION The first step in the construction of flow F consists of finding linear extensions of the condensed device graph.
Reference: [49] <author> R. P. Stanley, </author> <title> "Ordered structures and partitions," </title> <journal> Memoirs Amer. Math. Soc., </journal> <volume> vol. 119, </volume> <pages> pp. 1-102, </pages> <year> 1972. </year>
Reference-contexts: This number is very large but finite. Another interesting property of posets that may prove useful in VLSI technology is their ability to be stored as polynomials <ref> [48, 49] </ref>. This fact may prove useful as a compact means for describing complex device topology. PROCESS FLOW CONSTRUCTION The first step in the construction of flow F consists of finding linear extensions of the condensed device graph.
Reference: [50] <author> A. D. Kalvin and Y. L. Varol, </author> <title> "On the generation of all topological sortings," </title> <journal> J. Algorithms, </journal> <volume> vol. 4, </volume> <pages> pp. 150-162, </pages> <year> 1983. </year>
Reference-contexts: PROCESS FLOW CONSTRUCTION The first step in the construction of flow F consists of finding linear extensions of the condensed device graph. For finite graphs, the topological sort of its vertices can be performed in several ways. These sorting algorithms are based on (a) sequential generation of permutations <ref> [50, 21, 51, 52, 53, 54] </ref>, (b) finding directed paths in acyclic graphs [55, 56, 57], and (c) triangulation of its adjacency matrix [58]. Efficient parallel computation algorithms [59, 9, 60, 61] have also been developed.
Reference: [51] <author> A. B. Kahn, </author> <title> "Topological sortings of large networks," </title> <journal> Comm. ACM, </journal> <volume> vol. 5, </volume> <pages> pp. 558-562, </pages> <year> 1962. </year>
Reference-contexts: PROCESS FLOW CONSTRUCTION The first step in the construction of flow F consists of finding linear extensions of the condensed device graph. For finite graphs, the topological sort of its vertices can be performed in several ways. These sorting algorithms are based on (a) sequential generation of permutations <ref> [50, 21, 51, 52, 53, 54] </ref>, (b) finding directed paths in acyclic graphs [55, 56, 57], and (c) triangulation of its adjacency matrix [58]. Efficient parallel computation algorithms [59, 9, 60, 61] have also been developed.
Reference: [52] <author> D. E. Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> vol. </volume> <pages> 1. </pages> <address> Reading, Mass.: </address> <publisher> Addison-Wesley, </publisher> <year> 1968. </year>
Reference-contexts: PROCESS FLOW CONSTRUCTION The first step in the construction of flow F consists of finding linear extensions of the condensed device graph. For finite graphs, the topological sort of its vertices can be performed in several ways. These sorting algorithms are based on (a) sequential generation of permutations <ref> [50, 21, 51, 52, 53, 54] </ref>, (b) finding directed paths in acyclic graphs [55, 56, 57], and (c) triangulation of its adjacency matrix [58]. Efficient parallel computation algorithms [59, 9, 60, 61] have also been developed.
Reference: [53] <author> Y. L. Varol and D. Rotem, </author> <title> "An algorithm to generate all topological sorting arrangements," </title> <journal> The Computer Journal, </journal> <volume> vol. 24, </volume> <pages> pp. 83-84, </pages> <year> 1981. </year>
Reference-contexts: PROCESS FLOW CONSTRUCTION The first step in the construction of flow F consists of finding linear extensions of the condensed device graph. For finite graphs, the topological sort of its vertices can be performed in several ways. These sorting algorithms are based on (a) sequential generation of permutations <ref> [50, 21, 51, 52, 53, 54] </ref>, (b) finding directed paths in acyclic graphs [55, 56, 57], and (c) triangulation of its adjacency matrix [58]. Efficient parallel computation algorithms [59, 9, 60, 61] have also been developed.
Reference: [54] <author> G. </author> <title> Steiner, "An algorithm to generate the ideals of a partial order," </title> <journal> Operations Research Letters, </journal> <volume> vol. 5, </volume> <pages> pp. 317-320, </pages> <year> 1986. </year>
Reference-contexts: PROCESS FLOW CONSTRUCTION The first step in the construction of flow F consists of finding linear extensions of the condensed device graph. For finite graphs, the topological sort of its vertices can be performed in several ways. These sorting algorithms are based on (a) sequential generation of permutations <ref> [50, 21, 51, 52, 53, 54] </ref>, (b) finding directed paths in acyclic graphs [55, 56, 57], and (c) triangulation of its adjacency matrix [58]. Efficient parallel computation algorithms [59, 9, 60, 61] have also been developed. <p> Efficient parallel computation algorithms [59, 9, 60, 61] have also been developed. Since most device graphs contain a large number of vertices, it is neccessary to use an algorithm which does not generate any redundant information. We have adopted a modification of a sequential algorithm due to Steiner <ref> [54] </ref>. This algorithm constructs the exten sions using the ideals (feasible subsets) consistent with the poset order as shown in Figure 9 for the graph of Figure 6. An initial list of vertices U (n) and an empty extension E (0) are first formed. <p> These matrices are examined by a cardinality estimator. If kDk is too high, the device components are recursively condensed until an acceptable limit is reached. The condensed device is next sequenced using a low-memory budget modification of Steiner's algorithm <ref> [54] </ref>. For each of the generated sequences, the flow generator generates the L G and G G matrices of Eqs. (32)-(33) necessary for the flow expansion. The flow generator then inserts the gaps in the layer sequence consistent with these matrices.
Reference: [55] <author> A. V. Aho, M. R. Garey, and J. D. Ullman, </author> <title> "The transitive reduction of a directed graph," </title> <journal> SIAM J. Comput., </journal> <volume> vol. 1, </volume> <pages> pp. 131-137, </pages> <year> 1972. </year>
Reference-contexts: For finite graphs, the topological sort of its vertices can be performed in several ways. These sorting algorithms are based on (a) sequential generation of permutations [50, 21, 51, 52, 53, 54], (b) finding directed paths in acyclic graphs <ref> [55, 56, 57] </ref>, and (c) triangulation of its adjacency matrix [58]. Efficient parallel computation algorithms [59, 9, 60, 61] have also been developed. Since most device graphs contain a large number of vertices, it is neccessary to use an algorithm which does not generate any redundant information.
Reference: [56] <author> E. M. Reingold, J. Nievergelt, and N. Deo, </author> <title> Combinatorial Algorithms: Theory and Practice. </title> <editor> En-glewood Cliffs, N. J.: </editor> <publisher> Prentice-Hall, </publisher> <year> 1977. </year>
Reference-contexts: For finite graphs, the topological sort of its vertices can be performed in several ways. These sorting algorithms are based on (a) sequential generation of permutations [50, 21, 51, 52, 53, 54], (b) finding directed paths in acyclic graphs <ref> [55, 56, 57] </ref>, and (c) triangulation of its adjacency matrix [58]. Efficient parallel computation algorithms [59, 9, 60, 61] have also been developed. Since most device graphs contain a large number of vertices, it is neccessary to use an algorithm which does not generate any redundant information.
Reference: [57] <author> R. Tarjan, </author> <title> "Finding dominators in directed graphs," </title> <journal> SIAM J. Comput., </journal> <volume> vol. 3, </volume> <pages> pp. 62-89, </pages> <year> 1974. </year>
Reference-contexts: For finite graphs, the topological sort of its vertices can be performed in several ways. These sorting algorithms are based on (a) sequential generation of permutations [50, 21, 51, 52, 53, 54], (b) finding directed paths in acyclic graphs <ref> [55, 56, 57] </ref>, and (c) triangulation of its adjacency matrix [58]. Efficient parallel computation algorithms [59, 9, 60, 61] have also been developed. Since most device graphs contain a large number of vertices, it is neccessary to use an algorithm which does not generate any redundant information.
Reference: [58] <author> A. Nijenhuis and H. S. Wilf, </author> <title> Combinatorial Algorithms. </title> <address> New York: </address> <publisher> Academic Press, </publisher> <year> 1975. </year>
Reference-contexts: For finite graphs, the topological sort of its vertices can be performed in several ways. These sorting algorithms are based on (a) sequential generation of permutations [50, 21, 51, 52, 53, 54], (b) finding directed paths in acyclic graphs [55, 56, 57], and (c) triangulation of its adjacency matrix <ref> [58] </ref>. Efficient parallel computation algorithms [59, 9, 60, 61] have also been developed. Since most device graphs contain a large number of vertices, it is neccessary to use an algorithm which does not generate any redundant information. We have adopted a modification of a sequential algorithm due to Steiner [54].
Reference: [59] <author> M. C. </author> <title> Er, "A parallel computation approach to topological sorting," </title> <journal> The Computer Journal, </journal> <volume> vol. 26, </volume> <pages> pp. 293-295, </pages> <year> 1983. </year>
Reference-contexts: These sorting algorithms are based on (a) sequential generation of permutations [50, 21, 51, 52, 53, 54], (b) finding directed paths in acyclic graphs [55, 56, 57], and (c) triangulation of its adjacency matrix [58]. Efficient parallel computation algorithms <ref> [59, 9, 60, 61] </ref> have also been developed. Since most device graphs contain a large number of vertices, it is neccessary to use an algorithm which does not generate any redundant information. We have adopted a modification of a sequential algorithm due to Steiner [54].
Reference: [60] <author> P. Chaudhuri, </author> <title> "Fast parallel algorithms for a class of graph problems," Jr. </title> <journal> Comb. Inf. and Syst. Sci., </journal> <volume> vol. 12, no. 1, </volume> <pages> pp. 51-65, </pages> <year> 1987. </year>
Reference-contexts: These sorting algorithms are based on (a) sequential generation of permutations [50, 21, 51, 52, 53, 54], (b) finding directed paths in acyclic graphs [55, 56, 57], and (c) triangulation of its adjacency matrix [58]. Efficient parallel computation algorithms <ref> [59, 9, 60, 61] </ref> have also been developed. Since most device graphs contain a large number of vertices, it is neccessary to use an algorithm which does not generate any redundant information. We have adopted a modification of a sequential algorithm due to Steiner [54].
Reference: [61] <author> K. Culik and I. Fris, </author> <title> "Topological transformations as a tool in the design of systolic networks," </title> <journal> Theoretical Computer Science, </journal> <volume> vol. 37, </volume> <pages> pp. 183-216, </pages> <year> 1985. </year>
Reference-contexts: These sorting algorithms are based on (a) sequential generation of permutations [50, 21, 51, 52, 53, 54], (b) finding directed paths in acyclic graphs [55, 56, 57], and (c) triangulation of its adjacency matrix [58]. Efficient parallel computation algorithms <ref> [59, 9, 60, 61] </ref> have also been developed. Since most device graphs contain a large number of vertices, it is neccessary to use an algorithm which does not generate any redundant information. We have adopted a modification of a sequential algorithm due to Steiner [54].
Reference: [62] <author> E. Welzl, </author> <title> "Constructing the visibility graph for n-line segments in O(n 2 ) time," </title> <journal> Information Processing Letters, </journal> <volume> vol. 20, </volume> <pages> pp. 167-171, </pages> <year> 1990. </year>
Reference-contexts: Layers patterned by regular etching must be present before definition therefore g i;k l i . Furthermore the segment of layer l i corresponding to g i;k must be visible. The layer visibility is determined by examining the blocking graph of the layer sequence <ref> [62, 63] </ref>. If this gap is covered by components from layer l j then g i;k l j .
Reference: [63] <author> S. Foldes, I. Rival, and J. Urrutia, </author> <title> "Light sources, obstructions and spherical orders," </title> <journal> Discrete Mathematics, </journal> <volume> vol. 102, </volume> <pages> pp. 13-23, </pages> <year> 1992. </year>
Reference-contexts: Layers patterned by regular etching must be present before definition therefore g i;k l i . Furthermore the segment of layer l i corresponding to g i;k must be visible. The layer visibility is determined by examining the blocking graph of the layer sequence <ref> [62, 63] </ref>. If this gap is covered by components from layer l j then g i;k l j .
Reference: [64] <author> J. L. Vossen, </author> <title> Thin Film Processes. </title> <address> New York: </address> <publisher> Academic Press, </publisher> <year> 1978. </year>
Reference-contexts: Furthermore, the operator behavior under widely varying parameter ranges is in general unknown. Recipe parameters however are finely tuned for satisfactory performance through many experiments yielding predictable results. Most recipes are specific with few parameters that can be adjusted. Operator recipes are stored in a database containing general <ref> [64] </ref> as well as lab specific data. a) Lithography: The lithography recipe consists of a dehydration cycle, resist application, soft bake, exposure and hardbake (for etching). The photoresist thickness is determined from the roughness of the surface topography. <p> The database is organized in two parts, a general library of processes, and a lab specific library. The general library consists mainly of wet etchant data <ref> [64] </ref> since depositions and plasma etches are very much machine and lab specific. The database contents are accessed by all the parts of MISTIC. These contents are included in the output files of the various modules.
Reference: [65] <author> B. R. Penumalli, </author> <title> "A comprehensive two dimensional VLSI process simulation program, </title> <journal> BICEPS," IEEE Trans. Electron Devices, </journal> <volume> vol. ED-30, </volume> <pages> pp. 986-992, </pages> <year> 1983. </year>
Reference-contexts: However, in high concentration diffused layers, the diffusion coefficient is a function of concentration and dopant migration is affected by local electric fields. In this regime, the concentration of species C i obeys <ref> [65, 66] </ref> @t where f i is the electric field enhancement factor f i = [(0:5C net ) 2 + n 2 and n X Z i N i (56) In this regime, the gaussian approximation is a very crude guess to the actual profile.
Reference: [66] <author> C. P. Ho, J. D. Plummer, S. E. Hansen, and R. W. Dutton, </author> <title> "VLSI process modeling - SUPREM III," </title> <journal> IEEE Trans. Electron Devices, </journal> <volume> vol. ED-30, </volume> <pages> pp. 1438-1453, </pages> <year> 1983. </year>
Reference-contexts: However, in high concentration diffused layers, the diffusion coefficient is a function of concentration and dopant migration is affected by local electric fields. In this regime, the concentration of species C i obeys <ref> [65, 66] </ref> @t where f i is the electric field enhancement factor f i = [(0:5C net ) 2 + n 2 and n X Z i N i (56) In this regime, the gaussian approximation is a very crude guess to the actual profile.
Reference: [67] <author> J. Mockus, </author> <title> Bayesian Approach to Global Optimization : Theory and Applications. </title> <address> Boston: </address> <publisher> Kluwer, </publisher> <year> 1989. </year>
Reference-contexts: Several iteration schemes for (Q j ; t j ) have been implemented. These include a globally convergent Newton method, a contraction mapping, and a Bayesian global optimization <ref> [67] </ref>. The most robust scheme is a globally convergent New-ton method described in [68]. The main disadvantage of Newton-type codes is in the numerical evaluation of gradients which may confuse the solver ending the iteration in a local minima rather than a root.
Reference: [68] <author> W. H. Press, B. P. Flannery, S. A. Teulosky, and W. T. Vetterling, </author> <title> Numerical Recipes in C. </title> <address> New York: </address> <publisher> Cambridge Univ. Press, </publisher> <year> 1993. </year> <pages> Page 21 </pages>
Reference-contexts: Several iteration schemes for (Q j ; t j ) have been implemented. These include a globally convergent Newton method, a contraction mapping, and a Bayesian global optimization [67]. The most robust scheme is a globally convergent New-ton method described in <ref> [68] </ref>. The main disadvantage of Newton-type codes is in the numerical evaluation of gradients which may confuse the solver ending the iteration in a local minima rather than a root.
Reference: [69] <author> A. J. Strowjas, </author> <title> Statistical Design of Integrated Cir--cuits. </title> <address> New York: </address> <publisher> IEEE, </publisher> <year> 1987. </year>
Reference-contexts: Yield is also reduced by the prescence of random distribution of point defects on the wafer as well as random variations in the process operators. Random effects on yield have been studied by numerous authors <ref> [69, 70, 71] </ref> for fine tuning of well-known semiconductor processes. Since the compiler generates a large number of tentative processes with limited selectivities, we have adopted to estimate the deterministic yield instead. The most important deterministic factor on yield is the loading effect.
Reference: [70] <author> S. W. Director and W. Maly, </author> <title> Statistical Approach to VLSI. </title> <address> New York: </address> <publisher> North-Holland, </publisher> <year> 1994. </year>
Reference-contexts: Yield is also reduced by the prescence of random distribution of point defects on the wafer as well as random variations in the process operators. Random effects on yield have been studied by numerous authors <ref> [69, 70, 71] </ref> for fine tuning of well-known semiconductor processes. Since the compiler generates a large number of tentative processes with limited selectivities, we have adopted to estimate the deterministic yield instead. The most important deterministic factor on yield is the loading effect.
Reference: [71] <author> D. Moore and H. Walker, </author> <title> Yield Simulation For Integrated Circuits. </title> <address> New York: </address> <publisher> Kluwer, </publisher> <year> 1987. </year> <pages> Page 22 </pages>
Reference-contexts: Yield is also reduced by the prescence of random distribution of point defects on the wafer as well as random variations in the process operators. Random effects on yield have been studied by numerous authors <ref> [69, 70, 71] </ref> for fine tuning of well-known semiconductor processes. Since the compiler generates a large number of tentative processes with limited selectivities, we have adopted to estimate the deterministic yield instead. The most important deterministic factor on yield is the loading effect.
References-found: 71

