URL: http://seclab.cs.ucdavis.edu/papers/wilson.ho/diss.ps
Refering-URL: http://seclab.cs.ucdavis.edu/awb/AuditWorkBench.html
Root-URL: http://www.cs.ucdavis.edu
Note: Chapter 1  
Abstract-found: 0
Intro-found: 1
Reference: [Acce86] <author> Accetta, M. J., </author> <title> "Mach: A New Kernel Foundation for Unix Development," </title> <booktitle> Proc. Summer Usenix, </booktitle> <pages> pp. </pages> <month> 93-112 (July </month> <year> 1986). </year>
Reference-contexts: On the other hand, a distributed program is a concurrent program in which the processes reside on different physical machines and communicate through message passing. As high performance multiprocessor machines and high speed computer networks become more and more common, many large scale concurrent programs have been built (e.g., <ref> [Acce86, Allm83, Cher88, Dubo82, Hell78, Hume87] </ref>). By utilizing the combined power of multiple processors, they can shorten the execution time of many programs and can make them more tolerant to faults. <p> Examination and modification of the inferior processes' address space can then be made through the standard seek, read, and write mechanisms. This allows a much more efficient interaction between the debugging and the inferior processes. Mach <ref> [Acce86] </ref> is a newly designed operating system that has much stronger debugging support than existing systems. The Mach kernel provides a generalized exception handling mechanism [Blac88] for the debugger to detect any anomalies in an inferior process.
Reference: [ACM83] <editor> ACM, </editor> <booktitle> ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging. </booktitle> <month> March </month> <year> 1983. </year>
Reference-contexts: For each of the new ideas proposed, prototypical programs were implemented to demonstrate its feasibility. 1.1. Overview of Debugging Over the years, many software tools have been developed to aid programmers in debugging sequential programs (e.g., <ref> [ACM83, Adam86, Kats79, Stal91b] </ref>). These debuggers typically allow programmers to suspend the execution of a given program, examine in detail or modify its states, and then resume its execution. <p> Related Work A brief survey of some of the previous work on software debugging is given here. This is only a partial description of some of the significant work and is by no means exhaustive. More detailed information can be found in <ref> [ACM83, ACM88, ACM91, McDo89] </ref>. Only those debuggers that apply approaches related to our proposed design are listed.
Reference: [ACM88] <editor> ACM, </editor> <booktitle> ACM Workshop on Parallel and Distributed Debugging. </booktitle> <month> May </month> <year> 1988. </year>
Reference-contexts: Related Work A brief survey of some of the previous work on software debugging is given here. This is only a partial description of some of the significant work and is by no means exhaustive. More detailed information can be found in <ref> [ACM83, ACM88, ACM91, McDo89] </ref>. Only those debuggers that apply approaches related to our proposed design are listed.
Reference: [ACM91] <editor> ACM, </editor> <booktitle> Proc. ACM/ONR Workshop on Parallel and Distributed Debugging. </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: Related Work A brief survey of some of the previous work on software debugging is given here. This is only a partial description of some of the significant work and is by no means exhaustive. More detailed information can be found in <ref> [ACM83, ACM88, ACM91, McDo89] </ref>. Only those debuggers that apply approaches related to our proposed design are listed.
Reference: [Adam86] <author> Adams, E. and S. S. Muchnick, "Dbxtool: </author> <title> A Window-Based Symbolic Debugger for Sun Workstations," </title> <journal> Software|Practice and Experience Vol. </journal> <pages> 16(7) pp. </pages> <month> 653-669 (July </month> <year> 1986). </year>
Reference-contexts: For each of the new ideas proposed, prototypical programs were implemented to demonstrate its feasibility. 1.1. Overview of Debugging Over the years, many software tools have been developed to aid programmers in debugging sequential programs (e.g., <ref> [ACM83, Adam86, Kats79, Stal91b] </ref>). These debuggers typically allow programmers to suspend the execution of a given program, examine in detail or modify its states, and then resume its execution. <p> Over the years, many tools have been developed to assist programmers in debugging. Usually they employ both the state examination and behavioral approaches. Many of these debuggers (e.g., dbx <ref> [Adam86, DBX83] </ref>, sdb [Kats79], gdb [Stal91b], DEBUG [DEC88], and the Turbo system debugger [Borl85]) allow programmers to suspend a process in the middle of its execution, examine or even modify its state, print out selected information that might be related to the errors, and then resume the process's execution. <p> Furthermore, given the same input, a sequential program always goes through the identical states in its execu 19 tion. Hence, the same error will show up when the program is run for the second or subsequent time. This property is known as deterministic. State-of-the-art sequential debuggers, such as dbx <ref> [Adam86, DBX83] </ref>, sdb [Kats79], gdb [Stal91b], and VMS's DEBUG [DEC88], usually allow programmers to control the execution of the inferior process interactively. Besides stopping the inferior process to examine its memory contents, these debuggers can also be used to modify its state or change the path of its execution. <p> Most of the more popular debuggers for sequential programs provide more or less the same features, such as setting breakpoints, single stepping through instructions or statements, displaying source code and values of variables, and modifying the hardware registers or memory contents. Mark Linton's dbx <ref> [Adam86] </ref> provides facilities to trace the inferior process by printing out information whenever a certain statement is reached or the value of some user-specified variable is modified. <p> More sophisticated user interfaces often provide graphical input/output facilities. For example, a debugger may use multiple windows with one for showing the text of the source program, one for reading commands and printing output, and one for normal input/output of the inferior program <ref> [Adam86, Russ91a] </ref>. Furthermore, it may use a pointing device such as a mouse to specify locations of breakpoints, associate blocks of command text from the editor window with locations in the source program, or define relations between low-level and high-level events. <p> Many debuggers, such as gdb [Stal91b], dbx <ref> [Adam86, DBX83] </ref>, sdb [Kats79], and DEBUG [DEC88], implement source-level single-stepping in an very inefficient way. The inferior process is single-stepped at the machine instruction level, and after every instruction, the value of the program counter is examined. <p> Other kinds of assistance provided by the High-Level Interface vary from minimizing the 156 number of keystrokes (by providing a command line editor such as [Fox89] or using a mouse to quickly select a command from a list of commonly used commands <ref> [Adam86] </ref>), using graphical symbols to present the change of data structures [Shim91], to the use of sound to indicate the behavior of an inferior process [Fran91]. 6.2. Applications Our layered model provides a framework for implementing debugging and monitoring tools.
Reference: [Aho86] <author> Aho, A. V., R. Sethi, and J. D. Ullman, </author> <booktitle> Compilers: Principles, Techniques, and Tools, </booktitle> <publisher> Addison-Wesley Publishing Company (1986). </publisher>
Reference-contexts: of source program (i.e., definitions of events, breakpoint commands, etc.), allocation of storage for global variables, dynamic storage allocation of local variables, handling of parameters passing in function call, and many other necessary functionalities of a language interpreter. 118 Techniques for implementing language interpreters can be found in numerous publications <ref> [Aho86, Mak91] </ref> and are not within the scope of this dissertation. However, the unique operating environment of Dalek's command interpreter creates an implementation problem that merits special attention. This problem is the result of the fact that the debugger language works on two entirely different address spaces. <p> The implementation of language parsers has been well-studied <ref> [Aho86, Mak91] </ref> and is not discussed here. 6.1.6. High-Level Interface (Layer 6) A High-Level Interface contains all those functions that are not absolutely necessary for a debugger, but can help smooth the interaction between a programmer and a debugger and making the debugger easier to use.
Reference: [Alle86] <author> Allen, R., D. Baumgartner, K. Kennedy, and A. Porterfield, </author> <title> "Ptool: </title>
Reference-contexts: Other approaches to software debugging that are not discussed in detail are, for example, execution animation (either by time-process 26 diagrams [Hart85], graphical representations of data structures [Shim91, Soch88], algorithmic animation [Brow88], or even sound [Fran91]) and static analysis <ref> [Alle86, Tayl80] </ref>. Most of the more popular debuggers for sequential programs provide more or less the same features, such as setting breakpoints, single stepping through instructions or statements, displaying source code and values of variables, and modifying the hardware registers or memory contents.
References-found: 7

