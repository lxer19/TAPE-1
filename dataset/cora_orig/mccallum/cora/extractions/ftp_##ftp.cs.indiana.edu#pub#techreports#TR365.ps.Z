URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR365.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Email: sdlee@cs.indiana.edu dfried@cs.indiana.edu  
Title: Quasi-Static Scoping: Sharing Variable Bindings Across Multiple Lexical Scopes  
Author: Shinn-Der Lee and Daniel P. Friedman 
Address: Bloomington, Indiana 47405  
Affiliation: Computer Science Department Indiana University  
Pubnum: (Technical Report No. 365)  
Abstract: Static scoping embodies a strong encapsulation mechanism for hiding the details of program units. Yet, it does not allow the sharing of variable bindings (locations) across independent program units. Facilities such as module and object systems that require cross references of variables therefore must be added as special features. In this paper we present an alternative: quasi-static scoping. Quasi-static scoping is more flexible than static scoping, but has the same encapsulation mechanism. The user can control when and in what scope to resolve a quasi-static variable, i.e., to associate it with a variable binding. To demonstrate its versatility, we add quasi-static scoping to Scheme and show how to build the aforementioned facilities at the user-level. We also show that quasi-static scoping can be implemented efficiently. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Abelson and G. J. Sussman with J. Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Resolvers are run-time linking operators and quasi-static procedures are compiled but only partially linked programs. MIT Scheme's first-class environments <ref> [1, 12] </ref> resemble our resolvers. They differ from our quasi-static scoping in four aspects. First, there is no mechanism like resolve that can export variables selectively. Consequently, in the presence of first-class environments, optimization techniques such as constant folding that involve eliminating variables are no longer meaning preserving transformations.
Reference: [2] <author> N. Adams and J. Rees. </author> <title> Object-oriented programming in Scheme. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 277-288, </pages> <year> 1988. </year>
Reference-contexts: In summary, we believe that by-reference import and export and run-time linking are essential to a Scheme module system. But we would also like to have static linking because of macro sharing and efficiency. Thus, a combination of the above systems is preferred. 3.2 Objects In Scheme object systems <ref> [2, 15] </ref> where instance variables are lexical variables, inheritance of instance variables is not feasible. One way of getting around this restriction is to define for each instance variable a pair of methods called reader and writer, and simulate instance variable inheritance with method inheritance, as in CLOS [18].
Reference: [3] <author> L. Cardelli. </author> <title> Compiling a functional language. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 208-217, </pages> <year> 1984. </year>
Reference-contexts: Hence, instead of copying a sequence of frame pointers, we could copy down the slots of the free quasi-static variables. The result is reminiscent of the way Cardelli's Functional Abstract Machine <ref> [3] </ref> handles a procedure's free lexical variable references. It would require potentially more time and space to build a frame. On the other hand, it reduces every quasi-static variable reference's lexical address to a depth of zero.
Reference: [4] <editor> W. Clinger and J. Rees (editors). </editor> <title> Revised 4 report on the algorithmic language Scheme. </title> <journal> Lisp Pointers, </journal> <volume> 4(3) </volume> <pages> 1-55, </pages> <year> 1991. </year>
Reference-contexts: In the last section we make comparisons to other work and discuss future research directions. 2 Extending Scheme with Quasi-Static Scoping Scheme is an elegant statically-scoped functional language with imperative features that has a simple and clean semantics <ref> [4] </ref>. In this section we add quasi-static scoping to Scheme, showing that quasi-static scoping and static scoping can co-exist and complement each other. 2.1 Quasi-Static Procedures A quasi-static variable is not as static as a static one; it should only be used in circumstances where a static variable is inadequate.
Reference: [5] <author> P. Curtis and J. Rauen. </author> <title> A module system for Scheme. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 13-19, </pages> <year> 1990. </year>
Reference-contexts: To ease the restrictions, they switch to by-name import that essentially delays import until the value is needed. Unfortunately, by-name import only works for import values that are procedures. Curtis and Rauen's Scheme module system <ref> [5] </ref> uses by-reference import and export. But its goal is to perform compile-time (static) linking since macros are expected to be sharable as well. Therefore their interfaces are compile-time objects, since they must be computable statically. ML's module system [13] uses by-value import and export.
Reference: [6] <author> E. W. Dijkstra. </author> <title> Algol 60 translation. Supplement ALGOL Bulletin 10, </title> <year> 1960. </year>
Reference-contexts: The next k slots are for the local quasi-static formals q 1 , : : :, q k . The last h slots f 1 ; : : : ; f h are locations of the enclosing frames. They are the display <ref> [6] </ref> of the procedure's free quasi-static variable references. We discuss how the slots are filled later. The values of m and k are readily available from the syntax of the qs-lambda expression itself. The value of h depends on the syntactic context of the qs-lambda expression.
Reference: [7] <author> M. Felleisen and D. P. Friedman. </author> <title> A closer look at export and import statements. </title> <journal> Journal of Computer Languages, </journal> <volume> 11(1) </volume> <pages> 29-37, </pages> <year> 1986. </year>
Reference-contexts: The only changes are to the implementation itself; no other clients or interfaces need be recompiled or relinked. Our module system uses by-reference export and import, as well as run-time linking. Felleisen and Friedman's Scheme module system <ref> [7] </ref> also employs run-time linking. But it uses by-value import and export. There are thus serious restrictions on the ordering of linking, since import can occur only when the export value is readily available.
Reference: [8] <author> M. Felleisen and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 102 </volume> <pages> 235-271, </pages> <year> 1992. </year>
Reference-contexts: Then, run-time external name matching would be eliminated. Finally, for reasoning about quasi-static scoping, we have developed a calculus that is consistent and has a standardization procedure. The calculus is an extension of Felleisen and Hieb's calculus of sequential state <ref> [8] </ref>, which in turn is an extension of Plotkin's call-by-value -calculus [17]. We will continue its development into a more complete logical system and report it elsewhere. Acknowledgements.
Reference: [9] <author> S. Jagannathan. </author> <title> Reflective building blocks for modular systems. </title> <booktitle> To appear in the IMSA '92 International Workshop on Reflection and Meta-Level Architecture. </booktitle>
Reference-contexts: Fourth, environment is a notion that is not employed by every computational model. Thus, adding first-class environments to a language means that the language cannot be implemented easily on some environment-less architectures such as the G-machine [16]. Jagannathan's environment-based reflection language Rascal <ref> [9] </ref> is another language with first-class environments. Rascal provides a way to identify reifiable (exportable) variables; however, it still suffers from the first two disadvantages mentioned above, because some non-reifiable variables are dynamically bound. Lamping's unified system of parameterization [10] emphasizes the other part of our approach.
Reference: [10] <author> J. O. Lamping. </author> <title> A unified system of parameterization for programming languages. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 316-326, </pages> <year> 1988. </year>
Reference-contexts: Jagannathan's environment-based reflection language Rascal [9] is another language with first-class environments. Rascal provides a way to identify reifiable (exportable) variables; however, it still suffers from the first two disadvantages mentioned above, because some non-reifiable variables are dynamically bound. Lamping's unified system of parameterization <ref> [10] </ref> emphasizes the other part of our approach. It uses a special form data to identify non-lexical variables. But instead of providing an explicit resolution operation like resolve , it always uses the run-time dynamic environment to resolve the non-lexical variables. They are therefore truly dynamic variables.
Reference: [11] <author> K. J. Lang and B. A. Pearlmutter. Oaklisp: </author> <title> An object-oriented dialect of Scheme. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 1(1) </volume> <pages> 39-51, </pages> <year> 1988. </year>
Reference-contexts: Another constraint posed by lexical instance variables is that an object's method, which is a procedure, must be defined within the lexical scope of the object's instance variables in order for it to gain access to the instance variables. Oaklisp <ref> [11] </ref> removes the constraint by resorting to the add-method special form (add-method (op (type . inst-vars) . args) . body) where inst-vars is the list of instance variables of the class type that are accessible to the method's body. The addition of quasi-static scoping, however, provides a simple alternative.
Reference: [12] <author> J. S. Miller and G. J. Rozas. </author> <title> Free variables and first-class environments. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 4(2) </volume> <pages> 107-141, </pages> <year> 1991. </year>
Reference-contexts: Resolvers are run-time linking operators and quasi-static procedures are compiled but only partially linked programs. MIT Scheme's first-class environments <ref> [1, 12] </ref> resemble our resolvers. They differ from our quasi-static scoping in four aspects. First, there is no mechanism like resolve that can export variables selectively. Consequently, in the presence of first-class environments, optimization techniques such as constant folding that involve eliminating variables are no longer meaning preserving transformations.
Reference: [13] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Curtis and Rauen's Scheme module system [5] uses by-reference import and export. But its goal is to perform compile-time (static) linking since macros are expected to be sharable as well. Therefore their interfaces are compile-time objects, since they must be computable statically. ML's module system <ref> [13] </ref> uses by-value import and export. But since ML has first-class references (variable bindings), by-reference import and export are easily expressible as well. ML's functors, which are functions mapping modules to modules, are not first-class values; instead, they are first-order objects.
Reference: [14] <author> J. H. Morris Jr. </author> <title> Protection in programming languages. </title> <journal> CACM, </journal> <volume> 16(8) </volume> <pages> 15-21, </pages> <year> 1973. </year>
Reference-contexts: Thus, there is little, if any, computation needed at run time to resolve a variable reference, i.e., to determine the variable binding (location) denoted by the reference. Consequently, static scoping facilitates efficient implementation. Yet, static scoping does not allow variables to be shared across independent scopes <ref> [14] </ref>. Facilities such as module and object systems that support cross references of variables among lexical scopes thus must be added as special features. They provide the necessary scoping information to assist the evaluator (compiler or interpreter) in resolving variable references. In this paper we present an alternative: quasi-static scop-ing.
Reference: [15] <author> K. Ntrmark. </author> <title> Simulation of object-oriented concepts and mechanisms in Scheme. </title> <type> Technical Report R 90-01, </type> <institution> Institute of Electronic Systems, Aalborg University, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: In summary, we believe that by-reference import and export and run-time linking are essential to a Scheme module system. But we would also like to have static linking because of macro sharing and efficiency. Thus, a combination of the above systems is preferred. 3.2 Objects In Scheme object systems <ref> [2, 15] </ref> where instance variables are lexical variables, inheritance of instance variables is not feasible. One way of getting around this restriction is to define for each instance variable a pair of methods called reader and writer, and simulate instance variable inheritance with method inheritance, as in CLOS [18].
Reference: [16] <editor> S. L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: Fourth, environment is a notion that is not employed by every computational model. Thus, adding first-class environments to a language means that the language cannot be implemented easily on some environment-less architectures such as the G-machine <ref> [16] </ref>. Jagannathan's environment-based reflection language Rascal [9] is another language with first-class environments. Rascal provides a way to identify reifiable (exportable) variables; however, it still suffers from the first two disadvantages mentioned above, because some non-reifiable variables are dynamically bound.
Reference: [17] <author> G. D. Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: Finally, for reasoning about quasi-static scoping, we have developed a calculus that is consistent and has a standardization procedure. The calculus is an extension of Felleisen and Hieb's calculus of sequential state [8], which in turn is an extension of Plotkin's call-by-value -calculus <ref> [17] </ref>. We will continue its development into a more complete logical system and report it elsewhere. Acknowledgements. We are grateful for the insightful comments by Kent Dybvig, Chris Haynes, and the late Bob Hieb during the early stages of this research.
Reference: [18] <author> G. L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <note> Digital Press, second edition, 1990. 14 </note>
Reference-contexts: It is therefore still a resolvable quasi-static formal. The ability to lexically inherit quasi-static variables has applications beyond expressing currying. We can use it to implement Common Lisp's optional keyword parameters <ref> [18] </ref>. Consider the quasi-static procedure f defined in Figure 3. It has a quasi-static parameter a named externally as A that is lexically inherited by the inner quasi-static procedure (qs-lambda ((a a)) () () (set! a (+ n a)) a). When f is called with 3, A is unresolved. <p> One way of getting around this restriction is to define for each instance variable a pair of methods called reader and writer, and simulate instance variable inheritance with method inheritance, as in CLOS <ref> [18] </ref>. Another constraint posed by lexical instance variables is that an object's method, which is a procedure, must be defined within the lexical scope of the object's instance variables in order for it to gain access to the instance variables.
References-found: 18

