URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS94-04.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Specification and Testing of Temporal Properties of Concurrent System Designs  
Author: Laura K. Dillon and Qing Yu 
Address: Santa Barbara 93106  
Affiliation: Department of Computer Science University of California,  
Abstract: This paper investigates the use of Graphical Interval Logic for specification and testing of concurrent and real-time systems. Past research produced a toolset for creating specifications in GIL and for reasoning about properties of systems that satisfy their specifications. Current research is exploring the use of GIL specifications during system design and implementation. Our work to date has focused primarily on using GIL specifications as oracles during testing of executable designs. The paper presents an example in which GIL specifications for an Ada design are used to uncover faults during testing. It also shows how the graphical representation of formulas can be used to advantage in displaying a trace that violates a specification. The testing methods have yet to be automated. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur and D. Dill. </author> <title> Automata for modelling real-time systems. </title> <booktitle> In Proc. 17th ICALP, </booktitle> <pages> pages 322-335, </pages> <year> 1990. </year> <note> LNCS 443. </note>
Reference-contexts: Future research will extend the algorithm for checking timeless traces to timed traces. The extension will entail the introduction of `clocks', modeled after the clocks described in <ref> [1, 18] </ref>, which are started upon locating the left endpoint of an interval that contains a timing constraint. Each clock that is active in a state has an associated `clock condition', which is checked at each state of the interval being timed.
Reference: [2] <author> Joanne M. Atlee and John Gannon. </author> <title> State-based model checking of event-driven system requirements. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 19(1) </volume> <pages> 24-40, </pages> <month> January </month> <year> 1993. </year>
Reference: [3] <author> Gregor V. Bochmann, Rachida Dssouli, and J. R. Zhao. </author> <title> Trace analysis for conformance and arbitration testing. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 15(11) </volume> <pages> 1347-1355, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: The TSL Runtime System monitors executions of Ada tasking programs and checks them for conformance with specifications written in an event-based notation for specifying sequencing constraints [23,24]. Oracles for testing communication protocols can be produced from state transition diagrams <ref> [3] </ref>. A very powerful (but undecidable) extension of IL, called Real-Time Interval Logic (RIL), was designed for use in testing real-time systems [20]. Richardson, Aha and O'Malley argue that oracles based on multiparadigm and multilingual specifications are needed due to the multiparadigm nature of requirements [22].
Reference: [4] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference: [5] <author> Laura K. Dillon, George Kutty, P. Michael Melliar-Smith, Louise E. Moser, and Y. S. Ra-makrishna. </author> <title> Visual specifications for temporal reasoning. </title> <journal> Journal of Visual Languages and Computing, </journal> <note> to appear. </note>
Reference: [6] <author> Laura K. Dillon, George Kutty, Louise E. Moser, P. Michael Melliar-Smith, and Y. S. Ramakr-ishna. </author> <title> A graphical interval logic for specifying concurrent systems. </title> <note> Submitted. </note>
Reference-contexts: The GIL graphical editor interfaces with all tool components, so that the software engineer works exclusively with graphical formulas. The GIL toolset is the topic of [12]. Experiences with the toolset are reported in <ref> [6, 12, 16, 19] </ref>. 3 Using Specifications During Testing of Designs Testing is a very laborious process, particularly when concurrency is involved. Ideally, some criteria is used for selecting test executions that provide sufficient `coverage' of the space of possible executions of a design. <p> After augmenting these specifications with specifications for other expected liveness and fairness properties, the designer might verify that the design specifications ensure the following requirement, as illustrated in <ref> [6] </ref>. ServeRequest2 : The elevator eventually responds to every call for service. The method for producing an oracle from a GIL formula (which may represent a design specification or a system requirement) is straightforward.
Reference: [7] <author> Laura K. Dillon, George Kutty, Louise E. Moser, P. Michael Melliar-Smith, and Y. S. Ra-makrishna. </author> <title> Graphical specifications for concurrent software systems. </title> <booktitle> In Proc. 14th IEEE Inter. Conf. Software Engineering, </booktitle> <pages> pages 213-224, </pages> <address> Melbourne, </address> <month> May </month> <year> 1992. </year> <month> 12 </month>
Reference-contexts: 1 Introduction This paper describes ongoing research on the use of formal specifications and testing during design of concurrent and real-time systems. We use a highly intuitive visual notation, called Graphical Interval Logic (GIL) <ref> [7] </ref> for specifying temporal properties of designs. Specifications in GIL resemble the `back-of-envelope' timing diagrams that system designers and software engineers often draw when reasoning about a system under construction. A prototype toolset allows designers to draw GIL specifications and check the validity of proofs in the logic [12]. <p> In vertical layout a conjunction is indicated by stacking the formulas one below the other without the conjunction operator. Braces are used to disambiguate formulas. The syntax and semantics of GIL are described in more detail in <ref> [7] </ref> A prototype toolset supports the use of GIL for specifying and reasoning about properties of concurrent systems.
Reference: [8] <author> E. A. Emerson. </author> <title> Temporal and modal logic. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, chapter 16, </booktitle> <pages> pages 995-1072. </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference-contexts: This formula illustrates the natural and visual manner by which an interval limits the scope of a nested formula. In comparison, the equivalent formula in Propositional Temporal Logic <ref> [8] </ref> is expressed 2 (:f U (f ^:g U (h^:g^3g))) GIL provides a point operator, denoted by a triangle, which locates a state specified by a search pattern and, when the state can be located, asserts that the formula left-justified below the point operator holds at that state.
Reference: [9] <author> Paul K. Harter, Dennis M. Heimbigner, and Roger King. Idd: </author> <title> An interactive distributed debugger. </title> <booktitle> In IEEE Inter. Conf. Distributed Computer Systems, </booktitle> <pages> pages 498-506, </pages> <year> 1985. </year>
Reference-contexts: Oracles for concurrent systems can be based on any formal specification language with a suitable decision procedure. The IDD debugger for distributed programs uses a subset of Interval Logic (IL) [25] for expressing synchronization constraints. IDD checks assertions at runtime, stopping execution if an assertion is violated <ref> [9] </ref>. The TSL Runtime System monitors executions of Ada tasking programs and checks them for conformance with specifications written in an event-based notation for specifying sequencing constraints [23,24]. Oracles for testing communication protocols can be produced from state transition diagrams [3].
Reference: [10] <editor> Richard A. Kemmerer, editor. </editor> <booktitle> Proc. SIGSOFT `89 3rd ACM Symp. Testing, Analysis and Verification, </booktitle> <address> Key West, FL, </address> <month> December </month> <year> 1989. </year> <note> ACM Press. ACM SIGSOFT Software Engineering Notes 14(8). </note>
Reference: [11] <author> George Kutty, Y. S. Ramakrishna, Laura K. Dillon, Louise E. Moser, and P. Michael Melliar-Smith. </author> <title> Specification of a communication protocol in graphical interval logic. </title> <booktitle> In Proc. IEE Inter. Conf. Information Engineering, </booktitle> <pages> pages 432-441, </pages> <address> Singapore, </address> <month> December </month> <year> 1991. </year>
Reference: [12] <author> George Kutty, Y. S. Ramakrishna, Louise E. Moser, Laura K. Dillon, and P. Michael Melliar-Smith. </author> <title> A graphical interval logic toolset for verifying concurrent systems. </title> <booktitle> In Proc. 4th Conf. Computer Aided Verification, volume 697 of Lecture Notes in Computer Science, </booktitle> <pages> pages 138-153, </pages> <address> Elounda, Greece, July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Specifications in GIL resemble the `back-of-envelope' timing diagrams that system designers and software engineers often draw when reasoning about a system under construction. A prototype toolset allows designers to draw GIL specifications and check the validity of proofs in the logic <ref> [12] </ref>. In particular, a designer can verify that the design specifications imply critical correctness requirements (expressed in GIL), thereby certifying correctness of any design satisfying the specifications. GIL specifications for a design describe constraints on the temporal sequencing of conditions that summarize important properties of execution histories. <p> The GIL graphical editor interfaces with all tool components, so that the software engineer works exclusively with graphical formulas. The GIL toolset is the topic of <ref> [12] </ref>. Experiences with the toolset are reported in [6, 12, 16, 19]. 3 Using Specifications During Testing of Designs Testing is a very laborious process, particularly when concurrency is involved. <p> The GIL graphical editor interfaces with all tool components, so that the software engineer works exclusively with graphical formulas. The GIL toolset is the topic of [12]. Experiences with the toolset are reported in <ref> [6, 12, 16, 19] </ref>. 3 Using Specifications During Testing of Designs Testing is a very laborious process, particularly when concurrency is involved. Ideally, some criteria is used for selecting test executions that provide sufficient `coverage' of the space of possible executions of a design.
Reference: [13] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: We are currently investigating tradeoffs between expressiveness and analyzability to find a compromise that permits common 11 properties to be naturally expressed and also allows efficient trace checking. Since concurrent systems are often distributed and are inherently nondeterministic, collecting traces and regenerating executions pose difficult research problems <ref> [13, 14, 17, 26] </ref>. We do not plan to develop new techniques in this area, but will evaluate current techniques to find one that is suitable for our purposes.
Reference: [14] <author> Thomas J. LeBlanc and John M. Mellor-Crummey. </author> <title> Debugging parallel programs with instant replay. </title> <booktitle> ACM Symp. Theory of Computing, </booktitle> <address> C-36(4):471-482, </address> <month> April </month> <year> 1987. </year>
Reference-contexts: We are currently investigating tradeoffs between expressiveness and analyzability to find a compromise that permits common 11 properties to be naturally expressed and also allows efficient trace checking. Since concurrent systems are often distributed and are inherently nondeterministic, collecting traces and regenerating executions pose difficult research problems <ref> [13, 14, 17, 26] </ref>. We do not plan to develop new techniques in this area, but will evaluate current techniques to find one that is suitable for our purposes.
Reference: [15] <author> G. Luo, G.V. Bochman, and A.Petrenko. </author> <title> Test selection based on communicating nondeterministic finite state machines using a generalized wp-method. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 20(2) </volume> <pages> 149-162, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: Potential faults detected during analysis of designs might also be used to identify specific synchronization patterns that warrant additional testing. Of particular interest in this regard is the work of Luo, Bochmann and Petrenko <ref> [15] </ref>, in which they generate test sequences for concurrent programs and communication protocols from nondeterministic finite state machines.
Reference: [16] <author> Louise E. Moser, Y. S. Ramakrishna, George Kutty, P. Michael Melliar-Smith, and Laura K. Dillon. </author> <title> A graphical environment for design of concurrent and realtime systems. </title> <note> Submitted. </note>
Reference-contexts: The GIL graphical editor interfaces with all tool components, so that the software engineer works exclusively with graphical formulas. The GIL toolset is the topic of [12]. Experiences with the toolset are reported in <ref> [6, 12, 16, 19] </ref>. 3 Using Specifications During Testing of Designs Testing is a very laborious process, particularly when concurrency is involved. Ideally, some criteria is used for selecting test executions that provide sufficient `coverage' of the space of possible executions of a design.
Reference: [17] <author> Douglas Z. Pan and Mark A. Linton. </author> <title> Supporting reverse execution of parallel programs. </title> <booktitle> In ACM SIGPLAN/SIGOPS Work. Parallel and Distributed Debugging, </booktitle> <pages> pages 124-129, </pages> <year> 1988. </year>
Reference-contexts: We are currently investigating tradeoffs between expressiveness and analyzability to find a compromise that permits common 11 properties to be naturally expressed and also allows efficient trace checking. Since concurrent systems are often distributed and are inherently nondeterministic, collecting traces and regenerating executions pose difficult research problems <ref> [13, 14, 17, 26] </ref>. We do not plan to develop new techniques in this area, but will evaluate current techniques to find one that is suitable for our purposes.
Reference: [18] <author> Y. S. Ramakrishna, Laura K. Dillon, Louise E. Moser, P. Michael Melliar-Smith, and George Kutty. </author> <title> A real-time interval logic and its decision procedure. </title> <booktitle> In Proc. 13th Conf. Foundations of Software Technology and Theoretical Computer Science, volume 761 of Lecture Notes in Computer Science, </booktitle> <pages> pages 173-192, </pages> <address> Bombay, India, </address> <month> December </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: Future research will extend the algorithm for checking timeless traces to timed traces. The extension will entail the introduction of `clocks', modeled after the clocks described in <ref> [1, 18] </ref>, which are started upon locating the left endpoint of an interval that contains a timing constraint. Each clock that is active in a state has an associated `clock condition', which is checked at each state of the interval being timed.
Reference: [19] <author> Y. S. Ramakrishna, P. Michael Melliar-Smith, Louise E. Moser, Laura K. Dillon, and George Kutty. </author> <title> Really visual temporal reasoning. </title> <booktitle> In Proc. 14th IEEE Real-Time Systems Symp., </booktitle> <pages> pages 262-273, </pages> <address> Raleigh-Durham, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: The GIL graphical editor interfaces with all tool components, so that the software engineer works exclusively with graphical formulas. The GIL toolset is the topic of [12]. Experiences with the toolset are reported in <ref> [6, 12, 16, 19] </ref>. 3 Using Specifications During Testing of Designs Testing is a very laborious process, particularly when concurrency is involved. Ideally, some criteria is used for selecting test executions that provide sufficient `coverage' of the space of possible executions of a design.
Reference: [20] <author> Rami R. Razouk and Michael M. Gorlick. </author> <title> A real-time interval logic for reasoning about executions of real-time programs. </title> <booktitle> In Kemmerer [10], </booktitle> <pages> pages 10-19. </pages> <booktitle> ACM SIGSOFT Software Engineering Notes 14(8). </booktitle>
Reference-contexts: Oracles for testing communication protocols can be produced from state transition diagrams [3]. A very powerful (but undecidable) extension of IL, called Real-Time Interval Logic (RIL), was designed for use in testing real-time systems <ref> [20] </ref>. Richardson, Aha and O'Malley argue that oracles based on multiparadigm and multilingual specifications are needed due to the multiparadigm nature of requirements [22]. They use RTL to specify temporal requirements of an elevator system and Z to describe the scheduling of services.
Reference: [21] <author> Debra Richardson, Stephanie Leif Aha, and T. Owen O'Malley. </author> <title> Specification and testing of temporal properties of concurrent system designs. </title> <booktitle> In Kemmerer [10], </booktitle> <pages> pages 86-96. </pages> <booktitle> ACM SIGSOFT Software Engineering Notes 14(8). </booktitle> <pages> 13 </pages>
Reference-contexts: We do not plan to develop new techniques in this area, but will evaluate current techniques to find one that is suitable for our purposes. Specifications can also provide a basis for developing criteria for assessing the adequacy of test sets and for guiding the generation of test data <ref> [21] </ref>. The size of the test sets required when criteria are based on covering the concurrency states of a program grows exponentially with the number of tasks (processes) [27, 28]. Information in a specification can be used to generate more tractable test sets.
Reference: [22] <author> Debra J. Richardson, Stephanie L. Aha, and T. Owen O'Malley. </author> <title> Specification-based test oracles for reactive systems. </title> <booktitle> In Proc. 14th Inter. Conf. Software Engineering, </booktitle> <pages> pages 105-118, </pages> <address> Melbourne, AUS, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: A very powerful (but undecidable) extension of IL, called Real-Time Interval Logic (RIL), was designed for use in testing real-time systems [20]. Richardson, Aha and O'Malley argue that oracles based on multiparadigm and multilingual specifications are needed due to the multiparadigm nature of requirements <ref> [22] </ref>. They use RTL to specify temporal requirements of an elevator system and Z to describe the scheduling of services.
Reference: [23] <author> David Rosenblum. </author> <title> Specifying concurrent system with TSL. </title> <journal> IEEE Software, </journal> <pages> pages 52-61, </pages> <month> May </month> <year> 1991. </year>
Reference: [24] <author> David S. Rosenblum and David C. Luckham. </author> <title> Testing the correctness of tasking supervisors with TSL specifications. </title> <booktitle> In Kemmerer [10], </booktitle> <pages> pages 187-196. </pages>
Reference: [25] <author> R. L. Schwartz, P. M. Melliar-Smith, and F. H. Vogt. </author> <title> An interval logic for higher-level temporal reasoning. </title> <booktitle> In Proc. 2nd ACM Symp. Principles of Distributed Computing, </booktitle> <pages> pages 173-186, </pages> <address> Montreal, Canada, </address> <month> August </month> <year> 1983. </year>
Reference-contexts: However, because model checking requires examination of all reachable system states, it runs into the state explosion problem. Oracles for concurrent systems can be based on any formal specification language with a suitable decision procedure. The IDD debugger for distributed programs uses a subset of Interval Logic (IL) <ref> [25] </ref> for expressing synchronization constraints. IDD checks assertions at runtime, stopping execution if an assertion is violated [9]. The TSL Runtime System monitors executions of Ada tasking programs and checks them for conformance with specifications written in an event-based notation for specifying sequencing constraints [23,24].
Reference: [26] <author> K.C. Tai, R.H. Harver, and E.E. Obaid. </author> <title> Debugging concurrent ada programs by deterministic execution. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 17(1) </volume> <pages> 45-63, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: We are currently investigating tradeoffs between expressiveness and analyzability to find a compromise that permits common 11 properties to be naturally expressed and also allows efficient trace checking. Since concurrent systems are often distributed and are inherently nondeterministic, collecting traces and regenerating executions pose difficult research problems <ref> [13, 14, 17, 26] </ref>. We do not plan to develop new techniques in this area, but will evaluate current techniques to find one that is suitable for our purposes.
Reference: [27] <author> R.N. Taylor, D.L. Levine, and C.D. Kelly. </author> <title> Structural testing of concurrent programs. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 18(3) </volume> <pages> 206-215, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Ideally, some criteria is used for selecting test executions that provide sufficient `coverage' of the space of possible executions of a design. Coverage criteria for designs of concurrent systems must ensure coverage of the design's global synchronization structure <ref> [27, 28] </ref>, which dramatically increases the size of test sets. The test executions must then be examined for correctness. Determining correctness of an execution of a concurrent system requires examination of the temporal ordering and timing of events that occur during the execution. <p> The size of the test sets required when criteria are based on covering the concurrency states of a program grows exponentially with the number of tasks (processes) <ref> [27, 28] </ref>. Information in a specification can be used to generate more tractable test sets. For example, coverage criteria based on the structure of specifications might ensure that important synchronization patterns have been adequately tested, without examining all synchronization patterns.
Reference: [28] <author> Stewart N. Weiss. </author> <title> A formal framework for the study of concurrent program testing. </title> <booktitle> In Proc. SIGSOFT `88 2nd ACM Symp. Software Testing, Analysis, and Verification, </booktitle> <month> July </month> <year> 1988. </year> <month> 14 </month>
Reference-contexts: Ideally, some criteria is used for selecting test executions that provide sufficient `coverage' of the space of possible executions of a design. Coverage criteria for designs of concurrent systems must ensure coverage of the design's global synchronization structure <ref> [27, 28] </ref>, which dramatically increases the size of test sets. The test executions must then be examined for correctness. Determining correctness of an execution of a concurrent system requires examination of the temporal ordering and timing of events that occur during the execution. <p> The size of the test sets required when criteria are based on covering the concurrency states of a program grows exponentially with the number of tasks (processes) <ref> [27, 28] </ref>. Information in a specification can be used to generate more tractable test sets. For example, coverage criteria based on the structure of specifications might ensure that important synchronization patterns have been adequately tested, without examining all synchronization patterns.
References-found: 28

