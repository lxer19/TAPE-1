URL: http://www.pdos.lcs.mit.edu/papers/oam.ps
Refering-URL: http://www.pdos.lcs.mit.edu/PDOS-papers.html
Root-URL: 
Email: fkerr,wchsieh,tuna,kaashoek,weihlg@lcs.mit.edu  
Title: Optimistic Active Messages: A Mechanism for Scheduling Communication with Computation  
Author: Deborah A. Wallach, Wilson C. Hsieh, Kirk L. Johnson, M. Frans Kaashoek, and William E. Weihl 
Address: Cambridge MA 02139, USA  
Affiliation: M.I.T. Laboratory for Computer Science  
Date: July 1995.  
Note: Appears in PPoPP '95,  
Abstract: Low-overhead message passing is critical to the performance of many applications. Active Messages [27] reduce the software overhead for message handling: messages are run as handlers instead of as threads, which avoids the overhead of thread management and the unnecessary data copying of other communication models. Scheduling the execution of Active Messages is typically done by disabling and enabling interrupts, or by polling the network. This primitive scheduling control, combined with the fact that handlers are not schedulable entities, puts severe restrictions on the code that can be run in a message handler. This paper describes a new software mechanism, Optimistic Active Messages (OAM), that eliminates these restrictions; OAMs allow arbitrary user code to execute in handlers, and also allow handlers to block. Despite this gain in expressiveness, OAMs perform as well as Active Messages. We used OAM as the base for an RPC system, Optimistic RPC (ORPC), for the Thinking Machines CM-5 multiprocessor; it consists of an optimized thread package and a stub compiler that hides communication details from the programmer. ORPC is 1.5 to 5 times faster than traditional RPC (TRPC) for small messages and performs as well as Active Messages (AM). Applications that primarily communicate using large data transfers or are fairly coarse-grained perform equally well, independent of whether AMs, ORPCs, or TRPCs are used. For applications that send many short messages, however, the ORPC and AM implementations are up to three times faster than the TRPC implementations. Using ORPC, programmers obtain the benefits of well-proven programming abstractions such as threads, mutexes, and condition variables, do not have to be concerned with communication details, and yet obtain nearly the performance of hand-coded Active Message programs. This work was supported in part by the Advanced Research Projects Agency under contract N00014-94-1-0985, by a NSF National Young Investigator Award, by Project Scout under ARPA contract MDA972-92-J-1032and by a fellowship from the Computer Measurement Group. Weihl was also supported by the Digital Equipment Corporation while on sabbatical at Digital's Systems Research Center. Copyright c fl1995 by the Association for Computing Machinery, Inc. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee providedthat copies are not made or distributed for profit or direct commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Publications Dept., ACM Inc., fax +1 (212) 869-0481, or (permissions@acm.org). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> AGARWAL, A., BIANCHINI, R., CHAIKEN, D., JOHNSON, K. L., KRANZ, D., KUBIATOWICZ, J., LIM, B.-H., MACKENZIE, K., AND YEUNG, D. </author> <title> The MIT Alewife Machine: Architecture and Performance. </title> <booktitle> In Proceedings of the 22nd Annual International Symposium on Computer Architecture (June 1995). To appear. </booktitle>
Reference-contexts: On the CM-5, programmers are helped by a substantial amount of buffering in the network, which allows applications to poll infrequently; on architectures like Alewife <ref> [1] </ref> there is limited buffering in the network, so infrequent polling causes other processors to be blocked very quickly. In short, unless applications are fairly static, writing programs with Active Messages requires carefully orchestrating communication with computation, and sometimes turns into a black art. <p> Coarse-grained applications, or applications that send large messages, perform equally well whether they use ORPC, AM, or RPC. 5 Related work This work generalizes the original Active Messages work of von Eicken et al. [27], which showed that software approaches to fast communication can be effective. Alewife <ref> [1] </ref>, the J-Machine [9], and Tera [2] are examples of hardware-intensive approaches to fast communication and multi- threading. Our approach is a software alternative that does not depend on the existence of hardware thread contexts; Active Mes- sages research indicates that little hardware is needed to integrate computation and communication.
Reference: [2] <author> ALVERSON, R., CALLAHAN, D., CUMMINGS, D., KOBLENZ, B., PORTERFIELD, A., AND SMITH, B. </author> <title> The Tera Computer System. </title> <booktitle> In Proceedings of the International Conference on Supercomputing (Amsterdam, </booktitle> <address> The Netherlands, </address> <month> June </month> <year> 1990), </year> <pages> pp. 272-277. </pages>
Reference-contexts: Alewife [1], the J-Machine [9], and Tera <ref> [2] </ref> are examples of hardware-intensive approaches to fast communication and multi- threading. Our approach is a software alternative that does not depend on the existence of hardware thread contexts; Active Mes- sages research indicates that little hardware is needed to integrate computation and communication.
Reference: [3] <author> BAL, H. E., KAASHOEK, M. F., AND TANENBAUM, A. S. </author> <note> Orca: </note>
Reference-contexts: Our approach can easily be applied to other programming models that create threads for message arrivals: for example, object-oriented parallel systems such as ABCL/f [23], Concurrent Smalltalk [11], Concurrent Aggregates [6], Orca <ref> [3] </ref>, and Prelude [28]. In fact, we have ported the Orca system to the CM-5 and modified the compiler to run simple method calls in handlers using OAMs.
References-found: 3

