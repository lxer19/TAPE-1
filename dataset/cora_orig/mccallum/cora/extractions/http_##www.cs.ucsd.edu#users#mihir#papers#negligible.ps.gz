URL: http://www.cs.ucsd.edu/users/mihir/papers/negligible.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/mihir/papers/negligible.html
Root-URL: http://www.cs.ucsd.edu
Email: E-Mail: mihir@cs.ucsd.edu.  
Title: Note on Negligible Functions  
Author: Mihir Bellare 
Web: URL: http://www-cse.ucsd.edu/users/mihir.  
Date: March 1997  
Address: 9500 Gilman Drive La Jolla, California 92093, USA.  
Affiliation: Dept. of Computer Science Engineering University of California at San Diego  
Note: A  Supported in part by NSF CA REER Award CCR-9624439 and a Packard Foundation Fellowship in Science and Engineering.  
Abstract: Technical Report CS97-529, Department of Computer Science and Engineering, University of Cal- Abstract The notion of a negligible function is used in theoretical cryptography to formalize the notion of a function asymptotically "too small to matter." We claim the issue that really arises is what it might mean for a sequence of functions to be "negligible." We consider (and define) two such notions, and prove them equivalent. Roughly, this enables us to say that any cryptographic primitive has a specific associated "security level." In particular we can say this for any one-way function. We can also reconcile different definitions of negligible error arguments and computational proofs of knowledge that have appeared in the literature. Although there are some cryptographic consequences, the main result is something purely about negligible functions. ifornia at San Diego, March 1997.
Abstract-found: 1
Intro-found: 1
Reference: [BeGo] <author> M. Bellare and O. Goldreich. </author> <title> On Defining Proofs of Knowledge. </title> <booktitle> Advances in Cryptology - Crypto 92 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 740, </volume> <editor> E. Brickell ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Applying the above however we can show that the two formulations are nonetheless equivalent. See Section 4.2. Similarly, we relate two notions of computational proofs of knowledge with negligible knowledge error suggested in <ref> [BeGo] </ref>. See Section 4.3. 1.4 Non-uniform adversaries and uncountability As we indicated above, we wish to associate a function to each adversary, this function being the adversary's success probability, and consider the "negligibility" of the ensuing collection of functions. <p> As in Section 4.2 let P denote the class of all provers being considered. Computational knowledge error. The following general notion of a computational proof of 15 knowledge with knowledge error a function is given in <ref> [BeGo] </ref>. 6 Definition 4.8 [BeGo] We say that verifier V defines a computational proof of knowledge for NP-relation , with knowledge-error , if there is an expected polynomial time oracle algorithm E (the extractor) such that for every prover P 2 P there is a constant n P such that Pr <p> As in Section 4.2 let P denote the class of all provers being considered. Computational knowledge error. The following general notion of a computational proof of 15 knowledge with knowledge error a function is given in <ref> [BeGo] </ref>. 6 Definition 4.8 [BeGo] We say that verifier V defines a computational proof of knowledge for NP-relation , with knowledge-error , if there is an expected polynomial time oracle algorithm E (the extractor) such that for every prover P 2 P there is a constant n P such that Pr [ E P x <p> Negligible knowledge error. Now, it seems natural to say that a computational proof of knowledge with negligible knowledge error is one that has knowledge error , in the above sense, for some negligible function . In other words: Definition 4.9 <ref> [BeGo] </ref> We say that verifier V defines a computational proof of knowledge for NP-relation , with negligible knowledge-error, if there is an expected polynomial time oracle algorithm E (the extractor) and a negligible function such that for every prover P 2 P there is a constant n P such that Pr <p> An alternative is to allow the "knowledge error" to depend on the prover: Definition 4.10 <ref> [BeGo] </ref> We say that verifier V defines a computational proof of knowledge for NP-relation , with negligible knowledge-error, if there is an expected polynomial time oracle algorithm E (the extractor) such that for each prover P 2 P there is a negligible function P such that Pr [ E P x <p> It is suggested in <ref> [BeGo] </ref> that Definition 4.9 is preferable to Definition 4.10. This does seem the case because, like (soundness) error, it is more natural to think of knowledge error as a single function associated to the verifier. <p> For the first, we use Theorem 3.2. For the second, by defining the "best provers", we use Theorem 3.8. The details are omitted. Alternative form. As we mentioned in a previous footnote, the proof of knowledge definitions of <ref> [BeGo] </ref> are formulated in two styles. To be concrete, take Definition 4.8. The other formulation asks that the extractor always succeed as long at Accept P (x) &gt; (jxj), but is allowed an expected running time of n O (1) =(Accept P (x) (jxj)).
Reference: [BJY] <author> M. Bellare, M. Jakobsson and M. Yung. </author> <title> Round-optimal zero-knowledge arguments based on any one-way function. </title> <booktitle> Advances in Cryptology - Eurocrypt 97 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> ??, <editor> W. Fumy ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1997. </year> <note> Available at http://www-cse. ucsd.edu/users/mihir. </note>
Reference-contexts: Error probabilities in protocols. It seems to us natural that the "error probability" in a protocol is a (single) function associated to the verifier. A definition of "negligible error arguments" based on this view is given in <ref> [BJY] </ref>. Earlier, however, other definitions had appeared which did not have this view of error probability in the case of negligible error [Go, NOVY]. Applying the above however we can show that the two formulations are nonetheless equivalent. See Section 4.2. <p> Extending this, the following general definition of an argument with error probability a function * is given in <ref> [BJY] </ref>: Definition 4.4 [BJY] Verifier V is computationally sound for L, with error-probability *, if Acc P ev * for every prover P 2 P. Namely, the acceptance probability of any prover eventually drops below the error probability *. Negligible error arguments. <p> Extending this, the following general definition of an argument with error probability a function * is given in <ref> [BJY] </ref>: Definition 4.4 [BJY] Verifier V is computationally sound for L, with error-probability *, if Acc P ev * for every prover P 2 P. Namely, the acceptance probability of any prover eventually drops below the error probability *. Negligible error arguments. Here we are interested in arguments of negligible error probability. <p> Namely, an argument has negligible error if it has error * for some negligible function *. This is the view adopted in <ref> [BJY] </ref>. The definition amounts to the following: Definition 4.5 [BJY] Verifier V is computationally sound for L, with negligible error-probability, if there is a negligible function * such that Acc P ev * for every prover P 2 P. <p> Namely, an argument has negligible error if it has error * for some negligible function *. This is the view adopted in <ref> [BJY] </ref>. The definition amounts to the following: Definition 4.5 [BJY] Verifier V is computationally sound for L, with negligible error-probability, if there is a negligible function * such that Acc P ev * for every prover P 2 P. However, previous works had given a different definition of negligible error arguments. <p> So F is uniformly negligible by Theorem 3.8, as desired. It remains to verify that M has the claimed properties. But the reasoning is analogous to that in the proof of Theorem 4.3 so we skip it. Thus the definitions of negligible error arguments of [Go, NOVY] and <ref> [BJY] </ref> are equivalent. 4.3 Negligible knowledge error We are in the same setting of polynomially bounded parties as above, but the question now pertains to x 2 L.
Reference: [BrCr] <author> G. Brassard and C. Cr epeau. </author> <title> Non-transitive Transfer of Confidence: A perfect Zero-knowledge Interactive protocol for SAT and Beyond. </title> <booktitle> Proceedings of the 27th Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1986. </year>
Reference-contexts: Preliminaries. We consider a two-party protocol in which a prover attempts to convince a (probabilistic) polynomial time verifier V that their common input x belongs to some underlying language L. We will be looking at the notion of an argument (also called a computationally convincing proof) <ref> [BrCr, BCC] </ref>, so that the prover is a polynomial time algorithm. Fix a verifier V and a language L for all that follows. Let Acc P (x) denote the probability that V accepts in a conversation with P on common input x.
Reference: [BCC] <author> G. Brassard, D. Chaum and C. Cr epeau. </author> <title> Minimum Disclosure Proofs of Knowledge. </title> <journal> J. Computer and System Sciences, </journal> <volume> Vol. 37, </volume> <year> 1988, </year> <pages> pp. 156-189. </pages>
Reference-contexts: Preliminaries. We consider a two-party protocol in which a prover attempts to convince a (probabilistic) polynomial time verifier V that their common input x belongs to some underlying language L. We will be looking at the notion of an argument (also called a computationally convincing proof) <ref> [BrCr, BCC] </ref>, so that the prover is a polynomial time algorithm. Fix a verifier V and a language L for all that follows. Let Acc P (x) denote the probability that V accepts in a conversation with P on common input x.
Reference: [Go] <author> O. Goldreich. </author> <title> Foundations of cryptography: Fragments of a book. </title> <institution> Weizmann Institute of Science, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: A definition of "negligible error arguments" based on this view is given in [BJY]. Earlier, however, other definitions had appeared which did not have this view of error probability in the case of negligible error <ref> [Go, NOVY] </ref>. Applying the above however we can show that the two formulations are nonetheless equivalent. See Section 4.2. Similarly, we relate two notions of computational proofs of knowledge with negligible knowledge error suggested in [BeGo]. <p> The latter is called the "error probability." 13 In defining this error probability, however, one must be a little careful. 5 A definition for the case of error 1=3 is given by Goldreich <ref> [Go, Section 6.8.1] </ref>. Extending this, the following general definition of an argument with error probability a function * is given in [BJY]: Definition 4.4 [BJY] Verifier V is computationally sound for L, with error-probability *, if Acc P ev * for every prover P 2 P. <p> However, previous works had given a different definition of negligible error arguments. The notion proposed by Goldreich <ref> [Go, Section 6.8.1] </ref> and Naor et. al. [NOVY] is the following: Definition 4.6 [Go, NOVY] Verifier V is computationally sound for L, with negligible error-probability, if for every prover P 2 P the function Acc P is negligible. As a notion of security this seems satisfactory. <p> However, previous works had given a different definition of negligible error arguments. The notion proposed by Goldreich [Go, Section 6.8.1] and Naor et. al. [NOVY] is the following: Definition 4.6 <ref> [Go, NOVY] </ref> Verifier V is computationally sound for L, with negligible error-probability, if for every prover P 2 P the function Acc P is negligible. As a notion of security this seems satisfactory. <p> So F is uniformly negligible by Theorem 3.8, as desired. It remains to verify that M has the claimed properties. But the reasoning is analogous to that in the proof of Theorem 4.3 so we skip it. Thus the definitions of negligible error arguments of <ref> [Go, NOVY] </ref> and [BJY] are equivalent. 4.3 Negligible knowledge error We are in the same setting of polynomially bounded parties as above, but the question now pertains to x 2 L.
Reference: [GMR] <author> S. Goldwasser, S. Micali and C. Rackoff. </author> <title> The knowledge complexity of interactive proof systems. </title> <journal> SIAM J. on Computing, </journal> <volume> Vol. 18, No. 1, </volume> <pages> pp. 186-208, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: However we claim that F is pointwise negligible if and only if it is uniformly negligible. This says Definitions 4.5 and 4.6 of computational soundness with negligible error-probability are equivalent. 5 In an interactive proof setting <ref> [GMR] </ref> we would say the error probability is * if for all provers P and all x 62 L the probability that P convinces V to accept x is at most *(jxj).
Reference: [Le] <author> L. Levin. </author> <title> One-way functions and pseudorandom generators. </title> <journal> Combinatorica, </journal> <volume> Vol. 7, No. 4, </volume> <year> 1987, </year> <pages> pp. 357-363. </pages>
Reference-contexts: In other words, every one-way function does have a "specific" associated security level. Or, put another way, the order of the quantifiers does not matter. 2 In asking for a single "security level", this definition is in the style of the definitions of Levin <ref> [Le] </ref> and Luby [Lu]. The latter however measure the quality of inverters via their time to success probability ratios. <p> His solution is used in the proofs of the non-uniform cases. Thanks to Phillip Rogaway and Oded Goldreich for (independently) pointing to the connection with the notion of security of <ref> [Le, Lu] </ref>.
Reference: [Lu] <author> M. Luby. </author> <title> Pseudorandomness and cryptographic applications. </title> <publisher> Princeton Computer Science Notes, Princeton University Press, </publisher> <year> 1996. </year>
Reference-contexts: In other words, every one-way function does have a "specific" associated security level. Or, put another way, the order of the quantifiers does not matter. 2 In asking for a single "security level", this definition is in the style of the definitions of Levin [Le] and Luby <ref> [Lu] </ref>. The latter however measure the quality of inverters via their time to success probability ratios. <p> His solution is used in the proofs of the non-uniform cases. Thanks to Phillip Rogaway and Oded Goldreich for (independently) pointing to the connection with the notion of security of <ref> [Le, Lu] </ref>.
Reference: [NOVY] <author> M. Naor, R. Ostrovsky, R. Venkatasan, M. Yung. </author> <title> Perfect zero knowledge arguments for NP can be based on general complexity assumptions. </title> <booktitle> Advances in Cryptology - Crypto 92 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 740, </volume> <editor> E. Brickell ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <month> 18 </month>
Reference-contexts: A definition of "negligible error arguments" based on this view is given in [BJY]. Earlier, however, other definitions had appeared which did not have this view of error probability in the case of negligible error <ref> [Go, NOVY] </ref>. Applying the above however we can show that the two formulations are nonetheless equivalent. See Section 4.2. Similarly, we relate two notions of computational proofs of knowledge with negligible knowledge error suggested in [BeGo]. <p> However, previous works had given a different definition of negligible error arguments. The notion proposed by Goldreich [Go, Section 6.8.1] and Naor et. al. <ref> [NOVY] </ref> is the following: Definition 4.6 [Go, NOVY] Verifier V is computationally sound for L, with negligible error-probability, if for every prover P 2 P the function Acc P is negligible. As a notion of security this seems satisfactory. <p> However, previous works had given a different definition of negligible error arguments. The notion proposed by Goldreich [Go, Section 6.8.1] and Naor et. al. [NOVY] is the following: Definition 4.6 <ref> [Go, NOVY] </ref> Verifier V is computationally sound for L, with negligible error-probability, if for every prover P 2 P the function Acc P is negligible. As a notion of security this seems satisfactory. <p> So F is uniformly negligible by Theorem 3.8, as desired. It remains to verify that M has the claimed properties. But the reasoning is analogous to that in the proof of Theorem 4.3 so we skip it. Thus the definitions of negligible error arguments of <ref> [Go, NOVY] </ref> and [BJY] are equivalent. 4.3 Negligible knowledge error We are in the same setting of polynomially bounded parties as above, but the question now pertains to x 2 L.
References-found: 9

