URL: ftp://ftp.cs.virginia.edu/pub/techreports/CS-95-16.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: E-mail: fyo5u, song@virginia.edu  
Title: Fixed-Priority Scheduling of Periodic Tasks on Multiprocessor Systems  
Author: Yingfeng Oh and Sang H. Son 
Address: Thornton Hall, Charlottesville, VA 22903, USA  
Affiliation: Department of Computer Science, University of Virginia  
Abstract: Consider the problem of periodic task scheduling, in which we seek to minimize the total number of processors required to execute a set of tasks such that task deadlines are guaranteed by the Rate-Monotonic (or RM) algorithm on each processor. This problem was first investigated by Dhall and Liu, and the previous lowest bound for the problem was 2.0. In this paper, an improved solution is given by designing a new algorithm for it. The algorithm, called RM-First-Fit-Decreasing-Utilization (or RM-FFDU), is shown to have a worst-case tight bound of 5=3 = 1:66 : : :, the lowest upper bound ever derived for the scheduling problem. Simulation studies show that on the average, the new algorithm performs consistently better than those in the literature. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Audsley, A. Burns, M. Richardson, K. Tindell, and A. Wellings. </author> <title> Applying New Scheduling Theory to Static Priority Preemptive Scheduling. </title> <journal> Software Engineering Journal, </journal> <month> September </month> <year> 1993. </year> <month> 33 </month>
Reference-contexts: Another interesting question is to consider tasks which share resources and tasks whose deadlines do not coincide with their periods (see, e.g., <ref> [1] </ref>). These are the issues that we are currently investigating. The rate-monotonic scheduling was first discovered around 1972-1973, and made known to the world in the seminal paper by Liu and Layland in 1973.
Reference: [2] <author> D. J. Brown. </author> <title> A Lower Bound for On-line One-dimensional Bin Packing Algo--rithms. </title> <type> Technical Report TR No. </type> <institution> R-864, Coordinated Science Lab.,University of Illinois, Urbana, IL, </institution> <year> 1979. </year>
Reference-contexts: The First-Fit strategy is a simple, on-line one, and yet it can deliver near-optimal performance. For the classical bin-packing problem, the First-Fit heuristic has a tight bound of 1.7 [12], while no on-line algorithm can have a worst-case bound less than 1.53 <ref> [2, 17] </ref>.
Reference: [3] <author> A. Burchard, J. Liebeherr, Y. Oh, and S. H. Son. </author> <title> Real-Time Tasks to Homogeneous Multiprocessor Systems. </title> <journal> IEEE Transactions on Computers, </journal> <note> to appear. </note>
Reference-contexts: Most recently, Burchard, Liebeherr, Oh, and Son proposed an algorithm called RMGT, that has a worst-case bound of 1.75 <ref> [3] </ref>. Our approach to tackling the problem is to use a recently derived schedulability condition that exhibits good performance while remaining simple enough so that the worst-case performance analysis is still possible. We apply the familiar bin-packing heuristic - First-Fit-Decreasing [11] to allocate tasks to processors.
Reference: [4] <author> E. G. Coffman, M. R. Garey, and D. S. Johnson. </author> <title> Approximate Algorithms for Bin Packing An Updated Survey, 1985. Algorithm Design for Computer System Design, </title> <editor> (49-106) G. Ausiello, M. Lucertinit, and P. Serafini (ed.), </editor> <publisher> Springer-Verlag, </publisher> <address> NY. </address>
Reference-contexts: To assign tasks to processors, variants of well-known bin-packing heuristics can be applied, where processors and tasks are regarded as bins and items, respectively. The 9 bin-packing problem is concerned with packing variable-sized items into fixed-sized bins using the least number of bins (see, e.g., <ref> [4] </ref>). Among the different strategies, the First-Fit strategy has been frequently adapted to solve the various bin-packing problems and is one of the best studied ones. The First-Fit strategy is a simple, on-line one, and yet it can deliver near-optimal performance.
Reference: [5] <author> S. Davari and S. K. Dhall. </author> <title> An On Line Algorithm for Real-Time Allocation. </title> <booktitle> In IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 194-200, </pages> <year> 1986. </year>
Reference-contexts: Unfortunately, the upper bound derived for RMFF was incorrect due to some errors in their proof [19]. Davari and Dhall later considered two other algorithms called First-Fit-Decreasing-Utilization-Factor (or FFDUF) and NEXT-FIT-M (or NF-M) <ref> [5, 6] </ref>. <p> We would like to use this condition in determining the feasibility of a set of tasks, but the performance of the heuristics using this condition in solving the RMMS problem is not as good, as shown by the previous work <ref> [8, 5, 6] </ref>. This is because the condition is a worst-case one; there are some task sets that are feasible with the rate-monotonic algorithm, but cannot be determined to be feasible by the condition. A necessary and sufficient condition has been found for the rate-monotonic algorithm [13, 15].
Reference: [6] <author> S. Davari and S. K. Dhall. </author> <title> On a Periodic Real-Time Task Allocation Problem. </title> <booktitle> In 19th Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 133-141, </pages> <year> 1986. </year>
Reference-contexts: Unfortunately, the upper bound derived for RMFF was incorrect due to some errors in their proof [19]. Davari and Dhall later considered two other algorithms called First-Fit-Decreasing-Utilization-Factor (or FFDUF) and NEXT-FIT-M (or NF-M) <ref> [5, 6] </ref>. <p> We would like to use this condition in determining the feasibility of a set of tasks, but the performance of the heuristics using this condition in solving the RMMS problem is not as good, as shown by the previous work <ref> [8, 5, 6] </ref>. This is because the condition is a worst-case one; there are some task sets that are feasible with the rate-monotonic algorithm, but cannot be determined to be feasible by the condition. A necessary and sufficient condition has been found for the rate-monotonic algorithm [13, 15].
Reference: [7] <author> S. K. Dhall. </author> <title> Scheduling Periodic-Time-Critical Jobs on Single Processor and Multiprocessor Computing Systems. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1977. </year>
Reference-contexts: Since each task has a potentially infinite number of requests, it would be rather time-consuming to manually check that each request finishes before its corresponding deadline. Fortunately, Liu, Layland, and others have provided us with simple schedulability conditions that can be used for that purpose <ref> [18, 20, 7, 19] </ref>. Because the rate-monotonic algorithm is the best fixed-priority algorithm in the same sense as its optimality, and its ease of implementation due to the fixed-priority manner, we will use it in guaranteeing task deadlines on each processor.
Reference: [8] <author> S. K. Dhall and C. L. Liu. </author> <title> On a real-time scheduling problem. </title> <journal> Operations Research, </journal> <volume> 26(1) </volume> <pages> 127-140, </pages> <month> January/February </month> <year> 1978. </year>
Reference-contexts: The measure O (nlogn) denotes the computation time complexity for scheduling a set of n tasks. Dhall and Liu proposed two heuristic algorithms for the scheduling problem: Rate-Monotonic-Next-Fit (or RMNF) and Rate-Monotonic-First-Fit (or RMFF) <ref> [8] </ref>. It was shown that 2:4 &lt; RMNF 2:67, and 2 &lt; RMF F 4fi2 1=3 =(1+2 1=3 ) 2:23. Unfortunately, the upper bound derived for RMFF was incorrect due to some errors in their proof [19]. <p> We would like to use this condition in determining the feasibility of a set of tasks, but the performance of the heuristics using this condition in solving the RMMS problem is not as good, as shown by the previous work <ref> [8, 5, 6] </ref>. This is because the condition is a worst-case one; there are some task sets that are feasible with the rate-monotonic algorithm, but cannot be determined to be feasible by the condition. A necessary and sufficient condition has been found for the rate-monotonic algorithm [13, 15].
Reference: [9] <author> J. D. Gafford. </author> <title> Rate-Monotomic Scheduling. </title> <booktitle> IEEE Micro, </booktitle> <pages> pages 34-39, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The rate-monotonic scheduling discipline has been widely used in a number of applications. For example, it has been specified for use with Space Station on-board software as the means for scheduling multiple independent task execution; it will be built into the on-board operating system <ref> [9] </ref>. Many Ada compilers also support this scheduling discipline [21]. More recently, this scheduling discipline is used to schedule video, audio, and data streams in a multimedia system.
Reference: [10] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-completeness. W.H. </title> <publisher> Freeman and Company, </publisher> <year> 1978. </year>
Reference-contexts: Due to the complexity involved, the analysis of simple approximation methods for the problem represents a constant challenge. It is a common practice to analyze the performance ratio of the algorithm under study when working with approximation algorithms for combinatorial optimization problems <ref> [10] </ref>. Let A (I) denote the performance of a given algorithm for an instance I of a particular combinatorial optimization problem and let OP T (I) denote the performance of an optimal algorithm for the same instance. <p> Hence, any practical solution to the RMMS problem presents a trade-off between computational complexity and performance. It has been shown that heuristic algorithms can deliver near-optimal solutions to NP-complete problems with limited computational overhead <ref> [10] </ref>. Therefore, we seek practical, efficient approximation algorithms for the RMMS problem in hopes of guaranteeing near-optimal results. For the convenience of presentation, we adopt the following notations: processors are numbered in the order consistent with that of allocating them.
Reference: [11] <author> D. S. Johnson. </author> <title> Near-Optimal Bin Packing Algorithms. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1973. </year>
Reference-contexts: Our approach to tackling the problem is to use a recently derived schedulability condition that exhibits good performance while remaining simple enough so that the worst-case performance analysis is still possible. We apply the familiar bin-packing heuristic - First-Fit-Decreasing <ref> [11] </ref> to allocate tasks to processors. In the analysis of the worst-case performance, we not only obtain the upper bound of the algorithm, but also provide examples that show that the bound is tight. <p> By ordering the items according to their decreasing sizes and applying the First-Fit strategy to pack the new list of items, we have the famous First-Fit-Decreasing (or FFD) heuristic, which is clearly off-line and has a tight bound of 11/9 <ref> [11] </ref>. (Note that there are algorithms guaranteed to produce results as close to the optimal result as desired [23, 14], but these algorithms are not practical because the time required to ensure results at most (1 + *) times the optimal result grows extremely fast as * approaches zero.) It has
Reference: [12] <author> D. S. Johnson, A. Demers, J. D. Ullman, M. R. Garey, and R. L. Graham. </author> <title> Worst Case Performance Bounds for Simple One-dimensional Packing Algorithms. </title> <journal> SIAM Journal of Computing, </journal> <volume> 3 </volume> <pages> 299-325, </pages> <year> 1974. </year>
Reference-contexts: The First-Fit strategy is a simple, on-line one, and yet it can deliver near-optimal performance. For the classical bin-packing problem, the First-Fit heuristic has a tight bound of 1.7 <ref> [12] </ref>, while no on-line algorithm can have a worst-case bound less than 1.53 [2, 17].
Reference: [13] <author> M. Joseph and P. Pandya. </author> <title> Finding Response Times in a Real-Time System. </title> <journal> The Computer Journal, </journal> <volume> 29(5) </volume> <pages> 390-395, </pages> <year> 1986. </year> <month> 34 </month>
Reference-contexts: This is because the condition is a worst-case one; there are some task sets that are feasible with the rate-monotonic algorithm, but cannot be determined to be feasible by the condition. A necessary and sufficient condition has been found for the rate-monotonic algorithm <ref> [13, 15] </ref>. It is clear that the upper bound of the performance of a heuristic algorithm using the necessary and sufficient condition is no higher than that of the algorithm using any sufficient condition.
Reference: [14] <author> N. Karmarkar and R. M. Karp. </author> <title> An Efficient Approximate Scheme for the One--dimensional Bin Packing Problem. </title> <booktitle> In 23rd Annual Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 312-320, </pages> <year> 1982. </year>
Reference-contexts: sizes and applying the First-Fit strategy to pack the new list of items, we have the famous First-Fit-Decreasing (or FFD) heuristic, which is clearly off-line and has a tight bound of 11/9 [11]. (Note that there are algorithms guaranteed to produce results as close to the optimal result as desired <ref> [23, 14] </ref>, but these algorithms are not practical because the time required to ensure results at most (1 + *) times the optimal result grows extremely fast as * approaches zero.) It has been known that if the input data are preprocessed and the same heuristic strategy is employed, the performance
Reference: [15] <author> J. P. Lehoczky, L. Sha, and Y. Ding. </author> <title> The Rate-Monotonic Scheduling Algorithm: Exact Characterization and Average Behavior. </title> <booktitle> In IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 166-171, </pages> <year> 1989. </year>
Reference-contexts: This is because the condition is a worst-case one; there are some task sets that are feasible with the rate-monotonic algorithm, but cannot be determined to be feasible by the condition. A necessary and sufficient condition has been found for the rate-monotonic algorithm <ref> [13, 15] </ref>. It is clear that the upper bound of the performance of a heuristic algorithm using the necessary and sufficient condition is no higher than that of the algorithm using any sufficient condition.
Reference: [16] <author> J. Y.-T. Leung and J. Whitehead. </author> <title> On the Complexity of Fixed-Priority Scheduling of Periodic, Real-Time Tasks. Performance Evaluation, </title> <booktitle> 2 </booktitle> <pages> 237-250, </pages> <year> 1982. </year>
Reference-contexts: Since this problem has been proven to NP-complete <ref> [16] </ref>, we shall focus on fast heuristic algorithms for solving it, seeking to prove close bounds on the extent to which they can deviate from optimality. Due to the complexity involved, the analysis of simple approximation methods for the problem represents a constant challenge. <p> While rate-monotonic scheduling is optimal for a uniprocessor system, it is, unfortunately, not so for a multiprocessor system. In fact, the problem of optimally scheduling a set of periodic tasks on a multiprocessor system using either fixed-priority or dynamic priority assignment is known to be NP-complete <ref> [16] </ref>. Hence, any practical solution to the RMMS problem presents a trade-off between computational complexity and performance. It has been shown that heuristic algorithms can deliver near-optimal solutions to NP-complete problems with limited computational overhead [10].
Reference: [17] <author> M. F. Liang. </author> <title> A Lower Bound for On-line Bin Packing. </title> <journal> Information Processing Letters, </journal> <volume> 10(2) </volume> <pages> 76-79, </pages> <year> 1982. </year>
Reference-contexts: The First-Fit strategy is a simple, on-line one, and yet it can deliver near-optimal performance. For the classical bin-packing problem, the First-Fit heuristic has a tight bound of 1.7 [12], while no on-line algorithm can have a worst-case bound less than 1.53 <ref> [2, 17] </ref>.
Reference: [18] <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling Algorithms for Multiprogramming in a Hard Real Time Environment. </title> <journal> Journal of the ACM, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: T i , what is the minimum number of processors required to execute the tasks such that their deadlines are met by the rate-monotonic algorithm? The scheduling problem, referred to as the Rate-Monotonic Multiprocessor Scheduling (or RMMS), is a natural generalization of the uniprocessor periodic task scheduling problem studied in <ref> [18] </ref>. Since this problem has been proven to NP-complete [16], we shall focus on fast heuristic algorithms for solving it, seeking to prove close bounds on the extent to which they can deviate from optimality. <p> We say that a set of tasks is feasible if it can be scheduled by some algorithms such that all task deadlines are met. If a set of periodic tasks can be feasibly scheduled on a single processor using fixed-priority scheduling, then the Rate-Monotonic <ref> [18] </ref> or Intelligent Fixed Priority algorithm [20] is optimal, in the sense that if a set of periodic tasks is feasible with a fixed-priority algorithm, then it is feasible with the rate-monotonic algorithm. In fixed-priority scheduling, the priority of a task remains fixed once it is assigned. <p> Since each task has a potentially infinite number of requests, it would be rather time-consuming to manually check that each request finishes before its corresponding deadline. Fortunately, Liu, Layland, and others have provided us with simple schedulability conditions that can be used for that purpose <ref> [18, 20, 7, 19] </ref>. Because the rate-monotonic algorithm is the best fixed-priority algorithm in the same sense as its optimality, and its ease of implementation due to the fixed-priority manner, we will use it in guaranteeing task deadlines on each processor. <p> This condition is superior to Liu and Layland's condition in performance, since it always yields a processor utilization no lower than that by the Liu and Layland's condition <ref> [18] </ref>. It is also superior to the necessary and sufficient condition in time complexity, since the former runs only in time linear to the number of tasks, while the time complexity of the latter is data-dependent and is at least linear to the number of tasks.
Reference: [19] <author> Y. Oh. </author> <title> The Design and Analysis of Scheduling Algorithms for Real-time and Fault-tolerant Computer Systems. </title> <type> PhD thesis, </type> <institution> University of Virginia, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: It was shown that 2:4 &lt; RMNF 2:67, and 2 &lt; RMF F 4fi2 1=3 =(1+2 1=3 ) 2:23. Unfortunately, the upper bound derived for RMFF was incorrect due to some errors in their proof <ref> [19] </ref>. Davari and Dhall later considered two other algorithms called First-Fit-Decreasing-Utilization-Factor (or FFDUF) and NEXT-FIT-M (or NF-M) [5, 6]. <p> Since each task has a potentially infinite number of requests, it would be rather time-consuming to manually check that each request finishes before its corresponding deadline. Fortunately, Liu, Layland, and others have provided us with simple schedulability conditions that can be used for that purpose <ref> [18, 20, 7, 19] </ref>. Because the rate-monotonic algorithm is the best fixed-priority algorithm in the same sense as its optimality, and its ease of implementation due to the fixed-priority manner, we will use it in guaranteeing task deadlines on each processor. <p> Under the worst-case situation of task utilizations u i , the new condition degrades to the worst-case condition, i.e., i=1 C i =T i n (2 1=n 1) . The proof of the theorem can be found in <ref> [19] </ref>. To assign tasks to processors, variants of well-known bin-packing heuristics can be applied, where processors and tasks are regarded as bins and items, respectively. The 9 bin-packing problem is concerned with packing variable-sized items into fixed-sized bins using the least number of bins (see, e.g., [4]).
Reference: [20] <author> P. </author> <title> Serlin. Scheduling of Time Critical Processes. </title> <booktitle> In Spring Joint Computers Conference, </booktitle> <pages> pages 925-932, </pages> <year> 1972. </year>
Reference-contexts: If a set of periodic tasks can be feasibly scheduled on a single processor using fixed-priority scheduling, then the Rate-Monotonic [18] or Intelligent Fixed Priority algorithm <ref> [20] </ref> is optimal, in the sense that if a set of periodic tasks is feasible with a fixed-priority algorithm, then it is feasible with the rate-monotonic algorithm. In fixed-priority scheduling, the priority of a task remains fixed once it is assigned. <p> Since each task has a potentially infinite number of requests, it would be rather time-consuming to manually check that each request finishes before its corresponding deadline. Fortunately, Liu, Layland, and others have provided us with simple schedulability conditions that can be used for that purpose <ref> [18, 20, 7, 19] </ref>. Because the rate-monotonic algorithm is the best fixed-priority algorithm in the same sense as its optimality, and its ease of implementation due to the fixed-priority manner, we will use it in guaranteeing task deadlines on each processor.
Reference: [21] <author> L. Sha and J. B. Goodenough. </author> <title> Real-time Scheduling Theory and Ada. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 53-66, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Hence, we seek to minimize &lt; A as much as possible in designing a heuristic algorithm. Despite the fact that the rate-monotonic algorithm has become very populous among practitioners in solving many practical problems, and among researchers in generalizing the original results (see, e.g., <ref> [21] </ref>), previous results on the RMMS problem have been limited and the lack of progress in the area has been notable. The best bound was 2.00, which was derived about a decade ago, when the use of multiprocessor was not very common. <p> For example, it has been specified for use with Space Station on-board software as the means for scheduling multiple independent task execution; it will be built into the on-board operating system [9]. Many Ada compilers also support this scheduling discipline <ref> [21] </ref>. More recently, this scheduling discipline is used to schedule video, audio, and data streams in a multimedia system. The rest of the paper is organized as follows: In Section 2, we present the task model upon which the scheduling problem is defined. <p> with regard to most practical real-time applications, researchers through the years have successfully developed a host of scheduling techniques out of this discipline to solve many practical real-time problems, such as task synchronization, bus 6 scheduling, joint scheduling of periodic and aperiodic tasks, transient overload, and parallel processing (see, e.g., <ref> [22, 21] </ref>). The scheduling discipline has proved to be far more powerful than it was expected. While rate-monotonic scheduling is optimal for a uniprocessor system, it is, unfortunately, not so for a multiprocessor system.
Reference: [22] <author> L. Sha, J. P. Lehoczky, and R. Rajkumar. </author> <title> Solutions for Some Practical Problems in Prioritized Preemptive Scheduling. </title> <booktitle> In IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 181-191, </pages> <year> 1986. </year>
Reference-contexts: with regard to most practical real-time applications, researchers through the years have successfully developed a host of scheduling techniques out of this discipline to solve many practical real-time problems, such as task synchronization, bus 6 scheduling, joint scheduling of periodic and aperiodic tasks, transient overload, and parallel processing (see, e.g., <ref> [22, 21] </ref>). The scheduling discipline has proved to be far more powerful than it was expected. While rate-monotonic scheduling is optimal for a uniprocessor system, it is, unfortunately, not so for a multiprocessor system.
Reference: [23] <author> W. Fernandez De La Vega and G. S. Lucker. </author> <title> Bin Packing can be Solved within 1 + * in Linear Time. </title> <journal> Combinatoria, </journal> <volume> 1 </volume> <pages> 349-355, </pages> <year> 1981. </year> <pages> 35 36 37 </pages>
Reference-contexts: sizes and applying the First-Fit strategy to pack the new list of items, we have the famous First-Fit-Decreasing (or FFD) heuristic, which is clearly off-line and has a tight bound of 11/9 [11]. (Note that there are algorithms guaranteed to produce results as close to the optimal result as desired <ref> [23, 14] </ref>, but these algorithms are not practical because the time required to ensure results at most (1 + *) times the optimal result grows extremely fast as * approaches zero.) It has been known that if the input data are preprocessed and the same heuristic strategy is employed, the performance
References-found: 23

