URL: http://www.cs.columbia.edu/~cdo/ssafp96.ps
Refering-URL: http://www.cs.columbia.edu/~cdo/papers.html
Root-URL: http://www.cs.columbia.edu
Email: (e-mail: cokasaki@cs.cmu.edu)  
Title: Functional Data Structures  
Author: Chris Okasaki 
Address: 5000 Forbes Avenue, Pittsburgh, Pennsylvania, USA 15213  
Affiliation: School of Computer Science, Carnegie Mellon University  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Stephen Adams. </author> <title> Efficient sets|a balancing act. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(4) </volume> <pages> 553-561, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: We know by the invariant that if the front list is empty, then so is the rear list, so we avoid the redundant check by using a wildcard. A somewhat cleaner way to write this code is in terms of a pseudo-constructor (also called a smart constructor <ref> [1] </ref>) that enforces the invariant.
Reference: 2. <author> Gerth Sttlting Brodal and Chris Okasaki. </author> <title> Optimal purely functional priority queues. </title> <journal> Journal of Functional Programming, </journal> <volume> 6(6), </volume> <month> December </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: Many other implementations of priority queues can be adapted very easily to a functional setting. For example, King [17] and Okasaki [24] have described functional implementations of binomial queues. Brodal and Okasaki <ref> [2] </ref> 27 functor Pairing1 (structure E : ORDERED) : HEAP = struct structure Elem = E datatype Heap = Empty j Node of Elem.T fi Heap fi Heap susp exception EMPTY val empty = Empty fun isEmpty Empty = true j isEmpty = false fun unit x = Node (x, Empty,
Reference: 3. <author> F. Warren Burton. </author> <title> An efficient functional implementation of FIFO queues. </title> <journal> Information Processing Letters, </journal> <volume> 14(5) </volume> <pages> 205-206, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Thus, queues are perhaps the simplest example of a data structure whose implementation in a functional setting is substantially different from its implementation in an imperative setting. For this reason, functional queues have been widely studied <ref> [11, 9, 3, 23, 24] </ref>. A minimal signature for queues appears in Figure 2. <p> Signature for queues. 3 2.1 A Partial Solution The most common implementation of queues <ref> [9, 3] </ref> is as a pair of lists, one representing the front portion of the queue and the other representing the rear portion of the queue in reverse order. datatype ff Queue = Queue of ff list fi ff list In this representation, the first element of the queue is the <p> Allow at most one debit per stream node, and require that all suspended lists except the last be fully paid off.) 3 2.4 Bibliographic Notes Hood and Melville [11] and Gries [9, pages 250-251] first proposed the implementation of queues in Figure 3. Burton <ref> [3] </ref> proposed a similar implementation, but without the restriction that the first list be non-empty whenever the queue is non-empty. (Burton combines head and tail into a single operation, so he does not need this restriction to support head efficiently.) Hoogerwoord [12] later proposed a similar implementation of deques.
Reference: 4. <author> Seonghun Cho and Sartaj Sahni. </author> <title> Weight biased leftist trees and modified skip lists. </title> <booktitle> In International Computing and Combinatorics Conference, </booktitle> <address> page ??, June 1996. </address>
Reference-contexts: Implement a function makeHeap : Elem.T list ! Heap that produces a leftist heap from an unordered list of elements in O (n) time. (Note that the naive approach of folding insert across the list takes O (n log n) time.) 3 Exercise 19 (Weight-biased Leftist Heaps <ref> [4] </ref>).
Reference: 5. <author> Tyng-Ruey Chuang and Benjamin Goldberg. </author> <title> Real-time deques, multihead Tur-ing machines, and purely functional programming. </title> <booktitle> In Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 289-298, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Hood and Melville [11] also gave a rather complicated implementation of queues supporting all operations in O (1) worst-case time. Hood [10] and Chuang and Goldberg <ref> [5] </ref> later extended this implementation to handle the double-ended case. Okasaki [23] showed how to use lazy evaluation to simplify these implementations, while still retaining the worst-case bounds (see Exercise 7).
Reference: 6. <author> Clark Allan Crane. </author> <title> Linear lists and priority queues as balanced binary trees. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Stanford University, </institution> <month> February </month> <year> 1972. </year> <note> Available as STAN-CS-72-259. </note>
Reference-contexts: For heaps (priority queues), however, many standard imperative solutions translate quite nicely. In Section 4.1, we consider one such example | leftist heaps <ref> [6, 18] </ref>. In Section 4.2, though, we consider a second example | pairing heaps [8] | that is more problematical. 21 heaps are not polymorphic; rather, the type of elements is fixed, as is the ordering relation on those elements. <p> Exercise 20. Design an experiment to test whether the implementation in Figure 14 really does support merge in O (1) amortized time and deleteMin in O (log n) amortized time for non-single-threaded sequences of operations. 3 4.3 Bibliographic Notes Leftist heaps were invented by Crane <ref> [6] </ref>, and first presented in their current form by Knuth [18, pages 150-152]. Nu~nez, Palao, and Pe~na developed a functional implementation of leftist heaps similar to that in Figure 12.
Reference: 7. <author> James R. Driscoll, Neil Sarnak, Daniel D. K. Sleator, and Robert E. Tarjan. </author> <title> Making data structures persistent. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 38(1) </volume> <pages> 86-124, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: A data structure that supports multiple versions is called persistent, while a data structure that allows only a single version at a time is called ephemeral <ref> [7] </ref>. Functional programming languages have the curious property that all data structures are automatically persistent.
Reference: 8. <author> Michael L. Fredman, Robert Sedgewick, Daniel D. K. Sleator, and Robert E. Tar-jan. </author> <title> The pairing heap: A new form of self-adjusting heap. </title> <journal> Algorithmica, </journal> <volume> 1(1) </volume> <pages> 111-129, </pages> <year> 1986. </year>
Reference-contexts: For heaps (priority queues), however, many standard imperative solutions translate quite nicely. In Section 4.1, we consider one such example | leftist heaps [6, 18]. In Section 4.2, though, we consider a second example | pairing heaps <ref> [8] </ref> | that is more problematical. 21 heaps are not polymorphic; rather, the type of elements is fixed, as is the ordering relation on those elements. Not all heap data structures support an efficient merge operation, but we will consider only those that do. <p> Surprisingly, however, tight bounds for pairing heaps are not known. Clearly, unit, findMin, and merge run in O (1) worst-case time, but deleteMin might take as much as O (n) worst-case time. It has been conjectured <ref> [8] </ref> that the amortized running time of merge and deleteMin are O (1) and O (log n) respectively, but, even if true of an imperative implementation, this amortized bound is clearly false in the presence of persistence. Suppose we call deleteMin on some pairing heap h = Node (x, cs). <p> Nu~nez, Palao, and Pe~na developed a functional implementation of leftist heaps similar to that in Figure 12. Fredman, Sedgewick, Sleator, and Tarjan introduced pairing heaps in <ref> [8] </ref>, and conjectured that insert and merge run in O (1) amortized time, while deleteMin runs in O (log n) amortized time.
Reference: 9. <editor> David Gries. </editor> <booktitle> The Science of Programming. Texts and Monographs in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1981. </year>
Reference-contexts: Thus, queues are perhaps the simplest example of a data structure whose implementation in a functional setting is substantially different from its implementation in an imperative setting. For this reason, functional queues have been widely studied <ref> [11, 9, 3, 23, 24] </ref>. A minimal signature for queues appears in Figure 2. <p> Signature for queues. 3 2.1 A Partial Solution The most common implementation of queues <ref> [9, 3] </ref> is as a pair of lists, one representing the front portion of the queue and the other representing the rear portion of the queue in reverse order. datatype ff Queue = Queue of ff list fi ff list In this representation, the first element of the queue is the <p> Allow at most one debit per stream node, and require that all suspended lists except the last be fully paid off.) 3 2.4 Bibliographic Notes Hood and Melville [11] and Gries <ref> [9, pages 250-251] </ref> first proposed the implementation of queues in Figure 3.
Reference: 10. <author> Robert Hood. </author> <title> The Efficient Implementation of Very-High-Level Programming Language Constructs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> August </month> <year> 1982. </year> <type> (Cornell TR 82-503). </type>
Reference-contexts: Hood and Melville [11] also gave a rather complicated implementation of queues supporting all operations in O (1) worst-case time. Hood <ref> [10] </ref> and Chuang and Goldberg [5] later extended this implementation to handle the double-ended case. Okasaki [23] showed how to use lazy evaluation to simplify these implementations, while still retaining the worst-case bounds (see Exercise 7).
Reference: 11. <author> Robert Hood and Robert Melville. </author> <title> Real-time queue operations in pure Lisp. </title> <journal> Information Processing Letters, </journal> <volume> 13(2) </volume> <pages> 50-53, </pages> <month> November </month> <year> 1981. </year>
Reference-contexts: Thus, queues are perhaps the simplest example of a data structure whose implementation in a functional setting is substantially different from its implementation in an imperative setting. For this reason, functional queues have been widely studied <ref> [11, 9, 3, 23, 24] </ref>. A minimal signature for queues appears in Figure 2. <p> Allow at most one debit per stream node, and require that all suspended lists except the last be fully paid off.) 3 2.4 Bibliographic Notes Hood and Melville <ref> [11] </ref> and Gries [9, pages 250-251] first proposed the implementation of queues in Figure 3. <p> Hood and Melville <ref> [11] </ref> also gave a rather complicated implementation of queues supporting all operations in O (1) worst-case time. Hood [10] and Chuang and Goldberg [5] later extended this implementation to handle the double-ended case.
Reference: 12. <author> Rob R. Hoogerwoord. </author> <title> A symmetric set of efficient list operations. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(4) </volume> <pages> 505-513, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Burton [3] proposed a similar implementation, but without the restriction that the first list be non-empty whenever the queue is non-empty. (Burton combines head and tail into a single operation, so he does not need this restriction to support head efficiently.) Hoogerwoord <ref> [12] </ref> later proposed a similar implementation of deques. Hood and Melville [11] also gave a rather complicated implementation of queues supporting all operations in O (1) worst-case time. Hood [10] and Chuang and Goldberg [5] later extended this implementation to handle the double-ended case.
Reference: 13. <author> John Hughes. </author> <title> A novel representation of lists and its application to the function "reverse". </title> <journal> Information Processing Letters, </journal> <volume> 22(3) </volume> <pages> 141-144, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: makeCat : ff list ! ff Cat that runs in O (1) amortized time. (b) Write a function flatten : ff list list ! ff Cat that runs in O (1+E) amortized time, where E is the number of empty lists in the original list. 3 3.3 Bibliographic Notes Hughes <ref> [13, 14] </ref> has investigated several implementations of catenable lists, including ones similar to Figure 7. However, he does not support efficient head and tail operations; rather, he supplies a single operation for converting a catenable list to an ordinary list.
Reference: 14. <author> John Hughes. </author> <title> The design of a pretty-printing library. </title> <booktitle> In First International Spring School on Advanced Functional Programming Techniques, volume 519 of LNCS, </booktitle> <pages> pages 53-96. </pages> <publisher> Springer-Verlag, </publisher> <month> May </month> <year> 1995. </year>
Reference-contexts: makeCat : ff list ! ff Cat that runs in O (1) amortized time. (b) Write a function flatten : ff list list ! ff Cat that runs in O (1+E) amortized time, where E is the number of empty lists in the original list. 3 3.3 Bibliographic Notes Hughes <ref> [13, 14] </ref> has investigated several implementations of catenable lists, including ones similar to Figure 7. However, he does not support efficient head and tail operations; rather, he supplies a single operation for converting a catenable list to an ordinary list.
Reference: 15. <author> Douglas W. Jones. </author> <title> An empirical comparison of priority-queue and event-set implementations. </title> <journal> Communications of the ACM, </journal> <volume> 29(4) </volume> <pages> 300-311, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: In practice, pairing heaps are among the fastest of all imperative priority queues <ref> [15, 19, 21] </ref>. Since pairing heaps are also among the simplest of priority queues, they are the data structure of choice for many applications. Surprisingly, however, tight bounds for pairing heaps are not known. <p> Stasko and Vitter [26] proved that the bounds on insert and deleteMin did in fact hold for a variant of pairing heaps, but they did not consider the merge operation. Several studies have shown that pairing heaps are among the fastest implementations of priority queues in practice <ref> [15, 19, 21] </ref>. Many other implementations of priority queues can be adapted very easily to a functional setting. For example, King [17] and Okasaki [24] have described functional implementations of binomial queues.
Reference: 16. <author> Haim Kaplan and Robert E. Tarjan. </author> <title> Persistent lists with catenation via recursive slow-down. </title> <booktitle> In ACM Symposium on Theory of Computing, </booktitle> <pages> pages 93-102, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Okasaki [23] showed how to use lazy evaluation to simplify these implementations, while still retaining the worst-case bounds (see Exercise 7). The implementation in Figure 4 is a simplification of this approach, first appearing in [24] Kaplan and Tarjan <ref> [16] </ref> proposed yet another implementation of constant--time functional deques, based on an entirely different technique known as recursive slowdown. 3 Catenable Lists Appending lists is an extremely common operation, at least conceptually. Unfortunately, appending lists can be slow. <p> However, he does not support efficient head and tail operations; rather, he supplies a single operation for converting a catenable list to an ordinary list. This is comparable to requiring that all of the appends precede all the heads and tails. Kaplan and Tarjan <ref> [16] </ref> gave the first functional implementation of catenable lists to support all operations in O (1) worst-case time, based on the technique of recursive slowdown. Shortly thereafter, Okasaki [22] developed the implementation in Figure 10. <p> Functional data structures are not of interest only to functional programmers. Functional languages provide a convenient framework for designing persistent 28 data structures. If desired, these data structures can then be implemented in imperative languages. In fact, for some problems, such as catenable lists <ref> [16, 22] </ref>, the best known persistent solutions were designed in exactly this way.
Reference: 17. <author> David J. King. </author> <title> Functional binomial queues. </title> <booktitle> In Glasgow Workshop on Functional Programming, </booktitle> <pages> pages 141-150, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Several studies have shown that pairing heaps are among the fastest implementations of priority queues in practice [15, 19, 21]. Many other implementations of priority queues can be adapted very easily to a functional setting. For example, King <ref> [17] </ref> and Okasaki [24] have described functional implementations of binomial queues.
Reference: 18. <author> Donald E. Knuth. </author> <title> Searching and Sorting, </title> <booktitle> volume 3 of The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1973. </year> <month> 29 </month>
Reference-contexts: For heaps (priority queues), however, many standard imperative solutions translate quite nicely. In Section 4.1, we consider one such example | leftist heaps <ref> [6, 18] </ref>. In Section 4.2, though, we consider a second example | pairing heaps [8] | that is more problematical. 21 heaps are not polymorphic; rather, the type of elements is fixed, as is the ordering relation on those elements. <p> to test whether the implementation in Figure 14 really does support merge in O (1) amortized time and deleteMin in O (log n) amortized time for non-single-threaded sequences of operations. 3 4.3 Bibliographic Notes Leftist heaps were invented by Crane [6], and first presented in their current form by Knuth <ref> [18, pages 150-152] </ref>. Nu~nez, Palao, and Pe~na developed a functional implementation of leftist heaps similar to that in Figure 12.
Reference: 19. <author> Andrew M. Liao. </author> <title> Three priority queue applications revisited. </title> <journal> Algorithmica, </journal> <volume> 7(4) </volume> <pages> 415-427, </pages> <year> 1992. </year>
Reference-contexts: In practice, pairing heaps are among the fastest of all imperative priority queues <ref> [15, 19, 21] </ref>. Since pairing heaps are also among the simplest of priority queues, they are the data structure of choice for many applications. Surprisingly, however, tight bounds for pairing heaps are not known. <p> Stasko and Vitter [26] proved that the bounds on insert and deleteMin did in fact hold for a variant of pairing heaps, but they did not consider the merge operation. Several studies have shown that pairing heaps are among the fastest implementations of priority queues in practice <ref> [15, 19, 21] </ref>. Many other implementations of priority queues can be adapted very easily to a functional setting. For example, King [17] and Okasaki [24] have described functional implementations of binomial queues.
Reference: 20. <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: The emphasis will always be on developing data structures that achieve a good compromise between simplicity and efficiency in practice. Notation We will present all source code in Standard ML <ref> [20] </ref>, extended with the following primitives for lazy evaluation: type ff susp val delay : (unit ! ff) ! ff susp val force : ff susp ! ff These primitives are actually supported by several implementations of Standard ML, including Standard ML of New Jersey.
Reference: 21. <author> Bernard M. E. Moret and Henry D. Shapiro. </author> <title> An empirical analysis of algorithms for constructing a minimum spanning tree. </title> <booktitle> In Workshop on Algorithms and Data Structures, volume 519 of LNCS, </booktitle> <pages> pages 400-411. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: In practice, pairing heaps are among the fastest of all imperative priority queues <ref> [15, 19, 21] </ref>. Since pairing heaps are also among the simplest of priority queues, they are the data structure of choice for many applications. Surprisingly, however, tight bounds for pairing heaps are not known. <p> Stasko and Vitter [26] proved that the bounds on insert and deleteMin did in fact hold for a variant of pairing heaps, but they did not consider the merge operation. Several studies have shown that pairing heaps are among the fastest implementations of priority queues in practice <ref> [15, 19, 21] </ref>. Many other implementations of priority queues can be adapted very easily to a functional setting. For example, King [17] and Okasaki [24] have described functional implementations of binomial queues.
Reference: 22. <author> Chris Okasaki. Amortization, </author> <title> lazy evaluation, and persistence: Lists with catenation via lazy linking. </title> <booktitle> In IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 646-654, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Many applications obey this restriction, but for a general-purpose queue library, we would prefer an implementation that is efficient even when used persistently. As discussed in <ref> [22, 24] </ref>, lazy evaluation is the key to integrating amortization and persistence. <p> 1 if i &lt; m 0 if i &gt; m 2m + 1 if i m This distribution violates the invariant at both node 0 and node m, but discharging the debit on the first node restores the invariant. 2 This proof uses a debit argument in the style of <ref> [22, 24] </ref> instead of a traditional credit argument [27]. Debit arguments are more suitable for analyzing persistent data structures because, although a single credit cannot be spent more than once, it does no harm to discharge the same debit more than once. <p> This is comparable to requiring that all of the appends precede all the heads and tails. Kaplan and Tarjan [16] gave the first functional implementation of catenable lists to support all operations in O (1) worst-case time, based on the technique of recursive slowdown. Shortly thereafter, Okasaki <ref> [22] </ref> developed the implementation in Figure 10. This implementation is much simpler than Kaplan and Tar jan's approach, but supports all operations in O (1) amortized time, rather than worst-case time. 4 Heaps For queues and catenable lists, the usual imperative implementations do not translate well to a functional setting. <p> Functional data structures are not of interest only to functional programmers. Functional languages provide a convenient framework for designing persistent 28 data structures. If desired, these data structures can then be implemented in imperative languages. In fact, for some problems, such as catenable lists <ref> [16, 22] </ref>, the best known persistent solutions were designed in exactly this way.
Reference: 23. <author> Chris Okasaki. </author> <title> Simple and efficient purely functional queues and deques. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(4) </volume> <pages> 583-592, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Thus, queues are perhaps the simplest example of a data structure whose implementation in a functional setting is substantially different from its implementation in an imperative setting. For this reason, functional queues have been widely studied <ref> [11, 9, 3, 23, 24] </ref>. A minimal signature for queues appears in Figure 2. <p> Be careful to make rotations as lazy as possible. You may need to extend the streams library with a few extra operations. (b) Use a debit argument to prove that your deques require only O (1) amor tized time per operation. 3 Exercise 7 (Worst-case Queues <ref> [23] </ref>). To get queues that run in O (1) worst-case time instead of O (1) amortized time, we systematically schedule the execution of each suspension. <p> Hood and Melville [11] also gave a rather complicated implementation of queues supporting all operations in O (1) worst-case time. Hood [10] and Chuang and Goldberg [5] later extended this implementation to handle the double-ended case. Okasaki <ref> [23] </ref> showed how to use lazy evaluation to simplify these implementations, while still retaining the worst-case bounds (see Exercise 7).
Reference: 24. <author> Chris Okasaki. </author> <title> The role of lazy evaluation in amortized data structures. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 62-72, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Thus, queues are perhaps the simplest example of a data structure whose implementation in a functional setting is substantially different from its implementation in an imperative setting. For this reason, functional queues have been widely studied <ref> [11, 9, 3, 23, 24] </ref>. A minimal signature for queues appears in Figure 2. <p> Many applications obey this restriction, but for a general-purpose queue library, we would prefer an implementation that is efficient even when used persistently. As discussed in <ref> [22, 24] </ref>, lazy evaluation is the key to integrating amortization and persistence. <p> 1 if i &lt; m 0 if i &gt; m 2m + 1 if i m This distribution violates the invariant at both node 0 and node m, but discharging the debit on the first node restores the invariant. 2 This proof uses a debit argument in the style of <ref> [22, 24] </ref> instead of a traditional credit argument [27]. Debit arguments are more suitable for analyzing persistent data structures because, although a single credit cannot be spent more than once, it does no harm to discharge the same debit more than once. <p> Okasaki [23] showed how to use lazy evaluation to simplify these implementations, while still retaining the worst-case bounds (see Exercise 7). The implementation in Figure 4 is a simplification of this approach, first appearing in <ref> [24] </ref> Kaplan and Tarjan [16] proposed yet another implementation of constant--time functional deques, based on an entirely different technique known as recursive slowdown. 3 Catenable Lists Appending lists is an extremely common operation, at least conceptually. Unfortunately, appending lists can be slow. <p> Several studies have shown that pairing heaps are among the fastest implementations of priority queues in practice [15, 19, 21]. Many other implementations of priority queues can be adapted very easily to a functional setting. For example, King [17] and Okasaki <ref> [24] </ref> have described functional implementations of binomial queues.
Reference: 25. <author> David A. Schmidt. </author> <title> Detecting global variables in denotational specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(2) </volume> <pages> 299-310, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: this argument, we see that every queue operation requires only O (1) amortized time. 5 Unfortunately, traditional analysis techniques for amortization were devel-oped in an imperative setting and rely on a hidden assumption that all data structures are ephemeral, that is, that sequences of operations on data structures are single-threaded <ref> [25] </ref>. However, this assumption is routinely violated in a functional setting, where all data structures are automatically persistent. In the next section, we modify this implementation of queues to support persistence efficiently and introduce a proof technique for proving amortized bounds for persistent data structures. Exercise 2.
Reference: 26. <author> John T. Stasko and Jeffrey S. Vitter. </author> <title> Pairing heaps: experiments and analysis. </title> <journal> Communications of the ACM, </journal> <volume> 30(3) </volume> <pages> 234-249, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: Fredman, Sedgewick, Sleator, and Tarjan introduced pairing heaps in [8], and conjectured that insert and merge run in O (1) amortized time, while deleteMin runs in O (log n) amortized time. Stasko and Vitter <ref> [26] </ref> proved that the bounds on insert and deleteMin did in fact hold for a variant of pairing heaps, but they did not consider the merge operation. Several studies have shown that pairing heaps are among the fastest implementations of priority queues in practice [15, 19, 21].
Reference: 27. <author> Robert E. Tarjan. </author> <title> Amortized computational complexity. </title> <journal> SIAM Journal on Algebraic and Discrete Methods, </journal> <volume> 6(2) </volume> <pages> 306-318, </pages> <month> April </month> <year> 1985. </year> <title> This article was processed using the L a T E X macro package with LLNCS style 30 </title>
Reference-contexts: A common, but not always efficient, implementation of queues. This implementation is easy to analyze using traditional techniques of amortization <ref> [27] </ref>. The basic idea is to save a credit with every snoc operation. Then, every queue has a number of credits equal to the length of the rear list and these credits can be used to pay for reversing the rear list when the front list becomes empty. <p> &gt; m 2m + 1 if i m This distribution violates the invariant at both node 0 and node m, but discharging the debit on the first node restores the invariant. 2 This proof uses a debit argument in the style of [22, 24] instead of a traditional credit argument <ref> [27] </ref>. Debit arguments are more suitable for analyzing persistent data structures because, although a single credit cannot be spent more than once, it does no harm to discharge the same debit more than once.
References-found: 27

