URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/widom-cc-federated.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/
Root-URL: http://www.cs.berkeley.edu
Email: grefen@cs.utwente.nl widom@cs.stanford.edu  
Title: Integrity Constraint Checking in Federated Databases  
Author: Paul Grefen Jennifer Widom 
Address: 7500 AE Enschede, The Netherlands Stanford, CA 94305-2140 USA  
Affiliation: Department of Computer Science Department of Computer Science University of Twente Stanford University  
Abstract: We study the problem of monitoring integrity constraints in loosely-coupled federated databases, where global queries, global transaction mechanisms, and global concurrency control are unavailable. A family of constraint checking protocols for federated databases is developed and analyzed. The differences across protocols are with respect to the requirements of the underlying systems, the level of constraint checking guaranteed by the protocols, and the processing and communication costs. Thus, we offer a suite of options from which a protocol can be chosen to suit the capabilities and requirements of a particular federated database application.
Abstract-found: 1
Intro-found: 1
Reference: [BGM92] <author> D. Barbara and H. Garcia-Molina. </author> <title> The Demarcation Protocol: A technique for maintaining linear arithmetic constraints in distributed database systems. </title> <booktitle> In Advances in Database Technology|EDBT '92, Lecture Notes in Computer Science 580, </booktitle> <pages> pages 373-388. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: A few recent papers have addressed the issue of monitoring constraints in loosely-coupled, distributed, and sometimes heterogeneous database environments. One class of work involves local constraint checking|deriving tests whose success over one database implies the validity of a multidatabase constraint <ref> [BGM92, GSUW94, GW93] </ref>. Local tests optimize the constraint checking process, but they still require a conventional (non-local) method when the local test fails. As will be seen, in this paper we develop protocols that integrate local checking with non-local methods.
Reference: [BGMS92] <author> Y. Breitbart, H. Garcia-Molina, and A. Silberschatz. </author> <title> Overview of multidatabase transaction management. </title> <journal> VLDB Journal, </journal> <volume> 1(2), </volume> <month> October </month> <year> 1992. </year>
Reference-contexts: Since these approaches rely on global services that typically are unavailable in federated databases, they are inappropriate for the environment we consider. Note that some approaches focus on relaxing the traditional notion of transaction serializability for constraints in distributed environments, e.g. <ref> [BGMS92, Elm91] </ref>, but some level of locking and global query facilities is still expected. A few recent papers have addressed the issue of monitoring constraints in loosely-coupled, distributed, and sometimes heterogeneous database environments.
Reference: [BLT86] <author> J.A. Blakeley, P.-A. Larson, and F.W. Tompa. </author> <title> Efficiently updating materialized views. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 61-71, </pages> <address> Washington, D.C., </address> <month> June </month> <year> 1986. </year>
Reference-contexts: This class of constraints includes many of the most common constraint types, such as referential integrity and mutual exclusion. The problem of incremental constraint checking has been studied extensively (see, e.g., <ref> [BLT86, Nic82, RCBB89, QW91, Ull89] </ref>). The protocols we present can be extended in a straightforward way to more than two relations; the two-relation restriction is adopted for clarity and brevity only.
Reference: [BM93] <author> O. Babaoglu and K. Marzullo. </author> <title> Consistent global states of distributed systems: Fundamental concepts and mechanisms. </title> <editor> In S. Mullender, editor, </editor> <booktitle> Distributed Systems. </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: Finally, we note that in the field of distributed (operating) systems there has been considerable work in the area of snapshots and consistent global states; see e.g. <ref> [CL85, BM93] </ref>. Although this work appears highly related to the problem we are addressing, there are two significant differences: (1) The conditions to be evaluated in the distributed system setting are stable, meaning that 2 once the condition becomes valid, it stays valid. <p> In addition, we are currently investigating whether we can adapt our protocols so that logical clocks <ref> [BM93, Lam78] </ref> are sufficient. 3.5 The Transaction Remote Transaction Protocol (TRT) The TRQ and SRQ protocols add timestamping to the DRQ protocol in order to achieve accuracy. This corresponds to one dimension in the protocol space of Figure 2. The next dimension we consider is transactions. <p> repair, how repair should be specified, how it should take place, what the requirements, properties, and costs are, etc. * Consider more carefully the protocols identified by Table 9 that we have not studied but that may be applicable for certain environments. * Consider whether we can use logical clocks <ref> [BM93, Lam78] </ref> instead of timestamps for those protocols currently relying on synchronized time services. * Adapt our protocols for constraints that span more than two databases, and for constraints that may not always have a straightforward incremental check.
Reference: [CFPT94] <author> S. Ceri, P. Fraternali, S. Paraboschi, and L. Tanca. </author> <title> Automatic generation of production rules for integrity maintenance. </title> <note> To appear in ACM Transactions on Database Systems, </note> <year> 1994. </year>
Reference-contexts: Even in traditional centralized databases, constraint repair is an important topic of current research (e.g. <ref> [CFPT94, GL93] </ref>). In federated databases the problem becomes even more difficult.
Reference: [CGMW94] <author> S. Chawathe, H. Garcia-Molina, and J. Widom. </author> <title> Flexible constraint management for autonomous distributed databases. </title> <journal> IEEE Data Engineering Bulletin, Special Issue on Database Constraint Management, </journal> <volume> 17(2) </volume> <pages> 23-27, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Local tests optimize the constraint checking process, but they still require a conventional (non-local) method when the local test fails. As will be seen, in this paper we develop protocols that integrate local checking with non-local methods. In <ref> [CGMW94] </ref>, a framework is defined for constraint management in loosely-coupled, highly heterogeneous environments. The focus in [CGMW94] is on maintaining constraints across systems that have varying capabilities and varying "willingness" to participate in constraint checking protocols, on describing the timing properties associated with constraint checking, and on more "relaxed" notions of <p> As will be seen, in this paper we develop protocols that integrate local checking with non-local methods. In <ref> [CGMW94] </ref>, a framework is defined for constraint management in loosely-coupled, highly heterogeneous environments. The focus in [CGMW94] is on maintaining constraints across systems that have varying capabilities and varying "willingness" to participate in constraint checking protocols, on describing the timing properties associated with constraint checking, and on more "relaxed" notions of constraint consistency than we consider here. <p> Table 5: SRQ Protocol DB R DB S 6 R " t S " t Q (R; S) hQ (R; S); t 1 i hstatus; t 3 i constraint managers, it is necessary to guarantee that delta notifications from database systems are always received within a certain maximum delay t <ref> [CGMW94] </ref>. For this scenario we have designed the Semi-timestamped Remote Query Protocol (SRQ). SRQ is specified in Table 5 and depicted in SRQ protocol is very similar to the TRQ protocol, except the determination of whether updates may have "conflicted" must take into account the notification delays t .
Reference: [CL85] <author> K.M. Chandy and L. Lamport. </author> <title> Distributed snapshots: Determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <year> 1985. </year>
Reference-contexts: Finally, we note that in the field of distributed (operating) systems there has been considerable work in the area of snapshots and consistent global states; see e.g. <ref> [CL85, BM93] </ref>. Although this work appears highly related to the problem we are addressing, there are two significant differences: (1) The conditions to be evaluated in the distributed system setting are stable, meaning that 2 once the condition becomes valid, it stays valid.
Reference: [CW93] <author> S. Ceri and J. Widom. </author> <title> Managing semantic heterogeneity with production rules and persistent queues. </title> <booktitle> In Proceedings of the Nineteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 108-119, </pages> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: The issue of maintaining consistency of replicated data across loosely-coupled, semantically heterogeneous databases has been considered in, e.g. <ref> [CW93, RSK91] </ref>. Our constraint checking problem can be seen as a special case (or first step) of the consistency maintenance problem. In [CW93], a method is described that relies on active rules and persistent queues. The approach is similar to the simplest in our family of protocols. <p> The issue of maintaining consistency of replicated data across loosely-coupled, semantically heterogeneous databases has been considered in, e.g. [CW93, RSK91]. Our constraint checking problem can be seen as a special case (or first step) of the consistency maintenance problem. In <ref> [CW93] </ref>, a method is described that relies on active rules and persistent queues. The approach is similar to the simplest in our family of protocols. Similar issues are addressed in [RSK91], but no specific protocols are provided.
Reference: [DHW94] <author> U. Dayal, E.N. Hanson, and J. Widom. </author> <title> Active database systems. </title> <editor> In W. Kim, editor, </editor> <title> Modern Database Systems: The Object Model, Interoperability, and Beyond. </title> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1994. </year>
Reference-contexts: Notifications might be sent at the end of each transaction, or they could be sent more frequently or less frequently. The notification frequency determines the granularity of constraint checking. The notification mechanism can easily be supported by triggers or active rules, which are present in many systems <ref> [DHW94] </ref>. If triggers or active rules are not supported, then periodic polling may be substituted. The database systems in the federation are autonomous, in that global queries, global transactions, and global concurrency control mechanisms are not available. A message-passing interface connects the two sites. <p> This approach also requires that the database system is capable of 14 performing a notification and waiting for an acknowledgment, all within a single transaction. This capability is provided by most database systems supporting triggers or active rules <ref> [DHW94] </ref>. Once CM R has received the delta notification, it sends the appropriate query to DB S , to be executed within its own transaction t 0 at DB S . During execution of the query, t 0 will hold a shared lock (S-lock) on S.
Reference: [Elm91] <author> A. Elmagarmid, </author> <title> editor. </title> <journal> Special Issue on Unconventional Transaction Management, Data Engineering Bulletin 14(1), </journal> <month> March </month> <year> 1991. </year>
Reference-contexts: Since these approaches rely on global services that typically are unavailable in federated databases, they are inappropriate for the environment we consider. Note that some approaches focus on relaxing the traditional notion of transaction serializability for constraints in distributed environments, e.g. <ref> [BGMS92, Elm91] </ref>, but some level of locking and global query facilities is still expected. A few recent papers have addressed the issue of monitoring constraints in loosely-coupled, distributed, and sometimes heterogeneous database environments.
Reference: [GA90] <author> P.W.P.J. Grefen and P.M.G. Apers. </author> <title> Parallel handling of integrity constraints on fragmented relations. </title> <booktitle> In Proceedings of the International Symposium on Databases in Parallel and Distributed Systems, </booktitle> <address> Dublin, Ireland, </address> <year> 1990. </year>
Reference-contexts: family to be chosen and tailored for the capabilities and requirements of a particular federated database application. 1.1 Related Work Most work addressing the problem of integrity constraint checking in multidatabase environments has considered tightly-coupled distributed databases in which global queries, global transactions, and global concurrency control are present, e.g. <ref> [GA90, Qia89, SV86] </ref>. Since these approaches rely on global services that typically are unavailable in federated databases, they are inappropriate for the environment we consider.
Reference: [GA93] <author> P.W.P.J. Grefen and P.M.G. Apers. </author> <title> Integrity control in relational database systems an overview. </title> <journal> Journal of Data & Knowledge Engineering, </journal> <volume> 10(2), </volume> <year> 1993. </year>
Reference-contexts: If a constraint is violated, then the transaction may be aborted, the constraint may be corrected automatically, or some error condition may be raised <ref> [GA93] </ref>. Unfortunately, the lack fl This work was supported at Stanford by ARPA Contract F33615-93-1-1339, by the Anderson Faculty Scholar Fund, and by equipment grants from Digital Equipment Corporation and IBM Corporation. The U.S. Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation thereon. <p> We assume that constraints are expressed as queries, where the constraint evaluates to true iff the query result is empty. (This is a relatively standard and convenient formulation of constraints <ref> [GSUW94, GA93] </ref> and usually is equivalent to constraints expressed as logical formulae.) Hence, we denote a constraint C over relations R and S as a query Q (R; S).
Reference: [GL93] <author> M. Gertz and U.W. Lipeck. </author> <title> Deriving integrity maintaining triggers from transition graphs. </title> <booktitle> In Proceedings of the Ninth International Conference on Data Engineering, </booktitle> <pages> pages 22-29, </pages> <address> Vienna, Austria, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: Even in traditional centralized databases, constraint repair is an important topic of current research (e.g. <ref> [CFPT94, GL93] </ref>). In federated databases the problem becomes even more difficult.
Reference: [GSUW94] <author> A. Gupta, Y. Sagiv, J.D. Ullman, and J. Widom. </author> <title> Constraint checking with partial information. </title> <booktitle> In Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 45-55, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: A few recent papers have addressed the issue of monitoring constraints in loosely-coupled, distributed, and sometimes heterogeneous database environments. One class of work involves local constraint checking|deriving tests whose success over one database implies the validity of a multidatabase constraint <ref> [BGM92, GSUW94, GW93] </ref>. Local tests optimize the constraint checking process, but they still require a conventional (non-local) method when the local test fails. As will be seen, in this paper we develop protocols that integrate local checking with non-local methods. <p> We assume that constraints are expressed as queries, where the constraint evaluates to true iff the query result is empty. (This is a relatively standard and convenient formulation of constraints <ref> [GSUW94, GA93] </ref> and usually is equivalent to constraints expressed as logical formulae.) Hence, we denote a constraint C over relations R and S as a query Q (R; S). <p> Unfortunately, local tests are generally conservative, so if a local test fails it is still necessary to issue the remote query Q (R; S). A considerable theory of local tests has been developed in <ref> [GW93, GSUW94] </ref>. Here we show how that theory can be put into practice in the context of our constraint checking protocols. <p> Note that the local test must be evaluated within the same transaction in which the update occurred in order to behave correctly <ref> [GSUW94, ZGMHW94] </ref>, so a materialized delta set approach cannot be applied here. <p> Note that the local test must be evaluated within the same transaction in which the update occurred in order to behave correctly [GSUW94, ZGMHW94], so a materialized delta set approach cannot be applied here. The safety and accuracy of the LTT protocol follows from the correctness of local tests <ref> [GW93, GSUW94] </ref>, and from the safety and accuracy of the TRT protocol. 4 Analyzing the Family of Protocols In the previous section we developed a family of protocols along the four dimensions introduced in Figure 2. In this section we perform some preliminary analysis of the protocols.
Reference: [GW93] <author> A. Gupta and J. Widom. </author> <title> Local verification of global integrity constraints in distributed databases. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 49-58, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: A few recent papers have addressed the issue of monitoring constraints in loosely-coupled, distributed, and sometimes heterogeneous database environments. One class of work involves local constraint checking|deriving tests whose success over one database implies the validity of a multidatabase constraint <ref> [BGM92, GSUW94, GW93] </ref>. Local tests optimize the constraint checking process, but they still require a conventional (non-local) method when the local test fails. As will be seen, in this paper we develop protocols that integrate local checking with non-local methods. <p> Unfortunately, local tests are generally conservative, so if a local test fails it is still necessary to issue the remote query Q (R; S). A considerable theory of local tests has been developed in <ref> [GW93, GSUW94] </ref>. Here we show how that theory can be put into practice in the context of our constraint checking protocols. <p> Note that the local test must be evaluated within the same transaction in which the update occurred in order to behave correctly [GSUW94, ZGMHW94], so a materialized delta set approach cannot be applied here. The safety and accuracy of the LTT protocol follows from the correctness of local tests <ref> [GW93, GSUW94] </ref>, and from the safety and accuracy of the TRT protocol. 4 Analyzing the Family of Protocols In the previous section we developed a family of protocols along the four dimensions introduced in Figure 2. In this section we perform some preliminary analysis of the protocols. <p> Some protocols appearing in Table 9 have an inappropriate combination of features: Local tests cannot be used without local transactions. (Otherwise, the query for the local test might be evaluated in an erroneous state <ref> [GW93, ZGMHW94] </ref>.) This eliminates lines 9-10 and 13-14. Combining timestamps and transactions is "overkill" in the case where local tests are not used (eliminating lines 4 and 8).
Reference: [Lam78] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: In addition, we are currently investigating whether we can adapt our protocols so that logical clocks <ref> [BM93, Lam78] </ref> are sufficient. 3.5 The Transaction Remote Transaction Protocol (TRT) The TRQ and SRQ protocols add timestamping to the DRQ protocol in order to achieve accuracy. This corresponds to one dimension in the protocol space of Figure 2. The next dimension we consider is transactions. <p> repair, how repair should be specified, how it should take place, what the requirements, properties, and costs are, etc. * Consider more carefully the protocols identified by Table 9 that we have not studied but that may be applicable for certain environments. * Consider whether we can use logical clocks <ref> [BM93, Lam78] </ref> instead of timestamps for those protocols currently relying on synchronized time services. * Adapt our protocols for constraints that span more than two databases, and for constraints that may not always have a straightforward incremental check.
Reference: [Nic82] <author> J.-M. Nicolas. </author> <title> Logic for improving integrity checking in relational data bases. </title> <journal> Acta Informatica, </journal> <volume> 18 </volume> <pages> 227-253, </pages> <year> 1982. </year>
Reference-contexts: This class of constraints includes many of the most common constraint types, such as referential integrity and mutual exclusion. The problem of incremental constraint checking has been studied extensively (see, e.g., <ref> [BLT86, Nic82, RCBB89, QW91, Ull89] </ref>). The protocols we present can be extended in a straightforward way to more than two relations; the two-relation restriction is adopted for clarity and brevity only.
Reference: [OV91] <author> T. Oszu and P. Valduriez. </author> <title> Principles of Distributed Database Systems. </title> <publisher> Prentice-Hall, </publisher> <address> Engle--wood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: In this way, the TRT protocol effectively emulates a distributed two-phase locking protocol, ensuring serializability across sites with respect to R and S <ref> [OV91] </ref>. Note that although the TRT protocol emulates global locking, the protocol does not rely on global transaction mechanisms of any kind. Also note that an Indirect Transaction Remote Transaction Protocol (IRT) is also possible, where the bracketed query is sent to the remote database system through its constraint manager.
Reference: [Qia89] <author> X. Qian. </author> <title> Distribution design of integrity constraints. </title> <editor> In L. Kerschberg, editor, </editor> <booktitle> Expert Database Systems|Proceedings from the Second International Conference, </booktitle> <pages> pages 205-226. </pages> <address> Benjamin/Cummings, Redwood City, California, </address> <year> 1989. </year>
Reference-contexts: family to be chosen and tailored for the capabilities and requirements of a particular federated database application. 1.1 Related Work Most work addressing the problem of integrity constraint checking in multidatabase environments has considered tightly-coupled distributed databases in which global queries, global transactions, and global concurrency control are present, e.g. <ref> [GA90, Qia89, SV86] </ref>. Since these approaches rely on global services that typically are unavailable in federated databases, they are inappropriate for the environment we consider.
Reference: [QW91] <author> X. Qian and G. Wiederhold. </author> <title> Incremental recomputation of active relational expressions. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 3(3) </volume> <pages> 337-341, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: This class of constraints includes many of the most common constraint types, such as referential integrity and mutual exclusion. The problem of incremental constraint checking has been studied extensively (see, e.g., <ref> [BLT86, Nic82, RCBB89, QW91, Ull89] </ref>). The protocols we present can be extended in a straightforward way to more than two relations; the two-relation restriction is adopted for clarity and brevity only. <p> The query to check C incrementally with respect to changes on R <ref> [QW91, Ull89] </ref> is denoted Q (R; S), where again the query result is empty iff the constraint holds (assuming the constraint held before the update). Q (R; S) is similar. 2.4 Example Application Suppose we have two hospitals, H A and H B , in two neighboring cities. <p> Constraint C 2 is a local constraint, so it can be enforced at its local site (S A ) using standard 6 methods. Constraints C 1 and C 3 can each be "factored" into two incremental global constraints <ref> [QW91, Ull89] </ref>, dealing with relevant updates to each of the two relations: C A 1 : + P atients A 1 SSN=SSN P atients B C B 1 : P atients A 1 SSN=SSN + P atients B C B 3 : P hysician + P atients B P hN P
Reference: [RCBB89] <author> A. Rosenthal, S. Chakravarthy, B. Blaustein, and J. Blakeley. </author> <title> Situation monitoring for active databases. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 455-464, </pages> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: This class of constraints includes many of the most common constraint types, such as referential integrity and mutual exclusion. The problem of incremental constraint checking has been studied extensively (see, e.g., <ref> [BLT86, Nic82, RCBB89, QW91, Ull89] </ref>). The protocols we present can be extended in a straightforward way to more than two relations; the two-relation restriction is adopted for clarity and brevity only.
Reference: [RSK91] <author> M. Rusinkiewicz, A. Sheth, and G. Karabatis. </author> <title> Specifying interdatabase dependencies in a multidatabase environment. </title> <journal> IEEE Computer, </journal> <volume> 24(12) </volume> <pages> 46-53, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: The issue of maintaining consistency of replicated data across loosely-coupled, semantically heterogeneous databases has been considered in, e.g. <ref> [CW93, RSK91] </ref>. Our constraint checking problem can be seen as a special case (or first step) of the consistency maintenance problem. In [CW93], a method is described that relies on active rules and persistent queues. The approach is similar to the simplest in our family of protocols. <p> In [CW93], a method is described that relies on active rules and persistent queues. The approach is similar to the simplest in our family of protocols. Similar issues are addressed in <ref> [RSK91] </ref>, but no specific protocols are provided. A related problem is that of maintaining views over distributed data in loosely-coupled systems, addressed in [ZGMHW94] in the context of data warehousing. In [ZGMHW94], algorithms are presented for handling the anomalies that arise when materialized views are refreshed in an asynchronous manner.
Reference: [SV86] <author> E. Simon and P. Valduriez. </author> <title> Integrity control in distributed database systems. </title> <booktitle> In Proceedings of the Nineteenth International Conference on System Sciences, Hawaii, </booktitle> <year> 1986. </year>
Reference-contexts: family to be chosen and tailored for the capabilities and requirements of a particular federated database application. 1.1 Related Work Most work addressing the problem of integrity constraint checking in multidatabase environments has considered tightly-coupled distributed databases in which global queries, global transactions, and global concurrency control are present, e.g. <ref> [GA90, Qia89, SV86] </ref>. Since these approaches rely on global services that typically are unavailable in federated databases, they are inappropriate for the environment we consider.
Reference: [Ull89] <author> J.D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, Volumes I and II. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, Maryland, </address> <year> 1989. </year>
Reference-contexts: This class of constraints includes many of the most common constraint types, such as referential integrity and mutual exclusion. The problem of incremental constraint checking has been studied extensively (see, e.g., <ref> [BLT86, Nic82, RCBB89, QW91, Ull89] </ref>). The protocols we present can be extended in a straightforward way to more than two relations; the two-relation restriction is adopted for clarity and brevity only. <p> The query to check C incrementally with respect to changes on R <ref> [QW91, Ull89] </ref> is denoted Q (R; S), where again the query result is empty iff the constraint holds (assuming the constraint held before the update). Q (R; S) is similar. 2.4 Example Application Suppose we have two hospitals, H A and H B , in two neighboring cities. <p> Constraint C 2 is a local constraint, so it can be enforced at its local site (S A ) using standard 6 methods. Constraints C 1 and C 3 can each be "factored" into two incremental global constraints <ref> [QW91, Ull89] </ref>, dealing with relevant updates to each of the two relations: C A 1 : + P atients A 1 SSN=SSN P atients B C B 1 : P atients A 1 SSN=SSN + P atients B C B 3 : P hysician + P atients B P hN P
Reference: [WF90] <author> J. Widom and S.J. Finkelstein. </author> <title> Set-oriented production rules in relational database systems. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 259-270, </pages> <address> Atlantic City, New Jersey, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: 3 i Q (R; S) hQ (R; S); t 1 i hstatus; t 3 i make the protocol more efficient, reevaluation is performed with a cumulative delta set, i.e. a delta set combining multiple update notifications from a single site. (We assume a net effect semantics for cumulative delta sets <ref> [WF90] </ref>.) The Timestamped Remote Query Protocol (TRQ) is specified in Table 4 and depicted in Figure 5.
Reference: [ZGMHW94] <author> Y. Zhuge, H. Garcia-Molina, J. Hammer, and J. Widom. </author> <title> View maintenance in a warehousing environment. </title> <note> Submitted for publication, 1994. 24 </note>
Reference-contexts: The approach is similar to the simplest in our family of protocols. Similar issues are addressed in [RSK91], but no specific protocols are provided. A related problem is that of maintaining views over distributed data in loosely-coupled systems, addressed in <ref> [ZGMHW94] </ref> in the context of data warehousing. In [ZGMHW94], algorithms are presented for handling the anomalies that arise when materialized views are refreshed in an asynchronous manner. The algorithms in [ZGMHW94] rely on view definitions and compensating queries, and thus are not directly applicable to our problem. <p> The approach is similar to the simplest in our family of protocols. Similar issues are addressed in [RSK91], but no specific protocols are provided. A related problem is that of maintaining views over distributed data in loosely-coupled systems, addressed in <ref> [ZGMHW94] </ref> in the context of data warehousing. In [ZGMHW94], algorithms are presented for handling the anomalies that arise when materialized views are refreshed in an asynchronous manner. The algorithms in [ZGMHW94] rely on view definitions and compensating queries, and thus are not directly applicable to our problem. However, the results in [ZGMHW94] may become relevant as we extend our <p> A related problem is that of maintaining views over distributed data in loosely-coupled systems, addressed in <ref> [ZGMHW94] </ref> in the context of data warehousing. In [ZGMHW94], algorithms are presented for handling the anomalies that arise when materialized views are refreshed in an asynchronous manner. The algorithms in [ZGMHW94] rely on view definitions and compensating queries, and thus are not directly applicable to our problem. However, the results in [ZGMHW94] may become relevant as we extend our protocols to handle more complex constraints or to incorporate constraint repair. <p> In <ref> [ZGMHW94] </ref>, algorithms are presented for handling the anomalies that arise when materialized views are refreshed in an asynchronous manner. The algorithms in [ZGMHW94] rely on view definitions and compensating queries, and thus are not directly applicable to our problem. However, the results in [ZGMHW94] may become relevant as we extend our protocols to handle more complex constraints or to incorporate constraint repair. Finally, we note that in the field of distributed (operating) systems there has been considerable work in the area of snapshots and consistent global states; see e.g. [CL85, BM93]. <p> Note that the local test must be evaluated within the same transaction in which the update occurred in order to behave correctly <ref> [GSUW94, ZGMHW94] </ref>, so a materialized delta set approach cannot be applied here. <p> Some protocols appearing in Table 9 have an inappropriate combination of features: Local tests cannot be used without local transactions. (Otherwise, the query for the local test might be evaluated in an erroneous state <ref> [GW93, ZGMHW94] </ref>.) This eliminates lines 9-10 and 13-14. Combining timestamps and transactions is "overkill" in the case where local tests are not used (eliminating lines 4 and 8).
References-found: 26

