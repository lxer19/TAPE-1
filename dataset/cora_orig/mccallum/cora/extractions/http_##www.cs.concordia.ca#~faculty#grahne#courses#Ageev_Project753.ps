URL: http://www.cs.concordia.ca/~faculty/grahne/courses/Ageev_Project753.ps
Refering-URL: http://www.cs.concordia.ca/~faculty/grahne/courses/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Obtaining Complete and Valid Answers from Databases  
Author: By Sergei Z. Ageev 
Degree: A project submitted in partial fulfillment of the requirements for  
Note: 1998 by Sergei Z. Ageev  
Date: April 1998  
Address: Montreal, Canada  753  
Affiliation: Department of Computer Science Concordia University  COMP  
Abstract: We consider the problem of answering queries from databases that may be incomplete. A database is incomplete if some tuples may be missing from some relations, and only a part of each relation is known to be complete. This problem arises in several contexts. For example, systems that provide access to multiple heterogeneous information sources often encounter incomplete sources. The question we address is to determine whether the answer to a specific given query is complete even when the database is incomplete. We consider a model where the complete parts of a database are described as views. Thus the problem in question can be reduced to finding a rewriting of a query that uses the materialized views an we address the problem of finding minimal rewritings, and finding complete rewritings (i.e., rewritings that use only the views). We show that all the possible rewritings can be obtained by considering containment mappings from the views to the query. We describe also a polynomial time algorithm for finding rewritings, and which under certain conditions, finds minimal rewritings. Moreover, we present a sound and complete algorithm for the answer-completeness problem by relating it to the problem of independence of queries from updates. In addition, we also describe an algorithm that determines whether the answer to the query is complete in the current state of the database. Finally, we show that the treatment presented extends naturally to partially-incorrect databases. 
Abstract-found: 1
Intro-found: 1
Reference: [ACHK94] <author> Yigal Arens, Chin Y. Chee, Chun-Nan Hsu, and Craig A. Knoblock. </author> <title> Retrieving and integrating data from multiple information sources. </title> <journal> International Journal on Intelligent and Cooperative Information Systems, </journal> <year> 1994. </year>
Reference-contexts: Movie has listings for movies that are currently playing in New York. The answer to the question about query completeness is crucial to the information integration systems such as mediator based systems that provide access to multiple distributed information sources (e.g., TSIMMIS [CGMH + 94], SIMS <ref> [ACHK94] </ref>, the Internet Softbot [EW94] and the Information Manifold [LRO96a, LRO96b]). In practice, many of the sources these systems access contain only partial information. For instance, the system may have access to a public library that contains publications authored by marine biologists, but does not necessarily contain all of them.
Reference: [ASU79a] <author> Alfred Aho, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Efficient optimization of a class of relational expressions. </title> <journal> ACM Transactions on Database Systems (4) 4:435 - 454, </journal> <year> 1979. </year>
Reference-contexts: However, algorithms for restricted cases are given in [CV92 , CV94 , Sag88 , LS93]. In particular, we mention two approaches, query reachability [LS92, LS93] and uniform equivalence [Sag88]. Finally, if the database relations are known to satisfy integrity constraints (e.g., functional dependencies, tuple generating dependencies), the algorithms in <ref> [CM77, ASU79b, ASU79a, JK83] </ref> can be used for deciding equivalence. For the sake of completeness of our discussion, we describe algorithms for deciding uniform equivalence of programs that have built-in predicates.
Reference: [ASU79b] <author> Alfred Aho, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Equivalence of relational expressions. </title> <journal> SIAM Journal of Computing , (8)2:218 246, </journal> <year> 1979. </year>
Reference-contexts: However, algorithms for restricted cases are given in [CV92 , CV94 , Sag88 , LS93]. In particular, we mention two approaches, query reachability [LS92, LS93] and uniform equivalence [Sag88]. Finally, if the database relations are known to satisfy integrity constraints (e.g., functional dependencies, tuple generating dependencies), the algorithms in <ref> [CM77, ASU79b, ASU79a, JK83] </ref> can be used for deciding equivalence. For the sake of completeness of our discussion, we describe algorithms for deciding uniform equivalence of programs that have built-in predicates.
Reference: [BI94] <author> Daniel Barbara and Tomasz Imielinski. Sleepers and workaholics: </author> <title> Caching strategies in mobile environments. </title> <booktitle> In Proceedings of SIGMOD-94 , pages 1-12, </booktitle> <year> 1994. </year>
Reference-contexts: However, in practice there are situations in which we have access to databases that may be partial, i.e., some tuples may be missing or unaccessible. For example, in applications such as Global Information Systems [LSK95], Mobile Computing <ref> [BI94, HSW94] </ref>, view adaptation [GMR95], maintaining physical data independence [TSI94], the relations mentioned in the query may either not actually be physically stored (e.g., they may be only conceptual relations), or be impossible to consult (e.g. they are stored in a remote server that is temporarily unavailable to a mobile computing
Reference: [BCL89] <author> J. A. Blakeley , N. Coburn, and P . A. Larson. </author> <title> Updating derived relations: detecting irrelevant and autonomously computable updates. </title> <journal> Transactions of Database Systems, </journal> <volume> 14(3):369- 400, </volume> <year> 1989. </year>
Reference: [CGMH+94] <author> Sudarshan Chawathe, Hector Garcia-Molina, Joachim Hammer, Kelly Ireland, Yannis Papakonstantinou, Jeffrey Ullman, and Jennifer Widom. </author> <title> The TSIMMIS pro ject: In tegration of heterogenous information sources. </title> <booktitle> In proceedings of IPSJ, </booktitle> <address> Tokyo, Japan, </address> <month> October </month> <year> 1994. </year> <month> 20 </month>
Reference: [CKPS95] <author> Surajit Chaudhuri, Ravi Krishnamurthy, Spyros Potamianos, and Kyuseok Shim. </author> <title> Optimizing queries with materialized views. </title> <booktitle> In Proceedings of International Conference on Data Engineering, </booktitle> <year> 1995. </year>
Reference-contexts: ), it can be removed, resulting in the following rewriting: q ( X , Y , U, W ) r ( U , W ) , r ( W, U ) , V ( X, Y, C , D ) In conclusion of this section we mention Chaudhuri et al. <ref> [CKPS95] </ref> who considered the problem of finding rewritings for select-project-join queries and views, such that the rewritten query preserves the bag semantics. <p> They show that in this case all the usages of views are obtained by 1-1 mappings from the views to the query, and therefore their algorithm would not find all the usages in the case where the relations are sets. Chaudhuri et al. <ref> [CKPS95] </ref> also considered the question of how to extend a query processor to choose between the different rewritings, a question that w as not addressed in here. Dar et al. [DJLS95] recently extended the work in [CKPS95] to consider queries that involve aggregation. 4 Completeness and independence from updates Here we <p> Chaudhuri et al. <ref> [CKPS95] </ref> also considered the question of how to extend a query processor to choose between the different rewritings, a question that w as not addressed in here. Dar et al. [DJLS95] recently extended the work in [CKPS95] to consider queries that involve aggregation. 4 Completeness and independence from updates Here we will show that answer-completeness problem is closely related to the problem of detecting independence of queries from up dates [BCL89 , Elk90 , LS93].
Reference: [CM77] <author> A.K. Chandra and P .M. Merlin. </author> <title> Optimal implementation of conjunctive queries in relational databases. </title> <booktitle> In Proceedings of the Ninth Annual ACM Symposium on The Theory of Computing , pages 77-90, </booktitle> <year> 1977. </year>
Reference-contexts: Thus, the answer to this query is complete. Since Motro's initial advances complete algorithms for rewriting queries using views have been developed [LMSS95]. 3.1 Containment mapping Below we demonstrate that the problem of finding a rewriting is closely related to the query containment problem. Containment mappings <ref> [CM77] </ref> have been used to demonstrate containment among conjunctive queries. <p> When neither Q 1 nor Q 2 contain built-in predicates, finding a containment mapping is a necessary and sufficient condition for deciding that Q 1 contains Q 2, and is an NP-complete problem <ref> [CM77] </ref>. This remains true also when Q 2 contains built-in predicates. However, when Q 1 contains built-in predicates, finding a containment mapping provides only a sufficient condition, and the containment problem in this case is P p 2 complete [vdM92]. <p> However, algorithms for restricted cases are given in [CV92 , CV94 , Sag88 , LS93]. In particular, we mention two approaches, query reachability [LS92, LS93] and uniform equivalence [Sag88]. Finally, if the database relations are known to satisfy integrity constraints (e.g., functional dependencies, tuple generating dependencies), the algorithms in <ref> [CM77, ASU79b, ASU79a, JK83] </ref> can be used for deciding equivalence. For the sake of completeness of our discussion, we describe algorithms for deciding uniform equivalence of programs that have built-in predicates.
Reference: [CV92] <author> Surajit Chaudhuri and Moshe Vardi. </author> <title> On the equivalence of recursive and nonrecursive datalog programs. </title> <booktitle> In The Proceedings of the Eleventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> San Diego, CA. , pages 55 -66, </address> <year> 1992. </year>
Reference: [CV94] <author> Surajit Chaudhuri and Moshe Vardi. </author> <title> On the complexity of equivalence between recursive and nonrecursive datalog programs. </title> <booktitle> In The Proceedings of the Thirteenth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems , pages 55- 66, </booktitle> <year> 1994. </year>
Reference: [EGW94] <author> Oren Etzioni, Keith Golden, and Daniel Weld. </author> <title> Tractable closed world reasoning withup dates. </title> <booktitle> In Proceedings of the Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <address> KR-94. </address> , <year> 1994. </year> <note> Extended version to appear in Artificial Intelligence </note> . 
Reference-contexts: We presented also an algorithm that considers the current state of the database to determine whether the answer is complete. A related question one can pose about incomplete databases (which was considered in <ref> [EGW94] </ref>) is what happens when the partial-completeness information changes. In particular, is the answer to a query still complete even if parts of the database that were assumed to be complete may not be complete anymore. <p> It can be shown that this problem can be reformulated as a problem of independence of queries from deletion updates, thereby giving it a uniform treatment together the problem we considered here. In addition, we mention Etzioni et al. <ref> [EGW94 ] </ref> who considered the problem of answer-completeness in order to avoid redundant information gathering actions in the Internet Softbot system [EW94 ], and demonstrated experimentally the value of detecting answer-completeness.
Reference: [Elk90] <author> Charles Elkan. </author> <title> Independence of logic database queries and updates. </title> <booktitle> In Proceedings of the 9th ACM Symp. on Principles of Database Systems , pages 154-160, </booktitle> <year> 1990. </year>
Reference-contexts: G if and only if In - ( Q, ( R j , C j )) holds for every statement in G . Given Theorem 6.1 one can use algorithms for detecting independence also for deciding answer-correctness. Theorem 6.1 has an additional in consequence. As shown by Elkan <ref> [Elk90 ] </ref>, independence from a deletion is a sufficient condition for independence from an update, i.e., I n ( Q, ( R, C ))) )fi I n ( Q; ( R; C ))) . 7 Conclusions Here, we discussed the problem of answering queries from databases that may be incomplete or
Reference: [EW94] <author> Oren Etzioni and Dan Weld. </author> <title> A softbot-based in terface to the internet. </title> <journal> CACM , 37(7):72 -76, </journal> <year> 1994. </year>
Reference-contexts: The answer to the question about query completeness is crucial to the information integration systems such as mediator based systems that provide access to multiple distributed information sources (e.g., TSIMMIS [CGMH + 94], SIMS [ACHK94], the Internet Softbot <ref> [EW94] </ref> and the Information Manifold [LRO96a, LRO96b]). In practice, many of the sources these systems access contain only partial information. For instance, the system may have access to a public library that contains publications authored by marine biologists, but does not necessarily contain all of them. <p> In addition, we mention Etzioni et al. [EGW94 ] who considered the problem of answer-completeness in order to avoid redundant information gathering actions in the Internet Softbot system <ref> [EW94 ] </ref>, and demonstrated experimentally the value of detecting answer-completeness. They showed that answer-completeness is closed under conjunction and partial instantiation of queries, and use these properties as a basis for their algorithm for determining answer-completeness.
Reference: [Gin87] <editor> Matthew Ginsberg. </editor> <publisher> Readings in Nonmonotonic reasoning . Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, California, </address> <year> 1987. </year>
Reference-contexts: The query Q is said to be answer-complete w.r.t. G if for any database instance D for the relations Rv and Ra such that D satisfies G, then Q ( D ) =Q'( D ). The concept of information completeness is related to the Closed World Assumption (CWA) <ref> [Gin87] </ref>. Under this assumption, a database contains all the occurrences of data it attempts to model. CWA states that if the fact is not included in the database then it is false. The CWA is usually made on the database as a whole.
Reference: [JK83] <author> D. S. Johnson and A. Klug. </author> <title> Testing containment of conjunctive queries under functional and inclusion dependecies. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> (28):1:167-189, </volume> <year> 1983. </year>
Reference-contexts: However, algorithms for restricted cases are given in [CV92 , CV94 , Sag88 , LS93]. In particular, we mention two approaches, query reachability [LS92, LS93] and uniform equivalence [Sag88]. Finally, if the database relations are known to satisfy integrity constraints (e.g., functional dependencies, tuple generating dependencies), the algorithms in <ref> [CM77, ASU79b, ASU79a, JK83] </ref> can be used for deciding equivalence. For the sake of completeness of our discussion, we describe algorithms for deciding uniform equivalence of programs that have built-in predicates.
Reference: [GMR95] <author> Ashish Gupta, Inderpal Singh Mumick, and Kenneth A. Ross. </author> <title> Adapting Materialized Views after Redefinitions. </title> <booktitle> In Proceedings of SIGMOD- 95 , 1995. </booktitle>
Reference-contexts: However, in practice there are situations in which we have access to databases that may be partial, i.e., some tuples may be missing or unaccessible. For example, in applications such as Global Information Systems [LSK95], Mobile Computing [BI94, HSW94], view adaptation <ref> [GMR95] </ref>, maintaining physical data independence [TSI94], the relations mentioned in the query may either not actually be physically stored (e.g., they may be only conceptual relations), or be impossible to consult (e.g. they are stored in a remote server that is temporarily unavailable to a mobile computing device), or be very
Reference: [HSW94] <author> Yixiu Huang, Prasad Sistla, and Ouri Wolfson. </author> <title> Data replication for mobile computers. </title> <booktitle> In Proceedings of SIGMOD-94 , pages 13-24, </booktitle> <year> 1994. </year>
Reference-contexts: However, in practice there are situations in which we have access to databases that may be partial, i.e., some tuples may be missing or unaccessible. For example, in applications such as Global Information Systems [LSK95], Mobile Computing <ref> [BI94, HSW94] </ref>, view adaptation [GMR95], maintaining physical data independence [TSI94], the relations mentioned in the query may either not actually be physically stored (e.g., they may be only conceptual relations), or be impossible to consult (e.g. they are stored in a remote server that is temporarily unavailable to a mobile computing
Reference: [Klu88] <author> A. Klug. </author> <title> On conjunctive queries containing inequalities. </title> <journal> Journal of the ACM , pages 35(1): </journal> <pages> 146-160, </pages> <year> 1988. </year>
Reference-contexts: In fact, the lower bound on the problem of equivalence [vdM92] implies that this is also the lower bound on the answer-completeness problem. The proof of Theorem 4.2 follows from Theorem 4.1 and from decidability results for query containment <ref> [SY81, Klu88, LS93] </ref>. <p> Therefore, removing such tuples will not change the result of the query . Detecting redundancy is a more expensive procedure than detecting satisfiability. For example, for conjunctive queries with comparison predicates, the time complexity of detecting redundancy is P p 2 <ref> [Klu88, vdM92] </ref>, while checking satisfiability can be done in polynomial time [Ull89]. The case we consider involves variable-interval queries and updates. In particular, a conjunctive query Q is a variable-interval query if all the built-in atoms in Q have one constant (i.e., there are no comparisons between pairs of variables). <p> A variable-interval update is an update in which the updated tuples are specified by a conjunction of built-in atoms where each atom contains one constant. It should be noted that variable-interval queries are a more general class than semiinterval queries considered in <ref> [Klu88] </ref>. Algorithm 2 shows how to detect independence of variable-interval queries from variable-interval updates. The following theorem shows that the algorithm completely decides independence in this case in polynomial time.
Reference: [LMSS95] <author> Alon Y. Levy, Alberto O. Mendelzon, Yehoshua Sagiv, and Divesh Srivastava. </author> <title> Answering queries using views. </title> <booktitle> In Proceedings of the 14th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> San Jose, CA , 1995. </address>
Reference-contexts: CompleteOscar (Title, Year) Oscar (Title, Year). Such a rewriting gives an equivalent query to the original one. Thus, the answer to this query is complete. Since Motro's initial advances complete algorithms for rewriting queries using views have been developed <ref> [LMSS95] </ref>. 3.1 Containment mapping Below we demonstrate that the problem of finding a rewriting is closely related to the query containment problem. Containment mappings [CM77] have been used to demonstrate containment among conjunctive queries. <p> In the first, we consider containment mappings from the bodies of the views to the body of the query, and add the appropriate view literals to the query. In the second step, we remove literals of the original query that are redundant. It is shown in <ref> [LMSS95] </ref> that in general, both steps provide independent sources of exponential complexity. In this section we describe a polynomial time algorithm [LMSS95] for the second step. <p> In the second step, we remove literals of the original query that are redundant. It is shown in <ref> [LMSS95] </ref> that in general, both steps provide independent sources of exponential complexity. In this section we describe a polynomial time algorithm [LMSS95] for the second step. In particular, given a set of mappings from the views to the query, the algorithm determines which set of literals from the query can be removed. <p> It is important to note that the set of needed variables can be found in polynomial time in the size of the query . To summarize, we state the following theorem from <ref> [LMSS95] </ref>: Theorem 3.1: 1. The query q (X) N , v (Y) (5) is a rewriting of Q using V . 2. Suppose that h does not map two literals rj (Vj ) to the same literal in Rule (1), and Rule (1) is minimal. <p> Given a query Q, if there is a rewriting of the query using the complete (resp. valid) views, then the answer is complete (resp. valid). We presented complete algorithms for rewriting queries using views <ref> [LMSS95] </ref>. However, it is important to mention that finding a rewriting of the query using views has not been shown to be a necessary condition for answer-completeness.
Reference: [LRO96a] <author> Alon Y. Levy, Anand Rajaraman, and Joann J. Ordille. </author> <title> Query answering algorithms for information agents. </title> <booktitle> In Proceedings of the AAAI Thirteenth National Conference on Artificial Intelligence, </booktitle> <year> 1996. </year>
Reference-contexts: The answer to the question about query completeness is crucial to the information integration systems such as mediator based systems that provide access to multiple distributed information sources (e.g., TSIMMIS [CGMH + 94], SIMS [ACHK94], the Internet Softbot [EW94] and the Information Manifold <ref> [LRO96a, LRO96b] </ref>). In practice, many of the sources these systems access contain only partial information. For instance, the system may have access to a public library that contains publications authored by marine biologists, but does not necessarily contain all of them.
Reference: [LR O96b] <author> Alon Y. Levy, Anand Rajaraman, and Joann J. Ordille. </author> <title> Querying heterogeneous information sources using source descriptions. </title> <booktitle> In Proceedings of the 22nd VLDB Conference, </booktitle> <address> Bombay, India., </address> <year> 1996. </year>
Reference: [LS93] <author> Alon Y. Levy and Yehoshua Sagiv. </author> <title> Queries independent of updates. </title> <booktitle> In Proceedings of the 19th VLDB Conference, Dublin, </booktitle> <pages> Ireland , pages 171-181, </pages> <year> 1993. </year>
Reference-contexts: In order to generalize our results to queries containing built-in predicates it is 7 useful to note how containment mappings are also used to show containment of such queries. In particular, it follows from <ref> [LS93] </ref> that if Q 1 contains Q 2, then there exist queries Q 1 n 2 such that: Q 2,., Q 2 differ only in their built-in literals, and (A) Q 2 is equivalent to the union of Q 1 n For every i , 1 i n , there is <p> Dar et al. [DJLS95] recently extended the work in [CKPS95] to consider queries that involve aggregation. 4 Completeness and independence from updates Here we will show that answer-completeness problem is closely related to the problem of detecting independence of queries from up dates <ref> [BCL89 , Elk90 , LS93] </ref>. The problem of independence of queries from updates is to determine whether the answer to a query Q changes as a result of an insertion to the database or as a result of a deletion from the database. <p> The query Q is answer-complete w.r.t. G if and only if In + ( Q, ( R j , C j )) holds for every statement in G . Using Theorem 4.1 we can apply algorithms for detecting independence (e.g., <ref> [BCL89 , Elk90 , LS93] </ref>) to the problem of deciding answer-completeness. Levy and Sagiv [LS93 ] describe an algorithm for detecting independence based on checking equivalence between two queries. Algorithm 1 below adopts the method in [LS93] to decide answer-completeness based on equivalence checking. <p> G if and only if In + ( Q, ( R j , C j )) holds for every statement in G . Using Theorem 4.1 we can apply algorithms for detecting independence (e.g., [BCL89 , Elk90 , LS93]) to the problem of deciding answer-completeness. Levy and Sagiv <ref> [LS93 ] </ref> describe an algorithm for detecting independence based on checking equivalence between two queries. Algorithm 1 below adopts the method in [LS93] to decide answer-completeness based on equivalence checking. <p> Using Theorem 4.1 we can apply algorithms for detecting independence (e.g., [BCL89 , Elk90 , LS93]) to the problem of deciding answer-completeness. Levy and Sagiv [LS93 ] describe an algorithm for detecting independence based on checking equivalence between two queries. Algorithm 1 below adopts the method in <ref> [LS93] </ref> to decide answer-completeness based on equivalence checking. <p> The problem of checking query equivalence is well studied in the literature, and therefore algorithm decide-completeness can use a host of known results to decide completeness. For example, algorithms for equivalence of queries containing unions and negations are given in <ref> [SY81, LS93] </ref>. When queries are recursive, the equivalence problem is known to be undecidable [Shm93]. However, algorithms for restricted cases are given in [CV92 , CV94 , Sag88 , LS93]. In particular, we mention two approaches, query reachability [LS92, LS93] and uniform equivalence [Sag88]. <p> For example, algorithms for equivalence of queries containing unions and negations are given in [SY81, LS93]. When queries are recursive, the equivalence problem is known to be undecidable [Shm93]. However, algorithms for restricted cases are given in <ref> [CV92 , CV94 , Sag88 , LS93] </ref>. In particular, we mention two approaches, query reachability [LS92, LS93] and uniform equivalence [Sag88]. <p> When queries are recursive, the equivalence problem is known to be undecidable [Shm93]. However, algorithms for restricted cases are given in [CV92 , CV94 , Sag88 , LS93]. In particular, we mention two approaches, query reachability <ref> [LS92, LS93] </ref> and uniform equivalence [Sag88]. Finally, if the database relations are known to satisfy integrity constraints (e.g., functional dependencies, tuple generating dependencies), the algorithms in [CM77, ASU79b, ASU79a, JK83] can be used for deciding equivalence. <p> The algorithm <ref> [LS93] </ref> decides whether M ( P 1 ) M ( P 2 ) by checking whether M ( P 1 ) M ( r ) for every r P 2 . We discuss programs with only built-in predicates. <p> In fact, the lower bound on the problem of equivalence [vdM92] implies that this is also the lower bound on the answer-completeness problem. The proof of Theorem 4.2 follows from Theorem 4.1 and from decidability results for query containment <ref> [SY81, Klu88, LS93] </ref>. <p> Intuitively, in this case detecting independence is equivalent to deciding when the updated tuples and the query are mutually unsatisfiable, whereas in general, detecting independence requires that we detect that the updated tuples are redundant w.r.t. the query . The following example, adopted from <ref> [LS93] </ref>, explains the difference between satisfiability and redundancy . Example 4.4 : Consider a database containing the relation inCar ( Person, Car , Age ).
Reference: [LSK95] <author> Alon Y. Levy, Divesh Srivastava, and Thomas Kirk. </author> <title> Data model and query 21 evaluation in global information systems. </title> <journal> Journal of Intelligent Information Systems, </journal> <note> Special Issue on Networked Information Discovery and Retrieval , 5 (2), </note> <month> September </month> <year> 1995. </year>
Reference-contexts: However, in practice there are situations in which we have access to databases that may be partial, i.e., some tuples may be missing or unaccessible. For example, in applications such as Global Information Systems <ref> [LSK95] </ref>, Mobile Computing [BI94, HSW94], view adaptation [GMR95], maintaining physical data independence [TSI94], the relations mentioned in the query may either not actually be physically stored (e.g., they may be only conceptual relations), or be impossible to consult (e.g. they are stored in a remote server that is temporarily unavailable to
Reference: [Levy96] <author> Alon Levy. </author> <title> Obtaining complete information from incomplete databases. </title> <booktitle> Proceedings of the 22nd VLDB Conference, </booktitle> <address> Bombay, India, </address> <year> 1996. </year>
Reference-contexts: However, an important question to be asked is whether the answer is complete even though the database is incomplete. When queries contain negation, we need to modify our query answering algorithms to guarantee that we obtain only correct answers. Consider an example, adopted from <ref> [Levy96] </ref>. Example 1.1: Consider an example in which we have access to several online databases with information about movies. <p> That is, In + (q , ( Show , Hour 8 pm )) does not hold. 4.1 Deciding answer-completeness of a query based on independence Levy <ref> [Levy96] </ref> solution to the answer-completeness problem is based on showing that the problem can be equivalently translated to a problem of detecting independence of a query from an insertion up date. We show the connection between these two problems in this section. We first illustrate the connection with an example. <p> The answer to Q 2 is guaranteed to be complete, because even if we up date the database with movies produced before 1965, that would not change the answer to the query. The following theorem from <ref> [Levy96] </ref> formalizes the connection between independence and answer-completeness. <p> The correctness of the algorithm is established by the following theorem. Theorem 4.2 : M ( P ) M ( r ) iff c r |= c1 c m 14 To conclude this section, we present the following decidability results for the answer-completeness problem is obtained in <ref> [Levy96] </ref>. <p> However, if the algorithm returns that the query is not answer-complete, then there still may be database instances in which the answer is complete. In this section we describe an algorithm <ref> [Levy96] </ref> that decides whether the answer to the query is complete in the current database state. The algorithm is based on submitting a couple of additional queries whose answers will show whether the answer to Q is guaranteed to be complete. We first illustrate the algorithm with an example. <p> In Example 5.1, the variables Title, Theater and Time functionally determine all the other variables in the query. For simplicity of exposition we describe the algorithm from <ref> [Levy96] </ref> for conjunctive queries. <p> However, it is important to mention that finding a rewriting of the query using views has not been shown to be a necessary condition for answer-completeness. The problem of deciding answer-completeness can be translated to independence of insertion updates problem <ref> [Levy96] </ref>, whereas determining correctness of an answer can be translated to independence of deletion updates. Consequently, it is possible to deal uniformly with both cases. <p> However, as they show, their algorithm is not guaranteed to always detect answer-completeness when it holds. There are several interesting directions of future work <ref> [Levy96] </ref> to pursue. One is to consider other ways of specifying local-completeness information that cannot be captured by the statements we allowed in the present discussion.
Reference: [Mot89] <author> Amihai Motro. </author> <title> Integrity = validity + completeness. </title> <journal> ACM Transactions on Database Systems , 14(4) </journal> <pages> 480-502, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: In reality, the CWA can only be made on some subsets of the database. Rougly speaking, our completeness constraints assert that certain database subsets are "closed world". 6 3 Deciding completeness using views Motro <ref> [Mot89] </ref> considered originally the question whether the answer to a query is complete even though the database is not complete. He put forward a model of integrity control that addresses this problem. <p> Motro's <ref> [Mot89] </ref> approach is based on describing the complete (or valid) parts of the database as views. Given a query Q, if there is a rewriting of the query using the complete (resp. valid) views, then the answer is complete (resp. valid).
Reference: [Sag88] <author> Yehoshua Sagiv. </author> <title> Optimizing datalog programs. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming , pages 659 698. </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: When queries are recursive, the equivalence problem is known to be undecidable [Shm93]. However, algorithms for restricted cases are given in [CV92 , CV94 , Sag88 , LS93]. In particular, we mention two approaches, query reachability [LS92, LS93] and uniform equivalence <ref> [Sag88] </ref>. Finally, if the database relations are known to satisfy integrity constraints (e.g., functional dependencies, tuple generating dependencies), the algorithms in [CM77, ASU79b, ASU79a, JK83] can be used for deciding equivalence. <p> For the sake of completeness of our discussion, we describe algorithms for deciding uniform equivalence of programs that have built-in predicates. As shown in <ref> [Sag88] </ref>, uniform containment (and equivalence) can be given model-theoretic characterization, namely, the uniform containment P 2 u P 1 for datalog programs P 1 and P2 holds if and only if M ( P 1 ) M ( P 2 ), where M ( P i ) denotes the set of <p> We then apply the program P to the atoms q 1q ,, q nq . In <ref> [Sag88] </ref> it is shown that the program P generates pq from q 1q ,, q nq q if and only if M ( P ) M ( r ). However, there is a problem in applying this algorithm to programs with interpreted predicates.
Reference: [Shm93] <author> Oded Shmueli. </author> <title> Equivalence of datalog queries is undecidable. </title> <journal> Journal of Logic Programming , 15 </journal> <pages> 231-241, </pages> <year> 1993. </year>
Reference-contexts: For example, algorithms for equivalence of queries containing unions and negations are given in [SY81, LS93]. When queries are recursive, the equivalence problem is known to be undecidable <ref> [Shm93] </ref>. However, algorithms for restricted cases are given in [CV92 , CV94 , Sag88 , LS93]. In particular, we mention two approaches, query reachability [LS92, LS93] and uniform equivalence [Sag88].
Reference: [SY81] <author> Y. Sagiv and M. Yannakakis. </author> <title> Equivalence among relational expressions with the union and difference operators. </title> <journal> Journal of the ACM, </journal> <volume> 27(4) </volume> <pages> 633-655, </pages> <year> 1981. </year>
Reference-contexts: It is well known that a containment mapping can be found in polynomial time if each literal has at most two potential destinations; the exact algorithm is based on a reduction to the 2-SAT problem <ref> [SY81] </ref>. In some sense, this is the case in the minimization algorithm presented in Theorem 3.1, since each pi (Ui) can be mapped either to itself or to its associate. However, the contribution of Theorem 3.1 is twofold. First, it shows that each pi (Ui) has at most two destinations. <p> The problem of checking query equivalence is well studied in the literature, and therefore algorithm decide-completeness can use a host of known results to decide completeness. For example, algorithms for equivalence of queries containing unions and negations are given in <ref> [SY81, LS93] </ref>. When queries are recursive, the equivalence problem is known to be undecidable [Shm93]. However, algorithms for restricted cases are given in [CV92 , CV94 , Sag88 , LS93]. In particular, we mention two approaches, query reachability [LS92, LS93] and uniform equivalence [Sag88]. <p> In fact, the lower bound on the problem of equivalence [vdM92] implies that this is also the lower bound on the answer-completeness problem. The proof of Theorem 4.2 follows from Theorem 4.1 and from decidability results for query containment <ref> [SY81, Klu88, LS93] </ref>.
Reference: [Ull89] <author> Jeffrey D. Ullman. </author> <title> Principles of Database and Knowledge base Systems, Volumes I, </title> <publisher> II . Computer Science Press, </publisher> <address> Rockville MD, </address> <year> 1989. </year>
Reference-contexts: We assume set semantics for queries (and not multisets). In our analysis it is more convenient to use the notation of conjunctive queries <ref> [Ull89] </ref>. For example, the query Q 2 is given as a conjunctive query of the form: q2 (Director) Movie (Title, Director, Year) , Oscar (Title, Year), Year 1965. Unless otherwise specified, we assume that a query is a union of conjunctive queries. <p> Detecting redundancy is a more expensive procedure than detecting satisfiability. For example, for conjunctive queries with comparison predicates, the time complexity of detecting redundancy is P p 2 [Klu88, vdM92], while checking satisfiability can be done in polynomial time <ref> [Ull89] </ref>. The case we consider involves variable-interval queries and updates. In particular, a conjunctive query Q is a variable-interval query if all the built-in atoms in Q have one constant (i.e., there are no comparisons between pairs of variables).
Reference: [vdM92] <author> Ronvander Meyden. </author> <title> The complexity of querying indefinite data about linearly ordered domains. </title> <booktitle> In The Proceedings of the Eleventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> San Diego, CA., </address> <pages> pages 331 345, </pages> <year> 1992. </year>
Reference-contexts: This remains true also when Q 2 contains built-in predicates. However, when Q 1 contains built-in predicates, finding a containment mapping provides only a sufficient condition, and the containment problem in this case is P p 2 complete <ref> [vdM92] </ref>. In order to generalize our results to queries containing built-in predicates it is 7 useful to note how containment mappings are also used to show containment of such queries. <p> When the constraints involve comparison predicates the problem of deciding answer-completeness for the first case of Theorem 4.2 is P p 2 . In fact, the lower bound on the problem of equivalence <ref> [vdM92] </ref> implies that this is also the lower bound on the answer-completeness problem. The proof of Theorem 4.2 follows from Theorem 4.1 and from decidability results for query containment [SY81, Klu88, LS93]. <p> Therefore, removing such tuples will not change the result of the query . Detecting redundancy is a more expensive procedure than detecting satisfiability. For example, for conjunctive queries with comparison predicates, the time complexity of detecting redundancy is P p 2 <ref> [Klu88, vdM92] </ref>, while checking satisfiability can be done in polynomial time [Ull89]. The case we consider involves variable-interval queries and updates. In particular, a conjunctive query Q is a variable-interval query if all the built-in atoms in Q have one constant (i.e., there are no comparisons between pairs of variables).
References-found: 30

