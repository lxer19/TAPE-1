URL: http://www.cs.cornell.edu/Info/People/jackson/thesis/thesis.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/jackson/jackson.html
Root-URL: http://www.cs.cornell.edu
Title: ENHANCING THE NUPRL PROOF DEVELOPMENT SYSTEM AND APPLYING IT TO COMPUTATIONAL ABSTRACT ALGEBRA  
Author: Paul Bernard Jackson 
Degree: A Dissertation Presented to the Faculty of the Graduate School  in Partial Fulfillment of the Requirements for the Degree of Doctor of Philosophy by  
Date: January 1995  
Affiliation: of Cornell University  
Abstract-found: 0
Intro-found: 1
Reference: [ACHA90] <author> Stuart F. Allen, Robert L. Constable, Douglas J. Howe, and William B. Aitken. </author> <title> The semantics of reflected proof. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic and Computer Science, </booktitle> <pages> pages 95-107. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: The Nuprl type-theory is based on one of Martin-Lof's [ML82]. Nuprl's type-theory is discussed in more detail in Chapter 2. Theories developed in Nuprl include the fundamental theorem of arithmetic [How87], metatheory <ref> [Kno87, How88a, ACHA90, CH90] </ref>, category theory [AP90], Ramsey's theorem [Bas89], Higman's lemma [Mur90], hardware verification [BD89, Jac91, Lee92] and software verification [AL92, How88b]. The previous tactics used in Nuprl were developed in chief by Howe [How88a]. <p> (definition) facility, * moving to a completely new display-form selection and formatting facility, * the addition of a rule interpreter, so that most rules are not hard coded, but represented by objects in Nuprl's library, * the introduction of rules for universe-level polymorphism, * the addition of a reflection mechanism <ref> [ACHA90] </ref>, * the creation of a World-Wide-Web server for Nuprl so that theories can be interactively browsed from across the Internet. 1.5.2 Theorem Proving DeBruijn's Automath project was an early and very influential investigation into techniques for mechanically proof-checking mathematics [dB80]. <p> Constructive type theory offers no features for proving theorems about com 183 plexity, unless one considers adding in some reflection mechanism. A fair amount of work has been done in this direction in Nuprl <ref> [Kno87, How88a, ACHA90, CH90] </ref>. However, reflection in a constructive type theory requires constructing a theory of not only a functional programming language, but also a theory of sequents, rules and proofs; this is a much more challenging task, especially in a type theory as structurally complicated at Nuprl's.
Reference: [ACN90] <author> L. Augustsson, T. Coquand, and B. Nordstrom. </author> <title> A short description of another logical framework. </title> <booktitle> In Proc. of First Annual Workshop on Logical Framworks, </booktitle> <pages> pages 38-41, </pages> <address> Sophia-Antipolis, France, </address> <year> 1990. </year>
Reference-contexts: In this work, HOL's type theory takes on more the role of a metalogic. Recently, M. Gordon has also been investigating techniques for merging HOL with set theory [Gor94]. 13 Other theorem provers that use a constructive type theory and encode logic using the propositions-as-types correspondence include Alf <ref> [ACN90] </ref>, LEGO [Pol90], and Coq [DFH + 91]. Alf uses a more recent type theory of Martin-Lof's. Both LEGO and Coq use the Calculus of Constructions (CoC) [CH85], extending it with a kind of inductive definitions [Luo89, PPM89].
Reference: [Acz93] <author> Peter Aczel. </author> <title> Galois: a theory development project. </title> <type> manuscript, </type> <institution> University of Manchester, </institution> <year> 1993. </year>
Reference-contexts: Bailey developed a concrete theory of polynomials in one variable in the LEGO system and has proven the correctness of Euclid's algorithm over these polynomials [Bai93]. Aczel and Barthe are currently investigating doing Galois theory in LEGO <ref> [Acz93, Bar93] </ref>. The most significant differences between the CoC based type theories and Nuprl's, from the point of view of formalizing algebra, are in the treatment of equality and in that the CoC-based theories don't have a set type constructor.
Reference: [AL92] <author> Mark Aagaard and Miriam Leeser. </author> <title> Verifying a logic synthesis tool in Nuprl: A case study in software verification. </title> <editor> In Gregor Bochmann and David Probst, editors, </editor> <booktitle> Fourth International Workshop on Computer-Aided Verification, volume 663 of Lecture Notes in Computer Science, </booktitle> <pages> pages 69-81. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Nuprl's type-theory is discussed in more detail in Chapter 2. Theories developed in Nuprl include the fundamental theorem of arithmetic [How87], metatheory [Kno87, How88a, ACHA90, CH90], category theory [AP90], Ramsey's theorem [Bas89], Higman's lemma [Mur90], hardware verification [BD89, Jac91, Lee92] and software verification <ref> [AL92, How88b] </ref>. The previous tactics used in Nuprl were developed in chief by Howe [How88a]. In Chapter 3, I compare my tactics with those of Howe as well as with some rewriting tactics that Basin developed [Bas89].
Reference: [All87a] <author> Stuart F. Allen. </author> <title> A non-type theoretic definition of Martin-Lof's types. </title> <booktitle> In Proceedings of the Second Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 215-221. </pages> <publisher> IEEE, </publisher> <year> 1987. </year>
Reference-contexts: These type theories are constructive because they yield a constructive or intuitionistic logic, and because they give a recipe for automatically building functions that effect the constructions that theorems in constructive logic and mathematics talk about. Nuprl's type theory <ref> [C + 86, All87a, All87b] </ref> is most closely related to a type theory proposed by Martin-Lof in 1979 as a foundation for constructive mathematics [ML82]. The main differences are: * Martin-Lof's four kinds of judgement are reduced to one. Roughly speaking, a judgement is a kind of sequent. <p> Allen has given a semantics for Nuprl's type theory without the recursive or partial types <ref> [All87a, All87b] </ref>. This semantics takes the form of a second-order positive inductive definition that is both classical-set-theoretically valid and acceptable to most constructivist mathematicians. The definition is of a relation from which a type membership relation and a typed equality relation are derived.
Reference: [All87b] <author> Stuart F. Allen. </author> <title> A Non-Type-Theoretic Semantics for Type-Theoretic Language. </title> <type> Ph.D. dissertation, </type> <institution> Cornell University, </institution> <address> Ithaca, NY, </address> <year> 1987. </year> <type> TR 87-866. </type>
Reference-contexts: These type theories are constructive because they yield a constructive or intuitionistic logic, and because they give a recipe for automatically building functions that effect the constructions that theorems in constructive logic and mathematics talk about. Nuprl's type theory <ref> [C + 86, All87a, All87b] </ref> is most closely related to a type theory proposed by Martin-Lof in 1979 as a foundation for constructive mathematics [ML82]. The main differences are: * Martin-Lof's four kinds of judgement are reduced to one. Roughly speaking, a judgement is a kind of sequent. <p> Allen has given a semantics for Nuprl's type theory without the recursive or partial types <ref> [All87a, All87b] </ref>. This semantics takes the form of a second-order positive inductive definition that is both classical-set-theoretically valid and acceptable to most constructivist mathematicians. The definition is of a relation from which a type membership relation and a typed equality relation are derived. <p> This semantics for universe polymorphism is different from that proposed by Allen <ref> [All87b] </ref>. The level expression `e 1' is often abbreviated as e 0 . Note that it is often convenient to suppress the explicit mention of the universe levels, especially when a level expression is simply the level variable i or the level constant 1.
Reference: [All94] <author> Stuart F. Allen. </author> <title> formalization of a semantics for imperative programming languages. </title> <note> To appear in a Cornell University, </note> <institution> Department of Computer Science Technical Report, </institution> <year> 1994. </year>
Reference-contexts: They should be all publically available in the Nuprl V4.1 release sometime before the end of 1994 and also should be browseable on the World-Wide-Web [BCL + 94]. Contact the author for details. Other developments in Nuprl V4.1 include theories on the semantics of an imperative programming language <ref> [All94] </ref> and constructive real analysis [For93]. * core 1: Display forms for primitive terms. Definitions for propositions-as types correspondence. * core 2: Intuitionistic propositional and predicate logic. * bool 1: The boolean type and boolean operators. Demorgan laws and simplification theorems and tactics.
Reference: [AP90] <author> James A. Altucher and Prakash Panangaden. </author> <title> A mechanically assisted constructive proof in category theory. </title> <booktitle> In Proceedings of the 10th International Conference on Automated Deduction. </booktitle> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1990. </year> <note> (LNCS). 191 192 </note>
Reference-contexts: The Nuprl type-theory is based on one of Martin-Lof's [ML82]. Nuprl's type-theory is discussed in more detail in Chapter 2. Theories developed in Nuprl include the fundamental theorem of arithmetic [How87], metatheory [Kno87, How88a, ACHA90, CH90], category theory <ref> [AP90] </ref>, Ramsey's theorem [Bas89], Higman's lemma [Mur90], hardware verification [BD89, Jac91, Lee92] and software verification [AL92, How88b]. The previous tactics used in Nuprl were developed in chief by Howe [How88a]. <p> In Chapter 3, I compare my tactics with those of Howe as well as with some rewriting tactics that Basin developed [Bas89]. Others have experimented with constructing algebraic classes in Nuprl: Al-tucher and Panangaden produced a definition of a class of categories <ref> [AP90] </ref>, and Basin and Constable discuss abstract data-type definitions for multisets and for propositional logic [BC93]. Several major changes were made in moving from Nuprl V3 to Nuprl V4.1, aside from my work on the tactics and theories.
Reference: [AS85] <author> H. Abelson and G. J. Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: just achieved with the existing tactics that I have developed, it should be possible to produce both readable and completely formal expositions of small bodies of mathematics or computer science; for example, of a chapter or two of a book on number theory [HW78], `concrete mathematics' [GKP89] or functional programming <ref> [AS85, Pau91] </ref>. An interface between the World-Wide-Web [BCL + 94] and Nuprl is currently undergoing test.
Reference: [Bai93] <author> Anthony Bailey. </author> <title> Representing algebra in LEGO. </title> <type> Masters dissertation, </type> <institution> University of Edinburgh, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Both LEGO and Coq use the Calculus of Constructions (CoC) [CH85], extending it with a kind of inductive definitions [Luo89, PPM89]. Bailey developed a concrete theory of polynomials in one variable in the LEGO system and has proven the correctness of Euclid's algorithm over these polynomials <ref> [Bai93] </ref>. Aczel and Barthe are currently investigating doing Galois theory in LEGO [Acz93, Bar93]. <p> Algebraic classes would then be defined over setoids rather than types. The idea of setoids has been explored by members of the LEGO group including Pollack, Bailey and Barthe <ref> [Bar94, Bai93] </ref>. For simplicity, I chose in the work described described in this thesis to take an explicitly constructive approach as far as class definitions are concerned.
Reference: [Bar93] <author> Gilles Barthe. </author> <title> Formalizing galois theory. </title> <type> manuscript, </type> <institution> University of Manchester, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Bailey developed a concrete theory of polynomials in one variable in the LEGO system and has proven the correctness of Euclid's algorithm over these polynomials [Bai93]. Aczel and Barthe are currently investigating doing Galois theory in LEGO <ref> [Acz93, Bar93] </ref>. The most significant differences between the CoC based type theories and Nuprl's, from the point of view of formalizing algebra, are in the treatment of equality and in that the CoC-based theories don't have a set type constructor.
Reference: [Bar94] <author> Gilles Barthe. </author> <title> Mathematical concepts in type theory. </title> <type> manuscript, </type> <institution> University of Nijmegen, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: Algebraic classes would then be defined over setoids rather than types. The idea of setoids has been explored by members of the LEGO group including Pollack, Bailey and Barthe <ref> [Bar94, Bai93] </ref>. For simplicity, I chose in the work described described in this thesis to take an explicitly constructive approach as far as class definitions are concerned.
Reference: [Bas89] <author> David Basin. </author> <title> Building Problem Solving Environments in Constructive Type Theory. </title> <type> Ph.D. dissertation, </type> <institution> Cornell University, </institution> <address> Ithaca, NY, </address> <year> 1989. </year>
Reference-contexts: The Nuprl type-theory is based on one of Martin-Lof's [ML82]. Nuprl's type-theory is discussed in more detail in Chapter 2. Theories developed in Nuprl include the fundamental theorem of arithmetic [How87], metatheory [Kno87, How88a, ACHA90, CH90], category theory [AP90], Ramsey's theorem <ref> [Bas89] </ref>, Higman's lemma [Mur90], hardware verification [BD89, Jac91, Lee92] and software verification [AL92, How88b]. The previous tactics used in Nuprl were developed in chief by Howe [How88a]. In Chapter 3, I compare my tactics with those of Howe as well as with some rewriting tactics that Basin developed [Bas89]. <p> Ramsey's theorem <ref> [Bas89] </ref>, Higman's lemma [Mur90], hardware verification [BD89, Jac91, Lee92] and software verification [AL92, How88b]. The previous tactics used in Nuprl were developed in chief by Howe [How88a]. In Chapter 3, I compare my tactics with those of Howe as well as with some rewriting tactics that Basin developed [Bas89]. Others have experimented with constructing algebraic classes in Nuprl: Al-tucher and Panangaden produced a definition of a class of categories [AP90], and Basin and Constable discuss abstract data-type definitions for multisets and for propositional logic [BC93]. <p> Conversional languages 55 56 have been adopted in the HOL system [GM93], in Paulson's Isabelle system, in rewrite tactics written for Nuprl V3 <ref> [CH90, Bas89] </ref>, and in the rewrite package that I have developed for Nuprl V4.1. In Section 4.2, I introduce the notion of conversions and give examples of conversionals that I commonly use. Many examples of the use of this rewrite package can be found in later chapters. <p> This rewrite package has was also extensively used in Forester's implementation of constructive real analysis in Nuprl V4.1 [For93]. This package differs from that developed by Basin for Nuprl V3 <ref> [Bas89] </ref> in that he only implemented support for rewriting with respect to the = 2 equality relation of Nuprl's type theory and the if and only if relation (). He also didn't implement any direct computation conversions.
Reference: [Bat79] <author> Joseph L. Bates. </author> <title> A Logic For Correct Program Development. </title> <type> Ph.D. dissertation, </type> <institution> Cornell University, </institution> <year> 1979. </year>
Reference-contexts: specialized to obtain an implementation of the free abelian monoid class, and I generalized the construction of a monoid copower to obtain a free monoid algebra. 1.5 Previous and Related Work 1.5.1 In Nuprl The Nuprl project [CB83, C + 86] grew out of the earlier PL-CV [CJE82] and Lamb-daPrl <ref> [Bat79] </ref> projects in program verification and synthesis at Cornell, and the LCF project [GMW79] at Edinburgh. From LCF, Nuprl borrowed the idea of a tactic-driven refiner and the ML language for the tactics.
Reference: [BB85] <author> Errett Bishop and Douglas Bridges. </author> <title> Constructive Analysis. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: There were definitely exceptions, especially among logicians; for example, there was Brouwer who founded a school of `Intuitionistic' mathematics that was dogmatically constructive. Brouwer's work was revived by Heyting [Hey66] and Bishop <ref> [Bis67, BB85] </ref> who tried to show how to systematically hide constructive details so that constructive mathematics more resembled classical mathematics. Today, a few mathematicians are exploring constructive algebra in this light [MRR88, BB85]. Other investigations have been carried out where the computations are made more explicit [FS55, MN79]. <p> Brouwer's work was revived by Heyting [Hey66] and Bishop [Bis67, BB85] who tried to show how to systematically hide constructive details so that constructive mathematics more resembled classical mathematics. Today, a few mathematicians are exploring constructive algebra in this light <ref> [MRR88, BB85] </ref>. Other investigations have been carried out where the computations are made more explicit [FS55, MN79]. The strongest revival of interest in constructivity in algebra has undoubtably come from those concerned with the theory and design of computer algebra systems.
Reference: [BC85] <author> Joseph L. Bates and Robert L. Constable. </author> <title> Proofs as programs. </title> <journal> ACM Trans. Prog. Lang. Sys., </journal> <volume> 7(1) </volume> <pages> 113-136, </pages> <year> 1985. </year>
Reference-contexts: Since elements of types are often programs, a phrase commonly associated with the `propositions as types' approach is `proofs as programs' <ref> [BC85] </ref>. These type theories are constructive because they yield a constructive or intuitionistic logic, and because they give a recipe for automatically building functions that effect the constructions that theorems in constructive logic and mathematics talk about.
Reference: [BC93] <author> David A. Basin and Robert L. Constable. </author> <title> Metalogical frameworks. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Environments. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: Others have experimented with constructing algebraic classes in Nuprl: Al-tucher and Panangaden produced a definition of a class of categories [AP90], and Basin and Constable discuss abstract data-type definitions for multisets and for propositional logic <ref> [BC93] </ref>. Several major changes were made in moving from Nuprl V3 to Nuprl V4.1, aside from my work on the tactics and theories.
Reference: [BCL + 94] <author> Tim Berners-Lee, Robert Cailliau, Ari Luotonen, Henrik Frystyk Nielsen, and Arthur Secret. </author> <title> The World-Wide Web. </title> <journal> Communications of the ACM, </journal> <volume> 37(8) </volume> <pages> 76-82, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: There is not space in this thesis to give full listings for all these theories. They should be all publically available in the Nuprl V4.1 release sometime before the end of 1994 and also should be browseable on the World-Wide-Web <ref> [BCL + 94] </ref>. Contact the author for details. Other developments in Nuprl V4.1 include theories on the semantics of an imperative programming language [All94] and constructive real analysis [For93]. * core 1: Display forms for primitive terms. <p> An interface between the World-Wide-Web <ref> [BCL + 94] </ref> and Nuprl is currently undergoing test.
Reference: [BD89] <author> David A. Basin and Peter Delvecchio. </author> <title> Verification of combinational logic in Nuprl. In Hardware Specification, Verification and Synthesis: Mathematical Aspects, </title> <address> Ithaca, New York, </address> <year> 1989. </year>
Reference-contexts: The Nuprl type-theory is based on one of Martin-Lof's [ML82]. Nuprl's type-theory is discussed in more detail in Chapter 2. Theories developed in Nuprl include the fundamental theorem of arithmetic [How87], metatheory [Kno87, How88a, ACHA90, CH90], category theory [AP90], Ramsey's theorem [Bas89], Higman's lemma [Mur90], hardware verification <ref> [BD89, Jac91, Lee92] </ref> and software verification [AL92, How88b]. The previous tactics used in Nuprl were developed in chief by Howe [How88a]. In Chapter 3, I compare my tactics with those of Howe as well as with some rewriting tactics that Basin developed [Bas89].
Reference: [BG94] <author> Leo Bachmair and Harald Ganzinger. </author> <title> Ordered chaining for total or-derings. </title> <editor> In A. Bundy, editor, </editor> <booktitle> 12th Conference on Automated Deduction, Lecture Notes in Artifical Intelligence, </booktitle> <pages> pages 435-450. </pages> <publisher> Springer Verlag, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: To my knowledge, the issue of dealing with multiple strengths of rewrite relations has not yet been addressed anywhere other than in Nuprl. Researchers in the field of rewriting have begun to consider monotone rewriting <ref> [LA93, BG94] </ref>. It will be interesting to see whether these ideas can be adapted to work well in an interactive theorem proving context. Chapter 5 Methodology for Algebra 5.1 Introduction I discuss in this chapter some of the issues involved in defining classes of algebraic objects in Nuprl's type theory.
Reference: [Bis67] <author> Errett Bishop. </author> <title> Foundations of Constructive Analysis. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1967. </year> <month> 193 </month>
Reference-contexts: There were definitely exceptions, especially among logicians; for example, there was Brouwer who founded a school of `Intuitionistic' mathematics that was dogmatically constructive. Brouwer's work was revived by Heyting [Hey66] and Bishop <ref> [Bis67, BB85] </ref> who tried to show how to systematically hide constructive details so that constructive mathematics more resembled classical mathematics. Today, a few mathematicians are exploring constructive algebra in this light [MRR88, BB85]. Other investigations have been carried out where the computations are made more explicit [FS55, MN79].
Reference: [Bis70] <author> Errett Bishop. </author> <title> Mathematics as a Numerical Language. </title> <booktitle> In Intuitionism and Proof Theory, </booktitle> <pages> pages 53-71. </pages> <publisher> North-Holland, </publisher> <address> NY, </address> <year> 1970. </year>
Reference-contexts: For constructive mathematics to provide such a methodology, techniques are needed for systematically extracting programs from constructive proofs. Early work in this field includes that of Bishop <ref> [Bis70] </ref> and Constable [Con71]. What distinguished Martin-Lof's '82 type theory was that the method it suggested for program syn 5 thesis was exceptionally simple: a direct correspondence was set up between the constructs of mathematical logic, and the constructs of a functional programming language.
Reference: [Ble75] <author> W. W. Bledsoe. </author> <title> A new method for proving certain Presburger formulas. </title> <booktitle> In 4th International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 15-21, </pages> <address> Tiblsi, </address> <year> 1975. </year>
Reference-contexts: Arithmetic Reasoner I implemented a new inference rule for solving linear inequalities over the integers, based on Bledsoe's sup-inf algorithm <ref> [Ble75] </ref>. The chief enhancement I made was to take full advantage of the linear arithmetic properties of non-linear arithmetic functions and non-arithmetic functions that have integer values. Type-Checker All type checking in the Nuprl system is done by proof. <p> In practice in theorem proving, simple adaptations of methods over the rationals have worked well for the integers. I chose to implement in Nuprl a tactic that uses the Sup-Inf method for solving integer inequalities <ref> [Ble75] </ref>.
Reference: [BM79] <author> Robert S. Boyer and J. Strother Moore. </author> <title> A Computational Logic. </title> <booktitle> ACM Monograph Series. </booktitle> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: In terms of applying theorem-provers to hardware and software verification, most success has been with the NQTHM system of Boyer and Moore <ref> [BM79, BM88a] </ref>. Accomplishments include the checking the RSA public-key encryption algorithm [BM84] and the verification of microprocessor designs [HB92]. NQTHM has also been used to formalize Godel's incompleteness theorem [Sha86]. The generation of proofs in NQTHM is highly automated.
Reference: [BM84] <author> Robert Boyer and J. Strother Moore. </author> <title> Proof checking the RSA public key encription algorithm. </title> <journal> American Mathematical Monthly, </journal> <volume> 91(3) </volume> <pages> 181-189, </pages> <year> 1984. </year>
Reference-contexts: In terms of applying theorem-provers to hardware and software verification, most success has been with the NQTHM system of Boyer and Moore [BM79, BM88a]. Accomplishments include the checking the RSA public-key encryption algorithm <ref> [BM84] </ref> and the verification of microprocessor designs [HB92]. NQTHM has also been used to formalize Godel's incompleteness theorem [Sha86]. The generation of proofs in NQTHM is highly automated. The user commonly only guides proofs by perhaps giving a few high level hints and suggesting useful lemmas.
Reference: [BM88a] <author> Robert S. Boyer and J. Strother Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: An until-now fairly separate field of research has been the construction of mechanical theorem provers. I use this term here in a loose sense, encompassing not only resolution theorem provers and systems such as NQTHM <ref> [BM88a] </ref>, but also systems perhaps better called proof checkers such as Automath [dB80] and Mizar [Rud92], and proof development systems such as Nuprl and HOL [GM93]. <p> In terms of applying theorem-provers to hardware and software verification, most success has been with the NQTHM system of Boyer and Moore <ref> [BM79, BM88a] </ref>. Accomplishments include the checking the RSA public-key encryption algorithm [BM84] and the verification of microprocessor designs [HB92]. NQTHM has also been used to formalize Godel's incompleteness theorem [Sha86]. The generation of proofs in NQTHM is highly automated. <p> In resolution theorem provers, rewriting is often accomplished using the demodulation and paramodulation rules [WOEB84]. Most interactive theorem provers have some kind of rewriting facility. For example, the NQTHM prover uses rewriting heavily for simplification and for application of inductive hypotheses <ref> [BM88a] </ref>. Rewriting is also common in computer algebra systems. For example, Mathematica [Wol91] allows users to phrase transformation and simplification strategies as sets of rewrite rules. <p> As is done in NQTHM <ref> [BM88a] </ref>, and similar in style to the product operation mon_itop defined in Section 6.10, I found it very useful to define a For binding product operation over lists. for: == reduce (op;id;map (x:T. f [x];as)) mon_for: The typing lemmas for these are for_wf: 8A,B,C:U. 8f:B ! C ! C. 8k:C. 8as:A <p> Note that the insistence on functions being computable is not just a practice found in constructive type theories. It also occurs in simpler logics such as the `computational logic' of NQTHM <ref> [BM88a] </ref>. Other times though, I found the computability restrictions of Nuprl petty. For example, the split between the type of propositions and the type of booleans lead to | from a classical point of view | much unaesthetic duplication of definitions and theorems.
Reference: [BM88b] <author> Robert S. Boyer and J. Strother Moore. </author> <title> Integrating decision procedures into heuristic theorem provers: A case study with linear arithmetic. </title> <booktitle> In Machine Intelligence 11. </booktitle> <publisher> Oxford Universtiy Press, </publisher> <year> 1988. </year>
Reference-contexts: Of course, integrating decision procedures into theorem provers where proofs are mostly generated automatically is a much 182 different (and often much harder) problem, as is shown in Boyer and Moore's work in NQTHM <ref> [BM88b] </ref>. Much of the work in abstract algebra did make heavy use of Nuprl's dependent function and dependent product types ( and types), so I think it would be difficult to duplicate this work in say the present HOL system [GM93], which has a much simpler type theory.
Reference: [Bou74] <author> Nicolas Bourbaki. </author> <title> Algebra, Part I. Elements of Mathematics. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: In particular, every definition of a class, familiar in abstract algebra, can be viewed as an ADT specification. 1.4.3.1 Specification I created algebraic classes for monomials and polynomials based on the characterization found in Lang [Lan84] or Bourbaki <ref> [Bou74] </ref> of the algebra of polynomials as being a free monoid algebra over the ring of coefficients and the free abelian monoid of indeterminates. An interesting characteristic of this development was the treatment of freeness properties. <p> I based the ADT specification on the standard abstract mathematical characterization of multivariate polynomials found in say Lang [Lan84] or Bourbaki <ref> [Bou74] </ref>. The characterization defines algebraic structures for the monomials and polynomials over a given set of indeterminates and commutative ring of coefficients: 1. monomials are a free abelian monoid on the indeterminates. 2. polynomials are a free monoid algebra on the commutative ring of coefficients and the monoid of monomials.
Reference: [BvHH + 89] <author> Alan Bundy, Frank van Harmelen, Jane Hesketh, Alan Smaill, and Andrew Stevens. </author> <title> A rational reconstruction and extension of recursion analysis. </title> <booktitle> In International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 359-365, </pages> <address> Detroit, Michigan, </address> <year> 1989. </year>
Reference-contexts: in the work of Bundy and others; starting with a study of the rewriting strategies used in inductive proofs by NQTHM, they developed an elegant family of strategies that they have called rippling strategies, since the changes effected by rewrite rules propagate around term trees like ripples on a pond <ref> [BvHH + 89, BvHSI90] </ref>. To provide systematic control of rewriting in the LCF proof development system, Paulson introduced a language of conversions and conversionals [Pau83a, Pau87], reminiscent of the language of tactics and tacticals, which allows the piecing together of rewrite strategies from sets of rewrite rules.
Reference: [BvHSI90] <author> A. Bundy, F. van Harmelen, A. Smaill, and A. Ireland. </author> <title> Extensions to the rippling-out tactic for guiding inductive proofs. In M.E. </title> <editor> Stickel, editor, </editor> <booktitle> 10th International Conference on Automated Design, Lecture Notes in Artificial Intelligence, </booktitle> <volume> Vol. 449, </volume> <pages> pages 132-146. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: in the work of Bundy and others; starting with a study of the rewriting strategies used in inductive proofs by NQTHM, they developed an elegant family of strategies that they have called rippling strategies, since the changes effected by rewrite rules propagate around term trees like ripples on a pond <ref> [BvHH + 89, BvHSI90] </ref>. To provide systematic control of rewriting in the LCF proof development system, Paulson introduced a language of conversions and conversionals [Pau83a, Pau87], reminiscent of the language of tactics and tacticals, which allows the piecing together of rewrite strategies from sets of rewrite rules.
Reference: [BWi93] <author> Thomas Becker, Volker Weispfenning, </author> <title> and in cooperation with Heinz Kredel. Grobner Bases: a computational approach to commutative algebra. Graduate Texts in Mathematics. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: This algorithm in some form is used in many computer algebra systems today for solving 15 systems of polynomial equations. This algorithm and others are surveyed in many of the new texts that have come out recently on the mathematics of computer algebra <ref> [BWi93, CLO92, DST93, Mis93, Zip93a] </ref>. 1.6 Layout of Thesis The layout of the thesis is as follows: * Chapter 2 gives background information on Nuprl's type theory and the present state of the Nuprl V4.1 system.
Reference: [C + 86] <author> Robert Constable et al. </author> <title> Implementing Mathematics with The Nuprl Development System. </title> <publisher> Prentice-Hall, </publisher> <address> NJ, </address> <year> 1986. </year>
Reference-contexts: a very relevant to the program of formally verify core parts of theorem-proving and computer algebra systems; the implementation I chose to verify is similar to that which is commonly used in current computer algebra systems. 1.3 Overview of Nuprl System I took as my starting-point the Nuprl proof-development system <ref> [C + 86] </ref>. The core of Nuprl is a program called the refiner which has knowledge of a set of primitive inference rules and which is ultimately responsible for constructing every proof. Therefore, the correctness of proofs depends solely on the refiner. <p> Finite sets were defined as a subtype of these finite multisets and many of the finite multiset operations were given alternative characterizations on sets. The novelty of this development was chiefly in the use of Nuprl's quotient type <ref> [C + 86] </ref>. The quotient type allows hiding of internal structure of types; multi-sets were defined from lists by hiding the order of elements in lists. <p> I showed that any implementation of the monoid copower class can simply be specialized to obtain an implementation of the free abelian monoid class, and I generalized the construction of a monoid copower to obtain a free monoid algebra. 1.5 Previous and Related Work 1.5.1 In Nuprl The Nuprl project <ref> [CB83, C + 86] </ref> grew out of the earlier PL-CV [CJE82] and Lamb-daPrl [Bat79] projects in program verification and synthesis at Cornell, and the LCF project [GMW79] at Edinburgh. From LCF, Nuprl borrowed the idea of a tactic-driven refiner and the ML language for the tactics. <p> These type theories are constructive because they yield a constructive or intuitionistic logic, and because they give a recipe for automatically building functions that effect the constructions that theorems in constructive logic and mathematics talk about. Nuprl's type theory <ref> [C + 86, All87a, All87b] </ref> is most closely related to a type theory proposed by Martin-Lof in 1979 as a foundation for constructive mathematics [ML82]. The main differences are: * Martin-Lof's four kinds of judgement are reduced to one. Roughly speaking, a judgement is a kind of sequent. <p> The full set of rules for the Nuprl type theory can be found in the Nuprl book <ref> [C + 86] </ref> and in the system library. Thinking of the conclusions of sequents as types, all Nuprl rules have information about how to create an element of the conclusion of the rule consequent, given elements of the conclusions of each of the antecedents. <p> This problem can easily be rephrased as a linear programming problem for which the commonly used method in the operations research community is the simplex algorithm [Chv83]. Nuprl inherited from the PL-CV system built at Cornell a procedure called arith for solving arithmetic problems over the integers <ref> [CJE82, C + 86] </ref>. Roughly speaking, arith tries to solve a goal by putting arithmetic expressions into a normal form and then applying congruence closure. It also has some basic capabilities for solving inequalities.
Reference: [CB83] <author> Robert L. Constable and Joseph L. Bates. </author> <title> The nearly ultimate pearl. </title> <type> Technical Report TR 83-551, </type> <institution> Cornell University, </institution> <address> Ithaca, NY, </address> <month> January </month> <year> 1983. </year> <month> 194 </month>
Reference-contexts: I showed that any implementation of the monoid copower class can simply be specialized to obtain an implementation of the free abelian monoid class, and I generalized the construction of a monoid copower to obtain a free monoid algebra. 1.5 Previous and Related Work 1.5.1 In Nuprl The Nuprl project <ref> [CB83, C + 86] </ref> grew out of the earlier PL-CV [CJE82] and Lamb-daPrl [Bat79] projects in program verification and synthesis at Cornell, and the LCF project [GMW79] at Edinburgh. From LCF, Nuprl borrowed the idea of a tactic-driven refiner and the ML language for the tactics.
Reference: [CF58] <author> H. B. Curry and R. Feys. </author> <title> Combinatory Logic, volume I. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1958. </year>
Reference-contexts: Church introduced a `simple theory of types' [Chu40] that was adapted for use in the HOL theorem-proving system [GM93]. A recently-developed family of type theories is that of constructive type theories [Gir71, CH88]. These exploit a notion that has come to be known as the `propositions-as-types' correspondence <ref> [CF58, Sco70, Con71] </ref> where every logical proposition corresponds to a type, and a proof of a proposition involves finding an element of the type corresponding to the proposition. Since elements of types are often programs, a phrase commonly associated with the `propositions as types' approach is `proofs as programs' [BC85].
Reference: [CGG + 91] <author> Bruce W. Char, Keith O. Geddes, Gaston H. Gonnet, Benton L. Leong, Michael B. Monagan, and Stephen M. Watt. </author> <title> Maple V Language Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: For evidence of this, one only need look at the wealth of current work in scientific computation and numerical analysis. More recently, there has been very rapid growth in the popularity of computer algebra systems such as Mathematica [Wol91] and Maple <ref> [CGG + 91] </ref>. At their core, these systems have routines for carrying out such symbolic manipulations as factorizing polynomials, for computing integrals and differentials, and for finding symbolic solutions to sets of equations. They also provide languages for rapidly constructing packages that extend the systems' capabilities. <p> Further, users of computer algebra systems might well be unaware of the corners 1 2 that were cut by the programmers of the packages that they use. Computer algebra systems such as Maple <ref> [CGG + 91] </ref> and Axiom [JS92] are addressing the issue of the meaning of symbolic expressions by adopting sophisticated type systems. Some too make an attempt to track side conditions of calculations. However, all computer algebra systems lack the absolute notion of rigor found in mathematics. <p> Harrison developed some real analysis covering topics including limits of series, differentiability and properties of transcendental functions [Har92]. Harrison and Thery demonstrated using the Maple computer algebra system <ref> [CGG + 91] </ref> to factor and integrate expressions for HOL [HT93]. Maple's operations were verified in HOL by carrying out the much simpler inverse operations of expanding out factors and differentiation. E.
Reference: [CH85] <author> Thierry Coquand and Gerard Huet. </author> <title> Constructions: A higher order proof system for mechanizing mathematics. </title> <editor> In B. Buchberger, editor, </editor> <booktitle> EUROCAL '85: European Conference on Computer Algebra, </booktitle> <pages> pages 151-184. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Alf uses a more recent type theory of Martin-Lof's. Both LEGO and Coq use the Calculus of Constructions (CoC) <ref> [CH85] </ref>, extending it with a kind of inductive definitions [Luo89, PPM89]. Bailey developed a concrete theory of polynomials in one variable in the LEGO system and has proven the correctness of Euclid's algorithm over these polynomials [Bai93]. Aczel and Barthe are currently investigating doing Galois theory in LEGO [Acz93, Bar93].
Reference: [CH88] <author> Thierry Coquand and Gerard Huet. </author> <title> The Calculus of Constructions. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 95-120, </pages> <year> 1988. </year>
Reference-contexts: Church introduced a `simple theory of types' [Chu40] that was adapted for use in the HOL theorem-proving system [GM93]. A recently-developed family of type theories is that of constructive type theories <ref> [Gir71, CH88] </ref>. These exploit a notion that has come to be known as the `propositions-as-types' correspondence [CF58, Sco70, Con71] where every logical proposition corresponds to a type, and a proof of a proposition involves finding an element of the type corresponding to the proposition.
Reference: [CH90] <author> Robert L. Constable and Douglas J. Howe. </author> <title> Implementing metamathe-matics as an approach to automatic theorem proving. </title> <editor> In R.B. Banerji, editor, </editor> <booktitle> Formal Techniques in Artificial Intelligence: A Source Book, </booktitle> <pages> pages 45-76. </pages> <publisher> Elsevier Science Publishers (North-Holland), </publisher> <year> 1990. </year>
Reference-contexts: The Nuprl type-theory is based on one of Martin-Lof's [ML82]. Nuprl's type-theory is discussed in more detail in Chapter 2. Theories developed in Nuprl include the fundamental theorem of arithmetic [How87], metatheory <ref> [Kno87, How88a, ACHA90, CH90] </ref>, category theory [AP90], Ramsey's theorem [Bas89], Higman's lemma [Mur90], hardware verification [BD89, Jac91, Lee92] and software verification [AL92, How88b]. The previous tactics used in Nuprl were developed in chief by Howe [How88a]. <p> Conversional languages 55 56 have been adopted in the HOL system [GM93], in Paulson's Isabelle system, in rewrite tactics written for Nuprl V3 <ref> [CH90, Bas89] </ref>, and in the rewrite package that I have developed for Nuprl V4.1. In Section 4.2, I introduce the notion of conversions and give examples of conversionals that I commonly use. Many examples of the use of this rewrite package can be found in later chapters. <p> He also didn't implement any direct computation conversions. Howe also experimented with rewriting with respect to = 2 and (), and in constructing simplification conversions that grouped together sets of rewrite rules <ref> [CH90] </ref>. He did implement some direct-computation conversions, but these were not integrated with the tactic-based conversions and were much more basic than those that I developed. To my knowledge, the issue of dealing with multiple strengths of rewrite relations has not yet been addressed anywhere other than in Nuprl. <p> Constructive type theory offers no features for proving theorems about com 183 plexity, unless one considers adding in some reflection mechanism. A fair amount of work has been done in this direction in Nuprl <ref> [Kno87, How88a, ACHA90, CH90] </ref>. However, reflection in a constructive type theory requires constructing a theory of not only a functional programming language, but also a theory of sequents, rules and proofs; this is a much more challenging task, especially in a type theory as structurally complicated at Nuprl's.
Reference: [Che92] <author> W.Z. Chen. </author> <title> Tactic-based theorem proving and knowledge-based forward chaining. </title> <editor> In D. Kapur, editor, </editor> <booktitle> Eleventh International Conference on Automated Deduction, Lecture Notes in A.I., </booktitle> <volume> Vol. 607, </volume> <pages> pages 552-566. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: One other theorem-proving system worth mentioning is McAllester's Ontic system [McA89]. This system is based on Zermelo-Fraenkel set-theory. A milestone reached in it is the Stone representation theorem. Chen looked at adapting the inference algorithms that McAllester devised to the Nuprl environment <ref> [Che92] </ref>. 14 1.5.3 Computer Algebra Clarke and Zhao have added theorem-proving capabilities to Mathematica [Wol91] to create their Analytica system [CZ92]. They have impressive results in proving equivalences of sums of series, but their work has been hindered by the lack of rigor inherent in the Mathematica environment.
Reference: [Chu40] <author> A. Church. </author> <title> A formulation of the simple theory of types. </title> <journal> The Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 55-68, </pages> <year> 1940. </year>
Reference-contexts: The HOL system [GM93] is a tactic-based interactive theorem prover with a classical logic similar on Church's simple theory of types <ref> [Chu40] </ref> but with the addition of a type-polymorphism scheme similar to that found in the ML functional programming language. This theory is slightly weaker than ZF set theory. <p> The study of type theories is usually taken to have started with Russell's `theory of types' [Rus08, WR27] where a rather complicated system of types are introduced in order to avoid certain `vicious circle' paradoxes. Church introduced a `simple theory of types' <ref> [Chu40] </ref> that was adapted for use in the HOL theorem-proving system [GM93]. A recently-developed family of type theories is that of constructive type theories [Gir71, CH88].
Reference: [Chv83] <author> Vasek Chvatal. </author> <title> Linear Programming. </title> <publisher> Freeman, </publisher> <year> 1983. </year>
Reference-contexts: There are several standard algorithms for solving some kinds of arithmetic problems. For example, for deciding the satisfiability of conjunctions of inequalities over linear rational expressions, there is Fourier's technique of variable elimination that has been known for over a century <ref> [Chv83] </ref>. This problem can easily be rephrased as a linear programming problem for which the commonly used method in the operations research community is the simplex algorithm [Chv83]. <p> of conjunctions of inequalities over linear rational expressions, there is Fourier's technique of variable elimination that has been known for over a century <ref> [Chv83] </ref>. This problem can easily be rephrased as a linear programming problem for which the commonly used method in the operations research community is the simplex algorithm [Chv83]. Nuprl inherited from the PL-CV system built at Cornell a procedure called arith for solving arithmetic problems over the integers [CJE82, C + 86]. Roughly speaking, arith tries to solve a goal by putting arithmetic expressions into a normal form and then applying congruence closure.
Reference: [CJE82] <author> Robert L. Constable, Scott D. Johnson, and Carl D. Eichenlaub. </author> <title> Introduction to the PL/CV2 Programming Logic, </title> <booktitle> volume 135 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1982. </year>
Reference-contexts: can simply be specialized to obtain an implementation of the free abelian monoid class, and I generalized the construction of a monoid copower to obtain a free monoid algebra. 1.5 Previous and Related Work 1.5.1 In Nuprl The Nuprl project [CB83, C + 86] grew out of the earlier PL-CV <ref> [CJE82] </ref> and Lamb-daPrl [Bat79] projects in program verification and synthesis at Cornell, and the LCF project [GMW79] at Edinburgh. From LCF, Nuprl borrowed the idea of a tactic-driven refiner and the ML language for the tactics. <p> This problem can easily be rephrased as a linear programming problem for which the commonly used method in the operations research community is the simplex algorithm [Chv83]. Nuprl inherited from the PL-CV system built at Cornell a procedure called arith for solving arithmetic problems over the integers <ref> [CJE82, C + 86] </ref>. Roughly speaking, arith tries to solve a goal by putting arithmetic expressions into a normal form and then applying congruence closure. It also has some basic capabilities for solving inequalities.
Reference: [CLO92] <author> David Cox, John Little, and Donal O'Shea. </author> <title> Ideals, Varieties, and algorithms: an introduction to computational algebraic geometry and commutative algebra. Undergraduate Texts in Mathematics. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: This algorithm in some form is used in many computer algebra systems today for solving 15 systems of polynomial equations. This algorithm and others are surveyed in many of the new texts that have come out recently on the mathematics of computer algebra <ref> [BWi93, CLO92, DST93, Mis93, Zip93a] </ref>. 1.6 Layout of Thesis The layout of the thesis is as follows: * Chapter 2 gives background information on Nuprl's type theory and the present state of the Nuprl V4.1 system.
Reference: [CM85] <author> Robert L. Constable and Nax P. Mendler. </author> <title> Recursive definitions in type theory. </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Logics of Programs, </booktitle> <pages> pages 61-78, </pages> <address> Berlin, 1985. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This change enabled the reduction in kinds of judgement. * Nuprl's type theory has several extra types including the set type [Con85a], the quotient type [Con85a], recursive types <ref> [CM85] </ref>, and partial function 18 types [CS87]. Allen has given a semantics for Nuprl's type theory without the recursive or partial types [All87a, All87b]. This semantics takes the form of a second-order positive inductive definition that is both classical-set-theoretically valid and acceptable to most constructivist mathematicians.
Reference: [Con71] <author> Robert L. Constable. </author> <title> Constructive mathematics and automatic program writers. </title> <booktitle> In Proceedings of the IFIP Congress, </booktitle> <pages> pages 229-233, </pages> <address> Ljubljana, </address> <year> 1971. </year> <month> 195 </month>
Reference-contexts: For constructive mathematics to provide such a methodology, techniques are needed for systematically extracting programs from constructive proofs. Early work in this field includes that of Bishop [Bis70] and Constable <ref> [Con71] </ref>. What distinguished Martin-Lof's '82 type theory was that the method it suggested for program syn 5 thesis was exceptionally simple: a direct correspondence was set up between the constructs of mathematical logic, and the constructs of a functional programming language. <p> Church introduced a `simple theory of types' [Chu40] that was adapted for use in the HOL theorem-proving system [GM93]. A recently-developed family of type theories is that of constructive type theories [Gir71, CH88]. These exploit a notion that has come to be known as the `propositions-as-types' correspondence <ref> [CF58, Sco70, Con71] </ref> where every logical proposition corresponds to a type, and a proof of a proposition involves finding an element of the type corresponding to the proposition. Since elements of types are often programs, a phrase commonly associated with the `propositions as types' approach is `proofs as programs' [BC85].
Reference: [Con85a] <author> Robert L. Constable. </author> <title> Constructive mathematics as a programming logic I: some principles of theory. </title> <journal> In Annals of Mathematics, </journal> <volume> Vol. 24. </volume> <publisher> Elsevier Science Publishers, B.V. (North-Holland), </publisher> <year> 1985. </year> <title> Reprinted from Topics in the Theory of Computation, </title> <booktitle> Selected Papers of the Intl. Conf. on "Foundations of Computation Theory," FCT '83. </booktitle>
Reference-contexts: This change enabled the reduction in kinds of judgement. * Nuprl's type theory has several extra types including the set type <ref> [Con85a] </ref>, the quotient type [Con85a], recursive types [CM85], and partial function 18 types [CS87]. Allen has given a semantics for Nuprl's type theory without the recursive or partial types [All87a, All87b]. <p> This change enabled the reduction in kinds of judgement. * Nuprl's type theory has several extra types including the set type <ref> [Con85a] </ref>, the quotient type [Con85a], recursive types [CM85], and partial function 18 types [CS87]. Allen has given a semantics for Nuprl's type theory without the recursive or partial types [All87a, All87b]. This semantics takes the form of a second-order positive inductive definition that is both classical-set-theoretically valid and acceptable to most constructivist mathematicians.
Reference: [Con85b] <author> Robert L. Constable. </author> <title> The semantics of evidence. </title> <type> Technical Report TR 85-684, </type> <institution> Cornell University, Department of Computer Science, </institution> <address> Ithaca, New York, </address> <month> May </month> <year> 1985. </year>
Reference-contexts: It should be obvious whenever infix notation is being used. 2.1.3 Propositions Logic is injected into type theory using the propositions-as-types correspondence, so all propositional term constructors are defined from types <ref> [Con85b] </ref>. The definitions are: ? = def Void A ^ B = def A fi B A ) B = def A ! B 9x:A: B x = def x:A fi B x P i = def U i The symbol ? denotes falsity.
Reference: [CS87] <author> Robert L. Constable and Scott F. Smith. </author> <title> Partial objects in constructive type theory. </title> <booktitle> In Proceedings of the Second Annual Symposium on Logic in Computer Science. IEEE, </booktitle> <year> 1987. </year>
Reference-contexts: This change enabled the reduction in kinds of judgement. * Nuprl's type theory has several extra types including the set type [Con85a], the quotient type [Con85a], recursive types [CM85], and partial function 18 types <ref> [CS87] </ref>. Allen has given a semantics for Nuprl's type theory without the recursive or partial types [All87a, All87b]. This semantics takes the form of a second-order positive inductive definition that is both classical-set-theoretically valid and acceptable to most constructivist mathematicians.
Reference: [CZ92] <author> Edmund Clarke and Xudong Zhao. </author> <title> Analytica a theorem prover in Mathematica. </title> <editor> In D. Kapur, editor, </editor> <booktitle> 11th Conference on Automated Deduction, volume 607 of Lecture Notes in Artifical Intelligence, </booktitle> <pages> pages 761-765. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: A milestone reached in it is the Stone representation theorem. Chen looked at adapting the inference algorithms that McAllester devised to the Nuprl environment [Che92]. 14 1.5.3 Computer Algebra Clarke and Zhao have added theorem-proving capabilities to Mathematica [Wol91] to create their Analytica system <ref> [CZ92] </ref>. They have impressive results in proving equivalences of sums of series, but their work has been hindered by the lack of rigor inherent in the Mathematica environment.
Reference: [dB80] <author> N. G. de Bruijn. </author> <title> A survey of the project AUTOMATH. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, </editor> <booktitle> Essays in Combinatory Logic, Lambda Calculus, and Formalism, </booktitle> <pages> pages 589-606. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: An until-now fairly separate field of research has been the construction of mechanical theorem provers. I use this term here in a loose sense, encompassing not only resolution theorem provers and systems such as NQTHM [BM88a], but also systems perhaps better called proof checkers such as Automath <ref> [dB80] </ref> and Mizar [Rud92], and proof development systems such as Nuprl and HOL [GM93]. The HOL group refers to their system as a theorem proving environment, which I think is an apt phrase for describing all these kinds of system. <p> The most well-known foundational theories for mathematics are set theories; in particular Zermelo-Fraenkel set theory. However, it can be rather difficult and clumsy to reason about computations in set theory. Nuprl adopted a type-theoretic language close in spirit to that of DeBruijn's Automath system <ref> [dB80] </ref> and strongly influenced by work of Scott [Sco70] and Martin-Lof [ML82]. <p> for universe-level polymorphism, * the addition of a reflection mechanism [ACHA90], * the creation of a World-Wide-Web server for Nuprl so that theories can be interactively browsed from across the Internet. 1.5.2 Theorem Proving DeBruijn's Automath project was an early and very influential investigation into techniques for mechanically proof-checking mathematics <ref> [dB80] </ref>. Van Jutting formalized all of a foundational text on elementary analysis | Landau's "Grundla-gen" | in Automath [Jut77]. Recently, more mathematics has been formalized in the MIZAR system than any other.
Reference: [DFH + 91] <author> G. Dowek, A. Felty, H. Herbelin, G. Huet, C. Paulin, and B. Werner. </author> <title> The System Coq, V5.6, User's Guide. </title> <institution> INRIA, </institution> <month> September </month> <year> 1991. </year> <note> To appear as an INRIA technical report. </note>
Reference-contexts: Recently, M. Gordon has also been investigating techniques for merging HOL with set theory [Gor94]. 13 Other theorem provers that use a constructive type theory and encode logic using the propositions-as-types correspondence include Alf [ACN90], LEGO [Pol90], and Coq <ref> [DFH + 91] </ref>. Alf uses a more recent type theory of Martin-Lof's. Both LEGO and Coq use the Calculus of Constructions (CoC) [CH85], extending it with a kind of inductive definitions [Luo89, PPM89]. <p> These parsers often use type checking to resolve ambiguities and type inference to infer implicit type arguments. The automatic inference of implicit type information is common too in such systems as HOL [GM93] and Coq <ref> [DFH + 91] </ref>. Still, such an approach limits notation to being in one font without a full range of mathemtical symbols, subscripts and superscripts, and doesn't support two-dimensional notation.
Reference: [DGT92] <author> J. H. Davenport, P. Gianni, and B. M. Trager. </author> <title> Scratchpad's view of algebra II: A categorical view of factorization. Numerical Algorithms Group, </title> <year> 1992. </year>
Reference-contexts: On the other hand, I was able to develop the basic theory of common algebraic classes such as monoids, groups, rings and modules in a style similar to that adopted in the computer algebra system Axiom <ref> [JS92, DT92, DGT92] </ref>, and had success with interpreting free constructions computationally. <p> They have impressive results in proving equivalences of sums of series, but their work has been hindered by the lack of rigor inherent in the Mathematica environment. In several computer algebra systems, much effort has been put into allowing computations over a wide variety of types; for example Axiom <ref> [JS92, DT92, DGT92] </ref> which evolved from the ScratchPad system at IBM. There are strong similarities between Axiom's approach to constructivity and the approach adopted in this thesis. My interest in computer algebra has been stimulated by discussions with Zippel who has designed his own system Weyl [Zip93b]. <p> The approach I adopted to constructive algebra was predominantly an explicit one; that is, I assumed that constructions would always be made explicit and not be assumed implicit in the computational content of propositions. This approach was close in spirit to that taken in Scratchpad and Axiom <ref> [JS92, DT92, DGT92] </ref>. If inhabitants of algebraic classes were to have a decidable equality, then a function would be explicitly required to compute that equality in the signature.
Reference: [DJ90] <author> Nachum Dershowitz and Jean-Pierre Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 6. </booktitle> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: Usual treatments of rewriting <ref> [DJ90] </ref> assume that the equivalence relations being rewritten with respect to are global congruence relations, so that the substitutions suggested by rewrite rules are always valid. However, there are common instances where one wants to rewrite using relations that are not always respected. <p> Solving the inequalities themselves was fairly straightforward; I came up with an algorithm that always finds a match if there is one, and further which finds an equality match if possible [Jac94c]. Chapter 4 Rewriting 4.1 Introduction Rewriting <ref> [DJ90] </ref>, the process of using equations as transformational rules, is a common technique in theorem-proving. In resolution theorem provers, rewriting is often accomplished using the demodulation and paramodulation rules [WOEB84]. Most interactive theorem provers have some kind of rewriting facility.
Reference: [DST93] <author> J.H. Davenport, Y. Siret, and E. Tournier. </author> <title> Computer Algebra | Systems and Algorithms for Algebraic Computation. </title> <publisher> Academic Press, </publisher> <address> London, </address> <note> second edition, </note> <year> 1993. </year>
Reference-contexts: These freeness properties were viewed as the specifications for functions that instantiated the indeterminates in monomials and polynomials. 9 1.4.3.2 Implementation I based the implementation on the standard sparse representation of monomials and polynomials used in most computer algebra systems <ref> [DST93, Zip93a] </ref>. This representation involves using association lists (a-lists) of indeterminates and exponents to represent monomials, and a-lists of monomials and coefficients to represent polynomials. The keys (indices) of these a-lists were drawn from linear orders and the keys in an a-list were always maintained in order. <p> This algorithm in some form is used in many computer algebra systems today for solving 15 systems of polynomial equations. This algorithm and others are surveyed in many of the new texts that have come out recently on the mathematics of computer algebra <ref> [BWi93, CLO92, DST93, Mis93, Zip93a] </ref>. 1.6 Layout of Thesis The layout of the thesis is as follows: * Chapter 2 gives background information on Nuprl's type theory and the present state of the Nuprl V4.1 system. <p> The implementation verified is very similar to the basic sparse implementation described in texts on the design of computer algebra systems such as Davenport,Siret, Tournier <ref> [DST93] </ref> and Zippel [Zip93a]. This kind of implementation is in common use in current computer algebra systems.
Reference: [DT92] <author> J. H. Davenport and B. M. Trager. </author> <title> Scratchpad's view of algebra I: Basic commutative algebra. Numerical Algorithms Group, </title> <year> 1992. </year>
Reference-contexts: On the other hand, I was able to develop the basic theory of common algebraic classes such as monoids, groups, rings and modules in a style similar to that adopted in the computer algebra system Axiom <ref> [JS92, DT92, DGT92] </ref>, and had success with interpreting free constructions computationally. <p> They have impressive results in proving equivalences of sums of series, but their work has been hindered by the lack of rigor inherent in the Mathematica environment. In several computer algebra systems, much effort has been put into allowing computations over a wide variety of types; for example Axiom <ref> [JS92, DT92, DGT92] </ref> which evolved from the ScratchPad system at IBM. There are strong similarities between Axiom's approach to constructivity and the approach adopted in this thesis. My interest in computer algebra has been stimulated by discussions with Zippel who has designed his own system Weyl [Zip93b]. <p> The approach I adopted to constructive algebra was predominantly an explicit one; that is, I assumed that constructions would always be made explicit and not be assumed implicit in the computational content of propositions. This approach was close in spirit to that taken in Scratchpad and Axiom <ref> [JS92, DT92, DGT92] </ref>. If inhabitants of algebraic classes were to have a decidable equality, then a function would be explicitly required to compute that equality in the signature.
Reference: [Dum77] <author> Michael Dummett. </author> <title> Elements of Intuitionism. </title> <booktitle> Oxford Logic Series. </booktitle> <publisher> Clarendon Press, Oxford, </publisher> <year> 1977. </year> <month> 196 </month>
Reference-contexts: An ongoing project at Cornell is to set up links between Nuprl and Weyl. 1.5.4 Constructive Mathematics Excellent introductions to constructivism in mathematics have been given by for example, Troelstra and van Dalen [TvD88] and Dummett <ref> [Dum77] </ref>. Throughout the history of mathematics there has been some sensitivity to constructivity in algebra.
Reference: [Edw89] <author> H. M. Edwards. </author> <title> Kronecker's views on the foundations of Mathematics. </title> <institution> Courant Institute of Mathematical Sciences, </institution> <address> New York University, New York, </address> <year> 1989. </year>
Reference-contexts: Throughout the history of mathematics there has been some sensitivity to constructivity in algebra. For example, Edwards <ref> [Edw89] </ref> wrote in summarizing Kronecker's views: "Kronecker believed that a mathematical concept was not well defined until you had shown how, in each specific instance, to decide [algorithmically] whether the definition was fulfilled or not." However, after the turn of the century when significant new results were proven non-constructively (for example,
Reference: [FGT92a] <author> William M. Farmer, Joshua D. Guttman, and F. Javier Thayer. IMPS: </author> <title> System description. </title> <editor> In D. Kapur, editor, </editor> <booktitle> 11th Conference on Automated Deduction, volume 607 of Lecture Notes in Artifical Intelligence, </booktitle> <pages> pages 701-705. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: This tactic paradigm was introduced in the LCF system [GMW79] and has also been adopted in theorem provers such as HOL [GM93] and LEGO [Pol90]. Other interactive theorem provers such as IMPS <ref> [FGT92a] </ref>, and PVS [ORS92] have proof development languages that have many similarities with tactic languages. Ideally, all the rules the refiner implements should be in some sense straightforward and obviously correct.
Reference: [FGT92b] <author> William M. Farmer, Joshua D. Guttman, and F. Javier Thayer. </author> <title> Little theories. </title> <editor> In D. Kapur, editor, </editor> <booktitle> 11th Conference on Automated Deduction, volume 607 of Lecture Notes in Artifical Intelligence, </booktitle> <pages> pages 567-581. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Type-checking is decidable in these systems, but doing abstract algebra is rather involved. The approaches that have been looked at involve using a somewhat cumbersome encoding for sets called setoids. I discuss these in Chapter 5. Theorem provers such as Larch [GH93], IMPS <ref> [FGT92b] </ref>, PVS [ORS92], and 2OBJ [GSHH91] have notions of theories or modules which allow the collection together of type definitions, operator definitions and specification of predicates that the operators must satisfy. Further, these modules can be parameterized by one another and can inherit structure from one another. <p> There is the issue here of how the matcher would guess appropriate instantiations, and in practice, there probably would be some way for the user to provide suitable hints to the matcher. The developers of the IMPS theorem prover have experimented with such ideas <ref> [FGT92b] </ref> and it would be interesting to see whether these could be adapted to Nuprl. For simplicity, I have not touched the matcher, but have written utility functions that automatically instantiate sets of similar lemmas.
Reference: [For93] <author> Max B. Forester. </author> <title> Formalizing constructive real analysis. </title> <type> Technical Report TR93-1382, </type> <institution> Computer Science Dept., Cornell University, </institution> <address> Ithaca, NY, </address> <year> 1993. </year>
Reference-contexts: Contact the author for details. Other developments in Nuprl V4.1 include theories on the semantics of an imperative programming language [All94] and constructive real analysis <ref> [For93] </ref>. * core 1: Display forms for primitive terms. Definitions for propositions-as types correspondence. * core 2: Intuitionistic propositional and predicate logic. * bool 1: The boolean type and boolean operators. Demorgan laws and simplification theorems and tactics. <p> This needs a bit of explaining. Proofs involving transitive relations and monotonicity properties of terms can be made very similar in structure to those involving equivalence relations and congruence properties. For example, consider the following proof step that came up Forester's development of real analysis in Nuprl <ref> [For93] </ref>. i:N + f :N + ! N + mono (f ) ` BY RWH (RevLemmaC `monotone le`) 0 ` 59 Here, the definition mono (f ) is: mono (f ) = def 8a; b:N + : a &lt; b ) f a &lt; f b and the theorem monotone_le is: <p> I give several examples later on of how I exploited features such as handling differing strengths of rewrite relations, handling monotone reasoning, and using the second-order matching. This rewrite package has was also extensively used in Forester's implementation of constructive real analysis in Nuprl V4.1 <ref> [For93] </ref>. This package differs from that developed by Basin for Nuprl V3 [Bas89] in that he only implemented support for rewriting with respect to the = 2 equality relation of Nuprl's type theory and the if and only if relation (). He also didn't implement any direct computation conversions.
Reference: [FS55] <author> A. Frolich and J.E. Shepherdson. </author> <title> Effective procedures in field theory. </title> <journal> Philosophical Transactions of the Royal Society, Series A, </journal> <volume> 284(950) </volume> <pages> 407-432, </pages> <year> 1955. </year>
Reference-contexts: Today, a few mathematicians are exploring constructive algebra in this light [MRR88, BB85]. Other investigations have been carried out where the computations are made more explicit <ref> [FS55, MN79] </ref>. The strongest revival of interest in constructivity in algebra has undoubtably come from those concerned with the theory and design of computer algebra systems.
Reference: [GH93] <author> John V. Guttag and James J. Horning. </author> <title> Larch: Languages and Tools for Formal Specification. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Type-checking is decidable in these systems, but doing abstract algebra is rather involved. The approaches that have been looked at involve using a somewhat cumbersome encoding for sets called setoids. I discuss these in Chapter 5. Theorem provers such as Larch <ref> [GH93] </ref>, IMPS [FGT92b], PVS [ORS92], and 2OBJ [GSHH91] have notions of theories or modules which allow the collection together of type definitions, operator definitions and specification of predicates that the operators must satisfy. Further, these modules can be parameterized by one another and can inherit structure from one another.
Reference: [Gir71] <author> J.-Y. Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination des coupures dans l'analyse et la theorie des types. </title> <editor> In J. E. Fenstad, editor, </editor> <booktitle> Second Scandinavian Logic Symposium, </booktitle> <pages> pages 63-92, </pages> <address> Amsterdam, 1971. </address> <publisher> North-Holland. </publisher>
Reference-contexts: Church introduced a `simple theory of types' [Chu40] that was adapted for use in the HOL theorem-proving system [GM93]. A recently-developed family of type theories is that of constructive type theories <ref> [Gir71, CH88] </ref>. These exploit a notion that has come to be known as the `propositions-as-types' correspondence [CF58, Sco70, Con71] where every logical proposition corresponds to a type, and a proof of a proposition involves finding an element of the type corresponding to the proposition.
Reference: [GK94] <author> Michael R. Genesereth and Steven P. Ketchpel. </author> <title> Software agents. </title> <journal> Communications of the ACM, </journal> <volume> 37(7) 48-53,147, </volume> <month> July </month> <year> 1994. </year>
Reference-contexts: Rather, it is probably best to create an environment in which these tools can interact in ways that are both rich and varied, yet also completely formal. This topic is currently being pursued by the Logic Group at Stanford <ref> [GK94] </ref>, and there is considerable interest in it at Cornell. * As shown in this thesis, the Nuprl system can produce quite readable proofs.
Reference: [GKP89] <author> Ronald L. Graham, Donald E. Knuth, and Oren Patashnik. </author> <title> Concrete mathematics: a foundation for computer science. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: increase in automation, possibly just achieved with the existing tactics that I have developed, it should be possible to produce both readable and completely formal expositions of small bodies of mathematics or computer science; for example, of a chapter or two of a book on number theory [HW78], `concrete mathematics' <ref> [GKP89] </ref> or functional programming [AS85, Pau91]. An interface between the World-Wide-Web [BCL + 94] and Nuprl is currently undergoing test.
Reference: [GM93] <author> M. J. C. Gordon and T. F. Melham, </author> <title> editors. Introduction to HOL: A theorem proving environment for higher order logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: I use this term here in a loose sense, encompassing not only resolution theorem provers and systems such as NQTHM [BM88a], but also systems perhaps better called proof checkers such as Automath [dB80] and Mizar [Rud92], and proof development systems such as Nuprl and HOL <ref> [GM93] </ref>. The HOL group refers to their system as a theorem proving environment, which I think is an apt phrase for describing all these kinds of system. Such systems all support notions of definition, theorem and proof analogous to those that a mathematician employs. <p> This logic is too weak for abstract algebra: there is no way to define algebraic classes of objects and reason with them in ways common in 12 algebra, though `functional instantiation' extensions do allow some basic algebraic reasoning. The HOL system <ref> [GM93] </ref> is a tactic-based interactive theorem prover with a classical logic similar on Church's simple theory of types [Chu40] but with the addition of a type-polymorphism scheme similar to that found in the ML functional programming language. This theory is slightly weaker than ZF set theory. <p> Church introduced a `simple theory of types' [Chu40] that was adapted for use in the HOL theorem-proving system <ref> [GM93] </ref>. A recently-developed family of type theories is that of constructive type theories [Gir71, CH88]. <p> These parsers often use type checking to resolve ambiguities and type inference to infer implicit type arguments. The automatic inference of implicit type information is common too in such systems as HOL <ref> [GM93] </ref> and Coq [DFH + 91]. Still, such an approach limits notation to being in one font without a full range of mathemtical symbols, subscripts and superscripts, and doesn't support two-dimensional notation. <p> Tactics can be quite sophisticated, but still the correctness of any proof doesn't depend on them, only on the underlying refiner. This tactic paradigm was introduced in the LCF system [GMW79] and has also been adopted in theorem provers such as HOL <ref> [GM93] </ref> and LEGO [Pol90]. Other interactive theorem provers such as IMPS [FGT92a], and PVS [ORS92] have proof development languages that have many similarities with tactic languages. Ideally, all the rules the refiner implements should be in some sense straightforward and obviously correct. <p> Conversional languages 55 56 have been adopted in the HOL system <ref> [GM93] </ref>, in Paulson's Isabelle system, in rewrite tactics written for Nuprl V3 [CH90, Bas89], and in the rewrite package that I have developed for Nuprl V4.1. In Section 4.2, I introduce the notion of conversions and give examples of conversionals that I commonly use. <p> Much of the work in abstract algebra did make heavy use of Nuprl's dependent function and dependent product types ( and types), so I think it would be difficult to duplicate this work in say the present HOL system <ref> [GM93] </ref>, which has a much simpler type theory.
Reference: [GM94] <editor> Carl A. Gunter and John C. Mitchell, editors. </editor> <booktitle> Theoretical aspects of object-oriented programming: types, semantics, and language design. Foundations of Computing. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year> <month> 197 </month>
Reference-contexts: It would be interesting to see if this work could be tied in to current research in type systems for object-oriented programming <ref> [GM94] </ref>, where similar is sues crop up. * The work described in this thesis has many connections with that going on in the implementation and use of computer algebra systems.
Reference: [GMW79] <author> Michael J. Gordon, Robin Milner, and Christopher P. Wadsworth. </author> <title> Edinburgh LCF: A Mechanized Logic of Computation, </title> <booktitle> volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: generalized the construction of a monoid copower to obtain a free monoid algebra. 1.5 Previous and Related Work 1.5.1 In Nuprl The Nuprl project [CB83, C + 86] grew out of the earlier PL-CV [CJE82] and Lamb-daPrl [Bat79] projects in program verification and synthesis at Cornell, and the LCF project <ref> [GMW79] </ref> at Edinburgh. From LCF, Nuprl borrowed the idea of a tactic-driven refiner and the ML language for the tactics. Nuprl's original arithmetic decision procedure `arith' came from the PL-CV2 system, as did ideas for 10 the user interface. <p> Instead, one invokes programs written in ML (see Section 2.2.8) called tactics that automatically select and sequence appropriate rules. Tactics can be quite sophisticated, but still the correctness of any proof doesn't depend on them, only on the underlying refiner. This tactic paradigm was introduced in the LCF system <ref> [GMW79] </ref> and has also been adopted in theorem provers such as HOL [GM93] and LEGO [Pol90]. Other interactive theorem provers such as IMPS [FGT92a], and PVS [ORS92] have proof development languages that have many similarities with tactic languages. <p> Usually, it is pretty easy to fix such proofs. 2.2.8 The ML Language The ML language used in Nuprl is a functional language closely-related to the ML of the Edinburgh LCF theorem proving system <ref> [GMW79] </ref> and is a predecessor of ML used in Cambridge LCF [Pau85] and the SML language [MTH91, Pau91]. As in the LCF system, ML is used for writing all the tactics (ML originally stood for meta-language; it was designed for writing tactics).
Reference: [Gor94] <author> M.J.C. Gordon. </author> <title> Merging hol with set theory: preliminary experiments. </title> <type> Technical Report 353, </type> <institution> University of Cambridge Computer Laboratory, </institution> <year> 1994. </year>
Reference-contexts: Embeddings of set theory without this restriction are being explored by R. Jones at ICL in the UK. In this work, HOL's type theory takes on more the role of a metalogic. Recently, M. Gordon has also been investigating techniques for merging HOL with set theory <ref> [Gor94] </ref>. 13 Other theorem provers that use a constructive type theory and encode logic using the propositions-as-types correspondence include Alf [ACN90], LEGO [Pol90], and Coq [DFH + 91]. Alf uses a more recent type theory of Martin-Lof's.
Reference: [Gro91] <institution> The HOL Group. </institution> <note> HOL tutorial manual. Available on World-Wide Web at http://lal.cs.byu.edu/lal/holdoc/tutorial.html, 1991. </note>
Reference-contexts: E. Gunter [Gun89] developed a basic theory of groups, proved the group isomorphism theorems and showed that the integers mod n form a group. A. Gordon demonstrated how to prove the binomial theorem over arbitrary rings <ref> [Gro91] </ref>. Formulating abstract algebra in HOL is awkward because the type theory provides so few features in comparison with set theory. Decisions have to be made about how to represent the most basic notions of algebra in the type theory: notions such as set, cartesian product and function space.
Reference: [GSHH91] <author> Joseph Goguen, Andrew Stevens, Hendrik Hilberdink, and Keith Hobley. 2OBJ: </author> <title> A metalogical framework based on equational logic. </title> <type> manuscript, </type> <institution> Programming Research Group, Oxford University, </institution> <year> 1991. </year>
Reference-contexts: Type-checking is decidable in these systems, but doing abstract algebra is rather involved. The approaches that have been looked at involve using a somewhat cumbersome encoding for sets called setoids. I discuss these in Chapter 5. Theorem provers such as Larch [GH93], IMPS [FGT92b], PVS [ORS92], and 2OBJ <ref> [GSHH91] </ref> have notions of theories or modules which allow the collection together of type definitions, operator definitions and specification of predicates that the operators must satisfy. Further, these modules can be parameterized by one another and can inherit structure from one another.
Reference: [Gun89] <author> Elsa L. Gunter. </author> <title> Doing algebra in simple type theory. </title> <type> Technical Report MS-CIS-89-38, </type> <institution> Department of computer and Information Science, University of Pennsylvania, </institution> <year> 1989. </year>
Reference-contexts: Harrison and Thery demonstrated using the Maple computer algebra system [CGG + 91] to factor and integrate expressions for HOL [HT93]. Maple's operations were verified in HOL by carrying out the much simpler inverse operations of expanding out factors and differentiation. E. Gunter <ref> [Gun89] </ref> developed a basic theory of groups, proved the group isomorphism theorems and showed that the integers mod n form a group. A. Gordon demonstrated how to prove the binomial theorem over arbitrary rings [Gro91].
Reference: [Har92] <author> John Harrison. </author> <title> The HOL reals library. </title> <note> Available on World-Wide Web at http://lal.cs.byu.edu/lal/holdoc/library/reals.dvi, July 1992. </note>
Reference-contexts: HOL has mostly been used in domains related to hardware and software verification, though its foundational theories are quite general purpose and some success has been had with more abstract mathematics. Harrison developed some real analysis covering topics including limits of series, differentiability and properties of transcendental functions <ref> [Har92] </ref>. Harrison and Thery demonstrated using the Maple computer algebra system [CGG + 91] to factor and integrate expressions for HOL [HT93]. Maple's operations were verified in HOL by carrying out the much simpler inverse operations of expanding out factors and differentiation. E.
Reference: [HB70] <author> D. Hilbert and P. Bernays. </author> <title> Grundlagen der Mathematik, volume II. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1970. </year>
Reference-contexts: Note that Howe showed that it is consistent to add such functions [How91a] to the type theory, and also, one can always prove theorems with an explicit hypothesis about the existence say of an * Hilbert choice function <ref> [HB70] </ref>. I did not explore either of these approaches here.
Reference: [HB92] <author> Warren A Hunt, Jr. and Bishop C. Brock. </author> <title> A formal HDL and its use in the FM9001 verification. </title> <journal> Philosophical Transactions of the Royal Society, Series A, </journal> <volume> 339(1652) </volume> <pages> 35-47, </pages> <month> 15 April </month> <year> 1992. </year>
Reference-contexts: In terms of applying theorem-provers to hardware and software verification, most success has been with the NQTHM system of Boyer and Moore [BM79, BM88a]. Accomplishments include the checking the RSA public-key encryption algorithm [BM84] and the verification of microprocessor designs <ref> [HB92] </ref>. NQTHM has also been used to formalize Godel's incompleteness theorem [Sha86]. The generation of proofs in NQTHM is highly automated. The user commonly only guides proofs by perhaps giving a few high level hints and suggesting useful lemmas.
Reference: [Hey66] <author> A. Heyting. </author> <title> Intuitionism, An Introduction. </title> <publisher> North-Holland, </publisher> <address> Amster-dam, </address> <year> 1966. </year>
Reference-contexts: There were definitely exceptions, especially among logicians; for example, there was Brouwer who founded a school of `Intuitionistic' mathematics that was dogmatically constructive. Brouwer's work was revived by Heyting <ref> [Hey66] </ref> and Bishop [Bis67, BB85] who tried to show how to systematically hide constructive details so that constructive mathematics more resembled classical mathematics. Today, a few mathematicians are exploring constructive algebra in this light [MRR88, BB85].
Reference: [Hic94] <author> Jason Hickey. </author> <title> Highly dependent function types. Nuprl internal document, </title> <month> September </month> <year> 1994. </year>
Reference-contexts: To make such a type sensible, some well-founded ordering would need to be placed on the arguments. Perhaps such a type could be added. Hickey has been looking into this possibility <ref> [Hic94] </ref>. 80 Alternatively, a combination of types and record types could be used, since the degree of dependency in most class signatures is fairly small. <p> As indicated in Section 5.4, there is still some room for progress to be made within Nuprl's current type theory, and Jason Hickey, a graduate student at Cornell, has started on work looking at helpful extensions to the type theory to better support inheritance and subtyping <ref> [Hic94] </ref>.
Reference: [HL78] <author> Gerard Huet and Bernard Lang. </author> <title> Proving and applying program transformations expressed with second-order patterns. </title> <journal> Acta Informatica, </journal> <volume> 11 </volume> <pages> 31-55, </pages> <year> 1978. </year>
Reference-contexts: Nuprl V4.1's matching routine is based on a second-order restriction <ref> [HL78] </ref> of Huet's higher-order unification algorithm [Hue75]. This second-order routine handles patterns with bound variables, in contrast to Nuprl V3's first-order routine which did not.
Reference: [How87] <author> Douglas J. Howe. </author> <title> Implementing number theory: An experiment with Nuprl. </title> <booktitle> In Eighth Conference on Automated Deduction, volume 230 of Lecture Notes in Computer Science, </booktitle> <pages> pages 404-415. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1987. </year> <month> 198 </month>
Reference-contexts: All together over the years, over a dozen people have been involved in various ways with the Nuprl project. The Nuprl type-theory is based on one of Martin-Lof's [ML82]. Nuprl's type-theory is discussed in more detail in Chapter 2. Theories developed in Nuprl include the fundamental theorem of arithmetic <ref> [How87] </ref>, metatheory [Kno87, How88a, ACHA90, CH90], category theory [AP90], Ramsey's theorem [Bas89], Higman's lemma [Mur90], hardware verification [BD89, Jac91, Lee92] and software verification [AL92, How88b]. The previous tactics used in Nuprl were developed in chief by Howe [How88a].
Reference: [How88a] <author> Douglas J. Howe. </author> <title> Automating Reasoning in an Implementation of Constructive Type Theory. </title> <type> Ph.D. dissertation, </type> <institution> Cornell University, </institution> <address> Ithaca, NY, </address> <month> April </month> <year> 1988. </year>
Reference-contexts: The Nuprl type-theory is based on one of Martin-Lof's [ML82]. Nuprl's type-theory is discussed in more detail in Chapter 2. Theories developed in Nuprl include the fundamental theorem of arithmetic [How87], metatheory <ref> [Kno87, How88a, ACHA90, CH90] </ref>, category theory [AP90], Ramsey's theorem [Bas89], Higman's lemma [Mur90], hardware verification [BD89, Jac91, Lee92] and software verification [AL92, How88b]. The previous tactics used in Nuprl were developed in chief by Howe [How88a]. <p> Theories developed in Nuprl include the fundamental theorem of arithmetic [How87], metatheory [Kno87, How88a, ACHA90, CH90], category theory [AP90], Ramsey's theorem [Bas89], Higman's lemma [Mur90], hardware verification [BD89, Jac91, Lee92] and software verification [AL92, How88b]. The previous tactics used in Nuprl were developed in chief by Howe <ref> [How88a] </ref>. In Chapter 3, I compare my tactics with those of Howe as well as with some rewriting tactics that Basin developed [Bas89]. <p> There, second-order variable instances are simulated by applications of first-order variables, and second-order substitution is simulated by a combination of first-order substitution and beta-reduction. 3.10.2 Match Extension I used a match extension routine, much as described by Howe <ref> [How88a] </ref>; instantiating bindings for universally quantified expressions cannot always be figured out solely from initial matches. in some cases one has to go through an iterative process of matching types of existing bindings against the types of the corresponding variables in the universally quantified expressions. <p> Constructive type theory offers no features for proving theorems about com 183 plexity, unless one considers adding in some reflection mechanism. A fair amount of work has been done in this direction in Nuprl <ref> [Kno87, How88a, ACHA90, CH90] </ref>. However, reflection in a constructive type theory requires constructing a theory of not only a functional programming language, but also a theory of sequents, rules and proofs; this is a much more challenging task, especially in a type theory as structurally complicated at Nuprl's.
Reference: [How88b] <author> Douglas J. Howe. </author> <title> Computational metatheory in Nuprl. </title> <booktitle> CADE-9, </booktitle> <pages> pages 238-257, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Nuprl's type-theory is discussed in more detail in Chapter 2. Theories developed in Nuprl include the fundamental theorem of arithmetic [How87], metatheory [Kno87, How88a, ACHA90, CH90], category theory [AP90], Ramsey's theorem [Bas89], Higman's lemma [Mur90], hardware verification [BD89, Jac91, Lee92] and software verification <ref> [AL92, How88b] </ref>. The previous tactics used in Nuprl were developed in chief by Howe [How88a]. In Chapter 3, I compare my tactics with those of Howe as well as with some rewriting tactics that Basin developed [Bas89].
Reference: [How89] <author> Douglas J. Howe. </author> <title> Equality in lazy computation systems. </title> <booktitle> Proc. Fourth Symp. Logic in Computer Science, IEEE, </booktitle> <pages> pages 198-203, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Nuprl has a rich variety of equality and equivalence relations, some primitive and some user defined. The strongest, a computational equality relation, has been shown to be a congruence relation everywhere <ref> [How89] </ref>; it is always valid to replace some term by a computationally equivalent one. However, many other relations are only congruence relations in certain contexts. Rewriting with respect to the computational equality is justified using direct-computation primitive rules. All other rewrites are justified by tactics that construct congruence proofs.
Reference: [How91a] <author> Douglas J. Howe. </author> <title> On computational open-endedness in Martin-Lof's type theory. </title> <booktitle> In Proceedings of Sixth Symposium on Logic in Computer Science, </booktitle> <pages> pages 162-172. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1991. </year>
Reference-contexts: The definition essentially if of a term model in that terms do not denote anything other than themselves. Mendler [Men88] gave a semantics for Nuprl's recursive types and Smith [Smi89] gave a semantics for the partial function types. Howe <ref> [How91a] </ref> has given a set-theoretic model in which terms denote sets, and has shown by this model that it is consistent to extend Nuprl's type theory with oracle functions so that the logic created by the propositions-as-types correspondence is classical. <p> The doubling was needed so that a computable function for taking inverses of permutations could be defined; in keeping with the constructive approach of Nuprl's type theory, no methods are provided for constructing non-computable functions. Note that Howe showed that it is consistent to add such functions <ref> [How91a] </ref> to the type theory, and also, one can always prove theorems with an explicit hypothesis about the existence say of an * Hilbert choice function [HB70]. I did not explore either of these approaches here.
Reference: [How91b] <author> Douglas J. Howe. </author> <title> Universe polymorphism. Internal Nuprl V4 Document, </title> <year> 1991. </year>
Reference-contexts: The rules and semantics for this universe polymorphism were proposed by Howe <ref> [How91b] </ref>: a rule with clauses involving level variables is considered to be true just when the rule is true for all instantiations of level variables by constants. This semantics for universe polymorphism is different from that proposed by Allen [All87b].
Reference: [How93] <author> Douglas J. Howe. </author> <title> Reasoning about functional programs in Nuprl. Functional Programming, Concurrency, Simulation and Automated Reasoning, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <year> 1993. </year>
Reference-contexts: Fortunately, I think that much of the theory development and all the proof tool development would remain intact if a type theory were adopted with these or equivalent changes. Howe has put much thought into how such changes might be achieved <ref> [How93, HS94] </ref>. However, part of the problems are inherent in the constructivist agenda of seeing potential computational content in every logical proposition. The constructivist makes many subtle distinctions that a classical mathematician ignores.
Reference: [HS94] <author> Douglas J. Howe and Scott D. Stoller. </author> <title> An operational approach to combining classical set theory and functional programming languages. </title> <editor> In G. Goos and J. Hartmanis, editors, </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <pages> pages 36-55, </pages> <address> New York, </address> <month> April </month> <year> 1994. </year> <note> International Symposium TACS '94, Springer-Verlag. Theoretical Aspects of Computer Software. </note>
Reference-contexts: Another promising solution to this dilemma involves trying to combine set theory with a functional computation language <ref> [HS94] </ref>. Functions in this language are computable just when they are constructed in certain well-defined ways. 11.4 Appropriateness of Nuprl's Type Theory It is elegant to be working in a foundational theory where the objects you are often reasoning about are computable functions that you can actually execute. <p> Fortunately, I think that much of the theory development and all the proof tool development would remain intact if a type theory were adopted with these or equivalent changes. Howe has put much thought into how such changes might be achieved <ref> [How93, HS94] </ref>. However, part of the problems are inherent in the constructivist agenda of seeing potential computational content in every logical proposition. The constructivist makes many subtle distinctions that a classical mathematician ignores.
Reference: [HT93] <author> John Harrison and Laurent Thery. </author> <title> Extending the HOL theorem prover with a computer algebra system to reason about the reals. </title> <booktitle> In Proceedings of the HOL '93 Workshop on Higher Order Logic Theorem Proving and its Applications, </booktitle> <year> 1993. </year>
Reference-contexts: Harrison developed some real analysis covering topics including limits of series, differentiability and properties of transcendental functions [Har92]. Harrison and Thery demonstrated using the Maple computer algebra system [CGG + 91] to factor and integrate expressions for HOL <ref> [HT93] </ref>. Maple's operations were verified in HOL by carrying out the much simpler inverse operations of expanding out factors and differentiation. E. Gunter [Gun89] developed a basic theory of groups, proved the group isomorphism theorems and showed that the integers mod n form a group. A.
Reference: [HU79] <author> John E. Hopcroft and Jeffrey D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1979. </year>
Reference-contexts: For example, I write P 0 instead of P i 0 . 2.1.6 Well-Formedness Checking Nuprl's type theory is sufficiently complex that the problem of determining whether a term has a given type is in general undecidable: the halting problem <ref> [HU79] </ref> can be reduced to the type membership problem by constructing a type whose inhabitants are the numbers of those Turing machines that halt on zero input.
Reference: [Hue75] <author> Gerard P. Huet. </author> <title> A unification algorithm for the typed lambda-calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1(1) </volume> <pages> 27-58, </pages> <year> 1975. </year>
Reference-contexts: Nuprl V4.1's matching routine is based on a second-order restriction [HL78] of Huet's higher-order unification algorithm <ref> [Hue75] </ref>. This second-order routine handles patterns with bound variables, in contrast to Nuprl V3's first-order routine which did not. The advantage of using this second-order algorithm, rather than the full higher-order algorithm, is that it is much more controlled; unique most-general substitions (or unifiers) exist with it.
Reference: [HW78] <author> G. H. Hardy and E. M. Wright. </author> <title> An Introduction to the Theory of Numbers. </title> <publisher> Clarendon, </publisher> <address> fifth edition, </address> <year> 1978. </year>
Reference-contexts: a modest further increase in automation, possibly just achieved with the existing tactics that I have developed, it should be possible to produce both readable and completely formal expositions of small bodies of mathematics or computer science; for example, of a chapter or two of a book on number theory <ref> [HW78] </ref>, `concrete mathematics' [GKP89] or functional programming [AS85, Pau91]. An interface between the World-Wide-Web [BCL + 94] and Nuprl is currently undergoing test.
Reference: [Jac74] <author> Nathan Jacobson. </author> <title> Basic Algebra, volume I. </title> <publisher> Freeman, </publisher> <year> 1974. </year> <month> 199 </month>
Reference: [Jac91] <author> Paul B. Jackson. </author> <title> Developing a toolkit for floating-point hardware in the nuprl proof development system. </title> <booktitle> In Proceedings of the Advanced Research Workshop on Correct Hardware Design Methodologies. </booktitle> <address> Else-vier, </address> <year> 1991. </year>
Reference-contexts: The Nuprl type-theory is based on one of Martin-Lof's [ML82]. Nuprl's type-theory is discussed in more detail in Chapter 2. Theories developed in Nuprl include the fundamental theorem of arithmetic [How87], metatheory [Kno87, How88a, ACHA90, CH90], category theory [AP90], Ramsey's theorem [Bas89], Higman's lemma [Mur90], hardware verification <ref> [BD89, Jac91, Lee92] </ref> and software verification [AL92, How88b]. The previous tactics used in Nuprl were developed in chief by Howe [How88a]. In Chapter 3, I compare my tactics with those of Howe as well as with some rewriting tactics that Basin developed [Bas89]. <p> For example, digital-signal-processing, fast-fourier-transform, and hybrid control systems. I see these applications as providing focussed and worthwhile challenges for theorem proving technology. This is an area of interest that I pursued earlier in my thesis research <ref> [Jac91, Jac92] </ref> and that provided the initial motivation for much of the work described in this thesis. * One of the most significant problems with Nuprl is that of performance. The main cause of this problem is the highly redundant checking of well-formedness by proof.
Reference: [Jac92] <author> Paul B. Jackson. </author> <title> Nuprl and its use in circuit design. In R.T. </title> <editor> Boute V. Stavridou, T.F.Melham, editor, </editor> <booktitle> Proceedings of the 1992 International Conference on Theorem Provers in Circuit Design, IFIP Transactions A-10. </booktitle> <publisher> North-Holland, </publisher> <year> 1992. </year>
Reference-contexts: For example, digital-signal-processing, fast-fourier-transform, and hybrid control systems. I see these applications as providing focussed and worthwhile challenges for theorem proving technology. This is an area of interest that I pursued earlier in my thesis research <ref> [Jac91, Jac92] </ref> and that provided the initial motivation for much of the work described in this thesis. * One of the most significant problems with Nuprl is that of performance. The main cause of this problem is the highly redundant checking of well-formedness by proof.
Reference: [Jac94a] <author> Paul B. Jackson. </author> <title> Exploring abstract algebra in constructive type theory. </title> <editor> In A. Bundy, editor, </editor> <booktitle> 12th Conference on Automated Deduction, Lecture Notes in Artifical Intelligence. </booktitle> <publisher> Springer, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: In the short term, I am sure that some success is to be had in encouraging the linking of existing theorem provers and computer algebra systems. Here at Cornell, Zippel and I am currently engaged in investigating possibilities for interactions between Nuprl and Weyl <ref> [Jac94a] </ref>. In the long run, I see both technologies as developing so as to become more compatible with one another. However, it may be unwise to try to construct some monolithic hybrid system.
Reference: [Jac94b] <author> Paul B. Jackson. </author> <title> Nuprl V4.1 users guide and reference manual. </title> <type> Technical report, </type> <institution> Cornell University, Department of Computer Science, </institution> <year> 1994. </year>
Reference-contexts: Where appropriate, I point out the relationship between these tactics and those found in Nuprl V3, as well as in other theorem-proving systems. Note that the rewrite tactics are described separately in Chapter 4. For more details on the tactics, consult the Nuprl V4.1 Reference Manual <ref> [Jac94b] </ref>. I have ordered the sections of this chapter roughly according the the complexity of the tactics that they describe.
Reference: [Jac94c] <author> Paul B. Jackson. </author> <title> Solving universe-level constraints in Nuprl. </title> <note> To appear in a Nuprl internal document, </note> <month> December </month> <year> 1994. </year>
Reference-contexts: The main matching routines had all to be modified to propagate and collect these inequalities. Solving the inequalities themselves was fairly straightforward; I came up with an algorithm that always finds a match if there is one, and further which finds an equality match if possible <ref> [Jac94c] </ref>. Chapter 4 Rewriting 4.1 Introduction Rewriting [DJ90], the process of using equations as transformational rules, is a common technique in theorem-proving. In resolution theorem provers, rewriting is often accomplished using the demodulation and paramodulation rules [WOEB84]. Most interactive theorem provers have some kind of rewriting facility.
Reference: [JS92] <author> Richard D. Jenks and Robert S. Sutor. </author> <title> AXIOM: the Scientific Computation System. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Further, users of computer algebra systems might well be unaware of the corners 1 2 that were cut by the programmers of the packages that they use. Computer algebra systems such as Maple [CGG + 91] and Axiom <ref> [JS92] </ref> are addressing the issue of the meaning of symbolic expressions by adopting sophisticated type systems. Some too make an attempt to track side conditions of calculations. However, all computer algebra systems lack the absolute notion of rigor found in mathematics. <p> On the other hand, I was able to develop the basic theory of common algebraic classes such as monoids, groups, rings and modules in a style similar to that adopted in the computer algebra system Axiom <ref> [JS92, DT92, DGT92] </ref>, and had success with interpreting free constructions computationally. <p> They have impressive results in proving equivalences of sums of series, but their work has been hindered by the lack of rigor inherent in the Mathematica environment. In several computer algebra systems, much effort has been put into allowing computations over a wide variety of types; for example Axiom <ref> [JS92, DT92, DGT92] </ref> which evolved from the ScratchPad system at IBM. There are strong similarities between Axiom's approach to constructivity and the approach adopted in this thesis. My interest in computer algebra has been stimulated by discussions with Zippel who has designed his own system Weyl [Zip93b]. <p> As mentioned in Section 1.5.2, Harrison and Thery experimented with this idea in HOL and Maple. 181 The type systems adopted by theorem-proving systems such as Nuprl and computer algebra systems such as Axiom <ref> [JS92] </ref> or Weyl [Zip93b] have a lot of similarities. Could a theorem-prover and a computer algebra system share a system of types? This clearly would simplify interfacing the two kinds of systems, since then they would be working in the same mathematical language. <p> The approach I adopted to constructive algebra was predominantly an explicit one; that is, I assumed that constructions would always be made explicit and not be assumed implicit in the computational content of propositions. This approach was close in spirit to that taken in Scratchpad and Axiom <ref> [JS92, DT92, DGT92] </ref>. If inhabitants of algebraic classes were to have a decidable equality, then a function would be explicitly required to compute that equality in the signature.
Reference: [Jut77] <author> L. S. Jutting. </author> <title> Checking Landau's "Grundlagen" in the AUTOMATH system. </title> <type> Ph.D. dissertation, </type> <institution> Eindhoven University, </institution> <year> 1977. </year>
Reference-contexts: Van Jutting formalized all of a foundational text on elementary analysis | Landau's "Grundla-gen" | in Automath <ref> [Jut77] </ref>. Recently, more mathematics has been formalized in the MIZAR system than any other. MIZAR [Rud92] has been developed over the last 20 years by a team 11 under the leadership of A. Trybulec at the Bialystok branch of the University of Warsaw.
Reference: [Kno87] <author> Todd B. Knoblock. </author> <title> Metamathematical Extensibility in Type Theory. </title> <type> Ph.D. dissertation, </type> <institution> Cornell University, </institution> <year> 1987. </year>
Reference-contexts: The Nuprl type-theory is based on one of Martin-Lof's [ML82]. Nuprl's type-theory is discussed in more detail in Chapter 2. Theories developed in Nuprl include the fundamental theorem of arithmetic [How87], metatheory <ref> [Kno87, How88a, ACHA90, CH90] </ref>, category theory [AP90], Ramsey's theorem [Bas89], Higman's lemma [Mur90], hardware verification [BD89, Jac91, Lee92] and software verification [AL92, How88b]. The previous tactics used in Nuprl were developed in chief by Howe [How88a]. <p> Constructive type theory offers no features for proving theorems about com 183 plexity, unless one considers adding in some reflection mechanism. A fair amount of work has been done in this direction in Nuprl <ref> [Kno87, How88a, ACHA90, CH90] </ref>. However, reflection in a constructive type theory requires constructing a theory of not only a functional programming language, but also a theory of sequents, rules and proofs; this is a much more challenging task, especially in a type theory as structurally complicated at Nuprl's.
Reference: [LA93] <author> Jordi Levy and Jaume Agusti. Bi-rewriting, </author> <title> a term rewriting technique for monotonic order relations. </title> <editor> In Claude Kirchner, editor, </editor> <booktitle> 5th International Conference on Rewriting Techniques and Applications, volume 690 of LNCS, </booktitle> <pages> pages 17-31. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: To my knowledge, the issue of dealing with multiple strengths of rewrite relations has not yet been addressed anywhere other than in Nuprl. Researchers in the field of rewriting have begun to consider monotone rewriting <ref> [LA93, BG94] </ref>. It will be interesting to see whether these ideas can be adapted to work well in an interactive theorem proving context. Chapter 5 Methodology for Algebra 5.1 Introduction I discuss in this chapter some of the issues involved in defining classes of algebraic objects in Nuprl's type theory.
Reference: [Lan84] <author> Serge Lang. </author> <title> Algebra. </title> <publisher> Addison-Wesley, </publisher> <address> 2nd edition, </address> <year> 1984. </year>
Reference-contexts: In particular, every definition of a class, familiar in abstract algebra, can be viewed as an ADT specification. 1.4.3.1 Specification I created algebraic classes for monomials and polynomials based on the characterization found in Lang <ref> [Lan84] </ref> or Bourbaki [Bou74] of the algebra of polynomials as being a free monoid algebra over the ring of coefficients and the free abelian monoid of indeterminates. An interesting characteristic of this development was the treatment of freeness properties. <p> I based the ADT specification on the standard abstract mathematical characterization of multivariate polynomials found in say Lang <ref> [Lan84] </ref> or Bourbaki [Bou74].
Reference: [Lee92] <author> Miriam E. Leeser. </author> <title> Using Nuprl for the verification and synthesis of hardware. </title> <journal> Philosophical Transactions of the Royal Society, Series A, </journal> <volume> 339(1652) </volume> <pages> 49-68, </pages> <month> 15 April </month> <year> 1992. </year>
Reference-contexts: The Nuprl type-theory is based on one of Martin-Lof's [ML82]. Nuprl's type-theory is discussed in more detail in Chapter 2. Theories developed in Nuprl include the fundamental theorem of arithmetic [How87], metatheory [Kno87, How88a, ACHA90, CH90], category theory [AP90], Ramsey's theorem [Bas89], Higman's lemma [Mur90], hardware verification <ref> [BD89, Jac91, Lee92] </ref> and software verification [AL92, How88b]. The previous tactics used in Nuprl were developed in chief by Howe [How88a]. In Chapter 3, I compare my tactics with those of Howe as well as with some rewriting tactics that Basin developed [Bas89].
Reference: [Luo89] <author> Z. Luo. </author> <title> ECC, an extended calculus of construction. </title> <booktitle> In Proc. of Fourth Symp. on Logic in Comp. Sci., </booktitle> <pages> pages 385-395, </pages> <address> Pacific Grove, CA, </address> <month> June </month> <year> 1989. </year> <month> 200 </month>
Reference-contexts: Alf uses a more recent type theory of Martin-Lof's. Both LEGO and Coq use the Calculus of Constructions (CoC) [CH85], extending it with a kind of inductive definitions <ref> [Luo89, PPM89] </ref>. Bailey developed a concrete theory of polynomials in one variable in the LEGO system and has proven the correctness of Euclid's algorithm over these polynomials [Bai93]. Aczel and Barthe are currently investigating doing Galois theory in LEGO [Acz93, Bar93].
Reference: [Mat94] <author> R. Matuszewski. </author> <title> Formalized Mathematics: A Computer Assisted Approach, </title> <type> volume 1-4. </type> <institution> Universite Catholique de Louvain - Fondation Philippe le Hodey, </institution> <address> Brussels, </address> <pages> 1990-94. </pages>
Reference-contexts: All work done in Mizar is grouped into articles. Currently, over 300 articles have been written in the MIZAR language by over 60 authors. These articles contain over 6000 theorems in total. Articles are published in a Journal of Formalized Mathematics <ref> [Mat94] </ref> which is largely-automatically type-set from information in the MIZAR database. The subjects of the articles have been mostly in the fields of analysis, topology and algebra (including some universal algebra and category theory). I think there are several keys to MIZAR's success.
Reference: [McA89] <author> David A. McAllester. ONTIC: </author> <title> A Knowledge Representation System for Mathematics. </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1989. </year>
Reference-contexts: However, without some version of quotient types it would be difficult to verify constructive implementations of the classes where the equality on the representation type must be weakened in order to hide irrelevant detail. One other theorem-proving system worth mentioning is McAllester's Ontic system <ref> [McA89] </ref>. This system is based on Zermelo-Fraenkel set-theory. A milestone reached in it is the Stone representation theorem.
Reference: [Men88] <author> P.F. Mendler. </author> <title> Inductive Definition in Type Theory. </title> <type> Ph.D. dissertation, </type> <institution> Cornell University, </institution> <address> Ithaca, NY, </address> <year> 1988. </year>
Reference-contexts: The definition is of a relation from which a type membership relation and a typed equality relation are derived. The definition essentially if of a term model in that terms do not denote anything other than themselves. Mendler <ref> [Men88] </ref> gave a semantics for Nuprl's recursive types and Smith [Smi89] gave a semantics for the partial function types. <p> Howe, Allen and Mendler <ref> [Men88] </ref> have each considered such an extension, and not thought it problematic. Unfortunately, because equality of set-types is intensional in Nuprl's current type theory, the natural equality associated with PwT (T ) would be stronger than desired no matter what the equality associated with the the relation is.
Reference: [Mil91] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <journal> Journal of Logic and Computation, </journal> <volume> 1(4) </volume> <pages> 497-536, </pages> <year> 1991. </year>
Reference-contexts: I have found that second-order matching is adequate nearly all the time so far, Miller reports similar positive experiences when working in the system -prolog with a similar second-order unification algorithm that he calls fi 0 -unification <ref> [Mil91] </ref>, and I know that Paulson and Nipkow have had success with something similar in Isabelle [Pau90]. To discuss second-order matching, I first introduce the notions of second-order terms and second-order substitutions. Second-order terms are a generalization of terms.
Reference: [Mis93] <author> Bhubaneswar Mishra. </author> <title> Algorithmic Algebra. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: This algorithm in some form is used in many computer algebra systems today for solving 15 systems of polynomial equations. This algorithm and others are surveyed in many of the new texts that have come out recently on the mathematics of computer algebra <ref> [BWi93, CLO92, DST93, Mis93, Zip93a] </ref>. 1.6 Layout of Thesis The layout of the thesis is as follows: * Chapter 2 gives background information on Nuprl's type theory and the present state of the Nuprl V4.1 system.
Reference: [ML82] <author> Per Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In Sixth International Congress for Logic, Methodology, and Philosophy of Science, </booktitle> <pages> pages 153-175, </pages> <address> Amsterdam, 1982. </address> <publisher> North Hol-land. </publisher>
Reference-contexts: However, it can be rather difficult and clumsy to reason about computations in set theory. Nuprl adopted a type-theoretic language close in spirit to that of DeBruijn's Automath system [dB80] and strongly influenced by work of Scott [Sco70] and Martin-Lof <ref> [ML82] </ref>. A major difference between type theory and set theory is that in type theory, the notion of function is considered to be primitive and that type theories provide as primitive, at the very least, ways of constructing primitive recursive functions. <p> Eaton implementing the new editor and myself developing the tactics and libraries. All together over the years, over a dozen people have been involved in various ways with the Nuprl project. The Nuprl type-theory is based on one of Martin-Lof's <ref> [ML82] </ref>. Nuprl's type-theory is discussed in more detail in Chapter 2. Theories developed in Nuprl include the fundamental theorem of arithmetic [How87], metatheory [Kno87, How88a, ACHA90, CH90], category theory [AP90], Ramsey's theorem [Bas89], Higman's lemma [Mur90], hardware verification [BD89, Jac91, Lee92] and software verification [AL92, How88b]. <p> Nuprl's type theory [C + 86, All87a, All87b] is most closely related to a type theory proposed by Martin-Lof in 1979 as a foundation for constructive mathematics <ref> [ML82] </ref>. The main differences are: * Martin-Lof's four kinds of judgement are reduced to one. Roughly speaking, a judgement is a kind of sequent. The semantics of Nuprl's judgement is different from any of Martin-Lof's in that a judgement in Nuprl assumes rather than requires the well-formedness of hypotheses.
Reference: [MN79] <author> G. Metakides and A. Nerode. </author> <title> Effective content of field theory. </title> <journal> Annals of Mathematical Logic, </journal> <volume> 17 </volume> <pages> 289-320, </pages> <year> 1979. </year>
Reference-contexts: Today, a few mathematicians are exploring constructive algebra in this light [MRR88, BB85]. Other investigations have been carried out where the computations are made more explicit <ref> [FS55, MN79] </ref>. The strongest revival of interest in constructivity in algebra has undoubtably come from those concerned with the theory and design of computer algebra systems.
Reference: [MRR88] <author> Ray Mines, Fred Richman, and Wim Ruitenburg. </author> <title> A Course in constructive Algebra. </title> <publisher> Universitext. Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Brouwer's work was revived by Heyting [Hey66] and Bishop [Bis67, BB85] who tried to show how to systematically hide constructive details so that constructive mathematics more resembled classical mathematics. Today, a few mathematicians are exploring constructive algebra in this light <ref> [MRR88, BB85] </ref>. Other investigations have been carried out where the computations are made more explicit [FS55, MN79]. The strongest revival of interest in constructivity in algebra has undoubtably come from those concerned with the theory and design of computer algebra systems.
Reference: [MTH91] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Usually, it is pretty easy to fix such proofs. 2.2.8 The ML Language The ML language used in Nuprl is a functional language closely-related to the ML of the Edinburgh LCF theorem proving system [GMW79] and is a predecessor of ML used in Cambridge LCF [Pau85] and the SML language <ref> [MTH91, Pau91] </ref>. As in the LCF system, ML is used for writing all the tactics (ML originally stood for meta-language; it was designed for writing tactics).
Reference: [Mur90] <author> Chet Murthy. </author> <title> Extracting Constructive Content from Classical Proofs. </title> <type> Ph.D. dissertation, </type> <institution> Cornell University, </institution> <year> 1990. </year>
Reference-contexts: The Nuprl type-theory is based on one of Martin-Lof's [ML82]. Nuprl's type-theory is discussed in more detail in Chapter 2. Theories developed in Nuprl include the fundamental theorem of arithmetic [How87], metatheory [Kno87, How88a, ACHA90, CH90], category theory [AP90], Ramsey's theorem [Bas89], Higman's lemma <ref> [Mur90] </ref>, hardware verification [BD89, Jac91, Lee92] and software verification [AL92, How88b]. The previous tactics used in Nuprl were developed in chief by Howe [How88a]. In Chapter 3, I compare my tactics with those of Howe as well as with some rewriting tactics that Basin developed [Bas89].
Reference: [ORS92] <author> S. Owre, J.M. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <editor> In D. Kapur, editor, </editor> <booktitle> 11th Conference on Automated Deduction, volume 607 of Lecture Notes in Artifical Intelligence, </booktitle> <pages> pages 748-752. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Type-checking is decidable in these systems, but doing abstract algebra is rather involved. The approaches that have been looked at involve using a somewhat cumbersome encoding for sets called setoids. I discuss these in Chapter 5. Theorem provers such as Larch [GH93], IMPS [FGT92b], PVS <ref> [ORS92] </ref>, and 2OBJ [GSHH91] have notions of theories or modules which allow the collection together of type definitions, operator definitions and specification of predicates that the operators must satisfy. Further, these modules can be parameterized by one another and can inherit structure from one another. <p> This tactic paradigm was introduced in the LCF system [GMW79] and has also been adopted in theorem provers such as HOL [GM93] and LEGO [Pol90]. Other interactive theorem provers such as IMPS [FGT92a], and PVS <ref> [ORS92] </ref> have proof development languages that have many similarities with tactic languages. Ideally, all the rules the refiner implements should be in some sense straightforward and obviously correct.
Reference: [Pau83a] <author> Lawrence C. Paulson. </author> <title> A higher-order implementation of rewriting. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 3 </volume> <pages> 119-149, </pages> <year> 1983. </year>
Reference-contexts: To provide systematic control of rewriting in the LCF proof development system, Paulson introduced a language of conversions and conversionals <ref> [Pau83a, Pau87] </ref>, reminiscent of the language of tactics and tacticals, which allows the piecing together of rewrite strategies from sets of rewrite rules.
Reference: [Pau83b] <author> Lawrence C. Paulson. </author> <title> Tactics and tacticals in Cambridge LCF. </title> <type> Technical Report Report 39, </type> <institution> University of Cambridge, Computer Lab., </institution> <year> 1983. </year> <month> 201 </month>
Reference-contexts: The ability to rewrite with order relations has also been exploited in recent work in Nuprl on real analysis and I expect it could be very useful when developing theories of program refinement calculi and process algebras. The package was designed around the notion of conversion <ref> [Pau83b] </ref>. Conversions provide a modular language for composing rewrite rules into rewrite strategies. 1.4.1.2 Main Automatic Procedures Relational Reasoner I devised a simple tactic that automatically solved goals that depended on basic properties of order and equivalence relations, such as symmetry, antisymmetry, reflexivity, irreflexivity, transitivity and linearity.
Reference: [Pau85] <author> Lawrence C. Paulson. </author> <title> Interactive theorem proving with cambridge LCF. </title> <type> Technical Report Report 80, </type> <institution> University of Cambridge, Computer Lab., </institution> <year> 1985. </year>
Reference-contexts: Usually, it is pretty easy to fix such proofs. 2.2.8 The ML Language The ML language used in Nuprl is a functional language closely-related to the ML of the Edinburgh LCF theorem proving system [GMW79] and is a predecessor of ML used in Cambridge LCF <ref> [Pau85] </ref> and the SML language [MTH91, Pau91]. As in the LCF system, ML is used for writing all the tactics (ML originally stood for meta-language; it was designed for writing tactics).
Reference: [Pau87] <author> Lawrence C. Paulson. </author> <title> Logic and Computation: Interactive Proof with Cambridge LCF. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1987. </year>
Reference-contexts: To provide systematic control of rewriting in the LCF proof development system, Paulson introduced a language of conversions and conversionals <ref> [Pau83a, Pau87] </ref>, reminiscent of the language of tactics and tacticals, which allows the piecing together of rewrite strategies from sets of rewrite rules.
Reference: [Pau90] <author> Lawrence C. Paulson. </author> <title> Isabelle: The next 700 theorem provers. </title> <editor> In P. Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 361-385. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: Conciseness enhances comprehension (and also speeds writing). Apparent ambiguities are resolved by the reader's knowledge of the context the notation is presented in, and of what does and doesn't make sense semantically. In several theorem proving projects (MIZAR [Rud92] and Isabelle <ref> [Pau90] </ref>), for example), much effort has been expended on designing parsers so that reasonably concise notation can be typed using character-based text-editors 1 . These parsers often use type checking to resolve ambiguities and type inference to infer implicit type arguments. <p> that second-order matching is adequate nearly all the time so far, Miller reports similar positive experiences when working in the system -prolog with a similar second-order unification algorithm that he calls fi 0 -unification [Mil91], and I know that Paulson and Nipkow have had success with something similar in Isabelle <ref> [Pau90] </ref>. To discuss second-order matching, I first introduce the notions of second-order terms and second-order substitutions. Second-order terms are a generalization of terms. They can be thought of as `terms with holes', terms with zero or more subtrees missing.
Reference: [Pau91] <author> Lawrence C. Paulson. </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: Usually, it is pretty easy to fix such proofs. 2.2.8 The ML Language The ML language used in Nuprl is a functional language closely-related to the ML of the Edinburgh LCF theorem proving system [GMW79] and is a predecessor of ML used in Cambridge LCF [Pau85] and the SML language <ref> [MTH91, Pau91] </ref>. As in the LCF system, ML is used for writing all the tactics (ML originally stood for meta-language; it was designed for writing tactics). <p> just achieved with the existing tactics that I have developed, it should be possible to produce both readable and completely formal expositions of small bodies of mathematics or computer science; for example, of a chapter or two of a book on number theory [HW78], `concrete mathematics' [GKP89] or functional programming <ref> [AS85, Pau91] </ref>. An interface between the World-Wide-Web [BCL + 94] and Nuprl is currently undergoing test.
Reference: [Pol90] <author> R. Pollack. </author> <title> Lego user's guide. </title> <type> Technical report, </type> <institution> University of Edin-burgh, </institution> <year> 1990. </year>
Reference-contexts: Recently, M. Gordon has also been investigating techniques for merging HOL with set theory [Gor94]. 13 Other theorem provers that use a constructive type theory and encode logic using the propositions-as-types correspondence include Alf [ACN90], LEGO <ref> [Pol90] </ref>, and Coq [DFH + 91]. Alf uses a more recent type theory of Martin-Lof's. Both LEGO and Coq use the Calculus of Constructions (CoC) [CH85], extending it with a kind of inductive definitions [Luo89, PPM89]. <p> Tactics can be quite sophisticated, but still the correctness of any proof doesn't depend on them, only on the underlying refiner. This tactic paradigm was introduced in the LCF system [GMW79] and has also been adopted in theorem provers such as HOL [GM93] and LEGO <ref> [Pol90] </ref>. Other interactive theorem provers such as IMPS [FGT92a], and PVS [ORS92] have proof development languages that have many similarities with tactic languages. Ideally, all the rules the refiner implements should be in some sense straightforward and obviously correct.
Reference: [PPM89] <author> F. Pfenning and C. Paulin-Mohring. </author> <title> Inductively defined types in the Calculus of Constructions. </title> <booktitle> In Mathematical Foundations of Program Semantics, 5th International Conference, Lecture Notes in Computer Science, </booktitle> <volume> Vol. 442, </volume> <pages> pages 209-228. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Alf uses a more recent type theory of Martin-Lof's. Both LEGO and Coq use the Calculus of Constructions (CoC) [CH85], extending it with a kind of inductive definitions <ref> [Luo89, PPM89] </ref>. Bailey developed a concrete theory of polynomials in one variable in the LEGO system and has proven the correctness of Euclid's algorithm over these polynomials [Bai93]. Aczel and Barthe are currently investigating doing Galois theory in LEGO [Acz93, Bar93].
Reference: [Pra71] <author> Dag Prawitz. </author> <title> Ideas and results in proof theory. </title> <booktitle> In Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> pages 235-307. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1971. </year>
Reference-contexts: The rule can also be read bottom up as saying that in order to prove C is true, it is sufficient to prove that all the A i are true. The rules in the intuitionistic logic yielded by Nuprl's type theory are similar to those in Gentzen's LJ system <ref> [Pra71] </ref>. Nearly all the logic rules, when read top down, tell us how to introduce a logical connective or quantifier in a hypothesis or the conclusion. When read bottom-up they explain how to break down or decompose the connective.
Reference: [Rud92] <author> P. Rudnicki. </author> <title> An overview of the Mizar project. </title> <booktitle> In 1992 Workshop on Types for Proofs and Programs, </booktitle> <address> Bastad, </address> <year> 1992. </year> <institution> Chalmers University of Technology. </institution>
Reference-contexts: I use this term here in a loose sense, encompassing not only resolution theorem provers and systems such as NQTHM [BM88a], but also systems perhaps better called proof checkers such as Automath [dB80] and Mizar <ref> [Rud92] </ref>, and proof development systems such as Nuprl and HOL [GM93]. The HOL group refers to their system as a theorem proving environment, which I think is an apt phrase for describing all these kinds of system. <p> Van Jutting formalized all of a foundational text on elementary analysis | Landau's "Grundla-gen" | in Automath [Jut77]. Recently, more mathematics has been formalized in the MIZAR system than any other. MIZAR <ref> [Rud92] </ref> has been developed over the last 20 years by a team 11 under the leadership of A. Trybulec at the Bialystok branch of the University of Warsaw. It is based on classical first-order predicate logic, extended with second-order schema, and Tarski-Grothendieck set theory. <p> Conciseness enhances comprehension (and also speeds writing). Apparent ambiguities are resolved by the reader's knowledge of the context the notation is presented in, and of what does and doesn't make sense semantically. In several theorem proving projects (MIZAR <ref> [Rud92] </ref> and Isabelle [Pau90]), for example), much effort has been expended on designing parsers so that reasonably concise notation can be typed using character-based text-editors 1 . These parsers often use type checking to resolve ambiguities and type inference to infer implicit type arguments.
Reference: [Rus08] <author> Bertrand Russell. </author> <title> Mathematical logic as based on a theory of types. </title> <journal> Am. J. Math., </journal> <volume> 30 </volume> <pages> 222-62, </pages> <year> 1908. </year>
Reference-contexts: Often too, it is convenient that a major subject matter for theorem provers is program verification. The study of type theories is usually taken to have started with Russell's `theory of types' <ref> [Rus08, WR27] </ref> where a rather complicated system of types are introduced in order to avoid certain `vicious circle' paradoxes. Church introduced a `simple theory of types' [Chu40] that was adapted for use in the HOL theorem-proving system [GM93]. <p> This synthesis process goes by the name of extraction. 23 2.1.5 Universe Polymorphism An initially unappealing aspect of Nuprl's type theory is the stratification of types (and hence propositions) into universes, in a style reminiscent of Whitehead and Russell's in Principia Mathematica <ref> [WR27, Rus08] </ref>, but much simpler. In Nuprl V3 and before, the levels of universe terms were constants, which was inconvenient because often variants of the same lemma had be introduced which differed only in the levels of their universe terms.
Reference: [Sco70] <author> Dana S. Scott. </author> <title> Constructive validity. </title> <booktitle> In Symposium on Automatic Demonstration, volume 125 of Lecture Notes in Mathematics, </booktitle> <pages> pages 237-275, </pages> <address> Berlin, 1970. </address> <publisher> Spinger-Verlag. </publisher>
Reference-contexts: However, it can be rather difficult and clumsy to reason about computations in set theory. Nuprl adopted a type-theoretic language close in spirit to that of DeBruijn's Automath system [dB80] and strongly influenced by work of Scott <ref> [Sco70] </ref> and Martin-Lof [ML82]. A major difference between type theory and set theory is that in type theory, the notion of function is considered to be primitive and that type theories provide as primitive, at the very least, ways of constructing primitive recursive functions. <p> Church introduced a `simple theory of types' [Chu40] that was adapted for use in the HOL theorem-proving system [GM93]. A recently-developed family of type theories is that of constructive type theories [Gir71, CH88]. These exploit a notion that has come to be known as the `propositions-as-types' correspondence <ref> [CF58, Sco70, Con71] </ref> where every logical proposition corresponds to a type, and a proof of a proposition involves finding an element of the type corresponding to the proposition. Since elements of types are often programs, a phrase commonly associated with the `propositions as types' approach is `proofs as programs' [BC85].
Reference: [Sha86] <author> Natarajan Shankar. </author> <title> Proof Checking Metamathematics. </title> <type> Ph.D. dissertation, </type> <institution> University of Texas at Austin, </institution> <year> 1986. </year>
Reference-contexts: Accomplishments include the checking the RSA public-key encryption algorithm [BM84] and the verification of microprocessor designs [HB92]. NQTHM has also been used to formalize Godel's incompleteness theorem <ref> [Sha86] </ref>. The generation of proofs in NQTHM is highly automated. The user commonly only guides proofs by perhaps giving a few high level hints and suggesting useful lemmas. NQTHM automatically guesses how to do inductions and how to prove the subgoals of inductions.
Reference: [Sho67] <author> Joseph R. Shoenfield. </author> <title> Mathematical Logic. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1967. </year>
Reference-contexts: Chapter 2 Background on Nuprl 2.1 Type Theory The most common formal system studied in logic as a foundation for mathematics is first-order predicate calculus and some set theory, most commonly Zermelo-Fraenkel set theory <ref> [Sho67] </ref>. Nuprl uses instead a type theory which takes the place of both predicate calculus and set theory. 2.1.1 What is Type Theory? Type theory is an active research area in mathematics, logic and computer science and a diverse range of theories are collected under this name.
Reference: [Sho77] <author> Robert Shostak. </author> <title> On the SUP-INF Method for Proving Presburger Formulas. </title> <journal> JACM, </journal> <volume> 24(4) </volume> <pages> 351-360, </pages> <year> 1977. </year> <month> 202 </month>
Reference-contexts: The algorithm works by determining upper and lower bounds for each of the variables in turn | hence the name `sup-inf'. The bound calculations are always conservative, so that if some upper bound is strictly below some lower bound, then the conjunction is unsatisfiable. 50 Shostak <ref> [Sho77] </ref> showed that the calculated bounds are the best possible, and hence that the algorithm is complete for the rationals. He proposed a simple modification that made the algorithm return an explicit satisfying assignment when the conjunction is satisfiable.
Reference: [Smi89] <author> Scott F. Smith. </author> <title> Partial Objects in Type Theory. </title> <type> Ph.D. dissertation, </type> <institution> Cornell University, </institution> <address> Ithaca, NY, </address> <year> 1989. </year>
Reference-contexts: The definition is of a relation from which a type membership relation and a typed equality relation are derived. The definition essentially if of a term model in that terms do not denote anything other than themselves. Mendler [Men88] gave a semantics for Nuprl's recursive types and Smith <ref> [Smi89] </ref> gave a semantics for the partial function types. Howe [How91a] has given a set-theoretic model in which terms denote sets, and has shown by this model that it is consistent to extend Nuprl's type theory with oracle functions so that the logic created by the propositions-as-types correspondence is classical.
Reference: [Smu68] <author> Raymond Smullyan. </author> <title> First Order Logic. </title> <publisher> Springer-Verlag, </publisher> <year> 1968. </year>
Reference-contexts: Branches of a proof tree terminate with such rules as the hypothesis rule above. This style of theorem proving bears a close resemblance to the tableau method for proving theorems <ref> [Smu68] </ref>, which is commonly taught in logic courses, and which students usually find the simplest to use. Because rules are applied bottom-up, it is common to present Nuprl rules upside down.
Reference: [TvD88] <author> A.S. Troelstra and D. van Dalen. </author> <title> Constructivism in Mathematics, An Introduction, Vol. I,II. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1988. </year>
Reference-contexts: An ongoing project at Cornell is to set up links between Nuprl and Weyl. 1.5.4 Constructive Mathematics Excellent introductions to constructivism in mathematics have been given by for example, Troelstra and van Dalen <ref> [TvD88] </ref> and Dummett [Dum77]. Throughout the history of mathematics there has been some sensitivity to constructivity in algebra.
Reference: [Wir90] <author> Martin Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 13. </booktitle> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: in developing these lemmas was in first creating the theory of permutations mentioned previously, and characterizing the notion of `essential uniqueness'. 1.4.3 Polynomial Arithmetic Abstract algebra and the theory of abstract data types (ADT's) in programming languages have strong similarities that have pointed out many times in the ADT literature <ref> [Wir90] </ref>; in each case one first defines some class of objects, each object with a domain and certain operations over that domains that have certain abstract properties. Then one studies the characteristics of the objects, drawing on just what one knows from the class definition.
Reference: [WOEB84] <author> L. Wos, R. Overbeek, L. Ewing, and J. Boyle. </author> <title> Automated Reasoning. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1984. </year>
Reference-contexts: Chapter 4 Rewriting 4.1 Introduction Rewriting [DJ90], the process of using equations as transformational rules, is a common technique in theorem-proving. In resolution theorem provers, rewriting is often accomplished using the demodulation and paramodulation rules <ref> [WOEB84] </ref>. Most interactive theorem provers have some kind of rewriting facility. For example, the NQTHM prover uses rewriting heavily for simplification and for application of inductive hypotheses [BM88a]. Rewriting is also common in computer algebra systems.
Reference: [Wol91] <author> Stephen Wolfram. </author> <title> Mathematica: A System for Doing Mathematics by Computer. </title> <publisher> Addison-Wesley, </publisher> <address> second edition, </address> <year> 1991. </year>
Reference-contexts: For evidence of this, one only need look at the wealth of current work in scientific computation and numerical analysis. More recently, there has been very rapid growth in the popularity of computer algebra systems such as Mathematica <ref> [Wol91] </ref> and Maple [CGG + 91]. At their core, these systems have routines for carrying out such symbolic manipulations as factorizing polynomials, for computing integrals and differentials, and for finding symbolic solutions to sets of equations. They also provide languages for rapidly constructing packages that extend the systems' capabilities. <p> This system is based on Zermelo-Fraenkel set-theory. A milestone reached in it is the Stone representation theorem. Chen looked at adapting the inference algorithms that McAllester devised to the Nuprl environment [Che92]. 14 1.5.3 Computer Algebra Clarke and Zhao have added theorem-proving capabilities to Mathematica <ref> [Wol91] </ref> to create their Analytica system [CZ92]. They have impressive results in proving equivalences of sums of series, but their work has been hindered by the lack of rigor inherent in the Mathematica environment. <p> Most interactive theorem provers have some kind of rewriting facility. For example, the NQTHM prover uses rewriting heavily for simplification and for application of inductive hypotheses [BM88a]. Rewriting is also common in computer algebra systems. For example, Mathematica <ref> [Wol91] </ref> allows users to phrase transformation and simplification strategies as sets of rewrite rules.
Reference: [WR27] <author> A.N. Whitehead and B. Russell. </author> <title> Principia Mathematica, </title> <journal> volume 1, </journal> <volume> 2, 3. </volume> <publisher> Cambridge University Press, 2nd edition, </publisher> <pages> 1925-27. </pages>
Reference-contexts: Often too, it is convenient that a major subject matter for theorem provers is program verification. The study of type theories is usually taken to have started with Russell's `theory of types' <ref> [Rus08, WR27] </ref> where a rather complicated system of types are introduced in order to avoid certain `vicious circle' paradoxes. Church introduced a `simple theory of types' [Chu40] that was adapted for use in the HOL theorem-proving system [GM93]. <p> This synthesis process goes by the name of extraction. 23 2.1.5 Universe Polymorphism An initially unappealing aspect of Nuprl's type theory is the stratification of types (and hence propositions) into universes, in a style reminiscent of Whitehead and Russell's in Principia Mathematica <ref> [WR27, Rus08] </ref>, but much simpler. In Nuprl V3 and before, the levels of universe terms were constants, which was inconvenient because often variants of the same lemma had be introduced which differed only in the levels of their universe terms.
Reference: [Zip93a] <author> Richard E. Zippel. </author> <title> Effective Polynomial Computation. </title> <booktitle> The Kluwer International Series in Engineering and Computer Science. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: These freeness properties were viewed as the specifications for functions that instantiated the indeterminates in monomials and polynomials. 9 1.4.3.2 Implementation I based the implementation on the standard sparse representation of monomials and polynomials used in most computer algebra systems <ref> [DST93, Zip93a] </ref>. This representation involves using association lists (a-lists) of indeterminates and exponents to represent monomials, and a-lists of monomials and coefficients to represent polynomials. The keys (indices) of these a-lists were drawn from linear orders and the keys in an a-list were always maintained in order. <p> This algorithm in some form is used in many computer algebra systems today for solving 15 systems of polynomial equations. This algorithm and others are surveyed in many of the new texts that have come out recently on the mathematics of computer algebra <ref> [BWi93, CLO92, DST93, Mis93, Zip93a] </ref>. 1.6 Layout of Thesis The layout of the thesis is as follows: * Chapter 2 gives background information on Nuprl's type theory and the present state of the Nuprl V4.1 system. <p> The implementation verified is very similar to the basic sparse implementation described in texts on the design of computer algebra systems such as Davenport,Siret, Tournier [DST93] and Zippel <ref> [Zip93a] </ref>. This kind of implementation is in common use in current computer algebra systems. It involves representing a monomial by an association list (a-list) with indeterminates as keys 1 and indeterminate exponents as values, and representing a polynomial by an a-list with monomials as keys and monomial coefficients as values.
Reference: [Zip93b] <author> Richard E. Zippel. </author> <title> The Weyl computer algebra substrate. </title> <editor> In Alfonso Miola, editor, </editor> <booktitle> Design and Implementation of Symbolic Computation Systems, volume 722 of Lecture Notes in Computer Science, </booktitle> <pages> pages 303-318. </pages> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: There are strong similarities between Axiom's approach to constructivity and the approach adopted in this thesis. My interest in computer algebra has been stimulated by discussions with Zippel who has designed his own system Weyl <ref> [Zip93b] </ref>. An ongoing project at Cornell is to set up links between Nuprl and Weyl. 1.5.4 Constructive Mathematics Excellent introductions to constructivism in mathematics have been given by for example, Troelstra and van Dalen [TvD88] and Dummett [Dum77]. <p> As mentioned in Section 1.5.2, Harrison and Thery experimented with this idea in HOL and Maple. 181 The type systems adopted by theorem-proving systems such as Nuprl and computer algebra systems such as Axiom [JS92] or Weyl <ref> [Zip93b] </ref> have a lot of similarities. Could a theorem-prover and a computer algebra system share a system of types? This clearly would simplify interfacing the two kinds of systems, since then they would be working in the same mathematical language.
References-found: 138

