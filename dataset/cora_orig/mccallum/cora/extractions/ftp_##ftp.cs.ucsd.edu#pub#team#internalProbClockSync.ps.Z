URL: ftp://ftp.cs.ucsd.edu/pub/team/internalProbClockSync.ps.Z
Refering-URL: http://www.cs.ucsd.edu/users/flaviu/publications.html
Root-URL: http://www.cs.ucsd.edu
Email: f flaviu, cfetzer g@cs.ucsd.edu  
Title: Probabilistic Internal Clock Synchronization  
Author: Flaviu Cristian and Christof Fetzer 
Date: December 6, 1995  
Web: http://www-cse.ucsd.edu/users/fflaviu, cfetzerg CSE94-367  
Address: La Jolla, CA 920930114  
Affiliation: Department of Computer Science Engineering University of California, San Diego  
Abstract: We propose an improved probabilistic method for reading remote clocks in systems subject to unbounded communication delays and use this method to design a family of fault-tolerant probabilistic internal clock synchronization protocols. The members of this family differ in the failure classes they tolerate, from crash to arbitrary. Because of probabilistic reading, our protocols achieve better synchronization precisions than those achievable by previously known deterministic algorithms. Another advantage of the proposed protocols is that they use a linear, instead of quadratic, number of messages, and that message exchanges are staggered in time instead of all happening in narrow synchronization intervals. The envelope and drift rates of the synchronized clocks are proven to be optimal.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Cristian. </author> <title> Probabilistic clock synchronization. </title> <journal> Distributed Computing, </journal> <volume> 3 </volume> <pages> 146-158, </pages> <year> 1989. </year>
Reference-contexts: This makes them difficult to scale to larger networks. Given the practical importance of large, asynchronous distributed systems, such as those based on Unix and similar systems, the idea of probabilistic clock synchronization was proposed in <ref> [1] </ref> as a means to synchronize clocks in the presence of unbounded communication delays. However, [1] has discussed the use of probabilistic remote clock reading only to achieve external clock synchronization. <p> Given the practical importance of large, asynchronous distributed systems, such as those based on Unix and similar systems, the idea of probabilistic clock synchronization was proposed in <ref> [1] </ref> as a means to synchronize clocks in the presence of unbounded communication delays. However, [1] has discussed the use of probabilistic remote clock reading only to achieve external clock synchronization. The goal of this paper is to show how one can use probabilistic remote clock reading to achieve fault-tolerant internal clock synchronization. <p> We then propose a new probabilistic clock reading method optimized for achieving internal clock synchronization. The main advantages of this method are its reduced number of messages and its increased probability of successfully reading a remote clock. 3.1 Probabilistic Remote Clock Reading The basic idea behind probabilistic clock reading <ref> [1] </ref> is as follows. To read the clock of a remote process q, a process p must measure the round trip delay elapsed between the sending of the time request and the arrival of the reply on its local clock. <p> The likely success condition forbids a probabilistic clock reading method from always delivering an infinite remote clock error bound. Remote clock reading methods which guarantee that 7 P rob (E q (T; p) fl) = 1 are deterministic <ref> [1] </ref>. A remote clock reading method, such as [4], that does not provide the reading process p with a bound on the clock reading error is statistical. The advantage of probabilistic clock reading compared to deterministic clock reading is the possibility to achieve much smaller clock reading errors. <p> In this way, the remote clock reading procedure guarantees the timeliness and the bounded error conditions. The lower bound for clock reading errors achievable by probabilist reading is 3min <ref> [1] </ref>. If the maximum reading error is chosen so that fl &gt; 3min + 2 (D + S), k is chosen to be at least 2 and Z is chosen greater than ffi + 2fl + min + , the likely success condition is also satisfied.
Reference: [2] <author> L. Lamport and P. M. Melliar-Smith. </author> <title> Synchronizing clocks in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 32(1) </volume> <pages> 52-78, </pages> <month> Jan </month> <year> 1985. </year>
Reference-contexts: 1 Introduction Most distributed systems encountered in practice are asynchronous, in that they do not guarantee a bound on message communication delays. Traditional deterministic, fault-tolerant clock synchronization algorithms such as those of <ref> [2, 3] </ref> assume bounded communication delays. Thus, they cannot be directly used to synchronize clocks in asynchronous systems. fl An earlier version of this paper was published in the proceedings of the Thirteenth Symposium on Reliable Distributed Systems, Oct, 1994. <p> Because our protocols rely on a probabilistic remote clock reading method, they can be used to synchronize clocks despite unbounded communication delays. Since probabilistic reading achieves higher precisions than deterministic reading, the protocols achieve synchronization precisions better than those achievable by previously known deterministic algorithms, such as those of <ref> [2, 3, 7, 8] </ref>. Our algorithms use several new midpoint convergence functions, derived from the original fault-tolerant midpoint convergence function of [3]. These new convergence functions achieve optimal accuracy: the drift rate of the synchronized clocks is bounded by the maximum drift rate of correct hardware clocks.
Reference: [3] <author> J. Lundelius-Welch and N. Lynch. </author> <title> A new fault-tolerant algorithm for clock synchronization. </title> <journal> Information and Computation, </journal> <volume> 77(1) </volume> <pages> 1-36, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Most distributed systems encountered in practice are asynchronous, in that they do not guarantee a bound on message communication delays. Traditional deterministic, fault-tolerant clock synchronization algorithms such as those of <ref> [2, 3] </ref> assume bounded communication delays. Thus, they cannot be directly used to synchronize clocks in asynchronous systems. fl An earlier version of this paper was published in the proceedings of the Thirteenth Symposium on Reliable Distributed Systems, Oct, 1994. <p> Because our protocols rely on a probabilistic remote clock reading method, they can be used to synchronize clocks despite unbounded communication delays. Since probabilistic reading achieves higher precisions than deterministic reading, the protocols achieve synchronization precisions better than those achievable by previously known deterministic algorithms, such as those of <ref> [2, 3, 7, 8] </ref>. Our algorithms use several new midpoint convergence functions, derived from the original fault-tolerant midpoint convergence function of [3]. These new convergence functions achieve optimal accuracy: the drift rate of the synchronized clocks is bounded by the maximum drift rate of correct hardware clocks. <p> Since probabilistic reading achieves higher precisions than deterministic reading, the protocols achieve synchronization precisions better than those achievable by previously known deterministic algorithms, such as those of [2, 3, 7, 8]. Our algorithms use several new midpoint convergence functions, derived from the original fault-tolerant midpoint convergence function of <ref> [3] </ref>. These new convergence functions achieve optimal accuracy: the drift rate of the synchronized clocks is bounded by the maximum drift rate of correct hardware clocks. <p> exists between any experimentally determined max and the minimum delay min make the bound max impractical for the purpose of synchronizing N clocks, since all deterministic synchronization algorithms that depend on an upper bound for the maximum communication delay cannot achieve a maximum deviations better than (max min)(1 1=N ) <ref> [3] </ref>. In what follows, we do not assume any upper bound on communication delays. 3 2.2 Clocks A hardware clock consists of an oscillator and a counting register that is incremented by the ticks of the oscillator. <p> When F A processes are faulty at time t k+1 , a correct process fails to read at most F F A correct processes in round k. We adapt the fault-tolerant midpoint function proposed in <ref> [3] </ref> to mask remote clock reading failures and to provide an optimal drift rate for the virtual clocks. Let us first recall the basic idea behind the fault-tolerant midpoint function of [3]. Consider first that no reading failures can occur. <p> We adapt the fault-tolerant midpoint function proposed in <ref> [3] </ref> to mask remote clock reading failures and to provide an optimal drift rate for the virtual clocks. Let us first recall the basic idea behind the fault-tolerant midpoint function of [3]. Consider first that no reading failures can occur. Let the number of processes N be at least 3F + 1. A process p estimates the virtual clocks of all processes at the end of every round and sorts these clock readings. <p> Therefore, p sets its clock to T + fl. The drift rate of the virtual clocks is hence greater than , because the clocks have an additional drift introduced by the periodic 23 increment by fl. The fault-tolerant midpoint function of <ref> [3] </ref> is not applicable for failure assumption (FA 5), because under (FA 5) reading failures can be independent from each other. To show this, let us consider F = 1 and four correct processes p; q; r; s. <p> The basic idea behind the midpoint function proposed in this paper is as follows: a process must restrict the number of clock values that the midpoint function of <ref> [3] </ref> would reject, in order to be able to mask clock reading failures.
Reference: [4] <author> D. L. Mills. </author> <title> Internet time synchronization: the network time protocol. </title> <journal> IEEE Trans. Communications, </journal> <volume> 39(10) </volume> <pages> 1482-1493, </pages> <month> Oct </month> <year> 1991. </year>
Reference-contexts: These new convergence functions achieve optimal accuracy: the drift rate of the synchronized clocks is bounded by the maximum drift rate of correct hardware clocks. In contrast to clock synchronization algorithms which are based on statistical clock reading methods, such as <ref> [4] </ref>, our algorithms allow a process to detect the possibility that its local clock might be out of synch with the other correct clocks. Internal clock synchronization algorithms typically require that each time server process reads the clocks of all other time servers periodically. <p> The likely success condition forbids a probabilistic clock reading method from always delivering an infinite remote clock error bound. Remote clock reading methods which guarantee that 7 P rob (E q (T; p) fl) = 1 are deterministic [1]. A remote clock reading method, such as <ref> [4] </ref>, that does not provide the reading process p with a bound on the clock reading error is statistical. The advantage of probabilistic clock reading compared to deterministic clock reading is the possibility to achieve much smaller clock reading errors.
Reference: [5] <author> P. Miner. </author> <title> Verification of fault-tolerant clock synchronization systems. </title> <type> Technical Report TP-3349, </type> <institution> NASA, </institution> <month> Nov </month> <year> 1993. </year>
Reference-contexts: Since we use a probabilistic clock reading 14 method and so processes can fail to read correct clocks within a given maximum error, our assumptions are somewhat different from those of <ref> [7, 8, 5] </ref>.
Reference: [6] <author> F. Schmuck and F. Cristian. </author> <title> Continuous clock amortization need not affect the precision of a clock synchronization algorithm. </title> <booktitle> In Proceedings of Ninth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1990. </year>
Reference-contexts: For simplicity, we only consider discrete virtual clocks in this paper, knowing that we can substitute later continuous clocks to our discrete clocks without worsening the precision of the clock synchronization algorithms <ref> [6] </ref>. Like a hardware clock, a virtual clock C p is a total mapping from real-time RT to clock time CT .
Reference: [7] <author> F. Schneider. </author> <title> Understanding protocols for Byzantine clock synchronization. </title> <type> Technical Report 87-859, </type> <institution> Dept of Computer Science, Cornell University, </institution> <month> Aug </month> <year> 1987. </year>
Reference-contexts: Because our protocols rely on a probabilistic remote clock reading method, they can be used to synchronize clocks despite unbounded communication delays. Since probabilistic reading achieves higher precisions than deterministic reading, the protocols achieve synchronization precisions better than those achievable by previously known deterministic algorithms, such as those of <ref> [2, 3, 7, 8] </ref>. Our algorithms use several new midpoint convergence functions, derived from the original fault-tolerant midpoint convergence function of [3]. These new convergence functions achieve optimal accuracy: the drift rate of the synchronized clocks is bounded by the maximum drift rate of correct hardware clocks. <p> Since we use a probabilistic clock reading 14 method and so processes can fail to read correct clocks within a given maximum error, our assumptions are somewhat different from those of <ref> [7, 8, 5] </ref>. <p> This maximum deviation is better than the best maximum deviations we are aware of. For example, the bound for the fault-tolerant midpoint function derived with the constraints for ffi given in [8] and properties of the fault-tolerant midpoint function given in <ref> [7] </ref> is 9fl + 10fi + 4r max : Let us now derive an upper bound K for the maximum adjustment of a virtual clock.
Reference: [8] <author> N. Shankar. </author> <title> Mechanical verification of a schematic byzantine clock synchronization algorithm. </title> <type> Technical Report CR-4386, </type> <institution> NASA, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: Because our protocols rely on a probabilistic remote clock reading method, they can be used to synchronize clocks despite unbounded communication delays. Since probabilistic reading achieves higher precisions than deterministic reading, the protocols achieve synchronization precisions better than those achievable by previously known deterministic algorithms, such as those of <ref> [2, 3, 7, 8] </ref>. Our algorithms use several new midpoint convergence functions, derived from the original fault-tolerant midpoint convergence function of [3]. These new convergence functions achieve optimal accuracy: the drift rate of the synchronized clocks is bounded by the maximum drift rate of correct hardware clocks. <p> Since we use a probabilistic clock reading 14 method and so processes can fail to read correct clocks within a given maximum error, our assumptions are somewhat different from those of <ref> [7, 8, 5] </ref>. <p> This maximum deviation is better than the best maximum deviations we are aware of. For example, the bound for the fault-tolerant midpoint function derived with the constraints for ffi given in <ref> [8] </ref> and properties of the fault-tolerant midpoint function given in [7] is 9fl + 10fi + 4r max : Let us now derive an upper bound K for the maximum adjustment of a virtual clock.

References-found: 8

