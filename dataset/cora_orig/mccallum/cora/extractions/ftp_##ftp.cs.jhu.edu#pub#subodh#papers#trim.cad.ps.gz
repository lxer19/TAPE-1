URL: ftp://ftp.cs.jhu.edu/pub/subodh/papers/trim.cad.ps.gz
Refering-URL: http://www.cs.jhu.edu/~subodh/research/pub.html
Root-URL: http://www.cs.jhu.edu
Title: Efficient Rendering of Trimmed NURBS Surfaces  
Author: Subodh Kumar Dinesh Manocha 
Date: April 23, 1995  
Address: Chapel Hill NC 27599  Chapel Hill NC 27599  
Affiliation: Department of Computer Science University of North Carolina  Department of Computer Science University of North Carolina  
Abstract: We present an algorithm for interactive display of trimmed NURBS surfaces. The algorithm converts the NURBS surfaces to Bezier surfaces and NURBS trimming curves into Bezier curves. It tessellates each trimmed Bezier surface into triangles and renders them using the triangle rendering capabilities available in current graphics systems. It makes use of tight bounds for uniform tessellation of Bezier surfaces into cells and traces the trimming curves to compute the trimmed regions of each cell. This is based on marching along the trimming curves, intersection computation with the cells and triangulation of the cells. The resulting technique also makes use of spatial and temporal coherence between successive frames for cell computation and triangulation. Polygonization anomalies like cracks and angularities are avoided as well. The algorithm can display trimmed models described using thousands of Bezier surfaces at interactive frame rates on the high end graphics systems. Additional Keywords and Phrases: NURBS, Trimming curves, Bezier surface, Tessellation, Rendering. fl Supported by Office of Naval Research contract, ONR N00014-94-1-0738, DARPA ISTO Order No. A410, NSF Grant No. MIP-9306208, Junior Faculty Award, University Research Award, NSF Grant CCR-9319957, ARPA Contract DABT63-93-C-0048 and NSF/ARPA Science and Technology Center for Computer Graphics and Scientific Visualization, and NSF Prime Contract No. 8920219. y This paper has been approved by ARPA for public release, distribution unlimited. 
Abstract-found: 1
Intro-found: 1
Reference: [AES91] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> Tessellation of curved surfaces under highly varying transformations. </title> <booktitle> Proceedings of Eurographics'91, </booktitle> <pages> pages 385-97, </pages> <year> 1991. </year>
Reference-contexts: On the other hand these systems can render millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. As a result, only algorithms based on polygonization come close to real time display. Many different methods based on polygo-nization have been proposed in the literature <ref> [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86] </ref>. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these have been specializeed to trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models. <p> Another major reason for the choice of uniform tessellation is the relative simplicity and efficiency of handling trimming curves (as compared to adaptive subdivision). 3.1 Patch tessellation There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. They are base upon the size or the deviation criteria. Sometimes a normal deviation criterion is also used. This criterion bounds the deviation of the triangles' normals from the surface normal. While this bound can improve the image quality, it is relatively expensive to evaluate. <p> The size criterion can be applied in two ways for step size computation: * Compute the bounds on the surface in the object space as a preprocessing step and map these to the screen space. The step size is computed as a function of these bounds and viewing parameters <ref> [LR81, FMM86, AES91, KM94b] </ref>. * Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size is a function of these bounds [Roc87, RHD89].
Reference: [AES93] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> The scaling behavior of viewing transformations. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 13(3) </volume> <pages> 48-54, </pages> <year> 1993. </year>
Reference-contexts: On the other hand these systems can render millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. As a result, only algorithms based on polygonization come close to real time display. Many different methods based on polygo-nization have been proposed in the literature <ref> [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86] </ref>. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these have been specializeed to trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models.
Reference: [Ake93] <author> K. Akeley. </author> <title> Reality engine graphics. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 109-1116, </pages> <year> 1993. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current graphics systems. On the other hand these systems can render millions of transformed, shaded and z-buffered polygons per second <ref> [Ake93, Fea89] </ref>. As a result, only algorithms based on polygonization come close to real time display. Many different methods based on polygo-nization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces.
Reference: [Baj90] <author> C.L. Bajaj. </author> <title> Rational hypersurface display. </title> <booktitle> In Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 117-27, </pages> <address> Snowbird, UT, </address> <year> 1990. </year>
Reference: [Bea91] <author> R. Bedichek et al. </author> <title> Rapid low-cost display of spline surfaces. </title> <booktitle> In Proceedings of advanced reserach in VLSI, </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference: [BFHK93] <author> R. Barnhill, G. Farin, D. Hansford, and R. Klass. </author> <title> Adaptive surface triangulation. </title> <type> Manuscript, </type> <year> 1993. </year>
Reference: [Cat74] <author> E. Catmull. </author> <title> A subdivision algorithm for computer display of curved surfaces. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1974. </year>
Reference-contexts: In this paper we focus on trimmed surface models, typically obtained after surface intersection and other Boolean operations. The problem of rendering curved surfaces (both trimmed and untrimmed) has been extensively studied in the literature and main techniques include pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Kaj82, NSK90, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current graphics systems. On the other hand these systems can render millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89].
Reference: [Che93] <author> F. Cheng. </author> <title> Computation techniques on nurb surfaces. </title> <booktitle> In SIAM Conference on Geometric Design, </booktitle> <address> Tempe, AZ, </address> <year> 1993. </year>
Reference-contexts: Many different methods based on polygo-nization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these have been specializeed to trimmed surface models <ref> [RHD89, Luk93, LC93, Che93, SC88, Vla90] </ref>. We present a fast algorithm for rendering trimmed NURBS models. Our overall approach shares its principle with the algorithm presented by Rockwood et. al. [RHD89].
Reference: [Cla79] <author> J. H. Clark. </author> <title> A fast algorithm for rendering parametric surfaces. </title> <booktitle> Proceedings of ACM Siggraph, </booktitle> <pages> pages 289-99, </pages> <year> 1979. </year>
Reference: [CTV89] <author> K. Clarkson, R. E. Tarjan, and C. J. Van Wyk. </author> <title> A fast Las Vegas algorithm for triangulating a simple polygon. </title> <journal> Discrete Comput. Geom., </journal> <volume> 4 </volume> <pages> 423-432, </pages> <year> 1989. </year>
Reference-contexts: If we use the external point A instead of b, we get a correct triangulation there. Similarly we can replace all crossings with the corresponding external points, and avoid creating extra tessellants on the curve. This polygon can now be triangulated using any polygon triangulation algorithms <ref> [PS85, CTV89, Sei91] </ref>. Our current implementation uses an implementation of Seidel's randomized algorithm [Sei91, NM95]. There are two new problems with this method of polygon generation, though: 1. The external point of one cell is the exit point of another.
Reference: [Dea89] <author> T. Derose et al. Apex: </author> <title> two architectures for generating parametric curves and surfaces. </title> <journal> The Visual Computer, </journal> <volume> 5 </volume> <pages> 264-276, </pages> <year> 1989. </year>
Reference-contexts: On the other hand these systems can render millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. As a result, only algorithms based on polygonization come close to real time display. Many different methods based on polygo-nization have been proposed in the literature <ref> [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86] </ref>. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these have been specializeed to trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models.
Reference: [DN93] <author> M.F. Deering and S.R. Nelson. Leo: </author> <title> A system for cost effective 3d shaded graphics. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 101-108, </pages> <year> 1993. </year> <month> 25 </month>
Reference: [Far90] <author> G. Farin. </author> <title> Curves and Surfaces for Computer Aided Geometric Design: A Practical Guide. </title> <publisher> Academic Press Inc., </publisher> <year> 1990. </year>
Reference-contexts: In this paper we demonstrate these techniques on tensor-product surface models only. They can be generalized to triangular patches as well. 3 2 Problem Definition Given a trimmed NURBS surface model, we use knot insertion algorithms to decompose it into a series of Bezier patches <ref> [Far90] </ref>. We also subdivide the NURBS trimming curves at the patch boundaries and transform them into Bezier curves. Piecewise linear trimming curve representations are decomposed at the patch boundaries as well. All these steps are part of the preprocessing phase.
Reference: [Fea89] <author> H. Fuchs and J. Poulton et al. </author> <title> Pixel-planes 5: A heterogeneous multiprocessor graphics system using processor-enhanced memories. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 79-88, </pages> <year> 1989. </year>
Reference-contexts: Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current graphics systems. On the other hand these systems can render millions of transformed, shaded and z-buffered polygons per second <ref> [Ake93, Fea89] </ref>. As a result, only algorithms based on polygonization come close to real time display. Many different methods based on polygo-nization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. <p> We implemented this algorithm on two platforms - SGI-Onyx and the Pixelplanes 5 system at UNC. The Onyx was used with a single processor. The Pixelplanes 5 configuration included 30 graphic processors (though one of them is a master processor and does not perform the computations) and 14 renderers <ref> [Fea89] </ref>. The algorithm achieves load balancing by distributing neighboring patches onto different processors statically. No inter-processor communication is required. As a result it can be easily ported to any other multiple processor machine. The performance of the algorithm on the SGI has been shown in Table 6.
Reference: [FK90] <author> D.R. Forsey and V. Klassen. </author> <title> An adaptive subdivision algorithm for crack prevention in the display of parametric surfaces. </title> <booktitle> Proceedings of Graphics Interface, </booktitle> <pages> pages 1-8, </pages> <year> 1990. </year>
Reference: [FMM86] <author> D. Filip, R. Magedson, and R. Markot. </author> <title> Surface algorithms using bounds on derivatives. </title> <journal> CAGD, </journal> <volume> 3 </volume> <pages> 295-311, </pages> <year> 1986. </year>
Reference-contexts: On the other hand these systems can render millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. As a result, only algorithms based on polygonization come close to real time display. Many different methods based on polygo-nization have been proposed in the literature <ref> [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86] </ref>. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these have been specializeed to trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models. <p> Uniform tessellation involves choosing constant step sizes along each parameter. Adaptive tessellation uses a recursive approach to subdivision with a stopping condition (normally based on some "flatness" and "surface area" criteria). For large scale models, uniform subdivision methods have been found to be faster in practice <ref> [FMM86, KM94b] </ref>. In practice, large scaled NURBS models typically consist of relatively flat surfaces. This is indeed the case after converting B-spline models into Bezier surfaces. Adaptive subdivision performs well on surfaces with highly varying curvatures and large areas. In such cases uniform tessellation may oversample them. <p> Another major reason for the choice of uniform tessellation is the relative simplicity and efficiency of handling trimming curves (as compared to adaptive subdivision). 3.1 Patch tessellation There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. They are base upon the size or the deviation criteria. Sometimes a normal deviation criterion is also used. This criterion bounds the deviation of the triangles' normals from the surface normal. While this bound can improve the image quality, it is relatively expensive to evaluate. <p> The size criterion can be applied in two ways for step size computation: * Compute the bounds on the surface in the object space as a preprocessing step and map these to the screen space. The step size is computed as a function of these bounds and viewing parameters <ref> [LR81, FMM86, AES91, KM94b] </ref>. * Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size is a function of these bounds [Roc87, RHD89].
Reference: [Kaj82] <author> J. Kajiya. </author> <title> Ray tracing parametric patches. </title> <journal> Computer Graphics, </journal> <volume> 16(3) </volume> <pages> 245-254, </pages> <year> 1982. </year>
Reference-contexts: In this paper we focus on trimmed surface models, typically obtained after surface intersection and other Boolean operations. The problem of rendering curved surfaces (both trimmed and untrimmed) has been extensively studied in the literature and main techniques include pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Kaj82, NSK90, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current graphics systems. On the other hand these systems can render millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89].
Reference: [KM94a] <author> S. Krishnan and D. Manocha. </author> <title> An efficient surface intersection algorithm based on the lower dimensional formulation. </title> <type> Technical Report TR94-062, </type> <institution> Department of Computer Science, University of North Carolina, </institution> <year> 1994. </year>
Reference-contexts: This is not as straightforward as on the patch boundary curves u = 0; u = 1; v = 0 and v = 1. The same trimming curve can be (and often is) represented 8 differently on different patches <ref> [KM94a] </ref>. We need two steps to avoid cracks at trimming curves. First, we must take a curve's representation from the (u; v) space of the corresponding patch to the object (X,Y,Z) space.
Reference: [KM94b] <author> S. Kumar and D. Manocha. </author> <title> Interactive display of large scale nurbs models. </title> <type> Technical Report TR94-008, </type> <institution> Department of Computer Science, University of North Carolina, </institution> <year> 1994. </year>
Reference-contexts: The second criterion is referred as the size criterion. These two are used to obtain a good polygonization of the surface such that we obtain a smooth image after Gouraud or Phong shading of the polygons <ref> [KM94b, KML95] </ref>. 3 Tessellation Computation In this section, we highlight the algorithm for tessellating the surface as a function of the viewing parameters. More details are given in [KM94b, KML95]. In particular, we dynamically compute the polygonization of the surfaces as the viewing parameters are changing. <p> obtain a good polygonization of the surface such that we obtain a smooth image after Gouraud or Phong shading of the polygons <ref> [KM94b, KML95] </ref>. 3 Tessellation Computation In this section, we highlight the algorithm for tessellating the surface as a function of the viewing parameters. More details are given in [KM94b, KML95]. In particular, we dynamically compute the polygonization of the surfaces as the viewing parameters are changing. Polygonization can be computed using uniform or adaptive subdivision for each frame. Uniform tessellation involves choosing constant step sizes along each parameter. <p> Uniform tessellation involves choosing constant step sizes along each parameter. Adaptive tessellation uses a recursive approach to subdivision with a stopping condition (normally based on some "flatness" and "surface area" criteria). For large scale models, uniform subdivision methods have been found to be faster in practice <ref> [FMM86, KM94b] </ref>. In practice, large scaled NURBS models typically consist of relatively flat surfaces. This is indeed the case after converting B-spline models into Bezier surfaces. Adaptive subdivision performs well on surfaces with highly varying curvatures and large areas. In such cases uniform tessellation may oversample them. <p> The size criterion by itself may not result in a good approximation on patches with small area and highly varying curvature. A simple technique to account for such cases has been described in <ref> [KM94b] </ref>. The size criterion can be applied in two ways for step size computation: * Compute the bounds on the surface in the object space as a preprocessing step and map these to the screen space. <p> The size criterion can be applied in two ways for step size computation: * Compute the bounds on the surface in the object space as a preprocessing step and map these to the screen space. The step size is computed as a function of these bounds and viewing parameters <ref> [LR81, FMM86, AES91, KM94b] </ref>. * Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size is a function of these bounds [Roc87, RHD89]. <p> Computations of n t , the number of steps for a curve is also calculated similarly. More details are given in <ref> [KM94b] </ref>. 3.2 Boundary Curve Tessellation The number of steps that two adjacent patches are tessellated into, need not be the same. This can result in cracks in the rendered image. <p> When memory is not at a premium, we can retain these extra points. It turns out that, triangle rendering takes more time than triangle generation (and can easily become a bottleneck) <ref> [KM94b] </ref>. So while extra points may be retained, the triangulation must be redone using only the correct set of points. In our experience, we hardly ever need to store more than 60 70 thousand triangles, needing about 3 4 megabytes of memory.
Reference: [KML95] <author> S. Kumar, D. Manocha, and A. Lastra. </author> <title> Interactive display of large scale nurbs models. In Symposium on Interactive 3D Graphics, </title> <address> Monterey, CA, </address> <year> 1995. </year>
Reference-contexts: We compare the surface triangulation of the two algorithms in Fig. 1. Fig. 1 (a) corresponds to the SGI-GL implementation based on Rockwood et. al.'s algorithm [Nas93, SGI]. Our algorithm uses ideas from <ref> [KML95] </ref> for culling back facing patches. Such patches are not visible if the model is closed and consistent. We also make use of coherence between successive frames and performs incremental computation at each frame. This gains us a speedup of more than 8-9. <p> The second criterion is referred as the size criterion. These two are used to obtain a good polygonization of the surface such that we obtain a smooth image after Gouraud or Phong shading of the polygons <ref> [KM94b, KML95] </ref>. 3 Tessellation Computation In this section, we highlight the algorithm for tessellating the surface as a function of the viewing parameters. More details are given in [KM94b, KML95]. In particular, we dynamically compute the polygonization of the surfaces as the viewing parameters are changing. <p> obtain a good polygonization of the surface such that we obtain a smooth image after Gouraud or Phong shading of the polygons <ref> [KM94b, KML95] </ref>. 3 Tessellation Computation In this section, we highlight the algorithm for tessellating the surface as a function of the viewing parameters. More details are given in [KM94b, KML95]. In particular, we dynamically compute the polygonization of the surfaces as the viewing parameters are changing. Polygonization can be computed using uniform or adaptive subdivision for each frame. Uniform tessellation involves choosing constant step sizes along each parameter.
Reference: [LC93] <author> W.L. Luken and Fuhua Cheng. </author> <title> Rendering trimmed nurb surfaces. </title> <institution> Computer science research report 18669(81711), IBM Research Division, </institution> <year> 1993. </year>
Reference-contexts: Many different methods based on polygo-nization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these have been specializeed to trimmed surface models <ref> [RHD89, Luk93, LC93, Che93, SC88, Vla90] </ref>. We present a fast algorithm for rendering trimmed NURBS models. Our overall approach shares its principle with the algorithm presented by Rockwood et. al. [RHD89]. <p> This is in terms of converting the NURBS models into Bezier surfaces, using uniform tessellation and computing the trimmed regions of each cell and triangulating it. This is in contrast with direct rendering of trimmed NURBS surfaces using the B-spline representation <ref> [Luk93, LC93] </ref>. Our rendering algorithm involves the computation of intersections of the trimming curve with the domain cells, visible region determination and triangulation. These operations are relatively simpler and faster to perform on a Bezier representation than on B-splines. The algorithm in [RHD89] partitions each trimming curve into monotonic segments.
Reference: [LCWB80] <author> J.M. Lane, L.C. Carpenter, J. T. Whitted, and J.F. </author> <title> Blinn. Scan line methods for displaying parametrically defined surfaces. </title> <journal> Communications of ACM, </journal> <volume> 23(1) </volume> <pages> 23-34, </pages> <year> 1980. </year>
Reference-contexts: In this paper we focus on trimmed surface models, typically obtained after surface intersection and other Boolean operations. The problem of rendering curved surfaces (both trimmed and untrimmed) has been extensively studied in the literature and main techniques include pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Kaj82, NSK90, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current graphics systems. On the other hand these systems can render millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89].
Reference: [LR81] <author> J.M. Lane and R.F. Riesenfeld. </author> <title> Bounds on polynomials. </title> <journal> BIT, </journal> <volume> 2 </volume> <pages> 112-117, </pages> <year> 1981. </year>
Reference-contexts: On the other hand these systems can render millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. As a result, only algorithms based on polygonization come close to real time display. Many different methods based on polygo-nization have been proposed in the literature <ref> [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86] </ref>. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these have been specializeed to trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models. <p> Another major reason for the choice of uniform tessellation is the relative simplicity and efficiency of handling trimming curves (as compared to adaptive subdivision). 3.1 Patch tessellation There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. They are base upon the size or the deviation criteria. Sometimes a normal deviation criterion is also used. This criterion bounds the deviation of the triangles' normals from the surface normal. While this bound can improve the image quality, it is relatively expensive to evaluate. <p> The size criterion can be applied in two ways for step size computation: * Compute the bounds on the surface in the object space as a preprocessing step and map these to the screen space. The step size is computed as a function of these bounds and viewing parameters <ref> [LR81, FMM86, AES91, KM94b] </ref>. * Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size is a function of these bounds [Roc87, RHD89].
Reference: [Luk93] <institution> W.L. Luken. Tessellation of trimmed nurb surfaces. Computer science research report 19322(84059), IBM Research Division, </institution> <year> 1993. </year>
Reference-contexts: Many different methods based on polygo-nization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these have been specializeed to trimmed surface models <ref> [RHD89, Luk93, LC93, Che93, SC88, Vla90] </ref>. We present a fast algorithm for rendering trimmed NURBS models. Our overall approach shares its principle with the algorithm presented by Rockwood et. al. [RHD89]. <p> This is in terms of converting the NURBS models into Bezier surfaces, using uniform tessellation and computing the trimmed regions of each cell and triangulating it. This is in contrast with direct rendering of trimmed NURBS surfaces using the B-spline representation <ref> [Luk93, LC93] </ref>. Our rendering algorithm involves the computation of intersections of the trimming curve with the domain cells, visible region determination and triangulation. These operations are relatively simpler and faster to perform on a Bezier representation than on B-splines. The algorithm in [RHD89] partitions each trimming curve into monotonic segments.
Reference: [MD94] <author> D. Manocha and J. Demmel. </author> <title> Algorithms for intersecting parametric and algebraic curv es i: simple intersections. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 13(1) </volume> <pages> 73-100, </pages> <year> 1994. </year> <month> 26 </month>
Reference-contexts: For each active strip For each active cell in the strip Triangulate the cell. 4.1 Intersection Initially we calculate all pairwise intersections between curves whose bounding boxes overlap. We use the recently developed algorithms for intersecting parametric and algebraic curves, which reduce the problem to an eigenvalue problem <ref> [MD94] </ref>. We merge two intersecting curves into one by eliminating sections of the curves. When a part of a curve lies in a region trimmed out by another curve, that part is redundant and can be discarded. Fig. 6 demonstrates how this is done.
Reference: [Nas93] <author> R. Nash. </author> <title> Silicon Graphics, </title> <type> Personal Communication, </type> <year> 1993. </year>
Reference-contexts: We compare the surface triangulation of the two algorithms in Fig. 1. Fig. 1 (a) corresponds to the SGI-GL implementation based on Rockwood et. al.'s algorithm <ref> [Nas93, SGI] </ref>. Our algorithm uses ideas from [KML95] for culling back facing patches. Such patches are not visible if the model is closed and consistent. We also make use of coherence between successive frames and performs incremental computation at each frame. This gains us a speedup of more than 8-9. <p> The algorithm achieves load balancing by distributing neighboring patches onto different processors statically. No inter-processor communication is required. As a result it can be easily ported to any other multiple processor machine. The performance of the algorithm on the SGI has been shown in Table 6. The SGI-GL implementation <ref> [Nas93] </ref> is based on the algorithm presented in [RHD89] and has a microcoded geometry engine implementation for surface evaluations. This implementation works in immediate mode.
Reference: [NM95] <author> A. Narkhede and D. Manocha. </author> <title> Fast polygon triangulation based on seidel's algorithm. </title> <editor> In A. Paeth, editor, </editor> <title> Graphics Gems V, </title> <publisher> Academic Press, </publisher> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: Similarly we can replace all crossings with the corresponding external points, and avoid creating extra tessellants on the curve. This polygon can now be triangulated using any polygon triangulation algorithms [PS85, CTV89, Sei91]. Our current implementation uses an implementation of Seidel's randomized algorithm <ref> [Sei91, NM95] </ref>. There are two new problems with this method of polygon generation, though: 1. The external point of one cell is the exit point of another. If these points are included in polygons for both the cells, some overlapping triangles can be created. e.g.
Reference: [NSK90] <author> T. Nishita, T.W. Sederberg, and M. Kakimoto. </author> <title> Ray tracing trimmed rational surface patches. </title> <journal> Computer Graphics, </journal> <volume> 24(4) </volume> <pages> 337-345, </pages> <year> 1990. </year>
Reference-contexts: In this paper we focus on trimmed surface models, typically obtained after surface intersection and other Boolean operations. The problem of rendering curved surfaces (both trimmed and untrimmed) has been extensively studied in the literature and main techniques include pixel level surface subdivision, ray tracing, scan-line display and polygonization <ref> [Cat74, Kaj82, NSK90, LCWB80] </ref>. Techniques based on ray tracing, scan-line display and pixel level display do not make efficient use of the hardware capabilities available on current graphics systems. On the other hand these systems can render millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. <p> Note that some redundant curves that do not intersect any curve (curve D in Fig. 5) may still remain. This happens when a clockwise loop lies inside another (or is tangent to it) 2 . This containment is tested for each pair of non-intersecting curves whose bounding boxes overlap <ref> [NSK90] </ref>. We tessellate each curve on-line and get a piecewise linear representation: a sequence of points p 0 : : : p n . Note that the points of intersection must appear in this sequence. While the actual curves do not intersect, their piecewise linear approximations can.
Reference: [PS85] <author> F.P. Preparata and M. I. Shamos. </author> <title> Computational Geometry. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: If we use the external point A instead of b, we get a correct triangulation there. Similarly we can replace all crossings with the corresponding external points, and avoid creating extra tessellants on the curve. This polygon can now be triangulated using any polygon triangulation algorithms <ref> [PS85, CTV89, Sei91] </ref>. Our current implementation uses an implementation of Seidel's randomized algorithm [Sei91, NM95]. There are two new problems with this method of polygon generation, though: 1. The external point of one cell is the exit point of another.
Reference: [RHD89] <author> A. Rockwood, K. Heaton, and T. Davis. </author> <title> Real-time rendering of trimmed surfaces. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 107-117, </pages> <year> 1989. </year>
Reference-contexts: Many different methods based on polygo-nization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these have been specializeed to trimmed surface models <ref> [RHD89, Luk93, LC93, Che93, SC88, Vla90] </ref>. We present a fast algorithm for rendering trimmed NURBS models. Our overall approach shares its principle with the algorithm presented by Rockwood et. al. [RHD89]. <p> Many of these have been specializeed to trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models. Our overall approach shares its principle with the algorithm presented by Rockwood et. al. <ref> [RHD89] </ref>. This is in terms of converting the NURBS models into Bezier surfaces, using uniform tessellation and computing the trimmed regions of each cell and triangulating it. This is in contrast with direct rendering of trimmed NURBS surfaces using the B-spline representation [Luk93, LC93]. <p> Our rendering algorithm involves the computation of intersections of the trimming curve with the domain cells, visible region determination and triangulation. These operations are relatively simpler and faster to perform on a Bezier representation than on B-splines. The algorithm in <ref> [RHD89] </ref> partitions each trimming curve into monotonic segments. This monotonic subdivision followed by special triangulation at the patch boundaries sometimes becomes a bottleneck for the [RHD89] algorithm. We overcome these problems with handling trimming curves and present efficient algorithms for trimmed cell computation and triangulation (Fig 1). <p> These operations are relatively simpler and faster to perform on a Bezier representation than on B-splines. The algorithm in <ref> [RHD89] </ref> partitions each trimming curve into monotonic segments. This monotonic subdivision followed by special triangulation at the patch boundaries sometimes becomes a bottleneck for the [RHD89] algorithm. We overcome these problems with handling trimming curves and present efficient algorithms for trimmed cell computation and triangulation (Fig 1). We also 2 (a) [RHD89]'s Triangulation (b) Our Triangulation devise better bounds for uniformly tessellating the surface domain into fewer cells and compute the trimmed regions without partitioning them <p> The step size is computed as a function of these bounds and viewing parameters [LR81, FMM86, AES91, KM94b]. * Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size is a function of these bounds <ref> [Roc87, RHD89] </ref>. The advantage of the first method is that it reduces the on-line time for bounds computation. Little computation is required to calculate the desired step size for a patch given the viewing parameters (the transformation matrix). <p> This is easily achieved by generating triangle-strips (called coving triangles) at the boundaries (see Fig. 3) as described in <ref> [RHD89] </ref> for the boundaries of untrimmed patches. Since the trimming curves can themselves be boundary curves (especially when they arise from intersection of surfaces), we need an extension of the same concept here also. <p> We simply retriangulate the region. The u-lines are handled similarly. 6 Implementation & Performance Our algorithm performs well in practice and coving is no longer the bottleneck. The polygonization produced by our algorithm is compared to that of the implementation in SGI-GL library based on <ref> [RHD89] </ref> in Figs. 1 and 15. We implemented this algorithm on two platforms - SGI-Onyx and the Pixelplanes 5 system at UNC. The Onyx was used with a single processor. <p> No inter-processor communication is required. As a result it can be easily ported to any other multiple processor machine. The performance of the algorithm on the SGI has been shown in Table 6. The SGI-GL implementation [Nas93] is based on the algorithm presented in <ref> [RHD89] </ref> and has a microcoded geometry engine implementation for surface evaluations. This implementation works in immediate mode. So, even though we had turned off all usage of coherence in our algorithm, we did not have to do any monotonic decomposition, while the GL implementation needlessly did it for every frame.
Reference: [Roc87] <author> A. Rockwood. </author> <title> A generalized scanning technique for display of parametrically defined surface. </title> <journal> IEEE Computer Graphics and Applications, </journal> <pages> pages 15-26, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: On the other hand these systems can render millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. As a result, only algorithms based on polygonization come close to real time display. Many different methods based on polygo-nization have been proposed in the literature <ref> [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86] </ref>. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these have been specializeed to trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models. <p> In the context of uniform tessellation, the evaluation of Bezier polynomials can be optimized if we use points that lie on an isoparametric curve: we can reuse one of the factors of the tensor product or use forward 6 differencing <ref> [Roc87] </ref>. Another major reason for the choice of uniform tessellation is the relative simplicity and efficiency of handling trimming curves (as compared to adaptive subdivision). 3.1 Patch tessellation There is considerable literature on computation of bounds on polynomials [LR81, FMM86, Roc87, AES91]. <p> Another major reason for the choice of uniform tessellation is the relative simplicity and efficiency of handling trimming curves (as compared to adaptive subdivision). 3.1 Patch tessellation There is considerable literature on computation of bounds on polynomials <ref> [LR81, FMM86, Roc87, AES91] </ref>. They are base upon the size or the deviation criteria. Sometimes a normal deviation criterion is also used. This criterion bounds the deviation of the triangles' normals from the surface normal. While this bound can improve the image quality, it is relatively expensive to evaluate. <p> The step size is computed as a function of these bounds and viewing parameters [LR81, FMM86, AES91, KM94b]. * Transform the surface into screen space based on the transformation matrix. Use the transformed representation to compute the bounds and the step size is a function of these bounds <ref> [Roc87, RHD89] </ref>. The advantage of the first method is that it reduces the on-line time for bounds computation. Little computation is required to calculate the desired step size for a patch given the viewing parameters (the transformation matrix).
Reference: [SC88] <author> M. Shantz and S. Chang. </author> <title> Rendering trimmed nurbs with adaptive forward differencing. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 189-198, </pages> <year> 1988. </year>
Reference-contexts: Many different methods based on polygo-nization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these have been specializeed to trimmed surface models <ref> [RHD89, Luk93, LC93, Che93, SC88, Vla90] </ref>. We present a fast algorithm for rendering trimmed NURBS models. Our overall approach shares its principle with the algorithm presented by Rockwood et. al. [RHD89].
Reference: [Sei91] <author> R. Seidel. </author> <title> A simple and fast randomized algorithm for computing trapezoidal decompositions and for triangulating polygons. </title> <journal> Computational Geometry Theory & Applications, </journal> <volume> 1(1) </volume> <pages> 51-64, </pages> <year> 1991. </year>
Reference-contexts: If we use the external point A instead of b, we get a correct triangulation there. Similarly we can replace all crossings with the corresponding external points, and avoid creating extra tessellants on the curve. This polygon can now be triangulated using any polygon triangulation algorithms <ref> [PS85, CTV89, Sei91] </ref>. Our current implementation uses an implementation of Seidel's randomized algorithm [Sei91, NM95]. There are two new problems with this method of polygon generation, though: 1. The external point of one cell is the exit point of another. <p> Similarly we can replace all crossings with the corresponding external points, and avoid creating extra tessellants on the curve. This polygon can now be triangulated using any polygon triangulation algorithms [PS85, CTV89, Sei91]. Our current implementation uses an implementation of Seidel's randomized algorithm <ref> [Sei91, NM95] </ref>. There are two new problems with this method of polygon generation, though: 1. The external point of one cell is the exit point of another. If these points are included in polygons for both the cells, some overlapping triangles can be created. e.g.
Reference: [SGI] <author> SGI. </author> <title> The SGI Graphics Library manual. </title>
Reference-contexts: We compare the surface triangulation of the two algorithms in Fig. 1. Fig. 1 (a) corresponds to the SGI-GL implementation based on Rockwood et. al.'s algorithm <ref> [Nas93, SGI] </ref>. Our algorithm uses ideas from [KML95] for culling back facing patches. Such patches are not visible if the model is closed and consistent. We also make use of coherence between successive frames and performs incremental computation at each frame. This gains us a speedup of more than 8-9.
Reference: [SL87] <author> M. Shantz and S. Lien. </author> <title> Shading bicubic patches. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 189-196, </pages> <year> 1987. </year>
Reference-contexts: On the other hand these systems can render millions of transformed, shaded and z-buffered polygons per second [Ake93, Fea89]. As a result, only algorithms based on polygonization come close to real time display. Many different methods based on polygo-nization have been proposed in the literature <ref> [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86] </ref>. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these have been specializeed to trimmed surface models [RHD89, Luk93, LC93, Che93, SC88, Vla90]. We present a fast algorithm for rendering trimmed NURBS models.
Reference: [Vla90] <author> V. Vlassopoulos. </author> <title> Adaptive polygonization of parametric surface. </title> <journal> Visual Computer, </journal> <volume> 6 </volume> <pages> 291-298, </pages> <month> November </month> <year> 1990. </year> <pages> 27 28 </pages>
Reference-contexts: Many different methods based on polygo-nization have been proposed in the literature [AES93, Dea89, LR81, SL87, Roc87, AES91, FMM86]. Broadly speaking they can be classified into uniform and adaptive tessellation of NURBS surfaces. Many of these have been specializeed to trimmed surface models <ref> [RHD89, Luk93, LC93, Che93, SC88, Vla90] </ref>. We present a fast algorithm for rendering trimmed NURBS models. Our overall approach shares its principle with the algorithm presented by Rockwood et. al. [RHD89].
References-found: 36

