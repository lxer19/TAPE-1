URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr95/tr95-019.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr95-abstracts.html
Root-URL: http://www.cis.ufl.edu
Email: E-mail: fishwick@cise.ufl.edu  
Phone: Phone  FAX: (904) 392-1414  
Title: A Taxonomy for Simulation Modeling Based on Programming Language Principles  
Author: Paul A. Fishwick 
Date: June 21, 1996  
Web: WWW: http://www.cis.ufl.edu/~fishwick  
Address: Bldg. CSE, Room 301 Gainesville, FL 32611  
Affiliation: Dept. of Computer Information Science and Engineering University of Florida  
Note: SUBMISSION FOR SPECIAL ISSUE ON COMPUTER SIMULATION for IIE Transactions on IE Research  and  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Jerry Banks and John S. Carson. </author> <title> Discrete Event System Simulation. </title> <publisher> Prentice Hall, </publisher> <year> 1984. </year>
Reference-contexts: While there has been significant coverage in the simulation literature for analysis methods <ref> [1, 18] </ref>, the general area of modeling for simulation has lacked uniformity and indepth coverage. Two areas of modeling termed "discrete event" and "continuous" are defined in the simulation literature. For discrete event models, the field is sub-divided into event-oriented, process and activity-based modeling. <p> Two areas of modeling termed "discrete event" and "continuous" are defined in the simulation literature. For discrete event models, the field is sub-divided into event-oriented, process and activity-based modeling. To choose one of these sub-categories, we might ask "What is an event-oriented model?" There is no clear definition <ref> [1, 18] </ref> other than to state that a discrete event model is one where discrete events predominate. There is no attempt to further categorize or classify the form taken on by an event-oriented model. In mentioning form, we need to address the differences between syntax (form) and semantics (execution).
Reference: [2] <author> Grady Booch. </author> <title> Object Oriented Design. </title> <publisher> Benjamin Cummings, </publisher> <year> 1991. </year>
Reference-contexts: Conceptual models are highlighted in Artificial Intelligence (AI). In AI, we find a plethora of potential conceptual model types including semantic networks, logic-based formalisms (without a time base), frames and other schemata. We have found the object oriented (OO) paradigm <ref> [2, 32, 42] </ref> to encapsulate a favorable way of encoding conceptual models. One should begin to define a system by first defining attributes, methods, 6 Table 1: Sample Model Categories and Associated Applications. <p> Conceptual models comprise both aggregation and generalization hierarchies <ref> [32, 2] </ref>. Generalization hierarchies specify relationships based on type: a robot may be of several types such as welding, pick-and-place or inspection, or some combination of these. Aggregation hierarchies specify a relation based on composition: a robot is composed of a base, links and an end-effector. Within an object (ref.
Reference: [3] <author> Alan H. Borning. </author> <title> THINGLAB A Constraint-Oriented Simulation Laboratory. </title> <type> Technical report, </type> <note> Xerox PARC, </note> <year> 1979. </year>
Reference-contexts: The languages Lisp [38] and ML [25] are two example functional languages. Lisp has some declarative features (side effects) whereas other functional languages attempt to be "pure." Finally, with regard to computer science metaphors, constraint languages <ref> [3, 19] </ref> reflect a way of programming where procedures and declarations are insufficient. The constraint language CLP (R) [13] (Constraint Logic Programming) represents this type of language. Also, the next generation Prolog (Prolog III) is constraint oriented.
Reference: [4] <author> Peter C. Breedveld. </author> <title> A Systematic Method to Derive Bond Graph Models. </title> <booktitle> In Second European Simulation Congress, </booktitle> <address> Antwerp, Belgium, </address> <year> 1986. </year>
Reference-contexts: An example constraint graph is an analog electrical circuit or a bond graph <ref> [4] </ref>. * Spatial models have a focus on either the whole space or an entity. Space-based orientations involve the updated state of the entire space by convolution of a template over that space (as with the numerical solution of PDEs). <p> In such a case, an equation is often the best characterization of the model since a directional approach such as functional modeling is insufficient. Equational systems include difference models, ordinary differential equations and delay differential equations. Graphical models such as bond graphs <ref> [4, 16] </ref> and electrical network graphs [29] are also constraint based.
Reference: [5] <author> Alain Colmerauer. </author> <title> Prolog in 10 figures. </title> <journal> Communications of the ACM, </journal> <volume> 28(12):1296 - 1310, </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: Declarative programming semantics are those where data and variable declarations constitute the expression of the semantics; one specifies how variables change in the program by declaring present and future variable values. The form of declarative models is either graphical (automata,chains) or textual (patterns,logical inferences). Prolog <ref> [5] </ref> is an example of a declarative language with a textual orientation. Functional languages, such as Lisp [38], specify how variables change using compositional function mappings.
Reference: [6] <author> Richard C. Dorf. </author> <title> Modern Control Systems. </title> <publisher> Addison Wesley, </publisher> <year> 1986. </year>
Reference-contexts: When the system is viewed as a set of blocks communicating with messages or signals, the functional paradigm takes hold. The use of functional models is found in control engineering <ref> [6, 24] </ref> (continuous and discrete time signals) as well as in queuing networks (discrete signals). Some functional systems focus not so much on the functions, but more on the variables. Such models include signal flow graphs, compartmental models [15], and Systems Dynamics graphs [31].
Reference: [7] <author> Paul A. Fishwick. </author> <title> An Integrated Approach to System Modelling using a Synthesis of Artificial Intelligence, </title> <booktitle> Software Engineering and Simulation Methodologies. ACM Transactions on Modeling and Computer Simulation, </booktitle> <year> 1992. </year> <note> (submitted for review). 18 </note>
Reference-contexts: The lowest level of abstraction for a system will often implement a spatial model whereas the highest level may use a declarative finite state machine. Intermediate levels will often use functional and constraint techniques. Models that are composed of other models are termed multimodels <ref> [7, 8, 11] </ref>. By utilizing abstraction levels, we can switch levels during the simulation and use the abstraction most appropriate at that given time. This approach gives us multiple levels of explanation and is computationally more efficient than simulating the system at one level.
Reference: [8] <author> Paul A. Fishwick. </author> <title> A Simulation Environment for Multimodeling. Discrete Event Dy--namic Systems: </title> <journal> Theory and Applications, </journal> <volume> 3 </volume> <pages> 151-171, </pages> <year> 1993. </year>
Reference-contexts: The lowest level of abstraction for a system will often implement a spatial model whereas the highest level may use a declarative finite state machine. Intermediate levels will often use functional and constraint techniques. Models that are composed of other models are termed multimodels <ref> [7, 8, 11] </ref>. By utilizing abstraction levels, we can switch levels during the simulation and use the abstraction most appropriate at that given time. This approach gives us multiple levels of explanation and is computationally more efficient than simulating the system at one level.
Reference: [9] <author> Paul A. Fishwick. </author> <title> Simulation Model Design and Execution: Building Digital Worlds. </title> <publisher> Prentice Hall, </publisher> <year> 1995. </year>
Reference-contexts: We proceed to first define what we mean by the word model. Models are devices used by scientists and engineers to communicate with one another using a concise|often visual|representation of a physical system. In our methodology <ref> [9] </ref>, a model is defined as a graph (a visual formalism consisting of nodes, arcs and labels) with two exceptions: a set of rules or equations. Computer code and programs are not considered to be models since code semantics are specified at too low a level. <p> By providing an "event-oriented" model category, it is not clear whether this includes only those models which have explicitly surfaced "events" in their forms (as in event graphs [35] or animation scripts <ref> [9] </ref>) or whether a GPSS or Simscript program [23] could be considered an event-oriented model. Our approach is to clearly separate model design (syntax) from execution (semantics). Moreover, as stated earlier, programs are not considered to be models at least for most textually-based programming languages. <p> The "Moving" state is refined (or disaggregated) to include the PID controller. Multimodels with more than two levels and model types are detailed in <ref> [9] </ref>. Summary The existing taxonomy for simulation modeling was found to have several flaws, which are rectified using the new taxonomy.
Reference: [10] <author> Paul A. Fishwick. </author> <title> Toward a Convergence of Systems and Software Engineering. </title> <journal> IEEE Transactions on Systems, Man and Cybernetics, </journal> <month> May </month> <year> 1996. </year> <note> Submitted for review. </note>
Reference-contexts: These same categories can be used to organize dynamic models just as they currently do for programs, with modeling and programming have similar roots <ref> [10] </ref>. In Table 1, we show the base categories along with application areas and some sample model types used by those areas. Multimodels are not listed since they are models containing base category models as components.
Reference: [11] <author> Paul A. Fishwick and Bernard P. Zeigler. </author> <title> A Multimodel Methodology for Qualitative Model Engineering. </title> <journal> ACM Transactions on Modeling and Computer Simulation, </journal> <volume> 2(1) </volume> <pages> 52-81, </pages> <year> 1992. </year>
Reference-contexts: Programs and formal specifications [40, 41, 27] are a vital ingredient in the simulation process since, without these methods, modeling approaches lack precision and cohesion. However, our definition of modeling is positioned at a different level: models can be translated into executable programs and formal specifications. Fishwick and Zeigler <ref> [11] </ref> demonstrated this translation using the DEVS [41] formalism for one particular type of visual multimodel (finite state machine model controlling a set of constraint models). If one were to sketch a translation chain, it would be as follows: conceptual model ) executable model ) fFormalism,Programg. <p> The lowest level of abstraction for a system will often implement a spatial model whereas the highest level may use a declarative finite state machine. Intermediate levels will often use functional and constraint techniques. Models that are composed of other models are termed multimodels <ref> [7, 8, 11] </ref>. By utilizing abstraction levels, we can switch levels during the simulation and use the abstraction most appropriate at that given time. This approach gives us multiple levels of explanation and is computationally more efficient than simulating the system at one level.
Reference: [12] <author> Carlo Ghezzi and Mehdi Jazayeri. </author> <title> Programming Language Concepts. </title> <publisher> John Wiley, </publisher> <year> 1982. </year>
Reference-contexts: Likewise, this flow is directly analogous to functional composition in functional programming languages. The field of computer science contains categories of programming languages <ref> [12, 20] </ref> that serve to create three of the following six model categories: conceptual, declarative, functional, constraint, spatial and multimodel.
Reference: [13] <author> Nevin Heintze, Joxan Jaffar, Spiro Michaylov, Peter Stuckey, and Roland Yap. </author> <title> The CLP(R) Programmer's Manual: </title> <note> Version 1.1, </note> <month> November </month> <year> 1991. </year>
Reference-contexts: Lisp has some declarative features (side effects) whereas other functional languages attempt to be "pure." Finally, with regard to computer science metaphors, constraint languages [3, 19] reflect a way of programming where procedures and declarations are insufficient. The constraint language CLP (R) <ref> [13] </ref> (Constraint Logic Programming) represents this type of language. Also, the next generation Prolog (Prolog III) is constraint oriented. In constraint models, the focus is on a model structure, which involves basic balances of units such as mass and energy.
Reference: [14] <author> John E. Hopcroft and Jeffrey D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison Wesley, </publisher> <year> 1979. </year>
Reference-contexts: The idea behind declarative modeling is to focus on the structure of the state (or event) from one time period to the next, while de-emphasizing functions or constraints that define the transition. Models such as finite state automata <ref> [14] </ref>, Markov models, event graphs [35] and temporal logic models [22] fall into the declarative category. Declarative models are state-based (FSAs), event-based (event graphs) or hybrid (Petri nets [26]).
Reference: [15] <author> John A. Jacquez. </author> <title> Compartmental Analysis in Biology and Medicine. </title> <publisher> University of Michigan Press, </publisher> <year> 1985. </year> <note> Second edition. </note>
Reference-contexts: The use of functional models is found in control engineering [6, 24] (continuous and discrete time signals) as well as in queuing networks (discrete signals). Some functional systems focus not so much on the functions, but more on the variables. Such models include signal flow graphs, compartmental models <ref> [15] </ref>, and Systems Dynamics graphs [31]. In this latter group of models, the function is often an implicit linear one, with the pronounced variables shown in the graph representing state variables along with parameters.
Reference: [16] <author> Dean C. Karnopp, Donald L. Margolis, and Ronald C. Rosenberg. </author> <title> System Dynamics. </title> <publisher> John Wiley and Sons, </publisher> <year> 1990. </year>
Reference-contexts: In such a case, an equation is often the best characterization of the model since a directional approach such as functional modeling is insufficient. Equational systems include difference models, ordinary differential equations and delay differential equations. Graphical models such as bond graphs <ref> [4, 16] </ref> and electrical network graphs [29] are also constraint based.
Reference: [17] <author> Robert Kowalski. </author> <title> Logic for Problem Solving. </title> <publisher> Elsevier North Holland, </publisher> <year> 1979. </year>
Reference-contexts: A declarative simulation model is one where states and event transitions (individually or in groups) are specified in the model directly. Production rule languages and logic-based languages based on Horn clauses (such as Prolog <ref> [17] </ref>) create a mirror image of the declarative model for simulation. Moreover, declarative semantics are used to define the interpretation of programming language statements. A functional model is one where there is directionality in flow of a signal (whether discrete or continuous).
Reference: [18] <author> Averill M. Law and David W. </author> <title> Kelton. Simulation Modeling & Analysis. </title> <publisher> McGraw-Hill, </publisher> <year> 1991. </year> <note> Second edition. </note>
Reference-contexts: While there has been significant coverage in the simulation literature for analysis methods <ref> [1, 18] </ref>, the general area of modeling for simulation has lacked uniformity and indepth coverage. Two areas of modeling termed "discrete event" and "continuous" are defined in the simulation literature. For discrete event models, the field is sub-divided into event-oriented, process and activity-based modeling. <p> Two areas of modeling termed "discrete event" and "continuous" are defined in the simulation literature. For discrete event models, the field is sub-divided into event-oriented, process and activity-based modeling. To choose one of these sub-categories, we might ask "What is an event-oriented model?" There is no clear definition <ref> [1, 18] </ref> other than to state that a discrete event model is one where discrete events predominate. There is no attempt to further categorize or classify the form taken on by an event-oriented model. In mentioning form, we need to address the differences between syntax (form) and semantics (execution).
Reference: [19] <author> William Leler. </author> <title> Constraint Programming Languages: Their Specification and Generation. </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Prolog [5] is an example of a declarative language with a textual orientation. Functional languages, such as Lisp [38], specify how variables change using compositional function mappings. These mappings conform exactly to the mathematical definition of the term "function." Constraint programming languages <ref> [19] </ref> allow both forward and backward chains to be created to "solve" for variable values. These same categories can be used to organize dynamic models just as they currently do for programs, with modeling and programming have similar roots [10]. <p> The languages Lisp [38] and ML [25] are two example functional languages. Lisp has some declarative features (side effects) whereas other functional languages attempt to be "pure." Finally, with regard to computer science metaphors, constraint languages <ref> [3, 19] </ref> reflect a way of programming where procedures and declarations are insufficient. The constraint language CLP (R) [13] (Constraint Logic Programming) represents this type of language. Also, the next generation Prolog (Prolog III) is constraint oriented.
Reference: [20] <author> Bertrand Meyer. </author> <title> Introduction to the Theory of Programming Languages. </title> <publisher> Prentice Hall International Series, </publisher> <year> 1990. </year>
Reference-contexts: Likewise, this flow is directly analogous to functional composition in functional programming languages. The field of computer science contains categories of programming languages <ref> [12, 20] </ref> that serve to create three of the following six model categories: conceptual, declarative, functional, constraint, spatial and multimodel.
Reference: [21] <author> Greg Michaelson. </author> <title> An Introduction to Functional Programming through Lambda Calculus. </title> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: A functional model is one where there is directionality in flow of a signal (whether discrete or continuous). The flow has a source, several possible sinks, and contains coupled components through which material flows. Functional languages, often based on the lambda calculus <ref> [21, 30] </ref>, are very similar in principle. If programming language statements are not viewed declaratively, they usually are defined using functional semantics. The languages Lisp [38] and ML [25] are two example functional languages.
Reference: [22] <author> Ben Moszkowski. </author> <title> Executing Temporal Logic Programs. </title> <publisher> Cambridge Press, </publisher> <address> Cambridge, </address> <year> 1986. </year>
Reference-contexts: The idea behind declarative modeling is to focus on the structure of the state (or event) from one time period to the next, while de-emphasizing functions or constraints that define the transition. Models such as finite state automata [14], Markov models, event graphs [35] and temporal logic models <ref> [22] </ref> fall into the declarative category. Declarative models are state-based (FSAs), event-based (event graphs) or hybrid (Petri nets [26]).
Reference: [23] <author> Richard E. Nance. </author> <title> Simulation Programming Languages: An Abridged History. </title> <booktitle> In 1995 Winter Simulation Conference, </booktitle> <pages> pages 1307 - 1313, </pages> <address> Washington, DC, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: By providing an "event-oriented" model category, it is not clear whether this includes only those models which have explicitly surfaced "events" in their forms (as in event graphs [35] or animation scripts [9]) or whether a GPSS or Simscript program <ref> [23] </ref> could be considered an event-oriented model. Our approach is to clearly separate model design (syntax) from execution (semantics). Moreover, as stated earlier, programs are not considered to be models at least for most textually-based programming languages. One can attach semantics to syntax, but they remain orthogonal concepts.
Reference: [24] <author> Katsuhiko Ogata. </author> <title> Modern Control Engineering. </title> <publisher> Prentice Hall, </publisher> <year> 1970. </year>
Reference-contexts: When the system is viewed as a set of blocks communicating with messages or signals, the functional paradigm takes hold. The use of functional models is found in control engineering <ref> [6, 24] </ref> (continuous and discrete time signals) as well as in queuing networks (discrete signals). Some functional systems focus not so much on the functions, but more on the variables. Such models include signal flow graphs, compartmental models [15], and Systems Dynamics graphs [31].
Reference: [25] <author> L. C. Paulson. </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year> <month> 19 </month>
Reference-contexts: Functional languages, often based on the lambda calculus [21, 30], are very similar in principle. If programming language statements are not viewed declaratively, they usually are defined using functional semantics. The languages Lisp [38] and ML <ref> [25] </ref> are two example functional languages. Lisp has some declarative features (side effects) whereas other functional languages attempt to be "pure." Finally, with regard to computer science metaphors, constraint languages [3, 19] reflect a way of programming where procedures and declarations are insufficient.
Reference: [26] <author> James L. Peterson. </author> <title> Petri Net Theory and the Modeling of Systems. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1981. </year>
Reference-contexts: In mentioning form, we need to address the differences between syntax (form) and semantics (execution). A program or model may be of a particular form; however, the semantics of this form may have a variety of possibilities. A Petri net <ref> [26] </ref> has a particular form regardless of the way in which it is executed. Ideally, then, we would like to create a model category which classifies the form of the Petri net, apart from its potential execution characteristics. <p> Models such as finite state automata [14], Markov models, event graphs [35] and temporal logic models [22] fall into the declarative category. Declarative models are state-based (FSAs), event-based (event graphs) or hybrid (Petri nets <ref> [26] </ref>). For the robot scenario, example states for the robot object are "grasping," "inspecting" (for high abstraction levels) or the number of parts waiting for service on the conveyor (for low abstraction levels). The level of information and abstraction of models is discussed more in the Multimodel section.
Reference: [27] <author> Herbert Praehofer. </author> <title> Systems Theoretic Formalisms for Combined Discrete-Continuous System Simulation. </title> <journal> International Journal of General Systems, </journal> <volume> 19(3) </volume> <pages> 219-240, </pages> <year> 1991. </year>
Reference-contexts: Likewise, formal methods are viewed to specify the formal semantics for models but do not focus on representing the kind of high-level form needed for modeling. We consider low-level constructs defining system dynamics to be programs or formal specifications, rather than models. Programs and formal specifications <ref> [40, 41, 27] </ref> are a vital ingredient in the simulation process since, without these methods, modeling approaches lack precision and cohesion. However, our definition of modeling is positioned at a different level: models can be translated into executable programs and formal specifications.
Reference: [28] <author> Przemyslaw Prusinkiewicz and Aristid Lindenmeyer. </author> <title> The Algorithmic Beauty of Plants. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: PDEs are space-based where the template defines the integration method. L-Systems <ref> [28] </ref> are entity-based since the dynamics are based on how the organism grows over a fixed space. A CA represents a simple way of modeling a single server queue. Fig. 9 illustrates a CA with parts waiting for service from the robot.
Reference: [29] <author> R. Raghuram. </author> <title> Computer Simulation of Electronic Circuits. </title> <publisher> John Wiley, </publisher> <year> 1989. </year>
Reference-contexts: In such a case, an equation is often the best characterization of the model since a directional approach such as functional modeling is insufficient. Equational systems include difference models, ordinary differential equations and delay differential equations. Graphical models such as bond graphs [4, 16] and electrical network graphs <ref> [29] </ref> are also constraint based.
Reference: [30] <author> G. Revesz. </author> <title> Lambda Calculus Combinators and Functional Programming. </title> <publisher> Cambridge University Press, </publisher> <year> 1988. </year>
Reference-contexts: A functional model is one where there is directionality in flow of a signal (whether discrete or continuous). The flow has a source, several possible sinks, and contains coupled components through which material flows. Functional languages, often based on the lambda calculus <ref> [21, 30] </ref>, are very similar in principle. If programming language statements are not viewed declaratively, they usually are defined using functional semantics. The languages Lisp [38] and ML [25] are two example functional languages.
Reference: [31] <author> Nancy Roberts, David Andersen, Ralph Deal, Michael Garet, and William Shaffer. </author> <title> Introduction to Computer Simulation: A Systems Dynamics Approach. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Some functional systems focus not so much on the functions, but more on the variables. Such models include signal flow graphs, compartmental models [15], and Systems Dynamics graphs <ref> [31] </ref>. In this latter group of models, the function is often an implicit linear one, with the pronounced variables shown in the graph representing state variables along with parameters.
Reference: [32] <author> James Rumbaugh, Michael Blaha, William Premerlani, Eddy Frederick, and William Lorenson. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Conceptual models are highlighted in Artificial Intelligence (AI). In AI, we find a plethora of potential conceptual model types including semantic networks, logic-based formalisms (without a time base), frames and other schemata. We have found the object oriented (OO) paradigm <ref> [2, 32, 42] </ref> to encapsulate a favorable way of encoding conceptual models. One should begin to define a system by first defining attributes, methods, 6 Table 1: Sample Model Categories and Associated Applications. <p> Each of these sub-types has two sub-categories: 7 * Conceptual models are either in pictorial form or in natural language "text" form. For our purposes, we have chosen to represent conceptual models as aggregation and generalization hierarchies, commonly found in object-oriented design <ref> [32] </ref>. * Declarative models focus on patterns associated with states or events. An example declarative model type with a state focus is the finite state automaton. <p> Conceptual models comprise both aggregation and generalization hierarchies <ref> [32, 2] </ref>. Generalization hierarchies specify relationships based on type: a robot may be of several types such as welding, pick-and-place or inspection, or some combination of these. Aggregation hierarchies specify a relation based on composition: a robot is composed of a base, links and an end-effector. Within an object (ref.
Reference: [33] <author> Hanan Samet. </author> <title> Applications of Spatial Data Structures: Computer Graphics, Image Processing, and GIS. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: The first requirement, which is normally satisfied in non-spatial models through the use of facility queues, is satisfied automatically by employing spatial data structures <ref> [33, 34] </ref>. The second requirement is satisfied through adjacency tests or collision detection algorithms. Multimodel Large scale models are built from one or more abstraction levels, each level being designed using one of the aforementioned primitive model types.
Reference: [34] <author> Hanan Samet. </author> <title> The Design and Analysis of Spatial Data Structures. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: The first requirement, which is normally satisfied in non-spatial models through the use of facility queues, is satisfied automatically by employing spatial data structures <ref> [33, 34] </ref>. The second requirement is satisfied through adjacency tests or collision detection algorithms. Multimodel Large scale models are built from one or more abstraction levels, each level being designed using one of the aforementioned primitive model types.
Reference: [35] <author> Lee W. Schruben. </author> <title> Simulation Modeling with Event Graphs. </title> <journal> Communications of the ACM, </journal> <volume> 26(11), </volume> <year> 1983. </year>
Reference-contexts: By providing an "event-oriented" model category, it is not clear whether this includes only those models which have explicitly surfaced "events" in their forms (as in event graphs <ref> [35] </ref> or animation scripts [9]) or whether a GPSS or Simscript program [23] could be considered an event-oriented model. Our approach is to clearly separate model design (syntax) from execution (semantics). Moreover, as stated earlier, programs are not considered to be models at least for most textually-based programming languages. <p> The idea behind declarative modeling is to focus on the structure of the state (or event) from one time period to the next, while de-emphasizing functions or constraints that define the transition. Models such as finite state automata [14], Markov models, event graphs <ref> [35] </ref> and temporal logic models [22] fall into the declarative category. Declarative models are state-based (FSAs), event-based (event graphs) or hybrid (Petri nets [26]).
Reference: [36] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison Wesley, </publisher> <address> 2 edition, </address> <year> 1991. </year>
Reference-contexts: There are several reasons for using an object-oriented design for the conceptual model, including the use of advantageous features such as polymorphism and inheritance <ref> [36] </ref>; however, the primary reason is that the design is "close" to reality|at least in the way that we categorize the world with natural language. Conceptual models comprise both aggregation and generalization hierarchies [32, 2]. <p> A method can be code, whose form depends on the programming language, or a dynamic model. The structure of a class is seen in Fig. 6. Variables and code are described in OO languages such as C++ <ref> [36] </ref>. We define a static model as a graph of objects and a dynamic model as a graph of attributes and methods.
Reference: [37] <author> Tommaso Toffoli and Norman Margolus. </author> <title> Cellular Automata Machines: A New Environment for Modeling. </title> <publisher> MIT Press, </publisher> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: Kolmogorov's forward equation for a birth-death process in Eq. 2: d P ij (t) Rate = j1 P i;j1 (t) + j+1 P i;j+1 (t) Parts Arriving ( j + j )P ij (t) Parts Released (2) Spatial Model If a system is spatially decomposed as for cellular automata (CA) <ref> [37, 39] </ref>, Ising systems, PDE-based solutions or finite element models, then the system is being modeled using a spatial modeling technique. Spatial models are used to model systems in great detail, where individual pieces of physical phenomena are modeled by discretizing the geometry of the system. <p> The solid circle 14 represents a part. The shaded circle and polygons represent the phases of the server and the cross is a wildcard that matches any other cell. The rules in Fig. 10 are "block rules" <ref> [37] </ref> and are used as patterns used in a convolution procedure over the background CA space. A rule is applied by a search for the pattern on the left hand side of the rules in Fig. 10.
Reference: [38] <author> Patrick Henry Winston and Berthold Klaus Paul Horn. </author> <title> LISP. </title> <publisher> Addison Wesley, </publisher> <address> second edition, </address> <year> 1984. </year>
Reference-contexts: The form of declarative models is either graphical (automata,chains) or textual (patterns,logical inferences). Prolog [5] is an example of a declarative language with a textual orientation. Functional languages, such as Lisp <ref> [38] </ref>, specify how variables change using compositional function mappings. These mappings conform exactly to the mathematical definition of the term "function." Constraint programming languages [19] allow both forward and backward chains to be created to "solve" for variable values. <p> The flow has a source, several possible sinks, and contains coupled components through which material flows. Functional languages, often based on the lambda calculus [21, 30], are very similar in principle. If programming language statements are not viewed declaratively, they usually are defined using functional semantics. The languages Lisp <ref> [38] </ref> and ML [25] are two example functional languages. Lisp has some declarative features (side effects) whereas other functional languages attempt to be "pure." Finally, with regard to computer science metaphors, constraint languages [3, 19] reflect a way of programming where procedures and declarations are insufficient.
Reference: [39] <author> Stephen Wolfram. </author> <title> Theory and Applications of Cellular Automata. </title> <publisher> World Scientific Publishing, </publisher> <address> Singapore, </address> <year> 1986. </year> <note> (includes selected papers from 1983 - 1986). </note>
Reference-contexts: Kolmogorov's forward equation for a birth-death process in Eq. 2: d P ij (t) Rate = j1 P i;j1 (t) + j+1 P i;j+1 (t) Parts Arriving ( j + j )P ij (t) Parts Released (2) Spatial Model If a system is spatially decomposed as for cellular automata (CA) <ref> [37, 39] </ref>, Ising systems, PDE-based solutions or finite element models, then the system is being modeled using a spatial modeling technique. Spatial models are used to model systems in great detail, where individual pieces of physical phenomena are modeled by discretizing the geometry of the system.
Reference: [40] <author> Bernard P. Zeigler. </author> <title> Towards a Formal Theory of Modelling and Simulation: Structure Preserving Morphisms. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 19(4):742 - 764, </volume> <year> 1972. </year>
Reference-contexts: Likewise, formal methods are viewed to specify the formal semantics for models but do not focus on representing the kind of high-level form needed for modeling. We consider low-level constructs defining system dynamics to be programs or formal specifications, rather than models. Programs and formal specifications <ref> [40, 41, 27] </ref> are a vital ingredient in the simulation process since, without these methods, modeling approaches lack precision and cohesion. However, our definition of modeling is positioned at a different level: models can be translated into executable programs and formal specifications.
Reference: [41] <author> Bernard P. Zeigler. </author> <title> DEVS Representation of Dynamical Systems: Event-Based Intelligent Control. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 77(1):72 - 80, </volume> <month> January </month> <year> 1989. </year>
Reference-contexts: Likewise, formal methods are viewed to specify the formal semantics for models but do not focus on representing the kind of high-level form needed for modeling. We consider low-level constructs defining system dynamics to be programs or formal specifications, rather than models. Programs and formal specifications <ref> [40, 41, 27] </ref> are a vital ingredient in the simulation process since, without these methods, modeling approaches lack precision and cohesion. However, our definition of modeling is positioned at a different level: models can be translated into executable programs and formal specifications. <p> However, our definition of modeling is positioned at a different level: models can be translated into executable programs and formal specifications. Fishwick and Zeigler [11] demonstrated this translation using the DEVS <ref> [41] </ref> formalism for one particular type of visual multimodel (finite state machine model controlling a set of constraint models). If one were to sketch a translation chain, it would be as follows: conceptual model ) executable model ) fFormalism,Programg.

References-found: 41

