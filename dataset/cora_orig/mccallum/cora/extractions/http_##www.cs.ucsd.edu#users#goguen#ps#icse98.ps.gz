URL: http://www.cs.ucsd.edu/users/goguen/ps/icse98.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/goguen/new.html
Root-URL: http://www.cs.ucsd.edu
Email: fgoguen,klin,amori,grosu,asatog@cs.ucsd.edu  
Phone: phone: +1-619-534-4197, fax: -534-7029  
Title: Tools for Distributed Cooperative Design and Validation  
Author: Joseph Goguen, Kai Lin, Akira Mori, Grigore Ro~su and Akiyoshi Sato 
Address: 9500 Gilman Drive, La Jolla, CA 92093-0114, USA  
Affiliation: Dept. Computer Science Engineering, University of California, San Diego  
Abstract: We describe some tools to support distributed cooperative design and validation of software systems. Workers at different sites can collaborate on tasks including specification, refinement, validation, verification, and documentation. A distributed database supports alternative and incomplete activities, and can be read using any web browser; remote proof execution, animation, and informal explanation are supported, and results are broadcast by a protocol that prevents inconsistencies. The Kumo tool assists with validations and generates documentation websites. A range of formality is supported, from full mechanical proofs to informal "back of envelope" arguments, using a fuzzy logic for confidence levels. Some conclusions drawn from experiments are reported. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Joseph Goguen. </author> <title> The logic of inexact concepts. </title> <journal> Synthese, </journal> <volume> 19 </volume> <pages> 325-373, 1968-69. </pages>
Reference-contexts: The boolean expression at a node takes the disjunction of the boolean expressions of its fans; we use the fuzzy logic of <ref> [1] </ref> to evaluate boolean expressions. The truth value 1 means that there is a formal proof, while 0 means there is a formal disproof. Conjunction and disjunction are respectively evaluated by product and maximum. <p> Most branches are ands, but alternative validations for the same node are ors; these are respectively evaluated by product and maximum <ref> [1] </ref>.
Reference: [2] <author> Joseph Goguen. </author> <title> Principles of parameterized programming. </title> <editor> In Ted Biggerstaff and Alan Perlis, editors, </editor> <booktitle> Software Reusability, Volume I: Concepts and Models, </booktitle> <pages> pages 159-225. </pages> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The atomic specifications of a project have associated code. Composition steps tell how a given specification is obtained from simpler specifications; following the parameterized programming <ref> [2] </ref> paradigm, module expressions describe how to put modules together to form systems, using a rich set of composition operations. Another important relation is satisfaction, which just says that a specification satisfies some properties. <p> Some websites generated by kumo can be viewed at http://www.cs.ucsd.edu/groups/tatami/demos/. 1.2 Some Closely Related Work We very briefly discuss three particularly closely related tools, SpecWare [12], lileanna [14, 13], and toor [11]. SpecWare can generate code from detailed specs, and has a module system based on parameterized programming <ref> [2] </ref>; in particular it has colimit as a top level command; but it lacks the full power of parameterized programming module operations. lileanna fully implements parameterized programming and can compose Ada modules. <p> First Order Logic Hidden algebra 1 provides a logic for distributed concurrent systems, allowing correctness proofs that are (relatively!) simple and mechanizable; it handles classes, subclasses (inheritance), attributes, methods, local state, concurrency, distribution, nondeterminism, logical variables (as in logic programming), abstract data types, generic modules, and more generally parameterized programming <ref> [2] </ref>. Hidden algebra generalizes the process algebra and transition system approaches because it allows non-monadic operations, and can therefore exploit equations involving methods and attributes with parameters; see [7] for more information.
Reference: [3] <author> Joseph Goguen. Hyperprogramming: </author> <title> A formal approach to software environments. </title> <booktitle> In Proceedings, Symposium on Formal Approaches to Software Environment Technology. Joint System Development Corporation, </booktitle> <address> Tokyo, Japan, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: The tatami system combines the best of all of three, except code generation, and adds distributed cooperative work and sophisticated web publication capabilities, plus hidden algebra for verification of concurrent systems. This approach follows suggestions for "hyperprogramming" made in <ref> [3] </ref>. 2 The Tatami Databases Distributed cooperative proving requires careful bookkeeping for specifications, validation tasks, subtasks, and the relations and dependencies among them. Any worker can generate a new validation task, and any worker can pick it up and submit a partial solution, which is then broadcast to coworkers.
Reference: [4] <author> Joseph Goguen. </author> <title> Empirical study of a distributed cooperative verification exercise, 1997. </title> <type> Unpublished manuscript, UCSD. </type>
Reference-contexts: Our empirical finding that changes to the spec and goal are more common and extensive than the validation itself <ref> [4] </ref> will also be surprising, perhaps even shocking, to many in that community. 6 Computer supported distributed cooperative validation is a new research area, of potentially great importance for software engineering.
Reference: [5] <author> Joseph Goguen. </author> <title> Semiotic morphisms. </title> <type> Technical Report CS97-553, UCSD, </type> <institution> Dept. Computer Science & Eng., </institution> <year> 1997. </year> <note> Early version in Proc., Conf. Intelligent Systems: A Semiotic Perspective, Vol. </note> <editor> II, ed. J. Albus, A. Meystel and R. </editor> <address> Quintero, </address> <institution> Nat. Inst. Science & Technology (Gaithersberg MD, </institution> <month> 20-23 October </month> <year> 1996), </year> <pages> pages 26-31. </pages>
Reference-contexts: in our handmade demos at http://www.cs.ucsd.edu/groups/tatami/handdemos/.) 4.4 User Interface Issues Because we aim to help ordinary software engineers, user interface issues are of great importance, and we have put considerable effort into this often neglected area, going so far as to invent a new approach to representation called algebraic semiotics <ref> [5] </ref>, with which we can (sometimes) calculate the suitability of representations for users. Figure 4 shows screendumps of some typical tatami pages. These are the main display units for validations, and are supposed to be arranged to form 5 a narrative [8].
Reference: [6] <author> Joseph Goguen. </author> <title> Theorem Proving and Algebra. MIT, </title> <note> to appear. </note>
Reference-contexts: These rules include: * elimination rules for 8, 9, ^, _, ), and :; * Skolemization and lemma introduction; * case analysis, modus ponens, proof by contradic tion and substitution; * rewriting and equational deduction; * induction; and * coinduction. All except the last are standard; Chapter 8 of <ref> [6] </ref> provides more detail on the particular way these rules are formulated for kumo; coinduction is described in [7].
Reference: [7] <author> Joseph Goguen and Grant Malcolm. </author> <title> A hidden agenda. </title> <type> Technical Report CS97-538, UCSD, </type> <institution> Dept. Computer Science & Eng., </institution> <month> May </month> <year> 1997. </year> <note> To appear in Theoretical Computer Science. Early abstract in Proc., Conf. Intelligent Systems: A Semiotic Perspective, Vol. I, </note> <editor> ed. J. Albus, A. Meystel and R. </editor> <address> Quintero, </address> <institution> Nat. Inst. Science & Technology (Gaithersberg MD, </institution> <month> 20-23 October </month> <year> 1996), </year> <pages> pages 159-167. </pages>
Reference-contexts: Web technology provides powerful and rapidly evolving support for an asynchronous distributed, multimedia system of this kind. Our main validation method is based of a new development in algebraic specification called hidden algebra <ref> [7] </ref>, in which refinement proofs can be done in a particularly simple and elegant way using coinduction. However, it is important to recognize that not everything can be formalized, and that not everything that can be formalized should be. <p> Hidden algebra generalizes the process algebra and transition system approaches because it allows non-monadic operations, and can therefore exploit equations involving methods and attributes with parameters; see <ref> [7] </ref> for more information. Hidden algebra uses behavioral abstraction, or more precisely, behavioral satisfaction: hidden specifications characterize how objects (and systems) behave, not how they are implemented; they provide a notion of behavioral type. <p> 1 There is no room here for details of this logic, and in any case, these details are not needed to understand how the tatami system works. 2 Details of proofs rules are not needed; however we note that 4 is very effective for proving behavioral properties and behavioral refinements <ref> [7] </ref>. Sorts are used two ways in hidden algebra: for data values (e.g., of attributes), and for states of objects. <p> All except the last are standard; Chapter 8 of [6] provides more detail on the particular way these rules are formulated for kumo; coinduction is described in <ref> [7] </ref>. Users can also add derived rules to reuse common patterns; one very general derived rule called "simplify" is already built in. 4.2 Using kumo kumo produces TruthWebs, which are acyclic graphs of tatami pages, having links to tutorial and explanation pages, with frames to aid navigation.
Reference: [8] <author> Joseph Goguen, Akira Mori, and Kai Lin. </author> <title> Algebraic semiotics, ProofWebs and distributed cooperative proving. </title> <editor> In Yves Bartot, editor, </editor> <booktitle> Proceedings, User Interfaces for Theorem Provers, </booktitle> <pages> pages 25-34. </pages> <institution> INRIA, 1997. Sophia Antipolis, </institution> <month> 1-2 September </month> <year> 1997. </year>
Reference-contexts: Figure 4 shows screendumps of some typical tatami pages. These are the main display units for validations, and are supposed to be arranged to form 5 a narrative <ref> [8] </ref>. They link to each other and to appropriate explanation and tutorial material. Tatami pages appear in a fixed master window. <p> Tatami pages appear in a fixed master window. The truth status of a validation can is displayed in a status window popup; it also supports navigation through the TruthWeb; see document design and validation are called the tatami conventions <ref> [8] </ref>, and are based on algebraic semiotics. 5 Experiments, Results and Conclusions We have initial implementations for kumo and for the communication daemons that run the tatami protocol, and we have a barista server for OBJ3 running at ucsd.
Reference: [9] <author> Joseph Goguen and William Tracz. </author> <title> An implementation-oriented semantics for module composition, 1997. </title> <type> Draft manuscript. </type>
Reference-contexts: The module graphs of <ref> [9] </ref> provide one way to organize this. * It can be hard to know what others have done, because communication daemons automatically update the database; some kind of "What's New" fea ture may help. * Software proofs are often messier than mathematical proofs, because of the complex behavior of most software
Reference: [10] <author> Lutz Hamel. </author> <title> Behavioural Verification and Implementation of an Optimizing Compiler for OBJ3. </title> <type> PhD thesis, </type> <institution> Oxford University Computing Lab, </institution> <year> 1996. </year>
Reference-contexts: Several small TruthWebs are on our website, complete with illustrative applets, intuitive explanation pages, rule tutorials, and remotely executable formal proofs; an industrial scale correctness proof for OBJ optimizing compiler <ref> [10] </ref> is also on our website, and our correctness proof for the tatami protocol will soon be there too. We have run a simple experiment with cooperative distributed validation using the current implementation of our system: to show correctness of the array-with-pointer implementation of stack.
Reference: [11] <author> Francisco Pinheiro and Joseph Goguen. </author> <title> An object-oriented tool for tracing requirements. </title> <journal> IEEE Software, </journal> <pages> pages 52-64, </pages> <month> March </month> <year> 1996. </year> <note> Special issue of papers from ICRE'96. </note>
Reference-contexts: The tatami conventions are design guidelines that we have evolved for validation websites. Some websites generated by kumo can be viewed at http://www.cs.ucsd.edu/groups/tatami/demos/. 1.2 Some Closely Related Work We very briefly discuss three particularly closely related tools, SpecWare [12], lileanna [14, 13], and toor <ref> [11] </ref>. SpecWare can generate code from detailed specs, and has a module system based on parameterized programming [2]; in particular it has colimit as a top level command; but it lacks the full power of parameterized programming module operations. lileanna fully implements parameterized programming and can compose Ada modules.
Reference: [12] <author> Y.V. Srinivas and Richard Jullig. </author> <title> SpecWare language manual, version 2.0. </title> <type> Technical report, </type> <institution> Kestrel, </institution> <year> 1996. </year>
Reference-contexts: The tatami conventions are design guidelines that we have evolved for validation websites. Some websites generated by kumo can be viewed at http://www.cs.ucsd.edu/groups/tatami/demos/. 1.2 Some Closely Related Work We very briefly discuss three particularly closely related tools, SpecWare <ref> [12] </ref>, lileanna [14, 13], and toor [11].
Reference: [13] <author> William Tracz. lileanna: </author> <title> a parameterized programming language. </title> <booktitle> In Proceedings, Second International Workshop on Software Reuse, </booktitle> <pages> pages 66-78, </pages> <month> March </month> <year> 1993. </year> <pages> Lucca, </pages> <address> Italy. </address>
Reference-contexts: The tatami conventions are design guidelines that we have evolved for validation websites. Some websites generated by kumo can be viewed at http://www.cs.ucsd.edu/groups/tatami/demos/. 1.2 Some Closely Related Work We very briefly discuss three particularly closely related tools, SpecWare [12], lileanna <ref> [14, 13] </ref>, and toor [11].
Reference: [14] <author> William Tracz. </author> <title> Formal Specification of Parameterized Programs in lilleanna. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1997. </year>
Reference-contexts: The tatami conventions are design guidelines that we have evolved for validation websites. Some websites generated by kumo can be viewed at http://www.cs.ucsd.edu/groups/tatami/demos/. 1.2 Some Closely Related Work We very briefly discuss three particularly closely related tools, SpecWare [12], lileanna <ref> [14, 13] </ref>, and toor [11].
References-found: 14

