URL: http://csg-www.lcs.mit.edu:8001/Users/vivek/ps/fdpr2.ps
Refering-URL: http://csg-www.lcs.mit.edu:8001/Users/vivek/sark_pub.html
Root-URL: 
Email: mauriciosg@vnet.ibm.com Email: firis clhsu ong youngg@almaden.ibm  
Title: Optimized Code Restructuring of OS/2 Executables Visual Age C++ compiler and linker. The performance gains
Author: Jyh-Herng Chow Yong-fong Lee Kalyan Muthukumar Vivek Sarkar Mauricio Serrano Iris Garcia John Hsu Shauchi Ong Honesty Young fchowjh yflee muthu vivek sarkar 
Date: .com  
Note: A full-function prototype of FDPR/2 has been developed at IBM, targeted to restructure OS/2 Intel executables and DLLs generated by the IBM  by FDPR/2 have been quite encouraging so far; e.g., a performance gain of about 18% has been achieved for launching and  FDPR/2 is that it does not require any access or change to the Email:  source code of applications that it instruments or restructures. All it requires are the executables and the  
Address: 555 Bailey Avenue, San Jose, CA 95141  650 Harry Road, San Jose, CA 95120  
Affiliation: Application Dev. Technology Institute IBM Software Solutions Division  Almaden Research Center IBM Research Division  
Abstract: This paper describes the design and algorithms of FDPR/2 (Feedback Directed Program Restructuring of OS/2 executables), a general-purpose tool that can be used to instrument, profile, and restructure/optimize OS/2 executables for the tel x86 architecture. The optimizations delivered by FDPR/2's restructuring include improved utilization of the (instruction) memory hierarchy, improved branch alignment, and dead code elimination. These optimizations are known to be critical for object-oriented programs written in C++, and the relative performance gains observed are higher for large programs such as database engines, compilers, and debuggers that have large working sets and complex control flow. The code restructuring in FDPR/2 is performed at the basic-block granularity with the flexibility of general code motion of basic blocks across function boundaries. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> IBM OS/2 16/32-bit Object Module Format (OMF) and linear eXecutable Module Format (LX). Revision 8, </institution> <month> June </month> <year> 1994. </year> <month> 12 </month>
Reference-contexts: Following are some restrictions on the code that is restructured/instrumented by FDPR/2: * The executables must run in OS/2 2.x or later, to take advantage of the flat memory model and the Linear eXecutable header (LX) <ref> [1] </ref>. * The code must not be self-modifying. * FDPR/2 is guaranteed to work with executables produced by the Visual Age C++ compiler. However, executables produced by other compilers may also be restructured.
Reference: [2] <author> Thomas Ball and James Larus. </author> <title> Optimally Pro--filing and Tracing Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16 </volume> <pages> 1319-59, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: The current version of the front-end produces a slowdown of three to ten times when the instrumented program is run. Techniques such as the one presented in Ball and Larus <ref> [2] </ref> may also help reduce the overhead, but they would need to be adapted to the more dynamic program execution graph (rather than a static control flow graph). The performance of the restructured executables produced by FDPR/2 is currently tuned for the Pentium processor. <p> The times measured are the times to open the main application window and close it.) * Smarter Profiling: Presently, instrumentation code is added for all basic blocks that have 32-bit code. Ball and Larus <ref> [2] </ref> have shown that this is really not necessary; they have presented a technique that reduces the profiling overhead by instrumenting only a small subset of all the basic blocks.
Reference: [3] <author> Randy Heisch. </author> <title> Trace-directed Program Restructuring for AIX Executables. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 38(5) </volume> <pages> 595-604, </pages> <year> 1994. </year>
Reference-contexts: This idea in itself is not new. Global code restructuring techniques have been implemented by groups in IBM and elsewhere. A survey of these tools can be found in [8]. In particular, Heat-shrink <ref> [3] </ref> and AOPT are IBM code restructuring tools developed for AIX. These two tools are packaged together in the FDPR (Feedback Directed Program Restructuring) product, available on AIX 4.1. <p> It uses some heuristic to produce a new se quence of basic blocks from the PEG. Currently, we have implemented three heuristics in FDPR/2. Two of the heuristics implemented use variations of the depth-first traversal heuristic used by Randy Heisch <ref> [3] </ref> in FDPR on AIX. The third heuristic produces a sequence in which all the "live" blocks are sorted by their IDs followed by all the "dead" blocks sorted by their IDs. <p> This paper discusses many issues that arise in rewriting executables; for example, they discussed how a stripped executable can be instrumented, and how the extent of a jump table can be determined. Within IBM, Randy Heisch <ref> [3] </ref> and Itai Nahshon have implemented FDPR for AIX executables. FDPR is able to handle dynamic loaded modules and restructure operating system code. Its 20% performance improvement on a relational DBMS on AIX has been the motivation for our development of FDPR/2.
Reference: [4] <author> Wen-Mei W. Hwu and Pohua P. Chang. </author> <title> Achieving High Instruction Cache Performnace with an Optimizing Compiler. </title> <booktitle> In ACM International Symposium on Computer Architecture, </booktitle> <pages> pages 242-250, </pages> <year> 1989. </year>
Reference-contexts: Earlier work concentrated on reducing page faults by grouping routines into the same page on virtual memory machines. More recent work performs code repositioning at the basic block level, using profile information to glue frequently executed basic blocks together. Hwu and Chang <ref> [4] </ref> present their IMPACT compiler, which instruments profiler routines, groups basic blocks into traces that maximize spatial locality, and generates basic block layout and global layout. Within basic block layout, traces are put into a sequential order and the non-executed parts are moved to the bottom of the function.
Reference: [5] <author> James Larus and Thomas Ball. </author> <title> Rewriting Executable Files to Measure Program Behavior. </title> <journal> Software Practice and Experience, </journal> <volume> 24(2) </volume> <pages> 197-218, </pages> <year> 1994. </year>
Reference-contexts: ATOM is a tool=building system with which a diverse set of tools can be easily built. Larus and Ball <ref> [5] </ref> present their implementation of QP and QPT tools on MIPS and SPARC, the difficulties they encountered, their solutions, and recommendations for changes in compilers and executable file formats.
Reference: [6] <author> Rajeev Motwani and Vivek Sarkar. </author> <title> Optimal Selection of Short-Branch Instructions. </title> <type> Technical Report, </type> <month> June, </month> <year> 1995. </year>
Reference-contexts: The targets of CALLs and JMPs are updated and their sizes reduced to the extent possible (32 bits ! 8 bits ). Optimal algorithms for this problem can be found in <ref> [11, 6] </ref>. The current implementation in FDPR/2 uses a greedy fixpoint computation; iteratively, the sizes are reduced until no further reduction is possible. An optimal algorithm will be used in the fu ture. 5. The branch table entries are changed to reflect their new target addresses. 6.
Reference: [7] <author> Karl Pettis and Robert C. Hansen. </author> <title> Profile Guided Code Positioning. </title> <booktitle> In ACM Sigplan Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 16-27, </pages> <year> 1990. </year>
Reference-contexts: Within basic block layout, traces are put into a sequential order and the non-executed parts are moved to the bottom of the function. Within global layout, functions that usually execute close to each other are placed into the same page. Pettis and Hansen <ref> [7] </ref> of HP present a similar approach, which does procedure layout by the linker and basic block layout by the compiler optimizer. They also implement "procedure splitting" by collecting the non-executed parts of all procedures into a separate region, so that more procedures can be packed into the same page.
Reference: [8] <author> Barbara Simons. </author> <title> Code Positioning for Procedures and Basic Blocks. </title> <note> Technical Report ADTI-1994-006; also available as STL TR 03.580, </note> <institution> Application Development Technology Institute, </institution> <year> 1994. </year>
Reference-contexts: This idea in itself is not new. Global code restructuring techniques have been implemented by groups in IBM and elsewhere. A survey of these tools can be found in <ref> [8] </ref>. In particular, Heat-shrink [3] and AOPT are IBM code restructuring tools developed for AIX. These two tools are packaged together in the FDPR (Feedback Directed Program Restructuring) product, available on AIX 4.1.
Reference: [9] <author> Amitabh Srivastava and Alan Eustace. </author> <title> ATOM: </title>
Reference-contexts: They require the relocation information of objects available to OM, so that addresses can be distinguished from coincidental numerical constants. Furthermore, with the observation that many different instrumenting tools have a similar process, Srivat-sava and Eustace <ref> [9] </ref> present the ATOM system, built upon OM, that provides common infrastructure by extracting the tool-specific parts. ATOM is a tool=building system with which a diverse set of tools can be easily built.
References-found: 9

