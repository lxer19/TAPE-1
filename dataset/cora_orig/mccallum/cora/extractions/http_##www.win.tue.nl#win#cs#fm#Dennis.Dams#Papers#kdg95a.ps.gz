URL: http://www.win.tue.nl/win/cs/fm/Dennis.Dams/Papers/kdg95a.ps.gz
Refering-URL: http://www.win.tue.nl/cs/fm/Dennis.Dams/Papers/kdg95a-abs.html
Root-URL: http://www.win.tue.nl
Title: Practical Symbolic Model Checking of the full -calculus using Compositional Abstractions  
Author: Peter Kelb OFFIS Dennis Dams Rob Gerth 
Affiliation: Utrecht University  Eindhoven University of Technology  
Abstract: We apply abstract interpretation techniques to reduce the time and space requirements for model checking the full -calculus over parallel processes. The abstractions can be computed compositionally. The techniques have been implemented in a StateCharts model checker. Experiments show a 17-fold reduction on the average in the size of the BDDs on non-trivial specifications. 
Abstract-found: 1
Intro-found: 1
Reference: [LGS + 95] <author> C. Loiseaux, S. Graf, J. Sifakis, A. Bouajjani, and S. Bensalem. </author> <title> Property preserving abstractions for the verification of concurrent systems. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> Vol. 6, Iss. 1, </volume> <month> Januari </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Abstraction techniques <ref> [CGL94, LGS + 95, DGG94, CR94] </ref> offer one answer to the so-called state explosion problem that is inherent to verification by model checking. Such techniques allow aspects of a program that are irrelevant to the property being checked to be ignored, thus reducing the model representing the program's (relevant) behaviors.
Reference: [BCM + 92] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <journal> Information and Computation, </journal> <volume> 98(2) </volume> <pages> 142-171, </pages> <month> June </month> <year> 1992. </year> <note> Special Issue: Selections from 1990 IEEE Symposium on Logic in Computer Science. </note>
Reference-contexts: Such techniques allow aspects of a program that are irrelevant to the property being checked to be ignored, thus reducing the model representing the program's (relevant) behaviors. In symbolic model checking <ref> [BCM + 92] </ref>, both the state space of a program and its transition relation are encoded as boolean functions which are compactly represented by Binary Decision Diagrams (BDD's) [Bry92]. In this setting, abstractions should aim at the reduction of BDD's. <p> In practice, techniques such as iterative squaring are used to (exponentially) speed-up the fixed-point computations (see <ref> [BCM + 92] </ref>). 5 Programs Let S be the set of local states. A program P either has the form P 0 k P 00 , for programs P 0 and P 00 or is a labeled transition system (lts) (S; `; I) with S S.
Reference: [Bry86] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 35(8) </volume> <pages> 677-691, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: For closed 4 ', we have M; v j= ' just in case v 2 [[']]? where ? is the environment that maps every x 2 X to ;. 4 Binary decision diagrams Reduced Ordered Binary Decision Diagrams (BDD's) <ref> [Bry86, Bry92] </ref> are a way to economically represent boolean functions in a canonical way. Although for most boolean functions the size of their BDD representation is exponentially large, in many practical cases the BDDs are sufficiently small.
Reference: [Bry92] <author> Randal E. Bryant. </author> <title> Symbolic boolean manipulation with ordered binary-decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: In symbolic model checking [BCM + 92], both the state space of a program and its transition relation are encoded as boolean functions which are compactly represented by Binary Decision Diagrams (BDD's) <ref> [Bry92] </ref>. In this setting, abstractions should aim at the reduction of BDD's. It turns out that the blow-up of a BDD representing the behavior of a concurrent program usually results from the interdependency between individual processes rather than from the large total number of global states. <p> For closed 4 ', we have M; v j= ' just in case v 2 [[']]? where ? is the environment that maps every x 2 X to ;. 4 Binary decision diagrams Reduced Ordered Binary Decision Diagrams (BDD's) <ref> [Bry86, Bry92] </ref> are a way to economically represent boolean functions in a canonical way. Although for most boolean functions the size of their BDD representation is exponentially large, in many practical cases the BDDs are sufficiently small.
Reference: [CBM90] <author> O. Coudert, C. Berthet, and J. C. Madre. </author> <title> Verifying temporal properties of sequential machines without building their state diagrams. </title> <editor> In R. P. Kurshan and E. M. Clarke, editors, </editor> <booktitle> Proceedings of the 1990 Workshop on Computer-Aided Verification, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: strings. 4 A formula is closed if every variable occurring in it is bound by a fixed point operator. 5 We usually do not make a distinction between the boolean function R and its BDD representation. 4 4.1 Symbolic model checking Symbolic model checking is based on such BDD representations <ref> [CBM90] </ref>. The basic, nonlogical operation that needs to be done is computing preconditions, pre R (V ), which translates into computing relational products: 9~x 0 ( R (~x; ~x 0 ) ^ V (~x 0 )). Obviously, to represent a set as a BDD we use its characteristic predicate.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Proceedings 4th ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, California, </address> <year> 1977. </year>
Reference-contexts: Our optimized existential abstractions are essential for obtaining these results. Indeed, without them no useful existential abstractions could be defined. 2 Abstract Interpretation Many of the results and constructions below are most easily expressed using the language of Abstract Interpretation <ref> [CC77] </ref>; a general framework to define static analyses of programs. The basic tenet is that the operations of a programming language which operate on concrete values can be mimicked by corresponding abstract operations defined over abstract values that describe sets of concrete values.
Reference: [CGL94] <author> E. M. Clarke, O. Grumberg, and D. E. </author> <title> Long. Model checking and abstraction. </title> <journal> ACM TOPLAS, </journal> <volume> 16(5) </volume> <pages> 1512-1542, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Abstraction techniques <ref> [CGL94, LGS + 95, DGG94, CR94] </ref> offer one answer to the so-called state explosion problem that is inherent to verification by model checking. Such techniques allow aspects of a program that are irrelevant to the property being checked to be ignored, thus reducing the model representing the program's (relevant) behaviors.
Reference: [CR94] <author> R. Cleaveland and J. Riely. </author> <title> A testing-based abstractions for value-passing systems. </title> <editor> In B. Jonsson and J. Parrow, editors, CONCUR'94: </editor> <booktitle> Concurrency Theory, Lecture Notes in Computer Science 836, </booktitle> <pages> pages 417-432. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1994. </year> <month> 16 </month>
Reference-contexts: 1 Introduction Abstraction techniques <ref> [CGL94, LGS + 95, DGG94, CR94] </ref> offer one answer to the so-called state explosion problem that is inherent to verification by model checking. Such techniques allow aspects of a program that are irrelevant to the property being checked to be ignored, thus reducing the model representing the program's (relevant) behaviors.
Reference: [Dam94] <author> M. Dam. </author> <title> CTL fl and ECTL fl as fragments of the modal -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 126(1) </volume> <pages> 77-97, </pages> <year> 1994. </year>
Reference-contexts: of a property ' in which data and operations of the program are abstractly interpreted, yielding a description of any concrete evaluation of '. 3 -calculus and its interpretation The (propositional) -calculus generalizes a number of possibly better-known logics such as CTL, LTL and CTL fl , as shown in <ref> [Dam94] </ref>. For us, its main advantage is its computational nature. The basic modalities of the logic express properties of the successors of states and every constraint on the computations of a system must be explicitly coded in terms of extremal fixed points.
Reference: [DGG94] <author> D. Dams, O. Grumberg, and R. Gerth. </author> <title> Abstract interpretation of reactive systems: Abstractions preserving 8CTL fl , 9CTL fl and CTL fl . In E.-R. </title> <editor> Olderog, editor, </editor> <booktitle> Proceedings of the IFIP WG2.1/WG2.2/WG2.3 Working Conference on Programming Concepts, Methods and Calculi (PROCOMET), IFIP Transactions, </booktitle> <address> Amsterdam, </address> <month> June </month> <year> 1994. </year> <note> North-Holland/Elsevier. Full version available as Computing Science Note 95/16, </note> <institution> Eindhoven University of Technology, Dept. of Math. and Computing Science. </institution>
Reference-contexts: 1 Introduction Abstraction techniques <ref> [CGL94, LGS + 95, DGG94, CR94] </ref> offer one answer to the so-called state explosion problem that is inherent to verification by model checking. Such techniques allow aspects of a program that are irrelevant to the property being checked to be ignored, thus reducing the model representing the program's (relevant) behaviors.
Reference: [DHKS95] <author> W. Damm, H. Hungar, P. Kelb, and R. Schlor. </author> <title> Using graphical specification languages and symbolic model checking in the verification of a production cell. </title> <editor> In C. Lewerenz and T. Lindner, editors, </editor> <title> Formal Development of Reactive Systems: Case Study "Production Cell", </title> <booktitle> volume 891 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: However, we do have fs 0 ; t 0 g 2 ff pre 3 (fs 1 ; t 1 g) and by this fs 0 ; t 0 g 2 ff [[]] 4 ?. 7 Experimental results We applied the abstraction techniques developed above to verify a production cell <ref> [DHKS95] </ref>. The task of the production cell is to press metal blanks.
Reference: [Har87] <author> David Harel. StateCharts: </author> <title> A Visual Formalism for Complex Systems. </title> <booktitle> Science of Computer Programming 8, </booktitle> <year> 1987. </year>
Reference-contexts: This results in an optimized definition of the existential abstraction, obtained by combining the original existential abstraction together with the restricted universal abstraction. This method has been integrated in a symbolic model checker for the language of State-Charts <ref> [Har87] </ref>. Experimental results display a 17-fold reduction in space on the average for the verification of many non-trivial properties, including universal and existential properties, as well as properties that have both universal and existential aspects. <p> Figure 1 gives an example. The lts P on the right-hand-side is equivalent with [[P 0 k P 1 ]] (as will be defined below). Observe that parallel processes execute synchronously. Although such programs may look unfamiliar, they correspond to simplified Statechart models <ref> [Har87] </ref> in which no events are broadcast. Indeed, the test :(t 1 _t 2 ) in Figure 1 corresponds to the Statechart condition [not (IN (t 1) or IN (t 2))]. The verifier that we have imple mented deals with full Statecharts. <p> The crane closes the cycle and moves the blank from the deposit belt to the feed belt in order to press the blank again. We have modeled the production cell with StateCharts <ref> [Har87] </ref>. StateCharts is a graphical specification language. It is based on automata that can be composed in parallel and that form a hierarchy. The parallel composition leads to a (synchronous) lock-step semantics, where parallel components have to make a step if they can, otherwise they stutter.
Reference: [HK94] <author> J. Helbig and P. Kelb. </author> <title> An OBDD-Representation of StateCharts. </title> <booktitle> In Proceedings European Design Automation Conference (EDAC), </booktitle> <year> 1994. </year>
Reference-contexts: By this mechanism the parallel components will be synchronized. This fragment of Statecharts corresponds to the programs we introduced in this paper. A detailed description of the translation scheme for full StateCharts into BDDs can be found in <ref> [HK94] </ref>. Since the production cell contains several physical components which have to be controlled independently, the general structure of the StateChart specification is a parallel decomposition of the controller w.r.t. the physical components.
Reference: [Koz83] <author> D. Kozen. </author> <title> Results on the propositional -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 27 </volume> <pages> 333-354, </pages> <year> 1983. </year>
Reference-contexts: In this paper, we present an abstraction method which abstracts from such interdependencies in designated parts of processes as indicated by a user. We provide both universal and existential abstractions, suitable for verifying universal and existential properties expressed in the full -calculus <ref> [Koz83] </ref>. Combination of both types allows for verification of arbitrary -calculus properties. The method is fully compositional: the abstraction of a concurrent program is computed from user-specified abstractions of its individual components.
Reference: [Tar55] <author> A. Tarski. </author> <title> A Lattice-Theoretical Fixpoint Theorem and its Applications. </title> <journal> In Pacific Journal of Mathematics 5, </journal> <pages> pages 285-309, </pages> <year> 1955. </year> <month> 17 </month>
References-found: 15

