URL: http://www.csl.sri.com/reports/postscript/reconfig.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Email: Rushby@csl.sri.com  
Phone: Phone: +1 (415) 859-5456 Fax: +1 (415) 859-2844  
Title: Reconfiguration and Transient Recovery in State-Machine Architectures Submitted for publication  
Author: John Rushby 
Keyword: Reconfiguration, transient recovery, state-machine replication, Byzantine faults  
Note: This work was partially supported by NASA Langley Research Center under Contract NAS1 18969  
Address: Menlo Park CA 94025 USA  
Affiliation: Computer Science Laboratory SRI International  
Abstract: We consider an architecture for ultra-dependable operation based on synchronized state machine replication, extended to provide transient recovery and reconfiguration in the presence of Byzantine faults. The architecture allows processors suspected of being faulty to be placed on "probation." Processors in this status cannot disrupt other processors, but those that are nonfaulty or recovering from transient faults are able to remain synchronized with the other processors and with each other, can participate in interactively consistent exchange of data (i.e., Byzantine Agreement), and can restore damaged state data by loading majority-voted copies from other processors. The processors that are not on probation are able to coordinate membership of their group and to take processors on and off probation. These properties are achieved even if all the processors on probation and some of the others exhibit Byzantine faults. Key elements of the architecture are modified treatments for the problems of interactive consistency, clock synchronization, and group membership. Classical algorithms for these problems that tolerate t Byzantine faults among n processors are extended to tolerate t + p faults among n + p processors, partitioned into n "core members" and p "probationers," provided no more then t faults occur among the core members. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Richard W. Buskens and Ronald P. Bianchini, Jr. </author> <title> Distributed on-line diagnosis in the presence of arbitrary faults. </title> <booktitle> In Fault Tolerant Computing Symposium 23 [11], </booktitle> <pages> pages 470-479. </pages>
Reference-contexts: Several authors develop several sophisticated diagnosis algorithms of this type <ref> [1, 25, 26] </ref>; the accuracy of some of these has been formally verified by Lincoln [16]. This approach can be inaccurate in the presence of transient faults, however.
Reference: [2] <author> Flaviu Cristian. </author> <title> Agreeing who is present and who is absent in a synchronous distributed system. </title> <booktitle> In Fault Tolerant Computing Symposium 18, </booktitle> <pages> pages 206-211, </pages> <address> Tokyo, Japan, June 1988. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: This is an instance of the group membership problem for synchronous systems first introduced by Cristian <ref> [2] </ref>. The present instance is simpler than the general problem because all nonfaulty channels are performing the same computations in lockstep. Thus, all that is necessary is for each processor to run an identical, deterministic, selection algorithm on the interactively consistent syndrome information that was distributed in the diagnosis phase.
Reference: [3] <author> Judith Crow and John Rushby. </author> <title> Model-based reconfiguration: Toward an integration with diagnosis. </title> <booktitle> In Proceedings, </booktitle> <volume> AAAI-91 (Volume 2), </volume> <pages> pages 836-841, </pages> <address> Anaheim, CA, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Lincoln describes a diagnosis algorithm called UD that favors completeness over accuracy [16]. In general, however, it seems that diagnosis algorithms should consider the use to be made of their results, rather than strive for abstract accuracy or completeness <ref> [3] </ref>.
Reference: [4] <author> Ben L. Di Vito and Ricky W. Butler. </author> <title> Formal techniques for synchronized fault-tolerant systems. </title> <editor> In C. E. Landwehr, B. Randell, and L. Simoncini, editors, </editor> <title> Dependable Computing for Critical Applications|3, </title> <booktitle> volume 8 of Dependable Computing and Fault-Tolerant Systems, </booktitle> <pages> pages 163-188. </pages> <publisher> Springer-Verlag, </publisher> <address> Vienna, Austria, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: Provide that enough channels remain nonfaulty at all times, this approach provides self-stabilizing recovery from transient faults in the main computational tasks <ref> [4, 19] </ref>. 2.3 Residual Weaknesses State machine replication, augmented to provide transient recovery in the manner just described, is an attractively simple architecture that provides robust fault tolerance against transient Byzantine faults that arrive sequentially. However, practical 5 Clock synchronization generally requires the local clock adjustment plus the frame counter.
Reference: [5] <author> D. Dolev and H. R. </author> <title> Strong. Authenticated algorithms for Byzantine agreement. </title> <journal> SIAM Journal on Computing, </journal> <volume> 12(4) </volume> <pages> 656-666, </pages> <month> November </month> <year> 1983. </year>
Reference-contexts: An important parameter to all algorithms for interactive consistency is the number of rounds of information exchange that they perform; no r-round algorithm can withstand more than r simultaneous Byzan-tine faults <ref> [5, 8] </ref>.
Reference: [6] <author> Carl S. Droste and James E. Walker. </author> <title> The General Dynamics Case Study on the F16 Fly-by-Wire Flight Control System. AIAA Professional Study Series. </title> <institution> American Institute of Aeronautics and Astronautics. Undated. </institution>
Reference-contexts: its own voter, and the voted values from each channel are then further voted or averaged at the actuators through some form of "force-summing." For example, the outputs of different channels may energize separate coils of a single solenoid, or multiple hydraulic pistons may be linked to a single shaft <ref> [6, Figure 3.2-2] </ref>. There are three key elements to this architecture. 1. Clock synchronization ensures that all nonfaulty channels can coordinate their actions and communications using a common notion of time. Synchronization between nonfaulty channels must be achieved in the presence of disruption caused by faulty channels.
Reference: [7] <author> Klaus Echtle. </author> <title> Fault masking with reduced redundant communication. </title> <booktitle> In Fault Tolerant Computing Symposium 16, </booktitle> <pages> pages 178-183, </pages> <address> Vienna, Austria, </address> <month> July </month> <year> 1986. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: The extra rounds for the distribution to the probationers algorithm can be eliminated in when the basic algorithm is OM (1) using the optimization of Section 4.2.1.3. Further optimizations may be possible using techniques such as those of Echtle <ref> [7] </ref>. 4.2.2 Other Interactive Consistency Algorithms Interactive consistency algorithms derived from OM, such as OMH for the hybrid fault model [17], and ZA for the authenticated case [9], can be extended in exactly the same way as OM, since they are also based on majority voting (albeit in modified form).
Reference: [8] <author> M. Fischer and N. Lynch. </author> <title> A lower bound for the time to assure interactive consistency. </title> <journal> Information Processing Letters, </journal> <volume> 14 </volume> <pages> 183-186, </pages> <year> 1982. </year>
Reference-contexts: An important parameter to all algorithms for interactive consistency is the number of rounds of information exchange that they perform; no r-round algorithm can withstand more than r simultaneous Byzan-tine faults <ref> [5, 8] </ref>. <p> These approaches (which can be used in combination [9]) increase the total number of faults that can be tolerated in clock synchronization and interactive consistency, but Byzantine faults can never exceed one third of the components in clock synchronization, nor the number of rounds in interactive consistency <ref> [8, 10] </ref>. 2.2 Transient Recovery As noted, transient faults are many times more common than permanent faults.
Reference: [9] <author> Li Gong, Patrick Lincoln, and John Rushby. </author> <title> Byzantine agreement with authentication: Observations and applications in tolerating hybrid and link faults. </title> <booktitle> In Dependable Computing for Critical Applications|5, </booktitle> <pages> pages 79-90, </pages> <address> Champaign, IL, </address> <month> September </month> <year> 1995. </year> <note> IFIP WG 10.4, preliminary proceedings. </note>
Reference-contexts: These approaches (which can be used in combination <ref> [9] </ref>) increase the total number of faults that can be tolerated in clock synchronization and interactive consistency, but Byzantine faults can never exceed one third of the components in clock synchronization, nor the number of rounds in interactive consistency [8, 10]. 2.2 Transient Recovery As noted, transient faults are many times <p> However, practical 5 Clock synchronization generally requires the local clock adjustment plus the frame counter. Oral Message algorithms for interactive consistency require nothing; authenticated algorithms can require a significant quantity of data to maintain crypto-synch and to foil spoofing attacks <ref> [9] </ref>, which militates against their use in combination with transient recovery. 6 concerns limit the level of redundancy and the number of rounds that can be provided, so the architecture is vulnerable to the arrival of multiple faults in close proximity. <p> Further optimizations may be possible using techniques such as those of Echtle [7]. 4.2.2 Other Interactive Consistency Algorithms Interactive consistency algorithms derived from OM, such as OMH for the hybrid fault model [17], and ZA for the authenticated case <ref> [9] </ref>, can be extended in exactly the same way as OM, since they are also based on majority voting (albeit in modified form).
Reference: [10] <author> J. Y. Halpern, B. B. Simons, H. R. Strong, and D. Dolev. </author> <title> Fault-tolerant clock synchronization. </title> <booktitle> In Third ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 89-102, </pages> <address> Vancouver, B.C., Canada, </address> <month> August </month> <year> 1984. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: Synchronization between nonfaulty channels must be achieved in the presence of disruption caused by faulty channels. The number of faulty channels that can be tolerated depends on the algorithm, assumptions, and fault model employed, but under the weakest assumptions it is fewer than one-third <ref> [10, 14] </ref>. 2. Interactive Consistency ensures that all nonfaulty channels start their computations with identical sets of sensor readings. <p> These approaches (which can be used in combination [9]) increase the total number of faults that can be tolerated in clock synchronization and interactive consistency, but Byzantine faults can never exceed one third of the components in clock synchronization, nor the number of rounds in interactive consistency <ref> [8, 10] </ref>. 2.2 Transient Recovery As noted, transient faults are many times more common than permanent faults.
Reference: [11] <institution> Fault Tolerant Computing Symposium 23, Toulouse, </institution> <address> France, June 1993. </address> <publisher> IEEE Computer Society. </publisher>
Reference: [12] <author> R. M. Kieckhafer, C. J. Walter, A. M. Finn, and P. M. Thambidurai. </author> <title> The MAFT architecture for distributed fault tolerance. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(4) </volume> <pages> 398-405, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: The other algorithms required are outlined in Section 5 and conclusions presented in Section 6. 2 State Machine Replication with Transient Recovery Our focus is the approach to fault-tolerant computing first implemented in SIFT [27] and subsequently refined by MAFT <ref> [12] </ref> and several other projects (e.g., [13]). This has become known as the state machine approach to fault-tolerant computing [21]. 2 A frame-synchronous architecture based on state-machine replication operates as follows.
Reference: [13] <author> Jaynarayan H. Lala and Richard E. Harper. </author> <title> Architectural principles for safety-critical real-time applications. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 82(1) </volume> <pages> 25-40, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: The other algorithms required are outlined in Section 5 and conclusions presented in Section 6. 2 State Machine Replication with Transient Recovery Our focus is the approach to fault-tolerant computing first implemented in SIFT [27] and subsequently refined by MAFT [12] and several other projects (e.g., <ref> [13] </ref>). This has become known as the state machine approach to fault-tolerant computing [21]. 2 A frame-synchronous architecture based on state-machine replication operates as follows.
Reference: [14] <author> L. Lamport and P. M. Melliar-Smith. </author> <title> Synchronizing clocks in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 32(1) </volume> <pages> 52-78, </pages> <month> January </month> <year> 1985. </year> <month> 19 </month>
Reference-contexts: Synchronization between nonfaulty channels must be achieved in the presence of disruption caused by faulty channels. The number of faulty channels that can be tolerated depends on the algorithm, assumptions, and fault model employed, but under the weakest assumptions it is fewer than one-third <ref> [10, 14] </ref>. 2. Interactive Consistency ensures that all nonfaulty channels start their computations with identical sets of sensor readings. <p> The idea is that the core members synchronize among themselves using an algorithm such as interactive convergence <ref> [14] </ref>, ignoring inputs from probationers (in the case of interactive convergence, this essentially means treating their clock differences as if they are zero).
Reference: [15] <author> Leslie Lamport, Robert Shostak, and Marshall Pease. </author> <title> The Byzantine Generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Interactive Consistency is the symmetric version of Byzantine Agreement : in the latter problem, there is a distinguished processor called the transmitter (it is called the "Commanding General" in the metaphor of the Byzantine Generals <ref> [15] </ref>) and the goal is to distribute its private value to all the other processors (which are called receivers) in a manner that ensures Agreement and Validity. <p> The r-round algorithm OM (r) can solve the problem under these assumptions, provided r t and n &gt; 3r <ref> [15] </ref>. The algorithm is described recursively; the base case is OM (0). OM (0) 1. The transmitter sends its value to every receiver. 2. Each receiver uses the value obtained from the transmitter, or some arbitrary, but fixed, value if nothing is received. Next, we describe the general case. <p> It is not clear whether algorithms such as the classical Signed Messages algorithm SM <ref> [15] </ref> that do not use majority voting can be extended in a similar manner. 4.3 Summary Interactive consistency algorithms that use majority voting, such as OM, can be extended to tolerate an arbitrary number of faults, provided there no more than t faults among those components identified as the core, where
Reference: [16] <author> Patrick Lincoln. </author> <title> Formally verified algorithms for diagnosis of manifest, symmetric, link, and byzantine faults. </title> <type> Technical Report SRI-CSL-95-14, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Several authors develop several sophisticated diagnosis algorithms of this type [1, 25, 26]; the accuracy of some of these has been formally verified by Lincoln <ref> [16] </ref>. This approach can be inaccurate in the presence of transient faults, however. For example, in the scenario just given, a and b may be transiently faulty in the (different) frames when they accuse x of sending an incorrect value. <p> Lincoln describes a diagnosis algorithm called UD that favors completeness over accuracy <ref> [16] </ref>. In general, however, it seems that diagnosis algorithms should consider the use to be made of their results, rather than strive for abstract accuracy or completeness [3].
Reference: [17] <author> Patrick Lincoln and John Rushby. </author> <title> A formally verified algorithm for interactive consistency under a hybrid fault model. </title> <booktitle> In Fault Tolerant Computing Symposium 23 [11], </booktitle> <pages> pages 402-411. </pages>
Reference-contexts: It is possible to tolerate more faulty components in clock synchronization and interactive consistency if some of the faults are "not too bad." Hybrid fault models and their associated algorithms consider both Byzantine and less serious kinds of faults occurring in combination <ref> [17, 20, 23] </ref>; authenticated algorithms use digital signatures to constrain the behavior of faulty components [5,15]. <p> Further optimizations may be possible using techniques such as those of Echtle [7]. 4.2.2 Other Interactive Consistency Algorithms Interactive consistency algorithms derived from OM, such as OMH for the hybrid fault model <ref> [17] </ref>, and ZA for the authenticated case [9], can be extended in exactly the same way as OM, since they are also based on majority voting (albeit in modified form). <p> we are better off placing it on probation, because we will otherwise be vulnerable to failure if a second fault arrives (for example, a one-round hybrid fault tolerant interactive consistency algorithm can withstand two simultaneous faults among five processors only if both faults are of the essentially trivial "manifest" kind <ref> [17] </ref>). Diagnosis based on comparison of output values does not distinguish errors due to a faulty processor from those due to bad state data.
Reference: [18] <author> M. Pease, R. Shostak, and L. Lamport. </author> <title> Reaching agreement in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 27(2) </volume> <pages> 228-234, </pages> <month> April </month> <year> 1980. </year>
Reference-contexts: We then describe the extended problem and modified algorithms. 4.1 Classical Interactive Consistency In the classical problem of Interactive Consistency <ref> [18] </ref>, there are n processors, of which some number t may be faulty.
Reference: [19] <author> John Rushby. </author> <title> A fault-masking and transient-recovery model for digital flight-control systems. </title> <editor> In Jan Vytopil, editor, </editor> <booktitle> Formal Techniques in Real-Time and Fault-Tolerant Systems, Kluwer International Series in Engineering and Computer Science, chapter 5, </booktitle> <pages> pages 109-136. </pages> <publisher> Kluwer, </publisher> <address> Boston, Dordecht, London, </address> <year> 1993. </year> <note> An earlier version appeared in [24, pp. 237-257]. </note>
Reference-contexts: Provide that enough channels remain nonfaulty at all times, this approach provides self-stabilizing recovery from transient faults in the main computational tasks <ref> [4, 19] </ref>. 2.3 Residual Weaknesses State machine replication, augmented to provide transient recovery in the manner just described, is an attractively simple architecture that provides robust fault tolerance against transient Byzantine faults that arrive sequentially. However, practical 5 Clock synchronization generally requires the local clock adjustment plus the frame counter.
Reference: [20] <author> John Rushby. </author> <title> A formally verified algorithm for clock synchronization under a hybrid fault model. </title> <booktitle> In Thirteenth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 304-313, </pages> <address> Los Angeles, CA, </address> <month> August </month> <year> 1994. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: It is possible to tolerate more faulty components in clock synchronization and interactive consistency if some of the faults are "not too bad." Hybrid fault models and their associated algorithms consider both Byzantine and less serious kinds of faults occurring in combination <ref> [17, 20, 23] </ref>; authenticated algorithms use digital signatures to constrain the behavior of faulty components [5,15].
Reference: [21] <author> Fred B. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 299-319, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: This has become known as the state machine approach to fault-tolerant computing <ref> [21] </ref>. 2 A frame-synchronous architecture based on state-machine replication operates as follows. There are n replicated major components, generally called channels, that are electrically and physically isolated from each other so that their failures will, to the extent possible, be independent. <p> Each channel has a processor, some memory, and access to sensors and actuators. The channels execute the same software and are synchronized so that they perform actions at approximately the same time. At 2 Schneider's tutorial <ref> [21] </ref> describes the approach in its client-server form.
Reference: [22] <author> Kang C. Shin and P. Ramanathan. </author> <title> Diagnosis of processors with Byzantine faults in a distributed computing system. </title> <booktitle> In Fault Tolerant Computing Symposium 17, </booktitle> <pages> pages 55-60, </pages> <address> Pittsburgh, PA, </address> <month> July </month> <year> 1987. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: Unfortunately, it is provably impossible to achieve both accurate (no nonfaulty components are identified as faulty) and complete (all faulty components are identified) diagnosis in the presence of Byzantine faults <ref> [22] </ref>. Experience shows that transient faults are far more common than permanent ones. A transiently faulty component is one that malfunctions for a while and then spontaneously recovers. <p> However, this method of diagnosis is not complete: not all faulty channels will be identified. It is impossible to achieve both accurate and complete diagnosis in the presence of Byzantine faults <ref> [22] </ref>.
Reference: [23] <author> Philip Thambidurai and You-Keun Park. </author> <title> Interactive consistency with multiple failure modes. </title> <booktitle> In 7th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 93-100, </pages> <address> Columbus, OH, </address> <month> October </month> <year> 1988. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: It is possible to tolerate more faulty components in clock synchronization and interactive consistency if some of the faults are "not too bad." Hybrid fault models and their associated algorithms consider both Byzantine and less serious kinds of faults occurring in combination <ref> [17, 20, 23] </ref>; authenticated algorithms use digital signatures to constrain the behavior of faulty components [5,15].
Reference: [24] <editor> J. Vytopil, editor. </editor> <booktitle> Formal Techniques in Real-Time and Fault-Tolerant Systems, volume 571 of Lecture Notes in Computer Science, </booktitle> <address> Nijmegen, The Netherlands, </address> <month> January </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference: [25] <author> C. J. Walter, N. Suri, and M. M. Hugue. </author> <title> Continual on-line diagnosis of hybrid faults. </title> <editor> In F. Cristian, G. Le Lann, and T. Lunt, editors, </editor> <title> Dependable Computing for Critical Applications|4, </title> <booktitle> volume 9 of Dependable Computing and Fault-Tolerant Systems, </booktitle> <pages> pages 233-249. </pages> <publisher> Springer-Verlag, </publisher> <address> Vienna, Austria, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Several authors develop several sophisticated diagnosis algorithms of this type <ref> [1, 25, 26] </ref>; the accuracy of some of these has been formally verified by Lincoln [16]. This approach can be inaccurate in the presence of transient faults, however.
Reference: [26] <author> Chris J. Walter. </author> <title> Identifying the cause of detected errors. </title> <booktitle> In Fault Tolerant Computing Symposium 20, </booktitle> <pages> pages 48-55, </pages> <institution> Newcastle upon Tyne, </institution> <address> UK, June 1990. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: Several authors develop several sophisticated diagnosis algorithms of this type <ref> [1, 25, 26] </ref>; the accuracy of some of these has been formally verified by Lincoln [16]. This approach can be inaccurate in the presence of transient faults, however.
Reference: [27] <author> John H. Wensley, Leslie Lamport, Jack Goldberg, Milton W. Green, Karl N. Levitt, P. M. Melliar-Smith, Robert E. Shostak, and Charles B. Weinstock. SIFT: </author> <title> Design and analysis of a fault-tolerant computer for aircraft control. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 66(10) </volume> <pages> 1240-1255, </pages> <month> October </month> <year> 1978. </year> <month> 20 </month>
Reference-contexts: The other algorithms required are outlined in Section 5 and conclusions presented in Section 6. 2 State Machine Replication with Transient Recovery Our focus is the approach to fault-tolerant computing first implemented in SIFT <ref> [27] </ref> and subsequently refined by MAFT [12] and several other projects (e.g., [13]). This has become known as the state machine approach to fault-tolerant computing [21]. 2 A frame-synchronous architecture based on state-machine replication operates as follows. <p> Therefore exact-match majority voting will mask the outputs of faulty channels, provided that fewer than half the channels are faulty <ref> [27] </ref>. 2.1 Multiple-Fault Tolerance Notice the different number of faulty components tolerated by the different elements of this architecture: fewer than a third for clock synchronization and interactive consistency, and fewer than a half for the computational tasks.
References-found: 27

