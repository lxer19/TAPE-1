URL: ftp://ftp.cs.washington.edu/tr/1992/11/UW-CSE-92-11-01.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: Timing Analysis of Concurrent Systems An Algorithm for Determining Time Separation of Events  
Author: Tod Amon, Henrik Hulgaard, Gaetano Borriello, Steve Burns 
Address: Seattle, WA 98195 USA  
Affiliation: Department of Computer Science and Engineering, FR-35 University of Washington  
Abstract: A fundamental problem in the synthesis and optimization of concurrent systems is the determination of the separation time between system events. We present a theoretical framework for solving this problem for arbitrary process graphs without conditional behavior and develop an efficient and exact algorithm based on this theoretical foundation. Examples are used to demonstrate the operation and generality of the algorithm. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: Many process graphs that are not well-formed can be easily analyzed; these restrictions simplify the presentation of our solution. We thus restrict our analysis to well-formed graphs in the remainder of this paper. 3 <ref> [1; 1] </ref> [1; 1] fha; a; [4; 10]; 1i; ha; b; [1; 1]; 0i; hb; a; [1; 1]; 1i; hb; b; [5; 20]; 1ig 2.2 Execution Model An execution of a timed event-rule system is the consistent assignment of time values to each occurrence of the events in E 0 . <p> Many process graphs that are not well-formed can be easily analyzed; these restrictions simplify the presentation of our solution. We thus restrict our analysis to well-formed graphs in the remainder of this paper. 3 <ref> [1; 1] </ref> [1; 1] fha; a; [4; 10]; 1i; ha; b; [1; 1]; 0i; hb; a; [1; 1]; 1i; hb; b; [5; 20]; 1ig 2.2 Execution Model An execution of a timed event-rule system is the consistent assignment of time values to each occurrence of the events in E 0 . <p> Many process graphs that are not well-formed can be easily analyzed; these restrictions simplify the presentation of our solution. We thus restrict our analysis to well-formed graphs in the remainder of this paper. 3 <ref> [1; 1] </ref> [1; 1] fha; a; [4; 10]; 1i; ha; b; [1; 1]; 0i; hb; a; [1; 1]; 1i; hb; b; [5; 20]; 1ig 2.2 Execution Model An execution of a timed event-rule system is the consistent assignment of time values to each occurrence of the events in E 0 . <p> We thus restrict our analysis to well-formed graphs in the remainder of this paper. 3 <ref> [1; 1] </ref> [1; 1] fha; a; [4; 10]; 1i; ha; b; [1; 1]; 0i; hb; a; [1; 1]; 1i; hb; b; [5; 20]; 1ig 2.2 Execution Model An execution of a timed event-rule system is the consistent assignment of time values to each occurrence of the events in E 0 . <p> It is thus the relative difference between these minimum weight paths that needs to be identical. We can illustrate this decomposition in Figure 3. By using the cutsets X = fa 0 ; c 0 g, <ref> [1; 2] </ref> c 0 a 0 a 1 b 1 b 2 a 2 a 3 root 2 1 0 V 3 2 1 0 a c t = a, s = c, ff = 3, and fi = 0. <p> and d 2 &gt; d 1 then m (a fffin ) = min (d 1 n; d 2 (n 1) 2) for all ff fi n 1 and the m (v k ) values will repeat when the second term of the minimization finally becomes smaller than the first term. <ref> [1; 1] </ref> [1; 1] b 96 b 97 b 98 b 99 0481217 a 95 21 graph labeled with m (v k ) values (s fffi = a 100 and d 1 = 4 and d 2 = 5). <p> 2 &gt; d 1 then m (a fffin ) = min (d 1 n; d 2 (n 1) 2) for all ff fi n 1 and the m (v k ) values will repeat when the second term of the minimization finally becomes smaller than the first term. <ref> [1; 1] </ref> [1; 1] b 96 b 97 b 98 b 99 0481217 a 95 21 graph labeled with m (v k ) values (s fffi = a 100 and d 1 = 4 and d 2 = 5). <p> uses set union for scalar addition. 12 3.9 Matrix Closure In order to effectively compute (19) we will use the matrix closure of S, that is, the countably infinite union: S fl = I [ S [ S 2 [ S 3 [ : : : (20) The Floyd-Warshall algorithm <ref> [1] </ref> can be used to compute S fl because, in this context, set union and function composition form a closed semi-ring. <p> If the pipelines were not coupled at c the maximum separation between a and e would be unbounded. This is because the first pipeline (with a choosing delay 2) could be arbitrarily 14 b a <ref> [1; 2] </ref> c all other delays are [0; 0] [1; 2] slower than the second pipeline (with e choosing delay 1). The coupling of the pipelines forces one pipeline to wait for the other if it gets too far ahead. <p> If the pipelines were not coupled at c the maximum separation between a and e would be unbounded. This is because the first pipeline (with a choosing delay 2) could be arbitrarily 14 b a <ref> [1; 2] </ref> c all other delays are [0; 0] [1; 2] slower than the second pipeline (with e choosing delay 1). The coupling of the pipelines forces one pipeline to wait for the other if it gets too far ahead. <p> Adding more stages to both pipelines (before the synchronization) would allow e to get even further ahead of a. b a [3; 3] all other delays are <ref> [1; 1] </ref> Our next example (see Figure 6) exhibits interesting behavior. We again root all of the initial occurrences at 0. <p> ff 1 2 3 4 odd even 4 8 4 8 4 8 If we change d 1 = D 1 = 8 then t (a ff ) t (a ff1 ) ff 1 2 3 4 5 6 7 8 9 b a d e [10; 10] [10; 10] <ref> [1; 3] </ref> [1; 3] Our third example corresponds to two simple processes that are forced to synchronize at the event c (see Figure 7). This example demonstrates how the initial startup rules can affect our result. <p> 2 3 4 odd even 4 8 4 8 4 8 If we change d 1 = D 1 = 8 then t (a ff ) t (a ff1 ) ff 1 2 3 4 5 6 7 8 9 b a d e [10; 10] [10; 10] <ref> [1; 3] </ref> [1; 3] Our third example corresponds to two simple processes that are forced to synchronize at the event c (see Figure 7). This example demonstrates how the initial startup rules can affect our result. <p> ) ff 2 3 4 5 6 7 8 9 10 11 12 13 14 This example is of interest because we need to use the matrix closure of S to calculate | k ? = 7, and choosing ff smaller than k ? will not yield the solution. 16 <ref> [1; 1] </ref> [1; 9] [1; 5] [1; 1] [1; 1] g d e f The cutsets X = fa 0 ; b 0 ; c 0 ; d 0 ; e 0 ; f 0 ; g 0 g and Y = fa 1 ; b 1 ; c 1 ; <p> 2 3 4 5 6 7 8 9 10 11 12 13 14 This example is of interest because we need to use the matrix closure of S to calculate | k ? = 7, and choosing ff smaller than k ? will not yield the solution. 16 [1; 1] <ref> [1; 9] </ref> [1; 5] [1; 1] [1; 1] g d e f The cutsets X = fa 0 ; b 0 ; c 0 ; d 0 ; e 0 ; f 0 ; g 0 g and Y = fa 1 ; b 1 ; c 1 ; d 1 <p> 4 5 6 7 8 9 10 11 12 13 14 This example is of interest because we need to use the matrix closure of S to calculate | k ? = 7, and choosing ff smaller than k ? will not yield the solution. 16 [1; 1] [1; 9] <ref> [1; 5] </ref> [1; 1] [1; 1] g d e f The cutsets X = fa 0 ; b 0 ; c 0 ; d 0 ; e 0 ; f 0 ; g 0 g and Y = fa 1 ; b 1 ; c 1 ; d 1 ; e <p> 6 7 8 9 10 11 12 13 14 This example is of interest because we need to use the matrix closure of S to calculate | k ? = 7, and choosing ff smaller than k ? will not yield the solution. 16 <ref> [1; 1] </ref> [1; 9] [1; 5] [1; 1] [1; 1] g d e f The cutsets X = fa 0 ; b 0 ; c 0 ; d 0 ; e 0 ; f 0 ; g 0 g and Y = fa 1 ; b 1 ; c 1 ; d 1 ; e 1 ; <p> 8 9 10 11 12 13 14 This example is of interest because we need to use the matrix closure of S to calculate | k ? = 7, and choosing ff smaller than k ? will not yield the solution. 16 <ref> [1; 1] </ref> [1; 9] [1; 5] [1; 1] [1; 1] g d e f The cutsets X = fa 0 ; b 0 ; c 0 ; d 0 ; e 0 ; f 0 ; g 0 g and Y = fa 1 ; b 1 ; c 1 ; d 1 ; e 1 ; f 1
Reference: [2] <author> T. Amon and G. Borriello. </author> <title> Sizing synchronization queues: A case study in higher level synthesis. </title> <booktitle> In 28th ACM/IEEE Design Automation Conference, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: This will be especially useful when the implementation may include hardware and software components. At a higher level, the separation in time of communication actions between interacting machines can be used to size the data buffers or queues between them <ref> [2] </ref>. The ability to change circuit delays and re-evaluate the queue size permits synthesis tools to balance processes and thereby bound the queue size to a desired value or eliminate it and its associated buffering and handshaking overhead. <p> It is thus the relative difference between these minimum weight paths that needs to be identical. We can illustrate this decomposition in Figure 3. By using the cutsets X = fa 0 ; c 0 g, <ref> [1; 2] </ref> c 0 a 0 a 1 b 1 b 2 a 2 a 3 root 2 1 0 V 3 2 1 0 a c t = a, s = c, ff = 3, and fi = 0. <p> If the pipelines were not coupled at c the maximum separation between a and e would be unbounded. This is because the first pipeline (with a choosing delay 2) could be arbitrarily 14 b a <ref> [1; 2] </ref> c all other delays are [0; 0] [1; 2] slower than the second pipeline (with e choosing delay 1). The coupling of the pipelines forces one pipeline to wait for the other if it gets too far ahead. <p> If the pipelines were not coupled at c the maximum separation between a and e would be unbounded. This is because the first pipeline (with a choosing delay 2) could be arbitrarily 14 b a <ref> [1; 2] </ref> c all other delays are [0; 0] [1; 2] slower than the second pipeline (with e choosing delay 1). The coupling of the pipelines forces one pipeline to wait for the other if it gets too far ahead.
Reference: [3] <author> T. Amon and G. Borriello. </author> <title> An approach to symbolic timing verification. </title> <booktitle> In 29th ACM/IEEE Design Automation Conference, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: The verification problem is then to determine the separation in time of constrained events and ensure that they fall within the specified bounds. Amon/Borriello <ref> [3] </ref> have taken a different approach where the delays are manipulated symbolically leading to a set of inequalities that must hold true for any valid implementation. In all these cases, however, the process graph topology is restricted. [7] and [9] can only handle acyclic graphs while [3] only supports a limited <p> Amon/Borriello <ref> [3] </ref> have taken a different approach where the delays are manipulated symbolically leading to a set of inequalities that must hold true for any valid implementation. In all these cases, however, the process graph topology is restricted. [7] and [9] can only handle acyclic graphs while [3] only supports a limited form of inter-process communication. In the area of data-path synthesis there is a large body of work in allocation and scheduling that considers minimizing hardware by multiplexing. To accomplish this, scheduling constraints must be generated from the timing constraint specifications. <p> Adding more stages to both pipelines (before the synchronization) would allow e to get even further ahead of a. b a <ref> [3; 3] </ref> all other delays are [1; 1] Our next example (see Figure 6) exhibits interesting behavior. We again root all of the initial occurrences at 0. <p> ff 1 2 3 4 odd even 4 8 4 8 4 8 If we change d 1 = D 1 = 8 then t (a ff ) t (a ff1 ) ff 1 2 3 4 5 6 7 8 9 b a d e [10; 10] [10; 10] <ref> [1; 3] </ref> [1; 3] Our third example corresponds to two simple processes that are forced to synchronize at the event c (see Figure 7). This example demonstrates how the initial startup rules can affect our result. <p> 2 3 4 odd even 4 8 4 8 4 8 If we change d 1 = D 1 = 8 then t (a ff ) t (a ff1 ) ff 1 2 3 4 5 6 7 8 9 b a d e [10; 10] [10; 10] <ref> [1; 3] </ref> [1; 3] Our third example corresponds to two simple processes that are forced to synchronize at the event c (see Figure 7). This example demonstrates how the initial startup rules can affect our result.
Reference: [4] <author> Steven M. Burns. </author> <title> Performance Analysis and Optimization of Asynchronous Circuits. </title> <type> Ph.D. thesis, </type> <institution> California Institute of Technology, </institution> <year> 1991. </year> <month> CS-TR-91-1. </month>
Reference-contexts: Finally, section 5 summarizes the contributions of this paper. 2 Problem Formalization 2.1 A Finite Event-Rule System To formalize the problem we choose a simple modification of the event-rule system developed in <ref> [4] </ref>. ([8] introduced a similarly modified system. <p> Many process graphs that are not well-formed can be easily analyzed; these restrictions simplify the presentation of our solution. We thus restrict our analysis to well-formed graphs in the remainder of this paper. 3 [1; 1] [1; 1] fha; a; <ref> [4; 10] </ref>; 1i; ha; b; [1; 1]; 0i; hb; a; [1; 1]; 1i; hb; b; [5; 20]; 1ig 2.2 Execution Model An execution of a timed event-rule system is the consistent assignment of time values to each occurrence of the events in E 0 .
Reference: [5] <author> Ku D. C and G. De Micheli. </author> <title> Relative scheduling under timing constraints: Algorithms for high-level synthesis of digital circuits. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <month> May </month> <year> 1991. </year>
Reference-contexts: In the area of data-path synthesis there is a large body of work in allocation and scheduling that considers minimizing hardware by multiplexing. To accomplish this, scheduling constraints must be generated from the timing constraint specifications. The work of Ku/De Micheli <ref> [5] </ref> is an example of this but is limited to extracting the possible slack between data-flow events in a single process. Obtaining constraints from interactions between 2 processes enables more optimization of the respective data-paths and supports a modular style of specification. <p> We thus restrict our analysis to well-formed graphs in the remainder of this paper. 3 [1; 1] [1; 1] fha; a; [4; 10]; 1i; ha; b; [1; 1]; 0i; hb; a; [1; 1]; 1i; hb; b; <ref> [5; 20] </ref>; 1ig 2.2 Execution Model An execution of a timed event-rule system is the consistent assignment of time values to each occurrence of the events in E 0 . <p> 4 5 6 7 8 9 10 11 12 13 14 This example is of interest because we need to use the matrix closure of S to calculate | k ? = 7, and choosing ff smaller than k ? will not yield the solution. 16 [1; 1] [1; 9] <ref> [1; 5] </ref> [1; 1] [1; 1] g d e f The cutsets X = fa 0 ; b 0 ; c 0 ; d 0 ; e 0 ; f 0 ; g 0 g and Y = fa 1 ; b 1 ; c 1 ; d 1 ; e
Reference: [6] <author> K. Keutzer L. Lavagno and A. Sangiovanni-Vincentelli. </author> <title> Synthesis of verifiably hazard-free asynchronous control circuits. </title> <booktitle> In Proceedings of the 1991 University of California at Santa Cruz Conference on Advanced Research in VLSI, </booktitle> <month> March </month> <year> 1991. </year>
Reference-contexts: However, their approach does not generalize to arbitrary inter-process communication and in fact does not yield the tightest possible bounds on the separation in time of the events. Similar restrictions apply to the work of Lavagno/Keutzer/Sangiovanni-Vincentelli <ref> [6] </ref> who apply timing analysis to determine where hazards may occur in a combinational circuit. The separation bounds allow them to insert the appropriate duration delays to eliminate the hazards.
Reference: [7] <author> Kenneth McMillan and David L. Dill. </author> <title> Algorithms for interface timing verification. </title> <booktitle> In 1992 IEEE International Conference on Computer Design: VLSI in Computers and Processors, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: Interface logic verification is an especially troublesome area of circuit design because of the interactions of synchronous and asynchronous components that must meet specific timing requirements. Work by McMillan/Dill <ref> [7] </ref> and Vanbekbergen/Goossens/De Man [9] has directly addressed this issue by considering graphs whose ranges of delays are determined from the logic implementation. The verification problem is then to determine the separation in time of constrained events and ensure that they fall within the specified bounds. <p> Amon/Borriello [3] have taken a different approach where the delays are manipulated symbolically leading to a set of inequalities that must hold true for any valid implementation. In all these cases, however, the process graph topology is restricted. <ref> [7] </ref> and [9] can only handle acyclic graphs while [3] only supports a limited form of inter-process communication. In the area of data-path synthesis there is a large body of work in allocation and scheduling that considers minimizing hardware by multiplexing. <p> Finally, section 5 summarizes the contributions of this paper. 2 Problem Formalization 2.1 A Finite Event-Rule System To formalize the problem we choose a simple modification of the event-rule system developed in [4]. ([8] introduced a similarly modified system. The model can also be viewed as an extension of <ref> [7] </ref> and [9], where we consider cyclic max-only or type-2 graphs.) Let the pair hE 0 ; R 0 i be a repetitive, interval, event-rule system composed of ffi a finite set of (repeatable) events E 0 . ffi a finite set of rule templates R 0 . <p> We address only the problem of finding the maximum separation since ffi can easily be obtained via the transformation t (s ff ) t (t ff (fi) ) ffi 2.4 Acyclic Algorithm We build our solution to this problem on a graph algorithm developed by Dill/McMillan <ref> [7] </ref>.
Reference: [8] <author> Chris Myers and Teresa H.-Y. Meng. </author> <title> Synthesis of timed asynchronous circuits. </title> <booktitle> In 1992 IEEE International Conference on Computer Design: VLSI in Computers and Processors, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: This motivates the need for an efficient algorithm that can look over an arbitrarily long unfolding of the process graph. Many researchers have studied special cases of this problem. Most recently, Myers/Meng <ref> [8] </ref> used timing analysis to simplify the implementation of self-timed sequential logic.
Reference: [9] <author> Peter Vanbekbergen, G. Goossens, and Hugo De Man. </author> <title> Specification and analysis of timing constraints in signal transition graphs. </title> <booktitle> In European Design Automation Conference, </booktitle> <month> March </month> <year> 1992. </year>
Reference-contexts: Interface logic verification is an especially troublesome area of circuit design because of the interactions of synchronous and asynchronous components that must meet specific timing requirements. Work by McMillan/Dill [7] and Vanbekbergen/Goossens/De Man <ref> [9] </ref> has directly addressed this issue by considering graphs whose ranges of delays are determined from the logic implementation. The verification problem is then to determine the separation in time of constrained events and ensure that they fall within the specified bounds. <p> Amon/Borriello [3] have taken a different approach where the delays are manipulated symbolically leading to a set of inequalities that must hold true for any valid implementation. In all these cases, however, the process graph topology is restricted. [7] and <ref> [9] </ref> can only handle acyclic graphs while [3] only supports a limited form of inter-process communication. In the area of data-path synthesis there is a large body of work in allocation and scheduling that considers minimizing hardware by multiplexing. <p> The model can also be viewed as an extension of [7] and <ref> [9] </ref>, where we consider cyclic max-only or type-2 graphs.) Let the pair hE 0 ; R 0 i be a repetitive, interval, event-rule system composed of ffi a finite set of (repeatable) events E 0 . ffi a finite set of rule templates R 0 . <p> Furthermore, t (v k ) must occur before D units have elapsed after t (u k" ) for at least one of the incoming rules. This second property embodies the earliest time nature of the time assignment t. This is analogous to type 2 constraints in <ref> [9] </ref> and is similarly motivated by circuit propagation delays. Formally, we can define constraints on the time values introduced by each event occurrence. <p> 2 3 4 5 6 7 8 9 10 11 12 13 14 This example is of interest because we need to use the matrix closure of S to calculate | k ? = 7, and choosing ff smaller than k ? will not yield the solution. 16 [1; 1] <ref> [1; 9] </ref> [1; 5] [1; 1] [1; 1] g d e f The cutsets X = fa 0 ; b 0 ; c 0 ; d 0 ; e 0 ; f 0 ; g 0 g and Y = fa 1 ; b 1 ; c 1 ; d 1
References-found: 9

