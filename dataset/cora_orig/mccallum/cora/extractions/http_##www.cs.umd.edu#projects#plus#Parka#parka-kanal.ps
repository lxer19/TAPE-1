URL: http://www.cs.umd.edu/projects/plus/Parka/parka-kanal.ps
Refering-URL: http://www.cs.umd.edu/projects/plus/papers.html
Root-URL: 
Title: L A T E X documents for the Machine Intelligence and Pattern Recognition series defProviding
Author: W.j. Maas Matthew P. Evett William A. Andersen and James A. Hendler 
Address: College Park, MD 20742, USA  
Affiliation: Department of Computer Science, University of Maryland,  
Note: c flElsevier Science Publishers B.V. All rights reserved  
Abstract: PARKA is a frame-based knowledge representation system implemented on the Connection Machine. PARKA provides a representation language consisting of concept descriptions (frames) and binary relations on those descriptions (slots). The system is designed explicitly to provide extremely fast property inheritance inference capabilities. In particular, PARKA can perform fast "recognition" queries of the form "find all frames satisfying m property constraints" in O(d + m) time|proportional only to the depth (d) of the knowledge base (KB), and independent of its size. For conjunctive queries of this type, PARKA's performance is measured in tenths of a second, even for KBs with more than 100,000 frames. We show similar results for timings on on large IS-A networks derived from the Cyc commonsense KB, and for queries involving knowledge structure pattern matching in support of case-based planning. With such run-time performance, PARKA is possibly the "fastest knowledge representation system in the world".
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R.J. Brachman. </author> <title> I Lied about the Trees, </title> <journal> AI Magazine, </journal> <volume> Vol. 6, (No. 3), </volume> <month> Fall </month> <year> 1985. </year>
Reference-contexts: This paradigm suffers from redundancy, ambiguity, and other problems, and has been soundly criticized in the philosophical community as being epistemologically inadequate. Many of these criticisms have been detailed by Touretzky [24] and Brachman <ref> [1] </ref>. To address the problems of multiple inheritance, the current implementation uses a top-down, path-based, credulous inheritance mechanism based on the IDO metric to disambiguate multiple inherited values: Assume the frame in question, X, is not explicitly valued for the given property, P .
Reference: [2] <author> R.J. Brachman and J.G. Schmolze. </author> <title> An Overview of the KL-ONE Knowledge Representation System, </title> <journal> Cognitive Science, </journal> <volume> Vol. </volume> <month> 9 </month> <year> (1985). </year>
Reference-contexts: Recognition, for example, is NP-hard, though it is a special case of classification, which can itself be undecidable [16]. So, although PARKA's semantics are roughly based upon those of NETL [8] and KL-ONE <ref> [2] </ref>, we avoided semantic constructs lacking a computa-tionally effective implementation. We believe PARKA's superb run-time performance on even very large KBs more than compensates for its slighlty restricted expressiveness when compared to that of other, serial, KR systems.
Reference: [3] <author> R. DeMara and H. Kitano. </author> <title> PACE Benchmark for Parallel AI Architectures, </title> <type> Tech. Rep. </type> <institution> IMPACT-92-004-USC/CMU, and PKPL 92-5, Department of 18 References EE Systems, University of Southern California, and School of Computer Science, Carnegie Mellon University, </institution> <year> 1992. </year>
Reference: [4] <author> M.P. Evett. PARKA: </author> <title> A System for Massively Parallel Knowledge Representation, </title> <type> Ph.D. thesis, </type> <institution> Dept. of Computer Science, University of Maryland, College Park, </institution> <year> 1993 </year> <month> (forthcoming). </month>
Reference-contexts: We examined this degradation away from our theoretical performance predictions (the results of this study are detailed in <ref> [4] </ref>). <p> Thus, the complete propagation requires d + p 1 propagation steps. Full PARKA 11 implementation details can be found in <ref> [4] </ref>. PARKA's O (d + p) performance compares very favorably with recognition queries on serial systems, which require O (pb d ) time for the same queries, where b is the average fan-out of the IS-A hierarchy. <p> SNAP's representation language is relatively crude, but can be used as the basis for implementing more complex representation schemes. These systems and others are described and critiqued in much greater detail in <ref> [4] </ref>. 5. Conclusion Using KBs of more than 100,000 frames, we have shown that PARKA computes several types of KR retrievals in time independent of the size of the KB and dependent only on network depth. The run-time of these operations is in the tenths of seconds.
Reference: [5] <author> M.P. Evett, J.A. Hendler, and L. Spector, </author> <title> Parallel Knowledge Representation on the Connection Machine, </title> <journal> Journal of Parallel and Distributed Computing, </journal> <year> 1993 </year> <month> (forthcoming). </month>
Reference-contexts: If there is more than one such node (which is possible because PARKA allows multiple inheritance), the inherited value is either ambiguous, or is arbitrarily chosen from among the possible candidates. The first version of PARKA <ref> [5, 7] </ref> handled multiple-inheritance|as have many previous frame-based KR systems ([2] is just one)|by using inheritance path length to disambiguate multiple inheritance paths. This paradigm suffers from redundancy, ambiguity, and other problems, and has been soundly criticized in the philosophical community as being epistemologically inadequate. <p> Then, we timed SPARKA on the same queries and networks. The networks were quite large|up to 128K nodes 3 . Because encoding such large networks by hand was not possible, we developed algorithms for generating pseudo-random networks with certain topological characteristics. These techniques are described in <ref> [5, 7] </ref>. Our experience with the Cyc KB (see section 3.3) has affirmed our belief that the topologies used to measure PARKA's performance reflect those of realistic KBs. of varying size. This timing suite isolates the effect of network size on run-time.
Reference: [6] <author> M.P. Evett and J.A. Hendler. </author> <title> Degradation of Interprocessor Communication Operations on the Connection Machine, </title> <type> Tech. Rep., </type> <institution> Department of Computer Science, Univ. Maryland, College Park, </institution> <year> 1993 </year> <month> (forthcoming). </month>
Reference: [7] <author> M.P. Evett and J.A. Hendler. </author> <title> An Update of PARKA, a Massively Parallel Knowledge Representation System, </title> <type> Tech. Rep., </type> <institution> CS-TR-2850, Department of Computer Science, Univ. Maryland, College Park, </institution> <month> February, </month> <year> 1992. </year>
Reference-contexts: If there is more than one such node (which is possible because PARKA allows multiple inheritance), the inherited value is either ambiguous, or is arbitrarily chosen from among the possible candidates. The first version of PARKA <ref> [5, 7] </ref> handled multiple-inheritance|as have many previous frame-based KR systems ([2] is just one)|by using inheritance path length to disambiguate multiple inheritance paths. This paradigm suffers from redundancy, ambiguity, and other problems, and has been soundly criticized in the philosophical community as being epistemologically inadequate. <p> Then, we timed SPARKA on the same queries and networks. The networks were quite large|up to 128K nodes 3 . Because encoding such large networks by hand was not possible, we developed algorithms for generating pseudo-random networks with certain topological characteristics. These techniques are described in <ref> [5, 7] </ref>. Our experience with the Cyc KB (see section 3.3) has affirmed our belief that the topologies used to measure PARKA's performance reflect those of realistic KBs. of varying size. This timing suite isolates the effect of network size on run-time.
Reference: [8] <author> S.E. Fahlman. </author> <title> NETL: A System for Representing and Using Real World Knowledge, </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1979. </year>
Reference-contexts: Recognition, for example, is NP-hard, though it is a special case of classification, which can itself be undecidable [16]. So, although PARKA's semantics are roughly based upon those of NETL <ref> [8] </ref> and KL-ONE [2], we avoided semantic constructs lacking a computa-tionally effective implementation. We believe PARKA's superb run-time performance on even very large KBs more than compensates for its slighlty restricted expressiveness when compared to that of other, serial, KR systems. <p> As for related work in this field, Fahlman was one of the first to propose a massively parallel implementation of a frame description language (FDL) with NETL <ref> [8] </ref>. NETL, though, was never implemented. In the past several years, a few parallel KR systems have been implemented. Shastri has proposed a massively parallel, connectionist FDL implementation [18]. A recent implementation of a similar system is reported in [19].
Reference: [9] <author> J. Geller. </author> <title> Advanced Update Operations in Massively Parallel Knowledge Representation, </title> <type> Tech. Rep. </type> <institution> CIS-91-28, Dept. Computer and Information Science, New Jersey Institute of Technology, Newark, NJ, </institution> <year> 1991. </year>
Reference-contexts: As such it is not a general-purpose frame-system, though it might be adapted into such. In PARADYME the representation of frames is distributed across many processors: two processors are used for each (frame, slot, value) triplet. In <ref> [9] </ref>, Geller describes the design and implementation of an FDL on the CM-2. The system uses a special mapping of frames to processors to obtain constant-time property inheritance queries on certain classes of IS-A network topologies.
Reference: [10] <author> K.J. Hammond, </author> <title> Case-based planning: A framework for planning from experience, </title> <journal> Cognitive Science, </journal> <volume> Vol. 14 (1990), </volume> <pages> pp. 384-443. </pages>
Reference-contexts: DeMara and Kitano describe a generic pattern matching algorithm <ref> [10] </ref> running on Moldovan's SNAP system [15]. The "pattern matching" problem shares some similarities to that of structure retrieval, but is considerably different. The algorithm listed there is for finding matches against 4-node subgraphs, and it does so very quickly due to the special-purpose hardware on which SNAP is implemented.
Reference: [11] <author> B. Kettler, J.A. Hendler, </author> <title> W.A. Andersen, and M.P. Evett. Massively Parallel Support for Case-based Planning, </title> <journal> IEEE Expert, </journal> <year> 1993 </year> <month> (forthcoming). </month>
Reference-contexts: Serial systems use indexing schemes to mitigate this computational morass, but indexing can be unsatisfactory for a variety of reasons (as we discuss in <ref> [11] </ref>) including that typically it is infeasible to explicitly index all properties. The comparison between serial and parallel run-times is more striking when realizing that for realistic networks d log (n). It is commonly believed that such network shallowness will persist and probably be accentuated as net size increases. <p> This performance compares very favorably with recognition queries on serial systems, which require O (pn) time for the same queries, where n is the size of the KB. Recognition queries in PARKA are independent of KB size, and should scale up to arbitrarily larger domains. Indeed, in <ref> [11] </ref> we report sub-second run-time performance of recognition queries in a case-based planning system using KB's of over 10,000 frames. We achieved run-time performance 10,000 times better than that of a highly optimized serial version of PARKA 6 . <p> Structure Retrieval for Case-Based Planning As another part of our demonstration of PARKA's computational effectiveness as a KR system for very large AI applications, we implemented a general structural matching mechanism. PARKA's structural retrieval mechanism has been used to support CaPER, a case-based planning system <ref> [11] </ref>. Structure retrieval in PARKA is a generalization of recognition, and is closely related to the problem of computing subgraph isomorphism. <p> Structure retrieval parallel run-time performance Fig. 7. Structure retrieval serial run-time performance indexing features is one of PARKA's strengths. Because of it, CaPER is not hindered from retrieving potentially useful cases that share unindexed features with the target problem (other benefits are discussed in <ref> [11] </ref>.) We know of only one other massively parallel system that provides something like structure retrieval. DeMara and Kitano describe a generic pattern matching algorithm [10] running on Moldovan's SNAP system [15]. The "pattern matching" problem shares some similarities to that of structure retrieval, but is considerably different.
Reference: [12] <author> H. Kitano and T. Higuchi, </author> <title> Massively Parallel Memory-Based Parsing, </title> <booktitle> Proceedings of IJCAI-91, </booktitle> <year> 1991. </year>
Reference: [13] <author> J.L. Kolodner and R. Thau. </author> <title> Design and Implementation of a Case Memory, </title> <type> Tech. Rep. </type> <institution> RL88-1, Thinking Machines Corp., </institution> <address> Cambridge, MA, </address> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: NETL, though, was never implemented. In the past several years, a few parallel KR systems have been implemented. Shastri has proposed a massively parallel, connectionist FDL implementation [18]. A recent implementation of a similar system is reported in [19]. Kolodner describes PARADYME <ref> [13] </ref> as a "case memory", implemented as a frame system on the CM. PARADYME offers simple top-down inheritance, multi-valued and facetted slots. PARADYME was designed expressly for representing "events" for use by a case-based reasoner. As such it is not a general-purpose frame-system, though it might be adapted into such.
Reference: [14] <author> D.B. Lenat and R.V. Guha, </author> <title> Building Large Knowledge-Based Systems, </title> <publisher> Ad-dison Wesley, </publisher> <address> Reading, Mass., </address> <year> 1990. </year>
Reference-contexts: We anticipate that this contrast will become increasingly stark for the much larger KBs in applications involving real-world domains. (Lenat & Guha suggested that such KBs will contain tens of millions of nodes <ref> [14] </ref>.) 3.2. Recognition Queries on the Cyc KB The ability to solve recognition queries has driven much of PARKA's design. <p> The results support our run-time analysis and are discussed in the next two sections. 3.3. Using Cyc for Validation of PARKA We tested our run-time predictions for recognition queries by timing PARKA's performance on a version of the Cyc KB <ref> [14] </ref> converted for use with PARKA. Our motivation for using Cyc to evaluate PARKA's performance is twofold. First, we want to validate PARKA's inference mechanisms on a KB of large size and realistic topology.
Reference: [15] <author> D. Moldovan, W. Lee, and C. Lin, </author> <title> SNAP: A Marker-Propagation Architecture for Knowledge Processing. </title> <type> Tech. Rep. </type> <institution> CENG 89-10, Dept. Electrical Engineering-Systems, University of Southern California, </institution> <address> Los Angeles, CA, </address> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: DeMara and Kitano describe a generic pattern matching algorithm [10] running on Moldovan's SNAP system <ref> [15] </ref>. The "pattern matching" problem shares some similarities to that of structure retrieval, but is considerably different. The algorithm listed there is for finding matches against 4-node subgraphs, and it does so very quickly due to the special-purpose hardware on which SNAP is implemented. <p> Geller's system also allows constant-time "update operations" which maintain constant-time inheritance for future queries by modifying the frame to processor mapping appropriately. PARKA 17 Moldovan's SNAP system <ref> [15] </ref> uses special purpose hardware to provide extremely fast marker passing operations in a semantic network. SNAP's representation language is relatively crude, but can be used as the basis for implementing more complex representation schemes. These systems and others are described and critiqued in much greater detail in [4]. 5.
Reference: [16] <author> B. Nebel. </author> <title> Terminological Reasoning is Inherently Intractable, </title> <journal> Artificial Intelligence, </journal> <volume> Vol. 43, (No. 2), </volume> <year> 1990. </year>
Reference-contexts: It is unavoidable because many operations, are, in general, NP-hard or even undecidable for term-subsumption languages that are sound and complete. Recognition, for example, is NP-hard, though it is a special case of classification, which can itself be undecidable <ref> [16] </ref>. So, although PARKA's semantics are roughly based upon those of NETL [8] and KL-ONE [2], we avoided semantic constructs lacking a computa-tionally effective implementation.
Reference: [17] <author> B. Selman and H. Levesque. </author> <title> The Tractability of Path-Based Inheritance, </title> <booktitle> Proceedings of IJCAI-89, </booktitle> <address> Morgan-Kaufman, San Mateo, CA, </address> <year> 1989. </year>
Reference-contexts: If more than one element of B meets this criterion, X is said to be ambiguously valued for property P . Unfortunately, many retrieval operations involving top-down, path-based inheritance mechanisms, including IDO, have been shown to be NP-hard <ref> [17] </ref>. To calculate these operations in a timely manner, we adopted a slightly weaker ordering scheme for inheritance disambiguation. Again, let B be the set of ancestors of X that are explicitly valued for property P .
Reference: [18] <author> L. Shastri, </author> <title> Massive Parallelism in Artificial Intelligence, </title> <type> Tech. Rep. </type> <institution> MS-CIS-86-77 (LINC LAB 43), Dept. of Computer and Information Science, University of Pennsylvania, </institution> <address> Philadelphia, PA, </address> <year> 1986. </year>
Reference-contexts: Real-life domains, however, are orders of magnitude larger, and the run-time performance of these earlier AI techniques is often completely fl evett@cs.umd.edu y waander@cs.umd.edu z hendler@cs.umd.edu 2 Evett, Andersen & Hendler unacceptable for such domains (and even much smaller ones); that is, these techniques, while quite useful, are computationally ineffective <ref> [18] </ref>. The field of knowledge representation (KR) is one area where the techniques of the 80's did not deliver acceptable performance. Most existing KR systems require orders of magnitude more run-time than do humans for certain classes of queries. <p> NETL, though, was never implemented. In the past several years, a few parallel KR systems have been implemented. Shastri has proposed a massively parallel, connectionist FDL implementation <ref> [18] </ref>. A recent implementation of a similar system is reported in [19]. Kolodner describes PARADYME [13] as a "case memory", implemented as a frame system on the CM. PARADYME offers simple top-down inheritance, multi-valued and facetted slots. PARADYME was designed expressly for representing "events" for use by a case-based reasoner.
Reference: [19] <author> L. Shastri and V.G. Ajjanagadde. </author> <title> From Simple Associations to Systematic Reasoning: a Connectionist Representation of Rules, Variables and Dynamic Bindings Using Temporal Synchrony. </title> <type> Technical Report MS-CIS-90-05, </type> <institution> Department of Computer and Information Science, Univ. </institution> <note> of Pennsylvania (Revised January 1992). To appear in Behavorial and Brain Sciences. References 19 </note>
Reference-contexts: NETL, though, was never implemented. In the past several years, a few parallel KR systems have been implemented. Shastri has proposed a massively parallel, connectionist FDL implementation [18]. A recent implementation of a similar system is reported in <ref> [19] </ref>. Kolodner describes PARADYME [13] as a "case memory", implemented as a frame system on the CM. PARADYME offers simple top-down inheritance, multi-valued and facetted slots. PARADYME was designed expressly for representing "events" for use by a case-based reasoner.
Reference: [20] <author> L. Spector, J.A. Hendler, </author> <title> and M.P. Evett, Knowledge Representation in PARKA. </title> <type> Technical Report 2410, </type> <institution> Department of Computer Science, University of Maryland at College Park, </institution> <year> 1990. </year>
Reference: [21] <author> L. Spector, W. Andersen, J. Hendler, J., Kettler, B., Swartzman, E., Woods, C., and Evett, M., </author> <title> Knowledge Representation in PARKA Part 2: Experiments, Analysis, and Enhancements. </title> <type> Technical Report 2837, </type> <institution> Department of Computer Science, University of Maryland at College Park, </institution> <year> 1992. </year>
Reference-contexts: To make the comparison of the timings between PARKA and SPARKA as fair as possible, we implemented SPARKA as a severely stripped-down version of a more complete serial implementation (detailed in <ref> [21] </ref>). It has very little functionality other than for simple property inheritance calculations, but is optimized to effect those calculations as quickly as possible.
Reference: [22] <author> C. Stanfill, and D. Waltz, </author> <title> Toward Memory-Based Reasoning, </title> <journal> Communications of the ACM, </journal> <volume> Vol. 29 (No. 12), </volume> <month> December </month> <year> 1986, </year> <pages> pp. 1213-1228. </pages>
Reference-contexts: Our bias toward run-time performance over general expressiveness derives from our interest in memory-based reasoning 1 (MBR). We are strong 1 We use the term "MBR" in a broader sense than do Stanfill & Waltz <ref> [22] </ref>, to include 4 Evett, Andersen & Hendler supporters of the MBR paradigm and its importance in future AI work. We believe that memory intensive operations form the pillar of most intelligence tasks, sharing this belief with many others ([10-12, 22] are just a few).
Reference: [23] <author> A. Tate. </author> <title> Project Planning Using a Hierarchic Non-linear Planner. Research Report No. </title> <type> 25, </type> <institution> Department of Artificial Intelligence, University of Edin-burgh, </institution> <year> 1976. </year>
Reference-contexts: These case bases consisted of between 20 and 100 cases (respectively between 220 and 1100 subplans and between 3,000 and 10,000 frames). The case bases were generated automaically using the Nonlin planner <ref> [23] </ref>. The most complicated query on this case base required 1.5 seconds of CM time to compute. Future implementations are expected to reduce retrieval times to under 500 milliseconds for comparable probes through the use of more pipelining and caching techniques.
Reference: [24] <editor> D.S. Touretzky. </editor> <title> The Mathematics of Inheritance Systems. </title> <publisher> Morgan Kauf-mann, </publisher> <address> Los Altos, CA, </address> <year> 1986. </year>
Reference-contexts: This paradigm suffers from redundancy, ambiguity, and other problems, and has been soundly criticized in the philosophical community as being epistemologically inadequate. Many of these criticisms have been detailed by Touretzky <ref> [24] </ref> and Brachman [1]. To address the problems of multiple inheritance, the current implementation uses a top-down, path-based, credulous inheritance mechanism based on the IDO metric to disambiguate multiple inherited values: Assume the frame in question, X, is not explicitly valued for the given property, P . <p> Though PARKA's disambiguation mechanism is not quite as powerful as complete IDO, it enjoys many of the same advantages and is considerably stronger than a simple path-length based scheme. It does not suffer from the problems of redundancy noted by Touretzky <ref> [24] </ref> and in only one case does our inheritance scheme differ from IDO: in full IDO, if there are two explicitly valued ancestors, X and Y , but X is also an ancestor of Y , then Y is "more specific" than X, and so its property value is chosen.
Reference: [25] <author> T. Von Eicken, D. Culler, S. Goldstein and K. Schauser. </author> <title> Active Messages: a Mechanism for Integrated Communication and Computation, </title> <type> Tech. Rep. </type> <institution> UCB/CSD 92/#675, Computer Science Division, EECS, University of Cal-ifornia, Berkeley, </institution> <address> CA. </address>
Reference-contexts: Because the CM-5 is a MIMD machine (though we use it as a SPMD machine), we can use several inferencing techniques that aren't possible on the SIMD CM-2. In particular, we plan to use an active messaging scheme (in the sense of <ref> [25] </ref>) to increase the flexibility of PARKA's memory association schemes, and to increase the use of pipelining in inferencing. As for related work in this field, Fahlman was one of the first to propose a massively parallel implementation of a frame description language (FDL) with NETL [8].
Reference: [26] <author> R. Wilensky. </author> <title> Some Problems and Proposals for Knowledge Representation. </title> <type> Tech. Rep. </type> <institution> UCB/CSD 86/294, University of California, Berkeley, </institution> <month> May </month> <year> 1986. </year>
Reference-contexts: Recognition Queries on the Cyc KB The ability to solve recognition queries has driven much of PARKA's design. The problem of recognition is well-known in the field of KR (e.g., <ref> [26] </ref>) and is the problem of answering KB queries of the form: "find all frames x such that P 1 (x; c 1 ) ^ P 2 (x; c 2 ) ^ : : : ^ P p (x; c p )," where P i (z; c i ), 8i, is
References-found: 26

