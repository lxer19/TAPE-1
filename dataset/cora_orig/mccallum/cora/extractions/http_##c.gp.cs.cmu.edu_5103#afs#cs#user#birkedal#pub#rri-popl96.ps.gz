URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/birkedal/pub/rri-popl96.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/birkedal/www/papers.html
Root-URL: http://www.cs.cmu.edu
Title: From Region Inference to von Neumann Machines via Region Representation Inference  
Author: Lars Birkedal, Magnus Vejlstrup, NKT Elektronik 
Affiliation: Carnegie Mellon University Mads Tofte, University of Copenhagen  
Abstract: Region Inference is a technique for implementing programming languages that are based on typed call-by-value lambda calculus, such as Standard ML. The mathematical runtime model of region inference uses a stack of regions, each of which can contain an unbounded number of values. This paper is concerned with mapping the mathematical model onto real machines. This is done by composing region inference with Region Representation Inference, which gradually refines region information till it is directly implementable on conventional von Neumann machines. The performance of a new region-based ML compiler is compared to the performance of Standard ML of New Jersey, a state-of-the-art ML compiler. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alexander Aiken, Manuel Fahndrich, and Raph Levien. </author> <title> Better static memory management: Improving region-based analysis of higher-order languages. </title> <booktitle> In Proc. of the ACM SIGPLAN '95 Conference on Programming Languages and Implementation (PLDI), </booktitle> <pages> pages 174-185, </pages> <address> La Jolla, CA, June 1995. </address> <publisher> ACM Press. </publisher>
Reference: [2] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: This maximum can be found using the graph G computed in Section 6. 8 The Kit Abstract Machine The KAM has a runtime stack, an infinite number of registers and a region heap. The operations of the KAM are similar to those of Appel <ref> [2] </ref>, extended with operations for allocating and deallocating regions and for allocating memory in regions. Region names (Section 4.1) are represented as 32 bit words, with the two low order bits being used for storing the region size (finite/infinite) and the storage mode (attop/atbot).
Reference: [3] <author> Andrew W. Appel and David B. MacQueen. </author> <title> A Standard ML compiler. </title> <editor> In Gilles Kahn, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture. ACM, </booktitle> <publisher> Springer-Verlag, </publisher> <month> Sept </month> <year> 1987. </year>
Reference-contexts: The smallest benchmarks are shown in Section 9.3. In tables, we separate small benchmarks from other benchmarks by a horisontal line. All benchmarks were executed as stand-alone programs under the ML Kit (using the PA-RISC code generator) and Standard ML of New Jersey <ref> [3] </ref>, version 93 on an HP PA-RISC 9000s700 computer. All running times are in seconds (user time, measured by the UNIX time program).
Reference: [4] <author> Lars Birkedal, Nick Rothwell, Mads Tofte, and David N. Turner. </author> <title> The ML Kit (Version 1). </title> <type> Technical Report DIKU-report 93/14, </type> <institution> Department of Computer Science, University of Copenhagen, Universitetsparken 1, DK-2100 Copenhagen, </institution> <year> 1993. </year>
Reference: [5] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proc. 9th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <month> Jan. </month> <year> 1982. </year>
Reference: [6] <author> Martin Elsman and Niels Hallenberg. </author> <title> An optimizing backend for the ML Kit using a stack of regions. Student Project, </title> <institution> Department of Computer Science, University of Copenhagen (DIKU), </institution> <month> July 5 </month> <year> 1995. </year>
Reference: [7] <author> Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen. </author> <title> The essence of compiling with continuations. </title> <booktitle> In Proc. of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Storage Mode Analysis is based on statically inferred liveness properties. Liveness analysis has to take temporary values into account. Inspired by the A-Normal Form of Flanagan et al <ref> [7] </ref>, we shall therefore assume that the input expression to the storage mode analysis conforms to the following grammar of region annotated K-Normal Form expressions: e ::= x il j v a j x il x il j f il [~a ] a 0 x il j if x il then
Reference: [8] <author> Fritz Henglein and Jesper Jtrgensen. </author> <title> Formally optimal boxing. </title> <booktitle> In Conference Record of POPL'94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 213-226. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1994. </year>
Reference: [9] <author> P. Jouvelot and D.K. Gifford. </author> <title> Algebraic reconstruction of types and effects. </title> <booktitle> In Proceedings of the 18th ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <year> 1991. </year>
Reference: [10] <author> Xavier Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 177-188. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1992. </year>
Reference: [11] <author> J. M. Lucassen. </author> <title> Types and Effects, towards the integration of functional and imperative programming. </title> <type> PhD thesis, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1987. </year> <month> MIT/LCS/TR-408. </month>
Reference: [12] <author> J.M. Lucassen and D.K. Gifford. </author> <title> Polymorphic effect systems. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Principles of Programming Languages, </booktitle> <year> 1988. </year>
Reference: [13] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> J. Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference: [14] <author> Hanne Riis Nielson and Flemming Nielson. </author> <title> Higher-order concurrent programs with finite communication topology. </title> <booktitle> In Conference Record of POPL'94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-97. </pages> <publisher> ACM Press, </publisher> <month> Jan-uary </month> <year> 1994. </year>
Reference: [15] <author> Zhong Shao. </author> <title> Compiling Standard ML for Efficient Execution on Modern Machines. </title> <type> PhD thesis, </type> <institution> Princeton University, </institution> <year> 1994. </year> <note> (Also available as Research Report CS-TR-475-94). </note>
Reference: [16] <author> Jean-Pierre Talpin and Pierre Jouvelot. </author> <title> Polymorphic type, region and effect inference. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(3), </volume> <year> 1992. </year>
Reference: [17] <author> Mads Tofte and Jean-Pierre Talpin. </author> <title> Implementing the call-by-value lambda-calculus using a stack of regions. </title> <booktitle> In Proceedings of the 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 188-201. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: () =&gt; 0); Region inference ensures that the list l produced by mklist 2000 is discarded immediately after the closure for fn () =&gt; #1 (hd x) + f () is produced; note that the function will not access l | in fact the closure will contain a dangling pointer <ref> [17] </ref>. In garbage collected systems which do not allow dangling pointers, the space usage is O (mfin), where m and n are the arguments to cycle and mklist, respectively (here m = 1000 and n = 2000). With region inference, the space usage is just O (m).
Reference: [18] <author> Magnus Vejlstrup. </author> <title> Multiplicity inference. </title> <type> Master's thesis, </type> <institution> Dept. of Computer Science, Univ. of Copenhagen, </institution> <month> September </month> <year> 1994. </year>
References-found: 18

