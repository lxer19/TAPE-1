URL: http://www.cs.wustl.edu/cs/techreports/1995/wucs-95-31.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: 
Email: schmidt@cs.wustl.edu  
Title: An OO Encapsulation of Lightweight OS Concurrency Mechanisms in the ACE Toolkit  
Author: Douglas C. Schmidt 
Address: St. Louis, MO 63130, (314) 935-7538  
Affiliation: Department of Computer Science Washington University  
Web: http://www.cs.wustl.edu/~schmidt/  
Abstract: This document is available as technical report number WUCS-95-31, from techrep@cs.wustl.edu at Washington University, St. Louis. Abstract This paper describes the design of the ACE object-oriented thread encapsulation class library. The architecture of this class library is presented from an end-user and internal design perspective and several key design issues are discussed. Readers should gain an understanding of the overall design approach, as well as the tradeoffs between various software quality factors such as performance, portability, and extensibility. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, ASX: </author> <title> an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 30 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas--sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: This paper motivates and describes a C++ class library contained in the ADAPTIVE Communications Environment (ACE) <ref> [1] </ref>. ACE encapsulates and enhances the lightweight concurrency mechanisms provided both by So-laris 2.x threads [2] and POSIX Pthreads [3]. <p> for (int i = 0; i &lt; iterations; i++) ++request_count; // Count # of requests return (void *) iterations; - typedef void *(*THR_FUNC)(void *); // Main driver function for the // multi-threaded server. int main (int argc, char *argv []) - int n_threads = argc &gt; 1 ? atoi (argv <ref> [1] </ref>) : 4; int n_iterations = argc &gt; 2 ? atoi (argv [2]) : 1000000; thread_t t_id; // Divide iterations evenly among threads. int iterations = n_iterations / n_threads; // Spawn off N threads to run in parallel. for (int i = 0; i &lt; n_threads; i++) thr_create (0, 0, THR_FUNC <p> This section focuses on the steps involved in generalizing from existing code by using templates and overloading to transparently parameterize synchronization mechanisms into a concurrent application. The infrastructure code is based on components in the ADAPTIVE Communication Environment (ACE) framework described in <ref> [1, 26, 20] </ref>. This example examines several C++ language features that solve the serialization problem presented in Section 3.5.1 more elegantly. As described in that section, the original solution was inelegant, non-portable, error-prone, and required obtrusive changes to the source code. <p> Conversely, the put method may enqueue the message and defer handling to its svc method that is executing in a separate thread of control (i.e., the asynchronous processing approach illustrated in Figure 4 (2)). As discussed in <ref> [1] </ref>, the particular processing approach that is selected has a significant impact on performance and ease of programming. * Message Queueing Mechanisms In addition to the open, close, put, and svc pure virtual method interfaces, each Task also contains a Message Queue. <p> // The destructor of Thread_Control removes the // exiting thread from the Thread_Manager // automatically. return 0; - // Default port number. static const int default_port = 5000; int main (int argc, char *argv []) - // Port number of server. u_short port = argc &gt; 1 ? atoi (argv <ref> [1] </ref>) : default_port; // Internet address of server. INET_Addr addr (port); // Passive-mode listener object. SOCK_Acceptor server (addr); // Connected client.
Reference: [2] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalin-giah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedingsof the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: This paper motivates and describes a C++ class library contained in the ADAPTIVE Communications Environment (ACE) [1]. ACE encapsulates and enhances the lightweight concurrency mechanisms provided both by So-laris 2.x threads <ref> [2] </ref> and POSIX Pthreads [3]. The material presented in this paper is intended for a technical audience interested in understanding the strategies and tactics of object-oriented (OO) concurrent programming using Solaris [2] and POSIX [3] threads. <p> ACE encapsulates and enhances the lightweight concurrency mechanisms provided both by So-laris 2.x threads <ref> [2] </ref> and POSIX Pthreads [3]. The material presented in this paper is intended for a technical audience interested in understanding the strategies and tactics of object-oriented (OO) concurrent programming using Solaris [2] and POSIX [3] threads. <p> There is less experience, however, with emerging multi-threading and synchronization mechanisms for UNIX (such as Solaris threads <ref> [2] </ref> or POSIX pthreads [3]). This section presents an overview of background material relevant to concurrent programming and Solaris threads. <p> There is less experience, however, with emerging multi-threading and synchronization mechanisms for UNIX (such as Solaris threads [2] or POSIX pthreads [3]). This section presents an overview of background material relevant to concurrent programming and Solaris threads. More detailed discussions of concurrent programming, and Solaris/POSIX threads appear in <ref> [2, 18, 19, 3] </ref>. 3.1 Processes and Threads A process is a collection of resources that enable the execution of program instructions. These resources include virtual memory, I/O descriptors, a run-time stack, signal handlers, user and group ids, and access control tokens. <p> In addition to an instruction pointer, a thread consists of other resources such as a run-time stack of function activation records, a set of general-purpose registers, and thread-specific data. Conventional workstation operating systems (such as variants of UNIX <ref> [2, 21, 22] </ref> and Windows NT [15]) support the concurrent execution of multiple processes, each of which may contain 1 or more threads. A process serves as the unit of protection and resource allocation within a separate hardware protected address space. <p> # of requests return (void *) iterations; - typedef void *(*THR_FUNC)(void *); // Main driver function for the // multi-threaded server. int main (int argc, char *argv []) - int n_threads = argc &gt; 1 ? atoi (argv [1]) : 4; int n_iterations = argc &gt; 2 ? atoi (argv <ref> [2] </ref>) : 1000000; thread_t t_id; // Divide iterations evenly among threads. int iterations = n_iterations / n_threads; // Spawn off N threads to run in parallel. for (int i = 0; i &lt; n_threads; i++) thr_create (0, 0, THR_FUNC (&run_svc), (void *) iterations, THR_BOUND | THR_SUSPENDED, &t_id); // Resume all suspended <p> A spin-lock is a simple and efficient synchronization mechanism for certain types of short-lived resource contention, like auto-incrementing the global request count variable illustrated in Example 1 above. An adaptive spin-lock polls a designated memory location using the atomic hardware instruction until one of the following conditions occur <ref> [2] </ref>: * The value at this location is changed by the thread that currently owns the lock. This signifies that the lock has been released and may now be acquired by the spinning thread. * The thread that is holding the lock goes to sleep.
Reference: [3] <author> IEEE, </author> <title> Threads Extension for Portable Operating Systems (Draft 6), </title> <month> February </month> <year> 1992. </year>
Reference-contexts: This paper motivates and describes a C++ class library contained in the ADAPTIVE Communications Environment (ACE) [1]. ACE encapsulates and enhances the lightweight concurrency mechanisms provided both by So-laris 2.x threads [2] and POSIX Pthreads <ref> [3] </ref>. The material presented in this paper is intended for a technical audience interested in understanding the strategies and tactics of object-oriented (OO) concurrent programming using Solaris [2] and POSIX [3] threads. <p> ACE encapsulates and enhances the lightweight concurrency mechanisms provided both by So-laris 2.x threads [2] and POSIX Pthreads <ref> [3] </ref>. The material presented in this paper is intended for a technical audience interested in understanding the strategies and tactics of object-oriented (OO) concurrent programming using Solaris [2] and POSIX [3] threads. <p> These ACE components provide a portable and extensible interface for concurrent programming. This interface simplifies thread management and synchronization mechanisms used to develop clients and servers. This interface has been ported to POSIX pthreads <ref> [3] </ref> and a Microsoft WIN32 [15] port is also underway. 2.1.1 Overall Requirements In conjunction with the goal of encapsulating and simplifying the concurrency substrate of OS threading mechanisms, the ACE OO thread encapsulation class library is being developed in response to the following common application requirements. * Simplify program design <p> These active objects queue messages for input and output and perform user-defined message processing services in separate threads of control. This class is described in Section 5.5.1. 2.2.6 Miscellaneous ACE Concurrency Classes * Thread: The Thread class encapsulates the Solaris thr * and POSIX Pthreads <ref> [3] </ref> family of thread creation, termination, and management routines. This class is described in Section 5.6.1. 3 * Atomic Op: The Atomic Op class transparently pa-rameterizes synchronization into basic arithmetic operations. <p> There is less experience, however, with emerging multi-threading and synchronization mechanisms for UNIX (such as Solaris threads [2] or POSIX pthreads <ref> [3] </ref>). This section presents an overview of background material relevant to concurrent programming and Solaris threads. More detailed discussions of concurrent programming, and Solaris/POSIX threads appear in [2, 18, 19, 3]. 3.1 Processes and Threads A process is a collection of resources that enable the execution of program instructions. <p> There is less experience, however, with emerging multi-threading and synchronization mechanisms for UNIX (such as Solaris threads [2] or POSIX pthreads [3]). This section presents an overview of background material relevant to concurrent programming and Solaris threads. More detailed discussions of concurrent programming, and Solaris/POSIX threads appear in <ref> [2, 18, 19, 3] </ref>. 3.1 Processes and Threads A process is a collection of resources that enable the execution of program instructions. These resources include virtual memory, I/O descriptors, a run-time stack, signal handlers, user and group ids, and access control tokens. <p> In contrast, the un derlying Solaris cond t cond wait interface requires a mutex to be passed as a parameter on every call to wait. Solaris 2.x provides a built-in implementation of count ing semaphores (see the discussion in Section 3.5.3). How ever, the POSIX Pthreads <ref> [3] </ref> threads library does not include a semaphore.
Reference: [4] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: It is assumed that the reader is familiar with general OO design and programming techniques (such as design patterns <ref> [4] </ref>, application frameworks [5], modularity, information hiding, and object modeling [6]), OO notations (such as OMT [7]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [8]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [9]), and networking terminology (such <p> This example illustrates yet another benefit of using C++ wrappers: they promote interface conformance by adapting gratuitously incompatible interfaces (such as Solaris 2.x semaphores and mutexes). This is an example of the Adapter pattern from <ref> [4] </ref>.
Reference: [5] <author> R. Johnson and B. Foote, </author> <title> Designing Reusable Classes, </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> vol. 1, </volume> <pages> pp. 22-35, </pages> <month> June/July </month> <year> 1988. </year>
Reference-contexts: It is assumed that the reader is familiar with general OO design and programming techniques (such as design patterns [4], application frameworks <ref> [5] </ref>, modularity, information hiding, and object modeling [6]), OO notations (such as OMT [7]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [8]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [9]), and networking terminology (such as client/server architectures
Reference: [6] <author> G. Booch, </author> <title> Object Oriented Analysis and Design with Ap plications (2 nd Edition). </title> <address> Redwood City, California: Ben-jamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: It is assumed that the reader is familiar with general OO design and programming techniques (such as design patterns [4], application frameworks [5], modularity, information hiding, and object modeling <ref> [6] </ref>), OO notations (such as OMT [7]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [8]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [9]), and networking terminology (such as client/server architectures [10], RPC [11], CORBA [12], and TCP/IP <p> It employs a C++ idiom idiom commonly known as constructor as resource acquisition destructor as resource release <ref> [8, 27, 6] </ref>. As shown in the code above, the constructor of a Guard class acquires the lock on the Mutex object automatically when an object of the class is created. Likewise, the destructor of a Guard class automatically unlocks the Mutex object when the object goes out of scope.
Reference: [7] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen, </author> <title> Object-Oriented Modeling and Design. </title> <address> En-glewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: It is assumed that the reader is familiar with general OO design and programming techniques (such as design patterns [4], application frameworks [5], modularity, information hiding, and object modeling [6]), OO notations (such as OMT <ref> [7] </ref>), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [8]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [9]), and networking terminology (such as client/server architectures [10], RPC [11], CORBA [12], and TCP/IP [13, 14]).
Reference: [8] <author> Bjarne Stroustrup, </author> <title> The C++ Programming Language, 2 nd Edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: It is assumed that the reader is familiar with general OO design and programming techniques (such as design patterns [4], application frameworks [5], modularity, information hiding, and object modeling [6]), OO notations (such as OMT [7]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types <ref> [8] </ref>), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [9]), and networking terminology (such as client/server architectures [10], RPC [11], CORBA [12], and TCP/IP [13, 14]). <p> It employs a C++ idiom idiom commonly known as constructor as resource acquisition destructor as resource release <ref> [8, 27, 6] </ref>. As shown in the code above, the constructor of a Guard class acquires the lock on the Mutex object automatically when an object of the class is created. Likewise, the destructor of a Guard class automatically unlocks the Mutex object when the object goes out of scope.
Reference: [9] <author> W. R. Stevens, </author> <title> Advanced Programming in the UNIX Environment. </title> <address> Reading, Massachusetts: </address> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: (such as design patterns [4], application frameworks [5], modularity, information hiding, and object modeling [6]), OO notations (such as OMT [7]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [8]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication <ref> [9] </ref>), and networking terminology (such as client/server architectures [10], RPC [11], CORBA [12], and TCP/IP [13, 14]). This paper does not assume in-depth knowledge of con-currency, in general, or Solaris/POSIX multi-threading and synchronization mechanisms, in particular. An overview of concurrent programming and multi-threading is presented in Section 3.
Reference: [10] <author> D. E. Comer and D. L. Stevens, </author> <title> Internetworking with TCP/IP Vol III: Client Server Programming and Applications. </title> <address> En-glewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: modularity, information hiding, and object modeling [6]), OO notations (such as OMT [7]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [8]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [9]), and networking terminology (such as client/server architectures <ref> [10] </ref>, RPC [11], CORBA [12], and TCP/IP [13, 14]). This paper does not assume in-depth knowledge of con-currency, in general, or Solaris/POSIX multi-threading and synchronization mechanisms, in particular. An overview of concurrent programming and multi-threading is presented in Section 3.
Reference: [11] <author> Sun Microsystems, </author> <title> Open Network Computing: RPC Programming, </title> <month> June </month> <year> 1991. </year>
Reference-contexts: hiding, and object modeling [6]), OO notations (such as OMT [7]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [8]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [9]), and networking terminology (such as client/server architectures [10], RPC <ref> [11] </ref>, CORBA [12], and TCP/IP [13, 14]). This paper does not assume in-depth knowledge of con-currency, in general, or Solaris/POSIX multi-threading and synchronization mechanisms, in particular. An overview of concurrent programming and multi-threading is presented in Section 3.
Reference: [12] <institution> Object Management Group,The Common Object Request Broker: Architecture and Specification, 1.2 ed., </institution> <year> 1993. </year>
Reference-contexts: object modeling [6]), OO notations (such as OMT [7]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [8]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [9]), and networking terminology (such as client/server architectures [10], RPC [11], CORBA <ref> [12] </ref>, and TCP/IP [13, 14]). This paper does not assume in-depth knowledge of con-currency, in general, or Solaris/POSIX multi-threading and synchronization mechanisms, in particular. An overview of concurrent programming and multi-threading is presented in Section 3.
Reference: [13] <author> W. R. Stevens, </author> <title> UNIX Network Programming. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: OO notations (such as OMT [7]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [8]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [9]), and networking terminology (such as client/server architectures [10], RPC [11], CORBA [12], and TCP/IP <ref> [13, 14] </ref>). This paper does not assume in-depth knowledge of con-currency, in general, or Solaris/POSIX multi-threading and synchronization mechanisms, in particular. An overview of concurrent programming and multi-threading is presented in Section 3.
Reference: [14] <author> W. R. Stevens, </author> <title> TCP/IP Illustrated, </title> <booktitle> Volume 1. </booktitle> <address> Reading, Mas-sachusetts: </address> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: OO notations (such as OMT [7]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [8]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [9]), and networking terminology (such as client/server architectures [10], RPC [11], CORBA [12], and TCP/IP <ref> [13, 14] </ref>). This paper does not assume in-depth knowledge of con-currency, in general, or Solaris/POSIX multi-threading and synchronization mechanisms, in particular. An overview of concurrent programming and multi-threading is presented in Section 3.
Reference: [15] <author> H. Custer, </author> <title> Inside Windows NT. </title> <address> Redmond, Washington: </address> <publisher> Mi-crosoft Press, </publisher> <year> 1993. </year>
Reference-contexts: These ACE components provide a portable and extensible interface for concurrent programming. This interface simplifies thread management and synchronization mechanisms used to develop clients and servers. This interface has been ported to POSIX pthreads [3] and a Microsoft WIN32 <ref> [15] </ref> port is also underway. 2.1.1 Overall Requirements In conjunction with the goal of encapsulating and simplifying the concurrency substrate of OS threading mechanisms, the ACE OO thread encapsulation class library is being developed in response to the following common application requirements. * Simplify program design by allowing multiple application tasks <p> In addition to an instruction pointer, a thread consists of other resources such as a run-time stack of function activation records, a set of general-purpose registers, and thread-specific data. Conventional workstation operating systems (such as variants of UNIX [2, 21, 22] and Windows NT <ref> [15] </ref>) support the concurrent execution of multiple processes, each of which may contain 1 or more threads. A process serves as the unit of protection and resource allocation within a separate hardware protected address space. <p> For example, the following is an implementation of the Mutex class interface based on mechanisms in the Windows NT WIN32 API <ref> [15] </ref>: class Mutex - public: Mutex (void) - InitializeCriticalSection (&lock_); - Mutex (void) - DeleteCriticalSection (&lock_); - int acquire (void) - EnterCriticalSection (&lock_); return 0; - int release (void) - LeaveCriticalSection (&lock_); return 0; - private: // Win32 serialization mechanism.
Reference: [16] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, </title> <booktitle> in Proceedings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 1-7, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: This class is described in Section 5.4.2. 2.2.5 The ACE Active Objects Class Category * Task: The Task class is the central mechanism in ACE for defining active objects <ref> [16, 17] </ref>. These active objects queue messages for input and output and perform user-defined message processing services in separate threads of control. <p> -; Note how this classes inherits from the ACE Acceptor class, which is a generic factory for passively connecting clients and creating service handlers [30]. 5.5 The ACE Active Objects Class Category 5.5.1 The Task Class The Task class is the central mechanism in ACE for creating user-defined active objects <ref> [16] </ref> and passive objects that process application messages.
Reference: [17] <author> D. C. Schmidt and C. D. Cranor, Half-Sync/Half-Async: </author> <title> an Architectural Pattern for Efficient and Well-structured Concurrent I/O, </title> <booktitle> in Proceedings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 1-10, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: This class is described in Section 5.4.2. 2.2.5 The ACE Active Objects Class Category * Task: The Task class is the central mechanism in ACE for defining active objects <ref> [16, 17] </ref>. These active objects queue messages for input and output and perform user-defined message processing services in separate threads of control.
Reference: [18] <author> A. D. Birrell, </author> <title> An Introduction to Programming with Threads, </title> <type> Tech. Rep. </type> <institution> SRC-035, Digital Equipment Corporation, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: There is less experience, however, with emerging multi-threading and synchronization mechanisms for UNIX (such as Solaris threads [2] or POSIX pthreads [3]). This section presents an overview of background material relevant to concurrent programming and Solaris threads. More detailed discussions of concurrent programming, and Solaris/POSIX threads appear in <ref> [2, 18, 19, 3] </ref>. 3.1 Processes and Threads A process is a collection of resources that enable the execution of program instructions. These resources include virtual memory, I/O descriptors, a run-time stack, signal handlers, user and group ids, and access control tokens.
Reference: [19] <author> Sun Microsystems, Inc., </author> <title> Mountain View, CA, SunOS 5.3 Guide to Multi-Thread Programming, Part number: </title> <editor> 801-3176-10 ed., </editor> <month> May </month> <year> 1993. </year>
Reference-contexts: There is less experience, however, with emerging multi-threading and synchronization mechanisms for UNIX (such as Solaris threads [2] or POSIX pthreads [3]). This section presents an overview of background material relevant to concurrent programming and Solaris threads. More detailed discussions of concurrent programming, and Solaris/POSIX threads appear in <ref> [2, 18, 19, 3] </ref>. 3.1 Processes and Threads A process is a collection of resources that enable the execution of program instructions. These resources include virtual memory, I/O descriptors, a run-time stack, signal handlers, user and group ids, and access control tokens. <p> In many circumstances, however, multi 4 An MMU protects separate process address spaces from accidental or malicious corruption by other active processes in the system. threading does not improve performance. For example, compute-bound applications on a uni-processor <ref> [19] </ref> will not benefit from multi-threading since computation will not overlap communication. In addition, fine-grained locking causes high levels of synchronization overhead [23, 24]. This prevents applications from fully exploiting the benefits of parallel processing. There are some circumstances where multi-threading may improve performance significantly. <p> Solaris 2.x provides several synchronization mechanisms. This paper describes C++ wrappers for the four primary synchronization mechanisms in Solaris 2.x: mu-texes, readers/writer locks, counting semaphores, and condition variables <ref> [19] </ref>. ACE contains C++ wrappers (Mutex, RW Lock, Semaphore, and Condition) that encapsulate these four Solaris 2.x synchronization mechanisms (mutex t, rwlock t, sema t, and cond t, respectively). In the remainder of Section 3 we outline the behavior of the Solaris synchronization mechanisms.
Reference: [20] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: There are several common workarounds to avoid blocking in single-threaded servers: * Event demultiplexers/dispatcher one approach is to develop an event demultiplexer/dispatcher (such as the object-oriented Reactor framework <ref> [20] </ref>). This technique is widely used to manage multiple input devices in single-threaded user-interface frameworks. The main event demultiplexer/dispatcher detects an incoming event, demultiplexes the event to the appropriate event handler, and then dispatches an application-specific callback method associated with the event handler. <p> This section focuses on the steps involved in generalizing from existing code by using templates and overloading to transparently parameterize synchronization mechanisms into a concurrent application. The infrastructure code is based on components in the ADAPTIVE Communication Environment (ACE) framework described in <ref> [1, 26, 20] </ref>. This example examines several C++ language features that solve the serialization problem presented in Section 3.5.1 more elegantly. As described in that section, the original solution was inelegant, non-portable, error-prone, and required obtrusive changes to the source code. <p> It works with the Mutex, RW Mutex, and Semaphore classes. By default, Solaris provides non-recursive mutexes and readers/writer locks. These semantics are too restrictive in certain circumstances. Therefore, ACE provides support for recursive locks via the Recursive Lock class. Recursive locks are particularly useful for callback-driven C++ frameworks <ref> [28, 20] </ref>, where the framework event-loop performs a callback to user-defined code. Since the user-defined code may subsequently re-enter framework code via a method entry point, recursive locks are useful to prevent deadlock from occurring on locks held within the framework during the callback.
Reference: [21] <author> A. Garg, </author> <title> Parallel STREAMS: a Multi-Process Implementation, </title> <booktitle> in Proceedings of the Winter USENIX Conference, </booktitle> <address> (Washington, D.C.), </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: In addition to an instruction pointer, a thread consists of other resources such as a run-time stack of function activation records, a set of general-purpose registers, and thread-specific data. Conventional workstation operating systems (such as variants of UNIX <ref> [2, 21, 22] </ref> and Windows NT [15]) support the concurrent execution of multiple processes, each of which may contain 1 or more threads. A process serves as the unit of protection and resource allocation within a separate hardware protected address space.
Reference: [22] <author> S. Saxena, J. K. Peacock, F. Yang, V. Verma, and M. Krish-nan, </author> <title> Pitfalls in Multithreading SVR4 STREAMS and other Weightless Processes, </title> <booktitle> in Proceedings of the Winter USENIX Conference, </booktitle> <address> (San Diego, CA), </address> <pages> pp. 85-106, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: In addition to an instruction pointer, a thread consists of other resources such as a run-time stack of function activation records, a set of general-purpose registers, and thread-specific data. Conventional workstation operating systems (such as variants of UNIX <ref> [2, 21, 22] </ref> and Windows NT [15]) support the concurrent execution of multiple processes, each of which may contain 1 or more threads. A process serves as the unit of protection and resource allocation within a separate hardware protected address space.
Reference: [23] <author> D. C. Schmidt and T. Suda, </author> <title> Measuring the Performance of Parallel Message-based Process Architectures, </title> <booktitle> in Proceedings of the Conference on Computer Communications (INFO-COM), </booktitle> <address> (Boston, MA), </address> <pages> pp. 624-633, </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1995. </year>
Reference-contexts: For example, compute-bound applications on a uni-processor [19] will not benefit from multi-threading since computation will not overlap communication. In addition, fine-grained locking causes high levels of synchronization overhead <ref> [23, 24] </ref>. This prevents applications from fully exploiting the benefits of parallel processing. There are some circumstances where multi-threading may improve performance significantly. For example, a multi-threading connection-oriented application gateway may benefit by being run on a multi-processor platform.
Reference: [24] <author> Mats Bjorkman and Per Gunningberg, </author> <title> Locking Strategies in Multiprocessor Implementations of Protocols, </title> <booktitle> in Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), </booktitle> <address> (San Francisco, California), </address> <publisher> ACM, </publisher> <year> 1993. </year>
Reference-contexts: For example, compute-bound applications on a uni-processor [19] will not benefit from multi-threading since computation will not overlap communication. In addition, fine-grained locking causes high levels of synchronization overhead <ref> [23, 24] </ref>. This prevents applications from fully exploiting the benefits of parallel processing. There are some circumstances where multi-threading may improve performance significantly. For example, a multi-threading connection-oriented application gateway may benefit by being run on a multi-processor platform.
Reference: [25] <author> D. C. Schmidt, </author> <title> A Family of Reusable Design Patterns for Application-level Gateways, in The Theory and Practice of Object Systems (Special Issue on Patterns and Pattern Languages) (S. </title> <editor> P. Berczuk, ed.), </editor> <publisher> Wiley and Sons, </publisher> <year> 1995. </year>
Reference-contexts: This use case depicts a representative scenario that is based upon a production system <ref> [25] </ref>. Additional examples of the ACE OO thread encapsulation class library appear in Section 6, following the presentation the library interfaces in Section 5. Many useful C++ classes have evolved incrementally by generalizing from solutions to practical problems that arise during system development.
Reference: [26] <author> D. C. Schmidt and P. </author> <title> Stephenson,An Object-Oriented Framework for Developing Network Server Daemons, </title> <booktitle> in Proceed ings of the 2 nd C++ World Conference, </booktitle> <address> (Dallas, Texas), SIGS, </address> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: This section focuses on the steps involved in generalizing from existing code by using templates and overloading to transparently parameterize synchronization mechanisms into a concurrent application. The infrastructure code is based on components in the ADAPTIVE Communication Environment (ACE) framework described in <ref> [1, 26, 20] </ref>. This example examines several C++ language features that solve the serialization problem presented in Section 3.5.1 more elegantly. As described in that section, the original solution was inelegant, non-portable, error-prone, and required obtrusive changes to the source code.
Reference: [27] <author> G. Booch and M. Vilot, </author> <title> Simplifying the Booch Components, </title> <journal> C++ Report, </journal> <volume> vol. 5, </volume> <month> June </month> <year> 1993. </year>
Reference-contexts: It employs a C++ idiom idiom commonly known as constructor as resource acquisition destructor as resource release <ref> [8, 27, 6] </ref>. As shown in the code above, the constructor of a Guard class acquires the lock on the Mutex object automatically when an object of the class is created. Likewise, the destructor of a Guard class automatically unlocks the Mutex object when the object goes out of scope.
Reference: [28] <author> M. A. Linton and P. R. Calder, </author> <booktitle> The Design and Implementation of InterViews, in Proceedings of the USENIX C++ Workshop, </booktitle> <month> November </month> <year> 1987. </year>
Reference-contexts: It works with the Mutex, RW Mutex, and Semaphore classes. By default, Solaris provides non-recursive mutexes and readers/writer locks. These semantics are too restrictive in certain circumstances. Therefore, ACE provides support for recursive locks via the Recursive Lock class. Recursive locks are particularly useful for callback-driven C++ frameworks <ref> [28, 20] </ref>, where the framework event-loop performs a callback to user-defined code. Since the user-defined code may subsequently re-enter framework code via a method entry point, recursive locks are useful to prevent deadlock from occurring on locks held within the framework during the callback.
Reference: [29] <author> T. Harrison and D. C. Schmidt, </author> <title> Thread-Specific Storage: A Pattern for Reducing Locking Overhead in Concurrent Programs, </title> <booktitle> in OOPSLA Workshop on Design Patterns for Concurrent, Parallel, and Distributed Systems, ACM, </booktitle> <month> October </month> <year> 1995. </year>
Reference-contexts: A program executing factorial in multiple threads would produce unpredictable results since recursion depth is a global various that would be mod ified serially by multiple threads of control! A more ap propriate (and less expensive) locking strategy in this case would use the Thread-Specific Storage pattern <ref> [29] </ref> described in Section 5.6.4. 5.1.5 The Null Mutex Class The Null Mutex class provides a zero-overhead imple mentation of the general locking interface shared by the other C++ wrappers for Solaris synchronization. <p> The underlying pattern that this class is based upon is described in <ref> [29] </ref>. The following is the public interface of the ACE Thread Specific class: template &lt;class TYPE&gt; class Thread_Specific - public: // If caller passes a non-NULL ts_obj * // this is used to initialize the // thread-specific value. Thus, calls // to operator-&gt;() will return this value.
Reference: [30] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Actively and Passively Initializing Network Services, </title> <booktitle> in Workshop on Pattern Languages of Object-Oriented Programs at ECOOP '95, </booktitle> <address> (Aarhus, Denmark), </address> <month> August </month> <year> 1995. </year>
Reference-contexts: SVC_HANDLER *make_svc_handler (void); // Factory method that creates an appropriate // SVC_HANDLER *. virtual int thr_flags (void); // Returns the flags used to spawn a thread. -; Note how this classes inherits from the ACE Acceptor class, which is a generic factory for passively connecting clients and creating service handlers <ref> [30] </ref>. 5.5 The ACE Active Objects Class Category 5.5.1 The Task Class The Task class is the central mechanism in ACE for creating user-defined active objects [16] and passive objects that process application messages.
Reference: [31] <author> N. C. Hutchinson and L. L. Peterson, </author> <title> The x-kernel: An Architecture for Implementing Network Protocols, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 17, </volume> <pages> pp. 64-76, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The put method runs synchronously with respect to its caller, i.e., it borrows the thread of control from the Task that originally invoked its put method. This thread of control typically originate either upstream from an application process, downstream from a pool of threads that handle I/O device interrupts <ref> [31] </ref>, or internal to the Stream from an event dispatching mechanism (such as a timer-driven callout queue used to trigger retransmissions in a connection-oriented transport protocol Module).
Reference: [32] <author> D. C. Schmidt, </author> <title> The ADAPTIVE Communication Environment: Object-Oriented Network Programming Components for Developing Client/Server Applications, </title> <booktitle> in Proceedings of the 12 th Annual Sun Users Group Conference, </booktitle> <address> (San Fran-cisco, CA), </address> <pages> pp. 214-225, </pages> <address> SUG, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The following example illustrates the interface and implementation of a map manager component in the general ACE toolkit <ref> [32] </ref>. This component is typically used in a network server to map external identifiers (such as port numbers or connection ids) onto internal identifiers (such as pointers to queues where messages are stored when outgoing links to a satellite become flow controlled).
Reference: [33] <author> UNIX Software Operations, </author> <title> UNIX System V Release 4 Programmer's Guide: STREAMS. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Message Queue is modeled after the message queueing and buffer management facilities provided by System V STREAMS <ref> [33] </ref> and BSD UNIX [34]. An ACE Message Queue is composed of one or more Message Blocks that are linked together by prev and next pointers. In addition, a Message Block may also be linked to a chain of other Message Blocks.
Reference: [34] <author> W. R. Stevens, </author> <title> TCP/IP Illustrated, </title> <booktitle> Volume 2. </booktitle> <address> Reading, Mas-sachusetts: </address> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Message Queue is modeled after the message queueing and buffer management facilities provided by System V STREAMS [33] and BSD UNIX <ref> [34] </ref>. An ACE Message Queue is composed of one or more Message Blocks that are linked together by prev and next pointers. In addition, a Message Block may also be linked to a chain of other Message Blocks.
Reference: [35] <author> D. C. Schmidt, T. H. Harrison, and E. Al-Shaer, </author> <title> Object-Oriented Components for High-speed Network Programming, </title> <booktitle> in Proceedings of the Conference on Object-Oriented Technologies, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year> <month> 31 </month>
Reference-contexts: Each client request to the server is run in parallel. This example illustrates the use of the Thread Manager and the Thread Control classes. In addition, it also illustrates the use of the ACE C++ wrapper classes for sockets <ref> [35] </ref>. The code shown below is intentionally simplified for this example and does not represent how a highly robust and ef ficient implementation would be developed. For example, a production implementation would place an upper-bound on the number of spawned bound threads to avoid consuming large amounts of kernel resources.
References-found: 35

