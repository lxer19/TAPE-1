URL: http://www.cs.umn.edu/research/shashi-group/paper_ps/ssd_95.ps
Refering-URL: http://www.cs.umn.edu/Research/shashi-group/abstract/ssd_95.abs.html
Root-URL: http://www.cs.umn.edu
Email: E-mail Phone/Fax  shekhar@cs.umn.edu siva@cs.umn.edu kumar@cs.umn.edu  greg@arl.mil  
Title: Load-Balancing in High Performance GIS: Declustering Polygonal Maps  
Author: Shashi Shekhar Sivakumar Ravada Vipin Kumar Douglas Chubb Greg Turner Shashi Shekhar Sivakumar Ravada Vipin Kumar ()-/ Douglas Chubb Greg Turner 
Keyword: High Performance, Geographic Information Systems, Range Query, Declustering Methods, Load-Balancing, Polygon Clipping  
Address: 4-192 EE/CS, 200 Union St. SE Minneapolis, MN 55455  Vint Hill Farms Station Warrenton, VA 22186-5100  Adelphi, MD  
Affiliation: Department of Computer Science University of Minnesota  Research and Technology Division U.S. Army CECOM, RDEC, IEWD  Army Research Laboratory  
Note: Author Address  
Abstract: A high performance geographic information system (GIS) is a central component of many real-time applications of spatial decision making. The GIS may contain gigabytes of geometric and feature data (e.g. location, elevation, soil type etc.) stored on a hierarchy of memory devices and represented as grids and large sets of polygons. The data is often accessed via range queries (like polygon clipping) and map-overlay queries. For example, a real-time visualization software retrieves the visible subset of GIS data around the current location of simulator via range queries retrieving a million points/second. Such performance can be obtained only with major advances in exploiting parallelism and spatial database techniques within the computational geometry algorithms for range and map overlay queries. In this paper, we develop and experimentally evaluate data partitioning and load-balancing techniques for range queries in High Performance GIS. We implement static and dynamic load-balancing methods on a distributed memory parallel machine (Cray T3D) for polygon data and experimentally evaluate their performance. Preliminary results show that both the static and dynamic load-balancing methods are necessary for improved performance but not sufficient by themselves. We propose a new quasi-dynamic load-balancing technique which achieves better load-balance and speedups than traditional methods. On 16 processors, we are able to process range queries in under 0.12 seconds for a map with 329,296 edges, where the range query size is 20-25% of the total area of the map. We are also able to achieve average speedups of 14 on 16 processors. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aggarwal, B. Chazelle, L. Guibas, C. O'Dunlaing, and C. Yap. </author> <title> Parallel computational geometry. </title> <booktitle> In Proceedings of the 25th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 468-477, </pages> <year> 1985. </year>
Reference-contexts: However, the maps used in many HP-GIS applications are at least an order of magnitude larger than these simple maps. Hence, we need more refined approaches like parallel algorithms, which deliver the required performance. Processing of GIS-range-query can be parallelized by function-partitioning <ref> [1, 2, 4] </ref> or data-partitioning [3, 7, 9, 13, 14, 20, 26, 27]. Function-partitioning uses specialized parallel data-structures and algorithms which may be different from their sequential counterparts. Data-partitioning techniques divide the spatial data (e.g. points, lines, polygons) among different processors, and independently execute the sequential algorithm on each processor.
Reference: [2] <author> S. G. Akl and K. A. Lyons. </author> <title> Parallel Computational Geometry. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, </address> <year> 1993. </year>
Reference-contexts: However, the maps used in many HP-GIS applications are at least an order of magnitude larger than these simple maps. Hence, we need more refined approaches like parallel algorithms, which deliver the required performance. Processing of GIS-range-query can be parallelized by function-partitioning <ref> [1, 2, 4] </ref> or data-partitioning [3, 7, 9, 13, 14, 20, 26, 27]. Function-partitioning uses specialized parallel data-structures and algorithms which may be different from their sequential counterparts. Data-partitioning techniques divide the spatial data (e.g. points, lines, polygons) among different processors, and independently execute the sequential algorithm on each processor.
Reference: [3] <author> M. P. Armstrong, C. E. Pavlik, and R. Marciano. </author> <title> Experiments in the measurement of spatial association using a parallel supercomputer. </title> <journal> Geographical Systems, </journal> <volume> 1 </volume> <pages> 267-288, </pages> <year> 1994. </year>
Reference-contexts: However, the maps used in many HP-GIS applications are at least an order of magnitude larger than these simple maps. Hence, we need more refined approaches like parallel algorithms, which deliver the required performance. Processing of GIS-range-query can be parallelized by function-partitioning [1, 2, 4] or data-partitioning <ref> [3, 7, 9, 13, 14, 20, 26, 27] </ref>. Function-partitioning uses specialized parallel data-structures and algorithms which may be different from their sequential counterparts. Data-partitioning techniques divide the spatial data (e.g. points, lines, polygons) among different processors, and independently execute the sequential algorithm on each processor. <p> In addition, the processors may exchange partial results during the run time. In this paper, we only focus on data-partitioning techniques. Spatial data can be partitioned and allocated statically <ref> [3, 7, 8, 9, 10, 13, 14, 17, 22, 27] </ref> or dynamically [20, 26]. Static partitioning (or declustering) and load-balancing methods divide and allocated the data prior to the computation process. In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. <p> It has been shown that customized declus-tering techniques based on space partitioning with mapping functions [8, 27], proximity based local load-balance [13, 14, 17, 22], and similarity graph-partitioning [10, 22] are needed to effectively decluster spatial data. It has been shown <ref> [3, 7, 27] </ref> that static partitioning is adequate for achieving good load-balance where work can be estimated accurately before execution-time (e.g. in case of uniformly distributed point data). The work imposed by a polygon for an arbitrary range-query cannot be estimated accurately before execution-time. <p> Memory swapping and page faults are reduced in a parallel implementation, due to the smaller amount of the data each processor has to hold. This effect often results in superlinear speedups for GIS problems, due to the high memory requirements of GIS problems <ref> [3, 7] </ref>. Hence, it is desirable to isolate and distinguish the effect of page swapping from the effect of increased computational power for clear interpretation of the results.
Reference: [4] <author> M. J. Atallah and M. T. Goodrich. </author> <title> Efficient plane sweeping in parallel. </title> <booktitle> In Proceedings of the 2nd Annual ACM Symposium on Computational Geometry, </booktitle> <pages> pages 216-225, </pages> <year> 1986. </year>
Reference-contexts: However, the maps used in many HP-GIS applications are at least an order of magnitude larger than these simple maps. Hence, we need more refined approaches like parallel algorithms, which deliver the required performance. Processing of GIS-range-query can be parallelized by function-partitioning <ref> [1, 2, 4] </ref> or data-partitioning [3, 7, 9, 13, 14, 20, 26, 27]. Function-partitioning uses specialized parallel data-structures and algorithms which may be different from their sequential counterparts. Data-partitioning techniques divide the spatial data (e.g. points, lines, polygons) among different processors, and independently execute the sequential algorithm on each processor.
Reference: [5] <author> J. L. Bentley and T. A. Ottmann. </author> <title> Algorithms for reporting and counting geometric intersections. </title> <journal> IEEE Transactions on Computers, </journal> <volume> c-28(9):643-647, </volume> <year> 1979. </year>
Reference-contexts: In this paper, we focus on parallelizing the GIS-range-query problem over a set of processors to meet the high performance requirements imposed by a typical HP-GIS. 1 1.1 Related work and Our Contributions The existing sequential solutions for the GIS-range-query problem <ref> [5, 12, 25] </ref> cannot be directly used as a solution to the GIS-range-query problem due to the high performance requirements of the application. <p> With this ordering, all the vertices above/below a given X + Y value can be determined with a single binary search operation. Alternately, plane-sweep <ref> [5, 24] </ref> can be used for computing the intersection points. Polygonization of the result from the set of intersection points, clipped vertices, and clipped line segments is performed in linear time, using a simple traversal of the vertices and intersection points in the result.
Reference: [6] <author> T. Bially. </author> <title> Space-filling curves: Their generation and their application to bandwidth reduction. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> IT-15(6):658-664, </volume> <year> 1969. </year>
Reference-contexts: We use a mapping function based on the Hilbert Space-filling curve <ref> [6, 16] </ref>. (See [27] for a survey of other mapping functions for declustering.) (2) Local load-balancing methods [22, 17] consider a sample window of space (similar to the actual range-query) at a time, and try to equally distribute the load in that window to all the processors.
Reference: [7] <author> G. Brunetti, A. Clematis, B. Falcidieno, A. Sanguineti, and M. Spagnuolo. </author> <title> Parallel processing of spatial data for terrain characterization. </title> <booktitle> In Proceedings of the ACM workshop in GIS, </booktitle> <year> 1994. </year>
Reference-contexts: However, the maps used in many HP-GIS applications are at least an order of magnitude larger than these simple maps. Hence, we need more refined approaches like parallel algorithms, which deliver the required performance. Processing of GIS-range-query can be parallelized by function-partitioning [1, 2, 4] or data-partitioning <ref> [3, 7, 9, 13, 14, 20, 26, 27] </ref>. Function-partitioning uses specialized parallel data-structures and algorithms which may be different from their sequential counterparts. Data-partitioning techniques divide the spatial data (e.g. points, lines, polygons) among different processors, and independently execute the sequential algorithm on each processor. <p> In addition, the processors may exchange partial results during the run time. In this paper, we only focus on data-partitioning techniques. Spatial data can be partitioned and allocated statically <ref> [3, 7, 8, 9, 10, 13, 14, 17, 22, 27] </ref> or dynamically [20, 26]. Static partitioning (or declustering) and load-balancing methods divide and allocated the data prior to the computation process. In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. <p> It has been shown that customized declus-tering techniques based on space partitioning with mapping functions [8, 27], proximity based local load-balance [13, 14, 17, 22], and similarity graph-partitioning [10, 22] are needed to effectively decluster spatial data. It has been shown <ref> [3, 7, 27] </ref> that static partitioning is adequate for achieving good load-balance where work can be estimated accurately before execution-time (e.g. in case of uniformly distributed point data). The work imposed by a polygon for an arbitrary range-query cannot be estimated accurately before execution-time. <p> Memory swapping and page faults are reduced in a parallel implementation, due to the smaller amount of the data each processor has to hold. This effect often results in superlinear speedups for GIS problems, due to the high memory requirements of GIS problems <ref> [3, 7] </ref>. Hence, it is desirable to isolate and distinguish the effect of page swapping from the effect of increased computational power for clear interpretation of the results.
Reference: [8] <author> H. C. Du and J. S. Sobolewski. </author> <title> Disk allocation for product files on multiple disk systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7, </volume> <month> March </month> <year> 1982. </year>
Reference-contexts: In addition, the processors may exchange partial results during the run time. In this paper, we only focus on data-partitioning techniques. Spatial data can be partitioned and allocated statically <ref> [3, 7, 8, 9, 10, 13, 14, 17, 22, 27] </ref> or dynamically [20, 26]. Static partitioning (or declustering) and load-balancing methods divide and allocated the data prior to the computation process. In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. <p> Static partitioning (or declustering) and load-balancing methods divide and allocated the data prior to the computation process. In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. It has been shown that customized declus-tering techniques based on space partitioning with mapping functions <ref> [8, 27] </ref>, proximity based local load-balance [13, 14, 17, 22], and similarity graph-partitioning [10, 22] are needed to effectively decluster spatial data.
Reference: [9] <author> W. R. Franklin et al. </author> <title> Uniform grids: A technique for intersection detection on serial and parallel machines. </title> <booktitle> In Proceedings of the 9th Conference on Automated Cartography, American Society for Photogeometry and Remote Sensing, </booktitle> <pages> pages 100-109, </pages> <year> 1989. </year>
Reference-contexts: However, the maps used in many HP-GIS applications are at least an order of magnitude larger than these simple maps. Hence, we need more refined approaches like parallel algorithms, which deliver the required performance. Processing of GIS-range-query can be parallelized by function-partitioning [1, 2, 4] or data-partitioning <ref> [3, 7, 9, 13, 14, 20, 26, 27] </ref>. Function-partitioning uses specialized parallel data-structures and algorithms which may be different from their sequential counterparts. Data-partitioning techniques divide the spatial data (e.g. points, lines, polygons) among different processors, and independently execute the sequential algorithm on each processor. <p> In addition, the processors may exchange partial results during the run time. In this paper, we only focus on data-partitioning techniques. Spatial data can be partitioned and allocated statically <ref> [3, 7, 8, 9, 10, 13, 14, 17, 22, 27] </ref> or dynamically [20, 26]. Static partitioning (or declustering) and load-balancing methods divide and allocated the data prior to the computation process. In contrast, dynamic load-balancing techniques divide and/or allocate work at run time.
Reference: [10] <author> M. T. Fang, R. C. T. Lee, and C. C. Chang. </author> <title> The idea of declustering and its applications. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1986. </year>
Reference-contexts: In addition, the processors may exchange partial results during the run time. In this paper, we only focus on data-partitioning techniques. Spatial data can be partitioned and allocated statically <ref> [3, 7, 8, 9, 10, 13, 14, 17, 22, 27] </ref> or dynamically [20, 26]. Static partitioning (or declustering) and load-balancing methods divide and allocated the data prior to the computation process. In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. <p> In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. It has been shown that customized declus-tering techniques based on space partitioning with mapping functions [8, 27], proximity based local load-balance [13, 14, 17, 22], and similarity graph-partitioning <ref> [10, 22] </ref> are needed to effectively decluster spatial data. It has been shown [3, 7, 27] that static partitioning is adequate for achieving good load-balance where work can be estimated accurately before execution-time (e.g. in case of uniformly distributed point data). <p> We use a rectangle as the sample window and balance the load in that window by considering the number of edges corresponding to that window at each processor. (3) The Similarity-graph-based approach to declustering problems is described in detail in <ref> [22, 10] </ref>.
Reference: [11] <author> Z. Fang, P.-C. Yew, P. Tang, and C.-Q.Zhu. </author> <title> Dynamic processor self-scheduling for general parallel nested loops. </title> <booktitle> In Proceedings of the International Conference in Parallel Processing, </booktitle> <month> August </month> <year> 1987. </year> <month> 16 </month>
Reference-contexts: Granularity of work division determines how much work is transferred between a donor processor and an idle processor. This granularity may depend on the size of the remaining work, the number of processors, and the accuracy in estimating the remaining work. Several strategies like self-scheduling <ref> [11] </ref>, factoring scheduling [15], and chunk scheduling [18] exist for determining the amount of work to be transferred. In case of a work transfer, the number of messages and the amount of information exchanged between the processors determines the communication overhead for that work transfer.
Reference: [12] <author> A. Guttman. R-trees: </author> <title> A dynamic index structure for spatial searching. </title> <booktitle> In Proceedings of the SIGMOD Conference, </booktitle> <pages> pages 47-57, </pages> <year> 1984. </year>
Reference-contexts: In this paper, we focus on parallelizing the GIS-range-query problem over a set of processors to meet the high performance requirements imposed by a typical HP-GIS. 1 1.1 Related work and Our Contributions The existing sequential solutions for the GIS-range-query problem <ref> [5, 12, 25] </ref> cannot be directly used as a solution to the GIS-range-query problem due to the high performance requirements of the application. <p> It then merges the lists of polygon ids from each of the cells in the computed range and returns the resulting list of polygon ids. Note that other search structures such as Range-trees [24] and R-trees <ref> [12] </ref> can also be used in place of the grid file for this approximate filtering. Intersection computation is done using a simple filter and brute force method. In the case of the GIS-range-query problem, filter and brute force approach is competitive to plane sweep and triangulation-based approaches.
Reference: [13] <author> E. G. Hoel and H. Samet. </author> <title> Data parallel r-tree algorithms. </title> <booktitle> In Proceedings of the 1993 International Conference on Parallel Processing, </booktitle> <year> 1993. </year>
Reference-contexts: However, the maps used in many HP-GIS applications are at least an order of magnitude larger than these simple maps. Hence, we need more refined approaches like parallel algorithms, which deliver the required performance. Processing of GIS-range-query can be parallelized by function-partitioning [1, 2, 4] or data-partitioning <ref> [3, 7, 9, 13, 14, 20, 26, 27] </ref>. Function-partitioning uses specialized parallel data-structures and algorithms which may be different from their sequential counterparts. Data-partitioning techniques divide the spatial data (e.g. points, lines, polygons) among different processors, and independently execute the sequential algorithm on each processor. <p> In addition, the processors may exchange partial results during the run time. In this paper, we only focus on data-partitioning techniques. Spatial data can be partitioned and allocated statically <ref> [3, 7, 8, 9, 10, 13, 14, 17, 22, 27] </ref> or dynamically [20, 26]. Static partitioning (or declustering) and load-balancing methods divide and allocated the data prior to the computation process. In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. <p> In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. It has been shown that customized declus-tering techniques based on space partitioning with mapping functions [8, 27], proximity based local load-balance <ref> [13, 14, 17, 22] </ref>, and similarity graph-partitioning [10, 22] are needed to effectively decluster spatial data. It has been shown [3, 7, 27] that static partitioning is adequate for achieving good load-balance where work can be estimated accurately before execution-time (e.g. in case of uniformly distributed point data).
Reference: [14] <author> E. G. Hoel and H. Samet. </author> <title> Performance of data-parallel spatial operations. </title> <booktitle> In Proceedings of the 20th VLDB Conference, </booktitle> <pages> pages 156-167, </pages> <year> 1994. </year>
Reference-contexts: However, the maps used in many HP-GIS applications are at least an order of magnitude larger than these simple maps. Hence, we need more refined approaches like parallel algorithms, which deliver the required performance. Processing of GIS-range-query can be parallelized by function-partitioning [1, 2, 4] or data-partitioning <ref> [3, 7, 9, 13, 14, 20, 26, 27] </ref>. Function-partitioning uses specialized parallel data-structures and algorithms which may be different from their sequential counterparts. Data-partitioning techniques divide the spatial data (e.g. points, lines, polygons) among different processors, and independently execute the sequential algorithm on each processor. <p> In addition, the processors may exchange partial results during the run time. In this paper, we only focus on data-partitioning techniques. Spatial data can be partitioned and allocated statically <ref> [3, 7, 8, 9, 10, 13, 14, 17, 22, 27] </ref> or dynamically [20, 26]. Static partitioning (or declustering) and load-balancing methods divide and allocated the data prior to the computation process. In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. <p> In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. It has been shown that customized declus-tering techniques based on space partitioning with mapping functions [8, 27], proximity based local load-balance <ref> [13, 14, 17, 22] </ref>, and similarity graph-partitioning [10, 22] are needed to effectively decluster spatial data. It has been shown [3, 7, 27] that static partitioning is adequate for achieving good load-balance where work can be estimated accurately before execution-time (e.g. in case of uniformly distributed point data).
Reference: [15] <author> S. F. Hummel, E. Schonberg, and L. E. Flynn. </author> <title> Factoring a method for scheduling parallel loops. </title> <journal> Communications of the ACM, </journal> <pages> pages 35-90, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Granularity of work division determines how much work is transferred between a donor processor and an idle processor. This granularity may depend on the size of the remaining work, the number of processors, and the accuracy in estimating the remaining work. Several strategies like self-scheduling [11], factoring scheduling <ref> [15] </ref>, and chunk scheduling [18] exist for determining the amount of work to be transferred. In case of a work transfer, the number of messages and the amount of information exchanged between the processors determines the communication overhead for that work transfer.
Reference: [16] <author> H. V. Jagadish. </author> <title> Linear clustering of objects with multiple attributes. </title> <booktitle> In Proceedings of the 1990 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 332-342, </pages> <year> 1990. </year>
Reference-contexts: We use a mapping function based on the Hilbert Space-filling curve <ref> [6, 16] </ref>. (See [27] for a survey of other mapping functions for declustering.) (2) Local load-balancing methods [22, 17] consider a sample window of space (similar to the actual range-query) at a time, and try to equally distribute the load in that window to all the processors.
Reference: [17] <author> I. Kamel and C. Faloutsos. </author> <title> Parallel r-trees. </title> <booktitle> In Proceedings of the International Conference on Management of Data, ACM SIGMOD, </booktitle> <year> 1992. </year>
Reference-contexts: In addition, the processors may exchange partial results during the run time. In this paper, we only focus on data-partitioning techniques. Spatial data can be partitioned and allocated statically <ref> [3, 7, 8, 9, 10, 13, 14, 17, 22, 27] </ref> or dynamically [20, 26]. Static partitioning (or declustering) and load-balancing methods divide and allocated the data prior to the computation process. In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. <p> In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. It has been shown that customized declus-tering techniques based on space partitioning with mapping functions [8, 27], proximity based local load-balance <ref> [13, 14, 17, 22] </ref>, and similarity graph-partitioning [10, 22] are needed to effectively decluster spatial data. It has been shown [3, 7, 27] that static partitioning is adequate for achieving good load-balance where work can be estimated accurately before execution-time (e.g. in case of uniformly distributed point data). <p> We use a mapping function based on the Hilbert Space-filling curve [6, 16]. (See [27] for a survey of other mapping functions for declustering.) (2) Local load-balancing methods <ref> [22, 17] </ref> consider a sample window of space (similar to the actual range-query) at a time, and try to equally distribute the load in that window to all the processors.
Reference: [18] <author> C. Kruskal and A. Weiss. </author> <title> Allocating independent subtasks on parallel processors. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 1001-1016, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: This granularity may depend on the size of the remaining work, the number of processors, and the accuracy in estimating the remaining work. Several strategies like self-scheduling [11], factoring scheduling [15], and chunk scheduling <ref> [18] </ref> exist for determining the amount of work to be transferred. In case of a work transfer, the number of messages and the amount of information exchanged between the processors determines the communication overhead for that work transfer.
Reference: [19] <author> V. Kumar, A. Grama, A. Gupta, and G. Karypis. </author> <title> Introduction to Parallel Computing: Design and Analysis of Algorithms. </title> <publisher> The Benjamin/Cummings Publishing Company, Inc., </publisher> <year> 1994. </year>
Reference-contexts: A message containing m words can be broadcast from a processor to P 1 other processors (one-to-all communication) in time (t s + t w m) lg P <ref> [19] </ref>. Parallel run-time T P of an algorithm on P processors includes parallel computation time and communication time. In the ideal case, parallel computation time is given by T seq =P , where T seq is the sequential run-time of the algorithm. <p> The effectiveness of a load-balancing technique is measured by the load imbalance ratio, the increase in work due to the synchronization and communication, and the non-parallelized work in the parallel implementation <ref> [19] </ref>. The load imbalance factor is defined as (1 Average work at all the processors Maximum work at any processor ) and the total overhead of a parallel implementation is defined as P T P T seq . <p> technique addresses three issues: (1) Which processor should an idle processor ask for more work, (2) How much more work should an idle processor fetch, and (3) How to contain the communication overhead? Methods to decide who should an idle processor ask for more work are discussed and analyzed in <ref> [19, 20] </ref>.
Reference: [20] <author> V. Kumar, A. Grama, and V. N. Rao. </author> <title> Scalable load balancing techniques for parallel computers. </title> <journal> Journal of Distributed Computing, </journal> <volume> 7, </volume> <month> March </month> <year> 1994. </year>
Reference-contexts: However, the maps used in many HP-GIS applications are at least an order of magnitude larger than these simple maps. Hence, we need more refined approaches like parallel algorithms, which deliver the required performance. Processing of GIS-range-query can be parallelized by function-partitioning [1, 2, 4] or data-partitioning <ref> [3, 7, 9, 13, 14, 20, 26, 27] </ref>. Function-partitioning uses specialized parallel data-structures and algorithms which may be different from their sequential counterparts. Data-partitioning techniques divide the spatial data (e.g. points, lines, polygons) among different processors, and independently execute the sequential algorithm on each processor. <p> In addition, the processors may exchange partial results during the run time. In this paper, we only focus on data-partitioning techniques. Spatial data can be partitioned and allocated statically [3, 7, 8, 9, 10, 13, 14, 17, 22, 27] or dynamically <ref> [20, 26] </ref>. Static partitioning (or declustering) and load-balancing methods divide and allocated the data prior to the computation process. In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. <p> technique addresses three issues: (1) Which processor should an idle processor ask for more work, (2) How much more work should an idle processor fetch, and (3) How to contain the communication overhead? Methods to decide who should an idle processor ask for more work are discussed and analyzed in <ref> [19, 20] </ref>.
Reference: [21] <author> Y. Liang and B. A. Barsky. </author> <title> An analysis and algorithm for polygon clipping. </title> <journal> Communications of the ACM, </journal> <volume> 26, </volume> <month> November </month> <year> 1983. </year>
Reference-contexts: We call this problem the GIS-range-query problem. Note that the GIS-range-query problem is similar to the polygon-clipping problem <ref> [21] </ref> in computer graphics. <p> If each vertex (or intersection-point) is associated with its next and previous nodes, traversing these nodes in counter-clockwise order gives the resulting polygon. Alternative approaches for polygonization are presented in <ref> [21, 25] </ref>. 2.2 Cost model We characterize the main components of the sequential algorithm which mainly dominate the computation cost, using a simplified cost model.
Reference: [22] <author> D. R. Liu and S. Shekhar. </author> <title> A similarity graph-based approach to declustering problem and its applications. </title> <booktitle> In Proceedings of the Eleventh International Conference on Data Engineering, IEEE, </booktitle> <year> 1995. </year>
Reference-contexts: In addition, the processors may exchange partial results during the run time. In this paper, we only focus on data-partitioning techniques. Spatial data can be partitioned and allocated statically <ref> [3, 7, 8, 9, 10, 13, 14, 17, 22, 27] </ref> or dynamically [20, 26]. Static partitioning (or declustering) and load-balancing methods divide and allocated the data prior to the computation process. In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. <p> In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. It has been shown that customized declus-tering techniques based on space partitioning with mapping functions [8, 27], proximity based local load-balance <ref> [13, 14, 17, 22] </ref>, and similarity graph-partitioning [10, 22] are needed to effectively decluster spatial data. It has been shown [3, 7, 27] that static partitioning is adequate for achieving good load-balance where work can be estimated accurately before execution-time (e.g. in case of uniformly distributed point data). <p> In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. It has been shown that customized declus-tering techniques based on space partitioning with mapping functions [8, 27], proximity based local load-balance [13, 14, 17, 22], and similarity graph-partitioning <ref> [10, 22] </ref> are needed to effectively decluster spatial data. It has been shown [3, 7, 27] that static partitioning is adequate for achieving good load-balance where work can be estimated accurately before execution-time (e.g. in case of uniformly distributed point data). <p> Usually, terrain data (which is a set of polygons) has non-uniform distribution and variable size polygons, which makes it difficult to develop a strategy that will be optimal for all queries. It is known that the declustering problem is NP-hard even for point data <ref> [22] </ref>. Several heuristic methods that have been proposed in the literature for solving the declustering problem for point data are based on the ideas of space partitioning with mapping functions, local load-balance methods, and similarity-based methods [22]. <p> It is known that the declustering problem is NP-hard even for point data <ref> [22] </ref>. Several heuristic methods that have been proposed in the literature for solving the declustering problem for point data are based on the ideas of space partitioning with mapping functions, local load-balance methods, and similarity-based methods [22]. We define a polygon-to-point transformation function and use point-based static-declustering methods for declustering the polygon data. <p> We use a mapping function based on the Hilbert Space-filling curve [6, 16]. (See [27] for a survey of other mapping functions for declustering.) (2) Local load-balancing methods <ref> [22, 17] </ref> consider a sample window of space (similar to the actual range-query) at a time, and try to equally distribute the load in that window to all the processors. <p> We use a rectangle as the sample window and balance the load in that window by considering the number of edges corresponding to that window at each processor. (3) The Similarity-graph-based approach to declustering problems is described in detail in <ref> [22, 10] </ref>.
Reference: [23] <author> J. Nievergelt, H. Hinterberger, and K. D. Sevcik. </author> <title> The grid file: An adaptable, symmetric multikey file structure. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(1) </volume> <pages> 38-71, </pages> <year> 1984. </year>
Reference-contexts: Approximate filtering is carried out by a multi-dimensional search structure such as the grid file <ref> [23] </ref>, which is used as an indexing method for spatial data. We simplify the grid file discussed in [23] for the main memory environment and an example grid file for this environment is given in Figure 3. The space partitioning for the polygons is shown in Figure 3 (a). <p> Approximate filtering is carried out by a multi-dimensional search structure such as the grid file <ref> [23] </ref>, which is used as an indexing method for spatial data. We simplify the grid file discussed in [23] for the main memory environment and an example grid file for this environment is given in Figure 3. The space partitioning for the polygons is shown in Figure 3 (a).
Reference: [24] <author> F. P. Preparata and M. I. Shamos. </author> <title> Computational Geometry. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: It then merges the lists of polygon ids from each of the cells in the computed range and returns the resulting list of polygon ids. Note that other search structures such as Range-trees <ref> [24] </ref> and R-trees [12] can also be used in place of the grid file for this approximate filtering. Intersection computation is done using a simple filter and brute force method. In the case of the GIS-range-query problem, filter and brute force approach is competitive to plane sweep and triangulation-based approaches. <p> With this ordering, all the vertices above/below a given X + Y value can be determined with a single binary search operation. Alternately, plane-sweep <ref> [5, 24] </ref> can be used for computing the intersection points. Polygonization of the result from the set of intersection points, clipped vertices, and clipped line segments is performed in linear time, using a simple traversal of the vertices and intersection points in the result.
Reference: [25] <author> B. R. Vatti. </author> <title> A generic solution to polygon clipping. </title> <journal> Communications of the ACM, </journal> <volume> 35, </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: In this paper, we focus on parallelizing the GIS-range-query problem over a set of processors to meet the high performance requirements imposed by a typical HP-GIS. 1 1.1 Related work and Our Contributions The existing sequential solutions for the GIS-range-query problem <ref> [5, 12, 25] </ref> cannot be directly used as a solution to the GIS-range-query problem due to the high performance requirements of the application. <p> If each vertex (or intersection-point) is associated with its next and previous nodes, traversing these nodes in counter-clockwise order gives the resulting polygon. Alternative approaches for polygonization are presented in <ref> [21, 25] </ref>. 2.2 Cost model We characterize the main components of the sequential algorithm which mainly dominate the computation cost, using a simplified cost model.
Reference: [26] <author> F. Wang. </author> <title> A parallel intersection algorithm for vector polygon overlay. </title> <journal> IEEE Computer Graphics & Applications, </journal> <month> March </month> <year> 1993. </year>
Reference-contexts: However, the maps used in many HP-GIS applications are at least an order of magnitude larger than these simple maps. Hence, we need more refined approaches like parallel algorithms, which deliver the required performance. Processing of GIS-range-query can be parallelized by function-partitioning [1, 2, 4] or data-partitioning <ref> [3, 7, 9, 13, 14, 20, 26, 27] </ref>. Function-partitioning uses specialized parallel data-structures and algorithms which may be different from their sequential counterparts. Data-partitioning techniques divide the spatial data (e.g. points, lines, polygons) among different processors, and independently execute the sequential algorithm on each processor. <p> In addition, the processors may exchange partial results during the run time. In this paper, we only focus on data-partitioning techniques. Spatial data can be partitioned and allocated statically [3, 7, 8, 9, 10, 13, 14, 17, 22, 27] or dynamically <ref> [20, 26] </ref>. Static partitioning (or declustering) and load-balancing methods divide and allocated the data prior to the computation process. In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. <p> The work imposed by a polygon for an arbitrary range-query cannot be estimated accurately before execution-time. Thus, both static and dynamic load-balancing is needed for parallelizing range queries on polygonal maps <ref> [26] </ref>. In this paper, we develop and experimentally evaluate data-partitioning and load-balancing techniques for range queries on polygonal maps. Specifically, we extend three declustering methods that were developed for point data to polygon data, and then we experimentally measure their performance for the current problem. <p> Type IV schemes divide both the areas and the edges of individual polygons and the bounding box. The potential advantage of type III and IV schemes over type II scheme is the possibility of better load-balancing and lower processor idling, resulting in reduced parallel computation time <ref> [26] </ref>. However, note that types III and IV schemes result either in increased total work or in increased work for polygonization of the result.
Reference: [27] <author> Y. Zhou, S. Shekhar, and M. Coyle. </author> <title> Disk allocation methods for parallelizing grid files. </title> <booktitle> In Proceedings of the Tenth International Conference on Data Engineering, IEEE, </booktitle> <year> 1994. </year> <month> 17 </month>
Reference-contexts: However, the maps used in many HP-GIS applications are at least an order of magnitude larger than these simple maps. Hence, we need more refined approaches like parallel algorithms, which deliver the required performance. Processing of GIS-range-query can be parallelized by function-partitioning [1, 2, 4] or data-partitioning <ref> [3, 7, 9, 13, 14, 20, 26, 27] </ref>. Function-partitioning uses specialized parallel data-structures and algorithms which may be different from their sequential counterparts. Data-partitioning techniques divide the spatial data (e.g. points, lines, polygons) among different processors, and independently execute the sequential algorithm on each processor. <p> In addition, the processors may exchange partial results during the run time. In this paper, we only focus on data-partitioning techniques. Spatial data can be partitioned and allocated statically <ref> [3, 7, 8, 9, 10, 13, 14, 17, 22, 27] </ref> or dynamically [20, 26]. Static partitioning (or declustering) and load-balancing methods divide and allocated the data prior to the computation process. In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. <p> Static partitioning (or declustering) and load-balancing methods divide and allocated the data prior to the computation process. In contrast, dynamic load-balancing techniques divide and/or allocate work at run time. It has been shown that customized declus-tering techniques based on space partitioning with mapping functions <ref> [8, 27] </ref>, proximity based local load-balance [13, 14, 17, 22], and similarity graph-partitioning [10, 22] are needed to effectively decluster spatial data. <p> It has been shown that customized declus-tering techniques based on space partitioning with mapping functions [8, 27], proximity based local load-balance [13, 14, 17, 22], and similarity graph-partitioning [10, 22] are needed to effectively decluster spatial data. It has been shown <ref> [3, 7, 27] </ref> that static partitioning is adequate for achieving good load-balance where work can be estimated accurately before execution-time (e.g. in case of uniformly distributed point data). The work imposed by a polygon for an arbitrary range-query cannot be estimated accurately before execution-time. <p> We use a mapping function based on the Hilbert Space-filling curve [6, 16]. (See <ref> [27] </ref> for a survey of other mapping functions for declustering.) (2) Local load-balancing methods [22, 17] consider a sample window of space (similar to the actual range-query) at a time, and try to equally distribute the load in that window to all the processors.
References-found: 27

