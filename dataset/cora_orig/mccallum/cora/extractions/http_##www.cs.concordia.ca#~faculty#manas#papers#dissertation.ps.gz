URL: http://www.cs.concordia.ca/~faculty/manas/papers/dissertation.ps.gz
Refering-URL: http://www.cs.concordia.ca/~faculty/manas/research/sel-pubs.html
Root-URL: http://www.cs.concordia.ca
Title: Parametric Scheduling for Hard Real-Time Systems  
Degree: Manas Chandra Saksena, Doctor of Philosophy, 1994 Dissertation directed by: Professor Ashok K. Agrawala, and Assistant Professor Richard Gerber  
Affiliation: Department of Computer Science  
Note: Abstract Title of Dissertation:  
Abstract: In this dissertation we address the problem of scheduling real-time tasks with inter-task temporal dependencies. While such constraints occur frequently in timing specifications, they have not received much attention in scheduling theory. In the presence of such constraints, a strategy to create a schedule based on maximum execution times is often not adequate, and one must account for the variation in execution times of tasks. We address this issue by developing the notion of parametric scheduling, in which a schedule adapts itself to varying execution times. This is achieved by creating dispatch functions for tasks, which give the start time of a task as a function of the start and execution times of previous tasks in the schedule. The parametric scheduling paradigm improves upon the traditional time-driven approach by providing better support for complex timing constraints, as well as by giving the run-time dispatcher flexibility to manage "spare" time. We tackle the problem by decomposing it into three parts: (i) a parametric scheduler for totally ordered task sets, (ii) an order generator, and (iii) a pre-processor. The parametric scheduler generates the dispatch functions used by run-time dispatcher for an ordered set of tasks. We show that the dispatch functions can be generated efficiently, and that the run-time dispatching overhead is small for realistic constraints. The ordering of the tasks is created by the order-generator which uses deterministic scheduling for this purpose. Since the problem of deterministic scheduling for arbitrary, unordered task sets is NP-Hard, we develop a technique to pre-process the timing constraints so as to prune infeasible parts of the search space. We also develop complexity results and algorithms for the special case of merging two sequential task sets, which is useful 
Abstract-found: 1
Intro-found: 1
Reference: [ABRW91] <author> N. C. Audsley, A. Burns, M. F. Richardson, and A. J. Wellings. </author> <title> Hard Real-Time Scheduling: The Deadline Monotonic Approach. </title> <booktitle> In Proceedings Eighth IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 133-137, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: The seminal 11 work in [LL73] showed that for a set of independent periodic real-time tasks with deadlines at the end of the periods, the rate monotonic priority assignment is optimal among all static priority schemes. Since then several extensions have been proposed <ref> [LSST90, HKL91, ABRW91, Tin92, Bur93, TBW94] </ref> to relax many of the assumptions about the constraints permissible in the basic rate monotonic scheme. When tasks synchronize using shared resources, priority inversion may occur. Priority inversion occurs when a high priority process is blocked for by a lower priority processes.
Reference: [Bak90] <author> T. P. Baker. </author> <title> A Stack-Based Resource Allocation Policy for RealTime Processes. </title> <booktitle> In Proceedings, IEEE Real-Time Systems Symposium, </booktitle> <year> 1990. </year>
Reference-contexts: Furthermore, access to a critical section may be deferred to avoid deadlocks. Examples of such protocols are the basic priority inheritance protocol and priority ceiling protocol [SRL90], ceiling semaphore protocol [RSL89], semaphore control protocol [RSLR88] and stack resource protocol <ref> [Bak90] </ref>. Various extensions of fixed priority scheduling have been proposed to handle aperiodic tasks [SSL89]. A periodic server is used as a pseudo task to serve aperiodic requests. A class of algorithms called bandwidth preserving algorithms have been proposed which overcome the limitations of a polling scheme. <p> The conditions can be reduced to the cases when arbitrary preemption is allowed or when no preemption is allowed. The dynamic priority ceiling protocol [CL90] and stack resource protocol <ref> [Bak90] </ref> have been devised for use in conjunction with earliest deadline approach to avert priority inversion problems. 2.1.4 Scheduling with Relative Constraints None of the abovementioned schemes provide support for relative constraints, which distinguish the scheduling problem considered in this dissertation.
Reference: [BFR71] <author> P. Bratley, M. Florian, and P. Robillard. </author> <title> Scheduling with Earliest Start and Due Date Constraints. </title> <journal> Naval. Res. Log. Quart., </journal> <volume> 18 </volume> <pages> 511-519, </pages> <month> Dec. </month> <year> 1971. </year>
Reference-contexts: Since the search complexity is large, researchers have resorted to various heuristics to reduce the search effort, and thereby make the search feasible in practice. Branch and bound search is commonly used for optimal scheduling. A frequent way to represent the search space <ref> [BS74, BFR71, BFR75, FK89, Ram90, ZRS87, ZR87, VLHJ91] </ref> is to use a search tree in which the root (level 0) node represents an empty schedule, while each node at level k corresponds to a partial schedule containing k tasks. <p> For each node being expanded, the following conditions must hold. 1. All immediate extensions of the node must be feasible <ref> [BFR71, ZRS87] </ref>. 2. The remaining computational demand must not exceed the difference between the largest deadline of remaining tasks and current scheduling time [ZRS87]. If any condition is violated then no feasible schedule can be generated in the subtree originating from this node.
Reference: [BFR75] <author> P. Bratley, M. Florian, and P. Robillard. </author> <title> Scheduling with Earliest Start and Due Date Constraints on Multiple Machines. </title> <journal> Naval. Res. Log. Quart., </journal> <volume> 22 </volume> <pages> 165-173, </pages> <year> 1975. </year>
Reference-contexts: Since the search complexity is large, researchers have resorted to various heuristics to reduce the search effort, and thereby make the search feasible in practice. Branch and bound search is commonly used for optimal scheduling. A frequent way to represent the search space <ref> [BS74, BFR71, BFR75, FK89, Ram90, ZRS87, ZR87, VLHJ91] </ref> is to use a search tree in which the root (level 0) node represents an empty schedule, while each node at level k corresponds to a partial schedule containing k tasks.
Reference: [BS74] <author> K. R. Baker and Z. Su. </author> <title> Sequencing with Due-Date and Early Start Times to Minimize Maximum Tardiness. </title> <journal> Naval Res. Log. Quart., </journal> <volume> 21 </volume> <pages> 171-176, </pages> <year> 1974. </year>
Reference-contexts: Since the search complexity is large, researchers have resorted to various heuristics to reduce the search effort, and thereby make the search feasible in practice. Branch and bound search is commonly used for optimal scheduling. A frequent way to represent the search space <ref> [BS74, BFR71, BFR75, FK89, Ram90, ZRS87, ZR87, VLHJ91] </ref> is to use a search tree in which the root (level 0) node represents an empty schedule, while each node at level k corresponds to a partial schedule containing k tasks.
Reference: [BS89] <author> T. Baker and A. Shaw. </author> <title> The Cyclic Executive Model and Ada. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 1(1) </volume> <pages> 7-25, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: A special class of real-time systems, termed hard real-time systems, require that the timing constraints be guaranteed prior to execution, since the result of a timing failure may lead to unstable or undesirable system behavior. Many real-time systems are constructed using a cyclic executive model <ref> [BS89, Jor90] </ref> in which the application tasks are dispatched following a fixed periodic schedule. The schedule, also termed a calendar, is represented as a table which lists the tasks and their start times, which are constant offsets from the start of the cycle.
Reference: [Bur91] <author> A. Burns. </author> <title> Scheduling Hard Real-Time Systems: A Review. </title> <journal> Software Engineering Journal, </journal> <volume> 6(3) </volume> <pages> 116-128, </pages> <year> 1991. </year>
Reference-contexts: Similarly, non-preemptive disciplines 10 may allow limited preemption (e.g., at clock ticks) to increase schedulability. Most time based schedulers belong to this class. A significant amount of work has been carried out in real-time scheduling, and several reviews have also been published <ref> [CSR88, Bur91, XP91, RS94] </ref>. Here, we briefly review some of the previous work in real-time scheduling. 2.1.1 Time-Driven Scheduling In time-driven scheduling, a scheduling table is created which maps the tasks to their start times on the timeline.
Reference: [Bur93] <author> A. Burns. </author> <title> Fixed Priority Scheduling with Deadlines Prior to Completion. </title> <type> Technical Report YCS 212 (1993), </type> <institution> Department of Computer Science, University of York, </institution> <address> England, </address> <month> October </month> <year> 1993. </year> <month> 87 </month>
Reference-contexts: The seminal 11 work in [LL73] showed that for a set of independent periodic real-time tasks with deadlines at the end of the periods, the rate monotonic priority assignment is optimal among all static priority schemes. Since then several extensions have been proposed <ref> [LSST90, HKL91, ABRW91, Tin92, Bur93, TBW94] </ref> to relax many of the assumptions about the constraints permissible in the basic rate monotonic scheme. When tasks synchronize using shared resources, priority inversion may occur. Priority inversion occurs when a high priority process is blocked for by a lower priority processes.
Reference: [CC89] <author> H. Chetto and M. Chetto. </author> <title> Some Results of the Earliest Deadline First Algorithm. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-15(10):1261-1269, </volume> <month> October </month> <year> 1989. </year>
Reference-contexts: For a set of independent periodic tasks, a necessary and sufficient con 12 dition for schedulability is that the processor utilization should be less than 100% [LL73]. The schedulability tests have been extended for online determination of schedulability, when a new task arrives. Chetto <ref> [CC89] </ref> devised algorithms to determine feasibility of an arriving sporadic task, and the result has been extended for tasks with precedence constraints [CSB90].
Reference: [CL90] <author> M. Chen and K. Lin. </author> <title> Dynamic Priority Ceilings: A Concur-rency Control Protocol for Real-Time Systems. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 2(4) </volume> <pages> 325-346, </pages> <year> 1990. </year>
Reference-contexts: The conditions can be reduced to the cases when arbitrary preemption is allowed or when no preemption is allowed. The dynamic priority ceiling protocol <ref> [CL90] </ref> and stack resource protocol [Bak90] have been devised for use in conjunction with earliest deadline approach to avert priority inversion problems. 2.1.4 Scheduling with Relative Constraints None of the abovementioned schemes provide support for relative constraints, which distinguish the scheduling problem considered in this dissertation.
Reference: [Cof76] <author> E. G. Coffman. </author> <title> Computer and Job-Shop Scheduling Theory, </title> <editor> Ed. </editor> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1976. </year>
Reference-contexts: The result of traditional static scheduling is a table, which gives the start time assignment for each task in their order of execution. This table is used at run-time by the dispatcher to dispatch tasks at their pre-assigned start times. Static scheduling is usually done using deterministic techniques <ref> [Cof76, Gon77] </ref> in which the execution time of each task is assumed to be a constant. For real-time scheduling, even though the execution times are not constants, it usually suffices to use the maximum execution time (u i ) as the "worst case" execution time for each task.
Reference: [CSB90] <author> H. Chetto, M. Silly, and T. Bouchentouf. </author> <title> Dynamic Scheduling of Real-Time Tasks under Precedence Constraints. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 2 </volume> <pages> 181-194, </pages> <year> 1990. </year>
Reference-contexts: The schedulability tests have been extended for online determination of schedulability, when a new task arrives. Chetto [CC89] devised algorithms to determine feasibility of an arriving sporadic task, and the result has been extended for tasks with precedence constraints <ref> [CSB90] </ref>. Schedulability tests for a set of tasks competing for the processor at any instance of time were derived in [Hal90], when tasks may execute non-preemptively in critical regions. The conditions can be reduced to the cases when arbitrary preemption is allowed or when no preemption is allowed.
Reference: [CSR88] <author> S. C. Cheng, J. A. Stankovic, and K. Ramamritham. </author> <title> Scheduling algorithms for hard real-time systems | a brief survey. In Tutorial Hard Real-Time Systems. </title> <publisher> IEEE Publications, </publisher> <year> 1988. </year>
Reference-contexts: Similarly, non-preemptive disciplines 10 may allow limited preemption (e.g., at clock ticks) to increase schedulability. Most time based schedulers belong to this class. A significant amount of work has been carried out in real-time scheduling, and several reviews have also been published <ref> [CSR88, Bur91, XP91, RS94] </ref>. Here, we briefly review some of the previous work in real-time scheduling. 2.1.1 Time-Driven Scheduling In time-driven scheduling, a scheduling table is created which maps the tasks to their start times on the timeline.
Reference: [Das85] <author> B. Dasarathy. </author> <title> Timing Constraints of Real-Time Systems: Constructs for Expressing Them, Methods of Validating Them. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(1):80-86, </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: Timing specifications are event-based, and they establish many such minimum and maximum temporal distance constraints between occurrences of events <ref> [Das85, JM86, LW92] </ref>. To facilitate scheduling, a real-time program may be broken down into scheduling units termed as tasks, where each task corresponds to some segment of program code. The task boundaries (i.e., the start and finish time) serve as temporal markers on which the timing constraints can be enforced. <p> Finally, in [WDL91], a dynamic scheduling scheme based has been presented for hierarchical relative constraints; however, the scheme is not intended to provide o*ine guarantees. 2.2 Specification and Programming Languages The specification languages are used for high level specification of timing and functional requirements for real-time applications. Dasrathy <ref> [Das85] </ref> identified three types of timing constraints as useful for real-time systems. * Maximum: No more than t amount of time may elapse between the occur rence of two events. 13 * Minimum: No less than t amount of time may elapse between the occur- rence of two events. * Durational:
Reference: [DE73] <author> G. B. Dantzig and B. C. Eaves. </author> <title> Fourier-Motzkin Elimination and its Dual. </title> <journal> Journal of Combinatorial Theory (A), </journal> <volume> 14 </volume> <pages> 288-297, </pages> <year> 1973. </year>
Reference: [Der74] <author> M. Dertouzos. </author> <title> Control Robotics: the Procedural Control of Physical Processes. </title> <booktitle> Proceedings of the IFIP Congress, </booktitle> <pages> pages 807-813, </pages> <year> 1974. </year>
Reference-contexts: It is optimal in the sense that if a set of tasks can be feasibly scheduled by any scheduling algorithm, then it can also be feasibly scheduled by the earliest deadline first algorithm. It is also known to be optimal for a set of independent aperiodic tasks <ref> [Der74] </ref>. For a set of independent periodic tasks, a necessary and sufficient con 12 dition for schedulability is that the processor utilization should be less than 100% [LL73]. The schedulability tests have been extended for online determination of schedulability, when a new task arrives.
Reference: [DM89] <author> M. L. Dertouzos and A. K. Mok. </author> <title> Multiprocessor On-Line Scheduling of Hard Real-Time Tasks. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(12) </volume> <pages> 1497-1506, </pages> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: While the problem of guaranteeing timing constraints in hard real-time systems has received significant attention, few techniques have addressed the problem of guaranteeing inter-task temporal dependencies such as relative constraints. Most real-time scheduling techniques consider the scheduling of real-time tasks with ready times and deadlines <ref> [DM89, FK89, XP90, Ram90, SG91, VLHJ91, HKL91, TBW94] </ref>. These constraints impose constant intervals in which a task must be executed. In contrast, in the presence of relative constraints, the time window within which a task must execute may depend on the scheduling of the other tasks in the system.
Reference: [DMP91] <author> R. Dechter, I. Meiri, and J. Pearl. </author> <title> Temporal constraint networks. </title> <journal> Artificial Intelligence, </journal> <volume> 49 </volume> <pages> 61-95, </pages> <year> 1991. </year>
Reference-contexts: In this section we show how temporal analysis can be implemented when relative constraints are present in the task set as well. For this purpose, we use a constraint graph representation <ref> [DMP91] </ref> of the timing constraints as described below: 6.3.1 Constraint Graph Representation We use a constraint graph representation for the timing constraints. The constraint graph has been used for various temporal constraint problems, and provides a compact and convenient representation for standard constraints. <p> In particular, if the constraint graph has a negative cycle then there is no solution to the set of constraints. This result is useful in determining infeasibility of task sets as the following result (paraphrased from <ref> [DMP91] </ref>) shows: Theorem 6.1 A task set if unschedulable if there exists a negative cycle in its constraint graph. Note that while the constraint graph can be used to check for infeasibility, the lack of negative cycles does not imply that the task set is schedulable.
Reference: [DRSK89] <author> A. Damm, J. Reisinger, W. Schwabl, and H. Kopetz. </author> <title> The Real-Time Operating System of MARS. </title> <journal> ACM SIGOPS, Operating Systems Review, </journal> <volume> 23(3) </volume> <pages> 141-157, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: While cyclic executives have traditionally been built with minimal operating system functionality, recently several experimental operating systems have adopted a generalized cyclic scheduling model to guarantee critical hard real-time tasks. Prominent among these systems are MARS <ref> [DRSK89] </ref>, Maruti [SdSA94], and the Spring Kernel [SR89]. Critical tasks in these systems are scheduled using a static scheduling approach following a time-driven resource management model. In the time-driven model, resources are explicitly reserved prior to execution.
Reference: [EFMR83] <author> J. Erschler, G. Fontan, C. Merce, and F. Roubellat. </author> <title> A New Dominance Concept in Scheduling n Jobs on a Single Machine with Ready 88 Times and Due Dates. </title> <journal> Operations Research, </journal> <volume> 31(1) </volume> <pages> 114-127, </pages> <month> Jan. </month> <year> 1983. </year>
Reference-contexts: Yet, another approach is the decomposition approach using sequence scheduling [YSA94]. In this scheme a task set is decomposed into a sequence of subsets, and then each subset is scheduled independently for minimal length. The decomposition is based on dominance properties of sequences which extends the initial work of <ref> [EFMR83] </ref>. 2.1.2 Static Priority Scheduling In static priority schemes, a schedulability condition (or more generally an algorithmic test) is developed to see whether a given fixed priority assignment will result in the satisfaction of constraints under all situations. <p> The rationale behind the approach is that we can reduce the search time significantly by efficiently pruning the search space through simple analysis of timing constraints. The technique proposed in this chapter is in the same vein as the ideas presented in <ref> [EFMR83] </ref> and [YSA94], which are based on dominance properties of schedules. In [EFMR83], the notion of dominance is introduced (see Chapter 5) to eliminate task sequences which are dominated by some other sequence. In this manner, an effectively pruned search space is created. <p> The technique proposed in this chapter is in the same vein as the ideas presented in <ref> [EFMR83] </ref> and [YSA94], which are based on dominance properties of schedules. In [EFMR83], the notion of dominance is introduced (see Chapter 5) to eliminate task sequences which are dominated by some other sequence. In this manner, an effectively pruned search space is created.
Reference: [FK89] <author> G. Fohler and C. Koza. </author> <title> Heuristic Scheduling for Distributed Real-Time Systems. </title> <type> MARS 6/89, </type> <institution> Technische Universitat Wien, Vienna, Austria, </institution> <month> April </month> <year> 1989. </year>
Reference-contexts: While the problem of guaranteeing timing constraints in hard real-time systems has received significant attention, few techniques have addressed the problem of guaranteeing inter-task temporal dependencies such as relative constraints. Most real-time scheduling techniques consider the scheduling of real-time tasks with ready times and deadlines <ref> [DM89, FK89, XP90, Ram90, SG91, VLHJ91, HKL91, TBW94] </ref>. These constraints impose constant intervals in which a task must be executed. In contrast, in the presence of relative constraints, the time window within which a task must execute may depend on the scheduling of the other tasks in the system. <p> Since the search complexity is large, researchers have resorted to various heuristics to reduce the search effort, and thereby make the search feasible in practice. Branch and bound search is commonly used for optimal scheduling. A frequent way to represent the search space <ref> [BS74, BFR71, BFR75, FK89, Ram90, ZRS87, ZR87, VLHJ91] </ref> is to use a search tree in which the root (level 0) node represents an empty schedule, while each node at level k corresponds to a partial schedule containing k tasks.
Reference: [GHS94] <author> R. Gerber, S. Hong, and M. Saksena. </author> <title> Guaranteeing End-to-End Timing Constraints by Calibrating Intermediate Processes. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <year> 1994. </year> <note> Also available as University of Maryland CS-TR-3274, UMIACS-TR-94-58. </note>
Reference: [GJ79] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability, a Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman Company, </publisher> <address> San Francisco, </address> <year> 1979. </year>
Reference-contexts: Prior to this dissertation, all schemes have used constant start time assignments to tasks. The scheduling is done deterministically using worst case execution times for tasks, which is NP-Hard for almost all interesting cases <ref> [GJ79] </ref>. Thus most scheduling algorithms use implicit enumeration methods to search for a feasible schedule. Since the search complexity is large, researchers have resorted to various heuristics to reduce the search effort, and thereby make the search feasible in practice. Branch and bound search is commonly used for optimal scheduling. <p> The problem of creating a non-preemptive schedule for an arbitrary task set with standard constraints is clearly NP-Hard, as it subsumes the simpler problem of scheduling with ready times and deadlines, which itself is NP-Complete <ref> [GJ79] </ref>. Moreover, the presence of relative constraints renders even the preemptive version of the problem NP-Hard. This is in contrast to preemptive scheduling with ready times and deadlines, which has an efficient polynomial time solution [GJ79]. This result is shown in the following theorem. <p> subsumes the simpler problem of scheduling with ready times and deadlines, which itself is NP-Complete <ref> [GJ79] </ref>. Moreover, the presence of relative constraints renders even the preemptive version of the problem NP-Hard. This is in contrast to preemptive scheduling with ready times and deadlines, which has an efficient polynomial time solution [GJ79]. This result is shown in the following theorem. Theorem 3.1 Preemptive scheduling with standard constraints is NP-Hard. Proof: The theorem is proved by a reduction from the problem of non-preemptive scheduling with ready times and deadlines. <p> Is there a 44 polynomial-time algorithm that will generate a feasible ordering if and only if such an ordering exists? In this section, we show that the answer to this question is "no" by proving the problem to be NP-Complete. This is done by a reduction from Partition <ref> [GJ79] </ref>, which is often used for proving NP-Completeness of non-preemptive scheduling problems. Unfortunately, the usual reduction methods require unordered task sets, a characteristic absent in our scheduling problem. We develop a novel transformation from the partitioning problem to prove our result.
Reference: [GL89] <author> R. Gerber and I. Lee. </author> <title> Communicating Shared Resources: A model for distributed real-time systems. </title> <booktitle> In Proceedings of the 12th IEEE Real-time Systems Symposium, </booktitle> <pages> pages 68-78, </pages> <address> Santa Monica, Califor-nia, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: When such event based constraints are mapped to tasks, they often emerge as relative constraints | those which constrain the temporal distance between two tasks. Many real-time programming languages (e.g., DPS [LG85], RTC [WDL91], MPL [NTA90], CSR <ref> [GL89] </ref>, Flex [LN88], and TCEL [HG93a]) provide constructs 1 which allow the programmer to express relative constraints. However, it is one thing to simply write a real-time program, and quite another to ensure its desired execution behavior.
Reference: [Gon77] <author> M. J. Gonzalez. </author> <title> Deterministic Processor Scheduling. </title> <journal> Computing Surveys, </journal> <volume> 9(3) </volume> <pages> 173-204, </pages> <month> September </month> <year> 1977. </year>
Reference-contexts: The result of traditional static scheduling is a table, which gives the start time assignment for each task in their order of execution. This table is used at run-time by the dispatcher to dispatch tasks at their pre-assigned start times. Static scheduling is usually done using deterministic techniques <ref> [Cof76, Gon77] </ref> in which the execution time of each task is assumed to be a constant. For real-time scheduling, even though the execution times are not constants, it usually suffices to use the maximum execution time (u i ) as the "worst case" execution time for each task.
Reference: [GPS] <author> R. Gerber, W. Pugh, and M. Saksena. </author> <title> Parametric Dispatching of Hard Real-Time Tasks. </title> <journal> IEEE Transactions on Computers. </journal> <note> To appear. </note>
Reference: [Hal90] <author> W. A. Halang. </author> <title> A Practical Approach to Pre-emptable and Non-Pre-emptable Task Scheduling with Resource Constraints based on Earliest Deadlines. </title> <booktitle> In Proceeding EUROMICRO'90 Workshop on Real Time, </booktitle> <pages> pages 2-7. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: Chetto [CC89] devised algorithms to determine feasibility of an arriving sporadic task, and the result has been extended for tasks with precedence constraints [CSB90]. Schedulability tests for a set of tasks competing for the processor at any instance of time were derived in <ref> [Hal90] </ref>, when tasks may execute non-preemptively in critical regions. The conditions can be reduced to the cases when arbitrary preemption is allowed or when no preemption is allowed.
Reference: [HBW92] <author> M. G. Harmon, T. P. Baker, and D. B. Whalley. </author> <title> A Retargetable Technique for Predicting Execution Time. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 68-77. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1992. </year>
Reference-contexts: Usually one only has a priori upper and lower bounds, which can be generated by timing tools <ref> [ZBN93, HBW92, PK89, Sha89] </ref>. In such a scenario, the use of a static start time assignment which must satisfy the constraints under all execution behaviors results in unnecessary pessimism and inflexibility.
Reference: [HG93a] <author> S. Hong and R. Gerber. </author> <title> Compiling real-time programs into schedu-lable code. </title> <booktitle> In Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation. </booktitle> <publisher> ACM Press, </publisher> <month> June </month> <year> 1993. </year> <journal> SIGPLAN Notices, </journal> <volume> 28(6) </volume> <pages> 166-176. 89 </pages>
Reference-contexts: The task boundaries (i.e., the start and finish time) serve as temporal markers on which the timing constraints can be enforced. The mapping from event based constraints to equivalent task based constraints is facilitated through the use of event based real-time programming languages such as TCEL <ref> [HG93a] </ref>. When such event based constraints are mapped to tasks, they often emerge as relative constraints | those which constrain the temporal distance between two tasks. Many real-time programming languages (e.g., DPS [LG85], RTC [WDL91], MPL [NTA90], CSR [GL89], Flex [LN88], and TCEL [HG93a]) provide constructs 1 which allow the programmer <p> based real-time programming languages such as TCEL <ref> [HG93a] </ref>. When such event based constraints are mapped to tasks, they often emerge as relative constraints | those which constrain the temporal distance between two tasks. Many real-time programming languages (e.g., DPS [LG85], RTC [WDL91], MPL [NTA90], CSR [GL89], Flex [LN88], and TCEL [HG93a]) provide constructs 1 which allow the programmer to express relative constraints. However, it is one thing to simply write a real-time program, and quite another to ensure its desired execution behavior. <p> Such languages use time as a first class entity, so as to allow for specification of timing constraints within the language. Many such languages have been proposed, including DPS [LG85], MPL [NTA90], RTC [WDL91], RTC++ [ITM90], FLEX [LN88], TCEL <ref> [HG93a] </ref> etc.; all these languauges provide high level constructs for specifying timing constraints. Such high level timing constraints are useful to separate the specification of timing constraints from the means used to ensure their satisfaction. <p> These languages use constructs such as "within t do f: : : g," "at t do f: : : g" and "after t do f: : : g," which define a temporal scope and the timing constraint on that scope. TCEL <ref> [HG93a] </ref> provides similar constructs but assigns event-based semantics to them; such semantics are closer to actual event-based specification, and permit the compiler to apply techniques such as code motion for optimization. 14 2.3 Summary We have presented a brief overview of the related work in real-time scheduling and timing specifications. <p> A sequential program written in most real-time languages (e.g., DPS [LG85], MPL [NTA90], RTC [WDL91], and TCEL <ref> [HG93a] </ref>) imposes constraints which fall into this class. <p> On the other hand, within and delay are used to represent relative deadline and delay constraints, respectively. These constructs may be used to annotate any programming language, such as C, to express the timing constraints (see <ref> [LG85, LN88, NTA90, WDL91, HG93a] </ref>). Example 5.1 To illustrate the use of these constructs, consider a simple example program segment, which computes the speed of a moving robot.
Reference: [HG93b] <author> S. Hong and R. Gerber. </author> <title> Scheduling with compiler transformations: the TCEL approach. </title> <booktitle> In Proceedings, IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 80-84. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1993. </year> <journal> IEEE RTTC Real-Time Newsletter, </journal> 9(1/2):80-84. 
Reference: [HKL91] <author> M. G. Harbour, M. H. Klein, and J. P. Lehoczky. </author> <title> Fixed Priority Scheduling of Periodic Tasks with Varying Execution Priority. </title> <booktitle> In Proceedings, IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 116-128, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: While the problem of guaranteeing timing constraints in hard real-time systems has received significant attention, few techniques have addressed the problem of guaranteeing inter-task temporal dependencies such as relative constraints. Most real-time scheduling techniques consider the scheduling of real-time tasks with ready times and deadlines <ref> [DM89, FK89, XP90, Ram90, SG91, VLHJ91, HKL91, TBW94] </ref>. These constraints impose constant intervals in which a task must be executed. In contrast, in the presence of relative constraints, the time window within which a task must execute may depend on the scheduling of the other tasks in the system. <p> The seminal 11 work in [LL73] showed that for a set of independent periodic real-time tasks with deadlines at the end of the periods, the rate monotonic priority assignment is optimal among all static priority schemes. Since then several extensions have been proposed <ref> [LSST90, HKL91, ABRW91, Tin92, Bur93, TBW94] </ref> to relax many of the assumptions about the constraints permissible in the basic rate monotonic scheme. When tasks synchronize using shared resources, priority inversion may occur. Priority inversion occurs when a high priority process is blocked for by a lower priority processes.
Reference: [HL89] <author> C. C. Han and K. J. Lin. </author> <title> Job scheduling with temporal distance constraints. </title> <type> Technical Report UIUCDCS-R-89-1560, </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <year> 1989. </year>
Reference-contexts: There is, however, limited work done for relative constraints in the context of tasks having unit execution times <ref> [HL89, HL92b] </ref>. Relative deadlines are considered in [HL89], and an algorithm has been developed for the special case of multilevel chains of tasks, where only the head task in each chain has an absolute deadline, and each task has a deadline relative to its immediate predecessor. <p> There is, however, limited work done for relative constraints in the context of tasks having unit execution times [HL89, HL92b]. Relative deadlines are considered in <ref> [HL89] </ref>, and an algorithm has been developed for the special case of multilevel chains of tasks, where only the head task in each chain has an absolute deadline, and each task has a deadline relative to its immediate predecessor. The algorithm has a complexity of O (n 2 ).
Reference: [HL92a] <author> C. C. Han and K. J. Lin. </author> <title> Scheduling Distance-Constrained Real-Time Tasks. </title> <booktitle> In Proceedings, IEEE Real-time Systems Symposium, </booktitle> <pages> pages 300-308, </pages> <address> Phoenix, Arizona, </address> <month> December </month> <year> 1992. </year>
Reference-contexts: The algorithm has a complexity of O (n 2 ). Similar results have been obtained for tasks with relative separation constraints [HL92b]. In other work <ref> [HL92a] </ref>, Han and Lin propose a new task model in which a distance constraint must be satisfied between successive invocations of a task. Schedulability conditions for such task sets are analyzed based on pin-wheel scheduling.
Reference: [HL92b] <author> C. C. Han and K. J. Lin. </author> <title> Scheduling real-time computations with separation constraints. </title> <journal> Information Processing Letters, </journal> <volume> 12 </volume> <pages> 61-66, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: There is, however, limited work done for relative constraints in the context of tasks having unit execution times <ref> [HL89, HL92b] </ref>. Relative deadlines are considered in [HL89], and an algorithm has been developed for the special case of multilevel chains of tasks, where only the head task in each chain has an absolute deadline, and each task has a deadline relative to its immediate predecessor. <p> The algorithm has a complexity of O (n 2 ). Similar results have been obtained for tasks with relative separation constraints <ref> [HL92b] </ref>. In other work [HL92a], Han and Lin propose a new task model in which a distance constraint must be satisfied between successive invocations of a task. Schedulability conditions for such task sets are analyzed based on pin-wheel scheduling.
Reference: [ITM90] <author> Y. Ishikawa, H. Tokuda, and C. Mercer. </author> <title> Object-Oriented Real-Time Language Design: Constructs for Timing Constraints. </title> <booktitle> In Proceedings ECOOP/OOPSLA, </booktitle> <pages> pages 289-298, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Such languages use time as a first class entity, so as to allow for specification of timing constraints within the language. Many such languages have been proposed, including DPS [LG85], MPL [NTA90], RTC [WDL91], RTC++ <ref> [ITM90] </ref>, FLEX [LN88], TCEL [HG93a] etc.; all these languauges provide high level constructs for specifying timing constraints. Such high level timing constraints are useful to separate the specification of timing constraints from the means used to ensure their satisfaction. <p> The attributes of each block may be constrained by the attributes of other blocks, yielding programs in which operations are temporally dependent on each other. A slightly different approach is taken in languages like MPL [NTA90], RTC [WDL91] and RTC++ <ref> [ITM90] </ref>; they use constructs to im-plictly define temporal scopes. These languages use constructs such as "within t do f: : : g," "at t do f: : : g" and "after t do f: : : g," which define a temporal scope and the timing constraint on that scope.
Reference: [JM86] <author> F. Jahanian and A.K. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(9):890-904, </volume> <month> September </month> <year> 1986. </year>
Reference-contexts: Timing specifications are event-based, and they establish many such minimum and maximum temporal distance constraints between occurrences of events <ref> [Das85, JM86, LW92] </ref>. To facilitate scheduling, a real-time program may be broken down into scheduling units termed as tasks, where each task corresponds to some segment of program code. The task boundaries (i.e., the start and finish time) serve as temporal markers on which the timing constraints can be enforced. <p> By refining the notion of an event to be either the start or end of an activity, the events may be considered instantaneous. A different framework for describing real-time constraints is provided by RTL (Real Time Logic) <ref> [JM86] </ref>. This is an event/action model, where actions consume non-zero amount of system resources. Events are instantaneous, require no system resources and serve only as temporal markers. The constraints are specified using logical formulas on the occurences of events.
Reference: [Jor90] <author> J. E. Jordan. </author> <title> Experiences Structuring Software in a Periodic Real-Time Environment. </title> <journal> Software Practice and Experience, </journal> <volume> 20(7) </volume> <pages> 707-718, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: A special class of real-time systems, termed hard real-time systems, require that the timing constraints be guaranteed prior to execution, since the result of a timing failure may lead to unstable or undesirable system behavior. Many real-time systems are constructed using a cyclic executive model <ref> [BS89, Jor90] </ref> in which the application tasks are dispatched following a fixed periodic schedule. The schedule, also termed a calendar, is represented as a table which lists the tasks and their start times, which are constant offsets from the start of the cycle.
Reference: [Law73] <author> E. L. Lawler. </author> <title> Optimal sequencing of a single machine subject to precedence constraints. </title> <journal> Management Science, </journal> <volume> 19(5) </volume> <pages> 544-546, </pages> <month> Jan. </month> <year> 1973. </year>
Reference-contexts: It is well known that a set of periodic processes are schedulable if and only if a schedule exists for the least common multiple (LCM) of the periods <ref> [Law73] </ref>. Thus, the scheduling problem reduces to scheduling a finite set of tasks, where the set of tasks is obtained by instantiating the tasks of each process for every invocation within the LCM time frame.
Reference: [LG85] <author> I. Lee and V. Gehlot. </author> <title> Language Constructs for Real Time Programming. </title> <booktitle> In Real Time Systems Symposium, </booktitle> <pages> pages 57-66. </pages> <publisher> IEEE, </publisher> <year> 1985. </year> <month> 90 </month>
Reference-contexts: When such event based constraints are mapped to tasks, they often emerge as relative constraints | those which constrain the temporal distance between two tasks. Many real-time programming languages (e.g., DPS <ref> [LG85] </ref>, RTC [WDL91], MPL [NTA90], CSR [GL89], Flex [LN88], and TCEL [HG93a]) provide constructs 1 which allow the programmer to express relative constraints. However, it is one thing to simply write a real-time program, and quite another to ensure its desired execution behavior. <p> Motivated by the need to specify timing constraints, many real-time languages have been proposed in recent years. Such languages use time as a first class entity, so as to allow for specification of timing constraints within the language. Many such languages have been proposed, including DPS <ref> [LG85] </ref>, MPL [NTA90], RTC [WDL91], RTC++ [ITM90], FLEX [LN88], TCEL [HG93a] etc.; all these languauges provide high level constructs for specifying timing constraints. Such high level timing constraints are useful to separate the specification of timing constraints from the means used to ensure their satisfaction. <p> The timing constraints are specified on the start and finish times of a temporal scope. Most of these languages allow the temporal scopes to be nested but not overlapped. The DPS language <ref> [LG85] </ref> first proposed the notion of the "temporal scope," which is associated with attributes such as deadline, minimum and maximum release times, maximum execution time and maximum elapsed time. Likewise, Flex [LN88] supports the notion of a constraint block, with associated attributed such as start time, finish time and duration. <p> A sequential program written in most real-time languages (e.g., DPS <ref> [LG85] </ref>, MPL [NTA90], RTC [WDL91], and TCEL [HG93a]) imposes constraints which fall into this class. <p> On the other hand, within and delay are used to represent relative deadline and delay constraints, respectively. These constructs may be used to annotate any programming language, such as C, to express the timing constraints (see <ref> [LG85, LN88, NTA90, WDL91, HG93a] </ref>). Example 5.1 To illustrate the use of these constructs, consider a simple example program segment, which computes the speed of a moving robot.
Reference: [LL73] <author> C. L. Liu and J. Layland. </author> <title> Scheduling Algorithm for Multiprogram--ming in a Hard Real-Time Environment. </title> <journal> Journal of the ACM., </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <month> Jan. </month> <year> 1973. </year>
Reference-contexts: The seminal 11 work in <ref> [LL73] </ref> showed that for a set of independent periodic real-time tasks with deadlines at the end of the periods, the rate monotonic priority assignment is optimal among all static priority schemes. <p> The deferrable server and priority exchange algorithms may be used for soft deadline aperiodic tasks, whereas the sporadic server algorithm may be used to service sporadic tasks. 2.1.3 Dynamic Priority Scheduling When the priorities may be dynamically defined, the earliest-deadline-first policy is optimal for a set of independent periodic tasks <ref> [LL73] </ref>. The earliest deadline first algorithm assigns a higher priority to a task with a closer deadline. It is optimal in the sense that if a set of tasks can be feasibly scheduled by any scheduling algorithm, then it can also be feasibly scheduled by the earliest deadline first algorithm. <p> It is also known to be optimal for a set of independent aperiodic tasks [Der74]. For a set of independent periodic tasks, a necessary and sufficient con 12 dition for schedulability is that the processor utilization should be less than 100% <ref> [LL73] </ref>. The schedulability tests have been extended for online determination of schedulability, when a new task arrives. Chetto [CC89] devised algorithms to determine feasibility of an arriving sporadic task, and the result has been extended for tasks with precedence constraints [CSB90].
Reference: [LN88] <author> K. J. Lin and S. Natarajan. </author> <title> Expressing and Maintaining Timing Constraints in FLEX. </title> <booktitle> In Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1988. </year>
Reference-contexts: When such event based constraints are mapped to tasks, they often emerge as relative constraints | those which constrain the temporal distance between two tasks. Many real-time programming languages (e.g., DPS [LG85], RTC [WDL91], MPL [NTA90], CSR [GL89], Flex <ref> [LN88] </ref>, and TCEL [HG93a]) provide constructs 1 which allow the programmer to express relative constraints. However, it is one thing to simply write a real-time program, and quite another to ensure its desired execution behavior. <p> Such languages use time as a first class entity, so as to allow for specification of timing constraints within the language. Many such languages have been proposed, including DPS [LG85], MPL [NTA90], RTC [WDL91], RTC++ [ITM90], FLEX <ref> [LN88] </ref>, TCEL [HG93a] etc.; all these languauges provide high level constructs for specifying timing constraints. Such high level timing constraints are useful to separate the specification of timing constraints from the means used to ensure their satisfaction. <p> Most of these languages allow the temporal scopes to be nested but not overlapped. The DPS language [LG85] first proposed the notion of the "temporal scope," which is associated with attributes such as deadline, minimum and maximum release times, maximum execution time and maximum elapsed time. Likewise, Flex <ref> [LN88] </ref> supports the notion of a constraint block, with associated attributed such as start time, finish time and duration. The attributes of each block may be constrained by the attributes of other blocks, yielding programs in which operations are temporally dependent on each other. <p> On the other hand, within and delay are used to represent relative deadline and delay constraints, respectively. These constructs may be used to annotate any programming language, such as C, to express the timing constraints (see <ref> [LG85, LN88, NTA90, WDL91, HG93a] </ref>). Example 5.1 To illustrate the use of these constructs, consider a simple example program segment, which computes the speed of a moving robot.
Reference: [LSST90] <author> J. P. Lehoczky, J. Strosnider, L. Sha, and H. Tokuda. </author> <title> Fixed priority scheduling theory for hard real-time systems. </title> <booktitle> In Proc. of the Third Annual Workshop on Foundations of Real-Time Computing, </booktitle> <pages> pages 49-71, </pages> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: The seminal 11 work in [LL73] showed that for a set of independent periodic real-time tasks with deadlines at the end of the periods, the rate monotonic priority assignment is optimal among all static priority schemes. Since then several extensions have been proposed <ref> [LSST90, HKL91, ABRW91, Tin92, Bur93, TBW94] </ref> to relax many of the assumptions about the constraints permissible in the basic rate monotonic scheme. When tasks synchronize using shared resources, priority inversion may occur. Priority inversion occurs when a high priority process is blocked for by a lower priority processes.
Reference: [LW92] <author> R. R. Lutz and J. S. K. Wong. </author> <title> Detecting unsafe error recovery schedules. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(8) </volume> <pages> 749-760, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Timing specifications are event-based, and they establish many such minimum and maximum temporal distance constraints between occurrences of events <ref> [Das85, JM86, LW92] </ref>. To facilitate scheduling, a real-time program may be broken down into scheduling units termed as tasks, where each task corresponds to some segment of program code. The task boundaries (i.e., the start and finish time) serve as temporal markers on which the timing constraints can be enforced.
Reference: [MF75] <author> G. McMahon and M. Florian. </author> <title> On scheduling with ready times and due dates to minimize maximum lateness. </title> <journal> Operations Research, </journal> <volume> 23(3) </volume> <pages> 475-482, </pages> <month> May </month> <year> 1975. </year>
Reference-contexts: The successors of any node are immediate extensions of the partial schedule corresponding schedule at that node. Heuristics are used to guide search. A different enumeration method is explored in <ref> [MF75, XP90, SG91] </ref>. In these papers, an initial schedule is created using simple heuristics. The schedule is then successively refined to minimize the "maximum lateness" of the schedule. Yet, another approach is the decomposition approach using sequence scheduling [YSA94].
Reference: [ML91] <author> E. P. Markatos and T. J. LeBlanc. </author> <title> Predictable Virtual Processors for Real-Time Systems. </title> <type> Technical Report 396, </type> <institution> University of Rochester, Computer Science Department, </institution> <year> 1991. </year>
Reference-contexts: Sporadic processes may be incorporated by either transforming them into equivalent periodic processes [Mok83, XP90], or through the use of hybrid scheduling techniques <ref> [YS91, ML91] </ref>. Other aperiodic processes for which no minimum inter-arrival time can be specified must be scheduled when they arrive [RS94]. However, no a priori guarantees can be made for such processes.
Reference: [Mok83] <author> A. K. Mok. </author> <title> Fundamental Design Problems for the Hard Real-time Environments. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <month> May </month> <year> 1983. </year>
Reference-contexts: Periodic processes arrive at regular intervals termed the period of the process, while aperiodic processes arrive at irregular intervals. If an aperiodic process requires static guarantees, then a minimum inter-arrival time must be specified; such processes are often called sporadic processes <ref> [Mok83] </ref>. It is well known that a set of periodic processes are schedulable if and only if a schedule exists for the least common multiple (LCM) of the periods [Law73]. <p> Thus, the scheduling problem reduces to scheduling a finite set of tasks, where the set of tasks is obtained by instantiating the tasks of each process for every invocation within the LCM time frame. Sporadic processes may be incorporated by either transforming them into equivalent periodic processes <ref> [Mok83, XP90] </ref>, or through the use of hybrid scheduling techniques [YS91, ML91]. Other aperiodic processes for which no minimum inter-arrival time can be specified must be scheduled when they arrive [RS94]. However, no a priori guarantees can be made for such processes.
Reference: [NTA90] <author> V. Nirkhe, S. Tripathi, and A. Agrawala. </author> <title> Language Support for the Maruti Real-Time System. </title> <booktitle> In Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1990. </year>
Reference-contexts: When such event based constraints are mapped to tasks, they often emerge as relative constraints | those which constrain the temporal distance between two tasks. Many real-time programming languages (e.g., DPS [LG85], RTC [WDL91], MPL <ref> [NTA90] </ref>, CSR [GL89], Flex [LN88], and TCEL [HG93a]) provide constructs 1 which allow the programmer to express relative constraints. However, it is one thing to simply write a real-time program, and quite another to ensure its desired execution behavior. <p> Motivated by the need to specify timing constraints, many real-time languages have been proposed in recent years. Such languages use time as a first class entity, so as to allow for specification of timing constraints within the language. Many such languages have been proposed, including DPS [LG85], MPL <ref> [NTA90] </ref>, RTC [WDL91], RTC++ [ITM90], FLEX [LN88], TCEL [HG93a] etc.; all these languauges provide high level constructs for specifying timing constraints. Such high level timing constraints are useful to separate the specification of timing constraints from the means used to ensure their satisfaction. <p> The attributes of each block may be constrained by the attributes of other blocks, yielding programs in which operations are temporally dependent on each other. A slightly different approach is taken in languages like MPL <ref> [NTA90] </ref>, RTC [WDL91] and RTC++ [ITM90]; they use constructs to im-plictly define temporal scopes. <p> A sequential program written in most real-time languages (e.g., DPS [LG85], MPL <ref> [NTA90] </ref>, RTC [WDL91], and TCEL [HG93a]) imposes constraints which fall into this class. <p> On the other hand, within and delay are used to represent relative deadline and delay constraints, respectively. These constructs may be used to annotate any programming language, such as C, to express the timing constraints (see <ref> [LG85, LN88, NTA90, WDL91, HG93a] </ref>). Example 5.1 To illustrate the use of these constructs, consider a simple example program segment, which computes the speed of a moving robot.
Reference: [PK89] <author> P. Puschner and C. Koza. </author> <title> Calculating the Maximum Execution Times of Real-Time Programs. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 1(2) </volume> <pages> 159-176, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Usually one only has a priori upper and lower bounds, which can be generated by timing tools <ref> [ZBN93, HBW92, PK89, Sha89] </ref>. In such a scenario, the use of a static start time assignment which must satisfy the constraints under all execution behaviors results in unnecessary pessimism and inflexibility.
Reference: [Ram90] <author> K. Ramamritham. </author> <title> Allocation and Scheduling of Complex Periodic Tasks. </title> <booktitle> In Proceedings 10th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 108-115, </pages> <year> 1990. </year>
Reference-contexts: While the problem of guaranteeing timing constraints in hard real-time systems has received significant attention, few techniques have addressed the problem of guaranteeing inter-task temporal dependencies such as relative constraints. Most real-time scheduling techniques consider the scheduling of real-time tasks with ready times and deadlines <ref> [DM89, FK89, XP90, Ram90, SG91, VLHJ91, HKL91, TBW94] </ref>. These constraints impose constant intervals in which a task must be executed. In contrast, in the presence of relative constraints, the time window within which a task must execute may depend on the scheduling of the other tasks in the system. <p> Since the search complexity is large, researchers have resorted to various heuristics to reduce the search effort, and thereby make the search feasible in practice. Branch and bound search is commonly used for optimal scheduling. A frequent way to represent the search space <ref> [BS74, BFR71, BFR75, FK89, Ram90, ZRS87, ZR87, VLHJ91] </ref> is to use a search tree in which the root (level 0) node represents an empty schedule, while each node at level k corresponds to a partial schedule containing k tasks.
Reference: [RS94] <author> K. Ramamritham and J. A. Stankovic. </author> <title> Scheduling algorithms and operating systems support for real-time systems. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 82(1) </volume> <pages> 55-67, </pages> <month> January </month> <year> 1994. </year> <month> 91 </month>
Reference-contexts: Sporadic processes may be incorporated by either transforming them into equivalent periodic processes [Mok83, XP90], or through the use of hybrid scheduling techniques [YS91, ML91]. Other aperiodic processes for which no minimum inter-arrival time can be specified must be scheduled when they arrive <ref> [RS94] </ref>. However, no a priori guarantees can be made for such processes. Traditionally, the scheduling for such a system is done by constructing an o*ine schedule in which the dispatch times of all tasks are pre-determined. This has the advantage of simplicity, predictability, and efficiency of run-time dispatching. <p> Similarly, non-preemptive disciplines 10 may allow limited preemption (e.g., at clock ticks) to increase schedulability. Most time based schedulers belong to this class. A significant amount of work has been carried out in real-time scheduling, and several reviews have also been published <ref> [CSR88, Bur91, XP91, RS94] </ref>. Here, we briefly review some of the previous work in real-time scheduling. 2.1.1 Time-Driven Scheduling In time-driven scheduling, a scheduling table is created which maps the tasks to their start times on the timeline.
Reference: [RSL89] <author> R. Rajkumar, L. Sha, and J. P. Lehoczky. </author> <title> An Experimental Inves--tigation of Synchronization Protocols. </title> <booktitle> In Proceedings, IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 11-17, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: Furthermore, access to a critical section may be deferred to avoid deadlocks. Examples of such protocols are the basic priority inheritance protocol and priority ceiling protocol [SRL90], ceiling semaphore protocol <ref> [RSL89] </ref>, semaphore control protocol [RSLR88] and stack resource protocol [Bak90]. Various extensions of fixed priority scheduling have been proposed to handle aperiodic tasks [SSL89]. A periodic server is used as a pseudo task to serve aperiodic requests.
Reference: [RSLR88] <author> R. Rajkumar, L. Sha, J. P. Lehoczky, and K. Ramamritham. </author> <title> An Optimal Priority Inheritance Protocol for Real-Time Synchronization. </title> <type> COINS Technical Report 88-98, </type> <institution> University of Massachusetts, Department of Computer and Information Science, </institution> <month> October </month> <year> 1988. </year>
Reference-contexts: Furthermore, access to a critical section may be deferred to avoid deadlocks. Examples of such protocols are the basic priority inheritance protocol and priority ceiling protocol [SRL90], ceiling semaphore protocol [RSL89], semaphore control protocol <ref> [RSLR88] </ref> and stack resource protocol [Bak90]. Various extensions of fixed priority scheduling have been proposed to handle aperiodic tasks [SSL89]. A periodic server is used as a pseudo task to serve aperiodic requests.
Reference: [SA93] <author> M. Saksena and A. K. Agrawala. </author> <title> Temporal Analysis for Hard-Real Time Scheduling. </title> <booktitle> In Proceedings 12th International Phoenix Conference on Computers and Communications, </booktitle> <pages> pages 538-544, </pages> <month> March </month> <year> 1993. </year>
Reference: [SB94] <author> A. Stoyenko and T. P. Baker. </author> <title> Real-Time Schedulability Analyzable Mechanisms in Ada9X. </title> <journal> Proceeding of the IEEE, </journal> <volume> 82(1) </volume> <pages> 95-106, </pages> <month> Jan-uary </month> <year> 1994. </year>
Reference-contexts: Specifically, a desirable feature is the ability to specify timing constraints in a declarative rather than operational form <ref> [SB94] </ref>. In recent years many experimental languages have been proposed following this principle, and which allow the programmer to express a variety of timing constraints. Unfortunately, due to the limitations of current scheduling theory, many constraints which can be specified cannot be statically guaranteed.
Reference: [SdSA94] <author> M. Saksena, J. da Silva, and A. Agrawala. </author> <title> Design and Implementation of Maruti-II. In Sang Son, editor, </title> <booktitle> Principles of Real-Time Systems. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1994. </year> <note> Also available as CS-TR-2845, </note> <institution> University of Maryland. </institution>
Reference-contexts: While cyclic executives have traditionally been built with minimal operating system functionality, recently several experimental operating systems have adopted a generalized cyclic scheduling model to guarantee critical hard real-time tasks. Prominent among these systems are MARS [DRSK89], Maruti <ref> [SdSA94] </ref>, and the Spring Kernel [SR89]. Critical tasks in these systems are scheduled using a static scheduling approach following a time-driven resource management model. In the time-driven model, resources are explicitly reserved prior to execution. The temporal correctness of a system is demonstrated through the construction of a feasible schedule.
Reference: [SG91] <author> T. Shepard and J. A. M. Gagne. </author> <title> A Pre-Run-Time Scheduling Algorithm for Hard Real-Time Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(7) </volume> <pages> 669-677, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: While the problem of guaranteeing timing constraints in hard real-time systems has received significant attention, few techniques have addressed the problem of guaranteeing inter-task temporal dependencies such as relative constraints. Most real-time scheduling techniques consider the scheduling of real-time tasks with ready times and deadlines <ref> [DM89, FK89, XP90, Ram90, SG91, VLHJ91, HKL91, TBW94] </ref>. These constraints impose constant intervals in which a task must be executed. In contrast, in the presence of relative constraints, the time window within which a task must execute may depend on the scheduling of the other tasks in the system. <p> The successors of any node are immediate extensions of the partial schedule corresponding schedule at that node. Heuristics are used to guide search. A different enumeration method is explored in <ref> [MF75, XP90, SG91] </ref>. In these papers, an initial schedule is created using simple heuristics. The schedule is then successively refined to minimize the "maximum lateness" of the schedule. Yet, another approach is the decomposition approach using sequence scheduling [YSA94].
Reference: [SGA93] <author> M. Saksena, R. Gerber, and A. K. Agrawala. </author> <title> Scheduling with Relative Timing Constraints. </title> <booktitle> In Tenth IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 6-10, </pages> <month> May </month> <year> 1993. </year>
Reference: [Sha89] <author> A. C. Shaw. </author> <title> Reasoning about Time in Higher Level Language Software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 875-889, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Usually one only has a priori upper and lower bounds, which can be generated by timing tools <ref> [ZBN93, HBW92, PK89, Sha89] </ref>. In such a scenario, the use of a static start time assignment which must satisfy the constraints under all execution behaviors results in unnecessary pessimism and inflexibility.
Reference: [SR89] <author> J. A. Stankovic and K. Ramamritham. </author> <title> The Spring Kernel: A New Paradigm for Real-Time Operating Systems. </title> <journal> ACM SIGOPS, Operating Systems Review, </journal> <volume> 23(3) </volume> <pages> 54-71, </pages> <month> July </month> <year> 1989. </year> <month> 92 </month>
Reference-contexts: While cyclic executives have traditionally been built with minimal operating system functionality, recently several experimental operating systems have adopted a generalized cyclic scheduling model to guarantee critical hard real-time tasks. Prominent among these systems are MARS [DRSK89], Maruti [SdSA94], and the Spring Kernel <ref> [SR89] </ref>. Critical tasks in these systems are scheduled using a static scheduling approach following a time-driven resource management model. In the time-driven model, resources are explicitly reserved prior to execution. The temporal correctness of a system is demonstrated through the construction of a feasible schedule.
Reference: [SRL90] <author> L. Sha, R. Rajkumar, and J. P. Lehoczky. </author> <title> Priority Inheritance Pro--tocols: An Approach to Real-Time Synchronization. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(9) </volume> <pages> 1175-1185, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: When tasks synchronize using shared resources, priority inversion may occur. Priority inversion occurs when a high priority process is blocked for by a lower priority processes. This causes a serious problem for real-time schedulability, if the blocking time is unbounded <ref> [SRL90] </ref>. A class of synchronization protocols have been developed to be used in conjunction with fixed priority scheduling to provide bounded and predictable blocking times to alleviate the affect of priority inversion. In [SRL90], a class of priority inheritance protocols were developed and schedulability tests were provided. <p> This causes a serious problem for real-time schedulability, if the blocking time is unbounded <ref> [SRL90] </ref>. A class of synchronization protocols have been developed to be used in conjunction with fixed priority scheduling to provide bounded and predictable blocking times to alleviate the affect of priority inversion. In [SRL90], a class of priority inheritance protocols were developed and schedulability tests were provided. The central idea behind these protocols is that a lower priority process inherits the priority of a higher priority process when the lower priority process blocks the higher priority process. <p> Furthermore, access to a critical section may be deferred to avoid deadlocks. Examples of such protocols are the basic priority inheritance protocol and priority ceiling protocol <ref> [SRL90] </ref>, ceiling semaphore protocol [RSL89], semaphore control protocol [RSLR88] and stack resource protocol [Bak90]. Various extensions of fixed priority scheduling have been proposed to handle aperiodic tasks [SSL89]. A periodic server is used as a pseudo task to serve aperiodic requests.
Reference: [SSL89] <author> B. Sprunt, L. Sha, and J. Lehoczky. </author> <title> Aperiodic task scheduling for hard-real-time systems. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 1(1) </volume> <pages> 27-60, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Examples of such protocols are the basic priority inheritance protocol and priority ceiling protocol [SRL90], ceiling semaphore protocol [RSL89], semaphore control protocol [RSLR88] and stack resource protocol [Bak90]. Various extensions of fixed priority scheduling have been proposed to handle aperiodic tasks <ref> [SSL89] </ref>. A periodic server is used as a pseudo task to serve aperiodic requests. A class of algorithms called bandwidth preserving algorithms have been proposed which overcome the limitations of a polling scheme.
Reference: [TBW94] <author> K. Tindell, A. Burns, and A. Wellings. </author> <title> An Extendible Approach for Analyzing Fixed Priority Hard Real-Time Tasks. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 6(2), </volume> <month> March </month> <year> 1994. </year>
Reference-contexts: While the problem of guaranteeing timing constraints in hard real-time systems has received significant attention, few techniques have addressed the problem of guaranteeing inter-task temporal dependencies such as relative constraints. Most real-time scheduling techniques consider the scheduling of real-time tasks with ready times and deadlines <ref> [DM89, FK89, XP90, Ram90, SG91, VLHJ91, HKL91, TBW94] </ref>. These constraints impose constant intervals in which a task must be executed. In contrast, in the presence of relative constraints, the time window within which a task must execute may depend on the scheduling of the other tasks in the system. <p> The seminal 11 work in [LL73] showed that for a set of independent periodic real-time tasks with deadlines at the end of the periods, the rate monotonic priority assignment is optimal among all static priority schemes. Since then several extensions have been proposed <ref> [LSST90, HKL91, ABRW91, Tin92, Bur93, TBW94] </ref> to relax many of the assumptions about the constraints permissible in the basic rate monotonic scheme. When tasks synchronize using shared resources, priority inversion may occur. Priority inversion occurs when a high priority process is blocked for by a lower priority processes.
Reference: [Tin92] <author> K. W. Tindell. </author> <title> Using offset information to analyse static priority pre-emptively scheduled task sets. </title> <type> Technical Report YCS 182 (1992), </type> <institution> Department of Computer Science, University of York, </institution> <address> England, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: The seminal 11 work in [LL73] showed that for a set of independent periodic real-time tasks with deadlines at the end of the periods, the rate monotonic priority assignment is optimal among all static priority schemes. Since then several extensions have been proposed <ref> [LSST90, HKL91, ABRW91, Tin92, Bur93, TBW94] </ref> to relax many of the assumptions about the constraints permissible in the basic rate monotonic scheme. When tasks synchronize using shared resources, priority inversion may occur. Priority inversion occurs when a high priority process is blocked for by a lower priority processes.
Reference: [VLHJ91] <author> J. P. C. Verhoosel, E. J. Luit, D. K. Hammer, and E. Jansen. </author> <title> A Static Scheduling Algorithm for Distributed Hard Real-Time Systems. </title> <booktitle> Real-Time Systems, </booktitle> <pages> pages 227-246, </pages> <year> 1991. </year>
Reference-contexts: While the problem of guaranteeing timing constraints in hard real-time systems has received significant attention, few techniques have addressed the problem of guaranteeing inter-task temporal dependencies such as relative constraints. Most real-time scheduling techniques consider the scheduling of real-time tasks with ready times and deadlines <ref> [DM89, FK89, XP90, Ram90, SG91, VLHJ91, HKL91, TBW94] </ref>. These constraints impose constant intervals in which a task must be executed. In contrast, in the presence of relative constraints, the time window within which a task must execute may depend on the scheduling of the other tasks in the system. <p> Since the search complexity is large, researchers have resorted to various heuristics to reduce the search effort, and thereby make the search feasible in practice. Branch and bound search is commonly used for optimal scheduling. A frequent way to represent the search space <ref> [BS74, BFR71, BFR75, FK89, Ram90, ZRS87, ZR87, VLHJ91] </ref> is to use a search tree in which the root (level 0) node represents an empty schedule, while each node at level k corresponds to a partial schedule containing k tasks.
Reference: [WDL91] <author> V. Wolfe, S. Davidson, and I. Lee. RTC: </author> <title> Language support for real-time concurrency. </title> <booktitle> In Proceedings of the 12th IEEE Real-time Systems Symposium, </booktitle> <pages> pages 43-52, </pages> <address> San Antonio, Texas, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: When such event based constraints are mapped to tasks, they often emerge as relative constraints | those which constrain the temporal distance between two tasks. Many real-time programming languages (e.g., DPS [LG85], RTC <ref> [WDL91] </ref>, MPL [NTA90], CSR [GL89], Flex [LN88], and TCEL [HG93a]) provide constructs 1 which allow the programmer to express relative constraints. However, it is one thing to simply write a real-time program, and quite another to ensure its desired execution behavior. <p> In other work [HL92a], Han and Lin propose a new task model in which a distance constraint must be satisfied between successive invocations of a task. Schedulability conditions for such task sets are analyzed based on pin-wheel scheduling. Finally, in <ref> [WDL91] </ref>, a dynamic scheduling scheme based has been presented for hierarchical relative constraints; however, the scheme is not intended to provide o*ine guarantees. 2.2 Specification and Programming Languages The specification languages are used for high level specification of timing and functional requirements for real-time applications. <p> Such languages use time as a first class entity, so as to allow for specification of timing constraints within the language. Many such languages have been proposed, including DPS [LG85], MPL [NTA90], RTC <ref> [WDL91] </ref>, RTC++ [ITM90], FLEX [LN88], TCEL [HG93a] etc.; all these languauges provide high level constructs for specifying timing constraints. Such high level timing constraints are useful to separate the specification of timing constraints from the means used to ensure their satisfaction. <p> The attributes of each block may be constrained by the attributes of other blocks, yielding programs in which operations are temporally dependent on each other. A slightly different approach is taken in languages like MPL [NTA90], RTC <ref> [WDL91] </ref> and RTC++ [ITM90]; they use constructs to im-plictly define temporal scopes. <p> A sequential program written in most real-time languages (e.g., DPS [LG85], MPL [NTA90], RTC <ref> [WDL91] </ref>, and TCEL [HG93a]) imposes constraints which fall into this class. <p> On the other hand, within and delay are used to represent relative deadline and delay constraints, respectively. These constructs may be used to annotate any programming language, such as C, to express the timing constraints (see <ref> [LG85, LN88, NTA90, WDL91, HG93a] </ref>). Example 5.1 To illustrate the use of these constructs, consider a simple example program segment, which computes the speed of a moving robot.
Reference: [XP90] <author> J. Xu and D. L. Parnas. </author> <title> Scheduling processes with release times, deadlines, precedence, and exclusion relations. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-16(3):360-369, </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: While the problem of guaranteeing timing constraints in hard real-time systems has received significant attention, few techniques have addressed the problem of guaranteeing inter-task temporal dependencies such as relative constraints. Most real-time scheduling techniques consider the scheduling of real-time tasks with ready times and deadlines <ref> [DM89, FK89, XP90, Ram90, SG91, VLHJ91, HKL91, TBW94] </ref>. These constraints impose constant intervals in which a task must be executed. In contrast, in the presence of relative constraints, the time window within which a task must execute may depend on the scheduling of the other tasks in the system. <p> Thus, the scheduling problem reduces to scheduling a finite set of tasks, where the set of tasks is obtained by instantiating the tasks of each process for every invocation within the LCM time frame. Sporadic processes may be incorporated by either transforming them into equivalent periodic processes <ref> [Mok83, XP90] </ref>, or through the use of hybrid scheduling techniques [YS91, ML91]. Other aperiodic processes for which no minimum inter-arrival time can be specified must be scheduled when they arrive [RS94]. However, no a priori guarantees can be made for such processes. <p> The successors of any node are immediate extensions of the partial schedule corresponding schedule at that node. Heuristics are used to guide search. A different enumeration method is explored in <ref> [MF75, XP90, SG91] </ref>. In these papers, an initial schedule is created using simple heuristics. The schedule is then successively refined to minimize the "maximum lateness" of the schedule. Yet, another approach is the decomposition approach using sequence scheduling [YSA94].
Reference: [XP91] <author> J. Xu and D. L. Parnas. </author> <title> On Satisfying Timing Constraints in Hard-Real-Time Systems. </title> <booktitle> In Proceedings of the ACM SIGSOFT'91 Conference on Software for Critical Systems, </booktitle> <pages> pages 132-146, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: Similarly, non-preemptive disciplines 10 may allow limited preemption (e.g., at clock ticks) to increase schedulability. Most time based schedulers belong to this class. A significant amount of work has been carried out in real-time scheduling, and several reviews have also been published <ref> [CSR88, Bur91, XP91, RS94] </ref>. Here, we briefly review some of the previous work in real-time scheduling. 2.1.1 Time-Driven Scheduling In time-driven scheduling, a scheduling table is created which maps the tasks to their start times on the timeline.
Reference: [YS91] <author> M. Young and L-C. Shu. </author> <title> Hybrid online/o*ine scheduling for hard real-time systems. </title> <type> Technical Report SERC-TR-100-P, </type> <institution> Software Engineering Research Center, Department of Computer Sciences, Pur-due University, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: Sporadic processes may be incorporated by either transforming them into equivalent periodic processes [Mok83, XP90], or through the use of hybrid scheduling techniques <ref> [YS91, ML91] </ref>. Other aperiodic processes for which no minimum inter-arrival time can be specified must be scheduled when they arrive [RS94]. However, no a priori guarantees can be made for such processes.
Reference: [YSA94] <author> X. Yuan, M. Saksena, and A. Agrawala. </author> <title> A Decomposition Approach to Real-Time Scheduling. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 6(1), </volume> <year> 1994. </year> <month> 93 </month>
Reference-contexts: A different enumeration method is explored in [MF75, XP90, SG91]. In these papers, an initial schedule is created using simple heuristics. The schedule is then successively refined to minimize the "maximum lateness" of the schedule. Yet, another approach is the decomposition approach using sequence scheduling <ref> [YSA94] </ref>. In this scheme a task set is decomposed into a sequence of subsets, and then each subset is scheduled independently for minimal length. <p> The following definition of dominance allows us to compare the optimal schedules from different schedule sequences. Definition 5.2 (Dominance <ref> [YSA94] </ref>) Given two complete schedule sequences S 1 and S 2 for some problem , we say that S 1 dominates S 2 if the 50 following holds true: f easible (S 2 ) ) f easible (S 1 ); and; f inish (!(S 1 )) f inish (!(S 2 )) <p> The rationale behind the approach is that we can reduce the search time significantly by efficiently pruning the search space through simple analysis of timing constraints. The technique proposed in this chapter is in the same vein as the ideas presented in [EFMR83] and <ref> [YSA94] </ref>, which are based on dominance properties of schedules. In [EFMR83], the notion of dominance is introduced (see Chapter 5) to eliminate task sequences which are dominated by some other sequence. In this manner, an effectively pruned search space is created. In [YSA94], the idea is extended to decompose the task <p> vein as the ideas presented in [EFMR83] and <ref> [YSA94] </ref>, which are based on dominance properties of schedules. In [EFMR83], the notion of dominance is introduced (see Chapter 5) to eliminate task sequences which are dominated by some other sequence. In this manner, an effectively pruned search space is created. In [YSA94], the idea is extended to decompose the task set into subsets of tasks, thus avoiding backtracking across the subsets. The main drawback of these techniques stems from their "aggressive" approach to eliminating sequences, i.e., they may eliminate feasible sequences which are not dominant.
Reference: [ZBN93] <author> N. Zhang, A. Burns, and M. Nicholson. </author> <title> Pipelined Processors and Worst Case Execution Times. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 5(4), </volume> <month> October </month> <year> 1993. </year>
Reference-contexts: Usually one only has a priori upper and lower bounds, which can be generated by timing tools <ref> [ZBN93, HBW92, PK89, Sha89] </ref>. In such a scenario, the use of a static start time assignment which must satisfy the constraints under all execution behaviors results in unnecessary pessimism and inflexibility.
Reference: [ZR87] <author> W. Zhao and K. Ramamritham. </author> <title> Simple and Integrated Heuristic Algorithms for Scheduling Tasks with Time and Resource Constraints. </title> <journal> Journal of Systems and Software, </journal> <pages> pages 195-205, </pages> <year> 1987. </year>
Reference-contexts: Since the search complexity is large, researchers have resorted to various heuristics to reduce the search effort, and thereby make the search feasible in practice. Branch and bound search is commonly used for optimal scheduling. A frequent way to represent the search space <ref> [BS74, BFR71, BFR75, FK89, Ram90, ZRS87, ZR87, VLHJ91] </ref> is to use a search tree in which the root (level 0) node represents an empty schedule, while each node at level k corresponds to a partial schedule containing k tasks. <p> In the case of a conflict, a secondary heuristic earliest deadline was used. Further conflicts were resolved arbitrarily. The heuristic has a natural intuitive appeal and is known to produce good results among linear heuristics <ref> [ZR87] </ref>. 6.2.4 Simulation Study We conducted a simulation study to measure the affect of temporal analysis on scheduling. For each set of parameters, 100 task sets were generated. The simulations were done on Dec Station 3100 running ULTRIX, and the time measurements were taken using C-shell "time" facility.
Reference: [ZRS87] <author> W. Zhao, K. Ramamritham, and J. A. Stankovic. </author> <title> Scheduling Tasks with Resource requirements in a Hard Real-Time System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(5):564-577, </volume> <month> May </month> <year> 1987. </year> <month> 94 </month>
Reference-contexts: Since the search complexity is large, researchers have resorted to various heuristics to reduce the search effort, and thereby make the search feasible in practice. Branch and bound search is commonly used for optimal scheduling. A frequent way to represent the search space <ref> [BS74, BFR71, BFR75, FK89, Ram90, ZRS87, ZR87, VLHJ91] </ref> is to use a search tree in which the root (level 0) node represents an empty schedule, while each node at level k corresponds to a partial schedule containing k tasks. <p> For each node being expanded, the following conditions must hold. 1. All immediate extensions of the node must be feasible <ref> [BFR71, ZRS87] </ref>. 2. The remaining computational demand must not exceed the difference between the largest deadline of remaining tasks and current scheduling time [ZRS87]. If any condition is violated then no feasible schedule can be generated in the subtree originating from this node. <p> For each node being expanded, the following conditions must hold. 1. All immediate extensions of the node must be feasible [BFR71, ZRS87]. 2. The remaining computational demand must not exceed the difference between the largest deadline of remaining tasks and current scheduling time <ref> [ZRS87] </ref>. If any condition is violated then no feasible schedule can be generated in the subtree originating from this node. No search is conducted on the subtree rooted at such a node. A heuristic function is used to order the children of a node.
References-found: 72

