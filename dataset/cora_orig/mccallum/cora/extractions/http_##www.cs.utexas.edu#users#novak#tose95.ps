URL: http://www.cs.utexas.edu/users/novak/tose95.ps
Refering-URL: http://www.cs.utexas.edu/users/novak/tose95.html
Root-URL: 
Title: Creation of Views for Reuse of Software with Different Data Representations  
Author: Gordon S. Novak Jr. 
Note: This article appears in IEEE Transactions on Software Engineering, vol. 21, no.  1995, pp.  
Date: August 1, 1997  12, Dec.  993-1005.  
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences University of Texas at Austin  
Abstract: Copyright c fl1995 by IEEE. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE. Abstract Software reuse is inhibited by the many different ways in which equivalent data can be represented. We describe methods by which views can be constructed semiautomatically to describe how application data types correspond to the abstract types that are used in numerical generic algorithms. Given such views, specialized versions of the generic algorithms that operate directly on the application data can be produced by compilation. This enables reuse of the generic algorithms for an application with minimal effort. Graphical user interfaces allow views to be specified easily and rapidly. Algorithms are presented for deriving, by symbolic algebra, equations that relate the variables used in the application data to the variables needed for the generic algorithms. Arbitrary application data structures are allowed. Units of measurement are converted as needed. These techniques allow reuse of a single version of a generic algorithm for a variety of possible data representations and programming languages. These techniques can also be applied in data conversion and in object-oriented, functional, and transformational programming. fl G. S. Novak, Jr. is with the Department of Computer Sciences, University of Texas, Austin, TX 78712. An on-line demonstration of the software described in this paper is available on the World Wide Web via http://www.cs.utexas.edu/users/novak in the Automatic Programming Server demo, Mathematical View option. A workstation running X windows is required. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> IEEE Trans. </editor> <booktitle> on Software Engineering, </booktitle> <volume> vol. 11, no. 11, </volume> <month> Nov. </month> <year> 1985. </year>
Reference-contexts: Biggerstaff and Perlis [4] contains papers on theory and applications of software reuse. Mili [29] provides an extensive survey of approaches to software reuse, emphasizing the technical challenges of reuse for software production. Artificial intelligence approaches to software engineering are described in <ref> [1] </ref>, [28], and [41]. Some papers from these sources are reviewed individually in this section. 23 6.2 Software Components Weide [52] proposes a software components industry analogous to the electronic components industry, based on formally specified and unchangeable components with rigid interfaces.
Reference: [2] <author> A. Berlin and D. Weise, </author> <title> "Compiling Scientific Code Using Partial Evaluation," </title> <journal> IEEE Computer, </journal> <volume> vol. 23, no. 12, </volume> <pages> pp. 25-37, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Our views require fewer specifications because they operate at semantic (type-based and algebraic) levels, rather than at the syntactic level; most patterns of use are handled automatically by the algebraic optimization of the compiler. Berlin and Weise <ref> [2] </ref> used partial evaluation to improve the efficiency of scientific programs. Using information that some features of a problem are constant, their compiler performs as many constant calculations as possible at compile time, resulting in a program that is specialized and runs faster.
Reference: [3] <author> W. H. Beyer (ed.), </author> <title> CRC Standard Mathematical Tables and Formulae, </title> <editor> 29th ed., </editor> <address> Boca Raton, FL: </address> <publisher> CRC Press, </publisher> <year> 1991. </year>
Reference-contexts: Books often omit important features: <ref> [3] </ref> assumes that a human will determine the sign of the result. Even if a formula is found, it may not be expressed in terms of the available data. Some versions of the formula involve division by numbers that can be nearly zero.
Reference: [4] <author> T. Biggerstaff and A. Perlis (eds), </author> <title> Software Reusability (2 vols.), </title> <publisher> ACM Press / Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The algorithms presented here could be used to generate transforms for a language such as Polya. 6 Related Work 6.1 Software Reuse Krueger [24] is an excellent survey of software reuse; it also gives criteria for effective software reuse. Biggerstaff and Perlis <ref> [4] </ref> contains papers on theory and applications of software reuse. Mili [29] provides an extensive survey of approaches to software reuse, emphasizing the technical challenges of reuse for software production. Artificial intelligence approaches to software engineering are described in [1], [28], and [41].
Reference: [5] <author> J. Callahan and J. Purtilo, </author> <title> "A Packaging System for Heterogeneous Execution Environments," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 17, no. 6, </volume> <pages> pp. 626-635, </pages> <month> June </month> <year> 1991. </year> <title> 28 [6] "The Common Object Request Broker: Architecture and Specification," TC Document 91.12.1, Revision 1.1, </title> <booktitle> Object Management Group, </booktitle> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: Herlihy and Liskov [20] describe a method for transmission of structured data over a network, with a possibly different data representation at the destination. Their method employs user-written procedures to encode and decode the data into transmissible representations. They also describe a method for transmission of shared structures. <ref> [5] </ref> describes a system that automatically generates stub programs to interconnect processing modules that are in different languages or processors; this work is complementary to the techniques presented in this paper.
Reference: [7] <author> E. W. Dijkstra, </author> <title> A Discipline of Programming, </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: The view thus makes the application type appear to be a full-fledged implementation of the abstract type. Smith [45] uses the term theory morphism for a similar notion; Gries [17] uses the term coupling invariant and cites the term coordinate transformation used by Dijkstra <ref> [7] </ref>. The example of Fig. 2 illustrates a simple view in which a pipe is viewed as a circle in terms of the basis variable radius.
Reference: [8] <author> S. Efremidis, </author> <title> "On Program Transformations," </title> <type> Ph.D. dissertation, Tech. Report TR-94-1434, </type> <institution> Dept. of Computer Science, Cornell Univ., </institution> <year> 1994. </year>
Reference-contexts: Storing of basis variables could be implemented by storing into the application data, for functional languages that allow this, or by creating new data with the updated values in the case of strict functional languages. The Polya language [17] <ref> [8] </ref> allows a user to specify a set of transformations that are made to the intermediate code of a generic algorithm; these transformations are equivalent to the transformations performed by the GLISP compiler [31].
Reference: [9] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software, </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: the program is described. 2 Representation and Views Traditional data types combine two issues that should be separated to facilitate reuse: 1. the way in which application data are represented 2. procedures associated with a conceptual kind of object These are termed implementation inheritance and interface inheritance in object-oriented programming <ref> [9] </ref>. When the two are combined, the code of a procedure implicitly states assumptions about details of data representation. This inhibits software reuse, since any assumptions made in writing a procedure become requirements that must be met if the procedure is to be reused. <p> Views enhance type checking by checking units of measurement, and they provide encapsulation: when a view is used, only the operations defined by the view are available. The view mechanism provides the benefits of encapsulation while enhancing reusability and producing more efficient code than other encapsulation mechanisms <ref> [9] </ref>. 4 Graphical User Interface A graphical user interface makes it easy to specify correspondences between an application type and an abstract type using a mouse pointing device. <p> Thus, reuse with OOP requires conformance to existing standards. Views allow new kinds of objects to be used with existing methods. The term adapter or wrapper <ref> [9] </ref> denotes an object class that makes application data appear to be an instance of a target class. The wrapper object contains a pointer to the 22 application data and performs message translation to implement the messages required of a member of the target class. <p> We have previously described [35] the use of wrapper objects to allow display and direct-manipulation editing of user data by generic editor programs. There are two disadvantages of using wrapper objects <ref> [9] </ref>. It is necessary to allocate a wrapper object at runtime, which costs time and storage. Second, since translation of data is performed interpretively, there is overhead of additional message sending, and the same translation may be performed many times during execution. <p> Specialization of generic algorithms is more efficient than interpretive conversion of data. 6.8 Object-oriented Programming OOP is popular as a mechanism for software reuse; Gamma et al. <ref> [9] </ref> describe design patterns that are useful for OOP. We have described how views could be used to construct wrapper objects that make application objects appear to be members of a desired class. Use of views with the GLISP compiler extends good ideas in OOP: 1. <p> Use of views with the GLISP compiler extends good ideas in OOP: 1. OOP makes the connection between a message and the corresponding procedure at runtime; this is often a significant cost <ref> [9] </ref>. C++ [48] has relatively efficient message dispatching, at some cost in flexibility. Because GLISP [31] can specialize a method 26 in-line and optimize the resulting code in context, the overhead of interpretation is eliminated, and often there is no extra cost. 2.
Reference: [10] <author> D. Garlan, </author> <title> "Views for Tools in Integrated Environments," </title> <editor> in R. Conradi et al. (eds.), </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 244: </volume> <booktitle> Advanced Programming Environments, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Our system creates views from correspondences between application types and mathematical objects; the possible correspondences are more general than the one-to-one correspondences specified in OBJ3 views. Our system produces efficient specialized procedures in ordinary programming languages and is intended to be used as a program generation system. Garlan <ref> [10] </ref> and Kaiser [22] use views to allow multiple tools in a program development environment to access a common set of data about the program being developed.
Reference: [11] <author> K. Gieck, </author> <title> Engineering Formulas (5th ed.), </title> <publisher> McGraw-Hill, </publisher> <year> 1986. </year>
Reference-contexts: The diagram is intended to present virtually all the reasonable possibilities as buttons. This interface has several advantages: 1. Diagrams are easily and rapidly perceived by humans [26], and they are widely used in engineering and scientific communication <ref> [11] </ref>. 3 If there were alternative representations that were sufficiently different to require different diagrams, a menu to select among alternative diagrams could be presented to the user first. 17 2.
Reference: [12] <author> J. A. Goguen, </author> <title> "Reusing and Interconnecting Software Components," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 16-28, </pages> <month> Feb. </month> <year> 1986. </year>
Reference-contexts: Our system incorporates partial evaluation by means of in-line compilation and symbolic optimization. 6.6 Views Goguen describes a library interconnection language called LIL <ref> [12] </ref> and has implemented the language OBJ3 [13] [14] that incorporates parameterized programming and views. A view in OBJ3 is a mapping between a theory T and a module M that consistently maps sorts (types) of T to sorts of M and operations of T to operations of M.
Reference: [13] <author> J. A. Goguen, </author> <title> "Principles of Parameterized Programming," </title> <booktitle> in [4], </booktitle> <pages> pp. 159-225. </pages>
Reference-contexts: Similar viewpoints are found in mathematical definitions of isomorphism (e.g., [39], p. 129), in denotational semantics [15], and in work on program transformation [45] [17]. <ref> [13] </ref> describes views in terms of such isomorphisms. <p> Our system incorporates partial evaluation by means of in-line compilation and symbolic optimization. 6.6 Views Goguen describes a library interconnection language called LIL [12] and has implemented the language OBJ3 <ref> [13] </ref> [14] that incorporates parameterized programming and views. A view in OBJ3 is a mapping between a theory T and a module M that consistently maps sorts (types) of T to sorts of M and operations of T to operations of M.
Reference: [14] <author> J. A. Goguen, </author> <title> "Introducing OBJ," </title> <type> Technical Report SRI-CSL-92-03, </type> <institution> Computer Science Lab, SRI International, </institution> <address> Menlo Park, CA, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: Our system incorporates partial evaluation by means of in-line compilation and symbolic optimization. 6.6 Views Goguen describes a library interconnection language called LIL [12] and has implemented the language OBJ3 [13] <ref> [14] </ref> that incorporates parameterized programming and views. A view in OBJ3 is a mapping between a theory T and a module M that consistently maps sorts (types) of T to sorts of M and operations of T to operations of M.
Reference: [15] <author> M. J. C. Gordon, </author> <title> The Denotational Description of Programming Languages, </title> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Similar viewpoints are found in mathematical definitions of isomorphism (e.g., [39], p. 129), in denotational semantics <ref> [15] </ref>, and in work on program transformation [45] [17]. [13] describes views in terms of such isomorphisms.
Reference: [16] <author> D. Gries and J. Prins, </author> <title> "A New Notion of Encapsulation," </title> <journal> ACM SIGPLAN Notices, </journal> <volume> vol. 20, no. 7), </volume> <pages> pp. 131-139, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: KIDS [46] can transform general algorithms into executable versions that are highly efficient for combinatorial problems. The user selects transformations to be used and supplies a formal theory for the domain of application. This system is interesting and powerful, but its user must be mathematically sophisticated. Gries and Prins <ref> [16] </ref> proposed a system that would use syntactic transformations to specify the implementation of abstract algorithms. [31] describes related techniques that were implemented earlier. Volpano [51] and Gries [17] describe transformation of programs by syntactic coordinate transformations for variables or for patterns involving uses of variables.
Reference: [17] <author> D. Gries and D. Volpano, </author> <title> "The Transform aNew Language Construct," </title> <journal> Structured Programming, </journal> <volume> vol. 11, no. 1, </volume> <pages> pp. 1-10, </pages> <year> 1990. </year>
Reference-contexts: The view inherits all the generic procedures associated with the abstract type. The view thus makes the application type appear to be a full-fledged implementation of the abstract type. Smith [45] uses the term theory morphism for a similar notion; Gries <ref> [17] </ref> uses the term coupling invariant and cites the term coordinate transformation used by Dijkstra [7]. The example of Fig. 2 illustrates a simple view in which a pipe is viewed as a circle in terms of the basis variable radius. <p> Similar viewpoints are found in mathematical definitions of isomorphism (e.g., [39], p. 129), in denotational semantics [15], and in work on program transformation [45] <ref> [17] </ref>. [13] describes views in terms of such isomorphisms. <p> Storing of basis variables could be implemented by storing into the application data, for functional languages that allow this, or by creating new data with the updated values in the case of strict functional languages. The Polya language <ref> [17] </ref> [8] allows a user to specify a set of transformations that are made to the intermediate code of a generic algorithm; these transformations are equivalent to the transformations performed by the GLISP compiler [31]. <p> This system is interesting and powerful, but its user must be mathematically sophisticated. Gries and Prins [16] proposed a system that would use syntactic transformations to specify the implementation of abstract algorithms. [31] describes related techniques that were implemented earlier. Volpano [51] and Gries <ref> [17] </ref> describe transformation of programs by syntactic coordinate transformations for variables or for patterns involving uses of variables.
Reference: [18] <author> B. Hailpern and H. Ossher, </author> <title> "Extending Objects to Support Multiple Interfaces and Access Control," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 16, no. 11, </volume> <pages> pp. 1247-1257, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: Their MELD system can combine features, which are collections of object classes and methods, to allow additive construction of a system from selected component features. 25 Hailpern and Ossher <ref> [18] </ref> describe views in OOP that are subsets of the methods defined for a class. They use views to restrict use of certain methods; for example, a debugger could use methods that were unavailable to ordinary programs.
Reference: [19] <author> W. Harrison, </author> <title> "RPDE 3 : A Framework for Integrating Tool Fragments," </title> <journal> IEEE Software, </journal> <volume> vol. 4, no. 6, </volume> <pages> pp. 46-56, </pages> <month> Nov. </month> <year> 1987. </year>
Reference-contexts: They use views to restrict use of certain methods; for example, a debugger could use methods that were unavailable to ordinary programs. This system has been used in the RPDE 3 program development environment <ref> [19] </ref>. 6.7 Data Translation IDL (Interface Description Language) [25] allows exchange of large structured data, possibly including structure sharing, between separately written components of a large software system such as a compiler. IDL performs representation translation, so that different representations of data can be used by the different components.
Reference: [20] <author> M. Herlihy and B. Liskov, </author> <title> "A Value Transmission Method for Abstract Data Types," </title> <journal> ACM Trans. Programming Languages Syst., </journal> <volume> vol. 4, no. 4, </volume> <pages> pp. 527-551, </pages> <month> Oct. </month> <year> 1982. </year>
Reference-contexts: IDL performs representation translation, so that different representations of data can be used by the different components. Use of IDL requires that the user write precise specifications of the source and target data structures. Herlihy and Liskov <ref> [20] </ref> describe a method for transmission of structured data over a network, with a possibly different data representation at the destination. Their method employs user-written procedures to encode and decode the data into transmissible representations.
Reference: [21] <author> R. F. Hille, </author> <title> Data Abstraction and Program Development using Modula-2, </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year> <month> 29 </month>
Reference-contexts: Because the components would be verified, unchangeable, and have rigid interfaces, errors in using or modifying them would be prevented. Views, as described in this paper, allow components to be adapted to fit the application. 6.3 Languages with Generic Procedures Programming languages such as Ada, Modula-2 <ref> [21] </ref> [27], and C++ [48] allow parameterized modules; by constructing a module containing generic procedures for a parameterized abstract data type, the user obtains a specialized version of the module and its procedures.
Reference: [22] <author> G. Kaiser and D. Garlan, </author> <title> "Synthesizing Programming Environments from Reusable Features," </title> <booktitle> in [4], </booktitle> <pages> pp. 35-55. </pages>
Reference-contexts: Our system produces efficient specialized procedures in ordinary programming languages and is intended to be used as a program generation system. Garlan [10] and Kaiser <ref> [22] </ref> use views to allow multiple tools in a program development environment to access a common set of data about the program being developed.
Reference: [23] <author> E. Kant, F. Daube, W. MacGregor, and J. Wald, </author> <title> "Scientific Programming by Automated Synthesis," </title> <booktitle> in [28], </booktitle> <pages> pp. 169-205. </pages>
Reference-contexts: Our views specify transformations from features of abstract types to their implementations. Kant et al. <ref> [23] </ref> describe the Sinapse system for generating scientific programs involving simulation of differential equations over large spatial grids for applications such as seismic analysis.
Reference: [24] <author> C. W. Krueger, </author> <title> "Software Reuse," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 24, no. 2, </volume> <pages> pp. 131-184, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Unfortunately, rigidity of types inhibits reuse. Traditional ways of making application data match a procedure that is to be reused are costly and discourage reuse <ref> [24] </ref>. An effective method of reuse must minimize two costs: 1. Human cost: the time required by the programmer to find the program to be reused, to understand its documentation, and to adapt the reused program and/or application so that they fit. 2. <p> The algorithms presented here could be used to generate transforms for a language such as Polya. 6 Related Work 6.1 Software Reuse Krueger <ref> [24] </ref> is an excellent survey of software reuse; it also gives criteria for effective software reuse. Biggerstaff and Perlis [4] contains papers on theory and applications of software reuse. Mili [29] provides an extensive survey of approaches to software reuse, emphasizing the technical challenges of reuse for software production.
Reference: [25] <author> D. Lamb, </author> <title> "IDL: Sharing Intermediate Representations", </title> <journal> ACM Trans. Programming Languages Syst. </journal> <volume> vol. 9, no. 3, </volume> <pages> pp. 267-318, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Materialization of a new data set may be computationally expensive, but the cost is minor for small data sets. It is also reasonable to translate a large data set incrementally, or as a whole if a large amount of computation will be performed on it; <ref> [25] </ref> found that translation of data between phases of a large compiler was a minor cost. 5.3 Object-Oriented, Functional, and Transformational Program ming The algorithms in this paper can be used with other styles of program development. <p> They use views to restrict use of certain methods; for example, a debugger could use methods that were unavailable to ordinary programs. This system has been used in the RPDE 3 program development environment [19]. 6.7 Data Translation IDL (Interface Description Language) <ref> [25] </ref> allows exchange of large structured data, possibly including structure sharing, between separately written components of a large software system such as a compiler. IDL performs representation translation, so that different representations of data can be used by the different components.
Reference: [26] <author> J. Larkin and H. A. Simon, </author> <title> "Why a Diagram is (Sometimes) Worth 10,000 Words," </title> <journal> Cognitive Science, </journal> <volume> 11 </volume> <pages> 65-99, </pages> <note> 1987; also in [44]. </note>
Reference-contexts: The diagram is intended to present virtually all the reasonable possibilities as buttons. This interface has several advantages: 1. Diagrams are easily and rapidly perceived by humans <ref> [26] </ref>, and they are widely used in engineering and scientific communication [11]. 3 If there were alternative representations that were sufficiently different to require different diagrams, a menu to select among alternative diagrams could be presented to the user first. 17 2.
Reference: [27] <author> C. Lins, </author> <title> The Modula-2 Software Component Library, </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Because the components would be verified, unchangeable, and have rigid interfaces, errors in using or modifying them would be prevented. Views, as described in this paper, allow components to be adapted to fit the application. 6.3 Languages with Generic Procedures Programming languages such as Ada, Modula-2 [21] <ref> [27] </ref>, and C++ [48] allow parameterized modules; by constructing a module containing generic procedures for a parameterized abstract data type, the user obtains a specialized version of the module and its procedures.
Reference: [28] <author> M. Lowry and R. McCartney, eds., </author> <title> Automating Software Design, </title> <publisher> AAAI Press / MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Biggerstaff and Perlis [4] contains papers on theory and applications of software reuse. Mili [29] provides an extensive survey of approaches to software reuse, emphasizing the technical challenges of reuse for software production. Artificial intelligence approaches to software engineering are described in [1], <ref> [28] </ref>, and [41]. Some papers from these sources are reviewed individually in this section. 23 6.2 Software Components Weide [52] proposes a software components industry analogous to the electronic components industry, based on formally specified and unchangeable components with rigid interfaces.
Reference: [29] <author> H. Mili, F. Mili, and A. Mili, </author> <title> "Reusing Software: Issues and Research Directions," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 21, no. 6, </volume> <pages> pp. 528-562, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Biggerstaff and Perlis [4] contains papers on theory and applications of software reuse. Mili <ref> [29] </ref> provides an extensive survey of approaches to software reuse, emphasizing the technical challenges of reuse for software production. Artificial intelligence approaches to software engineering are described in [1], [28], and [41].
Reference: [30] <author> R. Neches, R. Fikes, T. Finin, T. Gruber, R. Patil, P. Senator, and W. Swartout, </author> <title> "Enabling Technology for Knowledge Sharing," </title> <journal> AI Magazine, </journal> <volume> vol. 12, no. 3, </volume> <pages> pp. 36-56, </pages> <month> Fall </month> <year> 1991. </year>
Reference-contexts: are many ways in which representations of equivalent data can differ: 1. names of individual variables, 4 2. data representations and units of measurement of variables, 3. data structures used to aggregate variables, 4. the set of variables chosen to represent an object, and 5. the conceptual method, or ontology <ref> [30] </ref>, of a representation. For example, a vector could be represented using Cartesian coordinates or polar coordinates. <p> As use of computer networks increases, users will often need to combine data from different sources or use data with a program that assumes a different format. The ARPA Knowledge-Sharing Project <ref> [30] </ref> addresses the problem of sharing knowledge bases that were developed using different ontologies.
Reference: [31] <author> G. Novak, </author> <title> "GLISP: A LISP-Based Programming System With Data Abstraction," </title> <journal> AI Magazine, </journal> <volume> vol. 4, no. 3, </volume> <pages> pp. 37-47, </pages> <month> Fall </month> <year> 1983. </year>
Reference-contexts: we describe several ways in which views can be applied to achieve reuse: 1. by specialization of generic procedures through views 2. by translation of data 3. by creation of wrappers or transforms for use with object-oriented, functional, or transformational programming. 18 5.1 Specialization of Generic Procedures The GLISP compiler <ref> [31, 32] </ref> can produce a specialized version of a generic procedure by compiling it relative to a view. The result is a self-contained procedure that performs the action of the generic procedure directly on the application data. The specialized procedure can be used as part of the application program. <p> GLISP is a high-level language with abstract data types that is compiled into Lisp; it is implemented in Common Lisp [47]. GLISP types include data structures in Lisp and in other languages. GLISP is described only briefly here; for more detail, see [33] and <ref> [31] </ref>. Data representation is a barrier to reuse in most languages because the syntax of program code depends on the data structures that are used and depends on whether data is stored or is computed. This prevents reuse of code for alternative implementations of data. <p> The Polya language [17] [8] allows a user to specify a set of transformations that are made to the intermediate code of a generic algorithm; these transformations are equivalent to the transformations performed by the GLISP compiler <ref> [31] </ref>. The algorithms presented here could be used to generate transforms for a language such as Polya. 6 Related Work 6.1 Software Reuse Krueger [24] is an excellent survey of software reuse; it also gives criteria for effective software reuse. <p> The user selects transformations to be used and supplies a formal theory for the domain of application. This system is interesting and powerful, but its user must be mathematically sophisticated. Gries and Prins [16] proposed a system that would use syntactic transformations to specify the implementation of abstract algorithms. <ref> [31] </ref> describes related techniques that were implemented earlier. Volpano [51] and Gries [17] describe transformation of programs by syntactic coordinate transformations for variables or for patterns involving uses of variables. <p> Use of views with the GLISP compiler extends good ideas in OOP: 1. OOP makes the connection between a message and the corresponding procedure at runtime; this is often a significant cost [9]. C++ [48] has relatively efficient message dispatching, at some cost in flexibility. Because GLISP <ref> [31] </ref> can specialize a method 26 in-line and optimize the resulting code in context, the overhead of interpretation is eliminated, and often there is no extra cost. 2. Interpretation of messages in OOP postpones error checking to runtime.
Reference: [32] <author> G. Novak, </author> <title> "GLISP User's Manual," </title> <type> Tech. Report STAN-CS-82-895, C.S. </type> <institution> Dept., Stanford Univ., 1982; TR-83-25, A.I. Lab, C.S. Dept., Univ. of Texas at Austin. </institution>
Reference-contexts: we describe several ways in which views can be applied to achieve reuse: 1. by specialization of generic procedures through views 2. by translation of data 3. by creation of wrappers or transforms for use with object-oriented, functional, or transformational programming. 18 5.1 Specialization of Generic Procedures The GLISP compiler <ref> [31, 32] </ref> can produce a specialized version of a generic procedure by compiling it relative to a view. The result is a self-contained procedure that performs the action of the generic procedure directly on the application data. The specialized procedure can be used as part of the application program.
Reference: [33] <author> G. Novak, F. Hill, M. Wan, and B. Sayrs, </author> <title> "Negotiated Interfaces for Software Reuse," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 18, no. 7, </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: The user only needs to select the items in the diagram that correspond to the application data. In this paper, we concentrate on numerical data of the kinds used in scientific and engineering programs. We have previously described <ref> [33] </ref> [34] [35] techniques for reuse of generic algorithms that deal with discrete data structures such as linked lists and trees; those methods, together with the methods described in this paper, allow reuse of algorithms that involve both discrete data structures and numerical data. <p> GLISP is a high-level language with abstract data types that is compiled into Lisp; it is implemented in Common Lisp [47]. GLISP types include data structures in Lisp and in other languages. GLISP is described only briefly here; for more detail, see <ref> [33] </ref> and [31]. Data representation is a barrier to reuse in most languages because the syntax of program code depends on the data structures that are used and depends on whether data is stored or is computed. This prevents reuse of code for alternative implementations of data. <p> This prevents reuse of code for alternative implementations of data. GLISP uses a single syntax, similar to a Lisp function call, to access features of an object <ref> [33] </ref>: ( f eature object ) The interpretation of this form depends on the compile-time type of the object: 1. If f eature is the name of a data field of object, code to access that field is compiled. 2. <p> Writing data translation programs by hand requires human understanding of both data formats. [40] presents a language for describing parameter lists and a system that produces interface modules that translate from a source calling sequence to a target calling sequence. Our paper <ref> [33] </ref> described automatic construction of translation procedures from correspondences; the techniques in this paper extend those. Standardization of data representations and formats is one way to achieve interoperability. However, it is difficult to find standards that fit everyone's needs, and conformity to standards is costly for some users.
Reference: [34] <author> G. Novak, </author> <title> "Software Reuse through View Type Clusters," </title> <booktitle> Proc. Seventh Knowledge-Based Software Eng. Conf., </booktitle> <publisher> IEEE CS Press, </publisher> <pages> pp. 70-79, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: The user only needs to select the items in the diagram that correspond to the application data. In this paper, we concentrate on numerical data of the kinds used in scientific and engineering programs. We have previously described [33] <ref> [34] </ref> [35] techniques for reuse of generic algorithms that deal with discrete data structures such as linked lists and trees; those methods, together with the methods described in this paper, allow reuse of algorithms that involve both discrete data structures and numerical data.
Reference: [35] <author> G. Novak, </author> <title> "Software Reuse by Compilation through View Type Clusters," </title> <note> submitted for publication. </note>
Reference-contexts: The user only needs to select the items in the diagram that correspond to the application data. In this paper, we concentrate on numerical data of the kinds used in scientific and engineering programs. We have previously described [33] [34] <ref> [35] </ref> techniques for reuse of generic algorithms that deal with discrete data structures such as linked lists and trees; those methods, together with the methods described in this paper, allow reuse of algorithms that involve both discrete data structures and numerical data. <p> The messages expected by the target class correspond to basis variables. The equations produced in making views can easily be converted into methods in the appropriate syntax for the OOP system. We have previously described <ref> [35] </ref> the use of wrapper objects to allow display and direct-manipulation editing of user data by generic editor programs. There are two disadvantages of using wrapper objects [9]. It is necessary to allocate a wrapper object at runtime, which costs time and storage.
Reference: [36] <author> G. Novak, </author> <title> "Generating Programs from Connections of Physical Models," </title> <booktitle> Proc. 10th Conf. on Artificial Intelligence for Applications, </booktitle> <publisher> IEEE CS Press, </publisher> <month> Mar. </month> <year> 1994, </year> <pages> pp. 224-230. 30 </pages>
Reference-contexts: The code that is produced is optimized and efficient. 5. Static error checking is performed at compile time. Related techniques have been used to create programs by connecting diagrammatic representations of physical and mathematical laws <ref> [36] </ref>.
Reference: [37] <author> G. Novak, </author> <title> "Conversion of Units of Measurement," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 21, no. 8, </volume> <pages> pp. 651-661, </pages> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: Most programming languages omit units of measurement entirely: there is no way to state the units that are used, much less to check consistency of units. GLISP allows units to be specified, and it automatically performs unit conversion <ref> [37] </ref> and checks validity.
Reference: [38] <author> L. C. Paulson,, </author> <title> ML for the Working Programmer, </title> <publisher> Cambridge Univ. Press, </publisher> <year> 1991. </year>
Reference-contexts: these languages allow much less parameterization than is possible using views; for example, it is not possible to define a procedure that works for either Cartesian or polar vectors, and it is not even possible to state units of measurement in these languages. 6.4 Functional and Set Languages ML [53] <ref> [38] </ref> is like a strongly typed Lisp; it includes polymorphic functions (e.g., functions over lists of an arbitrary type) and functors (functions that map structures, composed of types and functions, to structures). ML also includes references (pointers) that allow imperative programming. <p> Our system also allows composition of views. Miranda [50] is a strongly typed, purely functional language that supports higher-order functions. While this allows generic functions to be written, it is often difficult to write efficient programs in a purely functional language <ref> [38] </ref>: a change to data values requires creation of a new structure in a functional language. 6.5 Transformation Systems Transformation systems generate programs starting from an abstract algorithm specification; they repeatedly apply transformations that replace parts of the abstract algorithm with code that is closer to an implementation, until executable code
Reference: [39] <author> F. Preparata and R. Yeh, </author> <title> Introduction to Discrete Structures, </title> <publisher> Addison-Wesley, </publisher> <year> 1973. </year>
Reference-contexts: Similar viewpoints are found in mathematical definitions of isomorphism (e.g., <ref> [39] </ref>, p. 129), in denotational semantics [15], and in work on program transformation [45] [17]. [13] describes views in terms of such isomorphisms.
Reference: [40] <author> J. M. Purtilo and J. M. Atlee, </author> <title> "Module Reuse by Interface Adaptation," </title> <journal> Software Practice and Experience, </journal> <volume> vol. 21, no. 6, </volume> <pages> pp. 539-556, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The ARPA Knowledge-Sharing Project [30] addresses the problem of sharing knowledge bases that were developed using different ontologies. Writing data translation programs by hand requires human understanding of both data formats. <ref> [40] </ref> presents a language for describing parameter lists and a system that produces interface modules that translate from a source calling sequence to a target calling sequence. Our paper [33] described automatic construction of translation procedures from correspondences; the techniques in this paper extend those. <p> The Common Object Request Broker Architecture (CORBA) [6] includes an Interface Definition Language and can automatically generate stubs to allow interoperability of objects across distributed systems and across languages and machine architectures. Purtilo and Atlee <ref> [40] </ref> describe a system that translates calling sequences by producing small interface modules that reorder and translate parameters as necessary for the called procedure. In all of these cases, the emphasis is on relatively direct translation of data, focusing on issues of record structure, number representation, etc.
Reference: [41] <editor> C. Rich and R. Waters (eds), </editor> <booktitle> Readings in Artificial Intelligence and Software Engineering, </booktitle> <address> San Francisco: </address> <publisher> Morgan Kaufmann, </publisher> <year> 1986. </year>
Reference-contexts: Biggerstaff and Perlis [4] contains papers on theory and applications of software reuse. Mili [29] provides an extensive survey of approaches to software reuse, emphasizing the technical challenges of reuse for software production. Artificial intelligence approaches to software engineering are described in [1], [28], and <ref> [41] </ref>. Some papers from these sources are reviewed individually in this section. 23 6.2 Software Components Weide [52] proposes a software components industry analogous to the electronic components industry, based on formally specified and unchangeable components with rigid interfaces.
Reference: [42] <author> C. Rich and R. Waters, </author> <title> The Programmer's Apprentice, </title> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: Reuse of a carefully developed generic procedure is faster, less costly, and less error-prone than writing one by hand. Code that results from the viewing and compilation process is presented below. We do not expect a user of our system to read or understand such code. While some authors <ref> [42] </ref> have proposed that the user read and edit code that is produced by an automatic programming system, we do not: it is not easy to read someone else's code, and this is especially true for machine-generated code that has been optimized.
Reference: [43] <author> M. Schaefer, </author> <title> A Mathematical Theory of Global Program Optimization, </title> <publisher> Prentice-Hall, </publisher> <year> 1973. </year>
Reference-contexts: While repeated subexpressions sometimes appear in specialized code, these can be removed by the well-understood compiler technique of common subexpression elimination <ref> [43] </ref>. A useful viewpoint is that there is a mapping between an abstract data type and the corresponding application type, and an isomorphism between the two based on a generic algorithm and a specialized version of that algorithm.
Reference: [44] <editor> H. A. Simon, </editor> <booktitle> Models of Thought, </booktitle> <volume> vol. 2, </volume> <publisher> Yale Univ. Press, </publisher> <year> 1989. </year>
Reference: [45] <author> D. R. Smith, "KIDS: </author> <title> A Semiautomatic Program Development System," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 16, no. 9, </volume> <pages> pp. 1024-1043, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: The view inherits all the generic procedures associated with the abstract type. The view thus makes the application type appear to be a full-fledged implementation of the abstract type. Smith <ref> [45] </ref> uses the term theory morphism for a similar notion; Gries [17] uses the term coupling invariant and cites the term coordinate transformation used by Dijkstra [7]. <p> Similar viewpoints are found in mathematical definitions of isomorphism (e.g., [39], p. 129), in denotational semantics [15], and in work on program transformation <ref> [45] </ref> [17]. [13] describes views in terms of such isomorphisms.
Reference: [46] <author> D. R. Smith, </author> <title> "KIDS A Knowledge-based Software Development System," </title> <booktitle> in [28], </booktitle> <pages> pp. 483-514. </pages>
Reference-contexts: Sinapse accepts a relatively small program specification and generates from it a 24 much larger program in Fortran or other languages by repeatedly applying transformations within Mathematica [54]. This system appears to work well within its domain of applicability. KIDS <ref> [46] </ref> can transform general algorithms into executable versions that are highly efficient for combinatorial problems. The user selects transformations to be used and supplies a formal theory for the domain of application. This system is interesting and powerful, but its user must be mathematically sophisticated.
Reference: [47] <author> G. Steele, </author> <title> Common Lisp: the Language, </title> <publisher> Digital Press, </publisher> <year> 1990. </year>
Reference-contexts: The specialized procedure can be used as part of the application program. GLISP is a high-level language with abstract data types that is compiled into Lisp; it is implemented in Common Lisp <ref> [47] </ref>. GLISP types include data structures in Lisp and in other languages. GLISP is described only briefly here; for more detail, see [33] and [31].
Reference: [48] <author> B. Stroustrup, </author> <title> The C++ Programming Language, </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Views, as described in this paper, allow components to be adapted to fit the application. 6.3 Languages with Generic Procedures Programming languages such as Ada, Modula-2 [21] [27], and C++ <ref> [48] </ref> allow parameterized modules; by constructing a module containing generic procedures for a parameterized abstract data type, the user obtains a specialized version of the module and its procedures. <p> Use of views with the GLISP compiler extends good ideas in OOP: 1. OOP makes the connection between a message and the corresponding procedure at runtime; this is often a significant cost [9]. C++ <ref> [48] </ref> has relatively efficient message dispatching, at some cost in flexibility. Because GLISP [31] can specialize a method 26 in-line and optimize the resulting code in context, the overhead of interpretation is eliminated, and often there is no extra cost. 2.
Reference: [49] <author> W. Tracz, "LILEANNA: </author> <title> A parameterized programming language," </title> <booktitle> 2nd Int'l Workshop on Software Reuse: Advances in Software Reusability (IWSR-2), </booktitle> <publisher> IEEE CS Press, </publisher> <month> Mar. </month> <year> 1993, </year> <pages> pp. 66-78. </pages>
Reference-contexts: The authors state ([14], p. 56): OBJ3 is not a compiler, but is rather closer to an interpreter. The associa tive/commutative rewrite engine is not efficient enough for very large problems... Tracz <ref> [49] </ref> describes LILEANNA, which implements LIL for construction of Ada packages; views in LILEANNA map types, operations, and exceptions between theories. Our system creates views from correspondences between application types and mathematical objects; the possible correspondences are more general than the one-to-one correspondences specified in OBJ3 views.
Reference: [50] <author> D. Turner, </author> <title> "An Overview of Miranda," </title> <journal> SIGPLAN Notices, </journal> <month> Dec. </month> <year> 1986. </year>
Reference-contexts: However, ML does not allow generics as general as those described here. Our system allows storing into a data structure through a view; for example, a radius value can be "stored" into a pipe through a view. Our system also allows composition of views. Miranda <ref> [50] </ref> is a strongly typed, purely functional language that supports higher-order functions.
Reference: [51] <author> D. Volpano. and R. Kieburtz, </author> <title> "The Templates Approach to Software Reuse," </title> <booktitle> in [4], </booktitle> <pages> pp. 247-255. </pages>
Reference-contexts: This system is interesting and powerful, but its user must be mathematically sophisticated. Gries and Prins [16] proposed a system that would use syntactic transformations to specify the implementation of abstract algorithms. [31] describes related techniques that were implemented earlier. Volpano <ref> [51] </ref> and Gries [17] describe transformation of programs by syntactic coordinate transformations for variables or for patterns involving uses of variables.
Reference: [52] <author> B. W. Weide, W. F. Ogden, and S. H. </author> <title> Zweben, "Reusable Software Components," </title> <booktitle> in [55], </booktitle> <pages> pp. 1-65. </pages>
Reference-contexts: Mili [29] provides an extensive survey of approaches to software reuse, emphasizing the technical challenges of reuse for software production. Artificial intelligence approaches to software engineering are described in [1], [28], and [41]. Some papers from these sources are reviewed individually in this section. 23 6.2 Software Components Weide <ref> [52] </ref> proposes a software components industry analogous to the electronic components industry, based on formally specified and unchangeable components with rigid interfaces. Because the components would be verified, unchangeable, and have rigid interfaces, errors in using or modifying them would be prevented.
Reference: [53] <author> A. Wikstrom, </author> <title> Functional Programming Using Standard ML, </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: However, these languages allow much less parameterization than is possible using views; for example, it is not possible to define a procedure that works for either Cartesian or polar vectors, and it is not even possible to state units of measurement in these languages. 6.4 Functional and Set Languages ML <ref> [53] </ref> [38] is like a strongly typed Lisp; it includes polymorphic functions (e.g., functions over lists of an arbitrary type) and functors (functions that map structures, composed of types and functions, to structures). ML also includes references (pointers) that allow imperative programming.
Reference: [54] <author> S. Wolfram, </author> <title> Mathematica: a System for Doing Mathematics by Computer, </title> <publisher> Addison Wesley, </publisher> <year> 1991. </year>
Reference-contexts: A view must have a procedure to read and write each basis variable, while maintaining the storage and independence properties. The procedures are derived by symbolic algebra. Although powerful packages such as Mathematica <ref> [54] </ref> exist, we use a simple equation solver 1 Our interface actually allows an algebraic expression in terms of variables or computed quantities from the application type. 7 (setf (get 'line-segment 'basis-vars) '(p1x p1y p2x p2y)) (setf (get 'line-segment 'equations) '((= p1 (tuple (x p1x) (y p1y))) (= p1x (x p1)) <p> Sinapse accepts a relatively small program specification and generates from it a 24 much larger program in Fortran or other languages by repeatedly applying transformations within Mathematica <ref> [54] </ref>. This system appears to work well within its domain of applicability. KIDS [46] can transform general algorithms into executable versions that are highly efficient for combinatorial problems. The user selects transformations to be used and supplies a formal theory for the domain of application.
Reference: [55] <editor> M. C. Yovits, ed., </editor> <booktitle> Advances in Computers, </booktitle> <volume> vol. 33, </volume> <publisher> Academic Press, </publisher> <year> 1991. </year> <month> 31 </month>
References-found: 54

