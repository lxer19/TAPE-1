URL: http://www.cs.columbia.edu/~cdo/ml98maps.ps.gz
Refering-URL: http://www.cs.columbia.edu/~cdo/papers.html
Root-URL: http://www.cs.columbia.edu
Email: cokasaki@cs.columbia.edu  ajgill@semdesigns.com  
Title: Fast Mergeable Integer Maps  
Author: Chris Okasaki Andrew Gill 
Address: Austin, TX  
Affiliation: Department of Computer Science Columbia University  Semantic Designs  
Abstract: Finite maps are ubiquitous in many applications, but perhaps nowhere more so than in compilers and other language processors. In these applications, three operations on finite maps dominate all others: looking up the value associated with a key, inserting a new binding, and merging two finite maps. Most implementations of finite maps in functional languages are based on balanced binary search trees, which perform well on the first two, but poorly on the third. We describe an implementation of finite maps with integer keys that performs well in practice on all three operations. This data structure is not new|indeed, it is thirty years old this year|but it deserves to be more widely known.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Adams, S. </author> <title> Efficient sets|a balancing act. </title> <journal> Journal of Functional Programming 3, </journal> <month> 4 (Oct. </month> <year> 1993), </year> <pages> 553-561. </pages>
Reference-contexts: Figure 1 (b) shows the effect of this optimization on the example trie from Figure 1 (a). This representation can be enforced by constructing trees, not with the Br constructor directly, but rather with a helper function called a smart constructor <ref> [1] </ref>. fun br (Empty,Empty) = Empty | br (t0,t1) = Br (t0,t1) The lookup function given above still works for this new representation. Next, consider a map containing only a single binding. <p> Besides little- and big-endian Patricia trees, we tested splay trees [5], red-black trees [6], and balanced binary search trees derived from Adams' implementation <ref> [1] </ref>. All the implementations were tuned to approximately the same degree. The results are mixed. Splay trees are lightning fast on insertions (especially sequential insertions), and also perform quite well on merges.
Reference: [2] <author> Hoogerwoord, R. R. </author> <title> A logarithmic implementation of flexible arrays. </title> <booktitle> In Conference on Mathematics of Program Construction (July 1992), vol. 669 of LNCS, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 191-207. </pages>
Reference-contexts: This is similar to a Braun tree <ref> [2, 4] </ref>, except that in a Braun tree, data is stored at every node, whereas in a binary trie, data is stored only at the leaves.
Reference: [3] <author> Morrison, D. R. </author> <title> PATRICIA|practical algorithm to retrieve information coded in alphanumeric. </title> <journal> J. ACM 15, </journal> <month> 4 (Oct. </month> <year> 1968), </year> <pages> 514-534. </pages>
Reference-contexts: We describe an alternative implementation of finite maps with integer keys that performs extremely well in practice on all three operations. Our design is based on a thirty-year-old data structure known as a Patricia tree <ref> [3] </ref>, which deserves to be more widely known. <p> The br smart constructor now guarantees that no Empty node is ever a child of a Br node. fun br (p,m,Empty,t) = t | br (p,m,t,Empty) = t | br (p,m,t0,t1) = Br (p,m,t0,t1) This final design is called a Patricia tree <ref> [3] </ref>. It uses n Lf nodes and n 1 Br nodes to represent a finite map of size n &gt; 0. The worst-case running time of lookup is O (min (n; W )), where W is the word size of the int type.
Reference: [4] <author> Okasaki, C. </author> <title> Three algorithms on Braun trees. </title> <journal> Journal of Functional Programming 7, </journal> <volume> 6 (Nov. </volume> <year> 1997), </year> <pages> 661-666. </pages>
Reference-contexts: This is similar to a Braun tree <ref> [2, 4] </ref>, except that in a Braun tree, data is stored at every node, whereas in a binary trie, data is stored only at the leaves.
Reference: [5] <author> Okasaki, C. </author> <title> Purely Functional Data Structures. </title> <publisher> Cambridge University Press, </publisher> <year> 1998. </year>
Reference-contexts: Besides little- and big-endian Patricia trees, we tested splay trees <ref> [5] </ref>, red-black trees [6], and balanced binary search trees derived from Adams' implementation [1]. All the implementations were tuned to approximately the same degree. The results are mixed. Splay trees are lightning fast on insertions (especially sequential insertions), and also perform quite well on merges.
Reference: [6] <author> Okasaki, C. </author> <title> Red-black trees in a functional setting. </title> <journal> Journal of Functional Programming (1998). </journal> <note> To appear. 86 </note>
Reference-contexts: Besides little- and big-endian Patricia trees, we tested splay trees [5], red-black trees <ref> [6] </ref>, and balanced binary search trees derived from Adams' implementation [1]. All the implementations were tuned to approximately the same degree. The results are mixed. Splay trees are lightning fast on insertions (especially sequential insertions), and also perform quite well on merges.
References-found: 6

