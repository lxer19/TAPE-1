URL: http://www.cs.berkeley.edu/~ghorm/papers/slic-tr.ps
Refering-URL: http://www.cs.berkeley.edu/~ghorm/papers/
Root-URL: 
Email: fghorm,steverod,dpetrou,teag@cs.berkeley.edu  
Title: Interposition as an Operating System Extension Mechanism  
Author: Douglas P. Ghormley Steven H. Rodrigues David Petrou Thomas E. Anderson 
Date: September 25, 1997  
Address: Berkeley, CA 94720  
Affiliation: Computer Science Division University of California at Berkeley  
Abstract: Modern production operating systems are large and complex systems developed over many years by large teams of programmers, containing many hundreds of thousands of lines of code. Consequently, it is extremely difficult to add significant new functionality to these systems [16, 1, 42]. In response to this problem, a number of recent research projects have addressed the issue of extensible operating systems; these include SPIN [7, 5], VINO [45, 41], Ex-okernel [20], Lipto [17], and Fluke [21]. This paper addresses the problem of providing extensibility for existing production operating systems such as Solaris, through the technique of interposition on existing kernel interfaces. Interposition is useful as an extension mechanism because it is transparent, it permits the incremental addition of functionality to an interface, and it enables the easy composition of multiple extensions. We have designed and implemented a prototype extension mechanism, SLIC, which utilizes interposition to efficiently insert trusted extension code into a production operating system kernel. We have used SLIC to implement a number of useful operating system extensions: a patch to fix a security hole described in a CERT advisory, a simple encryption file system, and a restricted execution environment for arbitrary untrusted binaries. Performance measurements of the SLIC prototype show that interposition on existing kernel interfaces can be accomplished efficiently. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: A New Kernel Foundation For UNIX Development. </title> <booktitle> In Proceedings of the 1986 USENIX Summer Conference, </booktitle> <pages> pages 93-112, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Consequently, in practice, it is extremely difficult to add significant new functionality to modern production operating systems <ref> [16, 1, 42] </ref>. This does not diminish the need to continue to modify these systems. For example, security flaws are routinely discovered and reported by organizations such as Carnegie-Mellon's Computer Emergency Response Team (CERT) and the Department of Energy's Computer Incident Advisory Capability (CIAC). <p> Over the years, a number of systems have attempted to reduce the cost of adding new kernel functionality by restructuring the operating system with extensibility as a design goal. Systems built using this approach include Hydra [53], 1 Mach <ref> [1] </ref>, SPIN [7, 5], VINO [45, 41], Exokernel [20], Lipto [17], and Fluke [21]. Many of these systems have successfully demonstrated greatly reduced costs of adding new functionality. However, the cost of starting over from scratch can be prohibitive; for example, Microsoft has spent over $300M developing Windows NT [55]. <p> We believe that no other system provides this powerful combination of features for extending existing production operating systems. Specifically, Interposition Agents [27] leverages the Mach <ref> [1] </ref> system call redirection facility to transparently insert extensions at the system call interface. However, since the extension code runs in the application's address space and protection domain, this solution cannot enforce security guarantees or share resources among distrustful processes. <p> The drawback of this approach is that invoking the extension from the dispatcher requires costly context switches and kernel-user boundary crossings. This organization is similar to that employed by micro-kernels such as Mach <ref> [1] </ref>. An in-kernel extension is loaded directly into the kernel. When events are frequent, this organization has considerably better performance than the user-level approach, since the extensions are directly invoked by a procedure call from the dispatcher.
Reference: [2] <author> C. Amza, Alan L. Cox, Sandhya Dwarkadas, Peter Keleher, H. Lu, R. Rajamony, Weimin Yu, and Willy Zwaenepoel. TreadMarks: </author> <title> Shared memory computing on networks of workstations. </title> <journal> IEEE Computer, </journal> <volume> 29(2) </volume> <pages> 18-28, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: Forms of interposition can be found in the `pipe' construct used in Unix shells, in the extensibility mechanisms of programming language systems [29], in distributed file systems such as NFS [40], in distributed shared memory systems such as TreadMarks <ref> [2] </ref>, in World Wide Web proxy caches [8], and in MS-DOS terminate-and-stay-resident utilities and Macintosh toolbox extensions. 3 SLIC Design and Implementation To investigate the suitability of interposition for adding new functionality to existing operating systems, we have designed and implemented SLIC, an interposition mechanism for production Unix operating systems.
Reference: [3] <author> Thomas Anderson, Brian Bershad, Edward Lazowska, and Henry Levy. </author> <title> Scheduler Activations: Effective Kernel Support for the User-Level Management of Parallelism. </title> <journal> In ACM Transactions on Computer Systems, </journal> <pages> pages 53-79, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: We are also exploring the design space of useful extensions to be built with SLIC. Among these are transparent remote execution, a single system image in a network of workstations, extending the semantics of NFS to include full cache-coherency for simultaneous access [46] and supporting scheduler activations <ref> [3] </ref> through interposition on signals or directly on the scheduler. 8 Conclusion This paper has examined the utility of interposition as a mechanism for adding extensibility to production operating systems.
Reference: [4] <author> Arindam Banerji, John M. Tracey, and David L. Cohn. </author> <title> Protected Shared Libraries a new approach to modularity and sharing. </title> <booktitle> In Proceedings of the 1997 USENIX Technical Conference, </booktitle> <pages> pages 59-76, </pages> <address> Anaheim, CA, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: Software Fault Isolation (SFI) [50] can be used to rewrite application binaries to protect extensions running at user level from the application; unfortunately, it is difficult to apply SFI to arbitrary application programs without prohibitive implementation complexity. Protected Shared Libraries <ref> [4] </ref> has the same capability as SFI with less software effort, but requires specialized hardware support that is not available on most architectures. <p> COLA [31] enables interposition at the system call interface, but without any modification of the operating system kernel. It operates through interposition at the library level and consequently suffers from the same security drawbacks as the interposition technology used in [27]. Protected Shared Libraries <ref> [4] </ref> enables extensions to be securely loaded into an application's address space, so that user programs cannot access or modify extension code or data.
Reference: [5] <author> B. N. Bershad, S. Savage, E. G. Sirer P. Pardyak, M. Fiuczyn-ski, D. Becker, C. Chambers, and S. Eggers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: Over the years, a number of systems have attempted to reduce the cost of adding new kernel functionality by restructuring the operating system with extensibility as a design goal. Systems built using this approach include Hydra [53], 1 Mach [1], SPIN <ref> [7, 5] </ref>, VINO [45, 41], Exokernel [20], Lipto [17], and Fluke [21]. Many of these systems have successfully demonstrated greatly reduced costs of adding new functionality. However, the cost of starting over from scratch can be prohibitive; for example, Microsoft has spent over $300M developing Windows NT [55]. <p> Ease of Development: Extension writers should be able to use state-of-the-art programming tools such as sym bolic debuggers and performance analysis tools. SLIC assumes that extensions are trusted. Other research efforts have addressed the issues involved with supporting untrusted extensions <ref> [50, 5, 41] </ref>. 3.1 SLIC Architecture SLIC is comprised of multiple dispatchers and extensions as well as various support routines. Dispatchers are responsible for intercepting system interface events and for routing those events to interested extensions. Extensions receive events from the dispatcher and provide additional functionality to the operating system. <p> Finally, a simple method should be provided to enable dispatchers to write to the kernel code image. This is necessary to enable interposition on procedural interfaces using binary patching. 6 Related Work There has been a considerable amount of recent work <ref> [17, 45, 5, 20, 21] </ref> that has focused on building highly-extensible operating systems. Because these systems have built new operating systems kernels and new kernel structures, they have not focused on the problem of extensibility for existing systems. <p> Because these systems have built new operating systems kernels and new kernel structures, they have not focused on the problem of extensibility for existing systems. Of these systems, SPIN <ref> [5] </ref> and VINO [45, 41] are the closest in concept to our work. Both offer extensibility through interposition on a number of kernel interfaces. These interfaces have been explicitly designed for extensibility, rather than enabling extensibility on existing interfaces, which SLIC supports.
Reference: [6] <author> Brian Bershad, Thomas Anderson, Edward Lazowska, and Henry Levy. </author> <title> Lightweight Remote Procedure Calls. </title> <journal> In ACM Transactions on Computer Systems, </journal> <pages> pages 37-54, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: In addition, there is a large catalog of value-add functionality that has not been widely deployed, in part because of the difficulty of modifying existing systems: load sharing [56], process migration [48, 16], fast communication primitives <ref> [6, 49] </ref>, upcalls [14], distributed shared memory [32], and user-level pagers [54]. The goal of this paper is to simplify the process of evolving and extending existing production operating systems.
Reference: [7] <author> Brian N. Bershad, Craig Chambers, Susan Eggers, Chris Maeda, Dylan McNamee, Przemysaw Pardyak, Stefan Savage, and Emin G. Sirer. </author> <title> SPINAn Extensible Microkernel for Application-Specific Operating System Services. </title> <type> Technical report, </type> <institution> University of Washingtion, </institution> <year> 1994. </year>
Reference-contexts: Over the years, a number of systems have attempted to reduce the cost of adding new kernel functionality by restructuring the operating system with extensibility as a design goal. Systems built using this approach include Hydra [53], 1 Mach [1], SPIN <ref> [7, 5] </ref>, VINO [45, 41], Exokernel [20], Lipto [17], and Fluke [21]. Many of these systems have successfully demonstrated greatly reduced costs of adding new functionality. However, the cost of starting over from scratch can be prohibitive; for example, Microsoft has spent over $300M developing Windows NT [55].
Reference: [8] <author> C. Mic Bowman, Peter B. Danzig, Darren R. Hardy, Udi Man-ber, and Michael F. Schwartz. </author> <title> The Harvest information discovery and access system. </title> <booktitle> In Proceedings of the Second International World Wide Web Conference, </booktitle> <pages> pages 763-771, </pages> <month> Oc-tober </month> <year> 1994. </year>
Reference-contexts: Forms of interposition can be found in the `pipe' construct used in Unix shells, in the extensibility mechanisms of programming language systems [29], in distributed file systems such as NFS [40], in distributed shared memory systems such as TreadMarks [2], in World Wide Web proxy caches <ref> [8] </ref>, and in MS-DOS terminate-and-stay-resident utilities and Macintosh toolbox extensions. 3 SLIC Design and Implementation To investigate the suitability of interposition for adding new functionality to existing operating systems, we have designed and implemented SLIC, an interposition mechanism for production Unix operating systems.
Reference: [9] <author> Kraig Brockschmidt. </author> <title> Inside OLE 2. </title> <publisher> Microsoft Press, </publisher> <address> Red-mond, WA, </address> <year> 1994. </year>
Reference-contexts: By contrast with operating systems where relatively few successful ISV's exist (Transarc being a notable exception), robust ISV markets exist in other areas, such as databases [18], Web software [24, 33], and desktop publishing <ref> [38, 9] </ref> in each case, because extensibility has been designed into the system.
Reference: [10] <editor> Vulnerability in expreserve. CERT Advisory CA-96.19, CERT, </editor> <month> August </month> <year> 1996. </year>
Reference-contexts: Whenever possible, these advisories include information on how to resolve the problem reported. However, due to the lack of extensibility in existing systems, frequently this advice is to completely disable the insecure feature <ref> [11, 10, 12] </ref>. Though operating system vendors do provide patches for software found to be insecure, these patches can take weeks to become available [13]. Since CERT does not have access to source code for many systems, they are unable to directly provide patches for these problems.
Reference: [11] <editor> Vulnerability in Solaris admintool. CERT Advisory CA-96.16, CERT, </editor> <month> August </month> <year> 1996. </year>
Reference-contexts: The prototype currently runs on Solaris 2.5 and a Linux 2.0 port is in progress. We have used the SLIC prototype to implement a number of extensions that would have been significantly more difficult to accomplish by other means. One extension patches a security flaw publicized by CERT <ref> [11] </ref>. A second enables process execution with restricted capabilities, while a third is an encrypted file system. The rest of this paper is organized as follows. Section 2 provides background on interposition. In section 3, we describe the design, implementation, and performance of SLIC, our prototype interposition system. <p> Whenever possible, these advisories include information on how to resolve the problem reported. However, due to the lack of extensibility in existing systems, frequently this advice is to completely disable the insecure feature <ref> [11, 10, 12] </ref>. Though operating system vendors do provide patches for software found to be insecure, these patches can take weeks to become available [13]. Since CERT does not have access to source code for many systems, they are unable to directly provide patches for these problems. <p> However, using SLIC, many of these advisories could be accompanied by small extensions which would resolve the problem. To demonstrate this, we have implemented an extension to patch a recent security hole discovered in the Solaris admintool <ref> [11] </ref> which allowed unprivileged users to delete arbitrary files in the system in certain circumstances. Our 25 line extension monitors file operations, denying the operations which cause the problem.
Reference: [12] <editor> Vulnerability in WorkMan. CERT Advisory CA-96.23, CERT, </editor> <month> October </month> <year> 1996. </year>
Reference-contexts: Whenever possible, these advisories include information on how to resolve the problem reported. However, due to the lack of extensibility in existing systems, frequently this advice is to completely disable the insecure feature <ref> [11, 10, 12] </ref>. Though operating system vendors do provide patches for software found to be insecure, these patches can take weeks to become available [13]. Since CERT does not have access to source code for many systems, they are unable to directly provide patches for these problems.
Reference: [13] <editor> Vulnerability in talkd. CERT Advisory CA-97.04, CERT, </editor> <month> January </month> <year> 1997. </year>
Reference-contexts: Despite the need for immediate repair to prevent wide exploitation of the flaw, the required patches can take weeks to become available <ref> [13] </ref>. In addition, there is a large catalog of value-add functionality that has not been widely deployed, in part because of the difficulty of modifying existing systems: load sharing [56], process migration [48, 16], fast communication primitives [6, 49], upcalls [14], distributed shared memory [32], and user-level pagers [54]. <p> However, due to the lack of extensibility in existing systems, frequently this advice is to completely disable the insecure feature [11, 10, 12]. Though operating system vendors do provide patches for software found to be insecure, these patches can take weeks to become available <ref> [13] </ref>. Since CERT does not have access to source code for many systems, they are unable to directly provide patches for these problems. However, using SLIC, many of these advisories could be accompanied by small extensions which would resolve the problem.
Reference: [14] <author> David D. Clark. </author> <title> The Structuring of Systems Using Upcalls. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 171-180, </pages> <month> December 1-4 </month> <year> 1985. </year>
Reference-contexts: In addition, there is a large catalog of value-add functionality that has not been widely deployed, in part because of the difficulty of modifying existing systems: load sharing [56], process migration [48, 16], fast communication primitives [6, 49], upcalls <ref> [14] </ref>, distributed shared memory [32], and user-level pagers [54]. The goal of this paper is to simplify the process of evolving and extending existing production operating systems. A consequence of accomplishing this would be to enable independent software vendors (ISV's) to develop and deploy innovative operating system features.
Reference: [15] <institution> Chaos Computer Club. CCC: Microsoft security alert. </institution> <address> http://berlin.ccc.de/radioactivex.html, March 1997. </address>
Reference-contexts: There are many cases, however, in which the user does not trust the program being run. For example, programs downloaded from untrusted sources like the Internet may actually be Trojan horses designed to steal or destroy information <ref> [52, 15] </ref>. In addition, there are cases in which the user trusts the program, but not the data being processed, as in the case of helper applications used by web browsers to display various data formats.
Reference: [16] <author> Fred Douglis and John Ousterhout. </author> <title> Transparent Process Migration: Design Alternatives and the Sprite Implementation. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 21(8) </volume> <pages> 757-85, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Consequently, in practice, it is extremely difficult to add significant new functionality to modern production operating systems <ref> [16, 1, 42] </ref>. This does not diminish the need to continue to modify these systems. For example, security flaws are routinely discovered and reported by organizations such as Carnegie-Mellon's Computer Emergency Response Team (CERT) and the Department of Energy's Computer Incident Advisory Capability (CIAC). <p> In addition, there is a large catalog of value-add functionality that has not been widely deployed, in part because of the difficulty of modifying existing systems: load sharing [56], process migration <ref> [48, 16] </ref>, fast communication primitives [6, 49], upcalls [14], distributed shared memory [32], and user-level pagers [54]. The goal of this paper is to simplify the process of evolving and extending existing production operating systems.
Reference: [17] <author> Peter Druschel, Larry L. Peterson, and Norman Hutchinson. </author> <title> Beyond Micro-Kernel Design: Decoupling Modularity and Protection in Lipto. </title> <booktitle> In Proceedings of the 12th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 512-520, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Over the years, a number of systems have attempted to reduce the cost of adding new kernel functionality by restructuring the operating system with extensibility as a design goal. Systems built using this approach include Hydra [53], 1 Mach [1], SPIN [7, 5], VINO [45, 41], Exokernel [20], Lipto <ref> [17] </ref>, and Fluke [21]. Many of these systems have successfully demonstrated greatly reduced costs of adding new functionality. However, the cost of starting over from scratch can be prohibitive; for example, Microsoft has spent over $300M developing Windows NT [55]. <p> Finally, a simple method should be provided to enable dispatchers to write to the kernel code image. This is necessary to enable interposition on procedural interfaces using binary patching. 6 Related Work There has been a considerable amount of recent work <ref> [17, 45, 5, 20, 21] </ref> that has focused on building highly-extensible operating systems. Because these systems have built new operating systems kernels and new kernel structures, they have not focused on the problem of extensibility for existing systems.
Reference: [18] <author> Timothy Dyck. </author> <title> Informix slices its way to front. </title> <booktitle> PC Week, </booktitle> <address> 14(9):1, </address> <month> March </month> <year> 1997. </year>
Reference-contexts: A consequence of accomplishing this would be to enable independent software vendors (ISV's) to develop and deploy innovative operating system features. By contrast with operating systems where relatively few successful ISV's exist (Transarc being a notable exception), robust ISV markets exist in other areas, such as databases <ref> [18] </ref>, Web software [24, 33], and desktop publishing [38, 9] in each case, because extensibility has been designed into the system.
Reference: [19] <author> Mark W. Eichin and Jon A. Rochlis. </author> <title> With Microscope and Tweezers: An Analysis of the Internet Virus of November 1988. </title> <booktitle> In Proceedings of the 1989 IEEE Symposium on Research in Security and Privacy, </booktitle> <year> 1989. </year>
Reference-contexts: Input data could potentially exploit bugs in helper applications to insert Trojan horses into the system, a process similar to that used by the Internet Worm fingerd attack <ref> [19] </ref>. A common method for constructing a restricted execution environment is to use the tracing facility of the standard /proc file system to selectively deny or change those system calls which would violate security [23]. This approach suffers from a number of shortcomings.
Reference: [20] <author> D. R. Engler, M. F. Kaashoek, and Jr J. O'Toole. Exokernel: </author> <title> An Operating System Architecture for Application-Level Resource Management. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year> <month> 12 </month>
Reference-contexts: Over the years, a number of systems have attempted to reduce the cost of adding new kernel functionality by restructuring the operating system with extensibility as a design goal. Systems built using this approach include Hydra [53], 1 Mach [1], SPIN [7, 5], VINO [45, 41], Exokernel <ref> [20] </ref>, Lipto [17], and Fluke [21]. Many of these systems have successfully demonstrated greatly reduced costs of adding new functionality. However, the cost of starting over from scratch can be prohibitive; for example, Microsoft has spent over $300M developing Windows NT [55]. <p> Finally, a simple method should be provided to enable dispatchers to write to the kernel code image. This is necessary to enable interposition on procedural interfaces using binary patching. 6 Related Work There has been a considerable amount of recent work <ref> [17, 45, 5, 20, 21] </ref> that has focused on building highly-extensible operating systems. Because these systems have built new operating systems kernels and new kernel structures, they have not focused on the problem of extensibility for existing systems.
Reference: [21] <author> Bryan Ford, Mike Hibler, Jay Lepreau, Patrick Tullman, God--mar Back, and Steven Clawson. </author> <title> Microkernels Meet Recursive Virtual Machines. </title> <booktitle> In Proceedings of the 2nd USENIX Symposium on Operating Systems Design and Implementation, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: Systems built using this approach include Hydra [53], 1 Mach [1], SPIN [7, 5], VINO [45, 41], Exokernel [20], Lipto [17], and Fluke <ref> [21] </ref>. Many of these systems have successfully demonstrated greatly reduced costs of adding new functionality. However, the cost of starting over from scratch can be prohibitive; for example, Microsoft has spent over $300M developing Windows NT [55]. <p> Finally, a simple method should be provided to enable dispatchers to write to the kernel code image. This is necessary to enable interposition on procedural interfaces using binary patching. 6 Related Work There has been a considerable amount of recent work <ref> [17, 45, 5, 20, 21] </ref> that has focused on building highly-extensible operating systems. Because these systems have built new operating systems kernels and new kernel structures, they have not focused on the problem of extensibility for existing systems.
Reference: [22] <author> Simon Garfinkel. PGP: </author> <title> Pretty Good Privacy. </title> <publisher> O'Reilly and Associates, </publisher> <address> Sebastopol, CA, first edition, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: For example, in a networked environment with a central file server, traditional Unix file protections can be easily circumvented by monitoring the network traffic. To protect sensitive files, users may use encryption tools such as PGP <ref> [22] </ref>. However, stand-alone encryption tools can be time consuming and are not easily integrated with existing application binaries. A more effective method of ensuring file security is to support file encryption directly in the file system, transparently encrypting file writes, and decrypting file reads, when communicating with the server.
Reference: [23] <author> Ian Goldberg, David Wagner, Randy Thomas, and Eric Brewer. </author> <title> A Secure Environment for Untrusted Helper Applications. </title> <booktitle> In Proceedings of the Sixth USENIX Security Symposium, </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: A common method for constructing a restricted execution environment is to use the tracing facility of the standard /proc file system to selectively deny or change those system calls which would violate security <ref> [23] </ref>. This approach suffers from a number of shortcomings. First, the Solaris 2.5 /proc file system only allows system calls to be denied with EINTR as the error code, a code normally used to indicate that the attempted operation was interrupted and should be retried.
Reference: [24] <author> James Gosling and Henry McGilton. </author> <title> The Java(tm) Language Environment: A White Paper. </title> <address> http://java.dimensionx.com /whitePaper/java-whitepaper-1.html, </address> <year> 1995. </year>
Reference-contexts: By contrast with operating systems where relatively few successful ISV's exist (Transarc being a notable exception), robust ISV markets exist in other areas, such as databases [18], Web software <ref> [24, 33] </ref>, and desktop publishing [38, 9] in each case, because extensibility has been designed into the system.
Reference: [25] <author> J. Howard, M. Kazar, S. Menees, D. Nichols, M. Satya-narayanan, R. Sidebotham, and M. West. </author> <title> Scale and performance in a distributed file system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 51-81, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: right (for example chown ()), and performs security checks, such as checking the path or file access permissions, for 21 additional system calls (for example rmdir (). 4.4 Performance To evaluate the impact of these extensions on system performance, we ran the extensions under three benchmarks: the Modified Andrew Benchmark <ref> [25, 34] </ref>, a T E X compilation of a 262-page (760KB) document, and a gcc compilation of emacs-19.34 without support for X Windows.
Reference: [26] <author> Wilson Hsieh, Marc Fiuczynski, Charles Garrett, Stefan Savage, David Becker, and Brian N. Bershad. </author> <title> Language support for extensible operating systems. </title> <booktitle> In Proceedings of the Workshop on Compiler Support for System Software, </booktitle> <month> Febru-ary </month> <year> 1996. </year>
Reference-contexts: There are a number of limitations to this approach: the kernel is not protected from malicious or faulty extension code and there is no support for user-level development tools. Methods of protecting the kernel are well-known <ref> [35, 26, 43, 41] </ref>. By supplying exten sions with the same interface, whether at the user level or in the kernel, extensions can be safely developed at the user level and then inserted into the kernel. This enables development in a safe environment without sacrificing the potential for good performance. <p> Both offer extensibility through interposition on a number of kernel interfaces. These interfaces have been explicitly designed for extensibility, rather than enabling extensibility on existing interfaces, which SLIC supports. SPIN and VINO also aggressively focus on ensuring kernel protection from extensions, SPIN by using a type-safe language <ref> [44, 26] </ref>, and VINO through software fault isolation [50] and in-kernel transactions [41]. We assume trusted extensions. Interposition Agents [27] demonstrated that it is useful to construct interposition extensions in terms of the underlying abstractions of the interposed interface, rather than in terms of the physical events crossing that interface.
Reference: [27] <author> Michael B. Jones. </author> <title> Interposition Agents: Transparently Interposing User Code at the System Interface. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 80-93, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: We believe that no other system provides this powerful combination of features for extending existing production operating systems. Specifically, Interposition Agents <ref> [27] </ref> leverages the Mach [1] system call redirection facility to transparently insert extensions at the system call interface. However, since the extension code runs in the application's address space and protection domain, this solution cannot enforce security guarantees or share resources among distrustful processes. <p> Efficiency: The interposition mechanism should impose minimal overhead on the system and per-extension overhead should be a few times the cost of a procedure call, when performance is a concern. The user-level extension code used in systems such as Interposition Agents <ref> [27] </ref> is costly to access; our mechanism should enable in-kernel or mixed in-kernel/user-level extensions for performance [47]. Ease of Development: Extension writers should be able to use state-of-the-art programming tools such as sym bolic debuggers and performance analysis tools. SLIC assumes that extensions are trusted. <p> SPIN and VINO also aggressively focus on ensuring kernel protection from extensions, SPIN by using a type-safe language [44, 26], and VINO through software fault isolation [50] and in-kernel transactions [41]. We assume trusted extensions. Interposition Agents <ref> [27] </ref> demonstrated that it is useful to construct interposition extensions in terms of the underlying abstractions of the interposed interface, rather than in terms of the physical events crossing that interface. The interposition technology used in [27] bounced system calls to extensions linked into an application's address space. <p> We assume trusted extensions. Interposition Agents <ref> [27] </ref> demonstrated that it is useful to construct interposition extensions in terms of the underlying abstractions of the interposed interface, rather than in terms of the physical events crossing that interface. The interposition technology used in [27] bounced system calls to extensions linked into an application's address space. This mechanism has two disadvantages relative to SLIC. First, extensions are not protected from applications and thus cannot implement security extensions or share data between distrustful applications. <p> Second, the multiple protection boundary crossings limit the performance of the system. Our interposition technology enables high-performance interposition that is both enforced upon, and protected from applications, enabling a larger class of extensions. The actual toolkit presented in <ref> [27] </ref> could easily be constructed on our interposition platform and could simplify the process of extension de velopment. COLA [31] enables interposition at the system call interface, but without any modification of the operating system kernel. <p> COLA [31] enables interposition at the system call interface, but without any modification of the operating system kernel. It operates through interposition at the library level and consequently suffers from the same security drawbacks as the interposition technology used in <ref> [27] </ref>. Protected Shared Libraries [4] enables extensions to be securely loaded into an application's address space, so that user programs cannot access or modify extension code or data.
Reference: [28] <author> Yousef Khalidi and Michael Nelson. </author> <title> Extensible File Systems in Spring. </title> <booktitle> In Proceedingsof the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 1-14, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Extensions cannot, for example, add new abstractions to the system, but only compositions and variants of existing abstractions. This can limit extension functionality; for example, a cache-coherent file system can only be constructed through interposition if underlying layers expose a cache management mechanism in the file system interface <ref> [28] </ref>. This limitation on new functionality being expressible only as a composition or variant of existing functionality is more strict: interposition cannot add new events to interfaces. New events can only be added by overloading existing events (as routinely occurs with the Unix ioctl () interface).
Reference: [29] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <address> Cam-bridge, MA, </address> <year> 1991. </year>
Reference-contexts: Despite these limitations, interposition's power and flexibility has led to its wide-spread use throughout modern com puting systems. Forms of interposition can be found in the `pipe' construct used in Unix shells, in the extensibility mechanisms of programming language systems <ref> [29] </ref>, in distributed file systems such as NFS [40], in distributed shared memory systems such as TreadMarks [2], in World Wide Web proxy caches [8], and in MS-DOS terminate-and-stay-resident utilities and Macintosh toolbox extensions. 3 SLIC Design and Implementation To investigate the suitability of interposition for adding new functionality to existing
Reference: [30] <author> Steven R. Kleiman. Vnodes: </author> <title> An architecture for multiple file system types in Sun UNIX. </title> <booktitle> In Proceedings of the 1986 Summer USENIX Technical Conference, </booktitle> <pages> pages 238-247, </pages> <address> Atlanta, GA, </address> <year> 1986. </year> <institution> Sun Microsystems. </institution>
Reference-contexts: Thus, it is likely that the need to extend existing production operating systems will persist for the foreseeable future. A small number of projects have taken the alternative approach of re-engineering existing kernel interfaces to reduce the complexity of adding new functionality at those interfaces. The vnode interface <ref> [30, 39] </ref> is a prime example of this approach. While this interface is extremely useful for adding complete new file systems, it does not support the incremental addition of new functionality. Implementation details of the interface also vary widely across operating system vendors [51].
Reference: [31] <author> Eduardo Krell and Balachander Krishnamurthy. COLA: </author> <title> Customized overlaying. </title> <booktitle> In Proceedings of the Winter 1992 USENIX Technical Conference, </booktitle> <address> San Francisco, CA, </address> <month> January </month> <year> 1992. </year> <institution> AT&T Bell Laboratories, USENIX Association. </institution>
Reference-contexts: Our interposition technology enables high-performance interposition that is both enforced upon, and protected from applications, enabling a larger class of extensions. The actual toolkit presented in [27] could easily be constructed on our interposition platform and could simplify the process of extension de velopment. COLA <ref> [31] </ref> enables interposition at the system call interface, but without any modification of the operating system kernel. It operates through interposition at the library level and consequently suffers from the same security drawbacks as the interposition technology used in [27].
Reference: [32] <author> Kai Li and Paul Hudak. </author> <title> Memory Coherence in Shared Virtual Memory Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: In addition, there is a large catalog of value-add functionality that has not been widely deployed, in part because of the difficulty of modifying existing systems: load sharing [56], process migration [48, 16], fast communication primitives [6, 49], upcalls [14], distributed shared memory <ref> [32] </ref>, and user-level pagers [54]. The goal of this paper is to simplify the process of evolving and extending existing production operating systems. A consequence of accomplishing this would be to enable independent software vendors (ISV's) to develop and deploy innovative operating system features.
Reference: [33] <author> Netscape Communications Corporation. </author> <title> Netscape Navigator, </title> <note> 1994. http://www.netscape.com. </note>
Reference-contexts: By contrast with operating systems where relatively few successful ISV's exist (Transarc being a notable exception), robust ISV markets exist in other areas, such as databases [18], Web software <ref> [24, 33] </ref>, and desktop publishing [38, 9] in each case, because extensibility has been designed into the system.
Reference: [34] <author> John Ousterhout. </author> <booktitle> Why Aren't Operating Systems Getting Faster As Fast As Hardware? In Proceedings of the 1990 Summer USENIX Conference, </booktitle> <pages> pages 247-256, </pages> <address> Anaheim, CA, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: right (for example chown ()), and performs security checks, such as checking the path or file access permissions, for 21 additional system calls (for example rmdir (). 4.4 Performance To evaluate the impact of these extensions on system performance, we ran the extensions under three benchmarks: the Modified Andrew Benchmark <ref> [25, 34] </ref>, a T E X compilation of a 262-page (760KB) document, and a gcc compilation of emacs-19.34 without support for X Windows.
Reference: [35] <author> Przemysaw Pardyak and Brian N. Bershad. </author> <title> Dynamic binding in an extensible system. </title> <booktitle> In Proceedings of the Second Symposium on Operating Systems Design and Implementation (OSDI '96), </booktitle> <pages> pages 201-212, </pages> <address> Seattle, WA, </address> <month> October </month> <year> 1996. </year> <institution> University of Washington, USENIX Association. </institution>
Reference-contexts: The signal dispatcher provides similar functionality, enabling filtering on process id and signal type. These predicates are roughly analogous to the guards found in SPIN <ref> [35] </ref>. Table 1 presents a simplified portion of the system call dispatcher interface. <p> There are a number of limitations to this approach: the kernel is not protected from malicious or faulty extension code and there is no support for user-level development tools. Methods of protecting the kernel are well-known <ref> [35, 26, 43, 41] </ref>. By supplying exten sions with the same interface, whether at the user level or in the kernel, extensions can be safely developed at the user level and then inserted into the kernel. This enables development in a safe environment without sacrificing the potential for good performance.
Reference: [36] <institution> Pure Software, Inc. </institution> <note> Purify User's Guide, </note> <year> 1996. </year>
Reference-contexts: Extension code executing as a user-level server enables extension development to proceed as with normal user programs, with access to user-level libraries (such as communication libraries) and state-of-the-art development tools (such as symbolic debuggers and performance analysis tools such as Purify <ref> [36] </ref> and Quantify [37]). A user-level extension must not register its own events or events from its development tools with any dispatchers. The extension is protected against modification by user programs by virtue of running in a separate address space.
Reference: [37] <institution> Pure Software, Inc. </institution> <note> Quantify User's Guide, </note> <year> 1996. </year>
Reference-contexts: Extension code executing as a user-level server enables extension development to proceed as with normal user programs, with access to user-level libraries (such as communication libraries) and state-of-the-art development tools (such as symbolic debuggers and performance analysis tools such as Purify [36] and Quantify <ref> [37] </ref>). A user-level extension must not register its own events or events from its development tools with any dispatchers. The extension is protected against modification by user programs by virtue of running in a separate address space.
Reference: [38] <institution> Xtensions.com:the ultimate source for quark xtensions. </institution> <note> http://www.xtension.com/, 1997. </note>
Reference-contexts: By contrast with operating systems where relatively few successful ISV's exist (Transarc being a notable exception), robust ISV markets exist in other areas, such as databases [18], Web software [24, 33], and desktop publishing <ref> [38, 9] </ref> in each case, because extensibility has been designed into the system.
Reference: [39] <author> David S. H. Rosenthal. </author> <title> Evolving the vnode interface. </title> <booktitle> In Proceedings of the 1990 Summer USENIX Technical Conference, </booktitle> <pages> pages 107-117, </pages> <address> Anaheim, CA, </address> <month> June </month> <year> 1990. </year> <institution> Sun Microsystems. </institution>
Reference-contexts: Thus, it is likely that the need to extend existing production operating systems will persist for the foreseeable future. A small number of projects have taken the alternative approach of re-engineering existing kernel interfaces to reduce the complexity of adding new functionality at those interfaces. The vnode interface <ref> [30, 39] </ref> is a prime example of this approach. While this interface is extremely useful for adding complete new file systems, it does not support the incremental addition of new functionality. Implementation details of the interface also vary widely across operating system vendors [51].
Reference: [40] <author> R. Sandberg, D. Goldberg, Steven Kleiman, D. Walsh, and B. Lyon. </author> <title> Design and implementation of the Sun network filesystem. </title> <booktitle> In Proceedingsof the Summer 1985 USENIX Technical Conference, </booktitle> <pages> pages 119-130, </pages> <address> Dallas, TX, </address> <month> June </month> <year> 1985. </year> <institution> Sun Microsystems. </institution>
Reference-contexts: Despite these limitations, interposition's power and flexibility has led to its wide-spread use throughout modern com puting systems. Forms of interposition can be found in the `pipe' construct used in Unix shells, in the extensibility mechanisms of programming language systems [29], in distributed file systems such as NFS <ref> [40] </ref>, in distributed shared memory systems such as TreadMarks [2], in World Wide Web proxy caches [8], and in MS-DOS terminate-and-stay-resident utilities and Macintosh toolbox extensions. 3 SLIC Design and Implementation To investigate the suitability of interposition for adding new functionality to existing operating systems, we have designed and implemented SLIC,
Reference: [41] <author> Margo I. Seltzer, Yasuhiro Endo, Christoper Small, and Keith A. Smith. </author> <title> Dealing With Disaster: Surviving Misbehaved Kernel Extensions. </title> <booktitle> In Proceedings of the 2nd USENIX Symposium on Operating Systems Design and Implementation, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: Over the years, a number of systems have attempted to reduce the cost of adding new kernel functionality by restructuring the operating system with extensibility as a design goal. Systems built using this approach include Hydra [53], 1 Mach [1], SPIN [7, 5], VINO <ref> [45, 41] </ref>, Exokernel [20], Lipto [17], and Fluke [21]. Many of these systems have successfully demonstrated greatly reduced costs of adding new functionality. However, the cost of starting over from scratch can be prohibitive; for example, Microsoft has spent over $300M developing Windows NT [55]. <p> Ease of Development: Extension writers should be able to use state-of-the-art programming tools such as sym bolic debuggers and performance analysis tools. SLIC assumes that extensions are trusted. Other research efforts have addressed the issues involved with supporting untrusted extensions <ref> [50, 5, 41] </ref>. 3.1 SLIC Architecture SLIC is comprised of multiple dispatchers and extensions as well as various support routines. Dispatchers are responsible for intercepting system interface events and for routing those events to interested extensions. Extensions receive events from the dispatcher and provide additional functionality to the operating system. <p> There are a number of limitations to this approach: the kernel is not protected from malicious or faulty extension code and there is no support for user-level development tools. Methods of protecting the kernel are well-known <ref> [35, 26, 43, 41] </ref>. By supplying exten sions with the same interface, whether at the user level or in the kernel, extensions can be safely developed at the user level and then inserted into the kernel. This enables development in a safe environment without sacrificing the potential for good performance. <p> We have implemented a simple encryption file system. This extension implements a trivial exclusive-or encryption algorithm similar to that implemented in VINO <ref> [41] </ref>. The extension watches for open () and creat () system calls of files with a particular suffix and then records the process id and the file descriptor returned to the application. <p> Because these systems have built new operating systems kernels and new kernel structures, they have not focused on the problem of extensibility for existing systems. Of these systems, SPIN [5] and VINO <ref> [45, 41] </ref> are the closest in concept to our work. Both offer extensibility through interposition on a number of kernel interfaces. These interfaces have been explicitly designed for extensibility, rather than enabling extensibility on existing interfaces, which SLIC supports. <p> These interfaces have been explicitly designed for extensibility, rather than enabling extensibility on existing interfaces, which SLIC supports. SPIN and VINO also aggressively focus on ensuring kernel protection from extensions, SPIN by using a type-safe language [44, 26], and VINO through software fault isolation [50] and in-kernel transactions <ref> [41] </ref>. We assume trusted extensions. Interposition Agents [27] demonstrated that it is useful to construct interposition extensions in terms of the underlying abstractions of the interposed interface, rather than in terms of the physical events crossing that interface.
Reference: [42] <author> Margo I. Seltzer, Yasuhiro Endo, Christopher Small, and Keith A. Smith. </author> <title> Issues in extensible operating systems. </title> <note> Publication pending from IEEE Press, 1997. Available from http://www.eecs.harvard.edu/ ~vino/vino/papers/acm-96.ps. </note>
Reference-contexts: Consequently, in practice, it is extremely difficult to add significant new functionality to modern production operating systems <ref> [16, 1, 42] </ref>. This does not diminish the need to continue to modify these systems. For example, security flaws are routinely discovered and reported by organizations such as Carnegie-Mellon's Computer Emergency Response Team (CERT) and the Department of Energy's Computer Incident Advisory Capability (CIAC).
Reference: [43] <author> Emin Gun Sirer, Marc Fiuczynski, Przemysaw Pardyak, and Brian N. Bershad. </author> <title> Safe dynamic linking in an extensible operating system. </title> <booktitle> In Proceedings of the Workshop on Compiler Support for System Software. </booktitle> <institution> University of Washington, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: There are a number of limitations to this approach: the kernel is not protected from malicious or faulty extension code and there is no support for user-level development tools. Methods of protecting the kernel are well-known <ref> [35, 26, 43, 41] </ref>. By supplying exten sions with the same interface, whether at the user level or in the kernel, extensions can be safely developed at the user level and then inserted into the kernel. This enables development in a safe environment without sacrificing the potential for good performance.
Reference: [44] <author> Emin Gun Sirer, Stefan Savage, Przemysaw Pardyak, Greg DeFouw, Mary Ann Alapat, and Brian N. Bershad. </author> <title> Writing an operating system using Modula-3. </title> <booktitle> In Proceedings of the Workshop on Compiler Support for System Software. </booktitle> <institution> University of Washington, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: Both offer extensibility through interposition on a number of kernel interfaces. These interfaces have been explicitly designed for extensibility, rather than enabling extensibility on existing interfaces, which SLIC supports. SPIN and VINO also aggressively focus on ensuring kernel protection from extensions, SPIN by using a type-safe language <ref> [44, 26] </ref>, and VINO through software fault isolation [50] and in-kernel transactions [41]. We assume trusted extensions. Interposition Agents [27] demonstrated that it is useful to construct interposition extensions in terms of the underlying abstractions of the interposed interface, rather than in terms of the physical events crossing that interface.
Reference: [45] <author> Christopher Small and Margo Seltzer. VINO: </author> <title> An Integrated Platform for Operating System and Database Research. </title> <type> Technical Report TR-30-94, </type> <institution> Harvard, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: Over the years, a number of systems have attempted to reduce the cost of adding new kernel functionality by restructuring the operating system with extensibility as a design goal. Systems built using this approach include Hydra [53], 1 Mach [1], SPIN [7, 5], VINO <ref> [45, 41] </ref>, Exokernel [20], Lipto [17], and Fluke [21]. Many of these systems have successfully demonstrated greatly reduced costs of adding new functionality. However, the cost of starting over from scratch can be prohibitive; for example, Microsoft has spent over $300M developing Windows NT [55]. <p> Finally, a simple method should be provided to enable dispatchers to write to the kernel code image. This is necessary to enable interposition on procedural interfaces using binary patching. 6 Related Work There has been a considerable amount of recent work <ref> [17, 45, 5, 20, 21] </ref> that has focused on building highly-extensible operating systems. Because these systems have built new operating systems kernels and new kernel structures, they have not focused on the problem of extensibility for existing systems. <p> Because these systems have built new operating systems kernels and new kernel structures, they have not focused on the problem of extensibility for existing systems. Of these systems, SPIN [5] and VINO <ref> [45, 41] </ref> are the closest in concept to our work. Both offer extensibility through interposition on a number of kernel interfaces. These interfaces have been explicitly designed for extensibility, rather than enabling extensibility on existing interfaces, which SLIC supports.
Reference: [46] <author> V. Srinivasan and Jeffrey C. Mogul. Spritely NFS: </author> <title> Experiments with cache-consistency protocols. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 45-57, </pages> <address> Litchfield Park, AZ, </address> <month> December </month> <year> 1989. </year> <note> ACM. </note>
Reference-contexts: We are also exploring the design space of useful extensions to be built with SLIC. Among these are transparent remote execution, a single system image in a network of workstations, extending the semantics of NFS to include full cache-coherency for simultaneous access <ref> [46] </ref> and supporting scheduler activations [3] through interposition on signals or directly on the scheduler. 8 Conclusion This paper has examined the utility of interposition as a mechanism for adding extensibility to production operating systems.
Reference: [47] <author> David C. Steere, James J. Kistler, and M. Satyanarayanan. </author> <title> Efficient user-level file cache management on the Sun vnode interface. </title> <booktitle> In Proceedings of the Summer 1990 USENIX Technical Conference, </booktitle> <pages> pages 325-332, </pages> <address> Anaheim, CA, </address> <month> June </month> <year> 1990. </year> <institution> Carnegie Mellon University, USENIX Association. </institution>
Reference-contexts: The user-level extension code used in systems such as Interposition Agents [27] is costly to access; our mechanism should enable in-kernel or mixed in-kernel/user-level extensions for performance <ref> [47] </ref>. Ease of Development: Extension writers should be able to use state-of-the-art programming tools such as sym bolic debuggers and performance analysis tools. SLIC assumes that extensions are trusted.
Reference: [48] <author> Marvin Theimer, K. Landtz, and David Cheriton. </author> <title> Preempt-able Remote Execution Facilities for the V System. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 2-12, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: In addition, there is a large catalog of value-add functionality that has not been widely deployed, in part because of the difficulty of modifying existing systems: load sharing [56], process migration <ref> [48, 16] </ref>, fast communication primitives [6, 49], upcalls [14], distributed shared memory [32], and user-level pagers [54]. The goal of this paper is to simplify the process of evolving and extending existing production operating systems.
Reference: [49] <author> Thorsten von Eicken, David E. Culler, Steh C. Goldstein, and Klaus Erik Schauser. </author> <title> Active Messages: a Mechanism for Integrated Communication and Computation. </title> <booktitle> In Proc. of the 19th Int'l Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: In addition, there is a large catalog of value-add functionality that has not been widely deployed, in part because of the difficulty of modifying existing systems: load sharing [56], process migration [48, 16], fast communication primitives <ref> [6, 49] </ref>, upcalls [14], distributed shared memory [32], and user-level pagers [54]. The goal of this paper is to simplify the process of evolving and extending existing production operating systems.
Reference: [50] <author> Robert Wahbe, Steven Lucco, Thomas Anderson, and Susan Graham. </author> <title> Efficient Software-Based Fault Isolation. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <month> December </month> <year> 1993. </year> <month> 13 </month>
Reference-contexts: However, since the extension code runs in the application's address space and protection domain, this solution cannot enforce security guarantees or share resources among distrustful processes. Software Fault Isolation (SFI) <ref> [50] </ref> can be used to rewrite application binaries to protect extensions running at user level from the application; unfortunately, it is difficult to apply SFI to arbitrary application programs without prohibitive implementation complexity. <p> Ease of Development: Extension writers should be able to use state-of-the-art programming tools such as sym bolic debuggers and performance analysis tools. SLIC assumes that extensions are trusted. Other research efforts have addressed the issues involved with supporting untrusted extensions <ref> [50, 5, 41] </ref>. 3.1 SLIC Architecture SLIC is comprised of multiple dispatchers and extensions as well as various support routines. Dispatchers are responsible for intercepting system interface events and for routing those events to interested extensions. Extensions receive events from the dispatcher and provide additional functionality to the operating system. <p> These interfaces have been explicitly designed for extensibility, rather than enabling extensibility on existing interfaces, which SLIC supports. SPIN and VINO also aggressively focus on ensuring kernel protection from extensions, SPIN by using a type-safe language [44, 26], and VINO through software fault isolation <ref> [50] </ref> and in-kernel transactions [41]. We assume trusted extensions. Interposition Agents [27] demonstrated that it is useful to construct interposition extensions in terms of the underlying abstractions of the interposed interface, rather than in terms of the physical events crossing that interface.
Reference: [51] <author> Neil Webber. </author> <title> Operating System Support for Portable Filesys--tem Extensions. </title> <booktitle> In Proceedings of the 1993 USENIX Winter Conference, </booktitle> <pages> pages 219-228, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The vnode interface [30, 39] is a prime example of this approach. While this interface is extremely useful for adding complete new file systems, it does not support the incremental addition of new functionality. Implementation details of the interface also vary widely across operating system vendors <ref> [51] </ref>. Applying this technique to make existing operating systems more extensible would require substantially modifying and exposing all interfaces where additional functionality is desired, effectively re-engineering the majority of the operating system.
Reference: [52] <author> Nick Wingfield. </author> <title> ActiveX used as hacking tool. </title> <address> http://www.news.com/ News/Item/ 0%2C4%2C7761%2C00.html, </address> <month> February </month> <year> 1997. </year>
Reference-contexts: There are many cases, however, in which the user does not trust the program being run. For example, programs downloaded from untrusted sources like the Internet may actually be Trojan horses designed to steal or destroy information <ref> [52, 15] </ref>. In addition, there are cases in which the user trusts the program, but not the data being processed, as in the case of helper applications used by web browsers to display various data formats.
Reference: [53] <author> W. Wulf, E. Cohen, W. Corwin, A. Jones, R. Levin, C. Pier-son, and F. Pollack. HYDRA: </author> <title> The Kernel of a Multiprocessor Operating System. </title> <journal> Communications of the ACM, </journal> <volume> 17(6) </volume> <pages> 337-344, </pages> <month> June </month> <year> 1974. </year>
Reference-contexts: Over the years, a number of systems have attempted to reduce the cost of adding new kernel functionality by restructuring the operating system with extensibility as a design goal. Systems built using this approach include Hydra <ref> [53] </ref>, 1 Mach [1], SPIN [7, 5], VINO [45, 41], Exokernel [20], Lipto [17], and Fluke [21]. Many of these systems have successfully demonstrated greatly reduced costs of adding new functionality.
Reference: [54] <author> M. Young, A. Tevanian, R. Rashid, D. Golub, J. Eppinger, J. Chew, W. Bolosky, D. Black, and R. Baron. </author> <title> The Duality of Memory and Communication in the Implementation of a Multiprocessor Operating System. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-76, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: In addition, there is a large catalog of value-add functionality that has not been widely deployed, in part because of the difficulty of modifying existing systems: load sharing [56], process migration [48, 16], fast communication primitives [6, 49], upcalls [14], distributed shared memory [32], and user-level pagers <ref> [54] </ref>. The goal of this paper is to simplify the process of evolving and extending existing production operating systems. A consequence of accomplishing this would be to enable independent software vendors (ISV's) to develop and deploy innovative operating system features.
Reference: [55] <author> G. Pascal Zachary. </author> <title> Showstopper! The Breakneck Race to Create Windows NT and the Next Generation at Microsoft. </title> <publisher> Macmillan, Inc., </publisher> <year> 1994. </year>
Reference-contexts: Many of these systems have successfully demonstrated greatly reduced costs of adding new functionality. However, the cost of starting over from scratch can be prohibitive; for example, Microsoft has spent over $300M developing Windows NT <ref> [55] </ref>. Thus, it is likely that the need to extend existing production operating systems will persist for the foreseeable future. A small number of projects have taken the alternative approach of re-engineering existing kernel interfaces to reduce the complexity of adding new functionality at those interfaces.
Reference: [56] <author> Sognian Zhou, Jingwen Wang, Xiaohn Zheng, and Pierre Delisle. </author> <title> Utopia: A Load Sharing Facility for Large, Heterogeneous Distributed Computing Systems. </title> <type> Technical Report CSRI-257, </type> <institution> University of Toronto, </institution> <year> 1992. </year> <month> 14 </month>
Reference-contexts: In addition, there is a large catalog of value-add functionality that has not been widely deployed, in part because of the difficulty of modifying existing systems: load sharing <ref> [56] </ref>, process migration [48, 16], fast communication primitives [6, 49], upcalls [14], distributed shared memory [32], and user-level pagers [54]. The goal of this paper is to simplify the process of evolving and extending existing production operating systems.
References-found: 56

