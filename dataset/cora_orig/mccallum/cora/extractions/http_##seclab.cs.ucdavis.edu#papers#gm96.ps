URL: http://seclab.cs.ucdavis.edu/papers/gm96.ps
Refering-URL: http://seclab.cs.ucdavis.edu/papers.html
Root-URL: http://www.cs.ucdavis.edu
Title: Network Security Via Reverse Engineering of TCP Code: Vulnerability Analysis and Proposed Solutions  
Author: Biswaroop Guha and Biswanath Mukherjee 
Keyword: and Phrases: Network Security, TCP, IP, Reverse Engineering, Slicing, Vulnerability Analysis, State Transitions, Timer Escape Route.  
Note: Corresponding Author: Biswanath Mukherjee  
Address: Davis, CA 95616, U.S.A.  
Affiliation: Department of Computer Science University of California  
Email: fguha, mukherjeg@cs.ucdavis.edu  
Phone: Tel: +1-916-f785-5863, 752-4826g  
Date: November 7, 1995  
Abstract: The Transmission Control Protocol/Internet Protocol (TCP/IP) [1] suite is a very widely used technique that is employed to interconnect computing facilities in modern network environments. However, there exist several security vulnerabilities in the TCP specification and additional weaknesses in a number of widely-available implementations of TCP. These vulnerabilities may enable an intruder to "attack" TCP-based systems, enabling him/her to "hijack" a TCP connection or cause denial of service to legitimate users. We analyze TCP code via a "reverse engineering" technique called "slicing" to identify several of these vulnerabilities, especially those that are related to the TCP state-transition diagram. We discuss many of the flaws present in the TCP implementation of many widely used operating systems, such as SUNOS 4.1.3, SVR4, and ULTRIX 4.3. We describe the corresponding TCP attack "signatures" (including the well-known 1994 Christmas Day Mitnick Attack) and provide recommendations to improve the security state of a TCP-based system, e.g., incorporation of a "timer escape route" from every TCP state. fl This work has been supported by the Advanced Research Projects Agency (ARPA) under Contract No. DOD/DABT63-93-C-0045. A short, summarized version of this paper will appear in the Proceedings of the IEEE Infocom '96 Conference. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Postel, </author> <title> Transmission Control Protocol, </title> <type> RFC 793, </type> <year> 1981. </year>
Reference: [2] <author> D. E. Comer, </author> <title> Internetworking with TCP/IP: Vol. I Principles, Protocols, and Architecture, Third Edition, </title> <publisher> Prentice Hall, </publisher> <year> 1995. </year>
Reference-contexts: If the other end does not respond to a fixed number of these probes, the connection is terminated. * Additional TCP timers such as persist timer, delayed ACK timer, and retransmission timer are not relevant for our purposes here and, hence, are not discussed. Interested readers may refer to <ref> [2] </ref> [3] for more information on these timers. 3 Example Attack Scenarios 3.1 IP Spoofing 3.1.1 Instances The concept of attacks on TCP/IP such as TCP sequence-number guessing (to do IP-spoofing) was first brought to light by Morris [9].
Reference: [3] <author> W. R. Stevens, </author> <title> TCP/IP Illustrated Vol. 1 The Protocols, </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: This process of encapsulation enables a layer to easily interpret and parse the data that it receives from a lower layer and it has to pass on to the upper layer. Fig. 2 <ref> [3] </ref> illustrates the encapsulation process that occurs in the TCP/IP suite, assuming an Ethernet physical network. 2.2 Transport Layer Among all of the transport layers, TCP is the most popular. <p> Below, we examine the details of the header format of TCP along with the TCP state-transition diagram and TCP timers. 2.2.1 TCP Header The size of the TCP header is 20 bytes, without counting its options, as we observe in Fig. 3 <ref> [3] </ref>. Each TCP segment contains the source and destination port number to identify the sending and receiving application programs, respectively. The sequence number is essential to maintain the bytes 4 of data from the sender to the receiver in proper order. <p> Interested readers may refer to [2] <ref> [3] </ref> for more information on these timers. 3 Example Attack Scenarios 3.1 IP Spoofing 3.1.1 Instances The concept of attacks on TCP/IP such as TCP sequence-number guessing (to do IP-spoofing) was first brought to light by Morris [9].
Reference: [4] <author> W. R. Stevens and G. R. Wright, </author> <title> TCP/IP Illustrated Vol. 2 The Implementation, </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: There is an optional options field as well, taking care of vendor specific information. 2.2.2 TCP State-Transition Diagram Initiation, establishment, and termination of a connection is governed by the TCP state-transition diagram, which consists of well-defined states and transition arcs between these states (see Fig. 4) <ref> [4] </ref>. 2.2.3 TCP Timers The TCP state-transition diagram is very closely associated with timers. There are various timers associated with connection establishment or termination, flow control, and retransmission of data. * A connection-establishment timer is set when the SYN packet is sent during the connection-establishment phase. <p> If a response is not received within 75 seconds (in most TCP implemen tations), the connection establishment is aborted. * A FIN WAIT 2 timer is set to 10 minutes when a connection moves from the FIN WAIT 1 state to the FIN WAIT 2 1 state <ref> [4] </ref>. If the connection does not receive a TCP packet with the FIN bit set within the stipulated time, the timer expires and is set to 75 seconds. <p> When each receives the SYN-ACK packet from the other party, it assumes that the connection is established. In this scenario, the connection-establishment timer is switched off when the host receives the SYN packet from the other host <ref> [4] </ref>, as shown below. <p> Proceeding in this fashion, we have been able to build almost 5 the entire state-transition diagram implemented by the code. We obtain some transitions in the code which are not present in the specification of the TCP state-transition diagram <ref> [4] </ref>. The state-transitions marked in dashed lines in Fig. 8 are the "new" transitions that we obtained after analyzing our slice output.
Reference: [5] <institution> STREAMS Programmer's Guide - Solaris 2.4, SunSoft, Sun Microsystem, Inc., </institution> <year> 1994. </year>
Reference-contexts: X sends varieties of TCP packets to other hosts in the network and checks their responses. 19 6.2.1 Setup A device driver is a software component that provides an interface between the operating system and a device <ref> [5] </ref>. The driver controls the device in response to requests from the kernel. This device may be a physical device, such as a disk, in which case the driver is termed as a hardware driver.
Reference: [6] <author> S. M Bellovin, </author> <title> "There be dragons," </title> <booktitle> Proceedings of 1992 USENIX Security Symposium, </booktitle> <pages> pp. 1-16, </pages> <month> September </month> <year> 1992. </year>
Reference: [7] <author> S. M Bellovin, </author> <title> "Security Problems in the TCP/IP Protocol Suite," </title> <journal> Computer Communications Review, </journal> <volume> Vol. 19, No. 2, </volume> <pages> pp. 32-48, </pages> <month> April </month> <year> 1989. </year> <month> 24 </month>
Reference-contexts: The most widely used form of internetworking is provided by the Transmission Control Protocol/Internet Protocol (TCP/IP) suite. There are some inherent security problems in the TCP/IP suite <ref> [7] </ref> which makes the situation conducive to intruders. TCP sequence number prediction, IP address spoofing [9], misuse of IP's source routing principle, use of Internet Control Message Protocol (ICMP) messages for denial of service, etc. are some methods to exploit the network's vulnerabilities. <p> If we assume that the host X is not present in the same subnet as A or B so that it cannot "sniff" B's packets, host X has to figure out B's sequence number in order to create the TCP connection. These steps are described below <ref> [7] </ref>. 3 A kernel module named "tap-2.01" was compiled and installed on the system.
Reference: [8] <author> B. Cheswick, </author> <title> "An evening with Berferd: In which a cracker is lured, </title> <booktitle> endured and studied," Proceedings of the Winter USENIX Conference, </booktitle> <month> January </month> <year> 1992. </year>
Reference: [9] <author> R. T. Morris, </author> <title> "A Weakness in the 4.2BSD UNIX TCP/IP Software," </title> <note> Computing Science Technical Report No. 117, </note> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, New Jersey. </address> <note> [10] "IP Spoofing Attacks and Hijacked Terminal Connections," CERT Advisory, CA-95:01, </note> <month> Jan. 23, </month> <year> 1995. </year>
Reference-contexts: The most widely used form of internetworking is provided by the Transmission Control Protocol/Internet Protocol (TCP/IP) suite. There are some inherent security problems in the TCP/IP suite [7] which makes the situation conducive to intruders. TCP sequence number prediction, IP address spoofing <ref> [9] </ref>, misuse of IP's source routing principle, use of Internet Control Message Protocol (ICMP) messages for denial of service, etc. are some methods to exploit the network's vulnerabilities. <p> Interested readers may refer to [2] [3] for more information on these timers. 3 Example Attack Scenarios 3.1 IP Spoofing 3.1.1 Instances The concept of attacks on TCP/IP such as TCP sequence-number guessing (to do IP-spoofing) was first brought to light by Morris <ref> [9] </ref>. The Computer Emergency Response Team (CERT) Coordination Center received reports of attacks in which intruders created packets with spoofed source IP addresses [10]. These attacks exploit applications that use authentication based on IP addresses.
Reference: [11] <author> J. </author> <title> Markoff, New York Times, "Thief took bite out of security; hacker's breach shows vulnerability of computer networks," </title> <type> Nation, </type> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Prior to this attack, Mitnick had found his way into the Well, a small network used mainly by an eclectic group of about 11,000 computer users in the San Francisco Bay Area <ref> [11] </ref>. Mitnick had been reading electronic mail of the Well's subscribers and using Well accounts for remote attacks on computers across the Internet. During the 2 Common implementation values for 2MSL are 1 minute or 2 minutes. 6 attack on Shimomura's machine, two different intrusion mechanisms were employed [12].
Reference: [12] <author> T. Shimomura, </author> <title> "Technical details of the attack described by Markoff in NYT," </title> <booktitle> Usenix newsgroups: </booktitle> <address> comp.protocols.tcp-ip, comp.security.misc, </address> <month> Jan. 25, </month> <year> 1995. </year>
Reference-contexts: Mitnick had been reading electronic mail of the Well's subscribers and using Well accounts for remote attacks on computers across the Internet. During the 2 Common implementation values for 2MSL are 1 minute or 2 minutes. 6 attack on Shimomura's machine, two different intrusion mechanisms were employed <ref> [12] </ref>. IP source address spoofing and TCP sequence-number prediction were used to gain initial access to a diskless workstation, being used mostly as an X terminal. After obtaining root access, Mitnick "hijacked" an existing connection to another system by means of a loadable kernel STREAMS module 3 [12]. 3.1.2 Methodology Let <p> mechanisms were employed <ref> [12] </ref>. IP source address spoofing and TCP sequence-number prediction were used to gain initial access to a diskless workstation, being used mostly as an X terminal. After obtaining root access, Mitnick "hijacked" an existing connection to another system by means of a loadable kernel STREAMS module 3 [12]. 3.1.2 Methodology Let us assume that there are three hosts, host A, host B, and the intruder-controlled host X. Let us assume that B grants A some special privileges, and thus A can get some actions performed by B. <p> These steps are described below [7]. 3 A kernel module named "tap-2.01" was compiled and installed on the system. This is a kernel STREAMS module which can be pushed onto an existing STREAMS stack and used to take control of a tty device <ref> [12] </ref>. 7 X --&gt; B : SYN (Seq. no. = M), SRC = A X --&gt; B : ACK (Ack. no. = N+1), SRC = A At the same time, host X should take away host A's ability to respond to the packets of host B. <p> We shall discuss this in more details in next subsection. 3.1.3 The Attack During the Christmas Day, 1994, attack, Shimomura observed a sequence of packets that were generated to perform IP spoofing <ref> [12] </ref>. Let us continue with the previous example with X as the intruder-controlled system and observe the actions performed by the intruder. 1. X sends a number of probe packets to B and A, trying to determine whether there exists any kind of trust relationship among hosts A and B.
Reference: [13] <author> M. Weiser, </author> <title> "Program Slicing," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-10, </volume> <pages> pp. 352-375, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Also, we determine the importance of timers in different states and security problems associated with them if a state does not have the necessary timer-backup or escape route. We analyze the TCP state-transition diagram using a "reverse engineering" technique called slicing <ref> [13] </ref>. Program slicing is an abstraction mechanism in which code that might influence the value of a given variable at a location is extracted from the full source code of the program. We employ slicing to filter out the relevant state-transition information from the TCP source code. <p> Thus, X is successfully able to stall a port of host A. This is clearly a denial-of-service attack. In the following section, we shall discuss our approach to single out extraneous state-transitions in the TCP state-transition diagram using the slicing method. 4 Slicing Program slicing <ref> [13] </ref> produces a bona-fide program|a subset of the original program|that behaves exactly the same with respect to the computation of a designated property [15]. <p> Weiser <ref> [13] </ref> originally implemented slicing for FORTRAN programs. Automatic slicing requires that the behavior of interest be expressed in a certain way. If this behavior can be communicated as 12 values of some set of variables at some set of statements, then the specification is said to be slicing criterion [13]. <p> Weiser <ref> [13] </ref> originally implemented slicing for FORTRAN programs. Automatic slicing requires that the behavior of interest be expressed in a certain way. If this behavior can be communicated as 12 values of some set of variables at some set of statements, then the specification is said to be slicing criterion [13]. The concept of breaking down a large program into smaller and simpler modules for analysis is observed in [16]. Zislis defines "busy variables" as variables that will be used later in the program. <p> Zislis defines "busy variables" as variables that will be used later in the program. He employed these variables as the criteria to group related program statements and form a program slice. Weiser <ref> [13] </ref> used data-dependence to group statements together. There are several other ways to slice a program, namely backward data-flow slicing, forward data-flow slicing, control-flow slicing, etc. There are two essential properties of a program slice [14], as follows. 1. The program slice must be executable. 2.
Reference: [14] <author> G. Fink and K. Levitt, </author> <title> "Property-based testing of privileged programs," </title> <booktitle> Proc., Computer Security Applications Conference, </booktitle> <pages> pp. 154-163, </pages> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: program slicing, the meaning of slicing criteria, and some example slicing applications. 4.1 Overview Program slicing is an abstraction mechanism in which code that might influence the value of a given variable or a set of variables at a location is extracted from the full source code of the program <ref> [14] </ref>. Weiser [13] originally implemented slicing for FORTRAN programs. Automatic slicing requires that the behavior of interest be expressed in a certain way. <p> Weiser [13] used data-dependence to group statements together. There are several other ways to slice a program, namely backward data-flow slicing, forward data-flow slicing, control-flow slicing, etc. There are two essential properties of a program slice <ref> [14] </ref>, as follows. 1. The program slice must be executable. 2. For the same input values, the variables must have identical values at the corresponding lo cations both in the slice and the original program. This assists in maintaining the semantic meaning of the program. <p> More complex criteria involve multiple 13 variables, multiple locations, and more complex program analysis. A program slice is represented by a set of nodes. Anything that can be described in terms of nodes in a dataflow graph can serve as a slicing criterion <ref> [14] </ref>. At the same time, it is possible to combine the effects of different slicing methods using different criteria by simply manipulating the sets of nodes. Features such as set-union, set-differences, etc. can be accomplished on these set of nodes. <p> node is added to the slice if it is a definition of the value of a node in the slice, if it is used in a computation of a node in the slice, or if it is a part of a control point which dominates a node in the slice <ref> [14] </ref>. The final slice is the subset of the nodes of the flow graph which have been identified by the above procedure. The forward slice technique works forward through the parse tree. It traces the fan-out effect of a flow node. <p> The result and its security relevance will be discussed in the following sections. 5 Analysis 5.1 The Slicer In order to analyze the TCP source code for spurious state-transitions, we have employed the slicer Tester's Assistant (TA), version 0.7 <ref> [14] </ref>. TA has been developed in part by the Software Testing Research Laboratory at University of California, Davis. In order to slice a C file using TA, we first pass the program through a C preprocessor and feed it to the slicer.
Reference: [15] <author> R. W. Lo, </author> <title> Static Analysis of Programs with Application to Malicious Code Detection, </title> <type> PhD Dissertation, </type> <institution> University of California, Davis, </institution> <year> 1992. </year>
Reference-contexts: In the following section, we shall discuss our approach to single out extraneous state-transitions in the TCP state-transition diagram using the slicing method. 4 Slicing Program slicing [13] produces a bona-fide program|a subset of the original program|that behaves exactly the same with respect to the computation of a designated property <ref> [15] </ref>.
Reference: [16] <author> P. M. Zislis, </author> <title> "Semantic Decomposition of Computer Programs: An Aid to Program Testing," </title> <journal> Acta Informatica, </journal> <pages> pp. 245-269, </pages> <year> 1975. </year>
Reference-contexts: If this behavior can be communicated as 12 values of some set of variables at some set of statements, then the specification is said to be slicing criterion [13]. The concept of breaking down a large program into smaller and simpler modules for analysis is observed in <ref> [16] </ref>. Zislis defines "busy variables" as variables that will be used later in the program. He employed these variables as the criteria to group related program statements and form a program slice. Weiser [13] used data-dependence to group statements together.
Reference: [17] <author> C. Ko, G. Fink, K. Levitt, </author> <title> "Automated detection of vulnerabilities in privileged programs by execution monitoring," </title> <booktitle> Proc., Computer Security Applications Conference, </booktitle> <pages> pp. 134-144, </pages> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: In future, we would like to improve the TA (Tester's Assistant). We would also like to detect more vulnerabilities in the TCP. We would also like to investigate automated detection of vulnerabilities in privileged programs using TCP as their transport layer <ref> [17] </ref>.
Reference: [18] <author> SUN MICROSYSTEMS INC., </author> <title> SunOS 5.4 Reference Manual, Mountain View, CA, </title> <booktitle> 1994. </booktitle> <volume> 25 26 27 28 29 </volume>
Reference-contexts: X sends a number of probe packets to B and A, trying to determine whether there exists any kind of trust relationship among hosts A and B. Commands such as showmount, rpcinfo, and finger <ref> [18] </ref> were utilized for this purpose. 2. X sends a number of TCP SYN packets, i.e., packets containing the SYN flag set with some arbitrary initial sequence numbers to host A. <p> Ararat remains in the SYN RCVD state until the connection-establishment timer expires. 20 The sequence of packets, as observed by the output of tcpdump <ref> [18] </ref> is as follows. 23:26:51.475103 Kongur.32781 &gt; Ararat.ftp: S 4188491776:4188491776 (0) win 8760 &lt;mss 1460&gt; (DF) 23:26:51.477716 Ararat.ftp &gt; Kongur2.32781: S 1382592000:1382592000 (0) ack 4188491777 win 4096 &lt;mss 1460&gt; We observe that port 32781 of Kongur sends a SYN packet to the "ftp" port of Ararat with an initial sequence number
References-found: 17

