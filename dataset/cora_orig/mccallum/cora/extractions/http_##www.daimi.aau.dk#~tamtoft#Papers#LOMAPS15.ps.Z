URL: http://www.daimi.aau.dk/~tamtoft/Papers/LOMAPS15.ps.Z
Refering-URL: http://www.daimi.aau.dk/~tamtoft/papers.html
Root-URL: http://www.daimi.aau.dk
Email: e-mail:ftamtoft,fnielson,hrnielsong@daimi.aau.dk  
Title: Polymorphic Subtyping for Effect Analysis: the Dynamic Semantics  
Author: Torben Amtoft Flemming Nielson Hanne Riis Nielson Jurgen Ammann 
Address: Denmark  
Affiliation: Computer Science Department, Aarhus University,  
Abstract: We study an annotated type and effect system that integrates let-polymorphism, effects, and subtyping into an annotated type and effect system for a fragment of Concurrent ML. First a small-step operational semantics is defined and next the annotated type and effect system is proved semantically sound. This provides insights into the rule for generalisation in the annotated type and effect system. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Debbabi and D. Bolignano: </author> <title> A semantic theory for ML higher-order concur-rency primitives. In ML with Concurrency: Design, Analysis, Implementation and Application (editor: Flemming Nielson), </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: In addition, in order to ensure that "well-typed programs do not go wrong" one must establish that "error configurations" (those which are "stuck") cannot be typed. This is in contrast to the development in <ref> [1] </ref> where the construction of a denotational semantics is based on an annotated type and effect system in that only well-typed programs are given a semantics.
Reference: 2. <author> M. Felleisen and D.P. Friedman: </author> <title> Control operators, the SECD-Machine, and the - calculus. Formal Descriptions of Programming Concepts III, </title> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference-contexts: To formalise the call-by-value evaluation strategy we shall as in [8, 5] employ the notion of evaluation contexts <ref> [2] </ref>. Definition 16.
Reference: 3. <author> X. Leroy and P. Weis: </author> <title> Polymorphic type inference and assignment. </title> <booktitle> In Proc. POPL '91, </booktitle> <pages> pages 291-302. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: premise that the inference system assigns a type t to e but the conclusion depends on the kind of dynamic semantics used: for a denotational semantics one may require (as in [4]) that the denotation of e "has type" t; for a big-step (natural) semantics one may require (as in <ref> [10, 3] </ref>) that if e ! v then v "has type" t; for a small-step semantics [7] one requires (as in [11]) the following subject reduction property: if e ! e 0 then the inference system also assigns e 0 the type t.
Reference: 4. <author> R. Milner: </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Statements of semantic soundness typically contain as premise that the inference system assigns a type t to e but the conclusion depends on the kind of dynamic semantics used: for a denotational semantics one may require (as in <ref> [4] </ref>) that the denotation of e "has type" t; for a big-step (natural) semantics one may require (as in [10, 3]) that if e ! v then v "has type" t; for a small-step semantics [7] one requires (as in [11]) the following subject reduction property: if e ! e 0
Reference: 5. <author> H.R. Nielson and F. Nielson: </author> <title> Higher-order concurrent programs with finite communication topology. </title> <booktitle> In Proc. POPL'94, </booktitle> <pages> pages 84-97. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: The general picture is much as in <ref> [5] </ref> that types are unchanged whereas the behaviours get "smaller" and the environments are "extended". Extending the environment is a potential danger to semantic soundness, cf. the considerations in [10, section 5] where it was concluded that store operations in Standard ML are harmless unless they actually expand the store. <p> To formalise the call-by-value evaluation strategy we shall as in <ref> [8, 5] </ref> employ the notion of evaluation contexts [2]. Definition 16.
Reference: 6. <author> H.R. Nielson, F. Nielson, T. Amtoft: </author> <title> Polymorphic subtypes for effect analysis: the static semantics. </title> <booktitle> This volume of SLNCS, </booktitle> <year> 1997. </year>
Reference-contexts: 1 Introduction In a recent paper <ref> [6] </ref> we developed an annotated type and effect system for a fragment of Concurrent ML. <p> Extending the environment is a potential danger to semantic soundness, cf. the considerations in [10, section 5] where it was concluded that store operations in Standard ML are harmless unless they actually expand the store. In <ref> [6] </ref> it was demonstrated that channel allocations (the way our setting "expands the store") may be harmful unless one is very careful when deciding the set of variables over which to generalise in the rule for let in the inference system: not only should this set be disjoint from the set <p> Overview. We define a dynamic semantics which employs one system for the sequential components (Sect. 2.2) and another for the concurrent components (Sect. 2.3). Next (Sect. 2.4) we extend the repertoire of techniques <ref> [6] </ref> for nor-malising and manipulating the inference trees of the annotated type and effect system. <p> The following trivial result proves useful: Fact 3. Suppose C [ C 0 ` fl 1 fl 2 with fl 1 =2 FV (C). Then C 0 ` fl 1 fl 2 . 1 Following <ref> [6] </ref> we use g to stand for t or b and we use fl to stand for ff or fi and we use oe to stand for t or ts. <p> The type inference system. 2.1 Properties of the Inference System In this section we list some basic concepts and results which we shall use in the later development; except for Fact 8 and Fact 9 their proofs are given in <ref> [6] </ref>. The subtyping rules can be used "backwards" if the constraint set is well formed: Lemma 4. Suppose C is well-formed and that C ` t t 0 . <p> had when communicated. (It is possible for the sender to think that an even larger type was communicated, but this causes no harm.) 4 Conclusion We have given a formal justification of the semantic soundness of a previously developed annotated type and effect system that integrates polymorphism, sub-typing and effects <ref> [6] </ref>; in particular it was highlighted that the judicious choice of generalisation strategy in the system plays a crucial role, as witnessed by the proof of Lemma 37.
Reference: 7. <author> G.D. Plotkin: </author> <title> A structural approach to operational semantics. </title> <type> Report DAIMI FN-19, </type> <institution> Aarhus University, Denmark, </institution> <year> 1981. </year>
Reference-contexts: the kind of dynamic semantics used: for a denotational semantics one may require (as in [4]) that the denotation of e "has type" t; for a big-step (natural) semantics one may require (as in [10, 3]) that if e ! v then v "has type" t; for a small-step semantics <ref> [7] </ref> one requires (as in [11]) the following subject reduction property: if e ! e 0 then the inference system also assigns e 0 the type t.
Reference: 8. <author> J. H. Reppy: </author> <title> Concurrent ML: Design, application and semantics. </title> <booktitle> In Proc. Functional Programming, Concurrency, Simulation and Automated Reasoning, </booktitle> <pages> pages 165-198. </pages> <address> SLNCS 693, </address> <year> 1993. </year>
Reference-contexts: a certain sense as "predicted" by the effect information; in Sect. 3.2 we demonstrate (informally) that it is not possible to assign a type to the "error configurations" which have been characterised in Proposition 22. 2 Inference System and Semantics We shall make use of a variant of Concurrent ML <ref> [8] </ref> where expressions and constants are given by e ::= c j x j fn x ) e j e 1 e 2 j let x = e 1 in e 2 j rec f x ) e j if e then e 1 else e 2 c ::= () j <p> To formalise the call-by-value evaluation strategy we shall as in <ref> [8, 5] </ref> employ the notion of evaluation contexts [2]. Definition 16.
Reference: 9. <author> J. P. Talpin and P. Jouvelot: </author> <title> The type and effect discipline. </title> <journal> Information and Computation, </journal> <volume> 111, </volume> <year> 1994. </year>
Reference-contexts: may be harmful unless one is very careful when deciding the set of variables over which to generalise in the rule for let in the inference system: not only should this set be disjoint from the set of variables occurring in the behaviour (as is standard in effect systems, e.g. <ref> [9] </ref>) but it should also be "upwards closed" with respect to a constraint set. The present paper provides the formal justification and the proof of Lemma 37 highlights how the judicious choice of generalisation strategy allows to extend the environment. Overview.
Reference: 10. <author> M. Tofte: </author> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89 </volume> <pages> 1-34, </pages> <year> 1990. </year>
Reference-contexts: premise that the inference system assigns a type t to e but the conclusion depends on the kind of dynamic semantics used: for a denotational semantics one may require (as in [4]) that the denotation of e "has type" t; for a big-step (natural) semantics one may require (as in <ref> [10, 3] </ref>) that if e ! v then v "has type" t; for a small-step semantics [7] one requires (as in [11]) the following subject reduction property: if e ! e 0 then the inference system also assigns e 0 the type t. <p> The general picture is much as in [5] that types are unchanged whereas the behaviours get "smaller" and the environments are "extended". Extending the environment is a potential danger to semantic soundness, cf. the considerations in <ref> [10, section 5] </ref> where it was concluded that store operations in Standard ML are harmless unless they actually expand the store.
Reference: 11. <author> A.K. Wright and M. Felleisen: </author> <title> A syntactic approach to type soundness. </title> <journal> Information and Computation, </journal> <volume> 115, </volume> <pages> pages 38-94, </pages> <year> 1994. </year>
Reference-contexts: used: for a denotational semantics one may require (as in [4]) that the denotation of e "has type" t; for a big-step (natural) semantics one may require (as in [10, 3]) that if e ! v then v "has type" t; for a small-step semantics [7] one requires (as in <ref> [11] </ref>) the following subject reduction property: if e ! e 0 then the inference system also assigns e 0 the type t. In addition, in order to ensure that "well-typed programs do not go wrong" one must establish that "error configurations" (those which are "stuck") cannot be typed. <p> To this end one usually (cf. the methodical considerations in <ref> [11] </ref>) wants a result that guarantees that "error configurations are not typeable"; here we presuppose some well-formed constraint set C and some channel environment A. <p> Theorem 41 makes it explicit that the type of a channel does not change after it has been allocated. This should be compared with the subject reduction result in <ref> [11, lemma 5.2] </ref>, the formulation of which allows one the possibility of assigning different types to the same location at various stages (although apparently it is always possible to choose the same type and still get subject reduction). Remark.
References-found: 11

