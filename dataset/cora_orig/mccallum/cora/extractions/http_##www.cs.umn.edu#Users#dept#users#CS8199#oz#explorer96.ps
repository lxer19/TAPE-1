URL: http://www.cs.umn.edu/Users/dept/users/CS8199/oz/explorer96.ps
Refering-URL: http://www.cs.umn.edu/Users/dept/users/CS8199/oz/
Root-URL: http://www.cs.umn.edu
Email: E-mail: schulte@dfki.uni-sb.de  
Title: Oz Explorer: A Visual Constraint Programming Tool  
Author: Christian Schulte 
Date: July 9, 1996  
Address: Stuhlsatzenhausweg 3, 66123 Saarbrucken, Germany  
Affiliation: Programming Systems Lab, German Research Center for AI (DFKI)  
Abstract: This paper describes the Oz Explorer and its implementation. The Explorer is a visual constraint programming tool intended to support the development of constraint programs. It uses the search tree of a constraint problem as its central metaphor. Exploration and visualization of the search tree are user-driven and interactive. The constraints of any node in the tree are available first-class: predefined or user-defined procedures can be used to display or analyze them. The Explorer is a fast and memory efficient tool intended for the development of real-world constraint programs. The Explorer is implemented in Oz using first-class computation spaces. There is no fixed search strategy in Oz. Instead, first-class computation spaces allow to program search strategies. The Explorer is one particular example of a user-guided search strategy. The use of recomputation to trade space for time makes it possible to solve large real-world problems, which would use too much memory otherwise. 
Abstract-found: 1
Intro-found: 1
Reference: [ACD + 95] <author> Abderrahamane Aggoun, David Chan, Pierre Dufresne, Eamon Falvey, Hugh Grant, Alexander Herold, Geoffrey Macartney, Micha Meier, David Miller, Shyam Mudambi, Bruno Perez, Emmanuel Van Rossum, Joachim Schimpf, Periklis Andreas Tsahageas, and Dominique Henry de Vil-leneuve. </author> <title> ECL i PS e 3.5. User manual, </title> <institution> European Computer-Industry Research Centre (ECRC), Munich, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: 1 Introduction In the last decade constraint logic and concurrent constraint programming, especially with finite domain constraints, has become popular in many application areas. To a large extent, the growing interest is caused by both the expressive power and the availability of efficient implementations like CHIP [DVS + 88], ECLiPSe <ref> [ACD + 95] </ref>, cc (FD) [VSD95], clp (FD) [DC93], just to name a few. Development of applications based on constraint programming proceeds in two steps. The first step is to design a principally working solution. <p> The practicality of the Explorer is discussed in Section 10. 2 Related Work In the following we relate the Explorer to the Grace tool [Mei95], which is built on top of the ECLiPSe Prolog system <ref> [ACD + 95] </ref>. The Grace tool is intended to support the development and debugging of finite domain constraint programs. It does not use the metaphor of a search tree. Instead it maintains and displays a backtracking history of the finite domain variables involved.
Reference: [CGH93] <author> M. Carro, L. G omez, and M. Hermenegildo. </author> <title> Some paradigms for visualizing parallel execution of logic programs. </title> <editor> In David S. Warren, editor, </editor> <booktitle> International Conference on Logic Programming, </booktitle> <pages> pages 184200, </pages> <address> Bu-dapest, Hungary, </address> <year> 1993. </year> <title> MIT Press. 1 A primitive heuristic has been chosen to get a larger search space. </title> <type> 13 </type>
Reference-contexts: To use the Grace tool the user has to modify its program. In the area of parallel logic programming, tools are used to visualize the parallel execution of programs, e.g., the Must Tool [Kar92, SS90] and the VisAndOr Tool <ref> [CGH93] </ref>. These tools also visualize the (OR-parallel) search process, however they are designed to be used offline. During execution of a program a trace file is created. After execution has finished, the tool is used to visualize and analyze the created trace.
Reference: [DC93] <author> Daniel Diaz and Philippe Codognet. </author> <title> A minimal extension of the WAM for clp(FD). </title> <editor> In David S. Warren, editor, </editor> <booktitle> International Conference on Logic Programming, </booktitle> <pages> pages 774790, </pages> <address> Budapest, Hungary, 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: To a large extent, the growing interest is caused by both the expressive power and the availability of efficient implementations like CHIP [DVS + 88], ECLiPSe [ACD + 95], cc (FD) [VSD95], clp (FD) <ref> [DC93] </ref>, just to name a few. Development of applications based on constraint programming proceeds in two steps. The first step is to design a principally working solution. This is followed by the much harder task to make this solution work for problems of real-world size.
Reference: [DSVH90] <author> Mehmet Dincbas, Helmut Simonis, and Pascal Van Hentenryck. </author> <title> Solving Large Combinatorial Problems in Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 8(1-2):7494, </volume> <month> January-March </month> <year> 1990. </year>
Reference-contexts: That is, the harder the problem, the less overhead the Explorer incurs. Here, we choose the bridge example <ref> [DSVH90] </ref>, a medium sized scheduling problem. Its search tree consists of 743 nodes (371 choice, 3 solved and 369 failed). Its creation takes 4.43 seconds compared to 3.36 seconds for searching for the best solution. This is a relative overhead of 32%.
Reference: [DVS + 88] <author> Mehmet Dincbas, Pascal Van Hentenryck, Helmut Simonis, Abderra-hamane Aggoun, Thomas Graf, and F. Berthier. </author> <title> The constraint logic programming language CHIP. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems FGCS-88, </booktitle> <pages> pages 693702, </pages> <address> Tokyo, </address> <month> December </month> <year> 1988. </year>
Reference-contexts: 1 Introduction In the last decade constraint logic and concurrent constraint programming, especially with finite domain constraints, has become popular in many application areas. To a large extent, the growing interest is caused by both the expressive power and the availability of efficient implementations like CHIP <ref> [DVS + 88] </ref>, ECLiPSe [ACD + 95], cc (FD) [VSD95], clp (FD) [DC93], just to name a few. Development of applications based on constraint programming proceeds in two steps. The first step is to design a principally working solution.
Reference: [FW95] <author> Michael Fr ohlich and Mattias Werner. </author> <title> Demonstration of the interactive graph visualization system daVinci. </title> <editor> In R. Tamassia and I. G. Tollis, editors, </editor> <title> Graph Drawing, </title> <booktitle> DIMACS International Workshop GD'94, volume 894 of Lecture Notes in Computer Science, </booktitle> <address> Princeton, USA, 1995. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: The methods for computing the layout use an incremental version of the algorithm presented in [Ken95]. We first considered to use existing tools for computing and drawing layouts for graphs (e.g., VCG [San95], daVinci <ref> [FW95] </ref>). Unfortunately, it is hard to design a powerful user interface since the tools have a user interface on their own which can be customized in a limited fashion only. More severe, they fail to support incremental updates of the drawn tree efficiently.
Reference: [HSW95] <author> Martin Henz, Gert Smolka, and Jorg W urtz. </author> <title> Object-oriented concurrent constraint programming in Oz. </title> <editor> In Vijay Saraswat and Pascal Van Henten-ryck, editors, </editor> <booktitle> Principles and Practice of Constraint Programming, chapter 2, </booktitle> <pages> pages 2948. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1995. </year>
Reference-contexts: Oz is a concurrent constraint language providing for functional, object-oriented, and constraint programming <ref> [Smo95b, HSW95, SSW94, SS94, ST95] </ref>. It has a simple yet powerful computation model [Smo95b, Smo95a] which extends the concurrent constraint model [Mah87, SR90] by first-class procedures, concurrent state and encapsulated search. The Explorer uses the search tree as its central metaphor.
Reference: [Kar92] <author> Roland Karlsson. </author> <title> A High Performance OR-parallel Prolog System. </title> <type> PhD thesis, </type> <institution> Swedish Institute of Computer Science, Kista, Sweden, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: To use the Grace tool the user has to modify its program. In the area of parallel logic programming, tools are used to visualize the parallel execution of programs, e.g., the Must Tool <ref> [Kar92, SS90] </ref> and the VisAndOr Tool [CGH93]. These tools also visualize the (OR-parallel) search process, however they are designed to be used offline. During execution of a program a trace file is created. After execution has finished, the tool is used to visualize and analyze the created trace.
Reference: [Ken95] <author> Andrew J. Kennedy. </author> <title> Functional pearls: Drawing trees. </title> <journal> Journal of Functional Programming, </journal> <note> 1995. To appear. </note>
Reference-contexts: Invoking an operation at the user interface sends a message to the object and leads to execution of the corresponding method. The methods for computing the layout use an incremental version of the algorithm presented in <ref> [Ken95] </ref>. We first considered to use existing tools for computing and drawing layouts for graphs (e.g., VCG [San95], daVinci [FW95]). Unfortunately, it is hard to design a powerful user interface since the tools have a user interface on their own which can be customized in a limited fashion only.
Reference: [Mah87] <author> Michael J. Maher. </author> <title> Logic semantics for a class of committed-choice programs. </title> <editor> In Jean-Louis Lassez, editor, </editor> <booktitle> Logic Programming, Proceedings of the Fourth International Conference, </booktitle> <pages> pages 858876, </pages> <address> Melbourne, 1987. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Oz is a concurrent constraint language providing for functional, object-oriented, and constraint programming [Smo95b, HSW95, SSW94, SS94, ST95]. It has a simple yet powerful computation model [Smo95b, Smo95a] which extends the concurrent constraint model <ref> [Mah87, SR90] </ref> by first-class procedures, concurrent state and encapsulated search. The Explorer uses the search tree as its central metaphor. The user can interactively explore the search tree which is visualized as it is explored. Visible nodes carry information on the corresponding constraints.
Reference: [Meh95] <author> Michael Mehl. </author> <title> Window programming in DFKI Oz. DFKI Oz documentation series, </title> <booktitle> German Research Center for Artificial Intelligence (DFKI), </booktitle> <address> Saarbr ucken, Germany, </address> <year> 1995. </year>
Reference-contexts: More severe, they fail to support incremental updates of the drawn tree efficiently. The graphical part of the user interface and the drawing of the tree uses the object oriented interface <ref> [Meh95] </ref> to Tcl/Tk [Ous94] available in Oz. 10 fun -CreateNode Space- case -Ask Space-of failed then -New FailedNode init [] succeeded then -New SolvedNode init (Space)- [] alternatives then -New ChoiceNode init (Space)- end In the following we show how with first-class computation spaces the creation of the search tree can
Reference: [Mei95] <author> Micha Meier. </author> <title> Debugging constraint programs. </title> <editor> In Ugo Montanari and Francesca Rossi, editors, </editor> <booktitle> Proceedings of the First International Conference on Principles and Practice of Constraint Programming, volume 976 of Lecture Notes in Computer Science, pages 204221, </booktitle> <address> Cassis, France, September 1995. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: This is followed by the much harder task to make this solution work for problems of real-world size. The latter task usually involves a high amount of experimentation to gain additional insights into the structure of the problem. Meier reports in <ref> [Mei95] </ref> that a large part of the development process is spent on performance debugging. Therefore it is surprising that existing systems offer little support for the development of constraint programming applications (with the recent exception of [Mei95]). 1 This paper describes a visual constraint programming tool, called Oz Explorer, for Oz. <p> Meier reports in <ref> [Mei95] </ref> that a large part of the development process is spent on performance debugging. Therefore it is surprising that existing systems offer little support for the development of constraint programming applications (with the recent exception of [Mei95]). 1 This paper describes a visual constraint programming tool, called Oz Explorer, for Oz. Oz is a concurrent constraint language providing for functional, object-oriented, and constraint programming [Smo95b, HSW95, SSW94, SS94, ST95]. <p> The practicality of the Explorer is discussed in Section 10. 2 Related Work In the following we relate the Explorer to the Grace tool <ref> [Mei95] </ref>, which is built on top of the ECLiPSe Prolog system [ACD + 95]. The Grace tool is intended to support the development and debugging of finite domain constraint programs. It does not use the metaphor of a search tree.
Reference: [MMPS95] <author> Michael Mehl, Tobias Muller, Konstantin Popov, and Ralf Scheidhauer. </author> <title> DFKI Oz user's manual. DFKI Oz documentation series, </title> <booktitle> German Research Center for Artificial Intelligence (DFKI), </booktitle> <address> Saarbr ucken, Germany, </address> <year> 1995. </year>
Reference-contexts: This is important for problems which have infinite branches in its search tree. Double-clicking the succeeded node displays the constraints of the succeeded computation space using the Oz Browser <ref> [MMPS95] </ref> (a concurrent tool to visualize constraints). The first solution is as follows: sol (pos: pos (alice:1 bert:2 chris:3 deb:4 evan:5) ful: [0 0 1 0 0 1 0 0] Understanding textual output can be difficult, in particular for large problems.
Reference: [Ous94] <author> John K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. Professional Computing Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1994. </year>
Reference-contexts: More severe, they fail to support incremental updates of the drawn tree efficiently. The graphical part of the user interface and the drawing of the tree uses the object oriented interface [Meh95] to Tcl/Tk <ref> [Ous94] </ref> available in Oz. 10 fun -CreateNode Space- case -Ask Space-of failed then -New FailedNode init [] succeeded then -New SolvedNode init (Space)- [] alternatives then -New ChoiceNode init (Space)- end In the following we show how with first-class computation spaces the creation of the search tree can be implemented. 8
Reference: [San95] <author> Georg Sander. </author> <title> Graph layout through the VCG tool. </title> <editor> In R. Tamassia and I. G. Tollis, editors, </editor> <title> Graph Drawing, </title> <booktitle> DIMACS International Workshop GD'94, volume 894 of Lecture Notes in Computer Science, </booktitle> <pages> pages 194 205, </pages> <address> Princeton, USA, 1995. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: The methods for computing the layout use an incremental version of the algorithm presented in [Ken95]. We first considered to use existing tools for computing and drawing layouts for graphs (e.g., VCG <ref> [San95] </ref>, daVinci [FW95]). Unfortunately, it is hard to design a powerful user interface since the tools have a user interface on their own which can be customized in a limited fashion only. More severe, they fail to support incremental updates of the drawn tree efficiently.
Reference: [Smo95a] <author> Gert Smolka. </author> <title> The definition of Kernel Oz. </title> <editor> In Andreas Podelski, editor, </editor> <title> Constraints: Basics and Trends, </title> <booktitle> volume 910 of Lecture Notes in Computer Science, </booktitle> <pages> pages 251292. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Oz is a concurrent constraint language providing for functional, object-oriented, and constraint programming [Smo95b, HSW95, SSW94, SS94, ST95]. It has a simple yet powerful computation model <ref> [Smo95b, Smo95a] </ref> which extends the concurrent constraint model [Mah87, SR90] by first-class procedures, concurrent state and encapsulated search. The Explorer uses the search tree as its central metaphor. The user can interactively explore the search tree which is visualized as it is explored. <p> A full description of Oz's computation model can be found in <ref> [Smo95a, Smo95b] </ref>. The notion of a computation space is central to the computation model. A computation space consists of a number of tasks connected to a constraint store. Computation proceeds by reduction of tasks. The reduction of a task might create new tasks and might write constraints to the store.
Reference: [Smo95b] <author> Gert Smolka. </author> <title> The Oz programming model. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Computer Science Today, Lecture Notes in Computer Science, </booktitle> <volume> vol. 1000, </volume> <pages> pages 324343. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference-contexts: Oz is a concurrent constraint language providing for functional, object-oriented, and constraint programming <ref> [Smo95b, HSW95, SSW94, SS94, ST95] </ref>. It has a simple yet powerful computation model [Smo95b, Smo95a] which extends the concurrent constraint model [Mah87, SR90] by first-class procedures, concurrent state and encapsulated search. The Explorer uses the search tree as its central metaphor. <p> Oz is a concurrent constraint language providing for functional, object-oriented, and constraint programming [Smo95b, HSW95, SSW94, SS94, ST95]. It has a simple yet powerful computation model <ref> [Smo95b, Smo95a] </ref> which extends the concurrent constraint model [Mah87, SR90] by first-class procedures, concurrent state and encapsulated search. The Explorer uses the search tree as its central metaphor. The user can interactively explore the search tree which is visualized as it is explored. <p> A full description of Oz's computation model can be found in <ref> [Smo95a, Smo95b] </ref>. The notion of a computation space is central to the computation model. A computation space consists of a number of tasks connected to a constraint store. Computation proceeds by reduction of tasks. The reduction of a task might create new tasks and might write constraints to the store. <p> Computation spaces are first-class values in Oz, they can be passed as arguments of procedures, can be tested for equality and the like. They are abstract values, similar to procedures and cells in Oz (more information on this can be found in <ref> [Smo95b] </ref>).
Reference: [SR90] <author> Vijay A. Saraswat and Martin Rinard. </author> <title> Concurrent constraint programming. </title> <booktitle> In Proceedings of the 7th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232245, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year> <note> ACM Press. </note>
Reference-contexts: Oz is a concurrent constraint language providing for functional, object-oriented, and constraint programming [Smo95b, HSW95, SSW94, SS94, ST95]. It has a simple yet powerful computation model [Smo95b, Smo95a] which extends the concurrent constraint model <ref> [Mah87, SR90] </ref> by first-class procedures, concurrent state and encapsulated search. The Explorer uses the search tree as its central metaphor. The user can interactively explore the search tree which is visualized as it is explored. Visible nodes carry information on the corresponding constraints.
Reference: [SS90] <author> Jan Sundberg and Claes Svensson. </author> <title> MUSE TRACE: A graphic tracer for OR-parallel Prolog. </title> <type> SICS Technical Report T90003, </type> <institution> Swedish Institute of Computer Science, Kista, Sweden, </institution> <year> 1990. </year>
Reference-contexts: To use the Grace tool the user has to modify its program. In the area of parallel logic programming, tools are used to visualize the parallel execution of programs, e.g., the Must Tool <ref> [Kar92, SS90] </ref> and the VisAndOr Tool [CGH93]. These tools also visualize the (OR-parallel) search process, however they are designed to be used offline. During execution of a program a trace file is created. After execution has finished, the tool is used to visualize and analyze the created trace.
Reference: [SS94] <author> Christian Schulte and Gert Smolka. </author> <title> Encapsulated search in higher-order concurrent constraint programming. </title> <editor> In Maurice Bruynooghe, editor, </editor> <booktitle> Logic Programming: Proceedings of the 1994 International Symposium, </booktitle> <pages> pages 505520, </pages> <address> Ithaca, NY, November 1994. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Oz is a concurrent constraint language providing for functional, object-oriented, and constraint programming <ref> [Smo95b, HSW95, SSW94, SS94, ST95] </ref>. It has a simple yet powerful computation model [Smo95b, Smo95a] which extends the concurrent constraint model [Mah87, SR90] by first-class procedures, concurrent state and encapsulated search. The Explorer uses the search tree as its central metaphor.
Reference: [SSW94] <author> Christian Schulte, Gert Smolka, and J org W urtz. </author> <title> Encapsulated search and constraint programming in Oz. </title> <editor> In Alan H. Borning, editor, </editor> <booktitle> Second Workshop on Principles and Practice of Constraint Programming, volume 874 of Lecture Notes in Computer Science, </booktitle> <pages> pages 134150, </pages> <address> Orcas Island, WA, May 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Oz is a concurrent constraint language providing for functional, object-oriented, and constraint programming <ref> [Smo95b, HSW95, SSW94, SS94, ST95] </ref>. It has a simple yet powerful computation model [Smo95b, Smo95a] which extends the concurrent constraint model [Mah87, SR90] by first-class procedures, concurrent state and encapsulated search. The Explorer uses the search tree as its central metaphor.
Reference: [ST94] <author> Gert Smolka and Ralf Treinen. </author> <title> Records for logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 18(3):229258, </volume> <month> April </month> <year> 1994. </year>
Reference-contexts: The information is expressed by basic constraints. Basic constraints are logic formula interpreted in a fixed first-order structure. In the following we restrict ourselves to the case of finite domain constraints. In addition to finite domain constraints, Oz provides for constraints over rational and feature trees <ref> [ST94] </ref>. A basic finite domain constraint in Oz has the form x 2 D where D is a finite subset of the positive integers.
Reference: [ST95] <author> Gert Smolka and Ralf Treinen, </author> <title> editors. DFKI Oz Documentation Series. </title> <institution> German Research Center for Artificial Intelligence (DFKI), Saarbrucken, Germany, </institution> <year> 1995. </year>
Reference-contexts: Oz is a concurrent constraint language providing for functional, object-oriented, and constraint programming <ref> [Smo95b, HSW95, SSW94, SS94, ST95] </ref>. It has a simple yet powerful computation model [Smo95b, Smo95a] which extends the concurrent constraint model [Mah87, SR90] by first-class procedures, concurrent state and encapsulated search. The Explorer uses the search tree as its central metaphor.
Reference: [VSD95] <author> Pascal Van Hentenryck, Vijay Saraswat, and Yves Deville. </author> <title> Design, implementation and evaluation of the constraint language cc(FD). </title> <editor> In Andreas Podelski, editor, </editor> <booktitle> Constraint Programming: Basics and Trends, Lecture Notes in Computer Science, </booktitle> <volume> vol. 910, </volume> <pages> pages 293316. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: To a large extent, the growing interest is caused by both the expressive power and the availability of efficient implementations like CHIP [DVS + 88], ECLiPSe [ACD + 95], cc (FD) <ref> [VSD95] </ref>, clp (FD) [DC93], just to name a few. Development of applications based on constraint programming proceeds in two steps. The first step is to design a principally working solution. This is followed by the much harder task to make this solution work for problems of real-world size.
References-found: 24

