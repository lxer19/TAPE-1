URL: http://www.cs.cornell.edu/kozen/686/Vardi/cade97.ps
Refering-URL: http://www.cs.cornell.edu/kozen/686/
Root-URL: 
Email: Email: vardi@cs.rice.edu  
Title: Alternating Automata: Checking Truth and Validity for Temporal Logics  
Author: Moshe Y. Vardi 
Web: URL: http://www.cs.rice.edu/ vardi  
Address: Houston, TX 77005-1892, U.S.A.  
Affiliation: Rice University Department of Computer Science  
Abstract: We describe an automata-theoretic approach to the automated checking of truth and validity for temporal logics. The basic idea underlying this approach is that for any formula we can construct an alternating automaton that accepts precisely the models of the formula. For linear temporal logics the automaton runs on infinite words while for branching temporal logics the automaton runs on infinite trees. The simple combinatorial structures that emerge from the automata-theoretic approach decouple the logical and algorithmic components of truth and validity checking and yield clean and essentially optimal algorithms for both problems.
Abstract-found: 1
Intro-found: 1
Reference: [BL80] <author> J.A. Brzozowski and E. Leiss. </author> <title> Finite automata, and sequential networks. </title> <journal> Theoretical Computer Science, </journal> <volume> 10 </volume> <pages> 19-35, </pages> <year> 1980. </year>
Reference-contexts: Its dual gives a computing device the power of universal choice. It is therefore natural to consider computing devices that have the power of both existential choice and universal choice. Such devices are called alternating. Alternation was studied in [CKS81] in the context of Turing machines and in <ref> [BL80, CKS81] </ref> for finite automata. The alternation formalisms in [BL80] and [CKS81] are different, though equivalent. We follow here the formalism of [BL80], which was extended in [MS87] to automata on infinite structures. <p> It is therefore natural to consider computing devices that have the power of both existential choice and universal choice. Such devices are called alternating. Alternation was studied in [CKS81] in the context of Turing machines and in [BL80, CKS81] for finite automata. The alternation formalisms in <ref> [BL80] </ref> and [CKS81] are different, though equivalent. We follow here the formalism of [BL80], which was extended in [MS87] to automata on infinite structures. <p> Such devices are called alternating. Alternation was studied in [CKS81] in the context of Turing machines and in [BL80, CKS81] for finite automata. The alternation formalisms in <ref> [BL80] </ref> and [CKS81] are different, though equivalent. We follow here the formalism of [BL80], which was extended in [MS87] to automata on infinite structures. For a given set X, let B + (X) be the set of positive Boolean formulas over X (i.e., Boolean formulas built from elements in X using ^ and _), where we also allow the formulas true and false.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <editor> In D.L. Dill, editor, </editor> <booktitle> Computer Aided Verification, Proc. 6th Int. Conference, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 142-155, </pages> <address> Stanford, California, 1994. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address> <note> full version available from authors. </note>
Reference-contexts: Thus, the automata-theoretic approach did not seem to be applicable to branching-time truth checking, which in many cases can be done in linear running time [CES86, QS81, Cle93], Recently it has been shown that if one uses alternating automata rather than nondeterministic automata, then these problems can be solved <ref> [Var94, BVW94] </ref>. Alternating automata generalize the standard notion of nondeterministic automata by allowing several successor states to go down along the same word or the same branch of the tree. <p> The key obser-vation is that while the translation from temporal logic formulas to nondeterministic automata is exponential [VW86b, VW94], the translation to alternating automata is linear <ref> [MSS88, EJ91, Var94, BVW94] </ref>. Thus, the advantage of alternating automata is that they enable one to decouple the logic from the algorithmics. <p> It turns out that nonemptiness for alternating word automata over a 1-letter alphabet is easier than the general nonemptiness problem. Actually, it is as easy as the nonemptiness problem for nondeterministic Buchi tree automata (Proposition 5). Proposition 8. <ref> [BVW94] </ref> The nonemptiness problem for alternating B uchi word automata over a 1-letter alphabet is decidable in quadratic time. As we shall see later, the alternating automata in our applications have a special structure, studied first in [MSS86]. <p> The number of sets in the partition of S is defined as the depth of the automaton. It turns out that the nonemptiness problem for WAA on words over a 1-letter alphabet is easier than the nonemptiness problem for alternating Buchi word automata over a 1-letter alphabet. Proposition 9. <ref> [BVW94] </ref> The nonemptiness problem for weak alternating word automata over a 1-letter alphabet is decidable in linear time. As we will see, the WAA that we use have an even more special structure. <p> Thus, whenever a copy alternates modes, it must be that it moves from one S i to the next. We call a WAA that satisfies this property a hesitant alternating automata (or HAA, for short). Proposition 10. <ref> [BVW94] </ref> The nonemptiness problem for hesitant alternating word automata of size n and depth m over a 1-letter alphabet can be solved in time O (n) or in space O (m log 2 n). 3 Temporal Logics and Alternating Automata 3.1 Linear Temporal Logic Formulas of linear temporal logic (LTL) are <p> It turns out that the tree programs in which a given formula is true are exactly those accepted by some finite tree automaton. The following theorem establishes a very simple translation between CTL and weak alternating Buchi tree automata. Theorem 13. <ref> [MSS88, BVW94] </ref> Given a CTL formula ' and a finite set D N , one can build an HAA A D ' = (; D; S; s 0 ; ; F ), where = 2 P rop and jSj is in O (j'j), such that T ! (A D ' ) <p> Note that if P has m 1 states and A D;' has m 2 states then A P;' has O (m 1 m 2 ) states. Proposition 18. <ref> [BVW94] </ref> A P;' is nonempty if and only if P j= '. We can now put together Propositions 9, 10, and 18 to get a truth-checking algorithm for CTL. <p> Proposition 18. [BVW94] A P;' is nonempty if and only if P j= '. We can now put together Propositions 9, 10, and 18 to get a truth-checking algorithm for CTL. Theorem 19. <ref> [CES86, BVW94] </ref> Checking whether a CTL formula ' is true in a finite--state program P can be done in time O (jP j j'j) or in space O (j'j log 2 We note that the upper space bound of Theorem 14 is probably optimal, since the truth-checking problem for CTL is <p> in a finite--state program P can be done in time O (jP j j'j) or in space O (j'j log 2 We note that the upper space bound of Theorem 14 is probably optimal, since the truth-checking problem for CTL is PTIME-hard for fixed programs and NLOGSPACE-hard for fixed formulas <ref> [BVW94] </ref>.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: Underlying the notion of logical validity, however, is the notion of logical truth. In many computer science applications, the focus is on the checking of logical truth rather than of logical validity. This is certainly the case in database query evaluation (see [Var82]) and in finite-state program verification (see <ref> [CES86] </ref>). (In fact, we have argued elsewhere that even applications that traditionally focus on logical validity, such as knowledge representation, might be better off focusing on logical truth [HV91].) In general, the algorithmic techniques in computer-aided validity analysis, i.e., validity checking, and in computer-aided truth analysis, i.e., truth checking, seem to <p> One of the most significant developments in this ? Supported in part by the NSF grant CCR-9628400. area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs <ref> [CES86, LP85, QS81] </ref>. This derives its significance from the fact that many synchronization and communication protocols can be modeled as finite-state programs [Liu89, Rud87]. <p> This suggests that any algorithm that uses these translations as one of its steps is going to be an exponential-time algorithm. Thus, the automata-theoretic approach did not seem to be applicable to branching-time truth checking, which in many cases can be done in linear running time <ref> [CES86, QS81, Cle93] </ref>, Recently it has been shown that if one uses alternating automata rather than nondeterministic automata, then these problems can be solved [Var94, BVW94]. <p> Proposition 18. [BVW94] A P;' is nonempty if and only if P j= '. We can now put together Propositions 9, 10, and 18 to get a truth-checking algorithm for CTL. Theorem 19. <ref> [CES86, BVW94] </ref> Checking whether a CTL formula ' is true in a finite--state program P can be done in time O (jP j j'j) or in space O (j'j log 2 We note that the upper space bound of Theorem 14 is probably optimal, since the truth-checking problem for CTL is
Reference: [CG87] <author> E.M. Clarke and O. Grumberg. </author> <title> Avoiding the state explosion problem in temporal logic model-checking algorithms. </title> <booktitle> In Proc. 6th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 294-303, </pages> <address> Vancouver, British Columbia, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint (see <ref> [CG87, Wol89, CGL93] </ref>), though we prefer to use the term truth checking in this paper.
Reference: [CGL93] <author> E.M. Clarke, O. Grumberg, and D. </author> <title> Long. Verification tools for finite-state concurrent systems. </title> <booktitle> In A Decade of Concurrency Reflections and Perspectives (Proc. REX School/Symposium), volume 803 of Lecture Notes in Computer Science, </booktitle> <pages> pages 124-175. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint (see <ref> [CG87, Wol89, CGL93] </ref>), though we prefer to use the term truth checking in this paper.
Reference: [Cho74] <author> Y. Choueka. </author> <title> Theories of automata on !-tapes: A simplified approach. </title> <journal> J. Computer and System Sciences, </journal> <volume> 8 </volume> <pages> 117-141, </pages> <year> 1974. </year>
Reference-contexts: The infinite word w is accepted by A if there is an accepting run of A on w. The set of infinite words accepted by A is denoted L ! (A). An important feature of nondeterministic Buchi automata is their closure under intersection. Proposition 1. <ref> [Cho74] </ref> Let A 1 and A 2 be nondeterministic word B uchi automata with n 1 and n 2 states, respectively.
Reference: [CKS81] <author> A.K. Chandra, D.C. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 28(1) </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference-contexts: Its dual gives a computing device the power of universal choice. It is therefore natural to consider computing devices that have the power of both existential choice and universal choice. Such devices are called alternating. Alternation was studied in <ref> [CKS81] </ref> in the context of Turing machines and in [BL80, CKS81] for finite automata. The alternation formalisms in [BL80] and [CKS81] are different, though equivalent. We follow here the formalism of [BL80], which was extended in [MS87] to automata on infinite structures. <p> Its dual gives a computing device the power of universal choice. It is therefore natural to consider computing devices that have the power of both existential choice and universal choice. Such devices are called alternating. Alternation was studied in [CKS81] in the context of Turing machines and in <ref> [BL80, CKS81] </ref> for finite automata. The alternation formalisms in [BL80] and [CKS81] are different, though equivalent. We follow here the formalism of [BL80], which was extended in [MS87] to automata on infinite structures. <p> It is therefore natural to consider computing devices that have the power of both existential choice and universal choice. Such devices are called alternating. Alternation was studied in <ref> [CKS81] </ref> in the context of Turing machines and in [BL80, CKS81] for finite automata. The alternation formalisms in [BL80] and [CKS81] are different, though equivalent. We follow here the formalism of [BL80], which was extended in [MS87] to automata on infinite structures.
Reference: [Cle93] <author> R. Cleaveland. </author> <title> A linear-time model-checking algorithm for the alternation-free modal -calculus. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 2 </volume> <pages> 121-147, </pages> <year> 1993. </year>
Reference-contexts: This suggests that any algorithm that uses these translations as one of its steps is going to be an exponential-time algorithm. Thus, the automata-theoretic approach did not seem to be applicable to branching-time truth checking, which in many cases can be done in linear running time <ref> [CES86, QS81, Cle93] </ref>, Recently it has been shown that if one uses alternating automata rather than nondeterministic automata, then these problems can be solved [Var94, BVW94].
Reference: [CVWY92] <author> C. Courcoubetis, M.Y. Vardi, P. Wolper, and M. Yannakakis. </author> <title> Memory efficient algorithms for the verification of temporal properties. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 1 </volume> <pages> 275-288, </pages> <year> 1992. </year>
Reference-contexts: For a practical verification algorithm that is based on the automata-theoretic approach see <ref> [CVWY92] </ref>. 4.2 Branching Temporal Logic We are given a CTL formula '. Recall that ' is valid iff it is true in all programs. For LTL, Theorems 11 and 12 provided automata-theoretic characterizations of all models of the formula.
Reference: [EH85] <author> E.A. Emerson and J.Y. Halpern. </author> <title> Decision procedures and expressiveness in the temporal logic of branching time. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 30 </volume> <pages> 1-24, </pages> <year> 1985. </year>
Reference-contexts: It follows from Proposition 16 that a CTL formula is valid iff T ! (A :' ) = ;. Combining this with Proposition 7, we get: Theorem 17. <ref> [EH85] </ref> Checking whether a CTL formula ' is valid can be done in time O (2 O (j'j) ). We note that the upper time bound of Theorem 17 is essentially optimal, since the validity problem for CTL is EXPTIME-hard [FL79]. We now consider truth checking for CTL.
Reference: [EJ88] <author> E.A. Emerson and C. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proceedings of the 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 328-337, </pages> <address> White Plains, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: For linear temporal logic the structures are infinite words [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94], while for branching temporal logic the structures are infinite trees <ref> [ES84, SE84, Eme85, EJ88, VW86b] </ref>. This enables the reduction of temporal logic decision problems, both truth and validity checking, to known automata-theoretic problems. Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. [VW86b, VW94]). These translations have two disadvantages.
Reference: [EJ91] <author> E.A. Emerson and C. Jutla. </author> <title> Tree automata, mu-calculus and determinacy. </title> <booktitle> In Proceedings of the 32nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 368-377, </pages> <address> San Juan, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: The key obser-vation is that while the translation from temporal logic formulas to nondeterministic automata is exponential [VW86b, VW94], the translation to alternating automata is linear <ref> [MSS88, EJ91, Var94, BVW94] </ref>. Thus, the advantage of alternating automata is that they enable one to decouple the logic from the algorithmics.
Reference: [EL85a] <author> E.A. Emerson and C.-L. Lei. </author> <title> Modalities for model checking: Branching time logic strikes back. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-96, </pages> <address> New Orleans, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: A Buchi automaton A is nonempty if L ! (A) 6= ;. The nonemptiness problem for automata is to decide, given an automaton A, whether A is nonempty. It turns out that testing nonemptiness is easy. Proposition 2. 1. <ref> [EL85b, EL85a] </ref> The nonemptiness problem for nondeterministic B uchi word au tomata is decidable in linear time. 2. [VW94] The nonemptiness problem for nondeterministic B uchi automata of size n is decidable in space O (log 2 2.3 Alternating Automata on Infinite Words Nondeterminism gives a computing device the power of
Reference: [EL85b] <author> E.A. Emerson and C.-L. Lei. </author> <title> Temporal model checking under generalized fairness constraints. </title> <booktitle> In Proc. 18th Hawaii International Conference on System Sciences, </booktitle> <pages> pages 277-288, </pages> <address> Hawaii, </address> <year> 1985. </year>
Reference-contexts: A Buchi automaton A is nonempty if L ! (A) 6= ;. The nonemptiness problem for automata is to decide, given an automaton A, whether A is nonempty. It turns out that testing nonemptiness is easy. Proposition 2. 1. <ref> [EL85b, EL85a] </ref> The nonemptiness problem for nondeterministic B uchi word au tomata is decidable in linear time. 2. [VW94] The nonemptiness problem for nondeterministic B uchi automata of size n is decidable in space O (log 2 2.3 Alternating Automata on Infinite Words Nondeterminism gives a computing device the power of
Reference: [Eme85] <author> E.A. Emerson. </author> <title> Automata, tableaux, and temporal logics. In Logic of Programs, </title> <booktitle> volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 79-87. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: For linear temporal logic the structures are infinite words [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94], while for branching temporal logic the structures are infinite trees <ref> [ES84, SE84, Eme85, EJ88, VW86b] </ref>. This enables the reduction of temporal logic decision problems, both truth and validity checking, to known automata-theoretic problems. Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. [VW86b, VW94]). These translations have two disadvantages.
Reference: [Eme90a] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <address> B:997-1072, </address> <year> 1990. </year>
Reference-contexts: 2 n). 3 Temporal Logics and Alternating Automata 3.1 Linear Temporal Logic Formulas of linear temporal logic (LTL) are built from a set P rop of atomic propositions and are closed under the application of Boolean connectives, the unary temporal connective X (next), and the binary temporal connective U (until) <ref> [Eme90a] </ref>. LTL is interpreted over computations. A computation is a function : ! ! 2 P rop , which assigns truth values to the elements of P rop at each time instant (natural number). <p> such that L ! (A ' ) is exactly the set of computations in which the formula ' is true. 3.2 Branching Temporal Logic The branching temporal logic CTL (Computation Tree Logic) provides temporal con-nectives that are composed of a path quantifier immediately followed by a single linear temporal connective <ref> [Eme90a] </ref>. The path quantifiers are A (for all paths) and E (for some path). The linear-time connectives are X (next time) and U (until).
Reference: [Eme90b] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <booktitle> Handbook of theoretical computer science, </booktitle> <pages> pages 997-1072, </pages> <year> 1990. </year>
Reference-contexts: For LTL, Theorems 11 and 12 provided automata-theoretic characterizations of all models of the formula. This is not the case for CTL, as Theorem 13 provides only a characterization of tree models. Fortunately, this suffices for validity checking due to the following proposition. Proposition 16. <ref> [Eme90b] </ref> Let ' be a CTL formula. Then ' is valid iff ' is true in all j'j-tree programs. Let A ' be the automaton A fj'jg ' , i.e., it is the automaton A D ' of Theorem 13, with D = fj'jg.
Reference: [ES84] <author> E.A. Emerson and A. P. Sistla. </author> <title> Deciding branching time logic. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 14-24, </pages> <address> Washington, </address> <month> April </month> <year> 1984. </year>
Reference-contexts: For linear temporal logic the structures are infinite words [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94], while for branching temporal logic the structures are infinite trees <ref> [ES84, SE84, Eme85, EJ88, VW86b] </ref>. This enables the reduction of temporal logic decision problems, both truth and validity checking, to known automata-theoretic problems. Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. [VW86b, VW94]). These translations have two disadvantages.
Reference: [FL79] <author> M.J. Fischer and R.E. Ladner. </author> <title> Propositional dynamic logic of regular programs. </title> <journal> J. of Computer and Systems Sciences, </journal> <volume> 18 </volume> <pages> 194-211, </pages> <year> 1979. </year>
Reference-contexts: Our goal in this paper is to show that for temporal logics it is possible to unify the algorithmic techniques underlying validity and truth checking. We will argue that alternating automata provide such a unifying algorithmic tool. (This tool is also applicable to dynamic logics <ref> [FL79] </ref> and description logics [GL94], but because of space constraints we cannot cover these logics in this paper.) Temporal logics, which are logics geared towards the description of the temporal ordering of events, have been adopted as a powerful tool for specifying and verifying concurrent programs [Pnu77, MP92]. <p> Combining this with Proposition 7, we get: Theorem 17. [EH85] Checking whether a CTL formula ' is valid can be done in time O (2 O (j'j) ). We note that the upper time bound of Theorem 17 is essentially optimal, since the validity problem for CTL is EXPTIME-hard <ref> [FL79] </ref>. We now consider truth checking for CTL. For LTL, each program may correspond to infinitely many computations. Truth checking is thus reduced to checking inclusion between the set of computations allowed by the program and the language of an automaton describing the formula.
Reference: [GL94] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: Our goal in this paper is to show that for temporal logics it is possible to unify the algorithmic techniques underlying validity and truth checking. We will argue that alternating automata provide such a unifying algorithmic tool. (This tool is also applicable to dynamic logics [FL79] and description logics <ref> [GL94] </ref>, but because of space constraints we cannot cover these logics in this paper.) Temporal logics, which are logics geared towards the description of the temporal ordering of events, have been adopted as a powerful tool for specifying and verifying concurrent programs [Pnu77, MP92].
Reference: [HV91] <author> J. Y. Halpern and M. Y. Vardi. </author> <title> Model checking vs. theorem proving: a manifesto. </title> <editor> In V. Lifschitz, editor, </editor> <booktitle> Artificial Intelligence and Mathematical Theory of Computation (Papers in Honor of John McCarthy), </booktitle> <pages> pages 151-176. </pages> <publisher> Academic Press, </publisher> <address> San Diego, Calif., </address> <year> 1991. </year>
Reference-contexts: This is certainly the case in database query evaluation (see [Var82]) and in finite-state program verification (see [CES86]). (In fact, we have argued elsewhere that even applications that traditionally focus on logical validity, such as knowledge representation, might be better off focusing on logical truth <ref> [HV91] </ref>.) In general, the algorithmic techniques in computer-aided validity analysis, i.e., validity checking, and in computer-aided truth analysis, i.e., truth checking, seem to do very little with each other, in spite of the obvious relationship between truth and validity.
Reference: [KV97] <author> Orna Kupferman and M. Y. Vardi. </author> <title> Weak alternating automata are not so weak. </title> <booktitle> In Proc. 5th Israeli Symp. on Theory of Computing and Systems, </booktitle> <year> 1997. </year>
Reference-contexts: 12, L ! (A ' ) = L ! (A :' ) and the automaton A :' has 2 O (j'j) states. (A straightforward approach, starting with the automaton A ' and then complementing it, would result in a doubly exponential blow-up, since complementation of nondeterministic Buchi automata is exponential <ref> [SVW87, Mic88, Saf88, KV97] </ref>). To get the intersection of the two automata, we use Proposition 1. Consequently, we can build an automaton for L ! (A P ) " L ! (A :' ) having jW j 2 O (j'j) states. We need to check this automaton for emptiness.
Reference: [Lam80] <author> L. Lamport. </author> <title> Sometimes is sometimes not never on the temporal logic of programs. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-185, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Note that the formula that specifies the desired behavior clearly should be neither valid nor unsatisfiable, which entails that a computer-aided verification system has to have the capacity for validity checking in addition to truth checking. We distinguish between two types of temporal logics: linear and branching <ref> [Lam80] </ref>. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures.
Reference: [Liu89] <author> M.T. Liu. </author> <title> Protocol engineering. </title> <booktitle> Advances in Computing, </booktitle> <volume> 29 </volume> <pages> 79-195, </pages> <year> 1989. </year>
Reference-contexts: This derives its significance from the fact that many synchronization and communication protocols can be modeled as finite-state programs <ref> [Liu89, Rud87] </ref>. Finite-state programs can be modeled by transition systems where each state has a bounded description, and hence can be characterized by a fixed number of Boolean atomic propositions.
Reference: [LP85] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107, </pages> <address> New Orleans, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: One of the most significant developments in this ? Supported in part by the NSF grant CCR-9628400. area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs <ref> [CES86, LP85, QS81] </ref>. This derives its significance from the fact that many synchronization and communication protocols can be modeled as finite-state programs [Liu89, Rud87]. <p> Consequently, we can build an automaton for L ! (A P ) " L ! (A :' ) having jW j 2 O (j'j) states. We need to check this automaton for emptiness. Using Proposition 2, we get the following results. Theorem 15. <ref> [LP85, SC85, VW86a] </ref> Checking whether an LTL formula ' is true in a finite-state program P can be done in time O (jP j 2 O (j'j) ) or in space O ((j'j + log jP j) 2 ). <p> We also note that a time upper bound that is polynomial in the size of the program and exponential in the size of the specification is considered here to be reasonable, since the specification is usually rather short <ref> [LP85] </ref>. For a practical verification algorithm that is based on the automata-theoretic approach see [CVWY92]. 4.2 Branching Temporal Logic We are given a CTL formula '. Recall that ' is valid iff it is true in all programs.
Reference: [LPZ85] <author> O. Lichtenstein, A. Pnueli, and L. Zuck. </author> <title> The glory of the past. In Logics of Programs, </title> <booktitle> volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 196-218, </pages> <address> Brooklyn, 1985. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: The basic idea is to associate with each temporal logic formula a finite automaton on infinite structures that accepts exactly all the computations in which the formula is true. For linear temporal logic the structures are infinite words <ref> [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94] </ref>, while for branching temporal logic the structures are infinite trees [ES84, SE84, Eme85, EJ88, VW86b]. This enables the reduction of temporal logic decision problems, both truth and validity checking, to known automata-theoretic problems.
Reference: [MH84] <author> S. Miyano and T. Hayashi. </author> <title> Alternating finite automata on !-words. </title> <journal> Theoretical Computer Science, </journal> <volume> 32 </volume> <pages> 321-330, </pages> <year> 1984. </year>
Reference-contexts: It turns out that they have the same expressive power (although alternating Buchi automata are more succinct than nondeterministic Buchi automata). Proposition 3. <ref> [MH84] </ref> Let A be an alternating B uchi word automaton with n states. Then there is a nondeterministic B uchi word automaton A n with 2 O (n) states such that L ! (A n ) = L ! (A).
Reference: [Mic88] <author> M. Michel. </author> <title> Complementation is more difficult with automata on infinite words. </title> <address> CNET, Paris, </address> <year> 1988. </year>
Reference-contexts: 12, L ! (A ' ) = L ! (A :' ) and the automaton A :' has 2 O (j'j) states. (A straightforward approach, starting with the automaton A ' and then complementing it, would result in a doubly exponential blow-up, since complementation of nondeterministic Buchi automata is exponential <ref> [SVW87, Mic88, Saf88, KV97] </ref>). To get the intersection of the two automata, we use Proposition 1. Consequently, we can build an automaton for L ! (A P ) " L ! (A :' ) having jW j 2 O (j'j) states. We need to check this automaton for emptiness.
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: applicable to dynamic logics [FL79] and description logics [GL94], but because of space constraints we cannot cover these logics in this paper.) Temporal logics, which are logics geared towards the description of the temporal ordering of events, have been adopted as a powerful tool for specifying and verifying concurrent programs <ref> [Pnu77, MP92] </ref>. One of the most significant developments in this ? Supported in part by the NSF grant CCR-9628400. area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs [CES86, LP85, QS81].
Reference: [MS87] <author> D.E. Muller and P.E. Schupp. </author> <title> Alternating automata on infinite trees. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 54,:267-276, </address> <year> 1987. </year>
Reference-contexts: Such devices are called alternating. Alternation was studied in [CKS81] in the context of Turing machines and in [BL80, CKS81] for finite automata. The alternation formalisms in [BL80] and [CKS81] are different, though equivalent. We follow here the formalism of [BL80], which was extended in <ref> [MS87] </ref> to automata on infinite structures. For a given set X, let B + (X) be the set of positive Boolean formulas over X (i.e., Boolean formulas built from elements in X using ^ and _), where we also allow the formulas true and false. Let Y X.
Reference: [MS95] <author> D.E. Muller and P.E. Schupp. </author> <title> Simulating alternating tree automata by nondeterministic automata: New results and new proofs of the theorems by Rabin, McNaughton and Safra. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 141(1-2):69-108, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: As with alternating Buchi automata on words, alternating Buchi tree automata are as expressive as nondeterministic Buchi tree automata. Proposition 6. <ref> [MS95] </ref> Let A be an alternating B uchi automaton with n states. Then there is a nondeterministic B uchi automaton A n with 2 O (n) states such that T ! (A n ) = T ! (A).
Reference: [MSS86] <author> D.E. Muller, A. Saoudi, and P.E. Schupp. </author> <title> Alternating automata, the weak monadic theory of the tree and its complexity. </title> <editor> In L. Kott, editor, </editor> <booktitle> Automata, Languages and Programming, Proc. 13th Int. Colloquium (ICALP '86), volume 226 of Lecture Notes in Computer Science, </booktitle> <pages> pages 275-283. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: Proposition 8. [BVW94] The nonemptiness problem for alternating B uchi word automata over a 1-letter alphabet is decidable in quadratic time. As we shall see later, the alternating automata in our applications have a special structure, studied first in <ref> [MSS86] </ref>.
Reference: [MSS88] <author> D. E. Muller, A. Saoudi, and P. E. Schupp. </author> <title> Weak alternating automata give a simple explanation of why most temporal and dynamic logics are decidable in exponential time. </title> <booktitle> In Proceedings 3rd IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 422-427, </pages> <address> Edinburgh, </address> <month> July </month> <year> 1988. </year>
Reference-contexts: The key obser-vation is that while the translation from temporal logic formulas to nondeterministic automata is exponential [VW86b, VW94], the translation to alternating automata is linear <ref> [MSS88, EJ91, Var94, BVW94] </ref>. Thus, the advantage of alternating automata is that they enable one to decouple the logic from the algorithmics. <p> It turns out that the computations in which a given formula is true are exactly those accepted by some finite automaton on infinite words. The following theorem establishes a very simple translation between LTL and alternating Buchi automata on infinite words. Theorem 11. <ref> [MSS88, Var94] </ref> Given an LTL formula ', one can build an alternating B uchi automaton A ' = (; S; s 0 ; ; F ), where = 2 P rop and jSj is in O (j'j), such that L ! (A ' ) is exactly the set of computations in <p> It turns out that the tree programs in which a given formula is true are exactly those accepted by some finite tree automaton. The following theorem establishes a very simple translation between CTL and weak alternating Buchi tree automata. Theorem 13. <ref> [MSS88, BVW94] </ref> Given a CTL formula ' and a finite set D N , one can build an HAA A D ' = (; D; S; s 0 ; ; F ), where = 2 P rop and jSj is in O (j'j), such that T ! (A D ' )
Reference: [Pei85] <author> R. Peikert. </author> <title> !-regular languages and propositional temporal logic. </title> <type> Technical Report 85-01, </type> <institution> ETH, </institution> <year> 1985. </year>
Reference-contexts: The basic idea is to associate with each temporal logic formula a finite automaton on infinite structures that accepts exactly all the computations in which the formula is true. For linear temporal logic the structures are infinite words <ref> [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94] </ref>, while for branching temporal logic the structures are infinite trees [ES84, SE84, Eme85, EJ88, VW86b]. This enables the reduction of temporal logic decision problems, both truth and validity checking, to known automata-theoretic problems.
Reference: [Pnu77] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proc. 18th IEEE Symposium on Foundation of Computer Science, </booktitle> <pages> pages 46-57, </pages> <year> 1977. </year>
Reference-contexts: applicable to dynamic logics [FL79] and description logics [GL94], but because of space constraints we cannot cover these logics in this paper.) Temporal logics, which are logics geared towards the description of the temporal ordering of events, have been adopted as a powerful tool for specifying and verifying concurrent programs <ref> [Pnu77, MP92] </ref>. One of the most significant developments in this ? Supported in part by the NSF grant CCR-9628400. area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs [CES86, LP85, QS81].
Reference: [QS81] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in Cesar. </title> <booktitle> In Int. Symp. on programming, Proc. 5th Int. Symposium, volume 137 of Lecture Notes in Computer Science, </booktitle> <pages> pages 337-351. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: One of the most significant developments in this ? Supported in part by the NSF grant CCR-9628400. area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs <ref> [CES86, LP85, QS81] </ref>. This derives its significance from the fact that many synchronization and communication protocols can be modeled as finite-state programs [Liu89, Rud87]. <p> This suggests that any algorithm that uses these translations as one of its steps is going to be an exponential-time algorithm. Thus, the automata-theoretic approach did not seem to be applicable to branching-time truth checking, which in many cases can be done in linear running time <ref> [CES86, QS81, Cle93] </ref>, Recently it has been shown that if one uses alternating automata rather than nondeterministic automata, then these problems can be solved [Var94, BVW94].
Reference: [Rab70] <author> M.O. Rabin. </author> <title> Weakly definable relations and special automata. </title> <editor> In Y. Bar-Hilel, editor, </editor> <booktitle> Proc. Symp. Math. Logic and Foundations of Set Theory, </booktitle> <pages> pages 1-23. </pages> <publisher> North Holland, </publisher> <year> 1970. </year>
Reference-contexts: The set of trees accepted by A is denoted T ! (A). Proposition 5. <ref> [Rab70, VW86b] </ref> The nonemptiness problem for nondeterministic B uchi tree automata is decidable in quadratic time. 2.5 Alternating Automata on Infinite Trees An alternating B uchi tree automaton A is a tuple (; D; S; s 0 ; ; F ).
Reference: [Rud87] <author> H. </author> <title> Rudin. Network protocols and tools to help produce them. </title> <booktitle> Annual Review of Computer Science, </booktitle> <volume> 2 </volume> <pages> 291-316, </pages> <year> 1987. </year>
Reference-contexts: This derives its significance from the fact that many synchronization and communication protocols can be modeled as finite-state programs <ref> [Liu89, Rud87] </ref>. Finite-state programs can be modeled by transition systems where each state has a bounded description, and hence can be characterized by a fixed number of Boolean atomic propositions.
Reference: [Saf88] <author> S. Safra. </author> <title> On the complexity of omega-automata. </title> <booktitle> In Proceedings of the 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 319-327, </pages> <address> White Plains, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: 12, L ! (A ' ) = L ! (A :' ) and the automaton A :' has 2 O (j'j) states. (A straightforward approach, starting with the automaton A ' and then complementing it, would result in a doubly exponential blow-up, since complementation of nondeterministic Buchi automata is exponential <ref> [SVW87, Mic88, Saf88, KV97] </ref>). To get the intersection of the two automata, we use Proposition 1. Consequently, we can build an automaton for L ! (A P ) " L ! (A :' ) having jW j 2 O (j'j) states. We need to check this automaton for emptiness.
Reference: [SC85] <author> A.P. Sistla and E.M. Clarke. </author> <title> The complexity of propositional linear temporal logic. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 32 </volume> <pages> 733-749, </pages> <year> 1985. </year>
Reference-contexts: Since ! L ! (A ' ) = L ! (A :' ), we have that ' is valid iff L ! (A :' ) = ;. Thus, validity checking is been reduced to emptiness checking. We can now combine Proposition 2 with Corollary 12: Theorem 14. <ref> [SC85] </ref> Checking whether an LTL formula ' is valid can be done in time O (2 O (j'j) ) or in space O ((j'j) 2 ). We note that the upper space bound of Theorem 14 is essentially optimal, since the validity problem for LTL is PSPACE-hard [SC85]. <p> 12: Theorem 14. <ref> [SC85] </ref> Checking whether an LTL formula ' is valid can be done in time O (2 O (j'j) ) or in space O ((j'j) 2 ). We note that the upper space bound of Theorem 14 is essentially optimal, since the validity problem for LTL is PSPACE-hard [SC85]. We now assume that we are given a finite-state program P = (W; w 0 ; R; V ) and an LTL formula ', and we want to check that ' is true in P . <p> Consequently, we can build an automaton for L ! (A P ) " L ! (A :' ) having jW j 2 O (j'j) states. We need to check this automaton for emptiness. Using Proposition 2, we get the following results. Theorem 15. <ref> [LP85, SC85, VW86a] </ref> Checking whether an LTL formula ' is true in a finite-state program P can be done in time O (jP j 2 O (j'j) ) or in space O ((j'j + log jP j) 2 ). <p> We note that the upper space bound of Theorem 14 is essentially optimal, since the truth-checking problem for LTL is PSPACE-hard <ref> [SC85] </ref> for fixed programs and NLOGSPACE-hard for fixed formulas [VW86a]. We also note that a time upper bound that is polynomial in the size of the program and exponential in the size of the specification is considered here to be reasonable, since the specification is usually rather short [LP85].
Reference: [SE84] <author> R. S. Streett and E. A. Emerson. </author> <title> The propositional mu-calculus is elementary. </title> <editor> In J. Paredaens, editor, </editor> <booktitle> Automata, Languages and Programming, Proc. 11th Int. Colloquium (ICALP '84), volume 172 of Lecture Notes in Computer Science, </booktitle> <pages> pages 465-472. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1984. </year>
Reference-contexts: For linear temporal logic the structures are infinite words [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94], while for branching temporal logic the structures are infinite trees <ref> [ES84, SE84, Eme85, EJ88, VW86b] </ref>. This enables the reduction of temporal logic decision problems, both truth and validity checking, to known automata-theoretic problems. Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. [VW86b, VW94]). These translations have two disadvantages.
Reference: [Sis83] <author> A.P. Sistla. </author> <title> Theoretical issues in the design and analysis of distributed systems. </title> <type> PhD thesis, </type> <institution> Harvard University, </institution> <year> 1983. </year>
Reference-contexts: The basic idea is to associate with each temporal logic formula a finite automaton on infinite structures that accepts exactly all the computations in which the formula is true. For linear temporal logic the structures are infinite words <ref> [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94] </ref>, while for branching temporal logic the structures are infinite trees [ES84, SE84, Eme85, EJ88, VW86b]. This enables the reduction of temporal logic decision problems, both truth and validity checking, to known automata-theoretic problems.
Reference: [SVW87] <author> A.P. Sistla, M.Y. Vardi, and P. Wolper. </author> <title> The complementation problem for Buchi automata with applications to temporal logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 49 </volume> <pages> 217-237, </pages> <year> 1987. </year>
Reference-contexts: The basic idea is to associate with each temporal logic formula a finite automaton on infinite structures that accepts exactly all the computations in which the formula is true. For linear temporal logic the structures are infinite words <ref> [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94] </ref>, while for branching temporal logic the structures are infinite trees [ES84, SE84, Eme85, EJ88, VW86b]. This enables the reduction of temporal logic decision problems, both truth and validity checking, to known automata-theoretic problems. <p> 12, L ! (A ' ) = L ! (A :' ) and the automaton A :' has 2 O (j'j) states. (A straightforward approach, starting with the automaton A ' and then complementing it, would result in a doubly exponential blow-up, since complementation of nondeterministic Buchi automata is exponential <ref> [SVW87, Mic88, Saf88, KV97] </ref>). To get the intersection of the two automata, we use Proposition 1. Consequently, we can build an automaton for L ! (A P ) " L ! (A :' ) having jW j 2 O (j'j) states. We need to check this automaton for emptiness.
Reference: [Var82] <author> M.Y. Vardi. </author> <title> The complexity of relational query languages. </title> <booktitle> In Proc. 14th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 137-146, </pages> <address> San Francisco, </address> <year> 1982. </year>
Reference-contexts: Underlying the notion of logical validity, however, is the notion of logical truth. In many computer science applications, the focus is on the checking of logical truth rather than of logical validity. This is certainly the case in database query evaluation (see <ref> [Var82] </ref>) and in finite-state program verification (see [CES86]). (In fact, we have argued elsewhere that even applications that traditionally focus on logical validity, such as knowledge representation, might be better off focusing on logical truth [HV91].) In general, the algorithmic techniques in computer-aided validity analysis, i.e., validity checking, and in computer-aided
Reference: [Var94] <author> M.Y. Vardi. </author> <title> Nontraditional applications of automata theory. </title> <booktitle> In Theoretical Aspects of Computer Software, Proc. Int. Symposium (TACS'94), volume 789 of Lecture Notes in Computer Science, </booktitle> <pages> pages 575-597. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: Thus, the automata-theoretic approach did not seem to be applicable to branching-time truth checking, which in many cases can be done in linear running time [CES86, QS81, Cle93], Recently it has been shown that if one uses alternating automata rather than nondeterministic automata, then these problems can be solved <ref> [Var94, BVW94] </ref>. Alternating automata generalize the standard notion of nondeterministic automata by allowing several successor states to go down along the same word or the same branch of the tree. <p> The key obser-vation is that while the translation from temporal logic formulas to nondeterministic automata is exponential [VW86b, VW94], the translation to alternating automata is linear <ref> [MSS88, EJ91, Var94, BVW94] </ref>. Thus, the advantage of alternating automata is that they enable one to decouple the logic from the algorithmics. <p> It turns out that the computations in which a given formula is true are exactly those accepted by some finite automaton on infinite words. The following theorem establishes a very simple translation between LTL and alternating Buchi automata on infinite words. Theorem 11. <ref> [MSS88, Var94] </ref> Given an LTL formula ', one can build an alternating B uchi automaton A ' = (; S; s 0 ; ; F ), where = 2 P rop and jSj is in O (j'j), such that L ! (A ' ) is exactly the set of computations in
Reference: [Var96] <author> M.Y. Vardi. </author> <title> Alternating automata and program verification. </title> <booktitle> In Computer Science Today -Recent Trends and Developments, Lecture Notes in Computer Science 1000, </booktitle> <pages> pages 471-485. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Then there is a nondeterministic B uchi word automaton A n with 2 O (n) states such that L ! (A n ) = L ! (A). By combining Propositions 2 and 3 (with its exponential blowup), we can obtain a nonemptiness test for alternating Buchi automata. Proposition 4. <ref> [Var96] </ref> The nonemptiness problem for alternating B uchi word automata is decidable in exponential time or in quadratic space. 2.4 Nondeterministic Automata on Infinite Trees We now consider automata on labeled leafless D-trees. <p> Then there is a nondeterministic B uchi automaton A n with 2 O (n) states such that T ! (A n ) = T ! (A). By combining Propositions 5 and 6 (with its exponential blowup), we can obtain a nonemptiness test for alternating Buchi tree automata. Proposition 7. <ref> [Var96] </ref> The nonemptiness problem for alternating B uchi tree automata is decidable in exponential time. The nonemptiness problem for nondeterministic tree automata is reducible to the 1-letter nonemptiness problem for them, i.e., the nonemptiness problem for trees labeled by a 1-letter alphabet, say fag.
Reference: [VW86a] <author> M.Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proceedings of the First Symposium on Logic in Computer Science, </booktitle> <pages> pages 322-331, </pages> <address> Cambridge, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: Consequently, we can build an automaton for L ! (A P ) " L ! (A :' ) having jW j 2 O (j'j) states. We need to check this automaton for emptiness. Using Proposition 2, we get the following results. Theorem 15. <ref> [LP85, SC85, VW86a] </ref> Checking whether an LTL formula ' is true in a finite-state program P can be done in time O (jP j 2 O (j'j) ) or in space O ((j'j + log jP j) 2 ). <p> We note that the upper space bound of Theorem 14 is essentially optimal, since the truth-checking problem for LTL is PSPACE-hard [SC85] for fixed programs and NLOGSPACE-hard for fixed formulas <ref> [VW86a] </ref>. We also note that a time upper bound that is polynomial in the size of the program and exponential in the size of the specification is considered here to be reasonable, since the specification is usually rather short [LP85].
Reference: [VW86b] <author> M.Y. Vardi and P. Wolper. </author> <title> Automata-theoretic techniques for modal logics of programs. </title> <journal> Journal of Computer and System Science, </journal> <volume> 32(2) </volume> <pages> 182-21, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: For linear temporal logic the structures are infinite words [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94], while for branching temporal logic the structures are infinite trees <ref> [ES84, SE84, Eme85, EJ88, VW86b] </ref>. This enables the reduction of temporal logic decision problems, both truth and validity checking, to known automata-theoretic problems. Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. [VW86b, VW94]). These translations have two disadvantages. <p> This enables the reduction of temporal logic decision problems, both truth and validity checking, to known automata-theoretic problems. Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. <ref> [VW86b, VW94] </ref>). These translations have two disadvantages. First, the translation itself is rather nontrivial; indeed, in [VW86b, VW94] the translations go through a series of ad-hoc intermediate representations in an attempt to simplify the translation. <p> Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. <ref> [VW86b, VW94] </ref>). These translations have two disadvantages. First, the translation itself is rather nontrivial; indeed, in [VW86b, VW94] the translations go through a series of ad-hoc intermediate representations in an attempt to simplify the translation. Second, for both linear and branching temporal logics there is an exponential blow-up involved in going from formulas to automata. <p> We demonstrate this claim by showing how alternating automata can be used to derive truth- and validity checking algorithms for both linear and branching temporal logics. The key obser-vation is that while the translation from temporal logic formulas to nondeterministic automata is exponential <ref> [VW86b, VW94] </ref>, the translation to alternating automata is linear [MSS88, EJ91, Var94, BVW94]. Thus, the advantage of alternating automata is that they enable one to decouple the logic from the algorithmics. <p> The set of trees accepted by A is denoted T ! (A). Proposition 5. <ref> [Rab70, VW86b] </ref> The nonemptiness problem for nondeterministic B uchi tree automata is decidable in quadratic time. 2.5 Alternating Automata on Infinite Trees An alternating B uchi tree automaton A is a tuple (; D; S; s 0 ; ; F ).
Reference: [VW94] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 1-37, </pages> <year> 1994. </year>
Reference-contexts: The basic idea is to associate with each temporal logic formula a finite automaton on infinite structures that accepts exactly all the computations in which the formula is true. For linear temporal logic the structures are infinite words <ref> [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94] </ref>, while for branching temporal logic the structures are infinite trees [ES84, SE84, Eme85, EJ88, VW86b]. This enables the reduction of temporal logic decision problems, both truth and validity checking, to known automata-theoretic problems. <p> This enables the reduction of temporal logic decision problems, both truth and validity checking, to known automata-theoretic problems. Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. <ref> [VW86b, VW94] </ref>). These translations have two disadvantages. First, the translation itself is rather nontrivial; indeed, in [VW86b, VW94] the translations go through a series of ad-hoc intermediate representations in an attempt to simplify the translation. <p> Initially, the translations in the literature from temporal logic formulas to automata used nondeterministic automata (cf. <ref> [VW86b, VW94] </ref>). These translations have two disadvantages. First, the translation itself is rather nontrivial; indeed, in [VW86b, VW94] the translations go through a series of ad-hoc intermediate representations in an attempt to simplify the translation. Second, for both linear and branching temporal logics there is an exponential blow-up involved in going from formulas to automata. <p> We demonstrate this claim by showing how alternating automata can be used to derive truth- and validity checking algorithms for both linear and branching temporal logics. The key obser-vation is that while the translation from temporal logic formulas to nondeterministic automata is exponential <ref> [VW86b, VW94] </ref>, the translation to alternating automata is linear [MSS88, EJ91, Var94, BVW94]. Thus, the advantage of alternating automata is that they enable one to decouple the logic from the algorithmics. <p> The nonemptiness problem for automata is to decide, given an automaton A, whether A is nonempty. It turns out that testing nonemptiness is easy. Proposition 2. 1. [EL85b, EL85a] The nonemptiness problem for nondeterministic B uchi word au tomata is decidable in linear time. 2. <ref> [VW94] </ref> The nonemptiness problem for nondeterministic B uchi automata of size n is decidable in space O (log 2 2.3 Alternating Automata on Infinite Words Nondeterminism gives a computing device the power of existential choice. Its dual gives a computing device the power of universal choice. <p> We can now define : - (p; a) = true if p 2 a, - (p; a) = false if p 62 a, - (~ ^ ; a) = (~; a) ^ ( ; a), - (X ; a) = , By applying Proposition 3, we now get: Corollary 12. <ref> [VW94] </ref> Given an LTL formula ', one can build a B uchi automaton A ' = (; S; s 0 ; ; F ), where = 2 P rop and jSj is in 2 O (j'j) , such that L ! (A ' ) is exactly the set of computations in
Reference: [Wol89] <author> P. Wolper. </author> <title> On the relation of programs and computations to models of temporal logic. In Temporal Logic in Specification, </title> <booktitle> Proc., volume 398 of Lecture Notes in Computer Science, </booktitle> <pages> pages 75-123. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint (see <ref> [CG87, Wol89, CGL93] </ref>), though we prefer to use the term truth checking in this paper.
Reference: [WVS83] <author> P. Wolper, M.Y. Vardi, and A.P. Sistla. </author> <title> Reasoning about infinite computation paths. </title> <booktitle> In Proc. 24th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 185-194, </pages> <address> Tucson, </address> <year> 1983. </year>
Reference-contexts: The basic idea is to associate with each temporal logic formula a finite automaton on infinite structures that accepts exactly all the computations in which the formula is true. For linear temporal logic the structures are infinite words <ref> [WVS83, Sis83, LPZ85, Pei85, SVW87, VW94] </ref>, while for branching temporal logic the structures are infinite trees [ES84, SE84, Eme85, EJ88, VW86b]. This enables the reduction of temporal logic decision problems, both truth and validity checking, to known automata-theoretic problems.
References-found: 51

