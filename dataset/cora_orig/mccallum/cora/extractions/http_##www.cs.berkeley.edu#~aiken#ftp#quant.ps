URL: http://www.cs.berkeley.edu/~aiken/ftp/quant.ps
Refering-URL: http://www.cs.berkeley.edu/~aiken/pubs.html
Root-URL: 
Title: Optimal Representations of Polymorphic Types with Subtyping  
Author: Alexander Aiken Edward L. Wimmers Jens Palsberg 
Abstract: Report No. UCB/CSD-96-909 July 1996 Computer Science Division (EECS) University of California Berkeley, California 94720 
Abstract-found: 1
Intro-found: 1
Reference: [AM91] <author> A. Aiken and B. Murphy. </author> <title> Implementing regular tree expressions. </title> <booktitle> In Proceedings of the 1991 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 427-447, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: In this section we briefly illustrate some heuristic improvements that have been useful in practice <ref> [AM91, FA96] </ref>. As illustrated in Section 6.2, redundant intersections and unions are a significant source of incompleteness. This suggests the following procedure: Procedure 6.7 (Extended Variable Elimination Procedure (EVEP)) Let be an extended quantified type. 1.
Reference: [AW93] <author> A. Aiken and E. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: This feature has the advantage that the same program can be used at many different types. A number of type systems have been proposed that combine subtyping and polymorphism, among other features. The intended purposes of these systems varies. A few examples are: studies of type systems themselves <ref> [CW85, Cur90, AW93] </ref>, proposals for type systems for object-oriented languages [EST95], and program analysis systems used in program optimization [AWL94, HM94]. In short, the combination of subtyping and polymorphism is useful, with a wide range of applications. <p> The previous example is the simplest one possible; the problem of understanding types only increases with the size of the type and expressiveness of the type language. The following example is taken from the system of <ref> [AW93] </ref>, a subtype inference system with polymorphism. In typing a term, the inference algorithm in this system generates a system of subtyping constraints that must be satisfied. The solution of the constraints gives the desired type. <p> The algorithm for simplifying quantified types with subsidiary constraints has been in use for several years, but with the exception of code documentation little has been written previously on the subject. The algorithm has been implemented and used in Illyria 1 , the systems reported in <ref> [AW93] </ref>, and a large scale program analysis system for the functional language FL [AWL94]. This last application was by far the largest and best engineered. The quality of this system depended critically on eliminating variables wherever possible. <p> Example 4.21 Consider the minimal semantic domain (Example 2.2). It is clear that 8ff:(ff ! ff) (&gt; ! &gt;) in the minimal semantic domain. Therefore, 8ff:(ff ! ff) is reduced but not irredundant. Example 4.22 In the semantic domain used in <ref> [AW93] </ref>, x ! &gt; = y ! &gt; regardless of the values of x and y, because if the answer can be anything (i.e., &gt;), it does not matter what the domain is. In this case, 8ff:((ff ! ff) ! &gt;) &gt; ! &gt;. <p> By Lemma 7.5, E C is equivalent to a contractive system of equations. By Part 1 of Definition 7.6, contractive equations always have solutions in an adequate domain. 2 A construction of an adequate domain is given in <ref> [AW93] </ref>. 7.2 Soundness The equivalence between constraints and equations in an adequate domain suggests that variable elimination can be performed by first translating from constraints to equations, applying the results of Section 6.4 to eliminate variables, and then translating back (if desired) to constraints.
Reference: [AWL94] <author> A. Aiken, E. Wimmers, </author> <title> and T.K. Lakshman. Soft typing with conditional types. </title> <booktitle> In Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <address> Port-land, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: The intended purposes of these systems varies. A few examples are: studies of type systems themselves [CW85, Cur90, AW93], proposals for type systems for object-oriented languages [EST95], and program analysis systems used in program optimization <ref> [AWL94, HM94] </ref>. In short, the combination of subtyping and polymorphism is useful, with a wide range of applications. When taken together, subtyping and polymorphism induce equivalences on types that can be exploited to simplify the representation of types. <p> Email: wimmers@almaden.ibm.com z Author's address: Laboratory for Computer Science, MIT, NE43-340 545 Technology Square, Cambridge MA, 02139. Email: palsberg@theory.lcs.mit.edu 1 of, these "hidden" properties are exactly the information needed to justify compiler optimizations based on type information <ref> [AWL94] </ref>. The basic idea behind variable elimination is best illustrated with an example. A few definitions are needed first. Consider a simple type language defined by the following grammar: t ::= ff j &gt; j ? j t 1 ! t 2 In this grammar, ff is a type variable. <p> Eliminating variables simplifies the representation, making this very expensive aspect of type inference less costly. Finally, simplifying types can improve not only the speed but the quality of program analyses. For example, the soft typing system of <ref> [AWL94] </ref> reduces the problem of identifying where runtime type checks are not required in a program to testing whether certain type variables can be replaced by ? in a quantified type. This is exactly the task performed by elimination of variables in quantified types. <p> The algorithm has been implemented and used in Illyria 1 , the systems reported in [AW93], and a large scale program analysis system for the functional language FL <ref> [AWL94] </ref>. This last application was by far the largest and best engineered. The quality of this system depended critically on eliminating variables wherever possible. Other recent systems based on constrained types have also pointed out the importance of variable elimination.
Reference: [Cur90] <author> Pavel Curtis. </author> <title> Constrained quantification in polymorphic type analysis. </title> <type> Technical Report CSL-90-1, </type> <note> Xerox Parc, </note> <month> February </month> <year> 1990. </year>
Reference-contexts: This feature has the advantage that the same program can be used at many different types. A number of type systems have been proposed that combine subtyping and polymorphism, among other features. The intended purposes of these systems varies. A few examples are: studies of type systems themselves <ref> [CW85, Cur90, AW93] </ref>, proposals for type systems for object-oriented languages [EST95], and program analysis systems used in program optimization [AWL94, HM94]. In short, the combination of subtyping and polymorphism is useful, with a wide range of applications.
Reference: [CW85] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction and polymorphism. </title> <journal> Computing Surverys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: This feature has the advantage that the same program can be used at many different types. A number of type systems have been proposed that combine subtyping and polymorphism, among other features. The intended purposes of these systems varies. A few examples are: studies of type systems themselves <ref> [CW85, Cur90, AW93] </ref>, proposals for type systems for object-oriented languages [EST95], and program analysis systems used in program optimization [AWL94, HM94]. In short, the combination of subtyping and polymorphism is useful, with a wide range of applications.
Reference: [EST95] <author> J. Eifrig, S. Smith, and V. Trifonov. </author> <title> Sound polymorphic type inference for objects. </title> <booktitle> In OOPSLA '96, </booktitle> <year> 1995. </year>
Reference-contexts: A number of type systems have been proposed that combine subtyping and polymorphism, among other features. The intended purposes of these systems varies. A few examples are: studies of type systems themselves [CW85, Cur90, AW93], proposals for type systems for object-oriented languages <ref> [EST95] </ref>, and program analysis systems used in program optimization [AWL94, HM94]. In short, the combination of subtyping and polymorphism is useful, with a wide range of applications. When taken together, subtyping and polymorphism induce equivalences on types that can be exploited to simplify the representation of types. <p> This last application was by far the largest and best engineered. The quality of this system depended critically on eliminating variables wherever possible. Other recent systems based on constrained types have also pointed out the importance of variable elimination. In <ref> [EST95] </ref>, Eifrig, Smith, and Trifonov describe a variable elimination method similar, but not identical too, the one in Section 7. Pottier gives a method that can eliminate redundant variables from constraint sets [Pot96]. Both of these methods are heuristic; i.e., they are sound but not complete. <p> Definition 7.3 A system C of constraints is closed iff t 1 ff 2 C ^ ff t 2 2 C ) t 1 t 2 2 C A closed system C is consistent iff &gt; ? 62 C. Definition 7.3 is taken from <ref> [EST95] </ref>. Intuitively, closing a system of constraints C is equivalent to solving C, and if the closed system has no inconsistent constraints, then it has solutions. Instead of asserting that closed consistent systems have solutions directly, we characterize those solutions in terms of equations.
Reference: [FA96] <author> M. Fahndrich and A. Aiken. </author> <title> Making set-constraint program analyses scale. </title> <booktitle> In CP96 Workshop on Set Constraints, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: In this section we briefly illustrate some heuristic improvements that have been useful in practice <ref> [AM91, FA96] </ref>. As illustrated in Section 6.2, redundant intersections and unions are a significant source of incompleteness. This suggests the following procedure: Procedure 6.7 (Extended Variable Elimination Procedure (EVEP)) Let be an extended quantified type. 1. <p> The problem of whether there is a sound and complete variable elimination procedure for languages with intersection and union types remains open. We have also given a sound variable elimination procedure for polymorphic constrained types. Variable elimination is critically important in implementations of type systems using constrained types <ref> [FA96] </ref>, and in fact the desire to better understand variable elimination in this setting was the original motivation for this work. However, the problem of whether there is a sound and complete procedure for eliminating variables in polymorphic constrained types also remains open. 30
Reference: [HM94] <author> Fritz Henglein and Christian Mossin. </author> <title> Polymorphic binding-time analysis. </title> <editor> In Donald Sannella, editor, </editor> <booktitle> Proceedings of European Symposium on Programming, volume 788 of Lecture Notes in Computer Science, </booktitle> <pages> pages 287-301. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: The intended purposes of these systems varies. A few examples are: studies of type systems themselves [CW85, Cur90, AW93], proposals for type systems for object-oriented languages [EST95], and program analysis systems used in program optimization <ref> [AWL94, HM94] </ref>. In short, the combination of subtyping and polymorphism is useful, with a wide range of applications. When taken together, subtyping and polymorphism induce equivalences on types that can be exploited to simplify the representation of types.
Reference: [Koe94] <author> A. Koenig. </author> <title> An anecdote about ML type inference. </title> <booktitle> In Proceedings of the USENIX 1994 Symposium on Very High Level Languages, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: We briefly illustrate these three claims. The reasoning required to discover that 8ff:8fi:ff ! fi represents an everywhere-divergent function is non-trivial. There is a published account illustrating how types inferred from ML programs (which have polymorphism but no subtyping) can be used to detect non-terminating functions exactly as above <ref> [Koe94] </ref>. The previous example is the simplest one possible; the problem of understanding types only increases with the size of the type and expressiveness of the type language. The following example is taken from the system of [AW93], a subtype inference system with polymorphism.
Reference: [MPS84] <author> D. MacQueen, G. Plotkin, and R. Sethi. </author> <title> An ideal model for recursive polymophic types. </title> <booktitle> In Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 165-174, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: Thus, one might suspect that this type is equivalent to &gt; !?. The only function with this type is the one that diverges for all possible inputs. It turns out that, in fact, 8ff:8fi:ff ! fi &gt; ! ? in the standard ideal model of types <ref> [MPS84] </ref>. As argued above, the type with fewer variables is better for human readability, the speed of type inference, and for the automatic exploitation of type information by a compiler. We briefly illustrate these three claims. <p> A system of equations ffi 1 = t 1 ^ : : : ^ ffi n = t n is contractive iff each ffi i is contractive in every equation of the system. Contractiveness is a standard technical condition in systems with recursive types <ref> [MPS84] </ref>. Contrac-tiveness is necessary for equations to have unique solutions (e.g., an equation such as ffi = ffi may have many solutions). The results of this section only apply to systems of contractive equations.
Reference: [Pot96] <author> F. Pottier. </author> <title> Simplifying subtyping constraints. </title> <booktitle> In Proceedings of the 1996 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 122-133, </pages> <month> May </month> <year> 1996. </year> <month> 31 </month>
Reference-contexts: Other recent systems based on constrained types have also pointed out the importance of variable elimination. In [EST95], Eifrig, Smith, and Trifonov describe a variable elimination method similar, but not identical too, the one in Section 7. Pottier gives a method that can eliminate redundant variables from constraint sets <ref> [Pot96] </ref>. Both of these methods are heuristic; i.e., they are sound but not complete. Our focus in this paper is quite different. The problem of eliminating variables from polymorphic types appears quite difficult in the more expressive type languages (consider the incomplete algorithms just discussed).
References-found: 11

