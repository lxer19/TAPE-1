URL: http://www.cs.rice.edu/CS/PLT/Publications/pldi91-cf.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Soft Typing Type systems are designed to prevent the improper use of program operations. They
Author: Robert Cartwright and Mike Fagan 
Note: Summary  
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: Static type systems have two important advantages over dynamic type systems. First, they provide important feedback to the programmer by detecting a large class of program errors before execution. Second, they extract information that a compiler can exploit to produce more efficient code. The price paid for these advantages, however, is a loss of expressiveness, modularity, and semantic simplicity. This paper presents a soft type systems that retains the expressiveness of dynamic typing, but offers the early error detection and improved optimization capabilities of static typing. The key idea underlying soft typing is that a type checker need not reject programs containing "ill-typed" phrases. Instead, the type checker can insert explicit run-time checks, transforming "ill-typed" programs into type-correct ones. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martin Abadi, Luca Cardelli, Benjamin Pierce, and Gordon Plotkin. </author> <title> Dynamic typing in a statically typed language. </title> <booktitle> In Proceedings of the Sixteenth POPL Symposium, </booktitle> <year> 1989. </year>
Reference-contexts: + false ! z + suc + true + false) ! z + suc + true + false and N 0 2 ( x:x) now type checks. 8 Related Work The earliest work on combining static and dynamic was an investigation of the type "dynamic" conducted by Abadi et al <ref> [1] </ref>. They added dynamic data values to a conventionally statically typed data domain and provided facilities for converting data values to dynamic values by performing explicit "tagging" operations. This system permits programs written in statically typed languages to manipulate dynamic forms of data.
Reference: [2] <author> Alexander Aiken and Brian Murphy. </author> <title> Static type inference in a dynamically typed language. </title> <booktitle> In Proceedings of the 18th Annual Symposium on Principles of Programming Languages, </booktitle> <year> 1991. </year> <note> To appear. </note>
Reference-contexts: Researchers in the area of optimizing compilers have developed static type systems for dynamically typed languages to extract information for the purposes of code optimization. Two of the most prominent examples are the systems developed by Aiken and Murphy <ref> [2] </ref> and Cohagan and Gateley [6]. These systems, however, were not designed to be used or understood by programmers. Consequently, they lack the uniformity and generality required for soft typing.
Reference: [3] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> August </month> <year> 1990. </year> <note> (To Appear). </note>
Reference-contexts: Our soft type system is specifically designed to facilitate reasoning about subtypes of unions, an essential characteristic of soft type systems that we identified in Section 3. To reason about subtypes, we use the following inference system patterned after a system developed by Amadio and Cardelli <ref> [3] </ref> Definition 2 (Inference Rules for Subtyping ) Refl: ` T T Uni: ` T 1 T 1 + T 2 Trans: ` T 1 T 2 ` T 2 T 3 Con: ` c (S 1 ; . . . ; S n ) c (T 1 ; . .
Reference: [4] <author> Andrew W. Appel and David MacQueen. </author> <title> Standard ML of new jersey reference manual. </title> <note> (in preparation), </note> <year> 1990. </year>
Reference-contexts: The automatic type assignment and coercion insertion methods that we present for Exp can be extended to assignment and advanced control structures using the same techniques that Tofte [21], MacQueen <ref> [4] </ref>, and Duba et al [9] have developed for ML.
Reference: [5] <author> William Clinger and Jonathan Rees. </author> <title> Revised 3:99 Report on the Algorithmic Language Scheme, </title> <month> August </month> <year> 1990. </year>
Reference-contexts: Undefined applications are detected during program execution by tests embedded in the code implementing each primitive program operation. If an operation's arguments are not acceptable, the operation generates a program exception, transferring control to an exception handler in the program or the operating system. Scheme <ref> [5] </ref> is a prominent example of a dynamically typed programming language. Static typing has two important advantages over dynamic typing: Error Detection: The system flags all "suspect" program phrases before execution.
Reference: [6] <author> William Cohagan and John Gateley. </author> <title> Interprocedural dataflow type inference. </title> <note> Submitted to SIGPLAN '91, </note> <year> 1990. </year>
Reference-contexts: Researchers in the area of optimizing compilers have developed static type systems for dynamically typed languages to extract information for the purposes of code optimization. Two of the most prominent examples are the systems developed by Aiken and Murphy [2] and Cohagan and Gateley <ref> [6] </ref>. These systems, however, were not designed to be used or understood by programmers. Consequently, they lack the uniformity and generality required for soft typing.
Reference: [7] <author> Luis Damas and Robin Milner. </author> <title> Principal type-schemes for functional programs. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1982. </year>
Reference-contexts: The final step in defining our type language is adding the notion of universal quantification. As in ML <ref> [8, 7] </ref>, we restrict universal quantification to the "outside" of type terms. In this restricted setting, type terms containing quantifiers are called type schemes. A type scheme is defined by the grammar: ::= t j8t: where t denotes the set of tidy terms. <p> The inference system uses both the subtype relation defined by the subtype inference system given in Section 4 and the generic instance relation defined by Damas and Milner <ref> [7] </ref> for the ML type system. A generic instance of type scheme t is a type scheme t 0 obtained by substituting tidy type terms for quantified variables of t . For example, given the type 8ff:cons (ff) ! ff, then cons (int) ! int is a generic instance.
Reference: [8] <author> Luis Manuel Martins Damas. </author> <title> Type Assignment in Programming Languages. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1985. </year> <month> 13 </month>
Reference-contexts: The final step in defining our type language is adding the notion of universal quantification. As in ML <ref> [8, 7] </ref>, we restrict universal quantification to the "outside" of type terms. In this restricted setting, type terms containing quantifiers are called type schemes. A type scheme is defined by the grammar: ::= t j8t: where t denotes the set of tidy terms.
Reference: [9] <author> Bruce F. Duba, Robert Harper, and David MacQueen. </author> <title> Typing first-class continuations in ML. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1991. </year> <note> (To Appear). </note>
Reference-contexts: The automatic type assignment and coercion insertion methods that we present for Exp can be extended to assignment and advanced control structures using the same techniques that Tofte [21], MacQueen [4], and Duba et al <ref> [9] </ref> have developed for ML.
Reference: [10] <author> D. P. Friedman and M. Felleisen. </author> <title> The Little Lisper. </title> <publisher> Science Research Associates, </publisher> <address> third edition, </address> <year> 1989. </year>
Reference-contexts: This feature is usually called recursive typing. Given the operator fix, we can assign the type fix t:t ! fi to S. 4 The true power of recursive typing, however, lies in its use with union types. The follow-ing simple example (taken from an introductory Scheme course <ref> [10] </ref>) is a good illustration of this phenomenon.
Reference: [11] <author> You-Chin Fuh. </author> <title> Design and Implementation of a Functional Language with Subtypes. </title> <type> PhD thesis, </type> <institution> State University of New York at Stony Brook, </institution> <year> 1989. </year>
Reference-contexts: Consequently, they lack the uniformity and generality required for soft typing. Finally, many researchers in the area of static type systems have developed extensions to the ML type system that can type a larger fraction of "good" programs. In the arena, 12 the work of Mitchell [18], Fuh-Mishra <ref> [11, 12, 13] </ref>, and, of course Remy [19] is particularly noteworthy and has exerted a strong influence on our work. 9 Conclusions The principal contribution of this research is the introduction of a new paradigm for program typing called soft typing that combines the best features of static and dynamic typing.
Reference: [12] <author> You-Chin Fuh and Prateek Mishra. </author> <title> Type inference with subtypes. </title> <booktitle> In Conference Record of the European Symposium on Programming, </booktitle> <year> 1988. </year>
Reference-contexts: Consequently, they lack the uniformity and generality required for soft typing. Finally, many researchers in the area of static type systems have developed extensions to the ML type system that can type a larger fraction of "good" programs. In the arena, 12 the work of Mitchell [18], Fuh-Mishra <ref> [11, 12, 13] </ref>, and, of course Remy [19] is particularly noteworthy and has exerted a strong influence on our work. 9 Conclusions The principal contribution of this research is the introduction of a new paradigm for program typing called soft typing that combines the best features of static and dynamic typing.
Reference: [13] <author> You-Chin Fuh and Prateek Mishra. </author> <title> Polymorphic subtype inference: Closing the theory-practice gap. </title> <booktitle> In TAPSOFT, </booktitle> <year> 1989. </year>
Reference-contexts: Consequently, they lack the uniformity and generality required for soft typing. Finally, many researchers in the area of static type systems have developed extensions to the ML type system that can type a larger fraction of "good" programs. In the arena, 12 the work of Mitchell [18], Fuh-Mishra <ref> [11, 12, 13] </ref>, and, of course Remy [19] is particularly noteworthy and has exerted a strong influence on our work. 9 Conclusions The principal contribution of this research is the introduction of a new paradigm for program typing called soft typing that combines the best features of static and dynamic typing.
Reference: [14] <author> D. MacQueen, G. Plotkin, and R. Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1983. </year>
Reference-contexts: Hence, j may be greater than i. 5 on type functions. A formal definition of the semantics of type terms based on the ideal model <ref> [15, 14] </ref> of MacQueen, Plotkin, and Sethi is given in the full paper. For technical reasons, we must impose some modest restrictions on the usage of the fix and + operators in type terms.
Reference: [15] <author> D. B. MacQueen and Ravi Sethi. </author> <title> A semantic model of types for applicative languages. </title> <booktitle> In Conference Record of the Tenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1982. </year>
Reference-contexts: Hence, j may be greater than i. 5 on type functions. A formal definition of the semantics of type terms based on the ideal model <ref> [15, 14] </ref> of MacQueen, Plotkin, and Sethi is given in the full paper. For technical reasons, we must impose some modest restrictions on the usage of the fix and + operators in type terms.
Reference: [16] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <year> 1978. </year>
Reference-contexts: For the sake of simplicity, we will confine our attention in this paper to the simple functional language Exp introduced by Milner <ref> [16] </ref> as the functional core of ML. The automatic type assignment and coercion insertion methods that we present for Exp can be extended to assignment and advanced control structures using the same techniques that Tofte [21], MacQueen [4], and Duba et al [9] have developed for ML.
Reference: [17] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: This discipline can either be static or dynamic. A statically typed language prevents undefined applications by imposing syntactic restrictions on programs that guarantee the definedness of every application. The implementation refuses to execute programs that do not meet these restrictions. ML <ref> [17] </ref> is a prominent example of a contemporary statically typed language. In contrast, a dynamically typed language accepts all programs. Undefined applications are detected during program execution by tests embedded in the code implementing each primitive program operation.
Reference: [18] <author> John C. Mitchell. </author> <title> Coercion and type inference. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1983. </year>
Reference-contexts: Consequently, they lack the uniformity and generality required for soft typing. Finally, many researchers in the area of static type systems have developed extensions to the ML type system that can type a larger fraction of "good" programs. In the arena, 12 the work of Mitchell <ref> [18] </ref>, Fuh-Mishra [11, 12, 13], and, of course Remy [19] is particularly noteworthy and has exerted a strong influence on our work. 9 Conclusions The principal contribution of this research is the introduction of a new paradigm for program typing called soft typing that combines the best features of static and
Reference: [19] <author> Dider Remy. </author> <title> Typechecking records and variants in a natural extension of ml. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1989. </year>
Reference-contexts: Our algorithm differs from the ML algorithm in two respects. * First, we encode all program types as instances of a single polymorphic type that has type parameters for every type constructor and for every parameter to a type constructor. This encoding was developed by Remy <ref> [19] </ref> to reduce inheritance polymorphism to parametric polymorphism. * Second, we use circular unification (as in CAML [22]) instead of regular unification to solve systems of type equations. Circular unification is required to infer recursive types. <p> Finally, many researchers in the area of static type systems have developed extensions to the ML type system that can type a larger fraction of "good" programs. In the arena, 12 the work of Mitchell [18], Fuh-Mishra [11, 12, 13], and, of course Remy <ref> [19] </ref> is particularly noteworthy and has exerted a strong influence on our work. 9 Conclusions The principal contribution of this research is the introduction of a new paradigm for program typing called soft typing that combines the best features of static and dynamic typing.
Reference: [20] <author> Sattish Thatte. </author> <title> Quasi-static typing. </title> <booktitle> In Proceedings of the Seventeenth POPL Symposium, </booktitle> <year> 1990. </year>
Reference-contexts: It does not meet the criteria for soft typing because the programmer must annotate his program with explicit tagging operations to create "dynamic" values. In addition, programs are still rejected; narrowers are not inserted by the type checker. More recently, Thatte <ref> [20] </ref> has developed the notion of "quasi-static typing" that augments a static type system with a general type . Thatte's system resembles soft typing in that it insert narrowers when necessary, ensuring that all programs can be executed. However, it does not meet the other criteria required for soft typing.
Reference: [21] <author> Mads Tofte. </author> <title> Operational Semantics and Polymorphic Type Inference. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year>
Reference-contexts: The automatic type assignment and coercion insertion methods that we present for Exp can be extended to assignment and advanced control structures using the same techniques that Tofte <ref> [21] </ref>, MacQueen [4], and Duba et al [9] have developed for ML.
Reference: [22] <author> Pierre Weis. </author> <title> The CAML Reference Manual. </title> <institution> INRIA, </institution> <year> 1987. </year> <month> 14 </month>
Reference-contexts: This encoding was developed by Remy [19] to reduce inheritance polymorphism to parametric polymorphism. * Second, we use circular unification (as in CAML <ref> [22] </ref>) instead of regular unification to solve systems of type equations. Circular unification is required to infer recursive types. The Remy encoding is based on the observation that set of data constructors C is finite.
References-found: 22

