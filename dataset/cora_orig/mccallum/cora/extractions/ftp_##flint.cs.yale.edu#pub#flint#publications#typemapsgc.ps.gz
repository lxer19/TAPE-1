URL: ftp://flint.cs.yale.edu/pub/flint/publications/typemapsgc.ps.gz
Refering-URL: http://daffy.cs.yale.edu/users/shao-zhong/papers.html
Root-URL: http://www.cs.yale.edu
Email: boehm@parc.xerox.com zsh@cs.princeton.edu  
Title: Inferring Type Maps during Garbage Collection  
Author: Hans-J. Boehm Zhong Shao 
Date: September 10, 1993  
Abstract: Conservative garbage collectors are designed to operate in environments that do not provide sufficient information on the location of pointers. Instead of relying on compiler provided information on the location of pointers, they assume that any bit pattern that could be a valid pointer in fact is a valid pointer. This, however, can lead to inefficiencies and pointer misidentifications. In this position paper, we propose a simple runtime method that dynamically infers the pointer layout information during the garbage collection time. The inferred information might be used to make the subsequent passes of garbage collection run more efficiently.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Joel F. Bartlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Technical Report DEC WRL 88/2, </type> <institution> Digital Equipment Corporation Western Research Laboratory, </institution> <address> Palo Alto, CA, </address> <month> February </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Conservative garbage collectors <ref> [3, 1] </ref> are designed mainly for the kind of runtime environments (such as C, C++ programs) that do not contain enough information to distinguish pointers from other data.
Reference: [2] <author> Hans-J. Boehm, Alan J. Demers, and Scott Shenker. </author> <title> Mostly parallel garbage collection. </title> <booktitle> In Proc. ACM SIGPLAN '91 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 157-164, </pages> <address> New York, June 1991. </address> <publisher> ACM Press. </publisher>
Reference-contexts: It may also greatly decrease the time spent in a copying garbage collector, especially for systems that exhibit very high allocation rates, and low survival rates [6]. Unfortunately, it has so far been less successful in this last respect when used with conservative collectors and less allocation intensive systems <ref> [2] </ref>. Much of the scanning cost is due to scanning nonpointer fields in heap objects. BDWGC provides some facilities (e.g. pointerfree allocation) to avoid this. But these facilities are either restrictive or inconvenient. In particular [7] does not take advantage of them.
Reference: [3] <author> Hans-J. Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Conservative garbage collectors <ref> [3, 1] </ref> are designed mainly for the kind of runtime environments (such as C, C++ programs) that do not contain enough information to distinguish pointers from other data. <p> While the advantage of using garbage collectors over explicit storage management is obvious, using garbage collectors might incur more runtime overhead. Zorn [8, 7] recently compared the Boehm-Demers-Weiser conservative garbage collector (BDWGC) <ref> [3] </ref> with several other explicit storage management algorithms. His latest data [8] show that on several large programs written for explicit storage management, BDWGC runs about 5-40% slower than the best explicit storage management algorithm. Indeed, this should not be surprising. <p> The CALLOC_TYPED function works the same way as MALLOC_TYPED except that the type map inferred for each allocation site is per array element rather than the whole array. 3 Implementation We have implemented the above proposal in the version 3.2 of the Boehm-Demers-Weiser conservative garbage collector <ref> [3] </ref>. BDWGC supplies a standard set of storage allocation routines (just as the standard C malloc library); explicit disposal of "dead objects" (i.e., free) is no longer necessary because the garbage collection will be called to reclaim them if the allocation procedure runs out of memory.
Reference: [4] <author> David L. Detlefs. </author> <title> Concurrent, Atomic Garbage Collection. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon Univ., Pittsburgh, Penn-sylvania, </institution> <month> October </month> <year> 1990. </year>
Reference: [5] <author> Amer Diwan. </author> <title> Compiler support for garbage collection in a statically typed language. </title> <booktitle> In Proc. ACM SIGPLAN '92 Conf. on Prog. Lang. Design and Implementation, </booktitle> <address> New York, June 1992. </address> <publisher> ACM Press. </publisher> <pages> 6 </pages>
Reference-contexts: This approach is used most often by the accurate (i.e., non-conservative) tracing collectors <ref> [5] </ref>. The problem of this method is that it requires substantial compiler modifications to implement. Furthermore compilers and runtime systems must agree on a nontrivial interface, risking incompatibility. * Dynamic approach: to let the garbage collector itself infer the (partial) type map information during the garbage collection time.
Reference: [6] <author> David Michael Ungar. </author> <title> The Design and Evaluation of A High Performance Smalltalk System. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, Berkeley,California, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: Generational collection is a useful tool for reducing pause times and improving collector memory reference locality. It may also greatly decrease the time spent in a copying garbage collector, especially for systems that exhibit very high allocation rates, and low survival rates <ref> [6] </ref>. Unfortunately, it has so far been less successful in this last respect when used with conservative collectors and less allocation intensive systems [2]. Much of the scanning cost is due to scanning nonpointer fields in heap objects. BDWGC provides some facilities (e.g. pointerfree allocation) to avoid this.
Reference: [7] <author> Benjamin G. Zorn. </author> <title> The measured cost of conservative garbage collection. </title> <type> Technical Report CU-CS-573-92, </type> <institution> Univ. of Colorado at Boulder, Dept. of Computer Science, Boulder, Colorado, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: While the advantage of using garbage collectors over explicit storage management is obvious, using garbage collectors might incur more runtime overhead. Zorn <ref> [8, 7] </ref> recently compared the Boehm-Demers-Weiser conservative garbage collector (BDWGC) [3] with several other explicit storage management algorithms. His latest data [8] show that on several large programs written for explicit storage management, BDWGC runs about 5-40% slower than the best explicit storage management algorithm. <p> Much of the scanning cost is due to scanning nonpointer fields in heap objects. BDWGC provides some facilities (e.g. pointerfree allocation) to avoid this. But these facilities are either restrictive or inconvenient. In particular <ref> [7] </ref> does not take advantage of them. A more general technique for avoiding such overhead is to provide the collector with layout information (type maps) for objects in the heap.
Reference: [8] <author> Benjamin G. </author> <type> Zorn. </type> <institution> Univ. of Colorado at Boulder, </institution> <type> personal communication, </type> <year> 1993. </year>
Reference-contexts: While the advantage of using garbage collectors over explicit storage management is obvious, using garbage collectors might incur more runtime overhead. Zorn <ref> [8, 7] </ref> recently compared the Boehm-Demers-Weiser conservative garbage collector (BDWGC) [3] with several other explicit storage management algorithms. His latest data [8] show that on several large programs written for explicit storage management, BDWGC runs about 5-40% slower than the best explicit storage management algorithm. <p> While the advantage of using garbage collectors over explicit storage management is obvious, using garbage collectors might incur more runtime overhead. Zorn [8, 7] recently compared the Boehm-Demers-Weiser conservative garbage collector (BDWGC) [3] with several other explicit storage management algorithms. His latest data <ref> [8] </ref> show that on several large programs written for explicit storage management, BDWGC runs about 5-40% slower than the best explicit storage management algorithm. Indeed, this should not be surprising. In its standard configuration, this collector attempts to allocate approximately one quarter of the heap between collections. <p> Given an average object size of 100 bytes (which is not unrealistic)[9], every object allocation involves scanning of 300 bytes for pointers. Fast malloc/free implementations may allocate and free an object in 70 instructions <ref> [8] </ref>. We clearly cannot scan 300 bytes in 70 instructions. Several techniques are available for reducing this cost. Generational collection is a useful tool for reducing pause times and improving collector memory reference locality.
Reference: [9] <author> Benjamin G. Zorn and Dirk Grunwald. </author> <title> Empirical measurements of six allocation-intensive c programs. </title> <type> Technical Report CU-CS-604-92, </type> <institution> Univ. of Colorado at Boulder, Dept. of Computer Science, Boulder, Colorado, </institution> <month> July </month> <year> 1992. </year> <month> 7 </month>
References-found: 9

