URL: ftp://ftp.ifi.unizh.ch/pub/techreports/other_docs/Hoare_Logic.ps.gz
Refering-URL: http://www.ifi.unizh.ch/staff/fuchs.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fuchs@ifi.unizh.ch  
Title: STRUCTURED PROGRAMMING (1992) 13 Hoare Logic, Executable Specifications, and Logic Programs  
Author: Norbert E. Fuchs 
Address: Zurich  
Affiliation: Department of Computer Science University of  
Abstract: Starting from Hoare correctness formulae -P- S -Q- which define first-order predicates S by their pre and postconditions P and Q, I formulate logic specifications S P Q for the predicates. Subsequently, I discuss two methods to construct logic programs from logic specifications. First, I simply derive programs as the if-halves of their logic specifications. These programs are concise, readable, but often inefficient and should rather be considered executable specifications. In the second method, I derive more efficient programs by structural induction. These programs are recursive, and though correct not obviously logical consequences of the pre and postconditions of the predicate. 
Abstract-found: 1
Intro-found: 1
Reference: [Bundy et al. 90] <author> A.Bundy, A. Smaill, G. Wiggins, </author> <title> The Synthesis of Logic Programs from Inductive Proofs, </title> <editor> in: J. W. Lloyd (ed.), </editor> <booktitle> Computational Logic, ESPRIT Symposium Proceedings, </booktitle> <address> Brussels November 1990, </address> <publisher> Springer, </publisher> <year> 1990 </year>
Reference-contexts: 1 Introduction Recently there has been much interest in constructive methods to derive logic programs from their specifications (e.g. <ref> [Bundy et al. 90] </ref>, [Flener 91], [Fribourg 90], [Deville 90], [Lau, Prestwich 91]). Bundy and collaborators [Bundy et al. 90] in their Oyster system synthesize programs in first-order logic from nonexecutable specifications in typed constructive logic. <p> 1 Introduction Recently there has been much interest in constructive methods to derive logic programs from their specifications (e.g. <ref> [Bundy et al. 90] </ref>, [Flener 91], [Fribourg 90], [Deville 90], [Lau, Prestwich 91]). Bundy and collaborators [Bundy et al. 90] in their Oyster system synthesize programs in first-order logic from nonexecutable specifications in typed constructive logic. The synthesis uses the proofs-as-programs technique which constructively proves a specification theorem: each proof step is associated with a program construction step, e.g. proof by induction with recursion. <p> In fact, I present two construction methods, one leading to executable specifications, the other one to efficient recursive programs. Both Deville's logic descriptions [Deville 90] and Bundy's tracts <ref> [Bundy et al. 90] </ref> superficially resemble my logic specifications though their roles are completely different: logic specifications are the starting point for program synthesis, while logic descriptions and tracts are the result of program synthesis. Hoare correctness formulae for logic programs were also proposed by other authors.
Reference: [Clark 78] <author> K. L. Clark, </author> <title> Negation As Failure, </title> <editor> in: H. Gallaire, J. Minker (eds.), </editor> <booktitle> Logic and Data Bases, </booktitle> <publisher> Plenum Press, </publisher> <year> 1978, </year> <pages> pp. 293-322 </pages>
Reference: [Clark 79] <author> K. L. Clark, </author> <title> Predicate Logic As a Computational Formalism, </title> <type> Research Report 79/59, </type> <institution> Imperial College, </institution> <address> London, </address> <year> 1979 </year>
Reference: [Colussi, Marchiori 91] <author> L. Colussi, E. Marchiori, </author> <title> Proving Properties of Logic Programs Using Axiomatic Semantics. </title> <booktitle> Proceedings 8th International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1991 </year>
Reference-contexts: Hoare correctness formulae for logic programs were also proposed by other authors. Recently, Colussi and Marchiori <ref> [Colussi, Marchiori 91] </ref> defined an axiomatic semantics for Prolog programs with the specific intention to express Prolog's operational aspects. Colussi's and Marchiori's paper contains references to related earlier work.
Reference: [Cousot 90] <author> P. Cousot, </author> <title> Methods and Logics for Proving Programs, </title> <editor> in: J. van Leeuwen (ed.), </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. </volume> <editor> B: </editor> <title> Formal Models and Semantics, </title> <publisher> Elsevier, </publisher> <year> 1990 </year>
Reference-contexts: Though not actually applicable to realistic programs, this idea has turned out to be extremely fruitful for research on program verification and design, and has led to a large number of publications. Cousot <ref> [Cousot 90] </ref> gives a recent overview of the field and provides a comprehensive bibliography. 3 3 Specifications and Programs in Logic In Hoare correctness formulae, specifications are expressed in logic while programs are expressed in a procedural language.
Reference: [Deville 90] <author> Y. Deville, </author> <title> Logic Programming, Systematic Program Development, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1990 </year>
Reference-contexts: 1 Introduction Recently there has been much interest in constructive methods to derive logic programs from their specifications (e.g. [Bundy et al. 90], [Flener 91], [Fribourg 90], <ref> [Deville 90] </ref>, [Lau, Prestwich 91]). Bundy and collaborators [Bundy et al. 90] in their Oyster system synthesize programs in first-order logic from nonexecutable specifications in typed constructive logic. <p> The synthesized logic program consists of a set of equivalences called tracts. In a second step, the synthesized logic program is compiled into a Prolog program. Deville <ref> [Deville 90] </ref> formulates specifications of logic programs in natural language. In addition to a description of the relation to be specified, a specification contains information on the types and the directionality of the arguments, on possible restrictions, and on side-effects. <p> In fact, I present two construction methods, one leading to executable specifications, the other one to efficient recursive programs. Both Deville's logic descriptions <ref> [Deville 90] </ref> and Bundy's tracts [Bundy et al. 90] superficially resemble my logic specifications though their roles are completely different: logic specifications are the starting point for program synthesis, while logic descriptions and tracts are the result of program synthesis. <p> The declarative semantics of S is its least Herbrand model -H | HB S S|=H- where ground instances Following Clark ([Clark 79], <ref> [Deville 90] </ref>), I relate this declarative semantics to the one expressed by the correctness formula -P- S -Q-with the help of correctness and completeness criteria. <p> To derive efficient programs from logic specifications we have to employ other methods. In the following, I will investigate structural induction which leads to recursive programs. The induction principle <ref> [Deville 90] </ref> allows us to conclude that all members of a set S have a certain property P if S is well-founded, i.e. has a well-founded relation &lt; , if P is true for the minimal element E of the set, and if we can prove that P holds for an
Reference: [Dijkstra 76] <author> E. W. Dijkstra, </author> <title> A Discipline of Programming, </title> <publisher> Prentice-Hall, </publisher> <year> 1976 </year>
Reference-contexts: Termination is guaranteed only for the subset of states fulfilling the weakest precondition <ref> [Dijkstra 76] </ref>. The weakest precondition wp (S,Q) defines the set of all states for which the program S terminates in a state fulfilling the postcondition Q. This means that the logic program S wp (S,Q) Q also terminates.
Reference: [Flener 91] <author> P. Flener, </author> <title> Towards Stepwise, Schema-Guided Synthesis of Logic Programs, </title> <editor> in: K.-K. Lau, T. Clement (eds.), </editor> <booktitle> Proceedings of LOPSTR '91, </booktitle> <publisher> Springer, </publisher> <year> 1992 </year>
Reference-contexts: 1 Introduction Recently there has been much interest in constructive methods to derive logic programs from their specifications (e.g. [Bundy et al. 90], <ref> [Flener 91] </ref>, [Fribourg 90], [Deville 90], [Lau, Prestwich 91]). Bundy and collaborators [Bundy et al. 90] in their Oyster system synthesize programs in first-order logic from nonexecutable specifications in typed constructive logic.
Reference: [Fribourg 90] <author> L. </author> <title> Fribourg, Extracting logic programs from proofs that use extended Prolog execution and induction, </title> <booktitle> in: Proceedings 7th International Conference on Logic programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1990 </year>
Reference-contexts: 1 Introduction Recently there has been much interest in constructive methods to derive logic programs from their specifications (e.g. [Bundy et al. 90], [Flener 91], <ref> [Fribourg 90] </ref>, [Deville 90], [Lau, Prestwich 91]). Bundy and collaborators [Bundy et al. 90] in their Oyster system synthesize programs in first-order logic from nonexecutable specifications in typed constructive logic.
Reference: [Fuchs 91] <author> N. E. Fuchs, </author> <title> Specifications Are (Preferably) Executable, </title> <journal> Software Engineering Journal, </journal> <month> September </month> <year> 1992, </year> <note> also: Technical Report 91.10, </note> <institution> Institut fr Informatik, Universitt Zrich, </institution> <year> 1991 </year>
Reference-contexts: predicate h a mm i ng is defined by the correctness formula LimitN list (Hs)- hamming (Limit,Hs) -Hs=-H | HN has_primefactors_2_3_5 (H) H Limit which leads to the logic specification hamming (Limit,Hs) LimitN list (Hs) Hs=-H | HN has_primefactors_2_3_5 (H) H Limit from which I can derive the executable specification <ref> [Fuchs 91] </ref> hamming (Limit,Hs) :- set (H,(natural_number (H,Limit), has_primefactors_2_3_5 (H)),Hs). The predicate natural_number (H,Limit) generates natural numbers H up to Limit, while has_primefactors_2_3_5 tests for 'Hamming'-ness. Again, this executable specification is based on generate-and-test. For a more efficient recursive program I use induction with the list Hs as induction parameter.
Reference: [Hill, Lloyd 91] <author> P. M. Hill, J. W. Lloyd, </author> <title> The Gdel Report, </title> <institution> TR-91-02, Computer Science Department, University of Bristol, </institution> <month> March </month> <year> 1991 </year> <month> 13 </month>
Reference-contexts: We get a complete proof procedure if we delay the execution of literals which cannot yet safely be executed. Specifically, we delay negated literals until they are ground. Mechanism for delayed execution were discussed by [Naish 86], and are available in a number of Prolog implementations, and in Gdel <ref> [Hill, Lloyd 91] </ref>. Additionally, many of these languages allow to explicitly delay the execution of literals until user-defined conditions are fulfilled, i. e. the languages support coroutining. Coroutining can turn inefficient programs specifically executable specifications into efficient ones.
Reference: [Hoare 69] <author> C. A. R. Hoare, </author> <title> An axiomatic basis for computer programming, </title> <journal> CACM 12, </journal> <pages> pp. 576-583, </pages> <month> October </month> <year> 1969 </year>
Reference-contexts: In section 6, I briefly define structural induction, and demonstrate that by structural induction efficient programs can be derived from logic specifications. Finally in section 7, I summarize my results. 2 Hoare Logic In his seminal paper Hoare <ref> [Hoare 69] </ref> shows how programs can be given an axiomatic basis. Programs in procedural languages acquire a semantics by pre and postconditions expressed in first-order predicate logic. These pre and postconditions can be considered as specifications of the programs.
Reference: [Kowalski 79] <author> R. A. Kowalski, </author> <title> Logic for Problem Solving, </title> <publisher> North-Holland, </publisher> <year> 1979 </year>
Reference-contexts: This leads to the unfortunate complication that we have to establish relations between elements of two different languages, concretely that we have to prove that a program meets its specification. In the context of logic programming, Kowalski <ref> [Kowalski 79] </ref> points out that logic should not only be considered as a specification language but also as a means to solve the specified problem. Kowalski further emphasizes that expressing specifications and programs in the same language eases the task of verification.
Reference: [Kowalski 85] <author> R. A. Kowalski, </author> <title> The relation between logic programming and logic specification, </title> <editor> in: C. A. R. Hoare, J. C. Shepherdson (Eds.), </editor> <booktitle> Mathematical Logic and Programming Languages, Prentice-Hall International, </booktitle> <year> 1985 </year>
Reference-contexts: Combining Hoare's and Kowalski's ideas, I complete the process of abstraction by letting the S in Hoare's correctness formula stand for a logic program, i.e. by expressing both the specification and the program in logic. Kowalski <ref> [Kowalski 85] </ref> discusses this situation. He states that there is no syntactic difference between a program and its specification. Both specifications and programs can be executed by an interpreter based on automatic deduction though programs are expected to be more efficient than specifications. <p> Consequently, failure branches of the proof tree are pruned much earlier, and the proof can become significantly more efficient than without coroutining. Furthermore, a complete proof procedure allows us to take advantage of the relational nature of an executable specification <ref> [Kowalski 85] </ref>, i.e. we can query a specification for various instantiations of its arguments. 6 Derivation of Logic Programs By Structural Induction 6.1 Structural Induction The if-halves of logic specifications result in programs which are usually rather inefficient.
Reference: [Lau, Prestwich 91] <author> K.-K. Lau, S. D. Prestwich, </author> <title> Synthesis of a Family of Recursive Sorting Procedures, </title> <editor> in: V. Saraswat, K. Ueda (eds.), </editor> <booktitle> Proceedings of the 1991 International Symposium on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1991 </year>
Reference-contexts: 1 Introduction Recently there has been much interest in constructive methods to derive logic programs from their specifications (e.g. [Bundy et al. 90], [Flener 91], [Fribourg 90], [Deville 90], <ref> [Lau, Prestwich 91] </ref>). Bundy and collaborators [Bundy et al. 90] in their Oyster system synthesize programs in first-order logic from nonexecutable specifications in typed constructive logic.
Reference: [Levi 86] <author> G. Levi, </author> <title> New Research Directions in Logic Specification Languages, </title> <editor> in: H.-J. Kugler (Ed.), </editor> <booktitle> Information Processing 86 (IFIP), </booktitle> <publisher> Elsevier Science Publisher, </publisher> <pages> pp. 1005-1008, </pages> <year> 1986 </year>
Reference-contexts: First, the programs are concise, readable, and obviously fulfill their pre and postconditions. Second, if the pre and postconditions are available in executable form, the programs are executable, though not necessarily efficiently. As ([Fuchs 91], <ref> [Levi 86] </ref>) pointed out, pre and postconditions defining predicates by their properties often lead to programs based on generate-and-test, i.e. on search. 5.2 The First Few Smallest Elements of a List As an example, I will derive the program sm alle st which finds the S smallest elements in an unsorted
Reference: [Lloyd 87] <author> J. W. Lloyd, </author> <title> Foundations of Logic Programming,, </title> <publisher> Springer, </publisher> <year> 1987 </year>
Reference-contexts: Inconsistencies due to multiple assignments are impossible, because logical variables can be bound at most once. It is interesting to note, that the logic specification of S enhanced by an equality theory is equivalent to Clark's completion of S ([Clark 78], <ref> [Lloyd 87] </ref>) which forms the basis for the declarative semantics of normal logic programs. 5 4.3 Correctness and Completeness of Logic Specifications Let the definite logic program S implement the predicate s.
Reference: [Lloyd, Topor 84] <author> J. W. Lloyd, R. W. Topor, </author> <title> Making Prolog More Expressive, </title> <journal> Journal of Logic Programming, </journal> <volume> Vol. 1, No. 3, </volume> <pages> pp. 225-240, </pages> <year> 1984 </year>
Reference-contexts: In the general case, this Horn clause is in the extended form A W 6 introduced by <ref> [Lloyd, Topor 84] </ref>. The head A is an atomic formula, while the body W is a first-order formula including the usual connectors and quantifiers. In spite of their increased expressiveness, extended Horn clauses remain within the Horn clause subset of predicate logic. In fact, [Lloyd, Topor 84] demonstrated that extended Horn <p> form A W 6 introduced by <ref> [Lloyd, Topor 84] </ref>. The head A is an atomic formula, while the body W is a first-order formula including the usual connectors and quantifiers. In spite of their increased expressiveness, extended Horn clauses remain within the Horn clause subset of predicate logic. In fact, [Lloyd, Topor 84] demonstrated that extended Horn clauses can be transformed into equivalent normal Horn clauses provided that negation is safe.
Reference: [Naish 86] <author> L. Naish, </author> <title> Negation and Control in Prolog, </title> <publisher> LNCS 225, Springer, </publisher> <year> 1986 </year>
Reference-contexts: To ensure termination, Prolog's proof procedure must be replaced by a complete one. We get a complete proof procedure if we delay the execution of literals which cannot yet safely be executed. Specifically, we delay negated literals until they are ground. Mechanism for delayed execution were discussed by <ref> [Naish 86] </ref>, and are available in a number of Prolog implementations, and in Gdel [Hill, Lloyd 91]. Additionally, many of these languages allow to explicitly delay the execution of literals until user-defined conditions are fulfilled, i. e. the languages support coroutining.
References-found: 19

