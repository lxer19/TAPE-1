URL: http://www.research.digital.com/SRC/tla/ftrtft94.ps.Z
Refering-URL: http://www.research.digital.com/SRC/tla/papers.html
Root-URL: http://www.research.digital.com
Email: lamport@src.dec.com  merz@src.dec.com  
Title: Specifying and Verifying Fault-Tolerant Systems  Techniques in Real Time and Fault Tolerant Systems, held  
Author: Leslie Lamport and Stephan Merz 
Note: minor correction:  To appear in Proceedings of the Third International Symposium on Formal  1994 in Lubeck, Germany.  
Date: 25 July 1994  14 October 1994  September  
Affiliation: Digital Equipment Corporation Systems Research Center  
Pubnum: 19-23  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Martn Abadi and Leslie Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: The sending of a value v is initiated by a Send (v) step, which appends v44 to the tail of src <ref> [1] </ref> and complements src [2]|changing its value from 0 to 1 or vice-versa. Receipt of the value v occurs with a Rcv (v ) step, which is enabled iff v is the head of the sequence dest [1]. A Rcv (v) step removes v from the head of dest [1] and <p> by a Send (v) step, which appends v44 to the tail of src <ref> [1] </ref> and complements src [2]|changing its value from 0 to 1 or vice-versa. Receipt of the value v occurs with a Rcv (v ) step, which is enabled iff v is the head of the sequence dest [1]. A Rcv (v) step removes v from the head of dest [1] and complements dest [2]. The transmission of a value from one end of the channel to the other is45 modeled by a Tmt step, which moves an element from the head of src [1] to the tail of <p> src <ref> [1] </ref> and complements src [2]|changing its value from 0 to 1 or vice-versa. Receipt of the value v occurs with a Rcv (v ) step, which is enabled iff v is the head of the sequence dest [1]. A Rcv (v) step removes v from the head of dest [1] and complements dest [2]. The transmission of a value from one end of the channel to the other is45 modeled by a Tmt step, which moves an element from the head of src [1] to the tail of dest [1]. 13 module TimedChannel 41 import Sequences, Reals, RealTime parameters src; <p> of the sequence dest <ref> [1] </ref>. A Rcv (v) step removes v from the head of dest [1] and complements dest [2]. The transmission of a value from one end of the channel to the other is45 modeled by a Tmt step, which moves an element from the head of src [1] to the tail of dest [1]. 13 module TimedChannel 41 import Sequences, Reals, RealTime parameters src; dest 43 : variable t 47 : constant assumption Assump = (t 2 Real ) ^ (0 &lt; t) Send (v) 44 = src 0 = hsrc [1] ffi hv i; 1 src [2]i <p> Rcv (v) step removes v from the head of dest <ref> [1] </ref> and complements dest [2]. The transmission of a value from one end of the channel to the other is45 modeled by a Tmt step, which moves an element from the head of src [1] to the tail of dest [1]. 13 module TimedChannel 41 import Sequences, Reals, RealTime parameters src; dest 43 : variable t 47 : constant assumption Assump = (t 2 Real ) ^ (0 &lt; t) Send (v) 44 = src 0 = hsrc [1] ffi hv i; 1 src [2]i Rcv (v) 44 = ^ (dest <p> element from the head of src <ref> [1] </ref> to the tail of dest [1]. 13 module TimedChannel 41 import Sequences, Reals, RealTime parameters src; dest 43 : variable t 47 : constant assumption Assump = (t 2 Real ) ^ (0 &lt; t) Send (v) 44 = src 0 = hsrc [1] ffi hv i; 1 src [2]i Rcv (v) 44 = ^ (dest [1] 6= h i) ^ (v = Head (dest [1])) ^ dest 0 = hTail (dest [1]);1 dest [2]i Tmt 45 ^ src 0 = hTail (src [1]); src [2]i ^ dest 0 = hdest [1] ffi hHead <p> 13 module TimedChannel 41 import Sequences, Reals, RealTime parameters src; dest 43 : variable t 47 : constant assumption Assump = (t 2 Real ) ^ (0 &lt; t) Send (v) 44 = src 0 = hsrc <ref> [1] </ref> ffi hv i; 1 src [2]i Rcv (v) 44 = ^ (dest [1] 6= h i) ^ (v = Head (dest [1])) ^ dest 0 = hTail (dest [1]);1 dest [2]i Tmt 45 ^ src 0 = hTail (src [1]); src [2]i ^ dest 0 = hdest [1] ffi hHead (src [1])i; dest [2]i ext 48 = hsrc [2]; dest [2]i Spec 46 <p> src; dest 43 : variable t 47 : constant assumption Assump = (t 2 Real ) ^ (0 &lt; t) Send (v) 44 = src 0 = hsrc <ref> [1] </ref> ffi hv i; 1 src [2]i Rcv (v) 44 = ^ (dest [1] 6= h i) ^ (v = Head (dest [1])) ^ dest 0 = hTail (dest [1]);1 dest [2]i Tmt 45 ^ src 0 = hTail (src [1]); src [2]i ^ dest 0 = hdest [1] ffi hHead (src [1])i; dest [2]i ext 48 = hsrc [2]; dest [2]i Spec 46 = ^ (src = hh i; 0i) ^ 2 <p> &lt; t) Send (v) 44 = src 0 = hsrc <ref> [1] </ref> ffi hv i; 1 src [2]i Rcv (v) 44 = ^ (dest [1] 6= h i) ^ (v = Head (dest [1])) ^ dest 0 = hTail (dest [1]);1 dest [2]i Tmt 45 ^ src 0 = hTail (src [1]); src [2]i ^ dest 0 = hdest [1] ffi hHead (src [1])i; dest [2]i ext 48 = hsrc [2]; dest [2]i Spec 46 = ^ (src = hh i; 0i) ^ 2 [Tmt _ 9 v : Send (v )] src ^ (dest = hh i; 0i) ^ 2 [Tmt <p> = hsrc <ref> [1] </ref> ffi hv i; 1 src [2]i Rcv (v) 44 = ^ (dest [1] 6= h i) ^ (v = Head (dest [1])) ^ dest 0 = hTail (dest [1]);1 dest [2]i Tmt 45 ^ src 0 = hTail (src [1]); src [2]i ^ dest 0 = hdest [1] ffi hHead (src [1])i; dest [2]i ext 48 = hsrc [2]; dest [2]i Spec 46 = ^ (src = hh i; 0i) ^ 2 [Tmt _ 9 v : Send (v )] src ^ (dest = hh i; 0i) ^ 2 [Tmt _ 9 v : Rcv (v )] dest <p> Module TimedChannel. Formula Spec is the specification of the timed channel. A behavior satisfies 46 this formula iff the variables src and dest behave the way they should for a timed channel. The formula has three conjuncts. The first describes the sequence of values assumed by src. Initially, src <ref> [1] </ref> is the empty sequence and src [2] equals 0; every step that changes src is a Tmt step or a Send (v) step, for some v . The second conjunct similarly describes the sequence of values assumed by dest . The third conjunct asserts the real-time requirement. <p> The third conjunct asserts the real-time requirement. As explained in Section 2.2, the conjunct asserts that Tmt cannot remain enabled for more than t time units 47 before the next Tmt step occurs. Thus, this conjunct asserts that, when src <ref> [1] </ref> is nonempty, values are moved from it to dest [1] at the rate of at least one every t time units. <p> As explained in Section 2.2, the conjunct asserts that Tmt cannot remain enabled for more than t time units 47 before the next Tmt step occurs. Thus, this conjunct asserts that, when src <ref> [1] </ref> is nonempty, values are moved from it to dest [1] at the rate of at least one every t time units. We now come to ext , the pair consisting of the second components of src and 48 dest , and the explanation of what those second components are for. <p> The same technique is used with the temporal quantifier 999 999 , where the instantiation is called a refinement mapping <ref> [1] </ref>. To prove h2i4, we must instantiate the timer variable t used to express the timing constraint on Mid :Choose. The instantiation is simple|we instantiate t with the timer variable for the low-level Choose action.
Reference: 2. <author> Martn Abadi and Leslie Lamport. </author> <title> An old-fashioned recipe for real time. </title> <type> Research Report 91, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <year> 1992. </year> <title> An earlier version, without proofs, </title> <booktitle> appeared in [6, </booktitle> <pages> pages 1-27]. </pages>
Reference-contexts: This module imports the modules SpecParams, Reals, and RealTime. 6 The RealTime module is used to express real-time properties. It is essentially the same module as in [15], which in turn used the definitions from <ref> [2] </ref>. 1 Specifying real-time properties is an engineering problem that is solved by applying standard methods. We will explain the operators in the RealTime module as they appear in our specification. The module is given in Figure 20. <p> of states with status [Cmdr] = "Loyal" and ord [g ] = o, for some o in Order , or (ii) starts with a finite (possibly empty) sequence of such 1 The definition of VTimer in the RealTime module of [15] contains a typographical error; the correct definition appears in <ref> [2] </ref> and Figure 20. 2 Since real-time conditions are used to specify progress, there are no fairness condi tions in our processes. 7 states and ends with an infinite sequence of states in which status [Cmdr ] equals "Traitor" and ord [Cmdr ] assumes completely arbitrary values. <p> The final conjunct of LSpec (g) places a timing bound on the Choose (g) action, using the temporal formulas VTimer and MaxTimer , defined in module 38 RealTime. These formulas were introduced in <ref> [2] </ref> and used again in [15] as a general method for specifying real-time bounds. <p> src <ref> [2] </ref>|changing its value from 0 to 1 or vice-versa. Receipt of the value v occurs with a Rcv (v ) step, which is enabled iff v is the head of the sequence dest [1]. A Rcv (v) step removes v from the head of dest [1] and complements dest [2]. <p> 44 = ^ (dest [1] 6= h i) ^ (v = Head (dest [1])) ^ dest 0 = hTail (dest [1]);1 dest <ref> [2] </ref>i Tmt 45 ^ src 0 = hTail (src [1]); src [2]i ^ dest 0 = hdest [1] ffi hHead (src [1])i; dest [2]i ext 48 = hsrc [2]; dest [2]i Spec 46 = ^ (src = hh i; 0i) ^ 2 [Tmt _ 9 v : Send (v )] src ^ (dest = hh i; 0i) ^ 2 [Tmt _ 9 v : Rcv (v )] dest ^ 999 999 t : VTimer (t; Tmt ; t; hsrc; <p> A behavior satisfies 46 this formula iff the variables src and dest behave the way they should for a timed channel. The formula has three conjuncts. The first describes the sequence of values assumed by src. Initially, src [1] is the empty sequence and src <ref> [2] </ref> equals 0; every step that changes src is a Tmt step or a Send (v) step, for some v . The second conjunct similarly describes the sequence of values assumed by dest . The third conjunct asserts the real-time requirement.
Reference: 3. <author> Martn Abadi and Leslie Lamport. </author> <title> Conjoining specifications. </title> <type> Research Report 118, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <year> 1993. </year> <note> To appear in ACM Transactions on Programming Languages and Systems. </note>
Reference-contexts: We have used a specification style different from our customary one. We usually write interleaving specifications, in which events in different processes are 31 represented by separate steps <ref> [3] </ref>. Here, we have written noninterleaving specifications that allow individual steps which represent actions in two or more processes.
Reference: 4. <author> E. A. Ashcroft. </author> <title> Proving assertions about parallel programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 10 </volume> <pages> 110-135, </pages> <month> February </month> <year> 1975. </year>
Reference-contexts: 1 Introduction Assertional verification of concurrent systems began almost twenty years ago with the work of Ashcroft <ref> [4] </ref>. By the early 1980's, the basic principles of formal specification and verification of concurrent systems were known [10, 12, 19]. More precisely, we had learned how to specify and verify those aspects of a system that can be expressed as the correctness of an individual execution. <p> Theorem SpecGood is of the form Spec ) 2P, for a state predicate P. If Spec were of the canonical form Init ^2 [N ] v , then this would be a completely standard proof using the method first described by Ashcroft <ref> [4] </ref>: find a state predicate I (the invariant ) such that (i) Init implies I , (ii) I implies P , and (iii) I ^ [N ] v implies I 0 . (This TLA formulation of the proof method is more transparent than its original description as a method for reasoning
Reference: 5. <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: However, the primary issue is not one of language but of complexity. It is hard to reason about real programs because 32 they are complicated. Formal reasoning is generally applied only to concurrent programs written in toy languages like CSP [8] and Unity <ref> [5] </ref>. A program in a toy language is no closer to a real program than is a TLA formula. Further work is needed before formal reasoning about executable code becomes routine.
Reference: 6. <editor> J. W. de Bakker, C. Huizing, W. P. de Roever, and G. Rozenberg, editors. </editor> <booktitle> Real-Time: Theory in Practice, volume 600 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year> <title> Proceedings of a REX Real-Time Workshop, held in The Netherlands in June, </title> <year> 1991. </year>
Reference: 7. <author> Urban Engberg, Peter Grtnning, and Leslie Lamport. </author> <title> Mechanical verification of concurrent systems with TLA. In Computer-Aided Verification, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> Berlin, Heidelberg, New York, </address> <month> June </month> <year> 1992. </year> <title> Springer-Verlag. </title> <booktitle> Proceedings of the Fourth International Conference, </booktitle> <address> CAV'92. </address>
Reference-contexts: We indicate how proofs of our theorems are carried down to the level at which each leaf proof consists of simple expansion of definitions and propositional logic. Such simple proofs are easy to check mechanically; most steps in our proofs can be checked with the TLP verification system <ref> [7] </ref>. 3.1 Proof of Theorem SpecGood steps and the proof of the final step. The Let construct introduces definitions local to the proof. We use a hierarchical numbering convention for denoting parts of formulas, adding numbers to bulleted lists of conjuncts and disjuncts. <p> There are no shortcuts. Short proofs are short because they gloss over details that have to be checked to avoid errors. These proofs are amenable to mechanical verification. Most steps can be checked with the TLP verification system <ref> [7] </ref>. However, for this type of reasoning, which cannot be checked by finite-state methods, mechanical theorem proving still seems to be considerably more work than writing a hand proof. The hierarchical proof style makes it possible to reduce the probability of errors in hand proofs to an acceptable level.
Reference: 8. <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Series in Computer Science. Prentice-Hall International, </booktitle> <address> London, </address> <year> 1985. </year>
Reference-contexts: Most of the literature on verification concentrates on the underlying formalism and ignores the problem of defining a language for specifying real systems [11, 17, 18]. The literature on specification languages generally ignores the problem of reasoning formally about specifications of real systems <ref> [8, 9] </ref>. We address these practical issues by using existing tools: a precisely defined specification language and a hierarchical proof method. Section 2 contains the formal specifications of the problem and the algorithm. <p> However, the primary issue is not one of language but of complexity. It is hard to reason about real programs because 32 they are complicated. Formal reasoning is generally applied only to concurrent programs written in toy languages like CSP <ref> [8] </ref> and Unity [5]. A program in a toy language is no closer to a real program than is a TLA formula. Further work is needed before formal reasoning about executable code becomes routine.
Reference: 9. <author> Reino Kurki-Suonio. </author> <title> Operational specification with joint actions: Serializable databases. </title> <journal> Distributed Computing, </journal> <volume> 6(1) </volume> <pages> 19-37, </pages> <year> 1992. </year>
Reference-contexts: Most of the literature on verification concentrates on the underlying formalism and ignores the problem of defining a language for specifying real systems [11, 17, 18]. The literature on specification languages generally ignores the problem of reasoning formally about specifications of real systems <ref> [8, 9] </ref>. We address these practical issues by using existing tools: a precisely defined specification language and a hierarchical proof method. Section 2 contains the formal specifications of the problem and the algorithm.
Reference: 10. <author> Simon S. Lam and A. Udaya Shankar. </author> <title> Protocol verification via projections. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):325-342, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: 1 Introduction Assertional verification of concurrent systems began almost twenty years ago with the work of Ashcroft [4]. By the early 1980's, the basic principles of formal specification and verification of concurrent systems were known <ref> [10, 12, 19] </ref>. More precisely, we had learned how to specify and verify those aspects of a system that can be expressed as the correctness of an individual execution. Fault-tolerant systems are just one class of concurrent systems; they require no special techniques.
Reference: 11. <author> Simon S. Lam and A. Udaya Shankar. </author> <title> Specifying modules to satisfy interfaces: A state transition system approach. </title> <journal> Distributed Computing, </journal> <volume> 6(1) </volume> <pages> 39-63, </pages> <year> 1992. </year>
Reference-contexts: The specification and verification of fault-tolerant algorithms is not rocket science, but it is still not 2 standard engineering practice. Most of the literature on verification concentrates on the underlying formalism and ignores the problem of defining a language for specifying real systems <ref> [11, 17, 18] </ref>. The literature on specification languages generally ignores the problem of reasoning formally about specifications of real systems [8, 9]. We address these practical issues by using existing tools: a precisely defined specification language and a hierarchical proof method.
Reference: 12. <author> Leslie Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 190-222, </pages> <month> April </month> <year> 1983. </year>
Reference-contexts: 1 Introduction Assertional verification of concurrent systems began almost twenty years ago with the work of Ashcroft [4]. By the early 1980's, the basic principles of formal specification and verification of concurrent systems were known <ref> [10, 12, 19] </ref>. More precisely, we had learned how to specify and verify those aspects of a system that can be expressed as the correctness of an individual execution. Fault-tolerant systems are just one class of concurrent systems; they require no special techniques.
Reference: 13. <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <type> Research Report 79, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> December </month> <year> 1991. </year> <note> To appear in ACM Transactions on Programming Languages and Systems. </note>
Reference-contexts: The correspondence between the real system and the mathematical formula lies in the interpretation of the formula's variables. The free variables of the specification represent the system's interface|the part of the system that is being specified. A description of TLA and its proof rules can be found in <ref> [13] </ref>. However, we try to explain the meaning of the TLA formulas in our specification well enough so they can be read with no prior knowledge of TLA. Some formalisms describe systems in terms of events (often called actions) rather than states. <p> The first-level proof of h1i1 appears in Figure 9. The rule that underlies the proof is that proving I ^ A ) I 0 allows us to infer I ^ 2A ) 2I , where I is a predicate and A an action. This is an RTLA <ref> [13] </ref> rule, where RTLA is a logic that is like TLA except that 2A is an RTLA formula for any action A, not just for actions A of the form [N ] v .
Reference: 14. <author> Leslie Lamport. </author> <title> How to write a proof. </title> <type> Research Report 94, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> February </month> <year> 1993. </year> <note> To appear in American Mathematical Monthly. </note>
Reference-contexts: The key to moving proofs from the realm of mathematics into engineering practice is hierarchical structuring. We use the method of structuring proofs introduced in <ref> [14] </ref>. The conventions used in this method are described as they appear. A hierarchically structured proof is a sequence of steps, each with a proof. The proof of a step is either a short paragraph or calculation, or else a hierarchically structured proof.
Reference: 15. <editor> Leslie Lamport. Hybrid systems in TLA + . In Robert L. Grossman, Anil Nerode, Anders P. Ravn, and Hans Rischel, editors, </editor> <booktitle> Hybrid Systems, volume 736 of Lecture Notes in Computer Science, </booktitle> <pages> pages 77-102, </pages> <address> Berlin, Heidelberg, 1993. </address> <publisher> Springer-Verlag. </publisher> <pages> 33 </pages>
Reference-contexts: TLA + provides a language for writing TLA specifications. In addition to the operators of TLA, it contains operators for defining and manipulating data structures and syntactic structures for handling large specifications. The first published description of TLA + was in <ref> [15] </ref>. <p> The line ends the module. 14 The actual specification is contained in module HiLevel , which comes next. This module imports the modules SpecParams, Reals, and RealTime. 6 The RealTime module is used to express real-time properties. It is essentially the same module as in <ref> [15] </ref>, which in turn used the definitions from [2]. 1 Specifying real-time properties is an engineering problem that is solved by applying standard methods. We will explain the operators in the RealTime module as they appear in our specification. The module is given in Figure 20. <p> any behavior that either (i) consists of an infinite number of states with status [Cmdr] = "Loyal" and ord [g ] = o, for some o in Order , or (ii) starts with a finite (possibly empty) sequence of such 1 The definition of VTimer in the RealTime module of <ref> [15] </ref> contains a typographical error; the correct definition appears in [2] and Figure 20. 2 Since real-time conditions are used to specify progress, there are no fairness condi tions in our processes. 7 states and ends with an infinite sequence of states in which status [Cmdr ] equals "Traitor" and ord <p> The final conjunct of LSpec (g) places a timing bound on the Choose (g) action, using the temporal formulas VTimer and MaxTimer , defined in module 38 RealTime. These formulas were introduced in [2] and used again in <ref> [15] </ref> as a general method for specifying real-time bounds. <p> Our specifications are written in TLA + . The flexibility of TLA + is indicated by the ease with which real-time properties are expressed, even though the language has no special primitives for time. We use the same RealTime module for specifying Byzantine generals that was used in <ref> [15] </ref> for specifying a gas burner. This kind of flexibility and modularity are characteristic of an engineering discipline. Our proofs use the logic TLA. They are completely formal.
Reference: 16. <author> Leslie Lamport, Robert Shostak, and Marshall Pease. </author> <title> The Byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: The limited space provided by these proceedings, and the limited time and patience of the authors, have forced us to choose a simple example|the specification and hierarchical verification of a well known fault-tolerant algorithm. Our example is OM (1), the one-traitor "oral-message" solution to the Byzan-tine generals problem <ref> [16] </ref>. In this problem, there is a collection of generals|a commander and a set of lieutenants|who communicate with one another by message. Any of the generals, including the commander, may be a traitor. <p> Section 2 contains the formal specifications of the problem and the algorithm. There are three specifications, a high-level problem specification, a mid-level specification of the algorithm at roughly the level of detail provided in <ref> [16] </ref>, and a low-level specification that more realistically models message passing. Section 3 proves that each specification implements the next higher-level one. A correctness property of the high-level specification is also proved. <p> In other words, every loyal general chooses an order by time Now 0 + , and that order is the same as any other loyal general's order. All theorems are proved in Section 3. 2.2 The Mid-Level Specification The mid-level specification describes Algorithm OM (1) of <ref> [16] </ref>, an "oral-message" Byzantine agreement algorithm that works in the presence of at most one traitor. It is a two-round algorithm. In the first round, the commander sends her message to all lieutenants. In the second round, each lieutenant relays the message he received to all other lieutenants. <p> The only requirements on this majority function are (i) if the same order o is received from all but one of the other generals, then o is chosen, and (ii) all lieutenants use the same majority function. This informal description is essentially the one given in <ref> [16] </ref>. It contains several tacit assumptions|for example, that every lieutenant receives a value in the first round, even if the commander is a traitor. The formal specification makes these assumptions explicit.
Reference: 17. <author> Nancy Lynch and Mark Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proceedings of the Sixth Symposium on the Principles of Distributed Computing, </booktitle> <pages> pages 137-151. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1987. </year>
Reference-contexts: The specification and verification of fault-tolerant algorithms is not rocket science, but it is still not 2 standard engineering practice. Most of the literature on verification concentrates on the underlying formalism and ignores the problem of defining a language for specifying real systems <ref> [11, 17, 18] </ref>. The literature on specification languages generally ignores the problem of reasoning formally about specifications of real systems [8, 9]. We address these practical issues by using existing tools: a precisely defined specification language and a hierarchical proof method.
Reference: 18. <author> Zohar Manna and Amir Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: The specification and verification of fault-tolerant algorithms is not rocket science, but it is still not 2 standard engineering practice. Most of the literature on verification concentrates on the underlying formalism and ignores the problem of defining a language for specifying real systems <ref> [11, 17, 18] </ref>. The literature on specification languages generally ignores the problem of reasoning formally about specifications of real systems [8, 9]. We address these practical issues by using existing tools: a precisely defined specification language and a hierarchical proof method. <p> The proofs of h1i2 and h1i3 are straightforward 4 The rule is unsound for an infinite set S because 999 999 is defined so 999 999 x : F is invariant under stuttering. It is sound for the operator 999 999 of Manna and Pnueli <ref> [18] </ref>, which does not preserve invariance under stuttering. 28 h2i1. ^ CSpec ^ CSpecT ^ 8 g 2 Lt : LSpecT (g) ^ 8 g; h 2 Gen : TCSpecT (g; h) ^ RT (hord; rcvd ; in; out; status; sent i) ^ now = Now 0 ) Mid :Spec Proof:
Reference: 19. <author> Jayadev Misra and K. Mani Chandy. </author> <title> Proofs of networks of processes. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-7(4):417-426, </volume> <month> July </month> <year> 1981. </year>
Reference-contexts: 1 Introduction Assertional verification of concurrent systems began almost twenty years ago with the work of Ashcroft [4]. By the early 1980's, the basic principles of formal specification and verification of concurrent systems were known <ref> [10, 12, 19] </ref>. More precisely, we had learned how to specify and verify those aspects of a system that can be expressed as the correctness of an individual execution. Fault-tolerant systems are just one class of concurrent systems; they require no special techniques.

References-found: 19

