URL: http://www.prolangs.rutgers.edu/refs/docs/tr341.ps
Refering-URL: http://www.csd.uu.se/~thomasl/wpo/oo-compilation-papers.html
Root-URL: 
Email: framkrish,ryderg@cs.rutgers.edu  wlandi@scr.siemens.com  
Phone: +1 908 445  2  
Title: Complexity of Concrete Type-inference in the Presence of Exceptions  
Author: Ramkrishna Chatterjee Barbara G. Ryder William A. Landi 
Web: DCS-TR-341  
Address: Piscataway NJ 08855, USA  2001  755 College Rd. East, Princeton, NJ 08540 USA,  
Affiliation: 1 Department of Computer Science, Rutgers University,  Siemens Corporate Research Inc,  
Abstract: Concrete type-inference for statically typed object-oriented programming languages (e.g., Java, C ++ ) determines at each program point, those objects to which a reference may refer or a pointer may point during execution. A precise compile-time solution for this problem requires a flow-sensitive analysis. Our new complexity results for concrete type-inference distinguish the difficulty of the intraprocedural and interprocedural problem for languages with combinations of single-level types 3 , exceptions with or without subtyping, and dynamic dispatch. Our results include: The first polynomial-time algorithm for concrete type-inference in the presence of exceptions, which handles Java without threads, and C ++ ; Proofs that the above algorithm is always safe and provably precise on programs with single-level types, exceptions without subtyping, and without dynamic dispatch; Proof that interprocedural concrete type-inference problem with single-level types and exceptions with subtyping, and without dynamic dispatch is PSPACE-hard, while the intraprocedural prob lem is PSPACE-complete. Other complexity characterizations of concrete type-inference for pro grams without exceptions are also presented.
Abstract-found: 1
Intro-found: 1
Reference: [Age95] <author> Ole Agesen. </author> <title> The cartesian product algorithm: Simple and precise type inference of parametric polymorphism. </title> <booktitle> In Proceedings of European Conference on Object-oriented Programming (ECOOP '95), </booktitle> <year> 1995. </year>
Reference-contexts: While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95], which are the most precise, but also the most expensive. Approaches like <ref> [PS91, PC94, Age95] </ref> are in between the above two extremes. An intraprocedurally flow-insensitive algorithm does not distinguish between program points within a method; hence it reports the same solution for all program points within each method. <p> This way of maintaining context is similar to Landi-Ryder's [LR92] method of storing context using reaching aliases, except that our algorithm uses points-tos rather than aliases. Our algorithm also differs from approaches like <ref> [PS91, Age95] </ref> in being intraprocedurally flow-sensitive. 10 Conclusion In this paper, we have studied the complexity of CTI for a subset of Java, which includes exceptions. The complexity of CTI in the presence of exceptions has not been studied before. The following are the main contributions of this paper: 1.
Reference: [And94] <author> L. O. Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <year> 1994. </year> <note> Also available as DIKU report 94/19. </note>
Reference-contexts: Although some of these have been used for pointer analysis of C, they can be adapted for CTI of Java without exceptions and threads, or C ++ without exceptions. At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches <ref> [Ste96, SH97, ZRL96, And94] </ref>, which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95], which are the most precise, but also the most expensive.
Reference: [Bar78] <author> J. M. Barth. </author> <title> A practical interprocedural data flow analysis algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 21(9) </volume> <pages> 724-736, </pages> <year> 1978. </year>
Reference-contexts: Unfortunately, all realizable paths in a program are not necessarily executable and determining whether a particular branch of an if statement is executable is undecidable. Barth <ref> [Bar78] </ref> defined precise up to symbolic execution to be the precise solution under the assumption that all realizable program paths are executable (i.e., the result of a test is independent of previous tests and all the branches are possible).
Reference: [CBC93] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches [Ste96, SH97, ZRL96, And94], which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches <ref> [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95] </ref>, which are the most precise, but also the most expensive. Approaches like [PS91, PC94, Age95] are in between the above two extremes. <p> The complexity of flow-sensitive CTI in the presence of exceptions has not been studied previously. None of the previous flow-sensitive pointer analysis algorithms <ref> [LR92, WL95, EGH94, PR96, Ruf95, CBC93, MLR + 93] </ref> for C/C ++ handle exceptions. However, unlike in C ++ , exceptions are frequently used in Java programs, making it an important problem for Java. <p> This work takes state-of-the-art in pointer analysis one step further by handling exceptions. Our algorithm differs from other pointer analysis and CTI algorithms <ref> [EGH94, WL95, Ruf95, PC94, PS91, CBC93, MLR + 93] </ref> in the way it maintains context-sensitivity by associating assumed-points-tos with each data-flow element, rather than using some approximation of the call stack. This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions.
Reference: [CR97] <author> Ramkrishna Chatterjee and Barbara Ryder. </author> <title> Scalable, flow-sensitive type-inference for statically typed o-o languages. </title> <type> Technical Report DCS-TR-326, </type> <institution> Dept of CS, Rutgers University, </institution> <year> 1997. </year>
Reference-contexts: This means that the worst-case complexity (assuming V is at least 1) is O ((C (V + A) + n)V 2 L). Now each of C, V , A and L is at most O (n), hence the the worst-case complexity is O (n 5 ). In <ref> [CR97] </ref>, we present an example for which the algorithm attains this worst-case bound. 4.3 Complexity of intraprocedural CTI for programs with only single-level types and without dynamic dispatch, exceptions or threads Theorem 2 Intraprocedural CTI for programs with only single-level types and without dynamic dispatch, exceptions or threads is in non-deterministic <p> Moreover, various 32 heuristics can be used for improving its precision and efficiency. For example, in <ref> [CR97] </ref>, we discuss some techniques for improving the precision and efficiency of the basic algorithm. One obvious way to improve precision is to associate more context with data-flow elements. In [CR97], we show that remembering the receiver object along with a assumed-points-to can improve precision in many situations. <p> Moreover, various 32 heuristics can be used for improving its precision and efficiency. For example, in <ref> [CR97] </ref>, we discuss some techniques for improving the precision and efficiency of the basic algorithm. One obvious way to improve precision is to associate more context with data-flow elements. In [CR97], we show that remembering the receiver object along with a assumed-points-to can improve precision in many situations. Similarly, an assumed-points-to may be associated with excp-type in exceptional-conditional-points-tos.
Reference: [EGH94] <author> Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming language design and implementation, </booktitle> <pages> pages 242-256, </pages> <year> 1994. </year>
Reference-contexts: At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches [Ste96, SH97, ZRL96, And94], which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches <ref> [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95] </ref>, which are the most precise, but also the most expensive. Approaches like [PS91, PC94, Age95] are in between the above two extremes. <p> The complexity of flow-sensitive CTI in the presence of exceptions has not been studied previously. None of the previous flow-sensitive pointer analysis algorithms <ref> [LR92, WL95, EGH94, PR96, Ruf95, CBC93, MLR + 93] </ref> for C/C ++ handle exceptions. However, unlike in C ++ , exceptions are frequently used in Java programs, making it an important problem for Java. <p> Information flows from a call-node to the entry-node of a target method and comes back from the exit-node of the target method to the return-node of the call-node. Due to dynamic dispatch, interprocedural edges are constructed iteratively during data-flow analysis as in <ref> [EGH94] </ref>. Details of this construction are shown in Figure 3. We will denote the entry-node of main by start-node in the rest of this paper. 2.2 Representation of dynamically created objects All run-time objects (or arrays) created at a program point n are represented symbolically by object n. <p> Due to dynamic dispatch, the set of methods callable from a call site is iteratively computed during the data-flow analysis as in <ref> [EGH94] </ref>. Suppose hx, t i holds at a call site C which has a method M in its set of callable methods computed so far. <p> C, ndf elm )f // R is the return-node for call node C. if ( ndf elm implies an increase in the set CM of methods invoked from this site ) f // Recall that due to dynamic dispatch, the interprocedural // edges are constructed on the fly, as in <ref> [EGH94] </ref>. add this new method nM to CM; for ( each dfelm in the solution set of C ) interprocedurally propagate ( dfelm, C, nM ); // defined in Figure 4 g if ( ndf elm represents value of a local variable ) f if ( solution set for R contains <p> This work takes state-of-the-art in pointer analysis one step further by handling exceptions. Our algorithm differs from other pointer analysis and CTI algorithms <ref> [EGH94, WL95, Ruf95, PC94, PS91, CBC93, MLR + 93] </ref> in the way it maintains context-sensitivity by associating assumed-points-tos with each data-flow element, rather than using some approximation of the call stack. This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions.
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: point m or (4) object n.f field f, of reference type, an of object created at a program point n; and obj is object s an object created at a program point s. 2.5 Single-level type A single-level type is one of the following: (1) a primitive type defined in <ref> [GJS96] </ref> (e.g., int, float etc.), (2) a class that has all non-static data-members of primitive types (e.g., class A f int i,j; g) or (3) an array of a primitive type. 5 may refer to an instance of a class or an array. 4 Remark: Since any class in Java has <p> propagating the data-flow element used to check reachability is at most O (n), so we ignore it in our analysis. 12 5 Complexity of CTI in the presence of exceptions Semantics of finally: Before describing our results about CTI in the presence of exceptions, we will briefly describe the semantics <ref> [GJS96] </ref> of a finally statement in Java as it is important for understanding the rest of this paper. The semantics of exception handling in Java is more complicated than other languages like C ++ because of the finally statement.
Reference: [HU79] <author> J. E. Hofcroft and J. D. Ullman. </author> <title> Introduction to automata theory, languages and computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: As a result, even if we use Bill Landi's proof for 4 levels of indirection, the above construction shows that intraprocedural TIA is PSPACE-hard. Now we will show that intraprocedural TIA is in PSPACE, and hence PSPACE-complete. Savitch's theorem <ref> [HU79] </ref> implies that PSPACE= NPSPACE 13 . Hence, it is enough to show that intraprocedural TIA is in NPSPACE. Our proof is similar to Bill Landi's proof [Lan92a] that PTA is in NPSPACE.
Reference: [KU76] <author> J.B. Kam and J.D. Ullman. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> Journal of ACM, </journal> <volume> 23(1) </volume> <pages> 158-171, </pages> <year> 1976. </year>
Reference-contexts: If all statements 5 that can potentially generate run-time exceptions are considered, we will get a safe solution; however, this may generate far more information than what is useful. 3 CTI in the absence of exceptions Our basic algorithm for CTI is an iterative worklist algorithm <ref> [KU76] </ref>. It operates on an ICFG and is similar to the Landi-Ryder algorithm [LR92] for alias analysis, but instead of aliases, it computes points-tos.
Reference: [Lan92a] <author> W. A. Landi. </author> <title> Interprocedural aliasing in the presence of pointers, </title> <type> phd thesis. Technical Report LCSR-TR-174, </type> <institution> Dept of CS, Rutgers University, </institution> <year> 1992. </year>
Reference-contexts: Also, nested finally statements cause reasons for entering them to stack up. Now, in the rest of this section, we show that intraprocedural CTI for programs with only single-level types and exceptions with subtyping is PSPACE-complete, while the interprocedural case without dynamic dispatch is PSPACE-hard. In <ref> [Lan92a] </ref>, Bill Landi showed that intraprocedural may-alias analysis for a subset of C in the presence of pointers with at most 4 levels of indirection 11 and without dynamic allocation is PSPACE-complete. The only control-flow statements used in the proof are if and while. <p> Now we will show that intraprocedural TIA is in PSPACE, and hence PSPACE-complete. Savitch's theorem [HU79] implies that PSPACE= NPSPACE 13 . Hence, it is enough to show that intraprocedural TIA is in NPSPACE. Our proof is similar to Bill Landi's proof <ref> [Lan92a] </ref> that PTA is in NPSPACE. We present a non-deterministic algorithm for TIA, which uses polynomial amount 13 languages accepted by non-deterministic Turing machines using polynomial amount of space [Pap94]. 16 of space.
Reference: [Lan92b] <author> W. A. Landi. </author> <title> Undecidability of static analysis. </title> <journal> acm Letters on Programming Languages and Systems, </journal> <volume> 1(4) </volume> <pages> 323-337, </pages> <year> 1992. </year>
Reference-contexts: This shows that the overhead due to exceptions is small compared to the complexity of the basic algorithm. This is important because this technique for handling exceptions may be combined with other flow-sensitive algorithms. 8.1 Complexity of computing the precise solution in the general case Using Bill Landi's result <ref> [Lan92b] </ref> about undecidability of may alias analysis, it can be shown that CTI in the general case is undecidable. 8.2 Optimizations The estimate in lemma 11 is a worst-case bound; in practice we expect the performance of the extended algorithm to be much better.
Reference: [LR91] <author> W.A. Landi and Barbara G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: In contrast, an intraprocedurally flow-sensitive algorithm tries to compute different solutions for distinct program points. The example in Figure 5 in Appendix C illustrates this difference. An interprocedurally flow-sensitive (i.e. context-sensitive) algorithm considers (sometimes approximately) only interprocedurally realizable paths <ref> [RHS95, LR91] </ref>: paths along which calls and returns are properly matched, while an inter-procedurally flow-insensitive (i.e. context-insensitive) algorithm does not make this distinction. The example in Figure 6 in Appendix C illustrates this difference. <p> Finally, we present an extension of the basic algorithm for CTI in the presence of exceptions, and prove its complexity and correctness. 2 Basic definitions 2.1 Program representation Our algorithm operates on an interprocedural control flow graph or ICFG <ref> [LR91] </ref>. An ICFG contains a control flow graph (CFG) for each method in the program. Each statement in a method is represented by a node in the method's CFG. Each call site is represented using a pair of nodes: a call-node and a return-node. <p> We will show that the basic algorithm's worst-case complexity in this case is O (n 5 ), hence this case is in P. This an improvement over O (n 7 ) worst-case bound achievable by applying previous approaches of [RHS95] and <ref> [LR91] </ref> to this case. 6 Our proof is strongly influenced by a similar proof for aliases in [LR91]. 7 // initialize worklist. <p> This an improvement over O (n 7 ) worst-case bound achievable by applying previous approaches of [RHS95] and <ref> [LR91] </ref> to this case. 6 Our proof is strongly influenced by a similar proof for aliases in [LR91]. 7 // initialize worklist. <p> A proof that CTI for programs with only single-level types and without exceptions or dynamic dispatch can be solved in O (n 5 ) time. This an improvement over the O (n 7 ) worst-case bound achievable by applying previous approaches of [RHS95] and <ref> [LR91] </ref> to this case. 33 6. A proof that intraprocedural CTI for programs with only single-level types and without exceptions or dynamic dispatch is in non-deterministic log-space and hence NC.
Reference: [LR92] <author> W.A. Landi and Barbara G. Ryder. </author> <title> A safe approximation algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches [Ste96, SH97, ZRL96, And94], which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches <ref> [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95] </ref>, which are the most precise, but also the most expensive. Approaches like [PS91, PC94, Age95] are in between the above two extremes. <p> The complexity of flow-sensitive CTI in the presence of exceptions has not been studied previously. None of the previous flow-sensitive pointer analysis algorithms <ref> [LR92, WL95, EGH94, PR96, Ruf95, CBC93, MLR + 93] </ref> for C/C ++ handle exceptions. However, unlike in C ++ , exceptions are frequently used in Java programs, making it an important problem for Java. <p> It operates on an ICFG and is similar to the Landi-Ryder algorithm <ref> [LR92] </ref> for alias analysis, but instead of aliases, it computes points-tos. In Section 6, we will extend this algorithm to handle exceptions. 3.1 Lattice for data-flow analysis In order to restrict data-flow only to realizable paths, points-tos are computed conditioned on assumed-points-tos (akin to reaching alias in [LR92] [PR96]), which represent <p> the Landi-Ryder algorithm <ref> [LR92] </ref> for alias analysis, but instead of aliases, it computes points-tos. In Section 6, we will extend this algorithm to handle exceptions. 3.1 Lattice for data-flow analysis In order to restrict data-flow only to realizable paths, points-tos are computed conditioned on assumed-points-tos (akin to reaching alias in [LR92] [PR96]), which represent points-tos reaching the entry of a method, and approximate the calling context in which the method has been called (see the example in Appendix A). A points-to along with its assumed-points-to is called a conditional-points-to. <p> This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions. This way of maintaining context is similar to Landi-Ryder's <ref> [LR92] </ref> method of storing context using reaching aliases, except that our algorithm uses points-tos rather than aliases. Our algorithm also differs from approaches like [PS91, Age95] in being intraprocedurally flow-sensitive. 10 Conclusion In this paper, we have studied the complexity of CTI for a subset of Java, which includes exceptions.
Reference: [MLR + 93] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. Choi, M. Burke, and P. Carini. </author> <title> Pointer-induced aliasing: A clarification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(9) </volume> <pages> 67-70, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches [Ste96, SH97, ZRL96, And94], which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches <ref> [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95] </ref>, which are the most precise, but also the most expensive. Approaches like [PS91, PC94, Age95] are in between the above two extremes. <p> The complexity of flow-sensitive CTI in the presence of exceptions has not been studied previously. None of the previous flow-sensitive pointer analysis algorithms <ref> [LR92, WL95, EGH94, PR96, Ruf95, CBC93, MLR + 93] </ref> for C/C ++ handle exceptions. However, unlike in C ++ , exceptions are frequently used in Java programs, making it an important problem for Java. <p> This work takes state-of-the-art in pointer analysis one step further by handling exceptions. Our algorithm differs from other pointer analysis and CTI algorithms <ref> [EGH94, WL95, Ruf95, PC94, PS91, CBC93, MLR + 93] </ref> in the way it maintains context-sensitivity by associating assumed-points-tos with each data-flow element, rather than using some approximation of the call stack. This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions.
Reference: [Pap94] <author> C. H. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Recall that non-deterministic log-space is the set of languages accepted by nondeterministic Turing machines using logarithmic space <ref> [Pap94] </ref> and NC is the class of efficiently parallelizable problems which contains non-deterministic log-space. Proof Given a program point l in a method M and a points-to u, to check whether u holds at l, we non-deterministically (i.e., predecessors are chosen non-deterministically) search backwards starting at l. <p> Hence, it is enough to show that intraprocedural TIA is in NPSPACE. Our proof is similar to Bill Landi's proof [Lan92a] that PTA is in NPSPACE. We present a non-deterministic algorithm for TIA, which uses polynomial amount 13 languages accepted by non-deterministic Turing machines using polynomial amount of space <ref> [Pap94] </ref>. 16 of space. The input to the algorithm is the CFG of a method M, a node l in the CFG and a points-to hp, obj i.
Reference: [PC94] <author> J. Plevyak and A. Chien. </author> <title> Precise concrete type inference for object oriented languages. </title> <booktitle> In Proceeding of Conference on Object-Oriented Program 34 ming Systems, Languages and Applications (OOPSLA '94), </booktitle> <pages> pages 324-340, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95], which are the most precise, but also the most expensive. Approaches like <ref> [PS91, PC94, Age95] </ref> are in between the above two extremes. An intraprocedurally flow-insensitive algorithm does not distinguish between program points within a method; hence it reports the same solution for all program points within each method. <p> This work takes state-of-the-art in pointer analysis one step further by handling exceptions. Our algorithm differs from other pointer analysis and CTI algorithms <ref> [EGH94, WL95, Ruf95, PC94, PS91, CBC93, MLR + 93] </ref> in the way it maintains context-sensitivity by associating assumed-points-tos with each data-flow element, rather than using some approximation of the call stack. This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions.
Reference: [PR96] <author> Hemant Pande and Barbara G. Ryder. </author> <title> Data-flow-based virtual function res olution. </title> <booktitle> In LNCS 1145, Proceedings of the Third International Symposium on Static Analysis, </booktitle> <year> 1996. </year>
Reference-contexts: The complexity of flow-sensitive CTI in the presence of exceptions has not been studied previously. None of the previous flow-sensitive pointer analysis algorithms <ref> [LR92, WL95, EGH94, PR96, Ruf95, CBC93, MLR + 93] </ref> for C/C ++ handle exceptions. However, unlike in C ++ , exceptions are frequently used in Java programs, making it an important problem for Java. <p> In Section 6, we will extend this algorithm to handle exceptions. 3.1 Lattice for data-flow analysis In order to restrict data-flow only to realizable paths, points-tos are computed conditioned on assumed-points-tos (akin to reaching alias in [LR92] <ref> [PR96] </ref>), which represent points-tos reaching the entry of a method, and approximate the calling context in which the method has been called (see the example in Appendix A). A points-to along with its assumed-points-to is called a conditional-points-to. <p> Since any user defined exception type has to extend the Exception class, we do not rule out subtyping completely when we say exceptions without subtyping. 15 <ref> [PR96] </ref> contains an NP-hardness proof for a more restricted case. 18 What is meant is that if there is a user defined variable v of exception type e, no object whose type is a proper subtype of e (i.e. its class extends e) is allocated in the program. 6.1 Algorithm for
Reference: [PS91] <author> J. Palsberg and M. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proceedings of Conference on Object-Oriented Programming Systems, Lan guages, and Applications (OOPSLA '91), </booktitle> <pages> pages 146-161, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95], which are the most precise, but also the most expensive. Approaches like <ref> [PS91, PC94, Age95] </ref> are in between the above two extremes. An intraprocedurally flow-insensitive algorithm does not distinguish between program points within a method; hence it reports the same solution for all program points within each method. <p> This work takes state-of-the-art in pointer analysis one step further by handling exceptions. Our algorithm differs from other pointer analysis and CTI algorithms <ref> [EGH94, WL95, Ruf95, PC94, PS91, CBC93, MLR + 93] </ref> in the way it maintains context-sensitivity by associating assumed-points-tos with each data-flow element, rather than using some approximation of the call stack. This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions. <p> This way of maintaining context is similar to Landi-Ryder's [LR92] method of storing context using reaching aliases, except that our algorithm uses points-tos rather than aliases. Our algorithm also differs from approaches like <ref> [PS91, Age95] </ref> in being intraprocedurally flow-sensitive. 10 Conclusion In this paper, we have studied the complexity of CTI for a subset of Java, which includes exceptions. The complexity of CTI in the presence of exceptions has not been studied before. The following are the main contributions of this paper: 1.
Reference: [RHS95] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analy sis via graph reachability. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <year> 1995. </year>
Reference-contexts: In contrast, an intraprocedurally flow-sensitive algorithm tries to compute different solutions for distinct program points. The example in Figure 5 in Appendix C illustrates this difference. An interprocedurally flow-sensitive (i.e. context-sensitive) algorithm considers (sometimes approximately) only interprocedurally realizable paths <ref> [RHS95, LR91] </ref>: paths along which calls and returns are properly matched, while an inter-procedurally flow-insensitive (i.e. context-insensitive) algorithm does not make this distinction. The example in Figure 6 in Appendix C illustrates this difference. <p> We will show that the basic algorithm's worst-case complexity in this case is O (n 5 ), hence this case is in P. This an improvement over O (n 7 ) worst-case bound achievable by applying previous approaches of <ref> [RHS95] </ref> and [LR91] to this case. 6 Our proof is strongly influenced by a similar proof for aliases in [LR91]. 7 // initialize worklist. <p> If a conditional-points-to hz, u i 9 is computed by the algorithm at l, then there exists a rp (r,t,p,l,M) such that u holds at l, and 7 + indicates concatenation. 8 Every entry-node along it has a matching exit-node except possibly for the entry node of M <ref> [RHS95] </ref>. 9 z could be empty. 8 void process exit node ( exit node, ndf elm ) f // Let M be the method containing the exit node. if ( ndf elm represents the value of a local variable ) // it need not be forwarded to the successors (return-nodes of <p> A proof that CTI for programs with only single-level types and without exceptions or dynamic dispatch can be solved in O (n 5 ) time. This an improvement over the O (n 7 ) worst-case bound achievable by applying previous approaches of <ref> [RHS95] </ref> and [LR91] to this case. 33 6. A proof that intraprocedural CTI for programs with only single-level types and without exceptions or dynamic dispatch is in non-deterministic log-space and hence NC.
Reference: [Ruf95] <author> E. Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming language design and im plementation, </booktitle> <pages> pages 13-22, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches [Ste96, SH97, ZRL96, And94], which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches <ref> [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95] </ref>, which are the most precise, but also the most expensive. Approaches like [PS91, PC94, Age95] are in between the above two extremes. <p> The complexity of flow-sensitive CTI in the presence of exceptions has not been studied previously. None of the previous flow-sensitive pointer analysis algorithms <ref> [LR92, WL95, EGH94, PR96, Ruf95, CBC93, MLR + 93] </ref> for C/C ++ handle exceptions. However, unlike in C ++ , exceptions are frequently used in Java programs, making it an important problem for Java. <p> This work takes state-of-the-art in pointer analysis one step further by handling exceptions. Our algorithm differs from other pointer analysis and CTI algorithms <ref> [EGH94, WL95, Ruf95, PC94, PS91, CBC93, MLR + 93] </ref> in the way it maintains context-sensitivity by associating assumed-points-tos with each data-flow element, rather than using some approximation of the call stack. This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions.
Reference: [SH97] <author> M. Shapiro and S. Horwitz. </author> <title> Fast and accurate flow-insensitive points-to analysis. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <year> 1997. </year>
Reference-contexts: Although some of these have been used for pointer analysis of C, they can be adapted for CTI of Java without exceptions and threads, or C ++ without exceptions. At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches <ref> [Ste96, SH97, ZRL96, And94] </ref>, which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95], which are the most precise, but also the most expensive.
Reference: [Ste96] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <year> 1996. </year>
Reference-contexts: Although some of these have been used for pointer analysis of C, they can be adapted for CTI of Java without exceptions and threads, or C ++ without exceptions. At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches <ref> [Ste96, SH97, ZRL96, And94] </ref>, which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95], which are the most precise, but also the most expensive.
Reference: [WL95] <author> Robert P. Wilson and Monica S. Lam. </author> <title> Efficient context-sensitive pointer analysis for c programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming language design and implementation, </booktitle> <pages> pages 1-12, </pages> <year> 1995. </year>
Reference-contexts: At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches [Ste96, SH97, ZRL96, And94], which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches <ref> [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95] </ref>, which are the most precise, but also the most expensive. Approaches like [PS91, PC94, Age95] are in between the above two extremes. <p> The complexity of flow-sensitive CTI in the presence of exceptions has not been studied previously. None of the previous flow-sensitive pointer analysis algorithms <ref> [LR92, WL95, EGH94, PR96, Ruf95, CBC93, MLR + 93] </ref> for C/C ++ handle exceptions. However, unlike in C ++ , exceptions are frequently used in Java programs, making it an important problem for Java. <p> This work takes state-of-the-art in pointer analysis one step further by handling exceptions. Our algorithm differs from other pointer analysis and CTI algorithms <ref> [EGH94, WL95, Ruf95, PC94, PS91, CBC93, MLR + 93] </ref> in the way it maintains context-sensitivity by associating assumed-points-tos with each data-flow element, rather than using some approximation of the call stack. This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions.
Reference: [ZRL96] <author> S. Zhang, B. G. Ryder, and W. Landi. </author> <title> Program decomposition for pointer aliasing: A step towards practical analyses. </title> <booktitle> In Proceedings of the 4th Sym posium on the Foundations of Software Engineering, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: Although some of these have been used for pointer analysis of C, they can be adapted for CTI of Java without exceptions and threads, or C ++ without exceptions. At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches <ref> [Ste96, SH97, ZRL96, And94] </ref>, which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95], which are the most precise, but also the most expensive.
References-found: 24

