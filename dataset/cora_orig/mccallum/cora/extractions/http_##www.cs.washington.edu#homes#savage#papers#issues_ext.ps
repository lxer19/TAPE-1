URL: http://www.cs.washington.edu/homes/savage/papers/issues_ext.ps
Refering-URL: http://www.cs.washington.edu/homes/savage/
Root-URL: 
Title: Issues in the Design of an Extensible Operating System  
Author: Stefan Savage and Brian N. Bershad 
Date: June 28, 1994  
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: Extensible operating systems are designed around the principle that a system can be dynamically customized to best serve application needs. However, realizing this goal in a safe and efficient manner poses a number of unique problems. In this paper, we examine the requirements for constructing robust extensible systems and discuss implementation techniques to satisfy those requirements with low overhead.
Abstract-found: 1
Intro-found: 1
Reference: [Andert 94] <author> Andert, G. </author> <title> Object frameworks in the Taligent OS. </title> <booktitle> Proceedings of the Spring 1994 COMPCON Conference, </booktitle> <month> February </month> <year> 1994. </year>
Reference-contexts: Some frameworks however can simplify the construction of an incremental interface. Most notably, object-based and delegation-based interfaces have been shown to facilitate small changes <ref> [Andert 94, Khalidi & Nelson 93] </ref> when extensions are trusted. Their utility with untrusted extensions remains in question, however as they do not provide a complete solution [Steinberg 94]. Incrementality is not a natural by-product of a system's overall gross structure.
Reference: [Barnes 93] <author> Barnes, G. </author> <title> A method for implementing lock-free data structures. </title> <booktitle> In Proceedings of the 5th ACM Symposium on Parallel Algorithms & Architecture, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: With an untrusted extension, the lock may be taken out of order, taken not at all, or never relinquished. The compiler can apply mechanisms such as locks, wait-free synchronization or transactional memory which relieve the programmer from the responsibility of correctly managing synchronization state <ref> [Herlihy 90, Barnes 93] </ref>. For example, if the compiler can determine that a code segment accessing a shared data structure executes in bounded time, it can insert a locking protocol into the code sequence.
Reference: [Bershad et al. 90] <author> Bershad, B. N., Anderson, T. E., Lazowska, E. D., and Levy, H. M. </author> <title> Lightweight Remote Procedure Call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 37-55, </pages> <month> February </month> <year> 1990. </year> <booktitle> Also appeared in Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1989. </year>
Reference-contexts: Runtime processing and overhead is impossible to avoid when checking references on array bounds. An alternative is to rely on hardware memory protection mechanisms, which can provide inexpensive coarse-grain protection. However, hardware protection mechanisms can incur a significant cost when changing protection domains, even when heavily optimized <ref> [Bershad et al. 90] </ref>. In contrast, domain switching with software methods can be inexpensive [Wahbe et al. 93].
Reference: [Bershad et al. 94] <author> Bershad, B. N., Chambers, C., Eggers, S., Maeda, C., McNamee, D., Pardyak, P., Savage, S., and Sirer, E. G. </author> <title> SPIN An Extensible Microkernel for Application-specific Operating System Services. </title> <booktitle> In Proceedings of the 1994 European SIGOPS Workshop, </booktitle> <month> September </month> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: Government. 1 We are currently building an extensible operating system in which we are attempting to address the problems raised by the need for generalized extensibility <ref> [Bershad et al. 94] </ref>. In our system, application programs dynamically extend the set of services provided by the operating system by installing new code at runtime. In designing our system, we have found that an extensible system must at once satisfy three goals: * Incrementality.
Reference: [Black et al. 92] <editor> Black, D. L. et al. </editor> <booktitle> Microkernel Operating System Architecture and Mach. In Proceedings of the Usenix Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 11-30, </pages> <month> April </month> <year> 1992. </year> <month> 7 </month>
Reference-contexts: Consequently, an extensible operating system must provide a software infrastructure into which new components can be installed as though they were part of the native system. In general, operating systems have attempted to provide extensibility through some sort of protection mechanism, such as capabilities [Levy 84], IPC <ref> [Black et al. 92, Rozier et al. 88] </ref>, or special compilers, linkers, or interpreters [Mogul et al. 87, Wahbe et al. 93]. In practice though, the protection mechanism by itself has proven insufficient to support general extensibility.
Reference: [Cao 94] <author> Cao, P. </author> <type> Personal communication. </type> <month> May </month> <year> 1994. </year>
Reference-contexts: The size of the imposed extension, relative to the core system services, is likely to be small either because it represents an incremental extension to another service, or because it provides a control and data conduit to a larger extension that is itself protected with hardware mechanisms <ref> [Cao 94, Yuhara et al. 94] </ref>.
Reference: [Draves 93] <author> Draves, R. </author> <title> The Case for Run-Time Replaceable Kernel Modules. </title> <booktitle> In Proceedings of the Fourth Workshop on Workstation Operating Systems, </booktitle> <pages> pages 160-164, </pages> <year> 1993. </year>
Reference-contexts: though comes at a substantial cost: any application can crash another application, or the system; applications that work in isolation may cease to work when run in combination; and the lack of any defined interface to either operating system services, or operating system extensibility, has created a system configuration nightmare <ref> [Draves 93] </ref>. We address this issue in the next section. 4 Correctness An extensible system provides a namespace into which existing operating system code and new extensions can be introduced. In the case of MS-DOS, a single, shared address space containing all user and system code offers that namespace.
Reference: [Druschel 94] <author> Druschel, P. </author> <title> Efficient Support for Incremental Customization of OS Services. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Arizona, </institution> <year> 1994. </year>
Reference-contexts: For example, a powerful IPC mechanism, although necessary for communicating with a file server in user space, is not sufficient for changing the semantics or performance characteristics of that file server without large amounts of effort <ref> [Druschel 94] </ref>. The server, and the environment in which the server operates, must be amenable to change, which an IPC mechanism permits, but does not guarantee.
Reference: [Engler et al. 94] <author> Engler, D., Kaashoek, M. F., and O'Toole, J. </author> <title> The Operating System Kernel as a Secure Programmable Machine. </title> <booktitle> In Proceedings of the 1994 European SIGOPS Workshop, </booktitle> <month> September </month> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: As a result of these kinds of technical and administrative prohibitions, demanding applications, such as database, distributed transactions, parallel processing, and multimedia, are forced to rely on the "out of the box" interfaces and implementations when others may be more appropriate for reasons of performance, portability, interoperability, or data integrity <ref> [Kiczales et al. 93, Engler et al. 94] </ref>. 2 3 Incrementality and interfaces A key issue in the design and use of an extensible system is the ease with which changes to system behavior can be applied, or its incrementality.
Reference: [Hastings & Joyce 92] <author> Hastings, R. and Joyce, B. Purify: </author> <title> Fast Detection of Memory Leaks and Access Errors. </title> <booktitle> In Proceedings of the Winter 1992 USENIX Conference, </booktitle> <pages> pages 125-136, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: The constraint itself can be enforced by a mechanism, for example, memory protection, which in turn has any one of a number of implementations, such as hardware memory management, software fault isolation <ref> [Wahbe et al. 93, Hastings & Joyce 92] </ref> or language support [Mogul et al. 87]. Ensuring correctness strictly with protection mechanisms is not straightforward.
Reference: [Herlihy 90] <author> Herlihy, M. </author> <title> A Methodology for Implementing Highly Concurrent Structures. </title> <booktitle> Proceedings of the 2nd ACM SIG-PLAN Symposium on Principles & Practice of Parallel Programming, </booktitle> <month> March </month> <year> 1990. </year>
Reference-contexts: With an untrusted extension, the lock may be taken out of order, taken not at all, or never relinquished. The compiler can apply mechanisms such as locks, wait-free synchronization or transactional memory which relieve the programmer from the responsibility of correctly managing synchronization state <ref> [Herlihy 90, Barnes 93] </ref>. For example, if the compiler can determine that a code segment accessing a shared data structure executes in bounded time, it can insert a locking protocol into the code sequence.
Reference: [Hutchinson & Peterson 88] <author> Hutchinson, N. C. and Peterson, L. L. </author> <booktitle> Design of the x-Kernel. In Proceedings of the SIGCOMM '88 Symposiumy, </booktitle> <pages> pages 65-75, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: While this structure ultimately worked, the unconventional protocol splice was the source of many bugs in the initial implementation. In contrast, a protocol architecture such as the x-kernel <ref> [Hutchinson & Peterson 88] </ref>, which allows designers to construct a protocol graph from small components, exhibits substantially more incrementality. 1 Interfaces to hardware An important class of software interfaces in an extensible system are those that provide access to the raw hardware.
Reference: [Hutchinson 87] <author> Hutchinson, N. C. </author> <title> Emerald: An Object-Based Language for Distributed Programming. </title> <type> PhD dissertation, </type> <institution> University of Washington Dept. of Computer Science and Engineering, </institution> <month> January </month> <year> 1987. </year> <institution> Department of Computer Science technical report 87-01-01. </institution>
Reference-contexts: For example, if the compiler can determine that a code segment accessing a shared data structure executes in bounded time, it can insert a locking protocol into the code sequence. The compiler can also cooperate with the run-time system to ensure that extensions execute for bounded periods of time <ref> [Hutchinson 87] </ref>. A second advantage of automation using the language and compiler is that it facilitates static enforcement of the protection mechanisms, that is, it can verify code.
Reference: [Khalidi & Nelson 93] <author> Khalidi, Y. A. and Nelson, M. N. </author> <title> An Implementation of UNIX on an Object-Oriented Operating System. </title> <booktitle> In Proceedings of the 1993 Winter USENIX Conference, </booktitle> <pages> pages 469-480, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Some frameworks however can simplify the construction of an incremental interface. Most notably, object-based and delegation-based interfaces have been shown to facilitate small changes <ref> [Andert 94, Khalidi & Nelson 93] </ref> when extensions are trusted. Their utility with untrusted extensions remains in question, however as they do not provide a complete solution [Steinberg 94]. Incrementality is not a natural by-product of a system's overall gross structure.
Reference: [Kiczales et al. 91] <author> Kiczales, G., des Rivieres, J., and Bobrow, D. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In designing our system, we have found that an extensible system must at once satisfy three goals: * Incrementality. Small changes to the system's behavior can be affected with small amounts of code <ref> [Kiczales et al. 91] </ref>. * Correctness. An extension provided by an application should not compromise the overall integrity of the system. * Efficiency. The potential for an extension should incur no overhead.
Reference: [Kiczales et al. 93] <author> Kiczales, G., Lamping, J., Maeda, C., Keppel, D., and McNamee, D. </author> <title> The Need for Customizable Operating Systems. </title> <booktitle> In Proceedings of the Fourt Workshop on Workstation Operating Systems, </booktitle> <pages> pages 165-169, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: As a result of these kinds of technical and administrative prohibitions, demanding applications, such as database, distributed transactions, parallel processing, and multimedia, are forced to rely on the "out of the box" interfaces and implementations when others may be more appropriate for reasons of performance, portability, interoperability, or data integrity <ref> [Kiczales et al. 93, Engler et al. 94] </ref>. 2 3 Incrementality and interfaces A key issue in the design and use of an extensible system is the ease with which changes to system behavior can be applied, or its incrementality.
Reference: [Kleiman 86] <author> Kleiman, S. R. Vnodes: </author> <title> An Architecture for Multiple File System Types in Sun UNIX. </title> <booktitle> In Proceedings of the 1986 USENIX Conference, </booktitle> <pages> pages 238-247, </pages> <year> 1986. </year>
Reference-contexts: For example, extending a file system to support data compression cannot be easily accomplished in terms of basic device access interfaces. Interfaces to software Interfaces to software resources such as file systems, network protocols, or process management do not naturally exhibit incrementality. The UNIX Vnode interface <ref> [Kleiman 86] </ref> offers an example of an interface that exhibits some, but not complete, incrementality. With it, it is possible to define an entirely new file system without having to change the disk device driver or the system's exported file system interface.
Reference: [Le*er & McKusick 91] <author> Le*er, S. J. and McKusick, M. K. </author> <title> The Design and Implementation of the 4.3BSD UNIX Operating System Answer Book. </title> <publisher> Addison-Wesley Publishing, </publisher> <year> 1991. </year>
Reference-contexts: Of course, few users are actually capable of negotiating through system build procedures [ODE 91], let alone writing new code for the system <ref> [Le*er et al. 89, Le*er & McKusick 91, Pietrek 93] </ref>. Moreover, security and integrity concerns generally make arbitrary user extensions unacceptable, either on a personal computer [Livingston 94], on a shared machine, or even a machine on a shared network.
Reference: [Le*er et al. 89] <author> Le*er, S. J., McKusick, M. K., Karels, M. J., and Quarterman, J. S. </author> <title> The Design and Implementation of the 4.3BSD UNIX Operating System. </title> <publisher> Addison-Wesley Publishing, </publisher> <year> 1989. </year>
Reference-contexts: Of course, few users are actually capable of negotiating through system build procedures [ODE 91], let alone writing new code for the system <ref> [Le*er et al. 89, Le*er & McKusick 91, Pietrek 93] </ref>. Moreover, security and integrity concerns generally make arbitrary user extensions unacceptable, either on a personal computer [Livingston 94], on a shared machine, or even a machine on a shared network.
Reference: [Levy 84] <author> Levy, H. M. </author> <title> Capability-Based Computer Systems. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: Consequently, an extensible operating system must provide a software infrastructure into which new components can be installed as though they were part of the native system. In general, operating systems have attempted to provide extensibility through some sort of protection mechanism, such as capabilities <ref> [Levy 84] </ref>, IPC [Black et al. 92, Rozier et al. 88], or special compilers, linkers, or interpreters [Mogul et al. 87, Wahbe et al. 93]. In practice though, the protection mechanism by itself has proven insufficient to support general extensibility.
Reference: [Livingston 94] <author> Livingston, B. </author> <title> Window manager: Black screen of death. </title> <address> InfoWord, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Of course, few users are actually capable of negotiating through system build procedures [ODE 91], let alone writing new code for the system [Le*er et al. 89, Le*er & McKusick 91, Pietrek 93]. Moreover, security and integrity concerns generally make arbitrary user extensions unacceptable, either on a personal computer <ref> [Livingston 94] </ref>, on a shared machine, or even a machine on a shared network. For example, in our shared computing environment, Macintosh users are not allowed to share the same physical network as Unix users because of a history of network problems introduced by Macintosh extensions.
Reference: [Maeda & Bershad 93] <author> Maeda, C. and Bershad, B. N. </author> <title> Protocol Service Decomposition for High-Performance Networking. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 244-255, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Incrementality is not a natural by-product of a system's overall gross structure. Recently, for example, there have been efforts to migrate code from the operating system into a user's application directly through the use of operating system libraries <ref> [Maeda & Bershad 93, Thekkath et al. 93] </ref>. Library-level networking protocols place the bulk of the BSD UDP/IP and TCP/IP protocol stacks into a library that can be linked with the application.
Reference: [McNamee 94] <author> McNamee, D. Supremo: </author> <title> Increaing the Flexibility and Performance of Virtual Memory. </title> <type> Technical Report UW-TR-94-07-01, </type> <institution> University of Washington Dept. of Computer Science and Engineering, </institution> <year> 1994. </year>
Reference-contexts: However, if an application is only concerned with deter-mining if a particular page is presently in core, then it must either provide its own external pager in entirety, or it must rely on a different underlying virtual memory interface <ref> [McNamee 94] </ref>. 3.1 Extensibility namespaces Fundamentally, incremental extension requires fine grained decomposition of an implementation such that the structure provides convenient "hooks" for extension code. Together, these hooks define the namespace into which extensions can be installed. The size of this namespace determines a system's extensibility.
Reference: [Mogul et al. 87] <author> Mogul, J. C., Rashid, R. F., and Accetta, M. J. </author> <title> The Packet Filter: An Efficient Mechanism for User-level Network Code. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: In general, operating systems have attempted to provide extensibility through some sort of protection mechanism, such as capabilities [Levy 84], IPC [Black et al. 92, Rozier et al. 88], or special compilers, linkers, or interpreters <ref> [Mogul et al. 87, Wahbe et al. 93] </ref>. In practice though, the protection mechanism by itself has proven insufficient to support general extensibility. <p> The constraint itself can be enforced by a mechanism, for example, memory protection, which in turn has any one of a number of implementations, such as hardware memory management, software fault isolation [Wahbe et al. 93, Hastings & Joyce 92] or language support <ref> [Mogul et al. 87] </ref>. Ensuring correctness strictly with protection mechanisms is not straightforward. For each system interface exposed to an extension, be it a hardware or software interface, it is necessary to define the constraints governing the use, but preventing the misuse of that interface.
Reference: [Nelson et al. 88] <author> Nelson, M. N., Welch, B. B., and Ousterhout, J. K. </author> <title> Caching in the Sprite Network File System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 134-154, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: As a motivating example from the distributed systems domain, the NFS interface, which is stateless, does not rely on the correct functioning of clients [Sandberg 85]. In contrast, the interface to the Sprite file system, which is not stateless, does rely on the correct functioning of clients <ref> [Nelson et al. 88] </ref>. With a stateless interface, the client of the interface (an extension) is responsible for maintaining all state and for passing pieces of it across the interface as needed.
Reference: [ODE 91] <institution> Open Software Foundation. ODE Manula Pages, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: Given the source code, or a binary interface, any user can write new operating system code for an application, build it into a new kernel, install, and reboot. Of course, few users are actually capable of negotiating through system build procedures <ref> [ODE 91] </ref>, let alone writing new code for the system [Le*er et al. 89, Le*er & McKusick 91, Pietrek 93]. Moreover, security and integrity concerns generally make arbitrary user extensions unacceptable, either on a personal computer [Livingston 94], on a shared machine, or even a machine on a shared network.
Reference: [Pietrek 93] <author> Pietrek, M. </author> <title> Windows Internals. </title> <publisher> Addison-Wesley Publishing, </publisher> <year> 1993. </year>
Reference-contexts: Of course, few users are actually capable of negotiating through system build procedures [ODE 91], let alone writing new code for the system <ref> [Le*er et al. 89, Le*er & McKusick 91, Pietrek 93] </ref>. Moreover, security and integrity concerns generally make arbitrary user extensions unacceptable, either on a personal computer [Livingston 94], on a shared machine, or even a machine on a shared network.
Reference: [Rozier et al. 88] <author> Rozier, M., Abrossimov, V., Armand, F., Boule, I., Giend, M., Guillemont, M., Herrmann, F., Leonard, P., Langlois, S., and Neuhauser, W. </author> <title> The Chorus Distributed Operating System. </title> <journal> Computing Systems, </journal> <volume> 1(4), </volume> <year> 1988. </year>
Reference-contexts: Consequently, an extensible operating system must provide a software infrastructure into which new components can be installed as though they were part of the native system. In general, operating systems have attempted to provide extensibility through some sort of protection mechanism, such as capabilities [Levy 84], IPC <ref> [Black et al. 92, Rozier et al. 88] </ref>, or special compilers, linkers, or interpreters [Mogul et al. 87, Wahbe et al. 93]. In practice though, the protection mechanism by itself has proven insufficient to support general extensibility.
Reference: [Sandberg 85] <author> Sandberg, R. </author> <title> Design and Implementation of the Sun Network Filesystem. </title> <booktitle> Proc. USENIX 1985 Summer Conf. USENIX Association, </booktitle> <pages> pages 35-50, </pages> <year> 1985. </year>
Reference-contexts: One strategy that appears promising is to define stateless interfaces that impose no constraints on the caller. As a motivating example from the distributed systems domain, the NFS interface, which is stateless, does not rely on the correct functioning of clients <ref> [Sandberg 85] </ref>. In contrast, the interface to the Sprite file system, which is not stateless, does rely on the correct functioning of clients [Nelson et al. 88].
Reference: [Steinberg 94] <author> Steinberg, S. G. </author> <title> Corba. </title> <journal> Wired, </journal> <volume> 2(7), </volume> <year> 1994. </year>
Reference-contexts: Most notably, object-based and delegation-based interfaces have been shown to facilitate small changes [Andert 94, Khalidi & Nelson 93] when extensions are trusted. Their utility with untrusted extensions remains in question, however as they do not provide a complete solution <ref> [Steinberg 94] </ref>. Incrementality is not a natural by-product of a system's overall gross structure. Recently, for example, there have been efforts to migrate code from the operating system into a user's application directly through the use of operating system libraries [Maeda & Bershad 93, Thekkath et al. 93].
Reference: [Thekkath et al. 93] <author> Thekkath, C. A., Nguyen, T. D., Moy, E., and Lazowska, E. D. </author> <title> Implementing network protocols at user level. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(5) </volume> <pages> 554-565, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Incrementality is not a natural by-product of a system's overall gross structure. Recently, for example, there have been efforts to migrate code from the operating system into a user's application directly through the use of operating system libraries <ref> [Maeda & Bershad 93, Thekkath et al. 93] </ref>. Library-level networking protocols place the bulk of the BSD UDP/IP and TCP/IP protocol stacks into a library that can be linked with the application.
Reference: [Wahbe et al. 93] <author> Wahbe, R., Lucco, S., Anderson, T. E., and Graham, S. L. </author> <title> Efficient Software-Based Fault Isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: In general, operating systems have attempted to provide extensibility through some sort of protection mechanism, such as capabilities [Levy 84], IPC [Black et al. 92, Rozier et al. 88], or special compilers, linkers, or interpreters <ref> [Mogul et al. 87, Wahbe et al. 93] </ref>. In practice though, the protection mechanism by itself has proven insufficient to support general extensibility. <p> The constraint itself can be enforced by a mechanism, for example, memory protection, which in turn has any one of a number of implementations, such as hardware memory management, software fault isolation <ref> [Wahbe et al. 93, Hastings & Joyce 92] </ref> or language support [Mogul et al. 87]. Ensuring correctness strictly with protection mechanisms is not straightforward. <p> An alternative is to rely on hardware memory protection mechanisms, which can provide inexpensive coarse-grain protection. However, hardware protection mechanisms can incur a significant cost when changing protection domains, even when heavily optimized [Bershad et al. 90]. In contrast, domain switching with software methods can be inexpensive <ref> [Wahbe et al. 93] </ref>. This suggests that software mechanisms for isolating memory references are most effective when they protect code: * which is frequently invoked (because then the invocation overhead is low), * which executes for a short period of time (because then the absolute cost of protection is low).
Reference: [Wing 90] <author> Wing, J. M. </author> <title> A Specifier's Introduction to Formal Methods. </title> <journal> IEEE Compter, </journal> <volume> 23(9) </volume> <pages> 10-22, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: extension is correct before it is ever installed, and protection, which attempts to ensure that an extension behaves correctly after it is installed, and bounds the damage done if it does not. 4.1 Verification Verification may involve software verification techniques that statically prove the correctness of a piece of code <ref> [Wing 90] </ref> or simply an administrative decision that the code is trusted. Software verification techniques do not provide a complete or general purpose solution because the complexity of programs that can be entirely verified this way is restricted.
Reference: [Young et al. 87] <author> Young, M., Tevanian, A., Rashid, R., Golub, D., Eppinger, J., Chew, J., Bolosky, W., Black, D., and Baron, R. </author> <title> The Duality of Memory and Communication in the implementation of a Multiprocessor Operating System. </title> <booktitle> In The Proceedings of the 11th Symposium on Operating System Principles, </booktitle> <month> November </month> <year> 1987. </year>
Reference-contexts: Mach's external pager interface offers another example of an interface that exhibits some, but not complete, incrementality <ref> [Young et al. 87] </ref>.
Reference: [Yuhara et al. 94] <author> Yuhara, M., Bershad, B. N., Maeda, C., and Moss, J. E. B. </author> <title> Efficient Packet Demultiplexing for Multiple Endpoints and Large Messages. </title> <booktitle> In Proceedings of the 1994 Winter USENIX Conference, </booktitle> <month> January </month> <year> 1994. </year> <month> 8 </month>
Reference-contexts: The size of the imposed extension, relative to the core system services, is likely to be small either because it represents an incremental extension to another service, or because it provides a control and data conduit to a larger extension that is itself protected with hardware mechanisms <ref> [Cao 94, Yuhara et al. 94] </ref>.
References-found: 35

