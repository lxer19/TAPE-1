URL: http://www.csl.sri.com/~bruno/publis/qmw_csd736.ps.gz
Refering-URL: http://www.csl.sri.com/~bruno/publis.html
Root-URL: 
Email: e-mail: bruno@dcs.qmw.ac.uk  e-mail: steve@dcs.rhbnc.ac.uk  
Title: Embedding CSP in PVS. An Application to Authentication Protocols  
Author: Bruno Dutertre Steve Schneider 
Address: Mile End Road, London E1 4NS, UK  College,  TW20 0EX,  
Affiliation: Department of Computer Science Queen Mary and Westfield College, University of London  Dept. of Computer Science, Queen Mary and Westfield  Dept. of Computer Science, Royal Holloway, Egham, Surrey  
Date: May 7, 1997  
Pubnum: Technical Report 736  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Lamport. </author> <title> Conjoining Specifications. </title> <type> Technical Report 118, </type> <institution> Digital Equipment Corporation, System Research Center, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: By induction, this implies all the messages circulating in the network have positive rank. The lemma is similar to Abadi and Lamport's decomposition technique for invariant properties based on assumption/guarantee specifications <ref> [1] </ref>. <p> INIT) nonpositive_rank3 : LEMMA non_positive (rho, T3). 44 interface userA : |------- f1g subset?(sigma (userA), LocalEvents (a)) Rule? (AUTO-REWRITE "local transmission" "local reception" "interface pref [event]" "interface stop [event]") Installing automatic rewrites from: local transmission local reception interface pref [event] interface stop [event] this simplifies to: interface userA : |------- <ref> [1] </ref> subset?(sigma (userA), LocalEvents (a)) Rule? (EXPAND "userA") Expanding the definition of userA, this simplifies to: interface userA : |------- f1g subset?(sigma (Choice! i, xn: (trans (a, i, pub (i, conc (Na, Ia))) &gt;> (rec (a, i, pub (a, conc (Na, xn))) &gt;> (trans (a, i, pub (i, xn)) &gt;> Stop
Reference: [2] <author> P. B. Andrews. </author> <title> An Introduction to Mathematical Logic and Type Theory: To Truth through Proof. </title> <publisher> Academic Press, </publisher> <year> 1986. </year>
Reference-contexts: PVS is an interactive prover based on a form of higher order logic and is largely similar to other systems such as HOL [12], Isabelle/HOL [25] or IMPS [9]. Nonetheless, PVS supports a richer type system than standard higher order logic (as presented in <ref> [2] </ref> for example) and relies on an original approach to type checking. The PVS logic includes subtypes and dependent types and these features render type checking undecidable; the type checker may require users to show that their specifications are type consistent by generating proof obligations known as TCCs 1 . <p> The proof of validity rho starts by (rewrite "rank valid"). This yields the two following subgoals: validity_rho.1 : |------- -1- (FORALL (m1: message), (m2: message): rho (conc (m1, m2)) &gt; 0 &lt;=&gt; rho (m1) &gt; 0 AND rho (m2) &gt; 0) <ref> [2] </ref> FORALL S, m: positive (rho, S) AND (S |- m) IMPLIES rho (m) &gt; 0 validity_rho.2 : |------- -1- (FORALL (m: message), (k: key): rho (m) &gt; 0 AND rho (k) &gt; 0 IMPLIES rho (crypto (k, m)) &gt; 0) [2] FORALL S, m: positive (rho, S) AND (S |- <p> rho (m1) &gt; 0 AND rho (m2) &gt; 0) <ref> [2] </ref> FORALL S, m: positive (rho, S) AND (S |- m) IMPLIES rho (m) &gt; 0 validity_rho.2 : |------- -1- (FORALL (m: message), (k: key): rho (m) &gt; 0 AND rho (k) &gt; 0 IMPLIES rho (crypto (k, m)) &gt; 0) [2] FORALL S, m: positive (rho, S) AND (S |- m) IMPLIES rho (m) &gt; 0 and both are proved by (delete 2)(grind). 5.3.3 Rank Preservation Properties So far, all the proofs are routine; they mostly use automatic rewriting and decision procedures.
Reference: [3] <author> S. H. Brackin. </author> <title> Deciding Cryptographic Protocol Adequacy with HOL: </title> <booktitle> The Implementation. In TPHOLs'96, </booktitle> <pages> pages 61-76. </pages> <publisher> Springer-Verlag, LNCS 1125, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: We end up with [-1] rho (pub (a, conc (Na, nx!1))) &gt; 0 |------- -1- R3 (trans (a, i!2, pub (i!2, nx!1))) -2- rho (pub (i!2, nx!1)) &gt; 0 <ref> [3] </ref> R3 (rec (a, i!2, pub (a, conc (Na, nx!1)))) [4] R3 (trans (a, i!2, pub (i!2, conc (Na, Ia)))) where all process expressions have been eliminated. Formulas [3] and [4] are clearly false and can be deleted, then we apply (grind) which yields: --1- x_nonce (nx!1) = nb |------- -1- <p> (a, conc (Na, nx!1))) &gt; 0 |------- -1- R3 (trans (a, i!2, pub (i!2, nx!1))) -2- rho (pub (i!2, nx!1)) &gt; 0 <ref> [3] </ref> R3 (rec (a, i!2, pub (a, conc (Na, nx!1)))) [4] R3 (trans (a, i!2, pub (i!2, conc (Na, Ia)))) where all process expressions have been eliminated. Formulas [3] and [4] are clearly false and can be deleted, then we apply (grind) which yields: --1- x_nonce (nx!1) = nb |------- -1- trans (a, i!2, code (public (i!2), nx!1)) = trans (a, i!2, code (public (i!2), nonce (nb))) -2- i!2 = a. <p> Compared with the these works our main contribution is to have used the PVS embedding to a specific class of problems, namely the verification of authentication protocols. Apart from existing mechanization of belief logics such as described in <ref> [3] </ref>, tool support in this area, has mostly concentrated on analysing security protocols by searching for or attempting to construct attacks [16, 19, 14, 27]. The results of this kind of analysis is either the successful discovery of an attack, or else a bald statement that none can be found.
Reference: [4] <author> J. Bryans and S. Schneider. </author> <title> Mechanical Verification of the full Needham-Schroeder public key protocol. </title> <type> Technical report, </type> <institution> Royal Holloway, University of London, </institution> <year> 1997. </year> <note> in preparation. </note>
Reference-contexts: We end up with [-1] rho (pub (a, conc (Na, nx!1))) &gt; 0 |------- -1- R3 (trans (a, i!2, pub (i!2, nx!1))) -2- rho (pub (i!2, nx!1)) &gt; 0 [3] R3 (rec (a, i!2, pub (a, conc (Na, nx!1)))) <ref> [4] </ref> R3 (trans (a, i!2, pub (i!2, conc (Na, Ia)))) where all process expressions have been eliminated. Formulas [3] and [4] are clearly false and can be deleted, then we apply (grind) which yields: --1- x_nonce (nx!1) = nb |------- -1- trans (a, i!2, code (public (i!2), nx!1)) = trans (a, <p> (Na, nx!1))) &gt; 0 |------- -1- R3 (trans (a, i!2, pub (i!2, nx!1))) -2- rho (pub (i!2, nx!1)) &gt; 0 [3] R3 (rec (a, i!2, pub (a, conc (Na, nx!1)))) <ref> [4] </ref> R3 (trans (a, i!2, pub (i!2, conc (Na, Ia)))) where all process expressions have been eliminated. Formulas [3] and [4] are clearly false and can be deleted, then we apply (grind) which yields: --1- x_nonce (nx!1) = nb |------- -1- trans (a, i!2, code (public (i!2), nx!1)) = trans (a, i!2, code (public (i!2), nonce (nb))) -2- i!2 = a. <p> The full seven message Needham-Schroeder protocol which includes communication with the server has now been analysed <ref> [4] </ref> and the verification discussed in this paper extended very cleanly to the full version. In conclusion, we have presented viable mechanical support in PVS for the verification of security protocols with respect to authentication properties.
Reference: [5] <author> M. Burrows, M. Abadi, and R. Needham. </author> <title> A Logic of Authentication. </title> <type> Technical Report 39, </type> <institution> Digital Equipment Corporation, System Research Center, </institution> <month> February </month> <year> 1989. </year>
Reference: [6] <author> A. J. Camilleri. </author> <title> Mechanizing CSP trace theory in higher order logic. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 993-1004, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: We made some adjustments to the CSP variant used by introducing unbounded parallel composition and by using a restriction operator in order to simplify the statement and proof of important theorems. Other mechanizations of CSP with theorem provers can be found in the literature. Camilleri <ref> [6] </ref> presents a mechanization of CSP in HOL. The construction is similar to ours; it is a semantic embedding of the traces model but it also includes a HOL representation of the CSP syntax. There are minor differences in the CSP dialect considered and in the representation of events.
Reference: [7] <author> J. Crow, S. Owre, J. Rushby, N. Shankar, and M. Srivas. </author> <title> A tutorial introduction to PVS. </title> <booktitle> In WIFT'95 Workshop on Industrial-Strength Formal Specification Techniques, </booktitle> <month> April </month> <year> 1995. </year>
Reference: [8] <author> D. Dolev and A. C. Yao. </author> <title> On the Security of Public Key Protocols. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 29(2), </volume> <year> 1983. </year>
Reference-contexts: not directly interact with each other but their composition synchronise with F IF O on all events of the form in:x or out:y. 2.2 A general model for authentication protocols The approach proposed in [28] for analysing authentication protocols assumes a general network architecture, a variant of the Dolev-Yao model <ref> [8] </ref>. The network consists of a set of user processes which execute the protocol and an enemy which has full control over the communication medium. The users communicate with each other by sending messages through the insecure medium and the enemy can block, re-address, duplicate, and fake messages.
Reference: [9] <author> W. M. Farmer, J. D. Guttman, and F. J. Thayer. imps: </author> <title> An Interactive Mathematical Proof System. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 11 </volume> <pages> 213-248, </pages> <year> 1993. </year> <month> 60 </month>
Reference-contexts: In this section, we show how the necessary mechanical support can be provided by the PVS theorem prover. PVS is an interactive prover based on a form of higher order logic and is largely similar to other systems such as HOL [12], Isabelle/HOL [25] or IMPS <ref> [9] </ref>. Nonetheless, PVS supports a richer type system than standard higher order logic (as presented in [2] for example) and relies on an original approach to type checking.
Reference: [10] <author> Formal Systems (Europe) Ltd. </author> <title> Failure Divergence Refinement User Manual and Tutorial, </title> <year> 1993. </year>
Reference-contexts: In order to overcome these difficulties, some form of mechanical support is desirable. A tool can help produce all the constraints a rank function must satisfy and can detect errors or omissions during proofs. There exist specialised proof tools for CSP such as the model checker FDR <ref> [26, 10] </ref> which has been used in various applications, including the analysis of security protocols [17, 16]. <p> While this approach has had some high-profile successes, an inability to find attacks does not in itself guarantee correctness of the protocol. For example, in the CSP based approach to searching for attacks, the model-checking tool FDR <ref> [10] </ref> is deployed. Model-checking of a system relies on the finitary nature of its state space, so its relationship with the infinite possibilities of attacks (such as arise from such aspects as the possibility of arbitrary depths of encryption and combining of messages), is far from trivial.
Reference: [11] <author> D. Gollmann. </author> <title> What do we mean by Entity Authentication. </title> <booktitle> In IEEE Symposium on Security and Privacy, </booktitle> <year> 1996. </year>
Reference: [12] <author> M.J.C. Gordon and T.F. Melham. </author> <title> Introduction to HOL. A theorem proving environment for higher order logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: In this section, we show how the necessary mechanical support can be provided by the PVS theorem prover. PVS is an interactive prover based on a form of higher order logic and is largely similar to other systems such as HOL <ref> [12] </ref>, Isabelle/HOL [25] or IMPS [9]. Nonetheless, PVS supports a richer type system than standard higher order logic (as presented in [2] for example) and relies on an original approach to type checking.
Reference: [13] <author> C. A .R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1985. </year>
Reference-contexts: In the simplest model, the so-called trace semantics, processes are characterised by the sequences of events they may engage in. This is sufficient for investigating safety properties. Other models can distinguish between processes according to non-deterministic and divergence properties and are useful for studying liveness properties <ref> [13] </ref>. In this paper, only the trace model of CSP is considered. We assume that a fixed set of all possible events is given and each process is characterised by a set of finite sequences of elements of . <p> The semantic models ensure that all such recursive definitions are well founded. Any system of equations of the above form has at least one solution given by a least fixed point construction <ref> [13] </ref>. Furthermore, if all the CSP expressions in the right hand side of equations are guarded then the solution is unique. <p> In our framework, E can be any set of traces and, in particular, E can be a process. In this case, the symbol |&gt; can be interpreted as the classic refinement relation between CSP processes (see <ref> [13] </ref>). but useful properties. Lemmas sat choice1 or sat choice3 are two examples of PVS rewrite rules; they are the PVS counterparts of general proof rules of CSP.
Reference: [14] <author> R. Kemmerer, C. Meadows, and Millen J. </author> <title> Three systems for cryptographic analysis. </title> <journal> Journal of Cryptology, </journal> <volume> 7(2), </volume> <year> 1994. </year>
Reference-contexts: Apart from existing mechanization of belief logics such as described in [3], tool support in this area, has mostly concentrated on analysing security protocols by searching for or attempting to construct attacks <ref> [16, 19, 14, 27] </ref>. The results of this kind of analysis is either the successful discovery of an attack, or else a bald statement that none can be found.
Reference: [15] <author> R. Lazic and A. W. Roscoe. </author> <title> Using Logical Relations for Automated Verification of Data-independent CSP. </title> <booktitle> Electronic Notes in Theoretical Computer Science, </booktitle> <volume> 5, </volume> <year> 1997. </year>
Reference-contexts: Lowe [17] is considering a proof strategy based on the general form of a protocol run for establishing when absence of an attack on a finite state space is sufficient to establish that no attack exists in the infinite state space. Lazic and Roscoe <ref> [15] </ref> are developing a theory of data-independence which establishes conditions for results concerning a finite data space to extend to an arbitrary data space. Both of these approaches will give conditions for the results of model-checking on a restricted form of a protocol to extend to a fuller version.
Reference: [16] <author> G. Lowe. </author> <title> An attack on the Needham-Schroeder public-key authentication protocol. </title> <journal> Information Processing Letters, </journal> <volume> 56 </volume> <pages> 131-133, </pages> <year> 1995. </year>
Reference-contexts: A tool can help produce all the constraints a rank function must satisfy and can detect errors or omissions during proofs. There exist specialised proof tools for CSP such as the model checker FDR [26, 10] which has been used in various applications, including the analysis of security protocols <ref> [17, 16] </ref>. <p> The corresponding private key is denoted by K 1 x and we have the identity: ffmg K x g K 1 x = ffmg K 1 x g K x = m: Recently, Lowe has discovered a potential weakness in the above protocol <ref> [16, 17] </ref>. <p> Apart from existing mechanization of belief logics such as described in [3], tool support in this area, has mostly concentrated on analysing security protocols by searching for or attempting to construct attacks <ref> [16, 19, 14, 27] </ref>. The results of this kind of analysis is either the successful discovery of an attack, or else a bald statement that none can be found.
Reference: [17] <author> G. Lowe. </author> <title> Breaking and Fixing the Needham-Schroeder Public-Key Protocol Using FDR. </title> <booktitle> In Proc. of TACAS'96, </booktitle> <pages> pages 147-166. </pages> <publisher> Springer-Verlag, LNCS 1055, </publisher> <year> 1996. </year>
Reference-contexts: A tool can help produce all the constraints a rank function must satisfy and can detect errors or omissions during proofs. There exist specialised proof tools for CSP such as the model checker FDR [26, 10] which has been used in various applications, including the analysis of security protocols <ref> [17, 16] </ref>. <p> The corresponding private key is denoted by K 1 x and we have the identity: ffmg K x g K 1 x = ffmg K 1 x g K x = m: Recently, Lowe has discovered a potential weakness in the above protocol <ref> [16, 17] </ref>. <p> Whether this can qualify as an attack depends on the goal for which the protocol is used. This is certainly an oddity which can be easily corrected as Lowe <ref> [17] </ref> indicates: 1 A ! B : fN a ; Ag K b 3 A ! B : fN b g K b : All the examples presented in [28] are based on these two variants of Needham-Schroeder, most of them on Lowe's improved version. <p> Model-checking of a system relies on the finitary nature of its state space, so its relationship with the infinite possibilities of attacks (such as arise from such aspects as the possibility of arbitrary depths of encryption and combining of messages), is far from trivial. Lowe <ref> [17] </ref> is considering a proof strategy based on the general form of a protocol run for establishing when absence of an attack on a finite state space is sufficient to establish that no attack exists in the infinite state space.
Reference: [18] <author> C. Meadows. </author> <title> Applying formal methods to the analysis of a key management protocol. </title> <journal> Journal of Computer Security, </journal> <volume> 1(1), </volume> <year> 1992. </year>
Reference-contexts: He does not use an explicit rank function as we do, but he also aims to prove that particular messages can never occur in a trace, and this requires certain lemmas establishing that particular classes of message cannot occur. This is also a feature of the approach taken in <ref> [18] </ref>, which applies language theory to establish that particular terms cannot be generated using given production rules. Mechanical assistance for proofs is invaluable, and Paulson has some useful results concerning reusability of proof strategies.
Reference: [19] <author> J. Millen. </author> <title> The interrogator model. </title> <booktitle> In IEEE Symposium on Research in Security and Privacy, </booktitle> <year> 1995. </year>
Reference-contexts: Apart from existing mechanization of belief logics such as described in [3], tool support in this area, has mostly concentrated on analysing security protocols by searching for or attempting to construct attacks <ref> [16, 19, 14, 27] </ref>. The results of this kind of analysis is either the successful discovery of an attack, or else a bald statement that none can be found.
Reference: [20] <author> R. M. Needham and M. D. Schroeder. </author> <title> Using Encryption for Authentication in Large Networks of Computers. </title> <journal> Communications of the ACM, </journal> <volume> 21(12) </volume> <pages> 993-999, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: The full protocol is described in <ref> [20] </ref> and involves two principals A and B and a server S for distributing public keys.
Reference: [21] <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference: [22] <author> S. Owre, N. Shankar, and J. M. Rushby. </author> <title> The PVS Specification Language. </title> <institution> Computer Science Lab., SRI International, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: Many aspects of PVS are not covered in this document; a more complete description of the language and prover as well as examples of applications can be found elsewhere <ref> [22, 29] </ref>. In a first step, we need to develop a PVS representation of the CSP notion of processes. Since we are concerned exclusively with CSP trace semantics, an obvious choice is to represent processes by prefix-closed sets of traces. Traces themselves can be simply considered as lists of events.
Reference: [23] <author> L. Paulson. </author> <title> Proving Properties of Security Protocols by Induction. </title> <type> Technical Report TR409, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <month> December </month> <year> 1996. </year>
Reference-contexts: Both of these approaches will give conditions for the results of model-checking on a restricted form of a protocol to extend to a fuller version. Closer to our approach is that of Paulson <ref> [23, 24] </ref>, who has investigated the application of the proof tool Isabelle/HOL to proving security properties of proto 58 cols. He specifies security protocols in terms of traces of the system as a whole.
Reference: [24] <author> L. Paulson. </author> <title> Mechanised Proofs of Security Protocols: Needham-Schroeder with Public Keys. </title> <type> Technical Report TR413, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: Both of these approaches will give conditions for the results of model-checking on a restricted form of a protocol to extend to a fuller version. Closer to our approach is that of Paulson <ref> [23, 24] </ref>, who has investigated the application of the proof tool Isabelle/HOL to proving security properties of proto 58 cols. He specifies security protocols in terms of traces of the system as a whole.
Reference: [25] <author> Lawrence C. Paulson. </author> <title> A formulation of the simple theory of types (for Is-abelle). </title> <editor> In P. Martin-Lof and G. Mints, editors, </editor> <booktitle> Proceedings of the International Conference on Computer Logic COLOG'88, </booktitle> <pages> pages 246-274, </pages> <address> Tallinn, Estonia, </address> <month> December </month> <year> 1988. </year> <note> Springer-Verlag LNCS 417. </note>
Reference-contexts: In this section, we show how the necessary mechanical support can be provided by the PVS theorem prover. PVS is an interactive prover based on a form of higher order logic and is largely similar to other systems such as HOL [12], Isabelle/HOL <ref> [25] </ref> or IMPS [9]. Nonetheless, PVS supports a richer type system than standard higher order logic (as presented in [2] for example) and relies on an original approach to type checking.
Reference: [26] <author> A. W. Roscoe. </author> <title> Model-checking CSP. </title> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: In order to overcome these difficulties, some form of mechanical support is desirable. A tool can help produce all the constraints a rank function must satisfy and can detect errors or omissions during proofs. There exist specialised proof tools for CSP such as the model checker FDR <ref> [26, 10] </ref> which has been used in various applications, including the analysis of security protocols [17, 16].
Reference: [27] <author> A. W. Roscoe. </author> <title> Modelling and verifying key-exchange protocols using CSP and FDR. </title> <booktitle> In Proc. of CSFW8. </booktitle> <publisher> IEEE Press, </publisher> <year> 1995. </year> <month> 61 </month>
Reference-contexts: Apart from existing mechanization of belief logics such as described in [3], tool support in this area, has mostly concentrated on analysing security protocols by searching for or attempting to construct attacks <ref> [16, 19, 14, 27] </ref>. The results of this kind of analysis is either the successful discovery of an attack, or else a bald statement that none can be found.
Reference: [28] <author> S. Schneider. </author> <title> Using CSP for protocol analysis: the Needham-Schroeder Public Key Protocol. </title> <type> Technical Report CSD-TR-96-14, </type> <institution> Royal Holloway, University of London, </institution> <month> November </month> <year> 1996. </year>
Reference-contexts: out]j F IF O: In this expression, CON SU M ER and P RODU CER do not directly interact with each other but their composition synchronise with F IF O on all events of the form in:x or out:y. 2.2 A general model for authentication protocols The approach proposed in <ref> [28] </ref> for analysing authentication protocols assumes a general network architecture, a variant of the Dolev-Yao model [8]. The network consists of a set of user processes which execute the protocol and an enemy which has full control over the communication medium. <p> Hence, if an event of T occurs in tr, it is preceded by an event of R. Different authentication properties can all be formally expressed as "T authenticates R" for adequately chosen sets T and R <ref> [28] </ref>. <p> It follows that condition (1) is equivalent to N ET j [R]j Stop sat trT = hi: (2) The latter property can be verified using a rank function as shown in <ref> [28] </ref>. The idea is to assign to every message m an integer (m) called its rank in such a way that messages in T have non positive rank while only messages of positive rank can be produced by N ET j [R]j Stop. <p> This is certainly an oddity which can be easily corrected as Lowe [17] indicates: 1 A ! B : fN a ; Ag K b 3 A ! B : fN b g K b : All the examples presented in <ref> [28] </ref> are based on these two variants of Needham-Schroeder, most of them on Lowe's improved version. All the verifications have been mechanically checked with PVS. <p> This is property (7) of <ref> [28] </ref>. The stronger property where A knows that the nonce was produced by B does not hold; this is the weakness identified by Lowe. We start by declaring the identities of the two agents and the two nonces N a and N b . <p> In the last command, we apply manually the rule interface choice3; PVS finds a match and the resulting formula is reduced to true by automatic rewriting. 5.3.2 Rank Function In order to verify the authentication property, we use the following rank function, given in <ref> [28] </ref>: rank_code (k, n) : int = CASES k OF public (z) : IF z = a THEN n + 1 ELSE n ENDIF, secret (z) : IF z = a THEN n - 1 ELSE n ENDIF ENDCASES rho (m) : RECURSIVE int = CASES m OF text (z) : <p> Algebraic properties of cryptographic mechanisms (such as commutativity of encryption, or distributivity of encryption over concatenation) have to be given explicitly as equations on the message space. The CSP approach of <ref> [28] </ref> remains valid in the presence of such equations, and the only additional proof obligation is to ensure that the rank function is well-defined: since rank functions are generally defined inductively, it is required to establish that the same message constructed two different ways should have the same rank function whichever <p> We envisage to construct enough PVS theories to allow us to manipulate quotient types. This would enable the representation of messages by equivalence classes of an abstract data type and would rejoin the original approach of <ref> [28] </ref>. Another important avenue to explore will be the extent to which construction of the rank function can be assisted by the attempt to provide a PVS proof.
Reference: [29] <author> N. Shankar, S. Owre, and J. M. Rushby. </author> <title> The PVS Proof Checker: A reference Manual. </title> <institution> Computer Science Lab., SRI International, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Many aspects of PVS are not covered in this document; a more complete description of the language and prover as well as examples of applications can be found elsewhere <ref> [22, 29] </ref>. In a first step, we need to develop a PVS representation of the CSP notion of processes. Since we are concerned exclusively with CSP trace semantics, an obvious choice is to represent processes by prefix-closed sets of traces. Traces themselves can be simply considered as lists of events.
Reference: [30] <author> J. U. Skakkebk and N. Shankar. </author> <title> Towards a duration calculus proof assistant in PVS. In Formal Techniques in Real-time and Fault-Tolerant Systems. </title> <publisher> Springer-Verlag, LNCS 863, </publisher> <month> September </month> <year> 1994. </year>
Reference-contexts: However, such extensions would require considerably more work for a relatively little gain. Other formalisms than CSP have been embedded in PVS. As far as we are aware, the most extensive work in this area is the development of mechanical support for the duration calculus (DC) using PVS <ref> [30] </ref>. The approach used is largely similar to ours: the semantics of the duration calculus is directly defined in PVS. However, the embedding also includes a dedicated interface which makes the implementation largely transparent to users.
Reference: [31] <author> P. Syverson and P. van Oorschot. </author> <title> On Unifying Some Cryptographic Protocol Logics. </title> <booktitle> In Proc. of the 1994 IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 14-29, </pages> <year> 1994. </year>
Reference: [32] <author> F. J. Thayer. </author> <title> An approach to process algebra using imps. </title> <type> Technical Report MP-94B193, </type> <institution> The mitre Corporation, </institution> <year> 1994. </year> <month> 62 </month>
Reference-contexts: There are minor differences in the CSP dialect considered and in the representation of events. Due to the use of parameters, the PVS formalization seems more general and flexible. Thayer <ref> [32] </ref> uses a more general approach for representing CSP with the IMPS prover. The development relies on abstract monoids which can cover many variants of CSP including timed CSP.
References-found: 32

