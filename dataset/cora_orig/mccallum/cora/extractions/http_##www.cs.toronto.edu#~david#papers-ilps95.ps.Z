URL: http://www.cs.toronto.edu/~david/papers-ilps95.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/papers.html
Root-URL: 
Email: david@cis.ksu.edu  
Title: Top-Down beats Bottom-Up for Constraint Extensions of Datalog  
Author: David Toman 
Address: KS-66506  
Affiliation: Dept. of Comp. and Info. Sci. Kansas State University, Manhattan,  
Abstract: This paper proposes an efficient method for evaluating queries over constraint databases. The method is based on a combination of top-down resolution with memoing and closed form bottom-up evaluation. In this way top-down evaluation terminates for all queries for which the bottom-up evaluation also terminates. The main advantage of the proposed method is the direct use of partially instantiated queries without the need for rewriting of the original program. The evaluation algorithm automatically propagates the necessary constraints during the computation. In addition, top-down evaluation potentially allows the use of compilation techniques developed for compilers of logic programming languages, which can make query evaluation very efficient. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bancilhon F., Maier D., Sagiv Y., Ullman J. D. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proc. ACM Symposium on Principles of Database Systems, </booktitle> <year> 1986. </year>
Reference-contexts: However, such strategies fail to take into account the information contained in a partially instantiated query (i.e., they are not goal-oriented). There are two different approaches to solving this problem in the framework of standard Datalog: 1. Rewrite the program using Magic Set Transformation (MST) <ref> [1, 12] </ref> and sub sequently evaluate the transformed program bottom-up, and 2. Adopt a top-down evaluation strategy [3, 20] that is based on the resolution principle [11]. In this paper we consider mainly top-down resolution-based methods. <p> In the case of Datalog (i.e., the constraint class generated from the set fx = a : a 2 Ag) MST C reduces to the standard MST for Datalog <ref> [1] </ref>. Definition 4.2 (Adornment) Let G be an atom of arity k. An adornment A for this atom is a string over fb; f g of length k.
Reference: [2] <author> Bol, R, Degerstedt, L. </author> <title> The Underlying Search for Magic Templates and Tabulation. </title> <booktitle> Proc. International Conference on Logic Programming , 1993. </booktitle>
Reference: [3] <author> Clocksin, W. F., Mellish, C.S. </author> <title> Programming in Prolog. </title> <publisher> Springer Verlag 1987. </publisher>
Reference-contexts: There are two different approaches to solving this problem in the framework of standard Datalog: 1. Rewrite the program using Magic Set Transformation (MST) [1, 12] and sub sequently evaluate the transformed program bottom-up, and 2. Adopt a top-down evaluation strategy <ref> [3, 20] </ref> that is based on the resolution principle [11]. In this paper we consider mainly top-down resolution-based methods. However, the MST optimization for constraint deductive query languages will also be introduced for comparison purposes. <p> In this paper we consider mainly top-down resolution-based methods. However, the MST optimization for constraint deductive query languages will also be introduced for comparison purposes. It is well known that the standard top-down strategies, e.g., SLD-resolution <ref> [3] </ref>, despite their efficiency have a major drawback as query evaluation procedures: they lead to nontermination even in situations where bottom-up algorithms are guaranteed to terminate. Note also that breadth-first traversal of a SLD-tree does not guarantee termination in general.
Reference: [4] <author> Gao, H., Warren, D. S. </author> <title> A Powerful Evaluation Strategy For CLP Programs. </title> <booktitle> Proc. Intl. Workshop on Principles and Practice of Constraint Programming, </booktitle> <year> 1993. </year>
Reference-contexts: This dramatically increases the expressive power of the query language while preserving termination and efficiency. 2. The other direction is pursued in the area of (general) Logic Programming: In <ref> [4, 6, 10] </ref> top-down evaluation for constraint logic programs is proposed. However, in all cases, general constraint solving procedures are used. Thus these methods are not directly useful for query evaluation in constraint databases as the termination can not be guaranteed. The closest to our work is [4]. <p> However, in all cases, general constraint solving procedures are used. Thus these methods are not directly useful for query evaluation in constraint databases as the termination can not be guaranteed. The closest to our work is <ref> [4] </ref>. However, the method proposed there allows only propagation of constants (i.e., constraints of the form x = a); the constraint part of the query is essentially computed bottom-up. <p> However, the propagation of constraints at the time of goal resolution is reduced. The soundness and completeness properties are preserved by Lemma 3.9. The termination is guaranteed similarly to Theorem 3.12. In <ref> [4] </ref> the following version of this modification was presented: Action/Node Children Conditions Query projection body (G; B 1 ; : : : ; B k ; C) ! goal (G; B 1 ; true; B 2 ; : : : ; B k ; C) none In this case, there is
Reference: [5] <author> Jaffar J., Maher, M. J. </author> <title> Constraint Logic Programming: A Survey. </title> <journal> J. Logic Programming 1994, </journal> <volume> 19. 20 </volume> <pages> 503-581. </pages>
Reference-contexts: This definition is similar to the definition of Constraint Domain <ref> [5] </ref>. However, C contains only satisfiable constraints. The elements of C are used as a finite representation of the (possibly infinite) relations in a constraint database.
Reference: [6] <author> Johnson, M. </author> <title> Memoization in Constraint Logic Programming. </title> <booktitle> Proc. Intl. Workshop on Principles and Practice of Constraint Programming, </booktitle> <year> 1993. </year>
Reference-contexts: This dramatically increases the expressive power of the query language while preserving termination and efficiency. 2. The other direction is pursued in the area of (general) Logic Programming: In <ref> [4, 6, 10] </ref> top-down evaluation for constraint logic programs is proposed. However, in all cases, general constraint solving procedures are used. Thus these methods are not directly useful for query evaluation in constraint databases as the termination can not be guaranteed. The closest to our work is [4].
Reference: [7] <author> Kanellakis, P. C., Kuper, G. M., Revesz, </author> <title> P.Z . Constraint Query Languages, </title> <booktitle> Proc. 9th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pp 299-313, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction We propose a new method for evaluating deductive queries over constraint databases (i.e., where the constraints are used to represent the information stored in generalized relations <ref> [7] </ref>). The evaluation of queries in constraint databases is different from the one used in standard database systems. The constraints are used as the actual representation of the data stored in the database rather than as mere restrictions of the contents of otherwise ground relations. <p> In [22] a closed form bottom-up evaluation procedure for C ;&lt;Z = C &lt;Z [ C Z was developed including all the constraint operations as in Definition 2.2. We can also incorporate the dense order constraints over Q by a slight modification of constraint operations defined in <ref> [7] </ref>. All the above constraint classes are constraint-compact. <p> However, there are also constraint classes where all the constraint operations are defined, but which are not constraint-compact, e.g., the class generated from the set fx + c &lt; y : c 2 Zg (gap-order constraints with possibly negative size of the gap [14]) or the linear arithmetic constraints <ref> [7] </ref>. For such constraint classes termination can not be guaranteed for any query evaluation method. However, Constraint Memoing tries to eliminate the number of non-terminating queries in this case. Definition 2.5 (Datalog C Program) Let C be a class of constraints.
Reference: [8] <author> Kanellakis, P. C., Ramaswamy, S., Vengroff, D. E., Vitter, J. S. </author> <title> Indexing for Data Models with Constraints and Classes. </title> <booktitle> Proc. ACM Symposium on Principles of Database Systems, </booktitle> <pages> pp 233-243, </pages> <year> 1993. </year>
Reference-contexts: Storage and access methods. To achieve an efficient implementation of constraint databases, new storage management techniques have to be developed: access methods suitable for fast retrieval of the stored information, efficient updates of generalized relations, indexing techniques <ref> [8] </ref>, etc. Benchmarks. The performance of various implementations of Logic Programming languages (e.g., Prolog) is often judged by the performance on a standard benchmarks (e.g., nrev). We propose to develop similar benchmarks for query evaluation methods in constraint databases. The benchmarks should be independent of the particular class of constraints.
Reference: [9] <author> Kemp, D. B., Stuckey, P. J. </author> <title> Analysis based constraint query optimization. </title> <booktitle> Proc. International Conference on Logic Programming, </booktitle> <year> 1993. </year>
Reference-contexts: Recently, there have been several other attempts to make query evaluation in the presence of constraints efficient. There are two main directions of this research: 1. The first direction has its roots in the (deductive) database community: In <ref> [9, 12, 16, 17] </ref> techniques for pushing constraints present in the query are proposed. However, the goal of these methods is to preprocess the query (i.e., the goal and the rules) with respect to the given constraints for subsequent bottom-up evaluation.
Reference: [10] <author> Lim, P., Stuckey, P.J. </author> <title> A Constraint Logic Programming Shell. </title> <booktitle> PLILP 1990. </booktitle>
Reference-contexts: This dramatically increases the expressive power of the query language while preserving termination and efficiency. 2. The other direction is pursued in the area of (general) Logic Programming: In <ref> [4, 6, 10] </ref> top-down evaluation for constraint logic programs is proposed. However, in all cases, general constraint solving procedures are used. Thus these methods are not directly useful for query evaluation in constraint databases as the termination can not be guaranteed. The closest to our work is [4].
Reference: [11] <author> Lloyd, J. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Rewrite the program using Magic Set Transformation (MST) [1, 12] and sub sequently evaluate the transformed program bottom-up, and 2. Adopt a top-down evaluation strategy [3, 20] that is based on the resolution principle <ref> [11] </ref>. In this paper we consider mainly top-down resolution-based methods. However, the MST optimization for constraint deductive query languages will also be introduced for comparison purposes.
Reference: [12] <author> Mumick, I. S. </author> <title> Query Optimization in Deductive and Relational Databases. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1991. </year>
Reference-contexts: Recently, there have been several other attempts to make query evaluation in the presence of constraints efficient. There are two main directions of this research: 1. The first direction has its roots in the (deductive) database community: In <ref> [9, 12, 16, 17] </ref> techniques for pushing constraints present in the query are proposed. However, the goal of these methods is to preprocess the query (i.e., the goal and the rules) with respect to the given constraints for subsequent bottom-up evaluation. <p> However, such strategies fail to take into account the information contained in a partially instantiated query (i.e., they are not goal-oriented). There are two different approaches to solving this problem in the framework of standard Datalog: 1. Rewrite the program using Magic Set Transformation (MST) <ref> [1, 12] </ref> and sub sequently evaluate the transformed program bottom-up, and 2. Adopt a top-down evaluation strategy [3, 20] that is based on the resolution principle [11]. In this paper we consider mainly top-down resolution-based methods.
Reference: [13] <author> Ramakrishnan, R. </author> <title> Magic Templates. A spellbinding approach to logic programs. </title> <journal> J. Logic Programming 1991, </journal> <volume> 11 </volume> <pages> 189-216. </pages>
Reference-contexts: Arguments adorned by f are removed). For simplicity, only left-to-right SIPS 7 is used (rule 3 of the previous definition). This corresponds to the selection rule used in Constraint Memoing. In both cases different selection rules may improve the efficiency of query evaluation <ref> [13] </ref>. However, in the case on MST, the SIPS is fixed during the program transformation phase (and also there are difficulties with combining different SIPS in one program). <p> Analysis of binding patterns. Similarly to the MST transformation, the queries can be analyzed to determine the flow of information in clause bodies <ref> [13] </ref>. This is a considerably more complicated task in the presence of constraints: it is no longer sufficient to focus on single variables; the relationships between groups of variables have to be taken into consideration (as noted in Section 4).
Reference: [14] <author> Revesz, P. Z. </author> <title> A Closed Form Evaluation for Datalog Queries with Integer (Gap)-Order Constraints. </title> <journal> Theoretical Computer Science, </journal> <volume> vol. 116, no. 1, </volume> <pages> 117-149, </pages> <year> 1993. </year>
Reference-contexts: But neither of them seems to address all three requirements. The first approach is based on the fixpoint (bottom-up) evaluation of the rules. Here the first condition is usually met (e.g., for Datalog [23], Datalog with integer constraints <ref> [14, 22] </ref>, and sets [15]). However, the classes of allowed constraints are restricted to guarantee termination. Also, the evaluation process is not goal-oriented and thus the evaluation of partially instantiated queries is quite inefficient 1 . The other approach is based on resolution (top-down) method. <p> In the following text we omit the superscripts C . We also use a strict 3 version of ^ C . The following definition states a fundamental property of constraint classes on which the termination proofs of bottom-up query evaluation procedures are implicitly based <ref> [14, 15, 22, 23] </ref>. Definition 2.3 (Constraint-compact Class of Constraints) Let C be a class of constraints. <p> The evaluation remains unchanged as we use more general evaluation mechanism. Incorporation of more interesting constraints, e.g., constraints over integers (Z) is also easy: the gap-order constraints <ref> [14] </ref> are generated from the set C &lt;Z = fx &lt; u : u 2 Ag [ fu &lt; x : u 2 Ag [ fx + c &lt; y : c 2 Z + g. <p> However, there are also constraint classes where all the constraint operations are defined, but which are not constraint-compact, e.g., the class generated from the set fx + c &lt; y : c 2 Zg (gap-order constraints with possibly negative size of the gap <ref> [14] </ref>) or the linear arithmetic constraints [7]. For such constraint classes termination can not be guaranteed for any query evaluation method. However, Constraint Memoing tries to eliminate the number of non-terminating queries in this case. Definition 2.5 (Datalog C Program) Let C be a class of constraints. <p> Algorithm 2.9 was shown to be sound and complete for Datalog [23] and for Datalog &lt;;Z <ref> [14, 22] </ref>. A simple generalization of the proofs in [22] shows soundness and completeness for a general class C. Theorem 2.10 (Termination) Let C be a constraint-compact class of constraints. Then Algorithm 2.9 terminates for every query. <p> Note the essential use of constraint projection which allows to determine the relevant constraint for every atom. Also, SLG-resolution can handle negation (by use of additional rules). However, presence of negation together with constraints leads often to non-termination <ref> [14] </ref>. Thus our current proposal allows only positive programs. Adding negation is briefly discussed in section 6. <p> However, to prove termination (in both bottom-up and top-down cases) a finite encoding of a potentially infinite result of the evaluation is needed <ref> [14, 22] </ref>. Theorem 3.12 (Termination) If the class C is constraint-compact then the SLG C evaluation terminates for all queries (G; C; P ). P r o o f: Let C be a constraint-compact class of constraints. Then 1. <p> This condition is easy to satisfy in the case of finite domain constraints. However, for constraints over infinite domains (e.g., integers) this is often not possible (e.g., gap-order constraints over integers <ref> [14] </ref>). Storage and access methods. To achieve an efficient implementation of constraint databases, new storage management techniques have to be developed: access methods suitable for fast retrieval of the stored information, efficient updates of generalized relations, indexing techniques [8], etc. Benchmarks.
Reference: [15] <author> Srivastava, D., Ramakrishnan, R., Revesz, P. Z. </author> <title> Constraint Objects. </title> <booktitle> Proc. Intl. Workshop on Principles and Practice of Constraint Programming, </booktitle> <pages> 218-228, </pages> <year> 1994. </year>
Reference-contexts: But neither of them seems to address all three requirements. The first approach is based on the fixpoint (bottom-up) evaluation of the rules. Here the first condition is usually met (e.g., for Datalog [23], Datalog with integer constraints [14, 22], and sets <ref> [15] </ref>). However, the classes of allowed constraints are restricted to guarantee termination. Also, the evaluation process is not goal-oriented and thus the evaluation of partially instantiated queries is quite inefficient 1 . The other approach is based on resolution (top-down) method. Here the second and third conditions are usually met. <p> In the following text we omit the superscripts C . We also use a strict 3 version of ^ C . The following definition states a fundamental property of constraint classes on which the termination proofs of bottom-up query evaluation procedures are implicitly based <ref> [14, 15, 22, 23] </ref>. Definition 2.3 (Constraint-compact Class of Constraints) Let C be a class of constraints.
Reference: [16] <author> Srivastava, D., Ramakrishnan, R. </author> <title> Pushing Constraint Selections. </title> <journal> J. Logic Programming 1993:16:361-414, </journal> <year> 1993. </year>
Reference-contexts: Recently, there have been several other attempts to make query evaluation in the presence of constraints efficient. There are two main directions of this research: 1. The first direction has its roots in the (deductive) database community: In <ref> [9, 12, 16, 17] </ref> techniques for pushing constraints present in the query are proposed. However, the goal of these methods is to preprocess the query (i.e., the goal and the rules) with respect to the given constraints for subsequent bottom-up evaluation.
Reference: [17] <author> Stuckey, P. J., Sudarashan, S. </author> <title> Compiling Query Constraints. </title> <booktitle> Proc. ACM Symposium on Principles of Database Systems, </booktitle> <year> 1994. </year>
Reference-contexts: Recently, there have been several other attempts to make query evaluation in the presence of constraints efficient. There are two main directions of this research: 1. The first direction has its roots in the (deductive) database community: In <ref> [9, 12, 16, 17] </ref> techniques for pushing constraints present in the query are proposed. However, the goal of these methods is to preprocess the query (i.e., the goal and the rules) with respect to the given constraints for subsequent bottom-up evaluation.
Reference: [18] <author> Swift, T., Warren, D. S. </author> <title> Analysis of SLG-WAM Evaluation of Definite Programs. </title> <booktitle> Proc. 1994 International Logic Programming Symposium, </booktitle> <publisher> MIT Press, </publisher> <year> 1994, </year> <pages> 219-235. </pages>
Reference-contexts: Also, the evaluation process is not goal-oriented and thus the evaluation of partially instantiated queries is quite inefficient 1 . The other approach is based on resolution (top-down) method. Here the second and third conditions are usually met. However, termination for all queries is often sacrificed (an exception is <ref> [18] </ref>, where no constraints are allowed) in order to improve expressiveness and efficiency. These methods can also take full advantage of compilation techniques developed for other logic programming languages, e.g., 1 Application of program transformation techniques does not solve this problem in general. [19, 24]. <p> These methods can also take full advantage of compilation techniques developed for other logic programming languages, e.g., 1 Application of program transformation techniques does not solve this problem in general. [19, 24]. This greatly improves the (practical) efficiency of query evaluation <ref> [18] </ref> in the case of Datalog. We show that similar results can be achieved in the case of constraint databases as well. In this paper we try to combine the advantages of both approaches. <p> This has been observed in several papers, e.g., [20, 21] and an alternative to SLD-resolution was proposed (under various names). The main idea consists of remembering answers for already resolved subgoals. Such method also guarantees termination in the case of function-free logic programs <ref> [18] </ref>. We extend this method to constraint deductive queries while preserving termination and complexity bounds of bottom-up evaluation. 3 Top-down evaluation for Datalog C In the last section, bottom-up evaluation of Datalog C was defined in terms of elementary operations over a specific class of constraints.
Reference: [19] <author> Swift, T., Warren, D. S. </author> <title> An Abstract Machine for SLG Resolution: Definite Programs. </title> <booktitle> Proc. 1994 International Logic Programming Symposium, </booktitle> <publisher> MIT Press, </publisher> <year> 1994, </year> <pages> 633-652. </pages>
Reference-contexts: These methods can also take full advantage of compilation techniques developed for other logic programming languages, e.g., 1 Application of program transformation techniques does not solve this problem in general. <ref> [19, 24] </ref>. This greatly improves the (practical) efficiency of query evaluation [18] in the case of Datalog. We show that similar results can be achieved in the case of constraint databases as well. In this paper we try to combine the advantages of both approaches. <p> The performance of the Constraint Memoing can be boosted by utilizing the compilation methods developed in <ref> [19] </ref> and performance similar to ground Datalog can be expected. Future research in this area will focus on following issues: Compilation of constraints. To achieve an efficient implementation of Constraint Memoing, data structures for efficient representation of the constraints have to be developed.
Reference: [20] <author> Swift, T., Warren, D. S., Chen, W. </author> <title> Operational semantics of SLG evaluation. </title> <type> Tech. report, </type> <institution> SUNY at Stony Brook, </institution> <year> 1994. </year>
Reference-contexts: There are two different approaches to solving this problem in the framework of standard Datalog: 1. Rewrite the program using Magic Set Transformation (MST) [1, 12] and sub sequently evaluate the transformed program bottom-up, and 2. Adopt a top-down evaluation strategy <ref> [3, 20] </ref> that is based on the resolution principle [11]. In this paper we consider mainly top-down resolution-based methods. However, the MST optimization for constraint deductive query languages will also be introduced for comparison purposes. <p> Note also that breadth-first traversal of a SLD-tree does not guarantee termination in general. The drawback is caused by the occurrence of infinite paths in SLD search trees. This has been observed in several papers, e.g., <ref> [20, 21] </ref> and an alternative to SLD-resolution was proposed (under various names). The main idea consists of remembering answers for already resolved subgoals. Such method also guarantees termination in the case of function-free logic programs [18]. <p> This section shows, how a top-down evaluation procedure (SLG-resolution <ref> [20] </ref>) can be refined using the same operations to handle constraint queries. This approach allows us to build a very efficient top-down evaluation procedure for every class of constraints that has a closed form bottom-up evaluation procedure. Moreover the termination property of the bottom-up algorithm is preserved.
Reference: [21] <author> Tamaki, H., Sato, T. </author> <title> OLD-Resolution with Tabulation. </title> <booktitle> Proc. 3-rd International Conference on Logic Programming, </booktitle> <pages> 84-98, </pages> <year> 1986. </year>
Reference-contexts: Note also that breadth-first traversal of a SLD-tree does not guarantee termination in general. The drawback is caused by the occurrence of infinite paths in SLD search trees. This has been observed in several papers, e.g., <ref> [20, 21] </ref> and an alternative to SLD-resolution was proposed (under various names). The main idea consists of remembering answers for already resolved subgoals. Such method also guarantees termination in the case of function-free logic programs [18].
Reference: [22] <author> Toman, D., Chomicki, J., Rogers D. S. </author> <title> Datalog with Integer Periodicity Constraints. </title> <booktitle> Proc. 1994 International Logic Programming Symposium, </booktitle> <publisher> MIT Press, </publisher> <year> 1994, </year> <pages> 189-203. </pages>
Reference-contexts: But neither of them seems to address all three requirements. The first approach is based on the fixpoint (bottom-up) evaluation of the rules. Here the first condition is usually met (e.g., for Datalog [23], Datalog with integer constraints <ref> [14, 22] </ref>, and sets [15]). However, the classes of allowed constraints are restricted to guarantee termination. Also, the evaluation process is not goal-oriented and thus the evaluation of partially instantiated queries is quite inefficient 1 . The other approach is based on resolution (top-down) method. <p> However, while in the case of ground tuples (represented using equality constraints) constraint projection returns always only one constraint (tuple); in the case of more general constraints (e.g., <ref> [22] </ref>) constraint projection can return a set with more than one element. The last operation, con-straint subsumption, is used for elimination of duplicate answers, and in the case of Datalog reduces to checking for equality. <p> In the following text we omit the superscripts C . We also use a strict 3 version of ^ C . The following definition states a fundamental property of constraint classes on which the termination proofs of bottom-up query evaluation procedures are implicitly based <ref> [14, 15, 22, 23] </ref>. Definition 2.3 (Constraint-compact Class of Constraints) Let C be a class of constraints. <p> Similarly the periodicity constraints are generated from C Z = fx k c : c 2 Ag. In <ref> [22] </ref> a closed form bottom-up evaluation procedure for C ;&lt;Z = C &lt;Z [ C Z was developed including all the constraint operations as in Definition 2.2. We can also incorporate the dense order constraints over Q by a slight modification of constraint operations defined in [7]. <p> Algorithm 2.9 was shown to be sound and complete for Datalog [23] and for Datalog &lt;;Z <ref> [14, 22] </ref>. A simple generalization of the proofs in [22] shows soundness and completeness for a general class C. Theorem 2.10 (Termination) Let C be a constraint-compact class of constraints. Then Algorithm 2.9 terminates for every query. <p> Algorithm 2.9 was shown to be sound and complete for Datalog [23] and for Datalog &lt;;Z [14, 22]. A simple generalization of the proofs in <ref> [22] </ref> shows soundness and completeness for a general class C. Theorem 2.10 (Termination) Let C be a constraint-compact class of constraints. Then Algorithm 2.9 terminates for every query. <p> However, to prove termination (in both bottom-up and top-down cases) a finite encoding of a potentially infinite result of the evaluation is needed <ref> [14, 22] </ref>. Theorem 3.12 (Termination) If the class C is constraint-compact then the SLG C evaluation terminates for all queries (G; C; P ). P r o o f: Let C be a constraint-compact class of constraints. Then 1.
Reference: [23] <author> Ullman J. D. </author> <title> Principles of Database and Knowledge-base Systems, </title> <booktitle> Vol. 1,2. Computer Science Systems, </booktitle> <year> 1989. </year>
Reference-contexts: There exist two main approaches to satisfy the above requirements in the case of Datalog. But neither of them seems to address all three requirements. The first approach is based on the fixpoint (bottom-up) evaluation of the rules. Here the first condition is usually met (e.g., for Datalog <ref> [23] </ref>, Datalog with integer constraints [14, 22], and sets [15]). However, the classes of allowed constraints are restricted to guarantee termination. Also, the evaluation process is not goal-oriented and thus the evaluation of partially instantiated queries is quite inefficient 1 . The other approach is based on resolution (top-down) method. <p> Our approach allows full propagation of all possible constraints during the whole evaluation process (we compare the achieved efficiency of the two methods in section 5). In <ref> [23] </ref> the bottom-up approach (equipped with a query transformation phase) is shown to be no worse to the top-down approach for restricted classes of Datalog programs over ground relations. <p> In the following text we omit the superscripts C . We also use a strict 3 version of ^ C . The following definition states a fundamental property of constraint classes on which the termination proofs of bottom-up query evaluation procedures are implicitly based <ref> [14, 15, 22, 23] </ref>. Definition 2.3 (Constraint-compact Class of Constraints) Let C be a class of constraints. <p> query (G; C; P ) could be written as a SQL query select * from G where C that is evalueted in the database P . 3 I.e., ?-preserving. 2.1 Closed-form Bottom-up Evaluation The usual approach to query evaluation for Datalog C is a variation on the bottom-up evaluation algorithm <ref> [23] </ref>. In its simplest form a bottom-up evaluation algorithm is defined as follows: Definition 2.7 (Interpretation) Let R (x 1 ; : : :; x k ) be an atom and C 2 C a constraint such that F V (C) F V (R). <p> I := ; repeat J; I := I; TP C (I) while J 6= I return fC ^ D : (G; D) 2 Ig This arrangement also shows how other evaluation procedures based on TP can be utilized for constraint query evaluation (e.g., the semi-naive bottom-up evaluation <ref> [23] </ref>). Algorithm 2.9 was shown to be sound and complete for Datalog [23] and for Datalog &lt;;Z [14, 22]. A simple generalization of the proofs in [22] shows soundness and completeness for a general class C. Theorem 2.10 (Termination) Let C be a constraint-compact class of constraints. <p> C (I) while J 6= I return fC ^ D : (G; D) 2 Ig This arrangement also shows how other evaluation procedures based on TP can be utilized for constraint query evaluation (e.g., the semi-naive bottom-up evaluation <ref> [23] </ref>). Algorithm 2.9 was shown to be sound and complete for Datalog [23] and for Datalog &lt;;Z [14, 22]. A simple generalization of the proofs in [22] shows soundness and completeness for a general class C. Theorem 2.10 (Termination) Let C be a constraint-compact class of constraints. Then Algorithm 2.9 terminates for every query. <p> Then Algorithm 2.9 terminates for every query. All the constraint classes in Example 2.4 have a closed-form terminating bottom-up evaluation procedure (based on definitions 2.8 and 2.9). 2.2 Goal-oriented Evaluation Strategies There are several standard improvements to the naive bottom-up evaluation algorithm, e.g., the semi-naive algorithm <ref> [23] </ref>. However, such strategies fail to take into account the information contained in a partially instantiated query (i.e., they are not goal-oriented). There are two different approaches to solving this problem in the framework of standard Datalog: 1.
Reference: [24] <author> Warren, D. H. D. </author> <title> An Abstract Prolog Instruction Set, </title> <type> Tech. Report 309, </type> <institution> SRI International, AI Center, Palo Alto, </institution> <year> 1983. </year>
Reference-contexts: These methods can also take full advantage of compilation techniques developed for other logic programming languages, e.g., 1 Application of program transformation techniques does not solve this problem in general. <ref> [19, 24] </ref>. This greatly improves the (practical) efficiency of query evaluation [18] in the case of Datalog. We show that similar results can be achieved in the case of constraint databases as well. In this paper we try to combine the advantages of both approaches. <p> Also, the constraints specify complex relations between individual variables, which is not possible in the standard approach. Development of such representation enables building of very efficient query evaluation engines based on partial evaluation of the atomic constraints in a given class (similarly to the WAM abstract code <ref> [24] </ref>). Analysis of binding patterns. Similarly to the MST transformation, the queries can be analyzed to determine the flow of information in clause bodies [13].
References-found: 24

