URL: http://www.cs.iastate.edu/tech-reports/TR93-24a.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: 
Title: The Larch/Smalltalk Interface Specification Language TR93-24a  
Author: Yoonsik Cheon and Gary T. Leavens 
Address: 226 Atanasoff Ames, IA 50011  
Affiliation: Iowa State University of Science and Technology Department of Computer Science  
Date: May 17, 1994  
Abstract-found: 0
Intro-found: 1
Reference: [AG91] <author> Antonio J. Alencar and Joseph A. Goguen. </author> <title> OOZE: An object oriented Z environment. </title> <editor> In Pierre America, editor, </editor> <booktitle> ECOOP '91, European Conference on Object-Oriented Programming, </booktitle> <address> Geneva, Switzerland, </address> <month> July </month> <year> 1991, </year> <booktitle> Proceedings, volume 512 of Lecture Notes in Computer Science, </booktitle> <pages> pages 180-199. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Complex specifications are then constructed through class inheritance and instantiation. Its class model is also based on the idea of history which captures the sequence of operations and state changes undergone by an instance (object) of the class. The OOZE System <ref> [AG91] </ref>, based on Z and OBJ3, provides a powerful parameterization mechanism (modules, theories, views) as well as notions of objects, classes, and inheritance. Object-orientation was also attempted for the specification languages VDM [Bea88] and LOTOS [May88].
Reference: [Ame90] <author> Pierre America. </author> <title> A parallel object-oriented language with inheritance and subtyp-ing. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 161-168, </pages> <month> October </month> <year> 1990. </year> <booktitle> OOPSLA ECOOP '90 Proceedings, N. Meyrowitz (editor). </booktitle>
Reference-contexts: Formal requirements for such behavioral subtyping <ref> [Mey88a, LW90, Ame90, Lea91, LW93a, LW93b] </ref> involve either semantic modeling or theorem proving. The Larch proof assistant LP [GH93, Chapter 7], because it accepts LSL syntax, could be used to prove such properties. Larch/Smalltalk itself checks only for the traditional syntactic constraints, which we call the syntactic subtyping rule.
Reference: [Ame91] <author> Pierre America. </author> <title> Designing an object-oriented programming language with behavioral subtyping. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop No-ordwijkerhout, The Nertherlands, May 28-June 1, 1990, Proceedings, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pages 60-90. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In Larch/Smalltalk a type can be a subtype of more than one supertype, while in Smalltalk each class has only one superclass. To allow sound reasoning about programs that use sub-types, each object of such a subtype should behave like some object of each of its supertypes <ref> [Lea91, Ame91] </ref>. However, as verifying such behavioral constraints is more properly part 2 (right). <p> A superclass may specify that subclasses must define a method that a particular subclass does not define, or a subclass can redefine a method to make it inaccessible. We want specification inheritance to be based on behavior (subtyping), not implementation (subclassing) <ref> [Ame91, Coo89, LaL89] </ref>. * We want multiple inheritance of specifications; that is, we want a type to be a subtype of more than one type. <p> One way to ensure this is to define the trait functions that apply to abstract values of the subtype by a homomorphic coercion function from subtype abstract values to supertype abstract values <ref> [Rey80, GM87, BW90, Ame91] </ref>.
Reference: [Bea88] <author> Stephen Bear. </author> <title> Structuring for the VDM specification language. </title> <editor> In R. Bloomfield, L. Marshall, and R. Jones, editors, </editor> <title> VDM '88: VDM | The Way Ahead, </title> <booktitle> 2nd VDM-Europe Symposium, </booktitle> <address> Dublin, Ireland, </address> <month> September 11-16, </month> <year> 1988, </year> <booktitle> Proceedings, volume 328 of Lecture Notes in Computer Science, </booktitle> <pages> pages 2-25. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: The OOZE System [AG91], based on Z and OBJ3, provides a powerful parameterization mechanism (modules, theories, views) as well as notions of objects, classes, and inheritance. Object-orientation was also attempted for the specification languages VDM <ref> [Bea88] </ref> and LOTOS [May88]. In Fresco [Wil92], a programming environment for developing object-oriented software from specifications based on VDM, a class describes a specification, an implementation, or a mixture of two. A class is specified with model variables, invariants, and operation specifications.
Reference: [BW90] <author> Kim B. Bruce and Peter Wegner. </author> <title> An algebraic model of subtype and inheritance. </title> <editor> In Francois Ban~cilhon and Peter Buneman, editors, </editor> <booktitle> Advances in Database Programming Languages, </booktitle> <pages> pages 75-96. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <month> August </month> <year> 1990. </year>
Reference-contexts: One way to ensure this is to define the trait functions that apply to abstract values of the subtype by a homomorphic coercion function from subtype abstract values to supertype abstract values <ref> [Rey80, GM87, BW90, Ame91] </ref>.
Reference: [CDD + 89] <author> D. Carrington, D. Duke, R. Duke, P. King, G. Rose, and G. Smith. Object-Z: </author> <title> An object-oriented extension to Z. In Formal Description Techniques (FORTE '89), </title> <booktitle> Vancouver, </booktitle> <pages> pages 281-296. </pages> <publisher> North-Holland Publishing Co., </publisher> <month> December </month> <year> 1989. </year>
Reference-contexts: Schuman and Pitt [SP86] described a semantics to accommodate object orientation based on events and histories, though they did not provide the class as a single syntactic construct. Object-Z <ref> [CDD + 89] </ref> introduces classes to encapsulate the description of an object's state with its related operations. Complex specifications are then constructed through class inheritance and instantiation.
Reference: [Che91] <author> Yoonsik Cheon. Larch/Smalltalk: </author> <title> A specification language for Smalltalk. </title> <type> Technical Report TR #91-15, </type> <institution> Department of Computer Science; Iowa State University, Ames, IA, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: The description must be abstract so that irrelevant implementation choices and details are not exposed to the clients. In short, in an environment supporting reusability, one needs the abstraction that can be obtained by specification. Using a formal specification language increases precision and avoids unintended ambiguity. In Larch/Smalltalk <ref> [Che91] </ref> we have combined Larch-style specifications [GH93] and the notion of subtyping. The unit of specification is called an abstract data type or type for short. A type is an abstraction of one or more Smalltalk classes. A type specification consists of a set of method specifications. <p> The idea is to make the interface language dependent on a specific target programming language, and keep the shared language independent of any programming language. The interface components are specified in programming-language-specific Larch interface languages <ref> [Win87, GH91, Che91, Jon91, LC92] </ref> and the shared components are written in the Larch Shared Language (LSL) [GH93, Chapter 4]. The interface specifications are model-oriented while the shared components are equational. <p> The terms in assertions must be sort-correct in the sense that operator applications conform to their signatures specified in the traits <ref> [Che91] </ref> (see Section 3.3). This is similar to the notion of type-correctness in programming languages. In the specification of a method that can mutate its arguments, it is usually necessary to refer to the value of an object in two different states: the states before and after the method invocation. <p> In the sort inference rules we assume that terms are fully qualified. Refer to Appendix B for the default qualification rules for self and formal arguments. 4 Specification Inheritance and Subtyping Larch/Smalltalk is the first interface specification language that permits inheritance of specifications <ref> [Che91] </ref>. Inheritance of specifications permits specifiers to construct specifications incrementally. To specify a type incrementally, one states how it differs from other types, called supertypes, by adding additional features; this makes the new type a subtype of other types. <p> But the preference in Fresco seems to be to combine the two in conformant inheritance, in which the subclass also happens to implement a subtype [Mey88b]. Larch/Smalltalk is the first Larch interface specification language with subtyping and specification inheritance <ref> [Che91] </ref>. Other Larch interface languages with similar features are LM3 (Larch/Modula-3) [GH93, Chapter 6] and Larch/C ++ [LC92, CL93]. Both allow reuse of specifications in the interface level through specification inheritance.
Reference: [CL93] <author> Yoonsik Cheon and Gary T. Leavens. </author> <title> A quick overview of Larch/C++. </title> <type> Technical Report 93-18, </type> <institution> Department of Computer Science, Iowa State University, </institution> <month> June </month> <year> 1993. </year> <note> To appear in the Journal of Object-Oriented Programming. Available by anonymous ftp from ftp.cs.iastate.edu, and by email from almanac@cs.iastate.edu. </note>
Reference-contexts: Larch/Smalltalk is the first Larch interface specification language with subtyping and specification inheritance [Che91]. Other Larch interface languages with similar features are LM3 (Larch/Modula-3) [GH93, Chapter 6] and Larch/C ++ <ref> [LC92, CL93] </ref>. Both allow reuse of specifications in the interface level through specification inheritance. The most distinguishing features of Larch/Smalltalk compared to LM3 and Larch/C ++ are its simplicity and flexibility, and separation of types from classes.
Reference: [CL94] <author> Yoonsik Cheon and Gary T. Leavens. </author> <title> A gentle introduction to Larch/Smalltalk specification browsers. </title> <type> Technical Report 94-01, </type> <institution> Department of Computer Science, Iowa State University, </institution> <month> January </month> <year> 1994. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference: [CO88] <author> S. Clerici and F. Orejas. GSBL: </author> <title> An algebraic specification language based on inheritance. </title> <editor> In S. Gjessing and K. Nygaard, editors, </editor> <booktitle> ECOOP '88, European 31 Conference on Object-Oriented Programming, Oslo, Norway, volume 322 of Lec--ture Notes in Computer Science, </booktitle> <pages> pages 78-92. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Object orientation is reflected in the specification language ABEL [Dah87] in a class-like construct which defines objects in the conventional imperative sense. ABEL contains mechanisms for constructive and nonconstructive specifications as well as applicative and imperative programming. In GSBL <ref> [CO88] </ref>, an algebraic specification language, one can see full-fledged notions of objects, classes, and inheritance. In the database community, the Oblog + -language [JSS91] incorporates object orientation to specify information systems, especially for conceptual modeling of systems.
Reference: [Coo89] <author> W. R. Cook. </author> <title> A proposal for making Eiffel type-safe. </title> <editor> In Stephen Cook, editor, ECOOP'89, </editor> <booktitle> European Conference on Object-Oriented Programming, British Computer Society Workshop Series, </booktitle> <pages> pages 57-70. </pages> <publisher> Cambridge University Press, </publisher> <month> July </month> <year> 1989. </year> <note> Also in The Computer Journal 32(4), </note> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: A superclass may specify that subclasses must define a method that a particular subclass does not define, or a subclass can redefine a method to make it inaccessible. We want specification inheritance to be based on behavior (subtyping), not implementation (subclassing) <ref> [Ame91, Coo89, LaL89] </ref>. * We want multiple inheritance of specifications; that is, we want a type to be a subtype of more than one type. <p> Contravariance seems a bit awkward in practice, because a programmer typically wants to specialize rather than to generalize arguments. An alternative is to use covariance, which means that also argument types can be specialized. Such type systems are not statically sound and hard to reason about <ref> [Coo89] </ref>. In addition, contravariance does not seem to cause much problem at the specification level. The syntactic subtyping rule, together with specification inheritance, guarantees that a message understood by objects of a type is also understood by objects of its subtypes. <p> We can easily show that the subtyping relationship the other way around also conflicts with our subtyping rule. Therefore in general we do not have a subtype relationship between different instantiations of the same parameterized type, though there are some cases where such a relationship holds <ref> [Coo89] </ref>. 7 Discussion 7.1 Related Work Recently there has been much effort in applying object-oriented concepts to formal specification and reasoning techniques, that is to say, to design object-oriented specification 25 languages and to specify and verify programs in object-oriented programming languages.
Reference: [Coo92] <author> William R. Cook. </author> <title> Interfaces and specifications for the Smalltalk-80 collection classes. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(10) </volume> <pages> 1-15, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Specifying a type in terms of its differences from its supertypes leads to shorter specifications, and such specifications are easier to maintain. To start things off, a large number of type specifications are provided in the system, structured into a hierarchy based on their conceptual relationships <ref> [Coo92] </ref>, with the most general type Object at the root. The type Object specifies properties concerned with all objects; it has no method specification.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding Types, Data Abstraction and Polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: A Larch/Smalltalk type can be parameterized by type parameters to specify a set of related types. Type parameters can be restricted to subtypes of given types <ref> [CW85] </ref>. The process of writing formal specifications is as error-prone as the process of programming. As programming tools are of great help to programmers, specification tools, such as syntax and type checkers, will be a great help to specifiers. <p> Larch/Smalltalk itself checks only for the traditional syntactic constraints, which we call the syntactic subtyping rule. The syntactic subtyping rule says that for each subtype S of a supertype T , if an instance method M is specified both in S and T , the following conditions must hold <ref> [CW85, SCB + 86] </ref>: * For every input argument of M except for the implicit argument "self", its type in T 16 Set (Elem) type Set parameters Elem trait Set (Set (Elem) for S, Elem for E) meta methods new returns s &lt;: Set (Elem) ensures s post = fg ^ <p> In many applications, however, it is useful to have more information about the type parameters, for instance, the presence of certain methods. To help reason about parameterized types, one combines the idea of type parameters and subtyping into a notion called bounded quantification <ref> [CW85] </ref>. Each type parameter is bounded by a type. Only subtypes of a given type (upper bound) are allowed in place of type parameters.
Reference: [Dah87] <author> Ole-Johan Dahl. </author> <title> Object-oriented specification. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 561-576. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1987. </year>
Reference-contexts: This effort can be divided into two categories: designing new specification languages and extending existing specification languages with object oriented concepts. Object orientation is reflected in the specification language ABEL <ref> [Dah87] </ref> in a class-like construct which defines objects in the conventional imperative sense. ABEL contains mechanisms for constructive and nonconstructive specifications as well as applicative and imperative programming. In GSBL [CO88], an algebraic specification language, one can see full-fledged notions of objects, classes, and inheritance.
Reference: [ENO82] <author> George W. Ernst, Jainendra K. Navlakha, and William F. Ogden. </author> <title> Verification of programs with procedure-type parameters. </title> <journal> Acta Informatica, </journal> 18(??):149-169, 1982. 
Reference-contexts: Several approaches to specifying blocks are being examined: (1) modeling them explicitly as state transitions in LSL, (2) specifying in the interface the weakest pre- and post-conditions that the argument blocks have to satisfy <ref> [ENO82, Jon91] </ref>, (3) using free functions as proposed in LCL [Tan93], and (4) introducing new predicate operators that can model (repeated) invocation of argument blocks. An interesting fact about blocks is that they allow non-local exits; blocks are continuations.
Reference: [GH91] <author> J. V. Guttag and J. J. Horning. </author> <title> Introduction to LCL, a Larch/C interface language. </title> <type> Technical Report 74, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue Palo Alto, CA 94301, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: The idea is to make the interface language dependent on a specific target programming language, and keep the shared language independent of any programming language. The interface components are specified in programming-language-specific Larch interface languages <ref> [Win87, GH91, Che91, Jon91, LC92] </ref> and the shared components are written in the Larch Shared Language (LSL) [GH93, Chapter 4]. The interface specifications are model-oriented while the shared components are equational.
Reference: [GH93] <author> John V. Guttag and James J. Horning. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: In short, in an environment supporting reusability, one needs the abstraction that can be obtained by specification. Using a formal specification language increases precision and avoids unintended ambiguity. In Larch/Smalltalk [Che91] we have combined Larch-style specifications <ref> [GH93] </ref> and the notion of subtyping. The unit of specification is called an abstract data type or type for short. A type is an abstraction of one or more Smalltalk classes. A type specification consists of a set of method specifications. <p> The behavior of a method is specified by Hoare-style pre- and post-conditions [Hoa69]. The vocabulary for specifying pre- and post-conditions comes from the used trait, specified in a mostly equational style in the Larch Shared Language (LSL) <ref> [GH93] </ref>. The used trait describes the underlying mathematical model for the specified type. Having such a mathematical model allows one to reason about Smalltalk code without delving into the details of an object's implementation [Hoa72] (e.g., one does not need to know what its instance variables are). <p> In section 6, we show several example specifications to give readers some flavor of our specification language. We close with a discussion and some concluding remarks. 2 The Larch Approach to Interface Specification The Larch family of specification languages <ref> [GHW85, GH93] </ref> is related to both model-oriented specification and algebraic specification. In this style, the specification of underlying abstractions is separated from the specification of state transformations. Thus a specification of each program module consists of two components. <p> The interface components are specified in programming-language-specific Larch interface languages [Win87, GH91, Che91, Jon91, LC92] and the shared components are written in the Larch Shared Language (LSL) <ref> [GH93, Chapter 4] </ref>. The interface specifications are model-oriented while the shared components are equational. In the Larch family, there is a clear distinction between the specification of abstract models and the specification of interfaces of program modules. <p> On the other hand, the vocabulary for Larch interface specifications can be arbitrary enriched as it comes from the user-written shared components. Larch provides a set of shared components (traits) in the form of LSL Handbook <ref> [GH93, Appendix A] </ref>. Shown below is an interface specification of a method remove: of the Smalltalk class Set. The shared component, trait Set, is shown in Figure 2 1 . 1 The connection between the interface component and the shared component is not shown here. <p> The operators appearing in the requires and ensures clauses (e.g., 2, =, and delete) are defined precisely in the shared component (the trait Set). a mathematical notion of finite sets. The following is mainly a summarization of <ref> [GH93, 5 Chapter 4] </ref>. A trait specifies a mathematical model for interface specifications and describes intrinsic properties that are independent of the model of computation; that is, there is no concept of state, mutation, storage, etc. A trait is an equational specification with some additional constructs. <p> Formal requirements for such behavioral subtyping [Mey88a, LW90, Ame90, Lea91, LW93a, LW93b] involve either semantic modeling or theorem proving. The Larch proof assistant LP <ref> [GH93, Chapter 7] </ref>, because it accepts LSL syntax, could be used to prove such properties. Larch/Smalltalk itself checks only for the traditional syntactic constraints, which we call the syntactic subtyping rule. <p> The tuple definition is a LSL shorthand notation for introducing fixed-length tuples <ref> [GH93, Chapter 4] </ref>. For example, defining "G tuple of nodes: SN, edges: SE" introduces a tuple constructor ([ , ]), observer operators ( .nodes, .edges), and updating operators (set nodes and set edges, both of which produce new tuples) with appropriate axioms. <p> The operator includesNode tells whether a vertex is in a graph, while isolatedNode tests if a vertex is isolated from others. The operator 2 in the axiom for includesNode is the set membership operation, and comes from the included trait Set. The trait Set found in LSL Handbook <ref> [GH93, Appendix A] </ref> defines a mathematical model for finite sets. It is similar to the trait Set in Figure 2 except that it also defines typical set operations; [, ", (set difference), etc. <p> Larch/Smalltalk is the first Larch interface specification language with subtyping and specification inheritance [Che91]. Other Larch interface languages with similar features are LM3 (Larch/Modula-3) <ref> [GH93, Chapter 6] </ref> and Larch/C ++ [LC92, CL93]. Both allow reuse of specifications in the interface level through specification inheritance. The most distinguishing features of Larch/Smalltalk compared to LM3 and Larch/C ++ are its simplicity and flexibility, and separation of types from classes.
Reference: [GHW85] <author> John V. Guttag, James J. Horning, and Jeannette M. Wing. </author> <title> The Larch family of specification languages. </title> <journal> IEEE Software, </journal> <volume> 2(4), </volume> <month> September </month> <year> 1985. </year>
Reference-contexts: In section 6, we show several example specifications to give readers some flavor of our specification language. We close with a discussion and some concluding remarks. 2 The Larch Approach to Interface Specification The Larch family of specification languages <ref> [GHW85, GH93] </ref> is related to both model-oriented specification and algebraic specification. In this style, the specification of underlying abstractions is separated from the specification of state transformations. Thus a specification of each program module consists of two components.
Reference: [GM87] <author> Joseph A. Goguen and Jose Meseguer. </author> <title> Order-sorted algebra solves the constructor-selector, multiple representation and coercion problems. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, NY, </address> <pages> pages 18-29. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: One way to ensure this is to define the trait functions that apply to abstract values of the subtype by a homomorphic coercion function from subtype abstract values to supertype abstract values <ref> [Rey80, GM87, BW90, Ame91] </ref>.
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1983. </year>
Reference-contexts: 1 Introduction Object-oriented techniques encourage code reuse and modular design. In Smalltalk <ref> [GR83] </ref>, code reuse is achieved by defining one class to be a subclass of another class, called its superclass, thereby inheriting its data definitions and methods, or extending an existing class by adding new data definitions or new methods. <p> A meta method specification defines a message that is sent to an instance of the specified type's meta type, i.e., to an object that represents the type itself, not instances of the type. A meta type corresponds to Smalltalk's meta class <ref> [GR83] </ref>. A meta method typically specifies how to create an instance of the specified type. In the specification browsers, a method specification is classified as an instance or a meta when it is entered to the system by making an appropriate selection with the mouse. <p> The lexical conventions are the same as those of Smalltalk <ref> [GR83] </ref>. For example, hidentifieri is an arbitrary long sequence of letters and digits whose first character is a letter.
Reference: [Hay87] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <year> 1987. </year>
Reference-contexts: In the database community, the Oblog + -language [JSS91] incorporates object orientation to specify information systems, especially for conceptual modeling of systems. Several object-oriented extensions have been proposed for the specification language Z <ref> [Hay87] </ref> due to its style (e.g., graphical layout of specifications, use of set theoretic and logical notations, conventions for decorating input and output variables, etc.) and its growing use in industry.
Reference: [Hoa69] <author> C. A. R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: A type is an abstraction of one or more Smalltalk classes. A type specification consists of a set of method specifications. For each method, its interface (its arguments and their types) and behavior are precisely specified. The behavior of a method is specified by Hoare-style pre- and post-conditions <ref> [Hoa69] </ref>. The vocabulary for specifying pre- and post-conditions comes from the used trait, specified in a mostly equational style in the Larch Shared Language (LSL) [GH93]. The used trait describes the underlying mathematical model for the specified type. <p> All the method specifications together describe the protocol of the type. The behavior of a method is specified by the relationship between the inputs in the initial state and the output (return 9 value) in the final state by pre- and post-conditions <ref> [Hoa69] </ref>. As an example, consider the method includes:. includes: n &lt;: Integer returns b &lt;: Boolean requires true ensures b = n 2 self pre The method takes an integer and returns a boolean. Since the pre-condition holds trivially, the method can be invoked in any state.
Reference: [Hoa72] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(4) </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: The used trait describes the underlying mathematical model for the specified type. Having such a mathematical model allows one to reason about Smalltalk code without delving into the details of an object's implementation <ref> [Hoa72] </ref> (e.g., one does not need to know what its instance variables are). The mathematical model gives each object an abstract value in a given program state. To model mutation (e.g., assignment to instance variables), the object's abstract value may change from one state to another.
Reference: [Jon91] <author> Kevin D. Jones. LM3: </author> <title> A Larch interface language for Modula-3, a definition and introduction version 1.0. </title> <type> Technical Report 72, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue Palo Alto, CA 94301, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: The idea is to make the interface language dependent on a specific target programming language, and keep the shared language independent of any programming language. The interface components are specified in programming-language-specific Larch interface languages <ref> [Win87, GH91, Che91, Jon91, LC92] </ref> and the shared components are written in the Larch Shared Language (LSL) [GH93, Chapter 4]. The interface specifications are model-oriented while the shared components are equational. <p> For example, methods can be categorized 26 depending on whether they are public, protected, or private; in fact, this is what a sensible Smalltalk programmer does with Smalltalk methods. However, this cannot prevent clients from accessing protected or private methods if they want to. In LM3 <ref> [Jon91] </ref>, one can specify a higher-order procedure, a procedure that takes other procedures as its arguments. Similar features are also found in Larch/CLU [Win83] and LCL (Larch/C) [Tan93]. <p> Several approaches to specifying blocks are being examined: (1) modeling them explicitly as state transitions in LSL, (2) specifying in the interface the weakest pre- and post-conditions that the argument blocks have to satisfy <ref> [ENO82, Jon91] </ref>, (3) using free functions as proposed in LCL [Tan93], and (4) introducing new predicate operators that can model (repeated) invocation of argument blocks. An interesting fact about blocks is that they allow non-local exits; blocks are continuations.
Reference: [JSS91] <author> R. Jungclaus, G. Saake, and C. Sernadas. </author> <title> Formal specification of object systems. </title> <editor> In S. Abramsky and T. S. E. Maibaum, editors, </editor> <booktitle> TAPSOFT '91, Proceedings of the International Joint Conference on Theory and Practice of Software Development, Brighton, UK, Volume 2, Advances in Distributed Computing (ADC) and Colloquium on Combining Paradigms for Software Development (CCPSD), volume 494 of Lecture Notes in Computer Science, </booktitle> <pages> pages 60-82. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> April </month> <year> 1991. </year>
Reference-contexts: ABEL contains mechanisms for constructive and nonconstructive specifications as well as applicative and imperative programming. In GSBL [CO88], an algebraic specification language, one can see full-fledged notions of objects, classes, and inheritance. In the database community, the Oblog + -language <ref> [JSS91] </ref> incorporates object orientation to specify information systems, especially for conceptual modeling of systems.
Reference: [LaL89] <author> Wilf R. LaLonde. </author> <title> Designing families of data types using exemplars. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(2) </volume> <pages> 212-248, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Organizing specifications according to subtype relationships allows one to see types based on their conceptual relationships. This makes it easier both for specifiers to maintain large volumes of specifications and for clients to navigate through specifications for possible reuse of program modules <ref> [LaL89, LTP86] </ref>. A Larch/Smalltalk type can be parameterized by type parameters to specify a set of related types. Type parameters can be restricted to subtypes of given types [CW85]. The process of writing formal specifications is as error-prone as the process of programming. <p> A superclass may specify that subclasses must define a method that a particular subclass does not define, or a subclass can redefine a method to make it inaccessible. We want specification inheritance to be based on behavior (subtyping), not implementation (subclassing) <ref> [Ame91, Coo89, LaL89] </ref>. * We want multiple inheritance of specifications; that is, we want a type to be a subtype of more than one type. <p> We want to structure our specifications based on their conceptual relationships (subtyping), as opposed to the implementation relationships (subclassing). Clients find it much easier to understand and remember relationships that are logical than those that are side effects of particular implementation decisions <ref> [LaL89, LTP86] </ref>. There are two representations for Larch/Smalltalk specifications. In the Larch/Smalltalk browser, specifications are not just plain text, but organized material. A user writes a specification by editing templates given by the browsers.
Reference: [LC92] <author> Gary T. Leavens and Yoonsik Cheon. </author> <title> Preliminary design of Larch/C++. </title> <editor> In U. Martin and J. Wing, editors, </editor> <booktitle> Proceedings of the First International Workshop on Larch, Workshops in Computing Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> July </month> <year> 1992. </year>
Reference-contexts: The idea is to make the interface language dependent on a specific target programming language, and keep the shared language independent of any programming language. The interface components are specified in programming-language-specific Larch interface languages <ref> [Win87, GH91, Che91, Jon91, LC92] </ref> and the shared components are written in the Larch Shared Language (LSL) [GH93, Chapter 4]. The interface specifications are model-oriented while the shared components are equational. <p> That is, the meaning of an inherited method specification is given by reinterpreting the text of the inherited specification with the subtype's used trait. (This technique is also the foundation of specification inheritance in Larch/C ++ <ref> [LC92] </ref>.) This technique requires two conditions to be satisfied by the subtype's used trait. Syntactically the signature of the subtype's used trait must be superset of that of the supertype's used trait. Semantically the theory of the subtype's used trait must include that of the supertype's used trait. <p> Larch/Smalltalk is the first Larch interface specification language with subtyping and specification inheritance [Che91]. Other Larch interface languages with similar features are LM3 (Larch/Modula-3) [GH93, Chapter 6] and Larch/C ++ <ref> [LC92, CL93] </ref>. Both allow reuse of specifications in the interface level through specification inheritance. The most distinguishing features of Larch/Smalltalk compared to LM3 and Larch/C ++ are its simplicity and flexibility, and separation of types from classes.
Reference: [Lea91] <author> Gary T. Leavens. </author> <title> Modular specification and verification of object-oriented programs. </title> <journal> IEEE Software, </journal> <volume> 8(4) </volume> <pages> 72-80, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: In Larch/Smalltalk a type can be a subtype of more than one supertype, while in Smalltalk each class has only one superclass. To allow sound reasoning about programs that use sub-types, each object of such a subtype should behave like some object of each of its supertypes <ref> [Lea91, Ame91] </ref>. However, as verifying such behavioral constraints is more properly part 2 (right). <p> Formal requirements for such behavioral subtyping <ref> [Mey88a, LW90, Ame90, Lea91, LW93a, LW93b] </ref> involve either semantic modeling or theorem proving. The Larch proof assistant LP [GH93, Chapter 7], because it accepts LSL syntax, could be used to prove such properties. Larch/Smalltalk itself checks only for the traditional syntactic constraints, which we call the syntactic subtyping rule. <p> Basically we would like to design a Hoare-style proof logic adapted to object-oriented programming, something like the one discussed in <ref> [LW90, Lea91] </ref>. 7.3 Summary Behavioral specification of reusable components is more necessary in object-oriented programming than in conventional programming environment. The lack of such description techniques for Smalltalk has caused poor reuse of its huge library classes and made it hard for programmers to exchange code for possible reuse.
Reference: [Lea93] <author> Gary T. Leavens. </author> <title> Inheritance of interface specifications (extended abstract). </title> <type> Technical Report 93-23, </type> <institution> Iowa State University, Department of Computer Science, </institution> <month> September </month> <year> 1993. </year> <note> Submitted to the Workshop on Interface Definition Languages, WIDL '94. Available by anonymous ftp from ftp.cs.iastate.edu or by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: What does an inherited method specification mean? The basic problem is to ensure that the operators used in the inherited method specification, which were written for abstract values of the supertype, can be applied to the abstract values of the subtype <ref> [Lea93] </ref>. The simplest and most general answer, adopted by Larch/Smalltalk, is to view inheritance as textual expansion and to require that the subtype's used trait provide a meaning for the operators used in inherited method specifications.
Reference: [LTP86] <author> Wilf R. LaLonde, Dave A. Thomas, and John R. Pugh. </author> <title> An exemplar based Smalltalk. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 322-330, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOP-SLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: Organizing specifications according to subtype relationships allows one to see types based on their conceptual relationships. This makes it easier both for specifiers to maintain large volumes of specifications and for clients to navigate through specifications for possible reuse of program modules <ref> [LaL89, LTP86] </ref>. A Larch/Smalltalk type can be parameterized by type parameters to specify a set of related types. Type parameters can be restricted to subtypes of given types [CW85]. The process of writing formal specifications is as error-prone as the process of programming. <p> We want to structure our specifications based on their conceptual relationships (subtyping), as opposed to the implementation relationships (subclassing). Clients find it much easier to understand and remember relationships that are logical than those that are side effects of particular implementation decisions <ref> [LaL89, LTP86] </ref>. There are two representations for Larch/Smalltalk specifications. In the Larch/Smalltalk browser, specifications are not just plain text, but organized material. A user writes a specification by editing templates given by the browsers. <p> Thus a Larch/Smalltalk 28 type can be implemented by a single Smalltalk class, several classes forming a subhierarchy in the subclassing hierarchy, or a set of classes. Also a type may have several different implementations in a program <ref> [LTP86] </ref>. The separation of types from classes gives a great freedom in design and implementation. To allow specifications to be used practically in the programming process, Larch/Smalltalk specification browsers integrated in the Smalltalk system were implemented. A preliminary version is available by anonymous ftp from ftp.cs.iastate.edu.
Reference: [LW90] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about object-oriented programs that use subtypes (extended abstract). </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 212-223, </pages> <month> October </month> <year> 1990. </year> <booktitle> OOPSLA ECOOP '90 Proceedings, N. Meyrowitz (editor). </booktitle>
Reference-contexts: Formal requirements for such behavioral subtyping <ref> [Mey88a, LW90, Ame90, Lea91, LW93a, LW93b] </ref> involve either semantic modeling or theorem proving. The Larch proof assistant LP [GH93, Chapter 7], because it accepts LSL syntax, could be used to prove such properties. Larch/Smalltalk itself checks only for the traditional syntactic constraints, which we call the syntactic subtyping rule. <p> Basically we would like to design a Hoare-style proof logic adapted to object-oriented programming, something like the one discussed in <ref> [LW90, Lea91] </ref>. 7.3 Summary Behavioral specification of reusable components is more necessary in object-oriented programming than in conventional programming environment. The lack of such description techniques for Smalltalk has caused poor reuse of its huge library classes and made it hard for programmers to exchange code for possible reuse.
Reference: [LW93a] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> A new definition of the subtype relation. </title> <editor> In Oscar M. Nierstrasz, editor, </editor> <booktitle> ECOOP '93 | Object-Oriented Programming, 7th European Conference, Kaiserslautern, Germany, volume 707 of Lecture Notes in Computer Science, </booktitle> <pages> pages 118-141. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> July </month> <year> 1993. </year>
Reference-contexts: Formal requirements for such behavioral subtyping <ref> [Mey88a, LW90, Ame90, Lea91, LW93a, LW93b] </ref> involve either semantic modeling or theorem proving. The Larch proof assistant LP [GH93, Chapter 7], because it accepts LSL syntax, could be used to prove such properties. Larch/Smalltalk itself checks only for the traditional syntactic constraints, which we call the syntactic subtyping rule.
Reference: [LW93b] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> Specifications and their use in defining subtypes. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(10) </volume> <pages> 16-28, </pages> <month> October </month> <year> 1993. </year> <booktitle> OOPSLA '93 Proceedings, </booktitle> <editor> Andreas Paepcke (editor). </editor> <volume> 33 </volume>
Reference-contexts: Formal requirements for such behavioral subtyping <ref> [Mey88a, LW90, Ame90, Lea91, LW93a, LW93b] </ref> involve either semantic modeling or theorem proving. The Larch proof assistant LP [GH93, Chapter 7], because it accepts LSL syntax, could be used to prove such properties. Larch/Smalltalk itself checks only for the traditional syntactic constraints, which we call the syntactic subtyping rule.
Reference: [May88] <author> T. Mayer. </author> <title> Specification of object-oriented systems in LOTOS. </title> <editor> In K. Turner, editor, </editor> <booktitle> Formal Description Techniques (FORTE '88), </booktitle> <pages> pages 107-119. </pages> <publisher> North-Holland Publishing Co., </publisher> <year> 1988. </year>
Reference-contexts: The OOZE System [AG91], based on Z and OBJ3, provides a powerful parameterization mechanism (modules, theories, views) as well as notions of objects, classes, and inheritance. Object-orientation was also attempted for the specification languages VDM [Bea88] and LOTOS <ref> [May88] </ref>. In Fresco [Wil92], a programming environment for developing object-oriented software from specifications based on VDM, a class describes a specification, an implementation, or a mixture of two. A class is specified with model variables, invariants, and operation specifications.
Reference: [Mey88a] <author> Bertrand Meyer. </author> <title> Eiffel: A language and environment for software engineering. </title> <journal> The Journal of Systems and Software, </journal> <volume> 8(3) </volume> <pages> 199-246, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Formal requirements for such behavioral subtyping <ref> [Mey88a, LW90, Ame90, Lea91, LW93a, LW93b] </ref> involve either semantic modeling or theorem proving. The Larch proof assistant LP [GH93, Chapter 7], because it accepts LSL syntax, could be used to prove such properties. Larch/Smalltalk itself checks only for the traditional syntactic constraints, which we call the syntactic subtyping rule.
Reference: [Mey88b] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <year> 1988. </year>
Reference-contexts: Fresco also distinguishes between the class hierarchy of implementations and the type hierarchy of conformance. But the preference in Fresco seems to be to combine the two in conformant inheritance, in which the subclass also happens to implement a subtype <ref> [Mey88b] </ref>. Larch/Smalltalk is the first Larch interface specification language with subtyping and specification inheritance [Che91]. Other Larch interface languages with similar features are LM3 (Larch/Modula-3) [GH93, Chapter 6] and Larch/C ++ [LC92, CL93]. Both allow reuse of specifications in the interface level through specification inheritance.
Reference: [Rey80] <author> John C. Reynolds. </author> <title> Using category theory to design implicit conversions and generic operators. </title> <editor> In Neil D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, Proceedings of a Workshop, Aarhus, Denmark, volume 94 of Lecture Notes in Computer Science, </booktitle> <pages> pages 211-258. </pages> <publisher> Springer-Verlag, </publisher> <month> January </month> <year> 1980. </year>
Reference-contexts: One way to ensure this is to define the trait functions that apply to abstract values of the subtype by a homomorphic coercion function from subtype abstract values to supertype abstract values <ref> [Rey80, GM87, BW90, Ame91] </ref>.
Reference: [SCB + 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An introduction to Trellis/Owl. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 9-16, </pages> <month> Novem-ber </month> <year> 1986. </year>
Reference-contexts: Larch/Smalltalk itself checks only for the traditional syntactic constraints, which we call the syntactic subtyping rule. The syntactic subtyping rule says that for each subtype S of a supertype T , if an instance method M is specified both in S and T , the following conditions must hold <ref> [CW85, SCB + 86] </ref>: * For every input argument of M except for the implicit argument "self", its type in T 16 Set (Elem) type Set parameters Elem trait Set (Set (Elem) for S, Elem for E) meta methods new returns s &lt;: Set (Elem) ensures s post = fg ^
Reference: [SP86] <author> S.A. Schuman and D.H. Pitt. </author> <title> Object oriented subsystem specification. </title> <editor> In L.G.L.T. Meertens, editor, </editor> <booktitle> Program Specification and Transformation, </booktitle> <pages> pages 313-342. </pages> <publisher> North Holland, </publisher> <year> 1986. </year> <booktitle> Proceedings of the IFIP TC2/WG 2.1 Working Conference on Program Specification and Transformation, </booktitle> <address> Bad Tolz, FRG, </address> <month> 15-17 April, </month> <year> 1986. </year>
Reference-contexts: Several object-oriented extensions have been proposed for the specification language Z [Hay87] due to its style (e.g., graphical layout of specifications, use of set theoretic and logical notations, conventions for decorating input and output variables, etc.) and its growing use in industry. Schuman and Pitt <ref> [SP86] </ref> described a semantics to accommodate object orientation based on events and histories, though they did not provide the class as a single syntactic construct. Object-Z [CDD + 89] introduces classes to encapsulate the description of an object's state with its related operations.
Reference: [Tan93] <author> Yang Meng Tan. </author> <title> Semantic analysis of Larch interface specifications. </title> <editor> In U. Martin and J. Wing, editors, </editor> <booktitle> Proceedings of the First International Workshop on Larch, </booktitle> <month> July, </month> <year> 1992, </year> <title> Workshops in Computing. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: However, this cannot prevent clients from accessing protected or private methods if they want to. In LM3 [Jon91], one can specify a higher-order procedure, a procedure that takes other procedures as its arguments. Similar features are also found in Larch/CLU [Win83] and LCL (Larch/C) <ref> [Tan93] </ref>. The interface (arguments and their types) and the behavior (using pre- and post-conditions) of an argument procedure are specified in the header part of the procedure which takes it as an argument. <p> Several approaches to specifying blocks are being examined: (1) modeling them explicitly as state transitions in LSL, (2) specifying in the interface the weakest pre- and post-conditions that the argument blocks have to satisfy [ENO82, Jon91], (3) using free functions as proposed in LCL <ref> [Tan93] </ref>, and (4) introducing new predicate operators that can model (repeated) invocation of argument blocks. An interesting fact about blocks is that they allow non-local exits; blocks are continuations. A block can exit to the place where it was defined (which may be different from where it was invoked).
Reference: [Wil92] <author> Alan Wills. </author> <title> Specification in fresco. </title> <editor> In Susan Stepney, Rosalind Barden, and David Cooper, editors, </editor> <title> Object Orientation in Z, </title> <booktitle> Workshops in Computing, chapter 11, </booktitle> <pages> pages 127-135. </pages> <publisher> Springer-Verlag, </publisher> <address> Cambridge CB2 1LQ, UK, </address> <year> 1992. </year>
Reference-contexts: The OOZE System [AG91], based on Z and OBJ3, provides a powerful parameterization mechanism (modules, theories, views) as well as notions of objects, classes, and inheritance. Object-orientation was also attempted for the specification languages VDM [Bea88] and LOTOS [May88]. In Fresco <ref> [Wil92] </ref>, a programming environment for developing object-oriented software from specifications based on VDM, a class describes a specification, an implementation, or a mixture of two. A class is specified with model variables, invariants, and operation specifications.
Reference: [Win83] <author> Jeannette Marie Wing. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: Readers may skip this section at their first reading. Assertions in the pre- and post-conditions (also the invariants) must be sort-correct in the sense that LSL operator applications conform to their signatures specified in the traits <ref> [Win83] </ref>. Figure 4 shows the Larch/Smalltalk sort inference rules for sort-checking assertions, based on the abstract syntax for assertions (see Appendix A). <p> However, this cannot prevent clients from accessing protected or private methods if they want to. In LM3 [Jon91], one can specify a higher-order procedure, a procedure that takes other procedures as its arguments. Similar features are also found in Larch/CLU <ref> [Win83] </ref> and LCL (Larch/C) [Tan93]. The interface (arguments and their types) and the behavior (using pre- and post-conditions) of an argument procedure are specified in the header part of the procedure which takes it as an argument.
Reference: [Win87] <author> Jeannette M. Wing. </author> <title> Writing Larch interface language specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 1-24, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: The idea is to make the interface language dependent on a specific target programming language, and keep the shared language independent of any programming language. The interface components are specified in programming-language-specific Larch interface languages <ref> [Win87, GH91, Che91, Jon91, LC92] </ref> and the shared components are written in the Larch Shared Language (LSL) [GH93, Chapter 4]. The interface specifications are model-oriented while the shared components are equational.
Reference: [Win90] <author> Jeannette M. Wing. </author> <title> Using Larch to specify Avalon/C++ objects. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 1076-1088, </pages> <month> September </month> <year> 1990. </year> <month> 34 </month>
Reference-contexts: A similar approach might be taken to specify Smalltalk blocks. LM3 also has support for specifying threads, lightweight units of concurrency in Modula-3. A non-atomic routine is specified as sequence of atomic actions <ref> [Win90] </ref>. Concurrency issues are not addressed in Larch/Smalltalk. 7.2 Future Work 7.2.1 Language Extension In Smalltalk, methods can take or return blocks. That is, methods can be higher-order. A block is a closure; it contains parameterized code and an environment.
References-found: 44

