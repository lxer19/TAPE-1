URL: http://www.cs.umd.edu/~rich/courses/cmsc818G-s98/papers/ada_tse.ps
Refering-URL: http://www.cs.umd.edu/~rich/courses/cmsc818G-s98/resources.html
Root-URL: 
Title: Implementing Atomic Actions in Ada 95  
Author: A.J. Wellings and A. Burns 
Keyword: Software fault tolerance, Atomic actions, Ada 95, Excep tion handling, Recover blocks, Conversations  
Date: January 4, 1996  
Address: U.K.  
Affiliation: Real-Time Systems Research Group Department of Computer Science University of York  
Abstract: This paper illustrates how to program atomic action using the facilities of Ada 95. In particular, it shows how packages, protected objects, requeue, exceptions, asynchronous transfer of control, tagged types and controlled types can be used as building block from which to construct atomic actions with forward and backward error recovery and which are resilient to deserter tasks and task abortion. Distributed execution of atomic actions is also discussed. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Anderson, T. and Lee, P. </author> <year> (1990). </year> <title> Fault Tolerance Principles and Practice:, </title> <booktitle> 2nd edn, Prentice-Hall International. </booktitle>
Reference-contexts: With dynamic redundancy, the redundant components only come into operation when an error has been detected. Dynamic fault tolerance has four constituent phases <ref> (Anderson and Lee, 1990) </ref>. 1. Error detection Faults of significance will eventually manifest themselves in the form of an error; no fault tolerance scheme can be utilised until that error is detected. 2.
Reference: <author> Birrell, A. and Nelson, B. </author> <year> (1984). </year> <title> Implementing remote procedure calls, </title> <journal> ACM Transactions on Computer Systems 2(1): </journal> <pages> 39-59. </pages>
Reference-contexts: Its body exists only within a single partition. All other occurrences will have stubs allocated using standard RPC implementation techniques <ref> (Birrell and Nelson, 1984) </ref>. The specification of a Remote Call Interface has various restrictions which, for example, prohibit the definition of a variable (to ensure no remote data access). A package which is not categorised is called a normal library package.
Reference: <author> Brinch-Hansen, P. </author> <year> (1972). </year> <title> Structured multiprogramming, </title> <journal> CACM 15(7): </journal> <pages> 574-578. </pages>
Reference: <author> Brinch-Hansen, P. </author> <year> (1973). </year> <title> Operating System Principles, </title> <publisher> Prentice-Hall, </publisher> <address> New Jersey. </address>
Reference: <author> Burns, A. and Wellings, A. </author> <year> (1989). </year> <title> Programming atomic actions in ada, </title> <booktitle> Ada Letters 9(6): </booktitle> <pages> 67-79. </pages>
Reference-contexts: Arjuna uses the latter approach to provide a transaction-based toolkit for C++(Shrivastava et al., 1991). Arguably, high-level support is not needed and the required functionality can be programmed with lower-level primitives. For example, some attempts have been made to program conversations in Ada 83 <ref> (Burns and Wellings, 1989) </ref>(Clematis and Gianuzzi, 1993) (Romanovsky and Strigini, 1995); however, these were severely hampered by the lack of suitable language support. <p> Alternatively, a default handler could be provided which would raise the atomic action failure exception. 8 4 Ada 95 Ada 83, along with most concurrent programming languages, was unable to support the full functionality of atomic actions <ref> (Burns and Wellings, 1989) </ref>. Ada 95 does not support atomic actions directly but does provide a rich supply of language primitives which potentially can be used to implement the same functionality.
Reference: <author> Burns, A. and Wellings, A. </author> <year> (1990). </year> <title> Real-Time Systems and their Programming Languages, </title> <publisher> Addison Wesley. </publisher>
Reference-contexts: For concurrent systems, the position is not so clear cut. Although techniques such as conversations (Campbell and Randell, 1986) and atomic actions (Lomet, 1977) were developed some time ago, few of the main-stream languages or operating systems provide direct support <ref> (Burns and Wellings, 1990) </ref>. Instead, languages just as Concurrent Pascal has been used as the basis for experimentation (Kim, 1982), or a set of procedural extensions or object extensions have been produced. Arjuna uses the latter approach to provide a transaction-based toolkit for C++(Shrivastava et al., 1991).
Reference: <author> Burns, A. and Wellings, A. </author> <year> (1995). </year> <title> Concurrency in Ada, </title> <publisher> Cambridge University Press. </publisher>
Reference-contexts: It is this inability to declare partition types which is the main limitation of the Ada model; for example, arrays of partitions are not expressible within the language <ref> (Burns and Wellings, 1995) </ref>. Each partition resides at a single execution site where all its library units occupy the same logical address space. More than one partition may, however, reside on the same execution site. Partitions may be either active or passive.
Reference: <author> Campbell, R. and Randell, B. </author> <year> (1986). </year> <title> Error recovery in asynchronous systems, </title> <journal> IEEE Transactions on Software Engineering 1(8): </journal> <pages> 811-826. </pages>
Reference-contexts: For concurrent systems, the position is not so clear cut. Although techniques such as conversations <ref> (Campbell and Randell, 1986) </ref> and atomic actions (Lomet, 1977) were developed some time ago, few of the main-stream languages or operating systems provide direct support (Burns and Wellings, 1990). <p> This exception is raised in all the involved processes. There are two issues which must be considered when exception handling is added to atomic actions: resolution of concurrently raised exceptions and exceptions in nested actions <ref> (Campbell and Randell, 1986) </ref>. These are now briefly reviewed. Resolution of concurrently raised exceptions It is possibly for more than one process active in an atomic action to raise different exceptions at the same time.
Reference: <author> Clematis, A. and Gianuzzi, V. </author> <year> (1993). </year> <title> Structuring conversations in operation/procedure oriented programming languages, </title> <booktitle> Computer Languages 18(3): </booktitle> <pages> 153-168. </pages>
Reference: <author> Goodenough, J. B. </author> <year> (1975). </year> <title> Exception handling: Issues and a proposed notation, </title> <journal> CACM 18(12): </journal> <pages> 683-696. </pages> <note> 36 Gregory, </note> <author> S. and Knight, J. </author> <year> (1985). </year> <title> A new linguistic approach to backward error recovery, </title> <booktitle> The Fifteenth Annual International Symposium on Fault-Tolerant Computing Digest of Papers, </booktitle> <pages> pp. 404-409. </pages>
Reference-contexts: Judicious placement of acceptance tests or assertions allow errors to be detected before damage can be propagate. Similarly, techniques such as exception handling <ref> (Goodenough, 1975) </ref> (forward error recovery) and recovery blocks (Horning et al., 1974) (backward error recover) allow error recovery to be performed according to whether the fault was anticipated or not. For concurrent systems, the position is not so clear cut.
Reference: <author> Hoare, C. </author> <year> (1972). </year> <title> Towards a theory of parallel programming, Operating Systems Techniques, </title> <publisher> Academic Press, </publisher> <pages> pp. 61-71. </pages>
Reference-contexts: However, protected objects, ATC, tagged types and controlled types are new and will be briefly described. For a full discussion on these aspects of Ada 95 see Burns and Wellings (1995). 4.1 Protected Objects A protected object in Ada 95 is similar in concept to a conditional critical region <ref> (Hoare, 1972) </ref>(Brinch-Hansen, 1972) and a monitor (Hoare, 1974)(Brinch-Hansen, 1973). Data which is to accessed in mutual exclusion is encapsulated in a protected object. This data can only be accessed by procedures and entries also declared in the protected object.
Reference: <author> Hoare, C. </author> <year> (1974). </year> <title> Monitors an operating system structuring concept, </title> <journal> CACM 17(10): </journal> <pages> 549-557. </pages>
Reference-contexts: For a full discussion on these aspects of Ada 95 see Burns and Wellings (1995). 4.1 Protected Objects A protected object in Ada 95 is similar in concept to a conditional critical region (Hoare, 1972)(Brinch-Hansen, 1972) and a monitor <ref> (Hoare, 1974) </ref>(Brinch-Hansen, 1973). Data which is to accessed in mutual exclusion is encapsulated in a protected object. This data can only be accessed by procedures and entries also declared in the protected object. Execution of a procedure or an entry requires mutual exclusion access over the object.
Reference: <author> Horning, J. J., Lauer, H. C., Melliar-Smith, P. M. and Randell, B. </author> <year> (1974). </year>
Reference-contexts: Judicious placement of acceptance tests or assertions allow errors to be detected before damage can be propagate. Similarly, techniques such as exception handling (Goodenough, 1975) (forward error recovery) and recovery blocks <ref> (Horning et al., 1974) </ref> (backward error recover) allow error recovery to be performed according to whether the fault was anticipated or not. For concurrent systems, the position is not so clear cut.
Reference: <editor> A program structure for error detection and recovery, in E. Gelenbe and C. Kaiser (eds), </editor> <booktitle> Lecture Notes in Computer Science 16, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. </pages> <note> 171 - 187. Intermetrics (1995). Ada 95 reference manual, ANSI/ISO/IEC-8652:1995, In-termetrics. </note>
Reference-contexts: Arguably, high-level support is not needed and the required functionality can be programmed with lower-level primitives. For example, some attempts have been made to program conversations in Ada 83 (Burns and Wellings, 1989)(Clematis and Gianuzzi, 1993) <ref> (Romanovsky and Strigini, 1995) </ref>; however, these were severely hampered by the lack of suitable language support. For instance, Romanovsky and Strigini (1995) only allow parallelism to exist inside a conversation; the approach is not appropriate if a collection of pre-existing tasks wish to participate collectively in a conversation. <p> It is this inability to declare partition types which is the main limitation of the Ada model; for example, arrays of partitions are not expressible within the language <ref> (Burns and Wellings, 1995) </ref>. Each partition resides at a single execution site where all its library units occupy the same logical address space. More than one partition may, however, reside on the same execution site. Partitions may be either active or passive.
Reference: <author> Jalote, P. </author> <year> (1985). </year> <title> Atomic actions in concurrent systems, </title> <institution> UIUCDCS-R-85-1223, Department of Computer Science, University of Illinois. </institution>
Reference-contexts: These requirements are independent from the notion of a process and the form 3 of inter-process communication provided by a language <ref> (Jalote, 1985) </ref>. They are: 1. Well-defined boundaries Each atomic action should have a start, end and a side boundary. The start boundary is the location in each process involved in the atomic action where the action is deemed to start.
Reference: <author> Jalote, P. and Campbell, R. </author> <year> (1984). </year> <title> Fault tolerance using communicating sequential processes, </title> <booktitle> The Fourteenth Annual International Symposium on Fault-Tolerant Computing Digest of Papers, </booktitle> <pages> pp. 347-352. </pages>
Reference: <author> Jalote, P. and Campbell, R. </author> <year> (1986). </year> <title> Atomic actions for fault-tolerance using CSP, </title> <journal> IEEE Transactions on Software Engineering vol.SE-12 A07(no.1): </journal> <pages> 59-68. </pages>
Reference: <author> Kim, K. </author> <year> (1982). </year> <title> Approaches to mechanization of the conversation scheme based on monitors, </title> <journal> IEEE Transactions on Software Engineering vol.SE-8(3): </journal> <pages> 189-97. </pages>
Reference-contexts: Although techniques such as conversations (Campbell and Randell, 1986) and atomic actions (Lomet, 1977) were developed some time ago, few of the main-stream languages or operating systems provide direct support (Burns and Wellings, 1990). Instead, languages just as Concurrent Pascal has been used as the basis for experimentation <ref> (Kim, 1982) </ref>, or a set of procedural extensions or object extensions have been produced. Arjuna uses the latter approach to provide a transaction-based toolkit for C++(Shrivastava et al., 1991). Arguably, high-level support is not needed and the required functionality can be programmed with lower-level primitives.
Reference: <author> Lomet, D. </author> <year> (1977). </year> <title> Process structuring, synchronisation and recovery using atomic actions, </title> <booktitle> Proceedings ACM Conference Language Design for Reliable Software SIGPLAN, </booktitle> <pages> pp. 128-137. </pages> <booktitle> Published as Proceedings ACM Conference Language Design for Reliable Software SIGPLAN, </booktitle> <volume> volume 12, number 3. </volume>
Reference-contexts: For concurrent systems, the position is not so clear cut. Although techniques such as conversations (Campbell and Randell, 1986) and atomic actions <ref> (Lomet, 1977) </ref> were developed some time ago, few of the main-stream languages or operating systems provide direct support (Burns and Wellings, 1990). Instead, languages just as Concurrent Pascal has been used as the basis for experimentation (Kim, 1982), or a set of procedural extensions or object extensions have been produced. <p> Atomic actions have been proposed as a dynamic mechanism for controlling the joint executing of a group of processes such that their combined operation appears as an indivisible action. There are several almost equivalent ways of expressing the properties of an atomic action <ref> (Lomet, 1977) </ref> (Randell et al., 1978). 1. An action is atomic if the processes performing it are not aware of the existence of any other active process, and no other active process is aware of the activity of the processes during the time the processes are performing the action. 2.
Reference: <author> Randell, B. </author> <year> (1975). </year> <title> System structure for software fault tolerance, </title> <journal> IEEE Transactions on Software Engineering SE-1(2): </journal> <pages> 220-232. </pages>
Reference-contexts: When atomic actions are used in this way they are called conversations <ref> (Randell, 1975) </ref>. With conversations each action statement contains a recovery block.
Reference: <author> Randell, B. et al. </author> <year> (1995). </year> <title> From recovery blocks to concurrent atomic actions, </title> <editor> in B. Randell et al. (eds), </editor> <title> Predictable Dependable Computig Systems, </title> <publisher> Springer. </publisher>
Reference: <author> Randell, B., Lee, P. and Treleaven, P. </author> <year> (1978). </year> <title> Reliability issues in computing system design, </title> <journal> ACM Computing Surveys 10(2): </journal> <pages> 123-165. </pages>
Reference-contexts: Atomic actions have been proposed as a dynamic mechanism for controlling the joint executing of a group of processes such that their combined operation appears as an indivisible action. There are several almost equivalent ways of expressing the properties of an atomic action (Lomet, 1977) <ref> (Randell et al., 1978) </ref>. 1. An action is atomic if the processes performing it are not aware of the existence of any other active process, and no other active process is aware of the activity of the processes during the time the processes are performing the action. 2.
Reference: <author> Romanovsky, A. and Strigini, L. </author> <year> (1995). </year> <title> Backward error recovery via conversations in ada, </title> <journal> Software Engineering Journal 10(6): </journal> <pages> 219-232. </pages>
Reference-contexts: Arguably, high-level support is not needed and the required functionality can be programmed with lower-level primitives. For example, some attempts have been made to program conversations in Ada 83 (Burns and Wellings, 1989)(Clematis and Gianuzzi, 1993) <ref> (Romanovsky and Strigini, 1995) </ref>; however, these were severely hampered by the lack of suitable language support. For instance, Romanovsky and Strigini (1995) only allow parallelism to exist inside a conversation; the approach is not appropriate if a collection of pre-existing tasks wish to participate collectively in a conversation.
Reference: <author> Schlichting, R. and Schneider, F. </author> <year> (1983). </year> <title> Fail-stop processors: An approach to designing fault-tolerant computing systems, </title> <journal> Transactions on Computer Systems 1(3): </journal> <pages> 223-238. </pages> <note> 37 Shrivastava, </note> <author> S., Dixon., G. and Parrington, G. </author> <year> (1991). </year> <title> An overview of the Arjuna distributed programming system, </title> <booktitle> IEEE Software 8(1): </booktitle> <pages> 66-73. </pages>
Reference-contexts: Here a client-server model is used. The robot arm problem given in the previous section is used as an example. The following assumptions are made: * the Control and the Axis tasks are to be distributed * all machines are fail silent <ref> (Schlichting and Schneider, 1983) </ref> * replication for availability, if required, is achieved transparently to the program * all communication is reliable. In common with most distributed programming languages, it is not possible to take an arbitrary Ada program and distribute it.
Reference: <author> Tyrrell, A. and Holding, D. </author> <year> (1986). </year> <title> Design of reliable software in distributed systems using the conversation scheme, </title> <journal> IEEE Transactions on Software Engineering vol.SE-12(9): </journal> <pages> 921-8. </pages>
Reference: <author> Xu, J., Randell, B. et al. </author> <year> (1995). </year> <title> Fault tolerance in concurrent object-oriented software through coordinated error recovery, </title> <booktitle> Digest of Papers, The Twenty Fifth International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pp. 499-508. 38 </pages>
References-found: 26

