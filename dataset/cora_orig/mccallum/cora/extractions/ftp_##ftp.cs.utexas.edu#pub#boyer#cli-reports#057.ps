URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/057.ps
Refering-URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/index.html
Root-URL: 
Phone: (512) 322-9951  
Title: The Proof of Correctness of a Fault-Tolerant Circuit Design  
Author: William R. Bevier William D. Young 
Note: This work was sponsored in part at Computational Logic, Inc. by National Aeronautics and Space Administration Langley Research Center (NAS1-18878). The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., NASA Langley Research Center or the U.S. Government.  
Address: 1717 W. 6th St. Suite 290 Austin, Texas 78703  
Affiliation: Computational Logic Inc.  
Abstract: Technical Report 57 August 1990 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> W.R. Bevier and W.D. Young. </author> <title> Machine Checked Proofs of a Byzantine Agreement Algorithm. </title> <type> Technical Report 55, </type> <institution> Computational Logic, Inc., </institution> <month> June, </month> <year> 1990. </year>
Reference-contexts: We then defined a low-level characterization of the algorithm and proved that our low-level version is a correct implementation of our high-level version. As a consequence of this proof, we are guaranteed that our low-level implementation achieves interactive consistency. An earlier paper <ref> [1] </ref> reports on our work to describe our abstract implementation of the algorithm in the Boyer-Moore logic. We stated the interactive consistency conditions in the logic, and used the Boyer-Moore theorem prover to check a proof that our formalization of OM satisfies these conditions. <p> Lamport, Shostak and Pease [4] prove that OM is guaranteed to achieve interactive consistency only if n is greater than three times the number of faulty processes. The number of rounds of information exchange m must be at least the number of faulty processes. An accompanying paper <ref> [1] </ref> presents our formal definition of OM, and describes our mechanically checked proof that our formalization of the algorithm produces a vector which satisfies the interactive consistency conditions. Our formal statements of the two theorems that OM satisfies IC1 and IC2, respectively, are given below. <p> Case Counter: 0: data_out [i] sense, i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input <ref> [1] </ref> data_out [1] input [0] data_out [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], <p> Case Counter: 0: data_out [i] sense, i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input <ref> [1] </ref> data_out [1] input [0] data_out [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], <p> 0: data_out [i] sense, i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input <ref> [1] </ref> data_out [1] input [0] data_out [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], matrix [2,1]) icv [1] majority (matrix [0,1], matrix [1,0], matrix [2,2]) icv [2] majority (matrix [0,2], matrix [1,1], matrix [2,0]) clock clock+1 5: <p> [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out <ref> [1] </ref> matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], matrix [2,1]) icv [1] majority (matrix [0,1], matrix [1,0], matrix [2,2]) icv [2] majority (matrix [0,2], matrix [1,1], matrix [2,0]) clock clock+1 5: Actuator filter (icv) clock clock+1 6: clock clock+1 7: clock clock+1 4.
Reference: 2. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Case Counter: 0: data_out [i] sense, i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input [1] data_out [1] input [0] data_out <ref> [2] </ref> input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], matrix [2,1]) icv [1] <p> i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input [1] data_out [1] input [0] data_out <ref> [2] </ref> input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], matrix [2,1]) icv [1] majority (matrix [0,1], matrix [1,0], matrix [2,2]) icv [2] majority (matrix [0,2], matrix [1,1], matrix [2,0]) clock clock+1 5: Actuator filter (icv) clock <p> [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out <ref> [2] </ref> matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], matrix [2,1]) icv [1] majority (matrix [0,1], matrix [1,0], matrix [2,2]) icv [2] majority (matrix [0,2], matrix [1,1], matrix [2,0]) clock clock+1 5: Actuator filter (icv) clock clock+1 6: clock clock+1 7: clock clock+1 4. <p> How can we convince ourselves that this is true? Our design is fairly simple, but has some tricky details where mistakes can easily be made. To convince ourselves of this assertion we have proved the design correct, and mechanically checked the proof with the Boyer-Moore theorem prover <ref> [2, 3] </ref>. The specification and proof of correctness consists of the following elements. 11 Correctness of the function OM. The function OM is defined in the Boyer-Moore logic, and is proved to satisfy interactive consistency conditions. * The Circuit Specification Function.
Reference: 3. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year> <note> 4. </note> <author> -Leslie Lamport, Robert Shostak, </author> <title> and Marshall Pease . "The Byzantine Generals Problem". </title> <journal> ACM TOPLAS 4, </journal> <note> 3 (July 1982), </note> <author> 382-401.-5. -Marshall Pease, Robert Shostak, </author> <title> and Leslie Lamport . "Reaching Agreement in the Presence of Faults". </title> <type> JACM 27, </type> <month> 2 (April </month> <year> 1980), </year> <month> 228-234. </month> <title> Table of Contents </title>
Reference-contexts: A 3-bit counter, used to cycle a process through 8 steps. matrix. A 3 3 matrix of data used to store values received during the information exchange. icv. The 1 4 interactive consistency vector for this process. ICV <ref> [3] </ref> holds the process's local value, derived from the sense input. The inter-connection of the processes to accomplish information exchange is depicted in Figure 3. Each arrow represents one-way communication. <p> The purpose of each step is described below. The steps are numbered by the value of the 3-bit counter. The four processes share the clock input and hence perform these steps synchronously. 0. Read the sensed input. Save this as the process's local value in ICV <ref> [3] </ref>. Also, place this value on the output lines to the other three processes. This begins the report of each process's local value to all of the other processes. 1. Receive the local values of the other three processes, and store them in row 0 of the matrix. 2,3. <p> This implies that the filter function defined on the interactive consistency vector must be invariant under rotations of its vector argument. 10 actuator value is computed on the next cycle. Case Counter: 0: data_out [i] sense, i -0, 1, 2 icv <ref> [3] </ref> sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input [1] data_out [1] input [0] data_out [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: <p> How can we convince ourselves that this is true? Our design is fairly simple, but has some tricky details where mistakes can easily be made. To convince ourselves of this assertion we have proved the design correct, and mechanically checked the proof with the Boyer-Moore theorem prover <ref> [2, 3] </ref>. The specification and proof of correctness consists of the following elements. 11 Correctness of the function OM. The function OM is defined in the Boyer-Moore logic, and is proved to satisfy interactive consistency conditions. * The Circuit Specification Function.
Reference: 1. <institution> Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 </institution>
Reference-contexts: We then defined a low-level characterization of the algorithm and proved that our low-level version is a correct implementation of our high-level version. As a consequence of this proof, we are guaranteed that our low-level implementation achieves interactive consistency. An earlier paper <ref> [1] </ref> reports on our work to describe our abstract implementation of the algorithm in the Boyer-Moore logic. We stated the interactive consistency conditions in the logic, and used the Boyer-Moore theorem prover to check a proof that our formalization of OM satisfies these conditions. <p> Lamport, Shostak and Pease [4] prove that OM is guaranteed to achieve interactive consistency only if n is greater than three times the number of faulty processes. The number of rounds of information exchange m must be at least the number of faulty processes. An accompanying paper <ref> [1] </ref> presents our formal definition of OM, and describes our mechanically checked proof that our formalization of the algorithm produces a vector which satisfies the interactive consistency conditions. Our formal statements of the two theorems that OM satisfies IC1 and IC2, respectively, are given below. <p> Case Counter: 0: data_out [i] sense, i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input <ref> [1] </ref> data_out [1] input [0] data_out [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], <p> Case Counter: 0: data_out [i] sense, i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input <ref> [1] </ref> data_out [1] input [0] data_out [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], <p> 0: data_out [i] sense, i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input <ref> [1] </ref> data_out [1] input [0] data_out [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], matrix [2,1]) icv [1] majority (matrix [0,1], matrix [1,0], matrix [2,2]) icv [2] majority (matrix [0,2], matrix [1,1], matrix [2,0]) clock clock+1 5: <p> [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out <ref> [1] </ref> matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], matrix [2,1]) icv [1] majority (matrix [0,1], matrix [1,0], matrix [2,2]) icv [2] majority (matrix [0,2], matrix [1,1], matrix [2,0]) clock clock+1 5: Actuator filter (icv) clock clock+1 6: clock clock+1 7: clock clock+1 4.

Reference: 3. <institution> The Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 </institution>
Reference-contexts: A 3-bit counter, used to cycle a process through 8 steps. matrix. A 3 3 matrix of data used to store values received during the information exchange. icv. The 1 4 interactive consistency vector for this process. ICV <ref> [3] </ref> holds the process's local value, derived from the sense input. The inter-connection of the processes to accomplish information exchange is depicted in Figure 3. Each arrow represents one-way communication. <p> The purpose of each step is described below. The steps are numbered by the value of the 3-bit counter. The four processes share the clock input and hence perform these steps synchronously. 0. Read the sensed input. Save this as the process's local value in ICV <ref> [3] </ref>. Also, place this value on the output lines to the other three processes. This begins the report of each process's local value to all of the other processes. 1. Receive the local values of the other three processes, and store them in row 0 of the matrix. 2,3. <p> This implies that the filter function defined on the interactive consistency vector must be invariant under rotations of its vector argument. 10 actuator value is computed on the next cycle. Case Counter: 0: data_out [i] sense, i -0, 1, 2 icv <ref> [3] </ref> sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input [1] data_out [1] input [0] data_out [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: <p> How can we convince ourselves that this is true? Our design is fairly simple, but has some tricky details where mistakes can easily be made. To convince ourselves of this assertion we have proved the design correct, and mechanically checked the proof with the Boyer-Moore theorem prover <ref> [2, 3] </ref>. The specification and proof of correctness consists of the following elements. 11 Correctness of the function OM. The function OM is defined in the Boyer-Moore logic, and is proved to satisfy interactive consistency conditions. * The Circuit Specification Function.
Reference: 4. <institution> The Proof of Correctness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 </institution>
Reference-contexts: 1. Introduction A key problem facing the designers of systems which attempt to ensure fault tolerance by redundant processing is how to guarantee that the processors reach agreement, even when one or more processing units are faulty. Pease, Shostak and Lamport <ref> [5, 4] </ref> have devised the notion of interactive consistency, which formally characterizes what it means for non-faulty processors to reach agreement. <p> Lamport, Shostak, and Pease <ref> [4] </ref> describe the problem in terms of the metaphor of Byzantine Generals attempting to arrive at a common battle plan through an exchange of messages. One or more of the generals may be traitorous and attempt to thwart the loyal generals by preventing them from reaching agreement. <p> All loyal lieutenants obey the same order; IC2. If the commanding general is loyal, then every loyal lieutenant obeys the order he sends. Conditions IC1 and IC2 are called the interactive consistency conditions. <ref> [4] </ref> The interactive consistency conditions can be formalized fairly straightforwardly. Let n be some number -of processes. Let v be a vector of length n, where v [i] is the local value of process i, i -0, ..., n - 1-. <p> Our Boyer-Moore function OM takes four parameters: n, the number of processes; g, the name of the general; x = v [g], the general's local value; and m, an integer which determines the number of rounds of information exchange to take place. Lamport, Shostak and Pease <ref> [4] </ref> prove that OM is guaranteed to achieve interactive consistency only if n is greater than three times the number of faulty processes. The number of rounds of information exchange m must be at least the number of faulty processes.
Reference: 5. <institution> Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 i </institution>
Reference-contexts: 1. Introduction A key problem facing the designers of systems which attempt to ensure fault tolerance by redundant processing is how to guarantee that the processors reach agreement, even when one or more processing units are faulty. Pease, Shostak and Lamport <ref> [5, 4] </ref> have devised the notion of interactive consistency, which formally characterizes what it means for non-faulty processors to reach agreement. <p> have the following. -IC1. faulty (i) & faulty (j) fi w [i] = w [j] g g -IC2. faulty (g) & faulty (i) fi w [i] = v [g] g 4 We have formalized in the Boyer-Moore logic a version of the Oral Messages algorithm of Pease, Shostak, and Lamport <ref> [5] </ref>. This algorithm, and our (abstract) implementation of it in the form of a function OM in the Boyer-Moore logic, produces a vector w which satisfies the interactive consistency conditions. The vector is computed after some number of rounds of information exchange among the processes.
References-found: 7

