URL: http://www.iro.umontreal.ca/~mckenzie/camcthvo97.ps
Refering-URL: http://www.iro.umontreal.ca/~mckenzie/publications.html
Root-URL: http://www.iro.umontreal.ca
Title: Nondeterministic NC 1 computation  
Author: Herve Caussinus and Pierre McKenzie Denis Therien Heribert Vollmer 
Note: Work supported by NSERC of Canada and by FCAR du Quebec. Research performed while the author held a visiting position at the  ported by the Alexander von Humboldt Foundation under a Feodor Lynen scholarship.  
Address: C.P. 6128, Succursale Centre-ville Montreal (Quebec), H3C 3J7 Canada  3480 University Street Am Exerzierplatz 3 Montreal (Quebec), H3A 2A7 Canada 97072 Wurzburg, Germany  Santa Barbara, Santa Barbara, CA 93105. Sup  
Affiliation: Dep. d'informatique et recherche operationnelle Universite de Montreal  School of Computer Science Theoretische Informatik McGill University Universitat Wurzburg  Department of Mathematics, University of California at  
Abstract: We define the counting classes #NC 1 , GapNC 1 , PNC 1 and C = NC 1 . We prove that boolean circuits, algebraic circuits, programs over nondeterministic finite automata, and programs over constant integer matrices yield equivalent definitions of the latter three classes. We investigate closure properties. We observe that #NC 1 #L, that PNC 1 L, and that C = NC 1 L. Then we exploit our finite automaton model and extend the padding techniques used to investigate leaf languages. Finally, we draw some consequences from the resulting body of leaf language characterizations of complexity classes, including the unconditional separations of ACC 0 from MOD-PH and that of TC 0 from the counting hierarchy. Moreover we obtain that if dlogtime-uniformity and logspace-uniformity for AC 0 coincide then the polynomial time hierarchy equals PSPACE . 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Allender. </author> <title> A note on uniform circuit lower bounds for the counting hierarchy. </title> <booktitle> Proc. 2nd International Computing and Combinatorics Conference (COCOON), Springer Lecture Notes in Computer Science Vol. </booktitle> <volume> 1090, </volume> <pages> pages 127-135, </pages> <year> 1996. </year>
Reference-contexts: Some of our separations have in the meantime been reproved by Eric Allender using "traditional" (i.e., non leaf-language) techniques <ref> [1] </ref>. Finally, we obtain two nontrivial technical improvements to the known leaf language characterizations of PSPACE : we prove that NC 1 leaf languages over one-counter deterministic context-free languages and NC 1 leaf languages over linear deterministic context-free languages each capture the class PSPACE . <p> What can be made of these? How much further, if at all, can such characterizations be improved? From leaf language considerations, we have also deduced separations between complexity classes; these results have already been taken up and improved by Eric Allender (see <ref> [1] </ref>). A model which we chose not to exploit in the present paper is the program-over-monoid model, instrumental to the known algebraic characterizations of NC 1 subclasses (see [6, 8, 29]). However, nondeterminism can be introduced into that model in natural ways.
Reference: [2] <author> E. Allender and M. Ogihara. </author> <title> Relationships among PL, #L, and the determinant. </title> <booktitle> Proc. 9th Structure in Complexity Theory, </booktitle> <pages> pages 267-278, </pages> <year> 1994. </year>
Reference-contexts: Corollary 4.11 PNC 1 is closed under union and intersection. Proof. Follows from the established closure properties by reproducing the corresponding proof for PP from [10] or for PL from <ref> [2] </ref> essentially word for word. We remark that in addition to the above it can be shown e.g. that #BP is closed under weak summation and weak product, that FNC 1 #BP , and that #NC 1 is closed under binomial coefficients.
Reference: [3] <author> E. Allender and V. </author> <title> Gore. </title> <booktitle> On strong separations from AC 0 . Proc. 8th Fundamentals of Computation Theory, Springer Lecture Notes in Computer Science Vol. </booktitle> <volume> 529, </volume> <pages> pages 1-15, </pages> <year> 1991. </year>
Reference-contexts: If ACC 0 is equal to logspace-uniform ACC 0 then we have MOD-PH = PSPACE . 3. If TC 0 is equal to logspace-uniform TC 0 then we have CH = PSPACE . What can be said about a converse to Corollary 5.6? 4 Using padding tricks as in <ref> [3] </ref> one can show that e.g. the collapse of logspace and dlogtime uniformity for AC 0 is equivalent to the identity of linear space and the alternating linear time hierarchy. Certainly, the latter equality immediately implies PH = PSPACE , but it is not known if the converse holds. <p> For reasons 4 In our original abstract (Proceedings of the 11th IEEE Conference on Computational Complexity 1996, pages 12-21) we mentioned that a converse could be proved using ideas from <ref> [3] </ref>.
Reference: [4] <author> E. Allender and V. Gore. </author> <title> A uniform circuit lower bound for the permanent. </title> <journal> SIAM Journal on Computing, </journal> <volume> 23 </volume> <pages> 1026-1049, </pages> <year> 1994. </year>
Reference-contexts: The proof for the first claim is completely analogous. Corollary 5.4 1. ACC 0 6= MOD-PH. 2. TC 0 6= CH. Proof. Immediate from Theorem 5.3 and known leaf language characteri-zations from [19, 21]. Statement 1 of Corollary 5.4 improves a result by Allender and Gore <ref> [4] </ref> who showed that ACC 0 ae C = P .
Reference: [5] <author> C. Alvarez and B. Jenner. </author> <title> A very hard log-space counting class. </title> <journal> Theoretical Computer Science, </journal> <volume> 107 </volume> <pages> 3-30, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Counting classes have been studied extensively since the introduction of #P by Valiant [35]. A number of such classes were first defined in the context of polynomial time computation [24, 17]. Then, the logspace counting class #L was investigated <ref> [5] </ref>, together with many logspace variants adapted from the polynomial time case. Recently, counting classes based on finite model theory and on one-way logspace have been considered as well [31, 13].
Reference: [6] <author> D. </author> <title> Mix Barrington. Bounded-width polynomial-size branching programs recognize exactly those languages in N C 1 . Journal of Computer and System Sciences, </title> <booktitle> 38 </booktitle> <pages> 150-164, </pages> <year> 1989. </year>
Reference-contexts: Motivated by Barrington's characterization of NC 1 via bounded-width branching programs of polynomial size <ref> [6] </ref>, we also consider a class we call #BP . (A better name perhaps would be #BWBP to make clear that we are talking about bounded width, but we chose to use the shorter #BP .) This class is defined by counting accepting paths in nondeterministic branching programs (these are branching <p> Example. A "uniform projection over " is nothing but a (uniform) projection, in the sense of [34], or a (uniform) M -program viewed as a mapping from fl to fl with M , in the sense of <ref> [6, 29] </ref>. For example, refer to the M -program described on page 337 of [29], and let = f0; 1g and = fa; b; c; eg. Consider the instructions i , 1 i 2bn=2c, and the set F ae M , defined there. <p> When applied to a uniform logarithmic depth circuit family, their reduction yields as an intermediate step a projection to the matrix product problem. As argued by the authors of [11], this projection can be made DLOGTIME-uniform 2 , given the close analogy with the reductions in <ref> [6, 7] </ref>. Thus ALG 1 (Z) BPM (Z) since the finite set of ring elements used as inputs to the algebraic circuit give rise to a finite set of possible matrices. <p> sequence of constant dimension matrices over the integers f1; 0; 1g, compute a specific entry in the matrix product. (b) Given a sequence of constant dimension matrices over integers expressed in binary notation, compute a specific entry in the matrix product. 2 DLOGTIME uniformity of programs in the sense of <ref> [6, 7, 9] </ref> differs from our definition of program uniformity in that the former requires DLOGTIME recognition of a description language for programs akin to the direct connection language for circuits. However, the two definitions are equivalent in all interesting situations, because, for example, although [6, 7, 9] do not formally <p> programs in the sense of <ref> [6, 7, 9] </ref> differs from our definition of program uniformity in that the former requires DLOGTIME recognition of a description language for programs akin to the direct connection language for circuits. However, the two definitions are equivalent in all interesting situations, because, for example, although [6, 7, 9] do not formally require the ability to compute the length of a program in log time, any program of interest can be padded to length 2 l , where l is the length of the field of bits allocated to instruction numbers in the description language, and 2 <p> For later use, we mention that the class NC 1 is unchanged if unambiguous circuits alone are used to define it, as can be seen using techniques from [25], or by simply observing that the NC 1 circuit evaluating a permutation branching program from <ref> [6] </ref> is unambiguous. 4 Closure properties Clearly all the function classes examined in the previous sections are closed under addition and multiplication. <p> The automaton will never change its state when reading the symbol $, so we assume for simplicity that P K (x) 2 QBF ? . Now consider a "Barrington word" <ref> [6] </ref>, defined over the group S 5 and the variables X and Y as 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 This word was obtained using Barrington's construction [6] on the constant size f:; ^g-circuit for NAND (X; Y ). <p> Now consider a "Barrington word" <ref> [6] </ref>, defined over the group S 5 and the variables X and Y as 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 This word was obtained using Barrington's construction [6] on the constant size f:; ^g-circuit for NAND (X; Y ). This word has the property that it calculates NAND (X; Y ) if the identity permutation () represents "false" and the permutation (12345) represents "true". <p> A model which we chose not to exploit in the present paper is the program-over-monoid model, instrumental to the known algebraic characterizations of NC 1 subclasses (see <ref> [6, 8, 29] </ref>). However, nondeterminism can be introduced into that model in natural ways. The first author has shown [16] that much of the padding discussed in the present paper can be performed using very restricted monoids.
Reference: [7] <author> D. Barrington, N. Immerman and H. Straubing, </author> <title> On uniformity within N C 1 , Journal of Computer and System Sciences, </title> <address> 41:3:274-306, </address> <year> 1990. </year>
Reference-contexts: j) belong to FDLOGTIME (i.e. the complete logarithmic-length output can be computed in logarithmic time, which is stronger than requiring that each output bit separately be computable in logarithmic time, as is sometimes done), where integers are expressed in binary notation and h; i is a pairing function as in <ref> [7, Lemma 6.1] </ref>. A proof that uniform projections are transitive can be found in [16]. 4 For the following definitions we fix a semiring (R; +; fi). The semirings considered in this paper are the semiring N and the ring Z. <p> We say that a language A fl uniformly projects to a language B fl iff the characteristic function of A uniformly projects to that of B. Note that uniform projection reducibility implies DLOGTIME reducibility as defined for example in <ref> [7] </ref>. Example. A "uniform projection over " is nothing but a (uniform) projection, in the sense of [34], or a (uniform) M -program viewed as a mapping from fl to fl with M , in the sense of [6, 29]. <p> The other nodes are boolean AND or OR gates of indegree 2. There is one node of outdegree 0, called the output. A boolean circuit is a family C = (C n ) n2N of boolean n-circuits C n . The direct connection language <ref> [30, 7] </ref> of C is the set of tuples ht; a; b; yi, specifying that gate numbered a, of type t, is input to gate numbered b in C jyj (with appropriate conventions when a is an input gate). C is uniform if its direct connection language is in DLOGTIME. <p> When applied to a uniform logarithmic depth circuit family, their reduction yields as an intermediate step a projection to the matrix product problem. As argued by the authors of [11], this projection can be made DLOGTIME-uniform 2 , given the close analogy with the reductions in <ref> [6, 7] </ref>. Thus ALG 1 (Z) BPM (Z) since the finite set of ring elements used as inputs to the algebraic circuit give rise to a finite set of possible matrices. <p> sequence of constant dimension matrices over the integers f1; 0; 1g, compute a specific entry in the matrix product. (b) Given a sequence of constant dimension matrices over integers expressed in binary notation, compute a specific entry in the matrix product. 2 DLOGTIME uniformity of programs in the sense of <ref> [6, 7, 9] </ref> differs from our definition of program uniformity in that the former requires DLOGTIME recognition of a description language for programs akin to the direct connection language for circuits. However, the two definitions are equivalent in all interesting situations, because, for example, although [6, 7, 9] do not formally <p> programs in the sense of <ref> [6, 7, 9] </ref> differs from our definition of program uniformity in that the former requires DLOGTIME recognition of a description language for programs akin to the direct connection language for circuits. However, the two definitions are equivalent in all interesting situations, because, for example, although [6, 7, 9] do not formally require the ability to compute the length of a program in log time, any program of interest can be padded to length 2 l , where l is the length of the field of bits allocated to instruction numbers in the description language, and 2
Reference: [8] <author> D. Barrington and D. Therien, </author> <title> Finite Monoids and the Fine Structure of NC 1 , Journal of the Association of Computing Machinery, </title> <address> 35:4:941-952, </address> <year> 1988. </year>
Reference-contexts: A model which we chose not to exploit in the present paper is the program-over-monoid model, instrumental to the known algebraic characterizations of NC 1 subclasses (see <ref> [6, 8, 29] </ref>). However, nondeterminism can be introduced into that model in natural ways. The first author has shown [16] that much of the padding discussed in the present paper can be performed using very restricted monoids.
Reference: [9] <author> F. Bedard, F. Lemieux and P. McKenzie, </author> <title> Extensions to Barrington's M -program model, </title> <type> Theoret. </type> <institution> Comp. Sci. A 107:1:31-61, </institution> <year> 1993. </year>
Reference-contexts: sequence of constant dimension matrices over the integers f1; 0; 1g, compute a specific entry in the matrix product. (b) Given a sequence of constant dimension matrices over integers expressed in binary notation, compute a specific entry in the matrix product. 2 DLOGTIME uniformity of programs in the sense of <ref> [6, 7, 9] </ref> differs from our definition of program uniformity in that the former requires DLOGTIME recognition of a description language for programs akin to the direct connection language for circuits. However, the two definitions are equivalent in all interesting situations, because, for example, although [6, 7, 9] do not formally <p> programs in the sense of <ref> [6, 7, 9] </ref> differs from our definition of program uniformity in that the former requires DLOGTIME recognition of a description language for programs akin to the direct connection language for circuits. However, the two definitions are equivalent in all interesting situations, because, for example, although [6, 7, 9] do not formally require the ability to compute the length of a program in log time, any program of interest can be padded to length 2 l , where l is the length of the field of bits allocated to instruction numbers in the description language, and 2
Reference: [10] <author> R. Beigel, N. Reingold, and D. Spielman. </author> <title> P P is closed under intersection. </title> <booktitle> Proc. 23rd Symposium on Theory of Computing, </booktitle> <pages> pages 1-9, </pages> <year> 1991. </year>
Reference-contexts: Corollary 4.11 PNC 1 is closed under union and intersection. Proof. Follows from the established closure properties by reproducing the corresponding proof for PP from <ref> [10] </ref> or for PL from [2] essentially word for word. We remark that in addition to the above it can be shown e.g. that #BP is closed under weak summation and weak product, that FNC 1 #BP , and that #NC 1 is closed under binomial coefficients.
Reference: [11] <author> M. Ben-Or and R. Cleve. </author> <title> Computing algebraic formulas using a constant number of register. </title> <journal> SIAM Journal on Computing, </journal> <volume> 21(1) </volume> <pages> 54-58, </pages> <year> 1992. </year>
Reference-contexts: 1 It is well known that adding nondeterministic input bits to an NC 1 circuit results in a computation model powerful enough to solve NP-complete problems (see e.g. [31, 37]). 2 acterized by what we call programs over constant matrices; and then we use a result by Ben-Or and Cleve <ref> [11] </ref> who show that evaluating an arithmetic circuit reduces to iterated product of constant-size matrices. <p> The function (a) belongs to #BP by the transitivity of uniform projections. Theorem 3.3 GapBP = BPM (Z) = ALG 1 (Z) = GapNC 1 : Proof. The inclusion GapNC 1 ALG 1 (Z) follows from #NC 1 ALG 1 (N) (Theorem 3.1). Now Ben-Or and Cleve <ref> [11] </ref> reduce evaluating an algebraic formula over a ring R to multiplying 3fi3 matrices whose entries other than 0 and 1 are chosen from the inputs to the formula. <p> When applied to a uniform logarithmic depth circuit family, their reduction yields as an intermediate step a projection to the matrix product problem. As argued by the authors of <ref> [11] </ref>, this projection can be made DLOGTIME-uniform 2 , given the close analogy with the reductions in [6, 7]. Thus ALG 1 (Z) BPM (Z) since the finite set of ring elements used as inputs to the algebraic circuit give rise to a finite set of possible matrices.
Reference: [Bo77] <author> A. Borodin, </author> <title> On relating time and space to size and depth, </title> <journal> SIAM Journal on Computing, </journal> <volume> 6:4:733-744, </volume> <year> 1977. </year>
Reference-contexts: Equality of #NC 1 and ALG 1 (N) is folklore, see e.g. [22, 36]. Finally, to show #NC 1 #L, consider a #NC 1 circuit. A nondeterministic logspace machine can perform a modified depth-first search of this circuit, adapting Borodin's NC 1 L proof <ref> [Bo77] </ref>, as follows. The search starts at the output gate and proceeds towards the inputs, choosing a wire nondeterministically when it hits an OR gate, and proceeding normally when it hits an AND gate. The computation accepts when a proof that the output gate evaluates to one is found.
Reference: [12] <author> D. Bovet, P. Crescenzi, and R. Silvestri. </author> <title> A uniform approach to define complexity classes. </title> <journal> Theoretical Computer Science, </journal> <volume> 104 </volume> <pages> 263-283, </pages> <year> 1992. </year>
Reference-contexts: latter name better reflects the fact that the leaf language class obtained is a refinement of the leaf language classes defined using log space or polynomial time machines. 15 5.1 Padding techniques Leaf language classes have been studied in the context of polynomial time, logarithmic space, and logarithmic time computations <ref> [12, 19, 20, 21] </ref>. The numerous characterizations obtained in those papers make use of padding. Here we observe that in some sense the padding can be done by an automaton. This allows transferring in one blow many known characterizations to the Leaf NC 1 () setting.
Reference: [13] <author> H.-J. Burtschick. </author> <title> Comparing Counting Classes for Logspace, One-Way Logspace, and First-Order. </title> <booktitle> Proc. 20th Symposium on Mathematical Foundations of Computer Science, Springer Lecture Notes in Computer Science Vol. </booktitle> <volume> 969, </volume> <pages> pages 139-148, </pages> <year> 1995. </year>
Reference-contexts: Then, the logspace counting class #L was investigated [5], together with many logspace variants adapted from the polynomial time case. Recently, counting classes based on finite model theory and on one-way logspace have been considered as well <ref> [31, 13] </ref>.
Reference: [14] <author> S. Buss, S. Cook, A. Gupta and V. Ramachandran, </author> <title> An optimal parallel algorithm for formula evaluation, </title> <journal> SIAM Journal on Computing, </journal> <volume> 21:4:755-780, </volume> <year> 1992. </year>
Reference-contexts: Beyond a struggle with DLOGTIME-uniformity, this question again seems to bring to the fore the question of how efficiently an algebraic formula over a semiring can be balanced (see for instance <ref> [14] </ref>). In Section 5 of this paper, we have refined leaf language characterizations of complexity classes. In particular, we now have delicate characterizations of PSPACE in terms of restricted context-free languages and (projections over) automata.
Reference: [15] <author> P.-F. Dietz, I. Macarie, and J. Seiferas, </author> <title> Bits and relative order from residues, space efficiently, </title> <journal> Information Processing Letters, </journal> <volume> 50:3:123-127, </volume> <year> 1994. </year>
Reference-contexts: All equalities are immediate consequences of Theorem 3.3. Now Lipton and Zalcstein show that a logspace machine can check BPM (Z) calculations for equality with zero by carrying it out modulo enough small primes, proving C =0 BPM (Z) L [27]. Ioan Macarie ([28], see also <ref> [15] </ref>) shows that two natural numbers represented by their residues modulo appropriately many small primes can be compared in log space, implying that determining if a given entry in a product of constant size matrices over the integers can be done in log space, which proves C BP L.
Reference: [16] <author> H. Caussinus. Contributions a l'etude du non-determinisme restreint. Ph. D. </author> <type> thesis, </type> <institution> University of Montreal, </institution> <year> 1996. </year>
Reference-contexts: A proof that uniform projections are transitive can be found in <ref> [16] </ref>. 4 For the following definitions we fix a semiring (R; +; fi). The semirings considered in this paper are the semiring N and the ring Z. <p> The details of the construction of this projection, which are tedious but which require no new ideas besides those just sketched, can be found in <ref> [16] </ref>. <p> We leave it to the reader to solve the puzzle of how to use the second half of to create exactly the right number of leaves (or see <ref> [16] </ref>). In o (q), the leftmost leaf is a state q leaf, and all other leaves are state q # leaves, for some new state q # for which we set F (q # ) to #. <p> A model which we chose not to exploit in the present paper is the program-over-monoid model, instrumental to the known algebraic characterizations of NC 1 subclasses (see [6, 8, 29]). However, nondeterminism can be introduced into that model in natural ways. The first author has shown <ref> [16] </ref> that much of the padding discussed in the present paper can be performed using very restricted monoids. Interesting questions concerning the algebraic properties of the monoids simulating nondeterminism arise, and these may also provide an interesting avenue for future research.
Reference: [17] <author> S. Fenner, L. Fortnow, and S. Kurtz. </author> <title> Gap-definable counting classes. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 48 </volume> <pages> 116-148, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction Counting classes have been studied extensively since the introduction of #P by Valiant [35]. A number of such classes were first defined in the context of polynomial time computation <ref> [24, 17] </ref>. Then, the logspace counting class #L was investigated [5], together with many logspace variants adapted from the polynomial time case. Recently, counting classes based on finite model theory and on one-way logspace have been considered as well [31, 13]. <p> We come back to this issue in the next section. Corollary 3.5 motivates defining PNC 1 as C NC 1 . Observe that PP is defined analogously in terms of GapP functions in <ref> [17] </ref>. Corollary 3.6 The following languages are C = NC 1 -complete (resp. <p> Corollary 4.10 GapNC 1 is closed under subtraction, weak sum, weak prod uct, and binomial coefficients. Proof. The only nontrivial point is closure under binomial coefficients, but this follows from the other closure properties by expressing binomial coefficients involving negative numbers as in <ref> [17] </ref> using differences of binomial coefficients with only nonnegative numbers. Corollary 4.11 PNC 1 is closed under union and intersection. Proof. Follows from the established closure properties by reproducing the corresponding proof for PP from [10] or for PL from [2] essentially word for word.
Reference: [18] <author> U. Hertrampf. </author> <title> Complexity classes defined via k-valued logic. </title> <booktitle> Proc. 9th Structure in Complexity Theory, </booktitle> <pages> pages 224-234, </pages> <year> 1994. </year>
Reference-contexts: Which value to take and which function to evaluate depends only on the state of the machine. For an exact definition, see <ref> [18, 20] </ref>.) Then we can state the following: Theorem 5.1 Leaf NC 1 ((F )LOGTIME) = (F )P . 16 Proof. <p> Leaf NC 1 (AC 0 ) = PH . 4. Leaf NC 1 (ACC 0 ) = MOD-PH. 5. Leaf NC 1 (TC 0 ) = CH. 6. Leaf NC 1 (NC 1 ) = PSPACE . Proof. All mentioned classes are locally definable as shown in <ref> [18, 20] </ref>. Using our leaf language padding techniques we can now observe the following: Theorem 5.3 1. If C L Leaf NC 1 (C), then C 6= Leaf NC 1 (C). 2. If C P Leaf NC 1 (C), then C 6= Leaf NC 1 (C). Proof.
Reference: [19] <author> U. Hertrampf, C. Lautemann, T. Schwentick, H. Vollmer, and K.W. Wagner. </author> <title> On the power of polynomial time bit-reductions. </title> <booktitle> Proc. 8th Structure in Complexity Theory, </booktitle> <pages> pages 200-207, </pages> <year> 1993. </year>
Reference-contexts: We then proceed to refine known leaf language characterizations of complexity classes, using the formal framework of leaf languages for branching programs (which we call NC 1 leaf languages). We argue that many charac-terizability results carry over from the polynomial time <ref> [19] </ref> and logspace [21] cases to that of NC 1 . We then draw consequences from the leaf language characterizations. <p> latter name better reflects the fact that the leaf language class obtained is a refinement of the leaf language classes defined using log space or polynomial time machines. 15 5.1 Padding techniques Leaf language classes have been studied in the context of polynomial time, logarithmic space, and logarithmic time computations <ref> [12, 19, 20, 21] </ref>. The numerous characterizations obtained in those papers make use of padding. Here we observe that in some sense the padding can be done by an automaton. This allows transferring in one blow many known characterizations to the Leaf NC 1 () setting. <p> If C L Leaf NC 1 (C), then C 6= Leaf NC 1 (C). 2. If C P Leaf NC 1 (C), then C 6= Leaf NC 1 (C). Proof. Suppose C P Leaf NC 1 (C) = D. If follows from <ref> [19] </ref> (translating their padding into our context, just as we did above to obtain Corollary 5.2) that then Leaf NC 1 (D) EXPTIME. Thus the assumption that C = Leaf NC 1 (C) leads to the wrong conclusion that P = EXPTIME . <p> The proof for the first claim is completely analogous. Corollary 5.4 1. ACC 0 6= MOD-PH. 2. TC 0 6= CH. Proof. Immediate from Theorem 5.3 and known leaf language characteri-zations from <ref> [19, 21] </ref>. Statement 1 of Corollary 5.4 improves a result by Allender and Gore [4] who showed that ACC 0 ae C = P .
Reference: [20] <author> U. Hertrampf, H. Vollmer, K. Wagner. </author> <title> On balanced vs. unbalanced computation trees. </title> <journal> Mathematical Systems Theory, </journal> <note> in press. </note>
Reference-contexts: latter name better reflects the fact that the leaf language class obtained is a refinement of the leaf language classes defined using log space or polynomial time machines. 15 5.1 Padding techniques Leaf language classes have been studied in the context of polynomial time, logarithmic space, and logarithmic time computations <ref> [12, 19, 20, 21] </ref>. The numerous characterizations obtained in those papers make use of padding. Here we observe that in some sense the padding can be done by an automaton. This allows transferring in one blow many known characterizations to the Leaf NC 1 () setting. <p> Which value to take and which function to evaluate depends only on the state of the machine. For an exact definition, see <ref> [18, 20] </ref>.) Then we can state the following: Theorem 5.1 Leaf NC 1 ((F )LOGTIME) = (F )P . 16 Proof. <p> For an exact definition, see [18, 20].) Then we can state the following: Theorem 5.1 Leaf NC 1 ((F )LOGTIME) = (F )P . 16 Proof. The proof follows that of Theorem 3.1 in [21] and that of Theorem 3.1 in <ref> [20] </ref>: Given A 2 Leaf NC 1 ((F )LOGTIME), composing the projection with the (F )LOGTIME decision procedure for the leaf language yields an (F )P algorithm. For the converse, let A 2 (F )P via a nondeterministic machine working in polynomial time p (n). <p> Leaf NC 1 (AC 0 ) = PH . 4. Leaf NC 1 (ACC 0 ) = MOD-PH. 5. Leaf NC 1 (TC 0 ) = CH. 6. Leaf NC 1 (NC 1 ) = PSPACE . Proof. All mentioned classes are locally definable as shown in <ref> [18, 20] </ref>. Using our leaf language padding techniques we can now observe the following: Theorem 5.3 1. If C L Leaf NC 1 (C), then C 6= Leaf NC 1 (C). 2. If C P Leaf NC 1 (C), then C 6= Leaf NC 1 (C). Proof.
Reference: [21] <author> B. Jenner, P. McKenzie, and D. Therien. </author> <title> Logspace and logtime leaf languages. </title> <booktitle> Proc. 9th Structure in Complexity Theory, </booktitle> <pages> pages 242-254, </pages> <year> 1994. </year>
Reference-contexts: We then proceed to refine known leaf language characterizations of complexity classes, using the formal framework of leaf languages for branching programs (which we call NC 1 leaf languages). We argue that many charac-terizability results carry over from the polynomial time [19] and logspace <ref> [21] </ref> cases to that of NC 1 . We then draw consequences from the leaf language characterizations. <p> latter name better reflects the fact that the leaf language class obtained is a refinement of the leaf language classes defined using log space or polynomial time machines. 15 5.1 Padding techniques Leaf language classes have been studied in the context of polynomial time, logarithmic space, and logarithmic time computations <ref> [12, 19, 20, 21] </ref>. The numerous characterizations obtained in those papers make use of padding. Here we observe that in some sense the padding can be done by an automaton. This allows transferring in one blow many known characterizations to the Leaf NC 1 () setting. <p> For an exact definition, see [18, 20].) Then we can state the following: Theorem 5.1 Leaf NC 1 ((F )LOGTIME) = (F )P . 16 Proof. The proof follows that of Theorem 3.1 in <ref> [21] </ref> and that of Theorem 3.1 in [20]: Given A 2 Leaf NC 1 ((F )LOGTIME), composing the projection with the (F )LOGTIME decision procedure for the leaf language yields an (F )P algorithm. <p> The proof for the first claim is completely analogous. Corollary 5.4 1. ACC 0 6= MOD-PH. 2. TC 0 6= CH. Proof. Immediate from Theorem 5.3 and known leaf language characteri-zations from <ref> [19, 21] </ref>. Statement 1 of Corollary 5.4 improves a result by Allender and Gore [4] who showed that ACC 0 ae C = P . <p> Then we give a two-fold improvement to the surprising (but already somewhat technical) result, shown in <ref> [21] </ref>, that Leaf Logspace (DCFL) = PSPACE : first, we can produce the leaf string with an automaton instead of a log space Turing machine, and second, the language at the leaves can be taken to be a linear deterministic language. (A context-free language is said to be linear if it <p> This concludes the proof that PSPACE Leaf NC 1 (logspace-uniform AC 0 ); the reverse in clusion follows from the known fact that Leaf NC 1 (L) PSPACE <ref> [21] </ref>. Corollary 5.6 1. If AC 0 is equal to logspace-uniform AC 0 then we have PH = PSPACE . 2. If ACC 0 is equal to logspace-uniform ACC 0 then we have MOD-PH = PSPACE . 3. <p> We will now prove that PSPACE Leaf NC 1 (L D1C ); the reverse inclusion is imme diate from <ref> [21] </ref>. 20 We will describe a leaf automaton A = (Q, fX; X; F; ^; m; *; $g, S 5 [f#g, q 0 , ffi, F ) such that Leaf P K (L D1C ) = K, where P K is the uniform program (, fX; X; F; ^; m; *;
Reference: [22] <author> J. Jiao. </author> <title> Some questions concerning circuit counting classes and other 27 low level complexity classes. </title> <type> Manuscript. </type>
Reference-contexts: Thus we define #NC 1 as the set of functions counting the number of accepting proof trees of NC 1 circuits. (This definition has also been suggested by Jia Jiao <ref> [22] </ref>.) It is common folklore that this class equals the class of functions computed by logarithmic depth arithmetic circuits over the semiring of the natural numbers. <p> graph that results from unwinding the circuit C n into a tree, having the following three properties: each OR gate has indegree one, each AND gate has indegree two, and it evaluates to 1. (That we unwind the circuit into a tree before counting proof trees follows recent literature, e.g. <ref> [22, 36] </ref>.) We denote by #accept (C; x) the number of proof trees for x. 5 A function f : fl ! N is in #NC 1 iff there exists a uniform boolean circuit C such that f (x) = #accept (C; x). <p> Equality of #NC 1 and ALG 1 (N) is folklore, see e.g. <ref> [22, 36] </ref>. Finally, to show #NC 1 #L, consider a #NC 1 circuit. A nondeterministic logspace machine can perform a modified depth-first search of this circuit, adapting Borodin's NC 1 L proof [Bo77], as follows.
Reference: [23] <author> H. Jung. </author> <title> Depth efficient transformations of arithmetic into boolean circuits. </title> <booktitle> Proc. Foundations of Computation Theory, Springer Lecture Notes in Computer Scienc Vol. </booktitle> <volume> 199, </volume> <pages> pages 167-173, </pages> <year> 1985. </year>
Reference-contexts: But why should life be so complicated? Hermann Jung <ref> [23] </ref> showed that arithmetic circuits of logarithmic depth 25 can be simulated by boolean circuits of depth log n log fl n.
Reference: [24] <author> J. Kobler, U. Schoning, and J. Toran. </author> <title> On counting and approximation. </title> <journal> Acta Informatica, </journal> <volume> 26 </volume> <pages> 363-379, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Counting classes have been studied extensively since the introduction of #P by Valiant [35]. A number of such classes were first defined in the context of polynomial time computation <ref> [24, 17] </ref>. Then, the logspace counting class #L was investigated [5], together with many logspace variants adapted from the polynomial time case. Recently, counting classes based on finite model theory and on one-way logspace have been considered as well [31, 13].
Reference: [25] <author> K.-J. Lange. </author> <title> Unambiguity of circuits, </title> <journal> Theoretical Computer Science, </journal> <volume> 107 </volume> <pages> 77-94, </pages> <year> 1993. </year>
Reference-contexts: Now we say that a circuit C is unambiguous if, for each input x, #accept (C; x) 2 f0; 1g. For later use, we mention that the class NC 1 is unchanged if unambiguous circuits alone are used to define it, as can be seen using techniques from <ref> [25] </ref>, or by simply observing that the NC 1 circuit evaluating a permutation branching program from [6] is unambiguous. 4 Closure properties Clearly all the function classes examined in the previous sections are closed under addition and multiplication.
Reference: [26] <author> B. Litow. </author> <title> On iterated integer product. </title> <journal> Information Processing Letters, </journal> <volume> 42 </volume> <pages> 269-272, </pages> <year> 1992. </year>
Reference-contexts: Manindra Agrawal, Eric Allender, and Samir Datta (personal communication) obtained another proof of the latter inclusion making use of results from <ref> [26] </ref>. A natural question now is of course about the relation between C NC 1 and C = NC 1 . We come back to this issue in the next section. Corollary 3.5 motivates defining PNC 1 as C NC 1 .
Reference: [27] <author> R. J. Lipton and Y. Zalcstein. </author> <title> Word problems solvable in logspace. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 24(3) </volume> <pages> 522-526, </pages> <year> 1977. </year>
Reference-contexts: All equalities are immediate consequences of Theorem 3.3. Now Lipton and Zalcstein show that a logspace machine can check BPM (Z) calculations for equality with zero by carrying it out modulo enough small primes, proving C =0 BPM (Z) L <ref> [27] </ref>.
Reference: [28] <author> I. Macarie. </author> <title> Space-efficient deterministic simulation of probabilistic automata. </title> <booktitle> Proc. 11th Symposium on Theoretical Aspects of Computing (STACS), Springer Lecture Notes in Computer Science Vol. </booktitle> <volume> 775, </volume> <pages> pages 109-122, </pages> <year> 1994 </year>
Reference: [29] <author> P. McKenzie, P. Peladeau and D. Therien, </author> <title> NC 1 : The Automata-Theoretic Viewpoint, </title> <booktitle> Computational Complexity 1, </booktitle> <pages> 330-359, </pages> <year> 1991. </year>
Reference-contexts: Example. A "uniform projection over " is nothing but a (uniform) projection, in the sense of [34], or a (uniform) M -program viewed as a mapping from fl to fl with M , in the sense of <ref> [6, 29] </ref>. For example, refer to the M -program described on page 337 of [29], and let = f0; 1g and = fa; b; c; eg. Consider the instructions i , 1 i 2bn=2c, and the set F ae M , defined there. <p> For example, refer to the M -program described on page 337 of <ref> [29] </ref>, and let = f0; 1g and = fa; b; c; eg. Consider the instructions i , 1 i 2bn=2c, and the set F ae M , defined there. <p> A model which we chose not to exploit in the present paper is the program-over-monoid model, instrumental to the known algebraic characterizations of NC 1 subclasses (see <ref> [6, 8, 29] </ref>). However, nondeterminism can be introduced into that model in natural ways. The first author has shown [16] that much of the padding discussed in the present paper can be performed using very restricted monoids.
Reference: [30] <author> W. Ruzzo, </author> <title> On uniform circuit complexity, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 22:3:365-383, </volume> <year> 1981. </year>
Reference-contexts: The other nodes are boolean AND or OR gates of indegree 2. There is one node of outdegree 0, called the output. A boolean circuit is a family C = (C n ) n2N of boolean n-circuits C n . The direct connection language <ref> [30, 7] </ref> of C is the set of tuples ht; a; b; yi, specifying that gate numbered a, of type t, is input to gate numbered b in C jyj (with appropriate conventions when a is an input gate). C is uniform if its direct connection language is in DLOGTIME.
Reference: [31] <author> S. Saluja, K. V. Subrahmanyam, and M. N. Thakur. </author> <title> Descriptive complexity of #P functions. </title> <booktitle> Proc. 7th Structure in Complexity Theory, </booktitle> <pages> pages 169-184, </pages> <year> 1992. </year>
Reference-contexts: Then, the logspace counting class #L was investigated [5], together with many logspace variants adapted from the polynomial time case. Recently, counting classes based on finite model theory and on one-way logspace have been considered as well <ref> [31, 13] </ref>. <p> This result is proved in two steps: First, we observe that #BP can be char 1 It is well known that adding nondeterministic input bits to an NC 1 circuit results in a computation model powerful enough to solve NP-complete problems (see e.g. <ref> [31, 37] </ref>). 2 acterized by what we call programs over constant matrices; and then we use a result by Ben-Or and Cleve [11] who show that evaluating an arithmetic circuit reduces to iterated product of constant-size matrices.
Reference: [32] <author> S. </author> <type> Tan, </type> <institution> Calcul et verification paralleles de problemes d'algebre lineaire, these de doctorat, Universite de Paris-Sud, U.F.R. Scientifique d'Orsay, </institution> <note> No d'ordre 3420, </note> <year> 1994. </year>
Reference-contexts: entries in M are the respective numbers of paths between the nodes labelled 1; 2; : : : ; k in the first layer of G M and the nodes labelled 1; 2; : : : ; k in the last layer of G M (see for instance [33] or <ref> [32, p. 42] </ref> for the crucial step in this construction). The automaton in the #BP instance will thus have 3k 2 states and its alphabet will be ft : [3k 2 ] ! [3k 2 ]g.
Reference: [33] <author> S. </author> <title> Toda. Classes of arithmetic circuits capturing the complexity of computing the determinant. </title> <journal> IEICE Transactions on Communications/Electronics/Information and Systems, </journal> <volume> E75-D: </volume> <pages> 116-124, </pages> <year> 1992. </year>
Reference-contexts: k 2 entries in M are the respective numbers of paths between the nodes labelled 1; 2; : : : ; k in the first layer of G M and the nodes labelled 1; 2; : : : ; k in the last layer of G M (see for instance <ref> [33] </ref> or [32, p. 42] for the crucial step in this construction). The automaton in the #BP instance will thus have 3k 2 states and its alphabet will be ft : [3k 2 ] ! [3k 2 ]g.
Reference: [34] <author> L. Valiant, </author> <title> Completeness classes in algebra, </title> <booktitle> Proc. 11th Symposium on Theory of Computing, </booktitle> <pages> pages 249-261, </pages> <year> 1979. </year>
Reference-contexts: Note that uniform projection reducibility implies DLOGTIME reducibility as defined for example in [7]. Example. A "uniform projection over " is nothing but a (uniform) projection, in the sense of <ref> [34] </ref>, or a (uniform) M -program viewed as a mapping from fl to fl with M , in the sense of [6, 29]. For example, refer to the M -program described on page 337 of [29], and let = f0; 1g and = fa; b; c; eg.
Reference: [35] <author> L. Valiant. </author> <title> The complexity of computing the permanent. </title> <journal> Theor. Comp. Sci. </journal> <volume> 8 </volume> <pages> 189-201, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction Counting classes have been studied extensively since the introduction of #P by Valiant <ref> [35] </ref>. A number of such classes were first defined in the context of polynomial time computation [24, 17]. Then, the logspace counting class #L was investigated [5], together with many logspace variants adapted from the polynomial time case.
Reference: [36] <author> V. Vinay. </author> <title> Counting auxiliary pushdown automata and semi-unbounded arithmetic circuits. </title> <booktitle> Proc. 6th Structure in Complexity Theory, </booktitle> <pages> pages 28 270-284, </pages> <year> 1991. </year>
Reference-contexts: Given that the basic counting classes #P and #L are defined by counting the number of accepting paths in a nondeterministic computation, what "nondeterministic NC 1 " accepting paths are there to be counted 1 ? We propose a definition inspired by Vinay's circuit characterization of #LOGCFL <ref> [36] </ref>. <p> graph that results from unwinding the circuit C n into a tree, having the following three properties: each OR gate has indegree one, each AND gate has indegree two, and it evaluates to 1. (That we unwind the circuit into a tree before counting proof trees follows recent literature, e.g. <ref> [22, 36] </ref>.) We denote by #accept (C; x) the number of proof trees for x. 5 A function f : fl ! N is in #NC 1 iff there exists a uniform boolean circuit C such that f (x) = #accept (C; x). <p> Equality of #NC 1 and ALG 1 (N) is folklore, see e.g. <ref> [22, 36] </ref>. Finally, to show #NC 1 #L, consider a #NC 1 circuit. A nondeterministic logspace machine can perform a modified depth-first search of this circuit, adapting Borodin's NC 1 L proof [Bo77], as follows.
Reference: [37] <author> H. Vollmer and K.W. Wagner. </author> <title> Recursion theoretic characterizations of complexity classes of counting functions. </title> <journal> Theoretical Computer Science, </journal> <volume> 163 </volume> <pages> 245-258, </pages> <year> 1996. </year>
Reference-contexts: This result is proved in two steps: First, we observe that #BP can be char 1 It is well known that adding nondeterministic input bits to an NC 1 circuit results in a computation model powerful enough to solve NP-complete problems (see e.g. <ref> [31, 37] </ref>). 2 acterized by what we call programs over constant matrices; and then we use a result by Ben-Or and Cleve [11] who show that evaluating an arithmetic circuit reduces to iterated product of constant-size matrices. <p> Corollary 4.7 C = NC 1 PNC 1 . To establish more closure properties of PNC 1 , we first address some nontrivial closure properties of #NC 1 and GapNC 1 . The following terminology is from <ref> [37] </ref>: Let F be a class of functions.
Reference: [38] <author> K.W. Wagner. </author> <title> Some observations on the connection between counting and recursion. </title> <journal> Theoretical Computer Science, </journal> <volume> 47 </volume> <pages> 131-147, </pages> <year> 1986. </year> <month> 29 </month>
Reference-contexts: symbol different from 0 or 1 was chosen in order to allow the machine to detect trying to read beyond its nth virtual input.) Let CH denote the counting hierarchy, i.e., the union of all classes of the oracle hierarchy obtained by using the class PP as base class (see <ref> [38] </ref>). Corollary 5.2 1. Leaf NC 1 ( k LOGTIME) = p 2. Leaf NC 1 ( k LOGTIME) = p 3. Leaf NC 1 (AC 0 ) = PH . 4. Leaf NC 1 (ACC 0 ) = MOD-PH. 5. Leaf NC 1 (TC 0 ) = CH. 6.
References-found: 39

