URL: http://www.cs.wustl.edu/~schmidt/europlop-96/papers/paper22.ps
Refering-URL: http://www.cs.wustl.edu/~schmidt/europlop-96/ww3-papers.html
Root-URL: 
Email: (kuehne@isa.informatik.th-darmstadt.de)  
Title: Recipes to Reuse  
Author: Thomas Kuhne 
Address: Magdalenenstr. 11c, D-64289 Darmstadt  
Affiliation: Department of Computer Science, TU Darmstadt  
Abstract: We propose to use objects as closures for behavior parameterization. In contrast to reuse by inheritance, they realize reuse by composition. Closures allow black-box behavior parameterization with encapsulated components, promote function reuse, allow calculations on demand, represent first-class behavior, i.e., feature protocol-, undo-, and persistence mechanisms, and can represent "business-transactions". In this paper, we present closures as the object-oriented design pattern Recipe. In contrast to the Command pattern, Recipe establishes a useful collaboration with iterators. We show in particular how to use generic recipes with iterators in order to allow multi-dispatching operations on heterogeneous data structures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Abelson and G. J. Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, London, 6. edition, </address> <year> 1987. </year>
Reference-contexts: Otherwise, all parameters of a Recipe must have the same type. Laufer proposes a solution using the Bridge pattern [13], which also covers memory management in C ++ [25]. * Languages without garbage collection are less suited to support upward-funargs 4 <ref> [1] </ref> and delayed calculations. Constructors and Destructors only work for Recipes with lifetimes determined by environment lifetimes. 2.10 Known Uses Apart from the uncountable uses of Recipes in functional programming and e.g., Scheme [1], there are many truly object-oriented uses: Smalltalk [14] features blocks as Recipes with implicit binding of free <p> management in C ++ [25]. * Languages without garbage collection are less suited to support upward-funargs 4 <ref> [1] </ref> and delayed calculations. Constructors and Destructors only work for Recipes with lifetimes determined by environment lifetimes. 2.10 Known Uses Apart from the uncountable uses of Recipes in functional programming and e.g., Scheme [1], there are many truly object-oriented uses: Smalltalk [14] features blocks as Recipes with implicit binding of free variables. Sather provides Recipes as bound routines [33]. The Eiffel Booch Components use Recipes for searching, sorting, transforming and filtering of containers [16]. <p> This suggests that object-oriented programs can also increase metric reuse factors by using internal iter-ators. Our proposed transfold operator combined with respective Recipes yields many useful operations like map, filter, sum, length. As presented here, Recipes support both downward-funargs and upward-funargs <ref> [1] </ref>. While the former constitutes behavior parameterization, the latter occurs at partial applications and delayed calculations. With respect to behavior parameterization, Recipes and inheritance are not redundant concepts [24]. We clearly documented the added run time flexibility and decoupling properties of Recipes.
Reference: [2] <author> Micheal Beaudouin-Lafon. </author> <title> Object-oriented Languages. </title> <publisher> Chapman and Hall, </publisher> <year> 1994. </year>
Reference-contexts: We used just one aspect of Recipes for their motivation and supplied illustrating examples for other aspects individually. The power of closures makes it an ideal candidate for a language construct. Actually, it is one of only four abstractions supported by Smalltalk <ref> [2] </ref>. Likewise, Beta's [27] patterns are often used as genuine closures. Functional closures, i.e., higher-order functions, even allow to base an entire paradigm on them. Functional programming heavily relies on general list processing functions, which can be specialized for various purposes.
Reference: [3] <author> Kent Beck. </author> <title> Method object. Patterns mailing list Digest, </title> <type> 96(26), </type> <month> April </month> <year> 1996. </year>
Reference-contexts: As a result, the method can be split up into more manageable sub-methods, without passing parameters between inter-method invocations, since communication still can take place via Recipe attributes. The main computation method (e.g., evaluate) simply puts the pieces together, itself being as clear as documentation <ref> [3] </ref>. * Call-by-need Semantics. One aspect of call-by-need is to calculate a result only once, no matter how many times the calculation is requested. Recipes can do this, but class methods can also perform this using a technique called memoization.
Reference: [4] <author> Richard Bird and Philip Wadler. </author> <title> Introduction to Functional Programming. C.A.R. Hoare Series. </title> <publisher> Prentice Hall International, </publisher> <year> 1988. </year>
Reference-contexts: Hence, vendors do not have the option to sell pre-compiled library code only. We can get rid of all these disadvantages if we sacrifice the ability to adapt iteration schemes for particular functions. We accomplish this by using higher-order functions, well-known from functional programming <ref> [4] </ref> and as blocks from Smalltalk. Instead of subclassing the iterator, we pass a function to be applied to the elements. We pass a Recipe that describes what to do with the elements. Instead of an "is-a", we establish a "uses-a" relationship.
Reference: [5] <author> Thomas M. Breuel. </author> <title> Lexical closures for C++. </title> <booktitle> In C++ Conf. Proc., </booktitle> <pages> pages 293-304, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: This is useful for parameterization of algorithms, partial parameterization of functions, lazy evaluation, lifting methods to first-class citizens, and for separating functions from data. 1 2.2 Also Known As Lexical Closure <ref> [5] </ref>, Functor [7], Agent [16], Agent-Object [23], Functionoid [6], Functoid [25], Function-Object [37, 24]. 2.3 Motivation Behavior parameterization occurs in almost every program. Iterators are a good example. Consider a collection of books. <p> Actually, we call this special usage of a parameter for behavior parameterization "takes-a" [24]. Since we usually can not pass methods as functions and many object-oriented languages (e.g., C ++ , Eiffel) do not feature blocks, we pass an object representing the function <ref> [5, 7, 24] </ref>. The object's interface makes it possible to receive arguments and to return a result. As the object represents a way of doing things we call it Recipe. <p> We clearly documented the added run time flexibility and decoupling properties of Recipes. While true closures bind their free variables implicitly, our object-oriented version requires explicit binding. Breuel shows how to still achieve implicit binding by nested class definitions <ref> [5] </ref>. We have seen, however, that explicit binding does not lose anything essential, but on the contrary decouples the Recipe from its creating environment. Naturally, Recipe shares many properties with Command and Strategy. They abstract from function pointers, support composition, allow to undo operations, and achieve client/server decoupling.
Reference: [6] <author> Derek Coleman and et al. </author> <title> Object-oriented development: The Fusion Method. </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: This is useful for parameterization of algorithms, partial parameterization of functions, lazy evaluation, lifting methods to first-class citizens, and for separating functions from data. 1 2.2 Also Known As Lexical Closure [5], Functor [7], Agent [16], Agent-Object [23], Functionoid <ref> [6] </ref>, Functoid [25], Function-Object [37, 24]. 2.3 Motivation Behavior parameterization occurs in almost every program. Iterators are a good example. Consider a collection of books.
Reference: [7] <author> James O. Coplien. </author> <title> Advanced C ++ : Programming Styles and Idioms. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: This is useful for parameterization of algorithms, partial parameterization of functions, lazy evaluation, lifting methods to first-class citizens, and for separating functions from data. 1 2.2 Also Known As Lexical Closure [5], Functor <ref> [7] </ref>, Agent [16], Agent-Object [23], Functionoid [6], Functoid [25], Function-Object [37, 24]. 2.3 Motivation Behavior parameterization occurs in almost every program. Iterators are a good example. Consider a collection of books. <p> Actually, we call this special usage of a parameter for behavior parameterization "takes-a" [24]. Since we usually can not pass methods as functions and many object-oriented languages (e.g., C ++ , Eiffel) do not feature blocks, we pass an object representing the function <ref> [5, 7, 24] </ref>. The object's interface makes it possible to receive arguments and to return a result. As the object represents a way of doing things we call it Recipe. <p> Recipes make methods amenable to persistent command logging, command histories for undoing, network distribution of commands, etc. Like Commands, Recipes can provide an undo method, which will use information in the Recipe's state to undo operations [31, 13]. A perfect candidate for first-class methods are so-called "business transactions" <ref> [7] </ref>. Often the functions are the stable concepts of a system and represent good maintainance spots, in order to cope with changing functionality. Instead of being a well-defined operation on one single object, transactions are "an orchestration of objects working together toward a common goal" [7]. <p> methods are so-called "business transactions" <ref> [7] </ref>. Often the functions are the stable concepts of a system and represent good maintainance spots, in order to cope with changing functionality. Instead of being a well-defined operation on one single object, transactions are "an orchestration of objects working together toward a common goal" [7]. When transactions do not naturally fit into existing data abstractions, Recipes can lift them to first-class status while providing a uniform interface. * Monolithic Algorithms. <p> Unfortunately, the necessary switch statements on argument types are sensitive to the introduction of new types 2 . Yet, in the case of single-dispatch simulation, new dispatching methods (e.g., add complex) are necessary as well. Generic Recipes may use coercions to reduce the possible number of combinations <ref> [7] </ref>, and employ partial parameterization to avoid nested type switches: Upon receipt of an argument, the generic Recipe uses one type switch statement to create a corresponding new generic Recipe that will handle the rest of the ar guments. 2.5 Structure 2.6 Participants * Recipe declares an interface for application. * <p> Recipes abstract from function pointers and in particular from pointers to class methods. Instead of the C ++ code: aFilter.*(aFilter.current)(t), we can write aFilter (t) <ref> [7] </ref>. * Simplicity. Recipes do not introduce inheritance relationships and do not create spurious combinator classes. * Explicitness. The code cook.prepare (fish) is easy to understand. When Recipes are wired into COOK subclasses, cook.prepare depends on the actual cook type. <p> friends (C ++ ), allow to trade in efficiency for safety. 3 Its functional definition shall be: transfold f a g (foldr f a) ffi (map g) ffi trans 7 2.9 Implementation * C ++ allows to overload the "()" operator, which gives a nice syntax for Recipe applic ation <ref> [7] </ref>. Eiffel offers the infix operator "@". * In order to provide true static binding, Recipes must copy their arguments. Otherwise, their behavior will depend on side-effects on their arguments. In some cases, however, this may be desirable.
Reference: [8] <author> James O. Coplien. </author> <title> Multi-paradigm design and implementation. </title> <booktitle> Summer School on Object Orientation in Tampere, </booktitle> <institution> Finland, AT&T Bell Laboratories, Naperville, Illinois, USA, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: The control-objects in Jacobson's "use-case driven approach" represent such points of functional extendibility [19]. Concerning the optimal balance between free functions and object-oriented decomposition, further research is necessary <ref> [8] </ref>. In any case, withstanding the temptation to implement parameterization with inheritance, but using higher-order functions means introducing part of the functional paradigm into the object-oriented paradigm. No longer can we choose one technique from one paradigm only in order to solve a problem.
Reference: [9] <author> Laurent Dami. </author> <title> Software Composition: Towards an Integration of Functional and Object-Oriented Approaches. </title> <type> PhD thesis, Uni. </type> <institution> of Geneva, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: However, the complete number of arguments is effectively hidden to adaptable algorithms, which allows for trans parent behavior extensions. * allow partial parameterization. One Recipe definition actually introduces as many Recipes as the number of its arguments. Run time partially parameterized Recipes can be regarded as dynamically created functions <ref> [9] </ref>. * capture data from their creation environment and previous arguments. Hence, data providers can be separated from each other. A Recipe allows to combine local data from environments, even beyond their lifetime. * may dispatch on argument values and/or types.
Reference: [10] <author> Linda G. DeMichiel and Richard P. Gabriel. </author> <title> The common lisp object system: An overview. </title> <editor> In J. Bezivin, J-M. Hullot, P. Cointe, and H. Lieber-mann, editors, </editor> <booktitle> Proceedings ECOOP '87, </booktitle> <volume> LNCS 276, </volume> <pages> pages 151-170. </pages> <publisher> Springer Verlag, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: It uses run time type identification to select the correct code for a given combination of argument types. As such, it is not simply an overloaded Recipe, which would statically resolve the types. 1 Named after CLOS' <ref> [10] </ref> generic functions. Unfortunately, the necessary switch statements on argument types are sensitive to the introduction of new types 2 . Yet, in the case of single-dispatch simulation, new dispatching methods (e.g., add complex) are necessary as well.
Reference: [11] <author> M. Ellis and B. Stroustrup. </author> <title> The Annotated C ++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: In fact, the multiple inheritance solution causes iterator, function, and combinator class to share the same name-space. Implementation changes to either of the classes can easily invalidate the other. An interface between super- and subclasses, as the private parts in C ++ <ref> [11] </ref>, alleviates the prob lem considerably. * Unrestricted flexibility. Creating a designated class for the combination of an iteration scheme and a function opens up the possibility of overriding the iteration scheme for particular actions.
Reference: [12] <author> Anthony J. Field and Peter G. Harrison. </author> <title> Functional Programming. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Up to now, we described closures with the same functionality as available in functional languages <ref> [12] </ref>. There is more to object-oriented closures: Imperative closures can produce side-effects and carry state. As a result, they can be used for parameterization of side-effects and to accumulate results internally. The pattern description in section 2 will give applications for the remarkable properties listed above.
Reference: [13] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlis-sides. </author> <title> Design Patterns: Elements of Object-Oriented Software Architecture. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: For instance, the action to be performed during an iteration on a collection's elements is passed to the iteration method as a closure. This paper explains the concept of closures and makes it accessible to any object-oriented language by describing it as the design pattern <ref> [13] </ref> Recipe. In Smalltalk, closures are called blocks [14]. A block allows to inject behavior into an object. When a block is received and subsequently executed by an object, we can think of it as executing a new method in the object. <p> Moreover, writing the loops is error-prone, since it is easy to use an incorrect exit condition or to forget to step to the next element (see also "Write a Loop Once" [28] and the discussion in the Iterator pattern <ref> [13] </ref>). Consequently, we provide one more level of abstraction with an internal iterator. Given a function, it will apply the function to all elements in the collection. <p> In order to avoid switch statements we may use dynamic binding of iterators. The actual iteration method of an ITERATOR class is a Template Method <ref> [13] </ref>, which depends on an abstract function method. The implementation for the abstract function method, and thus the specific function to be applied to the elements, is given in descendants of ITERATOR [27, 30, 28]. Composing traversal algorithm and functions then works through dynamic binding of the abstract function method. <p> Imposing a Recipe's interface on related operations makes it possible to uniformly invoke them. Instead of switching to different method names (e.g., editor commands), we invoke evaluate on an abstract Recipe and rely on dynamic binding <ref> [31, 13] </ref>. Consequently, when we add new operations, we do not need to change the event handler. If specific evaluation names (e.g., execute, evaluate, solve) are considered important, then they can be provided as aliases. * First-Class methods. <p> Recipes make methods amenable to persistent command logging, command histories for undoing, network distribution of commands, etc. Like Commands, Recipes can provide an undo method, which will use information in the Recipe's state to undo operations <ref> [31, 13] </ref>. A perfect candidate for first-class methods are so-called "business transactions" [7]. Often the functions are the stable concepts of a system and represent good maintainance spots, in order to cope with changing functionality. <p> In addition, it is not possible to exchange the operations at run time. If we turn the algorithm into a Recipe, we must use a generic Recipe (see subsection Multi-dispatch) to dispatch on the node types, but in analogy to the Strategy pattern <ref> [13] </ref>, the algorithm logic is localized, - Recipe's state can accumulate results, and we can dynamically choose an algorithm. * Small interfaces. <p> The code cook.prepare (fish) is easy to understand. When Recipes are wired into COOK subclasses, cook.prepare depends on the actual cook type. Clever variable names (e.g., fish cook.prepare) often are not an option, e.g., cook.prepare (fish), followed by cook.prepare (desert). * Compositionality. As Macro-Commands <ref> [13] </ref>, Recipes can be dynamically composed to form a sequence of actions. Unlike Macro-Commands, Recipes may form a calculation pipeline by forwarding intermediate results to the next processing Recipe. A composite Recipe can also apply several component Recipes in parallel, producing multiple results at once. * Encapsulation. <p> Even different aspects of dispatching can be separated. For instance, a state transition function, applied to a state, will yield a function that maps inputs to new states (the principle of pattern State <ref> [13] </ref>). Type and/or value of a state can be used to decide between res ulting mappings. * Reuse. Recipe's impact on reuse is twofold: First, adaptable algorithms become more reusable because they do not need to know about additional parameters for Recipes. <p> Recipes suggest the use of internal, rather than external, iterators. Internal iterat-ors avoid explicit state and avoid reoccurring explicit control loops. Often external iterators are promoted to be more flexible. It is said to be practically impossible to compare two data structures with an internal iterator <ref> [13] </ref>. However, we simply propose to extend an iter-ator to accept not just one, but n data structures. A transfold 3 -method may access the first, second, etc., elements of all data structures simultaneously. <p> Eiffel may co-variantly redefine argument application, but C ++ demands the abstract class to be a template. Otherwise, all parameters of a Recipe must have the same type. Laufer proposes a solution using the Bridge pattern <ref> [13] </ref>, which also covers memory management in C ++ [25]. * Languages without garbage collection are less suited to support upward-funargs 4 [1] and delayed calculations. <p> Per contra, clients "have-an" Objectifier, while clients "take-a" Recipe. The latter is a uses, not a has-a relationship. * Command: A Recipe which does not take any arguments after creation and produces side-effects only boils down to the Command pattern <ref> [13] </ref>. One key aspect of Command is to decouple an invoker from a target object. Recipes typically do not delegate functionality. Rather then delegating behavior to server objects they implement it themselves. So, Recipes normally do not work with side-effects, but return their computation as an argument-application result. <p> Nevertheless, Recipes also can be used for client/server separation, i.e., as Call-back functions. In addition to Command, invokers are then able to pass additional information to Recipes by supplying arguments. * Visitor: Data structures need to know about Visitors because they have to provide an Accept method <ref> [13] </ref>. Sometimes this is undesirable because of the so-introduced mutual dependency between data structures and Visitors. When the data structure is not available as source code, it is even impossible to add the Accept method. <p> This allows reuse of the dispatching part for various operations. Of course, the type switches are sensitive to the addition of new structure objects. However, if the structure is unstable, Visitor is not recommended either <ref> [13] </ref>. * State/Strategy: Recipe, State [13], and Strategy [13] are concerned with encapsulating behavior. A decision between them can be based on concerns such as: Who is responsible for changing the vari able part of an algorithm? The State pattern manages the change of variability autonomously. <p> This allows reuse of the dispatching part for various operations. Of course, the type switches are sensitive to the addition of new structure objects. However, if the structure is unstable, Visitor is not recommended either <ref> [13] </ref>. * State/Strategy: Recipe, State [13], and Strategy [13] are concerned with encapsulating behavior. A decision between them can be based on concerns such as: Who is responsible for changing the vari able part of an algorithm? The State pattern manages the change of variability autonomously. Recipes are explicitly chosen by the client. <p> This allows reuse of the dispatching part for various operations. Of course, the type switches are sensitive to the addition of new structure objects. However, if the structure is unstable, Visitor is not recommended either <ref> [13] </ref>. * State/Strategy: Recipe, State [13], and Strategy [13] are concerned with encapsulating behavior. A decision between them can be based on concerns such as: Who is responsible for changing the vari able part of an algorithm? The State pattern manages the change of variability autonomously. Recipes are explicitly chosen by the client. <p> Recipes are explicitly chosen by the client. Strategies are chosen by the client, but independ ently of operation requests. Is it feasible to impose the same interface on all variations? If the available Strategies range from simple to complex, the abstract Strategy must support the maximum parameter interface <ref> [13] </ref>. Recipes avoid this by partial parameterization. Does the combination of common and variable part constitute a useful concept? The State pattern conceptually represents a monolithic finite state machine, so the combination of standard- and state-dependent behavior makes sense indeed. <p> Here, the combination acts as a built-in bookkeeping for the selection of the variable part. Recipes take part in the "takes-a" relation. A Recipe and its receiver are only temporarily combined in order to accomplish a task. 2.11.2 Collaboration * Iterator: Recipes work well in collaboration with Iterator <ref> [13] </ref>, since they allow the use of data from inside (elements) and outside the collection (previous Recipe arguments). <p> Recipe allows to replace the inheritance relationship between Links and Handlers <ref> [13] </ref> with object-composition. 2.11.3 Implementation * Composite: One way to uniformly access standard and composed Recipes is to use the Composite pattern [13]. Composite Recipes forward argument-application to its component Recipes. A tuple-Composite applies all Recipes in parallel to the same argument and thus represents a multi-result tuple. <p> Recipe allows to replace the inheritance relationship between Links and Handlers <ref> [13] </ref> with object-composition. 2.11.3 Implementation * Composite: One way to uniformly access standard and composed Recipes is to use the Composite pattern [13]. Composite Recipes forward argument-application to its component Recipes. A tuple-Composite applies all Recipes in parallel to the same argument and thus represents a multi-result tuple.
Reference: [14] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: This paper explains the concept of closures and makes it accessible to any object-oriented language by describing it as the design pattern [13] Recipe. In Smalltalk, closures are called blocks <ref> [14] </ref>. A block allows to inject behavior into an object. When a block is received and subsequently executed by an object, we can think of it as executing a new method in the object. <p> Constructors and Destructors only work for Recipes with lifetimes determined by environment lifetimes. 2.10 Known Uses Apart from the uncountable uses of Recipes in functional programming and e.g., Scheme [1], there are many truly object-oriented uses: Smalltalk <ref> [14] </ref> features blocks as Recipes with implicit binding of free variables. Sather provides Recipes as bound routines [33]. The Eiffel Booch Components use Recipes for searching, sorting, transforming and filtering of containers [16].
Reference: [15] <author> R. Harrison, L. G. Samaraweera, M. R. Dobie, and P. H. Lewis. </author> <title> Comparing programming paradigms: An evaluation of functional and object-oriented progams. </title> <type> Technical Report SO171BJ, </type> <institution> University of Southhampton, Dept. of Electronincs and Computer Science, UK, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: Functional programming heavily relies on general list processing functions, which can be specialized for various purposes. Here, behavior parameterization ("takes-a") is a fundamental technique for software reuse. Functional programming can even outperform object-oriented programming in terms of reuse <ref> [15] </ref>. This particular result can partly be attributed to the heavy use of library functions for intermediate list data structures. This suggests that object-oriented programs can also increase metric reuse factors by using internal iter-ators.
Reference: [16] <author> Aaron Hillegass. </author> <title> The design of the eiffel booch components. </title> <journal> Eiffel Outlook, </journal> <volume> 3(3) </volume> <pages> 20-21, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: This is useful for parameterization of algorithms, partial parameterization of functions, lazy evaluation, lifting methods to first-class citizens, and for separating functions from data. 1 2.2 Also Known As Lexical Closure [5], Functor [7], Agent <ref> [16] </ref>, Agent-Object [23], Functionoid [6], Functoid [25], Function-Object [37, 24]. 2.3 Motivation Behavior parameterization occurs in almost every program. Iterators are a good example. Consider a collection of books. <p> Sather provides Recipes as bound routines [33]. The Eiffel Booch Components use Recipes for searching, sorting, transforming and filtering of containers <ref> [16] </ref>. The Standard Template Library, which was adopted as part of the standard C ++ library, uses Recipes to inline operations for arithmetic, logic, and comparison [37]. 4 Functions returned as results.
Reference: [17] <author> John Hughes. </author> <title> Why functional programming matters. </title> <editor> In David A. Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, </booktitle> <pages> pages 17-42. </pages> <publisher> Addison-Wesley, </publisher> <month> August </month> <year> 1987. </year>
Reference-contexts: If the result is never needed, this pays off in run time efficiency. A Recipe represents a calculation that is performed only if someone is in need of the result. Note that lazy evaluation enables infinite data structures and supports modularization by de-coupling data generation from data consump tion <ref> [17] </ref>. * Multi-dispatch. Sometimes an operation depends on more than one argument type. For instance, adding two numbers works differently for various pairs of integers, reals, and complex numbers. <p> In summary, Recipes hide the number of both arguments and results to clients. This can be viewed as an aid to modularization, just like classes in object-oriented design [34] or higher-order functions and lazy evaluation in functional programming <ref> [17] </ref>. Accordingly, aggregation ("has-a"), inheritance ("is-a"), and behavior parameterization ("takes-a") should be equally well-known to designers. "Takes-a" realizes object composition, as opposed to breaking encapsulation with inheritance [36]. It is therefore a means to reach the goal of component oriented software [20, 32].
Reference: [18] <author> Daniel H. H. Ingalls. </author> <title> A simple technique for handling multiple polymorphism. </title> <booktitle> In Proceedings OOPSLA '86, </booktitle> <pages> pages 347-349, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Sometimes an operation depends on more than one argument type. For instance, adding two numbers works differently for various pairs of integers, reals, and complex numbers. Simulating multi-dispatch with standard single dispatch <ref> [18] </ref>, where only the type of the receiver objects is taken into account, results in many additional methods (like add Integer, add real). The dispatching code is thus distributed over all involved classes.
Reference: [19] <author> Ivar Jacobson and et al. </author> <title> Object-Oriented Software Engineering: A use case driven approach. </title> <publisher> Addison-Wesley, </publisher> <address> 4. edition, </address> <year> 1994. </year>
Reference-contexts: This is definitely useful. While adding new objects to a system is caught by an object-oriented decomposition, adding functionality often is better handled by extending functional abstractions. The control-objects in Jacobson's "use-case driven approach" represent such points of functional extendibility <ref> [19] </ref>. Concerning the optimal balance between free functions and object-oriented decomposition, further research is necessary [8]. In any case, withstanding the temptation to implement parameterization with inheritance, but using higher-order functions means introducing part of the functional paradigm into the object-oriented paradigm.
Reference: [20] <author> Mehdi Jazayeri. </author> <title> Component programming a fresh look at software components. </title> <booktitle> In Proceedings of the 5th European Software Engineering Conference, </booktitle> <address> Sitges, Spain, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: Accordingly, aggregation ("has-a"), inheritance ("is-a"), and behavior parameterization ("takes-a") should be equally well-known to designers. "Takes-a" realizes object composition, as opposed to breaking encapsulation with inheritance [36]. It is therefore a means to reach the goal of component oriented software <ref> [20, 32] </ref>. In combination, inheritance and Recipe allow for flexible prototyping as well as safe black-box composition. 11 As well as other patterns, Recipe can raise the level of design discussions.
Reference: [21] <author> Ralph E. Johnson. </author> <title> How to develop frameworks. </title> <booktitle> In ECOOP '94 Tutorial Documentation, </booktitle> <month> July </month> <year> 1994. </year> <month> 12 </month>
Reference-contexts: As Recipes establish client relationships only, they are protected from implementation changes to algorithms that use them. Likewise, the implementation of Recipes can change without invalidating the algorithms. Hence, Recipes allow so-called black-box reuse [22] and help to advance reuse by inher itance to reuse by composition <ref> [21] </ref>. * Security. A client of an adaptable algorithm can be sure not to change the algorithm semantics. It is impossible to be given an optimized version which does not fully comply to the original semantics (see section 2.3). * Flexibility.
Reference: [22] <author> Ralph E. Johnson and Brian Foote. </author> <title> Designing re-usable classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(2) </volume> <pages> 22-35, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: As Recipes establish client relationships only, they are protected from implementation changes to algorithms that use them. Likewise, the implementation of Recipes can change without invalidating the algorithms. Hence, Recipes allow so-called black-box reuse <ref> [22] </ref> and help to advance reuse by inher itance to reuse by composition [21]. * Security. A client of an adaptable algorithm can be sure not to change the algorithm semantics.
Reference: [23] <author> Thomas Kuhne. </author> <title> Higher order objects in pure object-oriented languages. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(7) </volume> <pages> 15-20, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: This is useful for parameterization of algorithms, partial parameterization of functions, lazy evaluation, lifting methods to first-class citizens, and for separating functions from data. 1 2.2 Also Known As Lexical Closure [5], Functor [7], Agent [16], Agent-Object <ref> [23] </ref>, Functionoid [6], Functoid [25], Function-Object [37, 24]. 2.3 Motivation Behavior parameterization occurs in almost every program. Iterators are a good example. Consider a collection of books.
Reference: [24] <author> Thomas Kuhne. </author> <title> Parameterization versus inheritance. </title> <editor> In C. Mingins and B. Meyer, editors, </editor> <booktitle> Technology of Object-Oriented Languages and Systems: TOOLS 15, </booktitle> <pages> pages 235-245, </pages> <publisher> Prentice Hall, </publisher> <year> 1995. </year>
Reference-contexts: This is useful for parameterization of algorithms, partial parameterization of functions, lazy evaluation, lifting methods to first-class citizens, and for separating functions from data. 1 2.2 Also Known As Lexical Closure [5], Functor [7], Agent [16], Agent-Object [23], Functionoid [6], Functoid [25], Function-Object <ref> [37, 24] </ref>. 2.3 Motivation Behavior parameterization occurs in almost every program. Iterators are a good example. Consider a collection of books. <p> Instead of subclassing the iterator, we pass a function to be applied to the elements. We pass a Recipe that describes what to do with the elements. Instead of an "is-a", we establish a "uses-a" relationship. Actually, we call this special usage of a parameter for behavior parameterization "takes-a" <ref> [24] </ref>. Since we usually can not pass methods as functions and many object-oriented languages (e.g., C ++ , Eiffel) do not feature blocks, we pass an object representing the function [5, 7, 24]. The object's interface makes it possible to receive arguments and to return a result. <p> Actually, we call this special usage of a parameter for behavior parameterization "takes-a" [24]. Since we usually can not pass methods as functions and many object-oriented languages (e.g., C ++ , Eiffel) do not feature blocks, we pass an object representing the function <ref> [5, 7, 24] </ref>. The object's interface makes it possible to receive arguments and to return a result. As the object represents a way of doing things we call it Recipe. <p> As presented here, Recipes support both downward-funargs and upward-funargs [1]. While the former constitutes behavior parameterization, the latter occurs at partial applications and delayed calculations. With respect to behavior parameterization, Recipes and inheritance are not redundant concepts <ref> [24] </ref>. We clearly documented the added run time flexibility and decoupling properties of Recipes. While true closures bind their free variables implicitly, our object-oriented version requires explicit binding. Breuel shows how to still achieve implicit binding by nested class definitions [5].
Reference: [25] <author> Konstantin Laufer. </author> <title> A framework for higher-order functions in C++. </title> <booktitle> In Proc. Conf. Object-Oriented Technologies (COOTS), </booktitle> <address> Monterey, CA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: This is useful for parameterization of algorithms, partial parameterization of functions, lazy evaluation, lifting methods to first-class citizens, and for separating functions from data. 1 2.2 Also Known As Lexical Closure [5], Functor [7], Agent [16], Agent-Object [23], Functionoid [6], Functoid <ref> [25] </ref>, Function-Object [37, 24]. 2.3 Motivation Behavior parameterization occurs in almost every program. Iterators are a good example. Consider a collection of books. <p> Eiffel may co-variantly redefine argument application, but C ++ demands the abstract class to be a template. Otherwise, all parameters of a Recipe must have the same type. Laufer proposes a solution using the Bridge pattern [13], which also covers memory management in C ++ <ref> [25] </ref>. * Languages without garbage collection are less suited to support upward-funargs 4 [1] and delayed calculations.
Reference: [26] <author> Gary T. Leavens. </author> <title> Fields in physics are like curried functions or Physics for functional programmers. </title> <type> Technical Report TR #94-06b, </type> <institution> Department of Computer Science, Iowa State University, 229 Atanasoff Hall, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: The second, created by applying the first to an argument, has n 1 parameters, and so on, until the last Recipe is applied to an argument and produces the result. An example from physics shows the useful functions which can be created from the gravitational force function <ref> [26] </ref>: Grav law m 1 r m 2 = G m 1 m 2 r 2 force earth = Grav law mass earth force surface = force earth radius earth force my = force surface mass my * Iteration. Recipes suggest the use of internal, rather than external, iterators.
Reference: [27] <author> Ole L. Madsen, Kristen Nygaard, and Birger Moller-Pedersen. </author> <title> Object-Oriented Programming in the BETA Programming Language. </title> <publisher> Addison-Wesley and ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: The actual iteration method of an ITERATOR class is a Template Method [13], which depends on an abstract function method. The implementation for the abstract function method, and thus the specific function to be applied to the elements, is given in descendants of ITERATOR <ref> [27, 30, 28] </ref>. Composing traversal algorithm and functions then works through dynamic binding of the abstract function method. Selecting one of several functions corresponds to selecting one of the existing ITERATOR subclasses. <p> We used just one aspect of Recipes for their motivation and supplied illustrating examples for other aspects individually. The power of closures makes it an ideal candidate for a language construct. Actually, it is one of only four abstractions supported by Smalltalk [2]. Likewise, Beta's <ref> [27] </ref> patterns are often used as genuine closures. Functional closures, i.e., higher-order functions, even allow to base an entire paradigm on them. Functional programming heavily relies on general list processing functions, which can be specialized for various purposes. Here, behavior parameterization ("takes-a") is a fundamental technique for software reuse.
Reference: [28] <author> Robert Martin. </author> <title> Discovering patterns in existing applications. </title> <editor> In James O. Coplien and Douglas C. Schmidt, editors, </editor> <booktitle> Pattern Languages of Program Design, </booktitle> <pages> pages 365-393. </pages> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Yet, we expect to use the traversal algorithm many times, which will result in many explicitly written loops. Moreover, writing the loops is error-prone, since it is easy to use an incorrect exit condition or to forget to step to the next element (see also "Write a Loop Once" <ref> [28] </ref> and the discussion in the Iterator pattern [13]). Consequently, we provide one more level of abstraction with an internal iterator. Given a function, it will apply the function to all elements in the collection. <p> The actual iteration method of an ITERATOR class is a Template Method [13], which depends on an abstract function method. The implementation for the abstract function method, and thus the specific function to be applied to the elements, is given in descendants of ITERATOR <ref> [27, 30, 28] </ref>. Composing traversal algorithm and functions then works through dynamic binding of the abstract function method. Selecting one of several functions corresponds to selecting one of the existing ITERATOR subclasses.
Reference: [29] <author> B. Meyer. </author> <title> Eiffel the language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Each new function demands a new subclass of ITERATOR. The name space for classes is cluttered by many concrete ITERATOR subclasses. We may combine all functions in one subclass using repeated inheritance <ref> [29] </ref>, but this only makes things worse. First, it is non-local design to lump all functions in one class. Second, we have to apply heavy renaming for iteration schemes and functions in the subclass; any combination of iteration scheme and function must be given a distinct name.
Reference: [30] <author> B. Meyer. </author> <title> Reusable Software. </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: The actual iteration method of an ITERATOR class is a Template Method [13], which depends on an abstract function method. The implementation for the abstract function method, and thus the specific function to be applied to the elements, is given in descendants of ITERATOR <ref> [27, 30, 28] </ref>. Composing traversal algorithm and functions then works through dynamic binding of the abstract function method. Selecting one of several functions corresponds to selecting one of the existing ITERATOR subclasses. <p> When the interval data is supplied in advance, we can use the resulting recipe for a standard library iteration. 2.4 Applicability Recipes are free functions. They are not members of a particular data abstraction. They resemble so-called design-objects <ref> [30] </ref>, like iterator objects, event handler, and Commands, which similarly constitute entities of their own right. The separation of functions from data can be beneficial in several ways: 3 * Parameterization. Recipes are a good candid-ate whenever general behavior can be adapted to special behavior. <p> Since Recipes are so easy to compose, it is feasible to form useful composite Recipes. For instance, we may combine a test- with an action-Recipe, in order to perform conditional actions on elements of a collection. Then, we do not necessarily need to provide special iterations as "do if". <ref> [30] </ref>. One Recipe with n parameters actually represents n Recipes and one value. The first Recipe has n parameters. The second, created by applying the first to an argument, has n 1 parameters, and so on, until the last Recipe is applied to an argument and produces the result.
Reference: [31] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> NJ, </address> <year> 1988. </year>
Reference-contexts: The user may rely on properties of the original iteration scheme. If the iteration function not only counts the elements, but in addition produces some side-effect, the side-effects will not be executed in the optimized version described above. Pre- and postconditions <ref> [31] </ref> can help to enforce behavioral identity between iteration schemes, but problems like the above are hard to cover and checking contracts at run time boils down to testing, as opposed to rig orous proofing. * Identity changes. <p> Imposing a Recipe's interface on related operations makes it possible to uniformly invoke them. Instead of switching to different method names (e.g., editor commands), we invoke evaluate on an abstract Recipe and rely on dynamic binding <ref> [31, 13] </ref>. Consequently, when we add new operations, we do not need to change the event handler. If specific evaluation names (e.g., execute, evaluate, solve) are considered important, then they can be provided as aliases. * First-Class methods. <p> Recipes make methods amenable to persistent command logging, command histories for undoing, network distribution of commands, etc. Like Commands, Recipes can provide an undo method, which will use information in the Recipe's state to undo operations <ref> [31, 13] </ref>. A perfect candidate for first-class methods are so-called "business transactions" [7]. Often the functions are the stable concepts of a system and represent good maintainance spots, in order to cope with changing functionality. <p> There are many ways to account for this: type-case statement (Sather [33]), typeid (C ++ , 3.0 specification), reverse as signment attempt (Eiffel <ref> [31] </ref>). * How shall we accumulate the results of an iteration? A functional programmer would im plement all of the three library operations (see 8 section 2.3) as a fold over a list of books. The result type of fold is determined by the function supplied.
Reference: [32] <author> Oscar Nierstrasz and Theo Dirk Meijler. </author> <title> Research directions in software composition. </title> <journal> ACM Computing Surveys, </journal> <volume> 27(2) </volume> <pages> 262-264, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Accordingly, aggregation ("has-a"), inheritance ("is-a"), and behavior parameterization ("takes-a") should be equally well-known to designers. "Takes-a" realizes object composition, as opposed to breaking encapsulation with inheritance [36]. It is therefore a means to reach the goal of component oriented software <ref> [20, 32] </ref>. In combination, inheritance and Recipe allow for flexible prototyping as well as safe black-box composition. 11 As well as other patterns, Recipe can raise the level of design discussions.
Reference: [33] <author> Stephen M. Omohundro. </author> <title> The Sather 1.0 specification. </title> <type> Technical report, </type> <institution> International Computer Science Institute, Berkeley, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: Unfortunately, this forces us to write at least n 1 classes for a Recipe with n parameters. * Generic Recipes must use run time type identification to deduce the type of actual arguments. There are many ways to account for this: type-case statement (Sather <ref> [33] </ref>), typeid (C ++ , 3.0 specification), reverse as signment attempt (Eiffel [31]). * How shall we accumulate the results of an iteration? A functional programmer would im plement all of the three library operations (see 8 section 2.3) as a fold over a list of books. <p> Sather provides Recipes as bound routines <ref> [33] </ref>. The Eiffel Booch Components use Recipes for searching, sorting, transforming and filtering of containers [16]. The Standard Template Library, which was adopted as part of the standard C ++ library, uses Recipes to inline operations for arithmetic, logic, and comparison [37]. 4 Functions returned as results.
Reference: [34] <author> D. Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Communications of the ACM, </journal> <volume> 15 </volume> <pages> 1053-1058, </pages> <year> 1972. </year>
Reference-contexts: Hence, Recipes can compute, e.g., traversal results without the need to modify the result type of the traversal algorithm. In summary, Recipes hide the number of both arguments and results to clients. This can be viewed as an aid to modularization, just like classes in object-oriented design <ref> [34] </ref> or higher-order functions and lazy evaluation in functional programming [17]. Accordingly, aggregation ("has-a"), inheritance ("is-a"), and behavior parameterization ("takes-a") should be equally well-known to designers. "Takes-a" realizes object composition, as opposed to breaking encapsulation with inheritance [36].
Reference: [35] <author> Peter Sestoft. </author> <title> Replacing function parameters by global variables. </title> <institution> Diku, University of Copenhagen, </institution> <month> October </month> <year> 1988. </year>
Reference-contexts: Passing client parameters to Recipes can be more inefficient than to, e.g., directly access internal attributes of an iterator superclass. In principle this could be tackled by compiler optimizations <ref> [35] </ref>. An overhead exists in creating and calling a Recipe, instead of just invoking a method. This suggests only to use Re cipes when truly needed. Care should be taken not to unnecessarily keep references to unevaluated calculations, i.e., Recipes. Otherwise, the oc cupied space can not be reclaimed.
Reference: [36] <author> Alan Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> Proceedings OOPSLA '86, </booktitle> <volume> 21(11) </volume> <pages> 38-45, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Accordingly, aggregation ("has-a"), inheritance ("is-a"), and behavior parameterization ("takes-a") should be equally well-known to designers. "Takes-a" realizes object composition, as opposed to breaking encapsulation with inheritance <ref> [36] </ref>. It is therefore a means to reach the goal of component oriented software [20, 32]. In combination, inheritance and Recipe allow for flexible prototyping as well as safe black-box composition. 11 As well as other patterns, Recipe can raise the level of design discussions.
Reference: [37] <author> A. Stepanov and M. Lee. </author> <title> The standard template library. ISO Programming Language C++ Project. Doc. No. </title> <address> X3J16/94-0095, WG21/NO482, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: This is useful for parameterization of algorithms, partial parameterization of functions, lazy evaluation, lifting methods to first-class citizens, and for separating functions from data. 1 2.2 Also Known As Lexical Closure [5], Functor [7], Agent [16], Agent-Object [23], Functionoid [6], Functoid [25], Function-Object <ref> [37, 24] </ref>. 2.3 Motivation Behavior parameterization occurs in almost every program. Iterators are a good example. Consider a collection of books. <p> Sather provides Recipes as bound routines [33]. The Eiffel Booch Components use Recipes for searching, sorting, transforming and filtering of containers [16]. The Standard Template Library, which was adopted as part of the standard C ++ library, uses Recipes to inline operations for arithmetic, logic, and comparison <ref> [37] </ref>. 4 Functions returned as results. These do not have a determined lifetime and must remember their environment. 2.11 Related Patterns 2.11.1 Categorization * Objectifier: A Recipe, like Objectifier, does not represent a concrete object from the real world [39], though one can reasonably take business-transactions for real.
Reference: [38] <author> Ake Wikstrom. </author> <title> Functional Programming Using Standard ML. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: In order to enable automatic evaluation on full argument supply while still supporting the above separation, it is possible to evaluate on the last parameter and allow a kind of dummy parameter (called unit in ML <ref> [38] </ref>). * Recipes do not break the encapsulation of the objects they are passed to. If a particular Recipe is closely coupled to a specific object type, then declaring the Recipe as the object's friend, i.e., using selective export, allows efficient access to internal data nevertheless.
Reference: [39] <author> Walter Zimmer. </author> <title> Relationships between design patterns. </title> <editor> In James O. Coplien and Douglas C. Schmidt, editors, </editor> <booktitle> Pattern Languages of Program Design, </booktitle> <pages> pages 345-364. </pages> <publisher> Addison-Wesley, </publisher> <year> 1994. </year> <month> 13 </month>
Reference-contexts: These do not have a determined lifetime and must remember their environment. 2.11 Related Patterns 2.11.1 Categorization * Objectifier: A Recipe, like Objectifier, does not represent a concrete object from the real world <ref> [39] </ref>, though one can reasonably take business-transactions for real. Recipe is very similar to Objectifier, in that it objectifies behavior and takes parameters during initialization and call. Per contra, clients "have-an" Objectifier, while clients "take-a" Recipe.
References-found: 39

