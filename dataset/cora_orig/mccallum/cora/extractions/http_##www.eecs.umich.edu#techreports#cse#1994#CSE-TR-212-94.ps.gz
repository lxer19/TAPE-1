URL: http://www.eecs.umich.edu/techreports/cse/1994/CSE-TR-212-94.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse94.html
Root-URL: http://www.eecs.umich.edu
Email: farnam@eecs.umich.edu  RAGUNATHAN RAJKUMAR rr@sei.cmu.edu  sitaram@cs.washington.edu  
Title: Runtime Monitoring of Timing Constraints in Distributed Real-Time Systems  
Author: FARNAM JAHANIAN SITARAM C. V. RAJU 
Keyword: Real-Time Constraints, Monitoring, Distributed Systems, Timing Failures  
Address: Ann Arbor, MI 48109  Pittsburgh, PA 15213  Seattle WA 98195  
Affiliation: Department of Electrical Engineering and Computer Science University of Michigan  Software Engineering Institute Carnegie-Mellon University  Department of Computer Science and Engineering University of Washington  
Note: 1?? c Kluwer Academic Publishers, Boston. Manufactured in The Netherlands.  
Abstract: Embedded real-time systems often operate under strict timing and dependability constraints. To ensure responsiveness, these systems must be able to provide the expected services in a timely manner even in the presence of faults. In this paper, we describe a run-time environment for monitoring of timing constraints in distributed real-time systems. In particular, we focus on the problem of detecting violations of timing assertions in an environment in which the real-time tasks run on multiple processors, and timing constraints can be either inter-processor or intra-processor constraints. Constraint violations are detected at the earliest possible time by deriving and checking intermediate constraints from the user-specified constraints. If the violations must be detected as early as possible, then the problem of minimizing the number of messages to be exchanged between the processors becomes intractable. We characterize a sub-class of timing constraints that occur commonly in distributed real-time systems and whose message requirements can be minimized. We also take into account the drift among the various processor clocks when detecting a violation of a timing assertion. Finally, we describe a prototype implementation of a distributed run-time monitor. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Arvind, K. </author> <year> 1989. </year> <title> A New Probabilistic Algorithm for Clock Synchronization, </title> <booktitle> Proc. IEEE Real-Time Systems Symp., </booktitle> <pages> pp. 330-339. 19 </pages>
Reference-contexts: We therefore use a clock synchronization algorithm <ref> [1] </ref>, [5], [16] to bound the deviations among the various processor clocks. As discussed in a subsequent section, we implemented approximately synchronized clocks based on the probabilistic algorithm described in [5].
Reference: 2. <author> Babaoglu, O. and Marzullo, K. </author> <year> 1993. </year> <title> Consistent Global States of Distributed Systems: Fundamental Concepts and Mechanism. in Distributed Systems, </title> <editor> S. Mullender (editor), </editor> <booktitle> 2nd edition. </booktitle>
Reference-contexts: Reference [7] considers an alternative approach by restricting the global predicate to one that can be efficiently detected, such as the conjunction and disjunction of local predicates. A good article on monitoring distributed computations for asynchronous systems appears in <ref> [2] </ref>. The rest of this paper is organized as follows. Section 2 describes an aircraft tracking system and discusses issues in detecting a violation of a timing assertion. Section 3 presents our event-based computation model, and discusses specification of timing assertions.
Reference: 3. <author> Chandy, K. M. and Lamport, L. </author> <month> February </month> <year> 1985. </year> <title> Distributed Snapshots: determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems. </journal>
Reference-contexts: Detecting a violation of a timing assertion in a distributed system is also related to the problem of detecting stable (global) properties of a system. Many snapshot algorithms for establishing a global consistent system state have been proposed in the past (e.g. <ref> [3] </ref>, [14]). A more recent work proposed a method for detecting locally stable properties by constructing substates of a system [18]. The goal of the snapshot algorithms is to preserve causality when constructing a global system state.
Reference: 4. <author> Chodrow, S., Jahanian, F. and Donner, M. </author> <month> Dec. </month> <year> 1991. </year> <title> Run-Time Monitoring of Real-Time Systems, </title> <booktitle> Proc. IEEE Real-Time Systems Symp., </booktitle> <pages> pp. 74-83. </pages>
Reference-contexts: Hence, design assumptions and important system constraints must be monitored at run-time, and a violation must be detected and appropriate action taken in a timely fashion. In an earlier work <ref> [4] </ref>, we have presented a general framework for formal specification and monitoring of run-time constraints in time-critical systems. We also described a single-processor implementation of a monitoring * This work was done while the first two authors were at the IBM T.J. <p> Our run-time monitor for distributed real-time systems is based on the Real-Time Logic (RTL) model proposed in [10], and our prototype is an extension of the uniprocessor implementation of <ref> [4] </ref>. In this model, a system computation is viewed as a sequence of event occurrences. The design assumptions and system properties that must be maintained are expressed as invariant relationships between various events, which are monitored during run-time. <p> This approach allows the run-time monitoring processes to be scheduled as time-constrained activities and therefore can be part of the schedulability test for the system. 3. Timing Constraints in Real-Time Systems We express the timing constraints in a notation based on RTL <ref> [4] </ref>, [10]. A detailed description of the computation model and the specification language is beyond the scope of this paper. In this section, we present an informal overview of the computational model and then discuss the representation of a timing assertion as a directed constraint graph. <p> Conclusions Run-time monitoring of a distributed real-time system must address issues such as constraint specification, clock synchronization, timer granularity, message overhead and time of detection. In this paper we have extended the uniprocessor monitoring model of <ref> [4] </ref> to a distributed real-time system. The principal advantage of our approach is that derived intermediate constraints can predict the violation of a user-level constraint even before the violation occurs. This can enable the application to take corrective action to adapt to the error condition.
Reference: 5. <author> Cristian, F. </author> <year> 1989. </year> <title> Probabilistic Clock Synchronization, </title> <booktitle> Distributed Computing 3, </booktitle> <pages> pp. 146-158. </pages>
Reference-contexts: We therefore use a clock synchronization algorithm [1], <ref> [5] </ref>, [16] to bound the deviations among the various processor clocks. As discussed in a subsequent section, we implemented approximately synchronized clocks based on the probabilistic algorithm described in [5]. A clock process on each processor synchronizes with the clock process on a master processor (master clock) by exchanging messages. <p> We therefore use a clock synchronization algorithm [1], <ref> [5] </ref>, [16] to bound the deviations among the various processor clocks. As discussed in a subsequent section, we implemented approximately synchronized clocks based on the probabilistic algorithm described in [5]. A clock process on each processor synchronizes with the clock process on a master processor (master clock) by exchanging messages. Let * be the maximum deviation among the clocks. <p> The monitor system, the clock synchronization layer and an X window system based user-interface consist of around 8000 lines of C code. We next describe in detail the principal layers that comprise our testbed. We implemented the probabilistic clock synchronization algorithm described in <ref> [5] </ref>. Every processor runs a clock-slave process that synchronizes its local clock with the clock on a master processor by periodically exchanging messages with the clock-master process. Based on our conservative choice of clock synchronization parameters, we calculated the clock deviation of three RS/6000's on a single token ring.
Reference: 6. <author> Garey, M. R. and Johnson, D. S. </author> <year> 1979. </year> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness, </title> <editor> W. H. </editor> <publisher> Freeman and Company. </publisher>
Reference-contexts: Proof: By transformation from the minimum equivalent digraph problem (MED) <ref> [6] </ref>. The formal statement of the MED problem is as follows: Instance: Directed graph G = (V; A), positive integer K jAj.
Reference: 7. <author> Garg, V. and Waldecker, B. </author> <year> 1992. </year> <title> Unstable Predicate Detection in Distributed Programs, </title> <type> Technical Report, </type> <institution> University of Texas at Austin. </institution>
Reference-contexts: Furthermore, causality between event occurrences is captured by a static constraint graph in our model. Recent work on evaluating nonstable global predicates for distributed computations also relate to our work, but to a lesser extent <ref> [7] </ref>, [17]. Reference [17] looks at several techniques for limiting the exponential number of states that must be considered to evaluate a property over computations. Reference [7] considers an alternative approach by restricting the global predicate to one that can be efficiently detected, such as the conjunction and disjunction of local <p> Recent work on evaluating nonstable global predicates for distributed computations also relate to our work, but to a lesser extent <ref> [7] </ref>, [17]. Reference [17] looks at several techniques for limiting the exponential number of states that must be considered to evaluate a property over computations. Reference [7] considers an alternative approach by restricting the global predicate to one that can be efficiently detected, such as the conjunction and disjunction of local predicates. A good article on monitoring distributed computations for asynchronous systems appears in [2]. The rest of this paper is organized as follows.
Reference: 8. <author> Haban, D. and Shin, K. G. </author> <month> Dec. </month> <year> 1989. </year> <title> Application of Real-Time Monitoring to Scheduling Tasks with Random Execution Times, </title> <booktitle> Proc. IEEE Real-Time Systems Symp., </booktitle> <pages> pp. 172-181. </pages>
Reference-contexts: These approaches introduce specialized co-processors for the collection and analysis of run-time information. The use of special-purpose hardware allows non-intrusive monitoring of a system by recording the run-time information in a large repository, often for post analysis. A related work <ref> [8] </ref> studies the use of monitoring information to aid in scheduling tasks.
Reference: 9. <author> Haban, D. and Wybranietz, D. </author> <month> Feb. </month> <year> 1990. </year> <title> A Hybrid Monitor for Behavior and Performance Analysis of Distributed Systems. </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 16,2, </volume> <pages> pp. 197-211. </pages>
Reference-contexts: Related Work Despite extensive work on monitoring and debugging facilities for parallel and distributed systems, run-time monitoring of real-time systems has received little attention with a few exceptions. Special hardware support for collecting run-time data in real-time applications has been considered in a number of recent papers <ref> [9] </ref>, [25]. These approaches introduce specialized co-processors for the collection and analysis of run-time information. The use of special-purpose hardware allows non-intrusive monitoring of a system by recording the run-time information in a large repository, often for post analysis.
Reference: 10. <author> Jahanian, F. and Goyal, A. </author> <month> June </month> <year> 1990. </year> <title> A Formalism for Monitoring Real-Time Constraints at Run-time, </title> <booktitle> Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 148-155. </pages>
Reference-contexts: Finally, in the absence of perfectly synchronized processor clocks or a global system clock, the meaning of a timing assertion on distributed events must be defined precisely. Our run-time monitor for distributed real-time systems is based on the Real-Time Logic (RTL) model proposed in <ref> [10] </ref>, and our prototype is an extension of the uniprocessor implementation of [4]. In this model, a system computation is viewed as a sequence of event occurrences. The design assumptions and system properties that must be maintained are expressed as invariant relationships between various events, which are monitored during run-time. <p> This approach allows the run-time monitoring processes to be scheduled as time-constrained activities and therefore can be part of the schedulability test for the system. 3. Timing Constraints in Real-Time Systems We express the timing constraints in a notation based on RTL [4], <ref> [10] </ref>. A detailed description of the computation model and the specification language is beyond the scope of this paper. In this section, we present an informal overview of the computational model and then discuss the representation of a timing assertion as a directed constraint graph. <p> As described in <ref> [10] </ref>, we use a notation based on RTL for specifying timing assertions.
Reference: 11. <author> Jahanian, F. and Rajkumar, R. </author> <month> May </month> <year> 1991. </year> <title> An Integrated Approach to Monitoring and Scheduling in Real-Time Systems, </title> <booktitle> IEEE Workshop on Real-Time Operating Systems and Software. </booktitle>
Reference-contexts: A discussion of our approach to scheduling the monitoring activities is beyond the scope of this paper and interested readers are referred to <ref> [11] </ref>. This approach allows the run-time monitoring processes to be scheduled as time-constrained activities and therefore can be part of the schedulability test for the system. 3. Timing Constraints in Real-Time Systems We express the timing constraints in a notation based on RTL [4], [10]. <p> Predictability is an important requirement of real-time systems. Therefore, one must quantify the intrusiveness of the monitoring activities on the timing behavior of the real-time application. Monitoring activities must themselves be scheduled and included in a scheduling analysis of the system <ref> [11] </ref>. A clean high-level programming interface is needed to specify the monitored constraints and their communication requirements. We are also designing a suite of complementary tools that support specification, testing, fault-injection and run-time monitoring of embedded real-time systems.
Reference: 12. <author> Kenny, K. B. and Lin, K.-J. </author> <month> May </month> <year> 1991. </year> <title> Building Flexible Real-Time Systems using the Flex Language. </title> <booktitle> Computer, </booktitle> <pages> pages 70-78. </pages>
Reference-contexts: These events are sent periodically by the local host to a remote host for displaying the execution history. The invasiveness of the monitoring facility is included in the schedulability analysis. Monitoring and detecting violations of certain predefined timing constraints have been proposed in real-time languages, such as FLEX <ref> [12] </ref>. Detecting a violation of a timing assertion in a distributed system is also related to the problem of detecting stable (global) properties of a system. Many snapshot algorithms for establishing a global consistent system state have been proposed in the past (e.g. [3], [14]).
Reference: 13. <author> Kilpatrick, C., Schwan, K. and Ogle, D. </author> <month> March </month> <year> 1990. </year> <title> Using Languages for Capture, Analysis and Display of Performance Information for Parallel and Distributed Applications, </title> <booktitle> International Conf. on Computer Languages. </booktitle>
Reference-contexts: The monitored information is fed back to the operating system for achieving an adaptive behavior. A work closer to our approach is a system for collection and analysis of distributed/parallel (real-time) programs <ref> [13] </ref>. The work is based on an earlier system for exploring the use of an extended E-R model for specification and access to monitoring information at run-time [22]. The assumption is that the relational model is an appropriate formalism for structuring the information generated by a distributed system.
Reference: 14. <author> Koo, R. and Toueg, S. </author> <month> January </month> <year> 1987. </year> <title> Checkpointing and Rollback-recovery for Distributed Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 23-31. </pages>
Reference-contexts: Detecting a violation of a timing assertion in a distributed system is also related to the problem of detecting stable (global) properties of a system. Many snapshot algorithms for establishing a global consistent system state have been proposed in the past (e.g. [3], <ref> [14] </ref>). A more recent work proposed a method for detecting locally stable properties by constructing substates of a system [18]. The goal of the snapshot algorithms is to preserve causality when constructing a global system state.
Reference: 15. <author> Kopetz, H. and Verissimo, P. </author> <year> 1990. </year> <title> Real-Time and Dependability Concepts, Distributed Systems, 2nd Edition, </title> <editor> S. </editor> <booktitle> Mullen-der(editor), </booktitle> <pages> pages 411-46. </pages>
Reference-contexts: Embedded real-time systems are in essence responsive: they often interact with the environment by "reacting to stimuli of external events and producing results, within specified timing constraints" <ref> [15] </ref>. To guarantee this responsiveness, the system must be able to provide the expected service even in the presence of faults. This paper addresses the problem of detecting timing failures in distributed real-time systems.
Reference: 16. <author> Lundelius, J. and Lynch, N. </author> <year> 1984. </year> <title> An Upper and Lower Bound for Clock Synchronization, </title> <booktitle> Information and Control 62, </booktitle> <pages> pp. 190-204. </pages>
Reference-contexts: We therefore use a clock synchronization algorithm [1], [5], <ref> [16] </ref> to bound the deviations among the various processor clocks. As discussed in a subsequent section, we implemented approximately synchronized clocks based on the probabilistic algorithm described in [5]. A clock process on each processor synchronizes with the clock process on a master processor (master clock) by exchanging messages.
Reference: 17. <author> Marzullo, K. and Neiger, G. </author> <year> 1991. </year> <title> Detection of Global State predicates, </title> <booktitle> Proc. of 5th International Workshop on Distributed Algorithms (WDAG-91), Delphi, </booktitle> <address> Greece, </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Furthermore, causality between event occurrences is captured by a static constraint graph in our model. Recent work on evaluating nonstable global predicates for distributed computations also relate to our work, but to a lesser extent [7], <ref> [17] </ref>. Reference [17] looks at several techniques for limiting the exponential number of states that must be considered to evaluate a property over computations. <p> Furthermore, causality between event occurrences is captured by a static constraint graph in our model. Recent work on evaluating nonstable global predicates for distributed computations also relate to our work, but to a lesser extent [7], <ref> [17] </ref>. Reference [17] looks at several techniques for limiting the exponential number of states that must be considered to evaluate a property over computations. Reference [7] considers an alternative approach by restricting the global predicate to one that can be efficiently detected, such as the conjunction and disjunction of local predicates.
Reference: 18. <author> Marzullo, K. and Sabel, L. </author> <month> March </month> <year> 1992. </year> <title> Using Consistent Subcuts for Detecting Stable Properties, </title> <institution> Technical Report Department of Computer Science, Cornell University. </institution>
Reference-contexts: Many snapshot algorithms for establishing a global consistent system state have been proposed in the past (e.g. [3], [14]). A more recent work proposed a method for detecting locally stable properties by constructing substates of a system <ref> [18] </ref>. The goal of the snapshot algorithms is to preserve causality when constructing a global system state. In our case, if a history of event occurrences is 3 maintained, then detecting a violation of a timing assertion can be viewed as detecting a stable property.
Reference: 19. <author> Raju, S. C. V. </author> <year> 1994. </year> <title> Using Assertions for Validating, Verifying and Monitoring Real-Time Systems, </title> <type> Ph.D. Thesis, </type> <institution> University of Washington. </institution>
Reference-contexts: We are also designing a suite of complementary tools that support specification, testing, fault-injection and run-time monitoring of embedded real-time systems. The approach to run-time monitoring of real-time systems, presented in this paper, has been used to check the simulation of an executable specification. References <ref> [19] </ref>, [21] describe the design, implementation and some experiments with a monitor for a real-time executable specification language called Communicating Real-Time State Machines. The simulation of an executable specification generates a trace of events. The trace can be tested for functional and timing correctness.
Reference: 20. <author> Raju, S. C. V., Rajkumar, R., and Jahanian, F. </author> <month> December </month> <year> 1992. </year> <title> Monitoring Timing Constraints in Distributed Real-Time Systems, </title> <booktitle> Proceedings of the 14th Real-Time Systems Symposium, </booktitle> <pages> pp. 57-67. </pages>
Reference: 21. <author> Raju, S. C. V. and Shaw, A. C. </author> <month> February </month> <year> 1994. </year> <title> "A Prototyping Environment for Specifying, Executing and Checking Communicating Real-Time State Machines", </title> <journal> Software Practice& Experience, </journal> <pages> pp. 175-195. </pages>
Reference-contexts: We are also designing a suite of complementary tools that support specification, testing, fault-injection and run-time monitoring of embedded real-time systems. The approach to run-time monitoring of real-time systems, presented in this paper, has been used to check the simulation of an executable specification. References [19], <ref> [21] </ref> describe the design, implementation and some experiments with a monitor for a real-time executable specification language called Communicating Real-Time State Machines. The simulation of an executable specification generates a trace of events. The trace can be tested for functional and timing correctness.
Reference: 22. <author> Snodgrass, R. </author> <month> May </month> <year> 1988. </year> <title> A Relational Approach to Monitoring Complex Systems. </title> <journal> ACM Trans. on Computer Systems 6,2, </journal> <pages> pp. 157-196. </pages>
Reference-contexts: A work closer to our approach is a system for collection and analysis of distributed/parallel (real-time) programs [13]. The work is based on an earlier system for exploring the use of an extended E-R model for specification and access to monitoring information at run-time <ref> [22] </ref>. The assumption is that the relational model is an appropriate formalism for structuring the information generated by a distributed system. A real-time monitor developed for the ARTS distributed operating system is presented in [24].
Reference: 23. <author> Tarjan, R. E. </author> <year> 1983. </year> <title> Data Structures and Network Algorithms, </title> <institution> Society for Industrial and Applied Mathematics. </institution>
Reference-contexts: The Floyd-Warshall all-pairs shortest-path algorithm <ref> [23] </ref> can be used to find the length of the shortest cycles from all vertices in the constraint graph. The complexity of the algorithm is O (n 3 ), where n is the number of vertices in the graph.
Reference: 24. <author> Tokuda, H., Koreta M. and Mercer, C. W. </author> <month> Jan. </month> <year> 1989. </year> <title> A Real-Time Monitor for a Distributed Real-Time Operating System, </title> <journal> ACM Sigplan Notices 24,1, </journal> <pages> pp. 68-77. </pages>
Reference-contexts: The assumption is that the relational model is an appropriate formalism for structuring the information generated by a distributed system. A real-time monitor developed for the ARTS distributed operating system is presented in <ref> [24] </ref>. The proposed monitor requires certain support from the kernel, such as notification of the state changes of a process, including waking-up, being scheduled.
Reference: 25. <author> Tsai, J. P., Fang, K-Y and Chen, H-Y. </author> <month> March </month> <year> 1990. </year> <title> A Noninvasive Architecture to Monitor Real-Time Distributed Systems, </title> <booktitle> IEEE Computer 23,3, </booktitle> <pages> pp. 11-23. 20 </pages>
Reference-contexts: Related Work Despite extensive work on monitoring and debugging facilities for parallel and distributed systems, run-time monitoring of real-time systems has received little attention with a few exceptions. Special hardware support for collecting run-time data in real-time applications has been considered in a number of recent papers [9], <ref> [25] </ref>. These approaches introduce specialized co-processors for the collection and analysis of run-time information. The use of special-purpose hardware allows non-intrusive monitoring of a system by recording the run-time information in a large repository, often for post analysis.
References-found: 25

