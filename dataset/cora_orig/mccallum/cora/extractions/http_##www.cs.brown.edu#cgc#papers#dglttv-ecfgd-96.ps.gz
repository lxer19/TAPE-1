URL: http://www.cs.brown.edu/cgc/papers/dglttv-ecfgd-96.ps.gz
Refering-URL: http://www.cs.brown.edu/people/rt/papers/recent-papers/recent-papers.html
Root-URL: http://www.cs.brown.edu
Email: dibattista@iasi.rm.cnr.it  ag@cs.brown.edu  gl@cs.brown.edu  rt@cs.brown.edu  tassinar@dis.uniroma1.it  vargiu@dis.uniroma1.it  
Title: An Experimental Comparison of Four Graph Drawing Algorithms  
Author: Giuseppe Di Battista Ashim Garg Giuseppe Liotta Roberto Tamassia Emanuele Tassinari Francesco Vargiu 
Date: November 1995)  
Note: (Revised Version,  
Address: via della Vasca Navale 00146 Roma Italy  115 Waterman Street Providence, RI 02912-1910 USA  115 Waterman Street Providence, RI 02912-1910 USA  115 Waterman Street Providence, RI 02912-1910 USA  Via Salaria, 113 00198 Roma Italy  Via Salaria, 113 00198 Roma Italy  
Affiliation: Dip. Discipline Scientifiche, Sez. Informatica Terza Universita di Roma  Department of Computer Science Brown University  Department of Computer Science Brown University  Department of Computer Science Brown University  Dip. Informatica e Sistemistica Universita di Roma "La Sapienza"  Dip. Informatica e Sistemistica Universita di Roma "La Sapienza"  
Abstract: In this paper we present an extensive experimental study comparing four general-purpose graph drawing algorithms. The four algorithms take as input general graphs (with no restrictions whatsoever on connectivity, planarity, etc.) and construct orthogonal grid drawings, which are widely used in software and database visualization applications. The test data (available by anonymous ftp) are 11,582 graphs, ranging from 10 to 100 vertices, which have been generated from a core set of 112 graphs used in "real-life" software engineering and database applications. The experiments provide a detailed quantitative evaluation of the performance of the four algorithms, and show that they exhibit trade-offs between "aesthetic" properties (e.g., crossings, bends, edge length) and running time. fl Research supported in part by the US National Science Foundation under grant CCR-9423847, by the U.S. Army Research Office under grant 34990-MA-MUR, by the Office of Naval Research and the Advanced Research Projects Agency under contract N00014-91-J-4052, ARPA order 8225, by the NATO Scientific Affairs Division, by the "Progetto Ambienti di Supporto all Progettazione di sistemi Informativi" and Grant 94.23.CT07 of the Italian National Research Council (CNR), and by the ESPRIT II Basic Research Actions Program of the European Community (project ALgorithms and Complexity). An extended abstract of this work was presented at the 11th Annual ACM Symposium on Computational Geometry, held in Vancouver (CA) in June 1995. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Batini, S. Ceri, and S. B. Navathe. </author> <title> Conceptual Database Design, an Entity-Relationship Approach. </title> <publisher> Benjamin Cummings, </publisher> <year> 1992. </year>
Reference-contexts: (especially from Database Informatica) and large government organization (including the Italian Internal Revenue Service and the Italian National Advisory Council for Computer Applications in the Government (Autorita per l'Informatica nella Pubblica Amministrazione)). * 33% of the graphs were taken from well-known reference books in software engineering [18] and database design <ref> [1] </ref>, and from journal articles on software visualization in the recent issues of Information Systems and the IEEE Transactions on Software Engineering. * 13% of the graphs were extracted from theses in software and database visualization written by students at the University of Rome "La Sapienza". the average number of edges
Reference: [2] <author> C. Batini, L. Furlani, and E. Nardelli. </author> <title> What is a good diagram? A pragmatic approach. </title> <booktitle> In Proc. 4th Internat. Conf. on the Entity Relationship Approach, </booktitle> <year> 1985. </year>
Reference-contexts: The average number of edges of the test graphs is slightly higher than the one of the core graphs. The 11; 582 test graphs are available on the Internet from ftp://infokit.dis.uniroma1.it/public/. Sparsity and "near-planarity" are typical properties of graphs used in software engineering and 9 database applications <ref> [2] </ref>. As expected, the test graphs turn out to be sparse (the average vertex degree is about 2.7, see Fig. 5.b) and with low crossing number (the experiments show that the average number of crossings is no more than about 0.7 times the number of vertices, see Fig. 6.b).
Reference: [3] <author> C. Batini, E. Nardelli, and R. Tamassia. </author> <title> A layout algorithm for data-flow diagrams. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> SE-12(4):538-546, </volume> <year> 1986. </year>
Reference-contexts: The augmentation edges are not displayed in the final drawing. multigraph general multigraphs accepted as input MakeConnected connectivity testing and augmentation connected connected graph MakeBiconnected biconnectivity testing and augmentation biconnected biconnected graph MakePlanar planarization <ref> [3, 33] </ref> connectedplanar crossings are now replaced by dummy vertices Make4planar expansion of vertices with degree greater than 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum degree 4 Step3giotto orthogonalization [39] step1TaTo89 construction of a visibility representation [37, 41, 49]) <p> graph has now maximum degree 4 Step3giotto orthogonalization [39] step1TaTo89 construction of a visibility representation [37, 41, 49]) step2TaTo89 fast orthogonalization [42] step4TaTo89 bend-stretching transformations, which remove bends by local lay out modifications [42] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto tidy compaction <ref> [3] </ref> BiedlKant orthogonal drawing algorithm [6] PapakostasTollis orthogonal drawing algorithm of [34, 35] manhattan the final output is an orthogonal grid drawing Table 1: Algorithmic components and intermediate representations used by algorithms Bend-Stretch, Column, Giotto, and Pair. <p> Details on key algorithmic components of Bend-Stretch, Column, Giotto, and Pair and their implementation are given below: MakePlanar This algorithmic component is the planarization phase of the algorithm described in <ref> [3] </ref>. It consists of the following steps: Extraction of a Planar Subgraph In this step, a set of edges is removed such that the resulting subgraph is planar. <p> The minimum cost flow is computed with the standard method of augmenting the flow along minimum-cost paths. Suitable con straints force a rectangular shape for the skeleton subgraphs (see Make4planar). Step4giotto This algorithmic component is the "tidy compaction" described in <ref> [3, 40] </ref> that computes an orthogonal grid drawing from an orthogonal representation by assigning integer lengths to the horizontal and vertical segments of the edges. This is done in two steps. First, the faces of the orthogonal representation are decomposed into rectangles.
Reference: [4] <author> Giuseppe Di Battista, Ashim Garg, Giuseppe Liotta, Roberto Tamassia, Emanuele Tassinari, and Francesco Vargiu. </author> <title> An experimental comparison of three graph drawing algorithms. </title> <booktitle> In Proc. 11th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 306-315, </pages> <year> 1995. </year>
Reference-contexts: This work provides an excellent overview and comparison of the main features of some popular drawing algorithms. However, it does not give detailed statistical results on their performance. After the conference version of the present paper appeared <ref> [4] </ref>, Brandenburg and Rohrer [7] have compared five "force-directed" methods for constructing straight-line drawings of general undirected graphs. The algorithms are tested on a a wide collection of examples and with different settings of the force parameters. The quality measures evaluated are crossings, edge length, vertex distribution, and running time.
Reference: [5] <author> P. Bertolazzi, G. Di Battista, and G. Liotta. </author> <title> Parametric graph drawing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(8) </volume> <pages> 662-673, </pages> <year> 1995. </year>
Reference-contexts: Diagram Server offers to its clients a set of facilities to represent and manage diagrams through a multiwindowing environment. One of the most important facilities is a library of automatic graph drawing algorithms <ref> [5] </ref>. A graph 10 drawing algorithm is fully specified in the automatic graph drawing facility by an algorithmic path, which describes the sequence of steps and intermediate representations (e.g., planar embedding, orthogonal shape, visibility representation) produced by the algorithm.
Reference: [6] <author> T. Biedl and G. Kant. </author> <title> A better heuristic for orthogonal graph drawings. </title> <booktitle> In Proc. 2nd Annu. European Sympos. Algorithms (ESA '94), volume 855 of Lecture Notes in Computer Science, </booktitle> <pages> pages 24-35. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The four algorithms, denoted Bend-Stretch, Column, Giotto, and Pair, are derived from theoretical papers <ref> [6, 34, 39, 42] </ref>, take as input general graphs (with no restrictions whatsoever on connectivity, planarity, etc.), and construct orthogonal grid drawings. <p> Algorithm Column is an extension of the orthogonal drawing algorithm by Biedl and Kant <ref> [6] </ref> to graphs of arbitrary vertex degree. Algorithm Pair is an extension of the orthogonal drawing algorithm by Papakostas and Tollis [34, 35] to graphs of arbitrary vertex degree. <p> 4 Step3giotto orthogonalization [39] step1TaTo89 construction of a visibility representation [37, 41, 49]) step2TaTo89 fast orthogonalization [42] step4TaTo89 bend-stretching transformations, which remove bends by local lay out modifications [42] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto tidy compaction [3] BiedlKant orthogonal drawing algorithm <ref> [6] </ref> PapakostasTollis orthogonal drawing algorithm of [34, 35] manhattan the final output is an orthogonal grid drawing Table 1: Algorithmic components and intermediate representations used by algorithms Bend-Stretch, Column, Giotto, and Pair. <p> The implementation closely follows the description of the algorithm in <ref> [6] </ref>. PapakostasTollis This step is implemented using the description of the algorithm of [34] given in [35]. The algorithm as described in [35] requires each vertex of the input graph to have degree exactly 4. <p> TotalBends: The experimental results sharply fit the theoretical results. Namely, Giotto has the minimum number of bends; Bend-Stretch, Column and Pair have a number of bends that, also for the constants, is essentially the one predicted by the theoretical analysis <ref> [42, 6, 34, 35] </ref>. As pointed out in Observation 1, the performance of Bend-Stretch, Pair, and Column on TotalBends negatively affects their performance on Area.
Reference: [7] <author> Franz J. Brandenburg and Christoph Rohrer. </author> <title> An experimental comparison of force-directed and randomized graph drawing algorithms. In Proc. Graph Drawing 1995, </title> <note> LNCS. (to appear). </note>
Reference-contexts: This work provides an excellent overview and comparison of the main features of some popular drawing algorithms. However, it does not give detailed statistical results on their performance. After the conference version of the present paper appeared [4], Brandenburg and Rohrer <ref> [7] </ref> have compared five "force-directed" methods for constructing straight-line drawings of general undirected graphs. The algorithms are tested on a a wide collection of examples and with different settings of the force parameters. The quality measures evaluated are crossings, edge length, vertex distribution, and running time.
Reference: [8] <author> N. Chiba, K. Onoguchi, and T. Nishizeki. </author> <title> Drawing planar graphs nicely. </title> <journal> Acta Inform., </journal> <volume> 22 </volume> <pages> 187-201, </pages> <year> 1985. </year>
Reference-contexts: However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. The performance of four planar straight-line drawing algorithms <ref> [8, 9, 12, 36, 46] </ref> is compared in [23]. These algorithms have been implemented and tested on 10,000 randomly generated maximal planar graphs. The standard deviations in angle size, edge length, and face area are used to compare the quality of the planar straight-line drawings produced. <p> Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [20] presents a comparative study of twelve graph drawings algorithms, including <ref> [8, 12, 17, 28, 38, 39, 48, 50] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planarization) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
Reference: [9] <author> M. Chrobak and T. Payne. </author> <title> A linear-time algorithm for drawing planar graphs. </title> <journal> Information Processing Letters, </journal> <volume> 54 </volume> <pages> 241-246, </pages> <year> 1995. </year>
Reference-contexts: However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. The performance of four planar straight-line drawing algorithms <ref> [8, 9, 12, 36, 46] </ref> is compared in [23]. These algorithms have been implemented and tested on 10,000 randomly generated maximal planar graphs. The standard deviations in angle size, edge length, and face area are used to compare the quality of the planar straight-line drawings produced.
Reference: [10] <author> R. F. Cohen, P. Eades, T. Lin, and F. Ruskey. </author> <title> Three-dimensional graph drawing. </title> <editor> In R. Tamas-sia and I. G. Tollis, editors, </editor> <booktitle> Graph Drawing (Proc. GD '94), volume 894 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-11. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: It would be interesting to improve on the time complexity of bend minimization. * It would be interesting to devise practical algorithms for orthogonal drawings in the 3 dimensional space. For recent results, see <ref> [10] </ref>. * Extensive experiments on algorithms for constructing other types of drawings (e.g., straight line, polyline, upward) should be conducted. Acknowledgments We thank Yannis Tollis and the anonymous referees for useful comments and suggestions. 19
Reference: [11] <author> R. Davidson and D. Harel. </author> <title> Drawing graphs nicely using simulated annealing. </title> <type> Technical report, </type> <institution> Department of Applied Mathematics and Computer Science, The Weizmann Institute of Science, Rehovot, </institution> <year> 1989. </year>
Reference-contexts: Most papers in this area show sample outputs, and some also provide limited experimental results on small (with fewer than 100 graphs) test suites (see, e.g., <ref> [11, 17, 19, 24, 27, 29] </ref> and the experimental papers in [43]). However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain.
Reference: [12] <author> H. de Fraysseix, J. Pach, and R. Pollack. </author> <title> Small sets supporting Fary embeddings of planar graphs. </title> <booktitle> In Proc. 20th Annu. ACM Sympos. Theory Comput., </booktitle> <pages> pages 426-433, </pages> <year> 1988. </year>
Reference-contexts: However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. The performance of four planar straight-line drawing algorithms <ref> [8, 9, 12, 36, 46] </ref> is compared in [23]. These algorithms have been implemented and tested on 10,000 randomly generated maximal planar graphs. The standard deviations in angle size, edge length, and face area are used to compare the quality of the planar straight-line drawings produced. <p> Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [20] presents a comparative study of twelve graph drawings algorithms, including <ref> [8, 12, 17, 28, 38, 39, 48, 50] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planarization) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
Reference: [13] <author> G. Di Battista, P. Eades, R. Tamassia, and I. G. Tollis. </author> <title> Algorithms for drawing graphs: an annotated bibliography. </title> <journal> Comput. Geom. Theory Appl., </journal> <volume> 4 </volume> <pages> 235-282, </pages> <year> 1994. </year>
Reference-contexts: Because of the direct applications of graph drawing to advanced graphic user interfaces and visualization systems, and thanks to the many theoretical challenges posed by the interplay of graph theory and geometry, an extensive literature on the subject <ref> [13, 43] </ref> has grown in the last decade. Various graphic standards have been proposed for the representation of graphs in the plane. <p> It is widely accepted (see, e.g., <ref> [13] </ref> ) that small values of the above measures are related to the perceived aesthetic appeal and visual effectiveness of the drawing. 3.2 Generation of the Test Graphs Since we are interested in evaluating the performance of graph drawing algorithms in practical applications, we have disregarded approaches completely based on random
Reference: [14] <author> G. Di Battista, A. Giammarco, G. Santucci, and R. Tamassia. </author> <title> The architecture of Diagram Server. </title> <booktitle> In Proc. IEEE Workshop on Visual Languages (VL'90), </booktitle> <pages> pages 60-65, </pages> <year> 1990. </year>
Reference-contexts: the above applications (clustering methods are typically used to hierarchically display large graphs). (a) (b) number of edges of the core graphs versus number of vertices. (a) (b) number of edges of the test graphs versus number of vertices. 3.3 Diagram Server Our experimental study was conducted using Diagram Server <ref> [14, 15] </ref>, a network server for client-applications that use diagrams (drawings of graphs). Diagram Server offers to its clients a set of facilities to represent and manage diagrams through a multiwindowing environment. One of the most important facilities is a library of automatic graph drawing algorithms [5].
Reference: [15] <author> G. Di Battista, G. Liotta, and F. Vargiu. </author> <title> Diagram Server. </title> <journal> J. Visual Languages and Computing, </journal> <volume> 6(3), </volume> <year> 1995. </year> <title> (special issue on Graph Visualization, edited by I. </title> <editor> F. Cruz and P. </editor> <publisher> Eades). </publisher>
Reference-contexts: the above applications (clustering methods are typically used to hierarchically display large graphs). (a) (b) number of edges of the core graphs versus number of vertices. (a) (b) number of edges of the test graphs versus number of vertices. 3.3 Diagram Server Our experimental study was conducted using Diagram Server <ref> [14, 15] </ref>, a network server for client-applications that use diagrams (drawings of graphs). Diagram Server offers to its clients a set of facilities to represent and manage diagrams through a multiwindowing environment. One of the most important facilities is a library of automatic graph drawing algorithms [5].
Reference: [16] <author> D. Dolev, F. T. Leighton, and H. Trickey. </author> <title> Planar embedding of planar graphs. </title> <editor> In F. P. Preparata, editor, </editor> <booktitle> Advances in Computing Research, </booktitle> <volume> volume 2, </volume> <pages> pages 147-161. </pages> <publisher> JAI Press, </publisher> <address> Greenwich, Conn., </address> <year> 1985. </year>
Reference-contexts: Finally, the experiments performed are an interesting source of both theoretical and practical open problems: * It would be interesting to perform further experiments on the practical performance of separator-based methods <ref> [16, 32, 47] </ref> that were originally developed for VLSI layout. * The behavior of Bend-Stretch could be improved by using, instead of the classical algorithms of [37, 41, 49], the algorithm by Kant [30] for constructing compact visibility representations. * The performance of Giotto and Bend-Stretch is affected by the number
Reference: [17] <author> T. Fruchterman and E. Reingold. </author> <title> Graph drawing by force-directed placement. </title> <journal> Softw. - Pract. Exp., </journal> <volume> 21(11) </volume> <pages> 1129-1164, </pages> <year> 1991. </year>
Reference-contexts: Most papers in this area show sample outputs, and some also provide limited experimental results on small (with fewer than 100 graphs) test suites (see, e.g., <ref> [11, 17, 19, 24, 27, 29] </ref> and the experimental papers in [43]). However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. <p> Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [20] presents a comparative study of twelve graph drawings algorithms, including <ref> [8, 12, 17, 28, 38, 39, 48, 50] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planarization) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
Reference: [18] <author> G. Gane and T. Sarson. </author> <title> Structured Systems Analysis. </title> <publisher> Prentice Hall, </publisher> <year> 1979. </year>
Reference-contexts: major Italian software companies (especially from Database Informatica) and large government organization (including the Italian Internal Revenue Service and the Italian National Advisory Council for Computer Applications in the Government (Autorita per l'Informatica nella Pubblica Amministrazione)). * 33% of the graphs were taken from well-known reference books in software engineering <ref> [18] </ref> and database design [1], and from journal articles on software visualization in the recent issues of Information Systems and the IEEE Transactions on Software Engineering. * 13% of the graphs were extracted from theses in software and database visualization written by students at the University of Rome "La Sapienza". the
Reference: [19] <author> E. R. Gansner, S. C. North, and K. P. Vo. </author> <title> DAG A program that draws directed graphs. </title> <journal> Softw. - Pract. Exp., </journal> <volume> 18(11) </volume> <pages> 1047-1062, </pages> <year> 1988. </year> <month> 20 </month>
Reference-contexts: Most papers in this area show sample outputs, and some also provide limited experimental results on small (with fewer than 100 graphs) test suites (see, e.g., <ref> [11, 17, 19, 24, 27, 29] </ref> and the experimental papers in [43]). However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain.
Reference: [20] <author> M. Himsolt. </author> <title> Comparing and evaluating layout algorithms within GraphEd. </title> <journal> J. Visual Lan--guages and Computing, </journal> <volume> 6(3), </volume> <year> 1995. </year> <title> (special issue on Graph Visualization, edited by I. </title> <editor> F. Cruz and P. </editor> <publisher> Eades). </publisher>
Reference-contexts: Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt <ref> [20] </ref> presents a comparative study of twelve graph drawings algorithms, including [8, 12, 17, 28, 38, 39, 48, 50]. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planarization) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
Reference: [21] <author> M. Himsolt. GraphEd: </author> <title> a graphical platform for the implementation of graph algorithms. </title> <editor> In R. Tamassia and I. G. Tollis, editors, </editor> <booktitle> Graph Drawing (Proc. GD '94), volume 894 of Lecture Notes in Computer Science, </booktitle> <pages> pages 182-193. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Only three algorithms draw general graphs, while the others are specialized for trees, planar graphs, Petri nets, and graph grammars. The experiments are conducted with the graph drawing system GraphEd <ref> [21] </ref>. Many examples of drawings constructed by the algorithms are shown, and various objective and subjective evaluations on the aesthetic quality of the drawings produced are given. However, statistics are provided only on the edge length, and few details on the experimental setting are provided.
Reference: [22] <author> J. Hopcroft and R. E. Tarjan. </author> <title> Efficient planarity testing. </title> <journal> J. ACM, </journal> <volume> 21(4) </volume> <pages> 549-568, </pages> <year> 1974. </year>
Reference-contexts: It consists of the following steps: Extraction of a Planar Subgraph In this step, a set of edges is removed such that the resulting subgraph is planar. The technique used is a greedy heuristic [33] that extends the the Hopcroft-Tarjan planarity testing algorithm <ref> [22] </ref> as follows: whenever a nonplanar configuration is detected, a sufficient number of edges is removed to resume the planarity testing algorithm.
Reference: [23] <author> S. Jones, P. Eades, A. Moran, N. Ward, G. Delott, and R. Tamassia. </author> <title> A note on planar graph drawing algorithms. </title> <type> Technical Report 216, </type> <institution> Department of Computer Science, University of Queensland, </institution> <year> 1991. </year>
Reference-contexts: However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. The performance of four planar straight-line drawing algorithms [8, 9, 12, 36, 46] is compared in <ref> [23] </ref>. These algorithms have been implemented and tested on 10,000 randomly generated maximal planar graphs. The standard deviations in angle size, edge length, and face area are used to compare the quality of the planar straight-line drawings produced.
Reference: [24] <author> M. Junger and P. Mutzel. </author> <title> Maximum planar subgraphs and nice embeddings: Practical layout tools. </title> <journal> Algorithmica. </journal> <note> (special issue on Graph Drawing, </note> <author> edited by G. Di Battista and R. Tamassia, </author> <note> to appear). </note>
Reference-contexts: Most papers in this area show sample outputs, and some also provide limited experimental results on small (with fewer than 100 graphs) test suites (see, e.g., <ref> [11, 17, 19, 24, 27, 29] </ref> and the experimental papers in [43]). However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. <p> Can a more sophisticated heuristics (for example based on the work of Junger and Mutzel <ref> [24] </ref> on the computation of the maximum planar subgraph) dramatically improve the behavior of such algorithms? * The performance of the algorithms Bend-Stretch, Column and Pair is affected by the bi-connectivity augmentation step (MakeBiconnected).
Reference: [25] <author> M. Junger and P. Mutzel. </author> <title> The polyhedral approach to the maximum planar subgraph problem: New chances for related problems. </title> <editor> In R. Tamassia and I. G. Tollis, editors, </editor> <booktitle> Graph Drawing (Proc. GD '94), volume 894 of Lecture Notes in Computer Science, </booktitle> <pages> pages 119-130. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: How much will it improve if we use a more sophisticated biconnectivity augmentation technique that preserves planarity (e.g., [31])? This issue is addressed in <ref> [25] </ref>. * One of the computational bottlenecks of the Giotto algorithm is the bend minimization step (Step3giotto), which has quadratic time complexity [39].
Reference: [26] <author> Michael Junger and Petra Mutzel. </author> <title> Exact and heuristic algorithms for 2-layer straightline crossing minimization. In Proc. Graph Drawing 1995, </title> <note> LNCS. (to appear). </note>
Reference-contexts: The quality measures evaluated are crossings, edge length, vertex distribution, and running time. They also identify tradeoffs between the running time and the aesthetic quality of the drawings produced. Junger and Mutzel <ref> [26] </ref> recently investigated crossing minimization strategies for straight-line 1 drawings of 2-layer graphs, and compared the performance of eight popular heuristics for this problem. 1.2 Our Results In this paper we present an extensive experimental study comparing four general-purpose graph drawing algorithms.
Reference: [27] <author> T. Kamada. </author> <title> Visualizing Abstract Objects and Relations. </title> <booktitle> World Scientific Series in Computer Science, </booktitle> <year> 1989. </year>
Reference-contexts: Most papers in this area show sample outputs, and some also provide limited experimental results on small (with fewer than 100 graphs) test suites (see, e.g., <ref> [11, 17, 19, 24, 27, 29] </ref> and the experimental papers in [43]). However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain.
Reference: [28] <author> T. Kamada and S. Kawai. </author> <title> An algorithm for drawing general undirected graphs. </title> <journal> Inform. Process. Lett., </journal> <volume> 31 </volume> <pages> 7-15, </pages> <year> 1989. </year>
Reference-contexts: Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [20] presents a comparative study of twelve graph drawings algorithms, including <ref> [8, 12, 17, 28, 38, 39, 48, 50] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planarization) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
Reference: [29] <author> G. Kant. </author> <title> Algorithms for Drawing Planar Graphs. </title> <type> PhD thesis, </type> <institution> Dept. Comput. Sci., Univ. </institution> <address> Utrecht, Utrecht, Netherlands, </address> <year> 1993. </year>
Reference-contexts: Most papers in this area show sample outputs, and some also provide limited experimental results on small (with fewer than 100 graphs) test suites (see, e.g., <ref> [11, 17, 19, 24, 27, 29] </ref> and the experimental papers in [43]). However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. <p> The second phase, orthogonalization, computes an orthogonal shape for the drawing. The third phase, compaction, produces the final drawing. This approach allows homogeneous treatment of a wide range of diagrammatic representations, aesthetics and constraints (see, e.g., <ref> [29, 40, 45] </ref>) and has been successfully used in industrial tools.
Reference: [30] <author> G. Kant. </author> <title> A more compact visibility representation. </title> <booktitle> In Proc. 19th Internat. Workshop Graph-Theoret. </booktitle> <institution> Concepts Comput. Sci. (WG'93), </institution> <year> 1993. </year>
Reference-contexts: problems: * It would be interesting to perform further experiments on the practical performance of separator-based methods [16, 32, 47] that were originally developed for VLSI layout. * The behavior of Bend-Stretch could be improved by using, instead of the classical algorithms of [37, 41, 49], the algorithm by Kant <ref> [30] </ref> for constructing compact visibility representations. * The performance of Giotto and Bend-Stretch is affected by the number of crossings introduced by the planarization phase.
Reference: [31] <author> G. Kant and H. L. Bodlaender. </author> <title> Planar graph augmentation problems. </title> <booktitle> In Proc. 2nd Workshop Algorithms Data Struct., volume 519 of Lecture Notes in Computer Science, </booktitle> <pages> pages 286-298. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: How much will it improve if we use a more sophisticated biconnectivity augmentation technique that preserves planarity (e.g., <ref> [31] </ref>)? This issue is addressed in [25]. * One of the computational bottlenecks of the Giotto algorithm is the bend minimization step (Step3giotto), which has quadratic time complexity [39].
Reference: [32] <author> C. E. Leiserson. </author> <title> Area-efficient graph layouts (for VLSI). </title> <booktitle> In Proc. 21st Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 270-281, </pages> <year> 1980. </year>
Reference-contexts: This result is somehow surprising since one would expect a better behavior for Pair and Column, which allow edge crossings even when the input graph is planar (the area of a drawing of a planar graph benefits of the possibility of introducing edge-crossings <ref> [32, 47] </ref>). We observe the following: Observation 1: While Giotto minimizes the number of bends, Bend-Stretch Pair and Column do not. <p> Finally, the experiments performed are an interesting source of both theoretical and practical open problems: * It would be interesting to perform further experiments on the practical performance of separator-based methods <ref> [16, 32, 47] </ref> that were originally developed for VLSI layout. * The behavior of Bend-Stretch could be improved by using, instead of the classical algorithms of [37, 41, 49], the algorithm by Kant [30] for constructing compact visibility representations. * The performance of Giotto and Bend-Stretch is affected by the number
Reference: [33] <author> E. Nardelli and M. Talamo. </author> <title> A fast algorithm for planarization of sparse diagrams. </title> <type> Technical Report R.105, </type> <institution> IASI-CNR, Rome, </institution> <year> 1984. </year>
Reference-contexts: The augmentation edges are not displayed in the final drawing. multigraph general multigraphs accepted as input MakeConnected connectivity testing and augmentation connected connected graph MakeBiconnected biconnectivity testing and augmentation biconnected biconnected graph MakePlanar planarization <ref> [3, 33] </ref> connectedplanar crossings are now replaced by dummy vertices Make4planar expansion of vertices with degree greater than 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum degree 4 Step3giotto orthogonalization [39] step1TaTo89 construction of a visibility representation [37, 41, 49]) <p> It consists of the following steps: Extraction of a Planar Subgraph In this step, a set of edges is removed such that the resulting subgraph is planar. The technique used is a greedy heuristic <ref> [33] </ref> that extends the the Hopcroft-Tarjan planarity testing algorithm [22] as follows: whenever a nonplanar configuration is detected, a sufficient number of edges is removed to resume the planarity testing algorithm.
Reference: [34] <author> A. Papakostas and I. G. Tollis. </author> <title> Improved algorithms and bounds for orthogonal drawings. </title> <editor> In R. Tamassia and I. G. Tollis, editors, </editor> <booktitle> Graph Drawing (Proc. GD '94), volume 894 of Lecture Notes in Computer Science, </booktitle> <pages> pages 40-51. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The four algorithms, denoted Bend-Stretch, Column, Giotto, and Pair, are derived from theoretical papers <ref> [6, 34, 39, 42] </ref>, take as input general graphs (with no restrictions whatsoever on connectivity, planarity, etc.), and construct orthogonal grid drawings. <p> Algorithm Column is an extension of the orthogonal drawing algorithm by Biedl and Kant [6] to graphs of arbitrary vertex degree. Algorithm Pair is an extension of the orthogonal drawing algorithm by Papakostas and Tollis <ref> [34, 35] </ref> to graphs of arbitrary vertex degree. <p> of a visibility representation [37, 41, 49]) step2TaTo89 fast orthogonalization [42] step4TaTo89 bend-stretching transformations, which remove bends by local lay out modifications [42] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto tidy compaction [3] BiedlKant orthogonal drawing algorithm [6] PapakostasTollis orthogonal drawing algorithm of <ref> [34, 35] </ref> manhattan the final output is an orthogonal grid drawing Table 1: Algorithmic components and intermediate representations used by algorithms Bend-Stretch, Column, Giotto, and Pair. <p> The implementation closely follows the description of the algorithm in [6]. PapakostasTollis This step is implemented using the description of the algorithm of <ref> [34] </ref> given in [35]. The algorithm as described in [35] requires each vertex of the input graph to have degree exactly 4. Consistent with this requirement, this step first introduces dummy edges so that each vertex has degree at least four. <p> TotalBends: The experimental results sharply fit the theoretical results. Namely, Giotto has the minimum number of bends; Bend-Stretch, Column and Pair have a number of bends that, also for the constants, is essentially the one predicted by the theoretical analysis <ref> [42, 6, 34, 35] </ref>. As pointed out in Observation 1, the performance of Bend-Stretch, Pair, and Column on TotalBends negatively affects their performance on Area.
Reference: [35] <author> A. Papakostas and I. G. Tollis. </author> <title> Improved algorithms and bounds for orthogonal drawings. </title> <type> Manuscript, </type> <year> 1995. </year>
Reference-contexts: Algorithm Column is an extension of the orthogonal drawing algorithm by Biedl and Kant [6] to graphs of arbitrary vertex degree. Algorithm Pair is an extension of the orthogonal drawing algorithm by Papakostas and Tollis <ref> [34, 35] </ref> to graphs of arbitrary vertex degree. <p> of a visibility representation [37, 41, 49]) step2TaTo89 fast orthogonalization [42] step4TaTo89 bend-stretching transformations, which remove bends by local lay out modifications [42] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto tidy compaction [3] BiedlKant orthogonal drawing algorithm [6] PapakostasTollis orthogonal drawing algorithm of <ref> [34, 35] </ref> manhattan the final output is an orthogonal grid drawing Table 1: Algorithmic components and intermediate representations used by algorithms Bend-Stretch, Column, Giotto, and Pair. <p> The implementation closely follows the description of the algorithm in [6]. PapakostasTollis This step is implemented using the description of the algorithm of [34] given in <ref> [35] </ref>. The algorithm as described in [35] requires each vertex of the input graph to have degree exactly 4. Consistent with this requirement, this step first introduces dummy edges so that each vertex has degree at least four. It then computes an st-numbering using a depth first search. <p> The implementation closely follows the description of the algorithm in [6]. PapakostasTollis This step is implemented using the description of the algorithm of [34] given in <ref> [35] </ref>. The algorithm as described in [35] requires each vertex of the input graph to have degree exactly 4. Consistent with this requirement, this step first introduces dummy edges so that each vertex has degree at least four. It then computes an st-numbering using a depth first search. <p> A drawing is then constructed using this classification, following the algorithm of <ref> [35] </ref>. In the drawing, each vertex is represented as a box whose height and width is equal to the number of rows and columns needed to make its incident edges "go in" or "come out" of it. Since the algorithm of [35] leaves some choice in placing the outgoing edges of <p> then constructed using this classification, following the algorithm of <ref> [35] </ref>. In the drawing, each vertex is represented as a box whose height and width is equal to the number of rows and columns needed to make its incident edges "go in" or "come out" of it. Since the algorithm of [35] leaves some choice in placing the outgoing edges of a vertex v, we have devised two heuristics to improve the drawing: * The columns of the incoming edges of v are used first for placing the outgoing edges. <p> New columns are therefore created only if, after reusing all columns of the incoming edges, there are still some outgoing edges left that need to be routed. This approach is a simple extension of the approach of <ref> [35] </ref>, and is useful for placing vertices with degree more than 4. * To reduce crossings, whenever possible, all the outgoing edges of v that require new 5 columns are assigned to consecutive (new) columns next to the column where v is placed. <p> TotalBends: The experimental results sharply fit the theoretical results. Namely, Giotto has the minimum number of bends; Bend-Stretch, Column and Pair have a number of bends that, also for the constants, is essentially the one predicted by the theoretical analysis <ref> [42, 6, 34, 35] </ref>. As pointed out in Observation 1, the performance of Bend-Stretch, Pair, and Column on TotalBends negatively affects their performance on Area.
Reference: [36] <author> R. </author> <title> Read. New methods for drawing a planar graph given the cyclic order of the edges at each vertex. </title> <journal> Congr. Numer., </journal> <volume> 56 </volume> <pages> 31-44, </pages> <year> 1987. </year>
Reference-contexts: However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. The performance of four planar straight-line drawing algorithms <ref> [8, 9, 12, 36, 46] </ref> is compared in [23]. These algorithms have been implemented and tested on 10,000 randomly generated maximal planar graphs. The standard deviations in angle size, edge length, and face area are used to compare the quality of the planar straight-line drawings produced.
Reference: [37] <author> P. Rosenstiehl and R. E. Tarjan. </author> <title> Rectilinear planar layouts and bipolar orientations of planar graphs. </title> <journal> Discrete Comput. Geom., </journal> <volume> 1(4) </volume> <pages> 343-353, </pages> <year> 1986. </year>
Reference-contexts: MakePlanar planarization [3, 33] connectedplanar crossings are now replaced by dummy vertices Make4planar expansion of vertices with degree greater than 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum degree 4 Step3giotto orthogonalization [39] step1TaTo89 construction of a visibility representation <ref> [37, 41, 49] </ref>) step2TaTo89 fast orthogonalization [42] step4TaTo89 bend-stretching transformations, which remove bends by local lay out modifications [42] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto tidy compaction [3] BiedlKant orthogonal drawing algorithm [6] PapakostasTollis orthogonal drawing algorithm of [34, 35] manhattan the final <p> source of both theoretical and practical open problems: * It would be interesting to perform further experiments on the practical performance of separator-based methods [16, 32, 47] that were originally developed for VLSI layout. * The behavior of Bend-Stretch could be improved by using, instead of the classical algorithms of <ref> [37, 41, 49] </ref>, the algorithm by Kant [30] for constructing compact visibility representations. * The performance of Giotto and Bend-Stretch is affected by the number of crossings introduced by the planarization phase.
Reference: [38] <author> K. Sugiyama, S. Tagawa, and M. </author> <title> Toda. Methods for visual understanding of hierarchical 21 systems. </title> <journal> IEEE Trans. Syst. Man Cybern., </journal> <volume> SMC-11(2):109-125, </volume> <year> 1981. </year>
Reference-contexts: Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [20] presents a comparative study of twelve graph drawings algorithms, including <ref> [8, 12, 17, 28, 38, 39, 48, 50] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planarization) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
Reference: [39] <author> R. Tamassia. </author> <title> On embedding a graph in the grid with the minimum number of bends. </title> <journal> SIAM J. Comput., </journal> <volume> 16(3) </volume> <pages> 421-444, </pages> <year> 1987. </year>
Reference-contexts: Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [20] presents a comparative study of twelve graph drawings algorithms, including <ref> [8, 12, 17, 28, 38, 39, 48, 50] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planarization) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline). <p> The four algorithms, denoted Bend-Stretch, Column, Giotto, and Pair, are derived from theoretical papers <ref> [6, 34, 39, 42] </ref>, take as input general graphs (with no restrictions whatsoever on connectivity, planarity, etc.), and construct orthogonal grid drawings. <p> a network-flow method that guarantees the minimum number of bends but has quadratic 2 y y y y @ @ @ H H H H H H y y y i S S y ffi ffi y i y y y y y (b) (d) (c) Orthogonalization. (d) Compaction. time-complexity <ref> [39] </ref>. Algorithm Bend-Stretch adopts the "bend-stretching" heuristic [42] that only guarantees a constant number of bends on each edge but runs in linear time. <p> biconnectivity testing and augmentation biconnected biconnected graph MakePlanar planarization [3, 33] connectedplanar crossings are now replaced by dummy vertices Make4planar expansion of vertices with degree greater than 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum degree 4 Step3giotto orthogonalization <ref> [39] </ref> step1TaTo89 construction of a visibility representation [37, 41, 49]) step2TaTo89 fast orthogonalization [42] step4TaTo89 bend-stretching transformations, which remove bends by local lay out modifications [42] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto tidy compaction [3] BiedlKant orthogonal drawing algorithm [6] PapakostasTollis orthogonal drawing <p> then v is replaced by two new vertices connected by a new edge; if deg (v) &gt; 6, then v is replaced by a cycle with just enough vertices to accommodate the incident edges of v. 4 Step3giotto The orthogonal representation is constructed using the constrained bend--minimization algorithm by Tamassia <ref> [39] </ref>. This algorithm computes a minimum cost flow on a network whose nodes represent the vertices and the faces of the graph, and whose edges represent the incidence relationships face-edge-vertex. The minimum cost flow is computed with the standard method of augmenting the flow along minimum-cost paths. <p> How much will it improve if we use a more sophisticated biconnectivity augmentation technique that preserves planarity (e.g., [31])? This issue is addressed in [25]. * One of the computational bottlenecks of the Giotto algorithm is the bend minimization step (Step3giotto), which has quadratic time complexity <ref> [39] </ref>. It would be interesting to improve on the time complexity of bend minimization. * It would be interesting to devise practical algorithms for orthogonal drawings in the 3 dimensional space.
Reference: [40] <author> R. Tamassia, G. Di Battista, and C. Batini. </author> <title> Automatic graph drawing and readability of diagrams. </title> <journal> IEEE Trans. Syst. Man Cybern., </journal> <volume> SMC-18(1):61-79, </volume> <year> 1988. </year>
Reference-contexts: The second phase, orthogonalization, computes an orthogonal shape for the drawing. The third phase, compaction, produces the final drawing. This approach allows homogeneous treatment of a wide range of diagrammatic representations, aesthetics and constraints (see, e.g., <ref> [29, 40, 45] </ref>) and has been successfully used in industrial tools. <p> The minimum cost flow is computed with the standard method of augmenting the flow along minimum-cost paths. Suitable con straints force a rectangular shape for the skeleton subgraphs (see Make4planar). Step4giotto This algorithmic component is the "tidy compaction" described in <ref> [3, 40] </ref> that computes an orthogonal grid drawing from an orthogonal representation by assigning integer lengths to the horizontal and vertical segments of the edges. This is done in two steps. First, the faces of the orthogonal representation are decomposed into rectangles.
Reference: [41] <author> R. Tamassia and I. G. Tollis. </author> <title> A unified approach to visibility representations of planar graphs. </title> <journal> Discrete Comput. Geom., </journal> <volume> 1(4) </volume> <pages> 321-341, </pages> <year> 1986. </year>
Reference-contexts: MakePlanar planarization [3, 33] connectedplanar crossings are now replaced by dummy vertices Make4planar expansion of vertices with degree greater than 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum degree 4 Step3giotto orthogonalization [39] step1TaTo89 construction of a visibility representation <ref> [37, 41, 49] </ref>) step2TaTo89 fast orthogonalization [42] step4TaTo89 bend-stretching transformations, which remove bends by local lay out modifications [42] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto tidy compaction [3] BiedlKant orthogonal drawing algorithm [6] PapakostasTollis orthogonal drawing algorithm of [34, 35] manhattan the final <p> source of both theoretical and practical open problems: * It would be interesting to perform further experiments on the practical performance of separator-based methods [16, 32, 47] that were originally developed for VLSI layout. * The behavior of Bend-Stretch could be improved by using, instead of the classical algorithms of <ref> [37, 41, 49] </ref>, the algorithm by Kant [30] for constructing compact visibility representations. * The performance of Giotto and Bend-Stretch is affected by the number of crossings introduced by the planarization phase.
Reference: [42] <author> R. Tamassia and I. G. Tollis. </author> <title> Planar grid embedding in linear time. </title> <journal> IEEE Trans. on Circuits and Systems, </journal> <volume> CAS-36(9):1230-1234, </volume> <year> 1989. </year>
Reference-contexts: The four algorithms, denoted Bend-Stretch, Column, Giotto, and Pair, are derived from theoretical papers <ref> [6, 34, 39, 42] </ref>, take as input general graphs (with no restrictions whatsoever on connectivity, planarity, etc.), and construct orthogonal grid drawings. <p> Algorithm Bend-Stretch adopts the "bend-stretching" heuristic <ref> [42] </ref> that only guarantees a constant number of bends on each edge but runs in linear time. <p> are now replaced by dummy vertices Make4planar expansion of vertices with degree greater than 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum degree 4 Step3giotto orthogonalization [39] step1TaTo89 construction of a visibility representation [37, 41, 49]) step2TaTo89 fast orthogonalization <ref> [42] </ref> step4TaTo89 bend-stretching transformations, which remove bends by local lay out modifications [42] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto tidy compaction [3] BiedlKant orthogonal drawing algorithm [6] PapakostasTollis orthogonal drawing algorithm of [34, 35] manhattan the final output is an orthogonal grid drawing <p> greater than 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum degree 4 Step3giotto orthogonalization [39] step1TaTo89 construction of a visibility representation [37, 41, 49]) step2TaTo89 fast orthogonalization <ref> [42] </ref> step4TaTo89 bend-stretching transformations, which remove bends by local lay out modifications [42] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto tidy compaction [3] BiedlKant orthogonal drawing algorithm [6] PapakostasTollis orthogonal drawing algorithm of [34, 35] manhattan the final output is an orthogonal grid drawing Table 1: Algorithmic components and intermediate representations used by algorithms Bend-Stretch, Column, <p> TotalBends: The experimental results sharply fit the theoretical results. Namely, Giotto has the minimum number of bends; Bend-Stretch, Column and Pair have a number of bends that, also for the constants, is essentially the one predicted by the theoretical analysis <ref> [42, 6, 34, 35] </ref>. As pointed out in Observation 1, the performance of Bend-Stretch, Pair, and Column on TotalBends negatively affects their performance on Area.
Reference: [43] <editor> R. Tamassia and I. G. Tollis, editors. </editor> <booktitle> Graph Drawing (Proc. GD '94), volume 894 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Because of the direct applications of graph drawing to advanced graphic user interfaces and visualization systems, and thanks to the many theoretical challenges posed by the interplay of graph theory and geometry, an extensive literature on the subject <ref> [13, 43] </ref> has grown in the last decade. Various graphic standards have been proposed for the representation of graphs in the plane. <p> Most papers in this area show sample outputs, and some also provide limited experimental results on small (with fewer than 100 graphs) test suites (see, e.g., [11, 17, 19, 24, 27, 29] and the experimental papers in <ref> [43] </ref>). However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. The performance of four planar straight-line drawing algorithms [8, 9, 12, 36, 46] is compared in [23].
Reference: [44] <author> I. G. Tollis. </author> <type> Personal communication, </type> <year> 1995. </year>
Reference-contexts: The st-numbering method implemented in Diagram Server is based on a depth-first search of the input graph. An alternative approach could be to use a breadth-first search. A very recent experimental study <ref> [44] </ref> shows that the choice of an st-numbering based on depth-first search can have a negative effect on the performance of Bend-Stretch, Pair, and Column with respect to several quality measures, including Area, Cross, ScreenRatio, and TotalEdgeLen.
Reference: [45] <author> H. Trickey. </author> <title> Drag: A graph drawing system. </title> <booktitle> In Proc. Internat. Conf. on Electronic Publishing, </booktitle> <pages> pages 171-182. </pages> <publisher> Cambridge University Press, </publisher> <year> 1988. </year>
Reference-contexts: The second phase, orthogonalization, computes an orthogonal shape for the drawing. The third phase, compaction, produces the final drawing. This approach allows homogeneous treatment of a wide range of diagrammatic representations, aesthetics and constraints (see, e.g., <ref> [29, 40, 45] </ref>) and has been successfully used in industrial tools.
Reference: [46] <author> W. T. Tutte. </author> <title> How to draw a graph. </title> <journal> Proceedings London Mathematical Society, </journal> <volume> 13(3) </volume> <pages> 743-768, </pages> <year> 1963. </year>
Reference-contexts: However, in order to evaluate the practical performance of a graph drawing algorithm in visualization applications, it is essential to perform extensive experimentations with input graphs derived from the application domain. The performance of four planar straight-line drawing algorithms <ref> [8, 9, 12, 36, 46] </ref> is compared in [23]. These algorithms have been implemented and tested on 10,000 randomly generated maximal planar graphs. The standard deviations in angle size, edge length, and face area are used to compare the quality of the planar straight-line drawings produced.
Reference: [47] <author> L. Valiant. </author> <title> Universality considerations in VLSI circuits. </title> <journal> IEEE Trans. Comput., </journal> <volume> C-30(2):135-140, </volume> <year> 1981. </year>
Reference-contexts: This result is somehow surprising since one would expect a better behavior for Pair and Column, which allow edge crossings even when the input graph is planar (the area of a drawing of a planar graph benefits of the possibility of introducing edge-crossings <ref> [32, 47] </ref>). We observe the following: Observation 1: While Giotto minimizes the number of bends, Bend-Stretch Pair and Column do not. <p> Finally, the experiments performed are an interesting source of both theoretical and practical open problems: * It would be interesting to perform further experiments on the practical performance of separator-based methods <ref> [16, 32, 47] </ref> that were originally developed for VLSI layout. * The behavior of Bend-Stretch could be improved by using, instead of the classical algorithms of [37, 41, 49], the algorithm by Kant [30] for constructing compact visibility representations. * The performance of Giotto and Bend-Stretch is affected by the number
Reference: [48] <author> J. Q. Walker II. </author> <title> A node-positioning algorithm for general trees. </title> <journal> Softw. - Pract. Exp., </journal> <volume> 20(7) </volume> <pages> 685-705, </pages> <year> 1990. </year>
Reference-contexts: Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [20] presents a comparative study of twelve graph drawings algorithms, including <ref> [8, 12, 17, 28, 38, 39, 48, 50] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planarization) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
Reference: [49] <author> S. K. Wismath. </author> <title> Characterizing bar line-of-sight graphs. </title> <booktitle> In Proc. 1st Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 147-152, </pages> <year> 1985. </year>
Reference-contexts: MakePlanar planarization [3, 33] connectedplanar crossings are now replaced by dummy vertices Make4planar expansion of vertices with degree greater than 4 into rectangular symbols fourplanar viewing the rectangular symbols as cycles of dummy vertices, the graph has now maximum degree 4 Step3giotto orthogonalization [39] step1TaTo89 construction of a visibility representation <ref> [37, 41, 49] </ref>) step2TaTo89 fast orthogonalization [42] step4TaTo89 bend-stretching transformations, which remove bends by local lay out modifications [42] orthogonal orthogonal representation, describing shape of the drawing in term of its angles Step4giotto tidy compaction [3] BiedlKant orthogonal drawing algorithm [6] PapakostasTollis orthogonal drawing algorithm of [34, 35] manhattan the final <p> source of both theoretical and practical open problems: * It would be interesting to perform further experiments on the practical performance of separator-based methods [16, 32, 47] that were originally developed for VLSI layout. * The behavior of Bend-Stretch could be improved by using, instead of the classical algorithms of <ref> [37, 41, 49] </ref>, the algorithm by Kant [30] for constructing compact visibility representations. * The performance of Giotto and Bend-Stretch is affected by the number of crossings introduced by the planarization phase.
Reference: [50] <author> D. Woods. </author> <title> Drawing Planar Graphs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1982. </year> <note> Technical Report STAN-CS-82-943. 22 </note>
Reference-contexts: Since the experiments are limited to randomly generated maximal planar graphs, this work gives only partial insight on the performance of the algorithms on general planar graphs. Himsolt [20] presents a comparative study of twelve graph drawings algorithms, including <ref> [8, 12, 17, 28, 38, 39, 48, 50] </ref>. The algorithms selected are based on various approaches (e.g., force-directed, layering, and planarization) and use a variety of graphic standards (e.g., orthogonal, straight-line, polyline).
References-found: 50

