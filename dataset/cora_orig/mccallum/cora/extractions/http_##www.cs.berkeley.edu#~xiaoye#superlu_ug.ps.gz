URL: http://www.cs.berkeley.edu/~xiaoye/superlu_ug.ps.gz
Refering-URL: http://www.cs.berkeley.edu/~xiaoye/superlu.html
Root-URL: http://www.cs.berkeley.edu
Title: SuperLU Users' Guide  
Author: James W. Demmel John R. Gilbert Xiaoye S. Li 
Note: Contents I Sequential SuperLU 3  
Date: November 15, 1997  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> E. Anderson, Z. Bai, C. Bischof, J. Demmel, J. Dongarra, J. Du Croz, A. Greenbaum, S. Ham-marling, A. McKenney, S. Ostrouchov, and D. Sorensen. </author> <title> LAPACK Users' Guide, Release 2.0. </title> <publisher> SIAM, </publisher> <address> Philadelphia, </address> <year> 1995. </year> <pages> 324 pages. </pages>
Reference-contexts: = 21.0; p = 16.0; e = 5.0; r = 18.0; l = 12.0; 1 This sample program is located in SuperLU/EXAMPLE/superlu.c. 5 a [6] = u; a [7] = p; a [8] = u; a [9] = e; a [10]= u; a [11]= r; asub [0] = 0; asub <ref> [1] </ref> = 1; asub [2] = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] <p> [0] = 0; asub <ref> [1] </ref> = 1; asub [2] = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] = 6; xa [3] = 8; xa [4] = 10; xa [5] = 12; /* Create matrix A in the format expected by SuperLU. */ dCreate_CompCol_Matrix (&A, m, n, nnz, a, asub, xa, NC, _D, GE); /* Create right-hand side matrix B. */ nrhs = 1; <p> 3, 3, 4 ]; colptr = [ 0, 3, 6, 8, 10, 12 ]; - * U = - Stype = NC; Dtype = _D; Mtype = TRU; nrow = 5; ncol = 5; *Store = - nnz = 11; nzval = [ 21.00, -13.26, 7.58, 21.00 ]; rowind = <ref> [ 0, 1, 2, 0 ] </ref>; colptr = [ 0, 0, 0, 1, 4, 4 ]; - * L = - Stype = SC; Dtype = _D; Mtype = TRLU; nrow = 5; ncol = 5; *Store = - nnz = 11; nsuper = 2; nzval = [ 19.00, 0.63, 0.63, <p> 3, 6, 8, 10, 12 ]; - * U = - Stype = NC; Dtype = _D; Mtype = TRU; nrow = 5; ncol = 5; *Store = - nnz = 11; nzval = [ 21.00, -13.26, 7.58, 21.00 ]; rowind = [ 0, 1, 2, 0 ]; colptr = <ref> [ 0, 0, 0, 1, 4, 4 ] </ref>; - * L = - Stype = SC; Dtype = _D; Mtype = TRLU; nrow = 5; ncol = 5; *Store = - nnz = 11; nsuper = 2; nzval = [ 19.00, 0.63, 0.63, 21.00, 0.57, 0.57, -13.26, 23.58, -0.24, 5.00, -0.77, <p> Dtype = _D; Mtype = TRLU; nrow = 5; ncol = 5; *Store = - nnz = 11; nsuper = 2; nzval = [ 19.00, 0.63, 0.63, 21.00, 0.57, 0.57, -13.26, 23.58, -0.24, 5.00, -0.77, 21.00, 34.20 ]; nzval_colptr = [ 0 3, 6, 9, 11, 13 ]; rowind = <ref> [ 0, 1, 4, 1, 2, 4, 3, 4 ] </ref>; rowind_colptr = [ 0, 3, 6, 6, 8, 8 ]; col_to_sup = [ 0, 1, 1, 2, 2 ]; - SuperMatrix data structure. <p> = [ 19.00, 0.63, 0.63, 21.00, 0.57, 0.57, -13.26, 23.58, -0.24, 5.00, -0.77, 21.00, 34.20 ]; nzval_colptr = [ 0 3, 6, 9, 11, 13 ]; rowind = [ 0, 1, 4, 1, 2, 4, 3, 4 ]; rowind_colptr = [ 0, 3, 6, 6, 8, 8 ]; col_to_sup = <ref> [ 0, 1, 1, 2, 2 ] </ref>; - SuperMatrix data structure. Zero-based indexing is used. 10 option), and P c is a column permutation chosen either by the user or SuperLU, usually to make the L and U factors as sparse as possible. <p> location in nzval [] and rowind [] which starts column j */ int *colend; /* colend [j] points to one past the location in nzval [] and rowind [] which ends column j */ - NCPformat; 3.2 Partial pivoting with threshold We have included a threshold pivoting parameter u 2 <ref> [0; 1] </ref> to control numerical stability. <p> values of u result in the following two strategies: * u = 0:0: either use user-specified pivot order if available, or else use diagonal pivot; * u = 1:0: classical partial pivoting. 4 User-callable routines The naming conventions, calling sequences and functionality of these routines mimic the corresponding LAPACK software <ref> [1] </ref>. In the routine names, such as xGSTRF, we use the two letters GS to denote general sparse matrices. The leading letter x stands for S, D, C, or Z, specifying the data type. <p> Each test matrix is subject to the tests listed in Table 2. Let r be the residual r = b Ax, and let m i be the number of nonzeros in row i of A. Then the componentwise backward error BERR and forward error FERR <ref> [1] </ref> are calculated by: BERR = max i (jAj jxj + jbj) i 4 Matrix g10 is first generated with the structure of the 10-by-10 five-point grid, and random numerical values. <p> FERR is an estimated bound on the error kx fl xk 1 =kxk 1 , where x fl is the true solution. For further details on error analysis and error bounds estimation, see <ref> [1, Chapter 4] </ref> and [2]. 7.3 Performance-tuning parameters SuperLU chooses such machine-dependent parameters as block size by calling an inquiry function sp ienv (), which may be set to return different values on different machines. <p> In the future, we will provide complete Fortran interfaces to the user-callable routines in the SuperLU library. 20 main () - /* Declare variables */ SuperMatrix A; /* original matrix */ SuperMatrix AC; /* A postmultiplied by a permutation matrix Q */ char refact <ref> [1] </ref>; ...... /* declarations of other variables */ /* Initialization */ - StatInit (panel_size, relax); ...... /* First-time factorization */ *refact = 'N'; /* Obtain and apply column permutation */ get_perm_c (1, &A, perm_c); sp_preorder (refact, &A, perm_c, etree, &AC); /* Factorization */ dgstrf (refact, &AC, 1.0, 0.0, relax, panel_size, etree,
Reference: [2] <author> M. Arioli, J. W. Demmel, and I. S. Duff. </author> <title> Solving sparse linear systems with sparse backward error. </title> <journal> SIAM J. Matrix Anal. Appl., </journal> <volume> 10(2) </volume> <pages> 165-190, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: The package uses LU decomposition with partial pivoting, and forward/back substitutions. The columns of A may be preordered before factorization (either by the user or by SuperLU); this pre-ordering for sparsity is completely separate from the factorization. To improve backward stability, we provide working precision iterative refinement subroutines <ref> [2] </ref>. Routines are also available to equilibrate the system, estimate the condition number, calculate the relative backward error, and estimate error bounds for the refined solutions. We also include a Matlab MEX-file interface, so that our factor and solve routines can be called as alternatives to those built into Matlab. <p> 16.0; e = 5.0; r = 18.0; l = 12.0; 1 This sample program is located in SuperLU/EXAMPLE/superlu.c. 5 a [6] = u; a [7] = p; a [8] = u; a [9] = e; a [10]= u; a [11]= r; asub [0] = 0; asub [1] = 1; asub <ref> [2] </ref> = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] = 6; xa [3] <p> [1] = 1; asub <ref> [2] </ref> = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] = 6; xa [3] = 8; xa [4] = 10; xa [5] = 12; /* Create matrix A in the format expected by SuperLU. */ dCreate_CompCol_Matrix (&A, m, n, nnz, a, asub, xa, NC, _D, GE); /* Create right-hand side matrix B. */ nrhs = 1; if ( !(rhs = <p> 3, 3, 4 ]; colptr = [ 0, 3, 6, 8, 10, 12 ]; - * U = - Stype = NC; Dtype = _D; Mtype = TRU; nrow = 5; ncol = 5; *Store = - nnz = 11; nzval = [ 21.00, -13.26, 7.58, 21.00 ]; rowind = <ref> [ 0, 1, 2, 0 ] </ref>; colptr = [ 0, 0, 0, 1, 4, 4 ]; - * L = - Stype = SC; Dtype = _D; Mtype = TRLU; nrow = 5; ncol = 5; *Store = - nnz = 11; nsuper = 2; nzval = [ 19.00, 0.63, 0.63, <p> Dtype = _D; Mtype = TRLU; nrow = 5; ncol = 5; *Store = - nnz = 11; nsuper = 2; nzval = [ 19.00, 0.63, 0.63, 21.00, 0.57, 0.57, -13.26, 23.58, -0.24, 5.00, -0.77, 21.00, 34.20 ]; nzval_colptr = [ 0 3, 6, 9, 11, 13 ]; rowind = <ref> [ 0, 1, 4, 1, 2, 4, 3, 4 ] </ref>; rowind_colptr = [ 0, 3, 6, 6, 8, 8 ]; col_to_sup = [ 0, 1, 1, 2, 2 ]; - SuperMatrix data structure. <p> = [ 19.00, 0.63, 0.63, 21.00, 0.57, 0.57, -13.26, 23.58, -0.24, 5.00, -0.77, 21.00, 34.20 ]; nzval_colptr = [ 0 3, 6, 9, 11, 13 ]; rowind = [ 0, 1, 4, 1, 2, 4, 3, 4 ]; rowind_colptr = [ 0, 3, 6, 6, 8, 8 ]; col_to_sup = <ref> [ 0, 1, 1, 2, 2 ] </ref>; - SuperMatrix data structure. Zero-based indexing is used. 10 option), and P c is a column permutation chosen either by the user or SuperLU, usually to make the L and U factors as sparse as possible. <p> FERR is an estimated bound on the error kx fl xk 1 =kxk 1 , where x fl is the true solution. For further details on error analysis and error bounds estimation, see [1, Chapter 4] and <ref> [2] </ref>. 7.3 Performance-tuning parameters SuperLU chooses such machine-dependent parameters as block size by calling an inquiry function sp ienv (), which may be set to return different values on different machines.
Reference: [3] <author> Timothy A. Davis, John R. Gilbert, Esmond Ng, and Barry Peyton. </author> <title> Approximate minimum degree ordering for unsymmetric matrices. </title> <note> Talk presented at XIII Householder Symposium on Numerical Algebra, June 1996. Journal version in preparation. </note>
Reference-contexts: r = 18.0; l = 12.0; 1 This sample program is located in SuperLU/EXAMPLE/superlu.c. 5 a [6] = u; a [7] = p; a [8] = u; a [9] = e; a [10]= u; a [11]= r; asub [0] = 0; asub [1] = 1; asub [2] = 4; asub <ref> [3] </ref> = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] = 6; xa [3] = 8; xa [4] <p> [2] = 4; asub <ref> [3] </ref> = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] = 6; xa [3] = 8; xa [4] = 10; xa [5] = 12; /* Create matrix A in the format expected by SuperLU. */ dCreate_CompCol_Matrix (&A, m, n, nnz, a, asub, xa, NC, _D, GE); /* Create right-hand side matrix B. */ nrhs = 1; if ( !(rhs = doubleMalloc (m * nrhs)) <p> _D; Mtype = GE; nrow = 5; ncol = 5; *Store = - nnz = 12; nzval = [ 19.00, 12.00, 12.00, 21.00, 12.00, 12.00, 21.00, 16.00, 21.00, 5.00, 21.00, 18.00 ]; rowind = [ 0, 1, 4, 1, 2, 4, 0, 2, 0, 3, 3, 4 ]; colptr = <ref> [ 0, 3, 6, 8, 10, 12 ] </ref>; - * U = - Stype = NC; Dtype = _D; Mtype = TRU; nrow = 5; ncol = 5; *Store = - nnz = 11; nzval = [ 21.00, -13.26, 7.58, 21.00 ]; rowind = [ 0, 1, 2, 0 ]; colptr <p> Dtype = _D; Mtype = TRLU; nrow = 5; ncol = 5; *Store = - nnz = 11; nsuper = 2; nzval = [ 19.00, 0.63, 0.63, 21.00, 0.57, 0.57, -13.26, 23.58, -0.24, 5.00, -0.77, 21.00, 34.20 ]; nzval_colptr = [ 0 3, 6, 9, 11, 13 ]; rowind = <ref> [ 0, 1, 4, 1, 2, 4, 3, 4 ] </ref>; rowind_colptr = [ 0, 3, 6, 6, 8, 8 ]; col_to_sup = [ 0, 1, 1, 2, 2 ]; - SuperMatrix data structure. <p> *Store = - nnz = 11; nsuper = 2; nzval = [ 19.00, 0.63, 0.63, 21.00, 0.57, 0.57, -13.26, 23.58, -0.24, 5.00, -0.77, 21.00, 34.20 ]; nzval_colptr = [ 0 3, 6, 9, 11, 13 ]; rowind = [ 0, 1, 4, 1, 2, 4, 3, 4 ]; rowind_colptr = <ref> [ 0, 3, 6, 6, 8, 8 ] </ref>; col_to_sup = [ 0, 1, 1, 2, 2 ]; - SuperMatrix data structure. <p> Both driver routines SGSSV and SGSSVX take perm c [] as an input argument. In the future, we will augment get perm c functionality with more ordering algorithms, such as approximate minimum degree ordering on the column intersection graph of A <ref> [3] </ref>. After permutation P c is applied to A, we use NCP format to represent the permuted matrix AP T c , in which the consecutive columns of nonzeros may not be stored contiguously in memory.
Reference: [4] <author> James W. Demmel, Stanley C. Eisenstat, John R. Gilbert, Xiaoye S. Li, and Joseph W.H. Liu. </author> <title> A supernodal approach to sparse partial pivoting. </title> <type> Technical Report UCB//CSD-95-883, </type> <institution> Computer Science Division, U.C. Berkeley, </institution> <month> July </month> <year> 1995. </year> <note> (Xerox PARC report CSL-95-03, LAPACK Working Note #103). To appear in SIAM J. Matrix Analysis and Applications. </note>
Reference-contexts: The resulting algorithm is highly efficient on modern architectures. The performance gains are particularly evident for large problems. There are "tuning parameters" to optimize the peak performance as a function of cache size. For a detailed description of the algorithm, see reference <ref> [4] </ref>. SuperLU is implemented in ANSI C, and must be compiled with a standard ANSI C compiler. It includes versions for both real and complex matrices, in both single and double precision. <p> = 12.0; 1 This sample program is located in SuperLU/EXAMPLE/superlu.c. 5 a [6] = u; a [7] = p; a [8] = u; a [9] = e; a [10]= u; a [11]= r; asub [0] = 0; asub [1] = 1; asub [2] = 4; asub [3] = 1; asub <ref> [4] </ref> = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] = 6; xa [3] = 8; xa [4] = 10; xa [5] <p> [3] = 1; asub <ref> [4] </ref> = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] = 6; xa [3] = 8; xa [4] = 10; xa [5] = 12; /* Create matrix A in the format expected by SuperLU. */ dCreate_CompCol_Matrix (&A, m, n, nnz, a, asub, xa, NC, _D, GE); /* Create right-hand side matrix B. */ nrhs = 1; if ( !(rhs = doubleMalloc (m * nrhs)) ) ABORT ("Malloc fails <p> However, it requires storage for a separate copy of matrix A. * L is a supernodal matrix with the storage type SC. Due to the supernodal structure, L is in fact stored as a sparse block lower triangular matrix <ref> [4] </ref>. typedef struct - int nnz; /* number of nonzeros in the matrix */ int nsuper; /* index of the last supernode */ void *nzval; /* array of nonzero values packed by column */ int *nzval_colptr; /* nzval_colptr [j] stores the location in nzval [] which starts column j */ int <p> 3, 6, 8, 10, 12 ]; - * U = - Stype = NC; Dtype = _D; Mtype = TRU; nrow = 5; ncol = 5; *Store = - nnz = 11; nzval = [ 21.00, -13.26, 7.58, 21.00 ]; rowind = [ 0, 1, 2, 0 ]; colptr = <ref> [ 0, 0, 0, 1, 4, 4 ] </ref>; - * L = - Stype = SC; Dtype = _D; Mtype = TRLU; nrow = 5; ncol = 5; *Store = - nnz = 11; nsuper = 2; nzval = [ 19.00, 0.63, 0.63, 21.00, 0.57, 0.57, -13.26, 23.58, -0.24, 5.00, -0.77, <p> Dtype = _D; Mtype = TRLU; nrow = 5; ncol = 5; *Store = - nnz = 11; nsuper = 2; nzval = [ 19.00, 0.63, 0.63, 21.00, 0.57, 0.57, -13.26, 23.58, -0.24, 5.00, -0.77, 21.00, 34.20 ]; nzval_colptr = [ 0 3, 6, 9, 11, 13 ]; rowind = <ref> [ 0, 1, 4, 1, 2, 4, 3, 4 ] </ref>; rowind_colptr = [ 0, 3, 6, 6, 8, 8 ]; col_to_sup = [ 0, 1, 1, 2, 2 ]; - SuperMatrix data structure. <p> The declaration of this function is int sp ienv (int ispec); Ispec specifies the parameter to be returned, (See reference <ref> [4] </ref> for their definitions.) ispec = 1: the panel size (w) = 2: the relaxation parameter to control supernode amalgamation (relax) = 3: the maximum allowable size for a supernode (maxsup) = 4: the minimum row dimension for 2-D blocking to be used (rowblk) = 5: the minimum column dimension for <p> In our technical paper <ref> [4] </ref>, we described a detailed methodology for setting these parameters for high performance. The relax parameter is usually set between 4 and 8. The other parameter values which give good performance on several machines are listed in Table 3.
Reference: [5] <author> James W. Demmel, John R. Gilbert, and Xiaoye S. Li. </author> <title> An asynchronous parallel supernodal algorithm for sparse gaussian elimination. </title> <type> Technical Report UCB//CSD-97-943, </type> <institution> Computer Science Division, U.C. Berkeley, </institution> <note> Feburary 1997. LAPACK Working Note #124, Submitted to SIAM J. Matrix Anal. Appl. </note>
Reference-contexts: sample program is located in SuperLU/EXAMPLE/superlu.c. 5 a [6] = u; a [7] = p; a [8] = u; a [9] = e; a [10]= u; a [11]= r; asub [0] = 0; asub [1] = 1; asub [2] = 4; asub [3] = 1; asub [4] = 2; asub <ref> [5] </ref> = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] = 6; xa [3] = 8; xa [4] = 10; xa [5] = 12; /* Create <p> [4] = 2; asub <ref> [5] </ref> = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] = 6; xa [3] = 8; xa [4] = 10; xa [5] = 12; /* Create matrix A in the format expected by SuperLU. */ dCreate_CompCol_Matrix (&A, m, n, nnz, a, asub, xa, NC, _D, GE); /* Create right-hand side matrix B. */ nrhs = 1; if ( !(rhs = doubleMalloc (m * nrhs)) ) ABORT ("Malloc fails for rhs []."); for <p> All these changes are summarized in Table 4 and their impacts on performance are studied thoroughly in <ref> [5, 11] </ref>. In this part of the Users' Guide, we describe only the changes that the user should be aware of. Other than these differences, most of the material in Part I is still applicable. <p> The need for this special treatment and how we implement it are fully explained and studied in <ref> [5, 11] </ref>. Here, we only sketch the main idea. Recall that the parallel algorithm assigns one panel of columns to one process. Two consecutive panels may be assigned to two different processes, even though they may belong to the same supernode discovered later. <p> To handle this situation, we implemented an algorithm that still uses the supernodes partition in H, but dynamically searches the supernodal graph of L to obtain a much tighter bound for the storage. Table 6 in <ref> [5] </ref> demonstrates the storage efficiency achieved by both static and dynamic approach. In summary, our program tries to use the static prediction first for the L supernodes. In this case, we ignore the integer value given in the function sp ienv (6), and simply use the nonzero count of H.
Reference: [6] <author> I.S Duff, R.G Grimes, and J.G Lewis. </author> <title> Users' guide for the harwell-boeing sparse matrix collection (release 1). </title> <type> Technical Report RAL-92-086, </type> <institution> Rutherford Appleton Laboratory, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: This storage format is called compressed column format, also known as Harwell-Boeing format <ref> [6] </ref>. Next, the two utility routines dCreate CompCol Matrix and dCreate Dense Matrix are called to set up matrices A and B, respectively, in the data structures internally used by SuperLU. The routine get perm c is called to generate a column permutation vector, stored in perm c []. <p> intMalloc (nnz)) ) ABORT ("Malloc fails for asub []."); if ( !(xa = intMalloc (n+1)) ) ABORT ("Malloc fails for xa []."); s = 19.0; u = 21.0; p = 16.0; e = 5.0; r = 18.0; l = 12.0; 1 This sample program is located in SuperLU/EXAMPLE/superlu.c. 5 a <ref> [6] </ref> = u; a [7] = p; a [8] = u; a [9] = e; a [10]= u; a [11]= r; asub [0] = 0; asub [1] = 1; asub [2] = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] <p> in SuperLU/EXAMPLE/superlu.c. 5 a <ref> [6] </ref> = u; a [7] = p; a [8] = u; a [9] = e; a [10]= u; a [11]= r; asub [0] = 0; asub [1] = 1; asub [2] = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] = 6; xa [3] = 8; xa [4] = 10; xa [5] = 12; /* Create matrix A in the <p> Following C's convention, all array indices and locations below are 0-based. * A may have storage type NC or NR. The NC format is the same as the Harwell-Boeing sparse matrix format <ref> [6] </ref>, that is, the compressed column storage. typedef struct - int nnz; /* number of nonzeros in the matrix */ void *nzval; /* array of nonzero values packed by column */ int *rowind; /* array of row indices of the nonzeros */ int *colptr; /* colptr [j] stores the location in <p> _D; Mtype = GE; nrow = 5; ncol = 5; *Store = - nnz = 12; nzval = [ 19.00, 12.00, 12.00, 21.00, 12.00, 12.00, 21.00, 16.00, 21.00, 5.00, 21.00, 18.00 ]; rowind = [ 0, 1, 4, 1, 2, 4, 0, 2, 0, 3, 3, 4 ]; colptr = <ref> [ 0, 3, 6, 8, 10, 12 ] </ref>; - * U = - Stype = NC; Dtype = _D; Mtype = TRU; nrow = 5; ncol = 5; *Store = - nnz = 11; nzval = [ 21.00, -13.26, 7.58, 21.00 ]; rowind = [ 0, 1, 2, 0 ]; colptr <p> 4 ]; - * L = - Stype = SC; Dtype = _D; Mtype = TRLU; nrow = 5; ncol = 5; *Store = - nnz = 11; nsuper = 2; nzval = [ 19.00, 0.63, 0.63, 21.00, 0.57, 0.57, -13.26, 23.58, -0.24, 5.00, -0.77, 21.00, 34.20 ]; nzval_colptr = <ref> [ 0 3, 6, 9, 11, 13 ] </ref>; rowind = [ 0, 1, 4, 1, 2, 4, 3, 4 ]; rowind_colptr = [ 0, 3, 6, 6, 8, 8 ]; col_to_sup = [ 0, 1, 1, 2, 2 ]; - SuperMatrix data structure. <p> *Store = - nnz = 11; nsuper = 2; nzval = [ 19.00, 0.63, 0.63, 21.00, 0.57, 0.57, -13.26, 23.58, -0.24, 5.00, -0.77, 21.00, 34.20 ]; nzval_colptr = [ 0 3, 6, 9, 11, 13 ]; rowind = [ 0, 1, 4, 1, 2, 4, 3, 4 ]; rowind_colptr = <ref> [ 0, 3, 6, 6, 8, 8 ] </ref>; col_to_sup = [ 0, 1, 1, 2, 2 ]; - SuperMatrix data structure.
Reference: [7] <author> Alan George, Joseph Liu, and Esmond Ng. </author> <title> A data structure for sparse QR and LU factorizations. </title> <journal> SIAM J. Sci. Stat. Comput., </journal> <volume> 9 </volume> <pages> 100-121, </pages> <year> 1988. </year>
Reference-contexts: ("Malloc fails for asub []."); if ( !(xa = intMalloc (n+1)) ) ABORT ("Malloc fails for xa []."); s = 19.0; u = 21.0; p = 16.0; e = 5.0; r = 18.0; l = 12.0; 1 This sample program is located in SuperLU/EXAMPLE/superlu.c. 5 a [6] = u; a <ref> [7] </ref> = p; a [8] = u; a [9] = e; a [10]= u; a [11]= r; asub [0] = 0; asub [1] = 1; asub [2] = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] <p> [6] = u; a <ref> [7] </ref> = p; a [8] = u; a [9] = e; a [10]= u; a [11]= r; asub [0] = 0; asub [1] = 1; asub [2] = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] = 6; xa [3] = 8; xa [4] = 10; xa [5] = 12; /* Create matrix A in the format expected by SuperLU. <p> To overcome this problem, we exploited the observation that the nonzero structure for L is contained in that of the Householder matrix H from the Householder sparse QR transformation <ref> [7, 8] </ref>. Furthermore, it can be shown that a fundamental supernode of L is always contained in a fundamental supernode of H. This containment property is true for for any row permutation P r in P r A = LU .
Reference: [8] <author> Alan George and Esmond Ng. </author> <title> Symbolic factorization for sparse Gaussian elimination with partial pivoting. </title> <journal> SIAM J. Sci. Stat. Comput., </journal> <volume> 8(6) </volume> <pages> 877-898, </pages> <year> 1987. </year>
Reference-contexts: []."); if ( !(xa = intMalloc (n+1)) ) ABORT ("Malloc fails for xa []."); s = 19.0; u = 21.0; p = 16.0; e = 5.0; r = 18.0; l = 12.0; 1 This sample program is located in SuperLU/EXAMPLE/superlu.c. 5 a [6] = u; a [7] = p; a <ref> [8] </ref> = u; a [9] = e; a [10]= u; a [11]= r; asub [0] = 0; asub [1] = 1; asub [2] = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] <p> [7] = p; a <ref> [8] </ref> = u; a [9] = e; a [10]= u; a [11]= r; asub [0] = 0; asub [1] = 1; asub [2] = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] = 6; xa [3] = 8; xa [4] = 10; xa [5] = 12; /* Create matrix A in the format expected by SuperLU. */ dCreate_CompCol_Matrix (&A, m, <p> _D; Mtype = GE; nrow = 5; ncol = 5; *Store = - nnz = 12; nzval = [ 19.00, 12.00, 12.00, 21.00, 12.00, 12.00, 21.00, 16.00, 21.00, 5.00, 21.00, 18.00 ]; rowind = [ 0, 1, 4, 1, 2, 4, 0, 2, 0, 3, 3, 4 ]; colptr = <ref> [ 0, 3, 6, 8, 10, 12 ] </ref>; - * U = - Stype = NC; Dtype = _D; Mtype = TRU; nrow = 5; ncol = 5; *Store = - nnz = 11; nzval = [ 21.00, -13.26, 7.58, 21.00 ]; rowind = [ 0, 1, 2, 0 ]; colptr <p> *Store = - nnz = 11; nsuper = 2; nzval = [ 19.00, 0.63, 0.63, 21.00, 0.57, 0.57, -13.26, 23.58, -0.24, 5.00, -0.77, 21.00, 34.20 ]; nzval_colptr = [ 0 3, 6, 9, 11, 13 ]; rowind = [ 0, 1, 4, 1, 2, 4, 3, 4 ]; rowind_colptr = <ref> [ 0, 3, 6, 6, 8, 8 ] </ref>; col_to_sup = [ 0, 1, 1, 2, 2 ]; - SuperMatrix data structure. <p> To overcome this problem, we exploited the observation that the nonzero structure for L is contained in that of the Householder matrix H from the Householder sparse QR transformation <ref> [7, 8] </ref>. Furthermore, it can be shown that a fundamental supernode of L is always contained in a fundamental supernode of H. This containment property is true for for any row permutation P r in P r A = LU .
Reference: [9] <author> John R. Gilbert, Xiaoye S. Li, Esmond G. Ng, and Barry W. Peyton. </author> <title> Computing row and column counts for sparse QR factorization. </title> <note> In preparation. (Talk presented at SIAM Symposium on Applied Linear Algebra, </note> <month> June </month> <year> 1994). </year>
Reference-contexts: = intMalloc (n+1)) ) ABORT ("Malloc fails for xa []."); s = 19.0; u = 21.0; p = 16.0; e = 5.0; r = 18.0; l = 12.0; 1 This sample program is located in SuperLU/EXAMPLE/superlu.c. 5 a [6] = u; a [7] = p; a [8] = u; a <ref> [9] </ref> = e; a [10]= u; a [11]= r; asub [0] = 0; asub [1] = 1; asub [2] = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= <p> [8] = u; a <ref> [9] </ref> = e; a [10]= u; a [11]= r; asub [0] = 0; asub [1] = 1; asub [2] = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] = 6; xa [3] = 8; xa [4] = 10; xa [5] = 12; /* Create matrix A in the format expected by SuperLU. */ dCreate_CompCol_Matrix (&A, m, n, nnz, a, asub, <p> 4 ]; - * L = - Stype = SC; Dtype = _D; Mtype = TRLU; nrow = 5; ncol = 5; *Store = - nnz = 11; nsuper = 2; nzval = [ 19.00, 0.63, 0.63, 21.00, 0.57, 0.57, -13.26, 23.58, -0.24, 5.00, -0.77, 21.00, 34.20 ]; nzval_colptr = <ref> [ 0 3, 6, 9, 11, 13 ] </ref>; rowind = [ 0, 1, 4, 1, 2, 4, 3, 4 ]; rowind_colptr = [ 0, 3, 6, 6, 8, 8 ]; col_to_sup = [ 0, 1, 1, 2, 2 ]; - SuperMatrix data structure. <p> Therefore, we can pre-allocate storage for the L supernodes based on the size of H supernodes. Fortunately, there exists a fast algorithm (almost linear in the number of nonzeros of A) to compute the size of H and the supernodes partition in H <ref> [9] </ref>. In practice, the above static prediction is fairly tight for most problems. However, for some others, the number of nonzeros in H greatly exceeds the number of nonzeros in L.
Reference: [10] <author> N. J. Higham. </author> <title> Algorithm 674: FORTRAN codes for estimating the one-norm of a real or complex matrix, with applications to condition estimation. </title> <journal> ACM Trans. Math. Soft., </journal> <volume> 14 </volume> <pages> 381-396, </pages> <year> 1988. </year>
Reference-contexts: ABORT ("Malloc fails for xa []."); s = 19.0; u = 21.0; p = 16.0; e = 5.0; r = 18.0; l = 12.0; 1 This sample program is located in SuperLU/EXAMPLE/superlu.c. 5 a [6] = u; a [7] = p; a [8] = u; a [9] = e; a <ref> [10] </ref>= u; a [11]= r; asub [0] = 0; asub [1] = 1; asub [2] = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; <p> [9] = e; a <ref> [10] </ref>= u; a [11]= r; asub [0] = 0; asub [1] = 1; asub [2] = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] = 6; xa [3] = 8; xa [4] = 10; xa [5] = 12; /* Create matrix A in the format expected by SuperLU. */ dCreate_CompCol_Matrix (&A, m, n, nnz, a, asub, xa, NC, _D, GE); <p> _D; Mtype = GE; nrow = 5; ncol = 5; *Store = - nnz = 12; nzval = [ 19.00, 12.00, 12.00, 21.00, 12.00, 12.00, 21.00, 16.00, 21.00, 5.00, 21.00, 18.00 ]; rowind = [ 0, 1, 4, 1, 2, 4, 0, 2, 0, 3, 3, 4 ]; colptr = <ref> [ 0, 3, 6, 8, 10, 12 ] </ref>; - * U = - Stype = NC; Dtype = _D; Mtype = TRU; nrow = 5; ncol = 5; *Store = - nnz = 11; nzval = [ 21.00, -13.26, 7.58, 21.00 ]; rowind = [ 0, 1, 2, 0 ]; colptr <p> Given the matrix A and its factors L and U , this estimates the condition number in the one-norm or infinity-norm. The algorithm is due to Hager and Higham <ref> [10] </ref>, and is the same as CONDEST in sparse Matlab. * xGSEQU/xLAQGS: Equilibrate. xGSEQU first computes the row and column scalings D r and D c which would make each row and each column of the scaled matrix D r AD c have equal norm. xLAQGS then applies them to the <p> Given the matrix A and its factors L and U , this estimates the condition number in the one-norm or infinity-norm. The algorithm is due to Hager and Higham <ref> [10] </ref>, and is the same as CONDEST in sparse Matlab. * DGSEQU/DLAQGS: Equilibrate. DGSEQU first computes the row and column scalings D r and D c which would make each row and each column of the scaled matrix D r AD c have equal norm.
Reference: [11] <author> Xiaoye S. Li. </author> <title> Sparse Gaussian elimination on high performance computers. </title> <type> Technical Report UCB//CSD-96-919, </type> <institution> Computer Science Division, U.C. Berkeley, </institution> <month> September </month> <year> 1996. </year> <type> Ph.D dissertation. 31 </type>
Reference-contexts: for xa []."); s = 19.0; u = 21.0; p = 16.0; e = 5.0; r = 18.0; l = 12.0; 1 This sample program is located in SuperLU/EXAMPLE/superlu.c. 5 a [6] = u; a [7] = p; a [8] = u; a [9] = e; a [10]= u; a <ref> [11] </ref>= r; asub [0] = 0; asub [1] = 1; asub [2] = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = <p> a [10]= u; a <ref> [11] </ref>= r; asub [0] = 0; asub [1] = 1; asub [2] = 4; asub [3] = 1; asub [4] = 2; asub [5] = 4; asub [6] = 0; asub [7] = 2; asub [8] = 0; asub [9] = 3; asub [10]= 3; asub [11]= 4; xa [0] = 0; xa [1] = 3; xa [2] = 6; xa [3] = 8; xa [4] = 10; xa [5] = 12; /* Create matrix A in the format expected by SuperLU. */ dCreate_CompCol_Matrix (&A, m, n, nnz, a, asub, xa, NC, _D, GE); /* Create right-hand <p> 4 ]; - * L = - Stype = SC; Dtype = _D; Mtype = TRLU; nrow = 5; ncol = 5; *Store = - nnz = 11; nsuper = 2; nzval = [ 19.00, 0.63, 0.63, 21.00, 0.57, 0.57, -13.26, 23.58, -0.24, 5.00, -0.77, 21.00, 34.20 ]; nzval_colptr = <ref> [ 0 3, 6, 9, 11, 13 ] </ref>; rowind = [ 0, 1, 4, 1, 2, 4, 3, 4 ]; rowind_colptr = [ 0, 3, 6, 6, 8, 8 ]; col_to_sup = [ 0, 1, 1, 2, 2 ]; - SuperMatrix data structure. <p> All these changes are summarized in Table 4 and their impacts on performance are studied thoroughly in <ref> [5, 11] </ref>. In this part of the Users' Guide, we describe only the changes that the user should be aware of. Other than these differences, most of the material in Part I is still applicable. <p> The need for this special treatment and how we implement it are fully explained and studied in <ref> [5, 11] </ref>. Here, we only sketch the main idea. Recall that the parallel algorithm assigns one panel of columns to one process. Two consecutive panels may be assigned to two different processes, even though they may belong to the same supernode discovered later.
Reference: [12] <author> Joseph W.H. Liu. </author> <title> Modification of the minimum degree algorithm by multiple elimination. </title> <journal> ACM Trans. Math. Software, </journal> <volume> 11 </volume> <pages> 141-153, </pages> <year> 1985. </year>
Reference-contexts: _D; Mtype = GE; nrow = 5; ncol = 5; *Store = - nnz = 12; nzval = [ 19.00, 12.00, 12.00, 21.00, 12.00, 12.00, 21.00, 16.00, 21.00, 5.00, 21.00, 18.00 ]; rowind = [ 0, 1, 4, 1, 2, 4, 0, 2, 0, 3, 3, 4 ]; colptr = <ref> [ 0, 3, 6, 8, 10, 12 ] </ref>; - * U = - Stype = NC; Dtype = _D; Mtype = TRU; nrow = 5; ncol = 5; *Store = - nnz = 11; nzval = [ 21.00, -13.26, 7.58, 21.00 ]; rowind = [ 0, 1, 2, 0 ]; colptr <p> Liu, which implements a variant of the minimum degree ordering algorithm <ref> [12] </ref>. Alternatively, the users can provide their own column permutation vector. For example, it may be an ordering suitable for the underlying physical problem. Both driver routines SGSSV and SGSSVX take perm c [] as an input argument.
Reference: [13] <author> POSIX System Application Program Interface: </author> <title> Threads extension [C Language], </title> <type> POSIX 1003.1c draft 4. </type> <institution> IEEE Standards Department. </institution> <month> 32 </month>
Reference-contexts: 4 ]; - * L = - Stype = SC; Dtype = _D; Mtype = TRLU; nrow = 5; ncol = 5; *Store = - nnz = 11; nsuper = 2; nzval = [ 19.00, 0.63, 0.63, 21.00, 0.57, 0.57, -13.26, 23.58, -0.24, 5.00, -0.77, 21.00, 34.20 ]; nzval_colptr = <ref> [ 0 3, 6, 9, 11, 13 ] </ref>; rowind = [ 0, 1, 4, 1, 2, 4, 3, 4 ]; rowind_colptr = [ 0, 3, 6, 6, 8, 8 ]; col_to_sup = [ 0, 1, 1, 2, 2 ]; - SuperMatrix data structure. <p> Table 5 lists the platforms on which we have tested the library, and the respective make.inc files. The most portable interface for shared memory programming is POSIX threads <ref> [13] </ref>, since nowadays many commercial UNIX operating systems have support for it. We call our POSIX threads interface the Pthreads interface. To use this interface, you can copy make.pthreads into make.inc and then compile the library.
References-found: 13

