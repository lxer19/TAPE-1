URL: http://theory.lcs.mit.edu/~strumpen/porch.ps.gz
Refering-URL: http://theory.lcs.mit.edu/~porch/
Root-URL: 
Email: strumpen@theory.lcs.mit.edu  
Title: Compiler Technology for Portable Checkpoints  
Author: Volker Strumpen 
Address: Cambridge, MA 02139  
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  
Abstract: We have implemented a prototype compiler called porch that transforms C programs into C programs supporting portable checkpoints. Portable checkpoints capture the state of a computation in a machine-independent format that allows the transfer of computations across binary incompatible machines. We introduce source-to-source compilation techniques for generating code to save and recover from such portable checkpoints automatically. These techniques instrument a program with code that maps the state of a computation into a machine-independent representation and vice versa. In particular, the following problems are addressed: (1) providing stack environment portability, (2) enabling conversion of complex data types, and (3) rendering pointers portable. Experimental results show that the overhead of checkpointing is reasonably small, even if data representation conversion is required for portability. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> David M. Beazley, Peter S. Lomdahl, Niels Grnbech-Jensen, Roscoe Giles, and Pablo Tamayo. </author> <title> Parallel Algorithms for Short-Range Molecular Dynamics. In Dietrich Stauffer, editor, Annual Reviews of Computational Physics, number 3, chapter 4. </title> <publisher> World Scientific Publishing Co., </publisher> <month> October </month> <year> 1995. </year>
Reference-contexts: A possible layout of the union in the code fragment above is: Several variables share the same address in memory: &u.s.i [0] = &u.s.d = &u.t.f, &u.s.i <ref> [1] </ref> = &u.t.s [0], and &u.s.i [2] = &u.t.s [2]. A distinction of these fields could not be made at runtime, if only an address were available. We solve this problem by generating additional information at compile-time. <p> The data structures involved consist of linked lists of particles, neighbors, and cells. A popular performance measure of molecular dynamics codes is the time per iteration <ref> [1] </ref>. We measured the overhead of check-pointing and recovery in number of iterations of the original code. different numbers of particles on four different machines. recovery overhead are roughly proportional to the number of particles. Each bar combines checkpointing and recovery overhead.
Reference: [2] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: The following example illustrates the information contained in a structure metric. If a C program containing data structure struct X is input to porch, it generates a structure metric consisting of structmetric t X metric and the array fieldmetric t fm: struct X - fieldmetric_t fm <ref> [2] </ref> = - char c [2]; - 0, 1, 0, 1, 2, Char -, double d; - 4, 8, 8, 8, 1, Double - - x; -; structmetric_t X_metric = - 2, fm, 12, 4, 16, 8 -; This example assumes the following type metrics for a basic data type char. <p> If a C program containing data structure struct X is input to porch, it generates a structure metric consisting of structmetric t X metric and the array fieldmetric t fm: struct X - fieldmetric_t fm <ref> [2] </ref> = - char c [2]; - 0, 1, 0, 1, 2, Char -, double d; - 4, 8, 8, 8, 1, Double - - x; -; structmetric_t X_metric = - 2, fm, 12, 4, 16, 8 -; This example assumes the following type metrics for a basic data type char. <p> To illustrate this problem, consider the following code fragment. union - union - int i [3]; double d; - s; struct - float f; short s [5]; - t; if ( boolexpression ) u.s.i <ref> [2] </ref> = 42; else u.t.f = 3.14; checkpoint (); Because the value of the if-conditional boolexpression is known in general only at runtime, the decision as to whether i, d or struct t must be saved in the checkpoint cannot be made at compile-time. <p> A possible layout of the union in the code fragment above is: Several variables share the same address in memory: &u.s.i [0] = &u.s.d = &u.t.f, &u.s.i [1] = &u.t.s [0], and &u.s.i <ref> [2] </ref> = &u.t.s [2]. A distinction of these fields could not be made at runtime, if only an address were available. We solve this problem by generating additional information at compile-time. <p> A possible layout of the union in the code fragment above is: Several variables share the same address in memory: &u.s.i [0] = &u.s.d = &u.t.f, &u.s.i [1] = &u.t.s [0], and &u.s.i <ref> [2] </ref> = &u.t.s [2]. A distinction of these fields could not be made at runtime, if only an address were available. We solve this problem by generating additional information at compile-time. <p> These are the only assignments to be transformed. For example, the if statement in the code fragment above is transformed into the following code. According to the depth-first numbering, field u.s.i is attributed tag 3, and field u.t.f is attributed tag 6. if ( boolexpression ) (settag (&u.s.i <ref> [2] </ref>, 3), u.s.i [2] = 42); else (settag (&u.t.f, 6), u.t.f = 3.14); The preceding presentation of the union-assignment transformation omits various details for the sake of brevity. <p> For example, the if statement in the code fragment above is transformed into the following code. According to the depth-first numbering, field u.s.i is attributed tag 3, and field u.t.f is attributed tag 6. if ( boolexpression ) (settag (&u.s.i <ref> [2] </ref>, 3), u.s.i [2] = 42); else (settag (&u.t.f, 6), u.t.f = 3.14); The preceding presentation of the union-assignment transformation omits various details for the sake of brevity. Our current implementation limits the use of unions: Assignments via pointers to union fields cannot be handled without pointer analysis or expensive run-time checking. <p> Our current implementation limits the use of unions: Assignments via pointers to union fields cannot be handled without pointer analysis or expensive run-time checking. For example, if a pointer int *p were defined in the code segment above, the assignment p = &u.s.i <ref> [2] </ref> would make p a pointer to a union field. Using p in an lvalue expression such as in (*p)++ prevents the compiler from determining the union field. Checkpointing and recovery of unions, as well as the last assignments to unions before potential checkpoint locations are relatively expensive. <p> In this case pointers need to be saved temporarily in another table between the save and restore phases. Analysis and Discussion To facilitate fast pointer resolution, porch's runtime system implements the object stack by means of three data structures, a stack, a dynamic table, and a red-black tree <ref> [2] </ref>. The stack holds entries for data/bss and runtime stack objects, the dynamic table holds entries for heap objects, and both stack and dynamic table are augmented with a red-black tree to effect fast searching.
Reference: [3] <author> Geert Deconinck, J. Vounckx, R. Cuyvers, and R. Lauwereins. </author> <title> Survey of Checkpointing and Rollback Techniques. </title> <institution> Technical Report O3.1.8 and O3.1.12, ESAT-ACAA Laboratory, Katholieke Univer-siteit, Leuven, Belgium, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: To illustrate this problem, consider the following code fragment. union - union - int i <ref> [3] </ref>; double d; - s; struct - float f; short s [5]; - t; if ( boolexpression ) u.s.i [2] = 42; else u.t.f = 3.14; checkpoint (); Because the value of the if-conditional boolexpression is known in general only at runtime, the decision as to whether i, d or struct <p> The structure metrics and pointer resolution algorithms are new and are a product of the constraints that arose during the design and implementation of porch. Checkpointing as well as process migration are well established related areas. Good surveys on checkpointing can be found in <ref> [3, 4] </ref>, and on process migration in [12]. Only little work has been done for heterogeneous environments, however. Integrating provision for portablility and fault-tolerance in a compiler tool appears to be a new approach. The Tui system [13] is conceptually the closest work.
Reference: [4] <author> E. N. Elnozahy, David B. Johnson, and Y. M. Wang. </author> <title> A Survey of Rollback-Recovery Protocols in Message Passing Systems. </title> <type> Technical Report CMU-CS-96-181, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <month> September </month> <year> 1996. </year>
Reference-contexts: Resume computation. Different scenarios are possible for storing the checkpoint in nonvolatile memory. For example, porch's runtime system saves the entire checkpoint to disk before resuming the computation. More clever would be to hide the communication latency by transferring the checkpoint to stable storage while continuing with useful computation <ref> [4] </ref>. Algorithm 3 (Recovery) The recovery operation recover k j restores the state of a computation on a machine architecture M j from a portable checkpoint according to the following algorithm: 1. Load checkpoint into shadow stack. 2. <p> The structure metrics and pointer resolution algorithms are new and are a product of the constraints that arose during the design and implementation of porch. Checkpointing as well as process migration are well established related areas. Good surveys on checkpointing can be found in <ref> [3, 4] </ref>, and on process migration in [12]. Only little work has been done for heterogeneous environments, however. Integrating provision for portablility and fault-tolerance in a compiler tool appears to be a new approach. The Tui system [13] is conceptually the closest work.
Reference: [5] <author> A. K. Ganesh, T. J. Marlowe, A. D. Stoyenko, M. F. Younis, and J. Salinas. </author> <title> Architecture and Language Support for Fault-tolerance in Complex Real-Time Systems. </title> <booktitle> In 2nd IEEE Conference on Engineering of Complex Computer Systems, </booktitle> <pages> pages 314322, </pages> <address> Montreal, Canada, </address> <month> October </month> <year> 1996. </year> <note> IEEE. </note>
Reference-contexts: To illustrate this problem, consider the following code fragment. union - union - int i [3]; double d; - s; struct - float f; short s <ref> [5] </ref>; - t; if ( boolexpression ) u.s.i [2] = 42; else u.t.f = 3.14; checkpoint (); Because the value of the if-conditional boolexpression is known in general only at runtime, the decision as to whether i, d or struct t must be saved in the checkpoint cannot be made at <p> Other applications of compiler technology for supporting checkpointing include identification of potential checkpoint locations in programs [7], and providing fault-tolerance for real-time systems <ref> [5] </ref>. 10 Conclusions This article introduces source-to-source transformations and algorithms to translate C programs into C programs capable of saving and recovering from portable checkpoints. We implemented the prototype compiler porch demonstrating the feasibility of the approach.
Reference: [6] <author> Christine R. Hofmeister. </author> <title> Dynamic Reconfiguration of Distributed Applications. </title> <type> PhD thesis, </type> <institution> Computer Science Department, University of Maryland, College Park, </institution> <year> 1993. </year> <note> (file://thumper.cs. umd.edu/files/docs/3210.ps.Z). </note>
Reference-contexts: To avoid checkpointing the stack, they restrict programs to be written in form of a main loop that computes and checkpoints alternately. Furthermore, the problem of handling data structure conversion in the presence of pointers is not addressed. Hofmeister <ref> [6] </ref> developed techniques for dynamic reconfiguration of software in heterogeneous distributed systems, including the transfer of software modules to another machine while an application is executing. This work implements source-to-source transformations by means of UNIX tools, such as cxref and awk rather than using compiler technology.
Reference: [7] <author> Chung-Chi Jim Li, Elliot M. Stewart, and W. Kent Fuchs. </author> <title> Compiler-assisted Full Checkpointing. </title> <journal> Software Practice and Experience, </journal> <volume> 24(10):871886, </volume> <month> October </month> <year> 1994. </year>
Reference-contexts: The existence of portable checkpoints is independent of the choice of L, and follows from the construction of the compiler transformations introduced in this article. A potential checkpoint location may be enabled at runtime, depending on system-based criteria such as timers <ref> [7] </ref>, or by sending a signal to the process. Upon expiration of the timer or receipt of the signal, the next visited potential checkpoint location becomes active, and a checkpoint will be saved. <p> Furthermore, Mermaid dedicates entire virtual memory pages for allocation of data of a particular type, which sacrifices transparency of memory allocation and is impractical for the stack. Other applications of compiler technology for supporting checkpointing include identification of potential checkpoint locations in programs <ref> [7] </ref>, and providing fault-tolerance for real-time systems [5]. 10 Conclusions This article introduces source-to-source transformations and algorithms to translate C programs into C programs capable of saving and recovering from portable checkpoints. We implemented the prototype compiler porch demonstrating the feasibility of the approach.
Reference: [8] <author> Robert C. Miller. </author> <title> A Type-checking Preprocessor for Cilk 2, a Mul-tithreaded C Language. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, Department of Electrical Engineering and Computer Science, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: Acknowledgements Balkrishna Ramkumar has been co-designing porch's predecessor c2ftc until he decided to make a fortune outside academia. Charles Leiserson provided the stimulating environment, which enabled the evolution of porch. He also coined the name porch. The parser and type checker have been borrowed from the identity compiler c2c <ref> [8] </ref>, written by Rob Miller, based on the Alewife C compiler from Eric Brewer and Michael Noakes. The c2c compiler served as a starting point for porch, which probably would not exist if c2c had not been available.
Reference: [9] <author> George C. Necula. </author> <title> Proof-Carrying Code. </title> <booktitle> In 24th ACM Symposium on Principles of Programming Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: The TIL compiler <ref> [9] </ref> uses a similar approach to facilitate safety proofs of code at runtime. The following example illustrates the information contained in a structure metric.
Reference: [10] <author> Balkrishna Ramkumar and Volker Strumpen. </author> <title> Portable Checkpoint-ing for Heterogeneous Architectures. </title> <booktitle> In Digest of Papers 27th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 5867, </pages> <address> Seattle, Washington, June 1997. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: Our performance studies have also shown that the overhead of compiler generated checkpointing is limited to few percent of the runtime for reasonable checkpointing frequencies, even in the presence of data representation conversions for portability <ref> [10, 15] </ref>. Besides removing the burden of coping with heterogeneity of computer architectures, the proposed technology is well suited for a variety of objectives. porch can be used to provide functionalities such as fault-tolerance, process migration in heterogeneous environments, process migration after recompilation, or load balancing. <p> As all other local variables, callid is saved and restored. The instrumentation of save and restore code consists of push and pop operations on a shadow stack, whereby local variables are accessed by name. A description of the save and restore code generation can be found in <ref> [10] </ref>. Note that recovery involves no more than resuming the functions on the runtime stack. Several code transformations are required prior to the release-and-resume instrumentation that are not elaborated here. <p> Furthermore, the target shadow shadow address must be accessible. During checkpointing this address is available only when the target object is pushed onto the shadow stack. Rather than scrutinizing whether an object is a pointer target upon pushing it onto the shadow stack (as done in a previous implementation <ref> [10] </ref>), we save information about each object, including its address range, in another runtime system supplied data structure, the object stack. <p> It is not attempted to present a thorough analysis or to verify the generality of the source-to-source compilation approach. Previously published results on the performance of checkpointing and recovery have already shown that the overhead of portable checkpointing is negligible for reasonable checkpointing frequencies <ref> [10, 15] </ref>. Here, we present evidence that the performance of our new pointer resolution algorithm is accept able as well. Linked List The checkpointing and recovery overhead is different for forward and backward pointers. A simple program serves as microbench-mark to study asymptotic performance. <p> Thus, it may pay off to tune programs accordingly, in particular if space is an issue. 9 Related Work The work presented in this article extends the ideas presented in <ref> [10, 15] </ref>. The structure metrics and pointer resolution algorithms are new and are a product of the constraints that arose during the design and implementation of porch. Checkpointing as well as process migration are well established related areas.
Reference: [11] <author> Erik Seligman and Adam Beguelin. </author> <title> High-Level Fault Tolerance in Distributed Programs. </title> <type> Technical Report CMU-CS-94-223, </type> <institution> Carnegie-Mellon University, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: It provides compiler support for process migration in heterogeneous systems. Tui modifies a compiler (ACK) to provide runtime information via debugging code. This approach allows Tui to handle multiple source languages easily. Tui is tied to a particular native compiler, however. Seligman and Beguelin <ref> [11] </ref> have considered portable check-pointing and restart algorithms in the context of the Dome C++ environment. To avoid checkpointing the stack, they restrict programs to be written in form of a main loop that computes and checkpoints alternately.
Reference: [12] <author> Jonathan M. Smith. </author> <title> A Survey of Process Migration Mechanisms. </title> <journal> ACM Operating Systems Review, </journal> <volume> 22(3):2840, </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: Checkpointing as well as process migration are well established related areas. Good surveys on checkpointing can be found in [3, 4], and on process migration in <ref> [12] </ref>. Only little work has been done for heterogeneous environments, however. Integrating provision for portablility and fault-tolerance in a compiler tool appears to be a new approach. The Tui system [13] is conceptually the closest work. It provides compiler support for process migration in heterogeneous systems.
Reference: [13] <author> Peter W. Smith. </author> <title> The Possibilities and Limitations of Heterogeneous Process Migration. </title> <type> PhD thesis, </type> <institution> Department of Computer Sience, University of British Columbia, </institution> <month> October </month> <year> 1997. </year> <note> (http://www.cs.ubc.ca/spider/psmith/tui.html). </note>
Reference-contexts: Good surveys on checkpointing can be found in [3, 4], and on process migration in [12]. Only little work has been done for heterogeneous environments, however. Integrating provision for portablility and fault-tolerance in a compiler tool appears to be a new approach. The Tui system <ref> [13] </ref> is conceptually the closest work. It provides compiler support for process migration in heterogeneous systems. Tui modifies a compiler (ACK) to provide runtime information via debugging code. This approach allows Tui to handle multiple source languages easily. Tui is tied to a particular native compiler, however.
Reference: [14] <author> Bjarne Steensgaard and Eric Jul. </author> <title> Object and Native Code Thread Mobility Among Heterogeneous Computers. </title> <booktitle> In 15th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 6878, </pages> <address> Copper Mountain Resort, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: This work implements source-to-source transformations by means of UNIX tools, such as cxref and awk rather than using compiler technology. It is not clear, how serious the limitations of this approach are. It would be straightforward, 10 however, to implement dynamic reconfiguration with porch. Steensgaard and Jul <ref> [14] </ref> implemented object migration within the framework of the Emerald system. They introduce bus stops, similar to potential checkpoint locations. For each bus stop code is generated to translate the stack environment into a machine-independent stack frame format and back. This method requires low level knowledge of the stack environment.
Reference: [15] <author> Volker Strumpen and Balkrishna Ramkumar. </author> <title> Portable Check-pointing and Recovery in Heterogeneous Environments. </title> <type> Technical Report ECE-96-6-1, </type> <institution> Departement of Electrical and Computer Engineering, University of Iowa, </institution> <month> June </month> <year> 1996. </year> <note> (http:// www.eng.uiowa.edu/strumpen/ece-96.6.1.ps.Z). </note>
Reference-contexts: Our performance studies have also shown that the overhead of compiler generated checkpointing is limited to few percent of the runtime for reasonable checkpointing frequencies, even in the presence of data representation conversions for portability <ref> [10, 15] </ref>. Besides removing the burden of coping with heterogeneity of computer architectures, the proposed technology is well suited for a variety of objectives. porch can be used to provide functionalities such as fault-tolerance, process migration in heterogeneous environments, process migration after recompilation, or load balancing. <p> It is not attempted to present a thorough analysis or to verify the generality of the source-to-source compilation approach. Previously published results on the performance of checkpointing and recovery have already shown that the overhead of portable checkpointing is negligible for reasonable checkpointing frequencies <ref> [10, 15] </ref>. Here, we present evidence that the performance of our new pointer resolution algorithm is accept able as well. Linked List The checkpointing and recovery overhead is different for forward and backward pointers. A simple program serves as microbench-mark to study asymptotic performance. <p> Thus, it may pay off to tune programs accordingly, in particular if space is an issue. 9 Related Work The work presented in this article extends the ideas presented in <ref> [10, 15] </ref>. The structure metrics and pointer resolution algorithms are new and are a product of the constraints that arose during the design and implementation of porch. Checkpointing as well as process migration are well established related areas.
Reference: [16] <author> Marvin M. Theimer and B. Hayes. </author> <title> Heterogeneous Process Migration by Recompilation. </title> <booktitle> In 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 1825, </pages> <address> Arlington, TX, </address> <month> May </month> <year> 1991. </year> <note> IEEE. </note>
Reference-contexts: They introduce bus stops, similar to potential checkpoint locations. For each bus stop code is generated to translate the stack environment into a machine-independent stack frame format and back. This method requires low level knowledge of the stack environment. Theimer and Hayes <ref> [16] </ref> have presented a recompilation-based approach to heterogeneous process migration. In their scheme, a portable migration program is generated each time that a checkpoint is to be taken. This migration program is recompiled on the migration target machine and used to rebuild the process state.
Reference: [17] <author> Songian Zhou, Michael Stumm, Kai Li, and D. Wortman. </author> <title> Heterogeneous Distributed Shared Memory. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 3(5):540554, </volume> <month> September </month> <year> 1992. </year> <month> 11 </month>
Reference-contexts: Our approach is conceptually simpler as we instrument the original program with code that barely affects the runtime during normal execution, and avoids the overhead of generating and recompiling a migration program. Zhou et al. <ref> [17] </ref> describe the Mermaid system for distributed shared memory on heterogeneous systems. Mermaid uses utility software to generate conversion code, rather than utilizing the information provided by the abstract syntax tree to this end.
References-found: 17

