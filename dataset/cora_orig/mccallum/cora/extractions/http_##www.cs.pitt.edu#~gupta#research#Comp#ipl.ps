URL: http://www.cs.pitt.edu/~gupta/research/Comp/ipl.ps
Refering-URL: http://www.cs.pitt.edu/~gupta/research/optimization.html
Root-URL: 
Title: Generalized Dominators  
Author: Rajiv Gupta 
Keyword: control flow graph, code optimization, loop invariants, array bound checks, code hoisting.  
Address: Pittsburgh Pittsburgh, PA 15260  
Affiliation: Dept. of Computer Science University of  
Abstract: The notion of dominators is generalized to include multiple-vertex dominators in addition to traditional single-vertex dominators. A multiple-vertex dominator of a vertex is a group of vertices that collectively dominate the vertex. An algorithm for computing immediate multiple-vertex dominators is presented. The immediate dominator information is expressed in the form of a directed acyclic graph referred to as the DDAG. The generalized dominator set of any vertex can be computed from the DDAG. The single-vertex dominator information restricts the propagation of loop invariant statements and array bound checks out of loops. Generalized dominator information avoids these restrictions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Agrawal, </author> <title> "Dominators, Super Blocks, and Program Coverage," </title> <booktitle> Proc. 21st Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 25-34, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: The discussion on generalized postdominators can be found in [2]. Generalized dominator information can be used during loop invariant code motion and code hoisting optimizations. Dominator and postdominator information has also been used to address the problem of program coverage. In <ref> [1] </ref> Agrawal identifies groups of statements such that a test set that exercises one statement also exercises the other statements in the subset. Generalized dominator and postdominator information can be used to discover opportunities for sharing test cases among statements that fall in different subsets according to Agrawal's analysis [2].
Reference: [2] <author> R. Gupta, </author> <title> "Generalized Dominators and Post-Dominators," </title> <booktitle> Proc. 19th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albuquerque, New Mexico, </address> <pages> pages 246-257, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: A dual notion of generalized multiple-vertex postdomina-tors can also be defined. The discussion on generalized postdominators can be found in <ref> [2] </ref>. Generalized dominator information can be used during loop invariant code motion and code hoisting optimizations. Dominator and postdominator information has also been used to address the problem of program coverage. <p> Generalized dominator and postdominator information can be used to discover opportunities for sharing test cases among statements that fall in different subsets according to Agrawal's analysis <ref> [2] </ref>. In [8] we have developed static analysis techniques that analyze the synchronization structure of a program to uncover opportunities for distributed breakpointing through which event state can be captured following the detection of an event occurrence. Generalized post-dominator information is used in identifying distributed breakpoints.
Reference: [3] <author> R. Gupta, </author> <title> "Optimizing Array Bound Checks using Flow Analysis," </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> Vol. 2, </volume> <pages> Nos. 1-4, pages 135-150, </pages> <month> March-December </month> <year> 1994. </year>
Reference-contexts: However, none of these optimizations can be directly performed using single-vertex dominators since loop invariants and array bound checks are typically moved out of a loop if they belong to a vertex in the loop which dominates all loop exits <ref> [3] </ref>. In this paper the notion of dominators is generalized to include sets of vertices which collectively dominate a given vertex. This generalization enables the optimization of code in Figure 1.
Reference: [4] <author> D. Harel, </author> <title> "A Linear Time Algorithm for Finding Dominators in Flow Graphs and Related Problems," </title> <booktitle> Proc. of the 17th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 185-194, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: A vertex v in a program control flow graph (CFG) dominates another vertex w, if every path from the beginning of the CFG to vertex w contains v. The problem of computing dominators has been extensively studied and several algorithms have been developed <ref> [5, 6, 7, 10, 4] </ref>. In previous research only single-vertex dominators have been considered. The single-vertex dominators prohibit the full exploitation of optimizations. For example, consider the code segment shown in Figure 1 (i).
Reference: [5] <author> M.S. Hetch and J.D. Ullman, </author> <title> "A Simple Algorithm for Global Data Flow Analysis of Programs," </title> <journal> SIAM Journal of Computing, </journal> <volume> Vol. 4, </volume> <pages> pages 519-532, </pages> <year> 1975. </year>
Reference-contexts: A vertex v in a program control flow graph (CFG) dominates another vertex w, if every path from the beginning of the CFG to vertex w contains v. The problem of computing dominators has been extensively studied and several algorithms have been developed <ref> [5, 6, 7, 10, 4] </ref>. In previous research only single-vertex dominators have been considered. The single-vertex dominators prohibit the full exploitation of optimizations. For example, consider the code segment shown in Figure 1 (i).
Reference: [6] <author> T. Lengauer and R.E. Tarjan, </author> <title> "A Fast Algorithm for Finding Dominators in a Flowgraph," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 1, </volume> <pages> pages 121-141, </pages> <year> 1979. </year>
Reference-contexts: A vertex v in a program control flow graph (CFG) dominates another vertex w, if every path from the beginning of the CFG to vertex w contains v. The problem of computing dominators has been extensively studied and several algorithms have been developed <ref> [5, 6, 7, 10, 4] </ref>. In previous research only single-vertex dominators have been considered. The single-vertex dominators prohibit the full exploitation of optimizations. For example, consider the code segment shown in Figure 1 (i). <p> First, the single-vertex dominators are computed using an existing algorithm <ref> [6, 7, 10] </ref>. Next, the multiple-vertex dominators are determined by considering combinations of dominators of its predecessors. To verify whether a set of vertices V , with cardinality j V j, dominates a vertex v, we must ensure that no subset of vertices in V dominates v.
Reference: [7] <author> P.W. Purdom and E.F. Moore, </author> <title> "Immediate Predominators in a Directed Graph," </title> <journal> Communications of the ACM, </journal> <volume> Vol. 15, No. 8, </volume> <pages> pages 777-778, </pages> <year> 1972. </year>
Reference-contexts: A vertex v in a program control flow graph (CFG) dominates another vertex w, if every path from the beginning of the CFG to vertex w contains v. The problem of computing dominators has been extensively studied and several algorithms have been developed <ref> [5, 6, 7, 10, 4] </ref>. In previous research only single-vertex dominators have been considered. The single-vertex dominators prohibit the full exploitation of optimizations. For example, consider the code segment shown in Figure 1 (i). <p> Since V 0 V this path does not pass through any vertex in V 0 . This contradicts our assumption that V 0 dominates v. Thus, there is no V 0 which dominates v. 2 An algorithm developed by Purdom and Moore <ref> [7] </ref> computes single-vertex dominators for all the vertices in a CFG. In this algorithm the dominator set for a vertex v is computed by taking the intersection of the dominator sets of (immediate) predecessors of v. <p> First, the single-vertex dominators are computed using an existing algorithm <ref> [6, 7, 10] </ref>. Next, the multiple-vertex dominators are determined by considering combinations of dominators of its predecessors. To verify whether a set of vertices V , with cardinality j V j, dominates a vertex v, we must ensure that no subset of vertices in V dominates v.
Reference: [8] <author> M. Spezialetti and R. Gupta, </author> <title> "Debugging Distributed Programs through the Detection of Simultaneous Events," </title> <booktitle> IEEE-CS 14th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 634-641, </pages> <address> Poznan, Poland, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Generalized dominator and postdominator information can be used to discover opportunities for sharing test cases among statements that fall in different subsets according to Agrawal's analysis [2]. In <ref> [8] </ref> we have developed static analysis techniques that analyze the synchronization structure of a program to uncover opportunities for distributed breakpointing through which event state can be captured following the detection of an event occurrence. Generalized post-dominator information is used in identifying distributed breakpoints.
Reference: [9] <author> V.C. Sreedhar, Y-F. Lee, and G.R. Gao, </author> <title> "DJ-Graphs and their Application to Flowgraph Analyses," </title> <institution> McGill University, School of Computer Science, </institution> <note> ACAPS Technical Memo 70, </note> <month> May </month> <year> 1994. </year>
Reference-contexts: In [8] we have developed static analysis techniques that analyze the synchronization structure of a program to uncover opportunities for distributed breakpointing through which event state can be captured following the detection of an event occurrence. Generalized post-dominator information is used in identifying distributed breakpoints. Recently Sreedhar and Gao <ref> [9] </ref> have developed a new representation for flowgraph analysis called DJ-graphs.
Reference: [10] <author> R.E. Tarjan, </author> <title> "Finding Dominators in Directed Graphs," </title> <journal> SIAM Journal of Computing, </journal> <volume> Vol. 3, No. 1, </volume> <pages> pages 62-89, </pages> <year> 1974. </year> <month> 9 </month>
Reference-contexts: A vertex v in a program control flow graph (CFG) dominates another vertex w, if every path from the beginning of the CFG to vertex w contains v. The problem of computing dominators has been extensively studied and several algorithms have been developed <ref> [5, 6, 7, 10, 4] </ref>. In previous research only single-vertex dominators have been considered. The single-vertex dominators prohibit the full exploitation of optimizations. For example, consider the code segment shown in Figure 1 (i). <p> First, the single-vertex dominators are computed using an existing algorithm <ref> [6, 7, 10] </ref>. Next, the multiple-vertex dominators are determined by considering combinations of dominators of its predecessors. To verify whether a set of vertices V , with cardinality j V j, dominates a vertex v, we must ensure that no subset of vertices in V dominates v.
References-found: 10

