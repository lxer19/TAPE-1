URL: ftp://ftp.cs.huji.ac.il/users/transis/thesis/kramer-msc.ps
Refering-URL: http://www.cs.huji.ac.il/labs/transis/thesis.html
Root-URL: http://www.cs.huji.ac.il
Title: Total Ordering of Messages in Multicast Communication Systems  
Author: Shlomo Kramer supervised by Prof. Danny Dolev 
Degree: A thesis submitted in fulfillment of the requirements for the degree of Master of Science by  
Address: Jerusalem, Israel.  
Affiliation: Institute of Computer Science The Hebrew University of Jerusalem  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. </author> <title> Membership algorithms for multicast communication groups. </title> <booktitle> In Intl. Workshop on Distributed Algorithms proceedings (WDAG-6), (L CNS, 647), number 6th, </booktitle> <pages> pages 292-312, </pages> <month> November </month> <year> 1992. </year> <note> previous version available as TR CS92-10, </note> <institution> Dept. of Comp. Sci., the Hebrew University of Jerusalem. </institution>
Reference-contexts: Experimenting with the ToTo protocols in the Transis environment we obtained a sus tained throughput of 250 1K messages per second between 8 sun-4 machines connected by a 10 Mbit/sec Ethernet. * Using Transis' membership service (see <ref> [1] </ref>), the ToTo protocols continue to form the total order in face of arbitrary machine crashes and recoveries as well as network detachments and reconnection. When a partition occurs, machines in every partition continue to form the same total order. This total order may differ across partitions. <p> When a machine comes up, it forms a singleton CCS. The CCS undergoes changes during operation: machines dynamically go up and down, and the CCS reflects these changes through a series of configuration changes. The Transis membership protocol (see <ref> [1] </ref>) operates within the regular flow of messages. Its operation can be schematically presented as consisting of three "stages": * Initiate: initiate a configuration change process by sending a configuration change message. * Agree: all machines dynamically agree on the next configuration change to be performed. <p> of messages prior or concurrent to the configuration change message. * Flush: after all messages in the above agreed upon set had been delivered, install the new configuration by delivering the configuration change message. 10 The Initiate and Agree stages, when invoked, terminate within a finite delay of time (see <ref> [1] </ref>). The Flush stage may involve the delivery for processing of agreed multicast messages. These pending messages may be waiting for a failed machine q to acknowledge their reception. To solve this potential deadlock the membership protocol must supply the multicast protocols with an intermediate event. <p> Intuitively, this stems from the fact that any message from a machine in CCS p Def unc p will causally follow a configuration change message extracting q from the configuration (see <ref> [1] </ref> for more details). Recall that a configuration change is installed by delivering a configuration change message to the upper level. <p> In order to assure a definite time bound for completion of the protocols, we assume that an extraction rule based on timeout 3 is used. The membership service in Transis preserves the following liveness property <ref> [1] </ref>: Liveness Property of The Membership Service Let p, q be two connected processors at time T . Let p receive a message m at time T .
Reference: [2] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. Transis: </author> <title> A communication sub-system for high availability. </title> <booktitle> In Annual International Symposium on Fault-Tolerant Computing, </booktitle> <volume> number 22, </volume> <pages> pages 76-84, </pages> <month> July </month> <year> 1992. </year> <note> previous version available as TR CS91-13, </note> <institution> Dept. of Comp. Sci., the Hebrew University of Jerusalem. </institution>
Reference-contexts: Furthermore, imposing a logical point-to-point connection renders these systems non-scalable, since the n 2 interconnectivity grows rapidly. In this work we use a novel communication model first introduced for the design of the Transis communication sub-system (see <ref> [2] </ref>). The underlying model consists of a set of machines that are clustered into broadcast domains, typically a broadcast domain will correspond to a LAN. The communication facility within a broadcast domain is a nonrealiable broadcast. <p> In this section we give a brief explanation of the causal multicast and atomic membership services supplied by Transis in the broadcast domain and discuss the assumptions made by the ToTo protocols about these services. A detailed description of the Transis environment and services can be found in <ref> [2] </ref>. 8 2.1.1 Causal Multicast The ToTo protocols assume that messages arrival order preserve causality (see [23]), which is defined as the reflexive, transitive closure of: (1) m cause ! m 0 if receive q (m) ! send q (m 0 ) 1 (2) m cause ! m 0 if send
Reference: [3] <author> C. Beeri, H. Schek, and G. Weikum. </author> <title> Multi-level transaction management, </title> <booktitle> theoretical art or practical need ? In Advances in Database Technology, </booktitle> <pages> pages 134-154, </pages> <address> Venice, Italy, </address> <month> March </month> <year> 1988. </year>
Reference: [4] <author> M. Ben-Or. </author> <title> Another advantage of free choice: Completely asynchronous agreement protocols. </title> <booktitle> In Proceedings of the Second Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 27-30, </pages> <address> New York, </address> <month> Aug. </month> <year> 1983. </year> <institution> Association for Computing Machinery. </institution>
Reference: [5] <author> U. N. Bhat. </author> <title> Elements of Applied Stochastic Processes. </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1972. </year>
Reference-contexts: For every machine q in the CCS, we model the stream of messages p receives from q by a continuous time renewal process N q (t) (see <ref> [5] </ref>). The stream of messages received by p is the superposition of n renewal processes N r (t) 1 r n (see r the i'th renewal period of the r'th process, then X 1 r ; : : : ; X i are mutually independent. <p> The latency L is given by: L = X (t1);n1 : 2 Essentially all renewal processes are asymptotically stationary (see <ref> [5] </ref>), so this is not a limiting assumption. 3 In fact, p may need to receive more then one message from a machine r, in this case one needs to replace in the following analysis X 1 r with P r r , where the random variable r models the number
Reference: [6] <author> K. Birman and T. Joseph. </author> <title> Realiable communication in the presence of failures. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 5(1) </volume> <pages> 47-76, </pages> <month> February </month> <year> 1987. </year>
Reference: [7] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight causal and atomic group mul-ticast. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <year> 1991. </year>
Reference-contexts: If a message arrives at a machine, and some of its causal predecessors are missing, Transis transparently handles message recovery and re-ordering. In this way, it guarantees that the ToTo protocol receives the messages in causal order. Other environments like <ref> [7, 28] </ref> are equally suitable for providing the causality requirement. Below, we sometimes refer to the environment and messages as the Transis environment and Transis messages.
Reference: [8] <author> G. Bracha. </author> <title> An t(log n) expected rounds randomized byzantine generals algorithm. </title> <booktitle> In Proc. of the 17th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 316-326, </pages> <year> 1985. </year>
Reference: [9] <author> J. M. Chang and N. Maxemchuck. </author> <title> Realiable broadcast protocols. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 2(3) </volume> <pages> 251-273, </pages> <month> August </month> <year> 1984. </year>
Reference: [10] <author> B. Chor and B. Coan. </author> <title> A simple and efficient randomized byzantine agreement algorithm. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> SE-11(6):531-539, </volume> <month> June </month> <year> 1985. </year> <month> 59 </month>
Reference: [11] <author> D. Dolev, C. Dwork, and L. Stockmeyer. </author> <title> On the minimal synchronism needed for distributed consensus. </title> <booktitle> In Proc. of the 24th IEEE Annual Symp. on Foundation of Computer Science, </booktitle> <volume> number 24, </volume> <pages> pages 393-402, </pages> <year> 1983. </year>
Reference-contexts: Furthermore, Total achieves only partial correctness. Even in faultless runs, Total may further delay admittance of a message after any number of acknowledgments had been received from all other machines. 1.1.2 Total Ordering and Fault Tolerance The total ordering of messages requires a consensus decision. Dolev, Dwork and Stockmeyer <ref> [11] </ref> show that with the presence of a virtually synchronous broadcast protocol, such that all the machines see the messages in the same (total) order, it is possible to achieve consensus with any number of faulty machines. <p> Proof: Assume in contradiction the existence of a block-free total ordering protocol P s.t. any schedule starting at a non-quiescent configuration and involves all the machines delivers some message. Using P we can implement a protocol contradicting Theorem 6.4 in the following simple way (see <ref> [11] </ref>): every machine sends an agreed multicast message with its initial value to all other machines. The register p:O 1 (holding the first message to be delivered) is regarded as p's decision value.
Reference: [12] <author> D. Dolev and H. R. </author> <title> Strong. Authenticated algorithms for byzantine agreement. </title> <journal> SIAM J. Comput., </journal> <volume> 12(3) </volume> <pages> 656-666, </pages> <month> Nov </month> <year> 1983. </year>
Reference: [13] <author> P. Feldman and S. Micali. </author> <title> Optimal algorithms for byzantine agreement. </title> <booktitle> In Proceedings of the 28 th Annual ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1988. </year>
Reference: [14] <author> W. Feller. </author> <title> An Introduction to Probability Theory and Its Applications. </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1966. </year>
Reference-contexts: The Poisson process is perhaps the most important renewal process. Its importance stems from the following fact (see <ref> [14] </ref>): given n renewal processes, the superposition process formed by combining all the renewal epochs into one sequence is, under fairly general conditions, approximately a Poisson process. This fact explains why events generated by a composite system (such as a communication system) can frequently be modeled by a Poisson process. <p> For the Poisson process, X 1 1 ; : : : ; X 1 are i.i.d. exponential with mean 1 . The expectation of X (i);n is given by (see <ref> [14] </ref>): EX (i);n = j=1 n j + 1 Using Equation 4.3 we get: l = i= n P (t = i) j=1 n j Consider, for example, a protocol P with t = + 1, where is some constant. <p> The periodic renewal process models the communication behavior of a machine sending a message every fixed interval of time. For such a process X (i);n = fi (i);n . Thus, the distribution function of X (i);n is given by (see <ref> [14] </ref>): P (X (i);n &gt; t) = k=0 k )t k (1 t) nk : And thus E (X (i);n ) is given by: E (X (i);n ) = 0 i1 X ( n Z c t k (1 t) nk dt i1 X ( n i1 X ( n (n
Reference: [15] <author> M. Fischer, N. Lynch, and M. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> J. ACM, </journal> <volume> 32 </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: We proceed to show that every block-free protocol has unbounded latency. We conclude by discussing some design issues concerning asynchrony and system architecture. 6.1 Block-Free Agreed Multicast Protocols The system model presented in this section is a slight modification to the one described in <ref> [15] </ref>. Following [15] we model a total ordering protocol P by an asynchronous system of n machines. Every machine is modeled by a deterministic I/O automata. <p> We proceed to show that every block-free protocol has unbounded latency. We conclude by discussing some design issues concerning asynchrony and system architecture. 6.1 Block-Free Agreed Multicast Protocols The system model presented in this section is a slight modification to the one described in <ref> [15] </ref>. Following [15] we model a total ordering protocol P by an asynchronous system of n machines. Every machine is modeled by a deterministic I/O automata. <p> If q = p and m is an agreed multicast message, receives m. * p.receive () Invokes cs:receive (p). If cs:receive (p) returns an agreed multicast message m, receives m. The definitions of configuration, step, schedule, run, reachable configuration and accessible configuration are exactly as in <ref> [15] </ref> and are thus omitted. Following [15] we define an event to be a pair (p; m) where p is a machine and m is a message. Recall that a step consists of two phases. First, a p:receive () operation is performed returning some (possibly null) message m. <p> If cs:receive (p) returns an agreed multicast message m, receives m. The definitions of configuration, step, schedule, run, reachable configuration and accessible configuration are exactly as in <ref> [15] </ref> and are thus omitted. Following [15] we define an event to be a pair (p; m) where p is a machine and m is a message. Recall that a step consists of two phases. First, a p:receive () operation is performed returning some (possibly null) message m. <p> We then show that the weak consensus problem in an asynchronous model is reducible to the total ordering problem in the model described above. 6.2 Block-Free Weak Consensus Protocols The system model is exactly the same as in <ref> [15] </ref> with the following slight modification: A configuration is decided when a single decision value is chosen by all the machines (if reached) in all the schedules leading from it. We mark it 0-valent or 1-valent accordingly. Otherwise, a configuration is non-decided. <p> We will henceforth false assume the existence of a block-free weak-consensus protocol P that always decides when all the machines participate correctly. We will reach a contradiction. We use from <ref> [15] </ref> Lemma 1 (the "square rule") and Lemma 2 (there are initial non-decided configurations). Note that in our proof, there are no bi-valent configurations, but non-decided ones, which lead to both deciding schedules of 0/1 values and to non-deciding schedules.
Reference: [16] <author> M. J. Fischer. </author> <title> The consensus problem in unreliable distributed systems (a brief survey). </title> <type> Technical Report YALEU/DCS/RR-273, </type> <institution> Yale University, </institution> <month> June </month> <year> 1983. </year>
Reference: [17] <author> K. J. Goldman. </author> <title> Highly concurrent logically synchronous multicast. </title> <journal> Distributed Computing, </journal> <volume> 4(4) </volume> <pages> 189-208, </pages> <year> 1991. </year>
Reference: [18] <author> A. Griefer and R. Strong. Dcf: </author> <title> Distributed communication with fault tolerance. </title> <booktitle> In Ann. Symp. Principles of Distributed Computing, </booktitle> <volume> number 7, </volume> <pages> pages 18-27, </pages> <month> August </month> <year> 1988. </year>
Reference: [19] <author> M. Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(1) </volume> <pages> 124-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Thus it is impossible to achieve the agreed multicast operation in an asynchronous distributed environment when failures may occur. This reduction of the consensus problem to the total ordering problem gives the agreed multicast its primary importance. In <ref> [19] </ref> it is shown that all shared objects are wait-free implementations of consensus objects, rendering the consensus objects universal. Consensus objects can be implemented using the agreed multicast service. Thus, the agreed multicast service can serve as a fundamental building block in many distributed systems. <p> In this section we present a model for hierarchical systems using the concurrent object paradigm introduced in [20] and <ref> [19] </ref>. A concurrent object is a simplified form of I/O automata. A full description of the concurrent object paradigm can be found in [19]. Our definition of a system differs from the definition in [19] in the following: * There is no distinction between processes and objects. <p> In this section we present a model for hierarchical systems using the concurrent object paradigm introduced in [20] and <ref> [19] </ref>. A concurrent object is a simplified form of I/O automata. A full description of the concurrent object paradigm can be found in [19]. Our definition of a system differs from the definition in [19] in the following: * There is no distinction between processes and objects. A concurrent system is composed of an arbitrary set of concurrent objects. <p> we present a model for hierarchical systems using the concurrent object paradigm introduced in [20] and <ref> [19] </ref>. A concurrent object is a simplified form of I/O automata. A full description of the concurrent object paradigm can be found in [19]. Our definition of a system differs from the definition in [19] in the following: * There is no distinction between processes and objects. A concurrent system is composed of an arbitrary set of concurrent objects.
Reference: [20] <author> M. Herlihy and J. Wing. </author> <title> Axioms for concurrent objects. </title> <booktitle> In Proceedings of the Fourteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 13-26, </pages> <address> Munich, </address> <month> Jan. </month> <year> 1987. </year> <note> ACM. </note>
Reference-contexts: In this section we present a model for hierarchical systems using the concurrent object paradigm introduced in <ref> [20] </ref> and [19]. A concurrent object is a simplified form of I/O automata. A full description of the concurrent object paradigm can be found in [19]. Our definition of a system differs from the definition in [19] in the following: * There is no distinction between processes and objects. <p> A history S is sequential if S ! is a total order. For sequential histories, every operation op s.t. E = client (op) or E = server (op) induces a state transition on E. Legal state transitions of an object E can be specified using pre- and postcondition (see <ref> [20] </ref> for an axiomatic specification for legal state transitions). A sequential history S is legal if for every element E, the subhistory S j E induces a sequence of legal state transitions on E.
Reference: [21] <author> M. F. Kaashoek, A. S. Tanenbaum, S. F. Hummel, and H. E. Bal. </author> <title> An efficient reliable broadcast protocol. </title> <journal> Operating Systems Review, </journal> <volume> 23(4) </volume> <pages> 5-19, </pages> <month> October </month> <year> 1989. </year>
Reference: [22] <author> L. Lamport. </author> <title> On interprocess communication. </title> <journal> Distributed Computing, </journal> <volume> 1(2) </volume> <pages> 77-85, 86-101, </pages> <year> 1986. </year>
Reference-contexts: A concurrent system is composed of an arbitrary set of concurrent objects. A concurrent object is both a client, invoking a sequential stream of requests to other objects, and a server, serving other objects' requests. * We do not use an auxiliary global-time order (see <ref> [22] </ref>) but rather use a precedence function. A precedence function maps histories to precedence relations and is part of the system's specification.
Reference: [23] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Commun. ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July 78. </month>
Reference-contexts: A detailed description of the Transis environment and services can be found in [2]. 8 2.1.1 Causal Multicast The ToTo protocols assume that messages arrival order preserve causality (see <ref> [23] </ref>), which is defined as the reflexive, transitive closure of: (1) m cause ! m 0 if receive q (m) ! send q (m 0 ) 1 (2) m cause ! m 0 if send q (m) ! send q (m 0 ) If m 0 follows m in the causal
Reference: [24] <author> S. W. Luan and V. D. Gligor. </author> <title> A fault-tolerant protocol for atomic broadcast. </title> <journal> IEEE Trans. Parallel & Distributed Syst., </journal> <volume> 1(3) </volume> <pages> 271-285, </pages> <month> July 90. </month>
Reference: [25] <author> N. Lynch and M. Merritt. </author> <title> Introduction to the theory of nested transactions. </title> <booktitle> In International Conference on Database Theory, </booktitle> <pages> pages 278-305, </pages> <address> Rome, Italy, </address> <month> September </month> <year> 1986. </year>
Reference: [26] <author> P. M. Melliar-Smith, L. E. Moser, and V. Agrawala. </author> <title> Broadcast protocols for distributed systems. </title> <journal> IEEE Trans. Parallel & Distributed Syst., </journal> <volume> (1), </volume> <month> Jan </month> <year> 1990. </year>
Reference: [27] <author> P. M. Melliar-Smith, L. E. Moser, and V. Agrawala. </author> <title> Membership algorithms for asynchronous distributed systems. </title> <booktitle> In Intl. Conf. Distributed Computing Systems, </booktitle> <month> May 91. </month>
Reference-contexts: Let p receive an agreed multicast message m at time T . By T + m is delivered at p. 3 In order to assure eventual termination it is sufficient to assume eventual extraction (see <ref> [27] </ref>). 26 Proof: By Lemma 3.11 (a), by T + , N T ail p (m) = l p . Denote by C p the set of undelivered messages prior or concurrent to m at time T +.
Reference: [28] <author> L. L. Peterson, N. C. Buchholz, and R. D. Schlichting. </author> <title> Preserving and using context information in interprocess communication. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 7(3) </volume> <pages> 217-246, </pages> <month> August 89. </month>
Reference-contexts: If a message arrives at a machine, and some of its causal predecessors are missing, Transis transparently handles message recovery and re-ordering. In this way, it guarantees that the ToTo protocol receives the messages in causal order. Other environments like <ref> [7, 28] </ref> are equally suitable for providing the causality requirement. Below, we sometimes refer to the environment and messages as the Transis environment and Transis messages.
Reference: [29] <author> M. O. Rabin. </author> <title> Randomized byzantine generals. </title> <booktitle> In Proc. of the 24th IEEE Annual Symp. on Foundation of Computer Science, </booktitle> <pages> pages 403-409, </pages> <year> 1983. </year> <month> 61 </month>
References-found: 29

