URL: http://www.cs.utexas.edu/users/moore/publications/multi-v-uni.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/moore/publications/index.html
Root-URL: 
Title: A Mechanically Checked Proof of a  
Date: 27, 1998  
Note: February  
Abstract: Multiprocessor Result via a Uniprocessor View Abstract We describe a mechanically checked correctness proof for a system of n processes, each running a simple, non-blocking counter algorithm. We prove that if the system runs longer than 5n steps, the counter is increased. The theorem is formalized in applicative Common Lisp and proved with the ACL2 theorem prover. The value of this paper lies not so much in the trivial algorithm addressed as in the method used to prove it correct. The method allows one to reason accurately about the behavior of a concurrent, multiprocess system by reasoning about the sequential computation carried out by a selected process, against a memory that is changed externally. Indeed, we prove general lemmas that allow shifting between the multiprocess and uniprocess views. We prove a safety property using a multiprocess view, project the property to a uniprocess view, and then prove a global progress property via a local, sequential computation argument.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook, Second Edition, </title> <publisher> Academic Press: </publisher> <address> London, </address> <year> 1997. </year>
Reference-contexts: ACL2, which stands for "A Computational Logic for Applicative Common Lisp," is a general-purpose first-order essentially quantifier-free logic of total recursive functions based on an applicative subset of Common Lisp [13]. ACL2 is a re-implemented and extended version of the Boyer-Moore theorem prover, Nqthm <ref> [1] </ref>. Its primary use has been the formal specification and verification of microprocessor designs and heavy-duty theorem proving about floating point arithmetic [2, 10, 12]. Two widely-used formal logics designed explicitly for reasoning about concurrent systems are Unity [3] and TLA [9].
Reference: [2] <author> B. Brock, M. Kaufmann and J S. Moore, </author> <title> "ACL2 Theorems about Commercial Microprocessors," </title> <editor> in M. Srivas and A. Camilleri (eds.) </editor> <booktitle> Proceedings of Formal Methods in Computer-Aided Design (FM-CAD'96), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 275-293, </pages> <year> 1996. </year>
Reference-contexts: A third reason the argument is interesting is that it leaves implicit an appeal to the pigeon hole principle: some process executes at least k steps if the system runs long enough. In essence, the purpose of this paper is to describe a formalization of this argument in ACL2 <ref> [2, 6] </ref>. In so doing we will also demonstrate that the "intuitively appealing" argument can be made entirely precise and rigorous. <p> ACL2 is a re-implemented and extended version of the Boyer-Moore theorem prover, Nqthm [1]. Its primary use has been the formal specification and verification of microprocessor designs and heavy-duty theorem proving about floating point arithmetic <ref> [2, 10, 12] </ref>. Two widely-used formal logics designed explicitly for reasoning about concurrent systems are Unity [3] and TLA [9]. In [4] Goldschlag formalizes Unity in the Nqthm logic and then uses Nqthm to derive many Unity proof rules and to check Unity proofs.
Reference: [3] <author> K. M. Chandy and J. Misra, </author> <title> Parallel Program Design: A Foundation, </title> <publisher> Addison Wesley: </publisher> <address> Massachusetts, </address> <year> 1988. </year>
Reference-contexts: Its primary use has been the formal specification and verification of microprocessor designs and heavy-duty theorem proving about floating point arithmetic [2, 10, 12]. Two widely-used formal logics designed explicitly for reasoning about concurrent systems are Unity <ref> [3] </ref> and TLA [9]. In [4] Goldschlag formalizes Unity in the Nqthm logic and then uses Nqthm to derive many Unity proof rules and to check Unity proofs.
Reference: [4] <author> D. M. Goldschlag, </author> <title> Mechanizing Unity, </title> <editor> in M. Broy and C. B. Jones (eds.), </editor> <booktitle> Programming Concepts and Methods, </booktitle> <publisher> North Holland: </publisher> <address> Amster-dam, </address> <year> 1990. </year>
Reference-contexts: Its primary use has been the formal specification and verification of microprocessor designs and heavy-duty theorem proving about floating point arithmetic [2, 10, 12]. Two widely-used formal logics designed explicitly for reasoning about concurrent systems are Unity [3] and TLA [9]. In <ref> [4] </ref> Goldschlag formalizes Unity in the Nqthm logic and then uses Nqthm to derive many Unity proof rules and to check Unity proofs. However, with the exception of [4], and some ongoing work at several labs, Unity and TLA do not currently have much mechanical proof support. <p> Two widely-used formal logics designed explicitly for reasoning about concurrent systems are Unity [3] and TLA [9]. In <ref> [4] </ref> Goldschlag formalizes Unity in the Nqthm logic and then uses Nqthm to derive many Unity proof rules and to check Unity proofs. However, with the exception of [4], and some ongoing work at several labs, Unity and TLA do not currently have much mechanical proof support. A distinguishing characteristic of our proof of the non-blocking counter algorithm is that it was mechanically checked.
Reference: [5] <author> M. Herlihy, </author> <title> Wait-Free Synchronization, </title> <journal> ACM Trans. Prog. Lang. and Sys. </journal> <volume> 11(1), </volume> <pages> pp. 124-149, </pages> <month> January, </month> <year> 1991 </year>
Reference-contexts: The idea of using non-atomic operations to implement atomic ones is apparently first discussed in Lamport's early papers, e.g., [8]. See <ref> [5] </ref> for a discussion of wait-free synchronization and the power of various synchronization primitives such as atomic reads and write, compare and swap, etc. <p> Most proofs in the literature are in the traditional style, e.g., <ref> [5] </ref>, although many such proofs about non-blocking algorithms are sufficiently subtle that their authors have found it necessary to adopt very precise notation, e.g., [11]. Our proof, while informally presented here, is actually carried out in the formal | indeed the mechanized | logic of ACL2.
Reference: [6] <author> M. </author> <title> Kaufmann and J Strother Moore "An Industrial Strength Theorem Prover for a Logic Based on Common Lisp,"IEEE Transactions on Software Engineering, </title> <booktitle> 23(4), </booktitle> <pages> pp. 203-213, </pages> <month> April, </month> <year> 1997 </year>
Reference-contexts: A third reason the argument is interesting is that it leaves implicit an appeal to the pigeon hole principle: some process executes at least k steps if the system runs long enough. In essence, the purpose of this paper is to describe a formalization of this argument in ACL2 <ref> [2, 6] </ref>. In so doing we will also demonstrate that the "intuitively appealing" argument can be made entirely precise and rigorous.
Reference: [7] <author> M. Kaufmann and J Strother Moore, </author> <title> "Structured Theory Development for a Mechanized Logic," </title> <address> URL http://www.cs.utexas.edu/- users/moore/acl2/reports/km98.ps. </address>
Reference-contexts: Then R holds between the successive memories seen by ustep starting from (proj p s) with memory oracle (proj-oracle p s L). We call this the Preorder Projection Theorem. We prove the Preorder Projection Theorem for any and R, using ACL2's "encapsulation" mechanism <ref> [7] </ref>.
Reference: [8] <author> L. Lamport, </author> <title> Concurrent reading and writing, </title> <journal> Commun. ACM, </journal> <month> 20(11), </month> <pages> pp 806-811, </pages> <month> November, </month> <year> 1977. </year>
Reference-contexts: The idea of using non-atomic operations to implement atomic ones is apparently first discussed in Lamport's early papers, e.g., <ref> [8] </ref>. See [5] for a discussion of wait-free synchronization and the power of various synchronization primitives such as atomic reads and write, compare and swap, etc.
Reference: [9] <author> L. Lamport, </author> <title> The Temporal Logic of Actions, </title> <journal> TOPLAS, </journal> <pages> 16(3) pp. 872-923, </pages> <month> May, </month> <year> 1994. </year>
Reference-contexts: Its primary use has been the formal specification and verification of microprocessor designs and heavy-duty theorem proving about floating point arithmetic [2, 10, 12]. Two widely-used formal logics designed explicitly for reasoning about concurrent systems are Unity [3] and TLA <ref> [9] </ref>. In [4] Goldschlag formalizes Unity in the Nqthm logic and then uses Nqthm to derive many Unity proof rules and to check Unity proofs. However, with the exception of [4], and some ongoing work at several labs, Unity and TLA do not currently have much mechanical proof support.
Reference: [10] <author> J S. Moore, T. Lynch, and M. Kaufmann. </author> <title> A Mechanically Checked Proof of the Correctness of the Kernel of the AMD5 K 86 Floating Point Division Algorithm, </title> <journal> IEEE Trans. Comp. </journal> <note> (to appear). </note>
Reference-contexts: ACL2 is a re-implemented and extended version of the Boyer-Moore theorem prover, Nqthm [1]. Its primary use has been the formal specification and verification of microprocessor designs and heavy-duty theorem proving about floating point arithmetic <ref> [2, 10, 12] </ref>. Two widely-used formal logics designed explicitly for reasoning about concurrent systems are Unity [3] and TLA [9]. In [4] Goldschlag formalizes Unity in the Nqthm logic and then uses Nqthm to derive many Unity proof rules and to check Unity proofs.
Reference: [11] <author> M. Moir, </author> <title> Fast, Long-Lived Renaming Improved and Simplified, </title> <note> Science of Computer Programming (to appear). URL: http://www.cs.- pitt.edu/~moir/Papers/moir-scp97.ps. 12 </note>
Reference-contexts: Most proofs in the literature are in the traditional style, e.g., [5], although many such proofs about non-blocking algorithms are sufficiently subtle that their authors have found it necessary to adopt very precise notation, e.g., <ref> [11] </ref>. Our proof, while informally presented here, is actually carried out in the formal | indeed the mechanized | logic of ACL2.
Reference: [12] <author> D. Russinoff, </author> <title> "A Mechanically Checked Proof of Correctness of the AMD5 K 86 Floating-Point Square Root Microcode," </title> <address> http://www.onr .com/user/russ/david/fsqrt.html, </address> <month> February, </month> <year> 1997. </year>
Reference-contexts: ACL2 is a re-implemented and extended version of the Boyer-Moore theorem prover, Nqthm [1]. Its primary use has been the formal specification and verification of microprocessor designs and heavy-duty theorem proving about floating point arithmetic <ref> [2, 10, 12] </ref>. Two widely-used formal logics designed explicitly for reasoning about concurrent systems are Unity [3] and TLA [9]. In [4] Goldschlag formalizes Unity in the Nqthm logic and then uses Nqthm to derive many Unity proof rules and to check Unity proofs.
Reference: [13] <author> G. L. Steele, Jr. </author> <title> Common Lisp The Language, Second Edition. </title> <publisher> Digital Press, </publisher> <address> 30 North Avenue, Burlington, MA 01803, </address> <year> 1990. </year> <month> 13 </month>
Reference-contexts: ACL2, which stands for "A Computational Logic for Applicative Common Lisp," is a general-purpose first-order essentially quantifier-free logic of total recursive functions based on an applicative subset of Common Lisp <ref> [13] </ref>. ACL2 is a re-implemented and extended version of the Boyer-Moore theorem prover, Nqthm [1]. Its primary use has been the formal specification and verification of microprocessor designs and heavy-duty theorem proving about floating point arithmetic [2, 10, 12].
References-found: 13

