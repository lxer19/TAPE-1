URL: http://www.cs.umd.edu/users/chechik/proposal.ps
Refering-URL: http://www.cs.umd.edu/users/chechik/research.html
Root-URL: 
Title: Automatic Analysis of Consistency Between Implementations and Requirements Research Proposal  
Author: Marsha Chechik 
Date: November 11, 1994  
Address: College Park, MD 20742  
Affiliation: Department of Computer Science University of Maryland,  
Abstract-found: 0
Intro-found: 1
Reference: [AFB + 88] <author> T. Alspaugh, S. Faulk, K. Britton, R. Parker, D. Parnas, and J. Shore. </author> <title> "Software Requirements for the A-7E Aircraft". </title> <type> Technical report, </type> <institution> Naval Research Laboratory, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Unfortunately, proving these properties provides no guarantee that they will be preserved in an implementation of the system. In Software Cost Reduction (SCR) requirements <ref> [AFB + 88, HL93, Hen80] </ref>, systems are modelled as concurrently executing state machines. Transition tables describe changes in the states of the system and in the values of the system's variables. <p> Section 3.7 describes the verification of user-defined system properties. In Section 3.8, we summarize the steps of our analysis. Section 3.9 presents the WLMS case study. Finally, in Section 3.10, we compare our approach with related work. 3.2 Requirements Notation Software Cost Reduction (SCR) requirements <ref> [AFB + 88, HL93, Hen80] </ref> model a system as a set of concurrently executing state machines. Each state machine interacts with its environ 11 ment's state variables. <p> These properties frequently appear in requirements documents, and during our case studies 32 we did not need to verify any other properties. Requirements specifications of realistic size and complexity (like <ref> [AFB + 88] </ref>) contain global properties which cannot be expressed using just these assertions. Thus, we want to be able to verify more general CTL formulas.
Reference: [AG93] <author> J.M. Atlee and J. Gannon. </author> <title> "State-Based Model Checking of Event-Driven Sys tem Requirements". </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 22-40, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Formal methods like model checking ([CES86]) can be used to demonstrate that safety properties of event-based systems are enforced by the system's requirements <ref> [AG93] </ref>. After building a finite-state structure representing the system's reachability graph, a model checker can automatically determine if the structure is a model of temporal logic formulas representing the system's safety properties. Unfortunately, proving these properties provides no guarantee that they will be preserved in an implementation of the system. <p> Two push buttons, SelfTst and Reset, permit the operator to test the system and return it to normal operation. A complete description of this system can be found in [van90]. The safety properties for this study were the same as those used in <ref> [AG93] </ref>. They are shown in Table 3.9. The WLMS was originally implemented by roughly 1300 lines of FORTRAN and Assembler code. To analyze the program, we translated it into C and replaced its PC interface routines with an Xlib interface.
Reference: [ASU88] <author> A. Aho, R. Sethi, and J. Ulman. </author> <booktitle> Compilers: Principles, Techniques, and Tools, Chapter 10. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Standard date-flow techniques (<ref> [ASU88] </ref>) are used to compute reaching definitions RD for each node in the CFG using a least fixed point. The fixed point computation may overestimate a basic block's RDs because it assumes that each predicate may evaluate to either True or False. gen and kill sets [ASU88] are computed for each Update and Initial command. An iterative algorithm is used to compute reaching definitions [ASU88] for these states. The in and out sets represent system states before and after the state. <p> The fixed point computation may overestimate a basic block's RDs because it assumes that each predicate may evaluate to either True or False. gen and kill sets <ref> [ASU88] </ref> are computed for each Update and Initial command. An iterative algorithm is used to compute reaching definitions [ASU88] for these states. The in and out sets represent system states before and after the state.
Reference: [Atl92] <author> J. Atlee. </author> <title> "Automated Analysis of Software Requirements". </title> <type> PhD thesis, </type> <institution> University of Maryland, College Park, Maryland, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: Dependencies between monitored or controlled variables are recorded via relationships. Relationships help requirements designers eliminate redundant information and increase the clarity of specifications <ref> [Atl92] </ref>. They also improve readability and reduce the effort involved in annotating an implementation.
Reference: [CC76] <author> Patrick Cousot and Radhia Cousot. </author> <title> "Static Determination of Dynamic Properties of Programs". </title> <booktitle> In Proceedings of the "Colloque sur la Programmation", </booktitle> <month> April </month> <year> 1976. </year>
Reference-contexts: Reese. "Requirements Specification for Process-Control Systems". IEEE Transactions on Software Engineering, 20 (9):684-707, September 1994. [Zav82] Pamela Zave. "An Operational Approach to Requirements Specifications for Embedded Systems". IEEE Transactions on Software Engineering, SE-8 (3):250-269, May 1982. 8 2.2 Formal Methods in Program Analysis 2.2.1 Abstract Interpretation Reading List <ref> [CC76] </ref> Patrick Cousot and Radhia Cousot. "Static Determination of Dynamic Properties of Programs". In Proceedings of the "Colloque sur la Programmation", April 1976. [CC77a] Patrick Cousot and Radhia Cousot. "Abstract Interpretation: A Unified Lat tice Model For Static Analysis of Programs by Construction or Approximation of Fixpoints". <p> Modeclass values are sets of modes which the system can attain at a particular point in the computation. Values of controlled and monitored variables are Undefined, True, False, and TrueOrFalse. In an abstract interpretation framework <ref> [CC76] </ref>, values of controlled and monitored variables and those of modeclass variables each form lattices (Figure 3.4). Thus the reaching definitions at each state of the program also form a lattice. The lattice in Figure 3.4a is used to compute RDs for boolean-valued variables.
Reference: [CC77] <author> Patrick Cousot and Radhia Cousot. </author> <title> "Abstract Interpretation: A Unified Lattice Model For Static Analysis of Programs by Construction or Approximation of Fix-points". </title> <booktitle> In Proceedings of the 4th POPL, </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, California, </address> <year> 1977. </year>
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. "Automatic Verification of Finite State Concurrent Systems Using Temporal Logic Specifications". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Research report, IBM T.J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY 10598, USA, March 1990. 2.2.2 Model Checking Reading List [AG93a] J.M. Atlee and J. Gannon. "State-Based Model Checking of Event-Driven Sys tem Requirements". IEEE Transactions on Software Engineering, pages 22-40, January 1993. <ref> [CES86] </ref> E.M. Clarke, E.A. Emerson, and A.P. Sistla. "Automatic Verification of Finite State Concurrent Systems Using Temporal Logic Specifications". ACM Transactions on Programming Languages and Systems, 8 (2):244-263, April 1986. [GMM90] Carlo Ghezzi, Dino Mandrioli, and Angelo Morzenti. "TRIO: A Logic Language for Executable Specifications of Real-Time Systems". <p> Thus, we want to be able to verify more general CTL formulas. The automatically-generated properties (see Section 3.4) will still be verified during one pass through the finite-state machine, and the user-specified properties will be verified one at a time in the manner described in <ref> [CES86] </ref>. For concurrent programs, we can utilize some of the compositional model checking techniques presented in [CLM89]. Unfortunately, as pointed out in Section 3.4 of this document, an abstraction of the implementation, I0 is not an equivalent to the implementation I, due to the presence of infeasible paths.
Reference: [CG94a] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Analysis of Consistency between Imple mentations and Requirements: A Case Study". </title> <note> (Submitted to ISE'95), </note> <month> September </month> <year> 1994. </year>
Reference-contexts: However, the bookkeeping tasks needed to determine all the possible system states at a particular program point make it difficult to ensure that global properties of the system hold. We developed a propotype tool, called Analyzer <ref> [CG94b, CG94a] </ref>, which attempts to automatically verify that an implementation is consistent with its requirements (see Figure 1.1). The inputs to the tool are 5 . a requirements specification and a C source program annotated with comments describing the values of variables which appear in the requirements. <p> The tool can also check if the abstraction is a model of certain safety properties supplied by the user. Our investigations <ref> [CG94b, CG94a] </ref> show that the tool is useful in detecting inconsistencies in implementations which were developed to conform to SCR-style requirements. In this document, we describe the tool and show results of a case study, during which we analyzed an implementation of a water-level monitoring system (WLMS) [van90].
Reference: [CG94b] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Verification of Requirements Implemen tations". </title> <booktitle> In Proceedings of the 1994 ISSTA, </booktitle> <pages> pages 1-14, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1994. </year> <month> 50 </month>
Reference-contexts: However, the bookkeeping tasks needed to determine all the possible system states at a particular program point make it difficult to ensure that global properties of the system hold. We developed a propotype tool, called Analyzer <ref> [CG94b, CG94a] </ref>, which attempts to automatically verify that an implementation is consistent with its requirements (see Figure 1.1). The inputs to the tool are 5 . a requirements specification and a C source program annotated with comments describing the values of variables which appear in the requirements. <p> The tool can also check if the abstraction is a model of certain safety properties supplied by the user. Our investigations <ref> [CG94b, CG94a] </ref> show that the tool is useful in detecting inconsistencies in implementations which were developed to conform to SCR-style requirements. In this document, we describe the tool and show results of a case study, during which we analyzed an implementation of a water-level monitoring system (WLMS) [van90].
Reference: [CHK92] <author> Keith D. Cooper, Mary W. Hall, and Ken Kennedy. </author> <title> "Procedure Cloning". </title> <booktitle> In Proceedings of IEEE International Conference on Computer Languages, </booktitle> <pages> pages 96-105, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Figure 3.6 shows a finite-state machine abstracting the code of Figure 3.5, with Info sets for every state. 3.5.3 Processing Function Calls We process functions using a technique called cloning <ref> [CHK92] </ref> which we adapted for our analysis. A similar algorithm was described in [Weg75]. This technique enables Analyzer to process programs with cycles in their call graphs (recursion), to analyze each called function 22 only a constant number of times, and to achieve reasonable precision in the analysis.
Reference: [CLM89] <author> E. M. Clarke, D. E. Long, and K. L. McMillan. </author> <title> "Compositional Model Checking". </title> <booktitle> In Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 464-475, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: The automatically-generated properties (see Section 3.4) will still be verified during one pass through the finite-state machine, and the user-specified properties will be verified one at a time in the manner described in [CES86]. For concurrent programs, we can utilize some of the compositional model checking techniques presented in <ref> [CLM89] </ref>. Unfortunately, as pointed out in Section 3.4 of this document, an abstraction of the implementation, I0 is not an equivalent to the implementation I, due to the presence of infeasible paths.
Reference: [DC94] <author> Matthew B. Dryer and Lori A. Clarke. </author> <title> "Data Flow Analysis for Verifying Prop erties of Concurrent Programs". </title> <year> 1994. </year>
Reference-contexts: IEEE Transactions on Software Engineering, 18 (9):785-793, Septem-ber 1992. [JS88] F. Jahanian and D. Stuart. "A Method for Verifying Properties of Modechart Specifications". In Proceedings of the Real-Time Systems Symposium, pages 12-21, 1988. 9 2.3 Static Analysis of Programs Reading List <ref> [DC94] </ref> Matthew B. Dryer and Lori A. Clarke. "Data Flow Analysis for Verifying Prop erties of Concurrent Programs". 1994. [HW94] W.E. Howden and B. Wieand. "QDA A Method for Systematic Informal Program Analysis". IEEE Transactions on Software Engineering, 20 (6):445-462, June 1994. [Jac93a] Daniel Jackson. "Abstract Analysis with Aspect".
Reference: [Fer93] <author> J.-C. Fernandez. </author> <title> "Abstract Interpretation and Verification of Reactive Systems". </title> <booktitle> In ??, pages 60-71, </booktitle> <year> 1993. </year>
Reference-contexts: In Proceedings of the "Colloque sur la Programmation", April 1976. [CC77a] Patrick Cousot and Radhia Cousot. "Abstract Interpretation: A Unified Lat tice Model For Static Analysis of Programs by Construction or Approximation of Fixpoints". In Proceedings of the 4th POPL, pages 238-252, Los Angeles, California, 1977. <ref> [Fer93] </ref> J.-C. Fernandez. "Abstract Interpretation and Verification of Reactive Systems". In ??, pages 60-71, 1993. [Mar90] Kim Marriott. "Frameworks for Abstract Interpretation". Research report, IBM T.J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY 10598, USA, March 1990. 2.2.2 Model Checking Reading List [AG93a] J.M. Atlee and J.
Reference: [FG94] <author> Jeffrey Fischer and Richard Gerber. </author> <title> "Compositional Model Checking of Ada Task ing Programs". </title> <type> Technical report, </type> <institution> University of Maryland College Park, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: can improve our approach by utilizing the following techniques: * We can be more careful about our processing, utilizing program slicing [HRB88] to propagate reaching definitions on a variable to variable bases, skipping program constructs which do not impact a particular variable. * We can use verification by counter-example technique <ref> [FG94] </ref> to look for branches which will violate a property, and then then look at communicating processes to determine if such value can be obtained. 35 4.4 Connecting Annotations and Code As described in Chapter 3, Analyzer uses only annotations and the control-flow information of the program to build the finite-state
Reference: [GMM90] <author> Carlo Ghezzi, Dino Mandrioli, and Angelo Morzenti. </author> <title> "TRIO: A Logic Language for Executable Specifications of Real-Time Systems". </title> <journal> Journal of Systems and Software, </journal> <volume> 12(2) </volume> <pages> 107-123, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Gannon. "State-Based Model Checking of Event-Driven Sys tem Requirements". IEEE Transactions on Software Engineering, pages 22-40, January 1993. [CES86] E.M. Clarke, E.A. Emerson, and A.P. Sistla. "Automatic Verification of Finite State Concurrent Systems Using Temporal Logic Specifications". ACM Transactions on Programming Languages and Systems, 8 (2):244-263, April 1986. <ref> [GMM90] </ref> Carlo Ghezzi, Dino Mandrioli, and Angelo Morzenti. "TRIO: A Logic Language for Executable Specifications of Real-Time Systems". Journal of Systems and Software, 12 (2):107-123, May 1990. [HLR92] Nicolas Halbwachs, Fabienne Lagnier, and Christophe Ratel. "Programming and Verifying Real-Time Systems by Means of the Synchronous Data-Flow Language LUSTRE".
Reference: [Har87] <author> David Harel. "StateCharts: </author> <title> A Visual Formalism for Complex Systems". </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: We also present some of the related work and possible avenues for further research. 6 . Chapter 2 Related Work 2.1 Requirements Analysis Reading List <ref> [Har87] </ref> David Harel. "StateCharts: A Visual Formalism for Complex Systems". Science of Computer Programming, 8:231-274, 1987. [Hen80] K. Heninger. "Specifying Software Requirements for Complex Systems: New Techniques and Their Applications". IEEE Transactions on Software Engineering, SE-6 (1):2-12, January 1980. [JLHM91] Matthew S. Jaffe, Nancy G. Levenson, Mats P.E.
Reference: [Hen80] <author> K. Heninger. </author> <title> "Specifying Software Requirements for Complex Systems: New Techniques and Their Applications". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):2-12, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: Unfortunately, proving these properties provides no guarantee that they will be preserved in an implementation of the system. In Software Cost Reduction (SCR) requirements <ref> [AFB + 88, HL93, Hen80] </ref>, systems are modelled as concurrently executing state machines. Transition tables describe changes in the states of the system and in the values of the system's variables. <p> We also present some of the related work and possible avenues for further research. 6 . Chapter 2 Related Work 2.1 Requirements Analysis Reading List [Har87] David Harel. "StateCharts: A Visual Formalism for Complex Systems". Science of Computer Programming, 8:231-274, 1987. <ref> [Hen80] </ref> K. Heninger. "Specifying Software Requirements for Complex Systems: New Techniques and Their Applications". IEEE Transactions on Software Engineering, SE-6 (1):2-12, January 1980. [JLHM91] Matthew S. Jaffe, Nancy G. Levenson, Mats P.E. Heimdahl, and Bonnie E. Mel hart. "Software Requirements Analysis for Real-Time Process-Control Systems". <p> Section 3.7 describes the verification of user-defined system properties. In Section 3.8, we summarize the steps of our analysis. Section 3.9 presents the WLMS case study. Finally, in Section 3.10, we compare our approach with related work. 3.2 Requirements Notation Software Cost Reduction (SCR) requirements <ref> [AFB + 88, HL93, Hen80] </ref> model a system as a set of concurrently executing state machines. Each state machine interacts with its environ 11 ment's state variables. <p> It would thus be desirable to extend our analysis method to processing concurrent programs. 33 We plan to change the SCR model used in [van90], to make it closer to the original, from <ref> [Hen80] </ref>. We represent each modeclass as a separate process which takes Inputs (we will call them monitored variables) and produces Outputs (controlled variables). Modeclasses are not allowed to communicate with each other directly, but rather through controlled variables.
Reference: [HL93] <author> C. Heitmeyer and B. Labaw. </author> <title> "Consistency Checks for SCR-Style Requirements Specifications". </title> <type> Technical Report NRL Report 93-9586, </type> <institution> Naval Research Laboratory, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Unfortunately, proving these properties provides no guarantee that they will be preserved in an implementation of the system. In Software Cost Reduction (SCR) requirements <ref> [AFB + 88, HL93, Hen80] </ref>, systems are modelled as concurrently executing state machines. Transition tables describe changes in the states of the system and in the values of the system's variables. <p> Section 3.7 describes the verification of user-defined system properties. In Section 3.8, we summarize the steps of our analysis. Section 3.9 presents the WLMS case study. Finally, in Section 3.10, we compare our approach with related work. 3.2 Requirements Notation Software Cost Reduction (SCR) requirements <ref> [AFB + 88, HL93, Hen80] </ref> model a system as a set of concurrently executing state machines. Each state machine interacts with its environ 11 ment's state variables.
Reference: [HLR92] <author> Nicolas Halbwachs, Fabienne Lagnier, and Christophe Ratel. </author> <title> "Programming and Verifying Real-Time Systems by Means of the Synchronous Data-Flow Language LUSTRE". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(9) </volume> <pages> 785-793, </pages> <month> Septem-ber </month> <year> 1992. </year>
Reference-contexts: ACM Transactions on Programming Languages and Systems, 8 (2):244-263, April 1986. [GMM90] Carlo Ghezzi, Dino Mandrioli, and Angelo Morzenti. "TRIO: A Logic Language for Executable Specifications of Real-Time Systems". Journal of Systems and Software, 12 (2):107-123, May 1990. <ref> [HLR92] </ref> Nicolas Halbwachs, Fabienne Lagnier, and Christophe Ratel. "Programming and Verifying Real-Time Systems by Means of the Synchronous Data-Flow Language LUSTRE". IEEE Transactions on Software Engineering, 18 (9):785-793, Septem-ber 1992. [JS88] F. Jahanian and D. Stuart. "A Method for Verifying Properties of Modechart Specifications".
Reference: [How90] <author> W.E. Howden. </author> <title> "Comments Analysis and Programming Errors". </title> <journal> IEEE Transac tions on Software Engineering, </journal> <volume> 16(1) </volume> <pages> 72-81, </pages> <month> January </month> <year> 1990. </year>
Reference: [HRB88] <author> Susan Horwitz, Thomas Reps, and David Binkley. </author> <title> "Interprocedural Slicing Using Dependence Graphs". </title> <booktitle> In Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 35-46, </pages> <address> Atlanta, Georgia, </address> <month> June </month> <year> 1988. </year> <month> 51 </month>
Reference-contexts: The naive approach presented above has several problems. The most serious is the exponential blowup in the size of the resulting CFG. We can improve our approach by utilizing the following techniques: * We can be more careful about our processing, utilizing program slicing <ref> [HRB88] </ref> to propagate reaching definitions on a variable to variable bases, skipping program constructs which do not impact a particular variable. * We can use verification by counter-example technique [FG94] to look for branches which will violate a property, and then then look at communicating processes to determine if such value
Reference: [HW94] <author> W.E. Howden and B. Wieand. </author> <title> "QDA A Method for Systematic Informal Pro gram Analysis". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(6) </volume> <pages> 445-462, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Jahanian and D. Stuart. "A Method for Verifying Properties of Modechart Specifications". In Proceedings of the Real-Time Systems Symposium, pages 12-21, 1988. 9 2.3 Static Analysis of Programs Reading List [DC94] Matthew B. Dryer and Lori A. Clarke. "Data Flow Analysis for Verifying Prop erties of Concurrent Programs". 1994. <ref> [HW94] </ref> W.E. Howden and B. Wieand. "QDA A Method for Systematic Informal Program Analysis". IEEE Transactions on Software Engineering, 20 (6):445-462, June 1994. [Jac93a] Daniel Jackson. "Abstract Analysis with Aspect". In Proceedings of the 1993 International Symposium on Software Testing and Analysis, pages 19-27, June 1993. [OO92] Kurt M.
Reference: [Jac92] <author> D. Jackson. </author> <title> Aspect: A Formal Specification Language for Detecting Bugs. </title> <type> PhD thesis, </type> <institution> MIT, Cambridge, Massachusetts, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: Generation of these properties is a rather complicated task, but front ends can be built to read specifications in various formats and convert them to a list of properties. 3.10.2 Static Analysis of Programs Analyzer uses concepts from Quick Defect Analysis (QDA)[How90, HW94], Cesar/Cecil [OO89, OO90, OO92], and Aspect <ref> [Jac92, Jac93a, Jac93b] </ref> In QDA, implementations are annotated with two types of comments: assertions that an object has one of a finite number of values, and assumptions about the object's values at particular control points.
Reference: [Jac93a] <author> Daniel Jackson. </author> <title> "Abstract Analysis with Aspect". </title> <booktitle> In Proceedings of the 1993 International Symposium on Software Testing and Analysis, </booktitle> <pages> pages 19-27, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Dryer and Lori A. Clarke. "Data Flow Analysis for Verifying Prop erties of Concurrent Programs". 1994. [HW94] W.E. Howden and B. Wieand. "QDA A Method for Systematic Informal Program Analysis". IEEE Transactions on Software Engineering, 20 (6):445-462, June 1994. <ref> [Jac93a] </ref> Daniel Jackson. "Abstract Analysis with Aspect". In Proceedings of the 1993 International Symposium on Software Testing and Analysis, pages 19-27, June 1993. [OO92] Kurt M. Olender and Leon K. Osterweil. "Interprocedural Static Analysis of Se quencing Constraints". <p> Generation of these properties is a rather complicated task, but front ends can be built to read specifications in various formats and convert them to a list of properties. 3.10.2 Static Analysis of Programs Analyzer uses concepts from Quick Defect Analysis (QDA)[How90, HW94], Cesar/Cecil [OO89, OO90, OO92], and Aspect <ref> [Jac92, Jac93a, Jac93b] </ref> In QDA, implementations are annotated with two types of comments: assertions that an object has one of a finite number of values, and assumptions about the object's values at particular control points.
Reference: [Jac93b] <author> Daniel Jackson. </author> <title> "Aspect: Detecting Bugs with Abstract Dependences". </title> <journal> (sub mitted to Transactions on Software Engineering and Methodology), </journal> <month> November </month> <year> 1993. </year>
Reference-contexts: Generation of these properties is a rather complicated task, but front ends can be built to read specifications in various formats and convert them to a list of properties. 3.10.2 Static Analysis of Programs Analyzer uses concepts from Quick Defect Analysis (QDA)[How90, HW94], Cesar/Cecil [OO89, OO90, OO92], and Aspect <ref> [Jac92, Jac93a, Jac93b] </ref> In QDA, implementations are annotated with two types of comments: assertions that an object has one of a finite number of values, and assumptions about the object's values at particular control points.
Reference: [JLHM91] <author> Matthew S. Jaffe, Nancy G. Levenson, Mats P.E. Heimdahl, and Bonnie E. Mel hart. </author> <title> "Software Requirements Analysis for Real-Time Process-Control Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(3), </volume> <month> March </month> <year> 1991. </year>
Reference-contexts: Chapter 2 Related Work 2.1 Requirements Analysis Reading List [Har87] David Harel. "StateCharts: A Visual Formalism for Complex Systems". Science of Computer Programming, 8:231-274, 1987. [Hen80] K. Heninger. "Specifying Software Requirements for Complex Systems: New Techniques and Their Applications". IEEE Transactions on Software Engineering, SE-6 (1):2-12, January 1980. <ref> [JLHM91] </ref> Matthew S. Jaffe, Nancy G. Levenson, Mats P.E. Heimdahl, and Bonnie E. Mel hart. "Software Requirements Analysis for Real-Time Process-Control Systems". IEEE Transactions on Software Engineering, 17 (3), March 1991. [LHHR94] N.G. Levenson, M.P.E. Heimdahl, H. Hildreth, and J.D. Reese. "Requirements Specification for Process-Control Systems".
Reference: [JS88] <author> F. Jahanian and D. Stuart. </author> <title> "A Method for Verifying Properties of Modechart Specifications". </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <pages> pages 12-21, </pages> <year> 1988. </year>
Reference-contexts: Journal of Systems and Software, 12 (2):107-123, May 1990. [HLR92] Nicolas Halbwachs, Fabienne Lagnier, and Christophe Ratel. "Programming and Verifying Real-Time Systems by Means of the Synchronous Data-Flow Language LUSTRE". IEEE Transactions on Software Engineering, 18 (9):785-793, Septem-ber 1992. <ref> [JS88] </ref> F. Jahanian and D. Stuart. "A Method for Verifying Properties of Modechart Specifications". In Proceedings of the Real-Time Systems Symposium, pages 12-21, 1988. 9 2.3 Static Analysis of Programs Reading List [DC94] Matthew B. Dryer and Lori A.
Reference: [LHHR94] <author> N.G. Levenson, M.P.E. Heimdahl, H. Hildreth, and J.D. Reese. </author> <title> "Requirements Specification for Process-Control Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9) </volume> <pages> 684-707, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: IEEE Transactions on Software Engineering, SE-6 (1):2-12, January 1980. [JLHM91] Matthew S. Jaffe, Nancy G. Levenson, Mats P.E. Heimdahl, and Bonnie E. Mel hart. "Software Requirements Analysis for Real-Time Process-Control Systems". IEEE Transactions on Software Engineering, 17 (3), March 1991. <ref> [LHHR94] </ref> N.G. Levenson, M.P.E. Heimdahl, H. Hildreth, and J.D. Reese. "Requirements Specification for Process-Control Systems". IEEE Transactions on Software Engineering, 20 (9):684-707, September 1994. [Zav82] Pamela Zave. "An Operational Approach to Requirements Specifications for Embedded Systems".
Reference: [LZ75] <author> B.H. Liskov and S.N. Zilles. </author> <title> "Specification Techniques for Data Abstraction". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1(1):7-18, </volume> <month> March </month> <year> 1975. </year>
Reference-contexts: Generally, when two descriptions of a system are written, designers attempt to convince themselves that concepts are captured in the higher-level description and preserved in the lower-level description <ref> [LZ75] </ref>. Formal methods like model checking ([CES86]) can be used to demonstrate that safety properties of event-based systems are enforced by the system's requirements [AG93].
Reference: [Mar90] <author> Kim Marriott. </author> <title> "Frameworks for Abstract Interpretation". </title> <type> Research report, </type> <institution> IBM T.J. Watson Research Center, </institution> <address> P.O. Box 704, Yorktown Heights, NY 10598, USA, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: In Proceedings of the 4th POPL, pages 238-252, Los Angeles, California, 1977. [Fer93] J.-C. Fernandez. "Abstract Interpretation and Verification of Reactive Systems". In ??, pages 60-71, 1993. <ref> [Mar90] </ref> Kim Marriott. "Frameworks for Abstract Interpretation". Research report, IBM T.J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY 10598, USA, March 1990. 2.2.2 Model Checking Reading List [AG93a] J.M. Atlee and J. Gannon. "State-Based Model Checking of Event-Driven Sys tem Requirements".
Reference: [OO89] <author> Kurt M. Olender and Leon J. Osterweil. </author> <title> "Cesar: A Static Sequencing Constraint Analyzer". </title> <booktitle> In Proceedings of the ACM SIGSOFT '89 Third Symposium on Software Testing, Analysis, and Verification (TAV3), </booktitle> <pages> pages 66-74, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Generation of these properties is a rather complicated task, but front ends can be built to read specifications in various formats and convert them to a list of properties. 3.10.2 Static Analysis of Programs Analyzer uses concepts from Quick Defect Analysis (QDA)[How90, HW94], Cesar/Cecil <ref> [OO89, OO90, OO92] </ref>, and Aspect [Jac92, Jac93a, Jac93b] In QDA, implementations are annotated with two types of comments: assertions that an object has one of a finite number of values, and assumptions about the object's values at particular control points.
Reference: [OO90] <author> Kurt M. Olender and Leon J. Osterweil. "Cecil: </author> <title> A Sequencing Constraint Lan guage for Automatic Static Analysis Generation". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 268-280, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Generation of these properties is a rather complicated task, but front ends can be built to read specifications in various formats and convert them to a list of properties. 3.10.2 Static Analysis of Programs Analyzer uses concepts from Quick Defect Analysis (QDA)[How90, HW94], Cesar/Cecil <ref> [OO89, OO90, OO92] </ref>, and Aspect [Jac92, Jac93a, Jac93b] In QDA, implementations are annotated with two types of comments: assertions that an object has one of a finite number of values, and assumptions about the object's values at particular control points.
Reference: [OO92] <author> Kurt M. Olender and Leon K. Osterweil. </author> <title> "Interprocedural Static Analysis of Se quencing Constraints". </title> <journal> ACM Transactions of Software Engineering and Methodology, </journal> <volume> 1(1) </volume> <pages> 21-52, </pages> <month> January </month> <year> 1992. </year> <month> 52 </month>
Reference-contexts: Howden and B. Wieand. "QDA A Method for Systematic Informal Program Analysis". IEEE Transactions on Software Engineering, 20 (6):445-462, June 1994. [Jac93a] Daniel Jackson. "Abstract Analysis with Aspect". In Proceedings of the 1993 International Symposium on Software Testing and Analysis, pages 19-27, June 1993. <ref> [OO92] </ref> Kurt M. Olender and Leon K. Osterweil. "Interprocedural Static Analysis of Se quencing Constraints". ACM Transactions of Software Engineering and Methodology, 1 (1):21-52, January 1992. 10 Chapter 3 Completed Work 3.1 Introduction We have developed a tool, called Analyzer, to check an implementation against its requirements. <p> Generation of these properties is a rather complicated task, but front ends can be built to read specifications in various formats and convert them to a list of properties. 3.10.2 Static Analysis of Programs Analyzer uses concepts from Quick Defect Analysis (QDA)[How90, HW94], Cesar/Cecil <ref> [OO89, OO90, OO92] </ref>, and Aspect [Jac92, Jac93a, Jac93b] In QDA, implementations are annotated with two types of comments: assertions that an object has one of a finite number of values, and assumptions about the object's values at particular control points.
Reference: [van90] <author> J. van Schouwen. </author> <title> "The A-7 Requirements Model: Re-examination for Real-Time Systems and an Application to Monitoring Systems". </title> <type> Technical Report TR-90-276, </type> <institution> Queen's University, Kingston, </institution> <address> Ontario, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: Our investigations [CG94b, CG94a] show that the tool is useful in detecting inconsistencies in implementations which were developed to conform to SCR-style requirements. In this document, we describe the tool and show results of a case study, during which we analyzed an implementation of a water-level monitoring system (WLMS) <ref> [van90] </ref>. We also present some of the related work and possible avenues for further research. 6 . Chapter 2 Related Work 2.1 Requirements Analysis Reading List [Har87] David Harel. "StateCharts: A Visual Formalism for Complex Systems". Science of Computer Programming, 8:231-274, 1987. [Hen80] K. <p> Two push buttons, SelfTst and Reset, permit the operator to test the system and return it to normal operation. A complete description of this system can be found in <ref> [van90] </ref>. The safety properties for this study were the same as those used in [AG93]. They are shown in Table 3.9. The WLMS was originally implemented by roughly 1300 lines of FORTRAN and Assembler code. <p> It would thus be desirable to extend our analysis method to processing concurrent programs. 33 We plan to change the SCR model used in <ref> [van90] </ref>, to make it closer to the original, from [Hen80]. We represent each modeclass as a separate process which takes Inputs (we will call them monitored variables) and produces Outputs (controlled variables). Modeclasses are not allowed to communicate with each other directly, but rather through controlled variables.
Reference: [Weg75] <author> Ben Wegbreit. </author> <title> "Property Extraction in Well-Founded Property Sets". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 1(3) </volume> <pages> 270-285, </pages> <month> September </month> <year> 1975. </year>
Reference-contexts: Figure 3.6 shows a finite-state machine abstracting the code of Figure 3.5, with Info sets for every state. 3.5.3 Processing Function Calls We process functions using a technique called cloning [CHK92] which we adapted for our analysis. A similar algorithm was described in <ref> [Weg75] </ref>. This technique enables Analyzer to process programs with cycles in their call graphs (recursion), to analyze each called function 22 only a constant number of times, and to achieve reasonable precision in the analysis.
Reference: [YT89] <author> Michal Young and Richard N. Taylor. </author> <title> "Rethinking the Taxonomy of Fault Detec tion Techniques". </title> <booktitle> In Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 53-62, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: These notions were defined in <ref> [YT89] </ref>, but we give a somewhat weaker definition of them. To clarify the definition, we use the Figure 3.3, where a and b are sets of properties accepted by I0 and I, respectively.
Reference: [Zav82] <author> Pamela Zave. </author> <title> "An Operational Approach to Requirements Specifications for Em bedded Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-8(3):250-269, </volume> <month> May </month> <year> 1982. </year> <month> 53 </month>
Reference-contexts: Levenson, Mats P.E. Heimdahl, and Bonnie E. Mel hart. "Software Requirements Analysis for Real-Time Process-Control Systems". IEEE Transactions on Software Engineering, 17 (3), March 1991. [LHHR94] N.G. Levenson, M.P.E. Heimdahl, H. Hildreth, and J.D. Reese. "Requirements Specification for Process-Control Systems". IEEE Transactions on Software Engineering, 20 (9):684-707, September 1994. <ref> [Zav82] </ref> Pamela Zave. "An Operational Approach to Requirements Specifications for Embedded Systems". IEEE Transactions on Software Engineering, SE-8 (3):250-269, May 1982. 8 2.2 Formal Methods in Program Analysis 2.2.1 Abstract Interpretation Reading List [CC76] Patrick Cousot and Radhia Cousot. "Static Determination of Dynamic Properties of Programs".
References-found: 37

