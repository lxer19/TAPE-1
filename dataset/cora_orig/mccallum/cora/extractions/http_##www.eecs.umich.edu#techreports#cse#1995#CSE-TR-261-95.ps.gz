URL: http://www.eecs.umich.edu/techreports/cse/1995/CSE-TR-261-95.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse95.html
Root-URL: http://www.eecs.umich.edu
Email: waleed@eecs.umich.edu  
Title: Optimal Dual-Issue Instruction Scheduling With Spills For Binary Expression Trees  
Author: Waleed M. Meleis Edward S. Davidson 
Address: Ann Arbor MI  
Affiliation: Advanced Computer Architecture Lab University of Michigan,  
Abstract: We describe an algorithm that produces code, with spills, for a register-constrained machine that can issue up to one arithmetic operation and one memory access operation per time slot, under the restrictions that the code's dependence graph is represented as a binary tree with no unary operations, and the latency of the operations is 1. We prove that the algorithm produces a minimum cost schedule, and show that its complexity is O(nk) where n is the number of operations to be scheduled and k is the number of spills in the schedule. The number of issue slots in the minimum length schedule is ae + 2k + jAj where ae is the number of registers used, k is the number of spills and jAj is the number of arithmetic operations in the tree. We show this is the cost of any schedule that is in "contiguous form". 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho and S. C. Johnson. </author> <title> Optimal code generation for expression trees. </title> <journal> Journal of the ACM, </journal> <volume> 23 </volume> <pages> 488-501, </pages> <year> 1976. </year>
Reference-contexts: This algorithm also uses a postorder traversal of the expression tree and executes in linear time. Aho and Johnson develop a dynamic programming algorithm that solves the same problem in <ref> [1] </ref>. Bernstein et al. [2] show how to find the cheapest dual-issue schedule without spills for a binary expression tree, given a fixed number of registers. They also give an efficient heuristic that applies if the expression tree contains unary operations. <p> the following sections, we show that every parallel evaluation, P Q, of F in contiguous form that contains k spilled values has a cost of ae (P Q) + 2k + jA (F )j and that no parallel evaluation can cost less. 3.1 Minimizing spills in a sequential evaluation In <ref> [1] </ref> and [13], efficient algorithms to solve a variant of the sequential scheduling problem are described. <p> In [4], 3 Bose describes a simple adaptation of the algorithm in <ref> [1] </ref> that solves the sequential scheduling problem without the fourth instruction class. The algorithm first computes a label, M , for each vertex of F , and then uses these labels to construct the schedule. Sequential scheduling algorithm Visit the vertices of the tree in postorder.
Reference: [2] <author> D. Bernstein, J. Jaffe, and M. Rodeh. </author> <title> Scheduling arithmetic and load operations in parallel with no spilling. </title> <journal> SIAM Journal of Computing, </journal> <volume> 18 </volume> <pages> 1098-1127, </pages> <year> 1987. </year>
Reference-contexts: This algorithm also uses a postorder traversal of the expression tree and executes in linear time. Aho and Johnson develop a dynamic programming algorithm that solves the same problem in [1]. Bernstein et al. <ref> [2] </ref> show how to find the cheapest dual-issue schedule without spills for a binary expression tree, given a fixed number of registers. They also give an efficient heuristic that applies if the expression tree contains unary operations. <p> The multi-processor scheduling problem for trees is shown to be NP-complete by Bernstein et al. in [3]. These results demonstrate that optimal code generation for a multiple-issue machine is difficult even in the absence of register restrictions. 1 2 The Machine/Computation Model The notation used in <ref> [2] </ref> formalizes the sequential and parallel scheduling problems without spills. We begin by extending this notation to allow the use of spill code. We consider a machine model that has access to R registers: r 1 r 2 ,...,r R and an arbitrarily large memory space. <p> Let J i = q i p i , and let P 0 = J 1 J 2 :::J jP Qj , then delete the NOPs to create a sequential evaluation, P . In <ref> [2] </ref> the same transformation is applied to parallel evaluations that do not contain spills. We first show that when P is constructed in this manner it represents a sequential evaluation. Then we show that ae (P ) ae (P Q).
Reference: [3] <author> D. Bernstein, M. Rodeh, and I. Gertner. </author> <title> On the complexity of scheduling problems for parallel/pipeplined machines. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 38 </volume> <pages> 1308-1313, </pages> <year> 1989. </year>
Reference-contexts: The multi-processor scheduling problem for DAGs is shown to be NP-complete by Ullman in [14]. The multi-processor scheduling problem for trees is shown to be NP-complete by Bernstein et al. in <ref> [3] </ref>. These results demonstrate that optimal code generation for a multiple-issue machine is difficult even in the absence of register restrictions. 1 2 The Machine/Computation Model The notation used in [2] formalizes the sequential and parallel scheduling problems without spills.
Reference: [4] <author> P. Bose. </author> <title> Optimal code generation for expressions in super scalar machines. </title> <booktitle> In Proc. Fall Joint Computer Conference, </booktitle> <pages> pages 372-379, </pages> <year> 1986. </year>
Reference-contexts: In addition to the three types of operations described above, these algorithms include another latency 1 binary arithmetic operator that reads one operand from a register and one operand from memory and writes its result to a register, causing no net change in inreg i . In <ref> [4] </ref>, 3 Bose describes a simple adaptation of the algorithm in [1] that solves the sequential scheduling problem without the fourth instruction class. The algorithm first computes a label, M , for each vertex of F , and then uses these labels to construct the schedule. <p> Store v 1 ; Schedule (v 2 ); Load v 1 ; Compute v; else if M (v 2 ) &lt; M (v 1 ): Schedule (v 1 ); Schedule (v 2 ); Compute v; else Schedule (v 2 ); Schedule (v 1 ); Compute v; End As argued in <ref> [4] </ref>, the sequential scheduling algorithm computes a cheapest evaluation of F that uses no more than R registers. Furthermore, it can be shown that if the cheapest evaluation contains no spills, the algorithm minimizes the maximum number of values in registers.
Reference: [5] <author> D. Bradlee, S. Eggers, and R. Henry. </author> <title> Integrating register allocation and instruction scheduling for RISCS. </title> <booktitle> In Proc. 4th Intl. Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <year> 1991. </year>
Reference: [6] <author> J. Bruno and R. Sethi. </author> <title> Code generation for a one-register machine. </title> <journal> Journal of the ACM, </journal> <volume> 23 </volume> <pages> 502-510, </pages> <year> 1976. </year>
Reference-contexts: An expression DAG differs from an expression tree in that a computed quantity may be used more than once in the course of the computation. Bruno and Sethi show in <ref> [6] </ref> that evaluating an expression DAG using minimal spill code for a 1-register machine is NP-complete. The spill insertion problem is to insert the minimum amount of spill code into a given initial schedule.
Reference: [7] <author> J. R. Goodman and W. C. Hsu. </author> <title> Code scheduling and register allocation in large basic blocks. </title> <booktitle> In Proc. 1988 Intl. Conf. on Supercomputing, </booktitle> <pages> pages 442-452, </pages> <year> 1988. </year> <month> 12 </month>
Reference: [8] <author> L. P. Horwitz, R. M. Karp, R. E. Miller, and S. Winograd. </author> <title> Index register allocation. </title> <journal> Journal of the Association of Computing Machinery, </journal> <volume> 13 </volume> <pages> 43-61, </pages> <year> 1966. </year>
Reference-contexts: The spill insertion problem is to insert the minimum amount of spill code into a given initial schedule. The most efficient algorithms known for spill insertion are shown by Horwitz et al. <ref> [8] </ref>, and Hsu et al. [9] to be exponential in the number of registers in the worst case. This is a striking result because it demonstrates that optimal code generation is difficult even when the instruction schedule is fixed. They derive pruning rules for optimal spilling and present heuristics.
Reference: [9] <author> W. Hsu, C. N. Fischer, and J. R. Goodman. </author> <title> On the minimization of loads/stores in local register allocation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15 </volume> <pages> 1252-1260, </pages> <year> 1989. </year>
Reference-contexts: The spill insertion problem is to insert the minimum amount of spill code into a given initial schedule. The most efficient algorithms known for spill insertion are shown by Horwitz et al. [8], and Hsu et al. <ref> [9] </ref> to be exponential in the number of registers in the worst case. This is a striking result because it demonstrates that optimal code generation is difficult even when the instruction schedule is fixed. They derive pruning rules for optimal spilling and present heuristics.
Reference: [10] <author> I. Nakata. </author> <title> On compiling algorithms for arithmetic expressions. </title> <journal> Communications of the ACM, </journal> <volume> 10 </volume> <pages> 492-494, </pages> <year> 1967. </year>
Reference-contexts: The problem of minimizing the number of registers needed to evaluate an expression tree without spills on a single-issue processor was first solved by Nakata <ref> [10] </ref> and by Redziejowski [11]. The algorithm uses a postorder evaluation of the expression tree and executes in time proportional to the number of operations to be scheduled.
Reference: [11] <author> R. R. Redziejowski. </author> <title> On arithmetic expressions and trees. </title> <journal> Communications of the ACM, </journal> <volume> 12 </volume> <pages> 81-84, </pages> <year> 1969. </year>
Reference-contexts: The problem of minimizing the number of registers needed to evaluate an expression tree without spills on a single-issue processor was first solved by Nakata [10] and by Redziejowski <ref> [11] </ref>. The algorithm uses a postorder evaluation of the expression tree and executes in time proportional to the number of operations to be scheduled.
Reference: [12] <author> R. Sethi. </author> <title> Complete register allocation problems. </title> <journal> SIAM Journal of Computing, </journal> <volume> 4 </volume> <pages> 226-248, </pages> <year> 1975. </year>
Reference-contexts: They also give an efficient heuristic that applies if the expression tree contains unary operations. The problem of minimizing the number of registers needed in an evaluation of an expression DAG without spills was shown to be NP complete by Sethi in <ref> [12] </ref>. An expression DAG differs from an expression tree in that a computed quantity may be used more than once in the course of the computation. Bruno and Sethi show in [6] that evaluating an expression DAG using minimal spill code for a 1-register machine is NP-complete.
Reference: [13] <author> R. Sethi and J. D. Ullman. </author> <title> The generation of optimal code for arithmetic expressions. </title> <journal> Journal of the ACM, </journal> <volume> 17 </volume> <pages> 715-728, </pages> <year> 1970. </year>
Reference-contexts: The algorithm uses a postorder evaluation of the expression tree and executes in time proportional to the number of operations to be scheduled. Sethi and Ullman extend this result in <ref> [13] </ref> to minimize the amount of spill code needed to evaluate an expression tree, given a fixed number of registers. This algorithm also uses a postorder traversal of the expression tree and executes in linear time. <p> sections, we show that every parallel evaluation, P Q, of F in contiguous form that contains k spilled values has a cost of ae (P Q) + 2k + jA (F )j and that no parallel evaluation can cost less. 3.1 Minimizing spills in a sequential evaluation In [1] and <ref> [13] </ref>, efficient algorithms to solve a variant of the sequential scheduling problem are described. <p> Furthermore, it can be shown that if the cheapest evaluation contains no spills, the algorithm minimizes the maximum number of values in registers. The proof of this, which we omit, is similar to the one given in <ref> [13] </ref> Clearly c (P ) equals the number of nodes in F plus the number of spill operations. Therefore an optimal sequential evaluation must contain the fewest spill operations among all sequential evaluations. Furthermore, if k values are spilled, there are 2k spill operations, i.e. k store/load pairs.
Reference: [14] <author> J. D. Ullman. </author> <title> Np-complete scheduling problems. </title> <journal> Journal of Computing Systems and Sciences, </journal> <volume> 10 </volume> <pages> 384-393, </pages> <year> 1975. </year> <month> 13 </month>
Reference-contexts: This is equivalent to the problem of optimally scheduling an expression on a machine with distinct functional units and infinite registers. The multi-processor scheduling problem for DAGs is shown to be NP-complete by Ullman in <ref> [14] </ref>. The multi-processor scheduling problem for trees is shown to be NP-complete by Bernstein et al. in [3].
References-found: 14

