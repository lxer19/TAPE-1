URL: http://www.cs.toronto.edu/~david/papers-tl2tsql.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/papers.html
Root-URL: 
Email: boehlen@iesd.auc.dk  chomicki@moncol.monmouth.edu  david@cs.toronto.edu  
Phone: 2  3  
Title: Querying ATSQL Databases with Temporal Logic  
Author: Michael H. Bohlen Jan Chomicki and David Toman 
Address: Fredrik Bajers Vej 7E, DK-9220 Aalborg Ost, Denmark,  West Long Branch, NJ 07764,  Toronto, Ontario M5S 1A4, Canada,  
Affiliation: 1 Dept. of Mathematics and Computer Science, Aalborg University  Department of Computer Science, Monmouth University  Department of Computer Science, University of Toronto  
Abstract: In this paper we establish a correspondence between temporal logic and a subset of ATSQL, a temporal extension of SQL-92. In addition we provide an effective translation from temporal logic to ATSQL that enables a user to write high-level queries which can be evaluated against a space-efficient representation of the database. A reverse translation, also provided in this paper, characterizes the expressive power of a syntactically defined subset of ATSQL queries.
Abstract-found: 1
Intro-found: 1
Reference: [AHV95] <author> S. Abiteboul, R. Hull, and V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1995. </year>
Reference-contexts: The presentation is based on an extension of the translation of relational calculus queries to relational algebra presented in <ref> [AHV95] </ref>. However, our approach can be analogously used in more complicated translations, e.g., [GT91]. <p> Thus it is easy to formulate "unsafe" queries in temporal logic that produce non-finitary answers or use quantification over the infinite universe of data values (similarly to relational calculus <ref> [AHV95] </ref>). To avoid these problems we introduce the notion of domain-independent temporal logic queries: Definition 3.4 Let ' be a FOTL query and D a temporal database. We define the active domain adom (D; ') to be the set of all data constants that appear in D and '. <p> The criterion is based on a modification of the criterion for the relational calculus queries <ref> [AHV95] </ref>: we treat the binary temporal connectives since and until as ^, and ignore the unary ones, 3; 1; 2; 0; 5, and 4: Definition 3.6 [Range restriction (rr).] Let ' be an arbitrary temporal query and F V (') the set of free variables in '. <p> By case analysis we can show that ' is not safe range (as none of the rules in Definition 3.13 is applicable by the assumption); a contradiction. 2 Similarly to <ref> [AHV95] </ref> the RANF TL rewriting terminates, as there are only finitely many subfor-mulas in the original query. Moreover, every safe range temporal query is domain independent: Lemma 3.16 Let ' be a safe-range temporal query. Then ' is domain independent. <p> It is translated to ATSQL by repeating the following two steps: 1. First the maximal non-temporal subformulas are translated to sequenced SQL queries; this can be done using a simple RANF T L to SQL translation (it can be patterned, e.g., after the RANF to Relational Algebra translation in <ref> [AHV95] </ref>). 2. The translations of the subformulas are combined using the translations of the temporal connectives defined in the next section. <p> is the translation of the temporal logic query ', and R ATSQL is the ATSQL variant of the result of the query. 3.5 Refinement and Optimization In Section 3.2 we have described only the simplest version of the translation; we used a direct temporal extension of the translation presented in <ref> [AHV95] </ref>. However, such a direct extension has several drawbacks. We address some of them in this section: Negation is pushed too deep during the SRNF T L phase. <p> Note, that this is a general problem with the conversion proposed in <ref> [AHV95] </ref> (and most of the other proposals) rather than with its temporal extension|our example indeed uses only pure first order logic.
Reference: [AHVdB96] <author> S. Abiteboul, L. Herr, and J. Van den Bussche. </author> <title> Temporal versus First-Order Logic to Query Temporal Databases. </title> <booktitle> In Proceedings of the 15th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 49-57, </pages> <year> 1996. </year>
Reference-contexts: The restriction to local queries is also critical. Pure ATSQL has the same expressive power as two-sorted first-order logic in which there is a separate sort for time. It has been recently shown <ref> [AHVdB96, TN96] </ref> that temporal logic is strictly less expressive than the above two-sorted logic. Thus, there can be no translation from ATSQL to temporal logic that works for all pure queries. 5 Summary We have established an exact correspondence between temporal logic and a syntactically defined subset of ATSQL. <p> In [Tom96] a translation from a point based two-sorted first-order logic to an interval based temporal query language was proposed. This translation could serve as a two-sorted first-order logic to ATSQL translation. There are two subtle points about this translation: * It generates non-local ATSQL queries. Indeed, the results <ref> [AHVdB96, TN96] </ref> show that there can not be a translation of the two-sorted first-order logic to local ATSQL queries (and views). * In general the generated query may be exponential in the size of the input query 7 .
Reference: [All83] <author> J. F. Allen. </author> <title> Maintaining Knowledge about Temporal Intervals. </title> <journal> Communications of the ACM, </journal> <volume> 16(11) </volume> <pages> 832-843, </pages> <year> 1983. </year>
Reference-contexts: To be consistent with SQL2, these relationships have a somewhat different meaning than the identically-named relationships in <ref> [All83] </ref>: P 1 = P 2 iff P 2 ^ P + 2 P 1 CONTAINS P 2 iff P 1 P 1 P + P 1 MEETS P 2 iff succ (P + 1 ) = P P 1 OVERLAPS P 2 iff P 1 P + 2 P + <p> It is easy to see that the above relationships can express all interval relationships of <ref> [All83] </ref> and thus all possible rela tionships between two periods. <p> The subformulas rooted by the temporal connectives are then translated to subqueries embedded into these templates. Mapping since and until Figure 4 graphically illustrates the semantics of since and until. We have listed all possible temporal relationships <ref> [All83] </ref> between the truth periods of two formulas A and B.
Reference: [BCST96] <author> M. H. Bohlen, J. Chomicki, R. T. Snodgrass, and D. Toman. </author> <title> Querying TSQL2 Databases with Temporal Logic. </title> <editor> In P. Apers, M. Bouzeghoub, and G. Gardarin, editors, </editor> <booktitle> Advances in Database Technology | EDBT'96, 5th International Conference on Extending Database Technology, volume 1057 of Lecture Notes in Computer Science, </booktitle> <pages> pages 325-341. </pages> <publisher> Springer, </publisher> <month> March </month> <year> 1996. </year>
Reference: [BJ96] <author> M. H. Bohlen and C. S. Jensen. </author> <title> A Seamless Integration of Time into SQL. </title> <journal> ACM Transactions on Database Systems, </journal> <year> 1996. </year>
Reference-contexts: The first direction is concerned with temporal extensions to practical query languages such as SQL, e.g., [GN93, NA93, Sar93]. The issues addressed include space-efficient storage, effective implementation techniques, and handling of large amounts of data. This direction of research includes ATSQL <ref> [BJ96] </ref> an integration of ideas from TSQL2 [Sno95] and ChronoLog [Boh94]. The second direction of research is concerned with defining high-level query languages with logical semantics, e.g., temporal logic [TC90, GM91, CCT94]. The advantages of using logic-based query languages come from their well-understood mathematical properties [GHR94]. <p> The paper is organized as follows: We start with a discussion of the basic framework in Section 2, including the syntax and semantics of temporal logic and ATSQL (in the case of ATSQL we introduce only constructs relevant to the development in this paper; for full description see <ref> [BJ96] </ref>). <p> However, the state-based semantics of temporal logic does not suggest an efficient implementation of such queries. An implementation taking advantage from a compact period-based representation of temporal databases promises much better performance. 2.2 ATSQL ATSQL <ref> [BJ96] </ref> is a further development of TSQL2: the consensus temporal extension of SQL-92. An early version of ATSQL has been proposed to the ISO international committee for standardization for incorporation into the SQL/Temporal standard and, therefore, we use it as our target temporal query language for our translation. ATSQL Databases. <p> SQL-92 queries preceded by the SEQUENCED VALID flag are evaluated relative to every snapshot of the temporal database; the results are then are collected in a temporal relation with timestamps corresponding to the evaluation point (cf. snapshot reducibility <ref> [BJ96] </ref>). 3. SQL-92 queries preceded by the NONSEQUENCED VALID flag: in this case the processing of the timestamps is completely controlled by the query, rather than by some implicit mechanism built-in the underlying DBMS.
Reference: [Boh94] <author> M. Bohlen. </author> <title> Managing Temporal Knowledge in Deductive Databases. </title> <type> PhD thesis, </type> <institution> Department fur Informatik, ETH Zurich, Switzerland, </institution> <year> 1994. </year>
Reference-contexts: The issues addressed include space-efficient storage, effective implementation techniques, and handling of large amounts of data. This direction of research includes ATSQL [BJ96] an integration of ideas from TSQL2 [Sno95] and ChronoLog <ref> [Boh94] </ref>. The second direction of research is concerned with defining high-level query languages with logical semantics, e.g., temporal logic [TC90, GM91, CCT94]. The advantages of using logic-based query languages come from their well-understood mathematical properties [GHR94]. The declarative character of these languages also allows the use of advanced optimization techniques.
Reference: [CC87] <author> J. Clifford and A. Croker. </author> <title> The Historical Relational Data Model (HRDM) and Algebra Based on Lifespans. </title> <booktitle> In Proceedings of the International Conference on Data Engineering, </booktitle> <pages> pages 528-537. </pages> <publisher> IEEE Computer Society, IEEE Computer Society Press, </publisher> <month> February </month> <year> 1987. </year>
Reference-contexts: Instead, most of the common proposals associate a concise description of the set of time instants at which a particular fact holds with the tuple representing such a fact. The description is commonly realized by a period 1 [NA93, Sar90, Sno87, Tan86] or a finite union of periods <ref> [CC87, Gad88, Sno95] </ref>.
Reference: [CCT94] <author> J. Clifford, A. Croker, and A. Tuzhilin. </author> <title> On Completeness of Historical Relational Query Languages. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(1) </volume> <pages> 64-116, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: This direction of research includes ATSQL [BJ96] an integration of ideas from TSQL2 [Sno95] and ChronoLog [Boh94]. The second direction of research is concerned with defining high-level query languages with logical semantics, e.g., temporal logic <ref> [TC90, GM91, CCT94] </ref>. The advantages of using logic-based query languages come from their well-understood mathematical properties [GHR94]. The declarative character of these languages also allows the use of advanced optimization techniques.
Reference: [Cho94] <author> J. Chomicki. </author> <title> Temporal Query Languages: a Survey. </title> <booktitle> Proceedings of the First International Conference on Temporal Logic, </booktitle> <pages> pages 506-534, </pages> <month> July </month> <year> 1994. </year> <note> 7 However, this may happen even in the calculus to algebra translation [AHV95]. 19 </note>
Reference-contexts: In particular, the transaction time, which relates when facts are stored in the database, is not considered. 2.1 Temporal logic Temporal logic is an abstract query language: a language defined with respect to the class of abstract temporal databases <ref> [Cho94] </ref>. An abstract temporal database, in turn, is a database which captures the formal semantics of a temporal database without considering any particular representation issues. It is possible to view an abstract temporal database in several different but equivalent ways. We choose here the timeslice view (called snapshot in [Cho94]) in <p> databases <ref> [Cho94] </ref>. An abstract temporal database, in turn, is a database which captures the formal semantics of a temporal database without considering any particular representation issues. It is possible to view an abstract temporal database in several different but equivalent ways. We choose here the timeslice view (called snapshot in [Cho94]) in which every time instant is associated with a (finite) set of facts that hold at it. <p> Example 2.1 Figure 1 presents an example of an abstract temporal database, viewed as a sequence of states. The database represents information about Eastern European history, modeling the independence of various countries <ref> [Cho94] </ref>. Each fact indicates an independent nation and its capital. This relation is used as a running example throughout the paper. <p> The query (indep (`P oland`; City) ^ City 6= `Cracow`) since indep (`P oland`; `Cracow`) returns the name of the city that superseded Cracow as Poland's capital and the years when this city was the capital. Example 2.4 Consider the query <ref> [Cho94, p.515] </ref> "list all countries that lost and regained independence" over the abstract temporal database shown in Figure 1.
Reference: [Cho95] <author> J. Chomicki. </author> <title> Efficient Checking of Temporal Integrity Constraints Using Bounded History Encoding. </title> <journal> ACM Transactions on Database Systems, </journal> <year> 1995. </year>
Reference-contexts: In addition, temporal logic has been also proposed as the language of choice for formulating temporal integrity constraints and triggers <ref> [Cho95, CT95, GL93, LS87, SW95] </ref>. The semantics of temporal logic queries is defined with respect to a temporal database: a time-instant indexed sequence of database states [GHR94]. However, for efficiency reasons we do not want to construct and store all the individual states explicitly.
Reference: [CT95] <author> J. Chomicki and D. Toman. </author> <title> Implementing Temporal Integrity Constraints Using an Active DBMS. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> August </month> <year> 1995. </year> <title> Early version in Proc. </title> <booktitle> 4th IEEE International Workshop on Research Issues in Data Engineering: Active Database Systems, </booktitle> <address> Houston, Texas, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: In addition, temporal logic has been also proposed as the language of choice for formulating temporal integrity constraints and triggers <ref> [Cho95, CT95, GL93, LS87, SW95] </ref>. The semantics of temporal logic queries is defined with respect to a temporal database: a time-instant indexed sequence of database states [GHR94]. However, for efficiency reasons we do not want to construct and store all the individual states explicitly.
Reference: [Gad88] <author> S. K. Gadia. </author> <title> A Homogeneous Relational Model and Query Languages for Temporal Databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(4) </volume> <pages> 418-448, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Instead, most of the common proposals associate a concise description of the set of time instants at which a particular fact holds with the tuple representing such a fact. The description is commonly realized by a period 1 [NA93, Sar90, Sno87, Tan86] or a finite union of periods <ref> [CC87, Gad88, Sno95] </ref>.
Reference: [GHR94] <author> D.M. Gabbay, I. Hodkinson, and M. Reynolds. </author> <title> Temporal Logic: Mathematical Foundations and Computational Aspects. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: The second direction of research is concerned with defining high-level query languages with logical semantics, e.g., temporal logic [TC90, GM91, CCT94]. The advantages of using logic-based query languages come from their well-understood mathematical properties <ref> [GHR94] </ref>. The declarative character of these languages also allows the use of advanced optimization techniques. <p> In addition, temporal logic has been also proposed as the language of choice for formulating temporal integrity constraints and triggers [Cho95, CT95, GL93, LS87, SW95]. The semantics of temporal logic queries is defined with respect to a temporal database: a time-instant indexed sequence of database states <ref> [GHR94] </ref>. However, for efficiency reasons we do not want to construct and store all the individual states explicitly. Instead, most of the common proposals associate a concise description of the set of time instants at which a particular fact holds with the tuple representing such a fact.
Reference: [GL93] <author> M. Gertz and U.W. Lipeck. </author> <title> Deriving Integrity Maintaining Triggers from Transition Graphs. </title> <booktitle> In Proceedings of the International Conference on Data Engineering, </booktitle> <year> 1993. </year>
Reference-contexts: In addition, temporal logic has been also proposed as the language of choice for formulating temporal integrity constraints and triggers <ref> [Cho95, CT95, GL93, LS87, SW95] </ref>. The semantics of temporal logic queries is defined with respect to a temporal database: a time-instant indexed sequence of database states [GHR94]. However, for efficiency reasons we do not want to construct and store all the individual states explicitly.
Reference: [GM91] <author> D. Gabbay and P. McBrien. </author> <title> Temporal Logic and Historical Databases. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1991. </year>
Reference-contexts: This direction of research includes ATSQL [BJ96] an integration of ideas from TSQL2 [Sno95] and ChronoLog [Boh94]. The second direction of research is concerned with defining high-level query languages with logical semantics, e.g., temporal logic <ref> [TC90, GM91, CCT94] </ref>. The advantages of using logic-based query languages come from their well-understood mathematical properties [GHR94]. The declarative character of these languages also allows the use of advanced optimization techniques.
Reference: [GN93] <author> S. K. Gadia and S. S. Nair. </author> <title> Temporal Databases: A Prelude to Parametric Data. </title> <editor> In A. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev, and R. T. Snodgrass, editors, </editor> <title> Temporal Databases: Theory, </title> <booktitle> Design, and Implementation, </booktitle> <pages> pages 28-66. </pages> <publisher> Ben-jamin/Cummings Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction In this paper, we bring together two research directions in temporal databases. The first direction is concerned with temporal extensions to practical query languages such as SQL, e.g., <ref> [GN93, NA93, Sar93] </ref>. The issues addressed include space-efficient storage, effective implementation techniques, and handling of large amounts of data. This direction of research includes ATSQL [BJ96] an integration of ideas from TSQL2 [Sno95] and ChronoLog [Boh94].
Reference: [GT91] <author> A. Van Gelder and R. W. Topor. </author> <title> Safety and Translation of Relational Calculus Queries. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 16(2) </volume> <pages> 235-278, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The presentation is based on an extension of the translation of relational calculus queries to relational algebra presented in [AHV95]. However, our approach can be analogously used in more complicated translations, e.g., <ref> [GT91] </ref>. <p> Note that this extension of the original criterion for relational calculus queries is the strongest possible: we map since and until to ^ and ignore the unary temporal connectives. To achieve better results we would have to start with a stronger criterion for the first order case, e.g., <ref> [GT91] </ref>. Lemma 3.7 Let ' be a domain-independent query. Then there is an equivalent safe range query. P r o o f: Every domain-independent query ' can be correctly evaluated using the active-domain semantics.
Reference: [JCE + 94] <author> C. S. Jensen, J. Clifford, R. Elmasri, S. K. Gadia, P. Hayes, and S. Jajodia. </author> <title> A Glossary of Temporal Database Concepts. </title> <booktitle> SIGMOD RECORD, </booktitle> <volume> 23(1) </volume> <pages> 52-64, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: We also assume a fixed time granularity. All the references to time in this paper represent the valid-time references capturing the relationship between individual time points and validity of facts in reality <ref> [JCE + 94] </ref>. In particular, the transaction time, which relates when facts are stored in the database, is not considered. 2.1 Temporal logic Temporal logic is an abstract query language: a language defined with respect to the class of abstract temporal databases [Cho94].
Reference: [Klu82] <author> A. Klug. </author> <title> Equivalence of Relational Algebra and Relational Calculus Query Languages Having Aggregate Functions. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 699-717, </pages> <year> 1982. </year>
Reference-contexts: as I can see). dave The following is a natural next question to ask: Is there a logical query language equivalent to full ATSQL? The lack of aggregates in temporal logic can be remedied by a syntactic extension of the language, along the lines of one proposed for relational calculus <ref> [Klu82] </ref>. The requirement of maximal periods is more fundamental. In fact, allowing noncoalesced periods calls for a temporal logic that is not point- but period-based. Thus in this case, there can be no translation from full ATSQL to the temporal logic discussed in this paper, even for local queries.
Reference: [LS87] <author> U. W. Lipeck and G. Saake. </author> <title> Monitoring Dynamic Integrity Constraints Based on Temporal Logic. </title> <journal> Information Systems, </journal> <volume> 12(3) </volume> <pages> 255-269, </pages> <year> 1987. </year>
Reference-contexts: In addition, temporal logic has been also proposed as the language of choice for formulating temporal integrity constraints and triggers <ref> [Cho95, CT95, GL93, LS87, SW95] </ref>. The semantics of temporal logic queries is defined with respect to a temporal database: a time-instant indexed sequence of database states [GHR94]. However, for efficiency reasons we do not want to construct and store all the individual states explicitly.
Reference: [MS93] <author> J. Melton and A. R. Simon. </author> <title> Understanding the new SQL: A Complete Guide. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, California, </address> <year> 1993. </year>
Reference-contexts: This assumption is fundamental for our translation of temporal logic queries to ATSQL to work correctly. ATSQL Queries. ATSQL extends the query language of SQL-92 <ref> [MS93] </ref>. The queries in this language come in three flavors: 1. SQL-92 queries (without any additional flags) are executed on the temporal database with respect to the current time instant (now). 2.
Reference: [NA93] <author> S. Navathe and R. Ahmed. </author> <title> Temporal Extensions to the Relational Model and SQL. </title> <editor> In A. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev, and R. T. Snodgrass, editors, </editor> <title> Temporal Databases: Theory, </title> <booktitle> Design, and Implementation, </booktitle> <pages> pages 92-109. </pages> <publisher> Ben-jamin/Cummings Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction In this paper, we bring together two research directions in temporal databases. The first direction is concerned with temporal extensions to practical query languages such as SQL, e.g., <ref> [GN93, NA93, Sar93] </ref>. The issues addressed include space-efficient storage, effective implementation techniques, and handling of large amounts of data. This direction of research includes ATSQL [BJ96] an integration of ideas from TSQL2 [Sno95] and ChronoLog [Boh94]. <p> Instead, most of the common proposals associate a concise description of the set of time instants at which a particular fact holds with the tuple representing such a fact. The description is commonly realized by a period 1 <ref> [NA93, Sar90, Sno87, Tan86] </ref> or a finite union of periods [CC87, Gad88, Sno95].
Reference: [Sar90] <author> N. Sarda. </author> <title> Extensions to SQL for Historical Databases. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(2) </volume> <pages> 220-230, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Instead, most of the common proposals associate a concise description of the set of time instants at which a particular fact holds with the tuple representing such a fact. The description is commonly realized by a period 1 <ref> [NA93, Sar90, Sno87, Tan86] </ref> or a finite union of periods [CC87, Gad88, Sno95].
Reference: [Sar93] <author> N. Sarda. HSQL: </author> <title> A Historical Query Language. </title> <editor> In A. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev, and R. T. Snodgrass, editors, </editor> <title> Temporal Databases: Theory, Design, and Implementation. </title> <publisher> Benjamin/Cummings Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction In this paper, we bring together two research directions in temporal databases. The first direction is concerned with temporal extensions to practical query languages such as SQL, e.g., <ref> [GN93, NA93, Sar93] </ref>. The issues addressed include space-efficient storage, effective implementation techniques, and handling of large amounts of data. This direction of research includes ATSQL [BJ96] an integration of ideas from TSQL2 [Sno95] and ChronoLog [Boh94].
Reference: [Sno87] <author> R. T. Snodgrass. </author> <title> The Temporal Query Language TQuel. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2) </volume> <pages> 247-298, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Instead, most of the common proposals associate a concise description of the set of time instants at which a particular fact holds with the tuple representing such a fact. The description is commonly realized by a period 1 <ref> [NA93, Sar90, Sno87, Tan86] </ref> or a finite union of periods [CC87, Gad88, Sno95].
Reference: [Sno95] <author> R. T. Snodgrass. </author> <title> The TSQL2 Temporal Query Language. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1995. </year>
Reference-contexts: The first direction is concerned with temporal extensions to practical query languages such as SQL, e.g., [GN93, NA93, Sar93]. The issues addressed include space-efficient storage, effective implementation techniques, and handling of large amounts of data. This direction of research includes ATSQL [BJ96] an integration of ideas from TSQL2 <ref> [Sno95] </ref> and ChronoLog [Boh94]. The second direction of research is concerned with defining high-level query languages with logical semantics, e.g., temporal logic [TC90, GM91, CCT94]. The advantages of using logic-based query languages come from their well-understood mathematical properties [GHR94]. <p> Instead, most of the common proposals associate a concise description of the set of time instants at which a particular fact holds with the tuple representing such a fact. The description is commonly realized by a period 1 [NA93, Sar90, Sno87, Tan86] or a finite union of periods <ref> [CC87, Gad88, Sno95] </ref>.
Reference: [SW95] <author> A.P. Sistla and O. Wolfson. </author> <title> Temporal Triggers in Active Databases. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <note> 1995. To appear. 20 </note>
Reference-contexts: In addition, temporal logic has been also proposed as the language of choice for formulating temporal integrity constraints and triggers <ref> [Cho95, CT95, GL93, LS87, SW95] </ref>. The semantics of temporal logic queries is defined with respect to a temporal database: a time-instant indexed sequence of database states [GHR94]. However, for efficiency reasons we do not want to construct and store all the individual states explicitly.
Reference: [Tan86] <author> A. U. Tansel. </author> <title> Adding Time Dimension to Relational Model and Extending Relational Algebra. </title> <journal> Information Systems, </journal> <volume> 11(4) </volume> <pages> 343-355, </pages> <year> 1986. </year>
Reference-contexts: Instead, most of the common proposals associate a concise description of the set of time instants at which a particular fact holds with the tuple representing such a fact. The description is commonly realized by a period 1 <ref> [NA93, Sar90, Sno87, Tan86] </ref> or a finite union of periods [CC87, Gad88, Sno95].
Reference: [TC90] <author> A. Tuzhilin and J. Clifford. </author> <title> A Temporal Relational Algebra as a Basis for Temporal Relational Completeness. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1990. </year>
Reference-contexts: This direction of research includes ATSQL [BJ96] an integration of ideas from TSQL2 [Sno95] and ChronoLog [Boh94]. The second direction of research is concerned with defining high-level query languages with logical semantics, e.g., temporal logic <ref> [TC90, GM91, CCT94] </ref>. The advantages of using logic-based query languages come from their well-understood mathematical properties [GHR94]. The declarative character of these languages also allows the use of advanced optimization techniques.
Reference: [TN96] <author> D. Toman and D. Niwinski. </author> <title> First-Order Queries over Temporal Databases Inexpressible in Temporal Logic. </title> <editor> In P. Apers, M. Bouzeghoub, and G. Gardarin, editors, </editor> <booktitle> Advances in Database Technology | EDBT'96, 5th International Conference on Extending Database Technology, volume 1057 of Lecture Notes in Computer Science, </booktitle> <pages> pages 307-324. </pages> <publisher> Springer, </publisher> <month> March </month> <year> 1996. </year>
Reference-contexts: The restriction to local queries is also critical. Pure ATSQL has the same expressive power as two-sorted first-order logic in which there is a separate sort for time. It has been recently shown <ref> [AHVdB96, TN96] </ref> that temporal logic is strictly less expressive than the above two-sorted logic. Thus, there can be no translation from ATSQL to temporal logic that works for all pure queries. 5 Summary We have established an exact correspondence between temporal logic and a syntactically defined subset of ATSQL. <p> In [Tom96] a translation from a point based two-sorted first-order logic to an interval based temporal query language was proposed. This translation could serve as a two-sorted first-order logic to ATSQL translation. There are two subtle points about this translation: * It generates non-local ATSQL queries. Indeed, the results <ref> [AHVdB96, TN96] </ref> show that there can not be a translation of the two-sorted first-order logic to local ATSQL queries (and views). * In general the generated query may be exponential in the size of the input query 7 .
Reference: [Tom96] <author> D. Toman. </author> <title> Point-based vs Interval-based Temporal Query Languages. </title> <booktitle> In Proceedings of the 15th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 58-67, </pages> <year> 1996. </year>
Reference-contexts: Finally, a translation from two-sorted first-order logic to ATSQL, which is of clear practical interest, is considerably more complicated than the translation from temporal logic to ATSQL given in the present paper. In <ref> [Tom96] </ref> a translation from a point based two-sorted first-order logic to an interval based temporal query language was proposed. This translation could serve as a two-sorted first-order logic to ATSQL translation. There are two subtle points about this translation: * It generates non-local ATSQL queries.
Reference: [Tom97] <author> D. Toman. </author> <title> Point-based Temporal Extension of SQL. </title> <institution> TR-CS-362, University of Toronto, </institution> <address> http://www.cs.utoronto.ca/ david/papers-sqltp.ps.Z, </address> <year> 1997. </year>
Reference-contexts: Indeed, the results [AHVdB96, TN96] show that there can not be a translation of the two-sorted first-order logic to local ATSQL queries (and views). * In general the generated query may be exponential in the size of the input query 7 . In <ref> [Tom97] </ref> we defined a syntactic criterion, that guarantees only polynomial (linear) increase in size for a subclass of the two-sorted first-order logic queries. Moreover, this subclass contains the first-order temporal logic.
Reference: [Wut91] <author> B. Wuthrich. </author> <title> Large Deductive Databases with Constraints. </title> <type> PhD thesis, </type> <institution> Department fur Informatik, ETH Zurich, Switzerland, </institution> <year> 1991. </year> <month> 21 </month>
References-found: 33

