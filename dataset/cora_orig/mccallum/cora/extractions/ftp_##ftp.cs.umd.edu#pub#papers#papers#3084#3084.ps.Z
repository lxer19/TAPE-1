URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3084/3084.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: E-mail: min@cs.umd.edu, nick@cs.umd.edu  
Title: Adaptive Database Buffer Allocation Using Query Feedback  
Author: ChungMin Melvin Chen Nicholas Roussopoulos 
Address: College Park  
Affiliation: Institute for Advanced Computer Studies and Department of Computer Science University of Maryland,  
Date: June 1993  
Pubnum: UMIACS-TR-93-49  CS-TR-3084  
Abstract: In this paper, we propose the concept of using query execution feedback for improving database buffer management. A query feedback model which adaptively quantifies the page fault characteristics of all query access patterns including sequential, looping and most importantly random, is defined. Based on this model, a load control and a marginal gain ratio buffer allocation scheme are developed. Simulation experiments show that the proposed method is consistently better than the previous methods and in most cases, it significantly outperforms all other methods for random access reference patterns.
Abstract-found: 1
Intro-found: 1
Reference: [BDT83] <author> D. Bitton, D.J. DeWitt, and C. Turbyfill. </author> <title> Benchmarking database systems, a systematic approach. </title> <booktitle> In Procs. of 9th VLDB, </booktitle> <year> 1983. </year>
Reference-contexts: The reference strings are collected from executing a number of queries against the Wisconsin Benchmark database <ref> [BDT83] </ref> on ADMS. Each base relation contains 10,000 tuples spanning over 2,500 pages. The number of participating relations in each query varying from 1 to 3. Table 3 shows the access patterns for each of the queries we chose.
Reference: [Bel66] <author> L. Belady. </author> <title> A study of replacement algorithms for a virtual-storage computer. </title> <journal> IBM Systems Journal, </journal> <volume> 5(2) </volume> <pages> 78-101, </pages> <year> 1966. </year>
Reference-contexts: It can be seen that the adaptability of MGR reduces the page faults. We also plot the faulting curves for MGR and MG-x-y for different buffer sizes, assuming that the above adjusted characteristic record is used for MGR. The optimal replacement algorithm OPT <ref> [Bel66] </ref>, which replaces the page that won't be used in the longest future, is also graphed for comparison. Figure 5.(a) compares the number of page faults at different buffer sizes.
Reference: [CD85] <author> H. Chou and D. DeWitt. </author> <title> An evaluation of buffer management strategies for relational database systems. </title> <booktitle> In Proceeding of the 11th Intl. Conf. on VLDB, </booktitle> <pages> pages 127-141, </pages> <year> 1985. </year>
Reference-contexts: Early works [Rei76, Kap80, EH84] accomplished this goal by adapting conventional allocation and replacement strategies for virtual memory system to database management systems. Recently, another class of algorithms <ref> [CD85, SS86, NFS91] </ref> based on the prediction of page access patterns exhibited by queries were proposed. <p> This paper also appears in Proceedings of the 19th International Conference on Very Large Data Bases, 1993. 1 buffer management allocation/replacement policy admission algorithms sequential looping random policy [l min ; l max ], rpl [l min ; l max ], rpl [l min ; l max ], rpl DBMIN <ref> [CD85] </ref> [1; 1], [t; t], MRU [1; 1], RAN, P MG-x-y [NFS91] [1; 1], [x% fl t; t], MRU [1; y], RAN l min A predictive load control [FNS91] [1; 1], [f (load); t], MRU [f (load); b yao ], RAN P Table 1: Buffer Management Algorithms Although algorithms based on <p> However, because of the less page reference locality found in database systems than that found in virtual memory systems [RR76, EH84], and due to the lack of embedded load control mechanism, these conventional strategies do not perform satisfactorily and might cause severe system throughput degradation when buffer congestion occurs <ref> [CD85] </ref>. The above techniques failed to take advantage of specific page reference behavior exhibited by database algorithms such as nested-loop joins, hash joins, and etc. This was corrected in another group of buffer management algorithms [SS82, SS86, CD85, NFS91, FNS91] based on the page reference characteristics exhibited by database queries. <p> The above techniques failed to take advantage of specific page reference behavior exhibited by database algorithms such as nested-loop joins, hash joins, and etc. This was corrected in another group of buffer management algorithms <ref> [SS82, SS86, CD85, NFS91, FNS91] </ref> based on the page reference characteristics exhibited by database queries. In this class of algorithms, load control and buffer allocation are incorporated. <p> In [SS82, SS86], the authors suggested that in order to run a query efficiently, a minimum number of buffers, called hot set size, must be provided during execution. The approach of the hot set based algorithm is improved and refined in following papers <ref> [CD85, NFS91, FNS91] </ref> based on the classification of reference patters. They are summarized in Table 1, where a sequential pattern accesses a sequence of distinct pages, a looping pattern accesses a set of pages iteratively, and anything else is called a random pattern. <p> For all algorithms, MRU (Most-Recently-Used) replacement is adopted for looping pattern, RAN replacement|which randomly selects a page for replacement|is used for random pattern, and no explicit replacement strategy is needed for sequential pattern since only one buffer page is allocated. For the algorithm DBMIN proposed in <ref> [CD85] </ref>, each pattern is allocated with a fix number of buffers (called locality set), this is reflected by l min = l max for all patterns. For looping pattern, the locality set size t is the number of distinct pages referenced in the loop. <p> The simulation is similar to the one used in <ref> [CD85, NFS91] </ref> which simulates a closed system with concurrent queries competing for buffers. For the purpose of baseline comparison, LRU is selected as a representative since according to [EH84, CD85], it makes no significant performance difference from the other conventional strategies such as Working-Set and Clock. <p> The simulation is similar to the one used in [CD85, NFS91] which simulates a closed system with concurrent queries competing for buffers. For the purpose of baseline comparison, LRU is selected as a representative since according to <ref> [EH84, CD85] </ref>, it makes no significant performance difference from the other conventional strategies such as Working-Set and Clock. Two schemes, local LRU (LLRU) and global LRU (GLRU) are simulated. Local LRU maintains an LRU list for each relation of the concurrent queries.
Reference: [Che92] <author> C. Chen. </author> <title> Adaptive query optimization. </title> <type> Thesis Proposal, </type> <institution> Department of Computer Science, University of Maryland, College Park, </institution> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: A simple load control mechanism is also adopted in the algorithm proposed here. However, the algorithm is basically an allocation-oriented approach as opposed to a load-control-oriented one. Although adaptive replacement strategies based on (limited) reference history have recently been explored for database systems <ref> [OOW93, Che92] </ref>, in this paper we assume LRU unless a looping pattern is detected in which case we use MRU. Simulation results have shown that the feedback is advantageous. <p> In the case of insufficient stack size or the strategy is not LRU, we can either simply set s R;B = C (R) or estimate/compute its value based on some other techniques (refer to <ref> [Che92] </ref> for more detail). 3.3 Use and Adaptation of Faulting Characteristics In this subsection, we discuss how the faulting characteristics can be used to differentiate the access patterns, and show how they can be adaptively adjusted, over recurring query executions, to reflect more informed faulting behaviors. <p> Intuitively, b 0 is a 5 In [NFS91], the expected marginal gain for looping patterns is derived, whose value is a constant depending on the reference string. The formula we give here computes the exact values instead of expected value, the detail of the derivations can be found in <ref> [Che92] </ref>. 10 more informed feedback than b if b 0 is closer to the size beyond which the residual gain becomes smaller than the pre-defined threshold .
Reference: [EH84] <author> W. Effelsberg and T. Haerder. </author> <title> Principles of database buffer management. </title> <journal> ACM TODS, </journal> <volume> 9(4) </volume> <pages> 560-595, </pages> <year> 1984. </year>
Reference-contexts: 1 Introduction The topic of buffer management in database management systems has been long investigated in the past. The goal of such research is to develop a buffer manager suitable for the database system in order to enhance the system performance. Early works <ref> [Rei76, Kap80, EH84] </ref> accomplished this goal by adapting conventional allocation and replacement strategies for virtual memory system to database management systems. Recently, another class of algorithms [CD85, SS86, NFS91] based on the prediction of page access patterns exhibited by queries were proposed. <p> Therefore, there are three tasks conducted by the manager: load control, buffer allocation, and buffer replacement. The first class of database buffer management algorithms <ref> [Rei76, SB76, Tue76, Kap80, EH84] </ref> used variations of traditional replacement techniques such as LRU (Least-Recently-Used) and Working-Set directly applied to the database buffer pool. <p> However, because of the less page reference locality found in database systems than that found in virtual memory systems <ref> [RR76, EH84] </ref>, and due to the lack of embedded load control mechanism, these conventional strategies do not perform satisfactorily and might cause severe system throughput degradation when buffer congestion occurs [CD85]. <p> The simulation is similar to the one used in [CD85, NFS91] which simulates a closed system with concurrent queries competing for buffers. For the purpose of baseline comparison, LRU is selected as a representative since according to <ref> [EH84, CD85] </ref>, it makes no significant performance difference from the other conventional strategies such as Working-Set and Clock. Two schemes, local LRU (LLRU) and global LRU (GLRU) are simulated. Local LRU maintains an LRU list for each relation of the concurrent queries.
Reference: [FNS91] <author> C. Faloutsos, R. T. Ng, and T. Sellis. </author> <title> Predictive load control for flexible buffer allocation. </title> <booktitle> In Proceeding of the 17th Intl. Conf. on VLDB, </booktitle> <pages> pages 265-274, </pages> <year> 1991. </year>
Reference-contexts: [l min ; l max ], rpl [l min ; l max ], rpl [l min ; l max ], rpl DBMIN [CD85] [1; 1], [t; t], MRU [1; 1], RAN, P MG-x-y [NFS91] [1; 1], [x% fl t; t], MRU [1; y], RAN l min A predictive load control <ref> [FNS91] </ref> [1; 1], [f (load); t], MRU [f (load); b yao ], RAN P Table 1: Buffer Management Algorithms Although algorithms based on prediction of access patterns capture some of the behavior of database queries, they still have some major deficiencies. <p> The above techniques failed to take advantage of specific page reference behavior exhibited by database algorithms such as nested-loop joins, hash joins, and etc. This was corrected in another group of buffer management algorithms <ref> [SS82, SS86, CD85, NFS91, FNS91] </ref> based on the page reference characteristics exhibited by database queries. In this class of algorithms, load control and buffer allocation are incorporated. <p> In [SS82, SS86], the authors suggested that in order to run a query efficiently, a minimum number of buffers, called hot set size, must be provided during execution. The approach of the hot set based algorithm is improved and refined in following papers <ref> [CD85, NFS91, FNS91] </ref> based on the classification of reference patters. They are summarized in Table 1, where a sequential pattern accesses a sequence of distinct pages, a looping pattern accesses a set of pages iteratively, and anything else is called a random pattern. <p> However, keeping x and y as global constants for all queries may not be adequate, since different reference strings, though of same reference patterns, can have completely different faulting behaviors. In a more recent paper by the same authors <ref> [FNS91] </ref>, a class of predictive load control algorithms were proposed. Subject to the current buffer availability, an incoming query is activated only if doing so, it will result in better expected system performance. <p> After a query is admitted, MG-x-y allocates as many buffers as possible to each relation, but not exceeding the specified upper bound. See Table 1 for detail. Among the class of predictive load control algorithms <ref> [FNS91] </ref>, the algorithm with the best overall performance, called EDU, is chosen as a representative in our simulation. Subject to the current available buffers, EDU activates a query only if it will result in better effective disk utilization than the one of the current state.
Reference: [Kap80] <author> J. Kaplan. </author> <title> Buffer management policies in a database environment. </title> <type> Master's thesis, </type> <institution> University of California, Berkeley, </institution> <year> 1980. </year>
Reference-contexts: 1 Introduction The topic of buffer management in database management systems has been long investigated in the past. The goal of such research is to develop a buffer manager suitable for the database system in order to enhance the system performance. Early works <ref> [Rei76, Kap80, EH84] </ref> accomplished this goal by adapting conventional allocation and replacement strategies for virtual memory system to database management systems. Recently, another class of algorithms [CD85, SS86, NFS91] based on the prediction of page access patterns exhibited by queries were proposed. <p> Therefore, there are three tasks conducted by the manager: load control, buffer allocation, and buffer replacement. The first class of database buffer management algorithms <ref> [Rei76, SB76, Tue76, Kap80, EH84] </ref> used variations of traditional replacement techniques such as LRU (Least-Recently-Used) and Working-Set directly applied to the database buffer pool.
Reference: [M + 70] <author> R. Mattson et al. </author> <title> Evaluation techniques for storage hierarchies. </title> <journal> IBM Systems Journal, </journal> <volume> 9(2) </volume> <pages> 78-117, </pages> <year> 1970. </year>
Reference-contexts: In general, there is no precise mathematical formula to express the page faults as a function of buffer sizes, even if the values of C (R) and jRj are known. Though for certain class of replacement algorithms <ref> [M + 70] </ref>, the faulting function on any reference string could be obtained by tracing the string only once, the overhead of computing and maintaining the number of buffer faults at every buffer size is large. For this reason, we introduce a model to characterize the faulting function. <p> Its exact value in general is not easy to calculate, simply tracing the reference string repeatedly for all buffer sizes to find the saturated size is impractical. However, for LRU replacement, its saturated sizes can be found efficiently. According to <ref> [M + 70] </ref>, LRU is a special member of a class of replacement algorithms called stack algorithms.
Reference: [NFS91] <author> R. T. Ng, C. Faloutsos, and T. Sellis. </author> <title> Flexible buffer allocation based on marginal gains. </title> <booktitle> In Proceeding of 1991 ACM-SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 387-396, </pages> <year> 1991. </year>
Reference-contexts: Early works [Rei76, Kap80, EH84] accomplished this goal by adapting conventional allocation and replacement strategies for virtual memory system to database management systems. Recently, another class of algorithms <ref> [CD85, SS86, NFS91] </ref> based on the prediction of page access patterns exhibited by queries were proposed. <p> on Very Large Data Bases, 1993. 1 buffer management allocation/replacement policy admission algorithms sequential looping random policy [l min ; l max ], rpl [l min ; l max ], rpl [l min ; l max ], rpl DBMIN [CD85] [1; 1], [t; t], MRU [1; 1], RAN, P MG-x-y <ref> [NFS91] </ref> [1; 1], [x% fl t; t], MRU [1; y], RAN l min A predictive load control [FNS91] [1; 1], [f (load); t], MRU [f (load); b yao ], RAN P Table 1: Buffer Management Algorithms Although algorithms based on prediction of access patterns capture some of the behavior of database <p> The above techniques failed to take advantage of specific page reference behavior exhibited by database algorithms such as nested-loop joins, hash joins, and etc. This was corrected in another group of buffer management algorithms <ref> [SS82, SS86, CD85, NFS91, FNS91] </ref> based on the page reference characteristics exhibited by database queries. In this class of algorithms, load control and buffer allocation are incorporated. <p> In [SS82, SS86], the authors suggested that in order to run a query efficiently, a minimum number of buffers, called hot set size, must be provided during execution. The approach of the hot set based algorithm is improved and refined in following papers <ref> [CD85, NFS91, FNS91] </ref> based on the classification of reference patters. They are summarized in Table 1, where a sequential pattern accesses a sequence of distinct pages, a looping pattern accesses a set of pages iteratively, and anything else is called a random pattern. <p> For example, a looping pattern query with locality set size of 100 will not be admitted to execution even if there are 90 buffer pages available. A more flexible allocation algorithm MG-x-y was proposed in <ref> [NFS91] </ref>. MG-x-y is similar to DBMIN except on the load control decision and hence the number of buffers allocated. <p> We call r b 0 the residual gain at b 0 . is a constant threshold set for all reference strings. Intuitively, b 0 is a 5 In <ref> [NFS91] </ref>, the expected marginal gain for looping patterns is derived, whose value is a constant depending on the reference string. <p> The simulation is similar to the one used in <ref> [CD85, NFS91] </ref> which simulates a closed system with concurrent queries competing for buffers. For the purpose of baseline comparison, LRU is selected as a representative since according to [EH84, CD85], it makes no significant performance difference from the other conventional strategies such as Working-Set and Clock. <p> There is no load control for global LRU, i.e., a query is admitted immediately as it arrives; for 15 local LRU, a query is admitted only when there are still available buffers. Since MG-x-y has been shown to outperform DBMIN using a flexible allocation <ref> [NFS91] </ref>, we do not include DBMIN in the comparison. By trial and error, we have adjusted the values of x and y in MG-x-y so that it reached its best overall performance.
Reference: [OOW93] <author> E. J. O'Neil, P. E. O'Neil, and G. Weikum. </author> <title> The LRU-K page replacement algorithm for database disk buffering. </title> <booktitle> In Proceeding of 1993 ACM-SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 297-306, </pages> <year> 1993. </year>
Reference-contexts: A simple load control mechanism is also adopted in the algorithm proposed here. However, the algorithm is basically an allocation-oriented approach as opposed to a load-control-oriented one. Although adaptive replacement strategies based on (limited) reference history have recently been explored for database systems <ref> [OOW93, Che92] </ref>, in this paper we assume LRU unless a looping pattern is detected in which case we use MRU. Simulation results have shown that the feedback is advantageous.
Reference: [Rei76] <author> A. Reiter. </author> <title> A study of buffer management policies for data management systems. </title> <type> Technical Report TR-1619, </type> <institution> Mathematics Research Center, University of Wisconsin-Madison, </institution> <year> 1976. </year>
Reference-contexts: 1 Introduction The topic of buffer management in database management systems has been long investigated in the past. The goal of such research is to develop a buffer manager suitable for the database system in order to enhance the system performance. Early works <ref> [Rei76, Kap80, EH84] </ref> accomplished this goal by adapting conventional allocation and replacement strategies for virtual memory system to database management systems. Recently, another class of algorithms [CD85, SS86, NFS91] based on the prediction of page access patterns exhibited by queries were proposed. <p> Therefore, there are three tasks conducted by the manager: load control, buffer allocation, and buffer replacement. The first class of database buffer management algorithms <ref> [Rei76, SB76, Tue76, Kap80, EH84] </ref> used variations of traditional replacement techniques such as LRU (Least-Recently-Used) and Working-Set directly applied to the database buffer pool.
Reference: [RES93] <author> N. Roussopoulos, N. Economou, and A. Stamenas. ADMS: </author> <title> A testbed for incremental access methods. </title> <journal> To appear in IEEE Trans. on Knowledge and Data Engineering, </journal> <year> 1993. </year> <month> 22 </month>
Reference-contexts: For example, for 10k1, the characteristic record gets 6 ADMS, the Advanced Database Management System, is a database management system developed at the Department of Computer Science, University of Maryland, College Park, <ref> [RES93] </ref>. 12 Execution 1, A = 50 b f (b) r b fl g c s jRj C (R) 10k2 17 879 6.98 17 7.06 123 125 992 125 total 2727 Execution 2, A = 100 b f (b) r b fl g c s 10k2 71 455 6.11 71 fl
Reference: [RR76] <author> J. Rodriguez-Rosell. </author> <title> Empirical data reference behavior in data base systems. </title> <journal> IEEE Computer, </journal> <volume> 9(11), </volume> <month> Nov. </month> <year> 1976. </year>
Reference-contexts: However, because of the less page reference locality found in database systems than that found in virtual memory systems <ref> [RR76, EH84] </ref>, and due to the lack of embedded load control mechanism, these conventional strategies do not perform satisfactorily and might cause severe system throughput degradation when buffer congestion occurs [CD85].
Reference: [SB76] <editor> S.W. Sherman and R.S. </editor> <title> Brice. Performance of a database manager in a virtual memory system. </title> <journal> ACM TODS, </journal> <volume> 1(4), </volume> <year> 1976. </year>
Reference-contexts: Therefore, there are three tasks conducted by the manager: load control, buffer allocation, and buffer replacement. The first class of database buffer management algorithms <ref> [Rei76, SB76, Tue76, Kap80, EH84] </ref> used variations of traditional replacement techniques such as LRU (Least-Recently-Used) and Working-Set directly applied to the database buffer pool.
Reference: [SS82] <author> G. Sacca and M. Schkolnick. </author> <title> A mechanism for managing the buffer pool in a relational database system using the hot set model. </title> <booktitle> In Proceeding of the 8th Intl. Conf. on VLDB, </booktitle> <pages> pages 257-262, </pages> <year> 1982. </year>
Reference-contexts: The above techniques failed to take advantage of specific page reference behavior exhibited by database algorithms such as nested-loop joins, hash joins, and etc. This was corrected in another group of buffer management algorithms <ref> [SS82, SS86, CD85, NFS91, FNS91] </ref> based on the page reference characteristics exhibited by database queries. In this class of algorithms, load control and buffer allocation are incorporated. <p> This was corrected in another group of buffer management algorithms [SS82, SS86, CD85, NFS91, FNS91] based on the page reference characteristics exhibited by database queries. In this class of algorithms, load control and buffer allocation are incorporated. In <ref> [SS82, SS86] </ref>, the authors suggested that in order to run a query efficiently, a minimum number of buffers, called hot set size, must be provided during execution.
Reference: [SS86] <author> G. Sacca and M. Schkolnick. </author> <title> Buffer management in relational database systems. </title> <journal> ACM TODS, </journal> <volume> 11(4) </volume> <pages> 474-498, </pages> <year> 1986. </year>
Reference-contexts: Early works [Rei76, Kap80, EH84] accomplished this goal by adapting conventional allocation and replacement strategies for virtual memory system to database management systems. Recently, another class of algorithms <ref> [CD85, SS86, NFS91] </ref> based on the prediction of page access patterns exhibited by queries were proposed. <p> The above techniques failed to take advantage of specific page reference behavior exhibited by database algorithms such as nested-loop joins, hash joins, and etc. This was corrected in another group of buffer management algorithms <ref> [SS82, SS86, CD85, NFS91, FNS91] </ref> based on the page reference characteristics exhibited by database queries. In this class of algorithms, load control and buffer allocation are incorporated. <p> This was corrected in another group of buffer management algorithms [SS82, SS86, CD85, NFS91, FNS91] based on the page reference characteristics exhibited by database queries. In this class of algorithms, load control and buffer allocation are incorporated. In <ref> [SS82, SS86] </ref>, the authors suggested that in order to run a query efficiently, a minimum number of buffers, called hot set size, must be provided during execution.
Reference: [Tue76] <author> W. Tuel. </author> <title> An analysis of buffer paging in virtual storage systems. </title> <journal> IBM Journal of Research and Development, </journal> <year> 1976. </year>
Reference-contexts: Therefore, there are three tasks conducted by the manager: load control, buffer allocation, and buffer replacement. The first class of database buffer management algorithms <ref> [Rei76, SB76, Tue76, Kap80, EH84] </ref> used variations of traditional replacement techniques such as LRU (Least-Recently-Used) and Working-Set directly applied to the database buffer pool.
Reference: [Yao77] <author> S.B. Yao. </author> <title> Approximating block accesses in database organizations. </title> <journal> Communications of ACM, </journal> <volume> 20(4), </volume> <year> 1977. </year> <month> 23 </month>
Reference-contexts: For random pattern, l max = b yao is the expected number of distinct pages referenced based on Yao's formula <ref> [Yao77] </ref>. This approach was shown to be more adaptive to different query loads than MG-x-y. However, the computation of b yao and the expected system performance is based on the assumption of uniform page access 2 , which in general is not true 3 .
References-found: 18

