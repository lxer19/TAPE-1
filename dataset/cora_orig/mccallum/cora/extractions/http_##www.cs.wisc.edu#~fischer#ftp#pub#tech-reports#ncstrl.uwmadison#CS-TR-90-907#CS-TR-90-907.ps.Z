URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-90-907/CS-TR-90-907.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-90-907/
Root-URL: http://www.cs.wisc.edu
Title: A Study of Three Alternative Workstation-Server Architectures for Object Oriented Database Systems  
Author: David J. DeWitt Philippe Futtersack David Maier Fernando Velez Authors' affiliations: D. DeWitt, GIP Altair. D. Maier, 
Note: currently on sabbatical with  currently on sabbatical with GIP Altair. P. Futtersack and F. Velez, GIP Altair, France, This work was partially supported by a research grant from The Graduate  (D. DeWitt) and by National Science Foundation grant IRI-8920642 (D. Maier).  
Affiliation: Computer Sciences Department, University of Wisconsin,  Department of Computer Science and Engineering, Oregon Graduate Institute for Science and Technology,  School of the University of Wisconsin  
Abstract-found: 0
Intro-found: 1
Reference: [Ande90] <author> T.L. Anderson, A.H. Berre, M. Mallison, H. Porter, B. Schneider. </author> <title> The hypermodel benchmark, </title> <booktitle> Proc. of the 2nd Intl. Conf. on Extending Data Base Technology, </booktitle> <address> Venice, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: The Altair Complex-Object Benchmark 4.1. Introduction To evaluate the performance of the alternative workstation-server architectures, the obvious alternatives were to use an existing benchmark or to design a benchmark specific for this evaluation. In terms of existing benchmarks, the Sun [Catt88] and Hypermodel <ref> [Ande90] </ref> benchmarks appeared to be the most reasonable alternatives. We opted against the Sun benchmark because it forms complex objects by choosing random objects to relate to one another. <p> In real object-oriented databases, objects frequently reference one another in either the form of aggregation relationships (e.g., a part and its component sub-parts) or M:N relationships between each other (e.g., suppliers and parts) <ref> [Ande90] </ref>. <p> In particular, we do not see a means to provide such a capability that could provide automatic bundling for most of the queries in either the Hypermodel <ref> [Ande90] </ref> and Sun [Catt88, Catt90] benchmarks short of processing the queries on the server itself. Note that a prefetching scheme (based on transitivity or some unit of clustering) will only help with the object-server if the prefetched objects are passed to the workstation in groups, rather than individually.
Reference: [Astr76] <author> M.H. Astrahan, et al. </author> <title> System R: A relational database management system, </title> <journal> ACM TODS 1:2, </journal> <month> June </month> <year> 1976. </year>
Reference-contexts: Harnessing the power of this technology will not be easy, as such systems pose many difficult engineering challenges. If one reflects on the commercialization of relational database systems, it took a full ten years to turn the first prototypes (INGRES and System R in 1976 <ref> [Ston76, Astr76] </ref>) into products that conservative customers willingly used. Given the relative complexity of object-oriented database systems, it is likely to take ten years before the technology of object-oriented database systems becomes solidified.
Reference: [Atki89] <author> M. Atkinson, F. Bancilhon, D. DeWitt, K. Dittrich, D. Maier, S. Zdonik. </author> <title> The object-oriented database system manifesto, </title> <booktitle> Proc. of the First Conf. on Deductive and Object-Oriented Databases, </booktitle> <address> Kyoto, Japan, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: With an OODBMS, a fair amount of an application is incorporated into the methods of the classes of which objects are instances. In addition, while OODBMSs also provide support for associative queries over sets of objects <ref> [Atki89] </ref>, applications employing an OODBMS typically have a large navigational component. One might simply run all applications programs on a centralized server.
Reference: [Banc88] <author> F. Bancilhon, G. Barbedette, V. Benzaken, C. Delobel, S. Gamerman, C. Lecluse, P. Pfeffer, P. Richard, F. Velez. </author> <title> The design and implementation of O2, an object-oriented database system, </title> <booktitle> In Advances in Object-Oriented Databases: Proc. of the 2nd Intl. Workshop on Object-Oriented Database Systems, </booktitle> <editor> K. Dittrich ed., </editor> <booktitle> Lecture Notes in Computer Science 334, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <month> 33 </month>
Reference-contexts: One alternative is the object server approach, so named because the unit of transfer between the server and the workstation is an object. In this architecture the server understands the concept of an object and is capable of applying methods to objects. The V1.0 prototype of O 2 <ref> [Banc88, Deux90] </ref>, the Orion 1 prototype [Kim90], and some pre-release versions of GemStone [Cope84] employ an object-server architecture. An alternative is the page server approach. In this design, the server deals only with pages and does not understand the semantics of objects. Thus, it cannot apply methods to objects.
Reference: [Bret89] <author> B. Bretl, et. al., </author> <title> The GemStone data management system. In Object-Oriented Concepts, Databases and Applications, </title> <editor> W. Kim, F. Lochovsky eds., </editor> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference: [Care89] <author> M. Carey et al., </author> <title> The Exodus extensible DBMS project: an overview. </title> <booktitle> In [Zdon89]. </booktitle>
Reference-contexts: Thus, it cannot apply methods to objects. In addition to providing the storage and retrieval of database pages, the server also provides concurrency control and recovery services for the database software running on the workstations. This architecture is currently being used by the ObServer [Horn87] and Exodus <ref> [Care89] </ref> prototypes. The third design represents a further simplification of the page-server architecture in which the workstations use a remote file service, such as NFS [Sun88], to read and write database pages directly. As with the page-server design, the server in this architecture provides concurrency control and recovery services.
Reference: [Catt88] <author> R. Cattell. </author> <title> Object-oriented DBMS performance measurement, </title> <booktitle> In Advances in Object-Oriented Databases: Proc. of the 2nd Intl. Workshop on Object-Oriented Database Systems, </booktitle> <editor> K. Dittrich ed., </editor> <booktitle> Lecture Notes in Computer Science 334, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: The Altair Complex-Object Benchmark 4.1. Introduction To evaluate the performance of the alternative workstation-server architectures, the obvious alternatives were to use an existing benchmark or to design a benchmark specific for this evaluation. In terms of existing benchmarks, the Sun <ref> [Catt88] </ref> and Hypermodel [Ande90] benchmarks appeared to be the most reasonable alternatives. We opted against the Sun benchmark because it forms complex objects by choosing random objects to relate to one another. <p> In particular, we do not see a means to provide such a capability that could provide automatic bundling for most of the queries in either the Hypermodel [Ande90] and Sun <ref> [Catt88, Catt90] </ref> benchmarks short of processing the queries on the server itself. Note that a prefetching scheme (based on transitivity or some unit of clustering) will only help with the object-server if the prefetched objects are passed to the workstation in groups, rather than individually.
Reference: [Catt90] <author> R. Cattell and J. </author> <title> Skeen Engineering Database Benchmark, </title> <note> submitted for publication, ACM TODS, </note> <month> May, </month> <year> 1990. </year>
Reference-contexts: Since one measurement we wanted was the impact of the degree of clustering of the components of a complex object on the performance of the alternative designs, the Sun benchmark was not appropriate. Recently, a new version of the Sun Benchmark has been designed <ref> [Catt90] </ref> which would have been much better suited for our purposes. Initially, the Hypermodel benchmark appeared a better match to our objectives because it provides both clustered and non-clustered groupings of objects. The problem with this benchmark is that it consists of a very large number of queries. <p> In particular, we do not see a means to provide such a capability that could provide automatic bundling for most of the queries in either the Hypermodel [Ande90] and Sun <ref> [Catt88, Catt90] </ref> benchmarks short of processing the queries on the server itself. Note that a prefetching scheme (based on transitivity or some unit of clustering) will only help with the object-server if the prefetched objects are passed to the workstation in groups, rather than individually.
Reference: [Chan89] <author> E.E. Chang, R.H. Katz. </author> <title> Exploiting inheritance and structure semantics for effective clustering and buffering in an object-oriented DBMS, </title> <booktitle> Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <address> Portland, OR, </address> <month> June 89. </month>
Reference-contexts: Of the expected 44 records reads, 17 are at level 6. Our selectivity factor on this query (and also the next) is related to the structural density parameter of Chang and Katz <ref> [Chan89] </ref>. Our selectivity of 0.8 appears to be in the middle of the range of structural densities actually observed in traces of access patterns from a suite of VLSI tools.
Reference: [Chou85] <author> H.-T. Chou, D.J. DeWitt, R.H. Katz, A.C. Klug. </author> <title> Design and implementation of the Wisconsin Storage System, </title> <journal> SoftwarePractice & Experience 15:10, </journal> <month> October </month> <year> 1985. </year>
Reference-contexts: Prototyping The Workstation-Server Architectures 3.1. Introduction This section describes our prototypes of the three alternative architectures. The basis for each of these prototypes was a stripped-down, single-user version of WiSS <ref> [Chou85] </ref>. We elected to use WiSS because it is currently hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 2 Actually not only is the updated block flushed to disk but also the inode (a Unix file system data structure) which points to the updated block. Thus, each data page write actually involves two disk I/Os.
Reference: [Cope84] <author> G. Copeland, D. Maier. </author> <title> Making Smalltalk a database system, </title> <booktitle> Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <month> June </month> <year> 1984. </year>
Reference-contexts: In this architecture the server understands the concept of an object and is capable of applying methods to objects. The V1.0 prototype of O 2 [Banc88, Deux90], the Orion 1 prototype [Kim90], and some pre-release versions of GemStone <ref> [Cope84] </ref> employ an object-server architecture. An alternative is the page server approach. In this design, the server deals only with pages and does not understand the semantics of objects. Thus, it cannot apply methods to objects.
Reference: [Depp87] <author> U. Deppisch and V. Obermeit, </author> <title> Tight Database Cooperation in a Server-Workstation Environment, </title> <booktitle> Proc. 7th International Conference on Distributed Computing Systems, </booktitle> <month> June </month> <year> 1987. </year>
Reference-contexts: The AIM-P database project also investigated the workstation-server linkage <ref> [Depp87] </ref>. Their high-level view is of two independent database systems taking advantage of a common physical format to speed transfers in a check-out model for long transactions, which differs from our view of partitioning the functionality of a single database system across two machines.
Reference: [Deux90] <editor> O. Deux et al. </editor> <title> The story of O2, </title> <journal> IEEE Transactions on Data and Knowledge Engineering, </journal> <month> March </month> <year> 1990. </year>
Reference-contexts: One alternative is the object server approach, so named because the unit of transfer between the server and the workstation is an object. In this architecture the server understands the concept of an object and is capable of applying methods to objects. The V1.0 prototype of O 2 <ref> [Banc88, Deux90] </ref>, the Orion 1 prototype [Kim90], and some pre-release versions of GemStone [Cope84] employ an object-server architecture. An alternative is the page server approach. In this design, the server deals only with pages and does not understand the semantics of objects. Thus, it cannot apply methods to objects. <p> The seven records that form each complex object are organized in the form of binary tree of depth 2, as shown in hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 4 The design of this benchmark is influenced by the data model of the O 2 database system <ref> [Deux90] </ref>, which distinguishes between values and objects. In an O 2 database, an object may have a complex structure without forcing each sub-component to be an object. Thus, it made sense for us to distinguish inter-object and intra-object references and treat them differently.
Reference: [Gray76] <author> J.N. Gray, et al. </author> <title> Granularity of locks and degrees of consistency in a shared data base. In Modeling in Data Base Management Systems, </title> <editor> G.M. Nijssen, ed., </editor> <publisher> North-Holland, </publisher> <year> 1976. </year>
Reference-contexts: A second disadvantage is that object-level locking may be difficult to implement. Consider what happens if object-level locking is employed and two workstations, A and B, update two different objects on the same data page. If classical locking protocols <ref> [Gray76] </ref> are used, both transactions will set IX locks on the shared page and X locks on the individual objects.
Reference: [Hagm86] <author> R.B. Hagmann, D. Ferrari, </author> <title> Performance analysis of several back-end database architectures, </title> <journal> ACM TODS 11:1, </journal> <month> Mar. </month> <year> 1986. </year>
Reference-contexts: This behavior is even more noticeable with the random update and all queries tests. 6. Related Work The previous work most similar to ours is a study by Hagmann and Ferrari <ref> [Hagm86] </ref>. They split the functionality of the university version of the INGRES system in various ways between two machines and measured CPU, disk and network usage.
Reference: [Horn87] <author> M.F. Hornick, S.B. Zdonik. </author> <title> A shared, segmented memory for an object-oriented database, </title> <journal> ACM TOOIS 5:1, </journal> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: Thus, it cannot apply methods to objects. In addition to providing the storage and retrieval of database pages, the server also provides concurrency control and recovery services for the database software running on the workstations. This architecture is currently being used by the ObServer <ref> [Horn87] </ref> and Exodus [Care89] prototypes. The third design represents a further simplification of the page-server architecture in which the workstations use a remote file service, such as NFS [Sun88], to read and write database pages directly.
Reference: [Kim90] <author> W. Kim, et al. </author> <title> Architecture of the ORION next generation database system, </title> <journal> IEEE Transactions on Data and Knowledge Engineering, </journal> <month> March </month> <year> 1990. </year>
Reference-contexts: In this architecture the server understands the concept of an object and is capable of applying methods to objects. The V1.0 prototype of O 2 [Banc88, Deux90], the Orion 1 prototype <ref> [Kim90] </ref>, and some pre-release versions of GemStone [Cope84] employ an object-server architecture. An alternative is the page server approach. In this design, the server deals only with pages and does not understand the semantics of objects. Thus, it cannot apply methods to objects. <p> The Orion-1 prototype instead executes the method on both the workstation and server <ref> [Kim90] </ref>. Since this strategy can result in duplicate copies of an object in the result, a complicated (and probably expensive) postprocessing step of duplicate elimination is required. There are also several minor problems that occur with the object-server architecture.
Reference: [Kung81] <author> H. Kung, J. Robinson, </author> <title> On optimistic methods for concurrency control, </title> <journal> ACM TODS 6:2, </journal> <month> June </month> <year> 1981. </year>
Reference: [Lind79] <author> B. Lindsay, et. al. </author> <title> Notes on distributed database systems, </title> <type> Technical Report RJ2571, </type> <institution> IBM Research Laboratory, </institution> <address> San Jose, California, </address> <month> July </month> <year> 1979. </year>
Reference: [Marq89] <author> J.A. Marques, P. Guedes. </author> <title> Extending the operating system to support an object-oriented environment, </title> <booktitle> Proc. OOPSLA '89, </booktitle> <address> New Orleans, </address> <month> Oct. 89. </month>
Reference-contexts: Similar architectural issues also arise in the design of distributed, object-oriented operating systems. In the Comandos <ref> [Marq89] </ref> system, for example, the default is for the Storage System to respond with single objects when the Virtual Object Memory has an object fault. However, logical clusters of objects can be declared, and the whole cluster is delivered when any object in it is requested. 7.
Reference: [Sun88] <institution> Network Programming Guide, Sun Microsystems, Part Number: 800-1779-10, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: This architecture is currently being used by the ObServer [Horn87] and Exodus [Care89] prototypes. The third design represents a further simplification of the page-server architecture in which the workstations use a remote file service, such as NFS <ref> [Sun88] </ref>, to read and write database pages directly. As with the page-server design, the server in this architecture provides concurrency control and recovery services. The current version of GemStone uses this architecture when configured for a workstation-server environment. We term this architecture the file server approach. <p> In Section 5, we examine how clustering affects the performance of this design. 2.4. The File-Server Architecture The final workstation-server architecture is a variation of the page-server design in which the workstation software uses a remote file service such as NFS <ref> [Sun88] </ref> to read and write database pages directly. Figure 3 shows such an architecture. There are several reasons why such an architecture is attractive. First, it provides many of the advantages of the page-server architecture, such as minimizing the overhead placed on the workstation by the server. <p> To provide the interprocessor communication necessary to implement such a system, we used the Sun RPC tools, including Rpcgen <ref> [Sun88] </ref>, which automatically generates the necessary procedure stubs given a data file that describes the message formats and the procedure names with which you wish to communicate remotely.
Reference: [Stam84] <author> J.W. Stamos. </author> <title> Static grouping of small objects to enhance performance of a paged virtual memory, </title> <journal> ACM TOCS 2:2, </journal> <month> May </month> <year> 1984. </year>
Reference-contexts: However, in spite of the differences between our model and theirs, the AIM-P techniques for concurrency control and update of auxiliary access structures might work in our context. Our results are similar to those obtained by Stamos <ref> [Stam84] </ref> who simulated the behavior of different memory architectures in a non-distributed, single-user object manager, using different strategies for clustering.
Reference: [Ston76] <author> M. Stonebraker, et al. </author> <title> The design and implementation of INGRES, </title> <journal> ACM TODS 1:3, </journal> <month> September </month> <year> 1986. </year>
Reference-contexts: Harnessing the power of this technology will not be easy, as such systems pose many difficult engineering challenges. If one reflects on the commercialization of relational database systems, it took a full ten years to turn the first prototypes (INGRES and System R in 1976 <ref> [Ston76, Astr76] </ref>) into products that conservative customers willingly used. Given the relative complexity of object-oriented database systems, it is likely to take ten years before the technology of object-oriented database systems becomes solidified.
Reference: [Vele89] <author> F. Velez, G. Bernard, V. Darnis. </author> <title> The O2 object manager: an overview, </title> <booktitle> Proc. VLDB XV, </booktitle> <address> Amsterdam, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: This ability is most valuable when there is no index on the collection that can be used by the selection operation. In addition, one can balance the system workload by moving work from the workstation to the server <ref> [Vele89] </ref>. Another advantage is that this architecture simplifies the design of the con-currency control subsystem as the server knows exactly which objects are accessed by each application. Hence, concurrency control can be almost completely centralized in the server. Furthermore, the implementation of object-level locking is straightforward.
Reference: [Zdon89] <author> S.B. Zdonik, D. Maier. </author> <title> Readings in Object-Oriented Database Systems, Introduction: Fundamentals of object-oriented databases, </title> <publisher> Morgan-Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
References-found: 25

