URL: http://www.cs.sunysb.edu/~juliana/tab-par-plilp.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~juliana/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: fjuliana,ruihu,tswift,warreng@cs.sunysb.edu  
Title: Exploiting Parallelism in Tabled Evaluations  
Author: Juliana Freire, Rui Hu, Terrance Swift, David S. Warren 
Address: NY 11794-4400  
Affiliation: Department of Computer Science State University of New York at Stony Brook Stony Brook,  
Abstract: This paper addresses general issues involved in parallelizing tabled evaluations by introducing a model of shared-memory parallelism which we call table-parallelism, and by comparing it to traditional models of parallelizing SLD. A basic architecture for supporting table-parallelism in the framework of the SLG-WAM[14] is also presented, along with an algorithm for detecting termination of subcomputations.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> F. Banchilhon and R. Ramakrishnan. </author> <title> An amateur's introduction to recursive query processing strategies. </title> <booktitle> In Proc. of SIGMOD 1986 Conf., </booktitle> <pages> pages 16-52. </pages> <publisher> ACM, </publisher> <year> 1986. </year>
Reference: 2. <author> R. Bol and L. Degerstedt. </author> <title> Tabulated resolution for the well-founded semantics. </title> <booktitle> In Proc. ILPS'93 Workshop on Programming with Logic Databases. </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Substantiation for this claim stems both from the asymptotic results of [12] and the experimental results of [15]. Tabling is also be relevant for computing the well-founded semantics: besides SLG, well-founded ordered search [13] and the tabulated resolution of <ref> [2] </ref> also use tabling. While nearly all of these approaches are sequential, there is a natural parallelism inherent in these evaluation methods which we call table-parallelism.
Reference: 3. <author> W. Chen, T. Swift, and D.S. Warren. </author> <title> Efficient implementation of general logical queries. </title> <journal> J. Logic Programming. </journal> <note> To Appear. </note>
Reference-contexts: Even without negation SLD is susceptible to infinite loops and redundant subcomputations, making it unacceptable for deductive databases. The latter deficiency, that of repeating subcomputations, has given rise to several systems which table subcomputations: OLDT [16], SLD-AL [18], and SLG <ref> [4, 3] </ref> are three tabling methods which have been implemented. At an abstract level, systems which use magic evaluation can also be thought of as tabling systems. Substantiation for this claim stems both from the asymptotic results of [12] and the experimental results of [15]. <p> Whenever the system fails over the leader of an SCC, it is provable that each subgoal inside the component is completed and all answers have been generated (details can be found in <ref> [3] </ref>). The strategy outlined above is unsuitable for parallel SLG, since active nodes for a particular tabled predicated might be in different threads.
Reference: 4. <author> W. Chen and D. S. Warren. </author> <title> Query evaluation under the well-founded semantics. </title> <booktitle> In Proc. of 12th PODS, </booktitle> <pages> pages 168-179, </pages> <year> 1993. </year>
Reference-contexts: Even without negation SLD is susceptible to infinite loops and redundant subcomputations, making it unacceptable for deductive databases. The latter deficiency, that of repeating subcomputations, has given rise to several systems which table subcomputations: OLDT [16], SLD-AL [18], and SLG <ref> [4, 3] </ref> are three tabling methods which have been implemented. At an abstract level, systems which use magic evaluation can also be thought of as tabling systems. Substantiation for this claim stems both from the asymptotic results of [12] and the experimental results of [15]. <p> SLG forest program clauses. By using answer resolution in this manner, rather than repeatedly using program clause resolution as in SLD, SLG avoids looping and thus terminates for programs with finite models <ref> [4] </ref>. SLG has an efficient partial implementation in the SLG-WAM of XSB 2 , which currently is restricted to apply to modularly stratified programs.
Reference: 5. <author> M. Codish and B. Demoen. </author> <title> Analysing logic programs using 'prop'-ositional logic programs and a magic wand. </title> <booktitle> In Proc. of the Int'l Symp. on Logic Programming, </booktitle> <pages> pages 114-130, </pages> <year> 1993. </year>
Reference-contexts: In terms of practical programs, the mixture of SLD and tabling has proven useful for program analysis [7] over flat domains <ref> [5] </ref>, and for the Unification Factoring compiler optimization [6]. While implementation has so far been sequential, both of these algorithms contain bottom-up subcomputations that are amenable to table-parallelism, along with top-down computations amenable to traditional SLD parallelism.
Reference: 6. <author> S. Dawson, C. R. Ramakrishnan, I. V. Ramakrishnan, K. Sagonas, S. Skiena, T. Swift, and D. S. Warren. </author> <title> Unification factoring for efficient execution of logic programs. </title> <booktitle> In Proc. of the 22nd Symp. on Principles of Programming Languages. ACM, </booktitle> <year> 1995. </year>
Reference-contexts: In terms of practical programs, the mixture of SLD and tabling has proven useful for program analysis [7] over flat domains [5], and for the Unification Factoring compiler optimization <ref> [6] </ref>. While implementation has so far been sequential, both of these algorithms contain bottom-up subcomputations that are amenable to table-parallelism, along with top-down computations amenable to traditional SLD parallelism.
Reference: 7. <author> S. Dawson, C.R. Ramakrishnan, and D.S. Warren. </author> <title> Using XSB for abstract interpretation. </title> <booktitle> In Special Workshop on Abstract Interpretation, </booktitle> <year> 1995. </year> <note> Eliat, Israel. To Appear. </note>
Reference-contexts: In terms of practical programs, the mixture of SLD and tabling has proven useful for program analysis <ref> [7] </ref> over flat domains [5], and for the Unification Factoring compiler optimization [6]. While implementation has so far been sequential, both of these algorithms contain bottom-up subcomputations that are amenable to table-parallelism, along with top-down computations amenable to traditional SLD parallelism.
Reference: 8. <author> E.W. Dijkstra, W.H.J Feijen, and A.J.M. van Gasteren. </author> <title> Derivation of a termination detection algorithm for distributed computations. </title> <journal> Information Processing Letters, </journal> <pages> pages 217 - 219, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: In order to detect completion, we use a variation of Dijkstra's <ref> [8] </ref> distributed termination detection algorithm which allows multiple maximal SCCs to be completed independently of one another 6 . In this section, we provide an overview of a completion detection algorithm 7 . Fig. 5. Call Dependency Graphs Completion detection is split into leader detection and termination detection. <p> The leader will wrongly assume that r k is done, and it will incorrectly complete. Following the model of <ref> [8] </ref>, we address this problem using a ColorF lag for each tabled subgoal. The ColorF lag indicates that a node in the SCC may have generated new answers after another node was checked as completed by the leader.
Reference: 9. <author> J. Freire, R. Hu, T. Swift, and D.S. Warren. </author> <title> Exploiting parallelism in tabled evaluations. </title> <type> Technical report, </type> <institution> SUNY at Stony Brook, </institution> <year> 1995. </year> <note> Full version available at http://www.cs.sunysb.edu/~sbprolog. </note>
Reference-contexts: A computation needs to maintain the following invariants in order to correctly complete subgoals. 6 The main difference between our algorithm and Dijkstra's is that we must allow leaders to change dynamically to account for the dynamic nature of SCCs. 7 Full details are available in <ref> [9] </ref>. Invariant 4.1 (StateFlag) The StateF lag is done for a given subgoal iff it is performing no answer or program clause resolution (i.e. doing no work). <p> Given a formalization of a parallel tabled evaluation as a whole, and not just of its completion algorithm, it can be proven that the synchronization required to complete tables causes neither deadlock nor starvation (this formalization is provided in the full version of the paper <ref> [9] </ref>). We now turn to the description of how the operations of Section 3 can be modified to implement table-parallelism. 5 Implementation Framework The instruction-level changes needed to parallelize the SLG-WAM are discussed below.
Reference: 10. <author> M. Hermenegildo and F. Rossi. </author> <title> On the correctness and efficiency of independent and-parallelism in logic programs. </title> <editor> In N. </editor> <booktitle> Amer. Conf. on Logic Programming., </booktitle> <year> 1989. </year>
Reference-contexts: Note that the search space for the program using table-parallelism will be no greater than for the program using or-parallelism, and may terminate in cases where the or-parallel program will not. Fig. 4. And-parallelism in SLG Folding can be used to emulate Independent And-Parallelism (see e.g. <ref> [10] </ref>). Consider the following goal: :- q (X),p (X,Y),r (X,Z). Using independence analysis, we could simulate and-parallelism in parallel SLG, by a program transformation as in Fig. 4, declaring and pr/3, p/2 and r/2 as tabled.
Reference: 11. <author> M. Hermenegildo and F. Rossi. </author> <title> Non-strict independent and-parallelism. </title> <booktitle> In Logic Programming: Proc of the 5th Int'l. Conf., </booktitle> <pages> pages 237-252, </pages> <year> 1990. </year>
Reference-contexts: As an extension of this example, suppose the goal :-p (X),q (X), and predicates p/1 and q/1 fulfill the conditions of non-strict independence as formulated in <ref> [11] </ref>.
Reference: 12. <author> H. Seki. </author> <title> On the power of Alexander templates. </title> <booktitle> In Proc. of 8th PODS, </booktitle> <pages> pages 150-159. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: At an abstract level, systems which use magic evaluation can also be thought of as tabling systems. Substantiation for this claim stems both from the asymptotic results of <ref> [12] </ref> and the experimental results of [15]. Tabling is also be relevant for computing the well-founded semantics: besides SLG, well-founded ordered search [13] and the tabulated resolution of [2] also use tabling.
Reference: 13. <author> P. Stuckey and S. Sudarshan. </author> <title> Well-founded ordered search. </title> <booktitle> In 13th conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 161-172, </pages> <year> 1993. </year>
Reference-contexts: Substantiation for this claim stems both from the asymptotic results of [12] and the experimental results of [15]. Tabling is also be relevant for computing the well-founded semantics: besides SLG, well-founded ordered search <ref> [13] </ref> and the tabulated resolution of [2] also use tabling. While nearly all of these approaches are sequential, there is a natural parallelism inherent in these evaluation methods which we call table-parallelism.
Reference: 14. <author> T. Swift and D. S. Warren. </author> <title> An abstract machine for SLG resolution: definite programs. </title> <booktitle> In Proceedings of the Symposium on Logic Programming, </booktitle> <pages> pages 633-654, </pages> <year> 1994. </year>
Reference-contexts: We describe and prove the correctness of a parallel completion algorithm which detects termination of subcomputations, allowing a great deal of con currency between subcomputations. In the framework of the SLG-WAM <ref> [14] </ref> , we present the extensions to tabling operations necessary to implement table-parallelism. 2 A brief overview of SLG SLG evaluates programs by keeping a table of answers to subgoals, and resolving repeated subgoals against answer clauses from the table rather than against Fig. 2. SLG forest program clauses. <p> Using a completion algorithm for early detection of completed SCCs, trees for a component can be disposed as soon as they are completely evaluated. At the engine level, the sequential SLG-WAM <ref> [14] </ref> makes several changes to the WAM in order to implement SLG. One change, which the parallel model will exploit, is the use of failure continuations to return answers to active nodes. <p> Since the changes mainly involve adding concurrency features to tabling operations, and since SLG-WAM instructions generally correspond to primitive tabling operations, a detailed knowledge of the SLG-WAM in not required to understand this section. For further elaboration, SLG-WAM instructions for definite programs have been presented in <ref> [14] </ref>. Changes occur in the following stages of the tabling process: In the Tabled Subgoal Call operation; In the New Answer operation, when adding an answer for a tabled subgoal; In the Completion operation. Note that the Answer Return operation of Section 3 is not affected by par-allelization.
Reference: 15. <author> T. Swift and D. S. Warren. </author> <title> Analysis of sequential SLG evaluation. </title> <booktitle> In Proceedings of the Symposium on Logic Programming, </booktitle> <pages> pages 219-238, </pages> <year> 1994. </year>
Reference-contexts: At an abstract level, systems which use magic evaluation can also be thought of as tabling systems. Substantiation for this claim stems both from the asymptotic results of [12] and the experimental results of <ref> [15] </ref>. Tabling is also be relevant for computing the well-founded semantics: besides SLG, well-founded ordered search [13] and the tabulated resolution of [2] also use tabling. While nearly all of these approaches are sequential, there is a natural parallelism inherent in these evaluation methods which we call table-parallelism. <p> However, the termination algorithm, and its associated flags would allow detection of fixpoint of an SCC. Indeed, by keeping in mind the well-known similarities between tabling and magic evaluation (see e.g. <ref> [15] </ref>) table-parallelism can also be seen as a way to parallelize database queries that may include recursion. In our implementation framework, only three elements are shared: the table itself, the completion table, and the subgoal dependency list.
Reference: 16. <author> H. Tamaki and T. Sato. </author> <title> OLDT resolution with tabulation. </title> <booktitle> In Third Int'l Conf. on Logic Programming, </booktitle> <pages> pages 84-98, </pages> <year> 1986. </year>
Reference-contexts: Even without negation SLD is susceptible to infinite loops and redundant subcomputations, making it unacceptable for deductive databases. The latter deficiency, that of repeating subcomputations, has given rise to several systems which table subcomputations: OLDT <ref> [16] </ref>, SLD-AL [18], and SLG [4, 3] are three tabling methods which have been implemented. At an abstract level, systems which use magic evaluation can also be thought of as tabling systems. Substantiation for this claim stems both from the asymptotic results of [12] and the experimental results of [15]. <p> differs from more traditional models, consider first that at Subgoal Call a tabling system must determine whether a subgoal is new to an evaluation or not: whether to create a generator node for program clause resolution or 3 This is similar to the multistage depth-first strategy proposed for OLDT in <ref> [16] </ref>. an active node for answer clause resolution. In order to make this decision, the subgoal must be traversed.
Reference: 17. <author> J. D. Ullman. </author> <title> Flux, sorting, and supercomputer organization for AI applications. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 1 </volume> <pages> 133-151, </pages> <year> 1984. </year>
Reference-contexts: In our implementation framework, only three elements are shared: the table itself, the completion table, and the subgoal dependency list. If the table itself were distributed using techniques as those in <ref> [17] </ref> and if the completion algorithms were distributed, then a model of distributed table-parallelism could be formulated which would serve as a general mechanism for distributed data queries.
Reference: 18. <author> L. Vieille. </author> <title> Recursive query processing: The power of logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 1-53, </pages> <year> 1989. </year>
Reference-contexts: Even without negation SLD is susceptible to infinite loops and redundant subcomputations, making it unacceptable for deductive databases. The latter deficiency, that of repeating subcomputations, has given rise to several systems which table subcomputations: OLDT [16], SLD-AL <ref> [18] </ref>, and SLG [4, 3] are three tabling methods which have been implemented. At an abstract level, systems which use magic evaluation can also be thought of as tabling systems. Substantiation for this claim stems both from the asymptotic results of [12] and the experimental results of [15].
Reference: 19. <author> D.H.D. Warren. </author> <title> An abstract Prolog instruction set. </title> <type> Technical report, </type> <institution> SRI, </institution> <year> 1983. </year>
Reference-contexts: The SLG-WAM has been shown to compute in-memory deductive database queries about an order of magnitude faster than current set-at-a-time methods, and to compute Prolog queries with little loss in efficiency over the WAM <ref> [19] </ref>. An SLG evaluation can be modelled by an SLG-forest which grows dynamically as predicates are called. Whenever a tabled subgoal S is called for the first time, it becomes the root of a subtree in the forest.
Reference: 20. <author> D.H.D. Warren. </author> <title> Or-parallel models of Prolog. </title> <booktitle> In Proceedings of the International Conference on Theory and Practice of Software Development. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Bindings are not shared between SLG trees in this model, so resolutions for separate trees can be performed in parallel. While the copying of a subgoal each time a thread is created was a drawback of the Abstract Model <ref> [20] </ref>, the copying does not add a significant overhead for a parallel tabling system over its sequential counterpart.
References-found: 20

