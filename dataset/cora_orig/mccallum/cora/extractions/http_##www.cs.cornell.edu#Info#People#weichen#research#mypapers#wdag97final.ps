URL: http://www.cs.cornell.edu/Info/People/weichen/research/mypapers/wdag97final.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/weichen/resume.htm
Root-URL: 
Email: aguilera,weichen,sam@cs.cornell.edu  
Title: Heartbeat: A Timeout-Free Failure Detector for Quiescent Reliable Communication  
Author: Marcos Kawazoe Aguilera Wei Chen Sam Toueg 
Address: Ithaca NY 14853-7501, USA  
Affiliation: Cornell University, Computer Science Department,  
Abstract: We study the problem of achieving reliable communication with quiescent algorithms (i.e., algorithms that eventually stop sending messages) in asynchronous systems with process crashes and lossy links. We first show that it is impossible to solve this problem without failure detectors. We then show how to solve it using a new failure detector, called heartbeat. In contrast to previous failure detectors that have been used to circumvent impossibility results, the heartbeat failure detector is implementable, and its implementation does not use timeouts. These results have wide applicability: they can be used to transform many existing algorithms that tolerate only process crashes into quiescent algorithms that tolerate both process crashes and message losses. This can be applied to consensus, atomic broadcast, k-set agreement, atomic commitment, etc. The heartbeat failure detector is novel: besides being implementable without timeouts, it does not output lists of suspects as typical failure detectors do. If we restrict failure detectors to output only lists of suspects, quiescent reliable communication requires 3P [2], which is not implementable. Combined with the results of this paper, this shows that traditional failure detectors that output only lists of suspects have fundamental limitations.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. K. Aguilera, W. Chen, and S. Toueg. Heartbeat: </author> <title> a timeout-free failure detector for quiescent reliable communication. </title> <type> Technical Report 97-1631, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> May </month> <year> 1997. </year>
Reference-contexts: In Section 11, we mention a generalization of our results for the case where the network may partition. A brief discussion of protocol quiescence versus protocol termination concludes the paper. All proofs are omitted here due to space limitations. They are provided in <ref> [1] </ref>. 4 Model We consider asynchronous message-passing distributed systems in which there are no timing assumptions. In particular, we make no assumptions on the time it takes to deliver a message, or on relative process speeds. <p> An algorithm implements C if it implements some D 2 C. 5 Quiescent Reliable Communication In this paper, we consider quasi reliable send and receive and reliable broadcast, because these communication primitives are sufficient to solve many problems (see Section 10.1). The full version of this paper <ref> [1] </ref> also considers stronger types of communication primitives, namely, reliable send and receive, and uniform reliable broadcast. 5.1 Quasi Reliable Send and Receive Consider any two distinct processes s and r. <p> These fields make every message unique. We say that q delivers message m if q returns from the invocation of deliver (m). Primitives broadcast and deliver satisfy the following properties [22]: 6 A stronger property, called No Loss, is used to define reliable send and receive <ref> [1] </ref>. 7 A quiescent implementation is allowed to send a finite number of messages even if no SEND s;r is invoked at all (e.g., some messages may be sent as part of an initialization phase). Validity: If a correct process broadcasts a message m, then it eventually delivers m.
Reference: 2. <author> M. K. Aguilera, W. Chen, and S. Toueg. </author> <title> On the weakest failure detector for quiescent reliable communication. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: Note that this algorithm is quiescent: eventually no process sends or receives messages. In <ref> [2] </ref>, Aguilera et al. show that among all failure detectors that output lists of suspects, 3P is the weakest one that can be used to solve the above problem. Unfortunately, 3P is not implementable in asynchronous systems with process crashes (this would violate a known impossibility result [18, 12]). <p> HB can be used to solve the problem of quiescent reliable communication and it is implementable, but its counters are unbounded. Can we solve this problem using a failure detector that is both implementable and has bounded output? <ref> [2] </ref> proves that the answer is no: The weakest failure detector with bounded output that can be used to solve quiescent reliable communication is 3P . Thus, the difference between HB, whose output is unbounded, and existing failure detectors, whose output is bounded, is more than skin deep. <p> Thus, the difference between HB, whose output is unbounded, and existing failure detectors, whose output is bounded, is more than skin deep. The results in this paper combined with those of <ref> [2] </ref>, show that failure detectors with bounded output (including those that output lists of processes) are restricted in power and/or applicability. 3 Outline of the Results We focus on two types of reliable communication mechanisms: quasi reliable send and receive, and reliable broadcast. <p> It can also be used to extend the results of [6]. 4. HB is novel: it is implementable without timeouts, and it does not output lists of suspects as typical failure detectors do [5, 12, 20, 21, 24, 27]. The results of this paper, combined with those in <ref> [2] </ref>, show that lists of suspects is not always the best failure detector output. 5 Reliable communication is a fundamental problem that has been extensively studied, especially in the context of data link protocols (see Chapter 22 of [25] for a compendium).
Reference: 3. <author> M. K. Aguilera, W. Chen, and S. Toueg. </author> <title> Quiescent reliable communication and quiescent consensus in partitionable networks. </title> <type> Technical Report 97-1632, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: By a slight abuse of notation, we sometimes use HB to refer to an arbitrary member of that class. It is easy to generalize the definition of HB so that the failure detector module at each process p outputs the heartbeat of every process in the system <ref> [3] </ref>, rather than just the heartbeats of the neighbors of p, but we do not need this generality here. 8 Quiescent Reliable Communication Using HB The communication networks that we consider are not necessarily completely connected, but we assume that every pair of correct processes is connected through a fair path. <p> In <ref> [3] </ref>, we drop this assumption and consider the more general problem of quiescent reliable communication in networks that may partition. <p> In <ref> [3] </ref> we also 11 In [6], message piggybacking is used to overcome message losses.
Reference: 4. <author> M. K. Aguilera and S. Toueg. </author> <title> Randomization and failure detection: a hybrid approach to solve consensus. </title> <booktitle> In Proceedings of the 10th International Workshop on Distributed Algorithms, Lecture Notes on Computer Science, </booktitle> <pages> pages 29-39. </pages> <publisher> Springer-Verlag, </publisher> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: We then explain how HB can be used to easily transform many existing algorithms that tolerate process crashes into quiescent algorithms that tolerate both process crashes and message losses (fair links). This transformation can be applied to the algorithms for consensus in <ref> [4, 8, 9, 12, 14, 17, 26] </ref>, for atomic broadcast in [12], for k-set agreement in [13], for atomic commitment in [20], for approximate agreement in [16], etc. Finally, we show that HB can be used to extend the work in [6] to obtain the following result. <p> For example, consider the randomized consensus algorithms of [8, 14, 17, 26], the failure-detector based ones of <ref> [4, 12] </ref>, the probabilistic one of [9], and the algorithms for atomic broadcast in [12], k-set agreement in [13], atomic commitment in [20], and approximate agreement in [16]. All these algorithms tolerate process crashes.
Reference: 5. <author> O. Babao glu, R. Davoli, and A. Montresor. </author> <title> Partitionable group membership: specification and algorithms. </title> <type> Technical Report UBLCS-97-1, </type> <institution> Dept. of Computer Science, University of Bologna, Bologna, Italy, </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: Introduced in [12], the abstraction of unreliable failure detectors has been used to solve several important problems such as consensus, atomic broadcast, group membership, non-blocking atomic commitment, and leader election <ref> [5, 15, 20, 24, 27] </ref>. Our goal is to use unreliable failure detectors to achieve quiescence, but before we do so we must address the following important question. <p> It can also be used to extend the results of [6]. 4. HB is novel: it is implementable without timeouts, and it does not output lists of suspects as typical failure detectors do <ref> [5, 12, 20, 21, 24, 27] </ref>.
Reference: 6. <author> A. Basu, B. Charron-Bost, and S. Toueg. </author> <title> Simulating reliable links with unreliable links in the presence of process crashes. </title> <booktitle> In Proceedings of the 10th International Workshop on Distributed Algorithms, Lecture Notes on Computer Science, </booktitle> <pages> pages 105-122. </pages> <publisher> Springer-Verlag, </publisher> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: Finally, we show that HB can be used to extend the work in <ref> [6] </ref> to obtain the following result. Let P be a problem. Suppose P is correct-restricted (i.e., its specification refers only to the behavior of correct processes) or a majority of processes are correct. <p> HB can be used to extend existing algorithms for many fundamental problems (e.g., consensus, atomic broadcast, k-set agreement, atomic commitment, approximate agreement) to tolerate message losses. It can also be used to extend the results of <ref> [6] </ref>. 4. HB is novel: it is implementable without timeouts, and it does not output lists of suspects as typical failure detectors do [5, 12, 20, 21, 24, 27]. <p> Our work differs from previous results by focusing on the use of unreliable failure detectors to achieve quiescent reliable communication in the presence of process crashes and link failures. The work by Basu et al. in <ref> [6] </ref> is the closest to ours, but their protocols do not use failure detectors and are not quiescent. In Section 10, we use HB to extend the results of [6] and obtain quiescent protocols. The paper is organized as follows. Our model is given in Section 4. <p> The work by Basu et al. in <ref> [6] </ref> is the closest to ours, but their protocols do not use failure detectors and are not quiescent. In Section 10, we use HB to extend the results of [6] and obtain quiescent protocols. The paper is organized as follows. Our model is given in Section 4. Section 5 defines the reliable communication primitives that we focus on. In Section 6, we show that, without failure detectors, quiescent reliable communication is impossible. <p> In particular, we make no assumptions on the time it takes to deliver a message, or on relative process speeds. Processes can communicate with each other by 4 The link failure model in <ref> [6] </ref> is slightly different from the one used here (cf. Section 10). 5 This was anticipated in [11]. sending messages through the network. We do not assume that the network is completely connected or that the links are bidirectional. The system can experience both process failures and link failures. <p> The resulting algorithms tolerate message losses and are quiescent. 10.2 Extending Results of [BCBT96] Another way to solve problems with quiescent algorithms that tolerate both process crashes and message losses is obtained by extending the results of <ref> [6] </ref>. That work addresses the following question: given a problem that can be solved in a system where the only possible failures are process crashes, is the problem still solvable if links can also fail by losing messages? One of the models of lossy links considered in [6] is called fair <p> the results of <ref> [6] </ref>. That work addresses the following question: given a problem that can be solved in a system where the only possible failures are process crashes, is the problem still solvable if links can also fail by losing messages? One of the models of lossy links considered in [6] is called fair lossy. Roughly speaking, a fair lossy link p ! q satisfies the following property: If p sends an infinite number of messages to q and q is correct, then q receives an infinite number of messages from p. <p> : and p ! q is fair lossy, q may never receive a copy of m 2 (while it receives m 1 infinitely often), whereas if p ! q is fair, q is guaranteed to receive an infinite number of copies of both m 1 and m 2 . 11 <ref> [6] </ref> establishes the following result: any problem P that can be solved in systems with process crashes can also be solved in systems with process crashes and fair lossy links, provided P is correct-restricted 12 or a majority of processes are correct. For each of these two cases, [6] shows how <p> . 11 <ref> [6] </ref> establishes the following result: any problem P that can be solved in systems with process crashes can also be solved in systems with process crashes and fair lossy links, provided P is correct-restricted 12 or a majority of processes are correct. For each of these two cases, [6] shows how to transform any algorithm that solves P in a system with process crashes, into one that solves P in a system with process crashes and fair lossy links. <p> The algorithms that result from these transformations, however, are not quiescent: each transformation requires processes to repeatedly send messages forever. Given HB, we can modify the transformations in <ref> [6] </ref> to ensure that if the original algorithm is quiescent then so is the transformed one. <p> The results in <ref> [6] </ref>, combined with the above modification, show that if a problem P can be solved with a quiescent algorithm in a system with crash failures only, and either P is correct-restricted or a majority of processes are correct, then P is solvable with a quiescent algorithm that uses HB in a <p> In [3] we also 11 In <ref> [6] </ref>, message piggybacking is used to overcome message losses.
Reference: 7. <author> R. Bazzi and G. Neiger. </author> <title> Simulating crash failures with many faulty processors. </title> <editor> In A. Segal and S. Zaks, editors, </editor> <booktitle> Proceedings of the 6th International Workshop on Distributed Algorithms, volume 647 of Lecture Notes on Computer Science, </booktitle> <pages> pages 166-184. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: To avoid this piggybacking, in this paper we adopted the model of fair links: message losses can now be overcome by separately sending each message repeatedly. 12 Intuitively, a problem P is correct-restricted if its specification does not refer to the behavior of faulty processes <ref> [7, 19] </ref>. consider the problem of consensus for networks that may partition, and we use HB to solve this problem with a quiescent protocol (we also use a generalization of the Eventually Strong failure detector [12]). 12 Quiescence versus Termination In this paper we considered communication protocols that tolerate process crashes
Reference: 8. <author> M. Ben-Or. </author> <title> Another advantage of free choice: Completely asynchronous agreement proto-cols. </title> <booktitle> In Proceedings of the 2nd ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 27-30, </pages> <month> Aug. </month> <year> 1983. </year>
Reference-contexts: We then explain how HB can be used to easily transform many existing algorithms that tolerate process crashes into quiescent algorithms that tolerate both process crashes and message losses (fair links). This transformation can be applied to the algorithms for consensus in <ref> [4, 8, 9, 12, 14, 17, 26] </ref>, for atomic broadcast in [12], for k-set agreement in [13], for atomic commitment in [20], for approximate agreement in [16], etc. Finally, we show that HB can be used to extend the work in [6] to obtain the following result. <p> For example, consider the randomized consensus algorithms of <ref> [8, 14, 17, 26] </ref>, the failure-detector based ones of [4, 12], the probabilistic one of [9], and the algorithms for atomic broadcast in [12], k-set agreement in [13], atomic commitment in [20], and approximate agreement in [16]. All these algorithms tolerate process crashes.
Reference: 9. <author> G. Bracha and S. Toueg. </author> <title> Asynchronous consensus and broadcast protocols. </title> <journal> J. ACM, </journal> <volume> 32(4) </volume> <pages> 824-840, </pages> <month> Oct. </month> <year> 1985. </year>
Reference-contexts: We then explain how HB can be used to easily transform many existing algorithms that tolerate process crashes into quiescent algorithms that tolerate both process crashes and message losses (fair links). This transformation can be applied to the algorithms for consensus in <ref> [4, 8, 9, 12, 14, 17, 26] </ref>, for atomic broadcast in [12], for k-set agreement in [13], for atomic commitment in [20], for approximate agreement in [16], etc. Finally, we show that HB can be used to extend the work in [6] to obtain the following result. <p> Informally, an implementation of SEND s;r and RECEIVE r;s is quiescent if it sends only a finite number of messages when SEND s;r is invoked a finite number of times. 7 5.2 Reliable Broadcast Reliable broadcast <ref> [9] </ref> is defined in terms of two primitives: broadcast (m) and deliver (m). We say that process p broadcasts message m if p invokes broadcast (m). <p> For example, consider the randomized consensus algorithms of [8, 14, 17, 26], the failure-detector based ones of [4, 12], the probabilistic one of <ref> [9] </ref>, and the algorithms for atomic broadcast in [12], k-set agreement in [13], atomic commitment in [20], and approximate agreement in [16]. All these algorithms tolerate process crashes.
Reference: 10. <author> T. D. Chandra, </author> <month> April </month> <year> 1997. </year> <title> Private Communication. </title>
Reference-contexts: Thus, HB should not be confused with existing implementations of failure detectors (some of which, such as those in Ensemble and Phoenix, have modules that are also called heartbeat <ref> [28, 10] </ref>). Even though existing failure detectors are also based on the repeated sending of a heartbeat, they use timeouts on heartbeats in order to derive lists of processes considered to be up or down; applications can only see these lists.
Reference: 11. <author> T. D. Chandra, V. Hadzilacos, and S. Toueg. </author> <title> The weakest failure detector for solving consensus. </title> <journal> Journal of the ACM, </journal> <volume> 43(4) </volume> <pages> 685-722, </pages> <month> July </month> <year> 1996. </year>
Reference-contexts: Processes can communicate with each other by 4 The link failure model in [6] is slightly different from the one used here (cf. Section 10). 5 This was anticipated in <ref> [11] </ref>. sending messages through the network. We do not assume that the network is completely connected or that the links are bidirectional. The system can experience both process failures and link failures. Processes can fail by crashing, and links can fail by dropping messages.
Reference: 12. <author> T. D. Chandra and S. Toueg. </author> <title> Unreliable failure detectors for reliable distributed systems. </title> <journal> Journal of the ACM, </journal> <volume> 43(2) </volume> <pages> 225-267, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: Moreover, the local lists of suspects dynamically change and lists of different processes do not have to agree (or even eventually agree). Introduced in <ref> [12] </ref>, the abstraction of unreliable failure detectors has been used to solve several important problems such as consensus, atomic broadcast, group membership, non-blocking atomic commitment, and leader election [5, 15, 20, 24, 27]. <p> How can we use an unreliable failure detector to achieve quiescent reliable communication in the presence of process and link failures? Consider the Eventually Perfect failure detector 3P <ref> [12] </ref>. Intuitively, 3P satisfies the following two properties: (a) if a process crashes then there is a time after which it is permanently suspected, and (b) if a process does not crash then there is a time after which it is never suspected. <p> In [2], Aguilera et al. show that among all failure detectors that output lists of suspects, 3P is the weakest one that can be used to solve the above problem. Unfortunately, 3P is not implementable in asynchronous systems with process crashes (this would violate a known impossibility result <ref> [18, 12] </ref>). Thus, at a first glance, it seems that achieving quiescent reliable communication requires a failure detector that cannot be implemented. <p> We then explain how HB can be used to easily transform many existing algorithms that tolerate process crashes into quiescent algorithms that tolerate both process crashes and message losses (fair links). This transformation can be applied to the algorithms for consensus in <ref> [4, 8, 9, 12, 14, 17, 26] </ref>, for atomic broadcast in [12], for k-set agreement in [13], for atomic commitment in [20], for approximate agreement in [16], etc. Finally, we show that HB can be used to extend the work in [6] to obtain the following result. <p> This transformation can be applied to the algorithms for consensus in [4, 8, 9, 12, 14, 17, 26], for atomic broadcast in <ref> [12] </ref>, for k-set agreement in [13], for atomic commitment in [20], for approximate agreement in [16], etc. Finally, we show that HB can be used to extend the work in [6] to obtain the following result. Let P be a problem. <p> It can also be used to extend the results of [6]. 4. HB is novel: it is implementable without timeouts, and it does not output lists of suspects as typical failure detectors do <ref> [5, 12, 20, 21, 24, 27] </ref>. <p> For example, consider the randomized consensus algorithms of [8, 14, 17, 26], the failure-detector based ones of <ref> [4, 12] </ref>, the probabilistic one of [9], and the algorithms for atomic broadcast in [12], k-set agreement in [13], atomic commitment in [20], and approximate agreement in [16]. All these algorithms tolerate process crashes. <p> For example, consider the randomized consensus algorithms of [8, 14, 17, 26], the failure-detector based ones of [4, 12], the probabilistic one of [9], and the algorithms for atomic broadcast in <ref> [12] </ref>, k-set agreement in [13], atomic commitment in [20], and approximate agreement in [16]. All these algorithms tolerate process crashes. Moreover, it is easy to verify that the only communication primitives that they actually need are quasi reliable send and receive, and/or reliable broadcast. <p> P is correct-restricted if its specification does not refer to the behavior of faulty processes [7, 19]. consider the problem of consensus for networks that may partition, and we use HB to solve this problem with a quiescent protocol (we also use a generalization of the Eventually Strong failure detector <ref> [12] </ref>). 12 Quiescence versus Termination In this paper we considered communication protocols that tolerate process crashes and message losses, and focused on achieving quiescence. What about achieving termination? A terminating protocol guarantees that every process eventually reaches a halting state from which it cannot take further actions.
Reference: 13. <author> S. Chaudhuri. </author> <title> More choices allow more faults: Set consensus problems in totally asynchronous systems. </title> <journal> Information and Computation, </journal> <volume> 105(1) </volume> <pages> 132-158, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: This transformation can be applied to the algorithms for consensus in [4, 8, 9, 12, 14, 17, 26], for atomic broadcast in [12], for k-set agreement in <ref> [13] </ref>, for atomic commitment in [20], for approximate agreement in [16], etc. Finally, we show that HB can be used to extend the work in [6] to obtain the following result. Let P be a problem. <p> For example, consider the randomized consensus algorithms of [8, 14, 17, 26], the failure-detector based ones of [4, 12], the probabilistic one of [9], and the algorithms for atomic broadcast in [12], k-set agreement in <ref> [13] </ref>, atomic commitment in [20], and approximate agreement in [16]. All these algorithms tolerate process crashes. Moreover, it is easy to verify that the only communication primitives that they actually need are quasi reliable send and receive, and/or reliable broadcast.
Reference: 14. <author> B. Chor, M. Merritt, and D. B. Shmoys. </author> <title> Simple constant-time consensus protocols in realistic failure models. </title> <journal> Journal of the ACM, </journal> <volume> 36(3) </volume> <pages> 591-614, </pages> <year> 1989. </year>
Reference-contexts: We then explain how HB can be used to easily transform many existing algorithms that tolerate process crashes into quiescent algorithms that tolerate both process crashes and message losses (fair links). This transformation can be applied to the algorithms for consensus in <ref> [4, 8, 9, 12, 14, 17, 26] </ref>, for atomic broadcast in [12], for k-set agreement in [13], for atomic commitment in [20], for approximate agreement in [16], etc. Finally, we show that HB can be used to extend the work in [6] to obtain the following result. <p> For example, consider the randomized consensus algorithms of <ref> [8, 14, 17, 26] </ref>, the failure-detector based ones of [4, 12], the probabilistic one of [9], and the algorithms for atomic broadcast in [12], k-set agreement in [13], atomic commitment in [20], and approximate agreement in [16]. All these algorithms tolerate process crashes.
Reference: 15. <author> D. Dolev, R. Friedman, I. Keidar, and D. Malkhi. </author> <title> Failure detectors in omission failure environments. </title> <type> Technical Report 96-1608, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <year> 1996. </year>
Reference-contexts: Introduced in [12], the abstraction of unreliable failure detectors has been used to solve several important problems such as consensus, atomic broadcast, group membership, non-blocking atomic commitment, and leader election <ref> [5, 15, 20, 24, 27] </ref>. Our goal is to use unreliable failure detectors to achieve quiescence, but before we do so we must address the following important question.
Reference: 16. <author> D. Dolev, N. A. Lynch, S. S. Pinter, E. W. Stark, and W. E. Weihl. </author> <title> Reaching approximate agreement in the presence of faults. </title> <journal> J. ACM, </journal> <volume> 33(3) </volume> <pages> 499-516, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: This transformation can be applied to the algorithms for consensus in [4, 8, 9, 12, 14, 17, 26], for atomic broadcast in [12], for k-set agreement in [13], for atomic commitment in [20], for approximate agreement in <ref> [16] </ref>, etc. Finally, we show that HB can be used to extend the work in [6] to obtain the following result. Let P be a problem. Suppose P is correct-restricted (i.e., its specification refers only to the behavior of correct processes) or a majority of processes are correct. <p> For example, consider the randomized consensus algorithms of [8, 14, 17, 26], the failure-detector based ones of [4, 12], the probabilistic one of [9], and the algorithms for atomic broadcast in [12], k-set agreement in [13], atomic commitment in [20], and approximate agreement in <ref> [16] </ref>. All these algorithms tolerate process crashes. Moreover, it is easy to verify that the only communication primitives that they actually need are quasi reliable send and receive, and/or reliable broadcast.
Reference: 17. <author> P. Feldman and S. Micali. </author> <title> An optimal algorithm for synchronous Byzantine agreement. </title> <type> Technical Report MIT/LCS/TM-425, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: We then explain how HB can be used to easily transform many existing algorithms that tolerate process crashes into quiescent algorithms that tolerate both process crashes and message losses (fair links). This transformation can be applied to the algorithms for consensus in <ref> [4, 8, 9, 12, 14, 17, 26] </ref>, for atomic broadcast in [12], for k-set agreement in [13], for atomic commitment in [20], for approximate agreement in [16], etc. Finally, we show that HB can be used to extend the work in [6] to obtain the following result. <p> For example, consider the randomized consensus algorithms of <ref> [8, 14, 17, 26] </ref>, the failure-detector based ones of [4, 12], the probabilistic one of [9], and the algorithms for atomic broadcast in [12], k-set agreement in [13], atomic commitment in [20], and approximate agreement in [16]. All these algorithms tolerate process crashes.
Reference: 18. <author> M. J. Fischer, N. A. Lynch, and M. S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> J. ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> Apr. </month> <year> 1985. </year>
Reference-contexts: In [2], Aguilera et al. show that among all failure detectors that output lists of suspects, 3P is the weakest one that can be used to solve the above problem. Unfortunately, 3P is not implementable in asynchronous systems with process crashes (this would violate a known impossibility result <ref> [18, 12] </ref>). Thus, at a first glance, it seems that achieving quiescent reliable communication requires a failure detector that cannot be implemented.
Reference: 19. <author> A. Gopal. </author> <title> Fault-Tolerant Broadcasts and Multicasts: The Problem of Inconsistency and Contamination. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: To avoid this piggybacking, in this paper we adopted the model of fair links: message losses can now be overcome by separately sending each message repeatedly. 12 Intuitively, a problem P is correct-restricted if its specification does not refer to the behavior of faulty processes <ref> [7, 19] </ref>. consider the problem of consensus for networks that may partition, and we use HB to solve this problem with a quiescent protocol (we also use a generalization of the Eventually Strong failure detector [12]). 12 Quiescence versus Termination In this paper we considered communication protocols that tolerate process crashes
Reference: 20. <author> R. Guerraoui. </author> <title> Revisiting the relationship between non-blocking atomic commitment and consensus. </title> <booktitle> In Proceedings of the 9th International Workshop on Distributed Algorithms, </booktitle> <pages> pages 87-100, </pages> <address> Le Mont-St-Michel, France, 1995. </address> <publisher> Springer Verlag, LNCS 972. </publisher>
Reference-contexts: Introduced in [12], the abstraction of unreliable failure detectors has been used to solve several important problems such as consensus, atomic broadcast, group membership, non-blocking atomic commitment, and leader election <ref> [5, 15, 20, 24, 27] </ref>. Our goal is to use unreliable failure detectors to achieve quiescence, but before we do so we must address the following important question. <p> This transformation can be applied to the algorithms for consensus in [4, 8, 9, 12, 14, 17, 26], for atomic broadcast in [12], for k-set agreement in [13], for atomic commitment in <ref> [20] </ref>, for approximate agreement in [16], etc. Finally, we show that HB can be used to extend the work in [6] to obtain the following result. Let P be a problem. <p> It can also be used to extend the results of [6]. 4. HB is novel: it is implementable without timeouts, and it does not output lists of suspects as typical failure detectors do <ref> [5, 12, 20, 21, 24, 27] </ref>. <p> For example, consider the randomized consensus algorithms of [8, 14, 17, 26], the failure-detector based ones of [4, 12], the probabilistic one of [9], and the algorithms for atomic broadcast in [12], k-set agreement in [13], atomic commitment in <ref> [20] </ref>, and approximate agreement in [16]. All these algorithms tolerate process crashes. Moreover, it is easy to verify that the only communication primitives that they actually need are quasi reliable send and receive, and/or reliable broadcast.
Reference: 21. <author> R. Guerraoui, M. Larrea, and A. Schiper. </author> <title> Non blocking atomic commitment with an unreliable failure detector. </title> <booktitle> In Proceedings of the 14th IEEE Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 13-15, </pages> <year> 1995. </year>
Reference-contexts: It can also be used to extend the results of [6]. 4. HB is novel: it is implementable without timeouts, and it does not output lists of suspects as typical failure detectors do <ref> [5, 12, 20, 21, 24, 27] </ref>.
Reference: 22. <author> V. Hadzilacos and S. Toueg. </author> <title> A modular approach to fault-tolerant broadcasts and related problems. </title> <type> Technical Report 94-1425, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Roughly speaking, a pair of send/receive primitives is quasi reliable if it satisfies the following property: if processes s and r are correct (i.e., they do not crash), then r receives a message from s exactly as many times as s sent that message to r. Reliable broadcast <ref> [22] </ref> ensures that if a correct process broadcasts a 2 As we will see, however, in some types of networks the actual implementation is not entirely trivial. message m then all correct processes deliver m; moreover, all correct processes deliver the same set of messages. <p> These fields make every message unique. We say that q delivers message m if q returns from the invocation of deliver (m). Primitives broadcast and deliver satisfy the following properties <ref> [22] </ref>: 6 A stronger property, called No Loss, is used to define reliable send and receive [1]. 7 A quiescent implementation is allowed to send a finite number of messages even if no SEND s;r is invoked at all (e.g., some messages may be sent as part of an initialization phase).
Reference: 23. <author> R. Koo and S. Toueg. </author> <title> Effects of message loss on the termination of distributed protocols. </title> <journal> Inf. Process. Lett., </journal> <volume> 27(4) </volume> <pages> 181-188, </pages> <month> Apr. </month> <year> 1988. </year>
Reference-contexts: Can we use HB to obtain reliable communication protocols that are terminating? The answer is no, even for systems with no process crashes. This follows from the result in <ref> [23] </ref> which shows that in a system with message losses (fair links) and no process crashes there is no terminating protocol that guarantees knowledge gain. Acknowledgments We are grateful to Anindya Basu, Bernadette Charron-Bost, and Vassos Hadzilacos for having provided extensive comments that improved the presentation of this paper.
Reference: 24. <author> W.-K. Lo and V. Hadzilacos. </author> <title> Using failure detectors to solve consensus in asynchronous shared-memory systems. </title> <booktitle> In Proceedings of the 8th International Workshop on Distributed Algorithms, </booktitle> <pages> pages 280-295, </pages> <address> Terschelling, The Netherlands, </address> <year> 1994. </year>
Reference-contexts: Introduced in [12], the abstraction of unreliable failure detectors has been used to solve several important problems such as consensus, atomic broadcast, group membership, non-blocking atomic commitment, and leader election <ref> [5, 15, 20, 24, 27] </ref>. Our goal is to use unreliable failure detectors to achieve quiescence, but before we do so we must address the following important question. <p> It can also be used to extend the results of [6]. 4. HB is novel: it is implementable without timeouts, and it does not output lists of suspects as typical failure detectors do <ref> [5, 12, 20, 21, 24, 27] </ref>.
Reference: 25. <author> N. A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1996. </year>
Reference-contexts: The results of this paper, combined with those in [2], show that lists of suspects is not always the best failure detector output. 5 Reliable communication is a fundamental problem that has been extensively studied, especially in the context of data link protocols (see Chapter 22 of <ref> [25] </ref> for a compendium). Our work differs from previous results by focusing on the use of unreliable failure detectors to achieve quiescent reliable communication in the presence of process crashes and link failures.
Reference: 26. <author> M. Rabin. </author> <title> Randomized Byzantine generals. </title> <booktitle> In Proceedings of the 24th Symposium on Foundations of Computer Science, </booktitle> <pages> pages 403-409. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> Nov. </month> <year> 1983. </year>
Reference-contexts: We then explain how HB can be used to easily transform many existing algorithms that tolerate process crashes into quiescent algorithms that tolerate both process crashes and message losses (fair links). This transformation can be applied to the algorithms for consensus in <ref> [4, 8, 9, 12, 14, 17, 26] </ref>, for atomic broadcast in [12], for k-set agreement in [13], for atomic commitment in [20], for approximate agreement in [16], etc. Finally, we show that HB can be used to extend the work in [6] to obtain the following result. <p> For example, consider the randomized consensus algorithms of <ref> [8, 14, 17, 26] </ref>, the failure-detector based ones of [4, 12], the probabilistic one of [9], and the algorithms for atomic broadcast in [12], k-set agreement in [13], atomic commitment in [20], and approximate agreement in [16]. All these algorithms tolerate process crashes.
Reference: 27. <author> L. S. Sabel and K. Marzullo. </author> <title> Election vs. consensus in asynchronous systems. </title> <type> Technical Report 95-1488, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <month> Febrary </month> <year> 1995. </year>
Reference-contexts: Introduced in [12], the abstraction of unreliable failure detectors has been used to solve several important problems such as consensus, atomic broadcast, group membership, non-blocking atomic commitment, and leader election <ref> [5, 15, 20, 24, 27] </ref>. Our goal is to use unreliable failure detectors to achieve quiescence, but before we do so we must address the following important question. <p> It can also be used to extend the results of [6]. 4. HB is novel: it is implementable without timeouts, and it does not output lists of suspects as typical failure detectors do <ref> [5, 12, 20, 21, 24, 27] </ref>.
Reference: 28. <author> R. van Renesse, </author> <month> April </month> <year> 1997. </year> <title> Private Communication. This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Thus, HB should not be confused with existing implementations of failure detectors (some of which, such as those in Ensemble and Phoenix, have modules that are also called heartbeat <ref> [28, 10] </ref>). Even though existing failure detectors are also based on the repeated sending of a heartbeat, they use timeouts on heartbeats in order to derive lists of processes considered to be up or down; applications can only see these lists.
References-found: 28

