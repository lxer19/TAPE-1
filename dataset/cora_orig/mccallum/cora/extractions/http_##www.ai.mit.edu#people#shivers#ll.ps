URL: http://www.ai.mit.edu/people/shivers/ll.ps
Refering-URL: http://www.ai.mit.edu/people/shivers/citations.html
Root-URL: 
Title: A Universal Scripting Framework or Lambda: the ultimate little language  
Author: Olin Shivers 
Address: Cambridge, Mass. 02139, USA  
Affiliation: MIT AI Lab,  
Abstract: The little languages approach to systems programming is flawed: inefficient, fragile, error-prone, inexpressive, and difficult to compose. A better solution is to embed task-specific sublanguages within a powerful, syntactically extensible, universal language, such as Scheme. I demonstrate two such embeddings that have been implemented in scsh, a Scheme programming environment for Unix systems programming. The first embedded language is a high-level process-control notation; the second provides for Awk-like processing. Embedding systems in this way is a powerful technique: for example, although the embedded Awk system was implemented with 7% of the code required for the standard C-based Awk, it is significantly more expressive than its C counterpart.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Alfred V. Aho, Brian W. Kernighan, Peter J. Weinberger. </author> <title> Awka pattern scanning and processing language. </title> <journal> SoftwarePractice and Experience, </journal> <volume> IX(4):267279, </volume> <month> April, </month> <year> 1979. </year>
Reference-contexts: Note that regular Scheme is used to provide the control structure, variables, and other linguistic machinery needed by the script fragments; this was made possible by our strategy of embedding our specialised notation within Scheme. 6 Awk in Scheme Our second case study is the Awk language for pattern-directed processing <ref> [1] </ref>. The first part of the design task was to factor the language into its two basic components: a record- and field-based I/O system, and a rule-based, pattern-directed control structure. Each of these components was implemented separately in the Scheme design.
Reference: 2. <author> Dylan: </author> <title> An Object-Oriented Dynamic Language. </title> <institution> Apple Computer, </institution> <year> 1992. </year>
Reference-contexts: We aren't restricted to using Scheme to embed our little languages. We could have used almost any member of the Lisp family of programming languages, including Common Lisp [9] or the original s-expression Dylan <ref> [2] </ref>. While Scheme has the most sophisticated macro system of any language in this family, the macro systems of the other members can be exploited in a similar manner.
Reference: 3. <author> Stuart I. Feldman. </author> <title> MakeA program for maintaining computer programs. </title> <journal> Software Practice and Experience, </journal> <volume> IX(4):255-265, </volume> <month> April, </month> <year> 1979. </year>
Reference-contexts: The language understood by the make utility, for example, is not a gen-eral programming language, but rather one which is specially adapted for expressing dependencies among the components of a system <ref> [3] </ref>. Sacrificing generality is rewarded by notational compactness and clarity. Unix's little-languages philosophy is to present the programmer with a suite of spe-cialised languagesa linguistic toolkit for systems implementation. <p> Having embedded two little languages within Scheme, it's not too hard to see how to embed twenty more. Two obvious candidates are the expect programmed-dialogue scripting tool [4], and the make utility for dependency-directed program recompilation <ref> [3] </ref>. Since the power of a glue language is the power of the interaction that it facilitates, this is a case of the more the betterthe possibilities for interaction between system components written in embedded sublanguages go up quadratically with the number of systems that are embedded within Scheme.
Reference: 4. <author> Don Libes. </author> <title> expect: Curing those uncontrollable fits of interaction. </title> <booktitle> In Proceedings of the Summer 1990 USENIX conference, </booktitle> <address> Anaheim, Ca., </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Having embedded two little languages within Scheme, it's not too hard to see how to embed twenty more. Two obvious candidates are the expect programmed-dialogue scripting tool <ref> [4] </ref>, and the make utility for dependency-directed program recompilation [3].
Reference: 5. <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: The current standard lacks a module system, static type-checking, exceptions, and record typesit would appear that time has passed the language by. Scheme's sole remaining virtue distinguishing it from more modern languages, such as ML <ref> [5] </ref>, is its unusually sophisticated macro system. But it is the syntactic extensibility provided by this macro system that provided us the crucial mechanism we needed to embed our little languages within Scheme. Designers of new programming languages would do well to note the power and utility of this mechanism.
Reference: 6. <editor> J. Rees and W. Clinger (editors). </editor> <title> The revised 4 report on the algorithmic language Scheme. Lisp Pointers IV(3):1-55, </title> <month> JulySeptember </month> <year> 1991. </year>
Reference-contexts: In practice, it often leads to fragile programs that rely on heuristic, error-prone parsers (often based on limited regular-expression matchers). 4 An Alternate Approach An alternate approach is to choose a powerful, syntactically extensible programming language, such as Scheme <ref> [6] </ref>, and embed our little language within it. This has the benefit of focus: it allows the tool designer and implementor to concentrate on the task-specific elements of his language.
Reference: 7. <author> Olin Shivers. </author> <title> A Scheme shell. </title> <note> To appear in the Journal of Lisp and Symbolic Computation. </note>
Reference-contexts: The second, more detailed example, will be an embedding of an Awk-like little language within Scheme. These systems were implemented in scsh, a portable Unix programming environment built in Scheme <ref> [7, 8] </ref>. Scsh has been used for a wide variety of systems programming tasks, such as cell-phone interfaces, mobile Web browsers, CAD tools, log analysers, http servers and other network tools.
Reference: 8. <author> Olin Shivers. </author> <title> The scsh manual. </title> <month> November </month> <year> 1995, </year> <note> scsh release 0.4. </note> <institution> MIT Laboratory for Computer Science. </institution> <note> (Also available at URL http://swissnet.ai.mit.edu/scsh/.) </note>
Reference-contexts: The second, more detailed example, will be an embedding of an Awk-like little language within Scheme. These systems were implemented in scsh, a portable Unix programming environment built in Scheme <ref> [7, 8] </ref>. Scsh has been used for a wide variety of systems programming tasks, such as cell-phone interfaces, mobile Web browsers, CAD tools, log analysers, http servers and other network tools.
Reference: 9. <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Maynard, Mass., </address> <note> second edition 1990. </note>
Reference-contexts: We aren't restricted to using Scheme to embed our little languages. We could have used almost any member of the Lisp family of programming languages, including Common Lisp <ref> [9] </ref> or the original s-expression Dylan [2]. While Scheme has the most sophisticated macro system of any language in this family, the macro systems of the other members can be exploited in a similar manner.
References-found: 9

