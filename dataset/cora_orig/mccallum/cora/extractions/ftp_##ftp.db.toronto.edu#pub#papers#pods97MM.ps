URL: ftp://ftp.db.toronto.edu/pub/papers/pods97MM.ps
Refering-URL: http://www.cs.toronto.edu/~kishor/websqlcost.html
Root-URL: 
Email: mendel@db.toronto.edu  milo@math.tau.ac.il  
Title: Formal Models of Web Queries Extended abstract  
Author: Alberto O. Mendelzon Tova Milo 
Web: http://www.cs.toronto.edu/~mendel  http://www.math.tau.ac.il/~milo  
Address: Toronto  
Affiliation: University of  Tel Aviv University  
Abstract: The paper presents a new model of query and computation on the Web. We focus on two important aspects that distinguish the access to Web data from the access to a standard database system: the navigational nature of the access and the lack of concurrency control. We show that these two issues have significant effect on the computability of queries. To illustrate the ideas and how they can be used in practice for designing appropriate Web query languages, we consider a particular query language, the Web calculus, an abstraction and extension of the practical Web query language WebSQL. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul, C.H. Papadimitriou, and V.Vianu. </author> <title> The power of the reflective relational machine. </title> <booktitle> In Proc. IEEE Symp. on Logic in Computer Science, </booktitle> <year> 1994. </year>
Reference-contexts: We give two characterizations of Web queries, one in terms of the sub-Web they depend on, and one in terms of generic machines <ref> [1] </ref>. In Section 4, we consider eventually computable queries, that can be evaluated only by a non-terminating computation. We characterize them by a monotonicity property and by a new kind of generic machine. <p> It turns out that a similar characterization can be given for Web queries as well. For that we use Web relational machines, a slight refinement of Abiteboul and Vianu's reflective relational machines <ref> [1] </ref>. We next briefly recall the definition of such machines and then define Web relational machine. Definition 3.4 A reflective relational machine is a Tur-ing machine with a special query tape and a separate relational store, capable of storing arbitrary relations. <p> It was shown in <ref> [1] </ref> that reflective relational machines compute exactly all the relational queries. The following theorem shows a similar relation between Web relational machines and Web queries.
Reference: [2] <author> S. Abiteboul and V. Vianu. </author> <title> Queries and computation on the Web. </title> <booktitle> In Proc. </booktitle> <volume> ICDT '97, </volume> <year> 1997. </year>
Reference-contexts: We show that, with appropriate assumptions, the results can be extended to handle forms and index servers. We conclude in Section 8. For lack of space we omit proofs. Related work The only work we are aware of dealing with formal models of Web queries is <ref> [2] </ref>, which is closely related to ours. There is however one central difference. According to [2], "Perhaps the most fundamental aspect of our model is that we view the Web as infinite." The argument for this is that "exhaustive exploration is -or will soon become- prohibitively expensive." This is not clear <p> We conclude in Section 8. For lack of space we omit proofs. Related work The only work we are aware of dealing with formal models of Web queries is <ref> [2] </ref>, which is closely related to ours. There is however one central difference. According to [2], "Perhaps the most fundamental aspect of our model is that we view the Web as infinite." The argument for this is that "exhaustive exploration is -or will soon become- prohibitively expensive." This is not clear to us. First, the Web is finite at any given moment, even if large. <p> This leads to a different classification of queries from the one in <ref> [2] </ref>, highlighting the specific effects of these two issues. <p> the Big Sur project at Berkeley [7], dealing with data from NASA's Earth Observing System, is designed for 1 Terabyte of data, or about 25 times the size of the Altavista index, and this is only 1/1000 of the ultimate data size that the EOS project will have to handle. <ref> [2] </ref>. In the dynamic Web, this query is only eventually computable, as it is in [2]. On the other hand, a query such as "list all documents" is eventually computable in both their model and ours (static and dynamic). <p> is designed for 1 Terabyte of data, or about 25 times the size of the Altavista index, and this is only 1/1000 of the ultimate data size that the EOS project will have to handle. <ref> [2] </ref>. In the dynamic Web, this query is only eventually computable, as it is in [2]. On the other hand, a query such as "list all documents" is eventually computable in both their model and ours (static and dynamic). And a query such as "does this node have any incoming link?" is not computable at all in any of the models. <p> Note that the last query above is a Web query by our definition but is not computable according to <ref> [2] </ref> because they assume that the Web is infinite. We next characterize Web queries. <p> For example, the query "list all documents referencing o" can be computed by enumerating all possible URL's and for each one testing whether it corresponds to an existing node, and whether this node point to o; but there is no way to stop. Following <ref> [2] </ref> we call such queries eventually computable. To formally define this, we first explain what it means for a relational query Q to be eventually computed by a Web machine. Definition 4.1 Let Q be a mapping from instances of a Web database to relations. <p> The notion is the same as in <ref> [2] </ref>, except that our Web machine is different from theirs. We now use it to define the eventually computable Web queries. <p> The notion is again similar to that of <ref> [2] </ref>, but there is one significant difference our definition of EC Web queries requires Q to be a relational query, not an arbitrary function. <p> First, we have to ensure that the first argument in a N , L, or P ath atom is bound to a known set of nodes; this is similar to what is called groundedness in [16], and source-safety in <ref> [2] </ref>. Second, as in the usual relational calculus, we have to ensure that arguments of a negated atom are instantiated and that terms of a disjunction use the same set of variables. The restrictions are specified as follows. <p> of forms. 9 Theorem 7.4 Under the assumption of computability for form attributes, Theorem 6.3 still holds in the presence of forms. 8 Conclusion and further work We have given a new model of query and computation on the Web, closely related to, but significantly different from, the model of <ref> [2] </ref>. We have separated the two reasons for non-terminating behavior of Web queries: navigational access to data and lack of concurrency control, and analyzed their impact. Cost is an important aspect of query evaluation. <p> The conventional approach in database theory is to estimate query evaluation time as a function of the size of the database. Viewing the Web as infinite, as done in <ref> [2] </ref>, makes such an estimation problematic.
Reference: [3] <author> S. Abiteboul and V.Vianu. </author> <title> Generic computation and its complexity. </title> <booktitle> In Proc. ACM STOC, </booktitle> <pages> pages 209-219, </pages> <year> 1991. </year>
Reference-contexts: The above theorem characterizes Web queries as a special sub-class of relational queries. Is it possible to give the Web queries a direct characterization independent of relational queries? For standard relational queries, such characterizations exist in the literature, and are given in terms of languages [9] or machines <ref> [3] </ref> that compute exactly all the relational queries. It turns out that a similar characterization can be given for Web queries as well. For that we use Web relational machines, a slight refinement of Abiteboul and Vianu's reflective relational machines [1].
Reference: [4] <author> Serge Abiteboul, Sophie Cluet, and Tova Milo. </author> <title> Querying and updating the file. </title> <booktitle> In Proceedings of the 19th VLDB Conference, </booktitle> <year> 1993. </year>
Reference-contexts: Also, our way to capture index servers is more accurate because it does not assume they are "perfect" indexes. Other relevant work includes query languages for graph databases and hypertext documents [6, 11, 17, 18] as well as query languages for structured or semi-structured documents such as <ref> [13, 4, 10] </ref>, and for unstructured data [8]. 2 Preliminaries We use a simple relational model of the Web to best highlight the essential computational issues. We first describe informally the main ideas, and then present our formal data model.
Reference: [5] <author> P. Atzeni, G. Mecca, P. Merialdo, and E. Tabet. </author> <title> Structures in the Web. </title> <type> Technical Report RT-INF-19-1997, </type> <institution> Dip. di Informatica e Automazione, Universita di Roma Tre, </institution> <year> 1997. </year>
Reference-contexts: 1 Introduction Tools and techniques for retrieving information from the World Wide Web are rapidly being developed <ref> [14, 15, 16, 5] </ref>. Most of these works are based on the metaphor of the Web as a database, in order to carry over and adapt familiar query languages such as SQL or Datalog.
Reference: [6] <author> C. Beeri and Y. Kornatzky. </author> <title> A logical query language for hypertext systems. </title> <booktitle> In Proc. of the European Conference on Hypertext, </booktitle> <pages> pages 67-80. </pages> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: A further difference is that our analysis, by allowing parameterized links, captures forms, which they do not treat. Also, our way to capture index servers is more accurate because it does not assume they are "perfect" indexes. Other relevant work includes query languages for graph databases and hypertext documents <ref> [6, 11, 17, 18] </ref> as well as query languages for structured or semi-structured documents such as [13, 4, 10], and for unstructured data [8]. 2 Preliminaries We use a simple relational model of the Web to best highlight the essential computational issues.
Reference: [7] <author> P. Brown and M. Stonebraker. BigSur: </author> <title> a system for the management of earth science data. </title> <booktitle> In Proceedings of VLDB '95, </booktitle> <pages> pages 720-28, </pages> <year> 1995. </year>
Reference-contexts: For example, the query "find all documents reachable from document d" is computable in our static model, but not in the model of 1 For example, the Big Sur project at Berkeley <ref> [7] </ref>, dealing with data from NASA's Earth Observing System, is designed for 1 Terabyte of data, or about 25 times the size of the Altavista index, and this is only 1/1000 of the ultimate data size that the EOS project will have to handle. [2].
Reference: [8] <author> P. Buneman, S. Davidson, G. Hillebrand, and D. Suciu. </author> <title> A query language and optimization techniques for unstructured data. </title> <booktitle> In Proceedings of SIGMOD '96, </booktitle> <pages> pages 505-516, </pages> <year> 1996. </year>
Reference-contexts: Other relevant work includes query languages for graph databases and hypertext documents [6, 11, 17, 18] as well as query languages for structured or semi-structured documents such as [13, 4, 10], and for unstructured data <ref> [8] </ref>. 2 Preliminaries We use a simple relational model of the Web to best highlight the essential computational issues. We first describe informally the main ideas, and then present our formal data model.
Reference: [9] <author> Ashok K. Chandra and David Harel. </author> <title> Computable queries for relational data bases. </title> <journal> JCSS, </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: Our goal is to provide a notion of computable Web queries that will play the role that the computable queries of Chan-dra and Harel <ref> [9] </ref> have played in the theory of relational databases. Of course, there are other important aspects of the Web, such as heterogeneity, autonomy, and lack of structure, which we do not address here. <p> Note that this is more restrictive than the traditional definition of relational queries in <ref> [9] </ref>, that allows partial recursive functions. For brevity, we omit the word total in the rest of this paper, and whenever we say relational query we mean a total one. <p> First all the reachable documents are retrieved, and then the query is evaluated on them (and the base relations) without any further access to the Web. (Proof omitted.) Remark: To deal with the use of constants in queries, one needs to talk about C-generic queries rather than just generic queries <ref> [9] </ref>. In the same way, we can naturally extend our definition and talk about C-generic Web queries these are simply C-generic relational queries that are computable by a Web machine. C-genericity allows the use of constants, so in particular constant URLs can be used in queries. <p> The above theorem characterizes Web queries as a special sub-class of relational queries. Is it possible to give the Web queries a direct characterization independent of relational queries? For standard relational queries, such characterizations exist in the literature, and are given in terms of languages <ref> [9] </ref> or machines [3] that compute exactly all the relational queries. It turns out that a similar characterization can be given for Web queries as well. For that we use Web relational machines, a slight refinement of Abiteboul and Vianu's reflective relational machines [1].
Reference: [10] <author> V. Christophides, S. Abiteboul, S. Cluet, and M. Scholl. </author> <title> From structured documents to novel query facilities. </title> <booktitle> In Proc. ACM SIGMOD'94, </booktitle> <pages> pages 313-324, </pages> <year> 1994. </year>
Reference-contexts: Also, our way to capture index servers is more accurate because it does not assume they are "perfect" indexes. Other relevant work includes query languages for graph databases and hypertext documents [6, 11, 17, 18] as well as query languages for structured or semi-structured documents such as <ref> [13, 4, 10] </ref>, and for unstructured data [8]. 2 Preliminaries We use a simple relational model of the Web to best highlight the essential computational issues. We first describe informally the main ideas, and then present our formal data model.
Reference: [11] <author> M. P. Consens and A. O. Mendelzon. </author> <title> Expressing structural hypertext queries in Graphlog. </title> <booktitle> In Hypertext'89, </booktitle> <pages> pages 269-292, </pages> <year> 1989. </year>
Reference-contexts: A further difference is that our analysis, by allowing parameterized links, captures forms, which they do not treat. Also, our way to capture index servers is more accurate because it does not assume they are "perfect" indexes. Other relevant work includes query languages for graph databases and hypertext documents <ref> [6, 11, 17, 18] </ref> as well as query languages for structured or semi-structured documents such as [13, 4, 10], and for unstructured data [8]. 2 Preliminaries We use a simple relational model of the Web to best highlight the essential computational issues.
Reference: [12] <institution> Digital Equipment Corporation. Alta Vista: Main page. </institution> <year> 1996. </year> <note> http://altavista.digital.com. </note>
Reference-contexts: There are only two ways to retrieve a document; either through its URL (uniform resource locator), or through some other document (possibly a form) that points to it. This statement may seem false at first sight to anyone who has used an index server such as Altavista <ref> [12] </ref>. These are Web sites that provide associative access to a large collection of documents by using a searchable index (built offline by navigation).
Reference: [13] <author> Ralf Hartmut Guting, Roberto Zicari, and David M. Choy. </author> <title> An algebra for structured office documents. </title> <journal> ACM TOIS, </journal> <volume> 7(2) </volume> <pages> 123-157, </pages> <year> 1989. </year>
Reference-contexts: Also, our way to capture index servers is more accurate because it does not assume they are "perfect" indexes. Other relevant work includes query languages for graph databases and hypertext documents [6, 11, 17, 18] as well as query languages for structured or semi-structured documents such as <ref> [13, 4, 10] </ref>, and for unstructured data [8]. 2 Preliminaries We use a simple relational model of the Web to best highlight the essential computational issues. We first describe informally the main ideas, and then present our formal data model.
Reference: [14] <author> D. Konopnicki and O. Shmueli. W3QS: </author> <title> A query system for the World Wide Web. </title> <booktitle> In Proc. of VLDB'95, </booktitle> <pages> pages 54-65, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction Tools and techniques for retrieving information from the World Wide Web are rapidly being developed <ref> [14, 15, 16, 5] </ref>. Most of these works are based on the metaphor of the Web as a database, in order to carry over and adapt familiar query languages such as SQL or Datalog. <p> Again, this is because even when the Web does not change at all, the query cannot be eventually computed. 6.2 Dynamic vs. Static queries Query engines for the Web, such as WebSQL [16], W3QL <ref> [14] </ref>, etc., provide query languages to specify user requests. The semantics of such engines is usually defined with respect to a static Web, i.e. what should the query result be if evaluated on some given Web database instance.
Reference: [15] <author> Laks V. S. Lakshmanan, Fereidoon Sadri, and Iyer N. Subramanian. </author> <title> A declarative language for querying and restructuring the Web. </title> <booktitle> In Proc. of 6th. International Workshop on Research Issues in Data Engineering, RIDE '96, </booktitle> <address> New Orleans, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Tools and techniques for retrieving information from the World Wide Web are rapidly being developed <ref> [14, 15, 16, 5] </ref>. Most of these works are based on the metaphor of the Web as a database, in order to carry over and adapt familiar query languages such as SQL or Datalog.
Reference: [16] <author> Alberto O. Mendelzon, George A. Mihaila, and Tova Milo. </author> <title> Querying the World Wide Web. </title> <booktitle> In Proc. </booktitle> <volume> PDIS '96, </volume> <pages> pages 80-91, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Tools and techniques for retrieving information from the World Wide Web are rapidly being developed <ref> [14, 15, 16, 5] </ref>. Most of these works are based on the metaphor of the Web as a database, in order to carry over and adapt familiar query languages such as SQL or Datalog. <p> To illustrate the ideas and how they can be used in practice for designing appropriate Web query languages, we consider in Section 5 a particular query language, the Web calculus, an abstraction and extension of the practical Web query language WebSQL <ref> [16] </ref>. We show that, if not properly restricted, the language can express queries that are not Web queries (e.g. "find all nodes with no incoming links"), and present the syntactic restrictions needed to express only Web queries, and various classes of eventually computable queries. <p> Our language, which we call the Web calculus, is an extension and an abstraction of an implemented language, WebSQL, described in <ref> [16] </ref>. WebSQL integrates content-based retrieval, as provided by index servers on the Web, with structure and topology-based retrieval. <p> Furthermore, R is a regular expression on an alphabet of link types, and the links along the path are restricted to satisfy R. We will not be making use of the regular expression in this section; see <ref> [16] </ref> for details. * A binary containment predicate that takes as first argument an oid and as a second argument an atomic value; it means that the string represented by the second argument occurs within the body of the document represented by the first argument. <p> First, we have to ensure that the first argument in a N , L, or P ath atom is bound to a known set of nodes; this is similar to what is called groundedness in <ref> [16] </ref>, and source-safety in [2]. Second, as in the usual relational calculus, we have to ensure that arguments of a negated atom are instantiated and that terms of a disjunction use the same set of variables. The restrictions are specified as follows. <p> It is open whether there are syntactic restrictions that capture exactly all the eventually computable Web calculus queries. Finally, we note that all the queries expressible in the WebSQL language of <ref> [16] </ref> are EC Web queries, and those satisfying the "groundedness" restriction in that paper are Web queries. 6 Dynamic environment The Web keeps changing and growing. In the current architecture no global concurrency control mechanism exists and thus the computation of queries is affected by the dynamic environment. <p> Again, this is because even when the Web does not change at all, the query cannot be eventually computed. 6.2 Dynamic vs. Static queries Query engines for the Web, such as WebSQL <ref> [16] </ref>, W3QL [14], etc., provide query languages to specify user requests. The semantics of such engines is usually defined with respect to a static Web, i.e. what should the query result be if evaluated on some given Web database instance. <p> Thus it is possible to compile any such query into a program that will run safely in a dynamic environment, i.e. with no non-termination concerns. In fact, the programs generated by the implemented WebSQL compiler <ref> [16] </ref> for these queries are such terminating programs. 7 Forms So far we ignored for simplicity the issue of forms. We explain below how they fit into the model and extend our results to this more comprehensive model. 7.1 Static Web As before, we first ignore updates to the Web. <p> This can be modeled by pricing oracle calls according to these parameters. Preliminary work on complexity of Web-queries in the context of a static Web was presented in <ref> [16] </ref>, where the notion of query locality was introduced to characterize the size of the network being accessed. Syntactic restrictions on WebSQL queries were presented to capture various locality classes. The case of EC queries and dynamic Web still needs to be studied.
Reference: [17] <author> T. Minohara and R. Watanabe. </author> <title> Queries on structure in hypertext. </title> <booktitle> In Foundations of Data Organization and Algorithms, </booktitle> <volume> FODO '93, </volume> <pages> pages 394-411. </pages> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: A further difference is that our analysis, by allowing parameterized links, captures forms, which they do not treat. Also, our way to capture index servers is more accurate because it does not assume they are "perfect" indexes. Other relevant work includes query languages for graph databases and hypertext documents <ref> [6, 11, 17, 18] </ref> as well as query languages for structured or semi-structured documents such as [13, 4, 10], and for unstructured data [8]. 2 Preliminaries We use a simple relational model of the Web to best highlight the essential computational issues.

References-found: 17

