URL: http://www.cs.umd.edu/projects/dimsum/papers/sigmod96.ps.gz
Refering-URL: http://www.cs.umd.edu/projects/dimsum/siumei/references.html
Root-URL: 
Email: j bthj j kossmanng@cs.umd.edu  
Title: Performance Tradeoffs for Client-Server Query Processing  
Author: Michael J. Franklin Bj orn Th or J onsson Donald Kossmann 
Address: College Park f franklin  
Affiliation: Department of Computer Science and Institute for Advanced Computer Studies University of Maryland,  
Abstract: The constructionof high-performance database systems that combine the best aspects of the relational and object-oriented approaches requires the design of client-server architectures that can fully exploit client and server resources in a flexible manner. The two predominant paradigms for client-server query execution are data-shipping and query-shipping. We first define these policies in terms of the restrictions they place on operator site selection during query optimization. We then investigate the performance tradeoffs between them for bulk query processing. While each strategy has advantages, neither one on its own is efficient across a wide range of circumstances. We describe and evaluate a more flexible policy called hybrid-shipping, which can execute queries at clients, servers, or any combination of the two. Hybrid-shipping is shown to at least match the best of the two pure policies, and in some situations, to perform better than both. The implementation of hybrid-shipping raises a number of difficult problems for query optimization. We describe an initial investigation into the use of a 2-step query optimization strategy as a way of addressing these issues. 
Abstract-found: 1
Intro-found: 1
Reference: [Bro92] <author> K. Brown. PRPL: </author> <title> A database workload specification language. </title> <type> Master's thesis, </type> <institution> Univ. of Wisconsin, </institution> <year> 1992. </year>
Reference-contexts: Every site has a CPU whose speed is specified by the Mips parameter, NumDisks disks, and a main-memory buffer pool. The CPU is modeled as a FIFO queue. Disks are modeled using a detailed characterization that was adapted from the ZetaSim model <ref> [Bro92] </ref>. The disk model includes an elevator disk scheduling policy, a controller cache, and read-ahead prefetching. There are many parameters to the disk model (not shown), including: rotational speed, seek factor, settle time, track and cylinder sizes, controller cache size, etc.
Reference: [C + 94] <author> M. Carey, et al. </author> <title> Shoring up persistent applications. </title> <booktitle> In ACM SIGMOD Conf., </booktitle> <address> Minneapolis, </address> <year> 1994. </year>
Reference-contexts: The simulator is written in C++ using the CSIM simulation toolkit. The simulator models a heterogeneous, peer-to-peer database system such as SHORE <ref> [C + 94] </ref> and provides a detailed model of query processing costs in such a system. At present, it does not model concurrency control and transaction management functions that would be required to support non-query workloads. <p> Current trends towards very large systems with many sites have motivated the design of new flexible architectures that, like hybrid-shipping, allow query processing on clients and servers; examples are Orion [J + 90] and Mariposa [S + 94]. Furthermore, SHORE <ref> [C + 94] </ref> provides a mechanism to allow the inclusion of a flexible query execution policy. There have been several closely related studies of query processing in local-area and client-server database systems.
Reference: [Cat94] <author> R. G. G. Cattell, </author> <title> editor. Object Database Standard. </title> <publisher> Morgan-Kaufmann Publishers, </publisher> <address> San Mateo, </address> <year> 1994. </year>
Reference-contexts: Bjorn Jonsson was supported in part by a Fulbright Fellowship. Donald Kossmann was supported in part by the Humboldt-Stiftung. towards integrating object-oriented features into their systems (e.g., the emerging SQL3 standard [Kul94]) while vendors of object-oriented systems are adding more powerful query facilities <ref> [Cat94] </ref>. Furthermore, a new class of hybrid Object-Relational systems has recently started to appear (e.g., Illus-tra and UniSQL). These efforts have resulted in significant progress towards integrating object and relational concepts, but this progress has been primarily at the language and data model levels. <p> A select operator can be given either a consumer or producer 2 For simplicity we use relational terminology when describing query operators. Analogous operations arise in object-oriented database languages that support associative queries such as OQL <ref> [Cat94] </ref>. 3 Other binary operators (such as set operations) can be annotated similarly to joins. 4 Other unary operators (such as aggregations and projections) can be annotated similarly to selections. 2 annotation, indicating that it should be executed at the site of its parent or child operator respectively. * Scan The
Reference: [CL86] <author> M. Carey and H. Lu. </author> <title> Load balancing in a locally distributed database system. </title> <booktitle> ACM SIGMOD Conf., </booktitle> <address> Washington, </address> <year> 1986. </year>
Reference-contexts: A static query optimizer generates a query plan based on the state of the system at compile time or based on general assumptions about the system state. 2-Step optimization which has been proposed for distributed systems in <ref> [CL86, S + 94] </ref> performs only some optimization decisions at compile time and then adjusts the partially optimized plan prior to query execution. We propose a 2-step optimizer that works as follows: 1. <p> There have been several closely related studies of query processing in local-area and client-server database systems. Carey and Lu studied join algorithms in local networks [LC85] and devised methods to load balance a system if data is replicated at several sites <ref> [CL86] </ref>. Among the first to study query processing specifically in a client-server environment were Hagmann and Ferrari [HF86]. They investigated different ways to split the functionality of a DBMS (e.g., query parsing, optimization, and execution) between client and server machines.
Reference: [D + 90] <author> D. DeWitt, et al. </author> <title> A study of three alternative workstation server architectures for object-oriented database systems. </title> <booktitle> 16th VLDB Conf., </booktitle> <address> Brisbane, </address> <year> 1990. </year>
Reference-contexts: Data-shipping is used in most object database systems, and it has been investigated, e.g., in <ref> [D + 90, Fra96] </ref>. Query-shipping, on the other hand, is used in most traditional relational systems.
Reference: [Fra96] <author> M. Franklin. </author> <title> Client Data Caching. </title> <publisher> Kluwer Academic Press, </publisher> <address> Boston, </address> <year> 1996. </year>
Reference-contexts: The settings are largely based on those used in previous studies; e.g., <ref> [Fra96, PCV94] </ref>. 7 The allocation of memory in our experiments is described in Section 4.1. Several details deserve additional explanation. <p> Data-shipping is used in most object database systems, and it has been investigated, e.g., in <ref> [D + 90, Fra96] </ref>. Query-shipping, on the other hand, is used in most traditional relational systems.
Reference: [GHK92] <author> S. Ganguly, W. Hasan, and R. Krishnamurthy. </author> <title> Query optimization for parallel execution. </title> <booktitle> ACM SIGMOD Conf., </booktitle> <address> San Diego, </address> <year> 1992. </year>
Reference-contexts: The cost model that we used is capable of estimating both the total cost and the response time of a query plan for a given system configuration. The total-cost estimates are based on the model of Mackert and Lohman [ML86]. The response-time estimates are generated using the model of <ref> [GHK92] </ref>. The response time of a query is defined to be the elapsed time from the initiation of query execution until the time that the last tuple of the query result is displayed at the client.
Reference: [Gra93] <author> G. Graefe. </author> <title> Query evaluation techniques for large databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(2), </volume> <year> 1993. </year>
Reference-contexts: In this study, there is no inter-query caching at servers. That is, when a server obtains data from another site, it uses it only for the duration of the current query. Query execution is based on an iterator model, similar to that of Volcano <ref> [Gra93] </ref>. Each query operator has an open-next-close interface; open prepares the operator (e.g., allocation of main memory and structures, initialization of scans, etc.), next is called repeatedly to yield tuples, and close terminates the operator and does some final housekeeping (e.g., freeing memory).
Reference: [GW93] <author> S. Ganguly and W. Wang. </author> <title> Optimizing queries for coarse grain parallelism. </title> <type> Technical report, </type> <institution> Rutgers University, </institution> <year> 1993. </year>
Reference-contexts: They investigated different ways to split the functionality of a DBMS (e.g., query parsing, optimization, and execution) between client and server machines. Related work on multi-node query processing includes techniques devised for parallel databases. In particular, cost models and efficient query optimization techniques devised for parallel database systems (e.g., <ref> [SE93, GW93] </ref>) can be adapted to distributed database systems. 7 Conclusion In order to build high-performance database systems that combine the best aspects of the relational and object-oriented approaches, it is necessary to design flexible client-server architectures that can fully exploit the client and server resources available in the system.
Reference: [HF86] <author> R. Hagmann and D. Ferrari. </author> <title> Performance analysis of several back-end database architectures. </title> <journal> ACM TODS, </journal> <volume> 11(1), </volume> <year> 1986. </year>
Reference-contexts: Carey and Lu studied join algorithms in local networks [LC85] and devised methods to load balance a system if data is replicated at several sites [CL86]. Among the first to study query processing specifically in a client-server environment were Hagmann and Ferrari <ref> [HF86] </ref>. They investigated different ways to split the functionality of a DBMS (e.g., query parsing, optimization, and execution) between client and server machines. Related work on multi-node query processing includes techniques devised for parallel databases.
Reference: [IK90] <author> Y. Ioannidis and Y. Kang. </author> <title> Randomized algorithms for optimizing large join queries. </title> <booktitle> ACM SIGMOD Conf., </booktitle> <address> Atlantic City, </address> <year> 1990. </year>
Reference-contexts: The simulation model captures the resources (CPU, memory, disk, and network) of a group of interconnected client and server machines. The query optimizer is based on randomized two-phase query optimization, which combines simulated annealing and iterative improvement, as proposed by Ioannidis and Kang <ref> [IK90] </ref>. Optimization can be aimed at minimizing either 3 (a)Data-Shipping (b) Query-Shipping (c) Hybrid-Shipping the cost or the response-time predictions for a query plan. The search space explored by the optimizer includes the full range of shipping strategies; it can, however, be constrained to produce only data-shipping or query-shipping plans. <p> The results of the performance study are then presented in Sections 4 and 5. 3.1 Query Optimization 3.1.1 Implementation of the Optimizer The query plans that are evaluated in this study are obtained using randomized two-phase query optimization (2PO) <ref> [IK90] </ref>. Randomized query optimization was chosen for the following reasons. First, randomized approaches have been shown to be successful at finding very good join orderings [IK90] and generating efficient plans even with very large search spaces [LVZ93]. <p> 3.1 Query Optimization 3.1.1 Implementation of the Optimizer The query plans that are evaluated in this study are obtained using randomized two-phase query optimization (2PO) <ref> [IK90] </ref>. Randomized query optimization was chosen for the following reasons. First, randomized approaches have been shown to be successful at finding very good join orderings [IK90] and generating efficient plans even with very large search spaces [LVZ93]. Second, the simplicity of the approach allowed the optimizer to be constructed quickly, and to be easily configured to generate plans for the three different execution strategies. <p> The possible moves are the following (where A, B, and C denote either temporary or base relations): 6 This study uses the same parameter settings to control the II and SA phases as used in <ref> [IK90] </ref>. 1. (A 1 B) 1 C ! A 1 (B 1 C) 3. A 1 (B 1 C) ! (A 1 B) 1 C 5. Change the site annotation of a join to consumer, outer relation, or inner relation. 6. <p> We propose a 2-step optimizer that works as follows: 1. At compile time, generate an incomplete query plan including join orderings but no site annotations (e.g., using a randomized <ref> [IK90] </ref> or System-R-style [S + 79] optimizer). 2. At execution time, carry out site selection and determine where to execute every operator of the plan (e.g., using simulated annealing [MLR90]). 2-Step optimization, therefore, takes into account that the system state can change rapidly; e.g., due to caching and varying loads.
Reference: [J + 90] <author> B. Jenq, et al. </author> <title> Query processing in distributed ORION. </title> <booktitle> 2nd EDBT Conf., </booktitle> <address> Venice, </address> <year> 1990. </year>
Reference-contexts: Current trends towards very large systems with many sites have motivated the design of new flexible architectures that, like hybrid-shipping, allow query processing on clients and servers; examples are Orion <ref> [J + 90] </ref> and Mariposa [S + 94]. Furthermore, SHORE [C + 94] provides a mechanism to allow the inclusion of a flexible query execution policy. There have been several closely related studies of query processing in local-area and client-server database systems.
Reference: [KF95] <author> D. Kossmann and M. Franklin. </author> <title> A study of query execution strategies for client-server database systems. </title> <type> Technical Report, </type> <institution> University of Maryland, </institution> <year> 1995. </year>
Reference-contexts: For simplicity however, in this paper we focus on results for one particular type of query, as the effects described in Section 4 were seen in varying degrees, for all query types we investigated. Additional experiments can be found in <ref> [KF95] </ref>. The benchmark queries are chain joins with moderate selectivity. These queries can be thought of as functional joins, as would be used to reconstruct normalized data.
Reference: [Kul94] <author> K. Kulkarni. </author> <title> Object-oriented extensions in SQL3: A status report. </title> <booktitle> ACM SIGMOD Conf., </booktitle> <address> Minneapolis, </address> <year> 1994. </year>
Reference-contexts: Bjorn Jonsson was supported in part by a Fulbright Fellowship. Donald Kossmann was supported in part by the Humboldt-Stiftung. towards integrating object-oriented features into their systems (e.g., the emerging SQL3 standard <ref> [Kul94] </ref>) while vendors of object-oriented systems are adding more powerful query facilities [Cat94]. Furthermore, a new class of hybrid Object-Relational systems has recently started to appear (e.g., Illus-tra and UniSQL).
Reference: [LC85] <author> H. Lu and M. Carey. </author> <title> Some experimental results on distributed join algorithms in a local network. </title> <booktitle> 11th VLDB Conf., </booktitle> <address> Stockholm, </address> <year> 1985. </year>
Reference-contexts: Furthermore, SHORE [C + 94] provides a mechanism to allow the inclusion of a flexible query execution policy. There have been several closely related studies of query processing in local-area and client-server database systems. Carey and Lu studied join algorithms in local networks <ref> [LC85] </ref> and devised methods to load balance a system if data is replicated at several sites [CL86]. Among the first to study query processing specifically in a client-server environment were Hagmann and Ferrari [HF86].
Reference: [LVZ93] <author> R. Lanzelotte, P. Valduriez, and M. Zait. </author> <title> On the effectiveness of optimization search strategies for parallel execution spaces. </title> <booktitle> 19th VLDB Conf., </booktitle> <address> Dublin, </address> <year> 1993. </year>
Reference-contexts: Randomized query optimization was chosen for the following reasons. First, randomized approaches have been shown to be successful at finding very good join orderings [IK90] and generating efficient plans even with very large search spaces <ref> [LVZ93] </ref>. Second, the simplicity of the approach allowed the optimizer to be constructed quickly, and to be easily configured to generate plans for the three different execution strategies. Third, the randomized approach optimizes very complex queries in a reasonable amount of time.
Reference: [ML86] <author> L. Mackert and G. Lohman. </author> <title> R fl optimizer validation and performance evaluation for distributed queries. </title> <booktitle> 12th VLDB Conf., </booktitle> <address> Kyoto, </address> <year> 1986. </year>
Reference-contexts: The cost model that we used is capable of estimating both the total cost and the response time of a query plan for a given system configuration. The total-cost estimates are based on the model of Mackert and Lohman <ref> [ML86] </ref>. The response-time estimates are generated using the model of [GHK92]. The response time of a query is defined to be the elapsed time from the initiation of query execution until the time that the last tuple of the query result is displayed at the client.
Reference: [MLR90] <author> T. Martin, K. Lam, and J. Russell. </author> <title> An evaluation of site selection algorithms for distributed query processing. </title> <journal> Computer Journal, </journal> <volume> 33(1), </volume> <year> 1990. </year>
Reference-contexts: At compile time, generate an incomplete query plan including join orderings but no site annotations (e.g., using a randomized [IK90] or System-R-style [S + 79] optimizer). 2. At execution time, carry out site selection and determine where to execute every operator of the plan (e.g., using simulated annealing <ref> [MLR90] </ref>). 2-Step optimization, therefore, takes into account that the system state can change rapidly; e.g., due to caching and varying loads.
Reference: [PCV94] <author> J. Patel, M. Carey, and M. Vernon. </author> <title> Accurate modeling of the hybrid hash join algorithm. </title> <booktitle> ACM SIGMETRICS Conf., </booktitle> <address> Nashville, </address> <year> 1994. </year>
Reference-contexts: The settings are largely based on those used in previous studies; e.g., <ref> [Fra96, PCV94] </ref>. 7 The allocation of memory in our experiments is described in Section 4.1. Several details deserve additional explanation. <p> As a result, disk I/O is always required to read the base relations from either a client or a server disk. As stated in Section 3.2, the simulator contains a detailed disk model. In this study, we use the settings from <ref> [PCV94] </ref>, which were intended to model a Fujitsu M2266 disk drive.
Reference: [R + 95] <author> N. Roussopoulos, et al. </author> <title> The ADMS project: Views R us. </title> <journal> IEEE Data Engeneering Bulletin, </journal> <volume> 18(2), </volume> <year> 1995. </year>
Reference-contexts: Data-shipping is used in most object database systems, and it has been investigated, e.g., in [D + 90, Fra96]. Query-shipping, on the other hand, is used in most traditional relational systems. ADMS <ref> [R + 95] </ref> is an example of a system that uses an extended query-shipping architecture: query results are cached at clients, and a query can be answered at the client if it matches the cached results of a previous query; if it does not match, the query is executed at the
Reference: [S + 79] <author> P. Selinger, et al. </author> <title> Access path selection in a relational database management system. </title> <booktitle> ACM SIGMOD Conf., </booktitle> <address> Boston, </address> <year> 1979. </year>
Reference-contexts: We propose a 2-step optimizer that works as follows: 1. At compile time, generate an incomplete query plan including join orderings but no site annotations (e.g., using a randomized [IK90] or System-R-style <ref> [S + 79] </ref> optimizer). 2. At execution time, carry out site selection and determine where to execute every operator of the plan (e.g., using simulated annealing [MLR90]). 2-Step optimization, therefore, takes into account that the system state can change rapidly; e.g., due to caching and varying loads.
Reference: [S + 90] <author> M. Stonebraker, et al. </author> <title> Third generation data base system manifesto. </title> <type> Technical Report, </type> <institution> UC Berkeley, </institution> <year> 1990. </year>
Reference-contexts: Because of these different, and in some ways complimentary strengths, it has become apparent that database systems combining the best aspects of the relational and object-oriented approaches are likely to gain acceptance across a larger range of applications (e.g., <ref> [S + 90] </ref>). 1.1 Merging RDBMS and ODBMS Functionality Database system builders have been approaching this perceived need in several ways. Relational vendors are moving fl This work was partially supported by NSF Grant IRI-94-09575, an IBM SUR award, and a grant from Bellcore.
Reference: [S + 94] <author> M. Stonebraker, et al. Mariposa: </author> <title> A new architecture for distributed data. </title> <booktitle> IEEE Conf. on Data Engineering, </booktitle> <address> Houston, </address> <year> 1994. </year>
Reference-contexts: A static query optimizer generates a query plan based on the state of the system at compile time or based on general assumptions about the system state. 2-Step optimization which has been proposed for distributed systems in <ref> [CL86, S + 94] </ref> performs only some optimization decisions at compile time and then adjusts the partially optimized plan prior to query execution. We propose a 2-step optimizer that works as follows: 1. <p> Current trends towards very large systems with many sites have motivated the design of new flexible architectures that, like hybrid-shipping, allow query processing on clients and servers; examples are Orion [J + 90] and Mariposa <ref> [S + 94] </ref>. Furthermore, SHORE [C + 94] provides a mechanism to allow the inclusion of a flexible query execution policy. There have been several closely related studies of query processing in local-area and client-server database systems.
Reference: [SE93] <author> J. Srivastava and G. Elsesser. </author> <title> Optimizing multi-join queries in parallel relational databases. </title> <booktitle> 2nd PDIS Conf., </booktitle> <address> San Diego, </address> <year> 1993. </year>
Reference-contexts: They investigated different ways to split the functionality of a DBMS (e.g., query parsing, optimization, and execution) between client and server machines. Related work on multi-node query processing includes techniques devised for parallel databases. In particular, cost models and efficient query optimization techniques devised for parallel database systems (e.g., <ref> [SE93, GW93] </ref>) can be adapted to distributed database systems. 7 Conclusion In order to build high-performance database systems that combine the best aspects of the relational and object-oriented approaches, it is necessary to design flexible client-server architectures that can fully exploit the client and server resources available in the system.
Reference: [Sha86] <author> L. Shapiro. </author> <title> Join processing in database systems with large main memories. </title> <journal> ACM TODS, </journal> <volume> 11(9), </volume> <year> 1986. </year> <month> 12 </month>
Reference-contexts: In addition to the costs for system functions such as messages and I/Os, the costs associated with the query operators are also modeled; i.e., the CPU cost of displaying, 5 comparing, hashing, and moving tuples in memory. All joins are processed using hybrid hashing <ref> [Sha86] </ref>. The amount of memory allocated to joins on a site is specified by BufAlloc 7 . 3.3 Workload Specification In order to examine the different execution strategies under a range of system configurations and settings, we use a benchmark consisting of 2-way and 10-way joins. <p> The amount of memory allocated for joins depends on whether the joins of the query are to be executed with minimum or maximum allocation (i.e., the BufAlloc parameter). Minimum and maximum allocations are defined according to Shapiro <ref> [Sha86] </ref>. Maximum allocation allows the hash table for the inner relation to be built entirely in main memory.
References-found: 25

