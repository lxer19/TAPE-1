URL: ftp://ftp.isi.edu/isi-pubs/rr-93-366.ps.Z
Refering-URL: http://www.isi.edu/isi-technical-reports.html
Root-URL: http://www.isi.edu
Title: Synthesis of Asynchronous Systems from Data Flow Specifications  
Author: Tzyh-Yung Wuu, USC-ISI Sarma B. K. Vrudhula, UA-ECE 
Date: December 1993  
Pubnum: ISI/RR-93-366  
Abstract: ISI Research Report ISI/RR-93-366 December 1993 This research was sponsored in part by the Advanced Research Projects Agency under contract number MDA903-92-D-0020 and in part by a grant from the National Science Foundation under award number MIP-9111206. Views and conclusions contained in this report are the authors' and should not be interpreted as representing the official opinion or policy of ARPA, NSF, the U.S. Government, or any person or agency connected with them. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> V. Akella and G. Gopalakrishnan. "SHILPA: </author> <title> A High-Level Synthesis System for Self-Timed Circuits". </title> <booktitle> In Proceedings of the ICCAD-92, </booktitle> <pages> pages 587-591, </pages> <year> 1992. </year>
Reference-contexts: The other approach focuses on the synthesis of asynchronous systems by the interconnection of pre-defined asynchronous modules. These methods attempt to translate a high-level language specification such as CSP, CSP-liked descriptions, OCCAM, or Trace structures <ref> [1, 5, 6, 9, 30] </ref> into a realization. The main task in these synthesis approaches is to correctly decompose/refine the given behavior description into atomic constructs, which have corresponding pre-defined asynchronous modules. <p> Therefore, we can show that Figures 36 (b) and (c) are equivalent as follows. <ref> [1; 1 ffi 2; 2 ffi 2] </ref> : hd 1 ; hd 2 ; d 3 ii = h1 : hd 1 ; hd 2 ; d 3 ii; = hd 1 ; 1 : hd 2 ; d 3 i; 2 : hd 2 ; d 3 ii 42 Similarly, <p> ; d 3 ii = h1 : hd 1 ; hd 2 ; d 3 ii; = hd 1 ; 1 : hd 2 ; d 3 i; 2 : hd 2 ; d 3 ii 42 Similarly, we can show that Figures 36 (a) and (d) are equivalent, i.e., <ref> [1; [2; 3] </ref>] : hd 1 ; d 2 ; d 3 i = hd 1 ; hd 2 ; d 3 ii A transformation for sharing scheme reduction Figure 37 (a) is a DFG under a special condition, which often appears after sharing schemes are applied.
Reference: [2] <author> J. Backus. </author> <title> "Can Programming Be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs", The 1977 Turing Award Lecture. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 613-641, </pages> <year> 1978. </year>
Reference-contexts: With atomic functions for data type conversion, Figures 36 (b) and (c) are equivalent, and Figures 36 (a) and (d) are equivalent. R ([1; 1 ffi 2; 2 ffi 2]) and R ([1; <ref> [2; 3] </ref>]) are atomic functions called routers in our system. Router functions rearrange input data by copying, repeating, and shu*ing input data. <p> R ([1; 1 ffi 2; 2 ffi 2]) and R ([1; [2; 3]]) are atomic functions called routers in our system. Router functions rearrange input data by copying, repeating, and shu*ing input data. The notation of router functions is based on Backus' FP <ref> [2] </ref>, where i is the FP selector function, square bracket [: : :] is the functional form of construction, and circle ffi is the functional form of composition. <p> d 3 ii = h1 : hd 1 ; hd 2 ; d 3 ii; = hd 1 ; 1 : hd 2 ; d 3 i; 2 : hd 2 ; d 3 ii 42 Similarly, we can show that Figures 36 (a) and (d) are equivalent, i.e., [1; <ref> [2; 3] </ref>] : hd 1 ; d 2 ; d 3 i = hd 1 ; hd 2 ; d 3 ii A transformation for sharing scheme reduction Figure 37 (a) is a DFG under a special condition, which often appears after sharing schemes are applied.
Reference: [3] <author> K. R. Baker. </author> <title> Introduction to Sequencing and Scheduling. </title> <publisher> John Wiley & Sons, </publisher> <year> 1974. </year>
Reference-contexts: With atomic functions for data type conversion, Figures 36 (b) and (c) are equivalent, and Figures 36 (a) and (d) are equivalent. R ([1; 1 ffi 2; 2 ffi 2]) and R ([1; <ref> [2; 3] </ref>]) are atomic functions called routers in our system. Router functions rearrange input data by copying, repeating, and shu*ing input data. <p> ; d 3 ii = h1 : hd 1 ; hd 2 ; d 3 ii; = hd 1 ; 1 : hd 2 ; d 3 i; 2 : hd 2 ; d 3 ii 42 Similarly, we can show that Figures 36 (a) and (d) are equivalent, i.e., <ref> [1; [2; 3] </ref>] : hd 1 ; d 2 ; d 3 i = hd 1 ; hd 2 ; d 3 ii A transformation for sharing scheme reduction Figure 37 (a) is a DFG under a special condition, which often appears after sharing schemes are applied. <p> d 3 ii = h1 : hd 1 ; hd 2 ; d 3 ii; = hd 1 ; 1 : hd 2 ; d 3 i; 2 : hd 2 ; d 3 ii 42 Similarly, we can show that Figures 36 (a) and (d) are equivalent, i.e., [1; <ref> [2; 3] </ref>] : hd 1 ; d 2 ; d 3 i = hd 1 ; hd 2 ; d 3 ii A transformation for sharing scheme reduction Figure 37 (a) is a DFG under a special condition, which often appears after sharing schemes are applied. <p> This problem is closely related to the resource-constrained project scheduling problem <ref> [3] </ref>, and the temporal aspects of this scheduling problem can be equivalently represented by partial orders [22]. Therefore, this problem is called the sequencing and allocation problem in asynchronous system synthesis. <p> The details about theoretical basis of these methods can be found in <ref> [3] </ref>. They are a heuristic algorithm and a branch and bound algorithm. Heuristic algorithm This algorithm uses the longest path delay from the output of the node to the output of the DFG to prioritize all operations in the DFG, then schedules these operations one by one to available resources. <p> Branch and bound algorithm A schedule is an active schedule if we cannot find another schedule by simply shifting a scheduled node to an earlier starting time. It has been shown that an optimum schedule is an active schedule <ref> [3] </ref>. This algorithm exhaustively enumerates all active schedules to find the optimum schedule, and the branch and bound technique is used to reduce the search space. We will not discuss the detail of this algorithm, which can be found in related literature [3]. 7 Examples Two examples are presented in this <p> that an optimum schedule is an active schedule <ref> [3] </ref>. This algorithm exhaustively enumerates all active schedules to find the optimum schedule, and the branch and bound technique is used to reduce the search space. We will not discuss the detail of this algorithm, which can be found in related literature [3]. 7 Examples Two examples are presented in this section. The first design is a 16-bit unsigned add-and-shift multiplier, and the second design is a 16-point, 16-bit FIR digital filter.
Reference: [4] <author> E. Brunvand. </author> <title> Translating Concurrent Communicating Programs into Asynchronous Circuits. </title> <type> Technical Report CMU-CS-91-198, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: The next two events are that the request is reset to 0 by the sender and that the acknowledge is reset to 0 by the receiver. In terms of the period of data validation, there two kinds of conventions for the four-phase handshaking protocol <ref> [4] </ref>. In the narrow convention, the sender holds the data valid from the rising request signal to the rising acknowledge signal. In the broad convention, the sender holds the data valid from the rising request signal to the falling acknowledge signal.
Reference: [5] <author> E. Brunvand and R. F. Sproull. </author> <title> Translating Concurrent Communicating Programs into Delay-Insensitive Circuits. </title> <type> Technical Report CMU-CS-89-126, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> April </month> <year> 1989. </year>
Reference-contexts: Moreover, the FSM model cannot describe concurrent behavior at any higher level. During the past five years there has been a tremendous resurgence of interest in the design of large scale asynchronous system [16] and more recently in the automatic synthesis of such systems <ref> [5, 6, 21] </ref>. An important aspect of certain types of asynchronous designs is that they 3 make it feasible to carry out large system design in a truly modular fashion by composing independently-designed components and ensuring correctness by construction [26, 30]. <p> The other approach focuses on the synthesis of asynchronous systems by the interconnection of pre-defined asynchronous modules. These methods attempt to translate a high-level language specification such as CSP, CSP-liked descriptions, OCCAM, or Trace structures <ref> [1, 5, 6, 9, 30] </ref> into a realization. The main task in these synthesis approaches is to correctly decompose/refine the given behavior description into atomic constructs, which have corresponding pre-defined asynchronous modules. <p> Notice that partitioning the synthesis procedure into steps is not unique and that the tasks of the synthesis steps are usually closely related [11, 18]. 4.5 Hardware Translation - Syntax-Directed Method We adopt the syntax-directed method <ref> [5, 6] </ref> to realize the physical design from the extended data flow graph (EDFG) specification. In this method, each basic construct in the high-level specification is directly translated into a corresponding hardware module.
Reference: [6] <author> S. M. Burns and A. J. Martin. </author> <title> Synthesis of Self-timed Circuits by Program Transformation. </title> <type> Technical Report 5253:TR:87, </type> <institution> Dept. of Computer Science, California Institute of Technology, </institution> <year> 1987. </year>
Reference-contexts: Moreover, the FSM model cannot describe concurrent behavior at any higher level. During the past five years there has been a tremendous resurgence of interest in the design of large scale asynchronous system [16] and more recently in the automatic synthesis of such systems <ref> [5, 6, 21] </ref>. An important aspect of certain types of asynchronous designs is that they 3 make it feasible to carry out large system design in a truly modular fashion by composing independently-designed components and ensuring correctness by construction [26, 30]. <p> The other approach focuses on the synthesis of asynchronous systems by the interconnection of pre-defined asynchronous modules. These methods attempt to translate a high-level language specification such as CSP, CSP-liked descriptions, OCCAM, or Trace structures <ref> [1, 5, 6, 9, 30] </ref> into a realization. The main task in these synthesis approaches is to correctly decompose/refine the given behavior description into atomic constructs, which have corresponding pre-defined asynchronous modules. <p> Notice that partitioning the synthesis procedure into steps is not unique and that the tasks of the synthesis steps are usually closely related [11, 18]. 4.5 Hardware Translation - Syntax-Directed Method We adopt the syntax-directed method <ref> [5, 6] </ref> to realize the physical design from the extended data flow graph (EDFG) specification. In this method, each basic construct in the high-level specification is directly translated into a corresponding hardware module.
Reference: [7] <author> T.-A. Chu. </author> <title> Synthesis of Self-timed VLSI Circuits from Graph Theoretic Specifications. </title> <type> Technical Report PhD thesis, </type> <institution> Dept. of EECS, Massachusetts Institute of Technology, </institution> <month> September </month> <year> 1987. </year>
Reference-contexts: In the area of asynchronous design there appear to be two approaches. One approach focuses on the design of reliable asynchronous circuits, e.g., hazard-free asynchronous circuits and delay-insensitive circuits. These methods are based on the manipulation of formal specifications such as signal transition graphs (STG) and Petri nets <ref> [7, 14, 15, 21, 23] </ref>. The other approach focuses on the synthesis of asynchronous systems by the interconnection of pre-defined asynchronous modules. These methods attempt to translate a high-level language specification such as CSP, CSP-liked descriptions, OCCAM, or Trace structures [1, 5, 6, 9, 30] into a realization.
Reference: [8] <author> A. L. Davis and R. M. Keller. </author> <title> "Data Flow Program Graphs". </title> <journal> IEEE COMPUTER, </journal> <volume> 15(2) </volume> <pages> 26-41, </pages> <year> 1982. </year>
Reference-contexts: Later, we will derive the extended data flow graph based on the same token model. 4 Data Flow Specification The data flow graph (DFG) is used as the input specification, and it is based on the token model used in data flow computing <ref> [8] </ref>. In this section, we briefly describe the structure and semantics of the DFG used in our synthesis system. A DFG is a directed graph with typed nodes and port-specific arcs, where port refers to the input/output terminals of a node. <p> A node is activated when all its necessary input arcs have tokens. An activated node computes or fires by absorbing all the tokens on its inputs and placing tokens on its outputs. There is no notion of synchronization among activated nodes, as these nodes operate asynchronously and concurrently <ref> [8] </ref>. 4.1 Basic Constructs By considering area/performance efficiency of asynchronous block implementation, we have generalized and enriched the basic DFG constructs, which are shown in Figure 7, from the conventional data flow specification. <p> The purpose of defining extended tokens is to emphasize the semantic difference between phantom nodes and non-phantom nodes, which are used in the conventional data flow graph <ref> [8] </ref>, and it is also to emphasize the relation among input data and output data of phantom nodes. 18 DFG vs. EDFG A DFG node is equivalent to its phantom counterpart with an input storage at each input port, e.g., the MFork/phantom MFork in Figure 15.
Reference: [9] <author> J. C. Ebergen. Arbiters: </author> <title> An Exercise in Specifying and Decomposing Asynchronously Communicating Components. </title> <type> Technical Report Technique Report CS-90-29, </type> <institution> Dept. of Computer Science, University of Waterloo, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: The other approach focuses on the synthesis of asynchronous systems by the interconnection of pre-defined asynchronous modules. These methods attempt to translate a high-level language specification such as CSP, CSP-liked descriptions, OCCAM, or Trace structures <ref> [1, 5, 6, 9, 30] </ref> into a realization. The main task in these synthesis approaches is to correctly decompose/refine the given behavior description into atomic constructs, which have corresponding pre-defined asynchronous modules.
Reference: [10] <author> A. D. Friedman and P. R. Menon. </author> <title> Theory and Design of Switching Circuits. </title> <publisher> Computer Science Press, Inc., </publisher> <year> 1975. </year>
Reference-contexts: The last section presents a conclusion for this work. 2 Background Much of the classical work done in asynchronous design has focused primarily on gate level control circuits. Methods for realizing such circuits are based on the Huffman model <ref> [10, 17] </ref> of a finite state machine (FSM). Such an approach is practical only for relatively small circuits. Moreover, the FSM model cannot describe concurrent behavior at any higher level.
Reference: [11] <author> D. Gajski et al. </author> <title> High-Level Synthesis Introduction to Chip and System Design. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1992. </year>
Reference-contexts: This enables the designer to rapidly explore many design alternatives at the data flow level, examining the 1 tradeoff between performance and area. Furthermore, these high-level design decisions can be replaced by design automation algorithms, namely, high-level synthesis <ref> [11, 18] </ref>. There are three main aspects of a synthesis system: the specification, the realization and the methods. The specification deals with developing a suitable representation of the abstract behavior. The realization is a representation of the system in terms of a set of interconnected components. <p> The EDFG is mainly used in the synthesis steps such as register minimization, deadlock prevention, and local transformation before the specifications are mapped to hardware modules. Notice that partitioning the synthesis procedure into steps is not unique and that the tasks of the synthesis steps are usually closely related <ref> [11, 18] </ref>. 4.5 Hardware Translation - Syntax-Directed Method We adopt the syntax-directed method [5, 6] to realize the physical design from the extended data flow graph (EDFG) specification. In this method, each basic construct in the high-level specification is directly translated into a corresponding hardware module. <p> This problem is analogous to the scheduling and allocation problem in synchronous system synthesis, but with no clock-controlled time step, i.e., the scheduling problem in an asynchronous system cannot be viewed as a partitioning of operations into time steps as in synchronous systems <ref> [11, 18] </ref>. This problem is closely related to the resource-constrained project scheduling problem [3], and the temporal aspects of this scheduling problem can be equivalently represented by partial orders [22]. Therefore, this problem is called the sequencing and allocation problem in asynchronous system synthesis.
Reference: [12] <author> J. P. Hayes. </author> <title> Computer Architecture and Organization. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <note> second edition, </note> <year> 1988. </year>
Reference-contexts: ASH (add-and-shift) takes the multiplicand (M ), a partial multiplication result (A; Q 0 ), and a partial multiplier (Q 00 ) to generate a new partial multiplication result and a new partial multiplier by means of the following operations <ref> [12] </ref>: fov; Ag A + M fl Q LSB ; where A, Q, and M are 16-bit, Q is formed by fQ 0 ; Q 00 g, ov is an 1-bit overflow for addition, and LSB +1 is the second least significant bit. f 1 is an atomic function that assigns
Reference: [13] <author> I. Koren and G. M. Silberman. </author> <title> "A Direct Mapping of Algorithms onto VLSI Processing Arrays Based on the Data Flow Approach". </title> <booktitle> In Proceedings of the 1983 International Conference on Parallel Processing, </booktitle> <pages> pages 335-337, </pages> <year> 1983. </year> <month> 71 </month>
Reference-contexts: It is necessary for the designer to explore these various design alternatives. The goal of our research is to tackle these design issues at system level. Our approach the resembles those approaches presented in <ref> [13, 19, 20] </ref> in the design specification and the mapping method. However, our approach is different from theirs in the following sense. Their basic modules are synchronous circuits. In their approach, each node in the data flow graph maps to a unique hardware module.
Reference: [14] <author> L. Lavagno, K. Keutzer, and A. Sangiovanni-Vincentelli. </author> <title> "Algorithms for Synthesis of Hazard-free Asynchronous Circuits". </title> <booktitle> In Proceedings of the 28th Design Automation Conference, </booktitle> <pages> pages 302-308, </pages> <year> 1991. </year>
Reference-contexts: In the area of asynchronous design there appear to be two approaches. One approach focuses on the design of reliable asynchronous circuits, e.g., hazard-free asynchronous circuits and delay-insensitive circuits. These methods are based on the manipulation of formal specifications such as signal transition graphs (STG) and Petri nets <ref> [7, 14, 15, 21, 23] </ref>. The other approach focuses on the synthesis of asynchronous systems by the interconnection of pre-defined asynchronous modules. These methods attempt to translate a high-level language specification such as CSP, CSP-liked descriptions, OCCAM, or Trace structures [1, 5, 6, 9, 30] into a realization.
Reference: [15] <author> K.-J. Lin and C.-S. Lin. </author> <title> "Automatic Synthesis of Asynchronous Circuits". </title> <booktitle> In Proceedings of the 28th Design Automation Conference, </booktitle> <pages> pages 296-301, </pages> <year> 1991. </year>
Reference-contexts: In the area of asynchronous design there appear to be two approaches. One approach focuses on the design of reliable asynchronous circuits, e.g., hazard-free asynchronous circuits and delay-insensitive circuits. These methods are based on the manipulation of formal specifications such as signal transition graphs (STG) and Petri nets <ref> [7, 14, 15, 21, 23] </ref>. The other approach focuses on the synthesis of asynchronous systems by the interconnection of pre-defined asynchronous modules. These methods attempt to translate a high-level language specification such as CSP, CSP-liked descriptions, OCCAM, or Trace structures [1, 5, 6, 9, 30] into a realization.
Reference: [16] <author> A. J. Martin et al. </author> <title> The Design of an Asynchronous Microprocessor. </title> <booktitle> Proceedings of the Decennial Caltech Conference on VLSI, </booktitle> <pages> pages 351-373, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: Such an approach is practical only for relatively small circuits. Moreover, the FSM model cannot describe concurrent behavior at any higher level. During the past five years there has been a tremendous resurgence of interest in the design of large scale asynchronous system <ref> [16] </ref> and more recently in the automatic synthesis of such systems [5, 6, 21].
Reference: [17] <author> E. J. McCluskey. </author> <title> Introduction to the Theory of Switching Circuits. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1965. </year>
Reference-contexts: The last section presents a conclusion for this work. 2 Background Much of the classical work done in asynchronous design has focused primarily on gate level control circuits. Methods for realizing such circuits are based on the Huffman model <ref> [10, 17] </ref> of a finite state machine (FSM). Such an approach is practical only for relatively small circuits. Moreover, the FSM model cannot describe concurrent behavior at any higher level.
Reference: [18] <author> M. C. McFarland, A. C. Parker, and P. Camposano. </author> <title> "The High-Level Synthesis of Digital Systems". </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 78(2) </volume> <pages> 301-318, </pages> <year> 1990. </year>
Reference-contexts: This enables the designer to rapidly explore many design alternatives at the data flow level, examining the 1 tradeoff between performance and area. Furthermore, these high-level design decisions can be replaced by design automation algorithms, namely, high-level synthesis <ref> [11, 18] </ref>. There are three main aspects of a synthesis system: the specification, the realization and the methods. The specification deals with developing a suitable representation of the abstract behavior. The realization is a representation of the system in terms of a set of interconnected components. <p> The EDFG is mainly used in the synthesis steps such as register minimization, deadlock prevention, and local transformation before the specifications are mapped to hardware modules. Notice that partitioning the synthesis procedure into steps is not unique and that the tasks of the synthesis steps are usually closely related <ref> [11, 18] </ref>. 4.5 Hardware Translation - Syntax-Directed Method We adopt the syntax-directed method [5, 6] to realize the physical design from the extended data flow graph (EDFG) specification. In this method, each basic construct in the high-level specification is directly translated into a corresponding hardware module. <p> This problem is analogous to the scheduling and allocation problem in synchronous system synthesis, but with no clock-controlled time step, i.e., the scheduling problem in an asynchronous system cannot be viewed as a partitioning of operations into time steps as in synchronous systems <ref> [11, 18] </ref>. This problem is closely related to the resource-constrained project scheduling problem [3], and the temporal aspects of this scheduling problem can be equivalently represented by partial orders [22]. Therefore, this problem is called the sequencing and allocation problem in asynchronous system synthesis.
Reference: [19] <author> B. Mendelson, B. Patel, and I. Koren. </author> <title> "designing special-purpose co-processors using the data-flow paradigm". In Advanced Topics in Data-Flow Computing. editted by J.-L. </title> <editor> Gaudiot and L. Bic, </editor> <publisher> Prentice-Hall Inc., </publisher> <pages> pages 547-570, </pages> <year> 1991. </year>
Reference-contexts: It is necessary for the designer to explore these various design alternatives. The goal of our research is to tackle these design issues at system level. Our approach the resembles those approaches presented in <ref> [13, 19, 20] </ref> in the design specification and the mapping method. However, our approach is different from theirs in the following sense. Their basic modules are synchronous circuits. In their approach, each node in the data flow graph maps to a unique hardware module.
Reference: [20] <author> B. Mendelson and G. M. Silberman. </author> <title> "Mapping Data Flow Programs on a VLSI Array of Processors". </title> <booktitle> In Proceedings of International Symposium on Computer Architecture, </booktitle> <pages> pages 72-80, </pages> <year> 1987. </year>
Reference-contexts: It is necessary for the designer to explore these various design alternatives. The goal of our research is to tackle these design issues at system level. Our approach the resembles those approaches presented in <ref> [13, 19, 20] </ref> in the design specification and the mapping method. However, our approach is different from theirs in the following sense. Their basic modules are synchronous circuits. In their approach, each node in the data flow graph maps to a unique hardware module.
Reference: [21] <author> T. H.-Y. Meng, R. W. Brodersen, and D. G. Messerschmitt. </author> <title> "Automatic Synthesis of Asynchronous Circuits from High-Level Specifications". </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 8(11) </volume> <pages> 1185-1205, </pages> <year> 1989. </year>
Reference-contexts: Moreover, the FSM model cannot describe concurrent behavior at any higher level. During the past five years there has been a tremendous resurgence of interest in the design of large scale asynchronous system [16] and more recently in the automatic synthesis of such systems <ref> [5, 6, 21] </ref>. An important aspect of certain types of asynchronous designs is that they 3 make it feasible to carry out large system design in a truly modular fashion by composing independently-designed components and ensuring correctness by construction [26, 30]. <p> In the area of asynchronous design there appear to be two approaches. One approach focuses on the design of reliable asynchronous circuits, e.g., hazard-free asynchronous circuits and delay-insensitive circuits. These methods are based on the manipulation of formal specifications such as signal transition graphs (STG) and Petri nets <ref> [7, 14, 15, 21, 23] </ref>. The other approach focuses on the synthesis of asynchronous systems by the interconnection of pre-defined asynchronous modules. These methods attempt to translate a high-level language specification such as CSP, CSP-liked descriptions, OCCAM, or Trace structures [1, 5, 6, 9, 30] into a realization. <p> The computational part can also be implemented by differential cascode voltage switch logic (DCVSL) without added delay <ref> [21] </ref>. DCVSL is suitable for four-phase handshaking operation; therefore, we need to have two-to-four and four-to-two phase change circuits to make this kind of circuit useful in two-phase design.
Reference: [22] <author> R. H. Mohring. </author> <title> "algorithmic aspects of comparability graphs and interval graphs". In Graphs and Orders The Role of Graphs in the Theory of Ordered Sets and Its Applications. editted by I. Rival, </title> <booktitle> NATO ASI Series, </booktitle> <pages> pages 41-101, </pages> <year> 1984. </year>
Reference-contexts: This problem is closely related to the resource-constrained project scheduling problem [3], and the temporal aspects of this scheduling problem can be equivalently represented by partial orders <ref> [22] </ref>. Therefore, this problem is called the sequencing and allocation problem in asynchronous system synthesis. Based on the goal of the synthesis task, there are many kinds of synthesis problems, e.g., the cost-constrained synthesis problem and the performance-constrained synthesis problem [24].
Reference: [23] <author> C. E. Molnar, T.-P. Fang, and F. U. Rosenberger. </author> <title> "Synthesis of Delay-Insensitive Modules". </title> <booktitle> In 1985 Chapel Hill Conference on VLSI, </booktitle> <pages> pages 67-86, </pages> <year> 1985. </year>
Reference-contexts: In the area of asynchronous design there appear to be two approaches. One approach focuses on the design of reliable asynchronous circuits, e.g., hazard-free asynchronous circuits and delay-insensitive circuits. These methods are based on the manipulation of formal specifications such as signal transition graphs (STG) and Petri nets <ref> [7, 14, 15, 21, 23] </ref>. The other approach focuses on the synthesis of asynchronous systems by the interconnection of pre-defined asynchronous modules. These methods attempt to translate a high-level language specification such as CSP, CSP-liked descriptions, OCCAM, or Trace structures [1, 5, 6, 9, 30] into a realization.
Reference: [24] <author> N. Park and A. C. Parker. "Sehwa: </author> <title> A Software Package for Synthesis of Pipelines from Behavioral Specifications". </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 7(3) </volume> <pages> 356-370, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Therefore, this problem is called the sequencing and allocation problem in asynchronous system synthesis. Based on the goal of the synthesis task, there are many kinds of synthesis problems, e.g., the cost-constrained synthesis problem and the performance-constrained synthesis problem <ref> [24] </ref>.
Reference: [25] <author> C. V. Ramamoorthy and G. S. Ho. </author> <title> "Performance Evaluation of Asynchronous Concurrent Systems Using Petri Nets. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(5):440-449, </volume> <year> 1980. </year>
Reference-contexts: In this section we first use timed Petri nets <ref> [25] </ref> to model the timing behavior of basic blocks. Then we showed that the composition of these timed Petri net models can be used to express the timing behavior 20 of asynchronous systems which are composed of basic blocks. <p> Ro: output data ready this corresponds to the output "request" signal transition. Ao: output data done this corresponds to the output "acknowledge" signal transition. The timing behavior of basic blocks is most easily described using timed Petri nets <ref> [25] </ref>, where transitions represent input/output (control) events of the block, and places represent the conditions of events in the block.
Reference: [26] <author> C. L. Seitz. </author> <title> "System Timing". In Introduction to VLSI Systems. </title> <editor> by C. Mead and L. Conway, </editor> <publisher> Addison Wesley, </publisher> <pages> pages 128-262, </pages> <year> 1980. </year>
Reference-contexts: An important aspect of certain types of asynchronous designs is that they 3 make it feasible to carry out large system design in a truly modular fashion by composing independently-designed components and ensuring correctness by construction <ref> [26, 30] </ref>. In the area of asynchronous design there appear to be two approaches. One approach focuses on the design of reliable asynchronous circuits, e.g., hazard-free asynchronous circuits and delay-insensitive circuits. <p> These are shown in Figure 2. Our current implementation follows the two-phase handshaking protocol with the bundled data convention <ref> [26, 28] </ref>. Referring to Figure 2 (b) we see that there are three events in each cycle of data transfer. First, valid data is put on the data bus by the sender. <p> Muller C-element There are two inputs and one output for a Muller C-element. The output of a C-element is 1 if all the inputs are 1, and it is 0 if all the inputs are 0; otherwise its value remains unchanged <ref> [26] </ref>. A two input C-element can be viewed as a logical and of two events, where an event can be a 0-1 or a 1-0 transition [28]. This behavior is shown in Asynchronous register The asynchronous register proposed by Sutherland is defined as follows.
Reference: [27] <author> E. A. Snow. </author> <title> Automation of Module Set Independent Register-Transfer Level Design. </title> <type> Technical Report Ph.D. Thesis, </type> <institution> Electrical Engineering Department, Carnegie-Mellon University, </institution> <month> April </month> <year> 1978. </year> <month> 72 </month>
Reference-contexts: of the data computation and the control generation, which is a hardware implementation issue and is not discussed in this report. 40 6.2 Local Transformations Algorithmic transformations can be used to improve the design efficiency at the behavioral level so that the resulting design description can generate a suitable implementation <ref> [27, 29, 31] </ref>. Most transformations use the peephole optimization technique, used similarly in the compiler design, and are therefore called local transformations in this context. The biases in behavioral level descriptions are caused by the designers' coding style or generated by other transformations such as sharing schemes. <p> Transformations are developed to reduce the number of operations, to reduce the size of control structures, to reduce length of the critical path, to remove the redundancy, and so on. Snow has systematically developed transformations for the C-MU RT-CAD system <ref> [27] </ref>. Most of Snow's transformations are general enough to have analogous transformations in our system such as dead activity elimination, redundant activity elimination, select factoring/combination, etc., so we will not describe the available transformations in our system.
Reference: [28] <author> I. E. Sutherland. "MICROPIPELINES", </author> <title> The 1988 Turing Award Lecture. </title> <journal> Communi--cations of the ACM, </journal> <volume> 32(6) </volume> <pages> 720-738, </pages> <year> 1989. </year>
Reference-contexts: a node representing an operator (or a hardware module) in the final EDFG may correspond to more than one node representing an operation (or a computation) in the original DFG specification. 3 Hardware Implementation and Data Flow Model The hardware model that is employed here is based on Sutherland's Micropipelines <ref> [28] </ref>. This model assumes that request signals are bundled with the data signals to ensure proper operation, namely, the bundled data convention. Unlike speed-independent and delay-insensitive designs, the micropipeline model requires determination of the delays in the computational blocks. <p> These are shown in Figure 2. Our current implementation follows the two-phase handshaking protocol with the bundled data convention <ref> [26, 28] </ref>. Referring to Figure 2 (b) we see that there are three events in each cycle of data transfer. First, valid data is put on the data bus by the sender. <p> protocol with the bundled data convention, a system may contain different protocols for different data transfers in its implementation, as long as the sender and the receiver of each data transfer follow the same protocol 1 . 3.2 Realization of a Basic Block A functional block as proposed by Sutherland <ref> [28] </ref> has the structure shown in Figure 5 (a). There are three basic elements in this structure. The Muller C-element, represented by a "C" gate, is used to control the handshaking protocol. The asynchronous register, represented by a "reg" block, is used to capture and pass input data. <p> A two input C-element can be viewed as a logical and of two events, where an event can be a 0-1 or a 1-0 transition <ref> [28] </ref>. This behavior is shown in Asynchronous register The asynchronous register proposed by Sutherland is defined as follows. <p> The bundled data convention and the bounded delay model are used here primarily to save silicon area and the design time for the computational parts. Combining Muller C-elements and asynchronous registers forms the pipeline structure of asynchronous systems, i.e., micropipelines <ref> [28] </ref>. <p> Therefore, data at I4 can start being executed by the right MUL even though the data of I2 is still in the sharing structure. 6.1.3 Sharing Scheme with Micropipelined Shared Unit A node/function which is micropipelined <ref> [28] </ref> by being partitioned into a pipeline, i.e., this node becomes a macro function defined by a series of sub-functions.
Reference: [29] <author> H. Trickey. "Flamel: </author> <title> A High-Level Hardware Compiler". </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 6(2) </volume> <pages> 259-269, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: of the data computation and the control generation, which is a hardware implementation issue and is not discussed in this report. 40 6.2 Local Transformations Algorithmic transformations can be used to improve the design efficiency at the behavioral level so that the resulting design description can generate a suitable implementation <ref> [27, 29, 31] </ref>. Most transformations use the peephole optimization technique, used similarly in the compiler design, and are therefore called local transformations in this context. The biases in behavioral level descriptions are caused by the designers' coding style or generated by other transformations such as sharing schemes.
Reference: [30] <author> J. L. A. van de Snepscheut. </author> <title> "Deriving Circuits from Programs". </title> <booktitle> Third Caltech Conference on Very Large Scale Integration, </booktitle> <pages> pages 241-256, </pages> <month> March </month> <year> 1983. </year>
Reference-contexts: An important aspect of certain types of asynchronous designs is that they 3 make it feasible to carry out large system design in a truly modular fashion by composing independently-designed components and ensuring correctness by construction <ref> [26, 30] </ref>. In the area of asynchronous design there appear to be two approaches. One approach focuses on the design of reliable asynchronous circuits, e.g., hazard-free asynchronous circuits and delay-insensitive circuits. <p> The other approach focuses on the synthesis of asynchronous systems by the interconnection of pre-defined asynchronous modules. These methods attempt to translate a high-level language specification such as CSP, CSP-liked descriptions, OCCAM, or Trace structures <ref> [1, 5, 6, 9, 30] </ref> into a realization. The main task in these synthesis approaches is to correctly decompose/refine the given behavior description into atomic constructs, which have corresponding pre-defined asynchronous modules.
Reference: [31] <author> R. A. Walker and D. E. Thomas. </author> <title> "Design Representation and Transformation in The System Architect's Workbench". </title> <booktitle> In Proceedings of the ICCAD-87, </booktitle> <pages> pages 166-169, </pages> <year> 1987. </year>
Reference-contexts: of the data computation and the control generation, which is a hardware implementation issue and is not discussed in this report. 40 6.2 Local Transformations Algorithmic transformations can be used to improve the design efficiency at the behavioral level so that the resulting design description can generate a suitable implementation <ref> [27, 29, 31] </ref>. Most transformations use the peephole optimization technique, used similarly in the compiler design, and are therefore called local transformations in this context. The biases in behavioral level descriptions are caused by the designers' coding style or generated by other transformations such as sharing schemes.
Reference: [32] <author> T.-Y. Wuu. </author> <title> A Data-Driven Model for Asynchronous System Synthesis. </title> <type> Technical Report Thesis Proposal, </type> <institution> Electrical Engineering-Systems, University of Southern California, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Thus there is a one-to-one correspondence between the elements of an EDGF and the hardware modules (see Figure 16). We have developed all the mappings in our cell library <ref> [32] </ref>, e.g., Figure 17 shows a design for the 4-output MFork. <p> The last step is to map the EDFG description into RTL netlist for the layout generation. The implementation results will be shown in Section 7.3. 7.3 Experimental Results We have implemented the example designs discussed in the preceding section using a library of asynchronous building blocks <ref> [32] </ref> composed with an industrial standard cell library, HP C34100 [34], in a commercial CAD tool, Cadence Design Framework II T M . Both the RTL netlist and the layout of these designs were produced 10 . <p> Many other issues regarding the design of basic asynchronous blocks and the hardware implementation have not been covered in this report, but they play an important role in realizing and demonstrating this design method. The detail of the design of basic asynchronous blocks can be found in <ref> [32] </ref>. Acknowledgement The authors thank Cesar Pina and Wes Hansford for offering the circuit design environment at MOSIS, allowing us to easily verify our ideas. We appreciate the use of the MOSIS netlist-to-parts service, standard cell library, and implementation tools.
Reference: [33] <author> T.-Y. Wuu and S.B.K. Vrudhula. </author> <title> A Design of a Fast and Area Efficient Multi-input Muller C-element. </title> <journal> IEEE Transactions on VLSI Systems, </journal> <volume> 1(2) </volume> <pages> 215-219, </pages> <year> 1993. </year>
Reference-contexts: c Based on the analysis of our design library, the forward propagation delay time of the n-input MSelector, F P MSelector (n), can be formulated as k 1 + dlog 2 ne fl k 2 , where k 1 , k 2 are constant factors and k 1 k 2 <ref> [33] </ref>. Generally we can ignore k 2 , and assume that F P MSelector (n) = F P MSelector is a constant.
Reference: [34] <institution> The HP C34100 Standard Cell Library Data Manual. Hewlett-Packard Company, Integrated Circuit Business Division, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: The implementation results will be shown in Section 7.3. 7.3 Experimental Results We have implemented the example designs discussed in the preceding section using a library of asynchronous building blocks [32] composed with an industrial standard cell library, HP C34100 <ref> [34] </ref>, in a commercial CAD tool, Cadence Design Framework II T M . Both the RTL netlist and the layout of these designs were produced 10 .
Reference: [35] <institution> Guidelines for Using The MOSIS Netlist-to-Parts Service, ViewLogic CMOSN Design Kit. USC/ISI, MOSIS Project, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: The details of realizations and synthesis algorithms are deferred to future papers. Our layout implementation relies on the MOSIS netlist-to-parts service <ref> [35, 36] </ref>. This paper is organized as follows. Section 2 reviews related work. Section 3 identifies the basic building blocks of the realization and maps their behavior into a data flow model. Section 4 describes the data flow specification DFG and the extended specification EDFG.
Reference: [36] <institution> The MOSIS Service. USC/ISI, MOSIS Project, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: The details of realizations and synthesis algorithms are deferred to future papers. Our layout implementation relies on the MOSIS netlist-to-parts service <ref> [35, 36] </ref>. This paper is organized as follows. Section 2 reviews related work. Section 3 identifies the basic building blocks of the realization and maps their behavior into a data flow model. Section 4 describes the data flow specification DFG and the extended specification EDFG.
Reference: [37] <institution> MOSIS prices and gate equivalents. Tanner Research, </institution> <month> April </month> <year> 1989. </year> <month> 73 </month>
Reference-contexts: Despite these factors, our high-level timing model is quite accurate; the DFGsim/Csim ratio is 98.1% for the best case and is 87.6% for the worst case in all our experimental results. It is common to use the cell area to estimate the routing overhead before placement and routing <ref> [37] </ref>. From above two examples, the Cell/Core ratio is within 56.2% to 64.5%. Although the area ratios for the above design are not fixed, these ratios vary in a certain small range.
References-found: 37

