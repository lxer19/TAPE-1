URL: ftp://ftp.cs.iastate.edu/pub/techreports/TR98-10/TR.ps.gz
Refering-URL: http://www.cs.iastate.edu/~leavens/main.html
Root-URL: http://www.cs.iastate.edu
Title: Dynamic Semantics and Type-checking of Tuple  
Author: Jianbing Chen Jianbing Chen 
Keyword: Tuple language, single dispatch, multiple dispatch, multi-methods, subtype, type checking, semantic prototype, tuples.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: This work was supported in part by grant CCR 9803843 from the US National Science Foundation and by a grant from Rockwell International.  Copyright c 1998 by  
Date: December 1998  
Pubnum: TR #98-10  
Abstract: 1997 CR Categories: D.3.1 [Programming Languages] Formal Definitions and Theory | semantics; D.3.2 [Programming Languages] Languages Classifications | object-oriented languages; D.3.3 [Programming Languages] Languages Constructs and Features | abstract data types, control structures, procedures, functions, and subroutines; D.3.m [Programming Languages] Miscellaneous | multimethods, single dispatch, multiple dispatch, type systems; F.3.2 [Logics and Meanings of Programs] Semantics of Programming Languages | denotational semantics; F.3.3 [Logics and Meanings of Programs] Studies of Program Constructs | control primitives, type structure. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Arnold and J. Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <note> second edition, </note> <year> 1998. </year>
Reference-contexts: However, programmers find it difficult to express binary methods and design patterns such as the "visitor" pattern [6, p.331-334] without multiple dispatch. We now give two examples to illustrate this point. Although examples are written in Java <ref> [1] </ref>, the problem is common to all languages which do not support multiple dispatch. 1.1 The Problem with Single Dispatch In Figure 1, two related classes have been defined. (These are inspired by Boyland and Castagna's article [3].) The meaning of the two classes are straightforward.
Reference: [2] <author> G. Baumgartner, K. Laufer, and V. F. Russo. </author> <title> On the interaction of object-oriented design patterns and programming languages. </title> <type> Technical Report CSD-TR-96-020, </type> <institution> Department of Computer Science, Purdue University, </institution> <month> Feb. </month> <year> 1998. </year>
Reference-contexts: However, in object-oriented programming, this is not preferrable. The second example (taken from the article <ref> [2] </ref>) presents a more general problem that is solved using a general technique known as "visitor" design pattern [6]. In Figure 2, abstract syntax trees and operations on these trees in the context of a compiler have been considered.
Reference: [3] <author> J. Boyland and G. Castagna. </author> <title> An implementation of multi-methods for java. </title> <booktitle> ACM, 1997. OOPSLA '97 Proceedings. </booktitle>
Reference-contexts: Although examples are written in Java [1], the problem is common to all languages which do not support multiple dispatch. 1.1 The Problem with Single Dispatch In Figure 1, two related classes have been defined. (These are inspired by Boyland and Castagna's article <ref> [3] </ref>.) The meaning of the two classes are straightforward.
Reference: [4] <author> L. Cardelli. </author> <title> A semantics of multiple inheritance. </title> <journal> Information and Computation, </journal> 76(2/3):138-164, February/March 1988. A revised version of the paper that appeared in the 1984 Semantics of Data Types Symposium, LNCS <volume> 173, </volume> pages <pages> 51-66. </pages>
Reference-contexts: Subtyping for class names involves the inheritance relation in the class environment which is assumed to be reflexive and transitively closed. Subtype checking for two arrow types corresponds to the contravariant rule <ref> [4] </ref>. We will use t 2 t 1 to denote that t 2 is a subtype of t 1 . Also, we use Aname top = Aname "Top" to denote the super class of all classes.
Reference: [5] <author> C. Chambers and G. T. Leavens. </author> <title> Typechecking and modules for multi-methods. </title> <journal> TOPLAS, </journal> <volume> 17(6) </volume> <pages> 805-843, </pages> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: Implementation-side checking <ref> [5] </ref> is performed after we have complete information about the type environment. This is for methods defined in tuple classes. Two checks are made. The first check ensures monotonicity.
Reference: [6] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year>
Reference-contexts: Many popular object-oriented programming languages, such as C++, Smalltalk-80, Java, and Eiffel, do not support multiple dispatch. However, programmers find it difficult to express binary methods and design patterns such as the "visitor" pattern <ref> [6, p.331-334] </ref> without multiple dispatch. We now give two examples to illustrate this point. <p> However, in object-oriented programming, this is not preferrable. The second example (taken from the article [2]) presents a more general problem that is solved using a general technique known as "visitor" design pattern <ref> [6] </ref>. In Figure 2, abstract syntax trees and operations on these trees in the context of a compiler have been considered. Abstract syntax trees are built from nodes for assignments, variable references, expressions and so on. Operations on abstract syntax trees include type checking, code generation, flow analysis, etc.
Reference: [7] <author> M. J. Gordon. </author> <title> Programming Language Theory and its Implementation. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Examples include life-critical systems such as nuclear reactor controllers, car braking systems, fly-by-wire aircraft and software controlled medical equipment."... "Formal proof of correctness provides a way of establishing the absence of bugs when exhaustive testing is impossible (as it almost always is)." <ref> [7, p.14] </ref> In general, there are two approaches to ensure the soundness of some type system: (i) Define the language by the axioms and rules of the logic. (ii) Prove that the logic fits the language. "Approach (i) is called axiomatic semantics.
Reference: [8] <author> D. H. H. Ingalls. </author> <title> A simple technique for handling multiple polymor-phism. </title> <booktitle> 21(11) </booktitle> <pages> 347-349, </pages> <month> Nov. </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: Hence the "visitor" pattern is implemented using double dispatching <ref> [8] </ref>. A couple of problems arise when using the "visitor" pattern. First, it is difficult to add new element classes. Each new element class XNode requires defining a method VisitX and corresponding method implementations in each visitor class to be added. This makes the visitor class library difficult to maintain.
Reference: [9] <author> G. T. Leavens and T. D. Millstein. </author> <title> Multiple dispatch as dispatch on tuples. </title> <booktitle> ACM, 1998. OOPSLA '98 Proceedings. </booktitle>
Reference-contexts: Furthermore, double dispatching is error-prone because it requires method selection to be implemented manually. This makes it hard to see which argument combination causes the execution of which method. 1.2 Tuple's Solution To solve the above problems, Leavens and Millstein designed a language called Tuple <ref> [9] </ref>. The idea is to extend the single-dispatch language (e.g, Java) with tuple expressions, tuple classes, tuple types, and the ability to declare and send message to tuples, which gives multiple dispatch. To illustrate, we will give answers to the above two examples in the syntax of Tuple. <p> Here, for each different node and visitor pair, a tuple class is defined. The corresponding visiting method is defined in the tuple class. In this way, the semantics is clear and the code is easy to modify. 1.3 Contribution of this Paper Based on the original Tuple paper <ref> [9] </ref>, we have implemented the dynamic semantics and type checking of Tuple in the functional languag Haskell [11]. Using our prototype system, we have gained experience coding in Tuple and also proved the soundness of the type system. <p> It is highly structural and clean. Based on the annotation tools developed by Leavens, we were able to make the implementation of the type checking rules look like inference rules used in the original paper by Leavens and Millstein <ref> [9] </ref>. 1.4 Outline of the Rest Paper In Section 2, we will discuss the abstract syntax and dynamic semantics of the language Tuple. In Section 3, we explain some issues in type checking Tuple programs. <p> The complete listing of dynamic semantics is given in the Appendix. 13 3 Type Checking Tuple In this section, our implementation of type checking Tuple is presented. This implementation is based on the framework laid in the original paper <ref> [9] </ref> by Leavens and Millstein. The abstract syntax of types in Tuple is described in Figure 5. There, Type gives our primitive types and the skeleton of our type system. There are two kinds of types. <p> Moreover, based on our prototype system, we have proved that our revised static type system of Tuple is sound with respect to the dynamic semantics. Besides that the dynamic semantics has been studied in more detail, several changes from the original Tuple paper <ref> [9] </ref> have been made during the process of soundness proof. They are as follows: 1.
Reference: [10] <author> D. A. Schmidt. </author> <title> The Structure of Typed Programming Languages. </title> <booktitle> Foundations of Computing Series. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: Here, :-&gt; is type constructor in Haskell. Ameth (Type,Type) is method type, which contains the signature of a method and the type assignment of an object's fields. Avar LogicalVar is the type for logical variables. Aerr is the error type (bottom type). Aexp Type denotes an expression type <ref> [10] </ref>. Acls ClassInfo and Atup TupleClassInfo denote the types of declarations of classes and tuple classes. Acon TypeContext is the type for a type context that results from some declarations. Our approach to type checking a Tuple program is similar to the one we used in the dynamic semantics. <p> Clearly, if a type context passes implementation-side checking, then it is a good type context. 16 4 Soundness of our Type System with re- spect to the Dynamic Semantics We first give a brief overview on soundness of type systems. Then our proof in Schmidt's style <ref> [10] </ref> is presented. 4.1 Soundness, Why and How? "For some applications, correctness is especially important.
Reference: [11] <author> S. Thompson. </author> <title> Haskell: The Craft of Functional Programming. </title> <publisher> Addison-Wesley, </publisher> <address> Harlow, England, </address> <year> 1996. </year> <month> 29 </month>
Reference-contexts: In this way, the semantics is clear and the code is easy to modify. 1.3 Contribution of this Paper Based on the original Tuple paper [9], we have implemented the dynamic semantics and type checking of Tuple in the functional languag Haskell <ref> [11] </ref>. Using our prototype system, we have gained experience coding in Tuple and also proved the soundness of the type system.
Reference: [12] <author> J. D. Ullman. </author> <title> Elements of ML Programming. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1994. </year> <month> 30 </month>
Reference-contexts: So as long as at the time of the evaluation we have all the information needed, the program is okay. Without this feature, we would have to pass a thunk instead. For example, if we have had chosen to implement the dynamic semantics in programming language ML <ref> [12] </ref>, we would have to code the meaning function meaningE with the following (Haskell syntax) type: meaningE :: Expression -&gt; (() -&gt; EnhInh) -&gt; (() -&gt; ExpressedValue) Instead, we have the following: meaningE :: Expression -&gt; EnhInh -&gt; ExpressedValue which is simpler and clearer.
References-found: 12

