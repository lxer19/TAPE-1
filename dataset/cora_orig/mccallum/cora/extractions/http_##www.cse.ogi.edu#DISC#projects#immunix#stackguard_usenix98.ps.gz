URL: http://www.cse.ogi.edu/DISC/projects/immunix/stackguard_usenix98.ps.gz
Refering-URL: http://www.cse.ogi.edu/DISC/projects/immunix/publications.html
Root-URL: http://www.cse.ogi.edu
Email: immunix-request@cse.ogi.edu,  
Title: StackGuard: Automatic Adaptive Detection and Prevention of Buffer-Overflow Attacks  
Author: Crispin Cowan, Calton Pu, Dave Maier, Heather Hinton Jonathan Walpole, Peat Bakke, Steve Beattie, Aaron Grier, Perry Wagle and Qian Zhang 
Web: http://cse.ogi.edu/DISC/projects/immunix  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  Ryerson Polytechnic University  
Abstract: This paper presents a systematic solution to the persistent problem of buffer overflow attacks. Buffer overflow attacks gained notoriety in 1988 as part of the Morris Worm incident on the Internet. While it is fairly simple to fix individual buffer overflow vulnerabilities, buffer overflow attacks continue to this day. Hundreds of attacks have been discovered, and while most of the obvious vulnerabilities have now been patched, more sophisticated buffer overflow attacks continue to emerge. We describe StackGuard: a simple compiler technique that virtually eliminates buffer overflow vulnerabilities with only modest performance penalties. Privileged programs that are recompiled with the StackGuard compiler extension no longer yield control to the attacker, but rather enter a fail-safe state. These programs require no source code changes at all, and are binary-compatible with existing operating systems and libraries. We describe the compiler technique (a simple patch to gcc), as well as a set of variations on the technique that tradeoff between penetration resistance and performance. We present experimental results of both the penetration resistance and the performance impact of this technique. fl This research is partially supported by DARPA contracts F30602-96-1-0331 and F30602-96-1-0302.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Crispin Cowan, Tito Autrey, Charles Krasic, Cal-ton Pu, and Jonathan Walpole. </author> <title> Fast Concurrent Dynamic Linking for an Adaptive Operating System. </title> <booktitle> In International Conference on Configurable Distributed Systems (ICCDS'96), Annapolis, </booktitle> <address> MD, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: into register [5] push canary-vector [register [5]] move canary-index-constant into register [4] move canary-vector [register [4]] into register [4] exclusive-or register [4] with top-of-stack jump-if-not-zero to constant address .canary-death-handler add 4 to stack-pointer &lt; normal return instructions here&gt; .canary-death-handler: ... 3.2 Preventing Return Address Changes With MemGuard The Synthetix project <ref> [18, 1, 2, 24] </ref> introduced a notion called quasi-invariants. Quasi-invariants are state properties that hold true for a while, but may change without notice. Quasi-invariants are used to specify optimistic specializations: code optimizations that are valid only while the quasi-invariants hold.
Reference: [2] <author> Crispin Cowan, Andrew Black, Charles Krasic, Calton Pu, Jonathan Walpole, Charles Consel, and Eugen-Nicolae Volanschi. </author> <title> Specialization Classes: An Object Framework for Specialization. </title> <booktitle> In Proceedings of the Fifth International Workshop on Object-Orientation in Operating Systems (IWOOOS '96), </booktitle> <address> Seattle, WA, </address> <month> October 27-28 </month> <year> 1996. </year>
Reference-contexts: into register [5] push canary-vector [register [5]] move canary-index-constant into register [4] move canary-vector [register [4]] into register [4] exclusive-or register [4] with top-of-stack jump-if-not-zero to constant address .canary-death-handler add 4 to stack-pointer &lt; normal return instructions here&gt; .canary-death-handler: ... 3.2 Preventing Return Address Changes With MemGuard The Synthetix project <ref> [18, 1, 2, 24] </ref> introduced a notion called quasi-invariants. Quasi-invariants are state properties that hold true for a while, but may change without notice. Quasi-invariants are used to specify optimistic specializations: code optimizations that are valid only while the quasi-invariants hold.
Reference: [3] <author> Crispin Cowan, Dylan McNamee, Andrew Black, Calton Pu, Jonathan Walpole, Charles Krasic, Re-naud Marlet, and Qian Zhang. </author> <title> A Toolkit for Specializing Production Operating System Code. </title> <type> Technical Report CSE-97-004, </type> <institution> Dept. of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: We have extended this work to treat return addresses on the stack as quasi-invariant during the activation lifetime of the function. The return address is read-only (invariant) while the function is active, thus preventing effective buffer overflow against the stack. MemGuard <ref> [3] </ref> is a tool developed to help debug optimistic specializations by locating code statements that change quasi-invariant values. MemGuard provides fine-grained memory protection: individual words of memory (quasi-invariant terms) can be designated as read-only, except when explicitly written via the MemGuard API.
Reference: [4] <author> Michele Crabb. </author> <title> Curmudgeon's Executive Summary. In Michele Crabb, editor, The SANS Network Security Digest. </title> <type> SANS, </type> <year> 1997. </year> <note> Contributing Editors: </note> <author> Matt Bishop, Gene Spafford, Steve Bellovin, Gene Schultz, Rob Kolstad, Marcus Ranum, Dorothy Denning, Dan Geer, Peter Neumann, Peter Galvin, David Harley, </author> <note> Jean Chouanard. </note>
Reference-contexts: The only remaining work for a would-be attacker to do is to find a poorly protected buffer in a privileged program, and construct an exploit. Hundreds of such exploits have been reported in recent years <ref> [4] </ref>. 3 StackGuard: Making the Stack Safe for Network Access StackGuard is a compiler extension that enhances the executable code produced by the compiler so that it detects and thwarts buffer-overflow attacks against the stack. The effect is transparent to the normal function of programs. <p> Even so, a determined attacker could break such a defense eventually; we discuss our approach to this problem in Section 3.3. 2 Naturally, none have been found to date :-) move canary-index-constant into register [5] push canary-vector [register [5]] move canary-index-constant into register <ref> [4] </ref> move canary-vector [register [4]] into register [4] exclusive-or register [4] with top-of-stack jump-if-not-zero to constant address .canary-death-handler add 4 to stack-pointer &lt; normal return instructions here&gt; .canary-death-handler: ... 3.2 Preventing Return Address Changes With MemGuard The Synthetix project [18, 1, 2, 24] introduced a notion called quasi-invariants. <p> Even so, a determined attacker could break such a defense eventually; we discuss our approach to this problem in Section 3.3. 2 Naturally, none have been found to date :-) move canary-index-constant into register [5] push canary-vector [register [5]] move canary-index-constant into register <ref> [4] </ref> move canary-vector [register [4]] into register [4] exclusive-or register [4] with top-of-stack jump-if-not-zero to constant address .canary-death-handler add 4 to stack-pointer &lt; normal return instructions here&gt; .canary-death-handler: ... 3.2 Preventing Return Address Changes With MemGuard The Synthetix project [18, 1, 2, 24] introduced a notion called quasi-invariants. <p> Even so, a determined attacker could break such a defense eventually; we discuss our approach to this problem in Section 3.3. 2 Naturally, none have been found to date :-) move canary-index-constant into register [5] push canary-vector [register [5]] move canary-index-constant into register <ref> [4] </ref> move canary-vector [register [4]] into register [4] exclusive-or register [4] with top-of-stack jump-if-not-zero to constant address .canary-death-handler add 4 to stack-pointer &lt; normal return instructions here&gt; .canary-death-handler: ... 3.2 Preventing Return Address Changes With MemGuard The Synthetix project [18, 1, 2, 24] introduced a notion called quasi-invariants. <p> determined attacker could break such a defense eventually; we discuss our approach to this problem in Section 3.3. 2 Naturally, none have been found to date :-) move canary-index-constant into register [5] push canary-vector [register [5]] move canary-index-constant into register <ref> [4] </ref> move canary-vector [register [4]] into register [4] exclusive-or register [4] with top-of-stack jump-if-not-zero to constant address .canary-death-handler add 4 to stack-pointer &lt; normal return instructions here&gt; .canary-death-handler: ... 3.2 Preventing Return Address Changes With MemGuard The Synthetix project [18, 1, 2, 24] introduced a notion called quasi-invariants.
Reference: [5] <author> Drew Dean, Edward W. Felten, and Dan S. Wal-lach. </author> <title> Java Security: From HotJava to Netscape and Beyond. </title> <booktitle> In Proceedings of the IEEE Symposium on Security and Privacy, </booktitle> <address> Oakland, CA, </address> <year> 1996. </year> <note> http://www.cs.princeton.edu/sip/ pub/secure96.html. </note>
Reference-contexts: Even so, a determined attacker could break such a defense eventually; we discuss our approach to this problem in Section 3.3. 2 Naturally, none have been found to date :-) move canary-index-constant into register <ref> [5] </ref> push canary-vector [register [5]] move canary-index-constant into register [4] move canary-vector [register [4]] into register [4] exclusive-or register [4] with top-of-stack jump-if-not-zero to constant address .canary-death-handler add 4 to stack-pointer &lt; normal return instructions here&gt; .canary-death-handler: ... 3.2 Preventing Return Address Changes With MemGuard The Synthetix project [18, 1, 2, <p> Even so, a determined attacker could break such a defense eventually; we discuss our approach to this problem in Section 3.3. 2 Naturally, none have been found to date :-) move canary-index-constant into register <ref> [5] </ref> push canary-vector [register [5]] move canary-index-constant into register [4] move canary-vector [register [4]] into register [4] exclusive-or register [4] with top-of-stack jump-if-not-zero to constant address .canary-death-handler add 4 to stack-pointer &lt; normal return instructions here&gt; .canary-death-handler: ... 3.2 Preventing Return Address Changes With MemGuard The Synthetix project [18, 1, 2, 24] introduced a notion <p> Type-safety is one of the foundations of the Java security model. Unfortunately, errors in the Java type checking system are one of the ways that Java programs and Java virtual machines can be attacked <ref> [5, 20] </ref>. If the correctness of the type checking system is in question, then programs depending on that type checking system for security benefit from these techniques in similar ways to the benefit provided to type-unsafe programs.
Reference: [6] <author> Solar Designer. </author> <title> Non-Executable User Stack. </title> <address> http://www.false.com/security/ linux-stack/. </address>
Reference-contexts: The result is not a conclusion of which approach is better, but rather a description of the different trade-offs that each approach provides. 6.1 Non-Executable Stack Solar Designer has developed a Linux patch that makes the stack non-executable <ref> [6] </ref>, precisely to address the stack smashing problem. This patch simply makes the stack portion of a user process's virtual address space non-executable, so that attack code injected onto the stack cannot be executed.
Reference: [7] <author> D. Farmer. </author> <title> The COPS Security Checker System. </title> <booktitle> In Summer 1990 USENIX Conference, </booktitle> <pages> page 165, </pages> <address> Anaheim, CA, </address> <month> June </month> <year> 1990. </year> <note> http://www.trouble.org/cops/. </note>
Reference-contexts: StackGuard offers powerful protection of any program compiled with the StackGuard compiler, but does nothing for programs that have not been thus compiled. However, tools such as COPS <ref> [7] </ref>, which search for programs that should not be SUID root, can be configured to look for programs that are SUID root, and have not been compiled using StackGuard or some other security verification tool [9].
Reference: [8] <editor> Stephanie Forrest, Anil Somayaji, and David. H. Ackley. </editor> <booktitle> Building Diverse Computer Systems . In HotOS-VI, </booktitle> <month> May </month> <year> 1997. </year>
Reference-contexts: Section 4 describes testing and performance of this patch. 3.1.1 Randomizing the Canary The Canary defense is sufficient to stop most buffer overflow attacks that are oblivious to the canary. In fact, simply changing the compiler's calling conventions is sufficient to stop most buffer overflow attacks <ref> [8] </ref>. Most current buffer overflow attacks are quite brittle, making specific, static assumptions about the layout of the stack frame.
Reference: [9] <author> Virgil Gligor, Serban Gavrila, and Sabari Gupta. </author> <title> Penetration Analysis Tools. </title> <type> Personal Communications, </type> <month> July </month> <year> 1997. </year>
Reference-contexts: StackGuard comes with a performance price, and can be viewed as an insurance policy. If one is very sure that a program is correct, i.e. contains no buffer overflow vulnerabilities because it has been verified using formal methods, or a validation tool <ref> [9] </ref>, then the program can be re-compiled and installed without benefit of StackGuard. StackGuard offers powerful protection of any program compiled with the StackGuard compiler, but does nothing for programs that have not been thus compiled. <p> However, tools such as COPS [7], which search for programs that should not be SUID root, can be configured to look for programs that are SUID root, and have not been compiled using StackGuard or some other security verification tool <ref> [9] </ref>.
Reference: [10] <author> Reed Hastings and Bob Joyce. Purify: </author> <title> Fast Detection of Memory Leaks and Access Errors. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <year> 1992. </year> <note> http://www.rational.com/support/ techpapers/fast detection/. </note>
Reference-contexts: Thus we propose that programs compiled with the bounds-checking compiler be treated as the backing store for MemGuard-protected programs, just as MemGuard-protected programs are the back-up plan for Canary-protected programs (see Section 3.3). 6.4 Memory Access Checking Purify <ref> [10] </ref> is a debugging tool for C programs with memory access errors. Purify uses object code insertion to instrument all memory accesses. The approach is similar to StackGuard, in that it does integrity checking of memory, but it does so on each memory access, rather than on each function return.
Reference: [11] <author> Immunix. </author> <title> Adaptive System Survivability. </title> <address> http://www.cse.ogi.edu/DISC/ projects/immunix, </address> <year> 1997. </year>
Reference-contexts: this approach can be continuously adjusted, reducing the minimum size of stack frames to reduce space consumption, and also increasing the probability that the top page of the stack actually will require MemGuard protection, with its associated costs. 3.3 Adaptive Defense Strategies StackGuard is a product of the Immunix project <ref> [11] </ref>, whose focus is adaptive responses to security threats. Thus we provide an adaptive response to intrusions, switching between the more performant Canary version, and the more robust MemGuard versions of StackGuard.
Reference: [12] <author> Richard Jones and Paul Kelly. </author> <title> Bounds Checking for C. </title> <address> http://www-ala.doc.ic.ac.uk/phjk/ BoundsChecking.html, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: However, these integrity checks were non-portable, hard-coded in assembler, and embedded in libc. This method protects against stack smashing attacks inside libc, but is not as general as StackGuard. 6.3 Array Bounds Checking for C Richard Jones and Paul Kelly have developed a gcc patch <ref> [12] </ref> that does full array bounds checking for C programs. Programs compiled with this patch are compatible with ordinary gcc modules, because they have not changed the representation of pointers.
Reference: [13] <author> Barton P. Miller, David Koski, Cjin Pheow Lee, Vivekananda Maganty, Ravi Murthy, Ajitkumar Natarajan, and Jeff Steidl. </author> <title> Fuzz Revisited: A reexamination of the Reliability of UNIX Utilities and Services. </title> <type> Report, </type> <institution> University of Wisconsin, </institution> <year> 1995. </year>
Reference-contexts: Many C programs have buffer overflow vulnerabilities, both because the C language lacks array bounds checking, and because the culture of C programmers encourages a performance-oriented style that avoids error checking where possible <ref> [14, 13] </ref>. For instance, many of the standard C library functions such as gets and strcpy do not do bounds checking by default. The common form of buffer overflow exploitation is to attack buffers allocated on the stack.
Reference: [14] <author> B.P. Miller, L. Fredrikson, and B. </author> <title> So. An Empirical Study of the Reliability of UNIX Utilities. </title> <journal> Communications of the ACM, </journal> <volume> 33(12) </volume> <pages> 33-44, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Many C programs have buffer overflow vulnerabilities, both because the C language lacks array bounds checking, and because the culture of C programmers encourages a performance-oriented style that avoids error checking where possible <ref> [14, 13] </ref>. For instance, many of the standard C library functions such as gets and strcpy do not do bounds checking by default. The common form of buffer overflow exploitation is to attack buffers allocated on the stack.
Reference: [15] <author> Mudge. </author> <title> How to Write Buffer Overflows. </title> <address> http://l0pht.com/advisories/ bufero.html, </address> <year> 1997. </year>
Reference-contexts: By far, the most common data structure to corrupt in this fashion is the stack, called a stack smashing attack, which we briefly describe here, and is described at length elsewhere <ref> [15, 17, 21] </ref>. Many C programs have buffer overflow vulnerabilities, both because the C language lacks array bounds checking, and because the culture of C programmers encourages a performance-oriented style that avoids error checking where possible [14, 13]. <p> The overwritten return address need only jump into the middle of the field of NOPs to hit the target. The cook-book descriptions of stack smashing attacks <ref> [15, 17, 21] </ref> have made construction of buffer-overflow exploits quite easy. The only remaining work for a would-be attacker to do is to find a poorly protected buffer in a privileged program, and construct an exploit.
Reference: [16] <editor> Aleph One. Bugtraq Mailing List. </editor> <address> http://geek-girl.com/bugtraq/. </address>
Reference-contexts: Security organizations such as CERT are reluctant to release exploits, and thus most of these exploits were obtained either from searching the web, or from the bugtraq mailing list <ref> [16] </ref>. Obtaining Vulnerable Source Code: Buffer overflow attacks exploit specific, simple vulnerabilities in popular software.
Reference: [17] <author> Aleph One. </author> <title> Smashing The Stack For Fun And Profit. </title> <journal> Phrack, </journal> <volume> 7(49), </volume> <month> November </month> <year> 1996. </year>
Reference-contexts: By far, the most common data structure to corrupt in this fashion is the stack, called a stack smashing attack, which we briefly describe here, and is described at length elsewhere <ref> [15, 17, 21] </ref>. Many C programs have buffer overflow vulnerabilities, both because the C language lacks array bounds checking, and because the culture of C programmers encourages a performance-oriented style that avoids error checking where possible [14, 13]. <p> Often, the attacks are based on reverse-engineering the attacked program, so as to determine the exact offset from the buffer to the return address in the stack frame, and the offset from the return address to the injected attack code. However, it is possible to soften these exacting requirements <ref> [17] </ref>: * The location of the return address can be approximated by simply repeating the desired return address several times in the approximate region of the return address. * The offset to the attack code can be approximated by prepending the attack code with an arbitrary number of NOP instructions. <p> The overwritten return address need only jump into the middle of the field of NOPs to hit the target. The cook-book descriptions of stack smashing attacks <ref> [15, 17, 21] </ref> have made construction of buffer-overflow exploits quite easy. The only remaining work for a would-be attacker to do is to find a poorly protected buffer in a privileged program, and construct an exploit. <p> Most current buffer overflow attacks are quite brittle, making specific, static assumptions about the layout of the stack frame. However, it is not very hard for attackers to develop buffer overflows that are insensitive to minor changes in the stack frame layout <ref> [17] </ref>: * To adapt to changes in the location of the return address relative to the buffer being overflowed, the at tacker can repeat the new value several times in the input string. * To adapt to imprecision in the offset of the injected code from the current program counter, the
Reference: [18] <author> Calton Pu, Tito Autrey, Andrew Black, Charles Consel, Crispin Cowan, Jon Inouye, Lakshmi Kethana, Jonathan Walpole, and Ke Zhang. </author> <title> Optimistic Incremental Specialization: Streamlining a Commercial Operating System. </title> <booktitle> In Symposium on Operating Systems Principles (SOSP), </booktitle> <address> Copper Mountain, Colorado, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: into register [5] push canary-vector [register [5]] move canary-index-constant into register [4] move canary-vector [register [4]] into register [4] exclusive-or register [4] with top-of-stack jump-if-not-zero to constant address .canary-death-handler add 4 to stack-pointer &lt; normal return instructions here&gt; .canary-death-handler: ... 3.2 Preventing Return Address Changes With MemGuard The Synthetix project <ref> [18, 1, 2, 24] </ref> introduced a notion called quasi-invariants. Quasi-invariants are state properties that hold true for a while, but may change without notice. Quasi-invariants are used to specify optimistic specializations: code optimizations that are valid only while the quasi-invariants hold.
Reference: [19] <author> Calton Pu, Andrew Black, Crispin Cowan, Jonathan Walpole, and Charles Consel. </author> <title> Microlanguages for Operating System Specialization. </title> <booktitle> In SIGPLAN Workshop on Domain-Specific Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: The deci sion to revert to the more performant, less secure mode is even more difficult, because the attacker may try to induce such a switch. Making the right choice, automatically, is challenging. We propose to create a small, domain-specific language <ref> [19] </ref> for specifying these policy choices. StackGuard comes with a performance price, and can be viewed as an insurance policy.
Reference: [20] <author> Jim Roskind. </author> <title> Panel: Security of Downloadable Executable Content. NDSS (Network and Distributed System Security), </title> <month> February </month> <year> 1997. </year>
Reference-contexts: Type-safety is one of the foundations of the Java security model. Unfortunately, errors in the Java type checking system are one of the ways that Java programs and Java virtual machines can be attacked <ref> [5, 20] </ref>. If the correctness of the type checking system is in question, then programs depending on that type checking system for security benefit from these techniques in similar ways to the benefit provided to type-unsafe programs.
Reference: [21] <author> Nathan P. Smith. </author> <title> Stack Smashing vulnerabilities in the UNIX Operating System. </title> <address> http://millcomm.com/nate/ machines/security/stack-smashing/ nate-buffer.ps, </address> <year> 1997. </year>
Reference-contexts: By far, the most common data structure to corrupt in this fashion is the stack, called a stack smashing attack, which we briefly describe here, and is described at length elsewhere <ref> [15, 17, 21] </ref>. Many C programs have buffer overflow vulnerabilities, both because the C language lacks array bounds checking, and because the culture of C programmers encourages a performance-oriented style that avoids error checking where possible [14, 13]. <p> The overwritten return address need only jump into the middle of the field of NOPs to hit the target. The cook-book descriptions of stack smashing attacks <ref> [15, 17, 21] </ref> have made construction of buffer-overflow exploits quite easy. The only remaining work for a would-be attacker to do is to find a poorly protected buffer in a privileged program, and construct an exploit.
Reference: [22] <author> Alexander Snarskii. </author> <title> FreeBSD Stack Integrity Patch. </title> <address> ftp://ftp.lucky.net/pub/unix/ local/libc-letter, </address> <year> 1997. </year>
Reference-contexts: Thus additional protection for critical data structures such as function pointers and function return addresses, as described in Section 5.4. 6.2 FreeBSD Stack Integrity Check Alexander Snarskii developed a FreeBSD patch <ref> [22] </ref> that does similar integrity checks to those used by the Canary variant of StackGuard. However, these integrity checks were non-portable, hard-coded in assembler, and embedded in libc.
Reference: [23] <author> E. Spafford. </author> <title> The Internet Worm Program: Analysis. </title> <journal> Computer Communication Review, </journal> <month> January </month> <year> 1989. </year>
Reference-contexts: 1 Introduction This paper presents a systematic solution to the persistent problem of buffer overflow attacks. Buffer overflow attack gained notoriety in 1988 as part of the Morris Worm incident on the Internet <ref> [23] </ref>. Despite the fact that fixing individual buffer overflow vulnerabilities is fairly simple, buffer overflow attacks continue to this day, as reported in the SANS Network Security Digest: Buffer overflows appear to be the most common problems reported in May, with degradation-of-service problems a distant second.
Reference: [24] <author> Eugen N. Volanschi, Charles Consel, Gilles Muller, and Crispin Cowan. </author> <title> Declarative Specialization of Object-Oriented Programs. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA'97), </booktitle> <address> Atlanta, GA, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: into register [5] push canary-vector [register [5]] move canary-index-constant into register [4] move canary-vector [register [4]] into register [4] exclusive-or register [4] with top-of-stack jump-if-not-zero to constant address .canary-death-handler add 4 to stack-pointer &lt; normal return instructions here&gt; .canary-death-handler: ... 3.2 Preventing Return Address Changes With MemGuard The Synthetix project <ref> [18, 1, 2, 24] </ref> introduced a notion called quasi-invariants. Quasi-invariants are state properties that hold true for a while, but may change without notice. Quasi-invariants are used to specify optimistic specializations: code optimizations that are valid only while the quasi-invariants hold.
References-found: 24

