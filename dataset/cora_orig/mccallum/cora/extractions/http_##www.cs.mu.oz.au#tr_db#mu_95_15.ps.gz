URL: http://www.cs.mu.oz.au/tr_db/mu_95_15.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: Improved Analysis of Logic Programs Using a Differential Approach  
Author: Mara Garca de la Banda, Kim Marriott, Harald Stndergaard and Peter Stuckey 
Address: Parkville Vic. 3052 Australia  
Affiliation: Dept. of Computer Science The University of Melbourne  
Pubnum: Technical Report 95/15  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Bruynooghe. </author> <title> A practical framework for the abstract interpretation of logic programs. </title> <journal> Journal of Logic Programming 10 (2): </journal> <pages> 91-124, </pages> <year> 1991. </year>
Reference-contexts: Recently, [6] have shown that global program analysis is also important for constraint logic programming (CLP) languages. Initial theoretical research in abstract interpretation of logic programs resulted in several generic "frameworks" for logic programming <ref> [1, 5, 9] </ref>. These formal frameworks are quite similar, and can be instantiated to a particular analysis by giving several parametric functions over the description domain. <p> However, if we replace the possibly infinite sets of constraints by more crude "approximations" or "descriptions" then we may obtain a dataflow analysis which terminates in finite time. This is the idea behind abstract interpretation of logic programs <ref> [1, 3, 5, 9] </ref>. Example 2.1 Consider the program le (X; Y ) 1 fl X = Y 2 fl and goal le (X; s (a)).
Reference: [2] <author> F. Bueno, M. Garca de la Banda and M. Hermenegildo. </author> <title> Effectiveness of global analysis in strict independence-based automatic parallelization. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Logic Programming: Proc. 1994 Int. Symp., </booktitle> <pages> pages 320-336. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Abstract interpretation based program analysis has proven very useful in compilation of logic programming languages. Several compilers have demonstrated that global program analysis can give large performance improvement for the sequential compilation of Prolog [13, 14] and give significant automatic parallelization <ref> [2] </ref>. Recently, [6] have shown that global program analysis is also important for constraint logic programming (CLP) languages. Initial theoretical research in abstract interpretation of logic programs resulted in several generic "frameworks" for logic programming [1, 5, 9]. <p> The efficiency results for SS and ASub are shown in Table 1. For each benchmark, the information shown is the following: analysis times in milliseconds 2 for the analyser using 1 A complete description of this benchmarks can be found, for example, in <ref> [2] </ref>. 2 SICStus 2.1, compactcode, SPARCstation 10, one processor. 13 the standard version (Std); ratios of analysis time compared to the standard for the rest of the versions (Spec for specialized, Diff for differential and SpecDiff for specialized differential). The last row indicates the arithmetic mean of the ratios.
Reference: [3] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation and application to logic programs. </title> <journal> Journal of Logic Programming 13 (2&3): </journal> <pages> 103-179, </pages> <year> 1992. </year>
Reference-contexts: However, if we replace the possibly infinite sets of constraints by more crude "approximations" or "descriptions" then we may obtain a dataflow analysis which terminates in finite time. This is the idea behind abstract interpretation of logic programs <ref> [1, 3, 5, 9] </ref>. Example 2.1 Consider the program le (X; Y ) 1 fl X = Y 2 fl and goal le (X; s (a)).
Reference: [4] <author> M. Garca de la Banda, M. Hermenegildo, M. Bruynooghe, V. Dumortier, G. Janssens and W. Simoens. </author> <title> Global Analysis of Constraint Logic Programs. </title> <type> Technical Report, </type> <institution> Dept. of Computer Science, Catholic University of Leuven, Belgium, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: Our specialized combination operator formalizes implementation techniques used in PLAI for set sharing [11] and structure sharing descriptions. The differential approach is, as far as we know, new. A related approach to the combination approach for the structure sharing descriptions is independently mentioned in <ref> [4] </ref>. It is difficult to make a detailed comparison with [4] as they do not give a formal definition or detailed example. The plan of the paper is as follows: Section 2 introduce our terminology and describes the traditional framework for abstract interpretation based analysis of (constraint) logic programs. <p> The differential approach is, as far as we know, new. A related approach to the combination approach for the structure sharing descriptions is independently mentioned in <ref> [4] </ref>. It is difficult to make a detailed comparison with [4] as they do not give a formal definition or detailed example. The plan of the paper is as follows: Section 2 introduce our terminology and describes the traditional framework for abstract interpretation based analysis of (constraint) logic programs. In Section 3 the problem with the traditional framework is detailed.
Reference: [5] <author> N. Jones and H. Stndergaard. </author> <title> A semantics-based framework for the abstract interpretation of Prolog. </title> <editor> In S. Abramsky and C. Hankin, editors, </editor> <booktitle> Abstract Interpretation of Declarative Languages, </booktitle> <pages> pages 123-142. </pages> <publisher> Ellis Horwood, </publisher> <year> 1987. </year>
Reference-contexts: Recently, [6] have shown that global program analysis is also important for constraint logic programming (CLP) languages. Initial theoretical research in abstract interpretation of logic programs resulted in several generic "frameworks" for logic programming <ref> [1, 5, 9] </ref>. These formal frameworks are quite similar, and can be instantiated to a particular analysis by giving several parametric functions over the description domain. <p> However, if we replace the possibly infinite sets of constraints by more crude "approximations" or "descriptions" then we may obtain a dataflow analysis which terminates in finite time. This is the idea behind abstract interpretation of logic programs <ref> [1, 3, 5, 9] </ref>. Example 2.1 Consider the program le (X; Y ) 1 fl X = Y 2 fl and goal le (X; s (a)).
Reference: [6] <author> A. Kelly, A. Macdonald, K. Marriott, H. Stndergaard, P. Stuckey and R. Yap. </author> <title> An optimizing compiler for CLP(R). </title> <type> Technical Report 94/5, </type> <institution> Dept. of Computer Science, The University of Melbourne, </institution> <year> 1995. </year>
Reference-contexts: 1 Introduction Abstract interpretation based program analysis has proven very useful in compilation of logic programming languages. Several compilers have demonstrated that global program analysis can give large performance improvement for the sequential compilation of Prolog [13, 14] and give significant automatic parallelization [2]. Recently, <ref> [6] </ref> have shown that global program analysis is also important for constraint logic programming (CLP) languages. Initial theoretical research in abstract interpretation of logic programs resulted in several generic "frameworks" for logic programming [1, 5, 9]. <p> In such an implementation termination is guaranteed, provided the number of constraint descriptions with a particular domain of variables is finite. A number of generic abstract interpretation engines based on essentially the above semantic equations have been built <ref> [11, 7, 6] </ref>. The engines provide sophisticated fixpoint algorithms and data structures. A specific analyser is built by providing the seven parametric functions we have listed. 3 Imprecision of the Standard Semantics Unfortunately the standard semantics is inherently imprecise.
Reference: [7] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental evaluation of a generic abstract interpretation algorithm for Prolog. </title> <booktitle> ACM Transactions on Programming Languages and Systems 16 (1): </booktitle> <pages> 35-101, </pages> <year> 1994. </year>
Reference-contexts: In such an implementation termination is guaranteed, provided the number of constraint descriptions with a particular domain of variables is finite. A number of generic abstract interpretation engines based on essentially the above semantic equations have been built <ref> [11, 7, 6] </ref>. The engines provide sophisticated fixpoint algorithms and data structures. A specific analyser is built by providing the seven parametric functions we have listed. 3 Imprecision of the Standard Semantics Unfortunately the standard semantics is inherently imprecise.
Reference: [8] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Reexecution in abstract interpretation of Prolog (extended abstract). </title> <editor> In K. Apt, editor, </editor> <booktitle> Logic Programming: Proc. Joint Int. Conf. Symp. Logic Programming, </booktitle> <pages> pages 750-764. </pages> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: This inherits the complementary advantages of both approaches. In a sense the differential approach is dual to the improvement of accuracy by reexecution <ref> [8] </ref>. For downwards closed domains, adding information repeatedly can only improve accuracy, which is what happens when a call is "reexecuted", whereas for upwards closed domains, avoiding adding the same information twice leads to improvements. The differential approach more accurately reflects the operational semantics.
Reference: [9] <author> K. Marriott, H. Stndergaard and N. D. Jones. </author> <title> Denotational abstract interpretation of logic programs. </title> <booktitle> ACM Transactions on Programming Languages and Systems 16 (3): </booktitle> <pages> 607-648, </pages> <year> 1994. </year>
Reference-contexts: Recently, [6] have shown that global program analysis is also important for constraint logic programming (CLP) languages. Initial theoretical research in abstract interpretation of logic programs resulted in several generic "frameworks" for logic programming <ref> [1, 5, 9] </ref>. These formal frameworks are quite similar, and can be instantiated to a particular analysis by giving several parametric functions over the description domain. <p> However, if we replace the possibly infinite sets of constraints by more crude "approximations" or "descriptions" then we may obtain a dataflow analysis which terminates in finite time. This is the idea behind abstract interpretation of logic programs <ref> [1, 3, 5, 9] </ref>. Example 2.1 Consider the program le (X; Y ) 1 fl X = Y 2 fl and goal le (X; s (a)). <p> Specific analyses are obtained by specifying a description domain X and the auxiliary functions over X. It follows from standard results in abstract interpretation theory that for any description domain X, std X approximates the operational semantics op <ref> [9] </ref>. Example 2.2 Consider the abstract domain SS for structure sharing. Descriptions are sets of pairs of variables. The pair XY indicates that in the solved form of the constraints, variables X and Y may share a common structure, that is, point to the same piece of memory.
Reference: [10] <author> K. Marriott and P. Stuckey. </author> <title> Approximating interaction between linear arithmetic constraints. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Logic Programming: Proc. 1994 Int. Symp., </booktitle> <pages> pages 571-585. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Accuracy was lost because the input to the call to q, fXY g, was not distinguished from new structure sharing that may have arisen in the call. 6 Example 3.3 As another example we consider the LSign description domain <ref> [10] </ref>. LSign is used to describe conjunctions of linear arithmetic constraints and gives information about possible failure. This is useful in parallelization and optimization. In LSign a linear arithmetic constraint is abstracted by replacing coefficients in the constraint by their sign.
Reference: [11] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Compile-time derivation of variable dependency using ab stract interpretation. </title> <journal> Journal of Logic Programming 13 (2&3): </journal> <pages> 315-347, </pages> <year> 1992. </year>
Reference-contexts: Due to this problem with the theoretical frameworks, actual implementations of analyses, particularly for structure sharing, use seemingly ad hoc techniques so as to obtain more accurate and efficient analyses. The present paper has four main technical contributions. * First, we formalize the existing techniques used in PLAI <ref> [11] </ref> to partially overcome this lack of precision. The techniques are formalized by relaxing the theoretical framework so that a specialized abstract combination operator is used which is only required to approximate constraint conjunction in certain situations. We show that this technique is always more accurate than the traditional framework. <p> They indicate that the approaches suggested here should be used in preference to direct use of a traditional theoretical framework. This will give more efficient and more accurate analysis for little additional implementation effort. Our specialized combination operator formalizes implementation techniques used in PLAI for set sharing <ref> [11] </ref> and structure sharing descriptions. The differential approach is, as far as we know, new. A related approach to the combination approach for the structure sharing descriptions is independently mentioned in [4]. <p> In such an implementation termination is guaranteed, provided the number of constraint descriptions with a particular domain of variables is finite. A number of generic abstract interpretation engines based on essentially the above semantic equations have been built <ref> [11, 7, 6] </ref>. The engines provide sophisticated fixpoint algorithms and data structures. A specific analyser is built by providing the seven parametric functions we have listed. 3 Imprecision of the Standard Semantics Unfortunately the standard semantics is inherently imprecise. <p> This idea has been used in the implementation of the abstract domains for pair sharing and set sharing in PLAI <ref> [11] </ref>. Here we formalize the idea. Imagine that we are evaluating atom A after a program point with constraint set E in the standard collecting semantics. <p> In general this is difficult. In this section we look at how they can be combined for the abstract domain SS. The same ideas can be used for other abstract domains like ASub and SetSharing <ref> [11] </ref>. <p> Note that in this case the differential component is not a legitimate abstraction. This will be referred to as the specialized differential analyser. All these versions have been implemented in the PLAI framework <ref> [11] </ref>, in which a specialized version for ASub was already available. The reliability of the comparison is based on the fact that, for each abstract domain, the versions have been implemented in such a way that they reuse the abstract functions implemented for the standard version.
Reference: [12] <author> H. Stndergaard. </author> <title> An application of abstract interpretation of logic programs: Occur check reduction. </title> <editor> In B. Robinet and R. Wilhelm, editors, </editor> <booktitle> Proc. ESOP 86 (Lecture Notes in Computer Science 213), </booktitle> <pages> pages 327-338. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: The pair XX indicates that the solved form of X may have two different paths to the same piece of memory (also referred to as X being non-linear). The structure sharing domain was introduced in <ref> [12] </ref> as a component of an analysis for determining when dropping the occur check in unification is safe. <p> Example 5.6 Consider the abstract domain ASub <ref> [12] </ref> which describes variable sharing. Descriptions have two parts [G; V S]: a groundness description G as in Example 2.1, and a structure sharing description V S as in SS.
Reference: [13] <author> A. Taylor. </author> <title> LIPS on a MIPS: Results from a Prolog compiler for a RISC. </title> <editor> In D. Warren and P. Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. Seventh Int. Conf., </booktitle> <pages> pages 174-185. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Abstract interpretation based program analysis has proven very useful in compilation of logic programming languages. Several compilers have demonstrated that global program analysis can give large performance improvement for the sequential compilation of Prolog <ref> [13, 14] </ref> and give significant automatic parallelization [2]. Recently, [6] have shown that global program analysis is also important for constraint logic programming (CLP) languages. Initial theoretical research in abstract interpretation of logic programs resulted in several generic "frameworks" for logic programming [1, 5, 9].
Reference: [14] <author> P. van Roy and A. Despain. </author> <title> The benefits of global dataflow analysis for an optimizing Prolog compiler. </title> <editor> In S. Debray and M. Hermenegildo, editors, </editor> <booktitle> Logic Programming: Proc. North American Conf. </booktitle> <year> 1990, </year> <pages> pages 501-515. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year> <month> 16 </month>
Reference-contexts: 1 Introduction Abstract interpretation based program analysis has proven very useful in compilation of logic programming languages. Several compilers have demonstrated that global program analysis can give large performance improvement for the sequential compilation of Prolog <ref> [13, 14] </ref> and give significant automatic parallelization [2]. Recently, [6] have shown that global program analysis is also important for constraint logic programming (CLP) languages. Initial theoretical research in abstract interpretation of logic programs resulted in several generic "frameworks" for logic programming [1, 5, 9].
References-found: 14

