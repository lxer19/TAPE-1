URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-676.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/tr600.html
Root-URL: 
Title: Modeling and Verification of Randomized Distributed Real-Time Systems  
Author: by Roberto Segala Nancy A. Lynch 
Degree: Laurea, Computer Science  Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degree of Doctor of Philosophy in Electrical Engineering and Computer Science at the  Signature of Author  Certified by  Professor of Computer Science Thesis Supervisor Accepted by Frederic R. Morgenthaler Chair, Departmental Committee on Graduate Students  
Note: c Massachusetts Institute of Technology  
Address: Pisa Italy  
Date: (1992)  (1991)  (1991)  June 1995  1995  May 15, 1995  
Affiliation: S.M., Electrical Engineering and Computer Science Massachusetts Institute of Technology  Diploma, Computer Science Scuola Normale Superiore Pisa  University of  MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [ACD91a] <author> R. Alur, C. Courcoubetis, and D.L. Dill. </author> <title> Model-checking for probabilistic real-time systems. </title> <editor> In J. Leach Albert, B. Monien, and M. Rodrguez, editors, </editor> <booktitle> Proceedings 18 th ICALP, Madrid, volume 510 of Lecture Notes in Computer Science, </booktitle> <pages> pages 115-136. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Moreover, they give an algorithm for computing the exact probability with which a sequential program satisfies a formula. Alur, Courcoubetis and Dill <ref> [ACD91a, ACD91b] </ref> develop a model checking algorithm for probabilistic real-time systems. Processes are modeled as a generalized semi-Markov process, which are studied in [Whi80, She87]. Essentially a process is a finite state transition system with timing constraints expressed by probability distributions on the delays. <p> Essentially a process is a finite state transition system with timing constraints expressed by probability distributions on the delays. They impose the restriction that every distribution is either discrete, or exponential, or has a density function which is different from 0 only on a finite collection of intervals (in <ref> [ACD91a] </ref> only this last case is studied). The temporal logic, called TCTL, is an extension of the branching-time temporal logic of Emerson and Clarke [EC82] where time delays are added to the modal operators. <p> element ff 0 2 of t-exec ( H 2 dM i ) such that ff 0 ff 0 2 , which is sufficient to conclude. 221 9.6 Discussion To our knowledge, no general probabilistic models with dense time have been proposed except for the automata of Courcoubetis, Alur and Dill <ref> [ACD91a, ACD91b] </ref>. In our model no probability distributions over passage of time are allowed within a probabilistic timed automaton; time can elapse probabilistically only within a probabilistic timed execution, and the associated probability distributions can be only discrete. <p> Further work should investigate on the extension of our model to non-discrete probability distributions. A starting point could be the study of restricted forms of non-discrete distributions as it is done by Courcoubetis, Alur and Dill in <ref> [ACD91a, ACD91b] </ref>. <p> It is likely that some restrictions must be imposed to the model to ensure that some minimal set of events is measurable. Examples of restricted models with continuous distributions are the automata of Alur, Courcuobetis and Dill <ref> [ACD91a, ACD91b] </ref>, where the time that elapses between two transitions is governed by an exponential distribution or by a distribution which is non zero in a finite collection of closed intervals, and the models of [GHR93, Hil93, BDG94], where the time between the occurrence of two actions is assumed to be
Reference: [ACD91b] <author> R. Alur, C. Courcoubetis, and D.L. Dill. </author> <title> Verifying automata specifications of probabilistic real-time systems. </title> <editor> In de Bakker et al. </editor> <booktitle> [dBHRR91], </booktitle> <pages> pages 28-44. </pages>
Reference-contexts: Moreover, they give an algorithm for computing the exact probability with which a sequential program satisfies a formula. Alur, Courcoubetis and Dill <ref> [ACD91a, ACD91b] </ref> develop a model checking algorithm for probabilistic real-time systems. Processes are modeled as a generalized semi-Markov process, which are studied in [Whi80, She87]. Essentially a process is a finite state transition system with timing constraints expressed by probability distributions on the delays. <p> element ff 0 2 of t-exec ( H 2 dM i ) such that ff 0 ff 0 2 , which is sufficient to conclude. 221 9.6 Discussion To our knowledge, no general probabilistic models with dense time have been proposed except for the automata of Courcoubetis, Alur and Dill <ref> [ACD91a, ACD91b] </ref>. In our model no probability distributions over passage of time are allowed within a probabilistic timed automaton; time can elapse probabilistically only within a probabilistic timed execution, and the associated probability distributions can be only discrete. <p> Further work should investigate on the extension of our model to non-discrete probability distributions. A starting point could be the study of restricted forms of non-discrete distributions as it is done by Courcoubetis, Alur and Dill in <ref> [ACD91a, ACD91b] </ref>. <p> It is likely that some restrictions must be imposed to the model to ensure that some minimal set of events is measurable. Examples of restricted models with continuous distributions are the automata of Alur, Courcuobetis and Dill <ref> [ACD91a, ACD91b] </ref>, where the time that elapses between two transitions is governed by an exponential distribution or by a distribution which is non zero in a finite collection of closed intervals, and the models of [GHR93, Hil93, BDG94], where the time between the occurrence of two actions is assumed to be
Reference: [ACS94] <author> B. Awerbuch, L. Cowen, and M.A. Smith. </author> <title> Efficient asynchronous distributed symmetry breaking. </title> <booktitle> In Proceedings of the 26 th Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1994. </year>
Reference-contexts: One example of such an algorithm is the randomized algorithm for maximal independent sets of Awerbuch, Cowen and Smith <ref> [ACS94] </ref>; another example is the toy resource allocation protocol again.
Reference: [Agg94] <author> S. Aggarwal. </author> <title> Time optimal self-stabilizing spanning tree algorithms. </title> <type> Technical Report MIT/LCS/TR-632, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1994. </year> <type> Master's thesis. </type>
Reference-contexts: What is missing is a proof showing that the worst case has been identified. A much better statement would be "no matter what happens, something else will happen", since it does not require us to identify the worst scenario. Using our methodology, Aggarwal <ref> [Agg94] </ref> discovered a bug in an algorithm designed by himself and Kutten [AK93] which was due to an argument of the kind cited above. Similarly, we discovered a bug in the timing analysis of the mutual exclusion algorithm of Pnueli and Zuck [PZ86]. This bug arose for the same reason. <p> Therefore, we can claim that we have met the challenge given by randomization at least partially. Surely we understand much more of the problem than before. The fact that we have been able to prove new results about randomized algorithms is a positive sign. In particular, Aggarwal <ref> [Agg94] </ref> used successfully the technique presented in this thesis for the verification of the randomized self-stabilizing algorithm of Aggarwal and Kutten [AK93], which is not trivial at all; during the verification process Aggarwal discovered also a subtle bug in the original protocol. <p> In particular, some completeness results would be useful. 13.2.8 More Algorithms to Verify In this thesis we have illustrated our direct verification technique by proving the correctness of the randomized dining philosophers algorithm of Lehmann and Rabin [LR81] and of the randomized agreement protocol of Ben-Or [BO83]. In <ref> [Agg94] </ref> Aggarwal uses our model to verify the correctness of the self-stabilizing minimum weight spanning tree randomized algorithm of Aggarwal and Kutten [AK93]. However, the technique should be tested against many other algorithms.
Reference: [AH90] <author> J. Aspnes and M.P. Herlihy. </author> <title> Fast randomized consensus using shared memory. </title> <journal> Journal of Algorithms, </journal> <volume> 15(1) </volume> <pages> 441-460, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: In [Agg94] Aggarwal uses our model to verify the correctness of the self-stabilizing minimum weight spanning tree randomized algorithm of Aggarwal and Kutten [AK93]. However, the technique should be tested against many other algorithms. We are currently investigating the agreement protocol of Aspnes and Herlihy <ref> [AH90] </ref> and the randomized mutual exclusion algorithm of Pnueli and Zuck [PZ86].
Reference: [AK93] <author> S. Aggarwal and S. Kutten. </author> <title> Time optimal self stabilizing spanning tree algorithms. In R.K. Shyamasundar, editor, </title> <booktitle> 13th International Conference on Foundations of Software Technology and Theoretical Computer Science, volume 761 of Lecture Notes in Computer Science, </booktitle> <pages> pages 400-410, </pages> <address> Bombay, India., </address> <month> December </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: A much better statement would be "no matter what happens, something else will happen", since it does not require us to identify the worst scenario. Using our methodology, Aggarwal [Agg94] discovered a bug in an algorithm designed by himself and Kutten <ref> [AK93] </ref> which was due to an argument of the kind cited above. Similarly, we discovered a bug in the timing analysis of the mutual exclusion algorithm of Pnueli and Zuck [PZ86]. This bug arose for the same reason. <p> The fact that we have been able to prove new results about randomized algorithms is a positive sign. In particular, Aggarwal [Agg94] used successfully the technique presented in this thesis for the verification of the randomized self-stabilizing algorithm of Aggarwal and Kutten <ref> [AK93] </ref>, which is not trivial at all; during the verification process Aggarwal discovered also a subtle bug in the original protocol. In the measure in which the power of a proof method is evaluated based on the bugs that such method helps to discover, our methodology has achieved something. <p> In [Agg94] Aggarwal uses our model to verify the correctness of the self-stabilizing minimum weight spanning tree randomized algorithm of Aggarwal and Kutten <ref> [AK93] </ref>. However, the technique should be tested against many other algorithms. We are currently investigating the agreement protocol of Aspnes and Herlihy [AH90] and the randomized mutual exclusion algorithm of Pnueli and Zuck [PZ86].
Reference: [AL91] <author> M. Abadi and L. Lamport. </author> <title> An old-fashioned recipe for real time. </title> <editor> In de Bakker et al. </editor> <booktitle> [dBHRR91], </booktitle> <pages> pages 1-27. </pages>
Reference-contexts: The main objective of this chapter is to add time to probabilistic automata. Following an approach that Abadi and Lamport <ref> [AL91] </ref> call the "old-fashioned recipe", we address real-time issues by augmenting probabilistic automata with some structure that models passage of time. In particular, we adopt the solution of Lynch and Vaandrager [LV95], where a timed automaton is an ordinary automaton whose actions include the positive real numbers.
Reference: [AL93] <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <year> 1993. </year>
Reference-contexts: Although the trace preorder is weak as a notion of implementation, and so finer relations could be more appropriate [DeN87, Gla90, Gla93], there are several situations where a trace based semantics is sufficient <ref> [LT87, Dil88, AL93, GSSL94] </ref>. The advantage of a trace based semantics is that it is easy to handle. <p> Furthermore, the use of the live trace preorder within ordinary automata makes sense as a notion of implementation in the presence of I/O distinction and of a property called receptiveness or environment-freedom <ref> [Dil88, AL93, GSSL94] </ref>. It would be useful to study the theory of receptiveness of [Dil88, AL93] and of environment-freedom of [GSSL94] in the context of randomization. In this case, differently from [GSSL94], the environment is expressed by a function rather than by a sequence of actions. <p> Furthermore, the use of the live trace preorder within ordinary automata makes sense as a notion of implementation in the presence of I/O distinction and of a property called receptiveness or environment-freedom [Dil88, AL93, GSSL94]. It would be useful to study the theory of receptiveness of <ref> [Dil88, AL93] </ref> and of environment-freedom of [GSSL94] in the context of randomization. In this case, differently from [GSSL94], the environment is expressed by a function rather than by a sequence of actions.
Reference: [AS85] <author> B. Alpern and F.B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21(4) </volume> <pages> 181-185, </pages> <year> 1985. </year>
Reference-contexts: 1=2 and 2=3, depending on how the coin to be flipped is chosen." There is also another statement that can be formulated in relation to the question: "The nondeterministic coin flipper does not beep with any probability greater than 2=3." This last property is better known as a safety property <ref> [AS85] </ref> for ordinary labeled transition systems. Let us go back to the scheduling problem. There are actual cases where it is natural to allow a scheduler not to schedule any transition even though some transition is enabled. <p> The trace preorder constitutes the basis for several other implementation relations and is known to preserve the safety properties of a system <ref> [AS85] </ref>. Roughly speaking, a safety property says that "something good holds forever" or that "something bad does not happen". The trace preorder is important for ordinary automata for its simplicity and for the availability of the simulation method [LT87, Jon91, LV91] (cf. <p> M 1 v D M 2 iff tdistrs (M 1 ) tdistrs (M 2 ): (7.13) The trace distribution preorder is a conservative extension of the trace preorder of ordinary automata, and it preserves properties that resemble the safety properties of ordinary automata <ref> [AS85] </ref>. Here we give some examples of such properties. <p> However, lot of work remains to be done within the theory of liveness. First of all it would be useful to study how the definition of safety and liveness properties of Alpern and Schneider <ref> [AS85] </ref> extends to the probabilistic framework and what consequences such extension has. Furthermore, the use of the live trace preorder within ordinary automata makes sense as a notion of implementation in the presence of I/O distinction and of a property called receptiveness or environment-freedom [Dil88, AL93, GSSL94].
Reference: [BBS92] <author> J.C.M. Baeten, J.A. Bergstra, and S.A. Smolka. </author> <title> Axiomatizing probabilistic processes: ACP with generative probabilities. </title> <booktitle> In Cleaveland [Cle92], </booktitle> <pages> pages 472-485. </pages>
Reference-contexts: A similar idea to express priorities is used by Smolka and Steffen in [SS90], where the stratified semantics of PCCS is extended with 0-probability transitions. Baeten, Bergstra and Smolka <ref> [BBS92] </ref> define an algebra, prACP I , which is an extension of ACP [BW90] with generative probabilities.
Reference: [BDG94] <author> M. Bernardo, L. Donatiello, and R. Gorrieri. </author> <title> Modeling and analyzing concurrent systems with MPA. </title> <editor> In U. Herzog and M. Rettelbach, editors, </editor> <booktitle> Proceedings of 269 the Second Workshop on Process Algebras and Performance Modelling (PAPM), </booktitle> <publisher> Erlangen, Germany, </publisher> <pages> pages 175-189, </pages> <year> 1994. </year>
Reference-contexts: In order to simplify the analysis, the random variables are assumed to have an exponential probability distribution, which is memoryless. Research in this area includes work from Gotz, Herzog and Rettelbach [GHR93], from Hillston [Hil94], and from Bernardo, Donatiello and Gorrieri <ref> [BDG94] </ref>. 2.5 Verification: Qualitative and Quantitative Methods Most of the research on the verification of randomized distributed systems is concerned with properties that hold with probability 1. <p> A starting point could be the study of restricted forms of non-discrete distributions as it is done by Courcoubetis, Alur and Dill in [ACD91a, ACD91b]. Useful ideas can come from the work on stochastic process algebras of Gotz, Herzog and Rettelbach [GHR93], Hillston [Hil94], and Bernardo, Donatiello and Gorrieri <ref> [BDG94] </ref>. 222 Chapter 10 Direct Verication Time Complexity Part of this chapter is based on joint work with Anna Pogosyants and Isaac Saias; some of the ideas have been influenced by discussion with Lenore Zuck. <p> Examples of restricted models with continuous distributions are the automata of Alur, Courcuobetis and Dill [ACD91a, ACD91b], where the time that elapses between two transitions is governed by an exponential distribution or by a distribution which is non zero in a finite collection of closed intervals, and the models of <ref> [GHR93, Hil93, BDG94] </ref>, where the time between the occurrence of two actions is assumed to be distributed exponentially. Exponential distributions occur in several real systems and are easy to model due to their memoryless structure.
Reference: [BFJ + 82] <author> J. Burns, M. Fisher, P. Jackson, N.A. Lynch, and G. Peterson. </author> <title> Data requirements for implementation of n-process mutual exclusion using a single shared variable. </title> <journal> Journal of the ACM, </journal> <volume> 29(1) </volume> <pages> 183-205, </pages> <year> 1982. </year>
Reference-contexts: On the other hand, Burns, Fisher, Jackson, Lynch and Patter-son <ref> [BFJ + 82] </ref> showed that (n) values are necessary for a deterministic distributed algorithm. Since then, several other randomized distributed algorithms were proposed in the literature, each one breaking impossibility results proved for deterministic distributed algorithms. Several surveys of randomized algorithms are currently available; among those we cite [Kar90, GSB94].
Reference: [BG91] <editor> J.C.M. Baeten and J.F. Groote, editors. </editor> <booktitle> Proceedings of CONCUR 91, Amsterdam, volume 527 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [BHR84] <author> S.D. Brookes, C.A.R. Hoare, and A.W. Roscoe. </author> <title> A theory of communicating sequential processes. </title> <journal> Journal of the ACM, </journal> <volume> 31(3) </volume> <pages> 560-599, </pages> <year> 1984. </year>
Reference-contexts: Then, an abstract notion of observation is defined on automata, and an automaton is said to be an implementation of another automaton iff there is a specific relation, usually a preorder relation, between their abstract observations. Examples of observations are traces [Hoa85, LV91] (cf. Section 3.2.3), and failures <ref> [Hoa85, BHR84] </ref>; in these two cases implementation is expressed by set inclusion. 7.1.1 Observational Semantics Formally, an automaton A is associated with a set Obs (A) of observations, and a preorder relation R is defined over sets of observations (for example R can be set inclusion). <p> The trace preorder is important for ordinary automata for its simplicity and for the availability of the simulation method [LT87, Jon91, LV91] (cf. Chapter 8), which provides several sufficient conditions for the trace preorder relation to hold. Other relations, based either on failures <ref> [Hoa85, BHR84] </ref> or on any other form of enriched traces, can be obtained by following the same methodology that we present here. <p> Another widely known semantics for ordinary automata is the failure semantics of Brookes, Hoare and Roscoe <ref> [BHR84] </ref>, which in turn is connected to the testing preorders of De Nicola and Hennessy [DH84].
Reference: [BK90] <editor> J.C.M. Baeten and J.W. Klop, editors. </editor> <booktitle> Proceedings of CONCUR 90, Amsterdam, volume 458 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference: [BM89] <author> B. Bloom and A. Meyer. </author> <title> A remark on bisimulation between probabilistic processes. </title> <booktitle> In Proceedings of the Symposium on Logical Foundations of Computer Science, volume 363 of Lecture Notes in Computer Science, </booktitle> <pages> pages 26-40, </pages> <year> 1989. </year>
Reference-contexts: The minimum probability assumption states that for every state the probability of each transition is either 0 or is above some minimal value. This condition corresponds to the image-finiteness condition for non-probabilistic processes. Bloom and Meyer <ref> [BM89] </ref> relate the notions of probabilistic and non-probabilistic bisimilarity by showing that two non-probabilistic finitely branching processes P and Q are bisimilar if and only if there exists an assignment of probabilities to the transitions of P and Q such that the corresponding reactive processes P 0 and Q 0 are
Reference: [BO83] <author> M. Ben-Or. </author> <title> Another advantage of free choice: completely asynchronous agreement protocols. </title> <booktitle> In Proceedings of the 2 nd Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Montreal, Quebec, Canada, </address> <month> August </month> <year> 1983. </year>
Reference-contexts: Factoring out the probability from a problem helps considerably in removing errors due to unexpected dependencies. We illustrate the method by verifying the correctness of the randomized dining philosophers algorithm of Lehmann and Rabin [LR81] and the algorithm for randomized agreement with stopping faults of Ben-Or <ref> [BO83] </ref>. In both cases the correctness proof is carried out by proving a collection of progress statements using some coin lemmas. Finally, we suggest another technique, called the partition technique, that departs considerably from the coin lemmas and that appears to be useful in some cases. <p> significative applications of progress statements the reader is referred to Chapter 6, where we prove the correctness of the randomized Dining Philosophers algorithm of Lehmann and Rabin [LR81], and we prove the correctness of the randomized algorithm of Ben-Or for agreement in asynchronous networks in the presence of stopping faults <ref> [BO83] </ref>. Instead, the final part of this chapter concentrates on standard methods to specify event schemas and adversary schemas, and on the relationship between deterministic and general (randomized) adversaries. <p> coin lemmas, and we illustrate their use via two main examples: Section 6.3 proves the correctness of the randomized Dining Philosophers algorithm of Lehmann and Rabin [LR81], and Section 6.5 proves the correctness of the randomized algorithm of Ben-Or for agreement in asynchronous networks in the presence of stopping faults <ref> [BO83] </ref>. At the end of the chapter we hint at another technique, called the partition technique, that departs considerably from the coin lemmas and that is necessary to prove stronger claims about the toy resource allocation protocol. <p> Thus, P H [GCOIN (S; E)(H)] 1 P C [E] (6.38) 6.5 Example: Randomized Agreement with Stopping Faults In this section we analyze the Randomized Agreement algorithm of Ben-Or <ref> [BO83] </ref>. Its proof of correctness is an application of Lemma 6.4.2. <p> Since the processes are asynchronous, no processes can distinguish a slow process from a failing process. Unfortunately, it is known from [FLP85] that there is no deterministic algorithm for asynchronous processes that solves the agreement problem and guarantees 1-failure termination. Here we present the randomized algorithm of Ben-Or <ref> [BO83] </ref>, which solves the agreement problem with certainty, and guarantees f -failure termination with probability 1 whenever n &gt; 3f . 6.5.2 The Algorithm Each process i has local variables x, initially v i , and y, initially null, and executes a series of stages numbered 1; 2; : : :, <p> In particular, some completeness results would be useful. 13.2.8 More Algorithms to Verify In this thesis we have illustrated our direct verification technique by proving the correctness of the randomized dining philosophers algorithm of Lehmann and Rabin [LR81] and of the randomized agreement protocol of Ben-Or <ref> [BO83] </ref>. In [Agg94] Aggarwal uses our model to verify the correctness of the self-stabilizing minimum weight spanning tree randomized algorithm of Aggarwal and Kutten [AK93]. However, the technique should be tested against many other algorithms.
Reference: [BPV94] <author> D. Bosscher, I. Polak, and F. Vaandrager. </author> <title> Verification of an audio control protocol. </title> <type> Technical Report CS-R9445, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: A labeled transition system is a state machine with labels associated with the transitions (the moves from one state to another state). Labeled transition systems have been used successfully for the modeling of ordinary distributed systems [Mil89, Jon91, LV91, LT87, GSSL94], and for their verification <ref> [WLL88, SLL93, SGG + 93, BPV94] </ref>; in this case the labels are used to model communication between several systems.
Reference: [BW90] <author> J.C.M. Baeten and W.P Weijland. </author> <title> Process Algebra. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science 18, </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: We advise the reader not familiar with concurrency theory to read this chapter again after reading the thesis. There have been two main research directions in the field of randomized distributed real-time systems: one focused mainly on modeling issues using process algebras <ref> [Hoa85, Mil89, BW90] </ref> and labeled transition systems [Kel76, Plo81] as the basic mathematical objects; the other focused mainly on verification using Markov chains as the basic model and temporal logic arguments [Pnu82] and model checking [EC82, CES83] as the basic verification technique. <p> A similar idea to express priorities is used by Smolka and Steffen in [SS90], where the stratified semantics of PCCS is extended with 0-probability transitions. Baeten, Bergstra and Smolka [BBS92] define an algebra, prACP I , which is an extension of ACP <ref> [BW90] </ref> with generative probabilities. The authors show that prACP I and a weaker version of ACP (ACP I ) are correlated in the sense that ACP I is the homomorphic image of prACP I in which the probabilities are forgotten.
Reference: [CES83] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2), </volume> <year> 1983. </year>
Reference-contexts: field of randomized distributed real-time systems: one focused mainly on modeling issues using process algebras [Hoa85, Mil89, BW90] and labeled transition systems [Kel76, Plo81] as the basic mathematical objects; the other focused mainly on verification using Markov chains as the basic model and temporal logic arguments [Pnu82] and model checking <ref> [EC82, CES83] </ref> as the basic verification technique. Most of the results of the first of the research directions fail to model pure nondeterminism, while the results of the second of the research directions model pure nondeterminism successfully, but not in its full generality. <p> The previous model checking algorithms relied heavily on the fact that probabilities were not quantified. The algorithm is based on the algorithm for model checking of Clarke, Emerson and Sistla <ref> [CES83] </ref>, and on previous work of Hansson and Jonsson [HJ89] where a model checking algorithm for PCTL (TPCTL without time) is presented. In order to deal with quantified probabilities, the algorithm reduces the computation of the probability of an event to a collection of finitely many linear recursive equations. <p> On the other hand, several times the low level analysis is the only way to discover flaws in the intuitions about an algorithm. Fortunately, the low level analysis is amenable to automatic verification, although the research in this area is still in progress. Model checking <ref> [EC82, CES83] </ref> is certainly a useful technique; in [SGG + 93] it is shown how a theorem prover can be used to help in the verification of a protocol using simulations; in [PS95] we have investigated how a randomized algorithm can be verified mechanically once the high level proof is formulated.
Reference: [Chr90a] <author> I. Christoff. </author> <title> Testing equivalences and fully abstract models for probabilistic processes. </title> <booktitle> In Baeten and Klop [BK90], </booktitle> <pages> pages 126-140. </pages>
Reference-contexts: Informally, a test checks whether a process has some specific features: if the interaction between a test and a process is successful, then the process has the desired feature. Ivan Christoff <ref> [Chr90b, Chr90a] </ref> analyzes generative processes by means of testing. A test is a nondeterministic finite-state process, and the interaction between a process and a test is 26 obtained by performing only those actions that both the processes offer and by keeping the relative probability of each transition unchanged. <p> Possibly, a related theory of testing in the style of [DH84] should be defined. It is very likely that the new testing preorders will be similar to those of Yi and Larsen [YL92]. Other theories of testing for probabilistic automata are studied in <ref> [Chr90b, Chr90a, CSZ92, YCDS94] </ref> and are explained in Section 2.2. 13.2.6 Liveness in Probabilistic Automata In the extension of the notion of an execution of an automaton we have obtained a parallelism between the theory of ordinary automata and the theory of probabilistic automata.
Reference: [Chr90b] <author> I. Christoff. </author> <title> Testing Equivalences for Probabilistic Processes. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Uppsala University, </institution> <year> 1990. </year>
Reference-contexts: Informally, a test checks whether a process has some specific features: if the interaction between a test and a process is successful, then the process has the desired feature. Ivan Christoff <ref> [Chr90b, Chr90a] </ref> analyzes generative processes by means of testing. A test is a nondeterministic finite-state process, and the interaction between a process and a test is 26 obtained by performing only those actions that both the processes offer and by keeping the relative probability of each transition unchanged. <p> The relations are defined in a style similar to the denotational models of Ivan Christoff, and, in particular, the trace and barbed semantics coincide with two of the semantics of <ref> [Chr90b] </ref>. Linda Christoff also defines three linear-time temporal logics that characterize her three semantics and provides efficient model checking algorithms for the recursion-free version of the logics. <p> Possibly, a related theory of testing in the style of [DH84] should be defined. It is very likely that the new testing preorders will be similar to those of Yi and Larsen [YL92]. Other theories of testing for probabilistic automata are studied in <ref> [Chr90b, Chr90a, CSZ92, YCDS94] </ref> and are explained in Section 2.2. 13.2.6 Liveness in Probabilistic Automata In the extension of the notion of an execution of an automaton we have obtained a parallelism between the theory of ordinary automata and the theory of probabilistic automata.
Reference: [Chr93] <author> L. Christoff. </author> <title> Specification and Verification Methods for Probabilistic Processes. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Uppsala University, </institution> <year> 1993. </year>
Reference-contexts: An offering is a finite sequence of non-empty sets of actions, and, informally, describes the actions that the environment offers to a process during the interaction between the process and a test. Linda Christoff <ref> [Chr93] </ref> builds on the work of Ivan Christoff and defines three linear semantics for generative processes: the trace semantics, the broom semantics, and the barbed semantics.
Reference: [Cle92] <editor> W.R. Cleaveland, editor. </editor> <booktitle> Proceedings of CONCUR 92, </booktitle> <address> Stony Brook, NY, USA, </address> <booktitle> volume 630 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [CM88] <author> K.M. Chandi and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year> <month> 270 </month>
Reference-contexts: We show how probabilistic statements can be combined together to yield more complex statements, thus allowing for some form of compositional verification. We introduce a special kind of probabilistic statement, called a progress statement, which is a probabilistic extension of the leads-to operator of UNITY <ref> [CM88] </ref>. Informally, a progress statement says that if a system is started from some state in a set of states U , then, no matter what adversary is used, a state in some other set of states U 0 is reached with some minimum probability p. <p> Zuck [Zuc86] introduces the notion of ff-fairness and shows that ff-fairness is complete for temporal logic properties that hold with probability 1. Rao [Rao90] extends UNITY <ref> [CM88] </ref> to account for randomized systems and properties that hold with probability 1. The main emphasis is on properties rather than states. A new notion of weak probabilistic precondition is introduced that, together with the extreme fairness of Pnueli, generalizes weakest preconditions. <p> A progress statement is a probabilistic generalization of the leads-to operator of UNITY <ref> [CM88] </ref>. Example 5.1.2 It is possible to show (cf. <p> Example 5.1.4 Consider the toy resource allocation protocol again. We know from Exam ple 5.1.2 that R ! Advs M 1 : (5.4) It is also possible to show that R ) R Unless M 1 ; (5.5) where R ) R Unless M 1 is a UNITY <ref> [CM88] </ref> expression stating that whenever a system is in a state of R the system remains in a state of R unless a state of M 1 is reached. <p> Proposition 5.5.6). The reader familiar with UNITY may note that the combination of (5.4) and (5.5) is a probabilistic generalization of the ensures operator of Chandy and Misra <ref> [CM88] </ref>. <p> We call (5.23) a progress statement since, if we view U 0 as a better condition than U , then (5.23) states that from U it is possible to have some progress with probability at least p. The reader familiar with UNITY <ref> [CM88] </ref> may note that a progress statement is a probabilistic generalization of the leads-to operator of UNITY. Let us concentrate on the formal meaning of (5.23).
Reference: [CSZ92] <author> R. Cleaveland, S.A. Smolka, and A. Zwarico. </author> <title> Testing preorders for probabilistic processes (extended abstract). </title> <booktitle> In Proceedings 19 th ICALP, Madrid, volume 623 of Lecture Notes in Computer Science, </booktitle> <pages> pages 708-719. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: In more recent work Jonsson, Ho-Stuart and Yi [JHY94] give a characterization of the may preorder based on tests that are not probabilistic, while Jonsson and Yi [JY95] give a characterization of the may and must preorders based on general tests. Cleaveland, Smolka and Zwarico <ref> [CSZ92] </ref> introduce a testing preorder on reactive processes. A test is a reactive process with a collection of successful states and a non-observable action. <p> An alternative characterization of the testing preorder of Cleaveland et al. <ref> [CSZ92] </ref> is provided by Yuen, Cleaveland, Dayar and Smolka [YCDS94]. A process is represented as a mapping from probabilistic traces to [0; 1], where a probabilistic trace is an alternating sequence of actions and probability distributions over actions. <p> A process is represented as a mapping from probabilistic traces to [0; 1], where a probabilistic trace is an alternating sequence of actions and probability distributions over actions. Yuen et al. use the alternative characterization to show that the testing preorder of Cleaveland et al. <ref> [CSZ92] </ref> is an equivalence relation. 27 2.3 Models with Nondeterminism and Denotational Models 2.3.1 Transitions with Sets of Probabilities Jonsson and Larsen [JL91] introduce a new kind of probabilistic transition system where the transitions are labeled by sets of allowed probabilities. <p> Possibly, a related theory of testing in the style of [DH84] should be defined. It is very likely that the new testing preorders will be similar to those of Yi and Larsen [YL92]. Other theories of testing for probabilistic automata are studied in <ref> [Chr90b, Chr90a, CSZ92, YCDS94] </ref> and are explained in Section 2.2. 13.2.6 Liveness in Probabilistic Automata In the extension of the notion of an execution of an automaton we have obtained a parallelism between the theory of ordinary automata and the theory of probabilistic automata.
Reference: [CY88] <author> C. Courcoubetis and M. Yannakakis. </author> <title> Verifying temporal properties of finite-state probabilistic programs. </title> <booktitle> In 29 th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 338-345, </pages> <year> 1988. </year>
Reference-contexts: By considering a slightly restricted logic, Vardi and Wolper [VW86] reduce the complexity of the model checking algorithm to only one exponent in the size of the formula. Courcoubetis and Yannakakis <ref> [CY88, CY90] </ref> investigate the complexity of model checking linear time propositional temporal logic of sequential and concurrent probabilistic processes. A sequential process is a Markov chain and a concurrent process is a Concurrent Markov Chain.
Reference: [CY90] <author> C. Courcoubetis and M. Yannakakis. </author> <title> Markov decision procedures and regular events. </title> <editor> In M. Paterson, editor, </editor> <booktitle> Proceedings 17 th ICALP, Warwick, volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 336-349. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1990. </year>
Reference-contexts: By considering a slightly restricted logic, Vardi and Wolper [VW86] reduce the complexity of the model checking algorithm to only one exponent in the size of the formula. Courcoubetis and Yannakakis <ref> [CY88, CY90] </ref> investigate the complexity of model checking linear time propositional temporal logic of sequential and concurrent probabilistic processes. A sequential process is a Markov chain and a concurrent process is a Concurrent Markov Chain. <p> This should be a sufficiently strong reason to pursue additional research on methodologies (automatic or not) for the analysis of properties that hold with probabilities different than 1. The work of Hansson [Han94] and the algorithm that Courcoubetis and Yannakakis present in <ref> [CY90] </ref> are in this direction. 242 Chapter 11 Hierarchical Verication Timed Trace Distributions 11.1 Introduction In this chapter we extend the trace distribution preorder of Chapter 7 to the timed framework. The main difference is that we use timed traces rather than traces.
Reference: [dBHRR91] <editor> J.W. de Bakker, C. Huizing, W.P. de Roever, and G. Rozenberg, editors. </editor> <booktitle> Proceedings of the REX Workshop "Real-Time: Theory in Practice", volume 600 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [DeN87] <author> R. De Nicola. </author> <title> Extensional equivalences for transition systems. </title> <journal> Acta Informatica, </journal> <volume> 24 </volume> <pages> 211-237, </pages> <year> 1987. </year>
Reference-contexts: For example, no implementation of the buffer of Figure 3-1 can return natural numbers that were never entered or natural numbers in the wrong order. Although the trace preorder is weak as a notion of implementation, and so finer relations could be more appropriate <ref> [DeN87, Gla90, Gla93] </ref>, there are several situations where a trace based semantics is sufficient [LT87, Dil88, AL93, GSSL94]. The advantage of a trace based semantics is that it is easy to handle.
Reference: [DH84] <author> R. De Nicola and M. Hennessy. </author> <title> Testing equivalences for processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 83-133, </pages> <year> 1984. </year>
Reference-contexts: very likely that new probabilistic statements, new results to combine probabilistic statements, and new coin lemmas can be developed based on the study of other algorithms; similarly, the fundamental idea behind the trace semantics that we 21 present can be used also for other kinds of observational semantics like failures <ref> [Hoa85, DH84] </ref>. We give hints on how it is possible to handle liveness within our model and state what we know already. <p> + 1 delay parameters computes an actual delay, and returns the expected value of f applied to the delay parameters of the computations of A that lead to fi. 2.2 Models based on Testing Research on modeling has also focused on extending the testing preorders of De Nicola and Hennessy <ref> [DH84] </ref> to probabilistic processes. To define a testing preorder it is necessary to define a notion of a test and of how a test interacts with a process. The interaction between a test and a process may lead to success or failure. <p> Linda Christoff also defines three linear-time temporal logics that characterize her three semantics and provides efficient model checking algorithms for the recursion-free version of the logics. Testing preorders that are more in the style of De Nicola and Hennessy <ref> [DH84] </ref> are presented by Yi and Larsen in [YL92], where they define a process algebra with all the operators of CCS plus a binary probabilistic choice operator parameterized by a probability p. Thus, the calculus of Yi and Larsen allows for nondeterminism. <p> The two preorders are shown to coincide with the testing preorders of De Nicola and Hennessy <ref> [DH84] </ref> when no probability is present. In more recent work Jonsson, Ho-Stuart and Yi [JHY94] give a characterization of the may preorder based on tests that are not probabilistic, while Jonsson and Yi [JY95] give a characterization of the may and must preorders based on general tests. <p> Two processes are compared based on the probability of reaching a successful state in the interaction between a process and a test. The authors show that their testing preorder is closely connected to the testing preorders of De Nicola and Hennessy <ref> [DH84] </ref> in the sense that if a process passes a test with some non-zero probability, then the non-probabilistic version of the process (the result of removing the probabilities from the transition relation of the process) may pass the non-probabilistic version of the test, and if a process passes a test with <p> The labels, also called actions , are used to model communication between a system and its external environment. Labeled transition systems have been used successfully for the analysis of concurrent and distributed systems <ref> [DH84, Mil89, LT87, LV93a] </ref>; for this reason we choose them as our basic model. Currently there are several definitions of labeled transition systems, each one best suited for the kind of application it is meant for. <p> Another widely known semantics for ordinary automata is the failure semantics of Brookes, Hoare and Roscoe [BHR84], which in turn is connected to the testing preorders of De Nicola and Hennessy <ref> [DH84] </ref>. Similarly to the trace distribution semantics, it should be possible to extend the failure semantics to the probabilistic framework and find a sufficiently powerful context to distinguish probabilistic automata that are not in the corresponding precongruence relation. Possibly, a related theory of testing in the style of [DH84] should be <p> and Hennessy <ref> [DH84] </ref>. Similarly to the trace distribution semantics, it should be possible to extend the failure semantics to the probabilistic framework and find a sufficiently powerful context to distinguish probabilistic automata that are not in the corresponding precongruence relation. Possibly, a related theory of testing in the style of [DH84] should be defined. It is very likely that the new testing preorders will be similar to those of Yi and Larsen [YL92].
Reference: [Dil88] <author> D. Dill. </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-Independent Circuits. </title> <publisher> ACM Distinguished Dissertations. MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: Although the trace preorder is weak as a notion of implementation, and so finer relations could be more appropriate [DeN87, Gla90, Gla93], there are several situations where a trace based semantics is sufficient <ref> [LT87, Dil88, AL93, GSSL94] </ref>. The advantage of a trace based semantics is that it is easy to handle. <p> In the CSP synchronization style two automata must synchronize on their common actions and evolve independently on the others. Both in the CCS and CSP styles, communication is achieved through synchronization. In this thesis we adopt the CSP synchronization style, which is essentially the style adopted in <ref> [LT87, Dil88, LV93a] </ref>. A technical problem that arises in our framework is that automata may communicate through their internal actions, while internal actions are not supposed to be visible. To avoid these unwanted communications, we define a notion of compatibility between 40 automata. <p> Furthermore, the use of the live trace preorder within ordinary automata makes sense as a notion of implementation in the presence of I/O distinction and of a property called receptiveness or environment-freedom <ref> [Dil88, AL93, GSSL94] </ref>. It would be useful to study the theory of receptiveness of [Dil88, AL93] and of environment-freedom of [GSSL94] in the context of randomization. In this case, differently from [GSSL94], the environment is expressed by a function rather than by a sequence of actions. <p> Furthermore, the use of the live trace preorder within ordinary automata makes sense as a notion of implementation in the presence of I/O distinction and of a property called receptiveness or environment-freedom [Dil88, AL93, GSSL94]. It would be useful to study the theory of receptiveness of <ref> [Dil88, AL93] </ref> and of environment-freedom of [GSSL94] in the context of randomization. In this case, differently from [GSSL94], the environment is expressed by a function rather than by a sequence of actions.
Reference: [EC82] <author> E.A. Emerson and E.C. Clarke. </author> <title> Using branching time temporal logic to synthesize synchronous skeletons. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 2 </volume> <pages> 241-266, </pages> <year> 1982. </year>
Reference-contexts: field of randomized distributed real-time systems: one focused mainly on modeling issues using process algebras [Hoa85, Mil89, BW90] and labeled transition systems [Kel76, Plo81] as the basic mathematical objects; the other focused mainly on verification using Markov chains as the basic model and temporal logic arguments [Pnu82] and model checking <ref> [EC82, CES83] </ref> as the basic verification technique. Most of the results of the first of the research directions fail to model pure nondeterminism, while the results of the second of the research directions model pure nondeterminism successfully, but not in its full generality. <p> The temporal logic, called TCTL, is an extension of the branching-time temporal logic of Emerson and Clarke <ref> [EC82] </ref> where time delays are added to the modal operators. TCTL can detect only whether a formula is satisfied with probability 0, or with a positive probability, or with probability 1. <p> On the other hand, several times the low level analysis is the only way to discover flaws in the intuitions about an algorithm. Fortunately, the low level analysis is amenable to automatic verification, although the research in this area is still in progress. Model checking <ref> [EC82, CES83] </ref> is certainly a useful technique; in [SGG + 93] it is shown how a theorem prover can be used to help in the verification of a protocol using simulations; in [PS95] we have investigated how a randomized algorithm can be verified mechanically once the high level proof is formulated.
Reference: [FLP85] <author> M. Fischer, N. Lynch, and M. Paterson. </author> <title> Impossibility of distributed consensus with a family of faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: We assume that a process fails by stopping, i.e., by failing to send messages to other processes from some point on. Since the processes are asynchronous, no processes can distinguish a slow process from a failing process. Unfortunately, it is known from <ref> [FLP85] </ref> that there is no deterministic algorithm for asynchronous processes that solves the agreement problem and guarantees 1-failure termination.
Reference: [GHR93] <author> N. Gotz, U. Herzog, and M. Rettelbach. </author> <title> Multiprocessor and distributed system design: the integration of functional specification and performance analysis using stochastic process algebras. </title> <editor> In L. Donatiello and R. Nelson, editors, </editor> <title> Performance Evaluation of Computer and Communication Systems. </title> <booktitle> Joint Tutorial Papers of Performance '93 and Sigmetrics '93, volume 729 of Lecture Notes in Computer Science, </booktitle> <pages> pages 121-146. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In particular, actions are associated with durations, and the durations are expressed by random variables. In order to simplify the analysis, the random variables are assumed to have an exponential probability distribution, which is memoryless. Research in this area includes work from Gotz, Herzog and Rettelbach <ref> [GHR93] </ref>, from Hillston [Hil94], and from Bernardo, Donatiello and Gorrieri [BDG94]. 2.5 Verification: Qualitative and Quantitative Methods Most of the research on the verification of randomized distributed systems is concerned with properties that hold with probability 1. <p> A starting point could be the study of restricted forms of non-discrete distributions as it is done by Courcoubetis, Alur and Dill in [ACD91a, ACD91b]. Useful ideas can come from the work on stochastic process algebras of Gotz, Herzog and Rettelbach <ref> [GHR93] </ref>, Hillston [Hil94], and Bernardo, Donatiello and Gorrieri [BDG94]. 222 Chapter 10 Direct Verication Time Complexity Part of this chapter is based on joint work with Anna Pogosyants and Isaac Saias; some of the ideas have been influenced by discussion with Lenore Zuck. <p> Examples of restricted models with continuous distributions are the automata of Alur, Courcuobetis and Dill [ACD91a, ACD91b], where the time that elapses between two transitions is governed by an exponential distribution or by a distribution which is non zero in a finite collection of closed intervals, and the models of <ref> [GHR93, Hil93, BDG94] </ref>, where the time between the occurrence of two actions is assumed to be distributed exponentially. Exponential distributions occur in several real systems and are easy to model due to their memoryless structure.
Reference: [GJS90] <author> A. Giacalone, C.C Jou, and S.A. Smolka. </author> <title> Algebraic reasoning for probabilistic concurrent systems. </title> <booktitle> In Proceedings of the Working Conference on Programming Concepts and Methods (IFIP TC2), Sea of Galilee, </booktitle> <address> Israel, </address> <year> 1990. </year>
Reference-contexts: Both the probabilistic bisimulation and the extended probabilistic logic are axiomatized. 2.1.2 Generative and Stratified Models Giacalone, Jou and Smolka <ref> [GJS90] </ref> define a process algebra for generative processes, called PCCS, which can be seen as a probabilistic extension of Milner's SCCS [Mil93]. In PCCS two processes synchronize at every transition regardless of the action that they perform.
Reference: [Gla90] <author> R.J. van Glabbeek. </author> <title> The linear time branching time spectrum. </title> <booktitle> In Baeten and Klop [BK90], </booktitle> <pages> pages 278-297. </pages>
Reference-contexts: For example, no implementation of the buffer of Figure 3-1 can return natural numbers that were never entered or natural numbers in the wrong order. Although the trace preorder is weak as a notion of implementation, and so finer relations could be more appropriate <ref> [DeN87, Gla90, Gla93] </ref>, there are several situations where a trace based semantics is sufficient [LT87, Dil88, AL93, GSSL94]. The advantage of a trace based semantics is that it is easy to handle.
Reference: [Gla93] <author> R.J. van Glabbeek. </author> <title> The linear time branching time spectrum ii. The semantics of sequential systems with silent moves. </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings of CONCUR 93, Hildesheim, Germany, volume 715 of Lecture Notes in Computer Science, </booktitle> <pages> pages 66-81. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <month> 271 </month>
Reference-contexts: For example, no implementation of the buffer of Figure 3-1 can return natural numbers that were never entered or natural numbers in the wrong order. Although the trace preorder is weak as a notion of implementation, and so finer relations could be more appropriate <ref> [DeN87, Gla90, Gla93] </ref>, there are several situations where a trace based semantics is sufficient [LT87, Dil88, AL93, GSSL94]. The advantage of a trace based semantics is that it is easy to handle.
Reference: [GSB94] <author> R. Gupta, S.A. Smolka, and S. Bhaskar. </author> <title> On randomization in sequential and distributed algorithms. </title> <journal> ACM Computing Surveys, </journal> <volume> 26(1) </volume> <pages> 1-86, </pages> <year> 1994. </year>
Reference-contexts: Since then, several other randomized distributed algorithms were proposed in the literature, each one breaking impossibility results proved for deterministic distributed algorithms. Several surveys of randomized algorithms are currently available; among those we cite <ref> [Kar90, GSB94] </ref>. The bottom line is that randomization has proved to be exceptionally useful for problems in distributed computation, and it is slowly making its way into practical applications.
Reference: [GSSL94] <author> R. Gawlick, R. Segala, J.F. Stgaard-Andersen, and N.A. Lynch. </author> <title> Liveness in timed and untimed systems. </title> <editor> In S. Abiteboul and E. Shamir, editors, </editor> <booktitle> Proceedings 21 th ICALP, Jerusalem, volume 820 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> A full version appears as MIT Technical Report number MIT/LCS/TR-587. </note>
Reference-contexts: This intuition leads to the idea of Labeled Transition Systems (LTS) [Kel76, Plo81]. A labeled transition system is a state machine with labels associated with the transitions (the moves from one state to another state). Labeled transition systems have been used successfully for the modeling of ordinary distributed systems <ref> [Mil89, Jon91, LV91, LT87, GSSL94] </ref>, and for their verification [WLL88, SLL93, SGG + 93, BPV94]; in this case the labels are used to model communication between several systems. <p> Although the trace preorder is weak as a notion of implementation, and so finer relations could be more appropriate [DeN87, Gla90, Gla93], there are several situations where a trace based semantics is sufficient <ref> [LT87, Dil88, AL93, GSSL94] </ref>. The advantage of a trace based semantics is that it is easy to handle. <p> We start with the generalization of the simplest relations that do not abstract from internal computation, and we conclude with the generalization of the forward simulations of [LV91] that approximate closely the trace distribution preorder. We prove the equivalent of the Execution Correspondence Lemma <ref> [GSSL94] </ref> for probabilistic automata, which states that there is a strong connection between the probabilistic executions of two probabilistic automata related by some simulation relation. <p> This relationship is known as the execution correspondence lemma for ordinary automata <ref> [GSSL94] </ref> and is useful in the context of liveness. <p> Furthermore, the use of the live trace preorder within ordinary automata makes sense as a notion of implementation in the presence of I/O distinction and of a property called receptiveness or environment-freedom <ref> [Dil88, AL93, GSSL94] </ref>. It would be useful to study the theory of receptiveness of [Dil88, AL93] and of environment-freedom of [GSSL94] in the context of randomization. In this case, differently from [GSSL94], the environment is expressed by a function rather than by a sequence of actions. <p> It would be useful to study the theory of receptiveness of [Dil88, AL93] and of environment-freedom of <ref> [GSSL94] </ref> in the context of randomization. In this case, differently from [GSSL94], the environment is expressed by a function rather than by a sequence of actions. <p> It would be useful to study the theory of receptiveness of [Dil88, AL93] and of environment-freedom of <ref> [GSSL94] </ref> in the context of randomization. In this case, differently from [GSSL94], the environment is expressed by a function rather than by a sequence of actions.
Reference: [GSST90] <author> R.J. van Glabbeek, S.A. Smolka, B. Steffen, and C.M.N. Tofts. </author> <title> Reactive, generative, and stratified models of probabilistic processes. </title> <booktitle> In Proceedings 5 th Annual Symposium on Logic in Computer Science, </booktitle> <address> Philadelphia, USA, </address> <pages> pages 130-141. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year>
Reference-contexts: each chapter we add a section where we explain how the results described in this section are related to our research. 2.1 Reactive, Generative and Stratified Models We present some of the existing work on modeling which is based on a classification due to van Glabbeek, Smolka, Steffen and Tofts <ref> [GSST90] </ref>. They define three types of processes: reactive, generative, and stratified . * Reactive model: Reactive processes consist of states and labeled transitions associated with probabilities. <p> Observe that among the three models above only the reactive model has a structure that can be used to express some form of pure nondeterminism (what action to perform), although in van Glabbeek et al. <ref> [GSST90] </ref> this issue is not considered. 2.1.1 Reactive Model Rabin [Rab63] studies the theory of probabilistic automata, which are an instance of the reactive model. <p> Our probabilistic executions are essentially generative pro-ceses, and our trace distributions are essentially the trace semantics of Jou and Smolka. In our case the properties shown by Jou and Smolka follow directly from measure theory. Van Glabbeek et al. <ref> [GSST90] </ref> state that the generative model is more general than the reactive model in the sense that generative processes, in addition to the relative probabilities of transitions with the same label, contain information about the relative probabilities of transitions with different labels. <p> Finally, the authors define probabilistic bisimulation for the generative and for the stratified models and show that bisim-ulation is a congruence in all the models and that bisimulation is preserved under projection from one model to the other. The results of van Glabbeek et al. <ref> [GSST90] </ref>, however, are based on the fact that parallel composition is synchronous. Tofts [Tof90] introduces a weighted synchronous calculus whose operational semantics resem 25 bles the stratified model. <p> The first relation is sensitive to the actual frequencies of the transitions leaving from a state, while the second relation is sensitive only to the relative frequencies of the transitions leaving from a state. In particular, the second relation coincides with the stratified bisimulation of van Glabbeek et al. <ref> [GSST90] </ref> after normalizing to 1 the frequencies of the transitions that leave from every state. <p> The authors define a strong bisimulation semantics in the style of Larsen and Skou [LS89] for which they provide a sound and complete axiomatization. The model of Hansson and Jonsson [HJ90] differs substantially from the models of van Glabbeek et al. <ref> [GSST90] </ref> in that there is a clear distinction between pure nondeterminism and probability. The model could be viewed as an instance of the reactive model; however, the parallel composition operation defined by Hansson and Jonsson [HJ90] is asynchronous, while the classification of van Glabbeek et al. [GSST90] works only for synchronous <p> van Glabbeek et al. <ref> [GSST90] </ref> in that there is a clear distinction between pure nondeterminism and probability. The model could be viewed as an instance of the reactive model; however, the parallel composition operation defined by Hansson and Jonsson [HJ90] is asynchronous, while the classification of van Glabbeek et al. [GSST90] works only for synchronous composition. A complete presentation of the work of Hansson and Jonsson [HJ89, HJ90] appears in Hansson's PhD thesis [Han91], later published as a book [Han94]. <p> The first approach coincides with viewing each probabilistic automaton as deciding its next action probabilistically independently of the other interacting automaton; the second approach is the one outlined in <ref> [GSST90] </ref>, where essentially deadlock is not allowed, and assumes some dependence between the involved probabilistic automata. For the rest of the discussion we assume that the transitions tr 1 and tr 2 do synchronize; however, we leave unspecified the way in which tr 1 and tr 2 synchronize. 70 2. <p> that is the same as M , except that sig (M 0 ) = (ext (M ) I; int (M ) [ I): That is, the actions in the set I are hidden from the external environment. 4.5 Discussion The generative model of probabilistic processes of van Glabbeek et al. <ref> [GSST90] </ref> is a special case of a fully probabilistic automaton; simple probabilistic automata are partially captured by the reactive model of [GSST90] in the sense that the reactive model assumes some form of nondeterminism between different actions. <p> [ I): That is, the actions in the set I are hidden from the external environment. 4.5 Discussion The generative model of probabilistic processes of van Glabbeek et al. <ref> [GSST90] </ref> is a special case of a fully probabilistic automaton; simple probabilistic automata are partially captured by the reactive model of [GSST90] in the sense that the reactive model assumes some form of nondeterminism between different actions. However, the reactive model does not allow nondeterministic choices between transitions involving the same action. <p> Our parallel composition operator is defined only for simple probabilistic automata, and thus a natural objection is that after all we are dealing just with the reactive model. Furthermore, the reactive model is the least general according to <ref> [GSST90] </ref>. Although we recognize that our simple probabilistic automata constitute a restricted model and that it would be desirable to extend the parallel composition operator to general probabilistic automata, we do not think that it is possible to use the classification of [GSST90] to judge the expressivity of simple probabilistic automata. <p> reactive model is the least general according to <ref> [GSST90] </ref>. Although we recognize that our simple probabilistic automata constitute a restricted model and that it would be desirable to extend the parallel composition operator to general probabilistic automata, we do not think that it is possible to use the classification of [GSST90] to judge the expressivity of simple probabilistic automata. The classification of [GSST90] is based on a synchronous parallel composition, while our parallel composition is based on a conservative extension of the parallel composition of CSP [Hoa85]. Furthermore, in the classification of [GSST90] a model is more general if it contains <p> that our simple probabilistic automata constitute a restricted model and that it would be desirable to extend the parallel composition operator to general probabilistic automata, we do not think that it is possible to use the classification of <ref> [GSST90] </ref> to judge the expressivity of simple probabilistic automata. The classification of [GSST90] is based on a synchronous parallel composition, while our parallel composition is based on a conservative extension of the parallel composition of CSP [Hoa85]. Furthermore, in the classification of [GSST90] a model is more general if it contains less nondeterminism, while in our model nondeterminism is one of the key <p> it is possible to use the classification of <ref> [GSST90] </ref> to judge the expressivity of simple probabilistic automata. The classification of [GSST90] is based on a synchronous parallel composition, while our parallel composition is based on a conservative extension of the parallel composition of CSP [Hoa85]. Furthermore, in the classification of [GSST90] a model is more general if it contains less nondeterminism, while in our model nondeterminism is one of the key features. 73 74 Chapter 5 Direct Verication Stating a Property This chapter presents a method to study the properties that a probabilistic automaton satisfies.
Reference: [Hal50] <author> P.R. Halmos. </author> <title> Measure Theory. </title> <publisher> Springer-Verlag, </publisher> <year> 1950. </year>
Reference-contexts: This section introduces the basic concepts of measure theory that are necessary. Most of the results are taken directly from Halmos <ref> [Hal50] </ref> and Rudin [Rud66], and the proofs can be found in the same books or in any other good book on measure theory or probability theory. 3.1.1 Measurable Spaces Consider a set . <p> Then the expected value of X , denoted by E [X ], is the weighted average of X based on the probability distribution P . We do not show how to compute the expected value of a random variable in general, and we refer the interested reader to <ref> [Hal50] </ref>.
Reference: [Han91] <author> H. Hansson. </author> <title> Time and Probability in Formal Design of Distributed Systems. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Uppsala University, </institution> <year> 1991. </year>
Reference-contexts: A complete presentation of the work of Hansson and Jonsson [HJ89, HJ90] appears in Hansson's PhD thesis <ref> [Han91] </ref>, later published as a book [Han94]. Our simple probabilistic automata are very similar in style to the objects of Hansson's book. 2.3.3 Denotational Semantics Seidel [Sei92] extends CSP [Hoa85] with probability. The extension is carried out in two steps. <p> The model checking algorithm transforms a process into a finite state process without probabilities and real-time, thus allowing the use of other existing algorithms. The problem of model-checking for TCTL is PSPACE-hard. 2.5.3 Quantitative Method: Model Checking Hansson <ref> [Han91, Han94] </ref> defines a model checking algorithm for his Labeled Concurrent Markov Chain model and his branching-time temporal logic TPCTL. Time is discrete in Hansson's model, but the logic improves on previous work because probabilities can be quantified (i.e., probabilities can be between 0 and 1). <p> However, the reactive model does not allow nondeterministic choices between transitions involving the same action. By restricting simple probabilistic automata to have finitely many states, we obtain objects with a structure similar to that of the Concurrent Labeled Markov Chains of <ref> [Han91] </ref>; however, in our model we do not need to distinguish between nondeterministic and probabilistic states. In our model nondeterminism is obtained by means of the structure of the transition relation. This allows us to retain most of the traditional notation that is used for automata.
Reference: [Han94] <author> H. Hansson. </author> <title> Time and Probability in Formal Design of Distributed Systems, volume 1 of Real-Time Safety Critical Systems. </title> <publisher> Elsevier, </publisher> <year> 1994. </year>
Reference-contexts: A complete presentation of the work of Hansson and Jonsson [HJ89, HJ90] appears in Hansson's PhD thesis [Han91], later published as a book <ref> [Han94] </ref>. Our simple probabilistic automata are very similar in style to the objects of Hansson's book. 2.3.3 Denotational Semantics Seidel [Sei92] extends CSP [Hoa85] with probability. The extension is carried out in two steps. <p> It is not known yet how the semantics of Jones and Plotkin compares to existing operational semantics. 28 2.4 Models with Real Time There are basically two models that address real time issues. One model is the model of Hansson and Jonsson <ref> [Han94] </ref>, where special actions can appear in the transitions. The occurrence of an action means that time has elapsed, and the amount of time that elapses in a computation is given by the number of occurrences of action . Thus, the time domain of Hansson and Jonsson's model is discrete. <p> The model checking algorithm transforms a process into a finite state process without probabilities and real-time, thus allowing the use of other existing algorithms. The problem of model-checking for TCTL is PSPACE-hard. 2.5.3 Quantitative Method: Model Checking Hansson <ref> [Han91, Han94] </ref> defines a model checking algorithm for his Labeled Concurrent Markov Chain model and his branching-time temporal logic TPCTL. Time is discrete in Hansson's model, but the logic improves on previous work because probabilities can be quantified (i.e., probabilities can be between 0 and 1). <p> We denote he kernel of strong simulation by SS . Because of Lemma 8.2.2, our strong bisimulations are the same as the bisimulations of <ref> [Han94] </ref>, and our strong simulations are a generalization of the simulations of [JL91]. It is easy to check that ' is an equivalence relation, that v SS is a preorder relation, and that both ' and v SS are preserved by the parallel composition operator. <p> Successively it was adapted to the alternating model by Hansson <ref> [Han94] </ref>. In this thesis we have defined the same strong bisimulation as in [Han94]. The formal definition differs from the definition given by Hansson in that we have used the lifting of a relation to probability spaces as defined by Jonsson and Larsen [JL91]. <p> Successively it was adapted to the alternating model by Hansson <ref> [Han94] </ref>. In this thesis we have defined the same strong bisimulation as in [Han94]. The formal definition differs from the definition given by Hansson in that we have used the lifting of a relation to probability spaces as defined by Jonsson and Larsen [JL91]. <p> The probabilistic versions of our simulation relations are justified both by the fact that a scheduler can combine transitions probabilistically, as we have said in this thesis, and by the fact that several properties, namely the ones specified by the logic PCTL of Hansson and Jonsson <ref> [Han94] </ref>, are valid relative to randomized schedulers iff they are valid relative to deterministic schedulers. This fact was first observed by Segala and Lynch [SL94] and can be proved easily using the results about deterministic and randomized schedulers that we proved in Chapter 5. <p> This should be a sufficiently strong reason to pursue additional research on methodologies (automatic or not) for the analysis of properties that hold with probabilities different than 1. The work of Hansson <ref> [Han94] </ref> and the algorithm that Courcoubetis and Yannakakis present in [CY90] are in this direction. 242 Chapter 11 Hierarchical Verication Timed Trace Distributions 11.1 Introduction In this chapter we extend the trace distribution preorder of Chapter 7 to the timed framework. <p> The probabilistic modal logic of [LS89] is a direct extension of the modal logic of Hennessy and Milner [HM85] for reactive processes, but it is not sufficiently powerful to deal with nondeterminism; similarly, the extended probabilistic logic of [LS92] is not sufficiently powerful. The Probabilistic Computation Tree Logic of <ref> [HJ89, Han94] </ref> captures more the consequences of the interplay between probability and nondeterminism; in [SL94] PCTL is generalized also to probabilistic systems with internal actions (WPCTL). However, there are still properties that are useful and do not seem to be expressible in WPCTL.
Reference: [Hil93] <author> J. Hillston. PEPA: </author> <title> Performance enhanced process algebra. </title> <type> Technical Report CSR-24-93, </type> <institution> Department of Computer Science, University of Edimburgh (UK), </institution> <year> 1993. </year>
Reference-contexts: Examples of restricted models with continuous distributions are the automata of Alur, Courcuobetis and Dill [ACD91a, ACD91b], where the time that elapses between two transitions is governed by an exponential distribution or by a distribution which is non zero in a finite collection of closed intervals, and the models of <ref> [GHR93, Hil93, BDG94] </ref>, where the time between the occurrence of two actions is assumed to be distributed exponentially. Exponential distributions occur in several real systems and are easy to model due to their memoryless structure.
Reference: [Hil94] <author> J. Hillston. </author> <title> A Compositional Approach to Performance Modeling. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Edimburgh (UK), </institution> <year> 1994. </year>
Reference-contexts: In particular, actions are associated with durations, and the durations are expressed by random variables. In order to simplify the analysis, the random variables are assumed to have an exponential probability distribution, which is memoryless. Research in this area includes work from Gotz, Herzog and Rettelbach [GHR93], from Hillston <ref> [Hil94] </ref>, and from Bernardo, Donatiello and Gorrieri [BDG94]. 2.5 Verification: Qualitative and Quantitative Methods Most of the research on the verification of randomized distributed systems is concerned with properties that hold with probability 1. <p> A starting point could be the study of restricted forms of non-discrete distributions as it is done by Courcoubetis, Alur and Dill in [ACD91a, ACD91b]. Useful ideas can come from the work on stochastic process algebras of Gotz, Herzog and Rettelbach [GHR93], Hillston <ref> [Hil94] </ref>, and Bernardo, Donatiello and Gorrieri [BDG94]. 222 Chapter 10 Direct Verication Time Complexity Part of this chapter is based on joint work with Anna Pogosyants and Isaac Saias; some of the ideas have been influenced by discussion with Lenore Zuck.
Reference: [HJ89] <author> H. Hansson and B. Jonsson. </author> <title> A framework for reasoning about time and reliability. </title> <booktitle> In Proceedings of the 10 th IEEE Symposium on Real-Time Systems, </booktitle> <address> Santa Monica, Ca., </address> <year> 1989. </year>
Reference-contexts: Refinement is then defined as inclusion of probabilistic processes. Finally, Jonsson and Larsen present a complete method for verifying containment between specifications. 2.3.2 Alternating Models Hansson and Jonsson <ref> [HJ89, HJ90] </ref> develop a probabilistic process algebra based on an alternating model . <p> The model could be viewed as an instance of the reactive model; however, the parallel composition operation defined by Hansson and Jonsson [HJ90] is asynchronous, while the classification of van Glabbeek et al. [GSST90] works only for synchronous composition. A complete presentation of the work of Hansson and Jonsson <ref> [HJ89, HJ90] </ref> appears in Hansson's PhD thesis [Han91], later published as a book [Han94]. Our simple probabilistic automata are very similar in style to the objects of Hansson's book. 2.3.3 Denotational Semantics Seidel [Sei92] extends CSP [Hoa85] with probability. The extension is carried out in two steps. <p> The previous model checking algorithms relied heavily on the fact that probabilities were not quantified. The algorithm is based on the algorithm for model checking of Clarke, Emerson and Sistla [CES83], and on previous work of Hansson and Jonsson <ref> [HJ89] </ref> where a model checking algorithm for PCTL (TPCTL without time) is presented. In order to deal with quantified probabilities, the algorithm reduces the computation of the probability of an event to a collection of finitely many linear recursive equations. <p> The probabilistic modal logic of [LS89] is a direct extension of the modal logic of Hennessy and Milner [HM85] for reactive processes, but it is not sufficiently powerful to deal with nondeterminism; similarly, the extended probabilistic logic of [LS92] is not sufficiently powerful. The Probabilistic Computation Tree Logic of <ref> [HJ89, Han94] </ref> captures more the consequences of the interplay between probability and nondeterminism; in [SL94] PCTL is generalized also to probabilistic systems with internal actions (WPCTL). However, there are still properties that are useful and do not seem to be expressible in WPCTL.
Reference: [HJ90] <author> H. Hansson and B. Jonsson. </author> <title> A calculus for communicating systems with time and probabilities. </title> <booktitle> In Proceedings of the 11 th IEEE Symposium on Real-Time Systems, </booktitle> <address> Orlando, Fl., </address> <year> 1990. </year>
Reference-contexts: Refinement is then defined as inclusion of probabilistic processes. Finally, Jonsson and Larsen present a complete method for verifying containment between specifications. 2.3.2 Alternating Models Hansson and Jonsson <ref> [HJ89, HJ90] </ref> develop a probabilistic process algebra based on an alternating model . <p> The authors define a strong bisimulation semantics in the style of Larsen and Skou [LS89] for which they provide a sound and complete axiomatization. The model of Hansson and Jonsson <ref> [HJ90] </ref> differs substantially from the models of van Glabbeek et al. [GSST90] in that there is a clear distinction between pure nondeterminism and probability. The model could be viewed as an instance of the reactive model; however, the parallel composition operation defined by Hansson and Jonsson [HJ90] is asynchronous, while the <p> of Hansson and Jonsson <ref> [HJ90] </ref> differs substantially from the models of van Glabbeek et al. [GSST90] in that there is a clear distinction between pure nondeterminism and probability. The model could be viewed as an instance of the reactive model; however, the parallel composition operation defined by Hansson and Jonsson [HJ90] is asynchronous, while the classification of van Glabbeek et al. [GSST90] works only for synchronous composition. A complete presentation of the work of Hansson and Jonsson [HJ89, HJ90] appears in Hansson's PhD thesis [Han91], later published as a book [Han94]. <p> The model could be viewed as an instance of the reactive model; however, the parallel composition operation defined by Hansson and Jonsson [HJ90] is asynchronous, while the classification of van Glabbeek et al. [GSST90] works only for synchronous composition. A complete presentation of the work of Hansson and Jonsson <ref> [HJ89, HJ90] </ref> appears in Hansson's PhD thesis [Han91], later published as a book [Han94]. Our simple probabilistic automata are very similar in style to the objects of Hansson's book. 2.3.3 Denotational Semantics Seidel [Sei92] extends CSP [Hoa85] with probability. The extension is carried out in two steps.
Reference: [HM85] <author> M. Hennessy and R. Milner. </author> <title> Algebraic laws for nondeterminism and concurrency. </title> <journal> Journal of the ACM, </journal> <volume> 32(1) </volume> <pages> 137-161, </pages> <year> 1985. </year>
Reference-contexts: However, there are several other statements that can be of interest. It would be desirable to find a probabilistic temporal logic that expresses as many properties as possible. The probabilistic modal logic of [LS89] is a direct extension of the modal logic of Hennessy and Milner <ref> [HM85] </ref> for reactive processes, but it is not sufficiently powerful to deal with nondeterminism; similarly, the extended probabilistic logic of [LS92] is not sufficiently powerful.
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, </address> <year> 1985. </year>
Reference-contexts: On one hand we formalize some of the kinds of the informal arguments that usually appear in existing papers; on the other hand we extend existing abstract verification techniques for labeled transition systems to the probabilistic framework. Examples of abstract techniques include the analysis of traces <ref> [Hoa85] </ref>, which are ordered sequences of labels that can occur during the evolution of a system, and of simulation relations [Mil89, Jon91, LV91], which are relations between the states of two systems such that one system can simulate the transitions of the other via the simulation relation. <p> A considerable amount of research has been carried out in extending trace semantics and simulation relations to the probabilistic case, especially within process algebras <ref> [Hoa85, Mil89, 17 BW90] </ref>; however, most of the existing literature does not address pure nondeterminism, and thus it has limited practical applicability. We believe it is important to have a model that is both useful for realistic problems and accounts for the existing theoretical work. <p> We illustrate the partition technique on a toy resource allocation protocol, which is one of the guiding examples throughout Chapters 5 and 6. Hierarchical Verification: Trace Distributions. Chapter 7 extends the trace-based semantics of ordinary automata <ref> [Hoa85] </ref> to the probabilistic framework. A trace is a ordered sequence of labels that occur in an execution; a trace distribution is the probability distribution on traces induced by a probabilistic execution. <p> very likely that new probabilistic statements, new results to combine probabilistic statements, and new coin lemmas can be developed based on the study of other algorithms; similarly, the fundamental idea behind the trace semantics that we 21 present can be used also for other kinds of observational semantics like failures <ref> [Hoa85, DH84] </ref>. We give hints on how it is possible to handle liveness within our model and state what we know already. <p> We advise the reader not familiar with concurrency theory to read this chapter again after reading the thesis. There have been two main research directions in the field of randomized distributed real-time systems: one focused mainly on modeling issues using process algebras <ref> [Hoa85, Mil89, BW90] </ref> and labeled transition systems [Kel76, Plo81] as the basic mathematical objects; the other focused mainly on verification using Markov chains as the basic model and temporal logic arguments [Pnu82] and model checking [EC82, CES83] as the basic verification technique. <p> A complete presentation of the work of Hansson and Jonsson [HJ89, HJ90] appears in Hansson's PhD thesis [Han91], later published as a book [Han94]. Our simple probabilistic automata are very similar in style to the objects of Hansson's book. 2.3.3 Denotational Semantics Seidel [Sei92] extends CSP <ref> [Hoa85] </ref> with probability. The extension is carried out in two steps. <p> There are two main synchronization mechanisms for labeled transition systems, better known as the CCS synchronization style [Mil89], and the CSP synchronization style <ref> [Hoa85] </ref>. In the CCS synchronization style the external actions are grouped in pairs of complementary actions; a synchronization occurs between two automata that perform complementary actions, and becomes invisible to the external environment, i.e., a synchronization is an internal action. <p> The classification of [GSST90] is based on a synchronous parallel composition, while our parallel composition is based on a conservative extension of the parallel composition of CSP <ref> [Hoa85] </ref>. <p> Then, an abstract notion of observation is defined on automata, and an automaton is said to be an implementation of another automaton iff there is a specific relation, usually a preorder relation, between their abstract observations. Examples of observations are traces <ref> [Hoa85, LV91] </ref> (cf. <p> Then, an abstract notion of observation is defined on automata, and an automaton is said to be an implementation of another automaton iff there is a specific relation, usually a preorder relation, between their abstract observations. Examples of observations are traces [Hoa85, LV91] (cf. Section 3.2.3), and failures <ref> [Hoa85, BHR84] </ref>; in these two cases implementation is expressed by set inclusion. 7.1.1 Observational Semantics Formally, an automaton A is associated with a set Obs (A) of observations, and a preorder relation R is defined over sets of observations (for example R can be set inclusion). <p> The trace preorder is important for ordinary automata for its simplicity and for the availability of the simulation method [LT87, Jon91, LV91] (cf. Chapter 8), which provides several sufficient conditions for the trace preorder relation to hold. Other relations, based either on failures <ref> [Hoa85, BHR84] </ref> or on any other form of enriched traces, can be obtained by following the same methodology that we present here.
Reference: [HS85] <author> S. Hart and M. Sharir. </author> <title> How to schedule if you must. </title> <journal> SIAM Journal on Computing, </journal> <volume> 14 </volume> <pages> 991-1012, </pages> <year> 1985. </year>
Reference-contexts: Finally the authors give some examples of problems where the use of randomization does not provide any extra power over pure nondeterminism. The proof principle of [HSP83] is generalized to the infinite state case by Hart and Sharir <ref> [HS85] </ref>.
Reference: [HSP83] <author> S. Hart, M. Sharir, and A. Pnueli. </author> <title> Termination of probabilistic concurrent programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 356-380, </pages> <year> 1983. </year>
Reference-contexts: Usually a scheduler is required to be fair in the sense that each process should be scheduled infinitely many times. 2.5.1 Qualitative Method: Proof Techniques Huart, Sharir and Pnueli <ref> [HSP83] </ref> consider n finite state asynchronous randomized processes that run in parallel, and provide two necessary and sufficient conditions to guarantee that a given set of goal states is reached with probability 1 under any fair scheduler. <p> Finally the authors give some examples of problems where the use of randomization does not provide any extra power over pure nondeterminism. The proof principle of <ref> [HSP83] </ref> is generalized to the infinite state case by Hart and Sharir [HS85]. <p> The main emphasis is on properties rather than states. A new notion of weak probabilistic precondition is introduced that, together with the extreme fairness of Pnueli, generalizes weakest preconditions. Finally, based on the work of Huart et al. <ref> [HSP83] </ref>, Rao argues that his new logic is complete for finite state programs. 2.5.2 Qualitative Method: Model Checking Vardi [Var85] presents a method for deciding whether a probabilistic concurrent finite state program satisfies a linear temporal logic specification, where satisfaction means that a formula is satisfied with probability 1 whenever the <p> As a result, it is possible to verify the correctness of a randomized distributed algorithm by analyzing only the effect of deterministic adversaries, 100 which is easier than analyzing every adversary. A similar result is shown by Hart, Sharir and Pnueli <ref> [HSP83] </ref> for fair adversaries and almost-sure termination properties, i.e., properties that express the fact that under all fair adversaries the system reaches some fixed set of states with probability 1.
Reference: [JHY94] <author> B. Jonsson, C. Ho-Stuart, and W. Yi. </author> <title> Testing and refinement for nondeterministic and probabilistic processes. </title> <editor> In Langmaack, de Roever, and Vytopil, editors, </editor> <booktitle> Proceedings of the Symposium on Formal Techniques in Real-Time and Fault-Tolerant Systems, volume 863 of Lecture Notes in Computer Science, </booktitle> <pages> pages 418-430, </pages> <year> 1994. </year>
Reference-contexts: The two preorders are shown to coincide with the testing preorders of De Nicola and Hennessy [DH84] when no probability is present. In more recent work Jonsson, Ho-Stuart and Yi <ref> [JHY94] </ref> give a characterization of the may preorder based on tests that are not probabilistic, while Jonsson and Yi [JY95] give a characterization of the may and must preorders based on general tests. Cleaveland, Smolka and Zwarico [CSZ92] introduce a testing preorder on reactive processes.
Reference: [JL91] <author> B. Jonsson and K.G. Larsen. </author> <title> Specification and refinement of probabilistic processes. </title> <booktitle> In Proceedings of the 6th IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 266-277, </pages> <address> Amsterdam, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Yuen et al. use the alternative characterization to show that the testing preorder of Cleaveland et al. [CSZ92] is an equivalence relation. 27 2.3 Models with Nondeterminism and Denotational Models 2.3.1 Transitions with Sets of Probabilities Jonsson and Larsen <ref> [JL91] </ref> introduce a new kind of probabilistic transition system where the transitions are labeled by sets of allowed probabilities. The idea is to model specifications where the probabilities associated with the transitions are not completely specified. <p> Thus, a relation over states needs to be lifted to distributions over states. Here we borrow an idea from <ref> [JL91] </ref>. Let R X fi Y be a relation between two sets X; Y , and let P 1 and P 2 be two probability spaces of Probs (X ) and Probs (Y ), respectively. <p> We denote he kernel of strong simulation by SS . Because of Lemma 8.2.2, our strong bisimulations are the same as the bisimulations of [Han94], and our strong simulations are a generalization of the simulations of <ref> [JL91] </ref>. It is easy to check that ' is an equivalence relation, that v SS is a preorder relation, and that both ' and v SS are preserved by the parallel composition operator. We conclude this section by proving two results about the lifting of a relation. <p> In this thesis we have defined the same strong bisimulation as in [Han94]. The formal definition differs from the definition given by Hansson in that we have used the lifting of a relation to probability spaces as defined by Jonsson and Larsen <ref> [JL91] </ref>. Strong simulation is similar in style to the satisfaction relation for the probabilistic specification systems of Jonsson and Larsen [JL91]. It is from [JL91] that we have borrowed the idea of the lifting of a relation to a probability space. <p> The formal definition differs from the definition given by Hansson in that we have used the lifting of a relation to probability spaces as defined by Jonsson and Larsen <ref> [JL91] </ref>. Strong simulation is similar in style to the satisfaction relation for the probabilistic specification systems of Jonsson and Larsen [JL91]. It is from [JL91] that we have borrowed the idea of the lifting of a relation to a probability space. <p> differs from the definition given by Hansson in that we have used the lifting of a relation to probability spaces as defined by Jonsson and Larsen <ref> [JL91] </ref>. Strong simulation is similar in style to the satisfaction relation for the probabilistic specification systems of Jonsson and Larsen [JL91]. It is from [JL91] that we have borrowed the idea of the lifting of a relation to a probability space.
Reference: [Jon91] <author> B. Jonsson. </author> <title> Simulations between specifications of distributed systems. </title> <booktitle> In Baeten and Groote [BG91], </booktitle> <pages> pages 346-360. </pages>
Reference-contexts: This intuition leads to the idea of Labeled Transition Systems (LTS) [Kel76, Plo81]. A labeled transition system is a state machine with labels associated with the transitions (the moves from one state to another state). Labeled transition systems have been used successfully for the modeling of ordinary distributed systems <ref> [Mil89, Jon91, LV91, LT87, GSSL94] </ref>, and for their verification [WLL88, SLL93, SGG + 93, BPV94]; in this case the labels are used to model communication between several systems. <p> Examples of abstract techniques include the analysis of traces [Hoa85], which are ordered sequences of labels that can occur during the evolution of a system, and of simulation relations <ref> [Mil89, Jon91, LV91] </ref>, which are relations between the states of two systems such that one system can simulate the transitions of the other via the simulation relation. <p> We generalize the strong and weak bisimulation and simulation relations of Milner, Jonsson, Lynch and Vaandrager <ref> [Mil89, Jon91, LV91] </ref> to the probabilistic framework. Then, we introduce a coarser simulation relation, called a probabilistic forward simulation, where a state is related to a probability distribution over states rather than to a single state. <p> Roughly speaking, a safety property says that "something good holds forever" or that "something bad does not happen". The trace preorder is important for ordinary automata for its simplicity and for the availability of the simulation method <ref> [LT87, Jon91, LV91] </ref> (cf. Chapter 8), which provides several sufficient conditions for the trace preorder relation to hold. Other relations, based either on failures [Hoa85, BHR84] or on any other form of enriched traces, can be obtained by following the same methodology that we present here. <p> Standard work on simulation relations appears in <ref> [Mil89, Jon91, LV91] </ref>. Simulation relations are stronger than the trace preorder, and are often used as a sound proof technique for the trace preorder. In this chapter we study how to extend some of the relations of [Mil89, Jon91, LV91] to the probabilistic framework. <p> Standard work on simulation relations appears in <ref> [Mil89, Jon91, LV91] </ref>. Simulation relations are stronger than the trace preorder, and are often used as a sound proof technique for the trace preorder. In this chapter we study how to extend some of the relations of [Mil89, Jon91, LV91] to the probabilistic framework. We start with the generalization of the simplest relations that do not abstract from internal computation, and we conclude with the generalization of the forward simulations of [LV91] that approximate closely the trace distribution preorder.
Reference: [JP89] <author> C. Jones and G. Plotkin. </author> <title> A probabilistic powerdomain of evaluations. </title> <booktitle> In Proceedings 4 th Annual Symposium on Logic in Computer Science, Asilomar, California, </booktitle> <pages> pages 186-195. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference-contexts: Jones and Plotkin <ref> [JP89] </ref> use a category theoretic approach to define a probabilistic pow-erdomain, and they use it to give a semantics to a language with probabilistic concurrency.
Reference: [JP94] <author> B. Jonsson and J. Parrow, </author> <title> editors. </title> <booktitle> Proceedings of CONCUR 94, Uppsala, Sweden, volume 836 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: [JS90] <author> C.C. Jou and S.A. Smolka. </author> <title> Equivalences, congruences, and complete axiomatiza-tions for probabilistic processes. </title> <booktitle> In Baeten and Klop [BK90], </booktitle> <pages> pages 367-383. </pages>
Reference-contexts: The authors provide an equational theory for PCCS based on the probabilistic bisimulation of Larsen and Skou [LS89], and provide an axiomatization for probabilistic bisimulation (the axiomatization is shown to be sound and complete in <ref> [JS90] </ref>). Furthermore, the authors define a notion of *-bisimulation, where two processes can simulate each other's transition with a probability difference at most *. Based on *-bisimulation, the authors define a metric on generative processes. Jou and Smolka [JS90] define trace and failure equivalence for generative processes. <p> probabilistic bisimulation (the axiomatization is shown to be sound and complete in <ref> [JS90] </ref>). Furthermore, the authors define a notion of *-bisimulation, where two processes can simulate each other's transition with a probability difference at most *. Based on *-bisimulation, the authors define a metric on generative processes. Jou and Smolka [JS90] define trace and failure equivalence for generative processes. <p> Conversely, let M 1 kC P v D M 2 kC P . Then, from Lemmas 7.5.3, 7.5.4, 7.5.5, 7.5.6, 7.5.7, 7.5.8, 7.5.9, and 7.5.10, M 1 v DC M 2 . 7.6 Discussion A trace-based semantics similar to ours is studied for generative processes by Jou and Smolka <ref> [JS90] </ref>. One of the processes of Jou and Smolka is essentially one of our probabilistic executions. The semantics of a process is given by a function, called a trace function, that associates a probability with each finite trace.
Reference: [JY95] <author> B. Jonsson and W. Yi. </author> <title> Compositional testing preorders for probabilistic processes. </title> <booktitle> In Proceedings 10 th Annual Symposium on Logic in Computer Science, </booktitle> <address> San Diego, California. </address> <publisher> IEEE Computer Society Press, </publisher> <year> 1995. </year>
Reference-contexts: The two preorders are shown to coincide with the testing preorders of De Nicola and Hennessy [DH84] when no probability is present. In more recent work Jonsson, Ho-Stuart and Yi [JHY94] give a characterization of the may preorder based on tests that are not probabilistic, while Jonsson and Yi <ref> [JY95] </ref> give a characterization of the may and must preorders based on general tests. Cleaveland, Smolka and Zwarico [CSZ92] introduce a testing preorder on reactive processes. A test is a reactive process with a collection of successful states and a non-observable action.
Reference: [Kar90] <author> R.M. Karp. </author> <title> An introduction to randomized algorithms. </title> <type> Technical Report TR-90-024, </type> <institution> Computer Science Division, University of California, Berkeley, </institution> <address> CA, </address> <year> 1990. </year>
Reference-contexts: Since then, several other randomized distributed algorithms were proposed in the literature, each one breaking impossibility results proved for deterministic distributed algorithms. Several surveys of randomized algorithms are currently available; among those we cite <ref> [Kar90, GSB94] </ref>. The bottom line is that randomization has proved to be exceptionally useful for problems in distributed computation, and it is slowly making its way into practical applications.
Reference: [Kel76] <author> R. Keller. </author> <title> Formal verification of parallel programs. </title> <journal> Communications of the ACM, </journal> <volume> 7(19) </volume> <pages> 561-572, </pages> <year> 1976. </year>
Reference-contexts: A reasonable tradeoff between theory and practice is necessary. 14 Our main intuition for a computer system, distributed or not, is as a state machine that computes by moving from one state to another state. This intuition leads to the idea of Labeled Transition Systems (LTS) <ref> [Kel76, Plo81] </ref>. A labeled transition system is a state machine with labels associated with the transitions (the moves from one state to another state). <p> We advise the reader not familiar with concurrency theory to read this chapter again after reading the thesis. There have been two main research directions in the field of randomized distributed real-time systems: one focused mainly on modeling issues using process algebras [Hoa85, Mil89, BW90] and labeled transition systems <ref> [Kel76, Plo81] </ref> as the basic mathematical objects; the other focused mainly on verification using Markov chains as the basic model and temporal logic arguments [Pnu82] and model checking [EC82, CES83] as the basic verification technique. <p> If C is any set, then we denote by Probs (C) the set of discrete probability spaces (; F ; P ) with no 0-probability elements such that C. 3.2 Labeled Transition Systems A Labeled Transition System <ref> [Kel76, Plo81] </ref> is a state machine with labeled transitions. The labels, also called actions , are used to model communication between a system and its external environment.
Reference: [KR92] <author> E. Kushilevitz and M. Rabin. </author> <title> Randomized mutual exclusion algorithms revisited. </title> <booktitle> In Proceedings of the 11 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Quebec, Canada, </address> <pages> pages 275-284, </pages> <year> 1992. </year>
Reference-contexts: Probability is very tricky. The 16 fact that a specific probability space was not identified was the reason for a bug discovered by Saias [Sai92] in the original algorithm of Rabin [Rab82], later fixed by Kushilevitz and Rabin <ref> [KR92] </ref>. Of course, in order to make sure we know what probability spaces we are working in, we need some easy mechanisms to identify those probability spaces.
Reference: [LR81] <author> D. Lehmann and M. Rabin. </author> <title> On the advantage of free choice: a symmetric and fully distributed solution to the dining philosophers problem. </title> <booktitle> In Proceedings of the 8 th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 133-138, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: distributed algorithms is that the interplay between probability and nondeterminism can create subtle and unexpected dependencies between probabilistic events; the experience with randomized distributed algorithms shows that "intuition often fails to grasp the full intricacy of the algorithm" [PZ86], and "proofs of correctness for probabilistic distributed systems are extremely slippery" <ref> [LR81] </ref>. <p> Factoring out the probability from a problem helps considerably in removing errors due to unexpected dependencies. We illustrate the method by verifying the correctness of the randomized dining philosophers algorithm of Lehmann and Rabin <ref> [LR81] </ref> and the algorithm for randomized agreement with stopping faults of Ben-Or [BO83]. In both cases the correctness proof is carried out by proving a collection of progress statements using some coin lemmas. <p> Based on these timed progress statements , we show how to derive upper bounds on the expected time to reach some set of states. We illustrate the technique by showing that the randomized dining philosophers algorithm of Lehmann and Rabin <ref> [LR81] </ref> guarantees progress within expected constant time. By extending the technique for the analysis of expected time, we show how to derive bounds on more abstract notions of complexity. In particular, we consider the algorithm for randomized agreement of Ben-Or as an example. The algorithm of Ben-Or runs in stages. <p> The proof rule of Pnueli [Pnu83], along with some other new rules, is used by Pnueli and Zuck [PZ86] to verify two non-trivial randomized algorithms, including the Randomized Dining Philosophers algorithm of Lehmann and Rabin <ref> [LR81] </ref>. Zuck [Zuc86] introduces the notion of ff-fairness and shows that ff-fairness is complete for temporal logic properties that hold with probability 1. Rao [Rao90] extends UNITY [CM88] to account for randomized systems and properties that hold with probability 1. The main emphasis is on properties rather than states. <p> To see more significative applications of progress statements the reader is referred to Chapter 6, where we prove the correctness of the randomized Dining Philosophers algorithm of Lehmann and Rabin <ref> [LR81] </ref>, and we prove the correctness of the randomized algorithm of Ben-Or for agreement in asynchronous networks in the presence of stopping faults [BO83]. <p> We present a large collection of coin lemmas, and we illustrate their use via two main examples: Section 6.3 proves the correctness of the randomized Dining Philosophers algorithm of Lehmann and Rabin <ref> [LR81] </ref>, and Section 6.5 proves the correctness of the randomized algorithm of Ben-Or for agreement in asynchronous networks in the presence of stopping faults [BO83]. <p> Thus, P H [e 1;:::;n (H )] (1 p 1 p n ): (6.19) This completes the proof. 110 6.3 Example: Randomized Dining Philosophers In this section we apply the methodology presented so far to prove the correctness of the Randomized Dining Philosophers algorithm of Lehmann and Rabin <ref> [LR81] </ref>. The proof is structured in two levels. The high level proof consists of a collection of progress statements that are concatenated together; the low level proof consists of the proofs of the statements of the high level proof. <p> It is known from <ref> [LR81] </ref> that there is no symmetric solution even for the simple dining philosophers problem, i.e., there is no deterministic solution for the dining philosophers problem where each philosopher follows exactly the same protocol; some mechanism to break the symmetry is necessary. <p> However, more work in this direction is necessary. In particular, some completeness results would be useful. 13.2.8 More Algorithms to Verify In this thesis we have illustrated our direct verification technique by proving the correctness of the randomized dining philosophers algorithm of Lehmann and Rabin <ref> [LR81] </ref> and of the randomized agreement protocol of Ben-Or [BO83]. In [Agg94] Aggarwal uses our model to verify the correctness of the self-stabilizing minimum weight spanning tree randomized algorithm of Aggarwal and Kutten [AK93]. However, the technique should be tested against many other algorithms.
Reference: [LS82] <author> D. Lehmann and S. Shelah. </author> <title> Reasoning with time and chance. </title> <journal> Information and Control, </journal> <volume> 53 </volume> <pages> 165-198, </pages> <year> 1982. </year>
Reference-contexts: Finally the authors give some examples of problems where the use of randomization does not provide any extra power over pure nondeterminism. The proof principle of [HSP83] is generalized to the infinite state case by Hart and Sharir [HS85]. Lehmann and Shelah <ref> [LS82] </ref> extend the temporal logic of linear time of Pnueli [Pnu82] to account for properties that hold with probability 1, and they provide three complete axioma-tizations of the logic: one axiomatization is for general models, one is for finite models, and one is for models with bounded transition probabilities (same as <p> A model of the logic is essentially a Markov chain, or alternatively an unlabeled generative process. The logic of Lehmann and Shelah <ref> [LS82] </ref> is obtained from the logic of Pnueli [Pnu82] by adding a new modal operator O whose meaning is that the argument formula is satisfied with probability 1.
Reference: [LS89] <author> K.G. Larsen and A. Skou. </author> <title> Bisimulation through probabilistic testing. </title> <booktitle> In Conference Record of the 16 th ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin, Texas, </address> <pages> pages 344-352, </pages> <year> 1989. </year>
Reference-contexts: He defines a notion of a language accepted by a probabilistic automaton relative to a cut point and shows that there are finite state probabilistic automata that define non-regular languages. Larsen and Skou <ref> [LS89, LS91] </ref> define a bisimulation type semantics, called probabilistic bisimulation, and a logic, called probabilistic model logic (PML), for reactive processes, and they introduce a notion of testing based on sequential tests and a copying facility. <p> The authors provide an equational theory for PCCS based on the probabilistic bisimulation of Larsen and Skou <ref> [LS89] </ref>, and provide an axiomatization for probabilistic bisimulation (the axiomatization is shown to be sound and complete in [JS90]). Furthermore, the authors define a notion of *-bisimulation, where two processes can simulate each other's transition with a probability difference at most *. <p> The idea is to model specifications where the probabilities associated with the transitions are not completely specified. They extend the bisimulation of Larsen and Skou <ref> [LS89] </ref> to the new framework and they propose two criteria for refinement between specifications. One criterion is analogous to the definition of simulations between non-probabilistic processes; the other criterion is weaker and regards a specification as a set of probabilistic processes. Refinement is then defined as inclusion of probabilistic processes. <p> Only the transitions leaving from probabilistic states are probabilistic, and for each probabilistic state the probabilities of the outgoing transitions add to 1. The authors define a strong bisimulation semantics in the style of Larsen and Skou <ref> [LS89] </ref> for which they provide a sound and complete axiomatization. The model of Hansson and Jonsson [HJ90] differs substantially from the models of van Glabbeek et al. [GSST90] in that there is a clear distinction between pure nondeterminism and probability. <p> H 1 [C q ] = q 2 2m (i)jfitrace (q 2 ) X P S (i) [P 2 ]P 2 [q 2 ]: (8.86) Finally, from Condition 3 of an Execution Correspondence Structure again, we obtain Equation (8.81). 8.8 Discussion Strong bisimulation was first defined by Larsen and Skou <ref> [LS89, LS91] </ref> for reactive processes. Successively it was adapted to the alternating model by Hansson [Han94]. In this thesis we have defined the same strong bisimulation as in [Han94]. <p> However, there are several other statements that can be of interest. It would be desirable to find a probabilistic temporal logic that expresses as many properties as possible. The probabilistic modal logic of <ref> [LS89] </ref> is a direct extension of the modal logic of Hennessy and Milner [HM85] for reactive processes, but it is not sufficiently powerful to deal with nondeterminism; similarly, the extended probabilistic logic of [LS92] is not sufficiently powerful.
Reference: [LS91] <author> K.G. Larsen and A. Skou. </author> <title> Bisimulation through probabilistic testing. </title> <journal> Information and Computation, </journal> <volume> 94(1) </volume> <pages> 1-28, </pages> <month> September </month> <year> 1991. </year> <month> 273 </month>
Reference-contexts: He defines a notion of a language accepted by a probabilistic automaton relative to a cut point and shows that there are finite state probabilistic automata that define non-regular languages. Larsen and Skou <ref> [LS89, LS91] </ref> define a bisimulation type semantics, called probabilistic bisimulation, and a logic, called probabilistic model logic (PML), for reactive processes, and they introduce a notion of testing based on sequential tests and a copying facility. <p> Pnueli [Pnu82] to account for properties that hold with probability 1, and they provide three complete axioma-tizations of the logic: one axiomatization is for general models, one is for finite models, and one is for models with bounded transition probabilities (same as the minimum probability requirement of Larsen and Skou <ref> [LS91] </ref>). A model of the logic is essentially a Markov chain, or alternatively an unlabeled generative process. <p> H 1 [C q ] = q 2 2m (i)jfitrace (q 2 ) X P S (i) [P 2 ]P 2 [q 2 ]: (8.86) Finally, from Condition 3 of an Execution Correspondence Structure again, we obtain Equation (8.81). 8.8 Discussion Strong bisimulation was first defined by Larsen and Skou <ref> [LS89, LS91] </ref> for reactive processes. Successively it was adapted to the alternating model by Hansson [Han94]. In this thesis we have defined the same strong bisimulation as in [Han94].
Reference: [LS92] <author> K.G. Larsen and A. Skou. </author> <title> Compositional verification of probabilistic processes. </title> <booktitle> In Cleaveland [Cle92], </booktitle> <pages> pages 456-471. </pages>
Reference-contexts: Larsen and Skou <ref> [LS92] </ref> introduce a synchronous calculus for reactive processes where the probabilistic behavior is obtained through a binary choice operator parameterized by a prob 24 ability p. <p> The probabilistic modal logic of [LS89] is a direct extension of the modal logic of Hennessy and Milner [HM85] for reactive processes, but it is not sufficiently powerful to deal with nondeterminism; similarly, the extended probabilistic logic of <ref> [LS92] </ref> is not sufficiently powerful. The Probabilistic Computation Tree Logic of [HJ89, Han94] captures more the consequences of the interplay between probability and nondeterminism; in [SL94] PCTL is generalized also to probabilistic systems with internal actions (WPCTL).
Reference: [LSS94] <author> N.A. Lynch, I. Saias, and R. Segala. </author> <title> Proving time bounds for randomized distributed algorithms. </title> <booktitle> In Proceedings of the 13 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Los Angeles, CA, </address> <pages> pages 314-323, </pages> <year> 1994. </year>
Reference-contexts: The verification of the randomized dining philosophers algorithm of Lehmann and Rabin (Section 6.3) is based on joint work with Nancy Lynch and Isaac Saias <ref> [LSS94] </ref>, and the verification of the randomized algorithm for agreement of Ben-Or is a formalization of a proof that appears in the book on distributed algorithms of Nancy Lynch [Lyn95]. 6.1 How to Prove the Validity of a Probabilistic Statement In Chapter 5 we have defined formally what is a probabilistic <p> The verification of the randomized dining philosophers algorithm of Lehmann and Rabin (Section 10.6) is based on joint work with Nancy Lynch and Isaac Saias <ref> [LSS94] </ref>; the verification of the randomized algorithm for agreement of Ben-Or (Section 10.8) is joint work with Anna Pogosyants and is a formalization of a proof that appears in the book on distributed algorithms of Nancy Lynch [Lyn95].
Reference: [LT87] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proceedings of the 6 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 137-151, </pages> <address> Vancouver, Canada, </address> <month> August </month> <year> 1987. </year> <note> A full version is available as MIT Technical Report MIT/LCS/TR-387. </note>
Reference-contexts: This intuition leads to the idea of Labeled Transition Systems (LTS) [Kel76, Plo81]. A labeled transition system is a state machine with labels associated with the transitions (the moves from one state to another state). Labeled transition systems have been used successfully for the modeling of ordinary distributed systems <ref> [Mil89, Jon91, LV91, LT87, GSSL94] </ref>, and for their verification [WLL88, SLL93, SGG + 93, BPV94]; in this case the labels are used to model communication between several systems. <p> We give hints on how it is possible to handle liveness within our model and state what we know already. Furthermore, we give ideas of what is possible within restricted models where some form of I/O distinction like in the work of Lynch and Tuttle <ref> [LT87] </ref> or some timing restriction like in the work of Merritt, Modugno and Tuttle [MMT91] is imposed. <p> The authors also provide a sound and complete axiomatization of probabilistic bisimulation. Wu, Smolka and Stark [WSS94] augment the I/O automaton model of Lynch and Tuttle <ref> [LT87] </ref> with probability and they study a compositional behavioral semantics which is also shown to be fully abstract with respect to probabilistic testing. A test is a probabilistic I/O automaton with a success action w. The model is reactive for the input actions and generative for the output actions. <p> The labels, also called actions , are used to model communication between a system and its external environment. Labeled transition systems have been used successfully for the analysis of concurrent and distributed systems <ref> [DH84, Mil89, LT87, LV93a] </ref>; for this reason we choose them as our basic model. Currently there are several definitions of labeled transition systems, each one best suited for the kind of application it is meant for. <p> Although the trace preorder is weak as a notion of implementation, and so finer relations could be more appropriate [DeN87, Gla90, Gla93], there are several situations where a trace based semantics is sufficient <ref> [LT87, Dil88, AL93, GSSL94] </ref>. The advantage of a trace based semantics is that it is easy to handle. <p> In the CSP synchronization style two automata must synchronize on their common actions and evolve independently on the others. Both in the CCS and CSP styles, communication is achieved through synchronization. In this thesis we adopt the CSP synchronization style, which is essentially the style adopted in <ref> [LT87, Dil88, LV93a] </ref>. A technical problem that arises in our framework is that automata may communicate through their internal actions, while internal actions are not supposed to be visible. To avoid these unwanted communications, we define a notion of compatibility between 40 automata. <p> However, if we decorate probabilistic automata with some additional structure that clarifies who is in control of what actions <ref> [LT87] </ref>, then parallel composition can be extended safely to some forms of general probabilistic automata, where the external actions are partitioned into input and output actions, the transitions that contain some input action are simple transitions, and input actions are enabled from every state (cf. Section 13.2.2). <p> Roughly speaking, a safety property says that "something good holds forever" or that "something bad does not happen". The trace preorder is important for ordinary automata for its simplicity and for the availability of the simulation method <ref> [LT87, Jon91, LV91] </ref> (cf. Chapter 8), which provides several sufficient conditions for the trace preorder relation to hold. Other relations, based either on failures [Hoa85, BHR84] or on any other form of enriched traces, can be obtained by following the same methodology that we present here. <p> Exponential distributions occur in several real systems and are easy to model due to their memoryless structure. However, other distributions should be studied. 13.2.2 Simplified Models Within the context of ordinary automata Lynch and Tuttle <ref> [LT87] </ref> have developed a model of I/O automata. The model enforces a distinction between Input actions and Output actions within an automaton, and requires that input actions are enabled from every state. <p> The advantage of the use of traces is that traces are easy to deal with. 264 For this reason, it makes sense to study a theory of probabilistic I/O automata as an extension of the model of <ref> [LT87] </ref> and as a restriction of our model. An interesting point of a model with I/O distinction is that it is possible to relax the requirement that all the transitions of a probabilistic I/O automaton are simple.
Reference: [LV91] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations for timing-based systems. </title> <editor> In de Bakker et al. </editor> <booktitle> [dBHRR91], </booktitle> <pages> pages 397-446. </pages>
Reference-contexts: This intuition leads to the idea of Labeled Transition Systems (LTS) [Kel76, Plo81]. A labeled transition system is a state machine with labels associated with the transitions (the moves from one state to another state). Labeled transition systems have been used successfully for the modeling of ordinary distributed systems <ref> [Mil89, Jon91, LV91, LT87, GSSL94] </ref>, and for their verification [WLL88, SLL93, SGG + 93, BPV94]; in this case the labels are used to model communication between several systems. <p> Examples of abstract techniques include the analysis of traces [Hoa85], which are ordered sequences of labels that can occur during the evolution of a system, and of simulation relations <ref> [Mil89, Jon91, LV91] </ref>, which are relations between the states of two systems such that one system can simulate the transitions of the other via the simulation relation. <p> We generalize the strong and weak bisimulation and simulation relations of Milner, Jonsson, Lynch and Vaandrager <ref> [Mil89, Jon91, LV91] </ref> to the probabilistic framework. Then, we introduce a coarser simulation relation, called a probabilistic forward simulation, where a state is related to a probability distribution over states rather than to a single state. <p> Then, an abstract notion of observation is defined on automata, and an automaton is said to be an implementation of another automaton iff there is a specific relation, usually a preorder relation, between their abstract observations. Examples of observations are traces <ref> [Hoa85, LV91] </ref> (cf. <p> Roughly speaking, a safety property says that "something good holds forever" or that "something bad does not happen". The trace preorder is important for ordinary automata for its simplicity and for the availability of the simulation method <ref> [LT87, Jon91, LV91] </ref> (cf. Chapter 8), which provides several sufficient conditions for the trace preorder relation to hold. Other relations, based either on failures [Hoa85, BHR84] or on any other form of enriched traces, can be obtained by following the same methodology that we present here. <p> Standard work on simulation relations appears in <ref> [Mil89, Jon91, LV91] </ref>. Simulation relations are stronger than the trace preorder, and are often used as a sound proof technique for the trace preorder. In this chapter we study how to extend some of the relations of [Mil89, Jon91, LV91] to the probabilistic framework. <p> Standard work on simulation relations appears in <ref> [Mil89, Jon91, LV91] </ref>. Simulation relations are stronger than the trace preorder, and are often used as a sound proof technique for the trace preorder. In this chapter we study how to extend some of the relations of [Mil89, Jon91, LV91] to the probabilistic framework. We start with the generalization of the simplest relations that do not abstract from internal computation, and we conclude with the generalization of the forward simulations of [LV91] that approximate closely the trace distribution preorder. <p> In this chapter we study how to extend some of the relations of [Mil89, Jon91, LV91] to the probabilistic framework. We start with the generalization of the simplest relations that do not abstract from internal computation, and we conclude with the generalization of the forward simulations of <ref> [LV91] </ref> that approximate closely the trace distribution preorder. We prove the equivalent of the Execution Correspondence Lemma [GSSL94] for probabilistic automata, which states that there is a strong connection between the probabilistic executions of two probabilistic automata related by some simulation relation.
Reference: [LV93a] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations part I: Untimed systems. </title> <type> Technical Report MIT/LCS/TM-486, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: The labels, also called actions , are used to model communication between a system and its external environment. Labeled transition systems have been used successfully for the analysis of concurrent and distributed systems <ref> [DH84, Mil89, LT87, LV93a] </ref>; for this reason we choose them as our basic model. Currently there are several definitions of labeled transition systems, each one best suited for the kind of application it is meant for. <p> Currently there are several definitions of labeled transition systems, each one best suited for the kind of application it is meant for. In this section we present a definition of labeled transition systems in the style of <ref> [LV93a] </ref>. 3.2.1 Automata An automaton A consists of four components: 1. a set states (A) of states. 2. a nonempty set start (A) states (A) of start states. 3. an action signature sig (A) = (ext (A); int (A)), where ext (A) and int (A) are disjoint sets of external and <p> Denote by traces fl (A) and traces (A) the sets of finite and all traces of A, respectively. Note, that a finite trace can be the trace of an infinite execution. 3.2.4 Trace Semantics In <ref> [LV93a] </ref> automata are compared based on traces. <p> In the CSP synchronization style two automata must synchronize on their common actions and evolve independently on the others. Both in the CCS and CSP styles, communication is achieved through synchronization. In this thesis we adopt the CSP synchronization style, which is essentially the style adopted in <ref> [LT87, Dil88, LV93a] </ref>. A technical problem that arises in our framework is that automata may communicate through their internal actions, while internal actions are not supposed to be visible. To avoid these unwanted communications, we define a notion of compatibility between 40 automata. <p> However, we have not shown any completeness result for probabilistic forward simulations and probabilistic forward timed simulations. In <ref> [LV93a, LV95] </ref> it is shown that forward simulations together with another kind of simulations called backward simulations are sound and complete for the trace preorder.
Reference: [LV93b] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations part II: Timing-based systems. </title> <type> Technical Report MIT/LCS/TM-487, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: the second problem the reader may object that it originates from the choice of using a distinct time-passage action for each amount of time that elapses in a transition, and thus we may conclude that the problem would be solved by using a unique action that expresses passage of time <ref> [LV93b] </ref> rather than a different action for every time; however, the problem has deeper roots.
Reference: [LV95] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations part II: Timing-based systems. </title> <type> Technical Report CS-R95??, </type> <institution> CWI, </institution> <address> Amsterdam, </address> ?? <year> 1995. </year>
Reference-contexts: Thus, simulation relations can be used as a sound technique to prove principal trace distribution inclusion. 20 Probabilistic Timed Automata. Chapter 9 starts the second part of the thesis. We extend probabilistic automata with time following the approach of Lynch and Vaandrager <ref> [LV95] </ref>, where passage of time is modeled by means of transitions labeled with positive real numbers. In order to use most of the untimed theory, we force time-passage transition not to be probabilistic. <p> Following an approach that Abadi and Lamport [AL91] call the "old-fashioned recipe", we address real-time issues by augmenting probabilistic automata with some structure that models passage of time. In particular, we adopt the solution of Lynch and Vaandrager <ref> [LV95] </ref>, where a timed automaton is an ordinary automaton whose actions include the positive real numbers. The occurrence of a real number d means that time d elapses. In addition, a timed automaton of [LV95] is required to satisfy two trajectory axioms: the first axiom says that if time d can <p> In particular, we adopt the solution of Lynch and Vaandrager <ref> [LV95] </ref>, where a timed automaton is an ordinary automaton whose actions include the positive real numbers. The occurrence of a real number d means that time d elapses. In addition, a timed automaton of [LV95] is required to satisfy two trajectory axioms: the first axiom says that if time d can elapse and immediately afterwards time d 0 can elapse, then time d + d 0 can elapse; the second axiom says that if time d can elapse, then there is a trajectory that allows <p> Chapter 10). In the rest of this chapter we concentrate on the definition of the timed model as an extension of the probabilistic automata of Chapter 4. Most of the concepts are extensions of the definitions of <ref> [LV95] </ref> to the probabilistic framework; the non-trivial part of the chapter is the definition of a probabilistic timed execution, where some measure-theoretical complications arise. 9.2 The Timed Model In this section we define probabilistic timed automata as an extension of the probabilistic automata of Chapter 4, and we extend the timed <p> probabilistic framework; the non-trivial part of the chapter is the definition of a probabilistic timed execution, where some measure-theoretical complications arise. 9.2 The Timed Model In this section we define probabilistic timed automata as an extension of the probabilistic automata of Chapter 4, and we extend the timed executions of <ref> [LV95] </ref> to our framework. <p> The definition of a timed trace that we give in this section is taken directly from <ref> [LV95] </ref>. Timed Sequence Pairs Let K be any set that does not intersect &lt; + . <p> However, we have not shown any completeness result for probabilistic forward simulations and probabilistic forward timed simulations. In <ref> [LV93a, LV95] </ref> it is shown that forward simulations together with another kind of simulations called backward simulations are sound and complete for the trace preorder.
Reference: [Lyn95] <author> N.A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: randomized dining philosophers algorithm of Lehmann and Rabin (Section 6.3) is based on joint work with Nancy Lynch and Isaac Saias [LSS94], and the verification of the randomized algorithm for agreement of Ben-Or is a formalization of a proof that appears in the book on distributed algorithms of Nancy Lynch <ref> [Lyn95] </ref>. 6.1 How to Prove the Validity of a Probabilistic Statement In Chapter 5 we have defined formally what is a probabilistic statement and we have shown how it is possible to combine probabilistic statements to derive more complex properties. <p> (Section 10.6) is based on joint work with Nancy Lynch and Isaac Saias [LSS94]; the verification of the randomized algorithm for agreement of Ben-Or (Section 10.8) is joint work with Anna Pogosyants and is a formalization of a proof that appears in the book on distributed algorithms of Nancy Lynch <ref> [Lyn95] </ref>. Close interaction with Anna Pogosyants lead us to the idea of the abstract complexity measures of Section 10.7. 10.1 General Considerations About Time The direct analysis of a probabilistic timed automaton is carried out exactly in the same way as for untimed probabilistic automata.
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Engle-wood Cliffs, </address> <year> 1989. </year>
Reference-contexts: This intuition leads to the idea of Labeled Transition Systems (LTS) [Kel76, Plo81]. A labeled transition system is a state machine with labels associated with the transitions (the moves from one state to another state). Labeled transition systems have been used successfully for the modeling of ordinary distributed systems <ref> [Mil89, Jon91, LV91, LT87, GSSL94] </ref>, and for their verification [WLL88, SLL93, SGG + 93, BPV94]; in this case the labels are used to model communication between several systems. <p> Examples of abstract techniques include the analysis of traces [Hoa85], which are ordered sequences of labels that can occur during the evolution of a system, and of simulation relations <ref> [Mil89, Jon91, LV91] </ref>, which are relations between the states of two systems such that one system can simulate the transitions of the other via the simulation relation. <p> A considerable amount of research has been carried out in extending trace semantics and simulation relations to the probabilistic case, especially within process algebras <ref> [Hoa85, Mil89, 17 BW90] </ref>; however, most of the existing literature does not address pure nondeterminism, and thus it has limited practical applicability. We believe it is important to have a model that is both useful for realistic problems and accounts for the existing theoretical work. <p> We generalize the strong and weak bisimulation and simulation relations of Milner, Jonsson, Lynch and Vaandrager <ref> [Mil89, Jon91, LV91] </ref> to the probabilistic framework. Then, we introduce a coarser simulation relation, called a probabilistic forward simulation, where a state is related to a probability distribution over states rather than to a single state. <p> We advise the reader not familiar with concurrency theory to read this chapter again after reading the thesis. There have been two main research directions in the field of randomized distributed real-time systems: one focused mainly on modeling issues using process algebras <ref> [Hoa85, Mil89, BW90] </ref> and labeled transition systems [Kel76, Plo81] as the basic mathematical objects; the other focused mainly on verification using Markov chains as the basic model and temporal logic arguments [Pnu82] and model checking [EC82, CES83] as the basic verification technique. <p> The labels, also called actions , are used to model communication between a system and its external environment. Labeled transition systems have been used successfully for the analysis of concurrent and distributed systems <ref> [DH84, Mil89, LT87, LV93a] </ref>; for this reason we choose them as our basic model. Currently there are several definitions of labeled transition systems, each one best suited for the kind of application it is meant for. <p> There are two main synchronization mechanisms for labeled transition systems, better known as the CCS synchronization style <ref> [Mil89] </ref>, and the CSP synchronization style [Hoa85]. In the CCS synchronization style the external actions are grouped in pairs of complementary actions; a synchronization occurs between two automata that perform complementary actions, and becomes invisible to the external environment, i.e., a synchronization is an internal action. <p> Standard work on simulation relations appears in <ref> [Mil89, Jon91, LV91] </ref>. Simulation relations are stronger than the trace preorder, and are often used as a sound proof technique for the trace preorder. In this chapter we study how to extend some of the relations of [Mil89, Jon91, LV91] to the probabilistic framework. <p> Standard work on simulation relations appears in <ref> [Mil89, Jon91, LV91] </ref>. Simulation relations are stronger than the trace preorder, and are often used as a sound proof technique for the trace preorder. In this chapter we study how to extend some of the relations of [Mil89, Jon91, LV91] to the probabilistic framework. We start with the generalization of the simplest relations that do not abstract from internal computation, and we conclude with the generalization of the forward simulations of [LV91] that approximate closely the trace distribution preorder. <p> A coarser equivalence relation is strong bisimulation <ref> [Par81, Mil89] </ref>, where two automata A 1 and A 2 are equivalent iff there is an equivalence relation between their states so that for each pair (s 1 ; s 2 ) of equivalent states, if s 1 ! s 0 1 , then there exists a state s 0 2
Reference: [Mil93] <author> R. Milner. </author> <title> Calculi for synchrony and asynchrony. </title> <journal> Theoretical Computer Science, </journal> <volume> 25 </volume> <pages> 267-310, </pages> <year> 1993. </year>
Reference-contexts: Both the probabilistic bisimulation and the extended probabilistic logic are axiomatized. 2.1.2 Generative and Stratified Models Giacalone, Jou and Smolka [GJS90] define a process algebra for generative processes, called PCCS, which can be seen as a probabilistic extension of Milner's SCCS <ref> [Mil93] </ref>. In PCCS two processes synchronize at every transition regardless of the action that they perform.
Reference: [MMT91] <author> M. Merritt, F. Modugno, and M. Tuttle. </author> <title> Time constrained automata. </title> <booktitle> In Baeten and Groote [BG91], </booktitle> <pages> pages 408-423. </pages>
Reference-contexts: Furthermore, we give ideas of what is possible within restricted models where some form of I/O distinction like in the work of Lynch and Tuttle [LT87] or some timing restriction like in the work of Merritt, Modugno and Tuttle <ref> [MMT91] </ref> is imposed. <p> A similar observation was made also by Wu, Stark and Smolka in [WSS94]. A restricted timed model with I/O distinction is introduced by Merrit, Modugno and Tuttle <ref> [MMT91] </ref>. In particular timing constraints can be described only by giving upper and lower bounds to the time it takes for a process to perform the next transition whenever it is ready to do so.
Reference: [OL82] <author> S. Owicki and L. Lamport. </author> <title> Proving liveness properties of concurrent programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4 </volume> <pages> 455-495, </pages> <year> 1982. </year>
Reference-contexts: The structure of the possible evolutions of a system can become intricate quickly, justifying the statement "there is rather a large body of sad experience to indicate that a concurrent program can withstand very careful scrutiny without revealing its errors" <ref> [OL82] </ref>. The introduction of randomization makes the problem even more challenging since two kinds of nondeterminism arise. We call them pure nondeterminism and probabilistic nondeter-minism.
Reference: [Par81] <author> D.M.R. Park. </author> <title> Concurrency and automata on infinite sequences. </title> <editor> In P. Deussen, editor, </editor> <booktitle> 5 th GI Conference, volume 104 of Lecture Notes in Computer Science, </booktitle> <pages> pages 167-183. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: A coarser equivalence relation is strong bisimulation <ref> [Par81, Mil89] </ref>, where two automata A 1 and A 2 are equivalent iff there is an equivalence relation between their states so that for each pair (s 1 ; s 2 ) of equivalent states, if s 1 ! s 0 1 , then there exists a state s 0 2
Reference: [Plo81] <author> G.D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer science Department, Aarhus University, </institution> <year> 1981. </year>
Reference-contexts: A reasonable tradeoff between theory and practice is necessary. 14 Our main intuition for a computer system, distributed or not, is as a state machine that computes by moving from one state to another state. This intuition leads to the idea of Labeled Transition Systems (LTS) <ref> [Kel76, Plo81] </ref>. A labeled transition system is a state machine with labels associated with the transitions (the moves from one state to another state). <p> We advise the reader not familiar with concurrency theory to read this chapter again after reading the thesis. There have been two main research directions in the field of randomized distributed real-time systems: one focused mainly on modeling issues using process algebras [Hoa85, Mil89, BW90] and labeled transition systems <ref> [Kel76, Plo81] </ref> as the basic mathematical objects; the other focused mainly on verification using Markov chains as the basic model and temporal logic arguments [Pnu82] and model checking [EC82, CES83] as the basic verification technique. <p> If C is any set, then we denote by Probs (C) the set of discrete probability spaces (; F ; P ) with no 0-probability elements such that C. 3.2 Labeled Transition Systems A Labeled Transition System <ref> [Kel76, Plo81] </ref> is a state machine with labeled transitions. The labels, also called actions , are used to model communication between a system and its external environment.
Reference: [Pnu82] <author> A. Pnueli. </author> <title> The temporal semantics of concurrent programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 45-60, </pages> <year> 1982. </year> <month> 274 </month>
Reference-contexts: research directions in the field of randomized distributed real-time systems: one focused mainly on modeling issues using process algebras [Hoa85, Mil89, BW90] and labeled transition systems [Kel76, Plo81] as the basic mathematical objects; the other focused mainly on verification using Markov chains as the basic model and temporal logic arguments <ref> [Pnu82] </ref> and model checking [EC82, CES83] as the basic verification technique. Most of the results of the first of the research directions fail to model pure nondeterminism, while the results of the second of the research directions model pure nondeterminism successfully, but not in its full generality. <p> The proof principle of [HSP83] is generalized to the infinite state case by Hart and Sharir [HS85]. Lehmann and Shelah [LS82] extend the temporal logic of linear time of Pnueli <ref> [Pnu82] </ref> to account for properties that hold with probability 1, and they provide three complete axioma-tizations of the logic: one axiomatization is for general models, one is for finite models, and one is for models with bounded transition probabilities (same as the minimum probability requirement of Larsen and Skou [LS91]). <p> A model of the logic is essentially a Markov chain, or alternatively an unlabeled generative process. The logic of Lehmann and Shelah [LS82] is obtained from the logic of Pnueli <ref> [Pnu82] </ref> by adding a new modal operator O whose meaning is that the argument formula is satisfied with probability 1. Pnueli [Pnu83] introduces the notion of extreme fairness and shows that a property that holds for all extreme fair executions holds with probability 1.
Reference: [Pnu83] <author> A. Pnueli. </author> <title> On the extremely fair treatment of probabilistic algorithms. </title> <booktitle> In Pro--ceedings of the 15 th Annual ACM Symposium on Theory of Computing, </booktitle> <address> Boston, Massachusetts, </address> <month> May </month> <year> 1983. </year>
Reference-contexts: The logic of Lehmann and Shelah [LS82] is obtained from the logic of Pnueli [Pnu82] by adding a new modal operator O whose meaning is that the argument formula is satisfied with probability 1. Pnueli <ref> [Pnu83] </ref> introduces the notion of extreme fairness and shows that a property that holds for all extreme fair executions holds with probability 1. Furthermore, Pnueli presents a sound proof rule based on extreme fairness and linear temporal logic. The model consists of n randomized processes in parallel. <p> An execution is extremely fair if and only if it is extremely fair relative to any formula expressed in the logic used in <ref> [Pnu83] </ref>. The proof rule of Pnueli [Pnu83], along with some other new rules, is used by Pnueli and Zuck [PZ86] to verify two non-trivial randomized algorithms, including the Randomized Dining Philosophers algorithm of Lehmann and Rabin [LR81]. <p> An execution is extremely fair if and only if it is extremely fair relative to any formula expressed in the logic used in <ref> [Pnu83] </ref>. The proof rule of Pnueli [Pnu83], along with some other new rules, is used by Pnueli and Zuck [PZ86] to verify two non-trivial randomized algorithms, including the Randomized Dining Philosophers algorithm of Lehmann and Rabin [LR81].
Reference: [PS95] <author> A. Pogosyants and R. Segala. </author> <title> Formal verification of timed properties of randomized distributed algorithms. </title> <booktitle> In Proceedings of the 14 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Ottawa, Ontario, Canada, </address> <month> August </month> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: There is a considerable amount of work on model checking of randomized distributed systems, and yet we are introducing new techniques. Furthermore, although there is some ongoing work on automating part of the proof methods developed in this thesis <ref> [PS95] </ref>, we do not address any decidability issue here. Our favorite analogy to justify our approach is that we view model checking as the program "Mathematica", a popular program for symbolic manipulation of analytic expressions. <p> We have carried out this last part using detailed operational arguments, which can be error prone themselves. However, since the problem is reduced to the analysis of a non-randomized system, several existing techniques can be used to eliminate our operational arguments. In <ref> [PS95] </ref> Segala and Pogosyants show how such an analysis can be carried out formally and possibly mechanized. 133 134 Chapter 7 Hierarchical Verication Trace Distributions 7.1 Introduction So far we have defined a model to describe randomized concurrent and distributed systems, and we have shown how to study the properties of <p> Model checking [EC82, CES83] is certainly a useful technique; in [SGG + 93] it is shown how a theorem prover can be used to help in the verification of a protocol using simulations; in <ref> [PS95] </ref> we have investigated how a randomized algorithm can be verified mechanically once the high level proof is formulated. However, there is still a lot of work that needs to be done.
Reference: [PZ86] <author> A. Pnueli and L. Zuck. </author> <title> Verification of multiprocess probabilistic protocols. </title> <journal> Distributed Computing, </journal> <volume> 1(1) </volume> <pages> 53-72, </pages> <year> 1986. </year>
Reference-contexts: The main difficulty with randomized distributed algorithms is that the interplay between probability and nondeterminism can create subtle and unexpected dependencies between probabilistic events; the experience with randomized distributed algorithms shows that "intuition often fails to grasp the full intricacy of the algorithm" <ref> [PZ86] </ref>, and "proofs of correctness for probabilistic distributed systems are extremely slippery" [LR81]. <p> Using our methodology, Aggarwal [Agg94] discovered a bug in an algorithm designed by himself and Kutten [AK93] which was due to an argument of the kind cited above. Similarly, we discovered a bug in the timing analysis of the mutual exclusion algorithm of Pnueli and Zuck <ref> [PZ86] </ref>. This bug arose for the same reason. The reader familiar with existing work, and in particular familiar with model checking, may be a bit puzzled at this point. There is a considerable amount of work on model checking of randomized distributed systems, and yet we are introducing new techniques. <p> An execution is extremely fair if and only if it is extremely fair relative to any formula expressed in the logic used in [Pnu83]. The proof rule of Pnueli [Pnu83], along with some other new rules, is used by Pnueli and Zuck <ref> [PZ86] </ref> to verify two non-trivial randomized algorithms, including the Randomized Dining Philosophers algorithm of Lehmann and Rabin [LR81]. Zuck [Zuc86] introduces the notion of ff-fairness and shows that ff-fairness is complete for temporal logic properties that hold with probability 1. <p> However, the technique should be tested against many other algorithms. We are currently investigating the agreement protocol of Aspnes and Herlihy [AH90] and the randomized mutual exclusion algorithm of Pnueli and Zuck <ref> [PZ86] </ref>. Based on the little experience that we have gained, we can say that the model provides us with a systematic way of analyzing those algorithms, and in particular it provides us with a simple methodology to identify the critical points of an algorithm.
Reference: [Rab63] <author> M.O. Rabin. </author> <title> Probabilistic automata. </title> <journal> Information and Control, </journal> <volume> 6 </volume> <pages> 230-245, </pages> <year> 1963. </year>
Reference-contexts: Observe that among the three models above only the reactive model has a structure that can be used to express some form of pure nondeterminism (what action to perform), although in van Glabbeek et al. [GSST90] this issue is not considered. 2.1.1 Reactive Model Rabin <ref> [Rab63] </ref> studies the theory of probabilistic automata, which are an instance of the reactive model. He defines a notion of a language accepted by a probabilistic automaton relative to a cut point and shows that there are finite state probabilistic automata that define non-regular languages.
Reference: [Rab76] <author> M.O. Rabin. </author> <title> Probabilistic algorithms. </title> <editor> In J. F. Traub, editor, </editor> <booktitle> Algorithms and Complexity: New Directions and Results, </booktitle> <pages> pages 21-39. </pages> <publisher> Academic Press, </publisher> <year> 1976. </year>
Reference-contexts: Introduction 1.1 The Challenge of Randomization In 1976 Rabin published a paper titled Probabilistic Algorithms <ref> [Rab76] </ref> where he presented efficient algorithms for two well-known problems: Nearest Neighbors , a problem in computational geometry, and Primality Testing , the problem of determining whether a number is prime.
Reference: [Rab82] <author> M.O. Rabin. </author> <title> N -process mutual exclusion with bounded waiting by 4 log N shared variables. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25 </volume> <pages> 66-75, </pages> <year> 1982. </year>
Reference-contexts: Rabin's paper was the beginning of a new trend of research aimed at using randomization to improve the complexity of existing algorithms. It is currently conjectured that there are no efficient deterministic algorithms for Nearest Neighbors and Primality Testing. Another considerable achievement came in 1982, when Rabin <ref> [Rab82] </ref> proposed a solution to a problem in distributed computing which was known to be unsolvable without randomization. <p> This is a rule of thumb that is valid in other fields like Information Theory and Detection Theory. Probability is very tricky. The 16 fact that a specific probability space was not identified was the reason for a bug discovered by Saias [Sai92] in the original algorithm of Rabin <ref> [Rab82] </ref>, later fixed by Kushilevitz and Rabin [KR92]. Of course, in order to make sure we know what probability spaces we are working in, we need some easy mechanisms to identify those probability spaces.
Reference: [Rao90] <author> J.R. Rao. </author> <title> Reasoning about probabilistic algorithms. </title> <booktitle> In Proceedings of the 9 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Quebec, Canada, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Zuck [Zuc86] introduces the notion of ff-fairness and shows that ff-fairness is complete for temporal logic properties that hold with probability 1. Rao <ref> [Rao90] </ref> extends UNITY [CM88] to account for randomized systems and properties that hold with probability 1. The main emphasis is on properties rather than states. A new notion of weak probabilistic precondition is introduced that, together with the extreme fairness of Pnueli, generalizes weakest preconditions.
Reference: [Rud66] <author> W. </author> <title> Rudin. Real Complex Analysis. </title> <publisher> McGraw-Hill, </publisher> <year> 1966. </year>
Reference-contexts: This section introduces the basic concepts of measure theory that are necessary. Most of the results are taken directly from Halmos [Hal50] and Rudin <ref> [Rud66] </ref>, and the proofs can be found in the same books or in any other good book on measure theory or probability theory. 3.1.1 Measurable Spaces Consider a set .
Reference: [Sai92] <author> I. Saias. </author> <title> Proving probabilistic correctness: the case of Rabin's algorithm for mutual exclusion. </title> <booktitle> In Proceedings of the 11 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Quebec, Canada, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: This is a rule of thumb that is valid in other fields like Information Theory and Detection Theory. Probability is very tricky. The 16 fact that a specific probability space was not identified was the reason for a bug discovered by Saias <ref> [Sai92] </ref> in the original algorithm of Rabin [Rab82], later fixed by Kushilevitz and Rabin [KR92]. Of course, in order to make sure we know what probability spaces we are working in, we need some easy mechanisms to identify those probability spaces.
Reference: [Sei92] <author> K. Seidel. </author> <title> Probabilistic communicating processes. </title> <type> Technical Report PRG-102, Ph.D. Thesis, </type> <institution> Programming Research Group, Oxford University Computing Laboratory, </institution> <year> 1992. </year>
Reference-contexts: A complete presentation of the work of Hansson and Jonsson [HJ89, HJ90] appears in Hansson's PhD thesis [Han91], later published as a book [Han94]. Our simple probabilistic automata are very similar in style to the objects of Hansson's book. 2.3.3 Denotational Semantics Seidel <ref> [Sei92] </ref> extends CSP [Hoa85] with probability. The extension is carried out in two steps.
Reference: [SGG + 93] <author> J.F. Stgaard-Andersen, S.J. Garland, J.V. Guttag, N.A. Lynch, and A. Pogosyants. </author> <title> Computer-assisted simulation proofs. </title> <editor> In C. Courcoubetis, editor, </editor> <booktitle> Proceedings of the fifth international conference on Computer Aided Verification, volume 697 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: A labeled transition system is a state machine with labels associated with the transitions (the moves from one state to another state). Labeled transition systems have been used successfully for the modeling of ordinary distributed systems [Mil89, Jon91, LV91, LT87, GSSL94], and for their verification <ref> [WLL88, SLL93, SGG + 93, BPV94] </ref>; in this case the labels are used to model communication between several systems. <p> Fortunately, the low level analysis is amenable to automatic verification, although the research in this area is still in progress. Model checking [EC82, CES83] is certainly a useful technique; in <ref> [SGG + 93] </ref> it is shown how a theorem prover can be used to help in the verification of a protocol using simulations; in [PS95] we have investigated how a randomized algorithm can be verified mechanically once the high level proof is formulated.
Reference: [She87] <author> G.S. Shedler. </author> <title> Regeneration and Networks of Queues. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Moreover, they give an algorithm for computing the exact probability with which a sequential program satisfies a formula. Alur, Courcoubetis and Dill [ACD91a, ACD91b] develop a model checking algorithm for probabilistic real-time systems. Processes are modeled as a generalized semi-Markov process, which are studied in <ref> [Whi80, She87] </ref>. Essentially a process is a finite state transition system with timing constraints expressed by probability distributions on the delays.
Reference: [SL94] <author> R. Segala and N.A. Lynch. </author> <title> Probabilistic simulations for probabilistic processes. </title> <booktitle> In Jonsson and Parrow [JP94], </booktitle> <pages> pages 481-496. </pages>
Reference-contexts: We do not use Condition 4 to prove any of the results that we present in this thesis; however, this condition is necessary to prove the results that Segala and Lynch present in <ref> [SL94] </ref>. <p> This fact was first observed by Segala and Lynch <ref> [SL94] </ref> and can be proved easily using the results about deterministic and randomized schedulers that we proved in Chapter 5. The weak probabilistic relations were introduced first by Segala and Lynch [SL94]. No simulation relations abstracting from internal computation were defined before. <p> This fact was first observed by Segala and Lynch <ref> [SL94] </ref> and can be proved easily using the results about deterministic and randomized schedulers that we proved in Chapter 5. The weak probabilistic relations were introduced first by Segala and Lynch [SL94]. No simulation relations abstracting from internal computation were defined before. <p> The Probabilistic Computation Tree Logic of [HJ89, Han94] captures more the consequences of the interplay between probability and nondeterminism; in <ref> [SL94] </ref> PCTL is generalized also to probabilistic systems with internal actions (WPCTL). However, there are still properties that are useful and do not seem to be expressible in WPCTL.
Reference: [SL95] <author> R. Segala and N.A. Lynch. </author> <title> Probabilistic simulations for probabilistic processes. </title> <journal> Nordic Journal of Computing, </journal> <year> 1995. </year>
Reference-contexts: In <ref> [SL95] </ref> we have stated that weak probabilistic simulation preserve a large fragment of WPCTL and that weak probabilistic bisimulations preserve WPCTL. The results of [SL95] can be proved easily given the results of this thesis. However, more work in this direction is necessary. <p> In <ref> [SL95] </ref> we have stated that weak probabilistic simulation preserve a large fragment of WPCTL and that weak probabilistic bisimulations preserve WPCTL. The results of [SL95] can be proved easily given the results of this thesis. However, more work in this direction is necessary.
Reference: [SLL93] <author> J.F. Stgaard-Andersen, N.A. Lynch, and B.W. Lampson. </author> <title> Correctness of communication protocols. a case study. </title> <type> Technical Report MIT/LCS/TR-589, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> November </month> <year> 1993. </year> <month> 275 </month>
Reference-contexts: A labeled transition system is a state machine with labels associated with the transitions (the moves from one state to another state). Labeled transition systems have been used successfully for the modeling of ordinary distributed systems [Mil89, Jon91, LV91, LT87, GSSL94], and for their verification <ref> [WLL88, SLL93, SGG + 93, BPV94] </ref>; in this case the labels are used to model communication between several systems.
Reference: [SS90] <author> S. Smolka and B. Steffen. </author> <title> Priority as extremal probability. </title> <booktitle> In Baeten and Klop [BK90], </booktitle> <pages> pages 456-466. </pages>
Reference-contexts: Moreover, it is possible to define a special weight ! that expresses infinite frequency and can be used to express priorities. A similar idea to express priorities is used by Smolka and Steffen in <ref> [SS90] </ref>, where the stratified semantics of PCCS is extended with 0-probability transitions. Baeten, Bergstra and Smolka [BBS92] define an algebra, prACP I , which is an extension of ACP [BW90] with generative probabilities.
Reference: [Tof90] <author> C. Tofts. </author> <title> A synchronous calculus of relative frequencies. </title> <note> In Baeten and Klop [BK90]. </note>
Reference-contexts: The results of van Glabbeek et al. [GSST90], however, are based on the fact that parallel composition is synchronous. Tofts <ref> [Tof90] </ref> introduces a weighted synchronous calculus whose operational semantics resem 25 bles the stratified model. The main difference is that the weights associated with the transitions are not probabilities, but rather frequencies , and thus their sums are not required to be 1.
Reference: [Var85] <author> M.Y. Vardi. </author> <title> Automatic verification of probabilistic concurrent finite-state programs. </title> <booktitle> In Proceedings of 26th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 327-338, </pages> <address> Portland, OR, </address> <year> 1985. </year>
Reference-contexts: Finally, Jonsson and Larsen present a complete method for verifying containment between specifications. 2.3.2 Alternating Models Hansson and Jonsson [HJ89, HJ90] develop a probabilistic process algebra based on an alternating model . The model of Hansson and Jonsson, which is derived from the Concurrent Markov Chains of Vardi <ref> [Var85] </ref>, is a model in which there are two kinds of states: probabilistic states, whose outgoing transitions are unlabeled and lead to nondeterministic states, and nondeterministic states , whose outgoing transitions are labeled and lead to probabilistic states. <p> A new notion of weak probabilistic precondition is introduced that, together with the extreme fairness of Pnueli, generalizes weakest preconditions. Finally, based on the work of Huart et al. [HSP83], Rao argues that his new logic is complete for finite state programs. 2.5.2 Qualitative Method: Model Checking Vardi <ref> [Var85] </ref> presents a method for deciding whether a probabilistic concurrent finite state program satisfies a linear temporal logic specification, where satisfaction means that a formula is satisfied with probability 1 whenever the scheduler is fair.
Reference: [VL92] <author> F.W. Vaandrager and N.A. Lynch. </author> <title> Action transducers and timed automata. </title> <booktitle> In Cleaveland [Cle92], </booktitle> <pages> pages 436-455. </pages>
Reference-contexts: Thus, patient (M ) is like M except that an arbitrary amount of time can elapse between two discrete transitions. It is immediate to verify that patient (M ) satisfies axioms A1 and A2. The patient construction was first defined for ordinary automata in <ref> [VL92] </ref>. Example 9.2.2 (Simple restrictions on time passage) The patient construction does not specify any limitations to the way time can elapse. Sometimes we may want to specify upper and lower bounds to the time it takes for some transition to take place.
Reference: [VW86] <author> M.Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proceedings Symposium on Logic in Computer Science, </booktitle> <pages> pages 332-344. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1986. </year>
Reference-contexts: The model checking algorithm of Vardi works in time polynomial in the size of the program and doubly exponential in the size of the specification. By considering a slightly restricted logic, Vardi and Wolper <ref> [VW86] </ref> reduce the complexity of the model checking algorithm to only one exponent in the size of the formula. Courcoubetis and Yannakakis [CY88, CY90] investigate the complexity of model checking linear time propositional temporal logic of sequential and concurrent probabilistic processes.
Reference: [Whi80] <author> W. Whitt. </author> <title> Continuity of generalized semi-markov processes. </title> <journal> Mathematics of Operations Research, </journal> <volume> 5, </volume> <year> 1980. </year>
Reference-contexts: Moreover, they give an algorithm for computing the exact probability with which a sequential program satisfies a formula. Alur, Courcoubetis and Dill [ACD91a, ACD91b] develop a model checking algorithm for probabilistic real-time systems. Processes are modeled as a generalized semi-Markov process, which are studied in <ref> [Whi80, She87] </ref>. Essentially a process is a finite state transition system with timing constraints expressed by probability distributions on the delays.
Reference: [WLL88] <author> J.L. Welch, L. Lamport, and N.A. Lynch. </author> <title> A lattice-structured proof technique applied to a minimum spanning tree algorithm. </title> <type> Technical Report MIT/LCS/TM-361, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: A labeled transition system is a state machine with labels associated with the transitions (the moves from one state to another state). Labeled transition systems have been used successfully for the modeling of ordinary distributed systems [Mil89, Jon91, LV91, LT87, GSSL94], and for their verification <ref> [WLL88, SLL93, SGG + 93, BPV94] </ref>; in this case the labels are used to model communication between several systems.
Reference: [WSS94] <author> S.H. Wu, S. Smolka, </author> <title> and E.W. Stark. Composition and behaviors of probabilistic I/O automata. </title> <note> In Jonsson and Parrow [JP94]. </note>
Reference-contexts: The authors also provide a sound and complete axiomatization of probabilistic bisimulation. Wu, Smolka and Stark <ref> [WSS94] </ref> augment the I/O automaton model of Lynch and Tuttle [LT87] with probability and they study a compositional behavioral semantics which is also shown to be fully abstract with respect to probabilistic testing. A test is a probabilistic I/O automaton with a success action w. <p> Section 13.2.2). An observation along this line appears in <ref> [WSS94] </ref>. 4.4 Other Useful Operators There are two other operators on probabilistic automata that should be mentioned, since they are used in general on ordinary automata. In this section we provide a short description of those operators. <p> Figure 13-1 gives an example of synchronization between a transition with three output actions a; b; c and two transitions of an I/O automaton with just two input actions a; b. A similar observation was made also by Wu, Stark and Smolka in <ref> [WSS94] </ref>. A restricted timed model with I/O distinction is introduced by Merrit, Modugno and Tuttle [MMT91]. In particular timing constraints can be described only by giving upper and lower bounds to the time it takes for a process to perform the next transition whenever it is ready to do so.
Reference: [YCDS94] <author> S. Yuen, R. Cleaveland, Z. Dayar, and S. Smolka. </author> <title> Fully abstract characterizations of testing preorders for probabilistic processes. </title> <note> In Jonsson and Parrow [JP94]. </note>
Reference-contexts: An alternative characterization of the testing preorder of Cleaveland et al. [CSZ92] is provided by Yuen, Cleaveland, Dayar and Smolka <ref> [YCDS94] </ref>. A process is represented as a mapping from probabilistic traces to [0; 1], where a probabilistic trace is an alternating sequence of actions and probability distributions over actions. <p> Possibly, a related theory of testing in the style of [DH84] should be defined. It is very likely that the new testing preorders will be similar to those of Yi and Larsen [YL92]. Other theories of testing for probabilistic automata are studied in <ref> [Chr90b, Chr90a, CSZ92, YCDS94] </ref> and are explained in Section 2.2. 13.2.6 Liveness in Probabilistic Automata In the extension of the notion of an execution of an automaton we have obtained a parallelism between the theory of ordinary automata and the theory of probabilistic automata.
Reference: [YL92] <author> W. Yi and K.G. Larsen. </author> <title> Testing probabilistic and nondeterministic processes. In Protocol Specification, </title> <booktitle> Testing and Verification XII, </booktitle> <pages> pages 47-61, </pages> <year> 1992. </year>
Reference-contexts: Linda Christoff also defines three linear-time temporal logics that characterize her three semantics and provides efficient model checking algorithms for the recursion-free version of the logics. Testing preorders that are more in the style of De Nicola and Hennessy [DH84] are presented by Yi and Larsen in <ref> [YL92] </ref>, where they define a process algebra with all the operators of CCS plus a binary probabilistic choice operator parameterized by a probability p. Thus, the calculus of Yi and Larsen allows for nondeterminism. A test is a process of their calculus with an additional label w. <p> Possibly, a related theory of testing in the style of [DH84] should be defined. It is very likely that the new testing preorders will be similar to those of Yi and Larsen <ref> [YL92] </ref>.

References-found: 106

