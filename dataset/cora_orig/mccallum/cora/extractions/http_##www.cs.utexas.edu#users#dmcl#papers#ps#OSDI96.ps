URL: http://www.cs.utexas.edu/users/dmcl/papers/ps/OSDI96.ps
Refering-URL: http://www.cs.utexas.edu/users/dmcl/allpapers.html
Root-URL: 
Email: E-mail: fpawang,xguo,ving@cs.utexas.edu,  
Phone: Telephone: (512) 471-9732, Fax: (512) 471-8885  
Title: A Hierarchical CPU Scheduler for Multimedia Operating Systems  
Author: Pawan Goyal, Xingang Guo, and Harrick M. Vin 
Web: URL: http://www.cs.utexas.edu/users/dmcl  
Address: Taylor Hall 2.124, Austin, Texas 78712-1188  
Affiliation: Distributed Multimedia Computing Laboratory Department of Computer Sciences, University of Texas at Austin  
Abstract: The need for supporting variety of hard and soft real-time, as well as best effort applications in a multimedia computing environment requires an operating system framework that: (1) enables different schedulers to be employed for different application classes, and (2) provides protection between the various classes of applications. We argue that these objectives can be achieved by hierarchical partitioning of CPU bandwidth, in which an operating system partitions the CPU bandwidth among various application classes, and each application class, in turn, partitions its allocation (potentially using a different scheduling algorithm) among its sub-classes or applications. We present Start-time Fair Queuing (SFQ) algorithm, which enables such hierarchical partitioning. We have implemented a hierarchical scheduler in Solaris 2.4. We describe our implementation, and demonstrate its suitability for multimedia operating systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. P. Anderson. </author> <title> Metascheduling for Continuous Media. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(3) </volume> <pages> 266-252, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Hence, the requirements of hard and soft real-time applications can not be met in this framework. In contrast, our framework achieves hierarchical partitioning through a theoretically sound hierarchical scheduler. Several other efforts have investigated scheduling techniques for multimedia systems <ref> [1, 5, 8, 13] </ref>. These scheduling algorithms are complementary to our hierarchical scheduler and can be employed as leaf class scheduler in our framework.
Reference: [2] <author> J. Davin and A. Heybey. </author> <title> A Simulation Study of Fair Queueing and Policy Enforcement. </title> <journal> Computer Communication Review, </journal> <volume> 20(5) </volume> <pages> 23-29, </pages> <month> Octo-ber </month> <year> 1990. </year>
Reference-contexts: Furthermore, it is not known to have any better properties than SFQ. Self Clocked Fair Queuing (SCFQ), originally proposed in <ref> [2] </ref> and later analyzed in [4], was designed to reduce the computational complexity of fair scheduling algorithms like WFQ. It achieves efficiency over WFQ by approximating v (t) with the finish tag of the quantum in service at time t.
Reference: [3] <author> A. Demers, S. Keshav, and S. Shenker. </author> <title> Analysis and Simulation of a Fair Queueing Algorithm. </title> <booktitle> In Proceedings of ACM SIGCOMM, </booktitle> <pages> pages 1-12, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Most of these algorithms have been proposed for fair allocation of network bandwidth; we have modified their presentation appropriately for CPU scheduling. The earliest known fair scheduling algorithm is Weighted Fair Queuing (WFQ) <ref> [3] </ref>. WFQ was designed to emulate a hypothetical weighted round robin server in which the service received by each thread in a round is infinitesimal and proportional to the weight of the thread.
Reference: [4] <author> S.J. Golestani. </author> <title> A Self-Clocked Fair Queueing Scheme for High Speed Applications. </title> <booktitle> In Proceedings of INFOCOM'94, </booktitle> <year> 1994. </year>
Reference-contexts: It has been shown in <ref> [4] </ref> that if a scheduling algorithm schedules threads in terms of quantums and guarantees that fi fi W f (t 1 ;t 2 ) r m fi fi H (f; m) for all inter vals, then H (f; m) 1 2 ( f + m ). <p> Though WFQ is known to have bounded fairness, it is not known if the modified algorithm retains its fairness properties. * WFQ requires the computation of v (t), which, in turn, requires simulation of the hypothetical server. This simulation is known to be computationally expensive <ref> [4] </ref>. In contrast, SFQ computes the start and the finish tags efficiently. * The unfairness of WFQ, as derived in [16], is sig nificantly higher than SFQ. * WFQ provides high delay to low throughput appli cations. <p> Furthermore, it is not known to have any better properties than SFQ. Self Clocked Fair Queuing (SCFQ), originally proposed in [2] and later analyzed in <ref> [4] </ref>, was designed to reduce the computational complexity of fair scheduling algorithms like WFQ. It achieves efficiency over WFQ by approximating v (t) with the finish tag of the quantum in service at time t.
Reference: [5] <author> R. Govindan and D. P. Anderson. </author> <title> Scheduling and IPC Mechanisms for Continuous Media. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 68-80, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Hence, the requirements of hard and soft real-time applications can not be met in this framework. In contrast, our framework achieves hierarchical partitioning through a theoretically sound hierarchical scheduler. Several other efforts have investigated scheduling techniques for multimedia systems <ref> [1, 5, 8, 13] </ref>. These scheduling algorithms are complementary to our hierarchical scheduler and can be employed as leaf class scheduler in our framework.
Reference: [6] <author> P. Goyal, H. M. Vin, and H. Cheng. </author> <title> Start-time Fair Queuing: A Scheduling Algorithm for Integrated Services Packet Switching Networks. </title> <booktitle> In Proceedings of ACM SIGCOMM'96, </booktitle> <pages> pages 157-168, </pages> <month> August </month> <year> 1996. </year>
Reference-contexts: To be feasible in general purpose operating systems, the scheduling algorithm should be computationally efficient. Recently, we have developed a packet scheduling algorithm, referred to as Start-time Fair Queuing (SFQ), which achieves fair allocation of network bandwidth <ref> [6] </ref>. In the next section, we present the algorithm and demonstrate that it meets the above requirements, and hence, is suitable for CPU scheduling in multimedia operating systems. 3 Start-time Fair Queuing Start-time Fair Queuing (SFQ) is a resource allocation algorithm that can be used for achieving fair CPU allocation. <p> SFQ achieves fair allocation of CPU regardless of variation in available processing bandwidth and hence meets the key requirement of a scheduling algorithm for hierarchical partitioning. Specifically, in <ref> [6] </ref>, we have shown that regardless of fluctuations in available processor bandwidth, SFQ guarantees that in any interval [t 1 ; t 2 ] in which two threads f and m are eligible for being scheduled, the following inequality holds: fi fi W f (t 1 ; t 2 ) r <p> Let Q be the set of threads served by CPU and let P n2Q r n C where C is the capacity of the CPU. Then, SFQ provides the following throughput and delay guarantees <ref> [6] </ref>: Throughput Guarantee: If the CPU is an FC server with parameters (C; ffi (C)), then the throughput received by a thread f with weight r f is also FC with parameters: P n + r f C f (6) If, on the other hand, the CPU is an EBF server <p> WFQ then schedules quantums in the increasing order of their finish tags. WFQ has several drawbacks for scheduling a CPU: * As demonstrated in <ref> [6] </ref>, WFQ does not provide fairness when the processor bandwidth fluctuates over time. <p> Furthermore, although it has the same fairness and implementation complexity as SFQ, it provides sig nificantly larger delay guarantee than SFQ. Specifically, it increases the maximum delay of quantum q j l j r f <ref> [6] </ref>. In the OS context, a randomized fair algorithm, termed lottery scheduling, was proposed in [19]. Due to its randomized nature, lottery scheduling achieved fairness only over large time-intervals. This limitation was later addressed by stride scheduling algorithm [18].
Reference: [7] <author> A. Greenberg and N. </author> <title> Madras. How Fair is Fair Queuing. </title> <journal> The Journal of ACM, </journal> <volume> 39(3) </volume> <pages> 568-598, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Since this condition is expected to hold for low throughput applications, we conclude that SFQ provides lower delay to low throughput applications. Since interactive applications are low throughput in nature, this feature of SFQ is highly desirable for CPU scheduling. Fair Queuing based on Start-time (FQS) was proposed in <ref> [7] </ref> to make WFQ suitable for CPU scheduling when quantum length may not be known a priori. It computes the start tag and the finish tag of a quantum exactly as in WFQ.
Reference: [8] <author> K. Jeffay, D. L. Stone, and F. D. Smith. </author> <title> Kernel Support for Live Digital Audio and Video. </title> <journal> Computer Communications, </journal> <volume> 15 </volume> <pages> 388-395, </pages> <month> July/August </month> <year> 1992. </year>
Reference-contexts: Hence, the requirements of hard and soft real-time applications can not be met in this framework. In contrast, our framework achieves hierarchical partitioning through a theoretically sound hierarchical scheduler. Several other efforts have investigated scheduling techniques for multimedia systems <ref> [1, 5, 8, 13] </ref>. These scheduling algorithms are complementary to our hierarchical scheduler and can be employed as leaf class scheduler in our framework.
Reference: [9] <author> K. Jeffay and D.L. Stone. </author> <title> Accounting for Interrupt Handling Costs in Dynamic Priority Task Systems. </title> <booktitle> In Proceedings of 14th IEEE Real-Time Systems Symposium Raleigh-Durham, NC, </booktitle> <pages> pages 212-221, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: To support hard and soft real-time application classes, the scheduling algorithm should provide bounds on minimum throughput and maximum delay observed by nodes. Furthermore, for the bounds to be useful, they should hold in realistic computing environments in which interrupts may be processed at the highest priority <ref> [9] </ref>. 4. To be feasible in general purpose operating systems, the scheduling algorithm should be computationally efficient. Recently, we have developed a packet scheduling algorithm, referred to as Start-time Fair Queuing (SFQ), which achieves fair allocation of network bandwidth [6].
Reference: [10] <author> M.B. Jones, P. Leach, R. Draves, and III J. Bar-rera. </author> <title> Support for User-Centric Modular Real-Time Resource Management in Rialto Oper ating System. </title> <booktitle> In Proceedings of NOSSDAV'95, </booktitle> <address> Durham, New Hampshire, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: We will formalize this notion in Section 3. also facilitates the development of a QoS manager that allocates resources as per the requirements of applications <ref> [10] </ref>. To illustrate, if an application requests hard (soft) real-time service, then the QoS manager can use a deterministic (statistical) admission control algorithm which utilizes the capacity allocated to hard (soft) real-time classes to determine if the request can be satisfied, and if so, assign it to the appropriate partition. <p> Such a transfer will ensure that the blocking thread will have a weight (and hence, the CPU allocation) that is at least as large as the weight of the blocked thread. We envision that our scheduling infrastructure would be used by a QoS manager <ref> [10] </ref> in a multimedia system (see Figure 4).
Reference: [11] <author> K. Lee. </author> <title> Performance Bounds in Communication Networks With Variable-Rate Links. </title> <booktitle> In Proceedings of ACM SIGCOMM'95, </booktitle> <pages> pages 126-136, </pages> <year> 1995. </year>
Reference-contexts: To derive these bounds, however, the variation in the CPU bandwidth has to be quantified. If the maximum rate of occurrence of interrupts and the CPU bandwidth used by the interrupts is known, the effective CPU bandwidth can be modeled as a Fluctuation Constrained (FC) server <ref> [11] </ref>. A FC server has two parameters; average rate C (instructions/s) and burstiness ffi (C) (instructions). Intuitively, in any interval during a busy period, an FC server does at most ffi (C) less work than an equivalent constant rate server. <p> However, if distributions of the computation time requirements for processing interrupts are known, then CPU is better modeled as an Exponentially Bounded Fluctuation (EBF) server <ref> [11] </ref>. An EBF server is a stochastic relaxation of FC server. Intuitively, the probability of work done by an EBF server deviating from the average rate by more than fl, decreases exponentially with fl.
Reference: [12] <author> C.L. Liu and J.W. Layland. </author> <title> Scheduling Algorithms for Multiprocessing in a Hard-Real Time Environment. </title> <journal> JACM, </journal> <volume> 20 </volume> <pages> 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: Conventional schedulers such as the Earliest Deadline First (EDF) and the Rate Monotonic Algorithm (RMA) are suitable for such applications <ref> [12] </ref>. * Soft real-time applications: These applications require an operating system to statistically guarantee QoS parameters such as maximum delay and throughput.
Reference: [13] <author> C. W. Mercer, S. Savage, and H. Tokuda. </author> <title> Processor Capacity Reserves: Operating System Support for Multimedia Applications. </title> <booktitle> In Proceedings of the IEEE ICMCS'94, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Techniques for avoiding priority inversion among threads belonging to the same leaf class, on the other hand, depend on the leaf class scheduler. For example, if the leaf scheduler uses static priority Rate Monotonic algorithm, then standard priority inheritance techniques can be employed <ref> [13, 14] </ref>. Similarly, when the leaf scheduler is SFQ, priority inversion can be avoided by transferring the weight of the blocked thread to the thread that is blocking it. <p> Hence, the requirements of hard and soft real-time applications can not be met in this framework. In contrast, our framework achieves hierarchical partitioning through a theoretically sound hierarchical scheduler. Several other efforts have investigated scheduling techniques for multimedia systems <ref> [1, 5, 8, 13] </ref>. These scheduling algorithms are complementary to our hierarchical scheduler and can be employed as leaf class scheduler in our framework.
Reference: [14] <author> T. Nakajima, T. Kitayama, H. Arakawa, and H. Tokuda. </author> <title> Integrated Management of Priority Inversion in Real-Time Mach. </title> <booktitle> In Proceedings of the 14th IEEE Real-Time Systems Symp., </booktitle> <pages> pages 120-130, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Techniques for avoiding priority inversion among threads belonging to the same leaf class, on the other hand, depend on the leaf class scheduler. For example, if the leaf scheduler uses static priority Rate Monotonic algorithm, then standard priority inheritance techniques can be employed <ref> [13, 14] </ref>. Similarly, when the leaf scheduler is SFQ, priority inversion can be avoided by transferring the weight of the blocked thread to the thread that is blocking it.
Reference: [15] <author> J. Nieh, J. Hanko, J. Northcutt, and G. Wall. </author> <title> SVR4UNIX Scheduler Unacceptable for Multimedia Applications. </title> <booktitle> In Proceedings of 4th International Workshop on Network and Operating System Support for Digital Audio and Video, </booktitle> <pages> pages 41-53, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Furthermore, no other known algorithm that simultaneously achieves predictable allocation and protection has a lower complexity. Although static priority algorithms have lower complexity, they provide no protection, and hence, have been found to be unsatisfactory for multimedia operating systems <ref> [15] </ref>. Recall from Section 1 that a scheduling algorithm suitable for video applications should: (1) provide QoS guarantees even in presence of overload, and (2) not require computation requirements to be known precisely. <p> In contrast, all the threads in SFQ received the same throughput in conformance with the theoretical predictions. In <ref> [15] </ref>, it has been demonstrated that when a multimedia application is run as a real-time thread in the SVR4 scheduler, the whole system may become unusable.
Reference: [16] <author> D. Stiliadis and A. Varma. </author> <title> Design and Analysis of Frame-based Fair Queueing: A New Traffic Scheduling Algorithm for Packet Switched Networks. </title> <booktitle> In Proceedings of SIGMETRICS'96, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: This simulation is known to be computationally expensive [4]. In contrast, SFQ computes the start and the finish tags efficiently. * The unfairness of WFQ, as derived in <ref> [16] </ref>, is sig nificantly higher than SFQ. * WFQ provides high delay to low throughput appli cations.
Reference: [17] <author> I. Stoica, H. Abdel-Wahab, and K. Jeffay. </author> <title> A Proportional Share Resource Allocation Algorithm for Real-Time, Time-Shared Systems. </title> <booktitle> In Proceedings of Real Time Systems Symposium (to appear), </booktitle> <month> December </month> <year> 1996. </year>
Reference-contexts: The stride scheduling algorithm is a variant of WFQ and, consequently, has all the drawbacks of WFQ. Furthermore, no theoretical properties of the stride scheduling algorithm are known. Recently, a proportionate share resource allocation algorithm, referred to as Earliest Eligible Virtual Deadline First (EEVDF), has been proposed <ref> [17] </ref>. Hierarchical partitioning of resource allocation was also proposed in [19] using the abstraction of tickets and currencies. In that framework, a thread is allocated tickets in some currency and the currency, in turn, is funded in terms of tickets of some other currency.
Reference: [18] <author> C. Waldspurger and W. Weihl. </author> <title> Stride Scheduling: Deterministic Proportional-share Resource Management. </title> <type> Technical Report TM-528, </type> <institution> MIT, Laboratory for Computer Science, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: In the OS context, a randomized fair algorithm, termed lottery scheduling, was proposed in [19]. Due to its randomized nature, lottery scheduling achieved fairness only over large time-intervals. This limitation was later addressed by stride scheduling algorithm <ref> [18] </ref>. The stride scheduling algorithm is a variant of WFQ and, consequently, has all the drawbacks of WFQ. Furthermore, no theoretical properties of the stride scheduling algorithm are known. Recently, a proportionate share resource allocation algorithm, referred to as Earliest Eligible Virtual Deadline First (EEVDF), has been proposed [17].
Reference: [19] <author> C. A. Waldspurger and W. E. Weihl. </author> <title> Lottery Scheduling: Flexible Proportional-share Resource Management. </title> <booktitle> In Proceedings of sym-posim on Operating System Design and Implementation, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: Specifically, it increases the maximum delay of quantum q j l j r f [6]. In the OS context, a randomized fair algorithm, termed lottery scheduling, was proposed in <ref> [19] </ref>. Due to its randomized nature, lottery scheduling achieved fairness only over large time-intervals. This limitation was later addressed by stride scheduling algorithm [18]. The stride scheduling algorithm is a variant of WFQ and, consequently, has all the drawbacks of WFQ. <p> Furthermore, no theoretical properties of the stride scheduling algorithm are known. Recently, a proportionate share resource allocation algorithm, referred to as Earliest Eligible Virtual Deadline First (EEVDF), has been proposed [17]. Hierarchical partitioning of resource allocation was also proposed in <ref> [19] </ref> using the abstraction of tickets and currencies. In that framework, a thread is allocated tickets in some currency and the currency, in turn, is funded in terms of tickets of some other currency. <p> This achieves hierarchical partitioning since if a thread becomes inactive, the value of the tickets of the threads that are funded by the same currency increases. This specification of hierarchical partitioning is similar to our scheduling structure. However, the key differences between our framework and the approach of <ref> [19] </ref> are as follows. First, our framework permits different scheduling algorithms to be employed for different classes of applications, whereas the framework of [19] does not. Second, hierarchical partitioning is achieved in [19] by re-computation of ticket values of every thread that are funded in the same currency or some ancestor <p> This specification of hierarchical partitioning is similar to our scheduling structure. However, the key differences between our framework and the approach of <ref> [19] </ref> are as follows. First, our framework permits different scheduling algorithms to be employed for different classes of applications, whereas the framework of [19] does not. Second, hierarchical partitioning is achieved in [19] by re-computation of ticket values of every thread that are funded in the same currency or some ancestor of the currency every time a thread gets blocked or exits. <p> However, the key differences between our framework and the approach of <ref> [19] </ref> are as follows. First, our framework permits different scheduling algorithms to be employed for different classes of applications, whereas the framework of [19] does not. Second, hierarchical partitioning is achieved in [19] by re-computation of ticket values of every thread that are funded in the same currency or some ancestor of the currency every time a thread gets blocked or exits. This approach not only incurs additional overhead of computing ticket values, but also does not provide any guarantees.
References-found: 19

