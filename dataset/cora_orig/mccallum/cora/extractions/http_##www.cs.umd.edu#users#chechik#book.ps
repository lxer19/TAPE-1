URL: http://www.cs.umd.edu/users/chechik/book.ps
Refering-URL: http://www.cs.umd.edu/users/chechik/research.html
Root-URL: 
Title: Using Model Checking to Analyze Requirements and Designs  
Author: Joanne Atlee Marsha Chechik John Gannon 
Abstract: Precise notations have been developed to specify unambiguous requirements, and ensure that all cases of appropriate system behavior are considered and documented. Using one such notation, we have developed techniques to automatically analyze software artifacts at early stages of the software development life cycle. We use model checking as our verification technique because it can be fully automated and can check properties of large systems. This paper describes model checking and summarizes our efforts to use it to analyze software requirements and designs. We prove that requirements model system safety properties and that designs model consistency properties derived from requirements by creating abstractions of these software artifacts and using model checking to determine if the abstractions are models of the properties. We present results from a case study in which we analyzed the require ments and design of a small but realistic system.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Allen and D. Garlan. </author> <title> "Formalizing Architectural Connection". </title> <booktitle> In Proceedings of the Sizteenth International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Model checking has been successfully applied to verifying and debugging hardware designs (e.g., [8, 7, 13]). More recently it has been used to analyze software artifacts. Model checking has been used to detect design flaws in software architecture designs <ref> [1] </ref> and Z specifications [23], and to prove properties of cache coherence protocols [30] and concurrent Ada programs [9]. The key to success in these endeavors is creating an appropriate abstraction of a system so that results obtained from analyzing the abstraction also apply to the system.
Reference: [2] <author> T. Alspaugh, S. Faulk, K. Britton, R. Parker, D. Parnas, and J. Shore. </author> <title> "Software Requirements for the A-7E Aircraft". </title> <type> Technical report, </type> <institution> Naval Research Laboratory, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Several formal requirements notations (e.g., the Software Cost Reduction (SCR) notation <ref> [2, 20, 22] </ref>, the Requirements State Machine Language [24], and Statecharts [18]) have been used to specify the requirements of large, real-world avionics applications (the A-7E aircraft, the FAA's Traffic Collision and Avoidance System, and the Lavi fighter's avionics system, respectively). <p> We present our conclusions in Section 7. 2 SCR Requirements The SCR requirements notation was developed by a research group at the Naval Research Laboratory as part of the Software Cost Reduction project <ref> [2, 22] </ref>. A complete SCR requirements specification contains behavioral, functional, precision, and timing requirements of a software system as well as assumptions about the environment in which the system will operate. <p> Formally, conditioned event @T (SwitchOn) when [PumpFail] occurs at time t if and only if primitive event @T (SwitchOn) occurs at time t and condition PumpFail is true for some non-zero interval of time leading up to and including time t <ref> [2] </ref>. SwitchOn is called the triggering event and PumpFail is called the event's when condition. A state of the monitored environment is defined by the current values of the conditions, and the state space is the set of possible combinations of values of conditions. <p> However, when conditions that are related to the triggering event may or may not be changing value along with the triggering event. We chose to model the older conditioned-event semantics <ref> [2] </ref> because we found it easier to write a correct SCR specification given these semantics. <p> These types of system goals frequently appear in requirements documents, and during our case studies we did not need to verify any other types of properties. Requirements specifications of realistic size and complexity (such as <ref> [2] </ref>), however, contain global properties which cannot be expressed using only these assertions.
Reference: [3] <author> J. Atlee. </author> <title> "Automated Analysis of Software Requirements". </title> <type> PhD thesis, </type> <institution> University of Mary-land, College Park, Maryland, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: As such, assumptions are invariant constraints that must hold in all system states. The syntax and semantics of assumption specifications are described in <ref> [3] </ref>; for the purposes of this paper, symbol "j" denotes exclusive-or, " &gt;" denotes implication, " &gt;>" denotes strict implication, and "&lt;" denotes an ordering on the lengths of time that conditions are true 1 .
Reference: [4] <author> J.M. Atlee and J. Gannon. </author> <title> "State-Based Model Checking of Event-Driven System Requirements". </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 22-40, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Our research has focused on developing techniques that use formal methods to enable automatic analysis of program artifacts at early stages of the software development life cycle <ref> [4, 6, 28, 5, 10, 11] </ref>. In this paper, we summarize our work to analyze program requirements and designs. We use model checking [14] because it can be fully automated and can check properties of large systems.
Reference: [5] <author> Joanne M. Atlee and Michael A. Buckley. </author> <title> "A Logic-Model Semantics for SCR Software Requirements". </title> <booktitle> In Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <month> January </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: Our research has focused on developing techniques that use formal methods to enable automatic analysis of program artifacts at early stages of the software development life cycle <ref> [4, 6, 28, 5, 10, 11] </ref>. In this paper, we summarize our work to analyze program requirements and designs. We use model checking [14] because it can be fully automated and can check properties of large systems.
Reference: [6] <author> Joanne M. Atlee and John Gannon. </author> <title> "Analyzing Timing Requirements". </title> <booktitle> In Proceedings of the 1993 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 117-127, </pages> <address> Cambridge, MA, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Our research has focused on developing techniques that use formal methods to enable automatic analysis of program artifacts at early stages of the software development life cycle <ref> [4, 6, 28, 5, 10, 11] </ref>. In this paper, we summarize our work to analyze program requirements and designs. We use model checking [14] because it can be fully automated and can check properties of large systems.
Reference: [7] <author> G. Barrett. </author> <title> "Model Checking in Practice: The t9000 Virtual Channel Processor". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 69-78, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Developers are more likely to understand a proof technique like model checking, which is based on search and which produces counter examples when proofs fail, than a technique based inductive theorem proving. Model checking has been successfully applied to verifying and debugging hardware designs (e.g., <ref> [8, 7, 13] </ref>). More recently it has been used to analyze software artifacts. Model checking has been used to detect design flaws in software architecture designs [1] and Z specifications [23], and to prove properties of cache coherence protocols [30] and concurrent Ada programs [9].
Reference: [8] <author> M. Browne. </author> <title> "Automatic Verification of Finite State Machines Using Temporal Logic". </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1989. </year>
Reference-contexts: Developers are more likely to understand a proof technique like model checking, which is based on search and which produces counter examples when proofs fail, than a technique based inductive theorem proving. Model checking has been successfully applied to verifying and debugging hardware designs (e.g., <ref> [8, 7, 13] </ref>). More recently it has been used to analyze software artifacts. Model checking has been used to detect design flaws in software architecture designs [1] and Z specifications [23], and to prove properties of cache coherence protocols [30] and concurrent Ada programs [9]. <p> We have developed automated techniques to translate SCR requirements into a logical model. We represent a system's safety assertions as logical formulas in a branching-time temporal logic, Computation Tree Logic [15] (CTL), and use existing CTL model checkers <ref> [8, 25] </ref> to check our models. Analyzing the safety properties of system's requirements, however, fails to tell us whether or not its implementation preserves these properties.
Reference: [9] <author> Tevfik Bultan, Jeffrey Fischer, and Richard Gerber. </author> <title> "Compositional Verification by Model Checking for Counter-Examples". </title> <booktitle> In Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <month> January </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: More recently it has been used to analyze software artifacts. Model checking has been used to detect design flaws in software architecture designs [1] and Z specifications [23], and to prove properties of cache coherence protocols [30] and concurrent Ada programs <ref> [9] </ref>. The key to success in these endeavors is creating an appropriate abstraction of a system so that results obtained from analyzing the abstraction also apply to the system.
Reference: [10] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Verification of Requirements Implementations". </title> <booktitle> In Proceedings of the 1994 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 1-14, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1994. </year> <month> 31 </month>
Reference-contexts: Our research has focused on developing techniques that use formal methods to enable automatic analysis of program artifacts at early stages of the software development life cycle <ref> [4, 6, 28, 5, 10, 11] </ref>. In this paper, we summarize our work to analyze program requirements and designs. We use model checking [14] because it can be fully automated and can check properties of large systems.
Reference: [11] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Analysis of Consistency Between Implementations and Requirements: A Case Study". </title> <booktitle> In Proceedings of 10th Annual Conference on Computer Assurance, </booktitle> <pages> pages 123-131, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Our research has focused on developing techniques that use formal methods to enable automatic analysis of program artifacts at early stages of the software development life cycle <ref> [4, 6, 28, 5, 10, 11] </ref>. In this paper, we summarize our work to analyze program requirements and designs. We use model checking [14] because it can be fully automated and can check properties of large systems.
Reference: [12] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Analysis of Consistency Between Requirements and Designs". </title> <type> Technical report CS-TR-3394.1, </type> <institution> Dept. of CS, University of Maryland, College Park, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: Requirements specifications of realistic size and complexity (such as [2]), however, contain global properties which cannot be expressed using only these assertions. Allowing the user to specify a richer set of properties is relatively easy, although not every CTL-expressible formula can be verified during our analysis (see <ref> [12] </ref>). 5.2 Design Language To create a design, programmers use a mixture of control-flow constructs, comments and annotations special statements which record mode transitions and changes to the values of controlled and monitored variables. These changes are local (rather than invariant) and therefore are relatively easy to specify. <p> We interpret annotations in the design to create a set-based approximation of attainable values for each requirements' variable [16, 17]. The details of building a DFG are given in <ref> [12] </ref>. <p> We check the formula only for predecessors of states labeled with Update annotations for F . In our example, both calculated events (I 1 and I 2 ) establish P 3 for node 9. We check all OLT properties in one traversal of FSM using the algorithm in <ref> [12] </ref>.
Reference: [13] <author> Edmind M. Clarke, Orna Grumberg, and David E. </author> <title> Long. "Model Checking and Abstraction". </title> <booktitle> In Proceedings of the Ninth Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Developers are more likely to understand a proof technique like model checking, which is based on search and which produces counter examples when proofs fail, than a technique based inductive theorem proving. Model checking has been successfully applied to verifying and debugging hardware designs (e.g., <ref> [8, 7, 13] </ref>). More recently it has been used to analyze software artifacts. Model checking has been used to detect design flaws in software architecture designs [1] and Z specifications [23], and to prove properties of cache coherence protocols [30] and concurrent Ada programs [9].
Reference: [14] <author> E.M. Clarke and E.A. Emerson. </author> <title> "Synthesis of synchronization skeletons for branching time temporal logic", </title> <booktitle> volume 131 of Lecture Nodes in Computer Science, chapter Logic of Programs: Workshop, </booktitle> <address> Yorktown Heights, NY, May 1981. </address> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: In this paper, we summarize our work to analyze program requirements and designs. We use model checking <ref> [14] </ref> because it can be fully automated and can check properties of large systems. Developers are more likely to understand a proof technique like model checking, which is based on search and which produces counter examples when proofs fail, than a technique based inductive theorem proving.
Reference: [15] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. "Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: We have developed automated techniques to translate SCR requirements into a logical model. We represent a system's safety assertions as logical formulas in a branching-time temporal logic, Computation Tree Logic <ref> [15] </ref> (CTL), and use existing CTL model checkers [8, 25] to check our models. Analyzing the safety properties of system's requirements, however, fails to tell us whether or not its implementation preserves these properties. <p> Computational tree logic (CTL) is a propositional branching time logic, whose operators permit explicit quantification over all possible futures <ref> [15] </ref>.
Reference: [16] <author> Patrick Cousot and Radhia Cousot. </author> <title> "Static Determination of Dynamic Properties of Programs". </title> <booktitle> In Proceedings of the "Colloque sur la Programmation", </booktitle> <month> April </month> <year> 1976. </year>
Reference-contexts: We interpret annotations in the design to create a set-based approximation of attainable values for each requirements' variable <ref> [16, 17] </ref>. The details of building a DFG are given in [12].
Reference: [17] <author> Patrick Cousot and Radhia Cousot. </author> <title> "Abstract Interpretation: A Unified Lattice Model For Static Analysis of Programs by Construction or Approximation of Fixpoints". </title> <booktitle> In Proceedings of the 4th POPL, </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, California, </address> <year> 1977. </year>
Reference-contexts: We interpret annotations in the design to create a set-based approximation of attainable values for each requirements' variable <ref> [16, 17] </ref>. The details of building a DFG are given in [12].
Reference: [18] <author> David Harel. "StateCharts: </author> <title> A Visual Formalism for Complex Systems". </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: Several formal requirements notations (e.g., the Software Cost Reduction (SCR) notation [2, 20, 22], the Requirements State Machine Language [24], and Statecharts <ref> [18] </ref>) have been used to specify the requirements of large, real-world avionics applications (the A-7E aircraft, the FAA's Traffic Collision and Avoidance System, and the Lavi fighter's avionics system, respectively). These requirements notations describe systems as sets of concurrently executing state machines which respond to events in their environments.
Reference: [19] <author> C. Heitmeyer. </author> <title> "Tools for Analyzing Requirements: A Formal Foundation", </title> <month> December </month> <year> 1994. </year> <note> Presented at the Fouth International SCR Workshop. </note>
Reference-contexts: Traditionally, implementations of reactive systems queue primitive events as their occurrences are detected; when a primitive event reaches the head of the queue, the system checks the values of other conditions to determine if a significant conditioned event (e.g., one that might activate a mode transition) has occurred <ref> [19] </ref>. An unconditional restriction on the occurrence of simultaneous events may violate environmental assumptions. Rather than incorporating a restriction on simultaneous events into the semantics of an SCR logic model, we express the restriction as an environmental assumption of the specification.
Reference: [20] <author> C. Heitmeyer and B. Labaw. </author> <title> "Consistency Checks for SCR-Style Requirements Specifications". </title> <type> Technical Report NRL Report 93-9586, </type> <institution> Naval Research Laboratory, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Several formal requirements notations (e.g., the Software Cost Reduction (SCR) notation <ref> [2, 20, 22] </ref>, the Requirements State Machine Language [24], and Statecharts [18]) have been used to specify the requirements of large, real-world avionics applications (the A-7E aircraft, the FAA's Traffic Collision and Avoidance System, and the Lavi fighter's avionics system, respectively).
Reference: [21] <author> C. Heitmeyer, B. Labaw, and D. Kiskis. </author> <title> "Consistency Checking of SCR-Style Requirements Specifications". </title> <booktitle> In Proceedings of RE'95 International Symposium of Requirements Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: According to the latest operational semantics of SCR, a when condition 10 must be satisfied immediately before the occurrence of a conditioned event, but its value at the time of the event is unknown <ref> [21] </ref>. Given the above restriction on the occurrence of simultaneous events, one can to infer the value of most when conditions: when conditions that are unrelated to the triggering event have the same value during the event as they had immediately before the event.
Reference: [22] <author> K. Heninger. </author> <title> "Specifying Software Requirements for Complex Systems: New Techniques and Their Applications". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):2-12, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: Several formal requirements notations (e.g., the Software Cost Reduction (SCR) notation <ref> [2, 20, 22] </ref>, the Requirements State Machine Language [24], and Statecharts [18]) have been used to specify the requirements of large, real-world avionics applications (the A-7E aircraft, the FAA's Traffic Collision and Avoidance System, and the Lavi fighter's avionics system, respectively). <p> We present our conclusions in Section 7. 2 SCR Requirements The SCR requirements notation was developed by a research group at the Naval Research Laboratory as part of the Software Cost Reduction project <ref> [2, 22] </ref>. A complete SCR requirements specification contains behavioral, functional, precision, and timing requirements of a software system as well as assumptions about the environment in which the system will operate.
Reference: [23] <author> Daniel Jackson and Craig A. Damon. </author> <title> "Elements of Style: Analyzing a Software Design Feature with a Counterexample Detector". </title> <booktitle> In Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <month> January </month> <year> 1996. </year> <note> To appear. 32 </note>
Reference-contexts: Model checking has been successfully applied to verifying and debugging hardware designs (e.g., [8, 7, 13]). More recently it has been used to analyze software artifacts. Model checking has been used to detect design flaws in software architecture designs [1] and Z specifications <ref> [23] </ref>, and to prove properties of cache coherence protocols [30] and concurrent Ada programs [9]. The key to success in these endeavors is creating an appropriate abstraction of a system so that results obtained from analyzing the abstraction also apply to the system.
Reference: [24] <author> N.G. Levenson, M.P.E. Heimdahl, H. Hildreth, and J.D. Reese. </author> <title> "Requirements Specification for Process-Control Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9) </volume> <pages> 684-707, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Several formal requirements notations (e.g., the Software Cost Reduction (SCR) notation [2, 20, 22], the Requirements State Machine Language <ref> [24] </ref>, and Statecharts [18]) have been used to specify the requirements of large, real-world avionics applications (the A-7E aircraft, the FAA's Traffic Collision and Avoidance System, and the Lavi fighter's avionics system, respectively).
Reference: [25] <author> K.L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic, </publisher> <year> 1993. </year>
Reference-contexts: We have developed automated techniques to translate SCR requirements into a logical model. We represent a system's safety assertions as logical formulas in a branching-time temporal logic, Computation Tree Logic [15] (CTL), and use existing CTL model checkers <ref> [8, 25] </ref> to check our models. Analyzing the safety properties of system's requirements, however, fails to tell us whether or not its implementation preserves these properties. <p> Automating model checking is quite easy, except that the entire state space of the model must be constructed before the fixed-point algorithms can be applied. Model checking can be performed symbolically by manipulating quantified boolean formulas without constructing a model's state space <ref> [25] </ref>. To perform symbolic model checking, sets of states and transition relations are represented by formulas, and set operations are defined in terms of formula manipulations. As before, a system state represents an interpretation (i.e., truth assignment) for a set of propositional variables V . <p> hold invariantly and constrain the specification's transition relation, each of the assumptions' representative formulas is conjoined with the formula representing the mode transition table. 4.4 System Goals and Model Checking Most of the SWLMS system's goals can be easily expressed as CTL formulas and proved using the SMV model checker <ref> [25] </ref>. The following formulas state properties that hold invariantly when the system is in a particular mode.
Reference: [26] <author> D. Parnas and J. Madey. </author> <title> "Functional Documentation for Computer Systems Engineering(Version 2)". </title> <type> Technical Report CRL Report 237, </type> <institution> McMaster University, Department of Electrical and Computer Engineering, </institution> <year> 1991. </year>
Reference-contexts: The machines' environment is abstracted as a set of monitored state variables and controlled state variables <ref> [26, 29] </ref>. Changes to monitored variables may cause the system to change its mode or to alter the values of its controlled variables. The input language of each machine is a set of conditioned events. <p> Similar to the N AT relation in Parnas's 4-variable model of system requirements <ref> [26] </ref>, an assumption specifies constraints on the values of conditions, imposed either by laws of nature or by other mode classes in the system. As such, assumptions are invariant constraints that must hold in all system states.
Reference: [27] <author> D.L. Parnas. </author> <title> "Some Theorems We Should Prove". </title> <booktitle> In Proceedings of 1993 International Conference on HOL Therem Proving and Its Applications, </booktitle> <address> Vancouver, BC, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Precise documentation of software requirements has several potential benefits <ref> [27] </ref>: designers know what they are to build; reviewers can check that customers' intentions are met; testers can formulate test cases independently from the system's implementation; and maintainers can use the original requirements to learn about the system before making their changes.
Reference: [28] <author> Tirumale Sreemani and Joanne M. Atlee. </author> <title> "Feasibility of Model Checking Software Requirements: A Case Study". </title> <type> Technical Report CS-95-48, </type> <institution> Department of Computer Science, University of Waterloo, </institution> <month> November </month> <year> 1995. </year>
Reference-contexts: Our research has focused on developing techniques that use formal methods to enable automatic analysis of program artifacts at early stages of the software development life cycle <ref> [4, 6, 28, 5, 10, 11] </ref>. In this paper, we summarize our work to analyze program requirements and designs. We use model checking [14] because it can be fully automated and can check properties of large systems.
Reference: [29] <author> A. J. van Schouwen. </author> <title> "The A-7 Requirements Model: Re-examination for Real-Time Systems and an Application to Monitoring Systems". </title> <type> Technical Report TR-90-276, </type> <institution> Queen's University, Kingston, </institution> <address> Ontario, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: for verifying designs: how to generate temporal logic properties from SCR tables, how build finite-state abstractions of designs, and how to model check the properties using a special-purpose model checker. 2 Section 6 describes a case study in which we analyzed the requirements and design of a Water-Level Monitoring System <ref> [29] </ref>. We present our conclusions in Section 7. 2 SCR Requirements The SCR requirements notation was developed by a research group at the Naval Research Laboratory as part of the Software Cost Reduction project [2, 22]. <p> The machines' environment is abstracted as a set of monitored state variables and controlled state variables <ref> [26, 29] </ref>. Changes to monitored variables may cause the system to change its mode or to alter the values of its controlled variables. The input language of each machine is a set of conditioned events. <p> The alternative invariant wmi (PumpFail,Error) holds for the model. 6 Case Study To demonstrate our analysis techniques on more realistic applications, we conducted a case study on a Water-Level Monitoring System (WLMS) which had been specified using SCR requirements and subsequently implemented <ref> [29] </ref>. Our usual analysis process starts by merging information from environmental assumptions into mode transition tables, and continues by trying to prove that the logic model derived from this combined information is a model of the system goals using model checking.
Reference: [30] <author> Jeannette Wing and Mandana Vaziri-Farahani. </author> <title> "Model Checking Software Systems: A Case Study". </title> <booktitle> In Proceedings of the 3rd Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 128-139, </pages> <month> October </month> <year> 1995. </year> <month> 33 </month>
Reference-contexts: More recently it has been used to analyze software artifacts. Model checking has been used to detect design flaws in software architecture designs [1] and Z specifications [23], and to prove properties of cache coherence protocols <ref> [30] </ref> and concurrent Ada programs [9]. The key to success in these endeavors is creating an appropriate abstraction of a system so that results obtained from analyzing the abstraction also apply to the system.
References-found: 30

