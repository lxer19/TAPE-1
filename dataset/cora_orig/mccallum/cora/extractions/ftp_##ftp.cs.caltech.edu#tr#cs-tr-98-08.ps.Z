URL: ftp://ftp.cs.caltech.edu/tr/cs-tr-98-08.ps.Z
Refering-URL: ftp://ftp.cs.caltech.edu/tr/INDEX.html
Root-URL: http://www.cs.caltech.edu
Title: CS-TR-98-08 The Specification of Dynamic Distributed Component Systems  
Author: Joseph R. Kiniry 
Degree: Thesis by  In Partial Fulfillment of the Requirements for the Degree of Master of Science  
Date: 1998 (Submitted May 29, 1998)  
Address: Pasadena, California  
Affiliation: California Institute of Technology  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Martin Adabi and Luca Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: CDL is a new specification language that incorporates ideas from several of the other specification models and languages previously mentioned (OCL, Z and VDM variants, Larch, UNITY, process algebras, and predicate calculus, in particular). CDL's core model and complementary theory is component-centric and based on object calculus <ref> [1] </ref>. CDL will be described in full detail as part of my PhD dissertation. It is not described here. 2.9 Examples A number of distributed systems have been built with the II. Several of them will be described in Chapter 5.
Reference: [2] <author> O. Agesen, L. Bak, C. Chambers, B.-W. Chang, U. Holzle, J. Maloney, R.B. Smith, D. Un-gar, and M. Wolczko. </author> <title> The self 3.0 programmer's reference manual. </title> <type> Technical report, </type> <institution> Sun Microsystems, </institution> <year> 1993. </year>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self <ref> [2, 167, 168] </ref>, Simula [12, 45], and Squeak [91].
Reference: [3] <author> Gul Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: What they do not help with (today) is any formal model- or system-correctness checking. That is the domain of the formal system specification languages. 2.2.2 Formal Component Specification Languages Some of the leading formal models and languages for component specification include the Actor model <ref> [4, 3, 58, 80] </ref>, Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL [25, 166], UNITY [30], VDM [97], and Z [90, 137, 152, 153, 178].
Reference: [4] <author> Gul Agha and Carl Hewitt. </author> <title> Research Directions in Object-Oriented Programming, chapter Actors: </title> <booktitle> A Conceptual Foundation for Concurrent Object-Oriented Programming, </booktitle> <pages> pages 49-74. </pages> <publisher> The MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: What they do not help with (today) is any formal model- or system-correctness checking. That is the domain of the formal system specification languages. 2.2.2 Formal Component Specification Languages Some of the leading formal models and languages for component specification include the Actor model <ref> [4, 3, 58, 80] </ref>, Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL [25, 166], UNITY [30], VDM [97], and Z [90, 137, 152, 153, 178].
Reference: [5] <institution> Agilis corporation web site. </institution> <note> Available as http://www.agiliscorp.com/, 1998. </note>
Reference-contexts: The newest version of OOCL (version 2.0), is a major method update with new features including the ability to model self-organizing, complex adaptive systems (CAS). For more information on the work underlying the OOCL method, see [83, 84, 146, 147, 161]. For a quick summary of OOCL, see <ref> [5, 160, 163] </ref>. OOCL introduces a number of new modeling constructs to help specify such dynamic system. These elements include: * Agent. An agent is an entity responsible for a set of tasks. * Organization. An organization is a group of agents working toward a common goal. * Constellation. <p> There are also level three and four knowledge and processes related to improving the team, division, or organization. Providing examples of each of the above diagrams and graphs would take up too much space for this body of work. We suggest <ref> [5, 163] </ref> for summaries and examples of all of the diagrams. OOCL also evolves and introduces new concepts to system modeling. The primary "evolved" traditional concepts at the heart of OOCL is the business object dictionary, an evolution of the data and class dictionaries of other methods.
Reference: [6] <author> Jonathan Aldrich, James Dooley, Scott Mandelsohn, and Adam Rifkin. </author> <title> Providing easier access to remote objects in distributed systems. </title> <booktitle> In Hawaii International Conference on System Sciences. IEEE Computer Society, </booktitle> <month> January </month> <year> 1998. </year>
Reference-contexts: See [138] for more information. * JEDI: A research framework for developing client-server systems. The JEDI system lets a developer build client-server systems without having to go through the process of stub/skeleton compilation. See <ref> [6] </ref> for more information. * SimulEdit: A peer-to-peer distributed editor. SimulEdit is an editor that lets users join and leave an editing session dynamically and is fault tolerant. See [164] for more information. * DALI: A distributed artificial life simulator infrastructure.
Reference: [7] <author> Peter Andrews. </author> <title> A Transfinite Type Theory with Type Variables. </title> <publisher> North-Holland Publishing Company, </publisher> <year> 1965. </year>
Reference-contexts: DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 42 * Type. A type is a metaclassifier for classes and objects (as per type theory; see <ref> [7, 8, 64, 72, 157, 165] </ref>). In some languages, like C++, type and class are equivalent. * Kind. A kind is a semantic metaclassifier for types. See Section 3.4.6 for more information on kinds. * Metalevels.
Reference: [8] <author> Peter Andrews. </author> <title> An Introduction to Mathematical Logic and Type Theory: To Truth Through Proof. </title> <publisher> Academic Press, </publisher> <year> 1986. </year>
Reference-contexts: DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 42 * Type. A type is a metaclassifier for classes and objects (as per type theory; see <ref> [7, 8, 64, 72, 157, 165] </ref>). In some languages, like C++, type and class are equivalent. * Kind. A kind is a semantic metaclassifier for types. See Section 3.4.6 for more information on kinds. * Metalevels.
Reference: [9] <author> Apple Computer Eastern Research and Technology Center. </author> <title> Dylan | an object-oriented dynamic language. </title> <type> Technical report, </type> <institution> Apple Computer, </institution> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: While I find the development and use of "research" and out-of-mainstream languages interesting and challenging, I will not pursue the creation or use of such a language. I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan <ref> [9] </ref>, ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [10] <author> Ken Arnold. </author> <title> The Java Programming Language, Second Edition. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1998. </year>
Reference-contexts: The adoption of a more "main-line" programming language that fulfills most of our needs will result in a body of work that can potentially influence a large number of practicianers. I chose to use the Java language <ref> [10, 68] </ref> and XML representation format [19] for exactly these reasons. * The support of modeling tools is very important. Different languages have different levels of tool support. Some (e.g., Actors) have no tool support; they are used as "by-hand" mathematical languages, useful for specification and proof. Others (e.g. <p> A new infrastructure, II 2.0, is being designed and built at this time (mid-1998). We have taken what we have learned in building II 1.0, added in new features found in Java 1.1 <ref> [10] </ref> and 1.2 [10, Appendix C], and incorporated a new object model that synthesizes the standard dynamic distributed system's object model with the Web object model. <p> A new infrastructure, II 2.0, is being designed and built at this time (mid-1998). We have taken what we have learned in building II 1.0, added in new features found in Java 1.1 [10] and 1.2 <ref> [10, Appendix C] </ref>, and incorporated a new object model that synthesizes the standard dynamic distributed system's object model with the Web object model.
Reference: [11] <author> J.C. Bicarregui, J.S. Fitzgerald, P.A. Lindsay, R. Moore, and B. Ritchie. </author> <title> Proof in VDM: A Practitioner's Guide. </title> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Abstraction Levels. System specification has many levels of granularity. At one end of the spectrum, what I'll call the "microscopic" level, there are specification languages for describing very static, precise systems, like the gates in a CPU (e.g. VDM <ref> [11] </ref>). At the "macroscopic" end of the scale, there are specification languages for describing entire huge, dynamic, and complex systems, like corporate entities (e.g. OOCL [161]). This granularity of specification, the abstraction level, influences the kinds of things that can be described.
Reference: [12] <editor> G.M. Birtwistle, O.-J. Dahl, B. Myhrhaug, and K. Nygaard. SIMULA begin. Studentlitteratur, </editor> <year> 1979. </year>
Reference-contexts: The primary technologies that help system builders manage this complexity are object-oriented and/or component-centric, and the primary tools are those that assist in system modeling and specification. 1.1 Motivation: Tackling Complexity But, nearly 30 years after their introduction <ref> [12, 162, 126] </ref>, these technological approaches only partially solve the complexity problem. They are not the final solution because large systems have hundreds, or even thousands of entities (classes, components, objects, files, computers, databases, etc.) and orders of magnitude more associations, dependencies, and relationships. <p> I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula <ref> [12, 45] </ref>, and Squeak [91]. The following are the out-of-mainstream production languages I believe are worthwhile: Eiffel [121, 122], Objective-C [43, 44] (the best short introduction can be found in [108], the best book on the language is [136]), Smalltalk [65, 66], and Python [112, 170, 171].
Reference: [13] <author> A. Bloesch, E. Kazmierczak, P. Kearney, and O. Traynor. Cogito: </author> <title> A methodology and system for formal software development. </title> <journal> International Journal of Software Engineering and Knowledge Engineering, </journal> <volume> 5(4) </volume> <pages> 599-617, </pages> <month> December </month> <year> 1995. </year> <title> DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, </title> <year> 1998 </year> <month> 87 </month>
Reference-contexts: More users will be inclined to try out a specification language if it includes a tool that helps them get their job done. (Examples include: Rational Rose [139]; the Demeter Tools [85]; DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 10 IFAD VDM-SL Toolbox [89]; Cogito <ref> [13] </ref>; LP, the Larch Prover [62], LSL, the Larch Shared Language [73], and LCLint, a tools used for statically checking annotated C programs [51] built with Larch).
Reference: [14] <author> Daniel G. Bobrow, Linda G. Demichiel, Richard P. Gabriel, Sonya E. Keene, Gregor Kiczales, and David A. Moon. </author> <title> Common Lisp Object System Specification. X3J13 Committee, document 880992r edition, </title> <month> June </month> <year> 1988. </year>
Reference-contexts: While I find the development and use of "research" and out-of-mainstream languages interesting and challenging, I will not pursue the creation or use of such a language. I consider the following interesting research languages: Beta [106, 113], CLOS <ref> [14, 60, 101, 102, 131] </ref> and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [15] <author> Grady Booch. </author> <title> Object-Oriented Analysis and Design with Applications. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1994. </year>
Reference-contexts: These methodologies are either very formal, or fairly informal | there are few methods that ride the middle-ground between usability and formalism. 2.2.1 Informal System Specification Methodologies First-Generation Methodologies. The leading first-generation informal and semi-informal system methodologies include Booch <ref> [15, 16] </ref>, Coad-Yourdon [35, 36], Martin/Odell [118, 119], OOSE/- Objectory [93, 94], Rumbaugh [142, 143], Shlaer-Mellor [148, 149], Syntropy [39], and Wirfs-Brock [174]. These methodologies focused primarily on building small to medium scale (up to hundreds of classes) object-oriented systems. <p> The original system modeling languages were not object-oriented, they were either data-oriented or behavior-oriented. Languages from both domains evolved and were incorporated into object-oriented modeling languages. Understandably, the bias of their origins can be seen in this transition. 3.2 Historical Opposites: Booch and Shlaer-Mellor The Booch <ref> [15] </ref> and Shlaer-Mellor [148] object-oriented methodologies are the historic archetypes of behavior and data-oriented methodologies. Booch is a behavior-oriented model, Shlaer-Mellor is a data-oriented model. <p> Each of these individuals brought their own perspective and modeling language and process to the table. Booch developed the previously mentioned Booch method <ref> [15] </ref>, Rumbaugh's language is called the Object Modeling Technique (OMT) [143], and Jacobson's language and process are called OOSE/Objectory [93]. Additionally, several other companies, individuals, and methods influenced the development of UML.
Reference: [16] <author> Grady Booch. </author> <title> Object Solutions | Managing the Object-Oriented Product. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1996. </year>
Reference-contexts: These methodologies are either very formal, or fairly informal | there are few methods that ride the middle-ground between usability and formalism. 2.2.1 Informal System Specification Methodologies First-Generation Methodologies. The leading first-generation informal and semi-informal system methodologies include Booch <ref> [15, 16] </ref>, Coad-Yourdon [35, 36], Martin/Odell [118, 119], OOSE/- Objectory [93, 94], Rumbaugh [142, 143], Shlaer-Mellor [148, 149], Syntropy [39], and Wirfs-Brock [174]. These methodologies focused primarily on building small to medium scale (up to hundreds of classes) object-oriented systems.
Reference: [17] <author> Grady Booch, Jim Rumbaugh, and Ivan Jacobson. </author> <title> Unified Modeling Language User Guide. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1997. </year>
Reference-contexts: But, uniformly, all do not have the constructs necessary to describe very large and/or distributed systems. Second-Generation Methodologies. The second-generation methodologies that are generally more formal and complete include Fusion [37], Meyer [121] and the Unified Modeling Language <ref> [17, 92, 144] </ref>. Designers of these new modeling techniques incorporated constructs that assist in the specification of large-scale and/or distributed systems. Additionally, these methods are capable of a DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 5 more formal specification of system components.
Reference: [18] <author> Tim Bray, Dave Hollander, and Andrew Layman. </author> <note> Namespaces in XML. Technical report, World Wide Web Consortium, 1998. http://www.w3.org/TR/WD-xml-names. </note>
Reference-contexts: UML is the de facto standard for system modeling and has a fairly well-defined (but not well-tested) mechanism and process for extending the core language. XML is the emerging de facto representation format for arbitrary data and has many constructs (namespaces <ref> [18] </ref>, linking [116], and pointing [117]) and instantiations (RDF [109], CKML [34], and OML [130]) and tools [53] which lend themselves to our use.
Reference: [19] <author> Tim Bray, Jean Paoli, and C. M. Sperberg-McQueen. </author> <title> Extensible Markup Language (XML). </title> <type> Technical report, </type> <note> World Wide Web Consortium, 1998. http://www.w3.org/TR/REC-xml. </note>
Reference-contexts: The adoption of a more "main-line" programming language that fulfills most of our needs will result in a body of work that can potentially influence a large number of practicianers. I chose to use the Java language [10, 68] and XML representation format <ref> [19] </ref> for exactly these reasons. * The support of modeling tools is very important. Different languages have different levels of tool support. Some (e.g., Actors) have no tool support; they are used as "by-hand" mathematical languages, useful for specification and proof. Others (e.g.
Reference: [20] <author> Edmund Burke and Eric Foxley. </author> <title> Logic and its Applications. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1996. </year>
Reference-contexts: The reader should be familiar with the Unified Modeling Language and at least one formal specification language. Suggested references include [42] and [50, Chapter 2] for UML, and <ref> [20, Chapter 6] </ref> for a specification language (in this case, Z [152]). In Chapter 2, I will discuss the general problem of systems and component specification in more detail. Next, in Chapter 3, I will describe some of our extensions to an existing system-level specification methodology. <p> Many of the abstract models have evolved from a formal grounding in mathematical <ref> [20, 67] </ref> and temporal logics [59]. Specification languages have been developed for a variety of abstraction levels, domains, and goals. These axes considerably influenced the design and evolution of specification languages and systems. Abstraction Levels. System specification has many levels of granularity. <p> I'll consider the implications of this statement in the next section. For the interested reader, an excellent concise overview of Z is available in <ref> [20, Chapter 6] </ref>. 2.4 The Utility of Specification Over the years, I have observed the genesis, evolution, and adoption of many specification and modeling languages. Based upon this experience, I have come up with the following set of "principles of specification".
Reference: [21] <author> Rich Burridge. </author> <title> Java Shared Data Toolkit User Guide. Sun Microsystems, </title> <publisher> Inc., </publisher> <address> 1.2 edition, </address> <month> April </month> <year> 1998. </year>
Reference-contexts: A session can negotiate with the underlying communication layer to determine the most appropriate process-to-process mechanism. While the current framework supports only UDP and native Java messaging layers (like RMI), the incorporation of alternative communication layers, like Ubernet [180], iBus [115], Java ACE [95], or JSDA <ref> [21] </ref> is straightforward. 4.4 The Infospheres Infrastructure: Specification I will provide a detailed specification of only one core subsystem (info.djinn) of II 1.0 here due to space considerations.
Reference: [22] <author> P. Butcher. </author> <title> A behavioral semantics for Linda-2. </title> <journal> Software Engineering Journal, </journal> <volume> 6(4) </volume> <pages> 196-204, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: State-Space Operations. A more unusual but equivalent specification technique is to describe components with respect to the ways in which they can access and modify their environment's state-space, perhaps via Z coupled with Linda as in <ref> [22] </ref>. Most non-object-oriented specification languages fall into this category because encapsulation is not a ground concept of the specification language. Each approach has advantages and disadvantages, but the specific form of the interface is less important than the fact that the component implementation is hidden.
Reference: [23] <author> Luca Cardelli. </author> <title> Obliq | a language with distributed scope. </title> <type> Technical report, </type> <institution> DEC Systems Research Center, </institution> <year> 1994. </year>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq <ref> [23, 24] </ref>, Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [24] <author> Luca Cardelli. </author> <title> A language with distributed scope. </title> <journal> Computing Systems, </journal> <volume> 8(1) </volume> <pages> 27-59, </pages> <year> 1995. </year>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq <ref> [23, 24] </ref>, Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [25] <author> CCITT. </author> <title> Specification and Description Language (SDL), recommendation z.100. </title> <type> Technical report, CCITT, </type> <year> 1988. </year>
Reference-contexts: formal system specification languages. 2.2.2 Formal Component Specification Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL <ref> [25, 166] </ref>, UNITY [30], VDM [97], and Z [90, 137, 152, 153, 178]. These models and their complementary languages are, for the most part, domain-specific. In particular Actors and UNITY have been proposed as a general purpose models for the specification and validation of concurrent and distributed systems.
Reference: [26] <author> K. Mani Chandy, Joseph R. Kiniry, Adam Rifkin, and Daniel M. Zimmerman. </author> <title> Webs of archived distributed computations for asynchronous collaboration. </title> <journal> Journal of Supercomputing, </journal> <volume> 11, </volume> <year> 1997. </year>
Reference-contexts: Additionally, these components must be able to participate in both synchronous and asynchronous collaborations. I will briefly discuss these requirements here, then describe the system design. 1 Portions of this chapter might be taken from previously published material including <ref> [26, 27, 28, 33, 69, 71] </ref>. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 48 4.2.1 Opaque Distributed Software Components The only visible aspects of an opaque component are (i) its external interface, so that other components can connect to it, and (ii) a specification of the component. <p> In addition, it is desirable for it to provide some method of efficiently updating persistent state information, such as by saving only incremental changes. 4.3 The Infospheres Infrastructure: Design In this section, I will briefly describe the Infospheres Infrastructure, version 1.0 <ref> [26, 33, 69] </ref>, and show how it satisfies the requirements identified in section 4.2. 4.3.1 Infospheres Framework The II framework employs three structuring mechanisms: personal networks enable long-term collaborations between people or groups; sessions provide a mechanism for carrying out the short-term tasks necessary within personal networks; and infospheres allow for
Reference: [27] <author> K. Mani Chandy, Joseph R. Kiniry, Adam Rifkin, Daniel M. Zimmerman, Wesley Tanaka, and Luke Weisman. </author> <title> A framework for structured distributed object computing. </title> <institution> California Institute of Technology Technical Report Caltech-CS-TR-97-07, California Institute of Technology, </institution> <month> February </month> <year> 1997. </year>
Reference-contexts: Additionally, these components must be able to participate in both synchronous and asynchronous collaborations. I will briefly discuss these requirements here, then describe the system design. 1 Portions of this chapter might be taken from previously published material including <ref> [26, 27, 28, 33, 69, 71] </ref>. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 48 4.2.1 Opaque Distributed Software Components The only visible aspects of an opaque component are (i) its external interface, so that other components can connect to it, and (ii) a specification of the component.
Reference: [28] <author> K. Mani Chandy, Joseph R. Kiniry, Adam Rifkin, Daniel M. Zimmerman, Wesley Tanaka, and Luke Weisman. </author> <title> A framework for structured distributed object computing. </title> <institution> crpc-tr CRPC-97-2, California Institute of Technology, </institution> <month> February </month> <year> 1997. </year>
Reference-contexts: Additionally, these components must be able to participate in both synchronous and asynchronous collaborations. I will briefly discuss these requirements here, then describe the system design. 1 Portions of this chapter might be taken from previously published material including <ref> [26, 27, 28, 33, 69, 71] </ref>. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 48 4.2.1 Opaque Distributed Software Components The only visible aspects of an opaque component are (i) its external interface, so that other components can connect to it, and (ii) a specification of the component.
Reference: [29] <author> K. Mani Chandy and Leslie Lamport. </author> <title> Distributed snapshots: Determining the global states of distributed systems. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <year> 1985. </year> <title> DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, </title> <year> 1998 </year> <month> 88 </month>
Reference-contexts: This is a variant of the global snapshot algorithm <ref> [29] </ref> in which a clock, or sequence number, is stored with the snapshot state. Within the snapshots, these logical clocks can be used for timestamping [107].
Reference: [30] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1988. </year>
Reference-contexts: Domains. Most specification languages are developed for specific problem domains. For example, VDM is a specification language primarily used in designing digital circuits, predicate calculus is used for the specification and proof of computational algorithms, and Concurrent Sequential Processes (CSP) [82] and UNITY <ref> [30] </ref> were developed to assist in the specification and proof of concurrent systems. Thus, the systems for which specification languages are developed influence their application, flexibility, and usability. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 4 Likewise, some languages are developed for a particular system paradigm. <p> languages. 2.2.2 Formal Component Specification Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL [25, 166], UNITY <ref> [30] </ref>, VDM [97], and Z [90, 137, 152, 153, 178]. These models and their complementary languages are, for the most part, domain-specific. In particular Actors and UNITY have been proposed as a general purpose models for the specification and validation of concurrent and distributed systems.
Reference: [31] <author> K. Mani Chandy and Adam Rifkin. </author> <title> Systematic composition of objects in distributed Internet applications: </title> <booktitle> Processes and sessions. In Hawaii International Conference on System Sciences, </booktitle> <pages> pages 63-75. </pages> <publisher> IEEE Computer Society, </publisher> <month> January </month> <year> 1997. </year>
Reference-contexts: Events. Events are messages with extra-system semantic meaning. Events are gaining popularity as a general-purpose communication framework, especially in publish-subscribe and push technologies [32, 78, 105, 110, 145, 154]. Message-Passing. Specification with respect to a component's sending and receiving messages is an alternative technique <ref> [31, 33, 52, 81] </ref>. State-Space Operations. A more unusual but equivalent specification technique is to describe components with respect to the ways in which they can access and modify their environment's state-space, perhaps via Z coupled with Linda as in [22].
Reference: [32] <author> K. Mani Chandy, Adam Rifkin, and Eve Schooler. </author> <title> Using announce-listen with global events to develop distributed control systems. </title> <booktitle> In ACM 1998 Workshop on Java for High-Performance Network Computing, </booktitle> <month> February </month> <year> 1998. </year>
Reference-contexts: Events. Events are messages with extra-system semantic meaning. Events are gaining popularity as a general-purpose communication framework, especially in publish-subscribe and push technologies <ref> [32, 78, 105, 110, 145, 154] </ref>. Message-Passing. Specification with respect to a component's sending and receiving messages is an alternative technique [31, 33, 52, 81]. State-Space Operations.
Reference: [33] <author> K. Mani Chandy, Adam Rifkin, Paolo Sivilotti, Jacob Mandelson, Matt Richardson, Wesley Tanaka, and Luke Weisman. </author> <title> A worldwide distributed system using Java and the Internet. </title> <booktitle> In International Symposium on High Performance Distributed Computing, </booktitle> <pages> pages 11-18, </pages> <year> 1996. </year>
Reference-contexts: Additionally, these components must be able to participate in both synchronous and asynchronous collaborations. I will briefly discuss these requirements here, then describe the system design. 1 Portions of this chapter might be taken from previously published material including <ref> [26, 27, 28, 33, 69, 71] </ref>. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 48 4.2.1 Opaque Distributed Software Components The only visible aspects of an opaque component are (i) its external interface, so that other components can connect to it, and (ii) a specification of the component. <p> Events. Events are messages with extra-system semantic meaning. Events are gaining popularity as a general-purpose communication framework, especially in publish-subscribe and push technologies [32, 78, 105, 110, 145, 154]. Message-Passing. Specification with respect to a component's sending and receiving messages is an alternative technique <ref> [31, 33, 52, 81] </ref>. State-Space Operations. A more unusual but equivalent specification technique is to describe components with respect to the ways in which they can access and modify their environment's state-space, perhaps via Z coupled with Linda as in [22]. <p> In addition, it is desirable for it to provide some method of efficiently updating persistent state information, such as by saving only incremental changes. 4.3 The Infospheres Infrastructure: Design In this section, I will briefly describe the Infospheres Infrastructure, version 1.0 <ref> [26, 33, 69] </ref>, and show how it satisfies the requirements identified in section 4.2. 4.3.1 Infospheres Framework The II framework employs three structuring mechanisms: personal networks enable long-term collaborations between people or groups; sessions provide a mechanism for carrying out the short-term tasks necessary within personal networks; and infospheres allow for
Reference: [34] <institution> Conceptual Knowledge Markup Language (CKML) DTD. </institution> <address> http://asimov.eecs.wsu.edu/ WAVE/Ontologies/CKML/CKML-DTD.html. </address>
Reference-contexts: XML is the emerging de facto representation format for arbitrary data and has many constructs (namespaces [18], linking [116], and pointing [117]) and instantiations (RDF [109], CKML <ref> [34] </ref>, and OML [130]) and tools [53] which lend themselves to our use. To summarize, I believe that next-generation work in formal specification must use the right language (s), provide tools, include interesting and relevant "boundary" research ideas, and use the proper ground technologies and standards.
Reference: [35] <author> Peter Coad and Edward Yourdon. OOA: </author> <title> Object-Oriented Analysis, 2nd Edition. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1990. </year>
Reference-contexts: These methodologies are either very formal, or fairly informal | there are few methods that ride the middle-ground between usability and formalism. 2.2.1 Informal System Specification Methodologies First-Generation Methodologies. The leading first-generation informal and semi-informal system methodologies include Booch [15, 16], Coad-Yourdon <ref> [35, 36] </ref>, Martin/Odell [118, 119], OOSE/- Objectory [93, 94], Rumbaugh [142, 143], Shlaer-Mellor [148, 149], Syntropy [39], and Wirfs-Brock [174]. These methodologies focused primarily on building small to medium scale (up to hundreds of classes) object-oriented systems.
Reference: [36] <author> Peter Coad and Edward Yourdon. OOD: </author> <title> Object-Oriented Design. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1990. </year>
Reference-contexts: These methodologies are either very formal, or fairly informal | there are few methods that ride the middle-ground between usability and formalism. 2.2.1 Informal System Specification Methodologies First-Generation Methodologies. The leading first-generation informal and semi-informal system methodologies include Booch [15, 16], Coad-Yourdon <ref> [35, 36] </ref>, Martin/Odell [118, 119], OOSE/- Objectory [93, 94], Rumbaugh [142, 143], Shlaer-Mellor [148, 149], Syntropy [39], and Wirfs-Brock [174]. These methodologies focused primarily on building small to medium scale (up to hundreds of classes) object-oriented systems.
Reference: [37] <author> Derek Coleman et al. </author> <title> Object-Oriented Development: The Fusion Method. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1993. </year>
Reference-contexts: Some are not integrally tied to the object-oriented paradigm, they are either process-oriented or data-oriented. But, uniformly, all do not have the constructs necessary to describe very large and/or distributed systems. Second-Generation Methodologies. The second-generation methodologies that are generally more formal and complete include Fusion <ref> [37] </ref>, Meyer [121] and the Unified Modeling Language [17, 92, 144]. Designers of these new modeling techniques incorporated constructs that assist in the specification of large-scale and/or distributed systems. <p> For example, Harel's work on state charts [74, 75, 76], Coleman et al work on numbering operations in Fusion <ref> [37] </ref>, and Gamma et al work on documenting patterns [61] were all rolled into the UML 1.0 final release. UML is a modeling language designed by a committee. Thus, it cannot be expected to solve the challenges presented in the last chapter.
Reference: [38] <editor> COMP.LANG.ML Frequently Asked Questions and Answers. </editor> <address> http://www.cis.ohio-state. edu/hypertext/faq/usenet/meta-lang-faq/faq.ht%ml. </address>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML <ref> [38, 124, 134] </ref>, the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [39] <author> S. Cook and J. Daniels. </author> <title> Designing Object Systems: Object-Oriented Modelling with Syntropy. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1994. </year>
Reference-contexts: The leading first-generation informal and semi-informal system methodologies include Booch [15, 16], Coad-Yourdon [35, 36], Martin/Odell [118, 119], OOSE/- Objectory [93, 94], Rumbaugh [142, 143], Shlaer-Mellor [148, 149], Syntropy <ref> [39] </ref>, and Wirfs-Brock [174]. These methodologies focused primarily on building small to medium scale (up to hundreds of classes) object-oriented systems. Some are not integrally tied to the object-oriented paradigm, they are either process-oriented or data-oriented.
Reference: [40] <institution> Rational Software Corporation et al. </institution> <note> UML Notation Guide, version 1.1. The UML 1.1 Consortium, </note> <month> September </month> <year> 1997. </year>
Reference-contexts: Because of their simplicity and customer/end-user focus, use cases have received a great deal of attention in the development of second generation modeling techniques like the Unified Modeling Language <ref> [40, 41, 42] </ref>. The primary components of a use-case model are use cases, actors, and the system being modeled. The system is a black-box that implements some set of functions, each of which is represented by a use case. <p> This core language is called the Unified Modeling Language (UML) <ref> [40, 41, 42] </ref>. UML was jointly developed by many companies, but leading the effort are three of the major researchers in the modeling community: Grady Booch, James Rumbaugh, and Ivar Jacobson. Each of these individuals brought their own perspective and modeling language and process to the table. <p> A simple example statechart is provided in Figure 3.2. A more complex statechart can be seen in Figure 3.3 2 Several figures in this document are adopted from, or modifications of, a variety of sources including <ref> [163, 88, 41, 40, 47] </ref>. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 16 DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 17 Activity Diagram.
Reference: [41] <institution> Rational Software Corporation et al. </institution> <note> UML Semantics, version 1.1. The UML 1.1 Consortium, </note> <month> September </month> <year> 1997. </year>
Reference-contexts: Because of their simplicity and customer/end-user focus, use cases have received a great deal of attention in the development of second generation modeling techniques like the Unified Modeling Language <ref> [40, 41, 42] </ref>. The primary components of a use-case model are use cases, actors, and the system being modeled. The system is a black-box that implements some set of functions, each of which is represented by a use case. <p> This core language is called the Unified Modeling Language (UML) <ref> [40, 41, 42] </ref>. UML was jointly developed by many companies, but leading the effort are three of the major researchers in the modeling community: Grady Booch, James Rumbaugh, and Ivar Jacobson. Each of these individuals brought their own perspective and modeling language and process to the table. <p> A simple example statechart is provided in Figure 3.2. A more complex statechart can be seen in Figure 3.3 2 Several figures in this document are adopted from, or modifications of, a variety of sources including <ref> [163, 88, 41, 40, 47] </ref>. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 16 DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 17 Activity Diagram. <p> Before defining these new elements, I must modify the semantics of the base metaclass Classifier. See <ref> [41, pg. 29] </ref> for the full details of the semantics of Classifier upon which the following discussion is based. The metaclass Classifier has four associations, feature, participant, realization, and specification.
Reference: [42] <institution> Rational Software Corporation et al. </institution> <type> UML Summary, version 1.1. Technical report, </type> <institution> The UML 1.1 Consortium, </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: The reader should be familiar with the Unified Modeling Language and at least one formal specification language. Suggested references include <ref> [42] </ref> and [50, Chapter 2] for UML, and [20, Chapter 6] for a specification language (in this case, Z [152]). In Chapter 2, I will discuss the general problem of systems and component specification in more detail. <p> Because of their simplicity and customer/end-user focus, use cases have received a great deal of attention in the development of second generation modeling techniques like the Unified Modeling Language <ref> [40, 41, 42] </ref>. The primary components of a use-case model are use cases, actors, and the system being modeled. The system is a black-box that implements some set of functions, each of which is represented by a use case. <p> This core language is called the Unified Modeling Language (UML) <ref> [40, 41, 42] </ref>. UML was jointly developed by many companies, but leading the effort are three of the major researchers in the modeling community: Grady Booch, James Rumbaugh, and Ivar Jacobson. Each of these individuals brought their own perspective and modeling language and process to the table. <p> In particular, aspects, reflective components, and metaobject protocols are poorly handled by UML. UML is now at revision 1.1 and its core specification is publicly available on the Web at http: //www.rational.com/uml/. A brief introduction to the language is provided in <ref> [42] </ref> and [50, Chapter 2]. 3.3.2 Catalysis Catalysis is a modeling language and process that takes the next step in scalable, rigorous, component-based development.
Reference: [43] <author> Brad Cox. Superdistribution: </author> <title> Objects As Property on the Electronic Frontier. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1996. </year>
Reference-contexts: The following are the out-of-mainstream production languages I believe are worthwhile: Eiffel [121, 122], Objective-C <ref> [43, 44] </ref> (the best short introduction can be found in [108], the best book on the language is [136]), Smalltalk [65, 66], and Python [112, 170, 171].
Reference: [44] <author> Brad Cox and Andrew Novabilsky. </author> <title> Object-Oriented Programming, An Evolutionary Approach. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1987. </year>
Reference-contexts: The following are the out-of-mainstream production languages I believe are worthwhile: Eiffel [121, 122], Objective-C <ref> [43, 44] </ref> (the best short introduction can be found in [108], the best book on the language is [136]), Smalltalk [65, 66], and Python [112, 170, 171].
Reference: [45] <author> O. Dahl and K. Nygaard. </author> <title> Simula, an Algol-based simulation language. </title> <journal> Communications of the ACM, </journal> <volume> 9(9) </volume> <pages> 671-678, </pages> <year> 1966. </year> <title> DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, </title> <year> 1998 </year> <month> 89 </month>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula <ref> [12, 45] </ref>, and Squeak [91]. The following are the out-of-mainstream production languages I believe are worthwhile: Eiffel [121, 122], Objective-C [43, 44] (the best short introduction can be found in [108], the best book on the language is [136]), Smalltalk [65, 66], and Python [112, 170, 171].
Reference: [46] <author> Edsger W. Dijkstra and Carel S. Scholten. </author> <title> Predicate Calculus and Program Semantics. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: That is the domain of the formal system specification languages. 2.2.2 Formal Component Specification Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus <ref> [46] </ref>, Process Algebras (CCS [123, 79]), CSP [82], SDL [25, 166], UNITY [30], VDM [97], and Z [90, 137, 152, 153, 178]. These models and their complementary languages are, for the most part, domain-specific.
Reference: [47] <author> Desmond D'Souza and Alan Wills. </author> <title> Objects, Components, and Frameworks with UML: the Catalysis Approach. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1998. </year>
Reference-contexts: Third-Generation Methodologies. Finally, third-generation languages, now emerging from the modeling community, show further refinement. They incorporate ideas and terminology from cognitive science, knowledge engineering and representation, and information theory. These new techniques include Catalysis <ref> [47] </ref>, Demeter [111], and Object-Oriented Change and Learning (OOCL) [161]. Due to the integration of ideas from these domains, these new techniques are very powerful and flexible. Cataysis. Catalysis, from Desmond D'Souza and Alan Wills, is the most "normal" of the third-generation languages. <p> For example, in UML, a set of use-case diagrams can be linked to sequence, collaboration, and activity diagrams, three kinds of more detailed diagrams in UML. Likewise, in Catalysis, use cases represent an abstraction of a new modeling construct called a collaboration <ref> [47] </ref>. A use case must, by definition, deliver value to the actor. In Objectory and UML, all actors are classes, and most actors represent system elements like customers, users, and other real-world entities. <p> the issuance of this RFP and realized the value in making UML an industry-wide standard with the OMG's stamp of approval. 1 In fact, this author was the reviewer of the new Addison-Wesley Catalysis book: Objects, Components, and Frameworks with UML The Catalysis Approach by Desmond D'Souza and Alan Wills <ref> [47] </ref>. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 15 Even though the core of UML comes from Booch, OMT, and OOSE/Objectory, ideas were incorporated from several other modeling languages as well. <p> A simple example statechart is provided in Figure 3.2. A more complex statechart can be seen in Figure 3.3 2 Several figures in this document are adopted from, or modifications of, a variety of sources including <ref> [163, 88, 41, 40, 47] </ref>. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 16 DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 17 Activity Diagram. <p> As D'Souza and Wills put it, "(Catalysis is) A next-generation standards-aligned method for open distributed object systems (that is constructed) from components and frameworks that reflect and support and adaptive enterprise." <ref> [47, Section 1.8] </ref>. The main "constructive" elements to system modeling that Catalysis contributes are called types, collaborations, refinements, and frameworks. <p> For example, types are refined to classes in Catalysis. Refinements in Catalysis differ from specialization and generalization in other modeling techniques because refinements can be applied to more than just system elements like classes and interfaces. E.g. Refinements can also be applied to business processes and specifications. See <ref> [47, Section 7.3] </ref> for a detailed refinement example. * Frameworks. Almost all modeling reveals reccuring patterns of types, classes, attributes, operations, and refinements. Many such patterns are captured by existing modeling constructs like associations, constraints, generalization, etc.
Reference: [48] <author> R. Duke, G. Rose, and G. Smith. Object-Z: </author> <title> A specification language advocated for the description of standards. </title> <type> Technical Report 94-45, </type> <institution> Software Verification Research Centre, School of Information Technology, The University of Queensland, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: While expressing higher abstraction levels with new constructs is possible, it leads to a model that is overly complex and focused on the wrong levels of abstraction and core entities. Examples of retrofitted or ill-targeted models include Object-Z <ref> [48] </ref>, MooZ, OOZE, Z++, VDM++ [49], Seuss [125], and Actors. These problems necessitate the creation of a new specification language and system.
Reference: [49] <author> E.H. Durr and J. van Katwijk. </author> <title> VDM++ | a formal specification language for object-oriented designs. </title> <editor> In Bertrand Meyer, Georg Heeg, and Boris Magnusson, editors, </editor> <booktitle> Proceedings of Technology of Object-oriented Languages and Systems (TOOLS Europe), </booktitle> <pages> pages 63-78. </pages> <publisher> Prentice-Hall, Inc., </publisher> <year> 1992. </year>
Reference-contexts: While expressing higher abstraction levels with new constructs is possible, it leads to a model that is overly complex and focused on the wrong levels of abstraction and core entities. Examples of retrofitted or ill-targeted models include Object-Z [48], MooZ, OOZE, Z++, VDM++ <ref> [49] </ref>, Seuss [125], and Actors. These problems necessitate the creation of a new specification language and system. Such a system must inherit most of its formalism from the traditional languages like Z and others, but it must also be grounded in modern system design and development.
Reference: [50] <author> Hans-Erik Eriksson and Magnus Penker. </author> <title> UML Toolkit. </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1998. </year>
Reference-contexts: The reader should be familiar with the Unified Modeling Language and at least one formal specification language. Suggested references include [42] and <ref> [50, Chapter 2] </ref> for UML, and [20, Chapter 6] for a specification language (in this case, Z [152]). In Chapter 2, I will discuss the general problem of systems and component specification in more detail. <p> Due to this positive benefit to complexity ratio, use-case diagrams are often seen in customer-focused system modeling more than any other diagram type. A good summary of use-case modeling is found in <ref> [50] </ref>. 2.3.2 The Z Specification Language At the other side of the complexity and completeness spectrum we find the Z system specification language. The Z language is a mathematical notation used to describe complex computing systems. <p> In particular, aspects, reflective components, and metaobject protocols are poorly handled by UML. UML is now at revision 1.1 and its core specification is publicly available on the Web at http: //www.rational.com/uml/. A brief introduction to the language is provided in [42] and <ref> [50, Chapter 2] </ref>. 3.3.2 Catalysis Catalysis is a modeling language and process that takes the next step in scalable, rigorous, component-based development.
Reference: [51] <author> David Evans, John V. Guttag, James J. Horning, and Yang Meng Tan. Lclint: </author> <title> A tool for using specifications to check code. </title> <booktitle> In Proceedings of the Symposium on the Foundations of Software Engineering, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: job done. (Examples include: Rational Rose [139]; the Demeter Tools [85]; DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 10 IFAD VDM-SL Toolbox [89]; Cogito [13]; LP, the Larch Prover [62], LSL, the Larch Shared Language [73], and LCLint, a tools used for statically checking annotated C programs <ref> [51] </ref> built with Larch). Moreover, if one can insinuate the use of a formal specification language via a commonly used tool without the user knowing (a priori) that they are using such a system, we will gain accidental "converts".
Reference: [52] <author> G. Florijn. </author> <title> Object protocols as functional parsers. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming, number 952 in Lecture Notes in Computer Science, </booktitle> <pages> pages 351-373, </pages> <year> 1995. </year>
Reference-contexts: Events. Events are messages with extra-system semantic meaning. Events are gaining popularity as a general-purpose communication framework, especially in publish-subscribe and push technologies [32, 78, 105, 110, 145, 154]. Message-Passing. Specification with respect to a component's sending and receiving messages is an alternative technique <ref> [31, 33, 52, 81] </ref>. State-Space Operations. A more unusual but equivalent specification technique is to describe components with respect to the ways in which they can access and modify their environment's state-space, perhaps via Z coupled with Linda as in [22].
Reference: [53] <institution> USGS NSDI formal metadata information and tools. </institution> <address> http://geochange.er.usgs.gov/pub/ tools/metadata/. </address>
Reference-contexts: XML is the emerging de facto representation format for arbitrary data and has many constructs (namespaces [18], linking [116], and pointing [117]) and instantiations (RDF [109], CKML [34], and OML [130]) and tools <ref> [53] </ref> which lend themselves to our use. To summarize, I believe that next-generation work in formal specification must use the right language (s), provide tools, include interesting and relevant "boundary" research ideas, and use the proper ground technologies and standards.
Reference: [54] <author> Jay W. </author> <title> Forrester. Industrial Dynamics. </title> <publisher> Productivity Press, </publisher> <year> 1961. </year>
Reference-contexts: I.e. OOCL is not used to design just software systems; it is used to design and understand business systems holistically | software is only one component of a complex business system. OOCL as a methodology has extended the object-oriented approach to support Jay Forrester's Systems Dynamics modeling approach <ref> [54, 55, 56, 57] </ref> as well as the Systems Thinking approach developed by MIT. The newest version of OOCL (version 2.0), is a major method update with new features including the ability to model self-organizing, complex adaptive systems (CAS).
Reference: [55] <author> Jay W. </author> <title> Forrester. Urban Dynamics. </title> <publisher> Productivity Press, </publisher> <year> 1969. </year>
Reference-contexts: I.e. OOCL is not used to design just software systems; it is used to design and understand business systems holistically | software is only one component of a complex business system. OOCL as a methodology has extended the object-oriented approach to support Jay Forrester's Systems Dynamics modeling approach <ref> [54, 55, 56, 57] </ref> as well as the Systems Thinking approach developed by MIT. The newest version of OOCL (version 2.0), is a major method update with new features including the ability to model self-organizing, complex adaptive systems (CAS).
Reference: [56] <author> Jay W. </author> <title> Forrester. World Dynamics. </title> <publisher> Productivity Press, </publisher> <address> 2nd edition, </address> <year> 1971. </year>
Reference-contexts: I.e. OOCL is not used to design just software systems; it is used to design and understand business systems holistically | software is only one component of a complex business system. OOCL as a methodology has extended the object-oriented approach to support Jay Forrester's Systems Dynamics modeling approach <ref> [54, 55, 56, 57] </ref> as well as the Systems Thinking approach developed by MIT. The newest version of OOCL (version 2.0), is a major method update with new features including the ability to model self-organizing, complex adaptive systems (CAS).
Reference: [57] <author> Jay W. </author> <title> Forrester. Collected Papers of Jay W. Forrester. </title> <publisher> Productivity Press, </publisher> <year> 1975. </year>
Reference-contexts: I.e. OOCL is not used to design just software systems; it is used to design and understand business systems holistically | software is only one component of a complex business system. OOCL as a methodology has extended the object-oriented approach to support Jay Forrester's Systems Dynamics modeling approach <ref> [54, 55, 56, 57] </ref> as well as the Systems Thinking approach developed by MIT. The newest version of OOCL (version 2.0), is a major method update with new features including the ability to model self-organizing, complex adaptive systems (CAS).
Reference: [58] <author> Svend Frtlund. </author> <title> Coordinating Distributed Objects: An Actor-Based Approach to Synchronization. </title> <publisher> The MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: What they do not help with (today) is any formal model- or system-correctness checking. That is the domain of the formal system specification languages. 2.2.2 Formal Component Specification Languages Some of the leading formal models and languages for component specification include the Actor model <ref> [4, 3, 58, 80] </ref>, Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL [25, 166], UNITY [30], VDM [97], and Z [90, 137, 152, 153, 178].
Reference: [59] <author> Dov M. Gabbay, Ian Hodkinson, and Mark Reynolds. </author> <title> Temporal Logic: Mathematical Foundations and Computational Aspects. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: Many of the abstract models have evolved from a formal grounding in mathematical [20, 67] and temporal logics <ref> [59] </ref>. Specification languages have been developed for a variety of abstraction levels, domains, and goals. These axes considerably influenced the design and evolution of specification languages and systems. Abstraction Levels. System specification has many levels of granularity.
Reference: [60] <author> R.P. Gabriel, J.L. White, and D.G. Bobrow. </author> <title> CLOS: Integrating object-oriented and functional programming. </title> <journal> Communications of the ACM, </journal> <volume> 34 </volume> <pages> 942-960, </pages> <year> 1991. </year>
Reference-contexts: While I find the development and use of "research" and out-of-mainstream languages interesting and challenging, I will not pursue the creation or use of such a language. I consider the following interesting research languages: Beta [106, 113], CLOS <ref> [14, 60, 101, 102, 131] </ref> and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [61] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1995. </year>
Reference-contexts: For example, Harel's work on state charts [74, 75, 76], Coleman et al work on numbering operations in Fusion [37], and Gamma et al work on documenting patterns <ref> [61] </ref> were all rolled into the UML 1.0 final release. UML is a modeling language designed by a committee. Thus, it cannot be expected to solve the challenges presented in the last chapter. In particular, UML does not handle emergent systems and knowledge representation at all.
Reference: [62] <author> Stephen J. Garland and John V. Guttag. </author> <title> A guide to LP, the Larch Prover. </title> <type> Technical Report 82, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <year> 1991. </year> <title> DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, </title> <year> 1998 </year> <month> 90 </month>
Reference-contexts: be inclined to try out a specification language if it includes a tool that helps them get their job done. (Examples include: Rational Rose [139]; the Demeter Tools [85]; DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 10 IFAD VDM-SL Toolbox [89]; Cogito [13]; LP, the Larch Prover <ref> [62] </ref>, LSL, the Larch Shared Language [73], and LCLint, a tools used for statically checking annotated C programs [51] built with Larch).
Reference: [63] <author> Mauro Gaspari and Gianluigi Zavattaro. </author> <title> An algebra of actors. </title> <type> Technical Report UBLCS-97-4, </type> <institution> Department of Computer Science, University of Bologna, </institution> <month> May </month> <year> 1997. </year>
Reference-contexts: That is the domain of the formal system specification languages. 2.2.2 Formal Component Specification Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras <ref> [63] </ref>, the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL [25, 166], UNITY [30], VDM [97], and Z [90, 137, 152, 153, 178]. These models and their complementary languages are, for the most part, domain-specific.
Reference: [64] <author> Jean-Yves Girard. </author> <title> Proofs and Types. </title> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 42 * Type. A type is a metaclassifier for classes and objects (as per type theory; see <ref> [7, 8, 64, 72, 157, 165] </ref>). In some languages, like C++, type and class are equivalent. * Kind. A kind is a semantic metaclassifier for types. See Section 3.4.6 for more information on kinds. * Metalevels.
Reference: [65] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1983. </year>
Reference-contexts: The following are the out-of-mainstream production languages I believe are worthwhile: Eiffel [121, 122], Objective-C [43, 44] (the best short introduction can be found in [108], the best book on the language is [136]), Smalltalk <ref> [65, 66] </ref>, and Python [112, 170, 171]. The adoption of a more "main-line" programming language that fulfills most of our needs will result in a body of work that can potentially influence a large number of practicianers.
Reference: [66] <author> Adele Goldberg and K.S. Rubin. </author> <title> Smalltalk-80: The Language edition = Revised, </title> <publisher> publisher = pub-aw, year = 1995,. </publisher>
Reference-contexts: The following are the out-of-mainstream production languages I believe are worthwhile: Eiffel [121, 122], Objective-C [43, 44] (the best short introduction can be found in [108], the best book on the language is [136]), Smalltalk <ref> [65, 66] </ref>, and Python [112, 170, 171]. The adoption of a more "main-line" programming language that fulfills most of our needs will result in a body of work that can potentially influence a large number of practicianers.
Reference: [67] <author> Martin Goldstern and Haim Judah. </author> <title> The Incompleteness Phenomenon: A New Course in Mathematical Logic. A.K. </title> <publisher> Peters, </publisher> <year> 1995. </year>
Reference-contexts: Many of the abstract models have evolved from a formal grounding in mathematical <ref> [20, 67] </ref> and temporal logics [59]. Specification languages have been developed for a variety of abstraction levels, domains, and goals. These axes considerably influenced the design and evolution of specification languages and systems. Abstraction Levels. System specification has many levels of granularity.
Reference: [68] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1996. </year>
Reference-contexts: The adoption of a more "main-line" programming language that fulfills most of our needs will result in a body of work that can potentially influence a large number of practicianers. I chose to use the Java language <ref> [10, 68] </ref> and XML representation format [19] for exactly these reasons. * The support of modeling tools is very important. Different languages have different levels of tool support. Some (e.g., Actors) have no tool support; they are used as "by-hand" mathematical languages, useful for specification and proof. Others (e.g. <p> The II 1.0 is documented in full in the Infospheres Infrastructure User's Guide [69] and is available for download via the group's Web site at http://www.infospheres.caltech.edu/ 1 . 4.1 Infospheres Infrastructure History The II was designed and built in late 1996, thus exclusively used the Java 1.0 language <ref> [68] </ref> and technologies. Its initial version (the alpha release) was built by a group of undergraduates managed by myself. The infrastructure was then redesigned and completely rewritten, but for the info.net package, by this author.
Reference: [69] <institution> The Infospheres Group. </institution> <note> The Infospheres Infrastructure version 1.0 User's Guide. </note> <institution> The Infos-pheres Group, California Institute of Technology, </institution> <month> Aug </month> <year> 1996. </year>
Reference-contexts: The II 1.0 is an extensive framework. Since this document is meant to focus specifically on modeling dynamic distributed systems, I will only briefly describe the core and relevant aspects of II 1.0 here. The II 1.0 is documented in full in the Infospheres Infrastructure User's Guide <ref> [69] </ref> and is available for download via the group's Web site at http://www.infospheres.caltech.edu/ 1 . 4.1 Infospheres Infrastructure History The II was designed and built in late 1996, thus exclusively used the Java 1.0 language [68] and technologies. <p> Additionally, these components must be able to participate in both synchronous and asynchronous collaborations. I will briefly discuss these requirements here, then describe the system design. 1 Portions of this chapter might be taken from previously published material including <ref> [26, 27, 28, 33, 69, 71] </ref>. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 48 4.2.1 Opaque Distributed Software Components The only visible aspects of an opaque component are (i) its external interface, so that other components can connect to it, and (ii) a specification of the component. <p> In addition, it is desirable for it to provide some method of efficiently updating persistent state information, such as by saving only incremental changes. 4.3 The Infospheres Infrastructure: Design In this section, I will briefly describe the Infospheres Infrastructure, version 1.0 <ref> [26, 33, 69] </ref>, and show how it satisfies the requirements identified in section 4.2. 4.3.1 Infospheres Framework The II framework employs three structuring mechanisms: personal networks enable long-term collaborations between people or groups; sessions provide a mechanism for carrying out the short-term tasks necessary within personal networks; and infospheres allow for <p> Each session of this personal network handles the acquisition, use, and release of resources, processes, and channels for the life of one specific task. Infospheres are discussed in detail as part of the user's guide to our framework <ref> [69] </ref>. Here, I will focus on the conceptual models for processes, personal networks, and sessions. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 50 4.3.2 Conceptual Model: Processes Processes are the persistent communicating components which manage interfaces and devices. <p> Note that modeling the semantics of mailboxes (and arbitrary messaging layers) requires the use of the new component interface specification stereotype, as described in Section 3.4.3. For the reader interested in more information about the info.net package, please see <ref> [69, Chapter 3] </ref>. 4.4.2 The Djinn Master The Djinn Master is the personal mini-ORB that is at the core of the II run-time. <p> Since the Djinn Master is itself a dynamic persistent active object, it can be summoned and manipulated like any other djinn. The partial class diagram for the info.master package is included in Figure 4.10. For the reader who is interested in more information, please see <ref> [69, Chapters 4 and 5] </ref>. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 64 DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 65 4.4.3 The Core Persistent Communicating Component: The Djinn I will describe the core subsystem, that of info.djinn in greater detail.
Reference: [70] <author> The Infospheres Group. </author> <title> The Infospheres Infrastructure version 2.0 Tutorial. The Infospheres Group, </title> <institution> California Institute of Technology, </institution> <year> 1998. </year>
Reference-contexts: More information on II 2.0 can be found in <ref> [70] </ref> and [71]. 4.2 The Infospheres Infrastructure: Requirements Analysis Our research goals dictate an infrastructure that must support the composition of distributed persistent opaque components with dynamic interfaces. Additionally, these components must be able to participate in both synchronous and asynchronous collaborations.
Reference: [71] <institution> The Infospheres Group. </institution> <note> The Infospheres Infrastructure version 2.0 User's Guide. </note> <institution> The Infos-pheres Group, California Institute of Technology, </institution> <year> 1998. </year>
Reference-contexts: More information on II 2.0 can be found in [70] and <ref> [71] </ref>. 4.2 The Infospheres Infrastructure: Requirements Analysis Our research goals dictate an infrastructure that must support the composition of distributed persistent opaque components with dynamic interfaces. Additionally, these components must be able to participate in both synchronous and asynchronous collaborations. <p> Additionally, these components must be able to participate in both synchronous and asynchronous collaborations. I will briefly discuss these requirements here, then describe the system design. 1 Portions of this chapter might be taken from previously published material including <ref> [26, 27, 28, 33, 69, 71] </ref>. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 48 4.2.1 Opaque Distributed Software Components The only visible aspects of an opaque component are (i) its external interface, so that other components can connect to it, and (ii) a specification of the component.
Reference: [72] <editor> Carl A. Gunter and John C. Mitchell, editors. </editor> <booktitle> Theoretical Aspects of Object-Oriented Programming. Foundations of Computing. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, USA, </address> <year> 1993. </year>
Reference-contexts: DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 42 * Type. A type is a metaclassifier for classes and objects (as per type theory; see <ref> [7, 8, 64, 72, 157, 165] </ref>). In some languages, like C++, type and class are equivalent. * Kind. A kind is a semantic metaclassifier for types. See Section 3.4.6 for more information on kinds. * Metalevels.
Reference: [73] <editor> John Guttag, James J. Horning, et al., editors. </editor> <title> Larch: Languages and Tools for Formal Specification. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: That is the domain of the formal system specification languages. 2.2.2 Formal Component Specification Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras [63], the Larch language and system <ref> [73] </ref>, OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL [25, 166], UNITY [30], VDM [97], and Z [90, 137, 152, 153, 178]. These models and their complementary languages are, for the most part, domain-specific. <p> specification language if it includes a tool that helps them get their job done. (Examples include: Rational Rose [139]; the Demeter Tools [85]; DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 10 IFAD VDM-SL Toolbox [89]; Cogito [13]; LP, the Larch Prover [62], LSL, the Larch Shared Language <ref> [73] </ref>, and LCLint, a tools used for statically checking annotated C programs [51] built with Larch).
Reference: [74] <author> D. Harel and E. Gery. </author> <title> Executable object modeling with statecharts. </title> <booktitle> In Proceedings of the 18th International Software Engineering Conference, </booktitle> <pages> pages 246-257. </pages> <publisher> IEEE Press, </publisher> <month> March </month> <year> 1996. </year>
Reference-contexts: DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 15 Even though the core of UML comes from Booch, OMT, and OOSE/Objectory, ideas were incorporated from several other modeling languages as well. For example, Harel's work on state charts <ref> [74, 75, 76] </ref>, Coleman et al work on numbering operations in Fusion [37], and Gamma et al work on documenting patterns [61] were all rolled into the UML 1.0 final release. UML is a modeling language designed by a committee.
Reference: [75] <author> D. Harel and A. Naamad. </author> <title> The STATEMATE semantics of statecharts. </title> <journal> In ACM Transactions on Software Engineering and Methodology, </journal> <volume> volume 5/4, </volume> <month> October </month> <year> 1996. </year>
Reference-contexts: DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 15 Even though the core of UML comes from Booch, OMT, and OOSE/Objectory, ideas were incorporated from several other modeling languages as well. For example, Harel's work on state charts <ref> [74, 75, 76] </ref>, Coleman et al work on numbering operations in Fusion [37], and Gamma et al work on documenting patterns [61] were all rolled into the UML 1.0 final release. UML is a modeling language designed by a committee.
Reference: [76] <author> David Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 15 Even though the core of UML comes from Booch, OMT, and OOSE/Objectory, ideas were incorporated from several other modeling languages as well. For example, Harel's work on state charts <ref> [74, 75, 76] </ref>, Coleman et al work on numbering operations in Fusion [37], and Gamma et al work on documenting patterns [61] were all rolled into the UML 1.0 final release. UML is a modeling language designed by a committee. <p> Statechart Diagram. A statechart diagram shows the sequences of states that an object or interaction goes through during its life-cycle in response to stimuli. It also documents the object's responses and actions. The semantics and notation of statechart diagrams is basically identical to David Harel's statechart diagrams <ref> [76] </ref>, as mentioned previously. A simple example statechart is provided in Figure 3.2. A more complex statechart can be seen in Figure 3.3 2 Several figures in this document are adopted from, or modifications of, a variety of sources including [163, 88, 41, 40, 47].
Reference: [77] <author> W. Harrison and H. Ossher. </author> <title> Subject-oriented programming (a critique of pure objects). </title> <booktitle> In ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, ACM SIGPLAN Notices, </booktitle> <pages> pages 411-428. </pages> <booktitle> ACM SIGPLAN, </booktitle> <publisher> ACM Press and Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Meta-Levels. "Meta" levels of system design and development are gaining attention for their expressive and descriptive power. Such constructs and theories include metaobject protocols [102], aspects [103], subject-oriented programming <ref> [77] </ref>, and reflection [114, 151]. A complete methodology must be able to capture all of the meta levels of the system being modeled. Components. Component architectures are at the root of most software development today.
Reference: [78] <author> Richard Hayton, Jean Bacon, John Bates, and Ken Moody. </author> <title> Using events to build large scale distributed applications. </title> <booktitle> In SIGOPS European Workshop '96, </booktitle> <year> 1996. </year>
Reference-contexts: Events. Events are messages with extra-system semantic meaning. Events are gaining popularity as a general-purpose communication framework, especially in publish-subscribe and push technologies <ref> [32, 78, 105, 110, 145, 154] </ref>. Message-Passing. Specification with respect to a component's sending and receiving messages is an alternative technique [31, 33, 52, 81]. State-Space Operations.
Reference: [79] <author> Matthew Hennessy. </author> <title> Algebraic Theory of Processes. </title> <publisher> The MIT Press, </publisher> <year> 1988. </year> <title> DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, </title> <year> 1998 </year> <month> 91 </month>
Reference-contexts: is the domain of the formal system specification languages. 2.2.2 Formal Component Specification Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS <ref> [123, 79] </ref>), CSP [82], SDL [25, 166], UNITY [30], VDM [97], and Z [90, 137, 152, 153, 178]. These models and their complementary languages are, for the most part, domain-specific.
Reference: [80] <author> C. Hewitt, P. Bishop, and R. Steiger. </author> <title> A universal modelar ACTOR formalism for AI. </title> <booktitle> In Proceedings, Third International Joint Conference on Artificial Intelligence, </booktitle> <year> 1973. </year>
Reference-contexts: What they do not help with (today) is any formal model- or system-correctness checking. That is the domain of the formal system specification languages. 2.2.2 Formal Component Specification Languages Some of the leading formal models and languages for component specification include the Actor model <ref> [4, 3, 58, 80] </ref>, Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL [25, 166], UNITY [30], VDM [97], and Z [90, 137, 152, 153, 178].
Reference: [81] <author> C.A.R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <year> 1978. </year>
Reference-contexts: Events. Events are messages with extra-system semantic meaning. Events are gaining popularity as a general-purpose communication framework, especially in publish-subscribe and push technologies [32, 78, 105, 110, 145, 154]. Message-Passing. Specification with respect to a component's sending and receiving messages is an alternative technique <ref> [31, 33, 52, 81] </ref>. State-Space Operations. A more unusual but equivalent specification technique is to describe components with respect to the ways in which they can access and modify their environment's state-space, perhaps via Z coupled with Linda as in [22].
Reference: [82] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1985. </year>
Reference-contexts: Domains. Most specification languages are developed for specific problem domains. For example, VDM is a specification language primarily used in designing digital circuits, predicate calculus is used for the specification and proof of computational algorithms, and Concurrent Sequential Processes (CSP) <ref> [82] </ref> and UNITY [30] were developed to assist in the specification and proof of concurrent systems. Thus, the systems for which specification languages are developed influence their application, flexibility, and usability. <p> of the formal system specification languages. 2.2.2 Formal Component Specification Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP <ref> [82] </ref>, SDL [25, 166], UNITY [30], VDM [97], and Z [90, 137, 152, 153, 178]. These models and their complementary languages are, for the most part, domain-specific. In particular Actors and UNITY have been proposed as a general purpose models for the specification and validation of concurrent and distributed systems. <p> I will informally describe several of the other system components of II to provide the reader with sufficient context for the details in Section 4.4.3. 4.4.1 The Messaging Subsystem The messaging subsystem is contained in the package info.net. It provides a asynchronous, mailbox-based messaging system, much like the CSP <ref> [82] </ref> model, built on top of UDP. The use-case and class diagrams for info.net are provided. The use-case diagrams are Figures 4.2 - 4.6 The partial class diagrams for info.net are found in Figures 4.7, 4.8, and 4.9.
Reference: [83] <author> John H. Holland. </author> <title> Hidden Order: How Adaptation Builds Complexity. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1995. </year>
Reference-contexts: The newest version of OOCL (version 2.0), is a major method update with new features including the ability to model self-organizing, complex adaptive systems (CAS). For more information on the work underlying the OOCL method, see <ref> [83, 84, 146, 147, 161] </ref>. For a quick summary of OOCL, see [5, 160, 163]. OOCL introduces a number of new modeling constructs to help specify such dynamic system. These elements include: * Agent. An agent is an entity responsible for a set of tasks. * Organization.
Reference: [84] <author> John J. Holland. </author> <title> Adaptation in Natural and Artificial Systems: An Introductory Analysis with Applications to Biology, Control, </title> <booktitle> and Artificial Intelligence. </booktitle> <publisher> University of Michigan Press, </publisher> <year> 1975. </year>
Reference-contexts: The newest version of OOCL (version 2.0), is a major method update with new features including the ability to model self-organizing, complex adaptive systems (CAS). For more information on the work underlying the OOCL method, see <ref> [83, 84, 146, 147, 161] </ref>. For a quick summary of OOCL, see [5, 160, 163]. OOCL introduces a number of new modeling constructs to help specify such dynamic system. These elements include: * Agent. An agent is an entity responsible for a set of tasks. * Organization.
Reference: [85] <author> Walter L. Hursch. </author> <title> User's guide to the Demeter Tools/C++. C++ Demeter System Documentation, </title> <month> May </month> <year> 1991. </year>
Reference-contexts: More users will be inclined to try out a specification language if it includes a tool that helps them get their job done. (Examples include: Rational Rose [139]; the Demeter Tools <ref> [85] </ref>; DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 10 IFAD VDM-SL Toolbox [89]; Cogito [13]; LP, the Larch Prover [62], LSL, the Larch Shared Language [73], and LCLint, a tools used for statically checking annotated C programs [51] built with Larch).
Reference: [86] <author> A. Hutt. </author> <title> Analysis and Design: Comparison of Methods. </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1994. </year>
Reference-contexts: Then I will introduce a set of new modeling constructs and diagrams which can be added to any modeling language to improve its expressiveness and capability. For the reader interested in an overview, history, description, and comparison of the primary methodologies of the late eighties and early nineties, see <ref> [86, 87, 119] </ref>. 3.3.1 UML: The Unified Modeling Language As previously mentioned, UML primarily originates from the work of Booch, Rumbaugh, and Ja-cobson. Booch and Rumbaugh began working on UML together in 1994 when Rumbaugh joined Booch's company, Rational Software Corporation.
Reference: [87] <author> A. Hutt. </author> <title> Analysis and Design: Description of Methods. </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1994. </year>
Reference-contexts: Then I will introduce a set of new modeling constructs and diagrams which can be added to any modeling language to improve its expressiveness and capability. For the reader interested in an overview, history, description, and comparison of the primary methodologies of the late eighties and early nineties, see <ref> [86, 87, 119] </ref>. 3.3.1 UML: The Unified Modeling Language As previously mentioned, UML primarily originates from the work of Booch, Rumbaugh, and Ja-cobson. Booch and Rumbaugh began working on UML together in 1994 when Rumbaugh joined Booch's company, Rational Software Corporation.
Reference: [88] <author> IBM et al. </author> <title> Object Constraint Language Specification, </title> <note> version 1.1. The UML 1.1 Consortium, </note> <month> September </month> <year> 1997. </year>
Reference-contexts: That is the domain of the formal system specification languages. 2.2.2 Formal Component Specification Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras [63], the Larch language and system [73], OCL <ref> [88] </ref>, Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL [25, 166], UNITY [30], VDM [97], and Z [90, 137, 152, 153, 178]. These models and their complementary languages are, for the most part, domain-specific. <p> A simple example statechart is provided in Figure 3.2. A more complex statechart can be seen in Figure 3.3 2 Several figures in this document are adopted from, or modifications of, a variety of sources including <ref> [163, 88, 41, 40, 47] </ref>. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 16 DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 17 Activity Diagram.
Reference: [89] <author> IFAD. </author> <title> IFAD VDM tools. </title> <address> http://www.ifad.dk/products/vdmtools.html. </address>
Reference-contexts: More users will be inclined to try out a specification language if it includes a tool that helps them get their job done. (Examples include: Rational Rose [139]; the Demeter Tools [85]; DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 10 IFAD VDM-SL Toolbox <ref> [89] </ref>; Cogito [13]; LP, the Larch Prover [62], LSL, the Larch Shared Language [73], and LCLint, a tools used for statically checking annotated C programs [51] built with Larch).
Reference: [90] <author> Darrel C. Ince. </author> <title> An Introduction to Discrete Mathematics, Formal System Specification and Z. </title> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL [25, 166], UNITY [30], VDM [97], and Z <ref> [90, 137, 152, 153, 178] </ref>. These models and their complementary languages are, for the most part, domain-specific. In particular Actors and UNITY have been proposed as a general purpose models for the specification and validation of concurrent and distributed systems.
Reference: [91] <author> Dan Ingalls, Ted Kaehler, John Maloney, Scott Wallace, and Alan Kay. </author> <title> Back to the future: The story of squeak, a practical smalltalk written in itself. </title> <booktitle> In ACM Conference on Object-Oriented Programming Systems, Languages, and Applications. </booktitle> <institution> Apple Computer and Walt Disney Imag-ineering, </institution> <year> 1997. </year> <month> ftp://st.cs.uiuc.edu/Smalltalk/Squeak/docs/OOPSLA.Squeak.html. </month>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak <ref> [91] </ref>. The following are the out-of-mainstream production languages I believe are worthwhile: Eiffel [121, 122], Objective-C [43, 44] (the best short introduction can be found in [108], the best book on the language is [136]), Smalltalk [65, 66], and Python [112, 170, 171].
Reference: [92] <author> Ivar Jacobson, Grady Booch, and Jim Rumbaugh. </author> <title> The Unified Process: A Software Engineering Process Using the Unified Modeling Language. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1998. </year>
Reference-contexts: But, uniformly, all do not have the constructs necessary to describe very large and/or distributed systems. Second-Generation Methodologies. The second-generation methodologies that are generally more formal and complete include Fusion [37], Meyer [121] and the Unified Modeling Language <ref> [17, 92, 144] </ref>. Designers of these new modeling techniques incorporated constructs that assist in the specification of large-scale and/or distributed systems. Additionally, these methods are capable of a DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 5 more formal specification of system components.
Reference: [93] <author> Ivar Jacobson, M. Christerson, P. Jonsson, and G. Overgaard. </author> <title> Object-Oriented Software Engineering. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1992. </year>
Reference-contexts: These methodologies are either very formal, or fairly informal | there are few methods that ride the middle-ground between usability and formalism. 2.2.1 Informal System Specification Methodologies First-Generation Methodologies. The leading first-generation informal and semi-informal system methodologies include Booch [15, 16], Coad-Yourdon [35, 36], Martin/Odell [118, 119], OOSE/- Objectory <ref> [93, 94] </ref>, Rumbaugh [142, 143], Shlaer-Mellor [148, 149], Syntropy [39], and Wirfs-Brock [174]. These methodologies focused primarily on building small to medium scale (up to hundreds of classes) object-oriented systems. Some are not integrally tied to the object-oriented paradigm, they are either process-oriented or data-oriented. <p> Each of these individuals brought their own perspective and modeling language and process to the table. Booch developed the previously mentioned Booch method [15], Rumbaugh's language is called the Object Modeling Technique (OMT) [143], and Jacobson's language and process are called OOSE/Objectory <ref> [93] </ref>. Additionally, several other companies, individuals, and methods influenced the development of UML. One of the most influential methods is called Catalysis, and is considered one of the leading-edge methods available today 1 . Finally, there exist some new methods that are outside the mainstream.
Reference: [94] <author> Ivar Jacobson et al. </author> <title> Object-Oriented Software Engineering | A Use Case Driven Approach. </title> <booktitle> ACM Press/Addison-Wesley, </booktitle> <year> 1992. </year>
Reference-contexts: These methodologies are either very formal, or fairly informal | there are few methods that ride the middle-ground between usability and formalism. 2.2.1 Informal System Specification Methodologies First-Generation Methodologies. The leading first-generation informal and semi-informal system methodologies include Booch [15, 16], Coad-Yourdon [35, 36], Martin/Odell [118, 119], OOSE/- Objectory <ref> [93, 94] </ref>, Rumbaugh [142, 143], Shlaer-Mellor [148, 149], Syntropy [39], and Wirfs-Brock [174]. These methodologies focused primarily on building small to medium scale (up to hundreds of classes) object-oriented systems. Some are not integrally tied to the object-oriented paradigm, they are either process-oriented or data-oriented. <p> I will discuss these requirements in more detail after providing an example of the range of formalism in use today. 2.3 Examples: From the Informal to the Formal For an example, I'll consider the general specification technique Use-Cases <ref> [94] </ref> and the formal specification language Z [137]. Use-Cases is extremely simple to learn and use, thus it is widely adopted in industry.
Reference: [95] <author> Prashant Jain and Douglas Schmidt. </author> <title> Java ACE homepage. </title> <address> http://www.cs.wustl.edu/ ~schmidt/JACE.html. </address>
Reference-contexts: A session can negotiate with the underlying communication layer to determine the most appropriate process-to-process mechanism. While the current framework supports only UDP and native Java messaging layers (like RMI), the incorporation of alternative communication layers, like Ubernet [180], iBus [115], Java ACE <ref> [95] </ref>, or JSDA [21] is straightforward. 4.4 The Infospheres Infrastructure: Specification I will provide a detailed specification of only one core subsystem (info.djinn) of II 1.0 here due to space considerations.
Reference: [96] <author> Ralph Johnson. </author> <type> Personal email communication. </type> <institution> dist-obj Mailing List: </institution> <address> http://www. infospheres.caltech.edu/mailing_lists/dist-obj/msg01196.html%, </address> <month> May </month> <year> 1998. </year> <title> DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, </title> <year> 1998 </year> <month> 92 </month>
Reference-contexts: That community has succeeded in taking an extremely important topic and making it so hard to understand that it is ignored by most of the people who need to know it <ref> [96] </ref>." This "generated complexity" that is prevelant in many of the fields that this work is based upon, (metaobject protocols, knowledge representation, reflection, semantics representation, etc.), I hope to avoid though a conscious effort to keep our vocabulary and concepts clear and to the point. * The proper ground technologies must
Reference: [97] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1986. </year>
Reference-contexts: Formal Component Specification Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL [25, 166], UNITY [30], VDM <ref> [97] </ref>, and Z [90, 137, 152, 153, 178]. These models and their complementary languages are, for the most part, domain-specific. In particular Actors and UNITY have been proposed as a general purpose models for the specification and validation of concurrent and distributed systems.
Reference: [98] <author> Markus Kaltenbach. </author> <title> Model checking for UNITY. </title> <type> Technical report, </type> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <year> 1994. </year>
Reference-contexts: Different languages have different levels of tool support. Some (e.g., Actors) have no tool support; they are used as "by-hand" mathematical languages, useful for specification and proof. Others (e.g. UNITY, predicate calculus, OOCL, and OCL) have partial tool support; a verifier, like UV, the UNITY Verifier <ref> [98] </ref>, or theorem prover or proof-checker might be available to assist an expert in system specification (e.g. Isabelle [133], LOTOS [169]). Finally, some (UML, Demeter, the VDM family, the Z family, and the Larch family) have excellent tool support.
Reference: [99] <author> Stewart Kauffman. </author> <title> The Origins of Order: Self-Organization and Selection in Evolution. </title> <publisher> Oxford University Press, </publisher> <year> 1993. </year>
Reference-contexts: Emergence. Systems not only change over time, but can exhibit behaviors that were not originally part of the system's original design. Such emergent behavior is unsurprising in some systems. Corporations, intentional non-deterministic or random systems, and artificially designed, evolvable simulations, like Tom Ray's Tierra [140] commonly exhibit surprising behavior <ref> [99, 100] </ref>. But a system like the World Wide Web, very simple at its core but complex in its scope, application, and degree of growth, is not expected to evidence such evolving behavior. Meta-Levels. "Meta" levels of system design and development are gaining attention for their expressive and descriptive power.
Reference: [100] <author> Stewart Kauffman. </author> <title> At Home in the Universe: The Search for Laws of Self-Organization and Complexity. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Emergence. Systems not only change over time, but can exhibit behaviors that were not originally part of the system's original design. Such emergent behavior is unsurprising in some systems. Corporations, intentional non-deterministic or random systems, and artificially designed, evolvable simulations, like Tom Ray's Tierra [140] commonly exhibit surprising behavior <ref> [99, 100] </ref>. But a system like the World Wide Web, very simple at its core but complex in its scope, application, and degree of growth, is not expected to evidence such evolving behavior. Meta-Levels. "Meta" levels of system design and development are gaining attention for their expressive and descriptive power. <p> The constructs that I am going to describe are primarily inspired by the modeling constructs used by chemists and biologists to describe molecular structures and reactions <ref> [100] </ref>. 3.4.5.1 New Modeling Constructs for Object Network Diagrams My new constructs for the entities that make up an object network are summarized in Figure 3.30. The novel constructs are defined as follows: * Agent.
Reference: [101] <author> Sonya E. Keene. </author> <title> Object-Oriented Programming in Common Lisp: A Programmer's Guide to CLOS. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1989. </year>
Reference-contexts: While I find the development and use of "research" and out-of-mainstream languages interesting and challenging, I will not pursue the creation or use of such a language. I consider the following interesting research languages: Beta [106, 113], CLOS <ref> [14, 60, 101, 102, 131] </ref> and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [102] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: While I find the development and use of "research" and out-of-mainstream languages interesting and challenging, I will not pursue the creation or use of such a language. I consider the following interesting research languages: Beta [106, 113], CLOS <ref> [14, 60, 101, 102, 131] </ref> and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91]. <p> Meta-Levels. "Meta" levels of system design and development are gaining attention for their expressive and descriptive power. Such constructs and theories include metaobject protocols <ref> [102] </ref>, aspects [103], subject-oriented programming [77], and reflection [114, 151]. A complete methodology must be able to capture all of the meta levels of the system being modeled. Components. Component architectures are at the root of most software development today. <p> Relationships between JavaBean composition tools and the beans that they contain are reflective associations. Examples of reflective associations are those used throughout the CLOS runtime <ref> [102] </ref>. * Meta association. (tmeta) A meta association is a association obtained via one or more operations at a meta-layer of an architecture.
Reference: [103] <author> Gregor Kiczales, John Lamping, Anurag Mendhekar, Chris Maeda, Cristina Lopes, Jean-Marc Loingtier, and John Irwin. </author> <title> Aspect-oriented programming. </title> <type> Technical Report SPL97-008 P9710042, </type> <institution> XEROX Corporation, </institution> <month> February </month> <year> 1997. </year>
Reference-contexts: Meta-Levels. "Meta" levels of system design and development are gaining attention for their expressive and descriptive power. Such constructs and theories include metaobject protocols [102], aspects <ref> [103] </ref>, subject-oriented programming [77], and reflection [114, 151]. A complete methodology must be able to capture all of the meta levels of the system being modeled. Components. Component architectures are at the root of most software development today.
Reference: [104] <author> Joseph R. Kiniry, Alexander Nicolson, and Donald Pinkston. </author> <title> DALI: A distributed artificial life simulator infrastructure. </title> <note> WWW, 1997. Available at http://www.cs.caltech.edu/~kiniry/ projects/alife/index.html. </note>
Reference-contexts: This system lets the user construct an distributed asynchronous simulation system for simulating artificial life systems (genomes specify behavior, speciation, pack behavior, etc.). The system scales extremely well given Infospheres 1.0's properties (i.e. hundreds of thousands to millions of interacting agents are possible). See <ref> [104] </ref> for more information. * Virtual Swap Meet: A distributed agent marketplace. This project is a peer-to-peer autonomous agent auctioning system. This system lets the user specify a set of items that they are interested in purchasing and a set of items that they are interested in selling.
Reference: [105] <author> Balachander Krishnamurthy and David S. Rosenblum. Yeast: </author> <title> A general purpose event-action system. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 21(10) </volume> <pages> 845-857, </pages> <month> Octo-ber </month> <year> 1995. </year>
Reference-contexts: Events. Events are messages with extra-system semantic meaning. Events are gaining popularity as a general-purpose communication framework, especially in publish-subscribe and push technologies <ref> [32, 78, 105, 110, 145, 154] </ref>. Message-Passing. Specification with respect to a component's sending and receiving messages is an alternative technique [31, 33, 52, 81]. State-Space Operations.
Reference: [106] <author> Bent B. Kristensen, Ole L. Madsen, Birger Mtller-Pederson, and Kristen Nygaard. </author> <booktitle> The BETA Programming Language, </booktitle> <pages> pages 7-48. </pages> <publisher> The MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: While I find the development and use of "research" and out-of-mainstream languages interesting and challenging, I will not pursue the creation or use of such a language. I consider the following interesting research languages: Beta <ref> [106, 113] </ref>, CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [107] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <year> 1978. </year>
Reference-contexts: This is a variant of the global snapshot algorithm [29] in which a clock, or sequence number, is stored with the snapshot state. Within the snapshots, these logical clocks can be used for timestamping <ref> [107] </ref>.
Reference: [108] <author> Don Larkin and Greg Wilson. </author> <title> Object-oriented programming and the Objective-C language. </title> <type> Technical report, </type> <institution> NeXT Software, Inc. (now Apple Corp.), </institution> <year> 1993. </year>
Reference-contexts: The following are the out-of-mainstream production languages I believe are worthwhile: Eiffel [121, 122], Objective-C [43, 44] (the best short introduction can be found in <ref> [108] </ref>, the best book on the language is [136]), Smalltalk [65, 66], and Python [112, 170, 171]. The adoption of a more "main-line" programming language that fulfills most of our needs will result in a body of work that can potentially influence a large number of practicianers.
Reference: [109] <author> Ora Lassila and Ralph Swick. </author> <title> Resource Description Framework (RDF) Model and Syntax. </title> <type> Technical report, </type> <note> World Wide Web Consortium, 1998. http://www.w3.org/TR/ WDrdf-syntax. </note>
Reference-contexts: XML is the emerging de facto representation format for arbitrary data and has many constructs (namespaces [18], linking [116], and pointing [117]) and instantiations (RDF <ref> [109] </ref>, CKML [34], and OML [130]) and tools [53] which lend themselves to our use. To summarize, I believe that next-generation work in formal specification must use the right language (s), provide tools, include interesting and relevant "boundary" research ideas, and use the proper ground technologies and standards.
Reference: [110] <author> Doug Lea. </author> <title> Design for open systems in Java. </title> <booktitle> In Proceedings of the Second International Conference on Coordination Models and Languages, </booktitle> <address> Berlin, Germany, </address> <month> September </month> <year> 1997. </year>
Reference-contexts: Events. Events are messages with extra-system semantic meaning. Events are gaining popularity as a general-purpose communication framework, especially in publish-subscribe and push technologies <ref> [32, 78, 105, 110, 145, 154] </ref>. Message-Passing. Specification with respect to a component's sending and receiving messages is an alternative technique [31, 33, 52, 81]. State-Space Operations.
Reference: [111] <author> Karl J. Lieberherr. </author> <title> Adaptive Object-Oriented Software: The Demeter Method with Propagation Patterns. </title> <publisher> PWS Publishing Company, </publisher> <year> 1996. </year>
Reference-contexts: Third-Generation Methodologies. Finally, third-generation languages, now emerging from the modeling community, show further refinement. They incorporate ideas and terminology from cognitive science, knowledge engineering and representation, and information theory. These new techniques include Catalysis [47], Demeter <ref> [111] </ref>, and Object-Oriented Change and Learning (OOCL) [161]. Due to the integration of ideas from these domains, these new techniques are very powerful and flexible. Cataysis. Catalysis, from Desmond D'Souza and Alan Wills, is the most "normal" of the third-generation languages. <p> It is very difficult to present a tightly focused, highly-specialized body of work to a general audience. Consider the Demeter method (a focused summary of Demeter's core concepts can be found in <ref> [111, Chapter 15] </ref>, an annotated version of [132]). Its focus is exclusively on adaptive object-oriented software through the use of propagation patterns. Because of this tight focus, and the fact that the method uses metalevel architectures, it has not had much impact in the modeling and design communities.
Reference: [112] <author> Mark Lutz. </author> <title> Programming Python. </title> <publisher> O'Reilly & Associates, Inc., </publisher> <year> 1996. </year> <title> DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, </title> <year> 1998 </year> <month> 93 </month>
Reference-contexts: The following are the out-of-mainstream production languages I believe are worthwhile: Eiffel [121, 122], Objective-C [43, 44] (the best short introduction can be found in [108], the best book on the language is [136]), Smalltalk [65, 66], and Python <ref> [112, 170, 171] </ref>. The adoption of a more "main-line" programming language that fulfills most of our needs will result in a body of work that can potentially influence a large number of practicianers.
Reference: [113] <author> Ole L. Madsen, Birger Mtller-Pedersen, and Kristen Nygaard. </author> <title> Object-Oriented Programming in the Beta Programming Language. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: While I find the development and use of "research" and out-of-mainstream languages interesting and challenging, I will not pursue the creation or use of such a language. I consider the following interesting research languages: Beta <ref> [106, 113] </ref>, CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [114] <editor> Pattie Maes and Daniele Nardi, editors. </editor> <title> Meta-Level Architectures and Reflection. </title> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: Meta-Levels. "Meta" levels of system design and development are gaining attention for their expressive and descriptive power. Such constructs and theories include metaobject protocols [102], aspects [103], subject-oriented programming [77], and reflection <ref> [114, 151] </ref>. A complete methodology must be able to capture all of the meta levels of the system being modeled. Components. Component architectures are at the root of most software development today.
Reference: [115] <author> Silvano Maffeis. </author> <title> iBus | the Java intranet software bus. </title> <type> Technical report, </type> <institution> SoftWired AG, Switzerland, </institution> <year> 1997. </year>
Reference-contexts: A session can negotiate with the underlying communication layer to determine the most appropriate process-to-process mechanism. While the current framework supports only UDP and native Java messaging layers (like RMI), the incorporation of alternative communication layers, like Ubernet [180], iBus <ref> [115] </ref>, Java ACE [95], or JSDA [21] is straightforward. 4.4 The Infospheres Infrastructure: Specification I will provide a detailed specification of only one core subsystem (info.djinn) of II 1.0 here due to space considerations.
Reference: [116] <author> Eve Maler and Steve DeRose. </author> <title> XML Linking Language (XLink). </title> <type> Technical report, </type> <note> World Wide Web Consortium, 1998. http://www.w3.org/TR/WD-xlink. </note>
Reference-contexts: UML is the de facto standard for system modeling and has a fairly well-defined (but not well-tested) mechanism and process for extending the core language. XML is the emerging de facto representation format for arbitrary data and has many constructs (namespaces [18], linking <ref> [116] </ref>, and pointing [117]) and instantiations (RDF [109], CKML [34], and OML [130]) and tools [53] which lend themselves to our use.
Reference: [117] <author> Eve Maler and Steve DeRose. </author> <title> XML Pointer Language (XPointer). </title> <type> Technical report, </type> <note> World Wide Web Consortium, 1998. http://www.w3.org/TR/WD-xptr. </note>
Reference-contexts: UML is the de facto standard for system modeling and has a fairly well-defined (but not well-tested) mechanism and process for extending the core language. XML is the emerging de facto representation format for arbitrary data and has many constructs (namespaces [18], linking [116], and pointing <ref> [117] </ref>) and instantiations (RDF [109], CKML [34], and OML [130]) and tools [53] which lend themselves to our use.
Reference: [118] <author> James Martin and James J. Odell. </author> <title> Object-Oriented Methods Pragmatic Considerations. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1996. </year>
Reference-contexts: These methodologies are either very formal, or fairly informal | there are few methods that ride the middle-ground between usability and formalism. 2.2.1 Informal System Specification Methodologies First-Generation Methodologies. The leading first-generation informal and semi-informal system methodologies include Booch [15, 16], Coad-Yourdon [35, 36], Martin/Odell <ref> [118, 119] </ref>, OOSE/- Objectory [93, 94], Rumbaugh [142, 143], Shlaer-Mellor [148, 149], Syntropy [39], and Wirfs-Brock [174]. These methodologies focused primarily on building small to medium scale (up to hundreds of classes) object-oriented systems. Some are not integrally tied to the object-oriented paradigm, they are either process-oriented or data-oriented.
Reference: [119] <author> James Martin and James J. Odell. </author> <title> Object-Oriented Methods, A Foundation. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1997. </year>
Reference-contexts: These methodologies are either very formal, or fairly informal | there are few methods that ride the middle-ground between usability and formalism. 2.2.1 Informal System Specification Methodologies First-Generation Methodologies. The leading first-generation informal and semi-informal system methodologies include Booch [15, 16], Coad-Yourdon [35, 36], Martin/Odell <ref> [118, 119] </ref>, OOSE/- Objectory [93, 94], Rumbaugh [142, 143], Shlaer-Mellor [148, 149], Syntropy [39], and Wirfs-Brock [174]. These methodologies focused primarily on building small to medium scale (up to hundreds of classes) object-oriented systems. Some are not integrally tied to the object-oriented paradigm, they are either process-oriented or data-oriented. <p> Then I will introduce a set of new modeling constructs and diagrams which can be added to any modeling language to improve its expressiveness and capability. For the reader interested in an overview, history, description, and comparison of the primary methodologies of the late eighties and early nineties, see <ref> [86, 87, 119] </ref>. 3.3.1 UML: The Unified Modeling Language As previously mentioned, UML primarily originates from the work of Booch, Rumbaugh, and Ja-cobson. Booch and Rumbaugh began working on UML together in 1994 when Rumbaugh joined Booch's company, Rational Software Corporation.
Reference: [120] <author> Elise Matefy and Jessica Walton. </author> <title> Virtual swap meet: A distributed agent marketplace, </title> <month> August </month> <year> 1997. </year> <note> http://www.infospheres.caltech.edu/papers/vsm/paper.html. </note>
Reference-contexts: Once a possible match is found, bartering agents then attempt to make the purchase/sale according to the user's preferences. See the group's project summary for more information <ref> [120] </ref>. * Distributed Games. A clone of the game Diplomacy was developed using II but could not be released due to licensing restrictions imposed by the owner company. Additionally, several entertaining client/server games (the card game "Spit", TRON light cycles, and the classic Pong) were constructed with the info.net package.
Reference: [121] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> 2nd edition, </address> <year> 1988. </year>
Reference-contexts: Some are not integrally tied to the object-oriented paradigm, they are either process-oriented or data-oriented. But, uniformly, all do not have the constructs necessary to describe very large and/or distributed systems. Second-Generation Methodologies. The second-generation methodologies that are generally more formal and complete include Fusion [37], Meyer <ref> [121] </ref> and the Unified Modeling Language [17, 92, 144]. Designers of these new modeling techniques incorporated constructs that assist in the specification of large-scale and/or distributed systems. <p> The following are the out-of-mainstream production languages I believe are worthwhile: Eiffel <ref> [121, 122] </ref>, Objective-C [43, 44] (the best short introduction can be found in [108], the best book on the language is [136]), Smalltalk [65, 66], and Python [112, 170, 171]. <p> Surpris DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 32 ingly, no language permits the user to specify the opposite, outbound, interface, sometimes called the "needs" interface. Only Meyer's Design by Contract <ref> [121] </ref> method and process support this two-way specification at its core. UML can be extended to support such a description, and I will provide just such an extension. * Properties and Attributes. Components that are objects have attributes that have special semantic value. These attributes are often called properties.
Reference: [122] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1992. </year>
Reference-contexts: The following are the out-of-mainstream production languages I believe are worthwhile: Eiffel <ref> [121, 122] </ref>, Objective-C [43, 44] (the best short introduction can be found in [108], the best book on the language is [136]), Smalltalk [65, 66], and Python [112, 170, 171].
Reference: [123] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1989. </year>
Reference-contexts: is the domain of the formal system specification languages. 2.2.2 Formal Component Specification Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS <ref> [123, 79] </ref>), CSP [82], SDL [25, 166], UNITY [30], VDM [97], and Z [90, 137, 152, 153, 178]. These models and their complementary languages are, for the most part, domain-specific.
Reference: [124] <author> Robin Milner, Mads Tofte, Robert Harper, and Dave MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> The MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML <ref> [38, 124, 134] </ref>, the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [125] <author> Jayadev Misra. </author> <title> A Discipline of Multiprogramming. </title> <note> Published via the web, 1996. Available as ftp://ftp.cs.utexas.edu/pub/psp/seuss/discipline.ps.Z. </note>
Reference-contexts: While expressing higher abstraction levels with new constructs is possible, it leads to a model that is overly complex and focused on the wrong levels of abstraction and core entities. Examples of retrofitted or ill-targeted models include Object-Z [48], MooZ, OOZE, Z++, VDM++ [49], Seuss <ref> [125] </ref>, and Actors. These problems necessitate the creation of a new specification language and system. Such a system must inherit most of its formalism from the traditional languages like Z and others, but it must also be grounded in modern system design and development.
Reference: [126] <editor> P. Naur and B. Randell, editors. </editor> <booktitle> Proceedings, NATO Conference on Software Engineering, </booktitle> <address> Brussels, Belgium, </address> <month> October </month> <year> 1969. </year> <institution> NATO Science Committee. </institution> <note> Published as a book in 1976. </note>
Reference-contexts: The primary technologies that help system builders manage this complexity are object-oriented and/or component-centric, and the primary tools are those that assist in system modeling and specification. 1.1 Motivation: Tackling Complexity But, nearly 30 years after their introduction <ref> [12, 162, 126] </ref>, these technological approaches only partially solve the complexity problem. They are not the final solution because large systems have hundreds, or even thousands of entities (classes, components, objects, files, computers, databases, etc.) and orders of magnitude more associations, dependencies, and relationships.
Reference: [127] <author> G. Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1991. </year>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family <ref> [127, 128, 175, 176, 173] </ref>, Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [128] <author> Inc. </author> <title> Oberon microsystems. Component pascal language report. </title> <type> Technical report, </type> <institution> Oberon microsystems, Inc., </institution> <month> September </month> <year> 1997. </year> <note> Available at http://www.oberon.ch/docu/language_ report.html. </note>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family <ref> [127, 128, 175, 176, 173] </ref>, Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [129] <editor> Object Management Group (OMG). </editor> <title> The Common Object Request Broker: Architecture and Specification (CORBA), revision 2.0. Object Management Group (OMG), </title> <address> 2.0 edition. </address>
Reference-contexts: In a distributed system, component interfaces are specified in one of four ways: Remote Invocation. The most prevalent interface specification method is procedure or method-based. Remote procedure call [156] (RPCs) have been used as a simple interface specification technique for many years. Remote method invocation <ref> [129, 179] </ref> (RMI | essentially, object-technology-centric RPCs) as a object specification technique has gained popularity with the rise in use of object-oriented languages, especially Java [158]. Events. Events are messages with extra-system semantic meaning.
Reference: [130] <institution> Ontology Markup Language (OML) DTD. </institution> <note> http://asimov.eecs.wsu.edu/WAVE/ Ontologies/OML/OML-DTD.html. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 94 </note>
Reference-contexts: XML is the emerging de facto representation format for arbitrary data and has many constructs (namespaces [18], linking [116], and pointing [117]) and instantiations (RDF [109], CKML [34], and OML <ref> [130] </ref>) and tools [53] which lend themselves to our use. To summarize, I believe that next-generation work in formal specification must use the right language (s), provide tools, include interesting and relevant "boundary" research ideas, and use the proper ground technologies and standards.
Reference: [131] <author> Andrew Paepcke, </author> <title> editor. Object-Oriented Programming: The CLOS Perspective. </title> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: While I find the development and use of "research" and out-of-mainstream languages interesting and challenging, I will not pursue the creation or use of such a language. I consider the following interesting research languages: Beta [106, 113], CLOS <ref> [14, 60, 101, 102, 131] </ref> and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [132] <author> Jens Palsberg, Cun Xiao, and Karl Lieberherr. </author> <title> Efficient implementation of adaptive software. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <year> 1995. </year>
Reference-contexts: It is very difficult to present a tightly focused, highly-specialized body of work to a general audience. Consider the Demeter method (a focused summary of Demeter's core concepts can be found in [111, Chapter 15], an annotated version of <ref> [132] </ref>). Its focus is exclusively on adaptive object-oriented software through the use of propagation patterns. Because of this tight focus, and the fact that the method uses metalevel architectures, it has not had much impact in the modeling and design communities.
Reference: [133] <author> Lawrence C. Paulson. </author> <title> Isabelle: A Generic Theorem Prover. </title> <booktitle> Number 828 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Others (e.g. UNITY, predicate calculus, OOCL, and OCL) have partial tool support; a verifier, like UV, the UNITY Verifier [98], or theorem prover or proof-checker might be available to assist an expert in system specification (e.g. Isabelle <ref> [133] </ref>, LOTOS [169]). Finally, some (UML, Demeter, the VDM family, the Z family, and the Larch family) have excellent tool support. They include generators, parsers, reusable libraries, compilers, proof-checkers, etc., and thus are excellent specification languages from a tools-oriented point of view.
Reference: [134] <author> Lawrence C. Paulson. </author> <title> ML for the Working Programmer (2nd Edition). </title> <publisher> Cambridge University Press, </publisher> <year> 1996. </year>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML <ref> [38, 124, 134] </ref>, the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [135] <author> L.L. Peterson and B.S. Davie. </author> <title> Computer Networks: A Systems Approach. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: If the communication layer cannot deliver a message, it raises an exception in the sender containing the message, the destination inbox, and the specific error condition. The system uses a sliding window protocol to manage the messages in transit <ref> [135] </ref>. The communication layer eventually handles every message at the head of an outbox. The conceptual model uses asynchronous messages rather than remote procedure calls, because the range of message latencies across the Internet makes message passing with synchronous remote procedure calls impractical.
Reference: [136] <author> L.J. Pinson and R.S. Wiener. Objective-C: </author> <title> Object-Oriented Programming Techniques. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1991. </year>
Reference-contexts: The following are the out-of-mainstream production languages I believe are worthwhile: Eiffel [121, 122], Objective-C [43, 44] (the best short introduction can be found in [108], the best book on the language is <ref> [136] </ref>), Smalltalk [65, 66], and Python [112, 170, 171]. The adoption of a more "main-line" programming language that fulfills most of our needs will result in a body of work that can potentially influence a large number of practicianers.
Reference: [137] <author> Ben Potter, Jane Sinclair, and David Till. </author> <title> An Introduction to Formal Specification and Z. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1991. </year>
Reference-contexts: Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL [25, 166], UNITY [30], VDM [97], and Z <ref> [90, 137, 152, 153, 178] </ref>. These models and their complementary languages are, for the most part, domain-specific. In particular Actors and UNITY have been proposed as a general purpose models for the specification and validation of concurrent and distributed systems. <p> I will discuss these requirements in more detail after providing an example of the range of formalism in use today. 2.3 Examples: From the Informal to the Formal For an example, I'll consider the general specification technique Use-Cases [94] and the formal specification language Z <ref> [137] </ref>. Use-Cases is extremely simple to learn and use, thus it is widely adopted in industry. Z complex and formal, thus is rarely used anywhere, even in academic circles. 2.3.1 Use-Case Modeling Use-Case modeling is a specification technique for describing a system at a very high abstraction level.
Reference: [138] <author> Ravi Ramamoorthi, Adam Rifkin, Boris Dimitrov, and K. Mani Chandy. </author> <title> A general resource reservation framework for scientific computing. </title> <booktitle> In Proceedings of the First International Scientific Computing in Object-Oriented Parallel Environments (ISCOPE) Conference, </booktitle> <month> December </month> <year> 1997. </year>
Reference-contexts: A global resource reservation tool was built that integrates a Tk/Tcl front-end with a Java/II back end to provide the user with an interactive interface for reserving slots on geographically distributed supercomputers with individual resource reservation schemes. See <ref> [138] </ref> for more information. * JEDI: A research framework for developing client-server systems. The JEDI system lets a developer build client-server systems without having to go through the process of stub/skeleton compilation. See [6] for more information. * SimulEdit: A peer-to-peer distributed editor.
Reference: [139] <institution> Rational Software Corporation. Rational ROSE. </institution> <note> http://www.rational.com/products/ rose/. </note>
Reference-contexts: They include generators, parsers, reusable libraries, compilers, proof-checkers, etc., and thus are excellent specification languages from a tools-oriented point of view. More users will be inclined to try out a specification language if it includes a tool that helps them get their job done. (Examples include: Rational Rose <ref> [139] </ref>; the Demeter Tools [85]; DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 10 IFAD VDM-SL Toolbox [89]; Cogito [13]; LP, the Larch Prover [62], LSL, the Larch Shared Language [73], and LCLint, a tools used for statically checking annotated C programs [51] built with Larch).
Reference: [140] <author> Tom S. Ray. </author> <title> An evolutionary approach to synthetic biology: Zen and the art of creating life. </title> <journal> Artificial Life, </journal> 1(1/2):195-226, 1994. 
Reference-contexts: Emergence. Systems not only change over time, but can exhibit behaviors that were not originally part of the system's original design. Such emergent behavior is unsurprising in some systems. Corporations, intentional non-deterministic or random systems, and artificially designed, evolvable simulations, like Tom Ray's Tierra <ref> [140] </ref> commonly exhibit surprising behavior [99, 100]. But a system like the World Wide Web, very simple at its core but complex in its scope, application, and degree of growth, is not expected to evidence such evolving behavior.
Reference: [141] <author> M. Reiser and Niklaus Wirth. </author> <title> Programming in Oberon: Steps Beyond Pascal and Modula. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1992. </year>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon <ref> [141, 177] </ref>, Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [142] <author> James Rumbaugh and Stephen Blaha. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1991. </year>
Reference-contexts: The leading first-generation informal and semi-informal system methodologies include Booch [15, 16], Coad-Yourdon [35, 36], Martin/Odell [118, 119], OOSE/- Objectory [93, 94], Rumbaugh <ref> [142, 143] </ref>, Shlaer-Mellor [148, 149], Syntropy [39], and Wirfs-Brock [174]. These methodologies focused primarily on building small to medium scale (up to hundreds of classes) object-oriented systems. Some are not integrally tied to the object-oriented paradigm, they are either process-oriented or data-oriented.
Reference: [143] <author> Jim Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, Bill Lorensen, and William Lorenson. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1991. </year>
Reference-contexts: The leading first-generation informal and semi-informal system methodologies include Booch [15, 16], Coad-Yourdon [35, 36], Martin/Odell [118, 119], OOSE/- Objectory [93, 94], Rumbaugh <ref> [142, 143] </ref>, Shlaer-Mellor [148, 149], Syntropy [39], and Wirfs-Brock [174]. These methodologies focused primarily on building small to medium scale (up to hundreds of classes) object-oriented systems. Some are not integrally tied to the object-oriented paradigm, they are either process-oriented or data-oriented. <p> Each of these individuals brought their own perspective and modeling language and process to the table. Booch developed the previously mentioned Booch method [15], Rumbaugh's language is called the Object Modeling Technique (OMT) <ref> [143] </ref>, and Jacobson's language and process are called OOSE/Objectory [93]. Additionally, several other companies, individuals, and methods influenced the development of UML. One of the most influential methods is called Catalysis, and is considered one of the leading-edge methods available today 1 .
Reference: [144] <author> Jim Rumbaugh, Ivar Jacobson, and Grady Booch. </author> <title> Unified Modeling Language Reference Manual. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1997. </year>
Reference-contexts: But, uniformly, all do not have the constructs necessary to describe very large and/or distributed systems. Second-Generation Methodologies. The second-generation methodologies that are generally more formal and complete include Fusion [37], Meyer [121] and the Unified Modeling Language <ref> [17, 92, 144] </ref>. Designers of these new modeling techniques incorporated constructs that assist in the specification of large-scale and/or distributed systems. Additionally, these methods are capable of a DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 5 more formal specification of system components.
Reference: [145] <author> Douglas C. Schmidt and Steve Vinoski. </author> <title> OMG event object service. </title> <journal> SIGS, </journal> <volume> 9(2), </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: Events. Events are messages with extra-system semantic meaning. Events are gaining popularity as a general-purpose communication framework, especially in publish-subscribe and push technologies <ref> [32, 78, 105, 110, 145, 154] </ref>. Message-Passing. Specification with respect to a component's sending and receiving messages is an alternative technique [31, 33, 52, 81]. State-Space Operations.
Reference: [146] <author> Peter Senge. </author> <title> The Fifth Discipline, The Art and Practice of Learning Organization. </title> <publisher> Doubleday, </publisher> <year> 1990. </year>
Reference-contexts: The newest version of OOCL (version 2.0), is a major method update with new features including the ability to model self-organizing, complex adaptive systems (CAS). For more information on the work underlying the OOCL method, see <ref> [83, 84, 146, 147, 161] </ref>. For a quick summary of OOCL, see [5, 160, 163]. OOCL introduces a number of new modeling constructs to help specify such dynamic system. These elements include: * Agent. An agent is an entity responsible for a set of tasks. * Organization.
Reference: [147] <editor> Peter Senge et al. </editor> <booktitle> The Fifth Discipline Fieldbook. </booktitle> <publisher> Doubleday, </publisher> <year> 1994. </year> <title> DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, </title> <year> 1998 </year> <month> 95 </month>
Reference-contexts: The newest version of OOCL (version 2.0), is a major method update with new features including the ability to model self-organizing, complex adaptive systems (CAS). For more information on the work underlying the OOCL method, see <ref> [83, 84, 146, 147, 161] </ref>. For a quick summary of OOCL, see [5, 160, 163]. OOCL introduces a number of new modeling constructs to help specify such dynamic system. These elements include: * Agent. An agent is an entity responsible for a set of tasks. * Organization.
Reference: [148] <author> Sally Shlaer and Steven Mellor. </author> <title> Object-Oriented Systems Analysis: Modeling the World in Data. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1988. </year>
Reference-contexts: The leading first-generation informal and semi-informal system methodologies include Booch [15, 16], Coad-Yourdon [35, 36], Martin/Odell [118, 119], OOSE/- Objectory [93, 94], Rumbaugh [142, 143], Shlaer-Mellor <ref> [148, 149] </ref>, Syntropy [39], and Wirfs-Brock [174]. These methodologies focused primarily on building small to medium scale (up to hundreds of classes) object-oriented systems. Some are not integrally tied to the object-oriented paradigm, they are either process-oriented or data-oriented. <p> The original system modeling languages were not object-oriented, they were either data-oriented or behavior-oriented. Languages from both domains evolved and were incorporated into object-oriented modeling languages. Understandably, the bias of their origins can be seen in this transition. 3.2 Historical Opposites: Booch and Shlaer-Mellor The Booch [15] and Shlaer-Mellor <ref> [148] </ref> object-oriented methodologies are the historic archetypes of behavior and data-oriented methodologies. Booch is a behavior-oriented model, Shlaer-Mellor is a data-oriented model.
Reference: [149] <author> Sally Shlaer and Steven Mellor. </author> <title> Object Life Cycles: Modeling the World in State. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1991. </year>
Reference-contexts: The leading first-generation informal and semi-informal system methodologies include Booch [15, 16], Coad-Yourdon [35, 36], Martin/Odell [118, 119], OOSE/- Objectory [93, 94], Rumbaugh [142, 143], Shlaer-Mellor <ref> [148, 149] </ref>, Syntropy [39], and Wirfs-Brock [174]. These methodologies focused primarily on building small to medium scale (up to hundreds of classes) object-oriented systems. Some are not integrally tied to the object-oriented paradigm, they are either process-oriented or data-oriented.
Reference: [150] <author> Oliver Sims. </author> <title> Business Objects: Delivering Cooperative Objects for Client-Server. </title> <publisher> McGraw-Hill, </publisher> <year> 1994. </year>
Reference-contexts: I will discuss such associations in a bit more detail in Section 3.4.6. An example of such an association is two objects sharing knowledge which is utilized to realize a communication mechanism, such as Sims' SDOs <ref> [150] </ref>. * Persistent association. (tpersistent ) The persistent association is an association which lasts across life-cycles of the participating entities. <p> 10,841 Grand total ratio (comments/code) 39% Table 4.1: A summary of the II 1.0 implementation size and internal documentation DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 80 To uncouple these dependencies, I suggest the use of a semantic messaging infrastructure, similar to that proposed by Sims in <ref> [150] </ref> 3 . Such a change would not only decouple the communicating components, but would again reduce the code size by another few thousand lines. 4.5.4 Infrastructure Impact Versions of the II have been downloaded by schools, companies, research labs, and others.
Reference: [151] <author> Brian C. Smith. </author> <title> Reflection and semantics in LISP. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 23-35. </pages> <publisher> ACM, </publisher> <year> 1984. </year>
Reference-contexts: Meta-Levels. "Meta" levels of system design and development are gaining attention for their expressive and descriptive power. Such constructs and theories include metaobject protocols [102], aspects [103], subject-oriented programming [77], and reflection <ref> [114, 151] </ref>. A complete methodology must be able to capture all of the meta levels of the system being modeled. Components. Component architectures are at the root of most software development today.
Reference: [152] <author> J.M. Spivey. </author> <title> Understanding Z: A Specification Language and its Formal Semantics, </title> <booktitle> volume 3 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1988. </year>
Reference-contexts: The reader should be familiar with the Unified Modeling Language and at least one formal specification language. Suggested references include [42] and [50, Chapter 2] for UML, and [20, Chapter 6] for a specification language (in this case, Z <ref> [152] </ref>). In Chapter 2, I will discuss the general problem of systems and component specification in more detail. Next, in Chapter 3, I will describe some of our extensions to an existing system-level specification methodology. <p> Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL [25, 166], UNITY [30], VDM [97], and Z <ref> [90, 137, 152, 153, 178] </ref>. These models and their complementary languages are, for the most part, domain-specific. In particular Actors and UNITY have been proposed as a general purpose models for the specification and validation of concurrent and distributed systems.
Reference: [153] <author> J.M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1992. </year>
Reference-contexts: Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL [25, 166], UNITY [30], VDM [97], and Z <ref> [90, 137, 152, 153, 178] </ref>. These models and their complementary languages are, for the most part, domain-specific. In particular Actors and UNITY have been proposed as a general purpose models for the specification and validation of concurrent and distributed systems.
Reference: [154] <author> G. Starovic, V. Cahill, and B. Tangney. </author> <title> An event-based object model for distributed programming. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Dublin, Trinity College, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: Events. Events are messages with extra-system semantic meaning. Events are gaining popularity as a general-purpose communication framework, especially in publish-subscribe and push technologies <ref> [32, 78, 105, 110, 145, 154] </ref>. Message-Passing. Specification with respect to a component's sending and receiving messages is an alternative technique [31, 33, 52, 81]. State-Space Operations.
Reference: [155] <author> Guy Steele. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> 2nd edition, </address> <year> 1990. </year>
Reference-contexts: While I find the development and use of "research" and out-of-mainstream languages interesting and challenging, I will not pursue the creation or use of such a language. I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and <ref> [155, Chapter 28] </ref>, Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [156] <editor> W.R. Stevens. TCP/IP Illustrated, </editor> <volume> Volume 1. </volume> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1994. </year>
Reference-contexts: In a distributed system, component interfaces are specified in one of four ways: Remote Invocation. The most prevalent interface specification method is procedure or method-based. Remote procedure call <ref> [156] </ref> (RPCs) have been used as a simple interface specification technique for many years. Remote method invocation [129, 179] (RMI | essentially, object-technology-centric RPCs) as a object specification technique has gained popularity with the rise in use of object-oriented languages, especially Java [158]. Events.
Reference: [157] <author> Thomas Streicher. </author> <title> Semantics of Type Theory: Correctness, Completeness, and Independence Results. </title> <address> Birkhduser, </address> <year> 1991. </year>
Reference-contexts: DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 42 * Type. A type is a metaclassifier for classes and objects (as per type theory; see <ref> [7, 8, 64, 72, 157, 165] </ref>). In some languages, like C++, type and class are equivalent. * Kind. A kind is a semantic metaclassifier for types. See Section 3.4.6 for more information on kinds. * Metalevels.
Reference: [158] <author> Sun Microsystems, Inc. </author> <title> Java Remote Method Invocation Specification. Sun Microsystems, </title> <publisher> Inc., </publisher> <address> 1.2beta1 edition, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: Remote procedure call [156] (RPCs) have been used as a simple interface specification technique for many years. Remote method invocation [129, 179] (RMI | essentially, object-technology-centric RPCs) as a object specification technique has gained popularity with the rise in use of object-oriented languages, especially Java <ref> [158] </ref>. Events. Events are messages with extra-system semantic meaning. Events are gaining popularity as a general-purpose communication framework, especially in publish-subscribe and push technologies [32, 78, 105, 110, 145, 154]. Message-Passing. Specification with respect to a component's sending and receiving messages is an alternative technique [31, 33, 52, 81].
Reference: [159] <author> Sun Microsystems, Inc. </author> <title> JavaBeans API specification, version 1.01. </title> <type> Technical report, </type> <institution> Sun Microsystems, Inc., </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: Components that are objects have attributes that have special semantic value. These attributes are often called properties. Examples of properties and their related semantics can be seen in the JavaBeans <ref> [159] </ref> component model. UML does have properties defined as base constructs; they are used to extend the language. These properties can be mapped to the properties of component software, but lack the additional semantics that standard properties have in component software.
Reference: [160] <author> Edward Swanstrom. OOCL Workbook. Agilis Corporation, </author> <year> 1997. </year>
Reference-contexts: The newest version of OOCL (version 2.0), is a major method update with new features including the ability to model self-organizing, complex adaptive systems (CAS). For more information on the work underlying the OOCL method, see [83, 84, 146, 147, 161]. For a quick summary of OOCL, see <ref> [5, 160, 163] </ref>. OOCL introduces a number of new modeling constructs to help specify such dynamic system. These elements include: * Agent. An agent is an entity responsible for a set of tasks. * Organization. An organization is a group of agents working toward a common goal. * Constellation.
Reference: [161] <author> Edward Swanstrom. </author> <title> Creating Agile Organizations with the OOCL Method. </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1998. </year> <note> See http://www.agiliscorp.com/ooclforum.html and http://www. agiliscorp.com/oocldraft/. </note>
Reference-contexts: VDM [11]). At the "macroscopic" end of the scale, there are specification languages for describing entire huge, dynamic, and complex systems, like corporate entities (e.g. OOCL <ref> [161] </ref>). This granularity of specification, the abstraction level, influences the kinds of things that can be described. A language that attempts to cover too many levels is likely to be overly ambiguous or complex. <p> Third-Generation Methodologies. Finally, third-generation languages, now emerging from the modeling community, show further refinement. They incorporate ideas and terminology from cognitive science, knowledge engineering and representation, and information theory. These new techniques include Catalysis [47], Demeter [111], and Object-Oriented Change and Learning (OOCL) <ref> [161] </ref>. Due to the integration of ideas from these domains, these new techniques are very powerful and flexible. Cataysis. Catalysis, from Desmond D'Souza and Alan Wills, is the most "normal" of the third-generation languages. <p> Finally, there exist some new methods that are outside the mainstream. While they often use UML as a syntactic base, they introduce new concepts, constructs, and techniques to system modeling. One of these new-generation languages is OOCL <ref> [161] </ref>. We'll briefly discuss these three leading methods, highlighting their strengths and weaknesses. Then I will introduce a set of new modeling constructs and diagrams which can be added to any modeling language to improve its expressiveness and capability. <p> The newest version of OOCL (version 2.0), is a major method update with new features including the ability to model self-organizing, complex adaptive systems (CAS). For more information on the work underlying the OOCL method, see <ref> [83, 84, 146, 147, 161] </ref>. For a quick summary of OOCL, see [5, 160, 163]. OOCL introduces a number of new modeling constructs to help specify such dynamic system. These elements include: * Agent. An agent is an entity responsible for a set of tasks. * Organization. <p> It exhibits the same limitations as Catalysis and UML. OOCL is not yet available in full for public review; <ref> [161] </ref> is still under development. When the full language definition becomes available, I will evaluate the capability and appropriateness of OOCL as a ground modeling language.
Reference: [162] <author> Clemens Szyperski. </author> <title> Component Software: Beyond Object-Oriented Programming. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1997. </year>
Reference-contexts: The primary technologies that help system builders manage this complexity are object-oriented and/or component-centric, and the primary tools are those that assist in system modeling and specification. 1.1 Motivation: Tackling Complexity But, nearly 30 years after their introduction <ref> [12, 162, 126] </ref>, these technological approaches only partially solve the complexity problem. They are not the final solution because large systems have hundreds, or even thousands of entities (classes, components, objects, files, computers, databases, etc.) and orders of magnitude more associations, dependencies, and relationships.
Reference: [163] <author> PLATINUM technology, Veronica Bowman, Edward Swanstrom, et al. </author> <title> Paradigm Plus: Methods Manual Addendum (OOCL). PLATINUM technology, </title> <address> 3.52 edition, </address> <year> 1997. </year>
Reference-contexts: A simple example statechart is provided in Figure 3.2. A more complex statechart can be seen in Figure 3.3 2 Several figures in this document are adopted from, or modifications of, a variety of sources including <ref> [163, 88, 41, 40, 47] </ref>. DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 16 DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 17 Activity Diagram. <p> The newest version of OOCL (version 2.0), is a major method update with new features including the ability to model self-organizing, complex adaptive systems (CAS). For more information on the work underlying the OOCL method, see [83, 84, 146, 147, 161]. For a quick summary of OOCL, see <ref> [5, 160, 163] </ref>. OOCL introduces a number of new modeling constructs to help specify such dynamic system. These elements include: * Agent. An agent is an entity responsible for a set of tasks. * Organization. An organization is a group of agents working toward a common goal. * Constellation. <p> There are also level three and four knowledge and processes related to improving the team, division, or organization. Providing examples of each of the above diagrams and graphs would take up too much space for this body of work. We suggest <ref> [5, 163] </ref> for summaries and examples of all of the diagrams. OOCL also evolves and introduces new concepts to system modeling. The primary "evolved" traditional concepts at the heart of OOCL is the business object dictionary, an evolution of the data and class dictionaries of other methods.
Reference: [164] <author> Louis Thomas, Sean Suchter, and Adam Rifkin. </author> <title> Developing peer-to-peer applications on the Internet: The distributed editor, </title> <journal> SimulEdit. Dr. Dobb's Journal, </journal> <year> 1997. </year>
Reference-contexts: The JEDI system lets a developer build client-server systems without having to go through the process of stub/skeleton compilation. See [6] for more information. * SimulEdit: A peer-to-peer distributed editor. SimulEdit is an editor that lets users join and leave an editing session dynamically and is fault tolerant. See <ref> [164] </ref> for more information. * DALI: A distributed artificial life simulator infrastructure. This system lets the user construct an distributed asynchronous simulation system for simulating artificial life systems (genomes specify behavior, speciation, pack behavior, etc.).
Reference: [165] <author> Simon Thompson. </author> <title> Type Theory and Functional Programming. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1991. </year> <title> DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, </title> <year> 1998 </year> <month> 96 </month>
Reference-contexts: DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, 1998 42 * Type. A type is a metaclassifier for classes and objects (as per type theory; see <ref> [7, 8, 64, 72, 157, 165] </ref>). In some languages, like C++, type and class are equivalent. * Kind. A kind is a semantic metaclassifier for types. See Section 3.4.6 for more information on kinds. * Metalevels.
Reference: [166] <author> Kenneth J. Turner, </author> <title> editor. Using Formal Description Techniques: An Introduction to Estelle, LOTOS, and SDL. Wiley Series in Communication and Distributed Systems. </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1993. </year>
Reference-contexts: formal system specification languages. 2.2.2 Formal Component Specification Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL <ref> [25, 166] </ref>, UNITY [30], VDM [97], and Z [90, 137, 152, 153, 178]. These models and their complementary languages are, for the most part, domain-specific. In particular Actors and UNITY have been proposed as a general purpose models for the specification and validation of concurrent and distributed systems.
Reference: [167] <author> D. Ungar, C. Chambers, B.-W. Chang, and U. Holzle. </author> <title> Organizing programs without classes. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 4(3) </volume> <pages> 223-242, </pages> <year> 1991. </year>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self <ref> [2, 167, 168] </ref>, Simula [12, 45], and Squeak [91].
Reference: [168] <author> D. Ungar and R. B. Smith. </author> <title> Self: The power of simplicity. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 4(3) </volume> <pages> 187-205, </pages> <year> 1991. </year>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon [141, 177], Obliq [23, 24], Self <ref> [2, 167, 168] </ref>, Simula [12, 45], and Squeak [91].
Reference: [169] <author> P.H.J. van Eijk, C.A. Vissers, and M. Diaz, </author> <title> editors. The Formal Description Technique LO-TOS. </title> <publisher> Elsevier Science, Inc., </publisher> <year> 1989. </year>
Reference-contexts: Others (e.g. UNITY, predicate calculus, OOCL, and OCL) have partial tool support; a verifier, like UV, the UNITY Verifier [98], or theorem prover or proof-checker might be available to assist an expert in system specification (e.g. Isabelle [133], LOTOS <ref> [169] </ref>). Finally, some (UML, Demeter, the VDM family, the Z family, and the Larch family) have excellent tool support. They include generators, parsers, reusable libraries, compilers, proof-checkers, etc., and thus are excellent specification languages from a tools-oriented point of view.
Reference: [170] <author> Guido van Rossum. </author> <title> Python reference manual. </title> <type> Technical Report 1.5, </type> <institution> Corporation for National Research Initiatives, </institution> <month> December </month> <year> 1997. </year> <note> Available at http://www.python.org/doc/ref/. </note>
Reference-contexts: The following are the out-of-mainstream production languages I believe are worthwhile: Eiffel [121, 122], Objective-C [43, 44] (the best short introduction can be found in [108], the best book on the language is [136]), Smalltalk [65, 66], and Python <ref> [112, 170, 171] </ref>. The adoption of a more "main-line" programming language that fulfills most of our needs will result in a body of work that can potentially influence a large number of practicianers.
Reference: [171] <author> Aaron Watters, Guido van Rossum, and James C. Ahlstrom. </author> <title> Internet Programming with Python. </title> <publisher> IDG Books, </publisher> <year> 1996. </year>
Reference-contexts: The following are the out-of-mainstream production languages I believe are worthwhile: Eiffel [121, 122], Objective-C [43, 44] (the best short introduction can be found in [108], the best book on the language is [136]), Smalltalk [65, 66], and Python <ref> [112, 170, 171] </ref>. The adoption of a more "main-line" programming language that fulfills most of our needs will result in a body of work that can potentially influence a large number of practicianers.
Reference: [172] <author> Peter Wegner. </author> <title> Interactive foundations of computing. </title> <address> http://www.cs.brown.edu/people/ pw/papers/finaltcs.ps, </address> <year> 1997. </year>
Reference-contexts: Modern system components change over time; they are replaced, they change behavior, they change location, etc. Additionally, the system changes over time as it responds to the changing demands. The forces behind the dynamism, much like Wegner's interactive systems' stimuli <ref> [172] </ref>, are placed upon it by other systems, users, customers, etc. Emergence. Systems not only change over time, but can exhibit behaviors that were not originally part of the system's original design. Such emergent behavior is unsurprising in some systems.
Reference: [173] <author> R.S. Wiener. </author> <title> Programming with object-pascal, pascal 5.5 from borland international. </title> <journal> SIGSnet Journal of Object-Oriented Programming, </journal> <volume> 2(2) </volume> <pages> 62-65, </pages> <month> July/August </month> <year> 1989. </year>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family <ref> [127, 128, 175, 176, 173] </ref>, Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [174] <author> Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener. </author> <title> Designing Object-Oriented Software. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1990. </year>
Reference-contexts: The leading first-generation informal and semi-informal system methodologies include Booch [15, 16], Coad-Yourdon [35, 36], Martin/Odell [118, 119], OOSE/- Objectory [93, 94], Rumbaugh [142, 143], Shlaer-Mellor [148, 149], Syntropy [39], and Wirfs-Brock <ref> [174] </ref>. These methodologies focused primarily on building small to medium scale (up to hundreds of classes) object-oriented systems. Some are not integrally tied to the object-oriented paradigm, they are either process-oriented or data-oriented. But, uniformly, all do not have the constructs necessary to describe very large and/or distributed systems.
Reference: [175] <author> Niklaus Wirth. </author> <title> The programming language PASCAL. </title> <journal> Acta Informatica, </journal> <volume> 1 </volume> <pages> 35-63, </pages> <year> 1971. </year>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family <ref> [127, 128, 175, 176, 173] </ref>, Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [176] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family <ref> [127, 128, 175, 176, 173] </ref>, Oberon [141, 177], Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [177] <author> Niklaus Wirth and J. Gutknecht. </author> <title> Project Oberon | The Design of an Operating System and Compiler. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1992. </year>
Reference-contexts: I consider the following interesting research languages: Beta [106, 113], CLOS [14, 60, 101, 102, 131] and [155, Chapter 28], Dylan [9], ML [38, 124, 134], the Pascal/Modula family [127, 128, 175, 176, 173], Oberon <ref> [141, 177] </ref>, Obliq [23, 24], Self [2, 167, 168], Simula [12, 45], and Squeak [91].
Reference: [178] <author> Jim Woodcock and Jim Davies. </author> <title> Using Z: Specification, Refinement, and Proof. </title> <booktitle> Prentice-Hall International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <year> 1996. </year>
Reference-contexts: Languages Some of the leading formal models and languages for component specification include the Actor model [4, 3, 58, 80], Actor Algebras [63], the Larch language and system [73], OCL [88], Predicate Calculus [46], Process Algebras (CCS [123, 79]), CSP [82], SDL [25, 166], UNITY [30], VDM [97], and Z <ref> [90, 137, 152, 153, 178] </ref>. These models and their complementary languages are, for the most part, domain-specific. In particular Actors and UNITY have been proposed as a general purpose models for the specification and validation of concurrent and distributed systems.
Reference: [179] <author> J.H. Wright. </author> <title> A reference model for object-oriented distributed systems. </title> <journal> British Telecom Technology Journal, </journal> <volume> 6(3) </volume> <pages> 66-75, </pages> <year> 1988. </year>
Reference-contexts: In a distributed system, component interfaces are specified in one of four ways: Remote Invocation. The most prevalent interface specification method is procedure or method-based. Remote procedure call [156] (RPCs) have been used as a simple interface specification technique for many years. Remote method invocation <ref> [129, 179] </ref> (RMI | essentially, object-technology-centric RPCs) as a object specification technique has gained popularity with the rise in use of object-oriented languages, especially Java [158]. Events. Events are messages with extra-system semantic meaning.
Reference: [180] <author> Daniel M. Zimmerman. </author> <title> A preliminary investigation into dynamic distributed workflow. </title> <type> Technical Report CS-TR-98-09, </type> <institution> Department of Computer Science, California Institute of Technology, </institution> <year> 1998. </year>
Reference-contexts: A session can negotiate with the underlying communication layer to determine the most appropriate process-to-process mechanism. While the current framework supports only UDP and native Java messaging layers (like RMI), the incorporation of alternative communication layers, like Ubernet <ref> [180] </ref>, iBus [115], Java ACE [95], or JSDA [21] is straightforward. 4.4 The Infospheres Infrastructure: Specification I will provide a detailed specification of only one core subsystem (info.djinn) of II 1.0 here due to space considerations. <p> From the experience we gained in using this debug package, we designed and this author implemented a new, general-purpose distributed debugging package for Java which is being used extensively in the development of II 2.0 and Dan Zimmerman's UberNet <ref> [180] </ref>. 4.5.2 Implementation Size For such a comprehensive framework, the implementation of II 1.0 is surprisingly small. Table 4.1 shows the summary of the implementation size and comment ratios, as provided by the CommentCounter 2 tool written by this author.
Reference: [181] <author> Daniel M. Zimmerman, Brian Rothstein, Yevgeniy Kaganovich, and Khai Pham. </author> <title> Constructing client-server multi-player asynchronous games using a single-computer model. </title> <booktitle> In Proceedings of IASTED, International Conference on Software Engineering, </booktitle> <month> November </month> <year> 1997. </year> <title> DRAFT NOT FOR DISTRIBUTION 10 : 43 July 12, </title> <year> 1998 </year>
Reference-contexts: A clone of the game Diplomacy was developed using II but could not be released due to licensing restrictions imposed by the owner company. Additionally, several entertaining client/server games (the card game "Spit", TRON light cycles, and the classic Pong) were constructed with the info.net package. See <ref> [181] </ref> for more information. Further example system implementation will take place on top of II 2.0, expected to be available in third quarter of 1998.
References-found: 181

