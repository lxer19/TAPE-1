URL: http://www.cs.toronto.edu/~avigal/pau.ps
Refering-URL: http://www.cs.toronto.edu/~avigal/publications.html
Root-URL: http://www.cs.toronto.edu
Email: Email: favigal, ieretzng@ie.technion.ac.il  
Title: A Parallel Execution Model for Updating Temporal Databases  
Author: Avigdor Gal, Opher Etzion 
Note: The work of this author was supported by the H. Kieval Research Fund.  
Address: Haifa, 32000, Israel  
Affiliation: Technion Israel Institute of Technology Faculty of Industrial Engineering and Management Information Systems Department  
Abstract: A parallel execution model for the update process of temporal databases is introduced in this paper, based on temporal parallelism and temporal independence. The parallel approach improves the throughput of massive and complex updates of a multi-version schema system. The notion of temporal agents and its effect on parallelism is discussed, as well as different transaction modes. Several simulation results that present the benefits of the parallel execution model are introduced and discussed. keywords: temporal databases, parallel processing, schema versioning.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Abbod, K. Brown, and H. Noble. </author> <title> Providing time-related constraints for conventional database systems. </title> <booktitle> In Proceedings of the 13th International Conference on VLDB, </booktitle> <pages> pages 167-175, </pages> <address> Brighton, </address> <year> 1987. </year>
Reference-contexts: Thus, we assume that each variable has the temporal characteristics. 5 class= Person properties= Social-Security-Number Name Address: House-Number Street City Zipcode State class= Meta-Data-Changes properties= Change-Code-Number Property-Name Property-Structure Address.Zipcode= (s1) 12345, Dec 1 1990, Dec 1 1990, <ref> [Dec 1 1990; 1] </ref> (s3) 1w2zk, June 5 1993; | -z - June 4 1993; | -z - [Sep 1 1991; 1] t v A variable with temporal extension consists of a variable-state set fse 1 ; : : : ; se n g of n state-elements. <p> variable has the temporal characteristics. 5 class= Person properties= Social-Security-Number Name Address: House-Number Street City Zipcode State class= Meta-Data-Changes properties= Change-Code-Number Property-Name Property-Structure Address.Zipcode= (s1) 12345, Dec 1 1990, Dec 1 1990, [Dec 1 1990; 1] (s3) 1w2zk, June 5 1993; | -z - June 4 1993; | -z - <ref> [Sep 1 1991; 1] </ref> t v A variable with temporal extension consists of a variable-state set fse 1 ; : : : ; se n g of n state-elements. <p> A1: The database is an append only database. New information is added, while existing information is left intact. The append only approach is necessary to support operations that require past database states. Unlike some other models that assume an append-only database (e.g., <ref> [1] </ref>), we use this assumption in the strictest fashion, i.e., no changes can be made to a state-element after the transaction that generated it has committed. <p> Others (e.g., [19]) expanded the modify operation to include meta-data, thus allowing schema evolution in time, as well as data evolution. Some studies ([18]; [27]; <ref> [1] </ref>; [25]) distinguished a modification from a correction. Modifying a data is carried out when the situation in the real world has changed. Correcting a data is carried out because an error in the existing data has been detected.
Reference: [2] <author> J. Banerjee, H.T. Chou, H.J. Kim, and H.F. Korth. </author> <title> Semantics and implementation of schema evolution in object-oriented database. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 16(3) </volume> <pages> 311-322, </pages> <year> 1987. </year> <booktitle> ACM SIGMOD conference. </booktitle>
Reference-contexts: The latter, however, failed to use the valid time along with the transaction time, and by that disallowing retroactive and proactive updates. Data conversion, as a result of a change in the schema is discussed in several papers, including [22], [28] 21 and <ref> [2] </ref>. None of these works approached the update complexity problem. 5.3 Updating temporal databases Most of the related work of updating temporal database remained within the conventional database operation types of insert, modify or delete while giving these operations slightly different meaning.
Reference: [3] <author> H. Boral and D.J. DeWitt. </author> <title> Database machines: an idea whose time has passed? a critique of the future of database machines. </title> <booktitle> In International workshop on Database Machines, </booktitle> <address> Munich, </address> <year> 1983. </year>
Reference-contexts: types of applications [14]. 5 Related work In this section we present works in related research areas, namely, parallel processing, schema evolution and updates in temporal databases. 20 5.1 Parallelism in databases Parallel processing technologies are used in the database systems area as a general solution of the I/O bottleneck <ref> [3] </ref>, influenced by high disk access time with respect to main memory access time. The proposed general solution is "increasing the I/O bandwidth through parallelism" [30].
Reference: [4] <author> U.S. Chakravarthy and J. Minker. </author> <title> Processing multiple queries in database systems. </title> <journal> Database Engineering, </journal> <volume> 5(3) </volume> <pages> 38-44, </pages> <month> Sept. </month> <year> 1982. </year> <month> 25 </month>
Reference-contexts: Intraquery parallelism allows a parallel execution of operations within the same query, and intraoperation parallelism permits an operation to be partitioned to suboperations using function partitioning. An example of the latter type is the parallel join operation [5]. The subject of parallel query processing has been researched by <ref> [4] </ref>, [17], [26] and others in the areas of relational databases and deductive databases. The work presented in this paper is aimed at providing an appropriate mechanism for updating temporal databases by taking advantage of parallel database systems and enabling intraoperation parallelism.
Reference: [5] <author> D.J. DeWitt and R. Gerber. </author> <title> Multiprocessor join algorithms. </title> <booktitle> In International Conference of VLDB, </booktitle> <address> Stockholm, </address> <year> 1985. </year>
Reference-contexts: Intraquery parallelism allows a parallel execution of operations within the same query, and intraoperation parallelism permits an operation to be partitioned to suboperations using function partitioning. An example of the latter type is the parallel join operation <ref> [5] </ref>. The subject of parallel query processing has been researched by [4], [17], [26] and others in the areas of relational databases and deductive databases.
Reference: [6] <author> D.J. Dewitt and J. Gray. </author> <title> Parallel database systems: the future of high performance database systems. </title> <journal> Communications of the ACM, </journal> <volume> 35(6) </volume> <pages> 85-98, </pages> <year> 1992. </year>
Reference-contexts: One of the possible solutions to this problem is the use of parallel processing for database updates. Consequently, there is a growing need for tools that take advantage of parallel database systems <ref> [6] </ref>. In this paper we present an execution model that is based on parallel processing as a solution for the performance problem in temporal database updates. The execution model supports all the update execution model features in conventional databases, and additional three features, as follows.
Reference: [7] <author> R. Elmasri and G. Wuu. </author> <title> A temporal model and query language for ER database. </title> <booktitle> In Proceedings of the International Conference on Data Engineering, </booktitle> <pages> pages 76-83, </pages> <month> Feb </month> <year> 1990. </year>
Reference-contexts: In the example given above, if the employee's promotion is effective only as of January 1995, the database proactively updates the new rank's value to be valid during [Jan 1995, Jan 1996). In many temporal databases (e.g., <ref> [7] </ref>) this requirement is omitted 2 since past information cannot be altered and future information cannot be modeled. Schema versioning considerations: The ability of temporal databases to respond to changes in the modeled reality stems from its capability to support meta-data (schema) changes in addition to data changes. <p> Modify This operation adds new information about an existing object. For example, on November 11 1991 the zipcode of John Doe has been changed to "12445" as of January 1 1992. The database modifies the Zipcode variable, keeping the old values as well. As argued by some researchers (e.g., <ref> [7] </ref>), the modification of an object value in a temporal database changes the value in a given interval while keeping the earlier historical values of the object. This is different from modification of an object value in non-temporal databases in which the new value replaces the previous one. <p> None of these works approached the update complexity problem. 5.3 Updating temporal databases Most of the related work of updating temporal database remained within the conventional database operation types of insert, modify or delete while giving these operations slightly different meaning. For example, according to some researchers (e.g., <ref> [7] </ref>) the difference between updates in temporal databases and nontemporal databases is that modification of an attribute value will make a temporal change while keeping the earlier historical values of the attribute rather than actually replacing the previous attribute value.
Reference: [8] <author> O. Etzion. </author> <title> Flexible consistency modes for active database applications. </title> <journal> Information Systems Journal, </journal> <volume> 18(6) </volume> <pages> 391-404, </pages> <month> Nov </month> <year> 1993. </year>
Reference-contexts: An important design issue is to determine the mutual consistency requirements among the distinct transactions. A similar problem has been examined in the context of derived data <ref> [8] </ref> resulting in the definition of the following mutual consistency modes of subtransactions. fully consistent: A subtransaction st1 is fully consistent with respect to a subtransaction st0, if their execution is atomic and both of them are executed within a single transaction. loosely consistent: A subtransaction st1 is loosely consistent with
Reference: [9] <author> O. Etzion, A. Gal, and A. Segev. </author> <title> Temporal active databases. </title> <booktitle> In Proceedings of the International Workshop on an Infrastructure for Temporal Database, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: The transaction model is subject to decisions about the level of possible parallelism and uses a control model that executes parallel subtransactions. The rest of the paper is organized as follows. Section 2 describes the data model of a temporal database, based on <ref> [9] </ref>. Section 3 discusses the schema evolution control and the execution model. In Section 4 we present the benefits of the execution model using simulation, and discuss the simulation results. Section 5 provides an overview of related work. <p> We refer to this time type as a decision time. Decision time (t d ) The time at which a data item's value was decided in the database's domain of discourse <ref> [9] </ref>. This time point denotes the time at which an event occurred, or the time at which a decision was made. From the database point of view, t d reflects the time point where an occurrence in the modeled reality entails a decision to initiate a database update transaction. <p> The object is considered to be non existing as of that time point. 2 It is possible to modify a variable, using its older values. This is done using rules, as discussed in <ref> [9] </ref>. 10 Unlike the suspend operation, the disable operation is final in the sense that disabled objects cannot be resumed, i.e., there is no reverse operation for disable.
Reference: [10] <author> O. Etzion, A. Gal, and A. Segev. </author> <booktitle> Retroactive and proactive processing. In Proceedings of Research Issues in Data Engineering Active Database Systems, </booktitle> <pages> pages 126-131, </pages> <month> Feb </month> <year> 1994. </year>
Reference-contexts: These requirements is partially satisfied by the infrastructure that has been devised within the temporal database area [29], basically aimed at incorporating time concepts as database's primitives. Other works (e.g., <ref> [10] </ref>) extended the temporal database capabilities to support retroactive and proactive updates, i.e., modifications of information that is valid in past or future time points. For example, a rank awarded to an employee in June 1994 is effective as of January 1994, generating as a result, a retroactive update.
Reference: [11] <author> S.K. Gadia. </author> <title> The role of temporal elements in temporal databases. </title> <journal> Data Engineering Bulletin, </journal> <volume> 7 </volume> <pages> 197-203, </pages> <year> 1988. </year>
Reference-contexts: A bitemporal database [15] consists of two time types, as follows. Valid time (t v ) designates the time points at which a data item is considered to be true in the modeled reality. The valid time is expressed using a temporal element <ref> [11] </ref>, which is a finite union of time intervals. Transaction time (t x ) designates the time when a data item becomes current in the database.
Reference: [12] <author> A. Gal. </author> <title> TALE | A Temporal Active Language and Execution Model. </title> <type> PhD thesis, </type> <institution> Technion|Israel Institute of Technology, Technion City, Haifa, Israel, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: An elaborated discussion of the single agent update process is available in <ref> [12] </ref>. 3.2.1 Basic assumptions Temporal update languages have traditionally provided just the most basic update capabilities, that is, insertion, modification and deletion of variables. Due to the temporal properties, the update language gains new capabilities that have not been discussed in previous studies.
Reference: [13] <author> A. Gal, O. Etzion, and A. Segev. </author> <title> Extended update functionality in temporal databases. </title> <type> Technical Report ISE-TR-94-1, </type> <institution> Technion|Israel Institute of Technology, </institution> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: In Section 4 we present the benefits of the execution model using simulation, and discuss the simulation results. Section 5 provides an overview of related work. The paper is concluded in Section 6. 2 The temporal data model In recent papers ([9], <ref> [13] </ref>) we have examined the properties of a general temporal database model as a key technology for supporting complex applications. <p> Some studies ([18]; [27]; [1]; [25]) distinguished a modification from a correction. Modifying a data is carried out when the situation in the real world has changed. Correcting a data is carried out because an error in the existing data has been detected. In <ref> [13] </ref> we provide an extended set of update operation types that consist of: insert, modify, suspend, disable, resume, freeze, unfreeze and revise.
Reference: [14] <author> H. Garcia-Molina and K. Salem. Sagas. </author> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 249-259, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: Thus, the autonomy of the commit decision is delegated to the agent level rather than the transaction level. It is worth noting that researchers in the transaction process research area have recognized the need to compromise the transaction atomicity for certain types of applications <ref> [14] </ref>. 5 Related work In this section we present works in related research areas, namely, parallel processing, schema evolution and updates in temporal databases. 20 5.1 Parallelism in databases Parallel processing technologies are used in the database systems area as a general solution of the I/O bottleneck [3], influenced by high
Reference: [15] <author> C.S. Jensen et al. </author> <title> A consensus glossary of temporal database concepts. </title> <journal> ACM SIGMOD Record, </journal> <volume> 23(1) </volume> <pages> 52-63, </pages> <year> 1994. </year>
Reference-contexts: In this section we briefly describe the main properties of the underlying architecture for the execution model. 2.1 Time types As argued in [27], temporal functionality in a database is supported using several types of time associated with each data item. A bitemporal database <ref> [15] </ref> consists of two time types, as follows. Valid time (t v ) designates the time points at which a data item is considered to be true in the modeled reality. The valid time is expressed using a temporal element [11], which is a finite union of time intervals. <p> The database uses a single "active" schema at all valid time points. Using this method, the active schema is normally the schema that is the result of the last schema modification. This method supports schema evolution, by allowing changes in the schema level, but does not support schema versioning <ref> [15] </ref>. 2. The database supports schema versioning by handling each schema version separately, in a sequential manner. This method uses a simple update algorithm, with no need for communication protocols. 3. The database supports a multi-agent model, as presented in this paper.
Reference: [16] <author> C.S. Jensen and L. Mark. </author> <title> A framework for vacuuming temporal databases. </title> <type> Technical Report CS-TR-2516, </type> <institution> University of Maryland, Dept of CS, College Park, MD 20742, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: A3: The update process allows the omission of any reference to temporal characteristics of the updated values. Defaults that are compatible with conventional databases' assumptions are enforced if the temporal characteristics are omitted. 1 Storage limitations may require physical deletions in which case a scheme such as <ref> [16] </ref> may be used. 9 3.2.2 Update operation types The update process consists of transactions in a similar way to conventional databases. A transaction consists of retrieval and update operations. The following eight update operations are supported: insert, modify, suspend, disable, resume, freeze, unfreeze, and revise.
Reference: [17] <author> W. Kim. </author> <title> Global optimization of relational queries: A first step. </title> <editor> In W. Kim, D. Reiner, and D. Batroy, editors, </editor> <booktitle> Query Processing in Database Systems, </booktitle> <pages> pages 206-216. </pages> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1984. </year>
Reference-contexts: Intraquery parallelism allows a parallel execution of operations within the same query, and intraoperation parallelism permits an operation to be partitioned to suboperations using function partitioning. An example of the latter type is the parallel join operation [5]. The subject of parallel query processing has been researched by [4], <ref> [17] </ref>, [26] and others in the areas of relational databases and deductive databases. The work presented in this paper is aimed at providing an appropriate mechanism for updating temporal databases by taking advantage of parallel database systems and enabling intraoperation parallelism.
Reference: [18] <author> M.R. </author> <title> Klopprogge and P.C. Lockmann. Modeling information preserving databases; consequences of the concept of time. </title> <booktitle> In Proceedings of the International Conference of VLDB, </booktitle> <address> Florence, Italy, </address> <year> 1983. </year> <month> 26 </month>
Reference: [19] <author> E. McKenzie. </author> <title> An Algebraic Language for Query and Update of Temporal Databases. </title> <type> PhD thesis, </type> <institution> Computer Science Department, University of North Carolina in Chapel Hill, </institution> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: For example, according to some researchers (e.g., [7]) the difference between updates in temporal databases and nontemporal databases is that modification of an attribute value will make a temporal change while keeping the earlier historical values of the attribute rather than actually replacing the previous attribute value. Others (e.g., <ref> [19] </ref>) expanded the modify operation to include meta-data, thus allowing schema evolution in time, as well as data evolution. Some studies ([18]; [27]; [1]; [25]) distinguished a modification from a correction. Modifying a data is carried out when the situation in the real world has changed.
Reference: [20] <author> L.E. McKenzie and R.T. Snodgrass. </author> <title> Schema evolution and the relational algebra. </title> <journal> Information Systems, </journal> <volume> 15(2) </volume> <pages> 207-232, </pages> <year> 1990. </year>
Reference-contexts: A thorough bibliography [23] contains approximately 40 papers regarding schema evolution in the relational data model, the object-oriented paradigm and others. Several papers (e.g., [24]) revised basic query languages to accommodate the effect of schema evolution while others (e.g., <ref> [20] </ref>) considered the update algebra required for handling evolving schema. The latter, however, failed to use the valid time along with the transaction time, and by that disallowing retroactive and proactive updates.
Reference: [21] <author> J. Mylopoulos and E. Yu. </author> <title> Aligning information system strategy with business strategy: A technical perspective. A Keynote Address in the Int. </title> <booktitle> Workshop on Next Generation Technologies and Systems, </booktitle> <address> Haifa, Israel, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: A user transaction is viewed as a collection of subtransactions applied to different snapshots. Each subtransaction is implemented as a conventional database transaction, with possible mutual commit and abort dependencies. The execution model utilizes the notion of information agents <ref> [21] </ref>. An information agent is a robust, situated, embodied, goal-driven application program. In our context, information agents interpret the updates 3 operations according to the valid schema at a given time point.
Reference: [22] <author> D.J. Penny and J. Stein. </author> <title> Class modifications in the gemstone object-oriented dbms. </title> <journal> SIGPLAN Not., </journal> <volume> 22(12) </volume> <pages> 111-117, </pages> <year> 1987. </year> <booktitle> Proc OOPSLA '87. </booktitle>
Reference-contexts: The latter, however, failed to use the valid time along with the transaction time, and by that disallowing retroactive and proactive updates. Data conversion, as a result of a change in the schema is discussed in several papers, including <ref> [22] </ref>, [28] 21 and [2]. None of these works approached the update complexity problem. 5.3 Updating temporal databases Most of the related work of updating temporal database remained within the conventional database operation types of insert, modify or delete while giving these operations slightly different meaning.
Reference: [23] <author> J.F. Roddick. </author> <title> Schema evolution in database systems|an annotated bibliography. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 21(4) </volume> <pages> 35-40, </pages> <month> Dec </month> <year> 1992. </year>
Reference-contexts: We enable parallel update processing of temporal databases by using function partitioning based on time, thus using the unique properties of this database research area. 5.2 Schema evolution Over the last years, several papers discussing different aspects of schema evolution have been published. A thorough bibliography <ref> [23] </ref> contains approximately 40 papers regarding schema evolution in the relational data model, the object-oriented paradigm and others. Several papers (e.g., [24]) revised basic query languages to accommodate the effect of schema evolution while others (e.g., [20]) considered the update algebra required for handling evolving schema.
Reference: [24] <author> J.F. Roddick. </author> <title> SQL/SE|a query language extension for databases supporting schema evolution. </title> <journal> SIG-MOD Record, </journal> <volume> 21(3) </volume> <pages> 10-16, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: A thorough bibliography [23] contains approximately 40 papers regarding schema evolution in the relational data model, the object-oriented paradigm and others. Several papers (e.g., <ref> [24] </ref>) revised basic query languages to accommodate the effect of schema evolution while others (e.g., [20]) considered the update algebra required for handling evolving schema. The latter, however, failed to use the valid time along with the transaction time, and by that disallowing retroactive and proactive updates.
Reference: [25] <author> E. Rose and A. Segev. </author> <title> Toodm-a temporal, object-oriented data model with temporal constraints. </title> <booktitle> In Proceedings of the International Conference on the Entity-Relationship Approach, </booktitle> <pages> pages 205-229, </pages> <address> San Mateo, California, </address> <year> 1991. </year>
Reference-contexts: Others (e.g., [19]) expanded the modify operation to include meta-data, thus allowing schema evolution in time, as well as data evolution. Some studies ([18]; [27]; [1]; <ref> [25] </ref>) distinguished a modification from a correction. Modifying a data is carried out when the situation in the real world has changed. Correcting a data is carried out because an error in the existing data has been detected.
Reference: [26] <author> T.K. Sellis. </author> <title> Multiple query optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(1) </volume> <pages> 23-52, </pages> <month> Mar </month> <year> 1988. </year>
Reference-contexts: An example of the latter type is the parallel join operation [5]. The subject of parallel query processing has been researched by [4], [17], <ref> [26] </ref> and others in the areas of relational databases and deductive databases. The work presented in this paper is aimed at providing an appropriate mechanism for updating temporal databases by taking advantage of parallel database systems and enabling intraoperation parallelism.
Reference: [27] <author> R. Snodgrass and I. Ahn. </author> <title> Temporal databases. </title> <journal> IEEE Computer, </journal> <volume> 19 </volume> <pages> 35-42, </pages> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: In this section we briefly describe the main properties of the underlying architecture for the execution model. 2.1 Time types As argued in <ref> [27] </ref>, temporal functionality in a database is supported using several types of time associated with each data item. A bitemporal database [15] consists of two time types, as follows. <p> Others (e.g., [19]) expanded the modify operation to include meta-data, thus allowing schema evolution in time, as well as data evolution. Some studies ([18]; <ref> [27] </ref>; [1]; [25]) distinguished a modification from a correction. Modifying a data is carried out when the situation in the real world has changed. Correcting a data is carried out because an error in the existing data has been detected.
Reference: [28] <author> L. Tan and T. Katayama. </author> <title> Meta operations for type manag. in object-oriented databases|a lazy mechanism for schema evolution. </title> <booktitle> In Proceedings of the First International Conference on DOOD, </booktitle> <pages> pages 241-258, </pages> <address> Kyoto, Japan, 1989. </address> <publisher> North-Holland. </publisher>
Reference-contexts: The latter, however, failed to use the valid time along with the transaction time, and by that disallowing retroactive and proactive updates. Data conversion, as a result of a change in the schema is discussed in several papers, including [22], <ref> [28] </ref> 21 and [2]. None of these works approached the update complexity problem. 5.3 Updating temporal databases Most of the related work of updating temporal database remained within the conventional database operation types of insert, modify or delete while giving these operations slightly different meaning.
Reference: [29] <author> A.U. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev, and R. Snodgrass. </author> <title> Temporal Databases. </title> <publisher> The Benjamin/Commings Publishing Company, Inc., </publisher> <address> Redwood City, CA., </address> <year> 1993. </year>
Reference-contexts: These requirements is partially satisfied by the infrastructure that has been devised within the temporal database area <ref> [29] </ref>, basically aimed at incorporating time concepts as database's primitives. Other works (e.g., [10]) extended the temporal database capabilities to support retroactive and proactive updates, i.e., modifications of information that is valid in past or future time points.
Reference: [30] <author> P. Valduriez. </author> <title> Parallel database systems: Open problems and new issues. </title> <booktitle> Distributed and Parallel Databases, </booktitle> <volume> 1(2) </volume> <pages> 137-165, </pages> <year> 1993. </year>
Reference-contexts: For example, a rank awarded to an employee in June 1994 is effective as of January 1994, generating as a result, a retroactive update. Adding time dependent information load databases with massive and complex updates. It has been claimed <ref> [30] </ref> that the size of information volumes inserted to databases steadily increases every year. Consequently, "the I/O bottleneck worsens" [30], i.e., the response time of updates may become unreasonable and the system's throughput is severely damaged. <p> Adding time dependent information load databases with massive and complex updates. It has been claimed <ref> [30] </ref> that the size of information volumes inserted to databases steadily increases every year. Consequently, "the I/O bottleneck worsens" [30], i.e., the response time of updates may become unreasonable and the system's throughput is severely damaged. <p> The proposed general solution is "increasing the I/O bandwidth through parallelism" <ref> [30] </ref>. This hardware solution should be accompanied by software solution in areas such as operating system support, data placement, parallel database programming languages, and transaction management. Many problems in these areas are still open [30]. There are three inherent parallelism types in data processing [30]. <p> The proposed general solution is "increasing the I/O bandwidth through parallelism" <ref> [30] </ref>. This hardware solution should be accompanied by software solution in areas such as operating system support, data placement, parallel database programming languages, and transaction management. Many problems in these areas are still open [30]. There are three inherent parallelism types in data processing [30]. Interquery parallelism enables the parallel execution of multiple queries generated by concurrent transactions. Intraquery parallelism allows a parallel execution of operations within the same query, and intraoperation parallelism permits an operation to be partitioned to suboperations using function partitioning. <p> "increasing the I/O bandwidth through parallelism" <ref> [30] </ref>. This hardware solution should be accompanied by software solution in areas such as operating system support, data placement, parallel database programming languages, and transaction management. Many problems in these areas are still open [30]. There are three inherent parallelism types in data processing [30]. Interquery parallelism enables the parallel execution of multiple queries generated by concurrent transactions. Intraquery parallelism allows a parallel execution of operations within the same query, and intraoperation parallelism permits an operation to be partitioned to suboperations using function partitioning.
Reference: [31] <author> G. Wiederhold. </author> <title> From data engineering to information engineering, </title> <booktitle> Feb 1994. A keynote address in International Conference on Data Engineering ICDE '94. </booktitle> <pages> 27 </pages>
Reference-contexts: 1 Introduction and motivation Current studies of many contemporary applications in areas such as decision support systems and decision analysis systems show the necessity of representing a time dependent information and of update operations that refer to past and future information <ref> [31] </ref>. These requirements is partially satisfied by the infrastructure that has been devised within the temporal database area [29], basically aimed at incorporating time concepts as database's primitives.
References-found: 31

