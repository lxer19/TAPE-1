URL: http://www.cs.wustl.edu/~schmidt/Svc-Conf.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/ACE-papers.html
Root-URL: http://www.cs.wustl.edu
Email: pjain@cs.wustl.edu and schmidt@cs.wustl.edu  
Title: Dynamically Configuring Communication Services with the Service Configurator Pattern  
Author: Prashant Jain and Douglas C. Schmidt 
Note: This article appeared in the June '97 C++ Report magazine.  
Address: St. Louis, MO 63130, (314) 935-7538  
Affiliation: Department of Computer Science Washington University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging, </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 9, </volume> <month> November/December </month> <year> 1996. </year>
Reference-contexts: This service provides accurate, fault-tolerant clock synchronization for computers collaborating in local area networks and wide area networks. Synchronized time services are important in distributed systems that require multiple hosts to maintain accurate global time. For instance, large-scale distributed medical imaging systems <ref> [1] </ref> require 1 TIME SERVER CLERK CLERK CLIENT CLIENTCLIENT TIME UPDATE TIME UPDATE TIME UPDATE CLIENT TIME SERVER TIME UPDATE globally synchronized clocks to ensure that patient exams are accurately timestamped and analyzed expeditiously by radiologists throughout the health-care delivery system.
Reference: [2] <author> R. Gusella and S. Zatti, </author> <title> The Accuracy of the Clock Synchronization Achieved by TEMPO in Berkeley UNIX 4.3BSD, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 15, </volume> <pages> pp. 847-853, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: distributed time service contains the following Time Server, Clerk, and Client components: * A Time Server answers queries about the time made by Clerks. * A Clerk queries one or more Time Servers to determine the correct time, calculates the approximate correct time using one of several distributed time algorithms <ref> [2, 3] </ref>, and updates its own local system time. * A Client uses the global time information maintained by a Clerk to provide consistency with the notion of time used by clients on other hosts. 2.4 A Common Solution One way to implement a distributed time service is to stat ically <p> TimeTime ServerServer CO-LOCATED DECOUPLED ClerkClerk CristianCristian AlgorithmAlgorithm ClerkClerk BerkeleyBerkeley AlgorithmAlgorithm TimeTime ServerServer 8.4 Reconfiguring an Application Now suppose we need to change the algorithm implementation of the Clerk. For example, we may decide to switch from an implementation of the Berkeley algorithm <ref> [2] </ref> to an implementation of Cristian's algorithm [3], both of which are outlined below: * Berkeley algorithm In this approach, the Time Server is an active component that polls every ma chine in the network periodically to ask what time it is there.
Reference: [3] <author> F. Cristian, </author> <title> Probabilistic Clock Synchronization, </title> <journal> Distributed Computing, </journal> <volume> vol. 3, </volume> <pages> pp. 146-158, </pages> <year> 1989. </year>
Reference-contexts: distributed time service contains the following Time Server, Clerk, and Client components: * A Time Server answers queries about the time made by Clerks. * A Clerk queries one or more Time Servers to determine the correct time, calculates the approximate correct time using one of several distributed time algorithms <ref> [2, 3] </ref>, and updates its own local system time. * A Client uses the global time information maintained by a Clerk to provide consistency with the notion of time used by clients on other hosts. 2.4 A Common Solution One way to implement a distributed time service is to stat ically <p> TimeTime ServerServer CO-LOCATED DECOUPLED ClerkClerk CristianCristian AlgorithmAlgorithm ClerkClerk BerkeleyBerkeley AlgorithmAlgorithm TimeTime ServerServer 8.4 Reconfiguring an Application Now suppose we need to change the algorithm implementation of the Clerk. For example, we may decide to switch from an implementation of the Berkeley algorithm [2] to an implementation of Cristian's algorithm <ref> [3] </ref>, both of which are outlined below: * Berkeley algorithm In this approach, the Time Server is an active component that polls every ma chine in the network periodically to ask what time it is there.
Reference: [4] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Clerk_Acceptor acceptor (Options::instance ()-&gt;port ()); // Register with the Reactor Singleton. Reactor::instance ()-&gt;register_handler (&acceptor, ACCEPT_MASK); // Run the event loop waiting for Clerks to // connect and perform time queries. for (;;) Reactor::instance ()-&gt;handle_events (); /* NOTREACHED */ - This program uses the Reactor pattern <ref> [4] </ref> and the Acceptor pattern [5] to implement a statically configured Time Server process. Each host that requires global time synchronization would run a Clerk process. The Clerks periodically update their local system time based on values received from one or more Time Servers. <p> Options::instance ()-&gt;parse_args (argc, argv); // Initialize the Clerk. Clerk clerk; // Run the event loop, periodically // querying the Time Servers to determine // the global time. for (;;) Reactor::instance ()-&gt;handle_events (); /* NOTREACHED */ - This program uses the Reactor pattern <ref> [4] </ref> and the Connector pattern [6] to implement a statically configured Clerk process. Client processes would use the synchronized time reported by their local Clerk. <p> Moreover, processes are often the wrong abstraction for many short-lived communication tasks (such as asking a Time Server for the current time or resolving a host address request in the Domain Name Service). In these cases, multi-threaded Active Objects [8] or single-threaded Reactive <ref> [4] </ref> event loops may be more efficient. 2.6 A Better Solution Often, a more convenient and flexible way to implement distributed services is to use the Service Configurator pattern. <p> centralized configuration mechanism simplifies the installation and administration of the services in an application by consolidating service attributes and initialization parameters in a single location. * Determine the service execution mechanism: A service that has been dynamically configured by a Service Configura-tor can be executed using various combinations of Reactive <ref> [4] </ref> and Active Object [8] schemes. <p> The example focuses on the configuration-related aspects of the distributed time service presented in Section 2.3. In addition, this example illustrates the use of other patterns (such as the Reactor pattern <ref> [4] </ref> and the Acceptor [5] and Connector [6] patterns) that are commonly used to develop communication services and Object Request Brokers. <p> However, the functionality of dynamically configuring, initializing, suspending, resuming, and terminating a Service created using the Manager Pattern must be added to fully implement the Service Configurator Pattern. A Service Configurator often makes use of the Reactor <ref> [4] </ref> pattern to perform event demultiplexing and dispatching on behalf of configured services. Likewise, dynamically configured services that execute for a long periods of time often use the Active Object pattern [15]. Administrative interfaces (such as configuration files or GUIs) to a Service Configurator-based system provide a Facade [16].
Reference: [5] <author> D. C. Schmidt, </author> <title> Design Patterns for Initializing Network Services: Introducing the Acceptor and Connector Patterns, </title> <journal> C++ Report, </journal> <volume> vol. 7, </volume> <month> November/December </month> <year> 1995. </year>
Reference-contexts: Reactor::instance ()-&gt;register_handler (&acceptor, ACCEPT_MASK); // Run the event loop waiting for Clerks to // connect and perform time queries. for (;;) Reactor::instance ()-&gt;handle_events (); /* NOTREACHED */ - This program uses the Reactor pattern [4] and the Acceptor pattern <ref> [5] </ref> to implement a statically configured Time Server process. Each host that requires global time synchronization would run a Clerk process. The Clerks periodically update their local system time based on values received from one or more Time Servers. <p> The example focuses on the configuration-related aspects of the distributed time service presented in Section 2.3. In addition, this example illustrates the use of other patterns (such as the Reactor pattern [4] and the Acceptor <ref> [5] </ref> and Connector [6] patterns) that are commonly used to develop communication services and Object Request Brokers. In the example below, the Concrete Service class in the OMT class diagram shown in Figure 3 is represented by the Time Server class, as well as the Clerk class. <p> The Acceptor class uses the Acceptor pattern <ref> [5] </ref> to create handlers for every connection from Clerks that want to receive requests for time updates. This design decouples the implementation of the Time Server from its configuration. Therefore, developers can change the implementation of the Time Server indepen dently of its configuration. <p> Both frameworks contain a master Acceptor <ref> [5] </ref> process that monitors the set of ports associated with the services. When a client connection occurs on a monitored port, the Acceptor process accepts the connection and demultiplexes the request to the appropriate pre-registered service handler.
Reference: [6] <author> D. C. Schmidt, </author> <title> Connector: a Design Pattern for Actively Initializing Network Services, </title> <journal> C++ Report, </journal> <volume> vol. 8, </volume> <month> January </month> <year> 1996. </year>
Reference-contexts: Options::instance ()-&gt;parse_args (argc, argv); // Initialize the Clerk. Clerk clerk; // Run the event loop, periodically // querying the Time Servers to determine // the global time. for (;;) Reactor::instance ()-&gt;handle_events (); /* NOTREACHED */ - This program uses the Reactor pattern [4] and the Connector pattern <ref> [6] </ref> to implement a statically configured Clerk process. Client processes would use the synchronized time reported by their local Clerk. To minimize communication overhead, the current time could be stored in shared memory that is mapped into the address space of the Clerk and all Clients on the same host. <p> Each subclass represents a concrete Service that has specific functionality in the distributed time service. The Time Server service is responsible for receiving and processing requests for time updates from Clerks. The Clerk service is a Connector <ref> [6] </ref> factory that (1) creates a new connection for every server, (2) dynamically allocates a new handler to send time update requests to a connected server, (3) receives the replies from all the servers through the handlers, and (4) then updates the local system time. <p> The example focuses on the configuration-related aspects of the distributed time service presented in Section 2.3. In addition, this example illustrates the use of other patterns (such as the Reactor pattern [4] and the Acceptor [5] and Connector <ref> [6] </ref> patterns) that are commonly used to develop communication services and Object Request Brokers. In the example below, the Concrete Service class in the OMT class diagram shown in Figure 3 is represented by the Time Server class, as well as the Clerk class. <p> The Connector class uses the Connector pattern <ref> [6] </ref> to create handlers for each connection to a Time Server. The handlers receive and process time updates from the Time Servers. The Clerk class inherits from the Service base class. Therefore, like the Time Server, it can be dynamically configured by the Service Configurator.
Reference: [7] <author> D. C. Schmidt and T. Suda, </author> <title> An Object-Oriented Framework for Dynamically Configuring Extensible Distributed Communication Systems, </title> <journal> IEE/BCS Distributed Systems Engineering Journal (Special Issue on Configurable Distributed Systems), </journal> <volume> vol. 2, </volume> <pages> pp. 280-293, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: However, terminating the process to change the Clerk code would terminate the Time Server as well. This disruption in service may not be acceptable for highly available systems (such as telecommunication switches or call centers <ref> [7] </ref>). * System performance may not scale up efficiently: Associating a process with each service ties up OS resources (such as I/O descriptors, virtual memory, and process table slots). This design can be wasteful if services are frequently idle. <p> There are two basic approaches to defining the service control interface, inheritance-based and message-based: * Inheritance-based This approach has each service inherit from a common base class. This is the approach used by the ACE Service Configurator framework <ref> [7] </ref> and Java applets. <p> The C++ code in this section implements the Time Server and the Clerk classes. 5 Both classes inherit from Service, allowing them to be dynamically configured into an application. In addition, the approach uses a configuration mechanism based on explicit dynamic linking <ref> [7] </ref> and a configuration file to dynamically configure the Clerk and Server portions of the distributed time service. The service execution mechanism is based on the reactive event handling model within a single thread of control. <p> Once the algorithm has been modified, the Clerk component is reconfigured dynamically by the Service Configurator. The code shown below also includes the main driver function, which provides the generic entry point into any Service Configurator-based application. The implementation runs on both UNIX/POSIX and Win32 platforms using ACE <ref> [7] </ref>, which can be obtained via the WWW at www.cs.wustl.edu/schmidt/ACE.html. 5 To save space, most of the error handling code has been omitted. 7 8.1 The Time Server Class The Time Server uses the Acceptor class to accept connections from one or more Clerks. <p> Each installed service is individually responsible for configuring itself and monitoring any communication endpoints, which can be more general than socket ports. For instance, the SCM can control named pipes and shared memory. * The ADAPTIVE Communication Environment (ACE) framework: The ACE framework <ref> [7] </ref> provides a set of C++ mechanisms for configuring and controlling communication services dynamically. The ACE Service Configurator extends the mechanisms provided by inetd, listen, and SCM to automatically support dynamic linking and unlinking of communication services.
Reference: [8] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, in Pattern 12 Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: This design can be wasteful if services are frequently idle. Moreover, processes are often the wrong abstraction for many short-lived communication tasks (such as asking a Time Server for the current time or resolving a host address request in the Domain Name Service). In these cases, multi-threaded Active Objects <ref> [8] </ref> or single-threaded Reactive [4] event loops may be more efficient. 2.6 A Better Solution Often, a more convenient and flexible way to implement distributed services is to use the Service Configurator pattern. <p> the installation and administration of the services in an application by consolidating service attributes and initialization parameters in a single location. * Determine the service execution mechanism: A service that has been dynamically configured by a Service Configura-tor can be executed using various combinations of Reactive [4] and Active Object <ref> [8] </ref> schemes.
Reference: [9] <author> W. Pree, </author> <title> Design Patterns for Object-Oriented Software Development. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: in Figure 3: init () fini () suspend () resume () info () Service ConcreteConcrete Service CService C ServiceService RepositoryRepository services ConcreteConcrete Service AService A ConcreteConcrete Service BService B The key participants in the Service Configurator pattern in clude the following: * Service (Service) Specifies the interface containing hook methods <ref> [9] </ref> (such as initialization and termination) used by a Service Configurator-based application to dy namically configure the Service. * Concrete Service (Clerk and Time Server) Implements the service's hook methods and other service-specific functionality (such as event pro cessing and communication with clients). * Service Repository (Service Repository) Maintains a repository <p> Administrative interfaces (such as configuration files or GUIs) to a Service Configurator-based system provide a Facade [16]. This Facade simplifies the management and control of applications that are executing within the Service Configurator. The virtual methods provided by the Service base class are callback hooks <ref> [9] </ref>. These hooks are used by the Service Configurator to initiate, suspend, resume, and terminate services. A Service (such as the Clerk class described in Section 8) may be created using a Factory Method [16].
Reference: [10] <author> W. R. Stevens, </author> <title> UNIX Network Programming, First Edition. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Two widely available network daemon management frameworks are inetd <ref> [10] </ref> and listen [11].
Reference: [11] <author> S. Rago, </author> <title> UNIX System V Network Programming. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Two widely available network daemon management frameworks are inetd [10] and listen <ref> [11] </ref>. Both frameworks consult configuration files that specify (1) service names (such as the standard Internet services ftp, telnet, daytime, and echo), (2) port numbers to listen on for clients to connect with these services, and (3) an executable file to invoke and perform the service when a client connects.
Reference: [12] <author> P. Jain and D. C. Schmidt, </author> <title> Service Configurator: A Pattern for Dynamic Configuration of Services, </title> <booktitle> in Proceedings of the 3 rd Conference on Object-Oriented Technologies and Systems, USENIX, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: It does this by providing methods (e.g., start and stop) that initiate and terminate threads. A method in a Java applet can access the thread it is running under using Thread.currentThread (), and then issue control messages to it such as suspend, resume, and stop. <ref> [12] </ref> presents an example that illustrates how the Service Configurator pattern is used for Java applets. 10 Related Patterns The intent of the Service Configurator pattern is similar to the Configuration pattern [13].
Reference: [13] <author> S. Crane, J. Magee, and N. Pryce, </author> <title> Design Patterns for Binding in Distributed Systems, </title> <booktitle> in The OOPSLA '95 Workshop on Design Patterns for Concurrent, Parallel, and Distributed Object-Oriented Systems, </booktitle> <address> (Austin, TX), </address> <publisher> ACM, </publisher> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: running under using Thread.currentThread (), and then issue control messages to it such as suspend, resume, and stop. [12] presents an example that illustrates how the Service Configurator pattern is used for Java applets. 10 Related Patterns The intent of the Service Configurator pattern is similar to the Configuration pattern <ref> [13] </ref>. The Configuration pattern 11 decouples structural issues related to configuring services in distributed applications from the execution of the services themselves. The Configuration pattern has been used in frameworks for configuring distributed systems to support the construction of a distributed system from a set of components.
Reference: [14] <author> P. Sommerland and F. Buschmann, </author> <title> The Manager Design Pattern, </title> <booktitle> in Proceedings of the 3 rd Pattern Languages of Programming Conference, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: In addition, the Service Configurator pattern focuses on decoupling service behavior from the service's concurrency strategies. The Manager Pattern <ref> [14] </ref> manages a collection of objects by assuming responsibility for creating and deleting these objects. In addition, it provides an interface to allow clients access to the objects it manages.
Reference: [15] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, </title> <booktitle> in Proceed ings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 1-7, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: A Service Configurator often makes use of the Reactor [4] pattern to perform event demultiplexing and dispatching on behalf of configured services. Likewise, dynamically configured services that execute for a long periods of time often use the Active Object pattern <ref> [15] </ref>. Administrative interfaces (such as configuration files or GUIs) to a Service Configurator-based system provide a Facade [16]. This Facade simplifies the management and control of applications that are executing within the Service Configurator. The virtual methods provided by the Service base class are callback hooks [9].
Reference: [16] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year> <month> 13 </month>
Reference-contexts: Likewise, dynamically configured services that execute for a long periods of time often use the Active Object pattern [15]. Administrative interfaces (such as configuration files or GUIs) to a Service Configurator-based system provide a Facade <ref> [16] </ref>. This Facade simplifies the management and control of applications that are executing within the Service Configurator. The virtual methods provided by the Service base class are callback hooks [9]. These hooks are used by the Service Configurator to initiate, suspend, resume, and terminate services. <p> The virtual methods provided by the Service base class are callback hooks [9]. These hooks are used by the Service Configurator to initiate, suspend, resume, and terminate services. A Service (such as the Clerk class described in Section 8) may be created using a Factory Method <ref> [16] </ref>. This allows an application to decide which type of Service subclass to create. 11 Concluding Remarks This article describes the Service Configurator pattern and illustrates how it decouples the implementation of services from their configuration. This decoupling increases the flexibility and extensibility of services.
References-found: 16

