URL: http://csg-www.lcs.mit.edu:8001/Users/vivek/ps/GaSa95.ps
Refering-URL: http://csg-www.lcs.mit.edu:8001/Users/vivek/sark_pub.html
Root-URL: 
Title: Location Consistency: Stepping Beyond the Memory Coherence Barrier  
Author: Guang R. Gao Vivek Sarkar 
Address: 3480 University Street 555 Bailey Avenue Montreal, Canada H3A 2A7 San Jose, California 95141  
Affiliation: School of Computer Science Application Development Technology Institute McGill University IBM Software Solutions Division  
Note: Appeared in the Proceedings of the 24th International Conference on Parallel Processing, August 14-18, 1995, (Vol. II Software).  
Abstract: In this paper, we introduce a new memory consistency model called Location Consistency (LC). The LC model uses a novel approach for defining memory consistency. The state of a memory location is modeled as a partially ordered multiset (pomset) of write operations and synchronization operations. The partial orders are determined solely by the ordering constraints imposed by the program being executed. We illustrate how the LC model can enable more compiler and hardware performance optimizations to be applied, compared to other memory consistency models which rely on the memory coherence assumption. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. V. Adve and M. D. Hill. </author> <title> Weak ordering|a new definition. </title> <booktitle> In Proceedings of the 17th ACM Symposium on Computer Architecture, </booktitle> <pages> pages 2-14, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: 1 Introduction The hardware memory consistency model that has been most commonly used as a basis for past work is sequential consistency (SC) [7]. It has been observed that sequential consistency limits performance by preventing the use of common uniprocessor hardware optimizations such as store buffers and out-of-order memory operations <ref> [6, 1] </ref>. The main approach taken in recent work on memory consistency models is to allow performance optimizations to be applied, while guaranteeing that sequential consistency is retained for a restricted class of programs | mainly programs that do not exhibit data races [2]. <p> Therefore, we refer to these weaker memory consistency models as SC-derived models. Recently proposed SC-derived models include weak ordering (WO) [3] , release consistency (RC) [6], data-race-free-0 (DRF0) <ref> [1] </ref>, and data-race-free-1 (DRF1) [2].
Reference: [2] <author> S. V. Adve and M. D. Hill. </author> <title> A unified formalization of four shared-memory models. </title> <booktitle> IEEE Transaction on Parallel and Distributed Systems, </booktitle> <pages> pages 613-624, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: The main approach taken in recent work on memory consistency models is to allow performance optimizations to be applied, while guaranteeing that sequential consistency is retained for a restricted class of programs | mainly programs that do not exhibit data races <ref> [2] </ref>. Therefore, we refer to these weaker memory consistency models as SC-derived models. Recently proposed SC-derived models include weak ordering (WO) [3] , release consistency (RC) [6], data-race-free-0 (DRF0) [1], and data-race-free-1 (DRF1) [2]. <p> is retained for a restricted class of programs | mainly programs that do not exhibit data races <ref> [2] </ref>. Therefore, we refer to these weaker memory consistency models as SC-derived models. Recently proposed SC-derived models include weak ordering (WO) [3] , release consistency (RC) [6], data-race-free-0 (DRF0) [1], and data-race-free-1 (DRF1) [2]. A central assumption in the definitions of all SC-derived memory consistency models is the memory coherence assumption, which can be stated as follows [6]: "all writes to the same location are serialized in some order and are performed in that order with respect to any processor". <p> As in other definitions of memory consistency models [6], we retain the assumption that each processor in the abstract interpreter sequentially executes its assigned instruction sequence, subject to all uniprocessor control and data dependences being satisfied. Analogous to the notion of a sequential consistent execution defined in <ref> [2] </ref>, we introduce the notion of a location consistent execution as any execution of a program by the abstract interpreter discussed above. Note that the execution model of the abstract interpreter makes no assumption on the timing of events in the program execution.
Reference: [3] <author> M. Dubois, C. Scheurich, and F. A. Briggs. </author> <title> Memory access buffering in multiprocessors. </title> <booktitle> In Proceedings of the 13th ACM International Symposium on Computer Architecture, </booktitle> <pages> pages 434-442, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Therefore, we refer to these weaker memory consistency models as SC-derived models. Recently proposed SC-derived models include weak ordering (WO) <ref> [3] </ref> , release consistency (RC) [6], data-race-free-0 (DRF0) [1], and data-race-free-1 (DRF1) [2].
Reference: [4] <author> G. R. Gao and V. Sarkar. </author> <title> Location Consistency: Stepping Beyond the Barriers of Memory Coherence and Serializability. </title> <note> ACAPS Tech. Memo 78 (Preliminary Version), </note> <institution> Sch. of Comp. Sci., McGill U., Montreal, Que., </institution> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: A sync operation performed on the entire set of processors is equivalent to a barrier synchronization. The matching of sync operations from different processors is done at run-time, in general. For a complete list of memory operations, readers are referred to <ref> [4] </ref>. 4 Abstraction of Memory System In this section, we define the memory abstraction used by the LC model. Section 4.1 defines the pom-set abstraction. Section 4.2 specifies how the state (pomset) of a memory location is updated by a write operation or a synchronization operation. <p> The descriptions of other element types (signal, wait, sync write, sync read, acquire, release) are similar, and can be found in <ref> [4] </ref>. 4.2 State-Update Operations for a Mem ory Location In this section, we specify how the state (pomset) is updated when a memory or synchronization operation is performed from one of the eight different types identified in section 4.1. <p> The initial state of the memory location is assumed to be the empty pomset. The following are examples of the default rule applied to the operations defined in subsection 4.1. A complete list of update rules can be found in <ref> [4] </ref>. * write | when a write operation from processor P i to location L with value v is executed, the element e = write (P i ; v) is inserted into the pomset for state (L), using the default state-update rule. * sync | when a sync operation among processors
Reference: [5] <author> K. Gharachorloo, A. Gupta, and J. Hennessy. </author> <title> Revision to 'memory consistency and event ordering in scalable shared-memory multiprocessors'. </title> <type> Technical report, </type> <institution> Computer System Laboratory, Stan-ford University, </institution> <month> April </month> <year> 1993. </year> <note> Technical Report No: CSL-TR-93-568. </note>
Reference-contexts: the memory location has not been initialized, and the abstract interpreter should take whatever action is specified in the program model for a read access to an uninitialized location e.g. return an undefined value, or raise an exception. 4 coherence assumption in conjunction with such hard-ware optimizations are discussed in <ref> [5] </ref>. Since the LC model does not depend on the memory coherence assumption, such complications in implementing hardware optimizations will not exist, and hence the potential for higher performance. The implementation requirements imposed by the LC model are weaker than the requirements imposed by the SC-derived models.
Reference: [6] <author> K. Gharachorloo, D. Lenoski, J. Laudon, P. Gibbons, A. Gupta, and J. Hennessy. </author> <title> Memory consistency and event ordering in scalable shared-memory multiprocessors. </title> <booktitle> In Proceedings of the 17th ACM International Symposium on Computer Architecture, </booktitle> <pages> pages 15-27, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: 1 Introduction The hardware memory consistency model that has been most commonly used as a basis for past work is sequential consistency (SC) [7]. It has been observed that sequential consistency limits performance by preventing the use of common uniprocessor hardware optimizations such as store buffers and out-of-order memory operations <ref> [6, 1] </ref>. The main approach taken in recent work on memory consistency models is to allow performance optimizations to be applied, while guaranteeing that sequential consistency is retained for a restricted class of programs | mainly programs that do not exhibit data races [2]. <p> Therefore, we refer to these weaker memory consistency models as SC-derived models. Recently proposed SC-derived models include weak ordering (WO) [3] , release consistency (RC) <ref> [6] </ref>, data-race-free-0 (DRF0) [1], and data-race-free-1 (DRF1) [2]. A central assumption in the definitions of all SC-derived memory consistency models is the memory coherence assumption, which can be stated as follows [6]: "all writes to the same location are serialized in some order and are performed in that order with respect <p> Recently proposed SC-derived models include weak ordering (WO) [3] , release consistency (RC) <ref> [6] </ref>, data-race-free-0 (DRF0) [1], and data-race-free-1 (DRF1) [2]. A central assumption in the definitions of all SC-derived memory consistency models is the memory coherence assumption, which can be stated as follows [6]: "all writes to the same location are serialized in some order and are performed in that order with respect to any processor". Memory coherence is a less restrictive form of serializability | it enforces serializ-ability of operations performed on the same location, rather than serializability of all memory operations. <p> As in other definitions of memory consistency models <ref> [6] </ref>, we retain the assumption that each processor in the abstract interpreter sequentially executes its assigned instruction sequence, subject to all uniprocessor control and data dependences being satisfied. <p> belongs to the value-set, V , specified by the state of the memory location L as maintained by the abstract interpreter in the corresponding location consistent execution. 6 Performance Potential and Imple mentation Issues As mentioned earlier, the LC model does not rely on the memory coherence assumption presented in <ref> [6] </ref> and other SC-derived models.
Reference: [7] <author> L. Lamport. </author> <title> How to make a multiprocessor that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 28(9) </volume> <pages> 690-691, </pages> <month> September </month> <year> 1979. </year>
Reference-contexts: 1 Introduction The hardware memory consistency model that has been most commonly used as a basis for past work is sequential consistency (SC) <ref> [7] </ref>. It has been observed that sequential consistency limits performance by preventing the use of common uniprocessor hardware optimizations such as store buffers and out-of-order memory operations [6, 1].
Reference: [8] <author> Vivek Sarkar. </author> <title> Synchronization using counting semaphores. </title> <booktitle> In Conference Proceedings, 1988 International Conference on Supercomputing, </booktitle> <pages> pages 627-637, </pages> <address> St. Malo, France, </address> <month> July 4-8, </month> <year> 1988. </year> <journal> ACM. </journal> <volume> 5 </volume>
Reference-contexts: This operation can be efficiently implemented by a counting semaphore <ref> [8] </ref>. A sync operation performed on the entire set of processors is equivalent to a barrier synchronization. The matching of sync operations from different processors is done at run-time, in general.
References-found: 8

