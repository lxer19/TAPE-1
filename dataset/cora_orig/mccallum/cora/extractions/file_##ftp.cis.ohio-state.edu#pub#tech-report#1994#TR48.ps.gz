URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1994/TR48.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Title: Modulo Classes and Advice  
Author: J. Ramachandran 
Keyword: Computational complexity, Kolmogorov Complexity, counting classes, advice.  
Address: Columbus, Ohio, 43210  
Affiliation: Computer and Information Sciences Ohio State University  
Abstract: We prove an upper bound on computing advice for a language A in the class of languages acceptable in deterministic polynomial time with logarithmic advice, A 2 P=log), relative to A itself. We then provide conditions under which advice for a language A 2 P=log can be computed in PF(A), and conditions for the existence of a set A in P=log without advice in PF(A). We show that paddable languages in MOD k P/log that are also self-reducible are in MOD k P, without advice. This is an extension of similar results for self-reducible paddable sets in P/log by Balcazar and Schoning [3]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Balc azar, J., Diaz, J., and Gabarr o, J. </author> <title> Structural Complexity I. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988. </year>
Reference-contexts: They showed P (P) = P and P P (#P <ref> [1] </ref>). Since then, there has been considerable research on relationships between counting classes, the best known of which is Toda's theorem proving that the polynomial time hierarchy is contained in BP:P and in P (PP). <p> MOD k P/log in general has undecidable sets, therefore the assumption of self reducibility is crucial in computing advice. 2 2 Definitions and Notations We use the definitions of standard complexity concepts as found in <ref> [1] </ref> and [2]. A function f is in the function class log if there exists a constant c such that, for all n 2 N ; jf (n)j c log n. Recall the definition of resource bounded Kolmogorov complexity. <p> Therefore computing advice even with reference to A is impossible. 5 MOD classes, self-reducibility and log advice We now consider self-reducible languages in MOD k P/log, and their relationship to MOD k P. We use standard definitions of structural complexity concepts as found in <ref> [1] </ref> and [2]. Definition 5.1 [4] A language L is in MOD k P if there exists a #P function f such that for all x 2 fl [x 2 L () f (x) 1 mod k]. Only prime k will be considered in the remainder of this paper.
Reference: [2] <author> Balc azar, J., Diaz, J., and Gabarr o, J. </author> <title> Structural Complexity II. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: MOD k P/log in general has undecidable sets, therefore the assumption of self reducibility is crucial in computing advice. 2 2 Definitions and Notations We use the definitions of standard complexity concepts as found in [1] and <ref> [2] </ref>. A function f is in the function class log if there exists a constant c such that, for all n 2 N ; jf (n)j c log n. Recall the definition of resource bounded Kolmogorov complexity. <p> Therefore computing advice even with reference to A is impossible. 5 MOD classes, self-reducibility and log advice We now consider self-reducible languages in MOD k P/log, and their relationship to MOD k P. We use standard definitions of structural complexity concepts as found in [1] and <ref> [2] </ref>. Definition 5.1 [4] A language L is in MOD k P if there exists a #P function f such that for all x 2 fl [x 2 L () f (x) 1 mod k]. Only prime k will be considered in the remainder of this paper.
Reference: [3] <author> Balc azar, J., and Sch oning, U. </author> <title> Logarithmic advice classes. </title> <type> Technical Report LSI-88-12, </type> <institution> Univ. Politecnica Catalunyu, Spain, </institution> <note> to appear in Theoretical Computer Science. </note>
Reference-contexts: Advice strings are useful in encoding small sets of information such as polynomial sized circuits and the census of sparse sets. The class P, of languages accepted by deterministic Turing machines in polynomial time, is commonly considered the class of feasible problems. Balcazar and Schoning, in <ref> [3] </ref>, started the study of classes of the form C=log. In this paper we first study the complexity of the class P/log. In contrast to P, P/log has undecidable problems due to the unbounded complexity of the advice function. <p> We study the nonuniform complexity of languages in MOD k P given logarithmic length bounded advice. This study is an extension of similar results for self-reducible paddable sets in P/log by Balcazar and Schoning who, in <ref> [3] </ref>, started the study of classes of the form C=log. The proof illustrates an interesting connection between modulo counting classes and advice. Our results are organized as follows: 1. We prove an upper bound for computing advice for a language in P= log, relative to the language itself. 2. <p> Balcazar and Schoning proved that self-reducible sets in strong-P/log are in P. In Theorem 5.7 we show that self-reducible sets in strong-MOD k P/log are in MOD k P. The proof of Theorem 5.7 involves rewriting the deterministic polynomial time algorithm from Balcazar and Schoning <ref> [3] </ref> as a nondeterministic polynomial time algorithm, where the number of accepts is congruent to 1 mod k if and only if the former algorithm accepts. We start with a definition and a technical lemma. <p> First-Good-Advice (x; u) is true for only one string u; juj c log n, where u is good advice. (u need not be w m itself, we only need 8x; [x 2 L (M; B (u))() x 2 L (M; B (w n ))] by Claim 7.) 2 As in <ref> [3] </ref>, the above proof is given with respect to self reducibility defined on the length order. The proof works under the assumptions of a polynomial well founded ordering as well.
Reference: [4] <author> Beigel, R. </author> <title> NP-hard sets are P-superterse unless R = NP. </title> <type> Technical Report 88-04, </type> <institution> Department of Computer Science, The Johns Hopkins University. </institution>
Reference-contexts: Therefore computing advice even with reference to A is impossible. 5 MOD classes, self-reducibility and log advice We now consider self-reducible languages in MOD k P/log, and their relationship to MOD k P. We use standard definitions of structural complexity concepts as found in [1] and [2]. Definition 5.1 <ref> [4] </ref> A language L is in MOD k P if there exists a #P function f such that for all x 2 fl [x 2 L () f (x) 1 mod k]. Only prime k will be considered in the remainder of this paper.
Reference: [5] <author> Beigel, R. </author> <title> Relativized counting classes: Relations among thresholds, parity, and mods. </title> <type> Tech. rep., </type> <institution> The Johns Hopkins University, Department of Computer Science, The Johns Hopkins University, </institution> <address> Baltimore, MD 21218, </address> <year> 1988. </year>
Reference-contexts: If C MOD k P=log then C MOD k P. Corollary 5.9 If PSPACE MOD k P=log then PSPACE = MOD k P. Since there exist relativized negations of all the above conclusions (by Beigel <ref> [5] </ref>) the hypothesis for each corollary is unlikely. Acknowledgments I thank Tim Long for his many helpful comments and corrections.
Reference: [6] <author> Beigel, R., and Gill, J. </author> <title> Counting classes: Thresholds, parity, mods and fewness. </title> <type> Tech. rep., </type> <institution> The Johns Hopkins University, Department of Computer Science, The Johns Hopkins University, </institution> <address> Baltimore, MD 21218, </address> <year> 1988. </year>
Reference-contexts: They showed P (P) = P and P P (#P [1]). Since then, there has been considerable research on relationships between counting classes, the best known of which is Toda's theorem proving that the polynomial time hierarchy is contained in BP:P and in P (PP). Beigel and Gill in <ref> [6] </ref>, generalizing on the notion of P, defined MOD k P as the class of languages L for which there exists a #P function f , such that for all strings x in fl , x is in L if and only if f (x) is 1 modulo k, for some
Reference: [7] <author> Gavald a, R. </author> <title> Kolmogorov Randomness and Its applications to Structural Complexity Theory. </title> <type> PhD thesis, </type> <institution> Universitat Politecnica de Catalunya, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: The class K [l (n); t (n)] denotes the set of strings x 2 =n that can be generated by a fixed universal transducer running some l (n) bit program in t (n) time. 3 Constructing advice for P/log Gavalda and Kobler presented results on constructing advice for P/poly in <ref> [7, 9] </ref>. In this section we answer the same question for the class P= log.
Reference: [8] <author> Karp, R., and Lipton, R. </author> <title> Some connections between nonuniform and uniform complexity classes. </title> <booktitle> In Proc. 12th ACM Symp. on Theory of Computing (1980), </booktitle> <pages> pp. 302-309. </pages>
Reference: [9] <author> K obler, J. </author> <title> Locating P/poly optimally in the extended low hierarchy. </title> <type> Tech. Rep. Nr. 92-05, </type> <institution> Ulmer Informatik-Berichte, </institution> <year> 1992. </year> <month> 16 </month>
Reference-contexts: The class K [l (n); t (n)] denotes the set of strings x 2 =n that can be generated by a fixed universal transducer running some l (n) bit program in t (n) time. 3 Constructing advice for P/log Gavalda and Kobler presented results on constructing advice for P/poly in <ref> [7, 9] </ref>. In this section we answer the same question for the class P= log.
Reference: [10] <author> Li, M., and Vitanyi, P. </author> <title> An Introduction to Kolmogorov Complexity and its applications. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: If T (p; y) = x then (p; y) = x, and hp; yi is a description of x. Definition 2.1 <ref> [10] </ref> The resource bounded Kolmogorov complexity of x conditional to and y, denoted C t;s (xjy), is the length of the shortest program p such that (p; y) is x. The simulation of by T runs in time t (jxj) and space s (jxj). <p> The simulation of by T runs in time t (jxj) and space s (jxj). Note that in the definition of C t;s (xjy) the information after the "j" is given for free. y may consist of several strings paired together. The Invariance Theorem in <ref> [10] </ref> states that Theorem 2.2 There exists a universal partial function 0 such that for all other partial functions , and all x; y 2 fl , there exists a constant c dependent only on such that C 0 (xjy) = C (xjy) + c.
Reference: [11] <author> Papadimitriou, C., and Zachos, S. </author> <title> Two remarks on the power of counting. </title> <booktitle> In Proc. sixth GI conf. on Theoretical Comp. </booktitle> <address> Sc. </address> <year> (1982), </year> <pages> pp. 269-276. </pages> <address> Springer-Verlag,LCNS, </address> <month> #145. </month>
Reference: [12] <author> Rubinstein, R. </author> <title> Structural Complexity Classes of Sparse Sets. </title> <type> PhD thesis, </type> <institution> Northeastern University, </institution> <month> August </month> <year> 1988. </year>
Reference-contexts: L is P-isomorphic to a language L 0 if and only there exists a polynomial-time invertible polynomial-time bijection between L and L 0 . Rubinstein in <ref> [12] </ref> showed the following: Theorem 4.4 [12] If S is a sparse set then the following four statements are equivalent. 1. S is P-printable. 2. The ranking function of S is computable in polynomial time. 3. S is P-isomorphic to a tally set in P. 4. <p> L is P-isomorphic to a language L 0 if and only there exists a polynomial-time invertible polynomial-time bijection between L and L 0 . Rubinstein in <ref> [12] </ref> showed the following: Theorem 4.4 [12] If S is a sparse set then the following four statements are equivalent. 1. S is P-printable. 2. The ranking function of S is computable in polynomial time. 3. S is P-isomorphic to a tally set in P. 4. <p> Let B be recognized by TM M in time p (n), for some polynomial p. Using the above results of Rubinstein <ref> [12] </ref> we present sufficient conditions for the existence of a g 2 good-discr (B; c) " PF.
Reference: [13] <author> Sch oning, U. </author> <title> Complexity and Structure. </title> <booktitle> Lecture Notes in Computer Science Vol. </booktitle> <volume> 211. </volume> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Thus, the results of the last section show that P= log is in EL P; 1 (Extended Low 1, defined in <ref> [13] </ref> as the class of sets A such that NP (A) P (A NP)). We now ask if this upper bound can be improved, and examine the conditions under which such an improvement is possible.
Reference: [14] <author> Toda, S., and Ogiwara, M. </author> <title> Counting classes are at least as hard as the the polynomial-time hierarchy. </title> <type> Tech. Rep. </type> <institution> CSIM 90-09, University of Electro-Comm., Department of Computer Science and Information Mathematics, </institution> <address> Chofu-shi, Tokyo 182, Japan, </address> <year> 1990. </year> <month> 17 </month>
References-found: 14

