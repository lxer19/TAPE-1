URL: ftp://ftp.cs.wisc.edu/sohi/papers/1994/micro.register-file.ps.gz
Refering-URL: http://www.cs.wisc.edu/~sohi/sohi.html
Root-URL: 
Email: sohig@cs.wisc.edu  
Title: The Anatomy of the Register File in a Multiscalar Processor  
Author: Scott E. Breach T.N. Vijaykumar Gurindar S. Sohi fbreach, vijay, 
Address: 1210 W. Dayton Street Madison, WI 53706  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Abstract: This paper presents the operation of the register file in the Multiscalar architecture. The register file provides the appearance of a logically centralized register file, yet is implemented as physically decentralized register files, queues, and control logic in a Multiscalar processor. We address the key issues of storage, communication, and synchronization required for a successful design and discuss the complications that arise in the face of speculation. In particular, the hardware required to implement the register file is detailed, and software support to streamline the operation of the register file is described. Illustrative examples detailing important aspects of the operation of the register file and an evaluation of its effectiveness are provided. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Franklin. </author> <title> The Multiscalar Architecture. </title> <type> PhD thesis, </type> <institution> University of Wisconsin-Madison, </institution> <type> Tech Report 1196, </type> <month> November </month> <year> 1993. </year>
Reference-contexts: 1 Introduction The Multiscalar architecture is a novel architecture for exploiting instruction-level parallelism (ILP) <ref> [1] </ref> [2] that speculatively executes multiple operations in parallel, yet provides the semblance of sequential execution. An implementation of this architecture, a Multiscalar processor, is a collection of execution engines which share a common register names-pace. <p> A full crossbar interconnects the stages to twice as many banks of interleaved data cache. Each bank has been fixed in the configuration of 8 kbytes of direct mapped data cache in 64 byte blocks and 256 address resolution entries <ref> [1] </ref> (which constitutes a total data cache of 64 kbytes and 128 kbytes for 4-stage and 8-stage processors respectively). The control flow prediction has been fixed in a PAs configuration [7] with 4 targets per prediction and 6 outcome histories.
Reference: [2] <author> M. Franklin and G.S. Sohi. </author> <title> The expandable split window paradigm for exploiting fine-grain parallelism. </title> <booktitle> In Proc. of ISCA 19, </booktitle> <pages> pages 58-67, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction The Multiscalar architecture is a novel architecture for exploiting instruction-level parallelism (ILP) [1] <ref> [2] </ref> that speculatively executes multiple operations in parallel, yet provides the semblance of sequential execution. An implementation of this architecture, a Multiscalar processor, is a collection of execution engines which share a common register names-pace.
Reference: [3] <author> M.D. Smith, M.S. Lam, and M.A. Horowitz. </author> <title> Boosting beyond static scheduling in a superscalar processor. </title> <booktitle> In Proc. of ISCA 17, </booktitle> <pages> pages 344-354, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: To avoid this multiple register copy operation, we maintain a collection of pointers using additional control bits to provide the illusion of two distinct past and present register banks, somewhat similar to approaches proposed to implement boosting <ref> [3] </ref> and precise interrupts [4]. The control bits consist of two bit masks, the past mask and the present mask. The physical registers are divided into two banks, bank 0 and bank 1.
Reference: [4] <author> J.E. Smith and A.R. Pleszkun. </author> <title> Implementing precise interrupts in pipelined processors. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(5) </volume> <pages> 562-573, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: To avoid this multiple register copy operation, we maintain a collection of pointers using additional control bits to provide the illusion of two distinct past and present register banks, somewhat similar to approaches proposed to implement boosting [3] and precise interrupts <ref> [4] </ref>. The control bits consist of two bit masks, the past mask and the present mask. The physical registers are divided into two banks, bank 0 and bank 1.
Reference: [5] <author> M. Franklin and G. S. Sohi. </author> <title> Register traffic analysis for streamlining inter-operation communication in fine-grain parallel processors. </title> <booktitle> In Proc. of MICRO-25, </booktitle> <pages> pages 236-245, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Accordingly, each register value propagates at most once around the ring, although most register values propagate far less, depending upon the characteristics of the tasks <ref> [5] </ref>. 3.4 Synchronization To provide synchronization between tasks, the control in each stage must identify if and when the correct register values for an instruction to execute are available.
Reference: [6] <author> D.N. Pnevmatikatos and G.S. Sohi. </author> <title> Guarded execution and branch prediction in dynamic ilp processors. </title> <booktitle> In Proc. of ISCA 21, </booktitle> <pages> pages 120-129, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: The two ways that appear most promising are (i) using special opcodes for such instructions (which we call op-and-send instructions) and (ii) using a specially inserted bit mask, similar to the GUARD instructions proposed in <ref> [6] </ref>. If the path of control in a task is complex, the situation becomes more involved. The instructions may be tagged with forward bits as before, but the determination of the create mask may be somewhat problematic.
Reference: [7] <author> T. Yeh and Y.N. Patt. </author> <title> A comparison of dynamic branch predictors that use two levels of branch history. </title> <booktitle> In Proc. of ISCA 20, </booktitle> <pages> pages 257-266, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The control flow prediction has been fixed in a PAs configuration <ref> [7] </ref> with 4 targets per prediction and 6 outcome histories.
Reference: [8] <author> R.E. Hank, S.A. Mahlke, R.A. Bringmann, J.C. Gyllenhaal, and W.W. Hwu. </author> <title> Superblock formation using static program analysis. </title> <booktitle> In Proc. of MICRO-26, </booktitle> <pages> pages 247-255, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: from the SPEC92 integer suite; 2 common Unix utilities, cmp from the GNU diffutils 2.6 with input cccp.c and wc from the GNU texu-tils 1.9 with input cccp.c (Note: these are the same utilities, albeit from different source code, with the same inputs as used by the IMPACT group in <ref> [8] </ref>); and a f2c translation of tomcatv from the SPEC92 floating point suite. All have been compiled with the Multiscalar compiler at optimization level -O2. All benchmarks have been simulated to completion and verified instruction-by-instruction during simulation. Dynamic instruction counts for the benchmark are given in Table 2.
References-found: 8

