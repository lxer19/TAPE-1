URL: http://www.cs.wisc.edu/~fischer/ftp/pub/sohi/papers/1992/micro.rta.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/sohi/papers/1992/
Root-URL: http://www.cs.wisc.edu
Title: Register Traffic Analysis for Streamlining Inter-Operation Communication in Fine-Grain Parallel Processors  
Author: Manoj Franklin and Gurindar S. Sohi 
Address: 1210 West Dayton Street Madison, WI 53706, USA  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Date: 1992  
Note: Proc. 25th Annual International Symposium on Microarchitecture (MICRO-25),  
Abstract: Traditionally, register files have been the primary agent for inter-operation communication in load/store architectures. As processors start issuing multiple instructions per cycle, a centralized register file can easily become a bottleneck. This paper analyzes the register file traffic in a load/store architecture with a view to motivate the development of alternate inter-operation communication mechanisms that reduce the bandwidth demanded of a centralized register file. We first provide metrics to characterize the register traffic. These metrics deal with the degree and locality of use of the register instances created. We then present the results of a simulation study that uses the MIPS R2000 architecture and the SPEC benchmark programs. We have two major results. First, a large number of the register instances are used only once, and the average degree of use of register instances is about 2. Second, most of the register instances are used up soon after they are created (within about 30-40 instructions). This suggests that alternate inter-operation communication mechanisms that exploit the temporal locality of use of register instances are likely to be effective in reducing the traffic burden on the centralized register file. The second result was pivotal in the design of the distributed register file for the multiscalar processing paradigm. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> ``Special Issue,'' </editor> <booktitle> IBM Journal of Research and Development, </booktitle> <volume> vol. 34, </volume> <pages> pp. 23-36, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: More recently, superscalar architectures such as the IBM RS/6000 <ref> [1] </ref> attempt to exploit this phenomenon, in a limited manner, by replacing a sequence of operations that produce single-use results by higher strength operations (e.g., IBM RS/6000's multiply-add fused unit [11] ).
Reference: [2] <author> J. R. Goodman et al, </author> <title> ``PIPE: a Decoupled Architecture for VLSI,'' </title> <booktitle> Proc. 12th Annual Symp. on Computer Architecture, </booktitle> <pages> pp. 20-27, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: The first step that was proposed in this direction was to split the register file into an integer file and a floating-point (FP) file, each file having fewer ports. It was even proposed to provide independent control to the integer and FP units, resulting in a decoupled architecture <ref> [2, 17] </ref>. While in theory this partitioning could reduce the bandwidth requirements of each register file by a factor of 2, in practice the bandwidth reduction achieved and the issue rate achieved depends upon the mix of FP and integer operations in the program. <p> Previously, such mechanisms have been used explicitly, i.e., in a manner visible to the ISA. For example, decou-pled architectures use explicit memory-to-processor queues for loads to communicate with computation instructions, and processor-to-memory queues for computation instructions to communicate with stores <ref> [2, 17] </ref>. Likewise, systolic arrays use systolic queues that allow some computation instructions to communicate with others directly [3, 7].
Reference: [3] <author> M. Annaratone et al, </author> <title> ``The Warp Computer: Architecture, Implementation and Performance,'' </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-36, </volume> <pages> pp. 1523-1538, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: For example, decou-pled architectures use explicit memory-to-processor queues for loads to communicate with computation instructions, and processor-to-memory queues for computation instructions to communicate with stores [2, 17]. Likewise, systolic arrays use systolic queues that allow some computation instructions to communicate with others directly <ref> [3, 7] </ref>.
Reference: [4] <author> M. Butler et al, </author> <title> ``Single Instruction Stream Parallelism Is Greater than Two,'' </title> <booktitle> Proc. 18th Annual Int'l Symp. on Computer Architecture, </booktitle> <pages> pp. 276-286, </pages> <year> 1991. </year>
Reference-contexts: We shall see why this need not be the case. An inspection of the dynamic dataflow graph of many sequential programs reveals that there exists a large amount of theoretically exploitable instruction-level parallelism <ref> [4, 8] </ref>, i.e., a large number of computation nodes that can be executed in parallel, provided a suitable processor model with a suitable inter-operation communication mechanism exists. In that case, if instructions of close proximity are dependent, then many of the farther-apart instructions should be independent.
Reference: [5] <author> R. P. Colwell et al, </author> <title> ``A VLIW Architecture for a Trace Scheduling Compiler,'' </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. 37, </volume> <pages> pp. 967-979, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: In any case, this separation of register files is only a temporary solution to the bandwidth problem. VLIW processors, such as the TRACE /300 <ref> [5] </ref>, take the above approach one step further by having multiple, ISA-visible integer and FP register files.
Reference: [6] <author> R. P. Colwell et al, </author> <title> ``Architecture and Implementation of a VLIW Supercomputer,'' </title> <booktitle> Proc. Supercomputing '90, </booktitle> <pages> pp. 910-919, </pages> <year> 1990. </year>
Reference-contexts: Interestingly, Multiflow retracted to the single register file model in their later model TRACE /500 <ref> [6] </ref>. 1.2. Reducing the Register File Traffic How can we reduce the register file traffic? The obvious answer is to provide some form of auxiliary storage elements that can carry out most of the inter-operation communication in a decentralized manner.
Reference: [7] <author> S. Borkar et al, </author> <title> ``Supporting Systolic and Memory Communication in iWarp,'' </title> <booktitle> Proc. 17th Annual Int'l Symp. on Computer Architecture, </booktitle> <pages> pp. 70-81, </pages> <year> 1990. </year>
Reference-contexts: For example, decou-pled architectures use explicit memory-to-processor queues for loads to communicate with computation instructions, and processor-to-memory queues for computation instructions to communicate with stores [2, 17]. Likewise, systolic arrays use systolic queues that allow some computation instructions to communicate with others directly <ref> [3, 7] </ref>.
Reference: [8] <author> T. M. Austin and G. S. Sohi, </author> <title> ``Dynamic Dependency Analysis of Ordinary Programs,'' </title> <booktitle> Proc. 19th Annual Int'l Symp. on Computer Architecture, </booktitle> <pages> pp. 342-351, </pages> <year> 1992. </year>
Reference-contexts: We shall see why this need not be the case. An inspection of the dynamic dataflow graph of many sequential programs reveals that there exists a large amount of theoretically exploitable instruction-level parallelism <ref> [4, 8] </ref>, i.e., a large number of computation nodes that can be executed in parallel, provided a suitable processor model with a suitable inter-operation communication mechanism exists. In that case, if instructions of close proximity are dependent, then many of the farther-apart instructions should be independent.
Reference: [9] <author> M. Franklin and G. S. Sohi, </author> <title> ``The Expandable Split Window Paradigm for Exploiting Fine-Grain Parallelism,'' </title> <booktitle> Proc. 19th Annual Int'l Symp. on Computer Architecture, </booktitle> <pages> pp. 58-67, </pages> <year> 1992. </year>
Reference-contexts: The second is to show how the register file usage characteristics were exploited in the design of a distributed register file for the multiscalar, erstwhile ESW (Expandable Split Window), processing paradigm <ref> [9] </ref>. The central idea of the distributed register file design was to have multiple versions of the register file, thereby keeping the number of read and write ports of each register file much less than that in the register file of conventional VLIW and superscalar processors. <p> An Application Having discussed some important register traffic characteristics, let us now turn our attention to how one might use them to develop alternate inter-operation communication mechanisms. In this section, we discuss how some of the characteristics were used in the development of the multiscalar processing model <ref> [9] </ref> for exploiting fine-grain parallelism, and the distributed inter-operation communication mechanism for the multiscalar model. The objective of this section is not to advocate a particular processing model or inter-operation communication mechanism, but only to illustrate how some of the results of Section 3 can be put into effective use. <p> This helps to keep the number of read and write ports per register file much less than that needed in conventional VLIW and superscalar processors. We shall briefly describe the multis-calar processing paradigm below; more detailed information can be found in <ref> [9] </ref>. 4.1. The Multiscalar Processing Paradigm In section 3, we saw that most of the register operands are generated in the immediate past, and that most of the register instances are used up almost immediately after creation. This means that instructions of close proximity, quite likely, are dependent. <p> The efficacy of the distributed future file system for the multiscalar model is further substantiated by the high sustained issue rates we obtained in our simulation studies of the multiscalar model, some of which were reported in <ref> [9] </ref>. 243 % Number of Subwindows 100 80 60 40 20 0 dnasa7 doduc matrix300 spice2g6 tomcatv % Number of Subwindows 100 80 60 40 20 0 dnasa7 doduc matrix300 spice2g6 tomcatv % Number of Subwindows 100 80 60 40 20 0 espresso gcc xlisp eqntott (i) FP Operands of FP
Reference: [10] <author> J. L. Hennessy and D. A. Patterson, </author> <title> Computer Architecture: A Quantitative Approach. </title> <address> San Mateo, CA: </address> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1990. </year>
Reference-contexts: The MIPS R2000 architecture is representative of the class of load/store architectures that have emerged recently; other architectures in this class have very similar traits <ref> [10] </ref>. Briefly, the MIPS R2000, with an R2010 FP coprocessor, has separate integer and FP register files. The integer register file has 32 registers, each of which is 32 bits wide. R0 is used as a special register to hold the constant value 0.
Reference: [11] <author> E. Hokenek, R. K. Montoye, and P. W. Cook, </author> <title> ``Second-Generation RISC Floating Point with Multiply-Add Fused,'' </title> <journal> IEEE J. of Solid-State Circuits, </journal> <volume> vol. 25, </volume> <pages> pp. 1207-1213, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: More recently, superscalar architectures such as the IBM RS/6000 [1] attempt to exploit this phenomenon, in a limited manner, by replacing a sequence of operations that produce single-use results by higher strength operations (e.g., IBM RS/6000's multiply-add fused unit <ref> [11] </ref> ). Recall that in load/store architectures, single-use instances are typically created because of the register file being used as an intermediate storage for computations.
Reference: [12] <author> R. Jolly, ``A 9-ns 1.4 Gigabyte/s, </author> <title> 17-Ported CMOS Register File,'' </title> <journal> IEEE J. of Solid-State Circuits, </journal> <volume> vol. 26, </volume> <pages> pp. 1407-1412, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: In CMOS, the area required to build read ports is proportional to the square of the number of ports <ref> [12] </ref>. Whereas a few multi-ported register files have been built, for example the register files for the Cydra 5 [15], the SIMP processor [14], Intel's iWarp [12], and the XIMD processor [19], we feel that centralized, multi-ported register files are not a good long-term solution, and that alternate means need to <p> In CMOS, the area required to build read ports is proportional to the square of the number of ports <ref> [12] </ref>. Whereas a few multi-ported register files have been built, for example the register files for the Cydra 5 [15], the SIMP processor [14], Intel's iWarp [12], and the XIMD processor [19], we feel that centralized, multi-ported register files are not a good long-term solution, and that alternate means need to be explored.
Reference: [13] <author> G. Kane, </author> <title> MIPS R2000 RISC Architecture. </title> <address> Engle-wood Cliffs, New Jersey: </address> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: Empirical Analysis of Register Traffic In this section, we present the results of an empirical study of the register traffic in a MIPS R2000 processor with an R2010 FP coprocessor <ref> [13] </ref>. The MIPS R2000 architecture is representative of the class of load/store architectures that have emerged recently; other architectures in this class have very similar traits [10]. Briefly, the MIPS R2000, with an R2010 FP coprocessor, has separate integer and FP register files.
Reference: [14] <author> K. Murakami, N. Irie, M. Kuga, and S. Tomita, </author> <title> ``SIMP (Single Instruction Stream / Multiple Instruction Pipelining): A Novel High-Speed Single-Processor Architecture,'' </title> <booktitle> Proc. 16th Annual Symp. on Computer Architecture, </booktitle> <pages> pp. 78-85, </pages> <year> 1989. </year>
Reference-contexts: In CMOS, the area required to build read ports is proportional to the square of the number of ports [12]. Whereas a few multi-ported register files have been built, for example the register files for the Cydra 5 [15], the SIMP processor <ref> [14] </ref>, Intel's iWarp [12], and the XIMD processor [19], we feel that centralized, multi-ported register files are not a good long-term solution, and that alternate means need to be explored.
Reference: [15] <author> B. R. Rau, D. W. L. Yen, W. Yen, and R. Towle, </author> <title> ``The Cydra 5 Departmental Supercomputer: Design Philosophies, Decisions, and Tradeoffs,'' </title> <journal> IEEE Computer, </journal> <volume> vol. 22, </volume> <pages> pp. 12-35, </pages> <month> January, </month> <year> 1989. </year>
Reference-contexts: In CMOS, the area required to build read ports is proportional to the square of the number of ports [12]. Whereas a few multi-ported register files have been built, for example the register files for the Cydra 5 <ref> [15] </ref>, the SIMP processor [14], Intel's iWarp [12], and the XIMD processor [19], we feel that centralized, multi-ported register files are not a good long-term solution, and that alternate means need to be explored.
Reference: [16] <author> R. M. Russel, </author> <title> ``The CRAY-1 Computer System,'' </title> <journal> CACM, </journal> <volume> vol. 21, </volume> <pages> pp. 63-72, </pages> <month> January </month> <year> 1978. </year>
Reference-contexts: This single-use property is not surprising; it has been routinely used in vector machines in the form of chaining to reduce the traffic to the vector register file (and of course to decrease the overall latency and increase the throughput of a sequence of vector operations) <ref> [16] </ref>. More recently, superscalar architectures such as the IBM RS/6000 [1] attempt to exploit this phenomenon, in a limited manner, by replacing a sequence of operations that produce single-use results by higher strength operations (e.g., IBM RS/6000's multiply-add fused unit [11] ).
Reference: [17] <author> J. E. Smith, </author> <title> ``Decoupled Access/Execute Architectures,'' </title> <booktitle> Proc. 9th Annual Symp. on Computer Architecture, </booktitle> <pages> pp. 112-119, </pages> <month> April </month> <year> 1982. </year>
Reference-contexts: The first step that was proposed in this direction was to split the register file into an integer file and a floating-point (FP) file, each file having fewer ports. It was even proposed to provide independent control to the integer and FP units, resulting in a decoupled architecture <ref> [2, 17] </ref>. While in theory this partitioning could reduce the bandwidth requirements of each register file by a factor of 2, in practice the bandwidth reduction achieved and the issue rate achieved depends upon the mix of FP and integer operations in the program. <p> Previously, such mechanisms have been used explicitly, i.e., in a manner visible to the ISA. For example, decou-pled architectures use explicit memory-to-processor queues for loads to communicate with computation instructions, and processor-to-memory queues for computation instructions to communicate with stores <ref> [2, 17] </ref>. Likewise, systolic arrays use systolic queues that allow some computation instructions to communicate with others directly [3, 7].
Reference: [18] <author> J. E. Smith and A. R. Pleszkun, </author> <title> ``Implementing Precise Interrupts in Pipelined Processors,'' </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. 37, </volume> <pages> pp. 562-573, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Furthermore, most of these last updates need not propagate beyond one or two stages, because a new instance would soon be created for those registers. The local register files, which we call future files, work similar in spirit to the future file proposed in <ref> [18] </ref> for implementing precise interrupts in pipelined processors. Thus we exploit the temporal locality of creation and use of register instances to design a good decentralized register file structure that ties well with the multiscalar execution model.
Reference: [19] <author> A. Wolfe and J. P. Shen, </author> <title> ``A Variable Instruction Stream Extension to the VLIW Architecture,'' </title> <booktitle> Proc. ASPLOS-IV, </booktitle> <pages> pp. 2-14, </pages> <month> April </month> <year> 1991. </year> <month> 245 </month>
Reference-contexts: Whereas a few multi-ported register files have been built, for example the register files for the Cydra 5 [15], the SIMP processor [14], Intel's iWarp [12], and the XIMD processor <ref> [19] </ref>, we feel that centralized, multi-ported register files are not a good long-term solution, and that alternate means need to be explored.
References-found: 19

