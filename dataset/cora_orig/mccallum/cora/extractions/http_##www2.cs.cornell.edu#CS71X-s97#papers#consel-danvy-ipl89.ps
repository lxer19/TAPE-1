URL: http://www2.cs.cornell.edu/CS71X-s97/papers/consel-danvy-ipl89.ps
Refering-URL: http://www2.cs.cornell.edu/CS71X-s97/cs719bib.htm
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Partial Evaluation of Pattern Matching in Strings  
Author: Charles Consel Olivier Danvy 
Keyword: Partial evaluation, program specialization, Knuth, Morris Pratt algorithm.  
Address: 4 place Jussieu, couloir 45-55, 2e etage Universitetsparken 1 75252 Paris Cedex 05 2100 Copenhagen France Denmark  
Affiliation: LITP DIKU Computer Science Department University of Paris VI University of Copenhagen  
Note: Information Processing Letters Vol. 30, No. 2, pp.  Acad. Andrei Ershov, ed.  
Email: chac@litp.ibp.fr danvy@diku.dk  
Date: 79-86, January 1989  
Abstract: This article describes how automatically specializing a fairly naive pattern matcher by partial evaluation leads to the Knuth, Morris & Pratt algorithm. Interestingly enough, no theorem proving is needed to achieve the partial evaluation, as was previously argued, and it is sufficient to identify a static component in the computation to get the result a deterministic finite automaton. This experiment illustrates how a small insight and partial evaluation can achieve a non-trivial result. 
Abstract-found: 1
Intro-found: 1
Reference: [Bjtrner, Ershov & Jones 88] <editor> Dines Bjtrner, Andrei P. Ershov, Neil D. Jones (eds.): </editor> <title> Partial Evaluation and Mixed Computation, Gl. </title> <address> Averns, Denmark, </address> <publisher> North-Holland (1988) </publisher>
Reference-contexts: Further, by partially evaluating the original Knuth, Morris & Pratt algorithm with respect to a next table, we have obtained a residual program structurally equivalent to the one above. During the first workshop on Partial Evaluation and Mixed Computation <ref> [Bjtrner, Ershov & Jones 88] </ref>, the question was asked recurrently whether a partial evaluator could treat the Knuth, Morris & Pratt algorithm. It is argued in [Futamura & Nogi 88] that it needs using a theorem prover.
Reference: [Consel 88] <author> Charles Consel: </author> <title> New Insights into Partial Evaluation: the Schism Experiment, </title> <booktitle> proceedings of the second European Symposium on Programming ESOP '88, Lecture Notes in Computer Science No 300 pp 236-246, </booktitle> <editor> Harald Ganzinger (ed.), </editor> <address> Nancy, France (March 1988) </address>
Reference-contexts: Self-applicable partial evaluators exist since [Jones, Sestoft & Stndergaard 85]. All the programs described here have been run with the partial evaluator of [Jones, Sestoft & Stndergaard 88] and with the Schism partial evaluator <ref> [Consel 88] </ref>, both of which are self-applicable. We will use Mix generically for naming any partial evaluator. Below, we reproduce the parts processed with Schism because they are written in Scheme [Rees & Clinger 86] and are thus readable without further description.
Reference: [Futamura 71] <author> Yoshihiko Futamura: </author> <title> Partial Evaluation of Computation Process an Approach to a Compiler-Compiler, </title> <journal> Systems, Computers, </journal> <volume> Controls Vol. </volume> <pages> 2, </pages> <note> No 5 pp 45-50 (1971) </note>
Reference-contexts: Further, self-applying the partial evaluator <ref> [Futamura 71] </ref>, that is, specializing the partial evaluator with respect to the pattern matching program: Mix Mix PM makes it generate a program compiling a pattern into the program above 1 .
Reference: [Futamura & Nogi 88] <author> Yoshihiko Futamura, Kenroku Nogi: </author> <title> Generalized Partial Computation, from Partial Evaluation and Mixed Computation pp 133-151, </title> <editor> Dines Bjtrner, Andrei P. Ershov and Neil D. Jones (eds.), </editor> <publisher> North-Holland (1988) </publisher>
Reference-contexts: During the first workshop on Partial Evaluation and Mixed Computation [Bjtrner, Ershov & Jones 88], the question was asked recurrently whether a partial evaluator could treat the Knuth, Morris & Pratt algorithm. It is argued in <ref> [Futamura & Nogi 88] </ref> that it needs using a theorem prover. This note shows that theorem proving it is not necessary for this, and that separating out the portion of the algorithm that will be repeated statically is sufficient to obtain straightforwardly the Knuth, Morris & Pratt algorithm.
Reference: [Knuth, Morris & Pratt 77] <author> Donald E. Knuth, James H. Morris, Vaughan R. Pratt: </author> <title> Fast Pattern Matching in Strings, </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. </volume> <pages> 6, </pages> <note> No 2 pp 323-350 (June 1977) </note>
Reference-contexts: obtain by partial evaluation a program whose semantics has the functionality: Subject-String ! Boolean where, for some alphabet , Pattern-String = Subject-String = fl We propose such an approach here, and more precisely to demonstrate that specializing a fairly simpleminded pattern matcher yields the efficient Knuth, Morris & Pratt algorithm <ref> [Knuth, Morris & Pratt 77] </ref>. Partial evaluation is a semantics-preserving program transformation based on propagating constants, unfolding and specializing procedures. <p> It is a strong starting point in <ref> [Knuth, Morris & Pratt 77] </ref> to have remarked that where to restart after a mismatch could be deduced from the pattern alone. <p> the redundancy has vanished: 5 (define (loop-5 d) (if (equal? 'b (car d)) (and (not (null? (cdr d))) (loop-6 (cdr d))) (restart-2 d))) The full effect of the Knuth, Morris & Pratt algorithm is now achieved, and we include in the appendix the same optimal code as section 3 of <ref> [Knuth, Morris & Pratt 77] </ref>. 5 Comparison with related work [Knuth, Morris & Pratt 77] is the seminal paper on fast pattern matching in strings. <p> 'b (car d)) (and (not (null? (cdr d))) (loop-6 (cdr d))) (restart-2 d))) The full effect of the Knuth, Morris & Pratt algorithm is now achieved, and we include in the appendix the same optimal code as section 3 of <ref> [Knuth, Morris & Pratt 77] </ref>. 5 Comparison with related work [Knuth, Morris & Pratt 77] is the seminal paper on fast pattern matching in strings. Because partial evaluation is essentially program specialization, we get algorithmic ("compiled") versions of the original next table that determines which character in the pattern should be tested after a mismatch.
Reference: [Jones, Sestoft & Stndergaard 85] <author> Neil D. Jones, Peter Sestoft, Harald Stndergaard: </author> <title> An Experiment in Partial Evaluation: the Generation of a Compiler Generator, </title> <booktitle> proceedings of the First International Conference on Rewriting Techniques and Applications, </booktitle> <editor> Jean-Pierre Jouannaud (ed.), </editor> <booktitle> Lecture Notes in Computer Science No 202 pp 124-140, </booktitle> <address> Dijon, France (June 1985) </address>
Reference-contexts: The semantics of the residual program is a function: Pattern-String ! (Subject-String ! Boolean) which illustrates that a self-applicable partial evaluator implements the Curry function. Self-applicable partial evaluators exist since <ref> [Jones, Sestoft & Stndergaard 85] </ref>. All the programs described here have been run with the partial evaluator of [Jones, Sestoft & Stndergaard 88] and with the Schism partial evaluator [Consel 88], both of which are self-applicable. We will use Mix generically for naming any partial evaluator. <p> Let us illustrate this, by partially evaluating that program with respect to a pattern string (a b a). By Mix's binding time analysis <ref> [Jones, Sestoft & Stndergaard 85] </ref> [Jones, Sestoft & Stndergaard 88], 1 In Mix Mix PM, Mix designates a program text and Mix designates its meaning, that is an input-output function.
Reference: [Jones, Sestoft & Stndergaard 88] <author> Neil D. Jones, Peter Sestoft, Harald Stndergaard: </author> <title> MIX: a Self-Applicable Partial Evaluator for Experiments in Compiler Generation, </title> <note> to appear in the international journal LISP and Symbolic Computation (1988) </note>
Reference-contexts: The semantics of the residual program is a function: Pattern-String ! (Subject-String ! Boolean) which illustrates that a self-applicable partial evaluator implements the Curry function. Self-applicable partial evaluators exist since [Jones, Sestoft & Stndergaard 85]. All the programs described here have been run with the partial evaluator of <ref> [Jones, Sestoft & Stndergaard 88] </ref> and with the Schism partial evaluator [Consel 88], both of which are self-applicable. We will use Mix generically for naming any partial evaluator. <p> Let us illustrate this, by partially evaluating that program with respect to a pattern string (a b a). By Mix's binding time analysis [Jones, Sestoft & Stndergaard 85] <ref> [Jones, Sestoft & Stndergaard 88] </ref>, 1 In Mix Mix PM, Mix designates a program text and Mix designates its meaning, that is an input-output function. The result is a (residual) program text. 2 variables p and pp are identified as static that is, computable from the pattern alone.
Reference: [Rees & Clinger 86] <editor> Jonathan Rees, William Clinger (eds.): </editor> <title> Revised 3 Report on the Algorithmic Language Scheme, </title> <journal> Sigplan Notices, </journal> <volume> Vol. </volume> <pages> 21, </pages> <note> No 12 pp 37-79 (December 1986) </note>
Reference-contexts: We will use Mix generically for naming any partial evaluator. Below, we reproduce the parts processed with Schism because they are written in Scheme <ref> [Rees & Clinger 86] </ref> and are thus readable without further description. Section 1 presents the naive algorithm and section 2 proposes one single transformation and its partial evaluation. Section 4 optimizes further the construction.
Reference: [Weiner 72] <author> P. Weiner: </author> <title> Linear Pattern Matching Algorithms, </title> <booktitle> IEEE Symposium on Switching and Automata Theory, </booktitle> <volume> Vol. </volume> <pages> 14 pp 1-11, </pages> <publisher> IEEE, </publisher> <address> New York (1972) 7 </address>
Reference-contexts: Finally let us point out that a pattern matching program could be specialized as well with respect to the subject string. However the residual program can be huge. This would need some better insight into suffix trees <ref> [Weiner 72] </ref>. It is our hope that this work contributes to present partial evaluation as an active help for creating and designing algorithms and programs. Acknowledgements To Neil D. Jones for his thoughtful interaction and support, and Peter Sestoft and Andrzej Filinski for their re-reading.
References-found: 9

