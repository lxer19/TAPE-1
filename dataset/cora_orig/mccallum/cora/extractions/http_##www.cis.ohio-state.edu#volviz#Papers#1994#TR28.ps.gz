URL: http://www.cis.ohio-state.edu/volviz/Papers/1994/TR28.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/volviz/papers_date.html
Root-URL: http://www.cis.ohio-state.edu
Title: Data-Parallel Volume Rendering Algorithms  
Author: Roni Yagel and Raghu Machiraju 
Affiliation: Department of Computer and Information Science The Ohio State University  
Abstract: Images generated from volumetric datasets are increasingly being used in many biomedical disciplines, archeology, geology, high energy physics, computational chemistry, computational uid dynamics, meteorology, astronomy, computer aided design, environmental sciences, and many others. However, given the overwhelming amounts of computations required for accurate manipulation and rendering of 3D rasters, it is obvious that special purpose hardware, parallel processing or a combination of both are imperative. In this presentation we consider the image composition scheme for parallel volume rendering in which each processor is assigned a portion of the volume. A processor renders only its data by using any existing volume rendering algorithm. We describe one such parallel algorithm that also takes advantage of vector processing capabilities. The resulting images from all processors are then combined (composited) in visibility order to form the final image. The major advantage of this approach is that, as viewing and shading parameters change, only 2D partial images are communicated among processors and not 3D volume data. Through experimental results and performance analysis we show that our parallel algorithm is amenable to extremely efficient implementations on distributed memory MIMD (Multiple Instruction Multiple Data) vector-processor architectures. It is also very suitable for hardware implementation based on image composition architectures, it supports various volume rendering algorithms, and it can be extended to provide load-balanced execution and to support rendering of unstructured grids. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Barnett, M., Littlefield, R., Payne, D.G., van de Geijn, R., </author> <title> Global Combine on Mesh Architec tures with Wormhole Routing, </title> <booktitle> Proceedings of International Parallel Processing Symposium, </booktitle> <year> 1993, </year> <month> pp.156-162 </month>
Reference-contexts: He however, did not study the image combining problem in detail. Image combining belongs to a class of operations called global combining which includes addition, subtraction, etc. of vectors. It is an associative, albeit non-commutative operation. Barnett et al. <ref> [1] </ref> proposed several methods to perform global combining on mesh connected machines. All but a few of these methods can be adapted to perform image combining. <p> Maa et al. [13] actually used a scheme called binary compositing which is similar to the recursive halving scheme proposed by Barnett et al. <ref> [1] </ref>. The recursive halving scheme, although more efficient, gives rise to more communication than the simple hierarchical method. A pipelined version of the simple hierarchical fan-in scheme can be 3 1 FIGURE 3. <p> The choice of one method of combining over the other can only be determined by the size of the images, the number of processors, the topology of the inter-connection network and the routing strategy used. Once again, Barnett et al. <ref> [1] </ref> performed a comparative study of the different methods of combining in which he concludes that for fewer number of processors, the simple fan-in scheme is more suitable. Also, for some compositing schemes, like the Z-buffer, specialized procedures can be developed for efficient execution on some architectures [4].
Reference: [2] <author> Cameron, G.G, Underill, </author> <title> P.E.,Rendering Volumetric Medical Image Data on a SIMD Architec ture Computer, </title> <booktitle> SPIE, Visualization in Biomedical Computing 1992, </booktitle> <volume> Vol. 1808, </volume> <pages> pp. </pages> <address> 137- 142. </address>
Reference-contexts: Most current implementations of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement. However, reported implementation of data-order methods are fewer <ref> [2] </ref>, [6], [8], [22], [29], since these methods are not very amenable to optimizations (such as adaptive sampling and early ray termination) and all voxels have to be considered to render the image. <p> The resulting implementation was not scalable since it required the communication of large amount of 3D volume data. It also suffered from the disadvantage of having computations and communication interspersed. The implementations by Schroeder and Salem [22], Vezina et al. [29], and Cameron and Underill <ref> [2] </ref> used the multi-pass method and were conducted on SIMD (Single-Instruction-Multiple-Data) machines. In these data parallel implementations communication and computations are conducted in separate phases. However, the communication is too fine grained, extensive, and frequent for an efficient implementation on MIMD machines.
Reference: [3] <author> Corrie, B., Mackerras, P., </author> <title> Data Coherence in Volume Rendering Algorithm, </title> <booktitle> Proceedings of 1993 Parallel Rendering Symposium, </booktitle> <address> San Jose, CA, </address> <year> 1993, </year> <pages> pp. 23-26. </pages>
Reference-contexts: The computational requirements increase by a few orders when images of high quality are required. Hence the need for parallel processing is mandatory for rendering volumes. There exists a growing amount of reported work on parallel volume rendering. Several researchers explored parallelization of the image order approach <ref> [3] </ref>, [16], [19], [23], [24]. The reader is directed to published surveys of various methods [10], [14], [17], [28]. Most current implementations of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement.
Reference: [4] <author> Cox, M., Hanrahan, P., </author> <title> Pixel Merging for Object-Parallel Rendering: a Distributed Snooping Algorithm, </title> <booktitle> Proceedings of 1993 Parallel Rendering Symposium, </booktitle> <address> San Jose, CA, </address> <year> 1993, </year> <pages> pp. 49 56. </pages>
Reference-contexts: Also, for some compositing schemes, like the Z-buffer, specialized procedures can be developed for efficient execution on some architectures <ref> [4] </ref>. An interesting extension of the image composition approach leads to data streaming volume rendering. This approach is particularly suitable if the number of primitives largely exceeds the number of processors. The data primitives are divided into separate groups, once again in visibility order, and are given to processors cyclically.
Reference: [5] <author> Ebert, D. S., Parent, R. </author> <title> E.,Rendering and Animation of Gaseous Phenomena by Combining Fast Volume and Scanline A-buffer Techniques, </title> <journal> Computer Graphics, Vol.24, </journal> <volume> No. 4, </volume> <month> August </month> <year> 1990, </year> <pages> pp. 357-366. </pages>
Reference-contexts: Explicit hidden volume elimination is required for data-order methods. Z-buffer and front-to-back [21] and back-to-front [7] methods have been commonly employed, while the A-buffer <ref> [5] </ref> method has been used for rendering gaseous volumes. Ideally, the composition operation is tantamount to evaluating an integral [26]. However, a linear operator like the Porter and Duffs [20] over operator suffices for most practical renderings.
Reference: [6] <author> Elvins, T. </author> <title> T.,Volume Rendering on a Distributed Memory Parallel Computer, </title> <booktitle> Proceedings of Visualization92, </booktitle> <address> Boston MA, </address> <month> October </month> <year> 1992, </year> <pages> pp. 93-98. </pages>
Reference-contexts: Most current implementations of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement. However, reported implementation of data-order methods are fewer [2], <ref> [6] </ref>, [8], [22], [29], since these methods are not very amenable to optimizations (such as adaptive sampling and early ray termination) and all voxels have to be considered to render the image. Elvins [6] and Machiraju and Yagel [14] used splatting as the reconstruction method of choice on MIMD (Multiple-Instruction 4 <p> However, reported implementation of data-order methods are fewer [2], <ref> [6] </ref>, [8], [22], [29], since these methods are not very amenable to optimizations (such as adaptive sampling and early ray termination) and all voxels have to be considered to render the image. Elvins [6] and Machiraju and Yagel [14] used splatting as the reconstruction method of choice on MIMD (Multiple-Instruction 4 Multiple-Data) machines. Elvins in his implementation took a functional approach to parallelization, wherein the tasks were mapped to processors based on functions of the pipeline and not on the volume data itself.
Reference: [7] <author> Frieder, G., Gordon, D., </author> <title> Reynolds R.,Back to Front Display of Voxel-Based Objects, </title> <journal> Com puter Graphics and Applications, </journal> <volume> Vol. 5, No. 1, </volume> <month> January </month> <year> 1985, </year> <pages> pp. 52-60. </pages>
Reference-contexts: The contribution of a voxel to different pixels is weighted by the entry in the table indexed by the offset of the pixel from the center of the splat. Explicit hidden volume elimination is required for data-order methods. Z-buffer and front-to-back [21] and back-to-front <ref> [7] </ref> methods have been commonly employed, while the A-buffer [5] method has been used for rendering gaseous volumes. Ideally, the composition operation is tantamount to evaluating an integral [26]. However, a linear operator like the Porter and Duffs [20] over operator suffices for most practical renderings. <p> As a result, primitives can be drawn to the screen in a back-to-front <ref> [7] </ref> or front-to-back [21] order without additional consideration to hidden object removal. In Section 5 we discuss the effect of different primitives on the performance of rendering algorithms. In the following subsection we describe the incremental transformation scheme, which is integrated into our image composition based renderers.
Reference: [8] <author> Goldwasser, S. M., Reynolds, R. A., Talton, D. A., Walsh, E. </author> <title> S.,High Performance Graphics Processors for Medical Imaging Applications, Parallel Processing for Computer Vision and Display, Dew, </title> <editor> P. M., Earnshaw, R. A., and Heywood, T. R., (eds.), </editor> <publisher> Addison-Wesley, </publisher> <year> 1989, </year> <pages> pp. 461-470. </pages>
Reference-contexts: Most current implementations of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement. However, reported implementation of data-order methods are fewer [2], [6], <ref> [8] </ref>, [22], [29], since these methods are not very amenable to optimizations (such as adaptive sampling and early ray termination) and all voxels have to be considered to render the image.
Reference: [9] <author> Hanrahan, </author> <title> P.,Three-Pass Affine Transforms for Volume Rendering, </title> <journal> Computer Graphics, </journal> <volume> Vol ume 24, No. 5, </volume> <month> November </month> <year> 1990, </year> <pages> pp. 71-77. </pages>
Reference-contexts: Hybrid methods exist in which the volume is traversed in both object and image order [26]. These approaches also differ in the way reconstruction is achieved. In the data-order approach the data samples are convolved with a finite filter kernel to reconstruct an original signal <ref> [9] </ref>, [27]. In the image-order approach the original signal is reconstructed by a trilinear interpolation from a neighborhood of voxel values [11]. A rendering algorithm integrates all of the above steps in some order. <p> Hanrahan proposed a reconstruction/transformation method that decomposes the transformation matrix into a series of lower dimensional shears <ref> [9] </ref>. Such a multi-pass shear 9 decomposition would allow for the easier supersampling operation along a single dimension (see several two dimensional convolution operations. Splatting spreads opacity and color of a voxel to several pixels. For parallel projections, a discrete filter kernel table can be employed.
Reference: [10] <author> Kaufman, A., Bakalash, R., Cohen, D., Yagel, R., </author> <title> A Survey of Architectures for Volume Ren dering, </title> <journal> IEEE Engineering in Medicine and Biology, </journal> <volume> Vol. 9, No. 4, </volume> <month> December </month> <year> 1990, </year> <month> pp.18-23. </month>
Reference-contexts: Hence the need for parallel processing is mandatory for rendering volumes. There exists a growing amount of reported work on parallel volume rendering. Several researchers explored parallelization of the image order approach [3], [16], [19], [23], [24]. The reader is directed to published surveys of various methods <ref> [10] </ref>, [14], [17], [28]. Most current implementations of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement.
Reference: [11] <author> Levoy, M., </author> <title> Display of Surfaces from Volume Data, </title> <journal> IEEE Computer Graphics and Applica tions, </journal> <volume> Vol. 8, No. 5, </volume> <month> May </month> <year> 1988, </year> <pages> pp. 29-37. </pages>
Reference-contexts: The volume is then shaded in screen space (c) and all colors along a line of sight are composited from back-to-front (d) to form the final image. View Shade Compose (a) (b) (d)(c) Reconstruct 3 sight ray from the pixel <ref> [11] </ref>, [25]. The voxels the ray pierces as it penetrates the volume are mapped to the original pixel. Hybrid methods exist in which the volume is traversed in both object and image order [26]. These approaches also differ in the way reconstruction is achieved. <p> In the data-order approach the data samples are convolved with a finite filter kernel to reconstruct an original signal [9], [27]. In the image-order approach the original signal is reconstructed by a trilinear interpolation from a neighborhood of voxel values <ref> [11] </ref>. A rendering algorithm integrates all of the above steps in some order. The exact order is determined usually by taking into account the trade-off between image quality and rendering efficiency. <p> The exact order is determined usually by taking into account the trade-off between image quality and rendering efficiency. For example, some methods shade the volume before reconstruction and viewing, avoiding the need to reshade whenever viewing parameters change <ref> [11] </ref>. Sometimes shading can be delayed and performed after viewing [30]. In Section 3.1 we will see some data-order variations of the volume rendering pipeline.
Reference: [12] <author> Lo, V., M., Rajopadhye, S., Gupta, G., </author> <title> Mapping Divide and Conquer Algorithms to Parallel Architectures, </title> <booktitle> Proceedings of International Conference on Parallel Processing, </booktitle> <volume> Vol. III, </volume> <pages> pp. 128-135, </pages> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: It is an associative, albeit non-commutative operation. Barnett et al. [1] proposed several methods to perform global combining on mesh connected machines. All but a few of these methods can be adapted to perform image combining. Lo et al. <ref> [12] </ref> proposed a scheme to map divide and conquer algorithms to meshes, which can be adapted to the image combining problem, successfully achieving a very efficient implementation.
Reference: [13] <author> Maa, K., L., Painter, J., S., Hansen, C., D., Krogh, M., F., </author> <title> A Data Distributed, </title> <booktitle> Parallel Algo rithm for Ray-Trace Volume Rendering, Proceedings of 1993 Parallel Rendering Symposium, </booktitle> <address> October 1993, San Jose, CA, pp.15-22. </address>
Reference-contexts: The image composition approach is versatile and can be applied to many rendering methods. Later, we show how two data-order algorithms (splatting and Z-buffer) are implemented under the image compositing paradigm. Recently, Maa et al. proposed the use of image composition to implement a volume ray-caster <ref> [13] </ref>. Even the rendering of any polyhedral (unstructured or irregular) grid can be accommodated in this model. The data space is divided into subvolumes by embedding the object space in a regular grid. Each processor renders the data clipped to its assigned subspace. <p> All but a few of these methods can be adapted to perform image combining. Lo et al. [12] proposed a scheme to map divide and conquer algorithms to meshes, which can be adapted to the image combining problem, successfully achieving a very efficient implementation. Maa et al. <ref> [13] </ref> actually used a scheme called binary compositing which is similar to the recursive halving scheme proposed by Barnett et al. [1]. The recursive halving scheme, although more efficient, gives rise to more communication than the simple hierarchical method.
Reference: [14] <author> Machiraju, R., Yagel, R. </author> <title> Efficient Feed-Forward Volume Rendering Techniques for Vector and Parallel Processors, </title> <booktitle> Proceedings of SUPERCOMPUTING93, </booktitle> <address> Portland, Oregon, </address> <month> November </month> <year> 1993, </year> <pages> pp. 699-708. </pages>
Reference-contexts: Hence the need for parallel processing is mandatory for rendering volumes. There exists a growing amount of reported work on parallel volume rendering. Several researchers explored parallelization of the image order approach [3], [16], [19], [23], [24]. The reader is directed to published surveys of various methods [10], <ref> [14] </ref>, [17], [28]. Most current implementations of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement. <p> However, reported implementation of data-order methods are fewer [2], [6], [8], [22], [29], since these methods are not very amenable to optimizations (such as adaptive sampling and early ray termination) and all voxels have to be considered to render the image. Elvins [6] and Machiraju and Yagel <ref> [14] </ref> used splatting as the reconstruction method of choice on MIMD (Multiple-Instruction 4 Multiple-Data) machines. Elvins in his implementation took a functional approach to parallelization, wherein the tasks were mapped to processors based on functions of the pipeline and not on the volume data itself. <p> Thus, viewing transformations in any volume rendering pipeline can implement incremental computations. Slices are enumerated in visibility order and are transformed one at a time and processed in the successive stages of the pipeline. A more detailed description of incremental schemes is available in <ref> [14] </ref>. A consequence of the incremental scheme could be the increased error in the computation of the transformed coordinates. The accumulated error for 3N 3 oating point additions in a non-vectorized incremental scheme with no separate phases can be significant if N is very large.
Reference: [15] <author> Molnar, S., Eyles, J., Poulton J., PixelFlow: </author> <title> High-Speed Rendering Using Image Composi tion, </title> <journal> Computer Graphics, </journal> <volume> Vol. 26, No. 2, </volume> <month> July </month> <year> 1992, </year> <pages> pp. 231-240. </pages>
Reference-contexts: In this paper we consider a general scheme for parallel volume rendering, described in Section 2. We describe an algorithm in this paper that has an extremely efficient implementation on distributed memory MIMD architectures and is suitable for hardware implementation based on the image composition architectures <ref> [15] </ref>. This data parallel scheme assigns a portion of the volume to each processor which renders it with any one of the above mentioned rendering algorithms. The resulting images from all processors are then combined (composited) in visibility order to form the final image. <p> Volume Rendering by Parallel Image Composition Of late, image composition approaches are gaining attention from researchers. Molnar et al. proposed and built image composition architectures <ref> [15] </ref>. Although their efforts were not directed towards volumes and primarily targeted towards hardware implementations, a similar approach can be adopted in software to render volumes on any given parallel architecture. Figure 2 shows schematically the image composition approach applied to the rendering pipeline described in Section 1. <p> Molnar et al. used separate processors, namely rendering, shading and compositing engines, to implement the image composition architecture <ref> [15] </ref>. The rendering engines implement the pipelines and then pass on the resulting local images to the compositors which then co-operatively combine them to obtain a final image. In software implementations on general purpose parallel machines, the functions of both the renderers and compositors are performed by the same processors. <p> The reason lies in the network congestion that arises when all processors attempt to send their images to a single distinguished processor. Molnar used a ring as an intercon N p ( ) I 7 nection network where the compositors function in a pipelined fashion (Figure 3b) <ref> [15] </ref>. Processors operate in a staggered fashion in which processor 1 (Figure 3b) finishes rendering its volume when the composited image (of 3 and 2) is ready and coming from processor 2.
Reference: [16] <author> Montani, C., Perego, R., Scopigno R., </author> <title> Parallel Volume Visualization on a Hypercube Architec ture, </title> <booktitle> Proceedings of 1992 Workshop on Volume Visualization, </booktitle> <address> October 1992, Boston, MA, </address> <pages> pp. 9-15. </pages>
Reference-contexts: The computational requirements increase by a few orders when images of high quality are required. Hence the need for parallel processing is mandatory for rendering volumes. There exists a growing amount of reported work on parallel volume rendering. Several researchers explored parallelization of the image order approach [3], <ref> [16] </ref>, [19], [23], [24]. The reader is directed to published surveys of various methods [10], [14], [17], [28]. Most current implementations of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement.
Reference: [17] <author> Neumann, U., </author> <title> Volume Reconstruction and Parallel Rendering ALgorithms: A Comparative 34 Analysis, </title> <type> Ph. D Thesis, </type> <institution> University of North Carolina at Chapel Hill, </institution> <year> 1993. </year>
Reference-contexts: Hence the need for parallel processing is mandatory for rendering volumes. There exists a growing amount of reported work on parallel volume rendering. Several researchers explored parallelization of the image order approach [3], [16], [19], [23], [24]. The reader is directed to published surveys of various methods [10], [14], <ref> [17] </ref>, [28]. Most current implementations of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement. <p> The color assigned to the pixel is that of the background or the accumulated color obtained by traversing the object and performing the compositing operation. Holes are not created in images rendered by image-order methods. Neumann <ref> [17] </ref> provides a comparison of splatting, ray casting, and multi-pass shears. He compares the execution efficiencies on workstations and the resulting quality of images produced. <p> Load imbalances between processors can occur especially for sparsely populated volumes with a non-uniform distribution of occupied voxels. Different primitives lead to different strategies and hence varying levels of performance. Neumann has studied the effect of different primitives on the performance of parallel volume rendering algorithms <ref> [17] </ref>. However, most of his efforts were not directed towards data-order methods. 31 5.2 Z-buffer Pipeline Table 6 shows the stagewise performance of the pipeline. We once again consider each stage of the pipeline. The rendering times for the Z-buffer are listed in the first row.
Reference: [18] <author> Neumann, U., </author> <title> Parallel Volume-Rendering Performance on Mesh-Connected Multicomputers, </title> <booktitle> Proceedings of 1993 Parallel Rendering Symposium, </booktitle> <address> October 1993, San Jose, CA, pp.97-104. </address>
Reference-contexts: In the latter strategy, combining is implemented in a tree-like divide-and-conquer fashion on parallel processors. In log (p) steps, the final image is created. The actual implementation should take into consideration the interconnection network used and the routing strategies implemented on the parallel processor. Neumann <ref> [18] </ref> attempted to study the communication performance of volume rendering algorithms. He performed empirical analysis and conducted experiments for both object and image order volume rendering implementations on distributed memory machines. He however, did not study the image combining problem in detail.
Reference: [19] <author> Nieh, J., Levoy, </author> <title> M.,Volume Rendering on Scalable Shared-Memory MIMD Architecture, </title> <booktitle> Proceedings of 1992 Workshop on Volume Visualization, </booktitle> <address> Boston, MA, </address> <pages> pp. 17-24. </pages>
Reference-contexts: The computational requirements increase by a few orders when images of high quality are required. Hence the need for parallel processing is mandatory for rendering volumes. There exists a growing amount of reported work on parallel volume rendering. Several researchers explored parallelization of the image order approach [3], [16], <ref> [19] </ref>, [23], [24]. The reader is directed to published surveys of various methods [10], [14], [17], [28]. Most current implementations of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement.
Reference: [20] <author> Porter, T., Duff, </author> <title> T.,Compositing Digital Images, </title> <journal> Computer Graphics, </journal> <volume> Vol. 18, No.3, </volume> <month> July </month> <year> 1984, </year> <pages> pp. 253-259. </pages>
Reference-contexts: Z-buffer and front-to-back [21] and back-to-front [7] methods have been commonly employed, while the A-buffer [5] method has been used for rendering gaseous volumes. Ideally, the composition operation is tantamount to evaluating an integral [26]. However, a linear operator like the Porter and Duffs <ref> [20] </ref> over operator suffices for most practical renderings. Semi-transparent objects or surfaces can be rendered only if a linear or higher order compositing operator is employed. Alternatively, a Z-buffer can be used to generate depth-cued images for opaque volumes. The composition operator here takes the form of a minimum operator. <p> The incremental scheme of the previous section is used in the first stage of the pipeline. Shading is conducted using the Phong illumination model, while reconstruction through splatting is done with a Gaussian filter. The over operator is used to composite the current slice with the accumulated local image <ref> [20] </ref>. All local images are then combined in parallel using the over operator once again. The transformation and compositing stages are easily amenable to vectorization and have been implemented as vectorized algorithms. The performance of the splatting stage depends more on the nature of data than the other stages. <p> The end result of the splatting stage is a set of reconstructed and shaded image slices of size I 2 on each processor of the parallel ensemble. Composition The composition operation implemented as a linear Porter and Duff over operator <ref> [20] </ref> is highly ame nable to pipelining or vector execution. The operator is listed by equations and 15 and 16. FIGURE 8.
Reference: [21] <author> Reynolds, R., Gordon, G., Chen, L., </author> <title> A Dynamic Screen Technique for Shaded Graphic Display of Slice-Repre sented Objects, Computer Vision, Graphics, </title> <booktitle> Image Processing, </booktitle> <volume> Vol. 38, No. 3, </volume> <month> June </month> <year> 1987, </year> <pages> pp. 275-298. </pages>
Reference-contexts: The contribution of a voxel to different pixels is weighted by the entry in the table indexed by the offset of the pixel from the center of the splat. Explicit hidden volume elimination is required for data-order methods. Z-buffer and front-to-back <ref> [21] </ref> and back-to-front [7] methods have been commonly employed, while the A-buffer [5] method has been used for rendering gaseous volumes. Ideally, the composition operation is tantamount to evaluating an integral [26]. However, a linear operator like the Porter and Duffs [20] over operator suffices for most practical renderings. <p> As a result, primitives can be drawn to the screen in a back-to-front [7] or front-to-back <ref> [21] </ref> order without additional consideration to hidden object removal. In Section 5 we discuss the effect of different primitives on the performance of rendering algorithms. In the following subsection we describe the incremental transformation scheme, which is integrated into our image composition based renderers.
Reference: [22] <author> Schroder, P., Salem, J. B., </author> <title> Fast Rotation of Volume Data on Data Parallel Architecture, </title> <booktitle> Proceedings of Visual ization91, </booktitle> <address> San Diego, CA, </address> <pages> pp. 50-57. </pages>
Reference-contexts: Most current implementations of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement. However, reported implementation of data-order methods are fewer [2], [6], [8], <ref> [22] </ref>, [29], since these methods are not very amenable to optimizations (such as adaptive sampling and early ray termination) and all voxels have to be considered to render the image. <p> The resulting implementation was not scalable since it required the communication of large amount of 3D volume data. It also suffered from the disadvantage of having computations and communication interspersed. The implementations by Schroeder and Salem <ref> [22] </ref>, Vezina et al. [29], and Cameron and Underill [2] used the multi-pass method and were conducted on SIMD (Single-Instruction-Multiple-Data) machines. In these data parallel implementations communication and computations are conducted in separate phases.
Reference: [23] <author> Schroder, P. and Krueger, </author> <title> Data Parallel Volume Rendering Algorithm for Interactive Visualization, </title> <journal> The Visual Computer, </journal> <volume> 9, </volume> <pages> pp. 405-416, </pages> <year> 1993. </year>
Reference-contexts: Hence the need for parallel processing is mandatory for rendering volumes. There exists a growing amount of reported work on parallel volume rendering. Several researchers explored parallelization of the image order approach [3], [16], [19], <ref> [23] </ref>, [24]. The reader is directed to published surveys of various methods [10], [14], [17], [28]. Most current implementations of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement.
Reference: [24] <author> Stredney, D., Yagel, R., May, S. F., Torello, M., </author> <title> Supercomputer Assisted Brain Visualization with an Extended Ray Tracer,1992 Workshop on Volume Visualization, </title> <address> Boston, MA, </address> <pages> pp. 33-38. </pages>
Reference-contexts: Hence the need for parallel processing is mandatory for rendering volumes. There exists a growing amount of reported work on parallel volume rendering. Several researchers explored parallelization of the image order approach [3], [16], [19], [23], <ref> [24] </ref>. The reader is directed to published surveys of various methods [10], [14], [17], [28]. Most current implementations of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement.
Reference: [25] <author> Tuy H.K. and Tuy L.T., </author> <title> Direct 2-D Display of 3-D Objects, </title> <journal> IEEE Computer Graphics & Applications, </journal> <volume> 4, 10, </volume> <month> November </month> <year> 1984, </year> <pages> pp. 29-33. </pages>
Reference-contexts: The volume is then shaded in screen space (c) and all colors along a line of sight are composited from back-to-front (d) to form the final image. View Shade Compose (a) (b) (d)(c) Reconstruct 3 sight ray from the pixel [11], <ref> [25] </ref>. The voxels the ray pierces as it penetrates the volume are mapped to the original pixel. Hybrid methods exist in which the volume is traversed in both object and image order [26]. These approaches also differ in the way reconstruction is achieved.
Reference: [26] <author> Upson, V., Keeler, M., V-Buffer: </author> <title> Visible Volume Rendering, </title> <journal> Computer Graphics, </journal> <volume> Vol. 22, No. 4, </volume> <month> August </month> <year> 1988, </year> <pages> pp. 59-64. </pages>
Reference-contexts: View Shade Compose (a) (b) (d)(c) Reconstruct 3 sight ray from the pixel [11], [25]. The voxels the ray pierces as it penetrates the volume are mapped to the original pixel. Hybrid methods exist in which the volume is traversed in both object and image order <ref> [26] </ref>. These approaches also differ in the way reconstruction is achieved. In the data-order approach the data samples are convolved with a finite filter kernel to reconstruct an original signal [9], [27]. <p> Explicit hidden volume elimination is required for data-order methods. Z-buffer and front-to-back [21] and back-to-front [7] methods have been commonly employed, while the A-buffer [5] method has been used for rendering gaseous volumes. Ideally, the composition operation is tantamount to evaluating an integral <ref> [26] </ref>. However, a linear operator like the Porter and Duffs [20] over operator suffices for most practical renderings. Semi-transparent objects or surfaces can be rendered only if a linear or higher order compositing operator is employed. Alternatively, a Z-buffer can be used to generate depth-cued images for opaque volumes.
Reference: [27] <author> Westover, </author> <title> L.,Footprint Evaluation for Volume Rendering,, </title> <journal> Computer Graphics, </journal> <volume> Vol. 24, No. 4, </volume> <month> August </month> <year> 1990, </year> <pages> pp. 367-376. </pages>
Reference-contexts: Hybrid methods exist in which the volume is traversed in both object and image order [26]. These approaches also differ in the way reconstruction is achieved. In the data-order approach the data samples are convolved with a finite filter kernel to reconstruct an original signal [9], <ref> [27] </ref>. In the image-order approach the original signal is reconstructed by a trilinear interpolation from a neighborhood of voxel values [11]. A rendering algorithm integrates all of the above steps in some order.
Reference: [28] <author> Wittenbrink, C. M., Somani, A. K., </author> <title> 2D and 3D optimal parallel image warping, </title> <booktitle> Seventh International Parallel Processing Symposium, </booktitle> <address> Newport Beach, CA, </address> <month> April 13-16, </month> <year> 1992, </year> <pages> pp. 331-337. </pages>
Reference-contexts: There exists a growing amount of reported work on parallel volume rendering. Several researchers explored parallelization of the image order approach [3], [16], [19], [23], [24]. The reader is directed to published surveys of various methods [10], [14], [17], <ref> [28] </ref>. Most current implementations of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement.
Reference: [29] <author> Vezina, G., Fletcher, P. A., Robertson, P. K., </author> <title> Volume Rendering on the MasPar MP-1, </title> <booktitle> Proceedings of 1992 Workshop on Volume Visualization, </booktitle> <address> October 1992, Boston, MA, </address> <pages> pp. 3-8. </pages>
Reference-contexts: Most current implementations of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement. However, reported implementation of data-order methods are fewer [2], [6], [8], [22], <ref> [29] </ref>, since these methods are not very amenable to optimizations (such as adaptive sampling and early ray termination) and all voxels have to be considered to render the image. Elvins [6] and Machiraju and Yagel [14] used splatting as the reconstruction method of choice on MIMD (Multiple-Instruction 4 Multiple-Data) machines. <p> The resulting implementation was not scalable since it required the communication of large amount of 3D volume data. It also suffered from the disadvantage of having computations and communication interspersed. The implementations by Schroeder and Salem [22], Vezina et al. <ref> [29] </ref>, and Cameron and Underill [2] used the multi-pass method and were conducted on SIMD (Single-Instruction-Multiple-Data) machines. In these data parallel implementations communication and computations are conducted in separate phases. However, the communication is too fine grained, extensive, and frequent for an efficient implementation on MIMD machines.
Reference: [30] <author> Yagel R., Cohen D. Kaufman A., </author> <title> Normal Estimation in 3D Discrete Space, </title> <journal> The Visual Computer, </journal> <volume> 8, </volume> <pages> 5-6, </pages> <month> June </month> <year> 1992, </year> <pages> pp. 278-291. </pages>
Reference-contexts: The exact order is determined usually by taking into account the trade-off between image quality and rendering efficiency. For example, some methods shade the volume before reconstruction and viewing, avoiding the need to reshade whenever viewing parameters change [11]. Sometimes shading can be delayed and performed after viewing <ref> [30] </ref>. In Section 3.1 we will see some data-order variations of the volume rendering pipeline. Considering the voluminous nature of 3D rasters and the overwhelming amounts of computations required for accurate reconstruction and rendering, it is obvious that special purpose hardware, parallel processing or a combination of both are imperative. <p> The normal vectors required for illumination computations are computed (if possible) or estimated from the sampled datasets. Image space shading methods assign color to voxels based either only on the depth values or on the gradient of depth values <ref> [30] </ref>. In ray-casting, rays are cast from the observers eye location through the pixels of the image. The color assigned to the pixel is that of the background or the accumulated color obtained by traversing the object and performing the compositing operation. <p> Images generated by this method are shown in Figure 12b, and Figure 13b. 3.5 Opaque Rendering with Z-buffer The Z-buffer pipeline employs the composition, shading and combining stages after the transformation stage. Composition is achieved by using a Z-buffer, while deferred shading <ref> [30] </ref> provides the color for each visible pixel on a local image. In deferred shading only visible voxels are shaded, thereby allowing for a considerable savings in rendering time.
Reference: [31] <author> Yagel R. </author> <title> Volume Rendering Polyhedral Grids by Incremental Slicing, </title> <institution> OSU-CISRC-10/93-TR35, Department of Computer and Information Science, The Ohio State University, </institution> <month> October </month> <year> 1993. </year> <title> 35 Color Images FIGURE 12. A 256 3 MRI volume rendered with Z-buffer algorithm(a) and with the splatting method (b). (a) (b) FIGURE 13. A 128 3 volume containing a sphere rendered with Z-buffer algorithm(a) and with the splatting method (b). (a) (b) </title>
Reference-contexts: The data space is divided into subvolumes by embedding the object space in a regular grid. Each processor renders the data clipped to its assigned subspace. Yagel proposed the use of a similar technique for the parallelization of his slicing-based rendering algorithm for unstructured grids <ref> [31] </ref>. The image composition paradigm allows also the subdivision of volume space in a variety of ways. One example would be the collection of subvolumes defined by a m-level octree or BSP tree.
References-found: 31

