URL: ftp://ftp.cs.toronto.edu/pub/kbms/proofs.ps.Z
Refering-URL: ftp://ftp.cs.toronto.edu/pub/kbms/readme.html
Root-URL: 
Title: Safe Locking Policies for Dynamic Databases  
Author: Vinay K Chaudhri and Vassos Hadzilacos 
Keyword: Concurrency Control, Correctness Issues  
Date: October 27, 1994  
Address: Toronto, Ontario M5S 1A4  
Affiliation: Department of Computer Science University of Toronto  
Abstract: It was shown by Yannakakis that a locking policy is not safe if and only if there exists a canonical non-serializable schedule of transactions running according to the rules of the policy in which all the transactions except one are executed serially [Yan82]. In the present paper, we study the generalization of this result to a dynamic database, that is, a database that may undergo insertions and deletions of entities. We illustrate the utility of this generalization by applying it to obtain correctness proofs of three locking policies that handle dynamic databases. 
Abstract-found: 1
Intro-found: 1
Reference: [AA90] <author> D. Agrawal and A. El Abbadi. </author> <title> Locks with Constrained Sharing. </title> <booktitle> In 9TH ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 85-93, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: It is interesting to observe that these three locking policies were developed in different contexts and are based on quite different ideas. This work can be extended in several directions. The same technique could be used to analyze other locking policies <ref> [AA90, dFRH94] </ref>. Furthermore, generalization of these results to a dynamic hypergraph policy [Yan82] and incorporating recovery considerations in it [SWY93] remains an open problem and needs to be investigated in the future. Safe Locking Policies for Dynamic Databases 11
Reference: [Cha94] <author> Vinay K Chaudhri. </author> <title> Transaction Synchronization in Knowledge Bases: Concepts, Realization and Quantitative Evaluation. </title> <type> PhD thesis, </type> <institution> University of Toronto, Toronto, </institution> <year> 1994. </year>
Reference-contexts: This characterization leads to a convenient proof technique that can be used to obtain correctness proofs for locking policies for dynamic databases. Specifically, we consider three locking policies (1) Dynamic Directed Graph policy with shared and exclusive locks (DDG-SX) <ref> [CHM92, Cha94] </ref>, which is an extension of the tree policy [SK80, KS83] and was designed by us for use in knowledge based applications, (2) Altruistic Locking [SGMS94] that was designed to deal with long-lived transactions, and (3) Dynamic Tree Policy [CM86] that allows a changing set of partial orders over a <p> We assume that we are given a directed graph representation G of the database. We assume that G is always connected and rooted. If G does not satisfy this property it can be converted into one that does by a simple construction <ref> [Cha94] </ref>. We also assume that once an object has been deleted from the database, it may not be inserted into it again. More discussion on this assumption can be found elsewhere [Cha94]. Let us now state the rules of the policy. Locking Rules for a Transaction T L1. <p> If G does not satisfy this property it can be converted into one that does by a simple construction <ref> [Cha94] </ref>. We also assume that once an object has been deleted from the database, it may not be inserted into it again. More discussion on this assumption can be found elsewhere [Cha94]. Let us now state the rules of the policy. Locking Rules for a Transaction T L1. Before a transaction T performs any INSERT, DELETE or WRITE operation on a node A (or an edge (A; B)), T has to lock A (both A and B) in exclusive mode.
Reference: [CHM92] <author> Vinay K Chaudhri, Vassos Hadzilacos, and John Mylopoulos. </author> <title> Concurrency Control for Knowledge Bases. </title> <booktitle> In Proceedings of the Third International Conference on Knowledge Representation and Reasoning, </booktitle> <pages> pages 762-773, </pages> <year> 1992. </year>
Reference-contexts: This characterization leads to a convenient proof technique that can be used to obtain correctness proofs for locking policies for dynamic databases. Specifically, we consider three locking policies (1) Dynamic Directed Graph policy with shared and exclusive locks (DDG-SX) <ref> [CHM92, Cha94] </ref>, which is an extension of the tree policy [SK80, KS83] and was designed by us for use in knowledge based applications, (2) Altruistic Locking [SGMS94] that was designed to deal with long-lived transactions, and (3) Dynamic Tree Policy [CM86] that allows a changing set of partial orders over a <p> To take advantage of the graph-like structure of such systems, we extended the DAG policy [SK80, Yan82] to the Dynamic Directed Graph (DDG) policy which can deal with general dynamic graphs <ref> [CHM92] </ref>. DDG-SX is the variant of this policy that supports both shared and exclusive locks. We first define some properties of directed graphs that are necessary for specifying our algorithm. A root of a directed graph is a node that does not have any predecessors.
Reference: [CM86] <author> Albert Croker and David Maier. </author> <title> A Dynamic Tree-Locking Protocol. </title> <booktitle> In Proceedings of the International Conference in Data Engineering, </booktitle> <pages> pages 49-56, </pages> <address> Los Angeles, CA, </address> <year> 1986. </year>
Reference-contexts: Dynamic Directed Graph policy with shared and exclusive locks (DDG-SX) [CHM92, Cha94], which is an extension of the tree policy [SK80, KS83] and was designed by us for use in knowledge based applications, (2) Altruistic Locking [SGMS94] that was designed to deal with long-lived transactions, and (3) Dynamic Tree Policy <ref> [CM86] </ref> that allows a changing set of partial orders over a database. It is interesting to note that these locking policies were developed in quite different contexts. The organization of this paper is as follows. <p> Hence the assumed canonical non-serializable schedule does not exist and the locking policy is safe. 2 6 Dynamic Tree Policy The Dynamic Tree (DTR) Policy was proposed to allow a changing set of partial orders to be defined over the objects in a database <ref> [CM86] </ref>. Thus, instead of assuming that we are given a directed graph corresponding to the database, the DTR policy defines a forest for itself.
Reference: [dFRH94] <author> Fernando de Ferreira Rezende and Theo Harder. </author> <title> A Lock Method for KBMSs Using Abstraction Relationships' Semantics. </title> <booktitle> In Proceedings of the Third International Conference on Knowledge Management, </booktitle> <year> 1994. </year> <note> To Appear. </note>
Reference-contexts: It is interesting to observe that these three locking policies were developed in different contexts and are based on quite different ideas. This work can be extended in several directions. The same technique could be used to analyze other locking policies <ref> [AA90, dFRH94] </ref>. Furthermore, generalization of these results to a dynamic hypergraph policy [Yan82] and incorporating recovery considerations in it [SWY93] remains an open problem and needs to be investigated in the future. Safe Locking Policies for Dynamic Databases 11
Reference: [KS83] <author> Z. M. Kedem and A. Silberschatz. </author> <title> Locking Protocols: From Exclusive to Shared Locks. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 30(4) </volume> <pages> 787-804, </pages> <year> 1983. </year>
Reference-contexts: This characterization leads to a convenient proof technique that can be used to obtain correctness proofs for locking policies for dynamic databases. Specifically, we consider three locking policies (1) Dynamic Directed Graph policy with shared and exclusive locks (DDG-SX) [CHM92, Cha94], which is an extension of the tree policy <ref> [SK80, KS83] </ref> and was designed by us for use in knowledge based applications, (2) Altruistic Locking [SGMS94] that was designed to deal with long-lived transactions, and (3) Dynamic Tree Policy [CM86] that allows a changing set of partial orders over a database.
Reference: [Pap79] <author> Christos Papadimitriou. </author> <title> Serializability of Concurrent Database Updates. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 26(4) </volume> <pages> 631-653, </pages> <month> October </month> <year> 1979. </year>
Reference-contexts: A schedule S is proper for a structural state G, if S (G) is defined. Safe Locking Policies for Dynamic Databases 3 When each write is preceded by a read, correctness (serializability) of a schedule S is equivalent to acyclicity of the serializability graph D (S) <ref> [Pap79] </ref>. If D (S) contains no cycles, then the schedule S is serializable. This condition is necessary if every WRITE is preceded by a READ and that is the assumption we adopt for the rest of this paper.
Reference: [SGMS94] <author> Kenneth Salem, Hector Garcia-Molina, and Jeannie Shands. </author> <title> Altruistic Locking. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(1) </volume> <pages> 117-164, </pages> <year> 1994. </year>
Reference-contexts: Specifically, we consider three locking policies (1) Dynamic Directed Graph policy with shared and exclusive locks (DDG-SX) [CHM92, Cha94], which is an extension of the tree policy [SK80, KS83] and was designed by us for use in knowledge based applications, (2) Altruistic Locking <ref> [SGMS94] </ref> that was designed to deal with long-lived transactions, and (3) Dynamic Tree Policy [CM86] that allows a changing set of partial orders over a database. It is interesting to note that these locking policies were developed in quite different contexts. The organization of this paper is as follows. <p> This is a contradiction. Hence such a schedule S 0 does not exist and the DDG-SX policy must be safe. 2 5 Altruistic Locking Altruistic locking was developed to deal with long-lived transactions <ref> [SGMS94] </ref>. We first define the rules of the altruistic locking policy for a database that undergoes insertions and deletions of entities [SGMS94]. We consider the basic version of altruistic locking in which all locks are exclusive. We assume that an ACCESS operation represents a READ immediately followed by a WRITE. <p> Hence such a schedule S 0 does not exist and the DDG-SX policy must be safe. 2 5 Altruistic Locking Altruistic locking was developed to deal with long-lived transactions <ref> [SGMS94] </ref>. We first define the rules of the altruistic locking policy for a database that undergoes insertions and deletions of entities [SGMS94]. We consider the basic version of altruistic locking in which all locks are exclusive. We assume that an ACCESS operation represents a READ immediately followed by a WRITE. Safe Locking Policies for Dynamic Databases 9 The last lock acquired by a transaction is known as its locked point. <p> This may be relaxed, but only at the cost of several additional assumptions <ref> [SGMS94] </ref>. We now outline the correctness proof of the altruistic locking using Theorem 1. More details are given in Appendix B. Theorem 3 The altruistic locking policy is safe. Proof Outline. We assume the contrary and construct a a canonical non-serializable schedule as in Theorem 1.
Reference: [SK80] <author> A. Silberschatz and Z. M. Kedem. </author> <title> Consistency in Hierarchical Database Systems. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 27(1) </volume> <pages> 72-80, </pages> <year> 1980. </year>
Reference-contexts: This characterization leads to a convenient proof technique that can be used to obtain correctness proofs for locking policies for dynamic databases. Specifically, we consider three locking policies (1) Dynamic Directed Graph policy with shared and exclusive locks (DDG-SX) [CHM92, Cha94], which is an extension of the tree policy <ref> [SK80, KS83] </ref> and was designed by us for use in knowledge based applications, (2) Altruistic Locking [SGMS94] that was designed to deal with long-lived transactions, and (3) Dynamic Tree Policy [CM86] that allows a changing set of partial orders over a database. <p> To take advantage of the graph-like structure of such systems, we extended the DAG policy <ref> [SK80, Yan82] </ref> to the Dynamic Directed Graph (DDG) policy which can deal with general dynamic graphs [CHM92]. DDG-SX is the variant of this policy that supports both shared and exclusive locks. We first define some properties of directed graphs that are necessary for specifying our algorithm.
Reference: [SWY93] <author> H.-J. Schek, G. Weikum, and H. Ye. </author> <title> Towards a Unified Theory of Concurrency Control and Recovery. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 300-311, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: This work can be extended in several directions. The same technique could be used to analyze other locking policies [AA90, dFRH94]. Furthermore, generalization of these results to a dynamic hypergraph policy [Yan82] and incorporating recovery considerations in it <ref> [SWY93] </ref> remains an open problem and needs to be investigated in the future. Safe Locking Policies for Dynamic Databases 11
Reference: [Yan82] <author> Mihalis Yannakakis. </author> <title> A Theory of Safe Locking Policies in Database Systems. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 29(3) </volume> <pages> 718-740, </pages> <month> July </month> <year> 1982. </year> <title> Safe Locking Policies for Dynamic Databases 12 </title>
Reference-contexts: Yannakakis showed that a locking policy is not safe if and only if there exists a canonical non-serializable schedule in which all transactions except one are executed serially <ref> [Yan82] </ref>. The serializability graph of such a schedule consists of a simple path closed by a back edge. Such a characterization is useful because it provides a technique that can be used to prove the correctness of a wide range of locking policies. <p> We denote by R (T ) the set of entities referenced by a transaction T . Let us summarize here the differences between our model and that of Yannakakis <ref> [Yan82] </ref>. First, we distinguish between the structural and value states of the database. In the model of a static database, such a distinction was not necessary, because the database is always in the same structural state. <p> The key difference between the above theorem and its analogue for static databases <ref> [Yan82] </ref> derives from the fact that properness of schedules does not now come for "free": Special precautions must be taken to ensure that the canonical non-serializable schedule is, indeed, proper. This difference influences the theorem in three ways. <p> To take advantage of the graph-like structure of such systems, we extended the DAG policy <ref> [SK80, Yan82] </ref> to the Dynamic Directed Graph (DDG) policy which can deal with general dynamic graphs [CHM92]. DDG-SX is the variant of this policy that supports both shared and exclusive locks. We first define some properties of directed graphs that are necessary for specifying our algorithm. <p> This work can be extended in several directions. The same technique could be used to analyze other locking policies [AA90, dFRH94]. Furthermore, generalization of these results to a dynamic hypergraph policy <ref> [Yan82] </ref> and incorporating recovery considerations in it [SWY93] remains an open problem and needs to be investigated in the future. Safe Locking Policies for Dynamic Databases 11
References-found: 11

