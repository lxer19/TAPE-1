URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/userlevel-networking.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/
Root-URL: http://www.cs.berkeley.edu
Title: Implementing Network Protocols at User Level  
Author: Chandramohan A. Thekkath, Thu D. Nguyen, Evelyn Moy, and Edward D. Lazowska 
Date: March 1, 1993  
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Pubnum: Technical Report 93-03-01  
Abstract: y E. Moy is with the Digital Equipment Corporation, Littleton, MA. Also appears in IEEE/ACM Transactions on Networking Oct 1993. Vol. 1, Num. 5, pages 554-565. A slightly modified version of this report also appears in Proceedings of the 1993 SIGCOMM Symposium on Communications Architectures, Protocols and Applications, pages 64-73, September 1993. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mark B. Abbot and Larry L. Peterson. </author> <title> A language-based approach to protocol implementation. </title> <booktitle> In Proceedings of the 1992 SIGCOMM Symposium on Communications Architectures and Protocols, </booktitle> <pages> pages 27-38, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: In this approach, based on application requirements, a specialized variant of a standard protocol is used rather than the standard protocol itself. A different application would use a slightly different variant of the same protocol. Language-based protocol implementations such as Morpheus <ref> [1] </ref> as well as protocol compilers [9, 10] are two recent attempts at exploiting user specified constraints to generate efficient implementations of communication protocols. The general idea of using partial evaluation to gain better I/O performance in systems has been used elsewhere as well [16]. <p> In other cases, the hardware packet demultiplexing mechanism is difficult to exploit because there is no separate connection setup phase that can negotiate the BQIs. There is much evidence to support the claim that application-specific knowledge can be exploited to achieve highly efficient communication. For example, <ref> [1, 10] </ref> are some of the more recent systems that use application-specific knowledge to generate communication protocols. By providing language-level support for generating protocols, these systems go beyond providing a set of pre-defined options to fine tune a protocol.
Reference: [2] <author> Andrew D. Birrell and Bruce Jay Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: For example, the need for an efficient transport for distributed systems was a factor in the development of request/response protocols in lieu of existing byte-stream protocols such as TCP <ref> [2] </ref>. Experience with specialized protocols shows that they achieve remarkably low latencies. However these protocols do not always deliver the highest throughput [3]. In systems that need to support both throughput-intensive and latency-critical applications, it is realistic to expect both types of protocols to co-exist.
Reference: [3] <author> David R. Cheriton and Carey L. Williamson. </author> <title> VMTP as the transport layer for high-performance distributed systems. </title> <journal> IEEE Communications Magazine, </journal> <volume> 27(6) </volume> <pages> 37-44, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Experience with specialized protocols shows that they achieve remarkably low latencies. However these protocols do not always deliver the highest throughput <ref> [3] </ref>. In systems that need to support both throughput-intensive and latency-critical applications, it is realistic to expect both types of protocols to co-exist. We expect the trend towards multiple protocols to continue due to at least three factors.
Reference: [4] <author> David Clark. </author> <title> The structuring of systems with upcalls. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 171-180, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: With more modern operating systems, which support lightweight threads and synchronization at user-level, protocol implementation at user-level enjoys the facilities that more traditional implementations exploited within the kernel. Issues of layering, lightweight context switching and timers have been extensively studied in the literature. Examples include Clark's Swift system <ref> [4] </ref>, the x-kernel [12], and the work by Watson and Mamrak [29]. It is well known that switching between processes that implement each layer of the protocol is expensive, as is the data copying overhead.
Reference: [5] <author> Eric C. Cooper and Richard P. Draves. </author> <title> C threads. </title> <type> Technical Report CMU-CS-88-154, </type> <institution> Carnegie Mellon University, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: Instead, network packet arrival notification is done via a lightweight semaphore that a library thread is waiting on, and user applications invoke protocol functions through procedure calls. Second, multiple threads of control and synchronization are provided by user-level C Thread primitives <ref> [5] </ref> rather than kernel primitives. In addition, protocol control block lookups are eliminated by having separate threads per connection that are upcalled. Finally, user data transfer between the application and the network device exploits shared memory to avoid copy costs where possible.
Reference: [6] <author> Digital Equipment Corporation, </author> <title> Workstation Systems Engineering. PMADD-AA TurboChannel Ethernet Module Functional Specification, </title> <journal> Rev 1.2., </journal> <month> August </month> <year> 1990. </year>
Reference-contexts: The exact mechanism for transferring the data from the network to shared memory varies with the host-network interface. The DECstation hosts connect to the Ethernet using the DEC PMADD-AA host-network interface <ref> [6] </ref>. This interface does not have DMA capabilities to and from the host memory. Instead, there are special packet buffers on board the controller that serve as a staging area for data. The host transfers data between these buffers and host memory using programmed I/O.
Reference: [7] <author> Willibald A. Doeringer, Doug Dykeman, Matthias Kaiserwerth, Bernd Werner Meister, Harry Rudin, and Robin Williamson. </author> <title> A survey of light-weight transport protocols for high-speed networks. </title> <journal> IEEE Transactions on Communications, </journal> <volume> 38(11) </volume> <pages> 20-31, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: As newer networks with different speed and error characteristics are deployed, protocol requirements will change. For example, higher speed, low error links may favor forward error correction and rate-based flow control over more traditional protocols <ref> [7] </ref>. Once again, if different network links exist at a single site, multiple protocols may need to co-exist.
Reference: [8] <author> Richard P. Draves, Brian N. Bershad, Richard F. Rashid, and Randall W. Dean. </author> <title> Using continuations to implement thread management and communication in operating systems. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 122-136, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Proposed solutions to the problem are generally variations of Clark's multitask modules, where context switches are avoided in moving data between the various transport layers. Additionally, there are many well understood mechanisms for fast context switches, such as continuations <ref> [8] </ref> and others. Timer implementations also have a profound impact on transport performance, because practically every message arrival and departure involves timer operations.
Reference: [9] <author> Edward W. Felten. </author> <title> The case for application-specific communication protocols. </title> <booktitle> In Proceedings of Intel Supercomputer Systems Division Technology Focus Conference, </booktitle> <pages> pages 171-181, </pages> <year> 1992. </year>
Reference-contexts: In this approach, based on application requirements, a specialized variant of a standard protocol is used rather than the standard protocol itself. A different application would use a slightly different variant of the same protocol. Language-based protocol implementations such as Morpheus [1] as well as protocol compilers <ref> [9, 10] </ref> are two recent attempts at exploiting user specified constraints to generate efficient implementations of communication protocols. The general idea of using partial evaluation to gain better I/O performance in systems has been used elsewhere as well [16].
Reference: [10] <author> Edward W. Felten. </author> <title> Protocol Compilation: High-Performance Communication for Parallel Programs. </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science and Enginerring, University of Washington, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: In this approach, based on application requirements, a specialized variant of a standard protocol is used rather than the standard protocol itself. A different application would use a slightly different variant of the same protocol. Language-based protocol implementations such as Morpheus [1] as well as protocol compilers <ref> [9, 10] </ref> are two recent attempts at exploiting user specified constraints to generate efficient implementations of communication protocols. The general idea of using partial evaluation to gain better I/O performance in systems has been used elsewhere as well [16]. <p> In other cases, the hardware packet demultiplexing mechanism is difficult to exploit because there is no separate connection setup phase that can negotiate the BQIs. There is much evidence to support the claim that application-specific knowledge can be exploited to achieve highly efficient communication. For example, <ref> [1, 10] </ref> are some of the more recent systems that use application-specific knowledge to generate communication protocols. By providing language-level support for generating protocols, these systems go beyond providing a set of pre-defined options to fine tune a protocol.
Reference: [11] <author> Alessandro Fiorin, David B. Golub, and Brian N. Bershad. </author> <title> An I/O system for Mach 3.0. </title> <booktitle> In Proceedings of the Second USENIX Mach Workshop, </booktitle> <pages> pages 163-176, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: 1 Introduction 1.1 Motivation Typically, network protocols have been implemented inside the kernel or in a trusted user-level server <ref> [11, 13] </ref>. Security and/or performance are the primary reasons that favor such an organization. We refer to this organization as monolithic because all protocol stacks supported by the system are implemented within a single address space. The goal of this paper is to explore alternatives to a monolithic structure. <p> In the second variant, device management is located in the kernel. The in-kernel device driver and the UX server communicate through a message based interface. The performance of this variant is lower than the one with the mapped device <ref> [11] </ref>. Some of the performance lost due to the message based interface can potentially be recovered by using a third variant that uses shared memory to pass data between the device and the protocol code as described in [22].
Reference: [12] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <title> The x-kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The general idea of using partial evaluation to gain better I/O performance in systems has been used elsewhere as well [16]. In particular, the notion of specializing a transport protocol to the needs of a particular application has been the motivation behind many recent system designs <ref> [12, 23, 27] </ref>. 1.2 Alternative Protocol Structures The discussion above argues for alternatives to monolithic protocol implementations since they are deficient in at least two ways. First, having all protocol variants executing in a single address space (especially if it is in-kernel) complicates code maintenance, debugging, and development. <p> Issues of layering, lightweight context switching and timers have been extensively studied in the literature. Examples include Clark's Swift system [4], the x-kernel <ref> [12] </ref>, and the work by Watson and Mamrak [29]. It is well known that switching between processes that implement each layer of the protocol is expensive, as is the data copying overhead.
Reference: [13] <author> Samuel J. Leffler, Marshall Kirk McKusick, Michael J. Karels, and John S. Quarterman. </author> <title> The Design and Implementation of the 4.3BSD UNIX Operating System. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction 1.1 Motivation Typically, network protocols have been implemented inside the kernel or in a trusted user-level server <ref> [11, 13] </ref>. Security and/or performance are the primary reasons that favor such an organization. We refer to this organization as monolithic because all protocol stacks supported by the system are implemented within a single address space. The goal of this paper is to explore alternatives to a monolithic structure.
Reference: [14] <author> Chris Maeda and Brian N. Bershad. </author> <title> Networking performance for microkernels. </title> <booktitle> In Proceedings of the Third Workshop on Workstation Operating Systems, </booktitle> <pages> pages 154-159, </pages> <month> April </month> <year> 1992. </year> <month> 19 </month>
Reference-contexts: It did not rely on any y This is the UX server, not to be confused with the NetMsgServer. 3 special-purpose hardware or on extensive operating system support. Several protocols including the PUP suite and VMTP were implemented. A similar organization for implementing UDP is described in <ref> [14] </ref>. Another alternative, the one we develop in this paper, is to organize protocol functions as a user linkable library.
Reference: [15] <author> Chris Maeda and Brian N. Bershad. </author> <title> Protocol service decomposition for high performance internet--working. </title> <booktitle> To appear in Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <year> 1993. </year>
Reference-contexts: Second, the design of Topaz trades off strict protection for increased performance and ease of implementation of protocols. A more recent example of encapsulating protocols in user-level libraries is the ongoing work at CMU that implements application level protocols beneath a UNIX compatible interface <ref> [15] </ref>. <p> However, we don't view this as an insurmountable problem with user-level library implementations of protocols. Some of this performance can be won back by a better implementation of synchronization primitives, user level threads, and protocol stacks. For instance, the implementation in <ref> [15] </ref> achieves a higher throughput than the Ultrix version. The observed throughput on AN1 is lower than the maximum the network can support.
Reference: [16] <author> Henry Massalin. </author> <title> Synthesis: An Efficient Implementation of Fundamental Operating System Services. </title> <type> Ph.D. thesis, </type> <institution> Columbia University, </institution> <year> 1992. </year>
Reference-contexts: The general idea of using partial evaluation to gain better I/O performance in systems has been used elsewhere as well <ref> [16] </ref>.
Reference: [17] <author> Henry Massalin and Calton Pu. </author> <title> Threads and input/output in the Synthesis kernel. </title> <booktitle> In Proceedings of 12th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Neither of these facilities is very difficult to implement. The logic required for address demultiplexing is simple and can be incorporated into the kernel either via run time code synthesis or via compilation when new protocols are added <ref> [17] </ref>. Based on our experience, the demultiplexing logic requires only a few instructions. In addition, virtual memory operations can be exploited so that the user-level library and the kernel can securely share a buffer area.
Reference: [18] <author> Steven McCanne and Van Jacobson. </author> <title> The BSD Packet Filter: A new architecture for user-level packet capture. </title> <booktitle> In Proceedings of the 1993 Winter USENIX Conference, </booktitle> <pages> pages 259-269, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Performance is more important than flexibility because slow packet demultiplexing tends to confine user-level protocol implementations to debugging and development rather than production use. The recent Berkeley Packet Filter implementation recognizes these issues and provides higher performance suited for modern RISC processors <ref> [18] </ref>. In the absence of hardware support, effective input demultiplexing requires two mechanisms: 1. Support for direct execution of demultiplexing code within the kernel. 2. Support for protected packet buffer sharing between user space and the kernel. Neither of these facilities is very difficult to implement.
Reference: [19] <author> Jeffrey C. Mogul, Richard F. Rashid, and Michael J. Accetta. </author> <title> The Packet Filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Further, and perhaps more importantly, this arrangement, like the monolithic version, does not permit easy exploitation of application-level information. Perhaps the best known example of this organization was done in the context of the Packet Filter <ref> [19] </ref>. This system implemented packet demultiplexing and device management within the kernel and supported implementations of standard protocols such as TCP and VMTP outside the kernel. <p> In the past, software implementations of address demultiplexing have offered flexibility at the expense of performance and have ignored the issues of multiple data copies. For example, the original UNIX implementation of the Packet Filter <ref> [19] </ref> features a stack-based language where filter programs composed of stack operations and operators are interpreted by a kernel-resident program at packet reception time. While the interpretation process offers flexibility, it is not likely to scale with CPU speeds because it is memory intensive.
Reference: [20] <author> Hilarie Orman, Edwin Menze III, Sean O'Malley, and Larry Peterson. </author> <title> A fast and general implementation of Mach IPC in a network. </title> <booktitle> In Proceedings of the USENIX Mach III Symposium, </booktitle> <pages> pages 75-88, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: We explored this particular organization for reasons mentioned in Section 1.1. Current research at the University of Arizona <ref> [20, 21] </ref> tries to address the general question of protocol decomposition into multiple domains in the context of the x-kernel.
Reference: [21] <author> Larry L. Peterson. </author> <title> Life on the OS/network boundary. </title> <journal> ACM Operating Systems Review, </journal> <volume> 27(2) </volume> <pages> 94-98, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: We explored this particular organization for reasons mentioned in Section 1.1. Current research at the University of Arizona <ref> [20, 21] </ref> tries to address the general question of protocol decomposition into multiple domains in the context of the x-kernel.
Reference: [22] <author> Franklin Reynolds and Jeffrey Heller. </author> <title> Kernel support for network protocol servers. </title> <booktitle> In Proceedings of the Second USENIX Mach Workshop, </booktitle> <pages> pages 149-162, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Some of the performance lost due to the message based interface can potentially be recovered by using a third variant that uses shared memory to pass data between the device and the protocol code as described in <ref> [22] </ref>. One alternative to a monolithic implementation is to dedicate a separate user-level server for each protocol stack, and separate server (s) for network device management.
Reference: [23] <author> Douglas C. Schmidt, Donald F. Box, and Tatsuya Suda. </author> <title> ADAPTIVE: A flexible and adaptive transport system architecture to support lightweight protocols for multimedia applications on high-speed networks. </title> <booktitle> In Proceedings of the Symposium on High Performance Distributed Computing, </booktitle> <pages> pages 174-186, </pages> <address> Syracuse, New York, </address> <month> September </month> <year> 1992. </year> <note> IEEE. </note>
Reference-contexts: The general idea of using partial evaluation to gain better I/O performance in systems has been used elsewhere as well [16]. In particular, the notion of specializing a transport protocol to the needs of a particular application has been the motivation behind many recent system designs <ref> [12, 23, 27] </ref>. 1.2 Alternative Protocol Structures The discussion above argues for alternatives to monolithic protocol implementations since they are deficient in at least two ways. First, having all protocol variants executing in a single address space (especially if it is in-kernel) complicates code maintenance, debugging, and development.
Reference: [24] <author> Michael D. Schroeder, Andrew D. Birrell, Michael Burrows, Hal Murray, Roger M. Needham, Thomas L. Rodeheffer, Edwin H. Satterthwaite, and Charles P. Thacker. Autonet: </author> <title> A high-speed, self-configuring local area network using point-to-point links. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 9(8) </volume> <pages> 1318-1335, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: We have tested our hypothesis by implementing a user-level library for TCP on workstation hosts running the Mach kernel connected to Ethernet and to the DEC SRC AN1 network <ref> [24] </ref>. We chose TCP for several reasons. First, it is a real protocol whose level of detail and functionality match that of other communication protocols; choosing a simpler protocol like UDP would be less convincing in this regard.
Reference: [25] <author> David L. Tennenhouse. </author> <title> Layered multiplexing considered harmful. </title> <booktitle> In Proceedings of the 1st International Workshop on High-Speed Networks, </booktitle> <pages> pages 143-148, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: Ideally, address demultiplexing should be done as low in the protocol stack as possible, but should dispatch to the highest protocol layer <ref> [25] </ref>. This is usually not done in hardware because the host-network interface is typically designed for link-level protocols and has no knowledge of higher level protocols. As a specific example, a TCP/IP packet on an Ethernet link has three headers.
Reference: [26] <author> Charles P. Thacker, Lawrence C. Stewart, and Edwin H. Satterthwaite, Jr. Firefly: </author> <title> A multiprocessor workstation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(8) </volume> <pages> 909-920, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: device manager without involving a dedicated protocol server as an intermediary. (Issues such as security need to be addressed in this approach and are considered in greater detail in Section 3.) An earlier example of this approach is found in the Topaz implementation of UDP on the DEC SRC Firefly <ref> [26] </ref>. Here the UDP library exists in each user address space. However, this experiment has some limitations. First, UDP is an unreliable datagram service, and is easier to implement (and thus a less realistic test) than a protocol like TCP.
Reference: [27] <author> Christian Tschudin. </author> <title> Flexible protocol stacks. </title> <booktitle> In Proceedings of the 1991 SIGCOMM Symposium on Communications Architectures and Protocols, </booktitle> <pages> pages 197-205, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: The general idea of using partial evaluation to gain better I/O performance in systems has been used elsewhere as well [16]. In particular, the notion of specializing a transport protocol to the needs of a particular application has been the motivation behind many recent system designs <ref> [12, 23, 27] </ref>. 1.2 Alternative Protocol Structures The discussion above argues for alternatives to monolithic protocol implementations since they are deficient in at least two ways. First, having all protocol variants executing in a single address space (especially if it is in-kernel) complicates code maintenance, debugging, and development.
Reference: [28] <author> George Varghese and Tony Lauck. </author> <title> Hashed and hierarchical timing wheels: Data structures for the efficient implementation of a timer facility. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 25-38, </pages> <month> November </month> <year> 1987. </year> <month> 20 </month>
Reference-contexts: Timer implementations also have a profound impact on transport performance, because practically every message arrival and departure involves timer operations. Once again, fast implementations of timer events are well known, e.g., using hierarchical timing wheels <ref> [28] </ref>. 2.2 Efficient Buffering and Input Packet Demultiplexing The buffer layer in a communication system manages data buffers between the user space, the kernel and the host-network interface.
Reference: [29] <author> Richard W. Watson and Sandy A. Mamrak. </author> <title> Gaining efficiency in transport services by appropriate design and implementation choices. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(2) </volume> <pages> 97-120, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: Exploiting Application Knowledge In addition to using special purpose protocols for different application areas, further performance advantages may be gained by exploiting application-specific knowledge to fine tune a particular instance of a protocol. Watson and Mamrak have observed that conflicts between application-level and transport-level abstractions lead to performance compromises <ref> [29] </ref>. One solution to this is to partially evaluate a general purpose protocol with respect to a particular application. In this approach, based on application requirements, a specialized variant of a standard protocol is used rather than the standard protocol itself. <p> Issues of layering, lightweight context switching and timers have been extensively studied in the literature. Examples include Clark's Swift system [4], the x-kernel [12], and the work by Watson and Mamrak <ref> [29] </ref>. It is well known that switching between processes that implement each layer of the protocol is expensive, as is the data copying overhead. Proposed solutions to the problem are generally variations of Clark's multitask modules, where context switches are avoided in moving data between the various transport layers.
References-found: 29

