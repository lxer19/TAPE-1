URL: http://www.cs.uni-bonn.de/~idea/CPT/ADBIS97.ps.gz
Refering-URL: http://www.cs.uni-bonn.de/~idea/publications.html
Root-URL: http://cs.uni-bonn.de
Email: e-mail: idea@informatik.uni-bonn.de  
Title: Tools for Chimera: An Environment for Designing and Prototyping Advanced Applications in an Active DOOD Model  
Author: Ulrike Griefahn, Thomas Lemke, Rainer Manthey 
Address: Romerstrae 164, D-53117 Bonn, Germany  
Affiliation: Department of Computer Science III University of Bonn  
Abstract: During the last five years, the object-oriented data model Chimera has served as a focus of numerous research activities within the European cooperation project IDEA. Chimera particularly emphasizes the use of deductive and active rules during object-oriented modeling. Apart from a full application design methodology based on Chimera, a number of tools supporting the different phases of this methodology have been developed by the IDEA partners. In this paper, the tools developed at the University of Bonn will be introduced. They support schema design, prototyping and evolution as well as deductive rule analysis and automatic generation of triggers for analyzing updates of derived data. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. L. Barja, A. A. Fernandes, N. W. Paton, M. H. Williams, A. Dinn, and A. I. Abdelmoty. </author> <title> Design and implementation of ROCK & ROLL: a deductive object-oriented database system. </title> <journal> Information Systems, </journal> <volume> 20(3) </volume> <pages> 185-211, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction Chimera [5, 6] is a novel database model and language combining active and deductive database concepts in a coherent object-oriented context. Till now, there are only very few attempts which aim at combining both rule paradigms with an object-oriented data model. At present, only the Rock&Roll language <ref> [1] </ref> goes into the same direction similarly providing such a hybrid database language. However, there are numerous approaches to integrating an object model with the one or the other form of rule individually.
Reference: [2] <author> C. Beeri, S. Naqvi, O. Shmueli, and S. Tsur. </author> <title> Set constructors in a logic database language. </title> <journal> Journal of Logic Programming, </journal> <volume> 10 </volume> <pages> 181-232, </pages> <year> 1991. </year>
Reference-contexts: Thus Chimera does not suffer from grouping problems for derived, set-valued attributes as occurred, e.g. in LDL <ref> [2] </ref>. As usual, deductive rules in a schema are required to be safe and stratifiable. Deductive rules defining various derived components of a class definition are introduced in the DDL of CL in a separate section, called the implementation of the respective class.
Reference: [3] <author> S. Ceri and P. Fraternali. </author> <title> Designing Database Applications with Objects and Rules: The IDEA Methodology. Addison-Wesley, </title> <note> to appear 1997. </note>
Reference-contexts: The main results of the project are a comprehensive methodology, two sets of tools supporting the various phases of this methodology, and a collection of case studies performed by the industrial partners. "The IDEA Methodology" <ref> [3] </ref> provides a framework for analyzing, designing, and prototyping database applications with objects and rules. The tool environments have been developed by teams at the Politecnico di Milano and at the University of Bonn, respectively. <p> Apart from the doc-ument defining the language in the form originally designed by the IDEA consortium [5], a comprehensive introduction into Chimera can be found in the book presenting the IDEA methodology <ref> [3] </ref>. Chimera consists of a conceptual model (called Chimera Model, short: CM), providing object-oriented modeling facilities, and of a conceptual language (called Chimera Language, short: CL), providing data definition commands, declarative queries, procedural primitives for database manipulation, as well as various forms of rules and constraints. <p> Such dependencies are on the one hand introduced via deductive rules. On the other hand they originate from the implicit assumptions inherent in the class hierarchies of an object-oriented model, such as inclusion of class extensions, inheritance and overriding (cf. <ref> [3, chap. 9 and 11] </ref>). The Passive Rule Design Tool (PRDT) [15] aims at supporting Chimera application designers in analyzing whether the deductive rules in a Chimera schema are syntactically and semantically well-formed.
Reference: [4] <author> S. Ceri, G. Gottlob, and L. Tanca. </author> <title> Logic Programming and Databases. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The schema designer activates PRDT from within CPT in order to check the deductive rules defined so far. For individual rules, the standard syntactic criteria for deductive databases <ref> [4] </ref> are checked, i.e., the type of each term occurring within a rule is deduced and checked for its correct use, and the finiteness of the set of possible bindings for each variable (safeness) is determined.
Reference: [5] <author> S. Ceri and R. Manthey. </author> <title> Consolidated specification of Chimera (CL and CM). </title> <booktitle> IDEA deliverable IDEA.DE.2P.006.01, </booktitle> <institution> Politecnico di Milano, </institution> <year> 1993. </year>
Reference-contexts: 1 Introduction Chimera <ref> [5, 6] </ref> is a novel database model and language combining active and deductive database concepts in a coherent object-oriented context. Till now, there are only very few attempts which aim at combining both rule paradigms with an object-oriented data model. <p> The language proved to support a lot of requirements in a quite satisfactory manner, though naturally a couple shortcomings of the original design have been identified over time. Apart from the doc-ument defining the language in the form originally designed by the IDEA consortium <ref> [5] </ref>, a comprehensive introduction into Chimera can be found in the book presenting the IDEA methodology [3]. <p> A Chimera trigger is eligible if this set of events includes at least one instance matching an event specification of the trigger. The execution of triggers is set-oriented as well which means that a trigger is executed only once for all its triggering instances (cf. <ref> [5] </ref>). In contrast to this, active rule processing in Phoenix is instance-oriented, i.e., it is invoked immediately after a single event occurs and the reaction of a triggered rule is executed separately for each triggering instance (cf. [9]).
Reference: [6] <author> S. Ceri and R. Manthey. </author> <title> Chimera: A model and language for active DOOD systems. </title> <booktitle> In Proc. of the 2nd East-West Database Workshop (EW 94), Workshops in Computing, </booktitle> <pages> pages 3-16. </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Chimera <ref> [5, 6] </ref> is a novel database model and language combining active and deductive database concepts in a coherent object-oriented context. Till now, there are only very few attempts which aim at combining both rule paradigms with an object-oriented data model.
Reference: [7] <author> S. Ceri and J. Widom. </author> <title> Deriving incremental production rules for deductive data. </title> <journal> Information Systems, </journal> <volume> 19(6) </volume> <pages> 467-490, </pages> <year> 1994. </year>
Reference-contexts: For a complete technical documentation on rule compilation we refer to [13] while a more detailed description of the explanation component can be found in [12]. 5.1 Rule Compilation The update propagation approach underlying PROP essentially transfers techniques developed for relational deductive databases, e.g. <ref> [7, 18] </ref>, to the DOOD case. However, due to the richer set of concepts and assumptions present in object-oriented models, there are numerous new and nontrivial problems which require the original techniques to be modified, refined, and extended.
Reference: [8] <author> F. Ferrandina, T. Meyer, R. Zicari, G. Ferran, and J. Madec. </author> <title> Schema and database evolution in the O 2 object database system. </title> <booktitle> In 21th Int. Conf. on Very Large Databases (VLDB 95), </booktitle> <pages> pages 170-181, </pages> <address> Zurich, Switzerland, </address> <year> 1995. </year>
Reference-contexts: Regarding the central problem of schema evolution, the adaptation of existing instances to the new schema, SEA actually supports the immediate conversion of affected in-stances [20]. We currently investigate how to integrate other strategies (delayed conversion <ref> [8] </ref>, schema versioning [17]) into SEA such that they coexist and can flexibly be chosen for a specific application.
Reference: [9] <author> U. Griefahn. </author> <title> First specification of Phoenix, an active database programming language. </title> <type> Technical Report IAI-TR-95-4, </type> <institution> University of Bonn, </institution> <year> 1995. </year>
Reference-contexts: At the core of this tool environment there is an implementation of the full Chimera model and language on top of a relational back-end (a non-commercial, academic prototype DBMS, programmed in persistent Prolog and supporting deduction and triggers as well <ref> [9] </ref>). This implementation is not intended to serve as an efficient DBMS for managing large databases, but as a prototyping environment for Chimera applications. For this reason it has been called the Chimera Prototyping Tool (CPT). <p> It supports users during schema design and prototyping. CPT can be accessed using a Command Interface (CPT/CI) or a Graphical User Interface (CPT/GUI) offering quite elaborate facilities for incremental schema design. CPT has been implemented on top of a newly developed database programming language, called Phoenix <ref> [9] </ref>, which combines declarative, imperative, and reactive features in the context of the relational model. Phoenix and thus CPT have been designed as single-application systems, i.e., for each application, a new database has to be created containing exactly one schema (plus data conforming to this schema). <p> In contrast to this, active rule processing in Phoenix is instance-oriented, i.e., it is invoked immediately after a single event occurs and the reaction of a triggered rule is executed separately for each triggering instance (cf. <ref> [9] </ref>). In order to realize the behaviour of Chimera triggers in Phoenix we distinguish two phases of rule processing in Chimera. Each phase will be implemented by adequate Phoenix trigger-reaction rules.
Reference: [10] <author> U. Griefahn and T. Lemke. </author> <title> Implementing Chimera on top of an active relational database system. </title> <type> Technical Report IAI-TR-96-6, </type> <institution> University of Bonn, </institution> <year> 1996. </year>
Reference-contexts: The compilation of value types, value classes, views, and integrity constraints is rather straightforward, because all these structures directly correspond to relational concepts. In the following we briefly sketch the main issues related to the problems mentioned; a full treatment can be found in <ref> [10] </ref>. Class hierarchy: The basic idea underlying the implementation of Chimera schemas is to store each object in exactly one extensional relation corresponding to the most specific class of the object.
Reference: [11] <author> U. Griefahn, T. Lemke, and R. Manthey. </author> <title> Chimera Prototyping Tool: User Manual. </title> <booktitle> IDEA deliverable IDEA.DE.22.O.006, </booktitle> <institution> University of Bonn, Germany, </institution> <year> 1996. </year>
Reference-contexts: In the following we will first give a short overview of CPT/GUI and then briefly explain how Chimera schemas and data manipulation commands are mapped onto Phoenix. 3.1 Graphical User Interface (CPT/GUI) The graphical user interface of CPT <ref> [11] </ref> provides intuitive, but powerful means for visualizing and developing Chimera schemas. It supports advanced graphical schema design without burdening the user with the odds of applying purely textual data definition commands. However in addition, CPT/GUI offers a fully synchronized text-based schema editor.
Reference: [12] <author> U. Griefahn and R. Manthey. </author> <title> Propagation rule compiler: Tool description. </title> <booktitle> IDEA deliverable IDEA.DE.22.O.003, </booktitle> <institution> University of Bonn, </institution> <year> 1995. </year>
Reference-contexts: In the following we will first briefly address the course of rule compilation and then illustrate the main features of the graphical explanation component. For a complete technical documentation on rule compilation we refer to [13] while a more detailed description of the explanation component can be found in <ref> [12] </ref>. 5.1 Rule Compilation The update propagation approach underlying PROP essentially transfers techniques developed for relational deductive databases, e.g. [7, 18], to the DOOD case.
Reference: [13] <author> U. Griefahn and T. Rath. </author> <title> Propagation rule compiler: </title> <type> Technical documentation. </type> <institution> IDEA deliverable IDEA.DE.22.O.005, University of Bonn, </institution> <year> 1996. </year>
Reference-contexts: In the following we will first briefly address the course of rule compilation and then illustrate the main features of the graphical explanation component. For a complete technical documentation on rule compilation we refer to <ref> [13] </ref> while a more detailed description of the explanation component can be found in [12]. 5.1 Rule Compilation The update propagation approach underlying PROP essentially transfers techniques developed for relational deductive databases, e.g. [7, 18], to the DOOD case.
Reference: [14] <author> T. Lemke. </author> <title> The Schema Evolution Assistant: Tool documentation. </title> <booktitle> IDEA deliverable IDEA.DE.22.O.008, </booktitle> <institution> University of Bonn, </institution> <year> 1996. </year>
Reference-contexts: The Schema Evolution Assistant (SEA) <ref> [14] </ref> has been developed in order to support a schema designer in the evolution of a schema. The designer interacts with SEA using CPT/GUI which provides a flexible means for handling even large and complex application schemas.
Reference: [15] <author> T. Lemke. </author> <title> The Passive Rule Design Tool: Tool documentation. </title> <booktitle> IDEA deliverable IDEA.DE.22.O.010, </booktitle> <institution> University of Bonn, </institution> <year> 1997. </year>
Reference-contexts: On the other hand they originate from the implicit assumptions inherent in the class hierarchies of an object-oriented model, such as inclusion of class extensions, inheritance and overriding (cf. [3, chap. 9 and 11]). The Passive Rule Design Tool (PRDT) <ref> [15] </ref> aims at supporting Chimera application designers in analyzing whether the deductive rules in a Chimera schema are syntactically and semantically well-formed. It explains and visualizes errors which might have occurred, and points out possible actions to be performed in view of overcoming deficiencies of the design.
Reference: [16] <author> R. Manthey. </author> <title> Beyond data dictionaries: Towards a reflective architecture of intelligent database systems. </title> <booktitle> In Deductive Object-Oriented Database Systems (DOOD 93), Lecture Notes in Computer Science, </booktitle> <pages> pages 328-339. </pages> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: Instead of tightly integrating SEA with the underlying Chimera DBMS, we originally decided to follow a reflective approach for schema management, because using Chimera itself for schema management immediately provides us with all advantages of an advanced data model and language <ref> [16] </ref>. We thus developed the reflective Schema Evolution Assistant, based on the representation of Chimera schemas as instances of a Chimera meta schema. The reflective SEA provides a variety of benefits: Data manipulation primitives can be used without changes and without restrictions for schema objects too.
Reference: [17] <author> S. Monk and I. Sommerville. </author> <title> A model for versioning classes in object-oriented databases. </title> <booktitle> In 10th British National Conf. on Databases (BNCOD 10), </booktitle> <pages> pages 42-58, </pages> <address> Aberdeen, Scotland, </address> <year> 1992. </year>
Reference-contexts: Regarding the central problem of schema evolution, the adaptation of existing instances to the new schema, SEA actually supports the immediate conversion of affected in-stances [20]. We currently investigate how to integrate other strategies (delayed conversion [8], schema versioning <ref> [17] </ref>) into SEA such that they coexist and can flexibly be chosen for a specific application.
Reference: [18] <author> A. Olive. </author> <title> Integrity constraints checking in deductive databases. </title> <booktitle> In Proc. of the 17th Int. Conf. on Very Large Data Bases (VLDB 91), </booktitle> <pages> pages 513-523. </pages> <publisher> Morgan Kauf-mann, </publisher> <year> 1991. </year>
Reference-contexts: For a complete technical documentation on rule compilation we refer to [13] while a more detailed description of the explanation component can be found in [12]. 5.1 Rule Compilation The update propagation approach underlying PROP essentially transfers techniques developed for relational deductive databases, e.g. <ref> [7, 18] </ref>, to the DOOD case. However, due to the richer set of concepts and assumptions present in object-oriented models, there are numerous new and nontrivial problems which require the original techniques to be modified, refined, and extended.
Reference: [19] <author> J. Widom. </author> <title> The Starburst active database rule system. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 8(4) </volume> <pages> 583-595, </pages> <year> 1996. </year>
Reference-contexts: Apart from these deductive rules defining attributes and constraints, an implementation section also contains the code of each targeted operation as well as the active rules implementing targeted triggers. The active rule language of Chimera is based on a set-oriented semantics similar to that of the Starburst rule system <ref> [19] </ref>. The event part of an active rule consists of one or more event pattern specifying situations in which the rule is to be activated. At present, only occurrences of data manipulation requests concerning the class under consideration are viewed as events.
Reference: [20] <author> R. Zicari. </author> <title> A framework for schema updates in an object-oriented database system. </title> <booktitle> In Int. Conf. on Data Engineering (ICDE 91), </booktitle> <pages> pages 2-13, </pages> <address> Kobe, Japan, </address> <year> 1991. </year>
Reference-contexts: Regarding the central problem of schema evolution, the adaptation of existing instances to the new schema, SEA actually supports the immediate conversion of affected in-stances <ref> [20] </ref>. We currently investigate how to integrate other strategies (delayed conversion [8], schema versioning [17]) into SEA such that they coexist and can flexibly be chosen for a specific application.
References-found: 20

