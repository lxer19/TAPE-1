URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-702.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/tr700.html
Root-URL: 
Title: Code Importing Techniques for Fast, Safe Client/Server Access  
Author: Joseph A. Bank 
Address: 545 Technology Square Cambridge, Massachusetts 02139  
Affiliation: Sun Microsystems. Massachusetts Institute of Technology Laboratory for Computer Science  
Note: c Massachusetts Institute of Technology 1996. All rights reserved. This work was supported by a grant from  
Date: September 1996  
Abstract-found: 0
Intro-found: 1
Reference: [BL94] <author> Philip Bogle and Barbara Liskov. </author> <title> Reducing cross-domain call overhead using batched futures. </title> <booktitle> In ACM Conference on Object-Oriented Programming: Systems, Languages, and Applications (OOPSLA), </booktitle> <year> 1994. </year>
Reference-contexts: Finally, the most significant part of the RPC Java veneer is the implementation of the stub classes that provide the client-side stubs needed by the language-independent interface. 1 The RPC Java veneer uses an optimization technique called batched futures <ref> [BL94] </ref>, but to simplify the discussion, the use of futures will not be discussed. 31 4.1.1 Communication Layer The RPC Java veneer uses the Java TCP/IP socket library for the IPC required to communicate with Thor. <p> The RPC Java veneer keeps track of which handles are in use by the Java client by using a reference counting mechanism <ref> [BL94] </ref>. A veneer handle table is used to keep track of the number of references for each handle seen by the Java client. This table maintains the invariant that the reference count for a given handle is the same as the number of stub objects that refer to that handle. <p> The first mechanism was presented in Phillip Bogle's thesis on Batched Futures <ref> [BL94] </ref>. Bogle presents a mechanism for combining (batching) a number of database calls into a single message. The return values of many calls are used only as intermediate value.
Reference: [Bor94] <author> Nathaniel S. Borenstein. </author> <title> Email with a mind of its own: The safe-tcl language for enabled mail. </title> <booktitle> In ULPAA, </booktitle> <year> 1994. </year>
Reference-contexts: Finally, batched futures requires additional client-side bookkeeping mechanisms in the Thor veneer. 7.2 Code Importing A number of systems have used code importing for a variety of reasons. For example, the Safe-Tcl language <ref> [Bor94] </ref> (an extension of the Tcl language) attempts to provide for "Enabled Mail" that would allow users to send email with embedded Safe-Tcl programs. Safe-Tcl uses a variety of techniques to make sure that the language satisfies strong security and portability constraints.
Reference: [BSP + 95] <author> B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. Fiuczynski, D. Becker, S. Eggers, and C. Chambers. </author> <title> Extensibility, safety and performance in the spin operating system. </title> <booktitle> In Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: In contrast, sandboxing relies on augmenting the imported code with runtime checks. 56 The SPIN operating system also allows applications to safely download extensions into the kernel <ref> [BSP + 95] </ref>. The safety of the system is achieved by requiring extensions to be written in a type-safe language. The code-importing Java veneer is similar to SPIN in that it relies upon the type safety of the imported language.
Reference: [CDN94] <author> Michael J. Carey, David J. DeWitt, and Jeffrey F. Naughton. </author> <title> The OO7 benchmark. </title> <type> Technical Report; Revised Version dated 7/21/1994 1140, </type> <institution> University of Wisconsin-Madison, </institution> <year> 1994. </year> <note> WWW users: see URL ftp://ftp.cs.wisc.edu/OO7. </note>
Reference-contexts: To provide a more meaningful comparison, the code importing Java veneer is compared against a highly optimized C++ veneer based on RPC. The experiments used were modeled on the experiments used in [LACZ96]. The experiments ran the single-user OO7 benchmark <ref> [CDN94] </ref>. The OO7 database contains a tree of assembly objects, with leaves pointing to three composite parts chosen randomly from among 500 such objects. Each composite part contains a graph of atomic parts linked by connection objects; each atomic part has 3 outgoing connections.
Reference: [EKJ95] <author> Dawson R. Engler, Frans Kaashoek, and James O'Toole Jr. Exokernel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: In each of these systems, code importing is used to add functionality to the system. In the code-importing Java veneer, code importing is used for performance reasons. Importing code has also been shown to be useful in operating systems for improving system performance. The Aegis <ref> [EKJ95] </ref> operating system allows untrusted code to be downloaded into the kernel. The untrusted code is made safe by using code inspection and sandboxing [WLAG93]. This use of code importing to improve performance is similar to the code-importing Java veneer.
Reference: [GM] <author> Inc. </author> <title> General Magic. An introduction to safety and security in telescript. </title> <note> Available at http://cnn.genmagic.com/Telescript/TDE/security.html. </note>
Reference-contexts: Safe-Tcl uses a variety of techniques to make sure that the language satisfies strong security and portability constraints. Another example is Telescript from General Magic, which also provides code importing in the form of executable content, while claiming to still maintain safety and security <ref> [GM] </ref>. Currently, a number of World Wide Web browsers use Java to allow users to import code and safely run that code locally. In each of these systems, code importing is used to add functionality to the system. In the code-importing Java veneer, code importing is used for performance reasons.
Reference: [JSS95] <author> Hotjava(tm): </author> <title> The security story, </title> <note> 1995. Available at http://java.sun.com/1.0alpha3/doc/security/security.html. </note>
Reference-contexts: Java code is compiled to bytecodes for an architecture-independent virtual machine, so that the same compiled code can be run on many different platforms. Additionally, a number of security features are built into Java to prevent code that is imported and executed from causing problems to the local machine <ref> [JSS95] </ref>. Java Language Safety Java, like C++, has facilities for controlling the access to the variables and methods of objects. These access controls allow objects to be used by non-trusted code with the guarantee that they will not be used improperly.
Reference: [LAC + 96] <author> Barbar Liskov, Atul Adya, Miguel Castro, Mark Day, Sanjay Ghemawat, Robert Gruber, Umesh Maheshwari, Andrew C. Myers, and Liuba Shrira. </author> <title> Safe and efficient sharing of persistant objects in Thor. </title> <booktitle> In ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <year> 1996. </year>
Reference-contexts: For a more complete background on Thor, see <ref> [LDG + 96, LAC + 96, LCD + 94] </ref>. For a more complete background on Java, see [Sun95a, Sun95b, Yel95]. 2.1 Thor Thor [LDG + 96] is an object-oriented database being developed at MIT that provides persistent and highly available storage for its objects.
Reference: [LACZ96] <author> B. Liskov, A. Adya, M. Castro, and Q. Zondervan. </author> <title> Type-safe heterogeneous sharing can be fast. </title> <booktitle> In Seventh International Workshop on Persistent Object Systems, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: Finally, Section 6.2.1 and Section 6.3 provides the experimental results and analysis of the results using the presented performance model. 6.1 Performance Model The execution time of an application using Thor can be explained by the following model based on a model presented in <ref> [LACZ96] </ref>. Suppose the client invokes N methods on Thor objects. Each of these calls has an associated cost S. S takes into account the average communication cost, safety costs such as runtime type-checking, and the marshaling and unmarshaling costs. <p> the computation performed at the client R C and the computation performed at the server R S . 1 The total application running time T can be expressed with the equation: T = X C + N S + R C + R S (6:1) 1 The model presented in <ref> [LACZ96] </ref> combines R C and R S into a single cost R. 47 6.2 The Experiments The intended experiment to compare the performance of code importing against standard RPC techniques involved measuring the performance of the two implementations of the Java veneer. <p> To provide a more meaningful comparison, the code importing Java veneer is compared against a highly optimized C++ veneer based on RPC. The experiments used were modeled on the experiments used in <ref> [LACZ96] </ref>. The experiments ran the single-user OO7 benchmark [CDN94]. The OO7 database contains a tree of assembly objects, with leaves pointing to three composite parts chosen randomly from among 500 such objects. <p> These costs are discussed in Section 6.3.2. 3 The implementation of Java that was used is the author's port to the DEC Alpha based on the implementation provided by Sun Microsystems. 50 6.3.1 C++ SHM The breakdown of the C++ SHM experiment is based on the analysis given in <ref> [LACZ96] </ref>, which provides a more extensive treatment of the performance benefits of different techniques such as batched futures. The C++ SHM experiment presented here uses the RPC based technique that has the best performance. <p> The .7 seconds is a conservative estimate since the C++ code that performs the client computation (R C ) is faster than the equivalent Theta code that performs the client computation in the all-inside experiment <ref> [LACZ96] </ref>. The all-inside experiment was optimized with cord and ftoc, two utilities that reorder procedures in an executable to reduce misses in the code cache.
Reference: [LCD + 94] <author> Barbara Liskov, Dorothy Curtis, Mark Day, Sanjay Ghemawhat, Robert Gru-ber, Paul Johnson, and Andrew C. Myers. </author> <title> Theta reference manual. </title> <type> Technical Report 88, </type> <institution> Laboratory for Computer Science, MIT, </institution> <month> February </month> <year> 1994. </year> <note> Also available at http://www.pmg.lcs.mit.edu/papers/thetaref/. </note>
Reference-contexts: For a more complete background on Thor, see <ref> [LDG + 96, LAC + 96, LCD + 94] </ref>. For a more complete background on Java, see [Sun95a, Sun95b, Yel95]. 2.1 Thor Thor [LDG + 96] is an object-oriented database being developed at MIT that provides persistent and highly available storage for its objects. <p> In addition, all built-in Theta types do runtime checks to prevent errors, e.g., array methods do bounds checking. Theta is based on a heap with automatic storage management. More information on Theta can be found in <ref> [LCD + 94] </ref>. 2.1.2 Language-Independent Interface The Thor system provides a language-independent interface based on RPC to allow clients to access the Thor server. In RPC terms, the language-independent interface provided by 19 Thor consists of the server-side stubs and the communication protocol for using those stubs from a client. <p> Java and Theta are both statically type checked, type-safe, garbage-collected, object-oriented languages with single inheritance. Both languages provide a means of signaling and handling exceptions <ref> [LCD + 94] </ref>[Sun95a]. 22 Because of the similarity between the two languages, the client interface between Java and Theta presents Java clients with a natural mapping of Thor's functionality to Java.
Reference: [LDG + 96] <author> Barbar Liskov, Mark Day, Sanjay Ghemawat, Robert Gruber, Umesh Mahesh-wari, Andrew C. Myers, and Liuba Shrira. </author> <title> The language-independent interface 61 of the Thor persistent object system. </title> <booktitle> In Object-Oriented Multi-Database Sys--tems, </booktitle> <pages> pages 570-588. </pages> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: For example, an entire client application can be downloaded to run directly inside of the server. To evaluate the benefits of using code importing, I implemented two interfaces between Thor <ref> [LDG + 96] </ref>, a new object-oriented database system, and clients written in the Java programming language [Sun95a]. The first Java interface to Thor uses a variant of RPC techniques for safety, communicating with Thor using TCP/IP communication. <p> For a more complete background on Thor, see <ref> [LDG + 96, LAC + 96, LCD + 94] </ref>. For a more complete background on Java, see [Sun95a, Sun95b, Yel95]. 2.1 Thor Thor [LDG + 96] is an object-oriented database being developed at MIT that provides persistent and highly available storage for its objects. <p> For a more complete background on Thor, see [LDG + 96, LAC + 96, LCD + 94]. For a more complete background on Java, see [Sun95a, Sun95b, Yel95]. 2.1 Thor Thor <ref> [LDG + 96] </ref> is an object-oriented database being developed at MIT that provides persistent and highly available storage for its objects. Thor objects are encapsulated, requiring clients to access database objects through calls of object methods and routines. <p> The same client API is provided by the two different Java veneer implementations discussed in Chapter 4 and Chapter 5. Since the two implementations provide the same API, the exact same Java client code runs in both versions. The Java client API is based upon the C++ client API <ref> [LDG + 96] </ref> with some additions to take advantage of features in Java such as exception handling. The client API is divided into two major parts. First, the Java client API provides a set of procedures for supporting basic Thor commands.
Reference: [Sun95a] <author> Sun Microsystems. </author> <title> Java Language Specification, </title> <note> version 1.0 beta edition, Oc-tober 1995. Available at http://ftp.javasoft.com/docs/vmspec.ps.Z. </note>
Reference-contexts: For example, an entire client application can be downloaded to run directly inside of the server. To evaluate the benefits of using code importing, I implemented two interfaces between Thor [LDG + 96], a new object-oriented database system, and clients written in the Java programming language <ref> [Sun95a] </ref>. The first Java interface to Thor uses a variant of RPC techniques for safety, communicating with Thor using TCP/IP communication. The second Java interface to Thor imports and runs the Java client code inside the Thor server using an embedded Java interpreter. <p> For a more complete background on Thor, see [LDG + 96, LAC + 96, LCD + 94]. For a more complete background on Java, see <ref> [Sun95a, Sun95b, Yel95] </ref>. 2.1 Thor Thor [LDG + 96] is an object-oriented database being developed at MIT that provides persistent and highly available storage for its objects. Thor objects are encapsulated, requiring clients to access database objects through calls of object methods and routines. <p> The creator for each stub class has a handle table index as an argument. The creator then initializes an index variable in the new stub objects and increments the reference count in the handle table. 2 Java allows the user to associate a finalizer procedure with each class <ref> [Sun95a] </ref>. An object's finalizer runs after the Java garbage collector determines that the object is no 2 The stub object index, the stub object creation methods, and the handle table itself are accessible only within the veneer package, preventing clients from creating invalid objects or objects with invalid reference counts. <p> The ability to run imported Java code is achieved by compiling and linking a slightly modified Java interpreter with the Thor server. The second function that the system provides is a mechanism for calling Thor methods from Java code. The Java interpreter provides native methods <ref> [Sun95a] </ref> for calling routines implemented in C. By using native methods in Java, 37 a library of C stub routines provides the interface for Java to call Thor operations directly. From a performance standpoint, the code-importing veneer design has a number of advantages compared with the RPC veneer.
Reference: [Sun95b] <author> Sun Microsystems. </author> <title> The Java Virtual Machine Specification, release 1.0 beta edition, </title> <month> August </month> <year> 1995. </year> <note> Available at http://ftp.javasoft.com/docs/javaspec.ps.tar.Z. </note>
Reference-contexts: For a more complete background on Thor, see [LDG + 96, LAC + 96, LCD + 94]. For a more complete background on Java, see <ref> [Sun95a, Sun95b, Yel95] </ref>. 2.1 Thor Thor [LDG + 96] is an object-oriented database being developed at MIT that provides persistent and highly available storage for its objects. Thor objects are encapsulated, requiring clients to access database objects through calls of object methods and routines.
Reference: [WLAG93] <author> Robert Wahbe, Steven Lucco, Thomas E. Anderson, and Susan L. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In 14th ACM Symp. on Operating System Principles, </booktitle> <pages> pages 203-216, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Importing code has also been shown to be useful in operating systems for improving system performance. The Aegis [EKJ95] operating system allows untrusted code to be downloaded into the kernel. The untrusted code is made safe by using code inspection and sandboxing <ref> [WLAG93] </ref>. This use of code importing to improve performance is similar to the code-importing Java veneer. The main differences are that verification of Java relies upon type safety of the language, and that once verification is performed the Java code can run without modification.
Reference: [Yel95] <author> Frank Yellin. </author> <title> Low-level security in Java, December 1995. </title> <booktitle> Presented at the Fourth International World Wide Web Conference, </booktitle> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: For a more complete background on Thor, see [LDG + 96, LAC + 96, LCD + 94]. For a more complete background on Java, see <ref> [Sun95a, Sun95b, Yel95] </ref>. 2.1 Thor Thor [LDG + 96] is an object-oriented database being developed at MIT that provides persistent and highly available storage for its objects. Thor objects are encapsulated, requiring clients to access database objects through calls of object methods and routines.
Reference: [Zon95] <author> Quinton Y. Zondervan. </author> <title> Increasing cross-domain call batching using promises and batched control structures. </title> <type> Technical Report MIT/LCS/TR-658, </type> <institution> Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA, </address> <month> June </month> <year> 1995. </year> <type> Master's thesis. 62 </type>
Reference-contexts: Unfortunately, for most programs, the batching factor (i.e., the number of calls that are sent at once) is fairly small, making the overall gain smaller than is desirable. The use of Batched Control Structures (BCS), presented by Zondervan <ref> [Zon95] </ref>, extends the applicability of call batching. In many programs the batching size using batched futures is limited by conditionals such as those used in loop control structures. BCS allows increased batching size by sending the server additional information about the structure of the program.
References-found: 16

