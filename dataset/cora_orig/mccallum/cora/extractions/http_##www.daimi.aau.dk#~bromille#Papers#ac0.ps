URL: http://www.daimi.aau.dk/~bromille/Papers/ac0.ps
Refering-URL: http://www.daimi.aau.dk/~bromille/Papers/index.html
Root-URL: http://www.daimi.aau.dk
Email: arne@dna.lund.dth.se  pbmilter@cs.toronto.edu  pmtsr@amsta.leeds.ac.uk  mthorup@diku.dk  
Title: Static Dictionaries on AC 0 RAMs: Query time fi( r is necessary and sufficient  
Author: Arne Andersson Peter Bro Miltersen Soren Riis Mikkel Thorup 
Note: DIKU-TR-96/5  
Address: Toronto  Leeds  
Affiliation: Lund University  University of  University of  University of Copenhagen  
Abstract: In this paper we consider solutions to the static dictionary problem on AC 0 RAMs, i.e. random access machines where the only restriction on the finite instruction set is that all computational instructions are in AC 0 . Our main result is a tight upper and lower bound of fi( log n= log log n) on the time for answering membership queries in a set of size n when reasonable space is used for the data structure storing the set; the upper bound can be obtained using O(n) space, and the lower bound holds even if we allow space 2 polylog n . Several variations of this bound is also obtained, including tight upper and lower bounds on the storage space if the query time must be constant and bounds valid for non-AC 0 RAMs if the execution time of an instruction computing a function is measured as the minimal depth of a polynomially sized unbounded fan-in circuit computing the function. We refer to this model as the Circuit RAM. As an example of the latter, we show that any RAM instruction set which permits a linear space, constant query time solution to the static dictionary problem must have an instruction of depth (log w= log log w), where w is the word size of the machine (and log the size of the universe). This matches the depth of multiplication and integer division, used in the two level perfect hashing scheme by Fredman, Komlos and Szemeredi. One of the non-dictionary related consequences of our techniques is a randomized AC 0 sorting algorithm using O(n(log log n) 2 ) time and linear space. fl Technical Report DIKU-TR-96/5, Department of Computer Science, University of Copenhagen. y This work was initiated while the author visited Copenhagen, supported by the Danish Science Research Council. 
Abstract-found: 1
Intro-found: 1
Reference: [AH92] <author> S. Albers and T. Hagerup, </author> <title> Improved parallel integer sorting without concurrent writing, </title> <booktitle> in Proceedings of the 3rd ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 463-472, </pages> <year> 1992. </year>
Reference-contexts: However, below we present an alternative method, grouping duplicates in time O (n log log n) and linear space. As a consequence, we will get linear space AC 0 sorting in expected time O (n (log log n) 2 ). As pointed out in [AHNR95], the results from <ref> [AH92] </ref> imply Lemma 28 On an AC 0 RAM, we can sort n keys of length w=(log n log log n) in time O (n) and space O (n).
Reference: [AHNR95] <author> A. Andersson, T. Hagerup, S. Nilsson, and R. Raman. </author> <title> Sorting in linear time? In Proc. </title> <booktitle> 27th ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 427-436, </pages> <year> 1995. </year>
Reference-contexts: Grouping and sorting In this section, we address the problem of sorting n words on an AC 0 RAM using O (n) space and o (n log n) time. Previous sub-n log n solutions either used multiplication [FW93] or super-linear space <ref> [AHNR95] </ref>. As a subroutine in our solution, we consider the problem of grouping duplicates in a sequence of n words, i.e. producing a permutation of the sequence where identical words are consecutive. Note that a sorting algorithm is also a grouping algorithm, but that the converse does not necessarily hold. <p> Note that a sorting algorithm is also a grouping algorithm, but that the converse does not necessarily hold. However, from <ref> [AHNR95] </ref>, we do have: Lemma 27 On an AC 0 RAM, if we can identify duplicates among n keys in time D (n) and space S (n), we can sort n keys in time O (D (n) log log n) and space S (n). <p> However, below we present an alternative method, grouping duplicates in time O (n log log n) and linear space. As a consequence, we will get linear space AC 0 sorting in expected time O (n (log log n) 2 ). As pointed out in <ref> [AHNR95] </ref>, the results from [AH92] imply Lemma 28 On an AC 0 RAM, we can sort n keys of length w=(log n log log n) in time O (n) and space O (n).
Reference: [AMRT96] <author> A. Andersson, P.B. Miltersen, S. Riis, and M. </author> <title> Thorup. Static Dictionaries on AC 0 RAMs: Query time fi( p log n= log log n) is necessary and sufficient, </title> <type> Technical Report DIKU-TR-96/5. </type> <institution> Department of Computer Science, University of Copenhagen. </institution> <year> 1996. </year>
Reference: [And95] <author> A. Andersson. </author> <title> Sublogarithmic searching without multiplications. </title> <booktitle> In Proc. FOCS, </booktitle> <year> 1995. </year>
Reference-contexts: Lemma 6 A set of n keys, each containing k bits, can be stored using linear space and with query time O i log w j Proof: We store the set as a Packed B-tree <ref> [And95] </ref>, i.e. a B-tree of degree w=k, where each B-tree node is represented inside a word. In order to search the packed B-tree, we need an instruction Rank (P; X; k) that views the words P and X as divided in k-bit fields. <p> If we set d = 1 and use the fact the H = O (log w) we get a cost of O (log 2 w). Previous sub-log n solutions to the dynamic predecessor problem have used either multiplication or super-linear space (see <ref> [And95] </ref> for a discussion). Grouping and sorting In this section, we address the problem of sorting n words on an AC 0 RAM using O (n) space and o (n log n) time. Previous sub-n log n solutions either used multiplication [FW93] or super-linear space [AHNR95].
Reference: [Bea94] <author> P. Beame. </author> <title> A switching lemma primer. </title> <type> Manuscript, </type> <year> 1994. </year>
Reference-contexts: Our lower bound proof uses Hastad's switching Lemma [Has87]. Rather than the original version, we use the following slight variation, which appears as Lemma 1 in <ref> [Bea94] </ref>. This version has the advantages of leaving a predetermined number of variables unset and yielding a decision tree rather than a DNF formula. Recall that a restriction on m variables is a map ae : f1; . . .; mg ! f0; 1; flg.
Reference: [BCH86] <author> P.W. Beame, S.A. Cook, H.J. </author> <title> Hoover. Log depth circuits for division and related problems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 15 </volume> <pages> 994-1003, </pages> <year> 1986. </year>
Reference-contexts: Instead we do allow them, but charge them more, using the well-studied depth measure from circuit complexity. Note that in the Circuit RAM model, the two level hashing scheme of [FKS84] has query time O (log w= log log w), since multiplication and integer division <ref> [BCH86] </ref> are in N C 1 and any function in N C 1 has polynomial size circuits of depth O (log w= log log w) [CSV84]. We provide a matching lower bound that also generalizes the lower bound of Theorem A.
Reference: [CW79] <author> J.L. Carter and M.N. Wegman. </author> <title> Universal classes of hash functions, </title> <journal> J. Comp. Syst. Sci. </journal> <volume> 18 (1979), </volume> <pages> 143-154. </pages>
Reference-contexts: Modifying a reduction from [Tho96], we derive Corollary 31 There is a monotone AC 0 priority queue supporting find-min in constant time and insert and delete in expected amortized time O ((log log n) 2 ). On a Circuit RAM we can actually do slightly better. Universal hashing <ref> [CW79] </ref> has expected query time O (log w= log log w) on a Circuit RAM, as opposed to the O (log w) expected AC 0 query time from Theorem 25.
Reference: [CSV84] <author> A.K. Chandra, L. Stockmeyer, and U. Vishkin. </author> <title> Constant depth reducibility. </title> <journal> SIAM Journal on Computing, </journal> <volume> 13 </volume> <pages> 423-439, </pages> <year> 1984. </year>
Reference-contexts: the Circuit RAM model, the two level hashing scheme of [FKS84] has query time O (log w= log log w), since multiplication and integer division [BCH86] are in N C 1 and any function in N C 1 has polynomial size circuits of depth O (log w= log log w) <ref> [CSV84] </ref>. We provide a matching lower bound that also generalizes the lower bound of Theorem A. Theorem C There is no Circuit RAM solution to the static dictionary problem using space 2 polylogn and with query time o (log w= log log w).
Reference: [DHKP93] <author> M. Dietzfelbinger, T. Hagerup, J. Katajainen, and M. Penttonen. </author> <title> A reliable randomized algorithm for the closest-pair problem. </title> <type> Technical Report 513, </type> <institution> Fachbereich Informatik, Universitat Dortmund, </institution> <year> 1993. </year>
Reference-contexts: Since these instructions are usually considered expensive, it is natural to ask whether their use can be avoided. The family may be replaced by a family due to Knuth [Knu73, p.509] using only multiplication, bitwise Boolean operations, and shifts (see <ref> [DHKP93] </ref> for details), so integer division is not essential. But so far, the existence of optimal schemes for static dictionaries with multiplication replaced by cheaper instructions has remained an open problem. <p> We use log n bits for branching, hence the height of the trie is c. At each node, the outgoing edges are stored in a hash table. For this purpose, we simulate the classical two level hashing of [FKS84]. As observed by <ref> [DHKP93] </ref>, the only non-AC 0 instruction needed for implementing this scheme is multiplication. We therefore only have to observe that we can perform a multiplication of two (log n)-bit keys in constant time, using O (n) extra space, namely a precomputed multiplication table for (log n)=2-bit keys.
Reference: [FM95] <author> F. Fich and P.B. Miltersen. </author> <title> Tables should be sorted (on random access machines). </title> <booktitle> In Proc. 4th International Workshop on Algorithms and Data Structures (WADS), </booktitle> <pages> pages 482-493, </pages> <year> 1995. </year>
Reference: [FKS84] <author> M.L. Fredman, J. Komlos, and E. Szemeredi. </author> <title> Storing a sparse table with O(1) worst case access time. </title> <journal> J. Ass. Comp. Mach., </journal> <volume> 31 </volume> <pages> 538-544, </pages> <year> 1984. </year>
Reference-contexts: The set A can be stored as a sorted table using n memory registers allowing queries to be answered using binary search in O (log n) time. Yao [Yao81] first considered the possibility of improving this solution and provided an improvement for certain cases. Fredman, Komlos and Szemeredi <ref> [FKS84] </ref> showed that for all values of w and n, there is a storage scheme using O (n) memory registers, so that queries can be answered in constant time. <p> Disallowing them would make our lower bounds less interesting, since such instructions are present on real computers. Instead we do allow them, but charge them more, using the well-studied depth measure from circuit complexity. Note that in the Circuit RAM model, the two level hashing scheme of <ref> [FKS84] </ref> has query time O (log w= log log w), since multiplication and integer division [BCH86] are in N C 1 and any function in N C 1 has polynomial size circuits of depth O (log w= log log w) [CSV84]. <p> Proof: We store the keys in a hash-coded path-compressed trie. We use log n bits for branching, hence the height of the trie is c. At each node, the outgoing edges are stored in a hash table. For this purpose, we simulate the classical two level hashing of <ref> [FKS84] </ref>. As observed by [DHKP93], the only non-AC 0 instruction needed for implementing this scheme is multiplication.
Reference: [FW93] <author> M.L. Fredman and D.E. Willard. </author> <title> Surpassing the information theoretic bound with fusion trees. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 47 </volume> <pages> 424-436, </pages> <year> 1993. </year> <month> 21 </month>
Reference-contexts: Grouping and sorting In this section, we address the problem of sorting n words on an AC 0 RAM using O (n) space and o (n log n) time. Previous sub-n log n solutions either used multiplication <ref> [FW93] </ref> or super-linear space [AHNR95]. As a subroutine in our solution, we consider the problem of grouping duplicates in a sequence of n words, i.e. producing a permutation of the sequence where identical words are consecutive.
Reference: [Has87] <author> J. Hastad. </author> <title> Computational Limitations of Small-Depth Circuits. </title> <publisher> ACM doctoral disser-tation award. MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Our lower bound relies on a recursive construction of a difficult set. At each level of the recursion we use probabilistic methods including Hastad's switching lemma <ref> [Has87] </ref>. <p> By a simple averaging argument, this will give the desired randomized lower bounds for the problem of storing the set consisting of first components of the pairs. Our lower bound proof uses Hastad's switching Lemma <ref> [Has87] </ref>. Rather than the original version, we use the following slight variation, which appears as Lemma 1 in [Bea94]. This version has the advantages of leaving a predetermined number of variables unset and yielding a decision tree rather than a DNF formula.
Reference: [Kar84] <author> R. Karlsson. </author> <title> Algorithms in a Restricted Universe. </title> <type> Ph.D. Thesis, </type> <institution> University of Waterloo, Canada, </institution> <year> 1984. </year>
Reference-contexts: Related research Apart from the sorted table/binary search solution, previous linear space solutions to the static dictionary problem implementable on AC 0 RAMs were constructed by Tarjan and Yao [TY79], achieving constant query time if w = c log n for some constant c, and by Willard [Wil84] and Karlsson <ref> [Kar84] </ref>, achieving query time O ( p Previous lower bounds for the static dictionary problem have been obtained by Fich and Mil-tersen [FM95,Mil96].
Reference: [Knu73] <author> D.E. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol. 3: </volume> <publisher> Sorting and Searching Addison-Wesley, </publisher> <year> 1973. </year>
Reference-contexts: Thus, multiplication and integer division are used by the query program. Since these instructions are usually considered expensive, it is natural to ask whether their use can be avoided. The family may be replaced by a family due to Knuth <ref> [Knu73, p.509] </ref> using only multiplication, bitwise Boolean operations, and shifts (see [DHKP93] for details), so integer division is not essential. But so far, the existence of optimal schemes for static dictionaries with multiplication replaced by cheaper instructions has remained an open problem.
Reference: [LMN93] <author> N. Linial, Y. Mansour, and N. Nisan. </author> <title> Constant depth circuits, Fourier transform, and learnability. </title> <journal> Journal of the ACM, </journal> <volume> 40(3) </volume> <pages> 607-620, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: From circuit complexity there is a result of Mansour, Nisan, and Tiwari [MNT93] (building on <ref> [LMN93] </ref>) that no AC 0 circuit implements a family of universal hash functions fH k g, where "implements" means that the circuit on input (k; x) computes H k (x).
Reference: [MNT93] <author> Y. Mansour, N. Nisan, and P. Tiwari. </author> <title> The computational complexity of universal hashing. </title> <journal> Theoretical Computer Science, </journal> <volume> 107 </volume> <pages> 121-133, </pages> <year> 1993. </year>
Reference-contexts: From circuit complexity there is a result of Mansour, Nisan, and Tiwari <ref> [MNT93] </ref> (building on [LMN93]) that no AC 0 circuit implements a family of universal hash functions fH k g, where "implements" means that the circuit on input (k; x) computes H k (x).
Reference: [Mil96] <author> P.B. Miltersen. </author> <title> Lower bounds for static dictionaries on RAMs with bit operations but no multiplication. </title> <note> ICALP '96, to appear. </note>
Reference-contexts: It is open if logarithmic query time is optimal for the Practical RAM, the best current lower bound being the ( p log n= log log n) one implied by this paper, improving the (log log n) one of <ref> [Mil96] </ref>. From circuit complexity there is a result of Mansour, Nisan, and Tiwari [MNT93] (building on [LMN93]) that no AC 0 circuit implements a family of universal hash functions fH k g, where "implements" means that the circuit on input (k; x) computes H k (x).
Reference: [Pap94] <author> C.H. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison Wesley, </publisher> <year> 1994. </year>
Reference-contexts: We now show how we can use the probabilistic method to replace the random restriction by one from a small, fixed, family, and thereby circumvent this problem. We shall use a Chernoff bound argument. The following version of the Chernoff bound can be found in <ref> [Pap94] </ref>. Lemma 36 Let X 1 ; X 2 ; . . . ; X m be independent Bernoulli trials with Pr [X i = 1] = p. Let X = P X i and let = E [X] = mp. Then Pr (X &gt; 2) &lt; e =3 .
Reference: [TY79] <author> R.E. Tarjan and A.C. Yao. </author> <title> Storing a sparse table. </title> <journal> Communications of the Ass. Comp. Mach., </journal> <volume> 22(11) </volume> <pages> 606-611, </pages> <month> November </month> <year> 1979. </year>
Reference-contexts: At each level of the recursion we use probabilistic methods including Hastad's switching lemma [Has87]. Related research Apart from the sorted table/binary search solution, previous linear space solutions to the static dictionary problem implementable on AC 0 RAMs were constructed by Tarjan and Yao <ref> [TY79] </ref>, achieving constant query time if w = c log n for some constant c, and by Willard [Wil84] and Karlsson [Kar84], achieving query time O ( p Previous lower bounds for the static dictionary problem have been obtained by Fich and Mil-tersen [FM95,Mil96].
Reference: [Tho96] <author> M. </author> <title> Thorup. On RAM priority queues. </title> <booktitle> In Proceedings of the 7th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 59-67, </pages> <year> 1996. </year>
Reference-contexts: A monotone priority queue is a priority queue with non-decreasing minimum, as is the case for applications within greedy algorithms. Modifying a reduction from <ref> [Tho96] </ref>, we derive Corollary 31 There is a monotone AC 0 priority queue supporting find-min in constant time and insert and delete in expected amortized time O ((log log n) 2 ). On a Circuit RAM we can actually do slightly better.
Reference: [Wil84] <author> D. E. Willard. </author> <title> New trie data structures which support very fast search operations. </title> <journal> Journal of Computer and Systems Sciences, </journal> <volume> 28 </volume> <pages> 379-394, </pages> <year> 1984. </year>
Reference-contexts: Related research Apart from the sorted table/binary search solution, previous linear space solutions to the static dictionary problem implementable on AC 0 RAMs were constructed by Tarjan and Yao [TY79], achieving constant query time if w = c log n for some constant c, and by Willard <ref> [Wil84] </ref> and Karlsson [Kar84], achieving query time O ( p Previous lower bounds for the static dictionary problem have been obtained by Fich and Mil-tersen [FM95,Mil96].
Reference: [Yao81] <author> A.C. Yao. </author> <title> Should tables be sorted? J. Ass. </title> <journal> Comp. Mach., </journal> <volume> 28 </volume> <pages> 615-628, </pages> <year> 1981. </year> <month> 22 </month>
Reference-contexts: We are interested in tradeoffs between the storage space (measured by the number of registers used) and the query time. The set A can be stored as a sorted table using n memory registers allowing queries to be answered using binary search in O (log n) time. Yao <ref> [Yao81] </ref> first considered the possibility of improving this solution and provided an improvement for certain cases. Fredman, Komlos and Szemeredi [FKS84] showed that for all values of w and n, there is a storage scheme using O (n) memory registers, so that queries can be answered in constant time.
References-found: 23

