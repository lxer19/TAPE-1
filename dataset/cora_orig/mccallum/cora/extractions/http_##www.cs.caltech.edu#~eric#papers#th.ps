URL: http://www.cs.caltech.edu/~eric/papers/th.ps
Refering-URL: http://www.cs.caltech.edu/~eric/papers/papers.html
Root-URL: http://www.cs.caltech.edu
Title: Finite-Difference Algorithms for Counting Problems  
Author: Eric Bax 
Degree: Thesis by  In Partial Fulfillment of the Requirements for the Degree of Doctor of Philosophy  
Date: 1998 (Submitted November 11, 1997)  
Address: Pasadena, California  
Affiliation: California Institute of Technology  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> T. Araki, Y. Sugiyama, T. Kasami, and J. Okui, </author> <title> Complexity of the deadlock avoidance problem, </title> <booktitle> Proc. 2nd IBM Symp. on Mathematical Foundations of Computer Science, </booktitle> <address> IBM Japan, Tokyo 229-252. </address>
Reference-contexts: We use the problem with the constraint that no partial requests are allowed. For in-depth analysis of deadlock problems, see <ref> [1, 14, 15, 19] </ref>. <p> Note that the bracketed expression is in <ref> [0; 1] </ref> for all k. So the term corresponding to k is no greater than 1 2 n k , which is the probability that the sum of n i.i.d. <p> Recall that the expected value of a row sum in a 0-1 matrix, given k variables x j assigned +1, is: 74 where p is the probability of each entry taking value 1. Since the computational reduction proof applies for p 2 <ref> [0; 1] </ref>, it applies for j k j as large as j2k nj. For f1; 0; 1g matrices, let 0 be the expected value of each entry. <p> E 2 (k) = R 1 (A.34) Note that hg (kh)h 0 g (k 0 h 0 ) E 2 (k) min x2 [0;1] hg ((k + x)h)h 0 g ((k 0 x)h 0 ) Examine the bounding fractions for x 2 <ref> [0; 1] </ref>. hg (kh)h 0 g (k 0 h 0 ) = g ((k + x)h)g ((k 0 x)h) Expand the Gaussians and subtract exponents to divide. e 1 2 (h 0 ) 2 [(k 0 ) 2 (k 0 x) 2 ] (A.37) Simplify. e 1 2 (h 0 ) <p> Thus, for any * &gt; 0, for all x 2 <ref> [0; 1] </ref>, for all n and n 0 sufficiently large, and for jkj n 0:66 and jk 0 j (n 0 ) 0:66 , 1 * &lt; e 2 npq [2kxx 2 ] 1 1 &lt; 1 + * (A.40) Hence, for every * &gt; 0 and n and n 0
Reference: [2] <author> E. Bax, </author> <title> Inclusion and exclusion algorithm for the Hamiltonian path problem, </title> <journal> Inform. Process. Lett., </journal> <note> 27 (4) (1993) 203-207. </note>
Reference-contexts: So the Hamiltonian paths correspond to multilinear terms. 2 1.2 Inclusion and Exclusion Method The following algorithm is adapted from a paper by Karp [24]. (For related results, see <ref> [2, 3] </ref>.) Let U be the set of length n + 1 s-t walks in G that contain neither vertex s nor vertex t as internal vertices. Let W S be the set of walks that lack all vertices in S f1; : : : ; ng.
Reference: [3] <author> E. Bax, </author> <title> Algorithms to count paths and cycles, </title> <journal> Inform. Process. Lett., </journal> <month> 52 </month> <year> (1994) </year> <month> 249-252. </month>
Reference-contexts: So the Hamiltonian paths correspond to multilinear terms. 2 1.2 Inclusion and Exclusion Method The following algorithm is adapted from a paper by Karp [24]. (For related results, see <ref> [2, 3] </ref>.) Let U be the set of length n + 1 s-t walks in G that contain neither vertex s nor vertex t as internal vertices. Let W S be the set of walks that lack all vertices in S f1; : : : ; ng. <p> The material in this chapter was originally published as a paper in Information Processing Letters [6]. For an algorithm that counts paths or cycles of all lengths, see <ref> [3] </ref>. For an algorithm to list all cycles, see [31]. 3.1 Paths Let G be a directed graph with vertex set V = fs; tg [ f1; : : : ; ng.
Reference: [4] <author> E. Bax, </author> <title> Recurrence-based reductions for inclusion and exclusion algorithms applied to #P problems, </title> <publisher> CalTech-CS-TR-96-01. </publisher>
Reference-contexts: Then we show how to produce computational reductions based on problem structure. Using the problem of counting paths by length as an example, we show that a framework to develop reductions for inclusion and exclusion algorithms <ref> [4] </ref> extends to finite-difference algorithms. 4.1 A Recursive Algorithm The following algorithm recursively evaluates the finite-differences in the expression D 1 D n P (). The problem size n and the finite-difference parameters u and v are global variables. <p> So the function call can be amended: if j; : : : ; j + m 1 are symmetric vertices then return P m i paths (j + m; x + e j + : : : + e j+i1 ) A fast test for vertex symmetry is given in <ref> [4] </ref>. 4.3 Ordering Finite-Difference Evaluations The reductions depend on the order of assignment to variables x 1 ; : : : ; x n . Some dependencies are not true restrictions; they were imposed to simplify the presentation. These dependencies can be overcome by dynamically reordering the assignments. <p> To prove this, recall that paths (j; x) computes D j D n . Permuting labels is equivalent to reordering the evaluation of finite-difference operators. Since finite-difference operators commute, the result remains the same. A previous paper <ref> [4] </ref> contains more details about the reductions presented here and about strategies to reduce computation by reordering the recursion. 23 Chapter 5 Finite-Difference Algorithms for Other Problems 5.1 Introduction To demonstrate the methods introduced in previous chapters, we now develop finite-difference algorithms for a few other problems.
Reference: [5] <author> E. Bax, </author> <title> Tailoring the permanent formula to problem instances, </title> <publisher> CalTech-CS-TR-96-17. </publisher>
Reference-contexts: The settings analyzed here are certainly not optimal for all specific 0-1 matrices. A technical report <ref> [5] </ref> outlines some methods to tailor the finite-difference parameters to problem instances. The next chapter is devoted to a procedure to increase the expected fraction of zero-valued terms. The procedure works in conjunction with the parameter settings analyzed in this chapter.
Reference: [6] <author> E. Bax and J. Franklin, </author> <title> A finite-difference sieve to count paths and cycles by length, </title> <journal> Inform. Process. Lett., </journal> <month> 60 </month> <year> (1996) </year> <month> 171-176. </month>
Reference-contexts: The principle of inclusion and exclusion does not apply directly to the general problem, but the finite-difference approach produces the algorithm in a straightforward fashion. The material in this chapter was originally published as a paper in Information Processing Letters <ref> [6] </ref>. For an algorithm that counts paths or cycles of all lengths, see [3]. For an algorithm to list all cycles, see [31]. 3.1 Paths Let G be a directed graph with vertex set V = fs; tg [ f1; : : : ; ng.
Reference: [7] <author> E. Bax and J. Franklin, </author> <title> A finite-difference sieve to compute the permanent, </title> <publisher> CalTech-CS-TR-96-04. </publisher>
Reference-contexts: However, 35 the counting problem is #P-complete. Ryser made progress on computing the permanent by developing an inclusion and exclusion algorithm [29]. The algorithms presented here are a generalization of that inclusion and exclusion algorithm. The results in this chapter are taken from several papers <ref> [7, 8] </ref>. 6.1 A Finite-Difference Formula for the Permanent The permanent of an n fi n 0-1 matrix is the number of n-sets of one-valued entries with one entry in each row and one entry in each column. per A = j 1 :::j n where j 1 : : : <p> P rfa 1 + : : : + a k (a k+1 + : : : + a n ) = 0g = -=0 (6.10) (For a dynamic programming procedure to compute the fraction of nonzero-valued terms for general finite-difference parameters, see <ref> [7] </ref>.) To find an upper bound for (6.9) as n ! 1, we will use several results from probability theory [11].
Reference: [8] <author> E. Bax and J. Franklin, </author> <title> A permanent formula with many zero-valued terms, </title> <journal> Inform. Process. Lett., </journal> <month> 63 </month> <year> (1997) </year> <month> 33-39. </month>
Reference-contexts: However, 35 the counting problem is #P-complete. Ryser made progress on computing the permanent by developing an inclusion and exclusion algorithm [29]. The algorithms presented here are a generalization of that inclusion and exclusion algorithm. The results in this chapter are taken from several papers <ref> [7, 8] </ref>. 6.1 A Finite-Difference Formula for the Permanent The permanent of an n fi n 0-1 matrix is the number of n-sets of one-valued entries with one entry in each row and one entry in each column. per A = j 1 :::j n where j 1 : : :
Reference: [9] <author> R. Bellman, </author> <title> Dynamic programming treatment of the travelling salesman problem, </title> <journal> J. Assoc. Comput. Mach., </journal> <month> 9 </month> <year> (1962) </year> <month> 61-63. </month>
Reference-contexts: Like the general finite-difference formula, the inclusion and exclusion formula can be computed in O (n 2 2 n ) time and O (n 2 ) space. 1.3 Dynamic Programming Method The following algorithm is adapted from a paper by Bellman <ref> [9] </ref>. (For related results, see [16].) The algorithm counts paths of successive lengths. On termination, c S;j is the number of s-j paths with internal vertices S. Hence, c f1;:::;ng;t is the number of s-t Hamiltonian paths. The adjacencies A and t are defined as before.
Reference: [10] <author> J. A. Bondy and U. S. R. Murty, </author> <title> Graph Theory with Applications, </title> <publisher> North-Holland 1976. </publisher>
Reference-contexts: In this case, the existence problem is NP-complete [23, 13], and the counting problem is #P-complete [33]. In the case of the permanent, the existence problem determining whether a bipartite graph has a complete matching is in P <ref> [25, 10] </ref>. However, 35 the counting problem is #P-complete. Ryser made progress on computing the permanent by developing an inclusion and exclusion algorithm [29]. The algorithms presented here are a generalization of that inclusion and exclusion algorithm.
Reference: [11] <author> W. Feller, </author> <title> An Introduction to Probability Theory and Its Applications, </title> <publisher> John Wiley and Sons, Inc. </publisher> <year> 1968. </year> <month> 111 </month>
Reference-contexts: + : : : + a n ) = 0g = -=0 (6.10) (For a dynamic programming procedure to compute the fraction of nonzero-valued terms for general finite-difference parameters, see [7].) To find an upper bound for (6.9) as n ! 1, we will use several results from probability theory <ref> [11] </ref>. First, approximate the binomial distribution n 1 2 n by the normal distribution 2 p n (k n 2 )), where g (z) = 1 p 2 2 z 2 . <p> Each even row has sum zero when half the entries of x that correspond to one-valued entries in the row are assigned +1. The fraction 54 of assignments that zero each even row is 1 n 2 4 4 1 n by Stirling's formula <ref> [11] </ref>. So each even row has a nonzero sum in about 1 1 p n of the assignments. <p> Bernoulli variables is k, given that each variable takes value one with probability 1 2 and zero with probability 1 2 . According to Feller <ref> [11] </ref>, p. 193, (6.7) jk n 1 k ~ p 1 1 n 0:28 ) (7.14) 58 So we introduce error o (exp ( 1 2 n 0:28 )) by restricting the sum to values of k such that jk n 2 j 2n 0:64 . According to Feller [11], p. <p> Feller <ref> [11] </ref>, p. 193, (6.7) jk n 1 k ~ p 1 1 n 0:28 ) (7.14) 58 So we introduce error o (exp ( 1 2 n 0:28 )) by restricting the sum to values of k such that jk n 2 j 2n 0:64 . According to Feller [11], p. 184, (3.13), 1 k ~ p g ( p ) for jk 2 where g () is the standard normal, i.e., g (z) = 1 p 2 2 z 2 ). <p> For example, in the extreme case that all terms have the same value, the estimate is exact regardless of the terms chosen for the sample. We place this intuition into a mathematical context using the central limit theorem, as derived in Feller <ref> [11] </ref>, p. 244. <p> Since we can choose N such that, for all n N , the approx 100 imations supplied by this appendix meet the error tolerance requirements, this appendix supplies sufficient asymptotic approximations. To use notation from Feller <ref> [11] </ref>, in which k plays a different role, we use n in the role of k and n 0 in the role of n k in the remainder of this appendix. <p> We will use results from Feller <ref> [11] </ref> for the sum over a single set of i.i.d. variables to derive results for the sum over a pair of sets. Following the notation in Feller [11], Ch. <p> We will use results from Feller <ref> [11] </ref> for the sum over a single set of i.i.d. variables to derive results for the sum over a pair of sets. Following the notation in Feller [11], Ch. <p> Also, a 0 m 0 + k 0 (p 0 ) m 0 +k 0 The following lemma is proved in Feller <ref> [11] </ref>, p. 184: Lemma 1 If n ! 1 and k is constrained to an interval jkj &lt; K n such that K 3 n =n 2 ! 0, then for every * &gt; 0 and n sufficiently large, 1 * &lt; hg (kh) where h = 1 p npq and <p> Since a k 1 and a 0 k 0 1 for all values of k and k 0 , the second sum is no greater than X a k + jk 0 j&gt;(n 0 ) 0:66 k 0 (A.24) According to Feller <ref> [11] </ref>, p. 193, (6.7), these sums are o (e 1 ) and o (e 1 ) (A.25) Hence, b s = (k;k 0 )2S j jkjn 0:66 and jk 0 j (n 0 ) 0:66 a k a 0 2 n 0:32 2 (n 0 ) 0:32 103 Now use the <p> Since hg (kh) 1 and h 0 g (k 0 h 0 ) 1, E 3 is no greater than 2 k&gt;n 0:66 Z h 0 g (k 0 h 0 )dk 0 (A.43) According to the tail bound from Feller <ref> [11] </ref>, p. 175, (1.7), Z hg (kh)dk &lt; n 0:66 g (n 0:66 h) = o (e 1 ) (A.44) Hence, E 3 = o (e 1 ) + o (e 1 ) (A.45) Combining the results for the integral and errors in (A.27) and (A.30) completes the proof of the
Reference: [12] <author> J. Franklin, </author> <title> Methods of Mathematical Economics pp.68-79, </title> <publisher> Springer-Verlag New York, Inc. </publisher> <year> 1980. </year>
Reference: [13] <author> M. R. Garey and D. S. Johnson, </author> <title> Computers and Intractability A Guide to the Theory of NP-Completeness, </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: The permanent problem has applications to statistical physics, including problems involving monomer-dimer systems. For more information, see [30]. Computing the permanent is a #P-complete problem [32]. #P problems are the counting problems associated with NP problems <ref> [32, 13] </ref>. For example, determining whether or not a graph has a Hamiltonian cycle is an NP problem, so counting the Hamiltonian cycles is a #P problem. In this case, the existence problem is NP-complete [23, 13], and the counting problem is #P-complete [33]. <p> For example, determining whether or not a graph has a Hamiltonian cycle is an NP problem, so counting the Hamiltonian cycles is a #P problem. In this case, the existence problem is NP-complete <ref> [23, 13] </ref>, and the counting problem is #P-complete [33]. In the case of the permanent, the existence problem determining whether a bipartite graph has a complete matching is in P [25, 10]. However, 35 the counting problem is #P-complete.
Reference: [14] <author> E. M. Gold, </author> <title> Deadlock prediction: easy and difficult cases, </title> <journal> SIAM J. Comput., </journal> <volume> 7, </volume> <pages> 320-336. </pages>
Reference-contexts: Two problems, a sequencing problem and a bin packing problem, are taken from a paper by Karp [24] in which inclusion and exclusion algorithms are developed for the problems. (The paper also contains references to dynamic programming algorithms.) Another problem, involving deadlock avoidance, is taken from a paper by Gold <ref> [14] </ref>. For each problem, we derive a generating function for which the multilinear terms correspond to objects or configurations that we wish to count. Then, the counting algorithm amounts to applying the finite differences D 1 D n to the generating function. <p> in t m;k (x) with k distinct variables produces one multilinear term in the polynomial: t m;k (x)F nk (x) (5.36) So the feasible packings for subsets of k items are counted by D 1 D n t m;k (x)F nk (x) (5.37) 5.4 Deadlock Avoidance A paper by Gold <ref> [14] </ref> analyzes a general deadlock avoidance problem and several constrained versions of the problem. We use the problem with the constraint that no partial requests are allowed. For in-depth analysis of deadlock problems, see [1, 14, 15, 19]. For a proof that the problem presented here is NP-complete, see [14]. 5.4.1 <p> We use the problem with the constraint that no partial requests are allowed. For in-depth analysis of deadlock problems, see <ref> [1, 14, 15, 19] </ref>. <p> Gold <ref> [14] </ref> analyzes a general deadlock avoidance problem and several constrained versions of the problem. We use the problem with the constraint that no partial requests are allowed. For in-depth analysis of deadlock problems, see [1, 14, 15, 19]. For a proof that the problem presented here is NP-complete, see [14]. 5.4.1 The Problem For a system with r resource types, an instance of the deadlock avoidance problem is specified by a nonnegative integer r-vector a 0 that indicates how many units of each resource are available initially and n processes P 1 ; : : : ; P n .
Reference: [15] <author> A. N. Habermann, </author> <title> Prevention of system deadlocks, </title> <journal> Comm. ACM, </journal> <volume> 12, </volume> <pages> 373-377, 385. </pages>
Reference-contexts: We use the problem with the constraint that no partial requests are allowed. For in-depth analysis of deadlock problems, see <ref> [1, 14, 15, 19] </ref>.
Reference: [16] <author> M. Held and R. M. Karp, </author> <title> A dynamic programming approach to sequencing problems, </title> <journal> J. Soc. Indust. Appl. Math, </journal> <month> 10 </month> <year> (1962) </year> <month> 196-210. </month>
Reference-contexts: Like the general finite-difference formula, the inclusion and exclusion formula can be computed in O (n 2 2 n ) time and O (n 2 ) space. 1.3 Dynamic Programming Method The following algorithm is adapted from a paper by Bellman [9]. (For related results, see <ref> [16] </ref>.) The algorithm counts paths of successive lengths. On termination, c S;j is the number of s-j paths with internal vertices S. Hence, c f1;:::;ng;t is the number of s-t Hamiltonian paths. The adjacencies A and t are defined as before.
Reference: [17] <author> F. B. Hildebrand, </author> <title> Introduction to Numerical Analysis, </title> <publisher> McGraw-Hill 1956. </publisher>
Reference-contexts: We begin with the multilinear term and proceed to other terms. For a general treatment of finite differences, consult the numerical analysis text by Hildebrand <ref> [17] </ref>. 2.1 Finite-Differences and Multilinear Terms Recall that we defined the finite-difference operator with respect to x j as follows. D j f () u j v j Let P () be a polynomial with every term of degree n or less.
Reference: [18] <author> W. Hoeffding, </author> <title> Probability inequalities for sums of bounded random variables, </title> <journal> Am. Stat. Assoc. J., </journal> (1963):13-30. 
Reference-contexts: Given a specific problem instance, the variance among finite-difference terms can be estimated by sampling, and it can be bounded by finding upper and lower bounds on term values, then computing the variance for the worst-case distribution with these bounds. Also, Hoeffding's inequality <ref> [18] </ref> may be used to derive probabilistic bounds on the effectiveness of estimation by sampling. 9.2 Sampling Terms by Type In this section, we consider methods to estimate the finite-difference formula (9.1) by separately estimating sums over partitions of the terms and adding the estimates to obtain 88 n real alternating
Reference: [19] <author> R. C. </author> <title> Holt Some deadlock properties of computer systems, </title> <journal> ACM Computing Surveys, </journal> <volume> 4, </volume> <pages> 179-196. </pages>
Reference-contexts: We use the problem with the constraint that no partial requests are allowed. For in-depth analysis of deadlock problems, see <ref> [1, 14, 15, 19] </ref>.
Reference: [20] <author> M. R. Jerrum and A. Sinclair, </author> <title> Approximating the permanent, </title> <journal> SIAM Journal on Computing, </journal> <volume> 18(6) </volume> <pages> 1149-1178, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: 95 then B x 0 ;S = 2 n p2R X j 8j62S and x j 2f1;1g 8j2S p 1 +1 n (9.99) since the generating function terms indexed by P R are zeroed. 9.4 Discussion Recently, several algorithms have been developed to estimate the permanent of a 0-1 matrix <ref> [20, 21, 22, 28] </ref>.
Reference: [21] <author> M. Jerrum and U. Vazirani, </author> <title> A mildly exponential approximation algorithm for the permanent, </title> <journal> Algorithmica, </journal> <volume> 16(1996) </volume> <pages> 392-401. </pages>
Reference-contexts: 95 then B x 0 ;S = 2 n p2R X j 8j62S and x j 2f1;1g 8j2S p 1 +1 n (9.99) since the generating function terms indexed by P R are zeroed. 9.4 Discussion Recently, several algorithms have been developed to estimate the permanent of a 0-1 matrix <ref> [20, 21, 22, 28] </ref>. <p> More recently, Jerrum and Vazirani <ref> [21] </ref> have developed an approximation algorithm with time complexity O (poly (ffi; *; n)2 p n log 2 n ). Furthermore, there are polynomial time algorithms for several restricted classes of 0-1 matrices. For more information, see [28], Ch. 11. <p> For more information, see [28], Ch. 11. The approximation methods developed in this chapter do not fit into the FPRAS framework. There are no guarantees regarding the ratio of our estimators to the permanent, for reasons involving algorithm design and theory. The FPRAS-type algorithms <ref> [21, 22] </ref> operate by sampling permanent terms at random or evaluating determinants, which involve signed permanent terms. Our sampling procedures evaluate products of row sums, which may have many terms that are not permanent terms.
Reference: [22] <author> N. Karmarkar, R. Karp, R. Lipton, L. Lovasz, and M. Luby, </author> <title> A Monte Carlo algorithm for estimating the permanent, </title> <journal> SIAM Journal on Computing, </journal> <volume> 22(2) </volume> <pages> 284-293, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: 95 then B x 0 ;S = 2 n p2R X j 8j62S and x j 2f1;1g 8j2S p 1 +1 n (9.99) since the generating function terms indexed by P R are zeroed. 9.4 Discussion Recently, several algorithms have been developed to estimate the permanent of a 0-1 matrix <ref> [20, 21, 22, 28] </ref>. <p> fi n 0-1 matrix A and a real number * &gt; 0, and in time polynomial in both n and 1 * produces output Y (A; *) with the property: Prf (1 *) per A Y (A; *) (1 + *) per Ag 4 Karmarkar, Karp, Lipton, Lovasz, and Luby <ref> [22] </ref> designed a randomized algorithm for which Prf (1 + *) 1 per A Y (A; *) (1 + *) per Ag 1 ffi (9.101) The algorithm has time complexity O (poly (ffi; *; n)2 n 2 ), which is about the square root of the O (n 2 2 n <p> For more information, see [28], Ch. 11. The approximation methods developed in this chapter do not fit into the FPRAS framework. There are no guarantees regarding the ratio of our estimators to the permanent, for reasons involving algorithm design and theory. The FPRAS-type algorithms <ref> [21, 22] </ref> operate by sampling permanent terms at random or evaluating determinants, which involve signed permanent terms. Our sampling procedures evaluate products of row sums, which may have many terms that are not permanent terms.
Reference: [23] <author> R. M. Karp, </author> <title> Reducibility among combinatorial problems, </title> <editor> in R. E. Miller and J. W. Thatcher (eds.), </editor> <title> Complexity of Computer Computations, </title> <publisher> Plenum Press, </publisher> <address> New York, </address> <pages> 85-103. </pages>
Reference-contexts: For example, determining whether or not a graph has a Hamiltonian cycle is an NP problem, so counting the Hamiltonian cycles is a #P problem. In this case, the existence problem is NP-complete <ref> [23, 13] </ref>, and the counting problem is #P-complete [33]. In the case of the permanent, the existence problem determining whether a bipartite graph has a complete matching is in P [25, 10]. However, 35 the counting problem is #P-complete.
Reference: [24] <author> R. M. Karp, </author> <title> Dynamic programming meets the principle of inclusion and exclusion, </title> <journal> Oper. Res. Lett., </journal> <note> 1 (2) (1982) 49-51. </note>
Reference-contexts: So the Hamiltonian paths correspond to multilinear terms. 2 1.2 Inclusion and Exclusion Method The following algorithm is adapted from a paper by Karp <ref> [24] </ref>. (For related results, see [2, 3].) Let U be the set of length n + 1 s-t walks in G that contain neither vertex s nor vertex t as internal vertices. <p> Two problems, a sequencing problem and a bin packing problem, are taken from a paper by Karp <ref> [24] </ref> in which inclusion and exclusion algorithms are developed for the problems. (The paper also contains references to dynamic programming algorithms.) Another problem, involving deadlock avoidance, is taken from a paper by Gold [14]. <p> Then, the counting algorithm amounts to applying the finite differences D 1 D n to the generating function. Finally, we outline algorithms for variations of the problems, including associated optimization problems and counting alternative objects or configurations. 5.2 Sequencing 5.2.1 The Problem The sequencing problem is defined as follows <ref> [24] </ref>: "We are given a set of tasks T 1 ; T 2 ; : : : ; T n . Three integers are associated with each task T i : a positive execution time l (i), a non-negative release time r (i), and a positive deadline d (i). <p> We can count these feasible schedules by dynamic programming. To that end, define E (t) = fijr (i) t l (i) and t d (i)g 8t 2 f0; : : : ; T g (5.1) as in <ref> [24] </ref>. Set E (t) indexes the tasks that may complete at time t without violating their time constraints. <p> Hence, the solution is: D 1 D n s T;k (x)F nk (x) (5.14) 5.3 Bin Packing 5.3.1 The Problem The bin packing problem is defined in <ref> [24] </ref> as follows: "An instance of the bin packing problem is specified by a positive integer bin capacity B, a positive integer m giving the number of bins, and n items, where the size of item i is given by a positive integer s (i). <p> set of items can be partitioned into sets U 1 ; : : : ; U m such that the sum of the sizes of the items in each u j is B or less." (For notational convenience, we use m for the number of bins; k is used in <ref> [24] </ref>.) 5.3.2 A Finite-Difference Algorithm Define a feasible packing for a multiset of items to be a sequence of m sequences of items with the following properties: 1. The items in the sequences of items form the multiset. 2.
Reference: [25] <author> H. W. Kuhn, </author> <title> The Hungarian method for the assignment problem, </title> <journal> Naval Res. Logist. Quart., </journal> <volume> 2 (1955) 83-97. </volume> <pages> 112 </pages>
Reference-contexts: In this case, the existence problem is NP-complete [23, 13], and the counting problem is #P-complete [33]. In the case of the permanent, the existence problem determining whether a bipartite graph has a complete matching is in P <ref> [25, 10] </ref>. However, 35 the counting problem is #P-complete. Ryser made progress on computing the permanent by developing an inclusion and exclusion algorithm [29]. The algorithms presented here are a generalization of that inclusion and exclusion algorithm.
Reference: [26] <author> J. H. van Lint and R. M. Wilson, </author> <title> A Course in Combinatorics, </title> <publisher> Cambridge University Press 1992. </publisher>
Reference-contexts: The free parameters of finite-difference formulas can be chosen to produce algorithms that are faster than their inclusion and exclusion counterparts. In combinatorics, generating functions are used to count the structures in a fixed superstructure [34] or to solve a recursion <ref> [26] </ref>. For these applications, a fixed generating function is produced, and the desired coefficients are deduced through analysis. In this work, a class of generating functions is developed for each problem.
Reference: [27] <author> N. Linial and N. Nisan, </author> <title> Approximate inclusion-exclusion, </title> <journal> Combinatorica, </journal> <note> 10 (4) (1990) 349-365. </note>
Reference-contexts: There, it is shown that unless NP=P, the permanent of a matrix with entries in f1; 0; 1g and with a positive permanent cannot be accurately approximated by any polynomial time procedure. A paper by Linial and Nisan <ref> [27] </ref> contains some results on approximating the size of a union of sets by the sum over a subset of the terms in the inclusion and exclusion formula.
Reference: [28] <author> R. Motwani and P. Raghavan, </author> <title> Randomized Algorithms, </title> <publisher> Cambridge University Press 1995, </publisher> <pages> pp. 315-329. </pages>
Reference-contexts: 95 then B x 0 ;S = 2 n p2R X j 8j62S and x j 2f1;1g 8j2S p 1 +1 n (9.99) since the generating function terms indexed by P R are zeroed. 9.4 Discussion Recently, several algorithms have been developed to estimate the permanent of a 0-1 matrix <ref> [20, 21, 22, 28] </ref>. <p> More recently, Jerrum and Vazirani [21] have developed an approximation algorithm with time complexity O (poly (ffi; *; n)2 p n log 2 n ). Furthermore, there are polynomial time algorithms for several restricted classes of 0-1 matrices. For more information, see <ref> [28] </ref>, Ch. 11. The approximation methods developed in this chapter do not fit into the FPRAS framework. There are no guarantees regarding the ratio of our estimators to the permanent, for reasons involving algorithm design and theory. <p> This is considered unlikely. Unless it is true, there is no FPRAS for a counting problem that corresponds to an NP-complete existence problem. This argument is adapted from <ref> [28] </ref>, Ch. 11. For even stronger results on the difficulty of approximating some specific problems, refer to the paper by Zuckerman [35].
Reference: [29] <author> H. J. Ryser, </author> <title> Combinatorial Mathematics, </title> <booktitle> The Mathematical Association of America 1963, Ch. </booktitle> <pages> 2. </pages>
Reference-contexts: Let W S be the set of walks that lack all vertices in S f1; : : : ; ng. The number of Hamiltonian paths is jU (W f1g [ : : : [ W fng )j (1.8) By the principle of inclusion and exclusion <ref> [29] </ref>, this is equal to jU j fj 1 gf1;:::;ng X jW fj 1 g " W fj 2 g j : : : jW f1g " : : : W fng j (1.9) Note that W fj 1 g " : : : " W fj k g = W <p> In the case of the permanent, the existence problem determining whether a bipartite graph has a complete matching is in P [25, 10]. However, 35 the counting problem is #P-complete. Ryser made progress on computing the permanent by developing an inclusion and exclusion algorithm <ref> [29] </ref>. The algorithms presented here are a generalization of that inclusion and exclusion algorithm. <p> The formulas can be computed by evaluating P (x) for each of the 2 n assignments to x. This requires O (2 n poly n) time and O (poly n) space. (The inclusion and exclusion formula by Ryser <ref> [29] </ref> is the finite-difference formula with u j = 1 and v j = 0 for all j.) 6.2 Zero-Valued Terms We develop computational reductions by selecting finite-difference parameters that induce many zero-valued terms in formula (6.6). <p> 1 per A Y (A; *) (1 + *) per Ag 1 ffi (9.101) The algorithm has time complexity O (poly (ffi; *; n)2 n 2 ), which is about the square root of the O (n 2 2 n ) time required to compute the permanent using Ryser's algorithm <ref> [29] </ref>. More recently, Jerrum and Vazirani [21] have developed an approximation algorithm with time complexity O (poly (ffi; *; n)2 p n log 2 n ). Furthermore, there are polynomial time algorithms for several restricted classes of 0-1 matrices. For more information, see [28], Ch. 11.
Reference: [30] <author> A. Sinclair, </author> <title> Algorithms for Random Generation and Counting: A Markov Chain Approach, </title> <publisher> Birkhauser, </publisher> <address> Boston 1993. </address>
Reference-contexts: Alternatively, if the matrix is the adjacency matrix of a directed graph, then the permanent is the number of directed cycle sets in which each vertex is on one cycle. The permanent problem has applications to statistical physics, including problems involving monomer-dimer systems. For more information, see <ref> [30] </ref>. Computing the permanent is a #P-complete problem [32]. #P problems are the counting problems associated with NP problems [32, 13]. For example, determining whether or not a graph has a Hamiltonian cycle is an NP problem, so counting the Hamiltonian cycles is a #P problem.
Reference: [31] <author> R. Tarjan, </author> <title> Enumeration of the elementary circuits of a directed graph, </title> <note> SIAM J. Com-put., 2 (3) (1973) 211-216. </note>
Reference-contexts: The material in this chapter was originally published as a paper in Information Processing Letters [6]. For an algorithm that counts paths or cycles of all lengths, see [3]. For an algorithm to list all cycles, see <ref> [31] </ref>. 3.1 Paths Let G be a directed graph with vertex set V = fs; tg [ f1; : : : ; ng.
Reference: [32] <author> L. G. Valiant, </author> <title> The complexity of computing the permanent, </title> <journal> Theoretical Computer Science, </journal> <volume> 8(1979) </volume> <pages> 189-201. </pages>
Reference-contexts: The permanent problem has applications to statistical physics, including problems involving monomer-dimer systems. For more information, see [30]. Computing the permanent is a #P-complete problem <ref> [32] </ref>. #P problems are the counting problems associated with NP problems [32, 13]. For example, determining whether or not a graph has a Hamiltonian cycle is an NP problem, so counting the Hamiltonian cycles is a #P problem. <p> The permanent problem has applications to statistical physics, including problems involving monomer-dimer systems. For more information, see [30]. Computing the permanent is a #P-complete problem [32]. #P problems are the counting problems associated with NP problems <ref> [32, 13] </ref>. For example, determining whether or not a graph has a Hamiltonian cycle is an NP problem, so counting the Hamiltonian cycles is a #P problem. In this case, the existence problem is NP-complete [23, 13], and the counting problem is #P-complete [33].
Reference: [33] <author> L. G. Valiant, </author> <title> The complexity of enumeration and reliability problems, </title> <note> SIAM J. Com-put., 8 (3) (1979) 410-421. </note>
Reference-contexts: For example, determining whether or not a graph has a Hamiltonian cycle is an NP problem, so counting the Hamiltonian cycles is a #P problem. In this case, the existence problem is NP-complete [23, 13], and the counting problem is #P-complete <ref> [33] </ref>. In the case of the permanent, the existence problem determining whether a bipartite graph has a complete matching is in P [25, 10]. However, 35 the counting problem is #P-complete. Ryser made progress on computing the permanent by developing an inclusion and exclusion algorithm [29].
Reference: [34] <author> H. Wilf, </author> <title> Generating Functionology, </title> <publisher> Academic Press, </publisher> <address> Boston 1994. </address>
Reference-contexts: Finite-difference algorithms are a generalization of inclusion and exclusion algorithms. The free parameters of finite-difference formulas can be chosen to produce algorithms that are faster than their inclusion and exclusion counterparts. In combinatorics, generating functions are used to count the structures in a fixed superstructure <ref> [34] </ref> or to solve a recursion [26]. For these applications, a fixed generating function is produced, and the desired coefficients are deduced through analysis. In this work, a class of generating functions is developed for each problem.
Reference: [35] <author> D. Zuckerman, </author> <title> On unapproximable versions of NP-complete problems, </title> <note> SIAM J. Com-put., 25 (6) (1996) 1293-1304. </note>
Reference-contexts: This is considered unlikely. Unless it is true, there is no FPRAS for a counting problem that corresponds to an NP-complete existence problem. This argument is adapted from [28], Ch. 11. For even stronger results on the difficulty of approximating some specific problems, refer to the paper by Zuckerman <ref> [35] </ref>. There, it is shown that unless NP=P, the permanent of a matrix with entries in f1; 0; 1g and with a positive permanent cannot be accurately approximated by any polynomial time procedure.
References-found: 35

