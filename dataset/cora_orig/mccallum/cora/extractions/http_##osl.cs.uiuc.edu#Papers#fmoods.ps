URL: http://osl.cs.uiuc.edu/Papers/fmoods.ps
Refering-URL: http://osl.cs.uiuc.edu/Papers/Overview.html
Root-URL: http://www.cs.uiuc.edu
Title: Abstracting Interaction Patterns: A Programming Paradigm for Open Distributed Systems Formal Methods for Open Object-based
Author: Gul A. Agha 
Keyword: Actors, concurrency, object-oriented programming, open systems, real-time systems, fault-tolerance, coordination, reflection.  
Note: To Appear:  IFIP Transactions, E. Najm and J.-B. Stefani, Editors Chapman Hall,  
Address: 1304 W. Springfield Avenue, University  Urbana, IL 61801, USA,  
Affiliation: Open Systems Laboratory Department of Computer Science,  of Illinois at Urbana-Champaign,  
Email: Email: agha@cs.uiuc.edu,  
Web: Web: http://www-osl.cs.uiuc.edu  
Date: 1997  
Abstract: This paper discusses mechanisms addressing the complexity of building and maintaining Open Distributed Systems. It is argued that a new programming paradigm based on modular specification of interaction patterns is required to address the complexity of such systems. Our research is based on developing abstraction mechanisms to simplify the task of developing and maintaining open systems. We define actors as a model of concurrency for open systems. We then review a number of programming abstractions that are useful in modular specification and implementation of open systems. Such abstractions include activators, protocols, synchronizers, and actorspaces. We observe that defining such abstractions for complex interaction patterns requires a sort of system decomposition that is not supported by standard execution models of concurrent programming, including actors and process algebras. Rather, a suitable meta-architecture is needed to allow the implementation of abstract representations of interaction patterns. Currently there is no entirely satisfactory formal theory of meta-architectures. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Agha, G. </author> <year> (1986). </year> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass. </address> <note> Conclusions 17 Agha, </note> <author> G. </author> <year> (1990). </year> <title> Concurrent Object-Oriented Programming. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 125-141. </pages>
Reference-contexts: Actors 3 ' $ ods which operate on the state. 2 ACTORS The Actor model provides a flexible method for representing computation in real-world systems. Actors extend the concept of objects to concurrent computation <ref> (Agha, 1986) </ref>. Recall that objects encapsulate a state and a set of procedures that manipulate the state; actors extend this by also encapsulating a thread of control. Each actor potentially executes in parallel with other actors and may send messages to actors it knows the addresses of.
Reference: <author> Agha, G., Mason, I. A., Smith, S. F., and Talcott, C. L. </author> <year> (1996). </year> <title> A foundation for actor computation. </title> <journal> Journal of Functional Programming. </journal> <note> to appear. </note>
Reference-contexts: Actor addresses may be communicated in messages, allowing dynamic interconnection. Finally, new actors may be created; such actors have their own unique addresses. It is possible to extend any sequential language with the actor constructs. For example, the call-by-value -calculus is extended in <ref> (Agha et al., 1996) </ref>. <p> Based on a slight variant of the transition system described above, a rigorous theory of actor systems is developed in <ref> (Agha et al., 1996) </ref>. Specifically, we define and study various notions of testing equivalence on actor expressions and configurations. The model we have developed provides fairness, namely that any enabled transition eventually fires. Fairness is an important requirement for reasoning about eventuality properties. <p> In a high level actor language, a new programming abstraction must be introduced to allow an abstract specification of a behavior that is activated by a set of messages rather than a single message. In <ref> (Frtlund and Agha, 1996) </ref>, we define such an abstraction, called activators, which allows specification of both input synchronization and reply synchronization; reply synchronization generalizes rpc-like communication to support the concurrent invocation of a group of actors. <p> We have shown how an operational semantics of a simple actor language which has been extended to allow timing constraints on messages, may be translated into an underlying real-time formalism, namely, timed graphs. The net result is to provide the real-time semantics of an actor language <ref> (Nielsen and Agha, 1996) </ref>. Moreover, the semantics Naming and Groups 15 ' $ bership may dynamically change. provides a loose specification of programs, rather than a semantics of actual implementations. <p> K. Shyamasun-dar, Daniel Sturman, Takuo Watanabe, and Nalini Venkatasubramanian. I have also particularly benefited from discussions with Ian Mason, Scott Smith and Carolyn Talcott. This paper extends and incorporates <ref> (Agha, 1996) </ref>. The research described has been supported in part by the Office of Naval Research (ONR contract numbers N00014-90-J-1899 and N00014-93-1-0273), the Digital Equipment Corporation, Hitachi, and the National Science Foundation (NSF CCR 93-12495).
Reference: <author> Agha, G. A. </author> <year> (1996). </year> <title> Modeling concurrent systems: Actors, nets, and the problem of abstraction and composition. </title> <editor> In Billington, J. and Reisig, W., editors, </editor> <booktitle> Applications and Theory of Petri Nets 1996, </booktitle> <volume> LNCS 1091, </volume> <pages> pages 1-10, </pages> <address> Osaka, Japan. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Actor addresses may be communicated in messages, allowing dynamic interconnection. Finally, new actors may be created; such actors have their own unique addresses. It is possible to extend any sequential language with the actor constructs. For example, the call-by-value -calculus is extended in <ref> (Agha et al., 1996) </ref>. <p> Based on a slight variant of the transition system described above, a rigorous theory of actor systems is developed in <ref> (Agha et al., 1996) </ref>. Specifically, we define and study various notions of testing equivalence on actor expressions and configurations. The model we have developed provides fairness, namely that any enabled transition eventually fires. Fairness is an important requirement for reasoning about eventuality properties. <p> In a high level actor language, a new programming abstraction must be introduced to allow an abstract specification of a behavior that is activated by a set of messages rather than a single message. In <ref> (Frtlund and Agha, 1996) </ref>, we define such an abstraction, called activators, which allows specification of both input synchronization and reply synchronization; reply synchronization generalizes rpc-like communication to support the concurrent invocation of a group of actors. <p> We have shown how an operational semantics of a simple actor language which has been extended to allow timing constraints on messages, may be translated into an underlying real-time formalism, namely, timed graphs. The net result is to provide the real-time semantics of an actor language <ref> (Nielsen and Agha, 1996) </ref>. Moreover, the semantics Naming and Groups 15 ' $ bership may dynamically change. provides a loose specification of programs, rather than a semantics of actual implementations. <p> K. Shyamasun-dar, Daniel Sturman, Takuo Watanabe, and Nalini Venkatasubramanian. I have also particularly benefited from discussions with Ian Mason, Scott Smith and Carolyn Talcott. This paper extends and incorporates <ref> (Agha, 1996) </ref>. The research described has been supported in part by the Office of Naval Research (ONR contract numbers N00014-90-J-1899 and N00014-93-1-0273), the Digital Equipment Corporation, Hitachi, and the National Science Foundation (NSF CCR 93-12495).
Reference: <author> Aksit, M., Wakita, K., Bosch, J., Bergmans, L., and Yonezawa, A. </author> <year> (1993). </year> <title> Abstracting object interactions using composition filters. </title> <editor> In Guerraoui, R., Nierstrasz, O., and Riveill, M., editors, </editor> <booktitle> Object-Based Distributed Programming, volume 791 of Lecture Notes in Computer Science, </booktitle> <pages> pages 152-184. </pages> <publisher> ECOOP, Springer-Verlag. </publisher>
Reference-contexts: Each role (e.g. right figure) defines protocol specific methods and events which the role implements. An event is a meta-level customization of a particular operation done by the runtime system for the actor assuming the given role. much like the concept of filters <ref> (Aksit et al., 1993) </ref>. A description of the implementation and semantics of protocols, including details about these examples, may be found in (Sturman, 1996). Notice that the behavior of an actor system in the presence of protocols may be quite different from its behavior otherwise.
Reference: <author> Callsen, C. J. and Agha, G. A. </author> <year> (1994). </year> <title> Open Heterogeneous Computing in ActorSpace. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <pages> pages 289-300. </pages>
Reference-contexts: The Actorspace model allows an abstract specification of a group of actors <ref> (Callsen and Agha, 1994) </ref>. An actorspace associates an actor with specific attributes; the sender of a message specifies a destination pattern which is pattern matched against the attributes of actors in the actorspace. A simple analogy with set theory illustrates the difference between naming in actors and ac-torspaces.
Reference: <author> Frtlund, S. </author> <year> (1992). </year> <title> Inheritance of synchronization constraints in concurrent object-oriented programming languages. </title> <editor> In Madsen, O. L., editor, </editor> <booktitle> Proceedings ECOOP '92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 185-196, </pages> <address> Utrecht, The Netherlands. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This solution is generally undesirable: it wastes net bandwidth and complicates programming. Instead, we would like the request from the consumer to be locally buffered until the buffer is ready to process get requests (see figure 4. The figure is from <ref> (Frtlund, 1992) </ref>). A local synchronization constraint is a programming construct which allows a declarative expression of a complex sequence of actions involving testing and storing messages.
Reference: <author> Frtlund, S. </author> <year> (1996). </year> <title> Coordinating Distributed Objects: An Actor-Based Approach to Synchronization. </title> <publisher> MIT Press. </publisher>
Reference-contexts: In a high level actor language, a new programming abstraction must be introduced to allow an abstract specification of a behavior that is activated by a set of messages rather than a single message. In <ref> (Frtlund and Agha, 1996) </ref>, we define such an abstraction, called activators, which allows specification of both input synchronization and reply synchronization; reply synchronization generalizes rpc-like communication to support the concurrent invocation of a group of actors. <p> A given implementation of synchronizers may satisfy this consistency requirement through different possible concurrency control mechanisms. Besides the need for concurrency control, the fact that synchronizers may be superimposed, and may be dynamically added or removed, means that implementing a system to support synchronizers is fairly challenging. See <ref> (Frtlund, 1996) </ref> for a discussion of one strategy for their efficient implementation. <p> Observe that synchronizers do not add to the set of possible observable events in an actor system; they merely rule out certain interleavings of events. A transition system for actors in the presence of synchronizers is also defined in <ref> (Frtlund, 1996) </ref>. The essential idea is to add a set of synchronizers, , to configurations. A function C map maps to a function that takes a multiset of message target pairs to a boolean value.
Reference: <author> Frtlund, S. and Agha, G. </author> <year> (1993). </year> <title> A language framework for multi-object coordination. </title> <booktitle> In Proceedings of ECOOP 1993, volume 707 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: By providing a language abstraction, called a synchronizer , to express these two types of coordination constraints, we are able to show that the task of distributed programming may be further simplified <ref> (Frtlund and Agha, 1993) </ref>. A synchronizer may observe messages flowing through to a group of actors; it has a local state which may change as a result of these observations.
Reference: <author> Frtlund, S. and Agha, G. </author> <year> (1996). </year> <title> Abstracting interactions based on message sets. </title> <booktitle> In Object-Based Models and Languages for Concurrent Systems, </booktitle> <volume> volume 924, </volume> <pages> pages 107-124. </pages> <note> Springer-Verlag. Lecture Notes in Computer Science. </note>
Reference-contexts: In a high level actor language, a new programming abstraction must be introduced to allow an abstract specification of a behavior that is activated by a set of messages rather than a single message. In <ref> (Frtlund and Agha, 1996) </ref>, we define such an abstraction, called activators, which allows specification of both input synchronization and reply synchronization; reply synchronization generalizes rpc-like communication to support the concurrent invocation of a group of actors. <p> A given implementation of synchronizers may satisfy this consistency requirement through different possible concurrency control mechanisms. Besides the need for concurrency control, the fact that synchronizers may be superimposed, and may be dynamically added or removed, means that implementing a system to support synchronizers is fairly challenging. See <ref> (Frtlund, 1996) </ref> for a discussion of one strategy for their efficient implementation. <p> Observe that synchronizers do not add to the set of possible observable events in an actor system; they merely rule out certain interleavings of events. A transition system for actors in the presence of synchronizers is also defined in <ref> (Frtlund, 1996) </ref>. The essential idea is to add a set of synchronizers, , to configurations. A function C map maps to a function that takes a multiset of message target pairs to a boolean value.
Reference: <author> Kim, W. and Agha, G. </author> <year> (1995). </year> <title> Efficient Support of Location Transparency in Concurrent Object-Oriented Programming Languages. </title> <booktitle> In Supercomputing '95. IEEE. </booktitle>
Reference-contexts: An actor runtime system provides the interface to services such as global addressing, memory management, fair scheduling, and communication. It turns out that these services can be efficiently implemented, thus raising the level of abstraction while reducing the size and complexity of code on concurrent architectures <ref> (Kim and Agha, 1995) </ref>. Note that the Actor model is, like the theory of higher order nets or the -calculus, general and inherently parallel.
Reference: <author> Nielsen, B. and Agha, G. </author> <year> (1996). </year> <title> Semantics for an actor-based real-time language. </title> <booktitle> In Fourth International Workshop on Parallel and Distributed Real-Time Systems, </booktitle> <address> Honolulu. </address> <note> (to be published). </note>
Reference-contexts: We have shown how an operational semantics of a simple actor language which has been extended to allow timing constraints on messages, may be translated into an underlying real-time formalism, namely, timed graphs. The net result is to provide the real-time semantics of an actor language <ref> (Nielsen and Agha, 1996) </ref>. Moreover, the semantics Naming and Groups 15 ' $ bership may dynamically change. provides a loose specification of programs, rather than a semantics of actual implementations.
Reference: <author> Plotkin, G. </author> <year> (1975). </year> <title> Call-by-name, call-by-value and the lambda calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159. </pages>
Reference-contexts: The notion of equivalence is defined by adding an observable distinguished event to the set of transitions. This technique is a variant of operational equivalence defined in <ref> (Plotkin, 1975) </ref>. Two actor expressions may be plugged into a context to see if the event occurs in one or the other case. Two expressions are considered equivalent if they have the same observations over all possible contexts.
Reference: <author> Ren, S., Agha, G., and Saito, M. </author> <year> (1996). </year> <title> A modular approach for programming distributed real-time systems. </title> <journal> Journal of Parallel and Distributed Computing. </journal> <note> (to appear). </note>
Reference-contexts: In contrast to conventional real-time language constructs, which express timing requirements on actions within an object, we think of timing requirements as constraints relative to message execution rather than as constraints internal to actors <ref> (Ren et al., 1996) </ref>. Because real-time constraints are separately specified, using generic software in real-time systems becomes feasible (see Figure 11). Semantics for concurrent programming languages usually focus on qualitative aspects, which is insufficient for real-time programming languages.
Reference: <author> Sami, Y. </author> <title> and Vidal-Naquet (1991). Formalization of the behavior of actors by colored petri nets and some applications. </title> <booktitle> In Conference on Parallel Architectures and Languages Europe, PARLE'91. </booktitle>
Reference-contexts: It is also possible to model a system of actors by means of a higher order net and vice versa <ref> (Sami and Vidal-Naquet, 1991) </ref>, although such a model does not satisfactorily account for the open systems aspects of actors. 3 LOCAL SYNCHRONIZATION CONSTRAINTS Consider a system of actors consisting of producers and consumers. A producer puts elements in a buffer and a consumer consumes them.
Reference: <author> Sturman, D. and Agha, G. </author> <year> (1994). </year> <title> A protocol description language for customizing failure semantics. </title> <booktitle> In The 13th Symposium on Reliable Distributed Systems, Dana Point, </booktitle> <address> California. </address> <publisher> IEEE. </publisher>
Reference-contexts: Interactions between these actors are mediated by a protocol which ensures the correct behavior of the protocol. 6 PROTOCOLS We have developed a programming language which allows protocols to be specified and linked to actors written in conventional actor languages <ref> (Sturman and Agha, 1994) </ref>. In our language, a protocol abstraction, such as one for the two phase commit protocol, may be defined. The abstraction may be instantiated by specifying a particular group of actors and other initialization parameters.

References-found: 15

