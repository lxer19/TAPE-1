URL: ftp://ftp.cs.arizona.edu/reports/1998/TR98-07.ps
Refering-URL: http://www.cs.arizona.edu/research/reports.html
Root-URL: http://www.cs.arizona.edu
Title: Efficient Storage and Indexing for Data Warehouses  
Author: Anindya Datta Bongki Moon Krithi Ramamritham Helen Thomas Igor Viguier 
Address: Tucson, AZ 85721  Atlanta, GA 30332  Tucson, AZ 85721  Amherst, MA 01003  
Affiliation: Department of Computer Science The University of Arizona  Georgia Institute of Technology, College of Computing,  University of Arizona, Department of Computer Science,  University of Massachusetts, Department of Computer Science,  
Date: 98-7 August, 1998  
Pubnum: Technical Report  
Abstract: Submitted to ACM Transactions on Database Systems, August, 1998. If accepted, copyright will transfer to ACM. Available at http://www.cs.arizona.edu/research/reports.html. "Have your Data and Index it, too" Abstract Two possible strategies may be utilized to enhance the efficiency of processing OLAP queries: (a) precomputation strategies (e.g., view materialization, realizing data cubes), and (b) ad-hoc strategies. While a significant amount of work has been done in developing precomputation strategies, it is generally recognized that it is difficult to materialize the answers to all possible queries. Thus, ad-hoc querying must be supported in data warehouses. This realization has sparked an interest in exploring indexing strategies suitable for OLAP queries. There appears to have been relatively little work done in ad-hoc query support for data warehouses [45, 46, 55, 39]. In this paper we propose DataIndexes as a new paradigm for storing the base data. An attractive feature of DataIndexes is that they serve as indexes as well as the store of base data. Thus, DataIndexes actually define a physical design strategy for a data warehouse where the indexing, for all intents and purposes, comes for "free". We also present two efficient algorithms for performing star-joins with DataIndexes. In addition, we present a mathematical analysis of all the indexes presented by O'Neil and Quass as well as our DataIndexes and present analytical expressions categorizing the cost of query evaluation using these structures for range selections and star-joins, two common classes of queries in OLAP. These aid in performing an analysis yielding precise "break-even" points for comparing these indexing alternatives. Overall, it turns out that DataIndexes are very attractive in a wide variety of cases in terms of enhancing the performance of range and star-join queries in data warehouses. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Adelberg, H. Garcia-Molina, and J. Widom. </author> <title> The STRIP rule system for efficiently maintaining derived data. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 147-158, </pages> <address> Tucson, AZ, </address> <month> May 13-15 </month> <year> 1997. </year>
Reference: [2] <author> S. Agarwal, R. Agrawal, P.M. Deshpande, A. Gupta, J.F. Naughton, R. Ramakrishnan, and S. Sarawagi. </author> <title> On the computation of multidimensional aggregates. </title> <booktitle> In Proc. 22nd VLDB Conf., </booktitle> <address> Mumbai, India, </address> <year> 1996. </year>
Reference-contexts: Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation [10, 23, 33, 30, 50, 68, 69], join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including <ref> [2, 17, 23, 42, 53, 58] </ref>. Yet another facet of query processing that has received attention in the literature is that of efficiency. Fast query evaluation is critical in OLAP environments given the interactive nature of most OLAP sessions. There are two basic approaches for quickly evaluating OLAP queries: 1.
Reference: [3] <author> R. Armstrong. </author> <title> Data warehousing: Dealing with the growing pains. </title> <booktitle> In Proc. Thirteenth Intl. Conf. on Data Engineering, </booktitle> <pages> pages 199-205, </pages> <address> Birmingham, UK, </address> <month> April 7-11 </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: It is recognized however, that such anticipation only works up to a point [11, 46], and a considerable fraction of the workload in OLAP applications will consist of ad-hoc queries which will need to be computed on demand <ref> [3] </ref>. This has led to work on strategies for ad-hoc query processing. 2. Ad-hoc Strategies. This approach to fast OLAP query processing supports ad-hoc querying by using fast 2 access structures on the base data. Database systems use indexes to improve efficiency of access to data.
Reference: [4] <author> M.W. Blasgen and K.P. Eswaran. </author> <title> On the evaluation of queries in a database system. </title> <type> Technical Report RJ-1745, </type> <institution> IBM Corp., </institution> <address> San Jose, CA, </address> <month> April </month> <year> 1976. </year>
Reference-contexts: A join operation could thus be performed by examining each one of these entries in turn. This approach should be significantly faster than with conventional join algorithms, which typically perform joins between two or more tables in a pairwise fashion. Such algorithms include nested-loop joins, merge joins <ref> [4] </ref>, hash-joins [5], or any derivative of these techniques [38, 56] (see [21] for a survey). In fact, the exact number of block accesses needed to scan a JDI is simply the number of data blocks occupied by this structure.
Reference: [5] <author> K. Bratbergsengen. </author> <title> Hashing methods and relational algebra operations. </title> <booktitle> In Proc. 10th VLDB, </booktitle> <address> Singapore, </address> <month> August </month> <year> 1984. </year>
Reference-contexts: A join operation could thus be performed by examining each one of these entries in turn. This approach should be significantly faster than with conventional join algorithms, which typically perform joins between two or more tables in a pairwise fashion. Such algorithms include nested-loop joins, merge joins [4], hash-joins <ref> [5] </ref>, or any derivative of these techniques [38, 56] (see [21] for a survey). In fact, the exact number of block accesses needed to scan a JDI is simply the number of data blocks occupied by this structure.
Reference: [6] <author> M.J. Carey and D. Kossman. </author> <title> On saying "enough already" in SQL. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 219-230, </pages> <address> Tucson, AZ, </address> <month> May 13-15 </month> <year> 1997. </year>
Reference-contexts: Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation [10, 23, 33, 30, 50, 68, 69], join or range queries [32, 60, 64], or supporting incomplete query answers <ref> [6, 29, 66] </ref>. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58]. Yet another facet of query processing that has received attention in the literature is that of efficiency.
Reference: [7] <author> C.Y. Chan and Y. Ioannidis. </author> <title> Bitmap index design and evaluation. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 355-366, </pages> <address> Seattle, WA, </address> <month> June 1-4 </month> <year> 1998. </year>
Reference-contexts: In addition to projection indexes [46] and bitmapped join indexes [45] mentioned already, such 9 index structures include bitmapped indexes [44], bit-sliced indexes [46]. Wu and Buchmann [67] presented an efficient encoding scheme for reducing the size of bitmapped indexes, and Chan and Ioannidis <ref> [7] </ref> proposed a framework for the design and evaluation of bitmap indexing schemes. An analysis of three index structures along with B + -trees is presented in [46], which indicates that these four structures are particularly appropriate for warehousing/OLAP environments.
Reference: [8] <author> D. Chatziantoniou and K.A. Ross. </author> <title> Querying multiple features of groups in relational databases. </title> <booktitle> In Proc. 22nd VLDB Conf., </booktitle> <address> Mumbai, India, </address> <year> 1996. </year> <month> 35 </month>
Reference-contexts: This area is starting to receive the attention it deserves. A number of "conventional" relational query processing approaches have been applied to or extended for answering OLAP queries. Some of this work has concentrated on efficiently performing GROUP BY <ref> [8, 9, 20] </ref>, aggregation [10, 23, 33, 30, 50, 68, 69], join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58].
Reference: [9] <author> S. Chaudhuri and K. Shim. </author> <title> Including group-by in query optimization. </title> <booktitle> In Proc. 20th Intl. Conf. on Very Large Databases, </booktitle> <pages> pages 131-139, </pages> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: This area is starting to receive the attention it deserves. A number of "conventional" relational query processing approaches have been applied to or extended for answering OLAP queries. Some of this work has concentrated on efficiently performing GROUP BY <ref> [8, 9, 20] </ref>, aggregation [10, 23, 33, 30, 50, 68, 69], join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58].
Reference: [10] <author> S. Chaudhuri and K. Shim. </author> <title> Optimizing queries with aggregate views. </title> <editor> In P. Apers, M. Bouzeghoub, and G. Gardaring, editors, </editor> <booktitle> Advances in Database Technology - EDBT'96 5th Intl. Conf. on Extending Database Technology, volume 1057 of Lecture Notes in Computer Science, </booktitle> <pages> pages 167-182. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1996. </year>
Reference-contexts: This area is starting to receive the attention it deserves. A number of "conventional" relational query processing approaches have been applied to or extended for answering OLAP queries. Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation <ref> [10, 23, 33, 30, 50, 68, 69] </ref>, join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58].
Reference: [11] <author> S. Chauduri and U. Dayal. </author> <title> An overview of data warehousing and OLAP technology. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 26(1) </volume> <pages> 65-74, </pages> <month> March </month> <year> 1997. </year>
Reference-contexts: Data warehousing refers to "a collection of decision support technologies aimed at enabling the knowledge worker (executive, manager, analyst) to make better and faster decisions" <ref> [11] </ref>. Thus, loosely speaking, a data warehouse is a "very large" repository of historical data pertaining to an organization [35]. OLAP refers to the technique of performing complex analysis over the information stored in a data warehouse [13]. <p> The significance of data warehousing is evidenced by the recent growth in the number of related products and services offered - the market for data warehousing, including hardware, database software, and tools, is projected to be $8 billion in 1998, up from $2 billion in 1995 <ref> [11] </ref>. These technologies are gaining widespread acceptance in a multitude of industries including retail sales (supermarkets, department stores, etc), telecommunications, and financial services. Data warehousing/OLAP systems are best understood by comparing them to traditional On-Line Transaction Processing (OLTP) systems. <p> In contrast to OLTP systems, data warehouses are designed for decision support purposes and contain long periods of historical data. For this reason, data warehouses tend to be extremely large it is not uncommon for a data warehouse to be hundreds of gigabytes to terabytes in size <ref> [11] </ref>. OLAP applications are characterized by the rendering of enterprise data into multidimensional perspectives, which is achieved through complex, ad-hoc queries that frequently aggregate and consolidate data, often using statistical formulae [13]. Thus, OLAP environments are query intensive, where aggregated and summarized data are much more important than detailed records. <p> Fast query evaluation is critical in OLAP environments given the interactive nature of most OLAP sessions. There are two basic approaches for quickly evaluating OLAP queries: 1. Precomputation Strategies. This approach relies on summary tables, derived tables that house precomputed or "ready-made" answers to queries <ref> [11] </ref>. This has been, by far, the most explored area in the context of data warehouses [1, 14, 22, 24, 25, 26, 28, 40, 41, 48, 49, 70]. <p> The basic premise underlying this work is that data warehouses can achieve faster response times by pre-aggregating (i.e., materializing) the answers to frequently asked queries. It is recognized however, that such anticipation only works up to a point <ref> [11, 46] </ref>, and a considerable fraction of the workload in OLAP applications will consist of ad-hoc queries which will need to be computed on demand [3]. This has led to work on strategies for ad-hoc query processing. 2. Ad-hoc Strategies. <p> In decision support environments, many queries access significant portions of the underlying database <ref> [11] </ref>. In addition, many operations on bitmaps are much faster than on RID lists [46]. For these reasons, in the remainder of this paper we assume that the rowsets used in evaluating a selection predicate are implemented as bit vectors.
Reference: [12] <author> J-H. Chu and G. Knott. </author> <title> An analysis of B-trees and their variants. </title> <journal> Information Systems, </journal> <volume> 14(5), </volume> <year> 1989. </year>
Reference-contexts: Database systems use indexes to improve efficiency of access to data. Various general purpose indexing techniques have been proposed and are utilized in OLTP systems, including hashing [54], B trees <ref> [12, 15] </ref>, and multidimensional trees such as the R-tree [27], the K-D-B tree [52], and the BV tree [18]. There exists another class of multidimensional structures, namely grid files [43], that allows for very fast access to multidimensional data.
Reference: [13] <author> E.F. Codd, </author> <title> S.B. Codd, and C.T. Salley. Providing OLAP (on-line analitycal processing) to user-analysts: An IT mandate. </title> <type> Technical report, </type> <institution> E.F. Codd & Associates, </institution> <year> 1993. </year>
Reference-contexts: Thus, loosely speaking, a data warehouse is a "very large" repository of historical data pertaining to an organization [35]. OLAP refers to the technique of performing complex analysis over the information stored in a data warehouse <ref> [13] </ref>. The significance of data warehousing is evidenced by the recent growth in the number of related products and services offered - the market for data warehousing, including hardware, database software, and tools, is projected to be $8 billion in 1998, up from $2 billion in 1995 [11]. <p> OLAP applications are characterized by the rendering of enterprise data into multidimensional perspectives, which is achieved through complex, ad-hoc queries that frequently aggregate and consolidate data, often using statistical formulae <ref> [13] </ref>. Thus, OLAP environments are query intensive, where aggregated and summarized data are much more important than detailed records. Typical OLAP queries require computationally expensive operations such as joins and aggregation.
Reference: [14] <author> L. Colby, T. Griffin, L. Libkin, I. Mumick, and H. Trickey. </author> <title> Algorithms for deferred view maintenance. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <address> Montreal, Quebec, Canada, </address> <month> June </month> <year> 1996. </year>
Reference: [15] <author> D. Comer. </author> <title> The ubiquitous B-tree. </title> <journal> ACM Computing Surveys, </journal> <volume> 11(2) </volume> <pages> 121-138, </pages> <month> June </month> <year> 1979. </year>
Reference-contexts: Database systems use indexes to improve efficiency of access to data. Various general purpose indexing techniques have been proposed and are utilized in OLTP systems, including hashing [54], B trees <ref> [12, 15] </ref>, and multidimensional trees such as the R-tree [27], the K-D-B tree [52], and the BV tree [18]. There exists another class of multidimensional structures, namely grid files [43], that allows for very fast access to multidimensional data. <p> We have selected four popular index structures for data warehousing : B-trees <ref> [15] </ref>, bitmapped indexes [44, 47], bit-sliced indexes [46, 34], and projection indexes [46, 61]. It is assumed that only the PartKey, SuppKey, CustKey, ShipDate, CommitDate and ReceiptDate columns of the SALES table are indexed.
Reference: [16] <author> G.P. Copeland and S. Khoshafian. </author> <title> A decomposition storage model. </title> <booktitle> In Proc. ACM SIGMOD, </booktitle> <pages> pages 268-279, </pages> <year> 1985. </year>
Reference-contexts: This RID can be expressed as b DT S = j (R) , and the slot number as s R = mod (R). It is the ordinal mapping that makes this basic approach more efficient than existing vertical partitioning methods such as the Decomposition Storage Model (DSM) <ref> [16, 36, 63] </ref>. Indeed, DSM utilizes surrogate keys to map individual attributes together, hence requiring a surrogate key to be associated with each attribute of each record in the database. The resulting database size is essentially the same as the size of the raw data in the original database configuration.
Reference: [17] <author> C. Dyreson. </author> <title> Information retrieval from an incomplete data cube. </title> <booktitle> In Proc. 22nd VLDB Conf., </booktitle> <address> Mumbai, India, </address> <year> 1996. </year>
Reference-contexts: Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation [10, 23, 33, 30, 50, 68, 69], join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including <ref> [2, 17, 23, 42, 53, 58] </ref>. Yet another facet of query processing that has received attention in the literature is that of efficiency. Fast query evaluation is critical in OLAP environments given the interactive nature of most OLAP sessions. There are two basic approaches for quickly evaluating OLAP queries: 1.
Reference: [18] <author> M. Freeston. </author> <title> A general solution to the n-dimensional B-tree problem. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <address> San Jose, CA, </address> <year> 1995. </year>
Reference-contexts: Database systems use indexes to improve efficiency of access to data. Various general purpose indexing techniques have been proposed and are utilized in OLTP systems, including hashing [54], B trees [12, 15], and multidimensional trees such as the R-tree [27], the K-D-B tree [52], and the BV tree <ref> [18] </ref>. There exists another class of multidimensional structures, namely grid files [43], that allows for very fast access to multidimensional data. However, in these and other index structures proposed for OLAP, one envisions a set of relations or table structures, and a separate set of indices or access structures.
Reference: [19] <author> C.D. </author> <title> French. Teaching an OLTP database kernel advanced datawarehousing techniques. </title> <booktitle> In Proc. 13th ICDE, </booktitle> <pages> pages 194-198, </pages> <address> Birmingham, UK, </address> <month> April 7-11 </month> <year> 1997. </year>
Reference-contexts: In such situations, it is advisable to only store the index if original table records can be reconstructed easily from the index itself. This is the starting point of the proposed DataIndex scheme and is how Sybase IQ stores data <ref> [19, 46] </ref>. Furthermore, with DataIndexes, each BDI of a table is stored separately with ordinal positon based mapping providing more efficient access to individual record fields compared to other vertical partitioning based methods. <p> These two problems, however, are likely to be negligible when compared with the overhead incurred by expensive index update operations. Compressibility: It should be clear that DataIndexes can be compressed much more readily than conventional tables, since the range of values each DataIndex covers is much smaller <ref> [19] </ref>. Some compression techniques allow operations on the underlying data to be performed without decompression. Thus, we can expect that compressed DataIndexes can provide even better performance than those studied in this paper.
Reference: [20] <author> P. Goel and B. Iyer. </author> <title> Sql query optimization: Reordering for a general class of queries. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 47-56, </pages> <address> Montreal, Quebec, Canada, </address> <month> June 4-6 </month> <year> 1996. </year>
Reference-contexts: This area is starting to receive the attention it deserves. A number of "conventional" relational query processing approaches have been applied to or extended for answering OLAP queries. Some of this work has concentrated on efficiently performing GROUP BY <ref> [8, 9, 20] </ref>, aggregation [10, 23, 33, 30, 50, 68, 69], join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58].
Reference: [21] <author> G. Graefe. </author> <title> Query evaluation techniques for large databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(2) </volume> <pages> 73-170, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: While they may perform well for simple queries involving a single table (e.g., restrictions, counting), they do not offer any improvement over conventional pairwise join techniques <ref> [21] </ref>. Typically, additional indexes are required along with projection indexes to improve join performance, incurring additional overhead. Clearly, there is a need to minimize the additional overhead incurred by index structures. <p> There exist relatively fast algorithms (e.g., merge and hash joins) for evaluating joins. However, approaches that use pointers to the underlying data, instead of the actual records, tend to give a better performance than other join strategies <ref> [21] </ref>. Thus, if a DataIndex relied on pointers to records to both store and index the underlying data, it would perhaps have a good join performance. <p> This approach should be significantly faster than with conventional join algorithms, which typically perform joins between two or more tables in a pairwise fashion. Such algorithms include nested-loop joins, merge joins [4], hash-joins [5], or any derivative of these techniques [38, 56] (see <ref> [21] </ref> for a survey). In fact, the exact number of block accesses needed to scan a JDI is simply the number of data blocks occupied by this structure. This is given by l jSALESj (r) , where r is the size of a RID (6 bytes).
Reference: [22] <author> T. Griffin and L. Libkin. </author> <title> Incremental maintenance of views with duplicates. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <address> San Jose, CA, </address> <month> May 23-25 </month> <year> 1995. </year>
Reference: [23] <author> A. Gupta, V. Harinarayan, and D. Quass. </author> <title> Aggregate-query processing in data warehousing environments. </title> <booktitle> In Proc. 21st VLDB Conf., </booktitle> <address> Zurich, Switzerland, </address> <year> 1995. </year>
Reference-contexts: This area is starting to receive the attention it deserves. A number of "conventional" relational query processing approaches have been applied to or extended for answering OLAP queries. Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation <ref> [10, 23, 33, 30, 50, 68, 69] </ref>, join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58]. <p> Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation [10, 23, 33, 30, 50, 68, 69], join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including <ref> [2, 17, 23, 42, 53, 58] </ref>. Yet another facet of query processing that has received attention in the literature is that of efficiency. Fast query evaluation is critical in OLAP environments given the interactive nature of most OLAP sessions. There are two basic approaches for quickly evaluating OLAP queries: 1.
Reference: [24] <author> A. Gupta, H. Jagadish, and I. Mumick. </author> <title> Data integration using self-maintainable views. </title> <booktitle> In Proc. Fifth Intl. Conf. on Extending Database Technology, </booktitle> <address> Avignon, France, </address> <month> March </month> <year> 1996. </year>
Reference: [25] <author> A. Gupta, I. Mumick, and V. Subrahmanian. </author> <title> Maintaining views incrementally. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 26-28, </pages> <address> Washington, DC, </address> <month> May 26-28 </month> <year> 1993. </year>
Reference: [26] <author> H. Gupta, V. Harinarayan, A. Rajaraman, and J.D. Ullman. </author> <title> Index selection for OLAP. </title> <booktitle> In Proc. Thirteenth Intl. Conf. on Data Engineering, </booktitle> <pages> pages 208-219, </pages> <address> Birmingham, UK, </address> <month> April 7-11 </month> <year> 1997. </year> <note> IEEE. </note>
Reference: [27] <author> A. Guttman. R-trees: </author> <title> a dynamic index structure for spatial searching. </title> <editor> In M. Stonebraker, editor, </editor> <booktitle> Readings in Database Systems, </booktitle> <pages> pages 599-609. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1988. </year>
Reference-contexts: Database systems use indexes to improve efficiency of access to data. Various general purpose indexing techniques have been proposed and are utilized in OLTP systems, including hashing [54], B trees [12, 15], and multidimensional trees such as the R-tree <ref> [27] </ref>, the K-D-B tree [52], and the BV tree [18]. There exists another class of multidimensional structures, namely grid files [43], that allows for very fast access to multidimensional data.
Reference: [28] <author> V. Harinarayan, A. Rajaraman, and J.D. Ullman. </author> <title> Implementing data cubes efficiently. </title> <booktitle> In Proc. ACM SIGMOD, </booktitle> <pages> pages 205-216, </pages> <address> Montreal, Canada, </address> <month> June 4-6 </month> <year> 1996. </year>
Reference: [29] <author> J.M. Hellerstein, P.J. Haas, and H.J. Wang. </author> <title> Online aggregation. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 171-182, </pages> <address> Tucson, AZ, </address> <month> May 13-15 </month> <year> 1997. </year> <month> 36 </month>
Reference-contexts: Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation [10, 23, 33, 30, 50, 68, 69], join or range queries [32, 60, 64], or supporting incomplete query answers <ref> [6, 29, 66] </ref>. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58]. Yet another facet of query processing that has received attention in the literature is that of efficiency.
Reference: [30] <author> J.M. Hellerstein and J.F. Naughton. </author> <title> Query execution techniques for caching expensive methods. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 423-424, </pages> <address> Montreal, Quebec, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: This area is starting to receive the attention it deserves. A number of "conventional" relational query processing approaches have been applied to or extended for answering OLAP queries. Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation <ref> [10, 23, 33, 30, 50, 68, 69] </ref>, join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58].
Reference: [31] <author> J.L. Hennessy and D.A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> 2nd edition, </address> <year> 1996. </year>
Reference-contexts: In fact, in most cases, we believe that the delays associated with these computations will be negligible compared to the much slower storage access times. This belief is strengthened by other studies <ref> [46, 31] </ref>, which have shown that I/O related costs (disk access plus I/O related CPU costs) are several orders of magnitude more than other CPU costs relating to query processing.
Reference: [32] <author> C-T. Ho, R. Agrawal, N. Meggido, and R. Srikant. </author> <title> Range queries in OLAP data cubes. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 73-88, </pages> <address> Tucson, AZ, </address> <month> May 13-15 </month> <year> 1997. </year>
Reference-contexts: A number of "conventional" relational query processing approaches have been applied to or extended for answering OLAP queries. Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation [10, 23, 33, 30, 50, 68, 69], join or range queries <ref> [32, 60, 64] </ref>, or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58]. Yet another facet of query processing that has received attention in the literature is that of efficiency.
Reference: [33] <author> C-T. Ho, J. Bruck, and R. Agrawal. </author> <title> Partial-sum queries in OLAP data cubes using covering codes. </title> <booktitle> In Proc. 16th ACM Symposium on Principles of Database Systems, </booktitle> <address> Tucson, AZ, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: This area is starting to receive the attention it deserves. A number of "conventional" relational query processing approaches have been applied to or extended for answering OLAP queries. Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation <ref> [10, 23, 33, 30, 50, 68, 69] </ref>, join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58].
Reference: [34] <author> Informix Software. </author> <title> INFORMIX-online extended parallel server and INFORMIX-universal server: A new generation of decision-support indexing for enterprise data warehouses. </title> <type> White Paper, </type> <year> 1997. </year>
Reference-contexts: We have selected four popular index structures for data warehousing : B-trees [15], bitmapped indexes [44, 47], bit-sliced indexes <ref> [46, 34] </ref>, and projection indexes [46, 61]. It is assumed that only the PartKey, SuppKey, CustKey, ShipDate, CommitDate and ReceiptDate columns of the SALES table are indexed. Table 2 summarizes the storage requirements of each indexing scheme for the 4 sample database 1 . <p> Before we conclude this section, it is important to point out that a number of variant indexes are supported in commercial products such as Sybase IQ [61], Oracle 8 [47], Informix Universal Server <ref> [34] </ref>, and Red Brick Warehouse [51]. In addition to projection indexes [46] and bitmapped join indexes [45] mentioned already, such 9 index structures include bitmapped indexes [44], bit-sliced indexes [46].
Reference: [35] <author> W.H. Inmon. </author> <title> Building the Data Warehouse. </title> <editor> J. </editor> <publisher> Wiley & Sons, Inc., </publisher> <address> second edition, </address> <year> 1996. </year>
Reference-contexts: Data warehousing refers to "a collection of decision support technologies aimed at enabling the knowledge worker (executive, manager, analyst) to make better and faster decisions" [11]. Thus, loosely speaking, a data warehouse is a "very large" repository of historical data pertaining to an organization <ref> [35] </ref>. OLAP refers to the technique of performing complex analysis over the information stored in a data warehouse [13].
Reference: [36] <author> S. Khoshafian, G.P. Copeland, T. Jagodis, H. Boral, and P. Valduriez. </author> <title> A query processing strategy for the decomposed storage model. </title> <booktitle> In Proc. ICDE, </booktitle> <pages> pages 636-643, </pages> <year> 1987. </year>
Reference-contexts: This RID can be expressed as b DT S = j (R) , and the slot number as s R = mod (R). It is the ordinal mapping that makes this basic approach more efficient than existing vertical partitioning methods such as the Decomposition Storage Model (DSM) <ref> [16, 36, 63] </ref>. Indeed, DSM utilizes surrogate keys to map individual attributes together, hence requiring a surrogate key to be associated with each attribute of each record in the database. The resulting database size is essentially the same as the size of the raw data in the original database configuration.
Reference: [37] <author> R. Kimball. </author> <title> The Data Warehouse Toolkit. </title> <editor> J. </editor> <publisher> Wiley & Sons, Inc., </publisher> <address> first edition, </address> <year> 1996. </year>
Reference-contexts: To illustrate these costs we refer to the star schema <ref> [37] </ref> presented in Figure 1, which was derived from the TPC-D benchmark database [62] with a scale factor of 1. This schema models the activities of a world-wide wholesale supplier over a period of 7 years, and will be used as a running example throughout this paper.
Reference: [38] <author> M. Kitsuregawa, M. Nakayama, and M. Takagi. </author> <title> The effect of bucket size tuning in the dynamic hybrid GRACE hash join method. </title> <booktitle> In Proc. 15th VLDB, </booktitle> <address> Amsterdam, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: This approach should be significantly faster than with conventional join algorithms, which typically perform joins between two or more tables in a pairwise fashion. Such algorithms include nested-loop joins, merge joins [4], hash-joins [5], or any derivative of these techniques <ref> [38, 56] </ref> (see [21] for a survey). In fact, the exact number of block accesses needed to scan a JDI is simply the number of data blocks occupied by this structure. This is given by l jSALESj (r) , where r is the size of a RID (6 bytes).
Reference: [39] <author> Y. Kotidis and N. Roussopoulos. </author> <title> An alternative storage organization for rolap aggregate views based on cubetrees. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 249-258, </pages> <address> Seattle, WA, </address> <month> June 1-4 </month> <year> 1998. </year>
Reference: [40] <author> D. Lomet, ed. </author> <title> Special issue on materialized views and data warehousing. </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> 18(2), </volume> <year> 1995. </year>
Reference: [41] <editor> I.S. Mumick and A. Gupta, editors. </editor> <booktitle> Proc. Workshop on Materialized Views: Techniques and Applications, </booktitle> <address> Montreal, Canada, </address> <month> June 7 </month> <year> 1996. </year>
Reference: [42] <author> I.S. Mumick, D. Quass, and B.S. Mumick. </author> <title> Maintenance of data cubes and summary tables in a warehouse. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 100-111, </pages> <address> Tucson, AZ, </address> <month> May 13-15 </month> <year> 1997. </year>
Reference-contexts: Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation [10, 23, 33, 30, 50, 68, 69], join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including <ref> [2, 17, 23, 42, 53, 58] </ref>. Yet another facet of query processing that has received attention in the literature is that of efficiency. Fast query evaluation is critical in OLAP environments given the interactive nature of most OLAP sessions. There are two basic approaches for quickly evaluating OLAP queries: 1.
Reference: [43] <author> J. Nievergelt, H. Hinterberger, and K.C. Sevcik. </author> <title> The grid file: An adaptable, symmetric multikey file structure. </title> <editor> In M. Stonebraker, editor, </editor> <booktitle> Readings in Database Systems, </booktitle> <pages> pages 582-598. </pages> <publisher> Morgan-Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1988. </year>
Reference-contexts: Various general purpose indexing techniques have been proposed and are utilized in OLTP systems, including hashing [54], B trees [12, 15], and multidimensional trees such as the R-tree [27], the K-D-B tree [52], and the BV tree [18]. There exists another class of multidimensional structures, namely grid files <ref> [43] </ref>, that allows for very fast access to multidimensional data. However, in these and other index structures proposed for OLAP, one envisions a set of relations or table structures, and a separate set of indices or access structures. That is, thus far, databases have considered index and data separately.
Reference: [44] <author> P. O'Neil. </author> <title> Model 204 architecture and performance. </title> <booktitle> In 2nd Intl. Workshop on High Performance Transaction Systems (HPTS), volume 359 of Springer-Verlag Lecture Notes on Computer Science, </booktitle> <pages> pages 40-59. </pages> <publisher> Springer-Verlag, </publisher> <address> Asilomar, CA, </address> <year> 1987. </year>
Reference-contexts: We have selected four popular index structures for data warehousing : B-trees [15], bitmapped indexes <ref> [44, 47] </ref>, bit-sliced indexes [46, 34], and projection indexes [46, 61]. It is assumed that only the PartKey, SuppKey, CustKey, ShipDate, CommitDate and ReceiptDate columns of the SALES table are indexed. Table 2 summarizes the storage requirements of each indexing scheme for the 4 sample database 1 . <p> In such cases, the number of records can vary from one page to the next. To solve this problem, one can define a maximum number of records per page, as is done in the model 204 database system <ref> [44] </ref>. In this case, a few ordinal position numbers () may not actually correspond to actual records. Alternatively, one can "encode" each unique value to a fixed length surrogate. <p> In addition to projection indexes [46] and bitmapped join indexes [45] mentioned already, such 9 index structures include bitmapped indexes <ref> [44] </ref>, bit-sliced indexes [46]. Wu and Buchmann [67] presented an efficient encoding scheme for reducing the size of bitmapped indexes, and Chan and Ioannidis [7] proposed a framework for the design and evaluation of bitmap indexing schemes.
Reference: [45] <author> P. O'Neil and G. Graefe. </author> <title> Multi-table joins through bitmapped join indices. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 24(3) </volume> <pages> 8-11, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: As we shall see, DataIndexes combine and extend, in an effective way, ideas embedded in other well-known database structuring techniques, specifically vertical partitioning and transposed files [57], as well as indexing techniques, specifically projection indexes [46] and bit-mapped join indexes <ref> [45] </ref>. As a second contribution, we propose two algorithms for efficiently performing star joins and show that these algorithms outperform existing approaches in a vast majority of situations. <p> The PART, CUSTOMER and SALES table must be joined to answer this query. Access methods that efficiently support join operations thus become crucial in decision support environments <ref> [45, 51] </ref>. The idea of a BDI presented in the previous section can very easily be extended to support such operations. Consider for instance, an analyst who is interested in possible trends or seasonalities in discounts offered to customers. <p> Finally, as mentioned previously in Section 2, projection indexes do not improve join performance. We introduce the notion of Join DataIndexes (JDI) for this purpose. O'Neil and Graefe <ref> [45] </ref> briefly introduced the idea of a bitmapped join index for efficiently supporting multi-table joins. JDIs capitalize on this idea in the context of the Basic DataIndex. A bitmapped join index (BJI) associates related rows from two tables [45], as follows. <p> O'Neil and Graefe <ref> [45] </ref> briefly introduced the idea of a bitmapped join index for efficiently supporting multi-table joins. JDIs capitalize on this idea in the context of the Basic DataIndex. A bitmapped join index (BJI) associates related rows from two tables [45], as follows. Consider two tables, T 1 and T 2 , related by a one-to-many relationship (i.e., one record of T 1 is referenced by many records of T 2 ). <p> Before we conclude this section, it is important to point out that a number of variant indexes are supported in commercial products such as Sybase IQ [61], Oracle 8 [47], Informix Universal Server [34], and Red Brick Warehouse [51]. In addition to projection indexes [46] and bitmapped join indexes <ref> [45] </ref> mentioned already, such 9 index structures include bitmapped indexes [44], bit-sliced indexes [46]. Wu and Buchmann [67] presented an efficient encoding scheme for reducing the size of bitmapped indexes, and Chan and Ioannidis [7] proposed a framework for the design and evaluation of bitmap indexing schemes. <p> We also proposed two fast algorithms for performing star-join operations on DataIndexed data warehouses. We have derived expressions that show the expected performance of DataIndexes and a number of other indexing approaches that have been proposed and utilized in data warehousing <ref> [45, 46] </ref>. Based on these expressions, we have analytically shown that the performance obtainable with DataIndexes is most often superior to that of even the best conventional approach.
Reference: [46] <author> P. O'Neil and D. Quass. </author> <title> Improved query performance with variant indexes. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 38-49, </pages> <address> Tucson, AZ, </address> <month> May 13-15 </month> <year> 1997. </year>
Reference-contexts: The basic premise underlying this work is that data warehouses can achieve faster response times by pre-aggregating (i.e., materializing) the answers to frequently asked queries. It is recognized however, that such anticipation only works up to a point <ref> [11, 46] </ref>, and a considerable fraction of the workload in OLAP applications will consist of ad-hoc queries which will need to be computed on demand [3]. This has led to work on strategies for ad-hoc query processing. 2. Ad-hoc Strategies. <p> Because DataIndexes are both storage and access structures, substantial space savings are realized. As we shall see, DataIndexes combine and extend, in an effective way, ideas embedded in other well-known database structuring techniques, specifically vertical partitioning and transposed files [57], as well as indexing techniques, specifically projection indexes <ref> [46] </ref> and bit-mapped join indexes [45]. As a second contribution, we propose two algorithms for efficiently performing star joins and show that these algorithms outperform existing approaches in a vast majority of situations. <p> We have selected four popular index structures for data warehousing : B-trees [15], bitmapped indexes [44, 47], bit-sliced indexes <ref> [46, 34] </ref>, and projection indexes [46, 61]. It is assumed that only the PartKey, SuppKey, CustKey, ShipDate, CommitDate and ReceiptDate columns of the SALES table are indexed. Table 2 summarizes the storage requirements of each indexing scheme for the 4 sample database 1 . <p> We have selected four popular index structures for data warehousing : B-trees [15], bitmapped indexes [44, 47], bit-sliced indexes [46, 34], and projection indexes <ref> [46, 61] </ref>. It is assumed that only the PartKey, SuppKey, CustKey, ShipDate, CommitDate and ReceiptDate columns of the SALES table are indexed. Table 2 summarizes the storage requirements of each indexing scheme for the 4 sample database 1 . <p> In such situations, it is advisable to only store the index if original table records can be reconstructed easily from the index itself. This is the starting point of the proposed DataIndex scheme and is how Sybase IQ stores data <ref> [19, 46] </ref>. Furthermore, with DataIndexes, each BDI of a table is stored separately with ordinal positon based mapping providing more efficient access to individual record fields compared to other vertical partitioning based methods. <p> Before we conclude this section, it is important to point out that a number of variant indexes are supported in commercial products such as Sybase IQ [61], Oracle 8 [47], Informix Universal Server [34], and Red Brick Warehouse [51]. In addition to projection indexes <ref> [46] </ref> and bitmapped join indexes [45] mentioned already, such 9 index structures include bitmapped indexes [44], bit-sliced indexes [46]. <p> In addition to projection indexes <ref> [46] </ref> and bitmapped join indexes [45] mentioned already, such 9 index structures include bitmapped indexes [44], bit-sliced indexes [46]. Wu and Buchmann [67] presented an efficient encoding scheme for reducing the size of bitmapped indexes, and Chan and Ioannidis [7] proposed a framework for the design and evaluation of bitmap indexing schemes. An analysis of three index structures along with B + -trees is presented in [46], which indicates <p> bit-sliced indexes <ref> [46] </ref>. Wu and Buchmann [67] presented an efficient encoding scheme for reducing the size of bitmapped indexes, and Chan and Ioannidis [7] proposed a framework for the design and evaluation of bitmap indexing schemes. An analysis of three index structures along with B + -trees is presented in [46], which indicates that these four structures are particularly appropriate for warehousing/OLAP environments. <p> A rowset is the access structure used in the first phase. Two approaches to representing a rowset would be to represent it as a list of row identifiers (RIDs) or a bit vector <ref> [46] </ref>. In a RID-list representation, a rowset can be thought of as a list structure containing a set of RIDs for selected tuples, and so the rowset cardinality is the number of selected tuples. <p> In decision support environments, many queries access significant portions of the underlying database [11]. In addition, many operations on bitmaps are much faster than on RID lists <ref> [46] </ref>. For these reasons, in the remainder of this paper we assume that the rowsets used in evaluating a selection predicate are implemented as bit vectors. Now we turn our attention to analyzing how a star-join query is evaluated in a data warehouse. <p> In fact, in most cases, we believe that the delays associated with these computations will be negligible compared to the much slower storage access times. This belief is strengthened by other studies <ref> [46, 31] </ref>, which have shown that I/O related costs (disk access plus I/O related CPU costs) are several orders of magnitude more than other CPU costs relating to query processing. <p> (B-tree) log P V 1 + V range K V fi B V range (23) 6.1.2 N ROWSET for a Bitmap Index A bitmapped index is identical to a conventional B-tree except that the rowsets corresponding to each unique search-key value are represented as bit vectors instead of RID lists <ref> [46] </ref>. <p> However, in practice, bitmapped indexes almost always require less storage than B + -tree as significant compression can usually be achieved on the bitmaps. We now provide an illustrative example. A simple compression technique used in bitmapped indexes <ref> [46] </ref> is to represent the rowsets as bitmaps only when the bitmap representation is smaller than a RID list representation. It is easily seen that a bitmapped index constructed according to this method can never require more storage than a B + -tree . <p> Because of this result, in the remainder of this paper, we do not consider the B + -tree but rather concentrate on the bitmapped index. 6.1.3 N ROWSET for a Projection Index A projection index corresponds to a mirror copy of the column being indexed <ref> [46] </ref>. <p> To lend some structure to these comparisons, we classify the indexing mechanisms into two classes: (a) Indexing 3 <ref> [46] </ref> gives an efficient algorithm for performing ranging queries on bit-sliced indexes. This algorithm uses multiple bit vectors to compute the final rowset. <p> Once R JOIN has been determined, the relevant values from the different tables are extracted from the source tables and stored in temporary files. These temporary files are then joined pair-wise until the final join result is computed, thereby requiring jDj individual two-way joins. Since it is well known <ref> [46] </ref> that pairwise joins do not perform well in a data warehouse environment, we do not include the cost analysis of this approach. 6.2.2 Bitmapped Indexes Bitmapped indexes may also be used to perform a star-join similarly to BJIs. <p> We also proposed two fast algorithms for performing star-join operations on DataIndexed data warehouses. We have derived expressions that show the expected performance of DataIndexes and a number of other indexing approaches that have been proposed and utilized in data warehousing <ref> [45, 46] </ref>. Based on these expressions, we have analytically shown that the performance obtainable with DataIndexes is most often superior to that of even the best conventional approach. <p> Some compression techniques allow operations on the underlying data to be performed without decompression. Thus, we can expect that compressed DataIndexes can provide even better performance than those studied in this paper. Other OLAP queries: The results in <ref> [46] </ref>, lead us to believe that DataIndexes would yield relatively low evaluation costs for other types of warehousing queries (such as group-bys and aggregations).
Reference: [47] <author> Oracle Corp. </author> <title> Star queries in Oracle8. </title> <type> White Paper, </type> <month> June </month> <year> 1997. </year>
Reference-contexts: We have selected four popular index structures for data warehousing : B-trees [15], bitmapped indexes <ref> [44, 47] </ref>, bit-sliced indexes [46, 34], and projection indexes [46, 61]. It is assumed that only the PartKey, SuppKey, CustKey, ShipDate, CommitDate and ReceiptDate columns of the SALES table are indexed. Table 2 summarizes the storage requirements of each indexing scheme for the 4 sample database 1 . <p> Before we conclude this section, it is important to point out that a number of variant indexes are supported in commercial products such as Sybase IQ [61], Oracle 8 <ref> [47] </ref>, Informix Universal Server [34], and Red Brick Warehouse [51]. In addition to projection indexes [46] and bitmapped join indexes [45] mentioned already, such 9 index structures include bitmapped indexes [44], bit-sliced indexes [46].
Reference: [48] <author> D. Quass. </author> <title> Maintenance expressions for views with aggregations. </title> <booktitle> In Proc. Workshop on Materialized Views: Techniques and Applications, </booktitle> <address> Montreal, Canada, </address> <month> June 7 </month> <year> 1996. </year>
Reference: [49] <author> D. Quass and J. Widom. </author> <title> On-line warehouse view maintenance. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 393-404, </pages> <address> Tucson, AZ, </address> <month> May 13-15 </month> <year> 1997. </year> <month> 37 </month>
Reference: [50] <author> S.G. Rao, A. Badia, and D. Van Gucht. </author> <title> Providing better support for a class of decision support queries. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 217-227, </pages> <address> Montreal, Quebec, Canada, </address> <month> June 4-6 </month> <year> 1996. </year>
Reference-contexts: This area is starting to receive the attention it deserves. A number of "conventional" relational query processing approaches have been applied to or extended for answering OLAP queries. Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation <ref> [10, 23, 33, 30, 50, 68, 69] </ref>, join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58].
Reference: [51] <author> Red Brick Systems. </author> <title> Star schema processing for complex queries. </title> <type> White Paper, </type> <month> July </month> <year> 1997. </year>
Reference-contexts: The PART, CUSTOMER and SALES table must be joined to answer this query. Access methods that efficiently support join operations thus become crucial in decision support environments <ref> [45, 51] </ref>. The idea of a BDI presented in the previous section can very easily be extended to support such operations. Consider for instance, an analyst who is interested in possible trends or seasonalities in discounts offered to customers. <p> Before we conclude this section, it is important to point out that a number of variant indexes are supported in commercial products such as Sybase IQ [61], Oracle 8 [47], Informix Universal Server [34], and Red Brick Warehouse <ref> [51] </ref>. In addition to projection indexes [46] and bitmapped join indexes [45] mentioned already, such 9 index structures include bitmapped indexes [44], bit-sliced indexes [46].
Reference: [52] <author> J.T. Robinson. </author> <title> The K-D-B-tree: A search structure for large multi-dimensional dynamic indexes. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 10-18, </pages> <address> New York, NY, </address> <year> 1981. </year>
Reference-contexts: Database systems use indexes to improve efficiency of access to data. Various general purpose indexing techniques have been proposed and are utilized in OLTP systems, including hashing [54], B trees [12, 15], and multidimensional trees such as the R-tree [27], the K-D-B tree <ref> [52] </ref>, and the BV tree [18]. There exists another class of multidimensional structures, namely grid files [43], that allows for very fast access to multidimensional data.
Reference: [53] <author> N. Roussopoulos, Y. Kotidis, and M. Roussopoulos. Cubetree: </author> <title> Organization of and bulk updates on the data cube. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 89-99, </pages> <address> Tucson, AZ, </address> <month> May 13-15 </month> <year> 1997. </year>
Reference-contexts: Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation [10, 23, 33, 30, 50, 68, 69], join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including <ref> [2, 17, 23, 42, 53, 58] </ref>. Yet another facet of query processing that has received attention in the literature is that of efficiency. Fast query evaluation is critical in OLAP environments given the interactive nature of most OLAP sessions. There are two basic approaches for quickly evaluating OLAP queries: 1.
Reference: [54] <author> B. Salzberg. </author> <title> Access methods. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(1) </volume> <pages> 117-120, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: Ad-hoc Strategies. This approach to fast OLAP query processing supports ad-hoc querying by using fast 2 access structures on the base data. Database systems use indexes to improve efficiency of access to data. Various general purpose indexing techniques have been proposed and are utilized in OLTP systems, including hashing <ref> [54] </ref>, B trees [12, 15], and multidimensional trees such as the R-tree [27], the K-D-B tree [52], and the BV tree [18]. There exists another class of multidimensional structures, namely grid files [43], that allows for very fast access to multidimensional data.
Reference: [55] <author> S. Sarawagi. </author> <title> Indexing OLAP data. </title> <journal> Bulletin of the IEEE Computer Society Technical Committee on Data Engineering, </journal> <pages> pages 36-43, </pages> <year> 1997. </year>
Reference: [56] <author> L.D. Shapiro. </author> <title> Join processing in database systems with large main memories. </title> <journal> ACM TODS, </journal> <volume> 11(3), </volume> <month> October </month> <year> 1986. </year>
Reference-contexts: This approach should be significantly faster than with conventional join algorithms, which typically perform joins between two or more tables in a pairwise fashion. Such algorithms include nested-loop joins, merge joins [4], hash-joins [5], or any derivative of these techniques <ref> [38, 56] </ref> (see [21] for a survey). In fact, the exact number of block accesses needed to scan a JDI is simply the number of data blocks occupied by this structure. This is given by l jSALESj (r) , where r is the size of a RID (6 bytes).
Reference: [57] <author> A. Shoshani. </author> <title> OLAP and statistical databases: Similarities and differences. </title> <journal> ACM TODS, </journal> <volume> 22, </volume> <year> 1997. </year>
Reference-contexts: Because DataIndexes are both storage and access structures, substantial space savings are realized. As we shall see, DataIndexes combine and extend, in an effective way, ideas embedded in other well-known database structuring techniques, specifically vertical partitioning and transposed files <ref> [57] </ref>, as well as indexing techniques, specifically projection indexes [46] and bit-mapped join indexes [45]. As a second contribution, we propose two algorithms for efficiently performing star joins and show that these algorithms outperform existing approaches in a vast majority of situations.
Reference: [58] <author> A. Shukla, P.M. Deshpande, J.F. Naughton, and K. Ramasamy. </author> <title> Storage estimation for multidimensional aggregates in the presence of hierarchies. </title> <booktitle> In Proc. 22nd VLDB Conf., </booktitle> <address> Mumbai, India, </address> <year> 1996. </year>
Reference-contexts: Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation [10, 23, 33, 30, 50, 68, 69], join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including <ref> [2, 17, 23, 42, 53, 58] </ref>. Yet another facet of query processing that has received attention in the literature is that of efficiency. Fast query evaluation is critical in OLAP environments given the interactive nature of most OLAP sessions. There are two basic approaches for quickly evaluating OLAP queries: 1.
Reference: [59] <author> D. Simpson. </author> <title> Corral your storage management costs. </title> <journal> Datamation, </journal> <pages> pages 88-93, </pages> <month> April </month> <year> 1997. </year>
Reference-contexts: This is especially true given that data and storage maintenance costs are often up to seven times as high per year as the original purchase cost <ref> [59] </ref>. Hence, a terabyte-sized system, with an initial media cost of $100,000, could cost an additional $700,000 for every year it is operational. This cost is certainly non-trivial. Indexess, obviously, add to this cost and hence it is essential to minimize these additional costs.
Reference: [60] <author> M. Spiliopoulou, M. Hatzopoulos, and Y. Cotronis. </author> <title> Parallel optimization of large join queries with set operators and aggregates in a parallel environment supporting pipeline. </title> <journal> IEEE TKDE, </journal> <volume> 8(3) </volume> <pages> 429-45, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: A number of "conventional" relational query processing approaches have been applied to or extended for answering OLAP queries. Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation [10, 23, 33, 30, 50, 68, 69], join or range queries <ref> [32, 60, 64] </ref>, or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58]. Yet another facet of query processing that has received attention in the literature is that of efficiency.
Reference: [61] <author> Sybase, Inc. </author> <title> Sybase IQ optimizing interactive performance for the data warehouse. </title> <type> White Paper, </type> <year> 1997. </year>
Reference-contexts: We have selected four popular index structures for data warehousing : B-trees [15], bitmapped indexes [44, 47], bit-sliced indexes [46, 34], and projection indexes <ref> [46, 61] </ref>. It is assumed that only the PartKey, SuppKey, CustKey, ShipDate, CommitDate and ReceiptDate columns of the SALES table are indexed. Table 2 summarizes the storage requirements of each indexing scheme for the 4 sample database 1 . <p> But even projection indexes incur a more than 12.5% increase in size of the indexed database over the unindexed database, assuming the index structures are stored in addition to the data. (Some implementations of projection indexes, such as Sybase IQ <ref> [61] </ref>, do not store both the index and data.) We also emphasize that projection indexes are not very effective for many OLAP queries. While they may perform well for simple queries involving a single table (e.g., restrictions, counting), they do not offer any improvement over conventional pairwise join techniques [21]. <p> Before we conclude this section, it is important to point out that a number of variant indexes are supported in commercial products such as Sybase IQ <ref> [61] </ref>, Oracle 8 [47], Informix Universal Server [34], and Red Brick Warehouse [51]. In addition to projection indexes [46] and bitmapped join indexes [45] mentioned already, such 9 index structures include bitmapped indexes [44], bit-sliced indexes [46].
Reference: [62] <institution> Transaction Processing Performance Council, </institution> <address> San Jose, </address> <month> CA. </month> <title> TPC Benchmark D (Decision Support) Standard Specification, revision 1.2.3 edition, </title> <month> June </month> <year> 1997. </year>
Reference-contexts: To illustrate these costs we refer to the star schema [37] presented in Figure 1, which was derived from the TPC-D benchmark database <ref> [62] </ref> with a scale factor of 1. This schema models the activities of a world-wide wholesale supplier over a period of 7 years, and will be used as a running example throughout this paper. <p> This query is thus similar to the "Volume Shipping Query" in <ref> [62] </ref>, which identifies sales volumes between different nations. Such a query is relatively typical of OLAP environments. Finally, we continue to use the same metric as used previously, the number of blocks accessed to evaluate the query, N star .
Reference: [63] <author> P. Valduriez, S. Khoshafian, </author> <title> and G.P. Copeland. Implementation techniques of complex objects. </title> <booktitle> In Proc. VLDB, </booktitle> <pages> pages 101-110, </pages> <year> 1986. </year>
Reference-contexts: This RID can be expressed as b DT S = j (R) , and the slot number as s R = mod (R). It is the ordinal mapping that makes this basic approach more efficient than existing vertical partitioning methods such as the Decomposition Storage Model (DSM) <ref> [16, 36, 63] </ref>. Indeed, DSM utilizes surrogate keys to map individual attributes together, hence requiring a surrogate key to be associated with each attribute of each record in the database. The resulting database size is essentially the same as the size of the raw data in the original database configuration.
Reference: [64] <author> B. Vance and D. Maier. </author> <title> Rapid bushy join-order optimization with cartesian products. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 35-46, </pages> <address> Montreal, Quebec, Canada, </address> <month> June 4-6 </month> <year> 1996. </year>
Reference-contexts: A number of "conventional" relational query processing approaches have been applied to or extended for answering OLAP queries. Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation [10, 23, 33, 30, 50, 68, 69], join or range queries <ref> [32, 60, 64] </ref>, or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58]. Yet another facet of query processing that has received attention in the literature is that of efficiency.
Reference: [65] <author> I.R. Viguier, A. Datta, and K. Ramamritham. </author> <title> Exact performance expressions for olap queries. </title> <type> Technical Report GOOD-TR-9709, </type> <institution> U. of Arizona, </institution> <year> 1997. </year> <note> Available from http://loochi.bpa.arizona.edu. </note>
Reference-contexts: Table Size (bytes) SALES 805,773,312 PART 34,136,064 SUPPLIER 2,564,096 CUSTOMER 42,377,216 TIME 73,728 all tables 884,924,416 Table 1: Table Sizes For Example Star Schema We next compute the total storage requirements of the sample database based on the exact expressions for the size of the various index types derived in <ref> [65] </ref>. We have selected four popular index structures for data warehousing : B-trees [15], bitmapped indexes [44, 47], bit-sliced indexes [46, 34], and projection indexes [46, 61]. It is assumed that only the PartKey, SuppKey, CustKey, ShipDate, CommitDate and ReceiptDate columns of the SALES table are indexed.
Reference: [66] <author> S.V. Vrbsky and J.W.S. Liu. </author> <title> APPROXIMATE a query processor that produces monotonically improving approximate answers. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5(6) </volume> <pages> 1056-1068, </pages> <year> 1993. </year>
Reference-contexts: Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation [10, 23, 33, 30, 50, 68, 69], join or range queries [32, 60, 64], or supporting incomplete query answers <ref> [6, 29, 66] </ref>. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58]. Yet another facet of query processing that has received attention in the literature is that of efficiency.
Reference: [67] <author> M-C. Wu and A. Buchmann. </author> <title> Encoded bitmap indexing for data warehouses. </title> <booktitle> In Proc. 14th ICDE, </booktitle> <pages> pages 220-230, </pages> <address> Orlando, Florida, </address> <month> February </month> <year> 1998. </year>
Reference-contexts: In addition to projection indexes [46] and bitmapped join indexes [45] mentioned already, such 9 index structures include bitmapped indexes [44], bit-sliced indexes [46]. Wu and Buchmann <ref> [67] </ref> presented an efficient encoding scheme for reducing the size of bitmapped indexes, and Chan and Ioannidis [7] proposed a framework for the design and evaluation of bitmap indexing schemes.
Reference: [68] <author> W.P. Yan and P.A. Larson. </author> <title> Eager aggregation and lazy aggregation. </title> <booktitle> In Proc. 21st Intl. Conf. on Very Large Databases, </booktitle> <pages> pages 345-357, </pages> <address> Zurich, Switzerland, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: This area is starting to receive the attention it deserves. A number of "conventional" relational query processing approaches have been applied to or extended for answering OLAP queries. Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation <ref> [10, 23, 33, 30, 50, 68, 69] </ref>, join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58].
Reference: [69] <author> Y. Zhao, P.M. Deshpande, and J.F. Naughton. </author> <title> An array-based algorithm for simultaneous multidimensional aggregates. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 159-170, </pages> <address> Tucson, AZ, </address> <month> May 13-15 </month> <year> 1997. </year>
Reference-contexts: This area is starting to receive the attention it deserves. A number of "conventional" relational query processing approaches have been applied to or extended for answering OLAP queries. Some of this work has concentrated on efficiently performing GROUP BY [8, 9, 20], aggregation <ref> [10, 23, 33, 30, 50, 68, 69] </ref>, join or range queries [32, 60, 64], or supporting incomplete query answers [6, 29, 66]. Several approaches have been proposed for supporting the SQL CUBE operator, including [2, 17, 23, 42, 53, 58].
Reference: [70] <author> Y. Zhuge, H. Garcia-Molina, J. Hammer, and J. Widom. </author> <title> View maintenance in a warehousing environment. </title> <booktitle> In Proc. ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 316-327, </pages> <address> San Jose, CA, </address> <month> May 23-25 </month> <year> 1995. </year>
References-found: 70

