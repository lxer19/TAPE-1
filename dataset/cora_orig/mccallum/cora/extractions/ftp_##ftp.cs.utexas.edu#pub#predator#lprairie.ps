URL: ftp://ftp.cs.utexas.edu/pub/predator/lprairie.ps
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: 
Email: fddas,batoryg@cs.utexas.edu  
Title: Synthesizing Rule Sets for Query Optimizers from Components  
Author: Dinesh Das Don Batory 
Address: Austin, Texas 78712-1188  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract: Query optimizers are complex subsystems of database management systems. Modifying query optimizers to admit new algorithms or storage structures is quite difficult, but partly alleviated by extensible approaches to optimizer construction. Rule-based optimizers are a step in that direction, but from our experience, the rule sets of such optimizers are rather monolithic and brittle. Conceptually minor changes often require wholesale modifications to a rule set. Consequently, much can be done to improve the extensibility of rule-based optimizers. As a remedy, we present a tool called Prairie that is based on an algebra of layered optimiz-ers. This algebra naturally leads to a building-blocks approach to rule-set construction. Defining customized rule sets and evolving previously defined rule sets is accomplished by composing building-blocks. We explain an implementation of Prairie and present experimental results that show how classical relational optimizers can be synthesized from building-blocks, and that the efficiency of query optimization is not sacrificed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Don Batory and Bart Geraci. </author> <title> Validating component compositions in software system genera tors. </title> <type> Technical Report TR 95-03, </type> <institution> The University of Texas at Austin, </institution> <year> 1995. </year>
Reference-contexts: The purpose of the layer is to either transform the JOIN operator into the Merge join algorithm, or to a concrete 3 Not all the compositions of GenVoca layers are necessarily meaningful or correct. Methods for validating the consistency of compositions are discussed in <ref> [1] </ref>. 6 Operator Tree Prairie Layer 1 Prairie Layer n P2V Preprocessor Volcano Rules Volcano Rule Engine Access Plan (a) Schematic representation %optimizer SEQUENTIAL [ MERGE [ SORT [ RET ] ] ] %layer SEQUENTIAL %trule JOIN (S 1 ; S 2 ) =)! JOIN (S 2 ; S 1 )
Reference: [2] <author> Don Batory and Sean O'Malley. </author> <title> The design and implementation of hierarchical software sys tems with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(4) </volume> <pages> 355-398, </pages> <month> October </month> <year> 1992. </year> <month> 17 </month>
Reference-contexts: Viewing complex rule sets as compositions of primitive layers is an example of the GenVoca paradigm of software generation <ref> [2] </ref>. In GenVoca, building-blocks of software systems are layers that import and export standardized interfaces; a layer transforms abstract programs (operator trees) that call operators of its export interface into more concrete programs (operator trees) that call operators of its import interface.
Reference: [3] <author> Don Batory, Vivek Singhal, Marty Sirkin, and Jeff Thomas. </author> <title> Scalable software libraries. </title> <booktitle> In Proceedings 1993 ACM SIGSOFT Conference, </booktitle> <pages> pages 191-199, </pages> <address> Los Angeles, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Consequently, conceptually simple modifications to a rule set often require significant effort including new function definitions to characterize the new feature. Modifying rule sets is actually quite important for systems like Starburst [15], Open OODB [5], or P2 <ref> [3, 4] </ref> where adding a new feature to a DBMS involves plugging a component into the DBMS itself. 1 For obvious reasons, updating a DBMS in such a manner should not require DBIs to hack rule sets in order to make the resulting DBMS execute correctly; rule sets should be automatically <p> The ability to generate reconfigurable rule sets almost on-the-fly not only means that Prairie can be used to construct highly customized rule sets, but also that it can be used to build throw-away optimizers for one-of-a-kind applications (something that is not possible with monolithic optimizers) <ref> [3, 4] </ref>. In [7, 8], we discussed how Prairie achieves the first three goals. In this paper, we describe how an extension to Prairie achieves the fourth goal: namely, how reconfigurable rule sets can be constructed from building-blocks. <p> Our primary goal in this paper was to quickly design and implement a practical framework for specifying layered optimiz-ers. Future work can add more generality to this approach. An important goal is to use Prairie to automatically generate efficient optimizers in P2 <ref> [3, 4] </ref>. We believe that rule-based query optimizers will be standard tools of future database systems. The pragmatic difficulties of using conventional rule-based optimizers led us to develop Prairie and its philosophy of using small, well-defined building-blocks for rule set specification.
Reference: [4] <author> Don Batory, Vivek Singhal, Jeff Thomas, Sankar Dasari, Bart Geraci, and Marty Sirkin. </author> <title> The GenVoca model of software-system generators. </title> <journal> IEEE Software, </journal> <volume> 11(5) </volume> <pages> 89-94, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Consequently, conceptually simple modifications to a rule set often require significant effort including new function definitions to characterize the new feature. Modifying rule sets is actually quite important for systems like Starburst [15], Open OODB [5], or P2 <ref> [3, 4] </ref> where adding a new feature to a DBMS involves plugging a component into the DBMS itself. 1 For obvious reasons, updating a DBMS in such a manner should not require DBIs to hack rule sets in order to make the resulting DBMS execute correctly; rule sets should be automatically <p> The ability to generate reconfigurable rule sets almost on-the-fly not only means that Prairie can be used to construct highly customized rule sets, but also that it can be used to build throw-away optimizers for one-of-a-kind applications (something that is not possible with monolithic optimizers) <ref> [3, 4] </ref>. In [7, 8], we discussed how Prairie achieves the first three goals. In this paper, we describe how an extension to Prairie achieves the fourth goal: namely, how reconfigurable rule sets can be constructed from building-blocks. <p> More experiments are needed, however, to verify that the performance is good when scaled to compositions of a large number of layers (i.e., compositions of 10-20 layers <ref> [4] </ref>). Another metric useful in measuring the benefits of layered rule set specifications is the ease with which they can be tailored to different applications. <p> Our primary goal in this paper was to quickly design and implement a practical framework for specifying layered optimiz-ers. Future work can add more generality to this approach. An important goal is to use Prairie to automatically generate efficient optimizers in P2 <ref> [3, 4] </ref>. We believe that rule-based query optimizers will be standard tools of future database systems. The pragmatic difficulties of using conventional rule-based optimizers led us to develop Prairie and its philosophy of using small, well-defined building-blocks for rule set specification.
Reference: [5] <author> Jose A. Blakeley, William J. McKenna, and Goetz Graefe. </author> <title> Experiences building the Open OODB query optimizer. </title> <booktitle> In Proceedings 1993 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 287-296, </pages> <address> Washington, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: For example, in the Volcano rule-based optimizer [10], rule implementations are not encapsulated. Consequently, conceptually simple modifications to a rule set often require significant effort including new function definitions to characterize the new feature. Modifying rule sets is actually quite important for systems like Starburst [15], Open OODB <ref> [5] </ref>, or P2 [3, 4] where adding a new feature to a DBMS involves plugging a component into the DBMS itself. 1 For obvious reasons, updating a DBMS in such a manner should not require DBIs to hack rule sets in order to make the resulting DBMS execute correctly; rule sets <p> Prairie is different than Starburst and Volcano in using a building-blocks methodology (as described in this paper). We have based our work on Volcano because it is freely available and because of Prairie's demonstrated usefulness [8] in re-engineering large Volcano rule sets such as the Open OODB optimizer <ref> [5] </ref>. As described in [8], Prairie provides three key features that simplify the effort in writing rules. First, abstractions (like rules and actions) capture the design and semantics of an optimizer. <p> In this case, the layered approach is very helpful because it helps a DBI to clearly see the effects of any change on the search space of an optimizer. For instance, the Open OODB optimizer <ref> [5] </ref> results in an extremely large search space for certain queries. If it were implemented using layers, then the DBI could more easily experiment with adding new rules and layers in various configurations. <p> are limitations on the types of rules that can occur in each phase; for example, cost computations are not permitted in the rewrite phase. 7 We chose 10 instead of a larger number since the average run time was not substantially different for more queries. 15 Starburst and Open OODB <ref> [5] </ref> do not provide a framework for DBI-defined components that can be composed to generate a rule set. The result is that rule sets in current optimizers defined using these models are monolithic consisting of a large number of rules. For example, the Open OODB optimizer [5] contains 26 rewrite rules <p> Starburst and Open OODB <ref> [5] </ref> do not provide a framework for DBI-defined components that can be composed to generate a rule set. The result is that rule sets in current optimizers defined using these models are monolithic consisting of a large number of rules. For example, the Open OODB optimizer [5] contains 26 rewrite rules without any mechanism to define more manageable rule set modularizations. The result is a cumbersome rule specification scheme that is highly error-prone and hard to modify in a streamlined manner.
Reference: [6] <author> Dean Daniels, Pat Selinger, Laura Haas, Bruce Lindsay, C. Mohan, Adrian Walker, and Paul Wilms. </author> <booktitle> An introduction to distributed query compilation in R fl . In Proceedings 2nd International Conference on Distributed Databases, </booktitle> <pages> pages 291-309, </pages> <address> Berlin, </address> <month> September </month> <year> 1982. </year>
Reference-contexts: The XFER operator denotes the transfer of streams between sites; one algorithm that implements the XFER operator is Ship. The Ship algorithm here is assumed to be a block transfer of streams (as in R fl <ref> [6] </ref>); other transfer strategies (e.g., tuple-at-a-time) could be defined in this or other layers encapsulating rewrites of distributed query processing. The REPLICATION layer models replicated databases. Its imported interface is a RET operator that simulates a centralized, non-replicated database.
Reference: [7] <author> Dinesh Das. </author> <title> Making Database Optimizers More Extensible. </title> <type> PhD thesis, </type> <institution> The University of Texas at Austin, </institution> <year> 1995. </year>
Reference-contexts: Thus, it is imperative that better ways to structure rule sets be found that make rule sets themselves more easily extensible and automatically updatable. In this paper, we describe extensions to the Prairie tool and rule specification language <ref> [7, 8] </ref> that meet this demand for rule-set extensibility. Monolithic rule sets can be modularized as compositions of primitive rule sets. <p> The distinction of implicit vs. explicit rules can be a source 2 (i.e., the time to optimize a query) is ensured by having efficient implementations of the abstractions. Experimental results demonstrating these goals were achieved are presented in <ref> [7, 8] </ref>. This paper describes a fourth important enhancement to the Prairie model, namely to generate reconfigurable rule sets from components. That is, rule sets are modularized as building-blocks that can be arranged in various ways to construct a customized rule set. <p> The ability to generate reconfigurable rule sets almost on-the-fly not only means that Prairie can be used to construct highly customized rule sets, but also that it can be used to build throw-away optimizers for one-of-a-kind applications (something that is not possible with monolithic optimizers) [3, 4]. In <ref> [7, 8] </ref>, we discussed how Prairie achieves the first three goals. In this paper, we describe how an extension to Prairie achieves the fourth goal: namely, how reconfigurable rule sets can be constructed from building-blocks. <p> This step is not necessary for the correct generation of Volcano specifications; it is, however, a means of generating smaller rule sets, and consequently, faster optimizers. Details are found in <ref> [7] </ref>. A question that might arise is the faithfulness of our layer compaction algorithm; that is, whether compacted layered optimizers have the same search space as a monolithic hand-coded optimizer. <p> Thus, in the centralized optimizer of Figure 5, the JOIN CONC operator in the SEQUENTIAL layer corresponds to the JOIN operator in the MERGE layer. Once this correspondence is established, the P2V preprocessor can use the rule compaction techniques described in <ref> [7] </ref> to combine all the layers together into a single, monolithic rule specification. The complexity of the compaction algorithm lies primarily in the process of combining rule actions; for more details, see [7]. <p> Once this correspondence is established, the P2V preprocessor can use the rule compaction techniques described in <ref> [7] </ref> to combine all the layers together into a single, monolithic rule specification. The complexity of the compaction algorithm lies primarily in the process of combining rule actions; for more details, see [7]. For the centralized optimizer shown in Figure 5, the compaction process results in the layer shown in Figure 6. It is interesting to note that the monolithic rule set obtained by layer compaction is the same 6 (except for rule actions; see [7]) as one that might have been hand-written <p> combining rule actions; for more details, see <ref> [7] </ref>. For the centralized optimizer shown in Figure 5, the compaction process results in the layer shown in Figure 6. It is interesting to note that the monolithic rule set obtained by layer compaction is the same 6 (except for rule actions; see [7]) as one that might have been hand-written by a DBI; the 6 Note, especially, that rules (e.g., the JOIN to JOIN CONC transformation in the MERGE layer) that simply transform 12 SEQUENTIAL JOIN (S 1 ; S 2 ) =)! JOIN (S 2 ; S 1 ) JOIN (JOIN (S
Reference: [8] <author> Dinesh Das and Don Batory. Prairie: </author> <title> A rule specification framework for query optimizers. </title> <booktitle> In Proceedings 11th International Conference on Data Engineering, </booktitle> <pages> pages 201-210, </pages> <address> Taipei, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: Thus, it is imperative that better ways to structure rule sets be found that make rule sets themselves more easily extensible and automatically updatable. In this paper, we describe extensions to the Prairie tool and rule specification language <ref> [7, 8] </ref> that meet this demand for rule-set extensibility. Monolithic rule sets can be modularized as compositions of primitive rule sets. <p> Prairie is different than Starburst and Volcano in using a building-blocks methodology (as described in this paper). We have based our work on Volcano because it is freely available and because of Prairie's demonstrated usefulness <ref> [8] </ref> in re-engineering large Volcano rule sets such as the Open OODB optimizer [5]. As described in [8], Prairie provides three key features that simplify the effort in writing rules. First, abstractions (like rules and actions) capture the design and semantics of an optimizer. <p> We have based our work on Volcano because it is freely available and because of Prairie's demonstrated usefulness <ref> [8] </ref> in re-engineering large Volcano rule sets such as the Open OODB optimizer [5]. As described in [8], Prairie provides three key features that simplify the effort in writing rules. First, abstractions (like rules and actions) capture the design and semantics of an optimizer. This has the advantage that changes to an optimizer consists of changing the implementation of its abstractions, not the abstractions themselves. <p> The distinction of implicit vs. explicit rules can be a source 2 (i.e., the time to optimize a query) is ensured by having efficient implementations of the abstractions. Experimental results demonstrating these goals were achieved are presented in <ref> [7, 8] </ref>. This paper describes a fourth important enhancement to the Prairie model, namely to generate reconfigurable rule sets from components. That is, rule sets are modularized as building-blocks that can be arranged in various ways to construct a customized rule set. <p> The ability to generate reconfigurable rule sets almost on-the-fly not only means that Prairie can be used to construct highly customized rule sets, but also that it can be used to build throw-away optimizers for one-of-a-kind applications (something that is not possible with monolithic optimizers) [3, 4]. In <ref> [7, 8] </ref>, we discussed how Prairie achieves the first three goals. In this paper, we describe how an extension to Prairie achieves the fourth goal: namely, how reconfigurable rule sets can be constructed from building-blocks.
Reference: [9] <author> Johann Christoph Freytag. </author> <title> A rule-based view of query optimization. </title> <booktitle> In Proceedings 1987 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 173-180, </pages> <address> San Francisco, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: Customizability of such optimizers is almost impossible without an enormous effort by the database implementor (DBI). This difficulty has lead to the development of rule-based query optimizers, whose primary purpose is to achieve query optimizer extensibility <ref> [9, 10, 12, 13] </ref>. The basic idea is that the actions of a query optimizer are defined as a set of rewrite rules that progressively optimize expressions which define how queries can be evaluated. From our experience, the rule sets of such optimizers are rather brittle.
Reference: [10] <author> Goetz Graefe. Volcano, </author> <title> an extensible and parallel query evaluation system. </title> <type> Technical Report CU-CS-481-90, </type> <institution> University of Colorado at Boulder, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Customizability of such optimizers is almost impossible without an enormous effort by the database implementor (DBI). This difficulty has lead to the development of rule-based query optimizers, whose primary purpose is to achieve query optimizer extensibility <ref> [9, 10, 12, 13] </ref>. The basic idea is that the actions of a query optimizer are defined as a set of rewrite rules that progressively optimize expressions which define how queries can be evaluated. From our experience, the rule sets of such optimizers are rather brittle. <p> From our experience, the rule sets of such optimizers are rather brittle. If a new feature (e.g., retrieval or join algorithm) is to be added to an optimizer, it is not quite a simple matter of adding one or more rules. For example, in the Volcano rule-based optimizer <ref> [10] </ref>, rule implementations are not encapsulated. Consequently, conceptually simple modifications to a rule set often require significant effort including new function definitions to characterize the new feature. <p> Experimental results are presented that show that a layered optimizer can be just as efficient as a monolithic one. We conclude by discussing related work. 2 Prairie: A Rule Specification Language Prairie is a front-end to the Volcano <ref> [10] </ref> optimizer generator. Prairie is similar to Starburst [15] in using a rule-based approach to optimizer design in that both rely on a model of rewrite rules with corresponding actions. Prairie is different than Starburst and Volcano in using a building-blocks methodology (as described in this paper). <p> Thus, JOIN refers to the exported join operator, and JOIN CONC refers to the imported join operator. 3.2 Composing Layers As mentioned earlier, Prairie is a front-end to the Volcano search engine <ref> [10] </ref>. DBIs specify high-level rule sets in Prairie, and a preprocessor (described below) compacts and optimizes this rule set into a (low-level) form that can be efficiently processed by Volcano. The extension that we have made to Prairie is to offer an alternative to specifying monolithic rule sets.
Reference: [11] <author> Goetz Graefe. </author> <title> Query evaluation techniques for large databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(2) </volume> <pages> 73-170, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Query optimization <ref> [11, 14, 19] </ref> is a fundamental part of database systems. It is the process of generating an efficient access plan (i.e., an execution strategy) for a database query. There are three aspects that define and influence query optimization: the search space, the cost model, and the search strategy.
Reference: [12] <author> Goetz Graefe and David J. DeWitt. </author> <title> The EXODUS optimizer generator. </title> <booktitle> In Proceedings 1987 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 387-394, </pages> <address> San Fran-cisco, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: Customizability of such optimizers is almost impossible without an enormous effort by the database implementor (DBI). This difficulty has lead to the development of rule-based query optimizers, whose primary purpose is to achieve query optimizer extensibility <ref> [9, 10, 12, 13] </ref>. The basic idea is that the actions of a query optimizer are defined as a set of rewrite rules that progressively optimize expressions which define how queries can be evaluated. From our experience, the rule sets of such optimizers are rather brittle.
Reference: [13] <author> L. M. Haas, J. C. Freytag, G. M. Lohman, and H. Pirahesh. </author> <title> Extensible query processing in Starburst. </title> <type> Research Report RJ 6610, </type> <institution> IBM Almaden Research Center, </institution> <month> December </month> <year> 1988. </year>
Reference-contexts: Customizability of such optimizers is almost impossible without an enormous effort by the database implementor (DBI). This difficulty has lead to the development of rule-based query optimizers, whose primary purpose is to achieve query optimizer extensibility <ref> [9, 10, 12, 13] </ref>. The basic idea is that the actions of a query optimizer are defined as a set of rewrite rules that progressively optimize expressions which define how queries can be evaluated. From our experience, the rule sets of such optimizers are rather brittle.
Reference: [14] <author> Won Kim, David S. Reiner, and Don S. Batory, </author> <title> editors. Query Processing in Database Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: 1 Introduction Query optimization <ref> [11, 14, 19] </ref> is a fundamental part of database systems. It is the process of generating an efficient access plan (i.e., an execution strategy) for a database query. There are three aspects that define and influence query optimization: the search space, the cost model, and the search strategy.
Reference: [15] <author> Guy M. Lohman. </author> <title> Grammar-like functional rules for representing query optimization alterna tives. </title> <booktitle> In Proceedings 1988 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 18-27, </pages> <address> Chicago, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: For example, in the Volcano rule-based optimizer [10], rule implementations are not encapsulated. Consequently, conceptually simple modifications to a rule set often require significant effort including new function definitions to characterize the new feature. Modifying rule sets is actually quite important for systems like Starburst <ref> [15] </ref>, Open OODB [5], or P2 [3, 4] where adding a new feature to a DBMS involves plugging a component into the DBMS itself. 1 For obvious reasons, updating a DBMS in such a manner should not require DBIs to hack rule sets in order to make the resulting DBMS execute <p> Experimental results are presented that show that a layered optimizer can be just as efficient as a monolithic one. We conclude by discussing related work. 2 Prairie: A Rule Specification Language Prairie is a front-end to the Volcano [10] optimizer generator. Prairie is similar to Starburst <ref> [15] </ref> in using a rule-based approach to optimizer design in that both rely on a model of rewrite rules with corresponding actions. Prairie is different than Starburst and Volcano in using a building-blocks methodology (as described in this paper). <p> None of the proposals discussed in this section (except, again, for Starburst and Open OODB) describe how that is done, or even if it is possible. Starburst <ref> [15] </ref> is an optimizer that uses functional rules to allow DBIs to specify transformations of user-queries. It has two phases. The query rewrite phase generates a search space for the optimizer based on heuristic, non-cost-based transformations.
Reference: [16] <author> Gail Mitchell, Umeshwar Dayal, and Stanley B. Zdonik. </author> <title> Control of an extensible query op timizer: A planning-based approach. </title> <booktitle> In Proceedings 19th International Conference on Very Large Data Bases, </booktitle> <pages> pages 517-528, </pages> <address> Dublin, </address> <month> August </month> <year> 1993. </year> <month> 18 </month>
Reference-contexts: The algorithm for the latter is not described, so the performance of the resulting optimizer is hard to predict. Also, it is not evident whether the general nature of the framework makes it hard and difficult to use. Mitchell, Dayal, and Zdonik <ref> [16, 17] </ref> propose a framework called Epoq in which optimizers are constructed using extensible regions. A region is defined by a stated goal (e.g., lower cost, join reorder, etc.). Each region defines a control strategy that transforms a query into alternative forms based on its internal transformation rules.
Reference: [17] <author> Gail Mitchell, Stanley B. Zdonik, and Umeshwar Dayal. </author> <title> An architecture for query processing in persistent object stores. </title> <booktitle> In Proceedings of the Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 787-798, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: The algorithm for the latter is not described, so the performance of the resulting optimizer is hard to predict. Also, it is not evident whether the general nature of the framework makes it hard and difficult to use. Mitchell, Dayal, and Zdonik <ref> [16, 17] </ref> propose a framework called Epoq in which optimizers are constructed using extensible regions. A region is defined by a stated goal (e.g., lower cost, join reorder, etc.). Each region defines a control strategy that transforms a query into alternative forms based on its internal transformation rules.
Reference: [18] <author> Edward Sciore and John Sieg, Jr. </author> <title> A modular query optimizer generator. </title> <booktitle> In Proceedings 6th International Conference on Data Engineering, </booktitle> <pages> pages 146-153, </pages> <address> Los Angeles, </address> <month> February </month> <year> 1990. </year>
Reference-contexts: Without a mechanism to add or remove sets of rules and automatically generate new rule sets quickly, such systems are extremely limited in the scope and speed of customization. Sciore and Sieg <ref> [18] </ref> describe an optimizer generator model that allows a DBI to construct a rule-based optimizer using modules. Each module consists of term rewrite rules (with conditions) to transform terms in a relational algebra. Each module has exported and imported interfaces which consist of terms.
Reference: [19] <author> C. T. Yu and C. C. Chang. </author> <title> Distributed query processing. </title> <journal> ACM Computing Surveys, </journal> <volume> 16(4):399 433, </volume> <month> December </month> <year> 1984. </year> <month> 19 </month>
Reference-contexts: 1 Introduction Query optimization <ref> [11, 14, 19] </ref> is a fundamental part of database systems. It is the process of generating an efficient access plan (i.e., an execution strategy) for a database query. There are three aspects that define and influence query optimization: the search space, the cost model, and the search strategy.
References-found: 19

