URL: http://www.cs.rice.edu/CS/PLT/Publications/pldi97-ff.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Email: cormac@cs.rice.edu matthias@cs.rice.edu  
Title: Componential Set-Based Analysis  
Author: Cormac Flanagan Matthias Felleisen 
Affiliation: Rice University  
Abstract: This paper presents componential set-based analysis, which is faster and handles larger programs without any loss of accuracy over set-based analysis. The design of the analysis exploits a number of theoretical results concerning constraint systems, including a completeness result and a decision algorithm concerning the observable equivalence of constraint systems. Experimental results validate the practicality of the analysis. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aho, A., J. Hopcroft and J. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1974. </year>
Reference-contexts: The entailment algorithm takes exponential time, since the size of R is exponential in the number of set variables in S 2 . Although faster algorithms for the entailment may exist, these algorithms must all be in PSPACE, because the containment problem on NFA's, which is PSPACE-complete <ref> [1] </ref>, can be polynomially reduced to the entailment problem on constraint systems. By using the entailment algorithm in both directions, we can now decide if two constraint systems are observable equivalent.
Reference: [2] <author> Aiken, A., Wimmers, E. L., and Lakshman, T. K. </author> <title> Soft typing with conditional types. </title> <booktitle> In Proceedings of the ACM Sigplan Conference on Principles of Programming Languages (1994), </booktitle> <pages> pp. 163-173. </pages>
Reference-contexts: Unfortunately, the algorithm is PSPACE-hard. Fortunately, a minimized constraint system is only optimal but not necessary for practical purposes. The 1 A number of researchers, including Reynolds [18], Jones and Muchnick [14], Heintze [11], Aiken <ref> [2] </ref>, and Cousot and Cousot [3] previously exploited the relationship between RTGs and the least solution of a constraint system. <p> We expect that some of our theoretical and practical results as well as the techniques will carry over to other constraint-based systems, such as the conditional type system of Aiken et al. <ref> [2] </ref>, Eifrig et al.'s object-oriented type system [5], or Pottier's or Smith et al.'s subtyping simplification algorithms [17, 21]. The presentation proceeds as follows. Section 2 describes an idealized source language. Sections 3 and 4 present the theoretical underpinnings of the new analysis. <p> Following Aiken et al. and Palsberg and O'Keefe, we formulate this derivation as a subtype system <ref> [2, 16] </ref>. <p> The rule (app ) for applications propagates values from the argument expression into the domain of the applied function and from the range of that function into the result of the application expression. The rule (let ) produces a constraint schema = 8A: (ff; S) for polymorphic, let-bound values <ref> [20, 2, 23] </ref>.
Reference: [3] <author> Cousot, P., and Cousot, R. </author> <title> Formal language, grammar, and set-constraint-based program analysis by abstract interpretation. </title> <booktitle> In Proceedings of the 1995 Conference on Functional Programming and Computer Architecture (1995), </booktitle> <pages> pp. 170-181. </pages>
Reference-contexts: Unfortunately, the algorithm is PSPACE-hard. Fortunately, a minimized constraint system is only optimal but not necessary for practical purposes. The 1 A number of researchers, including Reynolds [18], Jones and Muchnick [14], Heintze [11], Aiken [2], and Cousot and Cousot <ref> [3] </ref> previously exploited the relationship between RTGs and the least solution of a constraint system. <p> the program. 3.1 The Constraint Language To simplify the derivation of the constraint simplification algorithms, we formulate our constraint language in terms of type selectors, instead of the more usual 3 Cousot and Cousot showed that set-based analysis can alternatively be formulated as an abstract interpretation computed by chaotic iteration <ref> [3] </ref>. type constructors: t 2 SetExp = ff j c j dom (t ) j rng (t ) ff; fi; fl 2 SetVar Label c 2 Const = BConst [ Tag A set expression t is either a set variable; a constant; or one of the "selector" expressions dom (t )
Reference: [4] <author> Duesterwald, E., Gupta, R., and Soffa, M. L. </author> <title> Reducing the cost of data flow analysis by congruence partitioning. </title> <booktitle> In International Conference on Compiler Construction (April 1994). </booktitle>
Reference-contexts: They describe three algorithms for simplifying constraint systems, two of which which are similar to the empty and *-removal algorithms, and the third is a special case of the Hopcroft algorithm. They do not present results on the cost or effectiveness of these algorithms. Duesterwald et al <ref> [4] </ref> describe algorithms for simplifying data flow equations. These algorithms are similar to the *-removal and Hopcroft algorithms. Their approach only preserves the greatest solution of the equation system and assumes that the control flow graph is already known.
Reference: [5] <author> Eifrig, J., Smith, S., and Trifonov, V. </author> <title> Sound polymorphic type inference for objects. </title> <booktitle> In Conference on Object-Oriented Programming Systems, Languages, and Applications (1995). </booktitle>
Reference-contexts: We expect that some of our theoretical and practical results as well as the techniques will carry over to other constraint-based systems, such as the conditional type system of Aiken et al. [2], Eifrig et al.'s object-oriented type system <ref> [5] </ref>, or Pottier's or Smith et al.'s subtyping simplification algorithms [17, 21]. The presentation proceeds as follows. Section 2 describes an idealized source language. Sections 3 and 4 present the theoretical underpinnings of the new analysis. <p> He proposes some ad hoc algorithms for simplifying constraints, but does not present results on the cost or effectiveness of these algorithms. Eifrig, Smith and Trifonov <ref> [5, 21] </ref> describe a subtyp-ing relation between constrained types that are similar to our constraint systems, and they present an incomplete decision algorithm for subtyping.
Reference: [6] <author> F ahndrich, M., and Aiken, A. </author> <title> Making set-constraint based program analyses scale. </title> <type> Technical Report UCB/CSD-96-917, </type> <institution> University of California at Berkeley, </institution> <year> 1996. </year>
Reference-contexts: With the exception of the benchmarks browse, splay and graphs, which do not re-use many functions in a polymorphic fashion, this analysis is a factor of 2 to 4 times faster than the copy analysis, and it is also capable of analyzing larger programs. 8 Competitive Work Fahndrich and Aiken <ref> [6] </ref> examine constraint simplification for an analysis based on a more complex constraint language. They develop a number of heuristic algorithms for constraint simplification, which they test on programs of up to 6000 lines.
Reference: [7] <author> Flanagan, C., and Felleisen, M. </author> <title> Set-based analysis for full Scheme and its use in soft-typing. </title> <type> Technical Report TR95-254, </type> <institution> Rice University, </institution> <year> 1995. </year>
Reference-contexts: It is straightforward to extend the analysis to a realistic language including assignments, recursive data structures, objects and modules along the lines described in an earlier report <ref> [7] </ref>. Expressions in the language are either variables, values, function applications, let-expressions, or labeled expressions: see figure 1. We use labels to identify those program expressions whose values we wish to predict. Values include basic constants and functions. <p> The process iterates until the worklist is empty, at which point S is closed under fi. The complete algorithm can be found in an earlier technical report <ref> [7] </ref>. This closure process propagates all information concerning the possible constants for labeled expressions into constraints of the form c l. Hence, we can infer sba (P ) from fi (S) according to the following theorem.
Reference: [8] <author> Flanagan, C., and Felleisen, M. </author> <title> Modular and polymorphic set-based analysis: Theory and practice. </title> <type> Technical Report TR-96-266, </type> <institution> Rice University, </institution> <year> 1996. </year>
Reference-contexts: Theorem 3.2 (Correctness of sba) If P 7! fl E [ V l ] then V in sba (P )(l). This result follows from a subject reduction proof along the lines of Wright and Felleisen [22] and Pals-berg [15] and is contained in a related report <ref> [8] </ref>. 3.5 Computing the Least Solution To compute sba (P ), we close the constraint system for P under the rules fi described in figure 3.
Reference: [9] <author> Flanagan, C., Flatt, M., Krishnamurthi, S., Weirich, S., and Felleisen, M. </author> <title> Finding bugs in the web of program invariants. </title> <booktitle> In Proceedings of the ACM Conference on Programming Language Design and Implementation (1996), </booktitle> <pages> pp. 23-32. </pages>
Reference-contexts: 1 The Effectiveness of Set-Based Analysis Rice's Scheme program development environment provides a static debugger, MrSpidey, which analyzes a program and, using the results of this analysis, checks the soundness of all computational primitives <ref> [9] </ref>. If a primitive operation may fault due to a violation of its invariant, MrSpidey highlights the program operation so that the programmer can investigate the potential fault site before running the program.
Reference: [10] <author> Flatt, M. </author> <title> MzScheme Reference Manual. </title> <institution> Rice University. </institution>
Reference-contexts: The first three algorithms are linear in the number of non-empty constraints in the system, and Hopcroft is log-linear. We tested the algorithms on the constraint systems for nine program components on a 167MHz Sparc Ultra 1 with 326M of memory, using the MzScheme byte code compiler <ref> [10] </ref>. The results are described in figure 8. The second column gives the number of lines in each program component, and the third column gives the number of constraints in the original (unsimplified) constraint system after closing it under the rules fi.
Reference: [11] <author> Heintze, N. </author> <title> Set-based analysis of ML programs. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming (1994), </booktitle> <pages> pp. 306-317. </pages>
Reference-contexts: Using the graphical explanation facilities of MrSpidey, the programmer can determine whether this fault will really happen or whether the corresponding correctness proof is beyond the analysis's capabilities. MrSpidey's program analysis is a constraint-based system similar to Heintze's set-based analysis <ref> [11] </ref>. <p> Unfortunately, the algorithm is PSPACE-hard. Fortunately, a minimized constraint system is only optimal but not necessary for practical purposes. The 1 A number of researchers, including Reynolds [18], Jones and Muchnick [14], Heintze <ref> [11] </ref>, Aiken [2], and Cousot and Cousot [3] previously exploited the relationship between RTGs and the least solution of a constraint system. <p> Under this ordering, a constraint system S has both a maximal solution ( &gt; above) and a minimal solution. The minimal solution exists because the greatest lower bound u s with respect to v s of two solutions is also a solution <ref> [11] </ref>. We use LeastSoln (S) to denote this least solution, and define set-based analysis as the function that extracts the basic constants and function tags for each labeled expression from LeastSoln (S). <p> For its first step, it eliminates all those constraints that have only local relevance, thus producing a small combined constraint system for the entire program. As a result, the analysis tool can solve the combined system more quickly and using less space than traditional set-based analysis <ref> [11] </ref>. Finally, it recreates as much precision as traditional set-based analysis as needed on a per-component basis. The new analysis performs extremely in an interactive setting because it exploits the saved constraint files where possible and thus avoids re-processing many program components unnecessarily. We implemented four variants of this analysis.
Reference: [12] <author> Hopcroft, J. E. </author> <title> An n log n algorithm for minimizing the states of a finite automaton. </title> <booktitle> The Theory of Machines and Computations (1971), </booktitle> <pages> 189-196. </pages>
Reference-contexts: Using a model-theoretic argument, we can show that an equivalence relation ~ is a valid unifier for S if 1. Use a variant of Hopcroft's algorithm <ref> [12] </ref> to compute an equivalence relation ~ on the set variables of S that satisfies the following conditions: (a) Each set variable in E is in an equivalence class by itself. (b) If [ff fi] 2 S then 8ff ~ ff 0 9fi ~ fi 0 such that [ff 0 fi <p> To produce an equivalence relation satisfying these conditions, we use a variant of Hopcroft's O (n lg n) time algorithm <ref> [12] </ref> for computing an equivalence relation on states in a DFA and then merge set variables according to their equivalence class. 6 5.5 Simplification Benchmarks To test the effectiveness of the simplification algorithms, we extended MrSpidey with the four algorithms that we have just described: empty, unreachable, *-removal , and Hopcroft
Reference: [13] <author> Jagannathan, S., and Wright, A. K. </author> <title> Effective flow analysis for avoiding run-time checks. </title> <booktitle> In Proc. 2nd International Static Analysis Symposium, LNCS 983 (September 1995), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 207-224. </pages>
Reference-contexts: We tested the analyses using a standard set of benchmarks <ref> [13] </ref>. The results of the test runs are documented in figure 10.
Reference: [14] <author> Jones, N., and Muchnick, S. </author> <title> A flexible approach to inter-procedural data flow analysis and programs with recursive data structures. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages (January 1982), </booktitle> <pages> pp. 66-74. </pages>
Reference-contexts: Unfortunately, the algorithm is PSPACE-hard. Fortunately, a minimized constraint system is only optimal but not necessary for practical purposes. The 1 A number of researchers, including Reynolds [18], Jones and Muchnick <ref> [14] </ref>, Heintze [11], Aiken [2], and Cousot and Cousot [3] previously exploited the relationship between RTGs and the least solution of a constraint system.
Reference: [15] <author> Palsberg, J. </author> <title> Closure analysis in constraint form. </title> <journal> Transactions on Programming Languages and Systems 17, </journal> <volume> 1 (1995), </volume> <pages> 47-62. </pages>
Reference-contexts: Theorem 3.2 (Correctness of sba) If P 7! fl E [ V l ] then V in sba (P )(l). This result follows from a subject reduction proof along the lines of Wright and Felleisen [22] and Pals-berg <ref> [15] </ref> and is contained in a related report [8]. 3.5 Computing the Least Solution To compute sba (P ), we close the constraint system for P under the rules fi described in figure 3.
Reference: [16] <author> Palsberg, J., and O'Keefe, P. </author> <title> A type system equivalent to flow analysis. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Principles of Programming Languages (1995), </booktitle> <pages> pp. 367-378. </pages>
Reference-contexts: This set can be formally defined as the set of total functions f : fdom; rngg fl ! P (Const), and the rest of the development can be adapted mutandis mutatis <ref> [16] </ref>. For clarity, we present our results using the more intuitive notation instead. We use the functions const : D ! P (Const) and dom, rng : D ! D to extract the respective components of an element of D. <p> Following Aiken et al. and Palsberg and O'Keefe, we formulate this derivation as a subtype system <ref> [2, 16] </ref>.
Reference: [17] <author> Pottier, F. </author> <title> Simplifying subtyping constraints. </title> <booktitle> In Proceedings of the 1996 ACM SIGPLAN International Conference on Functional Programming (1996), </booktitle> <pages> pp. 122-133. </pages>
Reference-contexts: We expect that some of our theoretical and practical results as well as the techniques will carry over to other constraint-based systems, such as the conditional type system of Aiken et al. [2], Eifrig et al.'s object-oriented type system [5], or Pottier's or Smith et al.'s subtyping simplification algorithms <ref> [17, 21] </ref>. The presentation proceeds as follows. Section 2 describes an idealized source language. Sections 3 and 4 present the theoretical underpinnings of the new analysis. Section 5 introduces practical constraint simplification algorithms and Sections 6 and 7 discuss how these algorithms perform in a realistic program analysis system. <p> They develop a number of heuristic algorithms for constraint simplification, which they test on programs of up to 6000 lines. Their fastest approach yields a factor of 3 saving in both time and space, but is slow in absolute times compared to other analyses. Pottier <ref> [17] </ref> studies an ML-style language with a subtype system based on constraints, and and presents an incomplete algorithm for deciding entailment on constraint systems. He proposes some ad hoc algorithms for simplifying constraints, but does not present results on the cost or effectiveness of these algorithms.
Reference: [18] <author> Reynolds, J. </author> <title> Automatic computation of data set defintions. </title> <booktitle> Information Processing'68 (1969), </booktitle> <pages> 456-461. </pages>
Reference-contexts: Unfortunately, the algorithm is PSPACE-hard. Fortunately, a minimized constraint system is only optimal but not necessary for practical purposes. The 1 A number of researchers, including Reynolds <ref> [18] </ref>, Jones and Muchnick [14], Heintze [11], Aiken [2], and Cousot and Cousot [3] previously exploited the relationship between RTGs and the least solution of a constraint system.
Reference: [19] <author> Shivers, O. </author> <title> Control-flow Analysis of Higher-Order Languages, or Taming Lambda. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1991. </year>
Reference: [20] <author> Tofte, M. </author> <title> Type inference for polymorphic references. </title> <booktitle> Information and Computation 89, </booktitle> <month> 1 (November </month> <year> 1990), </year> <pages> 1-34. </pages>
Reference-contexts: The rule (app ) for applications propagates values from the argument expression into the domain of the applied function and from the range of that function into the result of the application expression. The rule (let ) produces a constraint schema = 8A: (ff; S) for polymorphic, let-bound values <ref> [20, 2, 23] </ref>.
Reference: [21] <author> Trifonov, V., and Smith, S. </author> <title> Subtyping constrained types. </title> <booktitle> In Third International Static Analysis Symposium (LNCS 1145) (1996), </booktitle> <pages> pp. 349-365. </pages>
Reference-contexts: We expect that some of our theoretical and practical results as well as the techniques will carry over to other constraint-based systems, such as the conditional type system of Aiken et al. [2], Eifrig et al.'s object-oriented type system [5], or Pottier's or Smith et al.'s subtyping simplification algorithms <ref> [17, 21] </ref>. The presentation proceeds as follows. Section 2 describes an idealized source language. Sections 3 and 4 present the theoretical underpinnings of the new analysis. Section 5 introduces practical constraint simplification algorithms and Sections 6 and 7 discuss how these algorithms perform in a realistic program analysis system. <p> He proposes some ad hoc algorithms for simplifying constraints, but does not present results on the cost or effectiveness of these algorithms. Eifrig, Smith and Trifonov <ref> [5, 21] </ref> describe a subtyp-ing relation between constrained types that are similar to our constraint systems, and they present an incomplete decision algorithm for subtyping.
Reference: [22] <author> Wright, A., and Felleisen, M. </author> <title> A syntactic approach to type soundness. </title> <booktitle> Information and Computation 115, 1 (1994), </booktitle> <pages> 38-94. </pages>
Reference-contexts: Theorem 3.2 (Correctness of sba) If P 7! fl E [ V l ] then V in sba (P )(l). This result follows from a subject reduction proof along the lines of Wright and Felleisen <ref> [22] </ref> and Pals-berg [15] and is contained in a related report [8]. 3.5 Computing the Least Solution To compute sba (P ), we close the constraint system for P under the rules fi described in figure 3.
Reference: [23] <author> Wright, A. K. </author> <title> Simple imperative polymorphism. </title> <booktitle> Lisp and Symbolic Computation 8, </booktitle> <month> 4 (Dec. </month> <year> 1995), </year> <pages> 343-356. </pages>
Reference-contexts: Values include basic constants and functions. Functions have identifying tags so that MrSpidey can reconstruct a call-graph from the results of the analysis. We use let-expressions to introduce polymorphic bindings, and hence restrict these bindings to syntactic values <ref> [23] </ref>. We work with the usual conventions and terminology of the v -calculus when discussing syntactic issues. <p> The rule (app ) for applications propagates values from the argument expression into the domain of the applied function and from the range of that function into the result of the application expression. The rule (let ) produces a constraint schema = 8A: (ff; S) for polymorphic, let-bound values <ref> [20, 2, 23] </ref>.
References-found: 23

