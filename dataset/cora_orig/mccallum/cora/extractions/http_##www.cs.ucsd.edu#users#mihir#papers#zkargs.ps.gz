URL: http://www.cs.ucsd.edu/users/mihir/papers/zkargs.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/mihir/papers/zkargs.html
Root-URL: http://www.cs.ucsd.edu
Email: E-mail: mihir@cs.ucsd.edu.  E-mail: markus@cs.ucsd.edu.  E-mail: moti@certco.com  
Title: Zero-Knowledge Arguments Based on any One-Way Function  
Author: Mihir Bellare Markus Jakobsson Moti Yung 
Address: San Diego, 9500 Gilman Drive, La Jolla, CA 92093, USA.  San Diego, 9500 Gilman Drive, La Jolla, CA 92093, USA.  CertCo, New York, NY, USA.  
Affiliation: Department of Computer Science Engineering, Mail Code 0114, University of California at  Science and Engineering. Department of Computer Science Engineering, Mail Code 0114, University of California at  
Date: July 1997  
Note: Round-Optimal  Supported in part by NSF CAREER Award CCR-9624439 and a Packard Foundation Fellowship in  
Abstract: A preliminary version of this paper appeared in Advances in Cryptology - Eurocrypt 97 Proceed--ings, Lecture Notes in Computer Science Vol. 1233, W. Fumy ed., Springer-Verlag, 1997. This is a revised version. Abstract We fill a gap in the theory of zero-knowledge protocols by presenting NP-arguments that achieve negligible error probability and computational zero-knowledge in four rounds of interaction, assuming only the existence of a one-way function. This result is optimal in the sense that four rounds and a one-way function are each individually necessary to achieve a negligible error zero-knowledge argument for NP. 
Abstract-found: 1
Intro-found: 1
Reference: [Be] <author> M. Bellare. </author> <title> A note on negligible functions. </title> <type> Technical Report CS97-529, </type> <institution> Department of Computer Science and Engineering, University of California at San Diego, </institution> <month> March </month> <year> 1997. </year> <note> Available at http://www-cse.ucsd.edu/users/mihir. </note>
Reference-contexts: However under such a definition there is no particular function we can actually call the error-probability of the protocol. Accordingly, we prefer the definition above. But it turns out that the notions are equivalent <ref> [Be] </ref>. This equivalence, captured in the following Proposition, will be instrumental in some of our proofs. Proposition 2.2 [Be] Let be an NP-relation. <p> Accordingly, we prefer the definition above. But it turns out that the notions are equivalent <ref> [Be] </ref>. This equivalence, captured in the following Proposition, will be instrumental in some of our proofs. Proposition 2.2 [Be] Let be an NP-relation. <p> See [BeGo] for the proof that these two notions are equivalent. Sometimes it is convenient to use one, sometimes the other. Also see <ref> [Be] </ref> for some issues relating to the case of negligible knowledge error and alternative ways to define it. 2.4 Zero-knowledge Ensembles and computational indistinguishability. We recall these notions of [GoMi, GMR]. <p> Again this definition is actually different from the standard one: the latter allows the inversion probability of each inverter to be a different negligible function. However, the two notions are equivalent <ref> [Be] </ref>. Hereafter we fix a one-way function f , and the notation f will always refer to this fixed function. 3.2 Formulas and satisfiability We will present ZK arguments for the NP-complete language SAT . <p> We must show that this implies f is not one-way. We will not give the construction and proof for this last statement in full because the idea is essentially the same as in the proof of Lemma 4.3. We begin by applying <ref> [Be] </ref> to be able to work with a function that is not negligible. We use the composite of E b P 1 as an algorithm to construct an inverter for f .
Reference: [BeGo] <author> M. Bellare and O. Goldreich. </author> <title> On Defining Proofs of Knowledge. </title> <booktitle> Advances in Cryptology - Crypto 92 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 740, </volume> <editor> E. Brickell ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Like soundness, in proofs it holds for arbitrary provers and in arguments for polynomial time ones. (The notion was suggested in [GMR], and an appropriate formalization has emerged in <ref> [BeGo] </ref>. See Section 2.3 for more.) Again, we will not discuss it further here, concentrating just on the two dimensions mentioned above. Four kinds of protocols. Since the dimensions discussed above are orthogonal, we get four kinds of protocols: * CZK arguments: Computationally convincing, computational ZK. <p> It turns out the technically more challenging part is to prove computational soundness. We introduce what seems to be a new technique, proving the soundness by using proofs of knowledge, relying on the strong formulation of the latter given in <ref> [BeGo] </ref>. 1.4 Open problems We have filled the (small) existing gap between upper and lower bounds for CZK arguments. For other protocol categories, the existing gap is larger and still unfilled. <p> This notion of a "proof of knowledge" was suggested in [GMR]. It was formalized in <ref> [BeGo] </ref> both for the standard interactive proof setting and the argument, or computationally convincing setting. (They discuss the latter in [BeGo, Section 4.7].) We adopt their notion. It comes in two equivalent forms. We present both. <p> This notion of a "proof of knowledge" was suggested in [GMR]. It was formalized in [BeGo] both for the standard interactive proof setting and the argument, or computationally convincing setting. (They discuss the latter in <ref> [BeGo, Section 4.7] </ref>.) We adopt their notion. It comes in two equivalent forms. We present both. Recall an oracle algorithm E is an algorithm that can be equipped with an oracle. An invocation of the oracle counts as one step. <p> We will talk of an "extractor" E which will be given an oracle for b P x , a prover algorithm on input x, and will then try to find a witness w to the membership of x in L . The first definition below is what <ref> [BeGo] </ref> refer to as the "alternative form of validity." Definition 2.3 [BeGo] We say that verifier V defines a computational proof of knowledge for NP-relation , with knowledge-error (), if there is a an expected polynomial time oracle algorithm E (the extractor) such that for every polynomial time interactive algorithm b <p> The first definition below is what <ref> [BeGo] </ref> refer to as the "alternative form of validity." Definition 2.3 [BeGo] We say that verifier V defines a computational proof of knowledge for NP-relation , with knowledge-error (), if there is a an expected polynomial time oracle algorithm E (the extractor) such that for every polynomial time interactive algorithm b P there is a constant N b P such that if <p> Again, note negligible knowledge error means the above is true for some negligible function (). In the next formulation (the main one of <ref> [BeGo] </ref>) the extractor must find a witness with probability one. It is not limited to (expected) polynomial time, but must run in time inversely proportional to the excess of the accepting probability over the knowledge error. Definition 2.4 [BeGo] We say that verifier V defines a computational proof of knowledge for <p> In the next formulation (the main one of <ref> [BeGo] </ref>) the extractor must find a witness with probability one. It is not limited to (expected) polynomial time, but must run in time inversely proportional to the excess of the accepting probability over the knowledge error. Definition 2.4 [BeGo] We say that verifier V defines a computational proof of knowledge for NP-relation , with knowledge-error (), if there is a an oracle algorithm E (the extractor) and a constant c such that for every polynomial time interactive algorithm b P there is a constant N b P such that <p> See <ref> [BeGo] </ref> for the proof that these two notions are equivalent. Sometimes it is convenient to use one, sometimes the other. Also see [Be] for some issues relating to the case of negligible knowledge error and alternative ways to define it. 2.4 Zero-knowledge Ensembles and computational indistinguishability. <p> We claim that if a prover A convinces V to accept ' then we can extract a satisfying assignment for fi, regardless of whether or not ' is satisfiable. Furthermore, this extraction can be done to meet the kinds of conditions asked in the definition of <ref> [BeGo] </ref>. This will help prove both the above mentioned claims, and, as motivation, it may help to say why. Roughly, an assignment to corresponds to knowledge of inverses of f on random points. But remember fi = ' _ . <p> Each try being poly (n) time, we have the claimed time bound on the expected running time of E 1 . Finally, we need to specify the extractor E claimed in the lemma. We apply a trick used in <ref> [BeGo] </ref> to prove the equivalence of Definitions 2.3 and 2.4.
Reference: [BMO1] <author> M. Bellare, S. Micali and R. Ostrovsky. </author> <title> Perfect Zero-Knowledge in Constant Rounds. </title> <booktitle> Proceedings of the 22nd Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1990. </year>
Reference-contexts: The strongest kind, but not possible for all of NP unless the polynomial time hierarchy collapses [Fo]. But there are examples for special languages: quadratic residuosity and its complement [GMR]; graph isomorphism and its complement [GMW]; constant round SZK proofs for quadratic residuosity and graph isomorphism <ref> [BMO1] </ref>. 1.2 Complexity measures and optimality Recall that the error-probability is the probability *() in the soundness condition, whether in a proof or an argument. Most atomic ZK protocols have constant error. But one really wants low error. <p> If this check fails S cannot abort or output this conversation. (One can check this would lead to an incorrect simulation.) Instead, it must return to Step 4 and try again, continuing this loop until the check does pass. (This is a standard procedure, used for example in <ref> [BMO1] </ref>, and as there one can show that the expected number of tries in this process is at most 2.) So we go on assuming the check did pass. (6) Having a satisfying assignment T to fi, the simulator (now in guise of the prover) is able to answer the challenges
Reference: [BMO2] <author> M. Bellare, S. Micali and R. Ostrovsky. </author> <title> The true complexity of statistical zero-Knowledge. </title> <booktitle> Proceedings of the 22nd Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1990. </year>
Reference-contexts: We want to meet this bound given only a one-way function. Remark. The above notion of black-box simulation zero-knowledge is stronger than those of <ref> [GoOr, GoKr, BMO2] </ref> in the following sense. In our notion, the simulator has no control over the coins R of b V x : they are automatically chosen (at random) and then fixed. <p> In the notions of [GoOr, GoKr], the simulator could choose these coins as it liked, even try running b V x on many different random tapes. In the notion of <ref> [BMO2] </ref> it could not choose them, but did have direct access to them, and could try several random tapes. However, since our results are positive, making a more stringent definition only strengthens them.
Reference: [BeYu] <author> M. Bellare and M. Yung. </author> <title> Certifying permutations: Non-interactive zero-knowledge based on any trapdoor permutation. </title> <journal> Journal of Cryptology, </journal> <volume> Vol. 9, No. 1, </volume> <pages> pp. 149-166, </pages> <month> Winter </month> <year> 1996. </year>
Reference-contexts: function Combine [GMW, HILL, Na] CZK proof !(log n) Algebraic [BrCr, BCC] SZK argument poly (n) One-way permutation [NOVY] SZK argument 6 Claw-free pairs [BCY] SZK argument 6 Claw-free pairs [GoKa] CZK proof 5 One-way function [FeSh] CZK argument 4 Algebraic [FeSh] CZK argument 4 Trapdoor perm. + Algebraic Combine <ref> [Bl, FLS, BeYu] </ref> CZK argument 4 One-way function This paper CZK argument type (CZK or SZK, proof or argument). Remember four rounds is optimal. * Assumptions: The complexity assumption underlying the protocol, it underlies either the computational ZK or the computational conviction (or both). <p> So one must build low error ZK protocols directly. 5 Previous work. A good deal of effort has gone into this, and a variety of ingenious constructions have been proposed. We summarize the known results in Figure 1. (One that may need elaboration is the protocol of <ref> [Bl, FLS, BeYu] </ref>. We discuss it briefly in Appendix A.) Notice that prior to our work optimality had not been achieved in any protocol category. That is, neither for CZK arguments, SZK arguments or CZK proofs did we have four round, low error protocols based on any one-way function. <p> Recall prover P begins with a witness w to x. The view generated by P and V depends not just on P but on w. An elegant way to bring this into the picture is via the notion of a witness selector <ref> [BeYu] </ref>. Definition 2.5 [BeYu] A witness selector for an NP-relation is a map W : L ! f0; 1g fl with the property that W (x) 2 (x) for each x 2 L . <p> Recall prover P begins with a witness w to x. The view generated by P and V depends not just on P but on w. An elegant way to bring this into the picture is via the notion of a witness selector <ref> [BeYu] </ref>. Definition 2.5 [BeYu] A witness selector for an NP-relation is a map W : L ! f0; 1g fl with the property that W (x) 2 (x) for each x 2 L .
Reference: [Bl] <author> M. Blum. </author> <title> Coin Flipping over the Telephone. </title> <booktitle> IEEE COMPCON 1982, </booktitle> <pages> pp. 133-137. </pages>
Reference-contexts: function Combine [GMW, HILL, Na] CZK proof !(log n) Algebraic [BrCr, BCC] SZK argument poly (n) One-way permutation [NOVY] SZK argument 6 Claw-free pairs [BCY] SZK argument 6 Claw-free pairs [GoKa] CZK proof 5 One-way function [FeSh] CZK argument 4 Algebraic [FeSh] CZK argument 4 Trapdoor perm. + Algebraic Combine <ref> [Bl, FLS, BeYu] </ref> CZK argument 4 One-way function This paper CZK argument type (CZK or SZK, proof or argument). Remember four rounds is optimal. * Assumptions: The complexity assumption underlying the protocol, it underlies either the computational ZK or the computational conviction (or both). <p> So one must build low error ZK protocols directly. 5 Previous work. A good deal of effort has gone into this, and a variety of ingenious constructions have been proposed. We summarize the known results in Figure 1. (One that may need elaboration is the protocol of <ref> [Bl, FLS, BeYu] </ref>. We discuss it briefly in Appendix A.) Notice that prior to our work optimality had not been achieved in any protocol category. That is, neither for CZK arguments, SZK arguments or CZK proofs did we have four round, low error protocols based on any one-way function.
Reference: [BDMP] <author> M. Blum, A. De Santis, S. Micali, and G. Persiano. </author> <title> Non-Interactive Zero-Knowledge Proof Systems. </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 20, No. 6, </volume> <month> December </month> <year> 1991, </year> <pages> pp. 1084-1118. </pages>
Reference: [BlMi] <author> M. Blum and S. Micali. </author> <title> How to generate cryptographically strong sequences of pseudo-random bits. </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 13, No. 4, </volume> <pages> pp. 850-864, </pages> <month> November </month> <year> 1984. </year> <month> 22 </month>
Reference-contexts: Then, A picks at random some string s to use as coins, and computes a function ff = Commit f (R; d; s). (This function depends on a pseudorandom bit generator <ref> [BlMi, Ya] </ref>, constructed out of f via [HILL], but we don't need to know that.) This ff is A's commitment to d and is sent to B.
Reference: [BrCr] <author> G. Brassard and C. Cr epeau. </author> <title> Non-transitive Transfer of Confidence: A perfect Zero--knowledge Interactive protocol for SAT and Beyond. </title> <booktitle> Proceedings of the 27th Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1986. </year>
Reference-contexts: Even a computationally unrestricted prover should be unable to make the verifier accept x 62 L, except with probability *(n). Protocols providing this strong degree of conviction are usually called "proofs." Computational conviction: This is the notion of <ref> [BrCr, BCC] </ref>. <p> See Definition 2.1 and the following discussion. 3 as a sub-case of statistical. A note on completeness. In addition, a basic completeness condition is always required. It asks that if x 2 L then there is a strategy via which the prover can make V accept. The definition of <ref> [BrCr, BCC] </ref> asks (as appropriate for a cryptographic protocol) that this be efficiently achievable: if P is given a witness for the membership of x in the NP language L then it can make V accept in polynomial time. The definition of [GMR] does not make such a requirement. <p> Four kinds of protocols. Since the dimensions discussed above are orthogonal, we get four kinds of protocols: * CZK arguments: Computationally convincing, computational ZK. The weakest kind, but still adequate for cryptographic protocols. For example the arguments for all of NP in <ref> [BrCr, BCC] </ref> when a standard bit commitment is used. * CZK proofs: Statistically convincing, computational ZK. For example the proofs for all of NP in [GMW]. * SZK arguments: Computationally convincing, statistical ZK. For example the arguments for all of NP in [BrCr, BCC] when a discrete logarithm based bit commitment <p> example the arguments for all of NP in <ref> [BrCr, BCC] </ref> when a standard bit commitment is used. * CZK proofs: Statistically convincing, computational ZK. For example the proofs for all of NP in [GMW]. * SZK arguments: Computationally convincing, statistical ZK. For example the arguments for all of NP in [BrCr, BCC] when a discrete logarithm based bit commitment is used; also [NOVY]. * SZK proofs: Statistically convincing, statistical ZK. The strongest kind, but not possible for all of NP unless the polynomial time hierarchy collapses [Fo]. <p> Some works like [FeSh] call this a move, and say a round is two consecutive moves. In their terminology, our four round protocols would be four move or two round protocols. 4 Rounds Assumption Reference Type poly (n) One-way function Combine [GMW, HILL, Na] CZK proof !(log n) Algebraic <ref> [BrCr, BCC] </ref> SZK argument poly (n) One-way permutation [NOVY] SZK argument 6 Claw-free pairs [BCY] SZK argument 6 Claw-free pairs [GoKa] CZK proof 5 One-way function [FeSh] CZK argument 4 Algebraic [FeSh] CZK argument 4 Trapdoor perm. + Algebraic Combine [Bl, FLS, BeYu] CZK argument 4 One-way function This paper CZK
Reference: [BCC] <author> G. Brassard, D. Chaum and C. Cr epeau. </author> <title> Minimum Disclosure Proofs of Knowledge. </title> <journal> J. Computer and System Sciences, </journal> <volume> Vol. 37, </volume> <year> 1988, </year> <pages> pp. 156-189. </pages>
Reference-contexts: Even a computationally unrestricted prover should be unable to make the verifier accept x 62 L, except with probability *(n). Protocols providing this strong degree of conviction are usually called "proofs." Computational conviction: This is the notion of <ref> [BrCr, BCC] </ref>. <p> See Definition 2.1 and the following discussion. 3 as a sub-case of statistical. A note on completeness. In addition, a basic completeness condition is always required. It asks that if x 2 L then there is a strategy via which the prover can make V accept. The definition of <ref> [BrCr, BCC] </ref> asks (as appropriate for a cryptographic protocol) that this be efficiently achievable: if P is given a witness for the membership of x in the NP language L then it can make V accept in polynomial time. The definition of [GMR] does not make such a requirement. <p> Four kinds of protocols. Since the dimensions discussed above are orthogonal, we get four kinds of protocols: * CZK arguments: Computationally convincing, computational ZK. The weakest kind, but still adequate for cryptographic protocols. For example the arguments for all of NP in <ref> [BrCr, BCC] </ref> when a standard bit commitment is used. * CZK proofs: Statistically convincing, computational ZK. For example the proofs for all of NP in [GMW]. * SZK arguments: Computationally convincing, statistical ZK. For example the arguments for all of NP in [BrCr, BCC] when a discrete logarithm based bit commitment <p> example the arguments for all of NP in <ref> [BrCr, BCC] </ref> when a standard bit commitment is used. * CZK proofs: Statistically convincing, computational ZK. For example the proofs for all of NP in [GMW]. * SZK arguments: Computationally convincing, statistical ZK. For example the arguments for all of NP in [BrCr, BCC] when a discrete logarithm based bit commitment is used; also [NOVY]. * SZK proofs: Statistically convincing, statistical ZK. The strongest kind, but not possible for all of NP unless the polynomial time hierarchy collapses [Fo]. <p> Some works like [FeSh] call this a move, and say a round is two consecutive moves. In their terminology, our four round protocols would be four move or two round protocols. 4 Rounds Assumption Reference Type poly (n) One-way function Combine [GMW, HILL, Na] CZK proof !(log n) Algebraic <ref> [BrCr, BCC] </ref> SZK argument poly (n) One-way permutation [NOVY] SZK argument 6 Claw-free pairs [BCY] SZK argument 6 Claw-free pairs [GoKa] CZK proof 5 One-way function [FeSh] CZK argument 4 Algebraic [FeSh] CZK argument 4 Trapdoor perm. + Algebraic Combine [Bl, FLS, BeYu] CZK argument 4 One-way function This paper CZK <p> To avoid depending on the details of any specific protocol, it is described via generic components and steps. The protocol. In the literature there are several commitment-based three round ZK arguments with error 1=2. For concreteness, take the one of Brassard, Crepeau and Chaum <ref> [BCC] </ref>, or the one based on general commitment in [ImYu]. To set it up using one-way function based commitment, we first have the verifier send a commitment setup string, and then run a protocol such as the ones in [BCC, ImYu], so that we have four rounds. <p> For concreteness, take the one of Brassard, Crepeau and Chaum [BCC], or the one based on general commitment in [ImYu]. To set it up using one-way function based commitment, we first have the verifier send a commitment setup string, and then run a protocol such as the ones in <ref> [BCC, ImYu] </ref>, so that we have four rounds. To avoid depending on the details of any specific underlying protocol, we describe the protocol via generic components and steps. Let fi denote the boolean formula which is the common input. <p> The answer being sent to the verifier, the latter checks that it is correct. The check is a function of the encapsulated circuit, the commitment setup string, the challenge, and the answer provided. Properties. We assume certain properties of this protocol. The standard example protocols (eg. <ref> [BCC] </ref>) do have these properties. We assume that if an encapsulated circuit C is successfully "opened" in both ways, ie. for both a 0-challenge and a 1-challenge, then one can obtain the truth assignment underlying fi.
Reference: [BCY] <author> G. Brassard, C. Cr epeau and M. Yung. </author> <title> Constant round perfect zero knowledge computa-tionally convincing protocols. </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. 84, No. 1, </volume> <year> 1991. </year>
Reference-contexts: The system has two dimensions: "conviction" and "zero-knowledge." Each can be formalized in one of two ways, a weak and a strong, depending on whether or not we restrict the adversary involved to polynomial time. To describe these dimensions, we use a terminology from <ref> [BCY] </ref> (which they credit to Chaum). Degrees of conviction. Conviction is about "soundness." If x 62 L we ask that no matter how the prover behaves, it cannot convince V to accept, except with low probability (called the error probability, and denoted *()). <p> In their terminology, our four round protocols would be four move or two round protocols. 4 Rounds Assumption Reference Type poly (n) One-way function Combine [GMW, HILL, Na] CZK proof !(log n) Algebraic [BrCr, BCC] SZK argument poly (n) One-way permutation [NOVY] SZK argument 6 Claw-free pairs <ref> [BCY] </ref> SZK argument 6 Claw-free pairs [GoKa] CZK proof 5 One-way function [FeSh] CZK argument 4 Algebraic [FeSh] CZK argument 4 Trapdoor perm. + Algebraic Combine [Bl, FLS, BeYu] CZK argument 4 One-way function This paper CZK argument type (CZK or SZK, proof or argument).
Reference: [FFS] <author> U. Feige, A. Fiat, and A. Shamir. </author> <title> Zero-Knowledge Proofs of Identity. </title> <journal> Journal of Cryptology, </journal> <volume> Vol. 1, </volume> <year> 1988, </year> <pages> pp. 77-94. </pages>
Reference: [FLS] <author> U. Feige, D. Lapidot, and A. Shamir. </author> <title> Multiple Non-Interactive Zero-Knowledge Proofs Based on a Single Random String. </title> <booktitle> Proceedings of the 31st Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1990. </year>
Reference-contexts: function Combine [GMW, HILL, Na] CZK proof !(log n) Algebraic [BrCr, BCC] SZK argument poly (n) One-way permutation [NOVY] SZK argument 6 Claw-free pairs [BCY] SZK argument 6 Claw-free pairs [GoKa] CZK proof 5 One-way function [FeSh] CZK argument 4 Algebraic [FeSh] CZK argument 4 Trapdoor perm. + Algebraic Combine <ref> [Bl, FLS, BeYu] </ref> CZK argument 4 One-way function This paper CZK argument type (CZK or SZK, proof or argument). Remember four rounds is optimal. * Assumptions: The complexity assumption underlying the protocol, it underlies either the computational ZK or the computational conviction (or both). <p> So one must build low error ZK protocols directly. 5 Previous work. A good deal of effort has gone into this, and a variety of ingenious constructions have been proposed. We summarize the known results in Figure 1. (One that may need elaboration is the protocol of <ref> [Bl, FLS, BeYu] </ref>. We discuss it briefly in Appendix A.) Notice that prior to our work optimality had not been achieved in any protocol category. That is, neither for CZK arguments, SZK arguments or CZK proofs did we have four round, low error protocols based on any one-way function.
Reference: [FeSh] <author> U. Feige and A. Shamir. </author> <title> Witness Indistinguishable and Witness Hiding Protocols. </title> <booktitle> Proceedings of the 22nd Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1990. </year>
Reference-contexts: Two main ones are: * Rounds: The round complexity is the number of messages exchanged, or rounds of interaction in the protocol. 2 2 There may be some danger of confusion in terminology. We call each sending of a message by a party a round. Some works like <ref> [FeSh] </ref> call this a move, and say a round is two consecutive moves. <p> four move or two round protocols. 4 Rounds Assumption Reference Type poly (n) One-way function Combine [GMW, HILL, Na] CZK proof !(log n) Algebraic [BrCr, BCC] SZK argument poly (n) One-way permutation [NOVY] SZK argument 6 Claw-free pairs [BCY] SZK argument 6 Claw-free pairs [GoKa] CZK proof 5 One-way function <ref> [FeSh] </ref> CZK argument 4 Algebraic [FeSh] CZK argument 4 Trapdoor perm. + Algebraic Combine [Bl, FLS, BeYu] CZK argument 4 One-way function This paper CZK argument type (CZK or SZK, proof or argument). <p> protocols. 4 Rounds Assumption Reference Type poly (n) One-way function Combine [GMW, HILL, Na] CZK proof !(log n) Algebraic [BrCr, BCC] SZK argument poly (n) One-way permutation [NOVY] SZK argument 6 Claw-free pairs [BCY] SZK argument 6 Claw-free pairs [GoKa] CZK proof 5 One-way function <ref> [FeSh] </ref> CZK argument 4 Algebraic [FeSh] CZK argument 4 Trapdoor perm. + Algebraic Combine [Bl, FLS, BeYu] CZK argument 4 One-way function This paper CZK argument type (CZK or SZK, proof or argument). <p> We look at low error CZK arguments for all of NP. Figure 1 tells us that it is possible to do it in four rounds using an algebraic assumption (hardness of discrete log) <ref> [FeSh] </ref>; or in five rounds using a one-way function [FeSh]. This leaves a (small but noticeable) gap, which we fill: we provide an optimal protocol, that uses only four rounds and a one-way function. Theorem 1.1 Suppose there exists a one-way function. <p> We look at low error CZK arguments for all of NP. Figure 1 tells us that it is possible to do it in four rounds using an algebraic assumption (hardness of discrete log) <ref> [FeSh] </ref>; or in five rounds using a one-way function [FeSh]. This leaves a (small but noticeable) gap, which we fill: we provide an optimal protocol, that uses only four rounds and a one-way function. Theorem 1.1 Suppose there exists a one-way function. <p> Techniques. Our protocol is for the NP-complete language SAT . Let ' be the input formula. We use the idea of Feige and Shamir <ref> [FeSh] </ref> of ORing to ' some formula which represents some choices of the verifier, and then having the prover run a standard ZK proof on input fi = ' _ . However, Feige and Shamir [FeSh] begin their protocol by having the verifier give a witness indistinguishable proof of knowledge of <p> Let ' be the input formula. We use the idea of Feige and Shamir <ref> [FeSh] </ref> of ORing to ' some formula which represents some choices of the verifier, and then having the prover run a standard ZK proof on input fi = ' _ . However, Feige and Shamir [FeSh] begin their protocol by having the verifier give a witness indistinguishable proof of knowledge of something underlying . Instead, we work directly with the one-way function, having the verifier give a cut-and-choose type proof that meets some conditions. This is interleaved with a standard ZK proof run on fi. <p> (Of course, a prover providing such an encapsulated circuit will be hard put to answer the challenges, but that will not matter for us.) Finally, of course, we also need that the protocol is ZK. (Actually, all we will use is that it is witness indistinguishable in the sense of <ref> [FeSh] </ref>, something which follows from its being ZK.) 4 Protocol 4R-ZK and its properties We now describe our protocol and its properties. We call the protocol 4R-ZK for "four round ZK." 4.1 Protocol description We give instructions for the prover P and the verifier V to execute protocol 4R-ZK. <p> This is not necessarily a satisfying assignment for '. Still, we can "mimic the prover" by using this assignment in the atomic protocol. The verifier will never know it was not an assignment to ', because the proof is ZK and hence witness indistinguishable <ref> [FeSh] </ref>: views of the verifier for different witnesses held by the prover are indistinguishable. So if the simulator can find a satisfying assignment to fi it can complete a simulation. <p> But since the atomic protocol is ZK it is also witness indistinguishable in the sense of <ref> [FeSh] </ref>. Furthermore, they show that witness indistinguishability is preserved under parallel repetition, so the protocol consisting of n parallel repetitions of the atomic protocol is also witness indistinguishable. So the transcripts produced for the two different witnesses in protocol 4R-ZK have (computationally) indistinguishable distributions.
Reference: [Fo] <author> L. Fortnow. </author> <title> The Complexity of Perfect Zero-Knowledge. </title> <booktitle> In Advances in Computing Research, </booktitle> <editor> Ed. S. Micali, </editor> <volume> Vol. 18, </volume> <year> 1989. </year>
Reference-contexts: For example the arguments for all of NP in [BrCr, BCC] when a discrete logarithm based bit commitment is used; also [NOVY]. * SZK proofs: Statistically convincing, statistical ZK. The strongest kind, but not possible for all of NP unless the polynomial time hierarchy collapses <ref> [Fo] </ref>.
Reference: [Go] <author> O. Goldreich. </author> <title> Foundations of cryptography: Fragments of a book. </title> <institution> Weizmann Institute of Science, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: This is necessary, as the discussion below explains. Note we say the system has negligible error as long as there is some negligible function *() such that the error is *(). This definition of a negligible error argument differs from previous ones like <ref> [Go, NOVY] </ref>, where the error corresponding to each prover is allowed to be a different negligible function, depending on the prover. However under such a definition there is no particular function we can actually call the error-probability of the protocol. Accordingly, we prefer the definition above. <p> In particular it is reasonable to ask that for each b P the error eventually goes below the desired error-probability *(n), which is what we did above. (For the case of error 1=3 the same definition is given in <ref> [Go] </ref>. However the latter adopts a different approach to negligible error as discussed above.) In particular, the probability of convincing the verifier to accept x 62 L in a computationally convincing proof cannot be reasonably expected to be exponentially small.
Reference: [GoKa] <author> O. Goldreich and A. Kahan. </author> <title> How to Construct Constant-Round Zero-Knowledge Proof Systems for NP. </title> <journal> Journal of Cryptology, </journal> <volume> Vol. 9, No. 3, </volume> <year> 1996, </year> <pages> pp. 167-190. </pages>
Reference-contexts: our four round protocols would be four move or two round protocols. 4 Rounds Assumption Reference Type poly (n) One-way function Combine [GMW, HILL, Na] CZK proof !(log n) Algebraic [BrCr, BCC] SZK argument poly (n) One-way permutation [NOVY] SZK argument 6 Claw-free pairs [BCY] SZK argument 6 Claw-free pairs <ref> [GoKa] </ref> CZK proof 5 One-way function [FeSh] CZK argument 4 Algebraic [FeSh] CZK argument 4 Trapdoor perm. + Algebraic Combine [Bl, FLS, BeYu] CZK argument 4 One-way function This paper CZK argument type (CZK or SZK, proof or argument).
Reference: [GoKr] <author> O. Goldreich and H. Krawczyk. </author> <title> On the Composition of Zero Knowledge Proof Systems. </title> <journal> SIAM J. on Computing, </journal> <volume> Vol. 25, No. 1, </volume> <pages> pp. 169-192, </pages> <year> 1996. </year>
Reference-contexts: Lower bounds. We know that things can't go too low. Four rounds and a one-way function are each individually necessary to get low-error ZK: * Four rounds needed: Goldreich and Krawczyk <ref> [GoKr] </ref> show that there do not exist three round, negligible error (whether proof or argument) ZK (whether computational or statistical) protocols for NP unless NP BPP. (There is a technical condition saying the ZK must be of a certain form called black-box. <p> Serial repetition lowers the error and preserves ZK [GoOr, ToWo], but at the cost of increasing the number of rounds to non-constant. So we would like to do parallel repetition. However, this is ruled out: first, we have the above mentioned results of <ref> [GoKr] </ref>; second, the latter also showed that in general parallel repetition does not preserve ZK. So one must build low error ZK protocols directly. 5 Previous work. A good deal of effort has gone into this, and a variety of ingenious constructions have been proposed. <p> Note formally, zero-knowledge is no longer a property of the language L but of the relation itself. Under this definition of zero-knowledge, we know that any negligible error probability zero-knowledge argument for an NP-complete relation must have at least four rounds, assuming NP is not in BPP <ref> [GoKr] </ref>. We want to meet this bound given only a one-way function. Remark. The above notion of black-box simulation zero-knowledge is stronger than those of [GoOr, GoKr, BMO2] in the following sense. <p> We want to meet this bound given only a one-way function. Remark. The above notion of black-box simulation zero-knowledge is stronger than those of <ref> [GoOr, GoKr, BMO2] </ref> in the following sense. In our notion, the simulator has no control over the coins R of b V x : they are automatically chosen (at random) and then fixed. <p> The simulator does not even have direct access to them: it just gets an oracle for b V x;R . In the notions of <ref> [GoOr, GoKr] </ref>, the simulator could choose these coins as it liked, even try running b V x on many different random tapes. In the notion of [BMO2] it could not choose them, but did have direct access to them, and could try several random tapes.
Reference: [GMW] <author> O. Goldreich, S. Micali and A. Wigderson. </author> <title> Proofs that yield nothing but their validity or all languages in NP have zero knowledge proof systems. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> Vol. 38, No. 1, </volume> <month> July </month> <year> 1991. </year>
Reference-contexts: The weakest kind, but still adequate for cryptographic protocols. For example the arguments for all of NP in [BrCr, BCC] when a standard bit commitment is used. * CZK proofs: Statistically convincing, computational ZK. For example the proofs for all of NP in <ref> [GMW] </ref>. * SZK arguments: Computationally convincing, statistical ZK. For example the arguments for all of NP in [BrCr, BCC] when a discrete logarithm based bit commitment is used; also [NOVY]. * SZK proofs: Statistically convincing, statistical ZK. <p> The strongest kind, but not possible for all of NP unless the polynomial time hierarchy collapses [Fo]. But there are examples for special languages: quadratic residuosity and its complement [GMR]; graph isomorphism and its complement <ref> [GMW] </ref>; constant round SZK proofs for quadratic residuosity and graph isomorphism [BMO1]. 1.2 Complexity measures and optimality Recall that the error-probability is the probability *() in the soundness condition, whether in a proof or an argument. Most atomic ZK protocols have constant error. But one really wants low error. <p> Some works like [FeSh] call this a move, and say a round is two consecutive moves. In their terminology, our four round protocols would be four move or two round protocols. 4 Rounds Assumption Reference Type poly (n) One-way function Combine <ref> [GMW, HILL, Na] </ref> CZK proof !(log n) Algebraic [BrCr, BCC] SZK argument poly (n) One-way permutation [NOVY] SZK argument 6 Claw-free pairs [BCY] SZK argument 6 Claw-free pairs [GoKa] CZK proof 5 One-way function [FeSh] CZK argument 4 Algebraic [FeSh] CZK argument 4 Trapdoor perm. + Algebraic Combine [Bl, FLS, BeYu]
Reference: [GoOr] <author> O. Goldreich and Y. Oren. </author> <title> Definitions and properties of zero-knowledge proof systems. </title> <journal> Journal of Cryptology, </journal> <volume> Vol. 7, No. 1, </volume> <year> 1994, </year> <pages> pp. 1-32. </pages>
Reference-contexts: Thus, a one-way function is a minimal assumption required to achieve ZK. The problem. There are many so-called "atomic" ZK protocols for NP that achieve constant error-probability in constant (three or four) rounds. Serial repetition lowers the error and preserves ZK <ref> [GoOr, ToWo] </ref>, but at the cost of increasing the number of rounds to non-constant. So we would like to do parallel repetition. However, this is ruled out: first, we have the above mentioned results of [GoKr]; second, the latter also showed that in general parallel repetition does not preserve ZK. <p> We want to meet this bound given only a one-way function. Remark. The above notion of black-box simulation zero-knowledge is stronger than those of <ref> [GoOr, GoKr, BMO2] </ref> in the following sense. In our notion, the simulator has no control over the coins R of b V x : they are automatically chosen (at random) and then fixed. <p> The simulator does not even have direct access to them: it just gets an oracle for b V x;R . In the notions of <ref> [GoOr, GoKr] </ref>, the simulator could choose these coins as it liked, even try running b V x on many different random tapes. In the notion of [BMO2] it could not choose them, but did have direct access to them, and could try several random tapes.
Reference: [GoMi] <author> S. Goldwasser and S. Micali. </author> <title> Probabilistic Encryption. </title> <journal> J. Computer and System Sciences, </journal> <volume> Vol. 28, </volume> <year> 1984, </year> <pages> pp. 270-299. </pages>
Reference-contexts: Sometimes it is convenient to use one, sometimes the other. Also see [Be] for some issues relating to the case of negligible knowledge error and alternative ways to define it. 2.4 Zero-knowledge Ensembles and computational indistinguishability. We recall these notions of <ref> [GoMi, GMR] </ref>. An ensemble indexed by L f0; 1g fl is a collection fE (x)g x2L of probability spaces (of finite support), one for each x 2 L.
Reference: [GMR] <author> S. Goldwasser, S. Micali and C. Rackoff. </author> <title> The knowledge complexity of interactive proof systems. </title> <journal> SIAM J. on Computing, </journal> <volume> Vol. 18, No. 1, </volume> <pages> pp. 186-208, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: 1 Introduction In a zero-knowledge (ZK) protocol, a prover P wants to "convince" a verifier V that some claim is true, without "revealing" any extra information <ref> [GMR] </ref>. In the theory of ZK protocols, researchers have looked at the complexity assumptions based on which protocols can be constructed, and the resources necessary to do so. Here we fill a gap in this area. <p> Conviction is about "soundness." If x 62 L we ask that no matter how the prover behaves, it cannot convince V to accept, except with low probability (called the error probability, and denoted *()). This has been formalized in two ways: Statistical conviction: This is the notion of <ref> [GMR] </ref>. Even a computationally unrestricted prover should be unable to make the verifier accept x 62 L, except with probability *(n). Protocols providing this strong degree of conviction are usually called "proofs." Computational conviction: This is the notion of [BrCr, BCC]. <p> The soundness will typically depend on the assumed intractability of some computational problem, like factoring or computing discrete logarithms. Protocols meeting this condition are usually called "arguments." Degrees of zero-knowledge. Roughly, the zero-knowledge condition of <ref> [GMR] </ref> asks that when x 2 L, the transcript of an interaction between the prover and a verifier yield no information (other than the fact that x 2 L) to an adversary who gets to examine the transcript. <p> The definition of [BrCr, BCC] asks (as appropriate for a cryptographic protocol) that this be efficiently achievable: if P is given a witness for the membership of x in the NP language L then it can make V accept in polynomial time. The definition of <ref> [GMR] </ref> does not make such a requirement. However, all known proofs (statistically convincing) for NP languages do meet this efficient completeness requirement, so we won't discuss it further, assuming it always to be true. A note on proofs of knowledge. <p> One usually also wants that when x 2 L, the ability of a prover to convince V to accept should be indicative of "knowledge" of a witness. Like soundness, in proofs it holds for arbitrary provers and in arguments for polynomial time ones. (The notion was suggested in <ref> [GMR] </ref>, and an appropriate formalization has emerged in [BeGo]. See Section 2.3 for more.) Again, we will not discuss it further here, concentrating just on the two dimensions mentioned above. Four kinds of protocols. <p> The strongest kind, but not possible for all of NP unless the polynomial time hierarchy collapses [Fo]. But there are examples for special languages: quadratic residuosity and its complement <ref> [GMR] </ref>; graph isomorphism and its complement [GMW]; constant round SZK proofs for quadratic residuosity and graph isomorphism [BMO1]. 1.2 Complexity measures and optimality Recall that the error-probability is the probability *() in the soundness condition, whether in a proof or an argument. Most atomic ZK protocols have constant error. <p> Issues in computational soundness. In the interactive proof setting <ref> [GMR] </ref>, the error-probability of a protocol (P; V ) is *() if for any x 62 L and any interactive algorithm b P playing the role of the prover, Acc ( b P x ; V x ) *(jxj). <p> This notion of a "proof of knowledge" was suggested in <ref> [GMR] </ref>. It was formalized in [BeGo] both for the standard interactive proof setting and the argument, or computationally convincing setting. (They discuss the latter in [BeGo, Section 4.7].) We adopt their notion. It comes in two equivalent forms. We present both. <p> Sometimes it is convenient to use one, sometimes the other. Also see [Be] for some issues relating to the case of negligible knowledge error and alternative ways to define it. 2.4 Zero-knowledge Ensembles and computational indistinguishability. We recall these notions of <ref> [GoMi, GMR] </ref>. An ensemble indexed by L f0; 1g fl is a collection fE (x)g x2L of probability spaces (of finite support), one for each x 2 L. <p> Let P; V be interactive algorithms. The definition of a zero-knowledge interactive proof <ref> [GMR] </ref> refers to a language L.
Reference: [HILL] <author> J. H -astad, R. Impagliazzo, L. Levin and M. Luby. </author> <title> Construction of a pseudo-random generator from any one-way function. </title> <type> Manuscript. </type> <note> Earlier versions in STOC 89 and STOC 90. </note>
Reference-contexts: Some works like [FeSh] call this a move, and say a round is two consecutive moves. In their terminology, our four round protocols would be four move or two round protocols. 4 Rounds Assumption Reference Type poly (n) One-way function Combine <ref> [GMW, HILL, Na] </ref> CZK proof !(log n) Algebraic [BrCr, BCC] SZK argument poly (n) One-way permutation [NOVY] SZK argument 6 Claw-free pairs [BCY] SZK argument 6 Claw-free pairs [GoKa] CZK proof 5 One-way function [FeSh] CZK argument 4 Algebraic [FeSh] CZK argument 4 Trapdoor perm. + Algebraic Combine [Bl, FLS, BeYu] <p> This is interleaved with a standard ZK proof run on fi. To implement the latter with a one-way function we use Naor's bit commitment scheme [Na] which can be based on a one-way function via <ref> [HILL] </ref>. The tricky part is getting the protocol to be ZK. When the protocol is finally designed, however, the ZK is not hard to see. It turns out the technically more challenging part is to prove computational soundness. <p> is important to remember is that knowledge of a satisfying assignment T to Formula f (y) is tantamount to knowledge of a pre-image x of y under f . 11 3.3 Naor's commitment scheme We will use Naor's commitment scheme [Na] which can be based on any one-way function via <ref> [HILL] </ref>. Some special properties of the scheme are important for us. It work like this. Suppose A has some data d 2 f0; 1g m that she wants to commit to B. <p> Then, A picks at random some string s to use as coins, and computes a function ff = Commit f (R; d; s). (This function depends on a pseudorandom bit generator [BlMi, Ya], constructed out of f via <ref> [HILL] </ref>, but we don't need to know that.) This ff is A's commitment to d and is sent to B. <p> Using D we would do one of the following. Either construct a polynomial sized circuit family that defeated the privacy of the bit commitment scheme, which would contradict the security of this scheme as proven in <ref> [Na, HILL] </ref>. Or, build a distinguisher that would contradict the witness indistinguishability of n parallel repetitions of the atomic protocol. We omit these proofs from this abstract. Acknowledgments We thank the (anonymous) referees of Eurocrypt 97 for comments which improved the presentation of the paper.
Reference: [ImLu] <author> R. Impagliazzo and M. Luby. </author> <title> One-way Functions are Essential for Complexity-Based Cryptography. </title> <booktitle> Proceedings of the 30th Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1989. </year>
Reference-contexts: ZK with low error. (The result also holds if the protocol is not sound but just a proof of knowledge, so that four rounds is also necessary for negligible knowledge error [IS1].) * One-way function needed: ZK arguments can be used to implement many kinds of cryptographic schemes, whence by <ref> [ImLu] </ref> require a one-way function to implement. Even for the proof case with a computationally unbounded prover, it is known that for "hard" languages some kind of "one-way function" is necessary [OsWi]. Thus, a one-way function is a minimal assumption required to achieve ZK. The problem.
Reference: [ImYu] <author> R. Impagliazzo and M. Yung. </author> <title> Direct Minimum-Knowledge Computations. </title> <booktitle> Advances in Cryptology - Crypto 87 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 293, </volume> <editor> C. Pomerance ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: The protocol. In the literature there are several commitment-based three round ZK arguments with error 1=2. For concreteness, take the one of Brassard, Crepeau and Chaum [BCC], or the one based on general commitment in <ref> [ImYu] </ref>. To set it up using one-way function based commitment, we first have the verifier send a commitment setup string, and then run a protocol such as the ones in [BCC, ImYu], so that we have four rounds. <p> For concreteness, take the one of Brassard, Crepeau and Chaum [BCC], or the one based on general commitment in [ImYu]. To set it up using one-way function based commitment, we first have the verifier send a commitment setup string, and then run a protocol such as the ones in <ref> [BCC, ImYu] </ref>, so that we have four rounds. To avoid depending on the details of any specific underlying protocol, we describe the protocol via generic components and steps. Let fi denote the boolean formula which is the common input.
Reference: [IS1] <author> T. Itoh and K. Sakurai. </author> <title> On the complexity of constant round ZKIP of possession of knowledge. </title> <journal> IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences, </journal> <volume> Vol. E76-A, No. 1, </volume> <month> January </month> <year> 1993. </year> <month> 23 </month>
Reference-contexts: See Definition 2.6.) Accordingly, four is the minimal number of rounds required to achieve ZK with low error. (The result also holds if the protocol is not sound but just a proof of knowledge, so that four rounds is also necessary for negligible knowledge error <ref> [IS1] </ref>.) * One-way function needed: ZK arguments can be used to implement many kinds of cryptographic schemes, whence by [ImLu] require a one-way function to implement.
Reference: [Na] <author> M. Naor. </author> <title> Bit Commitment using Pseudo-Randomness. </title> <booktitle> Advances in Cryptology - Crypto 89 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 435, </volume> <editor> G. Brassard ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Some works like [FeSh] call this a move, and say a round is two consecutive moves. In their terminology, our four round protocols would be four move or two round protocols. 4 Rounds Assumption Reference Type poly (n) One-way function Combine <ref> [GMW, HILL, Na] </ref> CZK proof !(log n) Algebraic [BrCr, BCC] SZK argument poly (n) One-way permutation [NOVY] SZK argument 6 Claw-free pairs [BCY] SZK argument 6 Claw-free pairs [GoKa] CZK proof 5 One-way function [FeSh] CZK argument 4 Algebraic [FeSh] CZK argument 4 Trapdoor perm. + Algebraic Combine [Bl, FLS, BeYu] <p> Instead, we work directly with the one-way function, having the verifier give a cut-and-choose type proof that meets some conditions. This is interleaved with a standard ZK proof run on fi. To implement the latter with a one-way function we use Naor's bit commitment scheme <ref> [Na] </ref> which can be based on a one-way function via [HILL]. The tricky part is getting the protocol to be ZK. When the protocol is finally designed, however, the ZK is not hard to see. It turns out the technically more challenging part is to prove computational soundness. <p> What is important to remember is that knowledge of a satisfying assignment T to Formula f (y) is tantamount to knowledge of a pre-image x of y under f . 11 3.3 Naor's commitment scheme We will use Naor's commitment scheme <ref> [Na] </ref> which can be based on any one-way function via [HILL]. Some special properties of the scheme are important for us. It work like this. Suppose A has some data d 2 f0; 1g m that she wants to commit to B. <p> The protocol must have two properties. First is privacy: ff gives B no information about d. Second is soundness: A can't create commitments which she can open in more than one way. In Naor's scheme <ref> [Na] </ref>, the privacy is true in a computational sense. That is, as long as B cannot invert the underlying one-way function f , it gets no partial information about d. <p> We say R is good if it is not bad. Naor's scheme has the property that a randomly chosen commitment setup string is bad with probability exponentially small in n <ref> [Na, Claim 3.1] </ref>. For our purposes we set the parameters of the scheme so that this probability is 2 2n . (The length of R required to make this true depends not only on n but also on the data length m. <p> Using D we would do one of the following. Either construct a polynomial sized circuit family that defeated the privacy of the bit commitment scheme, which would contradict the security of this scheme as proven in <ref> [Na, HILL] </ref>. Or, build a distinguisher that would contradict the witness indistinguishability of n parallel repetitions of the atomic protocol. We omit these proofs from this abstract. Acknowledgments We thank the (anonymous) referees of Eurocrypt 97 for comments which improved the presentation of the paper.
Reference: [NOVY] <author> M. Naor, R. Ostrovsky, R. Venkatasan, M. Yung. </author> <title> Perfect zero knowledge arguments for NP can be based on general complexity assumptions. </title> <booktitle> Advances in Cryptology - Crypto 92 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 740, </volume> <editor> E. Brickell ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: For example the proofs for all of NP in [GMW]. * SZK arguments: Computationally convincing, statistical ZK. For example the arguments for all of NP in [BrCr, BCC] when a discrete logarithm based bit commitment is used; also <ref> [NOVY] </ref>. * SZK proofs: Statistically convincing, statistical ZK. The strongest kind, but not possible for all of NP unless the polynomial time hierarchy collapses [Fo]. <p> In their terminology, our four round protocols would be four move or two round protocols. 4 Rounds Assumption Reference Type poly (n) One-way function Combine [GMW, HILL, Na] CZK proof !(log n) Algebraic [BrCr, BCC] SZK argument poly (n) One-way permutation <ref> [NOVY] </ref> SZK argument 6 Claw-free pairs [BCY] SZK argument 6 Claw-free pairs [GoKa] CZK proof 5 One-way function [FeSh] CZK argument 4 Algebraic [FeSh] CZK argument 4 Trapdoor perm. + Algebraic Combine [Bl, FLS, BeYu] CZK argument 4 One-way function This paper CZK argument type (CZK or SZK, proof or argument). <p> This is necessary, as the discussion below explains. Note we say the system has negligible error as long as there is some negligible function *() such that the error is *(). This definition of a negligible error argument differs from previous ones like <ref> [Go, NOVY] </ref>, where the error corresponding to each prover is allowed to be a different negligible function, depending on the prover. However under such a definition there is no particular function we can actually call the error-probability of the protocol. Accordingly, we prefer the definition above.
Reference: [OsWi] <author> R. Ostrovsky and A. Wigderson. </author> <title> One-way functions are essential for non-trivial zero-knowledge. </title> <booktitle> Proceedings of the Second Israel Symposium on Theory and Computing Systems, IEEE, </booktitle> <year> 1993. </year>
Reference-contexts: Even for the proof case with a computationally unbounded prover, it is known that for "hard" languages some kind of "one-way function" is necessary <ref> [OsWi] </ref>. Thus, a one-way function is a minimal assumption required to achieve ZK. The problem. There are many so-called "atomic" ZK protocols for NP that achieve constant error-probability in constant (three or four) rounds.
Reference: [ToWo] <author> M. Tompa and H. Woll. </author> <title> Random Self-Reducibility and Zero-Knowledge Interactive-Proofs of Possession of Information. </title> <booktitle> Proceedings of the 28th Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1987. </year>
Reference-contexts: Thus, a one-way function is a minimal assumption required to achieve ZK. The problem. There are many so-called "atomic" ZK protocols for NP that achieve constant error-probability in constant (three or four) rounds. Serial repetition lowers the error and preserves ZK <ref> [GoOr, ToWo] </ref>, but at the cost of increasing the number of rounds to non-constant. So we would like to do parallel repetition. However, this is ruled out: first, we have the above mentioned results of [GoKr]; second, the latter also showed that in general parallel repetition does not preserve ZK.
Reference: [Ya] <author> A. C. Yao. </author> <title> Theory and Applications of Trapdoor functions. </title> <booktitle> Proceedings of the 23rd Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1982. </year>
Reference-contexts: Then, A picks at random some string s to use as coins, and computes a function ff = Commit f (R; d; s). (This function depends on a pseudorandom bit generator <ref> [BlMi, Ya] </ref>, constructed out of f via [HILL], but we don't need to know that.) This ff is A's commitment to d and is sent to B.
References-found: 31

