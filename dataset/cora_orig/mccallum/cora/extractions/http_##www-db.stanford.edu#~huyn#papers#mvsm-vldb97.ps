URL: http://www-db.stanford.edu/~huyn/papers/mvsm-vldb97.ps
Refering-URL: http://www.cs.toronto.edu/~mendel/dwbib.html
Root-URL: 
Email: huyn@cs.stanford.edu  
Title: Multiple-View Self-Maintenance in Data Warehousing Environments  
Author: Nam Huyn 
Affiliation: Stanford University  
Abstract: A data warehouse materializes views derived from data that may not reside at the warehouse. Maintaining these views efficiently in response to base updates is difficult, since it may involve querying external sources where the base data reside. This paper considers the problem of view self-maintenance, where the views are maintained without using all the base data. Without full use of the base data, however, maintaining a view unambiguously is not always possible. Thus, the two critical questions that must be addressed are to determine, in a given situation, whether a view is maintainable, and how to maintain it. We provide algorithms that answer these questions for a general class of views, and for an important subclass, generate SQL queries that test whether a view is maintainable and update the view if it is. We improve significantly on previous work by solving the view self-maintenance problem in the presence of multiple views, with optional access to a subset of the base data, and under arbitrary mixes of insertions and deletions. We also provide better insight into the view self-maintenance problem by reducing it to a problem of deciding query containment that can be solved. fl Work supported by ARO grant DAAH04-95-1-0192. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the VLDB copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Very Large Data Base Endowment. To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment. Proceedings of the 23rd VLDB Conference Athens, Greece, 1997 
Abstract-found: 1
Intro-found: 1
Reference: [CM77] <author> A. K. Chandra and P. M. Merlin. </author> <title> Optimal implementation of conjunctive queries in relational databases. </title> <booktitle> In Proc. 9th ACM Symp. on Theory of Computing, </booktitle> <pages> pp. 77-90, </pages> <year> 1977. </year>
Reference-contexts: They are exponen tial in the size of the view definitions. This complexity is not surprising, in light of the NP-completeness of checking query containment <ref> [CM77] </ref>. While the complexity of test generation is not as critical as the complexity of test execution, the availability of good query optimization techniques can help simplify the tests and further improve their execution speed.
Reference: [GB95] <author> A. Gupta and J. A. Blakeley. </author> <title> Using Partial Information to Update Materialized Views. </title> <booktitle> In Information Systems, </booktitle> <volume> 20(8), </volume> <pages> pp. 641-662, </pages> <year> 1995. </year>
Reference-contexts: Within the realm of runtime self-maintenance, we are not aware of any work that addresses the question of self-maintainability with respect to an instance of more than one view or base relation, or under an arbitrary mix of insertions and deletions to the base relations. [TB88] and more recently <ref> [GB95] </ref> gave self-maintainability conditions (they called conditions for Autonomously Computable Updates) for views that are SPJ queries with no self-joins and for updates that are either insertions or deletions to a single base relation. <p> Their method cannot be extended easily to take advantage of multiple views or the base relations, or to handle updates that mix insertions with deletions. [Hu96] addressed the single-view strict self-maintenance problem and solved it more efficiently than <ref> [GB95] </ref>, but only for views that are SPJ queries with no self-joins and for updates that are single insertions. Again, their method cannot be generalized easily. In the realm of compile-time self-maintenance, [GJM94] addressed the single-view self-maintenance for views defined as SPJ queries and under either insertions, deletions, or updates.
Reference: [GJM94] <author> A. Gupta, H. V. Jagadish and I. S. Mumick. </author> <title> Data Integration Using Self-Maintainable Views. </title> <note> In Technical Memorandum 113880-941101-32, </note> <institution> AT&T Bell Labs, </institution> <month> November </month> <year> 1995. </year>
Reference-contexts: Again, their method cannot be generalized easily. In the realm of compile-time self-maintenance, <ref> [GJM94] </ref> addressed the single-view self-maintenance for views defined as SPJ queries and under either insertions, deletions, or updates. More recently, [Q*96] solved a different but related problem, namely that of making a view self-maintainable by introducing a minimal set of auxiliary views to materialize.
Reference: [GM95] <author> A. Gupta and I. S. Mumick. </author> <title> Maintenance of Materialized Views: Problems, Techniques, </title> <journal> and Applications. In IEEE Data Engineering Bulletin, Special Issue on Materialized Views & Data Warehousing, </journal> <volume> 18(2), </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: Related Work on Self-Maintenance Self-maintenance generally refers to the problem of maintaining views without full use of the base relations. <ref> [GM95] </ref> gave an excellent classification of different notions of self-maintenance, based on what information is available for view maintenance. A major distinction is what we call compile-time vs. run-time.
Reference: [GMS93] <author> A. Gupta, I. S. Mumick, </author> <title> and V.S. Subrah-manian. Maintaining Views Incrementally. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <month> June </month> <year> 1993. </year>
Reference: [G*94] <author> A. Gupta, Y. Sagiv, J. D. Ullman and J. Widom. </author> <title> Constraint Checking with Partial Information. </title> <booktitle> In Proc. 13th ACM Symp. on Principles of Database Systems, </booktitle> <pages> pp. 45-55, </pages> <year> 1994. </year>
Reference: [H*95] <author> J. Hammer, H. Garcia-Molina, J. Widom, W. Labio, and Y. Zhuge. </author> <title> The Stanford Data Warehousing Project. </title> <journal> In IEEE Data Engineering Bulletin, </journal> <volume> 18(2), </volume> <pages> pp. 41-48, </pages> <month> June </month> <year> 1995. </year>
Reference: [Hu96] <author> N. Huyn. </author> <title> Efficient View Self-Maintenance. </title> <booktitle> In Proc. Workshop on Materialized Views: Techniques and Applications, </booktitle> <pages> pp. 17-25, </pages> <year> 1996. </year>
Reference-contexts: Such situations never arise in traditional work on materialized view maintenance ([GM95, Kuc91, GMS93, SJ96]) where all the base data is usually assumed to be available. Thus, an important question (originally considered in <ref> [TB88, Hu96] </ref>), which was never raised in traditional view-maintenance work, is to determine whether a view is maintainable, that is, guaranteed to have a unique new state, given an update to the base relations, an instance of the views, and an instance of a subset of the base relations. <p> Their method cannot be extended easily to take advantage of multiple views or the base relations, or to handle updates that mix insertions with deletions. <ref> [Hu96] </ref> addressed the single-view strict self-maintenance problem and solved it more efficiently than [GB95], but only for views that are SPJ queries with no self-joins and for updates that are single insertions. Again, their method cannot be generalized easily. <p> While the use of projection in views seems to make the problem considerably harder since the number of consistent mappings h can be exponential in the worst case, results from <ref> [Hu96] </ref> suggest that it does not have to be so. For example, [Hu96] showed that even with projection, self-maintainability of a single conjunctive-query view with no self-join can be efficiently decided with a simple query. <p> While the use of projection in views seems to make the problem considerably harder since the number of consistent mappings h can be exponential in the worst case, results from <ref> [Hu96] </ref> suggest that it does not have to be so. For example, [Hu96] showed that even with projection, self-maintainability of a single conjunctive-query view with no self-join can be efficiently decided with a simple query.
Reference: [Hu97] <author> N. Huyn. </author> <title> Multiple-View Self-Maintenance in Data Warehousing Environments. </title> <type> Technical Report, </type> <note> available as http://www-db.stan-ford.edu/pub/huyn/1997/mvsm.ps, 1997. </note>
Reference-contexts: We show how to extend the results for strict self-maintenance to generalized self-maintenance. The paper concludes in Section 8. Throughout this paper, results are stated without their proof, which can be found in <ref> [Hu97] </ref>. 2 Defining the Multiple-View Self Maintenance Problem Throughout this paper, the warehouse consists of materialized views V 1 ; V 2 ; : : : ; V m derived from base relations R 1 ; R 2 ; : : : ; R n . <p> Due to space limitation, this algorithm is not shown here. It can be found in <ref> [Hu97] </ref>. Essentially, given two queries, the algorithm first generates a logical expression that captures the condition for containment for the queries.
Reference: [IK93] <author> W. H. Inmon and C. Kelley. Rdb/VMS: </author> <title> Developing the Data Warehouse. </title> <publisher> QED Publishing Group, </publisher> <address> Boston, Massachusetts, </address> <year> 1993. </year>
Reference: [Klu88] <author> A. Klug. </author> <title> On Conjunctive Queries Containing Inequalities. </title> <editor> In J. </editor> <booktitle> ACM 35:1, </booktitle> <pages> pp. 146-160, </pages> <year> 1988. </year>
Reference: [Kuc91] <author> V. Kuechenhoff. </author> <title> On the Efficient Computation of the Difference Between Consecutive Database States. </title> <booktitle> In Int. Conf. on DOOD, </booktitle> <year> 1991. </year>
Reference: [LS93] <author> A. Levy and Y.Sagiv. </author> <title> Queries Independent of Updates. </title> <booktitle> Proc. 19th Int. Conf. on Very Large Data Bases, </booktitle> <year> 1993, </year> <pages> pp. 171-181. </pages>
Reference-contexts: These queries involve negation and 6= comparisons, and use r 1 ; : : : ; r n as input. The <ref> [LS93] </ref> algorithm can decide containment of unions of such queries in time exponential in the size of the views.
Reference: [Q*96] <author> D. Quass, A. Gupta, I. Mumick and J. Widom. </author> <title> Making Views Self-Maintainable for Data Warehousing. </title> <booktitle> In Proc. 4th Int. Conf. on Parallel and Distributed Information Systems, </booktitle> <address> Miami Beach, FL, </address> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: Again, their method cannot be generalized easily. In the realm of compile-time self-maintenance, [GJM94] addressed the single-view self-maintenance for views defined as SPJ queries and under either insertions, deletions, or updates. More recently, <ref> [Q*96] </ref> solved a different but related problem, namely that of making a view self-maintainable by introducing a minimal set of auxiliary views to materialize. However, how to make more than one view self-maintainable was not addressed. Outline of the Paper In Section 2, we define the multiple-view self-maintenance problem.
Reference: [RED] <institution> Red Brick Systems. Red Brick Warehouse, </institution> <year> 1995. </year>
Reference: [SJ96] <author> M. Staudt and M. Jarke. </author> <title> Incremental Maintenance of Externally Materialized Views. </title> <booktitle> In Proc. 22nd VLDB Conf., </booktitle> <address> Mumbai, India, </address> <year> 1996. </year>
Reference-contexts: Many known algorithms exist in the view-maintenance literature ([Kuc91, SJ96]) that can generate queries for incrementally maintaining a view using both the view and all the base relations. Using for instance <ref> [SJ96] </ref> in Step 2, Algorithm 3.1 generates the queries that compute the required insertions to and deletions from a view, in time linear in the size of the view definitions. The size of these queries is also linear.
Reference: [TB88] <author> F. W. Tompa and J. </author> <title> A .Blakeley. Maintaining Materialized Views Without Accessing Base Data. </title> <booktitle> In Information Systems, </booktitle> <volume> 13(4), </volume> <pages> pp. 393-406, </pages> <year> 1988. </year>
Reference-contexts: Such situations never arise in traditional work on materialized view maintenance ([GM95, Kuc91, GMS93, SJ96]) where all the base data is usually assumed to be available. Thus, an important question (originally considered in <ref> [TB88, Hu96] </ref>), which was never raised in traditional view-maintenance work, is to determine whether a view is maintainable, that is, guaranteed to have a unique new state, given an update to the base relations, an instance of the views, and an instance of a subset of the base relations. <p> Within the realm of runtime self-maintenance, we are not aware of any work that addresses the question of self-maintainability with respect to an instance of more than one view or base relation, or under an arbitrary mix of insertions and deletions to the base relations. <ref> [TB88] </ref> and more recently [GB95] gave self-maintainability conditions (they called conditions for Autonomously Computable Updates) for views that are SPJ queries with no self-joins and for updates that are either insertions or deletions to a single base relation.
Reference: [Ull89] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, Volumes 1 and 2. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year>
Reference-contexts: Notation In this work, we assume a relational database frame work in which views are defined by relational queries over base relations. Set semantics is also assumed. Thus, the answer to a query is a set of tuples. We will use the notation of Datalog <ref> [Ull89] </ref> for all the queries involved in our algorithms. This choice is by convenience, even though any other relational languages could be used. <p> Query Containment The main technique used in solving the self-maintainability problem (1) is based on showing that it can be reduced to a particular implication problem known in the literature as the query containment (ab-brev. QC) problem <ref> [Ull89] </ref>.
Reference: [Z*95] <author> Y. Zhuge, H. Garcia-Molina, J. Hammer and J Widom. </author> <title> View Maintenance in a Warehousing Environment. </title> <booktitle> In Proc. ACM SIGMOD, </booktitle> <address> San Jose, Cali-fornia, </address> <year> 1995. </year> <pages> Page 12 </pages>
Reference-contexts: When a base relation is asynchronously updated by the source, it may be read by the warehouse in a different state than what is assumed by the warehouse. This situation may lead to erroneous updates to the warehouse, as reported in <ref> [Z*95] </ref>. Thus, a warehouse system that uses generalized self-maintenance must either allow access only to Page 11 base relations that change in lock step with the ware-house, or combine our techniques with the compensation techniques developed in [Z*95]. 8 Conclusion and Future Work We have given algorithms that test view maintainability <p> This situation may lead to erroneous updates to the warehouse, as reported in <ref> [Z*95] </ref>. Thus, a warehouse system that uses generalized self-maintenance must either allow access only to Page 11 base relations that change in lock step with the ware-house, or combine our techniques with the compensation techniques developed in [Z*95]. 8 Conclusion and Future Work We have given algorithms that test view maintainability and incrementally maintain a view in response to a base update, based on the current state of all the views in the warehouse and of a specified subset of the base relations.
References-found: 19

