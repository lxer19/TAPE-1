URL: http://www.cs.wustl.edu/~schmidt/GLOBECOM-97.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/tri-dove.html
Root-URL: 
Email: gokhale@cs.wustl.edu and schmidt@cs.wustl.edu  
Title: Evaluating the Performance of Demultiplexing Strategies for Real-time CORBA  
Author: Aniruddha Gokhale and Douglas C. Schmidt 
Keyword: Communication software, Real-time CORBA, De-multiplexing.  
Address: St. Louis, MO 63130, USA.  
Affiliation: Department of Computer Science, Washington University  
Abstract: This paper will appear in the proceedings of GLOBECOM '97, Phoenix, AZ, November, 1997. Abstract Efficient and predictable demultiplexing is necessary to provide real-time support for distributed object computing applications developed with CORBA. This paper presents two contributions to the study of demultiplexing for real-time CORBA endsystems. First, we present an empirical study of four CORBA request de-multiplexing strategies (linear search, perfect hashing, dynamic hashing, and active demultiplexing) for a range of target objects and operations. Second, we describe how we are using the perfect hashing and active demultiplexing strategies to develop a high-performance, real-time ORB called TAO. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mary L. Bailey, Burra Gopal, Prasenjit Sarkar, Michael A. Pagels, and Larry L. Peterson. Pathfinder: </author> <title> A pattern-based packet classifier. </title> <booktitle> In Proceedings of the 1 st Symposium on Operating System Design and Implementation. USENIX Association, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: A number of schemes to implement fast and efficient packet filters are available. These include the BSD Packet Filter (BPF) [12], the Mach Packet Filter (MPF) [21], PathFinder <ref> [1] </ref>, demultiplexing based on automatic parsing [11], and the Dynamic Packet Filter (DPF) [3]. Most existing demultiplexing strategies are implemented within the OS kernel. However, to optimally reduce ORB endsystem de-multiplexing overhead requires a vertically integrated architecture that extends from the OS kernel to the application servants.
Reference: [2] <author> Zubin D. Dittia, Guru M. Parulkar, and Jr. Jerome R. Cox. </author> <title> The APIC Ap proach to High Performance Network Interface Design: Protected DMA and Other Techniques. </title> <booktitle> In Proceedings of INFOCOM '97, </booktitle> <address> Kobe, Japan, </address> <month> April </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: For instance, <ref> [19, 4, 2] </ref> study demultiplexing issues in communication systems and show how layered demultiplexing is not suitable for applications that require real-time quality of service guarantees. 3 Detailed description on the four demultiplexing strategies is available at URL http://www.cs.wustl.edu/~schmidt/GLOBECOM-97.ps.gz 3 Packet filters are a mechanism for efficiently demultiplexing incoming packets to
Reference: [3] <author> Dawson R. Engler and M. Frans Kaashoek. DPF: </author> <title> Fast, Flexible Message Demultiplexing using Dynamic Code Generation. </title> <booktitle> In Proceedings of ACM SIGCOMM '96 Conference in Computer Communication Review, </booktitle> <pages> pages 53 59, </pages> <institution> Stanford University, California, USA, </institution> <month> August </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: A number of schemes to implement fast and efficient packet filters are available. These include the BSD Packet Filter (BPF) [12], the Mach Packet Filter (MPF) [21], PathFinder [1], demultiplexing based on automatic parsing [11], and the Dynamic Packet Filter (DPF) <ref> [3] </ref>. Most existing demultiplexing strategies are implemented within the OS kernel. However, to optimally reduce ORB endsystem de-multiplexing overhead requires a vertically integrated architecture that extends from the OS kernel to the application servants.
Reference: [4] <author> David C. Feldmeier. </author> <title> Multiplexing Issues in Communications System De sign. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), pages 209219, </booktitle> <address> Philadelphia, PA, </address> <month> September </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: For instance, <ref> [19, 4, 2] </ref> study demultiplexing issues in communication systems and show how layered demultiplexing is not suitable for applications that require real-time quality of service guarantees. 3 Detailed description on the four demultiplexing strategies is available at URL http://www.cs.wustl.edu/~schmidt/GLOBECOM-97.ps.gz 3 Packet filters are a mechanism for efficiently demultiplexing incoming packets to
Reference: [5] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks. </title> <booktitle> In Proceedings of SIGCOMM '96, </booktitle> <pages> pages 306317, </pages> <address> Stanford, CA, </address> <month> August </month> <year> 1996. </year> <note> ACM. </note>
Reference-contexts: Our earlier work focused on measuring and optimz-ing ORB presentation layer overhead to improve throughput <ref> [5, 6] </ref> and reduce latency [7]. This paper extends our earlier work by focusing on strategies for optimizing CORBA demultiplexing overhead. fl This work was supported in part by NSF grant NCR-9628218, US Sprint, and Boeing. <p> In addition, layered demultiplexing can cause priority inversions because servant-level QoS information is inaccessible to the lowest level device drivers and protocol stacks in the I/O subsystem of an ORB endsystem. Conventional implementations of CORBA incur significant de-multiplexing overhead. In particular, <ref> [5, 7] </ref> show that ~17% of the total server processing time is spent demultiplexing requests. <p> A maximum of 32 Kbytes is allotted per ATM virtual circuit connection for receiving and transmitting frames (for a total of 64 K). This allows up to eight switched virtual connections per card. This hardware platform is shown in Figure 4. 3.2 Parameter Settings Our earlier studies <ref> [5, 7] </ref> of CORBA performance over ATM demonstrate the performance impact of parameters such as the number of servants on an endsystem (e.g., a server), and interfaces with large number of methods. <p> For this reason, we are using the perfect hashing demultiplexing strategy in the TAO ORB we are building for real-time avionics applications [18, 9]. 5 Concluding Remarks An important class of applications (such as avionics, virtual reality, and telecommunication systems) require scalable, low latency communication. Our earlier work <ref> [5, 7] </ref> shows why latency-sensitive applications that utilize many servants and large interfaces are not yet supported efficiently by contemporary CORBA implementations due to demultiplexing overhead, presentation layer conversions, data copying, and many layers of virtual method calls. On low-speed networks this overhead is often masked.
Reference: [6] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> The Performance of the CORBA Dynamic Invocation Interface and Dynamic Skeleton Interface over High-Speed ATM Networks. </title> <booktitle> In Proceedings of GLOBECOM '96, </booktitle> <pages> pages 50 56, </pages> <address> London, England, </address> <month> November </month> <year> 1996. </year> <note> IEEE. </note>
Reference-contexts: Our earlier work focused on measuring and optimz-ing ORB presentation layer overhead to improve throughput <ref> [5, 6] </ref> and reduce latency [7]. This paper extends our earlier work by focusing on strategies for optimizing CORBA demultiplexing overhead. fl This work was supported in part by NSF grant NCR-9628218, US Sprint, and Boeing.
Reference: [7] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Evaluating Latency and Scal ability of CORBA Over High-Speed ATM Networks. </title> <booktitle> In Proceedings of the International Conference on Distributed Computing Systems, </booktitle> <address> Baltimore, Maryland, </address> <month> May </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: Our earlier work focused on measuring and optimz-ing ORB presentation layer overhead to improve throughput [5, 6] and reduce latency <ref> [7] </ref>. This paper extends our earlier work by focusing on strategies for optimizing CORBA demultiplexing overhead. fl This work was supported in part by NSF grant NCR-9628218, US Sprint, and Boeing. <p> In addition, layered demultiplexing can cause priority inversions because servant-level QoS information is inaccessible to the lowest level device drivers and protocol stacks in the I/O subsystem of an ORB endsystem. Conventional implementations of CORBA incur significant de-multiplexing overhead. In particular, <ref> [5, 7] </ref> show that ~17% of the total server processing time is spent demultiplexing requests. <p> A maximum of 32 Kbytes is allotted per ATM virtual circuit connection for receiving and transmitting frames (for a total of 64 K). This allows up to eight switched virtual connections per card. This hardware platform is shown in Figure 4. 3.2 Parameter Settings Our earlier studies <ref> [5, 7] </ref> of CORBA performance over ATM demonstrate the performance impact of parameters such as the number of servants on an endsystem (e.g., a server), and interfaces with large number of methods. <p> For this reason, we are using the perfect hashing demultiplexing strategy in the TAO ORB we are building for real-time avionics applications [18, 9]. 5 Concluding Remarks An important class of applications (such as avionics, virtual reality, and telecommunication systems) require scalable, low latency communication. Our earlier work <ref> [5, 7] </ref> shows why latency-sensitive applications that utilize many servants and large interfaces are not yet supported efficiently by contemporary CORBA implementations due to demultiplexing overhead, presentation layer conversions, data copying, and many layers of virtual method calls. On low-speed networks this overhead is often masked.
Reference: [8] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Principles for Optimizing CORBA Internet Inter-ORB Protocol Performance. </title> <note> In Submitted to the Hawaiian International Conference on System Sciences (Washington University Technical Report #WUCS-97-10), </note> <month> January </month> <year> 1998. </year>
Reference: [9] <author> Timothy H. Harrison, David L. Levine, and Douglas C. Schmidt. </author> <title> The Design and Performance of a Real-time CORBA Event Service. </title> <booktitle> In Proceedings of OOPSLA '97, </booktitle> <address> Atlanta, GA, </address> <month> October </month> <year> 1997. </year> <note> ACM. </note>
Reference-contexts: Both servant and operation lookup take constant time. Perfect hashing is applicable when the keys to be hashed are known a priori. In many hard real-time systems (such as avionic 2 The active object map [15] associates object keys to servants maintained by an Object Adapter. 2 control systems <ref> [9] </ref>), the objects and operations can be configured statically. In this scenario, it is possible to use perfect hashing to hash the object and operations. For our experiment, we used the GNU gperf [16] tool to generate perfect hash functions for object keys and operation names. <p> For this reason, we are using the perfect hashing demultiplexing strategy in the TAO ORB we are building for real-time avionics applications <ref> [18, 9] </ref>. 5 Concluding Remarks An important class of applications (such as avionics, virtual reality, and telecommunication systems) require scalable, low latency communication.
Reference: [10] <institution> Pure Software Inc. </institution> <note> Quantify User's Guide. </note> <institution> Pure Software Inc., </institution> <year> 1996. </year>
Reference-contexts: This system call uses the SunOS 5.5 high-resolution timer, which expresses time in nanoseconds from an arbitrary time in the past. The time returned by gethrtime is very accurate since it does not drift. 4 The profile information for the empirical analysis was obtained using the Quantify <ref> [10] </ref> performance measurement tool. Quantify analyzes performance bottlenecks and identifies sections of code that dominate execution time. Unlike traditional sampling-based profilers (such as the UNIX gprof tool), Quantify reports results without including its own overhead.
Reference: [11] <author> Mahesh Jayaram and Ron Cytron. </author> <title> Efficient Demultiplexing of Network Packets by Automatic Parsing. </title> <booktitle> In Proceedings of the Workshop on Compiler Support for System Software (WCSSS 96), </booktitle> <institution> University of Arizona, </institution> <address> Tucson, AZ, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: A number of schemes to implement fast and efficient packet filters are available. These include the BSD Packet Filter (BPF) [12], the Mach Packet Filter (MPF) [21], PathFinder [1], demultiplexing based on automatic parsing <ref> [11] </ref>, and the Dynamic Packet Filter (DPF) [3]. Most existing demultiplexing strategies are implemented within the OS kernel. However, to optimally reduce ORB endsystem de-multiplexing overhead requires a vertically integrated architecture that extends from the OS kernel to the application servants.
Reference: [12] <author> Steven McCanne and Van Jacobson. </author> <title> The BSD Packet Filter: A New Archi tecture for User-level Packet Capture. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 259270, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: A number of schemes to implement fast and efficient packet filters are available. These include the BSD Packet Filter (BPF) <ref> [12] </ref>, the Mach Packet Filter (MPF) [21], PathFinder [1], demultiplexing based on automatic parsing [11], and the Dynamic Packet Filter (DPF) [3]. Most existing demultiplexing strategies are implemented within the OS kernel.
Reference: [13] <author> Jeffrey C. Mogul, Richard F. Rashid, and Michal J. Accetta. </author> <title> The Packet Filter: an Efficient Mechanism for User-level Network Code. </title> <booktitle> In Proceedings of the 11 th Symposium on Operating System Principles (SOSP), </booktitle> <month> November </month> <year> 1987. </year>
Reference-contexts: study demultiplexing issues in communication systems and show how layered demultiplexing is not suitable for applications that require real-time quality of service guarantees. 3 Detailed description on the four demultiplexing strategies is available at URL http://www.cs.wustl.edu/~schmidt/GLOBECOM-97.ps.gz 3 Packet filters are a mechanism for efficiently demultiplexing incoming packets to application endpoints <ref> [13] </ref>. A number of schemes to implement fast and efficient packet filters are available. These include the BSD Packet Filter (BPF) [12], the Mach Packet Filter (MPF) [21], PathFinder [1], demultiplexing based on automatic parsing [11], and the Dynamic Packet Filter (DPF) [3].
Reference: [14] <institution> Object Management Group. </institution> <note> The Common Object Request Broker: Architec ture and Specification, 2.0 edition, </note> <month> July </month> <year> 1995. </year>
Reference-contexts: 1 Introduction CORBA is a distributed object computing middleware standard defined by the Object Management Group (OMG) <ref> [14] </ref>. CORBA is designed to allow clients to invoke operations on remote objects without concern for where the object resides or what language the object is written in. <p> of our experiments and analyzes the overhead associated with each demultiplexing strategy; and Section 5 presents concluding remarks. 2 Overview of CORBA Demultiplexing 2.1 Conventional CORBA Demultiplexing Archi tectures A CORBA request header contains the identity of its remote object implementation (which is called a servant by the CORBA specification <ref> [14] </ref>) and its intended remote operation. A servant is uniquely identified by an object key and an operation name. An object key is represented as an IDL sequence, which is a single dimensional dynamic array of bytes; an operation name is represented as a string.
Reference: [15] <institution> Object Management Group. </institution> <note> Specification of the Portable Object Adapter (POA), OMG Document orbos/97-05-15 edition, </note> <month> June </month> <year> 1997. </year>
Reference-contexts: The Object Adapter is the component in the CORBA architecture that associates a servant with the ORB, demultiplexes incoming requests to the servant, and dispatches the appropriate operation of that servant. While current CORBA implementations typically provide a single Object Adapter per ORB, recent ORBOS portability enhancements <ref> [15] </ref> define the Portable Object Adapter (POA) to support multiple Object Adapters per ORB. The demultiplexing strategy used by an ORB can impact performance significantly. <p> A second perfect hashing function is then used to locate the operation. Both servant and operation lookup take constant time. Perfect hashing is applicable when the keys to be hashed are known a priori. In many hard real-time systems (such as avionic 2 The active object map <ref> [15] </ref> associates object keys to servants maintained by an Object Adapter. 2 control systems [9]), the objects and operations can be configured statically. In this scenario, it is possible to use perfect hashing to hash the object and operations.
Reference: [16] <author> Douglas C. Schmidt. GPERF: </author> <title> A Perfect Hash Function Generator. </title> <booktitle> In Pro ceedings of the 2 nd C++ Conference, </booktitle> <pages> pages 87102, </pages> <address> San Francisco, Cali-fornia, </address> <month> April </month> <year> 1990. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: In this scenario, it is possible to use perfect hashing to hash the object and operations. For our experiment, we used the GNU gperf <ref> [16] </ref> tool to generate perfect hash functions for object keys and operation names.
Reference: [17] <author> Douglas C. Schmidt and Chris Cleeland. </author> <title> Applying Patterns to Develop Ex tensible and Maintainable ORB Middleware. </title> <journal> Communications of the ACM (Special Issue on Software Maintenance), </journal> <volume> 40(12), </volume> <month> December </month> <year> 1997. </year>
Reference-contexts: The result is O (1) performance for 1 SunSoft IIOP is freely available from the OMG web site at URL ftp://ftp.omg.org and the TAO ORB is available at http://www.cs.wustl.edu/~schmidt/TAO.html. the average- and worst-cases. TAO's flexible design allows different demultiplexing strategies <ref> [17] </ref> to be plugged into its Object Adapter.
Reference: [18] <author> Douglas C. Schmidt, David L. Levine, and Sumedh Mungee. </author> <title> The Design and Performance of Real-Time Object Request Brokers. </title> <journal> Computer Communications, </journal> <year> 1997. </year>
Reference-contexts: Unless this overhead is reduced and demultiplexing is performed predictably, ORBs cannot provide real-time quality of service guarantees to applications. 2.2 Design of a Real-time Object Adapter for TAO TAO is a high performance, real-time ORB developed at Washing-ton University <ref> [18] </ref>. It runs on a range of OS platforms that support real-time features including VxWorks, Solaris 2.x, and Windows NT. <p> For this reason, we are using the perfect hashing demultiplexing strategy in the TAO ORB we are building for real-time avionics applications <ref> [18, 9] </ref>. 5 Concluding Remarks An important class of applications (such as avionics, virtual reality, and telecommunication systems) require scalable, low latency communication. <p> is possible to add new objects at run-time using dynamic linking, though this is generally disparaged in hard real-time environments. 5 We assume that the security implications of using active demultiplexing are addressed via the CORBA security service. 6 demultiplexing strategy in TAO, which is our high performance, real-time ORB <ref> [18] </ref>.
Reference: [19] <author> David L. Tennenhouse. </author> <title> Layered Multiplexing Considered Harmful. </title> <booktitle> In Pro ceedings of the 1 st International Workshop on High-Speed Networks, </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: Demultiplexing client requests through all these layers is expensive, particularly when a large number of operations appear in an IDL interface and/or a large number of servants are managed by an ORB. Layered demultiplexing is particularly inappropriate for real-time applications <ref> [19] </ref> because it increases latency by increasing the number of times that internal tables must be searched while incoming client requests traverse various protocol processing layers. <p> It runs on a range of OS platforms that support real-time features including VxWorks, Solaris 2.x, and Windows NT. TAO provides a highly optimized version of SunSoft's implementation of the CORBA Internet Inter-ORB Protocol (IIOP)[8]. 1 TAO's Object Adapter is designed to minimize overhead via de-layered demultiplexing <ref> [19] </ref> shown in Figure 2. This approach maps client requests directly to servant/operation tuples that perform application-level upcalls. <p> For instance, <ref> [19, 4, 2] </ref> study demultiplexing issues in communication systems and show how layered demultiplexing is not suitable for applications that require real-time quality of service guarantees. 3 Detailed description on the four demultiplexing strategies is available at URL http://www.cs.wustl.edu/~schmidt/GLOBECOM-97.ps.gz 3 Packet filters are a mechanism for efficiently demultiplexing incoming packets to
Reference: [20] <author> Steve Vinoski. </author> <title> CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments. </title> <journal> IEEE Communications Magazine, </journal> <volume> 14(2), </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: In addition, CORBA shields applications from non-portable details related to the OS/hardware platform they run on and the communication protocols and networks used to interconnect distributed objects <ref> [20] </ref>. However, the performance and features of current CORBA implementations are not yet suited for hard real-time systems (e.g., avionics) and constrained latency systems (e.g., teleconferencing) due to overheads incurred by conventional Object Request Brokers (ORBs).
Reference: [21] <author> M. Yuhara, B. Bershad, C. Maeda, and E. Moss. </author> <title> Efficient Packet Demulti plexing for Multiple Endpoints and Large Messages. </title> <booktitle> In Proceedings of the Winter Usenix Conference, </booktitle> <month> January </month> <year> 1994. </year> <month> 7 </month>
Reference-contexts: A number of schemes to implement fast and efficient packet filters are available. These include the BSD Packet Filter (BPF) [12], the Mach Packet Filter (MPF) <ref> [21] </ref>, PathFinder [1], demultiplexing based on automatic parsing [11], and the Dynamic Packet Filter (DPF) [3]. Most existing demultiplexing strategies are implemented within the OS kernel. However, to optimally reduce ORB endsystem de-multiplexing overhead requires a vertically integrated architecture that extends from the OS kernel to the application servants.
References-found: 21

