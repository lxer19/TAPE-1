URL: http://osl.cs.uiuc.edu/Papers/nielsen-ren-agha.ps
Refering-URL: http://osl.cs.uiuc.edu/Papers/RT.html
Root-URL: http://www.cs.uiuc.edu
Email: Email: bnielsen@cs.auc.dk  Email: f ren j agha g@cs.uiuc.edu  
Title: Specification of Real-Time Interaction Constraints  
Author: Brian Nielsen Shangping Ren Gul Agha 
Address: Fredrik Bajersvej 7E DK-9220 Aalborg, Denmark  1304 W. Springfield Av. Urbana, Illinois 61801, U.S.A  
Affiliation: Aalborg University Dpt. of Computer Science  University of Illinois at Urbana-Champaign Dpt. of Computer Science  
Abstract: We present a coordination language and its semantics for specification and implementation of object-oriented real-time systems. Real-time systems operate under real-time constraints, and our language supports expression thereof. In our language, a system is modeled by two separate but complementary descriptions: A collection of objects define the system's structure and functional behavior, and a set of interaction constraints define how these objects may interact. Our language thereby supports development of real-time systems by enabling objects build in isolation or reused from other systems to be composed via interaction constraints. We use the Actor model to describe objects and the concept of real-time synchronizers to describe interaction constraints. Our model is accompanied by a formal semantics that precisely defines what real-time constraints means, and what constitutes a program's correct real-time behaviors. The semantics defines how the system may evolve in the real-time domain, and what progress guarantees the language makes. We briefly discuss implementation problems and potential solutions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, Los Alamitos, </publisher> <address> California, </address> <year> 1986. </year> <note> ISBN 0-262-01092-5. </note>
Reference-contexts: To our knowledge composition filters has not been defined formally. Section 2 introduces and exemplifies our model. Section 3 provides the formal definition. Finally, in Section 4 we discuss our implementation ideas. 2. Specification of interaction constraints In the Actor model <ref> [1, 2, 4] </ref> distributed computing entities (hardware or software) are modeled as abstract self contained objects called actors. An actor encapsulates a state, provides a set of public methods, and potentially invokes public methods in other objects by means of message passing.
Reference: [2] <author> G. Agha. </author> <title> Concurrent Object-Oriented Programming. </title> <booktitle> Com munications of the ACM, </booktitle> <address> 33(9):125141, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: To our knowledge composition filters has not been defined formally. Section 2 introduces and exemplifies our model. Section 3 provides the formal definition. Finally, in Section 4 we discuss our implementation ideas. 2. Specification of interaction constraints In the Actor model <ref> [1, 2, 4] </ref> distributed computing entities (hardware or software) are modeled as abstract self contained objects called actors. An actor encapsulates a state, provides a set of public methods, and potentially invokes public methods in other objects by means of message passing.
Reference: [3] <author> G. Agha. </author> <title> Modeling Concurrent Systems: Actors, Nets, and the Problem of Abstraction and Composition. </title> <booktitle> In 17th In ternational Conference on Application and Theory of Petri Nets, </booktitle> <address> Osaka, Japan, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: When an actor executed a become it created a new anonymous actor to carry out the rest of its computation, and prepared itself to receive a new message. Thus, in the classic model, actors were multi-threaded, and tended to be extremely fine-grained. In recent literature <ref> [3] </ref>, the simpler ready has replaced become, with essentially no loss of expressiveness.
Reference: [4] <author> G. Agha, I. A. Mason, S. F. Smith, and C. L. Talcott. </author> <title> A Foundation for Actor Computation. </title> <journal> Journal of Functional Programming, </journal> <note> page 68pp, To be published. </note>
Reference-contexts: To our knowledge composition filters has not been defined formally. Section 2 introduces and exemplifies our model. Section 3 provides the formal definition. Finally, in Section 4 we discuss our implementation ideas. 2. Specification of interaction constraints In the Actor model <ref> [1, 2, 4] </ref> distributed computing entities (hardware or software) are modeled as abstract self contained objects called actors. An actor encapsulates a state, provides a set of public methods, and potentially invokes public methods in other objects by means of message passing. <p> Semantics of Actors We define a transition system for the actor-language. This defines how the state of the actor system changes when a primitive operation is performed, thus giving an abstract interpretation. The actor semantics presented here is inspired by the work of <ref> [4] </ref> where additional information can be found, but our is imperative in style, whereas [4] is applicative. Our semantic model abstracts away the notion of methods. Instead, each actor has a single behaviora sequence of statementsthat it applies to every incoming message. <p> This defines how the state of the actor system changes when a primitive operation is performed, thus giving an abstract interpretation. The actor semantics presented here is inspired by the work of <ref> [4] </ref> where additional information can be found, but our is imperative in style, whereas [4] is applicative. Our semantic model abstracts away the notion of methods. Instead, each actor has a single behaviora sequence of statementsthat it applies to every incoming message.
Reference: [5] <author> M. Aksit, J. Bosch, W. van der Sterren, and L. Bergmans. </author> <title> Real-Time Specification Inheritance Anomalies and Real Time Filters. </title> <booktitle> In Proceedings ECOOP, </booktitle> <pages> pages 386407, </pages> <year> 1994. </year>
Reference-contexts: We define a destilled language, RT-Synchronizers , and provide an operational semantics that defines the real-time behavior of a constrained actor-program. Related work that permit separate specification of real-time and synchronization constraints is <ref> [5] </ref> which proposes the composition filter model. Real-time input and output filters declared in an extended interface enable the specification of time bounds on method executions. Among many, one difference is that RT-Synchronizers takes a global view of a collection of objects rather than of a single object.
Reference: [6] <author> R. Alur, C. Courcoubetis, and D. Dill. </author> <title> Modelchecking for realtime systems. </title> <booktitle> In Proceedings of the Fifth IEEE Sympo sium on Logic in Computer Science, </booktitle> <pages> pages 414425, </pages> <year> 1990. </year>
Reference-contexts: Our approach to defining the semantics is inspired by the recent years research in formal specification languages for real-time systems, and the use of timed transition systems are borrowed from these languages. Often, the languages take the form of extended automata (Timed automata <ref> [6] </ref>, Timed Graphs [6, 11]), or process algebras such as Timed CSP [16]. A different approach is to include a model of the underlying execution resources. This approach is taken in [15] and [19]. <p> Our approach to defining the semantics is inspired by the recent years research in formal specification languages for real-time systems, and the use of timed transition systems are borrowed from these languages. Often, the languages take the form of extended automata (Timed automata [6], Timed Graphs <ref> [6, 11] </ref>), or process algebras such as Timed CSP [16]. A different approach is to include a model of the underlying execution resources. This approach is taken in [15] and [19].
Reference: [7] <author> S. Frlund. </author> <title> Constraint-Based Synchronization of Distributed Activities. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana Champaign, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: What goes on inside an object is encapsulated, and cannot be constrained. Specifically, a collection of synchronizer-entities constrain by delaying or accelerating message invocations. We use the object-oriented Actor-model to describe objects. The idea of separating functional behavior and interaction policies for Actors were first proposed by Frlund in <ref> [7] </ref>, but only logical synchronization constraints could be specified. Later Ren in [13] made a first proposal for a dual language where real-time constraints could be expressed. Our work is a continuation of this line of research where we have emphasized a formal treatment of the model.
Reference: [8] <author> R. Gerber and I. Lee. </author> <title> Communicating Shared Resources: A Model for Distributed Real-Time Systems. </title> <booktitle> In Proc. Real Time Systems Symposium, </booktitle> <pages> pages 6878, </pages> <address> Santa Monica, CA, USA, 1989. </address> <publisher> IEEE. </publisher>
Reference-contexts: This approach is taken in [15] and [19]. The resulting semantics includes an abstract model of the execution environment (number of CPU's, scheduler, execution time of assignments etc.). The process algebra Communicating Shared Resources (CSR) has been designed with the explicit purpose of modeling resources <ref> [8, 9] </ref>. A process always runs on some, possibly shared, resource. A set of processes can be mapped to different sets of resources, hence describing different implementations. Thus, these approaches model relative concrete system, rather than being specifications for a set of possible systems, as is our goal. 4.
Reference: [9] <author> R. Gerber and I. Lee. </author> <title> A Layered Approach to Automating the Verification of Real-Time Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(9):768784, </volume> <month> September </month> <year> 1992. </year>
Reference-contexts: This approach is taken in [15] and [19]. The resulting semantics includes an abstract model of the execution environment (number of CPU's, scheduler, execution time of assignments etc.). The process algebra Communicating Shared Resources (CSR) has been designed with the explicit purpose of modeling resources <ref> [8, 9] </ref>. A process always runs on some, possibly shared, resource. A set of processes can be mapped to different sets of resources, hence describing different implementations. Thus, these approaches model relative concrete system, rather than being specifications for a set of possible systems, as is our goal. 4.
Reference: [10] <author> B. Kirk, L. Nigro, and F. Pupo. </author> <title> Using Real Time Constraints for Modularisation. </title> <booktitle> In Joint Modular Language Conference, </booktitle> <address> March 1997. Linz. </address>
Reference-contexts: In essence this requires the programmer to manually perform (deadline) constraint propagation and solving as part of the programming task. This fits with the philosophy that turning a specification into a program is a matter of refining specifications by gradually introducing more and more detail. A recent result is <ref> [10] </ref> where certain aspects of RT-Synchronizers are implemented in their DART framework where constraints are used to dynamically instruct the scheduler about delays and deadlines of messages. However the paper gives no systematic (automatic) translation of of constraints to scheduling information.
Reference: [11] <author> X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> Compiling Real-Time Specifications into Extended Automata. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(9):805816, </volume> <month> September </month> <year> 1992. </year>
Reference-contexts: The idea is that system execution can be observed by alternatingly observing a set instaneous transitions and observing a delay. In <ref> [11] </ref> this idea was termed the two-phase functioning principle: System state evolves alter-natingly by performing a sequence of instantaneous actions and by letting time pass. By adding the rule: ffff "(d) ! ff j ffff , we extend ! transition relation with the ability of letting time pass. <p> Our approach to defining the semantics is inspired by the recent years research in formal specification languages for real-time systems, and the use of timed transition systems are borrowed from these languages. Often, the languages take the form of extended automata (Timed automata [6], Timed Graphs <ref> [6, 11] </ref>), or process algebras such as Timed CSP [16]. A different approach is to include a model of the underlying execution resources. This approach is taken in [15] and [19].
Reference: [12] <author> S. Ren. </author> <title> An Actor-Based Framework for Real-Time Coordina tion. </title> <type> PhD thesis, </type> <institution> Department Computer Science. University of Illinois at Urbana-Champaign, </institution> <year> 1997. </year> <type> PhD. Thesis. </type>
Reference-contexts: Conflicting constraints that have no solutions should be detected as part of the compilers static program check. Ren has in <ref> [12] </ref> showed how RT-Synchronizers - constraints can be mapped to linear inequality systems for which polynomial time algorithms exist for detecting solv ability. <p> We propose to let the compiler compute a conservative version of the causality graph annotated with worst case ex ecution time and message propagation delays, and include a copy of it at runtime <ref> [12] </ref>. The runtime system then has the information necessary to propagate constraints automatically. The cost of this scheme is the space needed to store the causality graph and the time required to do the propagation.
Reference: [13] <author> S. Ren and G. Agha. RT-Synchronizer: </author> <title> Language Support for Real-Time Specifications in Distributed Systems. </title> <journal> ACM Sigplan Notices, </journal> <volume> 30(11), </volume> <month> November </month> <year> 1995. </year> <booktitle> Proceedings of the ACM Sigplan 1995 Workshop on Languages, Compilers, and Tools for Real-Time Systems. </booktitle>
Reference-contexts: Specifically, a collection of synchronizer-entities constrain by delaying or accelerating message invocations. We use the object-oriented Actor-model to describe objects. The idea of separating functional behavior and interaction policies for Actors were first proposed by Frlund in [7], but only logical synchronization constraints could be specified. Later Ren in <ref> [13] </ref> made a first proposal for a dual language where real-time constraints could be expressed. Our work is a continuation of this line of research where we have emphasized a formal treatment of the model.
Reference: [14] <author> M. Saksena, P. Freedman, and P. Rodziewicz. </author> <title> Guidelines for Automated Implementation of Executable Object Oriented Models for Real-Time Embedded Control Software. </title> <booktitle> In 18th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 240251. </pages> <publisher> IEEE, </publisher> <month> December </month> <year> 1997. </year>
Reference-contexts: Similar restrictions can be made to RT-Synchronizers . With simple dependencies between periodic tasks generalized rate-monotonic analysis can be utilized [18]. The Real-time Object-Oriented Modeling method (ROOM) [17], which has many notions in common with the actor-model, has recently been extended with notions for specifying real-time properties <ref> [14] </ref>: Message sequence charts with annotated timing information can be used to express activation periods of methods or end-to-end deadlines on sequences of message invocations. With these two kinds of constraints and a few design guidelines the authors show how scheduling theory can be applied to room-models.
Reference: [15] <author> I. Satoh and M. Tokoro. </author> <title> Semantics for a Real-Time Object Oriented Programming Language. </title> <booktitle> In Int. Conf. on Computer Languages, </booktitle> <pages> pages 159170, </pages> <address> Toulouse, France, 1994. </address> <publisher> IEEE. </publisher>
Reference-contexts: Often, the languages take the form of extended automata (Timed automata [6], Timed Graphs [6, 11]), or process algebras such as Timed CSP [16]. A different approach is to include a model of the underlying execution resources. This approach is taken in <ref> [15] </ref> and [19]. The resulting semantics includes an abstract model of the execution environment (number of CPU's, scheduler, execution time of assignments etc.). The process algebra Communicating Shared Resources (CSR) has been designed with the explicit purpose of modeling resources [8, 9].
Reference: [16] <author> S. Schneider. </author> <title> An Operational Semantics for Timed CSP. In formation and Computation, </title> <address> 116:193213, </address> <year> 1995. </year>
Reference-contexts: Often, the languages take the form of extended automata (Timed automata [6], Timed Graphs [6, 11]), or process algebras such as Timed CSP <ref> [16] </ref>. A different approach is to include a model of the underlying execution resources. This approach is taken in [15] and [19]. The resulting semantics includes an abstract model of the execution environment (number of CPU's, scheduler, execution time of assignments etc.).
Reference: [17] <author> B. Selic, G. Gullekson, and P. T. Ward. </author> <title> Real-time Object oriented Modeling. </title> <publisher> Wiley Professional Computing. John Wi ley & Sons, Inc., </publisher> <address> New York, </address> <year> 1994. </year> <note> ISBN 0-471-59917-4. </note>
Reference-contexts: To make schedulability analysis practical one often restricts the types of constraints to periodic constraints. Similar restrictions can be made to RT-Synchronizers . With simple dependencies between periodic tasks generalized rate-monotonic analysis can be utilized [18]. The Real-time Object-Oriented Modeling method (ROOM) <ref> [17] </ref>, which has many notions in common with the actor-model, has recently been extended with notions for specifying real-time properties [14]: Message sequence charts with annotated timing information can be used to express activation periods of methods or end-to-end deadlines on sequences of message invocations.
Reference: [18] <author> L. Sha, R. Rajkumar, and S. S. Sathaye. </author> <title> Generalized Rate Monotonic Scheduling Theory: A Framework for Develop ing Real-Time Systems. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 82(1):68 82, </volume> <month> January </month> <year> 1994. </year>
Reference-contexts: Additionally, a full verification of the implemented system is rarely practical. To make schedulability analysis practical one often restricts the types of constraints to periodic constraints. Similar restrictions can be made to RT-Synchronizers . With simple dependencies between periodic tasks generalized rate-monotonic analysis can be utilized <ref> [18] </ref>.
Reference: [19] <author> P. Zhou and J. Hooman. </author> <title> A Proof Theory for Asynchronously Communicating Real-Time Systems. </title> <booktitle> In Proc. Real-Time Systems Symposium, </booktitle> <pages> pages 177186, </pages> <address> Phoenix, AZ, USA, 1992. </address> <publisher> IEEE. </publisher>
Reference-contexts: Often, the languages take the form of extended automata (Timed automata [6], Timed Graphs [6, 11]), or process algebras such as Timed CSP [16]. A different approach is to include a model of the underlying execution resources. This approach is taken in [15] and <ref> [19] </ref>. The resulting semantics includes an abstract model of the execution environment (number of CPU's, scheduler, execution time of assignments etc.). The process algebra Communicating Shared Resources (CSR) has been designed with the explicit purpose of modeling resources [8, 9]. A process always runs on some, possibly shared, resource.
References-found: 19

