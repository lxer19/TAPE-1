URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr95/tr95-032.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr95-abstracts.html
Root-URL: http://www.cis.ufl.edu
Abstract-found: 0
Intro-found: 1
Reference: [ACL91] <author> R. Agrawal, R. Cochrane, and B. Lindsay. </author> <title> On maintaining priorities in a production rule system. </title> <booktitle> In Proceedings International Conference on Very Large Data Bases, </booktitle> <pages> pages 479-487, </pages> <address> Barcelona, Spain, </address> <year> 1991. </year>
Reference-contexts: If an active database system randomly chooses a rule to execute (out of several triggered rules), the final database state is nondeterministic. This adds to the problem of understanding applications that trigger rules. Priorities are generally used to deal with conflict resolution of rules <ref> [SHP88, C + 89, ACL91, Han92] </ref>. When multiple conflicting rules are triggered at the same time, a rule with the highest priority is selected for execution. [AWH92] focuses on testing whether or not given a rule set has the confluence property. <p> For the above reasons, we do not consider this approach in our work. A somewhat different approach taken in active database systems such as Starburst <ref> [AWH92, ACL91] </ref> and Postgres [SHP88, SJGP90] is to statically assign execution priorities over rules. In these systems if multiple rules are triggered, a rule with the highest priority among them is executed first.
Reference: [AMC93] <author> E. Anwar, L. Maugis, and S. Chakravarthy. </author> <title> A new perspective on rule support for object-oriented databases. </title> <booktitle> In Proceedings International Conference on Management of Data, </booktitle> <pages> pages 99-108, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Incorporating ECA rules (Event-Condition-Action rules) enhances the functionality of traditional database systems significantly <ref> [C + 89, GJ91, AMC93, HW93] </ref>. Also, ECA rules provide flexible alternatives for implementing many database features, such as integrity constraint enforcement, that are traditionally hard-wired into a DBMS [CW90, SJGP90, WF90, CW91, WCL91]. An ECA-rule consists of three parts: event, condition, and action.
Reference: [AWH92] <author> A. Aiken, J. Widom, and J. Hellerstein. </author> <title> Behavior of database production rules: Termination, confluence, and observable determinism. </title> <booktitle> In Proceedings International Conference on Management of Data, </booktitle> <pages> pages 59-68, </pages> <address> San Diego, CA, </address> <year> 1992. </year>
Reference-contexts: A disjunction occurs when either component event occurs [CKAK94]. Now, if event E 1 occurs, it will trigger both r i and r j . As addressed in <ref> [AWH92] </ref>, multiple triggered rules pose problems when different execution orders can produce different final database states. If an active database system randomly chooses a rule to execute (out of several triggered rules), the final database state is nondeterministic. This adds to the problem of understanding applications that trigger rules. <p> This adds to the problem of understanding applications that trigger rules. Priorities are generally used to deal with conflict resolution of rules [SHP88, C + 89, ACL91, Han92]. When multiple conflicting rules are triggered at the same time, a rule with the highest priority is selected for execution. <ref> [AWH92] </ref> focuses on testing whether or not given a rule set has the confluence property. A rule set is said to be confluent if any permutation of the rules yields the same final database state when the rules are executed. <p> For the above reasons, we do not consider this approach in our work. A somewhat different approach taken in active database systems such as Starburst <ref> [AWH92, ACL91] </ref> and Postgres [SHP88, SJGP90] is to statically assign execution priorities over rules. In these systems if multiple rules are triggered, a rule with the highest priority among them is executed first. <p> Depending on the execution order of triggering rules, directly conflicting rules may be executed in a different order from what the user specified, likely resulting non-confluent rule executions. Unless all the direct conflicts are removed by rewriting the rules, one possible remedy for this problem, implied in Starburst <ref> [AWH92] </ref>, would be to regard the indirectly conflicting rules as conflicting ones. Figure 1 (b) illustrates how conflicts of Figure 1 (a) are propagated toward ancestor rules in trigger relationship if this approach is taken. An undesirable consequence of propagating conflicts is that it severely limits parallel rule execution. <p> Nevertheless we conservatively maintain a trigger edge if there is any possibility of r i 's triggering r j . In addition, we are assuming that a trigger graph is acyclic to guarantee termination of rule executions <ref> [AWH92] </ref>. If a trigger graph contains a cycle, it is possible that once a rule in the cycle is triggered all the rules in the cycle keep triggering the next rule indefinitely.
Reference: [BFKM85] <author> L. Brownston, R. Farrell, E. Kant, and N. Martin. </author> <title> Programming Expert Systems in OPS5: An Introduction to Rule-Based Programming. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1985. </year>
Reference-contexts: eligible for execution. 1 In this paper, fl This work is partly supported by the Office of Naval Research and the Navy Command, Control and Ocean Surveillance Center RDT&E Division, and by the Rome Laboratory. 1 The definition of trigger is blurred as condition-action rules such as the production rule <ref> [BFKM85] </ref> have evolved to ECA-rules. <p> We also show that our model is a perfect fit for parallel rule executions (Section 5). Conclusions are in Section 6. 2 2 Limitations of the Earlier Rule Execution Models Early rule execution models such as one used in OPS5 <ref> [BFKM85] </ref> deal with problems of confluent rule executions only in terms of conflict resolution. When multiple rules are triggered (and eligible for execution), the rule scheduler selects a rule to execute according to a certain set of criteria such as recency of trigger time, complexity of conditions.
Reference: [C + 89] <author> S. Chakravarthy et al. Hipac: </author> <title> A research project in active, time-constrained database management (final report). </title> <type> Technical Report XAIT-89-02, </type> <institution> Xerox Advanced Information Technology, </institution> <address> Cambridge, MA, </address> <month> Aug. </month> <year> 1989. </year> <month> 18 </month>
Reference-contexts: 1 Introduction Incorporating ECA rules (Event-Condition-Action rules) enhances the functionality of traditional database systems significantly <ref> [C + 89, GJ91, AMC93, HW93] </ref>. Also, ECA rules provide flexible alternatives for implementing many database features, such as integrity constraint enforcement, that are traditionally hard-wired into a DBMS [CW90, SJGP90, WF90, CW91, WCL91]. An ECA-rule consists of three parts: event, condition, and action. <p> If an active database system randomly chooses a rule to execute (out of several triggered rules), the final database state is nondeterministic. This adds to the problem of understanding applications that trigger rules. Priorities are generally used to deal with conflict resolution of rules <ref> [SHP88, C + 89, ACL91, Han92] </ref>. When multiple conflicting rules are triggered at the same time, a rule with the highest priority is selected for execution. [AWH92] focuses on testing whether or not given a rule set has the confluence property. <p> One issue is the precision of data dependency (or dependency in general). Our definition in Section 3.2 may be too coarse as some rules might be commutative despite presence of the defined dependencies. Another issue is related to coupling modes defined in HiPAC <ref> [C + 89] </ref>. In this paper, we assumed the immediate coupling mode between. The semantics of confluent rule execution in the deferred and detached coupling modes needs to be addressed.
Reference: [CKAK94] <author> S. Chakravarthy, V. Krishnaprasad, E. Anwar, and S.-K. Kim. </author> <title> Composite events for active databases: Semantics, contexts, and detection. </title> <booktitle> In Proceedings International Conference on Very Large Data Bases, </booktitle> <pages> pages 606-617, </pages> <address> Santiago, Chile, </address> <month> Sep. </month> <year> 1994. </year>
Reference-contexts: An active database system monitors occurrences of events pre-specified by ECA rules. Once specified events have occurred, the condition part of the relevant rule is tested. If the test is satisfied, the rule's action part can be executed. In Sentinel <ref> [CKAK94] </ref>, a rule is said to be triggered when the rule has passed the event detection phase; that is, when one or more events which the rule is waiting for have occurred. <p> A disjunction occurs when either component event occurs <ref> [CKAK94] </ref>. Now, if event E 1 occurs, it will trigger both r i and r j . As addressed in [AWH92], multiple triggered rules pose problems when different execution orders can produce different final database states. <p> In our current work, however, we do not pursue this issue any further. (For event specifications in Sentinel, see <ref> [CKAK94] </ref>.) 8 4 Confluence and Priority Specification In this section we present basic ideas that give us a handle for dealing with conflicting rules in order to obtain confluent rules executions. We consider simple cases first.
Reference: [CW90] <author> S. Ceri and J. Widom. </author> <title> Deriving production rules for constraint maintenance. </title> <booktitle> In Proceedings International Conference on Very Large Data Bases, </booktitle> <pages> pages 566-577, </pages> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Incorporating ECA rules (Event-Condition-Action rules) enhances the functionality of traditional database systems significantly [C + 89, GJ91, AMC93, HW93]. Also, ECA rules provide flexible alternatives for implementing many database features, such as integrity constraint enforcement, that are traditionally hard-wired into a DBMS <ref> [CW90, SJGP90, WF90, CW91, WCL91] </ref>. An ECA-rule consists of three parts: event, condition, and action. Execution of ECA rules goes through three phases: event detection, condition test, and execution of action.
Reference: [CW91] <author> S. Ceri and J. Widom. </author> <title> Deriving production rules for incremental view maintenance. </title> <booktitle> In Proceedings International Conference on Very Large Data Bases, </booktitle> <pages> pages 577-589, </pages> <address> Barcelona, Spain, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Incorporating ECA rules (Event-Condition-Action rules) enhances the functionality of traditional database systems significantly [C + 89, GJ91, AMC93, HW93]. Also, ECA rules provide flexible alternatives for implementing many database features, such as integrity constraint enforcement, that are traditionally hard-wired into a DBMS <ref> [CW90, SJGP90, WF90, CW91, WCL91] </ref>. An ECA-rule consists of three parts: event, condition, and action. Execution of ECA rules goes through three phases: event detection, condition test, and execution of action.
Reference: [GJ91] <author> N. Gehani and H. Jagadish. </author> <title> Ode as an active database: Constraints and triggers. </title> <booktitle> In Proceedings International Conference on Very Large Data Bases, pages 327-and 336, </booktitle> <address> Barcelona, Spain, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Incorporating ECA rules (Event-Condition-Action rules) enhances the functionality of traditional database systems significantly <ref> [C + 89, GJ91, AMC93, HW93] </ref>. Also, ECA rules provide flexible alternatives for implementing many database features, such as integrity constraint enforcement, that are traditionally hard-wired into a DBMS [CW90, SJGP90, WF90, CW91, WCL91]. An ECA-rule consists of three parts: event, condition, and action.
Reference: [Han92] <author> E. Hanson. </author> <title> The design and implementation of the Ariel active database rule system. </title> <type> Technical Report UF-CIS-018-92, </type> <institution> CIS Department, University of Florida, </institution> <address> Gainesville, FL 32611, </address> <year> 1992. </year>
Reference-contexts: If an active database system randomly chooses a rule to execute (out of several triggered rules), the final database state is nondeterministic. This adds to the problem of understanding applications that trigger rules. Priorities are generally used to deal with conflict resolution of rules <ref> [SHP88, C + 89, ACL91, Han92] </ref>. When multiple conflicting rules are triggered at the same time, a rule with the highest priority is selected for execution. [AWH92] focuses on testing whether or not given a rule set has the confluence property.
Reference: [HW93] <author> E. Hanson and J. Widom. </author> <title> An overview of production rules in database systems. </title> <journal> The Knowledge Engineering Review, </journal> <volume> 8(3) </volume> <pages> 121-143, </pages> <month> Sep. </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Incorporating ECA rules (Event-Condition-Action rules) enhances the functionality of traditional database systems significantly <ref> [C + 89, GJ91, AMC93, HW93] </ref>. Also, ECA rules provide flexible alternatives for implementing many database features, such as integrity constraint enforcement, that are traditionally hard-wired into a DBMS [CW90, SJGP90, WF90, CW91, WCL91]. An ECA-rule consists of three parts: event, condition, and action.
Reference: [KC95] <author> Seung-Kyum Kim and S. Chakravarthy. </author> <title> A confluent rule execution model for active databases. </title> <type> Technical Report UF-CISE-, </type> <institution> CISE Department, University of Florida, </institution> <address> Gainesville, FL 32611, </address> <year> 1995. </year>
Reference-contexts: In order to handle overlapping trigger paths, we have explored other alternatives than the strict order-preserving rule execution. Serial trigger-path execution and serializable trigger-path execution are them, but due to space limit they are omitted in this paper. The full description of these alternative is found in <ref> [KC95] </ref>. We are currently investigating other issues not addressed in this paper. One issue is the precision of data dependency (or dependency in general). Our definition in Section 3.2 may be too coarse as some rules might be commutative despite presence of the defined dependencies.
Reference: [SHP88] <author> M. Stonebraker, E. Hanson, and S. Potamianos. </author> <title> The POSTGRES rule manager. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(7) </volume> <pages> 897-907, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: If an active database system randomly chooses a rule to execute (out of several triggered rules), the final database state is nondeterministic. This adds to the problem of understanding applications that trigger rules. Priorities are generally used to deal with conflict resolution of rules <ref> [SHP88, C + 89, ACL91, Han92] </ref>. When multiple conflicting rules are triggered at the same time, a rule with the highest priority is selected for execution. [AWH92] focuses on testing whether or not given a rule set has the confluence property. <p> For the above reasons, we do not consider this approach in our work. A somewhat different approach taken in active database systems such as Starburst [AWH92, ACL91] and Postgres <ref> [SHP88, SJGP90] </ref> is to statically assign execution priorities over rules. In these systems if multiple rules are triggered, a rule with the highest priority among them is executed first. <p> Therefore, it is not realistic to provide every possible alternative for these cases. Rather, a much less general scheme of priority specification, which provides only some specific alternatives, needs to be considered. the priority scheme adopted in Postgres <ref> [SHP88] </ref>. Numbers in brackets denote absolute priorities associated with rules. A larger number denotes a higher priority. This priority specification guarantees confluent rule executions although non-conflicting rules (r i and r j ) too need to be assigned priorities.
Reference: [SJGP90] <author> M. Stonebraker, A. Jhingran, J. Goh, and S. Potamianos. </author> <title> On rules, procedures, caching and views in database systems. </title> <booktitle> In Proceedings International Conference on Management of Data, </booktitle> <pages> pages 281-290, </pages> <address> Atlantic City, NJ, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Incorporating ECA rules (Event-Condition-Action rules) enhances the functionality of traditional database systems significantly [C + 89, GJ91, AMC93, HW93]. Also, ECA rules provide flexible alternatives for implementing many database features, such as integrity constraint enforcement, that are traditionally hard-wired into a DBMS <ref> [CW90, SJGP90, WF90, CW91, WCL91] </ref>. An ECA-rule consists of three parts: event, condition, and action. Execution of ECA rules goes through three phases: event detection, condition test, and execution of action. <p> For the above reasons, we do not consider this approach in our work. A somewhat different approach taken in active database systems such as Starburst [AWH92, ACL91] and Postgres <ref> [SHP88, SJGP90] </ref> is to statically assign execution priorities over rules. In these systems if multiple rules are triggered, a rule with the highest priority among them is executed first.
Reference: [WCL91] <author> J. Widom, R. Cochrane, and B. Lindsay. </author> <title> Implementing set-oriented production rules as an extension to starburst. </title> <booktitle> In Proceedings International Conference on Very Large Data Bases, </booktitle> <pages> pages 275-285, </pages> <address> Barcelona, Spain, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Incorporating ECA rules (Event-Condition-Action rules) enhances the functionality of traditional database systems significantly [C + 89, GJ91, AMC93, HW93]. Also, ECA rules provide flexible alternatives for implementing many database features, such as integrity constraint enforcement, that are traditionally hard-wired into a DBMS <ref> [CW90, SJGP90, WF90, CW91, WCL91] </ref>. An ECA-rule consists of three parts: event, condition, and action. Execution of ECA rules goes through three phases: event detection, condition test, and execution of action.
Reference: [WF90] <author> J. Widom and S. Finkelstein. </author> <title> Set-oriented production rules in relational database systems. </title> <booktitle> In Proceedings International Conference on Management of Data, </booktitle> <pages> pages 259-270, </pages> <address> Atlantic City, NJ, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Incorporating ECA rules (Event-Condition-Action rules) enhances the functionality of traditional database systems significantly [C + 89, GJ91, AMC93, HW93]. Also, ECA rules provide flexible alternatives for implementing many database features, such as integrity constraint enforcement, that are traditionally hard-wired into a DBMS <ref> [CW90, SJGP90, WF90, CW91, WCL91] </ref>. An ECA-rule consists of three parts: event, condition, and action. Execution of ECA rules goes through three phases: event detection, condition test, and execution of action.
References-found: 16

