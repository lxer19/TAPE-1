URL: http://ptolemy.eecs.berkeley.edu/papers/real_time/icassp95.ps.Z
Refering-URL: http://ptolemy.eecs.berkeley.edu/papers/real_time/
Root-URL: 
Email: fparks,ealg@EECS.Berkeley.EDU  
Title: NON-PREEMPTIVE REAL-TIME SCHEDULING OF DATAFLOW SYSTEMS  
Author: Thomas M. Parks and Edward A. Lee 
Address: Berkeley CA 94720  
Affiliation: Department of Electrical Engineering and Computer Sciences University of California,  
Date: May 1995  
Note: Presented at the IEEE International Conference on Acoustics, Speech, and Signal Processing  
Abstract: Real-time signal processing applications can be described naturally with dataflow graphs. The systems we consider have a mix of real-time and non-real-time processing, where independent dataflow graphs represent tasks and individual dataflow actors are subtasks. Rate-monotonic scheduling is optimal for fixed-priority, preemptive scheduling of periodic tasks. Priority inheritance protocols extend rate-monotonic scheduling theory to include tasks that contend for exclusive access to shared resources. We show that non-preemptive rate-monotonic scheduling can be viewed as preemptive scheduling where the processor is explicitly considered a shared resource. We propose a dynamic, real-time execution model inspired by multithreaded dataflow architectures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Edward Ashford Lee and David G. Messerschmitt. </author> <title> Static scheduling of synchronous data flow programs for digital signal processing. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(1):24-35, </volume> <month> January </month> <year> 1987. </year>
Reference: [2] <author> Ronald E. Crochiere and Lawrence R. Rabiner. </author> <title> Multirate Digital Signal Processing. </title> <booktitle> Prentice-Hall Signal Processing Series. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1983. </year>
Reference-contexts: For example, the problem of converting from the compact disc (CD) sampling rate of 44.1 kHz to the digital audio tape (DAT) rate of 48 kHz in multiple stages <ref> [2] </ref> is easy to express with the SDF model.
Reference: [3] <author> Jose Luis Pino, Thomas M. Parks, and Edward A. Lee. </author> <title> Mapping multiple independent synchronous dataflow graphs onto heterogeneous multiprocessors. </title> <booktitle> In Asilomar Conference on Signals, Systems and Computers, </booktitle> <year> 1994. </year>
Reference-contexts: Signal processing systems that have a mix of periodic, real-time tasks and non-real-time user interface tasks can be described with multiple independent SDF graphs <ref> [3] </ref>, where each dataflow graph is a task and the individual actors in the graph are subtasks that cannot be preempted.
Reference: [4] <author> Michael R. Garey and David S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: The problem of sequencing a set of tasks with execution times, release times and deadlines on a single processor is NP-compete <ref> [4] </ref>. There is a large body of literature in the operations research community that deals with this and similar problems. A review of static real-time scheduling techniques is beyond the scope of this paper. Dataflow schedulers commonly ignore timing constraints.
Reference: [5] <author> C. L. Liu and James W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard-real-time environment. </title> <journal> Journal of the ACM, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: Fixed priorities can simplify the implementation of the run-time scheduler and allow predictable, graceful degradation in overload situations: low priority tasks are the first to miss their deadlines. The rate-monotonic priority assignment <ref> [5, 6] </ref> is an optimal fixed-priority scheme for independent, periodic real-time tasks. Priority inheritance protocols [7] extend rate-monotonic scheduling theory to periodic tasks that are not independent, but must contend for exclusive access to shared resources. In this paper we apply these results from preemptive scheduling theory to non-preemptive scheduling. <p> Because such fine-grain synchronization proved to be a bottleneck, dataflow machines have evolved to support coarse-grain synchronization for threads of sequential instructions. We extend TAM to support static schedules, task suspension, and priorities so that it can be used for real-time systems. 2. RATE-MONOTONIC SCHEDULING In their landmark paper <ref> [5] </ref>, Liu and Layland address the problem of prioritized, preemptive scheduling for a set of independent, periodic real-time tasks. Each task is characterized by a period, T i and an execution time C i . <p> Liu and Layland prove that the rate-monotonic priority assignment, where tasks with a higher rate (shorter period) receive a higher priority, is optimal among all fixed-priority schemes in the following sense: Theorem 1 <ref> [5] </ref> If a feasible priority assignment exists for some task set, the rate-monotonic priority assignment is feasible for that task set. A feasible priority assignment guarantees that each invocation of a task completes execution before its deadline at the beginning of the next period.
Reference: [6] <author> J. P. Lehoczky, L. Sha, and Y. Ding. </author> <title> The rate monotonic scheduling algorithm: Exact characterization and average case behavior. </title> <booktitle> In IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 166-171, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Fixed priorities can simplify the implementation of the run-time scheduler and allow predictable, graceful degradation in overload situations: low priority tasks are the first to miss their deadlines. The rate-monotonic priority assignment <ref> [5, 6] </ref> is an optimal fixed-priority scheme for independent, periodic real-time tasks. Priority inheritance protocols [7] extend rate-monotonic scheduling theory to periodic tasks that are not independent, but must contend for exclusive access to shared resources. In this paper we apply these results from preemptive scheduling theory to non-preemptive scheduling. <p> A feasible priority assignment guarantees that each invocation of a task completes execution before its deadline at the beginning of the next period. A set of N tasks can be scheduled using rate-monotonic priorities if and only if <ref> [6] </ref>: 8i; 1 i N min i X C j ~ T j 1 where R i = f (k; l)j1 k i; 1 l bT i =T k cg.
Reference: [7] <author> Lui Sha, Ragunathan Rajkumar, and John P. Lehoczky. </author> <title> Priority inheritance protocols: An approach to real-time synchronization. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(9) </volume> <pages> 1175-1185, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Fixed priorities can simplify the implementation of the run-time scheduler and allow predictable, graceful degradation in overload situations: low priority tasks are the first to miss their deadlines. The rate-monotonic priority assignment [5, 6] is an optimal fixed-priority scheme for independent, periodic real-time tasks. Priority inheritance protocols <ref> [7] </ref> extend rate-monotonic scheduling theory to periodic tasks that are not independent, but must contend for exclusive access to shared resources. In this paper we apply these results from preemptive scheduling theory to non-preemptive scheduling. The advantages of non-preemptive scheduling are clear. <p> Because priorities are fixed, the system exhibits graceful degradation: lower priority tasks are the first to miss their deadlines in an overload situation. Non-real-time tasks can be included in the system by assigning them priorities lower than all the real-time tasks. 3. PRIORITY INHERITANCE PROTOCOLS In <ref> [7] </ref> Sha, Rajkumar and Lehoczky address the problem of prioritized, preemptive scheduling for a set of periodic real-time tasks that interact through shared resources. <p> In addition to a period T i and execution time C i , each task is characterized by a worst-case blocking time B i . A set of N tasks is schedulable using priority inheritance if <ref> [7] </ref>: (k;l)2R i j=1 lT k lT k C i + lT k 4. NON-PREEMPTIVE RATE-MONOTONIC SCHEDULING The results from priority inheritance protocols can be used to determine the processor utilization bound for non-preemptive scheduling when the processor is considered as a shared resource.
Reference: [8] <author> David E. Culler, Seth Copen Goldstein, Klaus Erik Schauser, and Thorsten von Eicken. </author> <title> Tam a compiler controlled threaded abstract machine. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18(3) </volume> <pages> 347-370, </pages> <month> July </month> <year> 1993. </year>
Reference: [9] <author> Xiaoping Yuan and Ashok K. Agrawala. </author> <title> A decomposition approach to non-preemptive scheduling in hard real-time systems. </title> <booktitle> In IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 240-248, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: There is the overhead of switching to that subtask, the execution time of that subtask, and the overhead of switching to the higher priority task before it is allowed to run. Other work on non-preemptive scheduling <ref> [9, 10] </ref> lacks the notion of a subtask: once a task begins execution it cannot be suspended and must run to completion.
Reference: [10] <author> Kevin Jeffay, Donald F. Stanat, and Charles U. Martel. </author> <title> On non-preemptive scheduling of periodic and sporadic tasks. </title> <booktitle> In IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 129-139, </pages> <month> De-cember </month> <year> 1991. </year>
Reference-contexts: There is the overhead of switching to that subtask, the execution time of that subtask, and the overhead of switching to the higher priority task before it is allowed to run. Other work on non-preemptive scheduling <ref> [9, 10] </ref> lacks the notion of a subtask: once a task begins execution it cannot be suspended and must run to completion.
Reference: [11] <author> A. Moitra. Voluntary preemption: </author> <title> A tool in the design of hard real-time systems. </title> <booktitle> In Formal Techniques in Real-Time and Fault-Tolerant Systems, </booktitle> <pages> pages 87-106, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Other work on non-preemptive scheduling [9, 10] lacks the notion of a subtask: once a task begins execution it cannot be suspended and must run to completion. Moitra <ref> [11] </ref> proposes a scheduling technique voluntary preemption that does allow a task to suspend before completion, but his bound N X C i 1 + D is more pessimistic than the one presented here. A different approach to non-preemptive rate-monotonic scheduling was taken in [12].
Reference: [12] <author> Ichiro Kuroda and Takao Nishitani. </author> <title> Asynchronous multirate system design for programmable DSPs. </title> <booktitle> In IEEE International Conference on Acoustics, Speech, and Signal Processing, </booktitle> <volume> volume 5, </volume> <pages> pages 549-552, </pages> <address> San Francisco, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: Moitra [11] proposes a scheduling technique voluntary preemption that does allow a task to suspend before completion, but his bound N X C i 1 + D is more pessimistic than the one presented here. A different approach to non-preemptive rate-monotonic scheduling was taken in <ref> [12] </ref>. They addressed the problem of scheduling periodic tasks where the timing is derived from separate hardware clocks, such as the example in figure 1.
Reference: [13] <author> Robert A. </author> <title> Iannucci. Parallel Machines: Parallel Machine Languages: The Emergence of Hybrid Dataflow Computer Achitectures. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1990. </year>
Reference-contexts: Such machines could not make effective use of pipelines and caches, which have been used very successfully in sequential, von Neumann machines. Thus dataflow machines have evolved to support coarse-grain synchronization for multiple threads of sequential instructions <ref> [13] </ref>. 6. A REAL-TIME THREADED ABSTRACT MACHINE The threaded abstract machine (TAM)[8] was developed for massively parallel architectures where the goal is to keep processor nodes busy and tolerate long-latency synchronization and communication operations. Enabled tasks are maintained on a ready queue.
Reference: [14] <author> R. S. Nikhil, G. M. Papadopoulos, and Arvind. </author> <title> ?T: A mul-tithreaded massively parallel architecture. </title> <booktitle> In International Symposium on Computer Architecture, </booktitle> <pages> pages 156-167. </pages> <institution> The Association for Computer Machinery, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Each independent dataflow graph becomes a real-time task. The sequence of actor firings for a task is computed statically. The tasks are scheduled using the non-preemptive rate-monotonic algorithm described in section 4. This execution model could be implemented in software as with TAM, or in hardware as with ?T <ref> [14] </ref> (pronounced start) which is essentially a hardware implementation of TAM. 3 7. CONCLUSION We have presented sufficient conditions for the existence of a feasible dynamic, non-preemptive rate-monotonic schedule for a set of independent, periodic real-time tasks.
Reference: [15] <author> Marc Engels, Greet Bilsen, Rudy Lauwereins, and Jean Peperstraete. </author> <title> Cyclo-static dataflow: Model and implementation. </title> <booktitle> In Asilomar Conference on Signals, Systems and Computers, </booktitle> <year> 1994. </year>
Reference-contexts: We plan to extend our scheduling methods to allow for more general timing constraints and for precedence constraints among tasks. We will also explore different system representations, such as cyclo-static dataflow <ref> [15] </ref> and process networks [16]. Cyclo-static dataflow is a generalization of synchronous dataflow that can alleviate the problem where actors with long execution times destroy the feasibility of a non-preemptive, real-time schedule.
Reference: [16] <author> Edward A. Lee. </author> <title> Dataflow process networks. </title> <institution> Memorandum UCB/ERL M94/53, Electronics Research Laboratory, University of California, Berkeley, </institution> <month> July </month> <year> 1994. </year> <month> 4 </month>
Reference-contexts: We plan to extend our scheduling methods to allow for more general timing constraints and for precedence constraints among tasks. We will also explore different system representations, such as cyclo-static dataflow [15] and process networks <ref> [16] </ref>. Cyclo-static dataflow is a generalization of synchronous dataflow that can alleviate the problem where actors with long execution times destroy the feasibility of a non-preemptive, real-time schedule.
References-found: 16

