URL: http://bugle.cs.uiuc.edu/Papers/Choices.ps.Z
Refering-URL: http://bugle.cs.uiuc.edu/Papers/papers.html
Root-URL: http://www.cs.uiuc.edu
Title: A Performance Study of An Object-Oriented, Parallel Operating System  
Author: David R. Kohr, Jr. Xingbin Zhang Daniel A. Reed Mustafizur Rahman 
Address: Urbana, Illinois 61801  Amherst, Massachusetts 01003  
Affiliation: Department of Computer Science University of Illinois  Department of Computer Science University of Massachusetts at Amherst  
Abstract: The nascent and rapidly evolving state of parallel systems often leaves parallel application developers at the mercy of inefficient, inflexible operating system software. Given the relatively primitive state of parallel systems software, maximizing the performance of parallel applications not only requires judicious tuning of both the application and system software, but occasionally, the replacement of specific system software modules with others that can more readily respond to the imposed pattern of resource demands. To assess the feasibility of application and performance tuning via malleable system software and to understand the performance penalties for detailed operating system performance data capture, we describe a set of performance instrumentation techniques for parallel, object-oriented operating systems and a set of performance experiments with Choices, an experimental, object-oriented operating system designed for use with parallel systems. Choices provides a framework for experimentation and performance optimization by encouraging the customization or replacement of individual resource management policies. These performance experiments show that (a) the performance overhead for operating system data capture is modest, (b) the penalty for malleable, object-oriented operating systems is negligible, but (c) strict adherence of implementation to design is necessary for module replacement.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Campbell, R., and Islam, N. </author> <title> A Parallel Ob ject-Oriented Operating System. In Research Directions in Concurrent Object-Oriented Programming (1992), </title> <editor> G. Agha, P. Wegner, and A. Yonezawa, Eds., </editor> <publisher> MIT Press. </publisher>
Reference-contexts: Instead, a building block approach is needed that allows one to assemble operating system modules in a variety of ways to accommodate specific application needs. In this paper, we describe a set of performance experiments with Choices <ref> [1] </ref>, an experimental, object-oriented operating system designed for use with parallel systems. <p> Later, the focus shifted to the logical organization of single processor operating systems (e.g., kernels [7], modularization [6], and process hierarchies [5]) and then to distributed system models (e.g., remote procedure calls and client/server models). Choices <ref> [1] </ref> is an experimental operating system, designed to promote experimentation with new operating system design mechanisms and with new resource management policies. By separating mechanism and policy, Choices encourages experimentation with both. Mechanisms permit reconfiguration of operating system components to support new parallel architectures and applications.
Reference: [2] <author> Campbell, R. H., Islam, N., Johnson, R., Kougiouris, P., and Madany, P. </author> <title> Choices, Frameworks and Refinement. </title> <booktitle> In Object-Orientation in Operating Systems (Palo Alto, </booktitle> <address> CA, </address> <month> Oct. </month> <year> 1991), </year> <editor> Luis-Felipe Cabrera and Vincent Russo, and Marc Shapiro, Ed., </editor> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 9-15. </pages>
Reference-contexts: The object-oriented application interface has a name server that implements inheritance and polymorphism and provides access to system services, local and remote servers, and persistent objects. In the Choices design, a conceptual framework subsumes the conventional organization of an operating system as a group of layers <ref> [18, 2] </ref>. The framework for the system provides generalized components and constraints to which the specialized subframeworks must conform.
Reference: [3] <author> Campbell, R. H., Islam, N., and Madany, P. </author> <title> Choices, Frameworks and Refinement. </title> <booktitle> Computing Systems 5, 3 (1992), </booktitle> <pages> 217-257. 22 </pages>
Reference-contexts: By separating mechanism and policy, Choices encourages experimentation with both. Mechanisms permit reconfiguration of operating system components to support new parallel architectures and applications. For policy experiments, Choices supports a set of components that can be combined to support different models of parallel programming <ref> [3] </ref>. Generic components are customized through object-oriented inheritance and specialization to match the specific concurrency requirements of applications. 2.1 Design Philosophy Choices has, as its kernel, a dynamic collection of C++ objects [11]. System resources, mechanisms, and policies are represented as objects that belong to a class hierarchy [18].
Reference: [4] <author> Denning, P. J. </author> <title> Working Sets Past and Present. </title> <journal> IEEE Tranactions on Software Engineering (Jan. </journal> <year> 1980), </year> <pages> 64-84. </pages>
Reference-contexts: During the early years, resource management policies (e.g., virtual memory and backing store, disk arm scheduling, and process scheduling) <ref> [4, 22] </ref> were the primary research focus. Later, the focus shifted to the logical organization of single processor operating systems (e.g., kernels [7], modularization [6], and process hierarchies [5]) and then to distributed system models (e.g., remote procedure calls and client/server models).
Reference: [5] <author> Dijkstra, E. J. </author> <title> The Structure of the THE Multiprogramming System. </title> <journal> Communications of the ACM, </journal> <month> 5 (May </month> <year> 1968), </year> <pages> 341-346. </pages>
Reference-contexts: During the early years, resource management policies (e.g., virtual memory and backing store, disk arm scheduling, and process scheduling) [4, 22] were the primary research focus. Later, the focus shifted to the logical organization of single processor operating systems (e.g., kernels [7], modularization [6], and process hierarchies <ref> [5] </ref>) and then to distributed system models (e.g., remote procedure calls and client/server models). Choices [1] is an experimental operating system, designed to promote experimentation with new operating system design mechanisms and with new resource management policies. By separating mechanism and policy, Choices encourages experimentation with both.
Reference: [6] <author> Haberman, A. N., Flon, L., and Cooprider, L. </author> <title> Modularization and Hierarchy in a Family of Operating Systems. </title> <journal> Communications of the ACM, </journal> <month> 5 (May </month> <year> 1976), </year> <pages> 266-272. </pages>
Reference-contexts: During the early years, resource management policies (e.g., virtual memory and backing store, disk arm scheduling, and process scheduling) [4, 22] were the primary research focus. Later, the focus shifted to the logical organization of single processor operating systems (e.g., kernels [7], modularization <ref> [6] </ref>, and process hierarchies [5]) and then to distributed system models (e.g., remote procedure calls and client/server models). Choices [1] is an experimental operating system, designed to promote experimentation with new operating system design mechanisms and with new resource management policies.
Reference: [7] <author> Hansen, P. B. </author> <title> The Nucleus of a Multiprogramming System. </title> <journal> Communications of the ACM, </journal> <month> 9 (Sept. </month> <year> 1970), </year> <pages> 238-241. </pages>
Reference-contexts: During the early years, resource management policies (e.g., virtual memory and backing store, disk arm scheduling, and process scheduling) [4, 22] were the primary research focus. Later, the focus shifted to the logical organization of single processor operating systems (e.g., kernels <ref> [7] </ref>, modularization [6], and process hierarchies [5]) and then to distributed system models (e.g., remote procedure calls and client/server models). Choices [1] is an experimental operating system, designed to promote experimentation with new operating system design mechanisms and with new resource management policies.
Reference: [8] <author> Intel. </author> <title> Application Tool User's Guide. </title> <institution> Intel Supercomputer Systems Division, Beaverton, Oregon, </institution> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: The belief is based on our implementation of similar instrumentation on systems with tens to hundreds of processors [15] and the use of these techniques on other massively parallel systems <ref> [8] </ref> that have hundreds of processors. 6 Experimental Data Analysis Using the native Choices operating system instrumentation and the portable application instrumentation, we instrumented members of the SPLASH benchmark suite to assess the performance of both Choices and Umax, Encore's parallel Unix, on a two processor Encore Multimax 320.
Reference: [9] <author> Lehr, T. </author> <title> Compensating for Perturbation by Software Performance Monitors in Asynchronous Computations. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, Department of Computer Science, </institution> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: Under constrained conditions, the effects of direct perturbations can be removed by post-processing the captured performance data to adjust the observed event times <ref> [9, 12, 13] </ref>. 4 More generally, inserted software instrumentation has more subtle effects (e.g., displacing data values from the cache or causing pipeline stalls), the exact cost of each instrumentation point is not known, and exact compensation for instrumentation effects is not possible.
Reference: [10] <author> Lehr, T., Black, D., Segall, Z., and Vrsalovic, D. </author> <title> Visualizing Context-Switches of Parallel Programs Using PIE and the Mach Kernel Monitor. </title> <booktitle> In Proceedings of the 1990 International Conference on Parallel Processing (Aug. </booktitle> <year> 1990), </year> <pages> pp. 298-299. </pages>
Reference-contexts: to study primarily the effects of the Choices scheduler and disk input/output system on the performance of the SPLASH codes, we elected to instrument only a subset of the Choices modules. 3 Given constraints on the number of possible operating system instrumentation points, context switch instrumentation provides the most information <ref> [10] </ref> | it exposes not only the decisions of the task scheduler, but also the interactions of application tasks and the execution patterns of service daemons.
Reference: [11] <author> Madany, P., Islam, N., Kougiouris, P., and Campbell, R. H. </author> <title> "Practical Examples of Reification and Reflection in C++". </title> <booktitle> In International Workshop on Reflection and MetaLevel Architecture (Nov. </booktitle> <year> 1992), </year> <pages> pp. 76-82. </pages>
Reference-contexts: Generic components are customized through object-oriented inheritance and specialization to match the specific concurrency requirements of applications. 2.1 Design Philosophy Choices has, as its kernel, a dynamic collection of C++ objects <ref> [11] </ref>. System resources, mechanisms, and policies are represented as objects that belong to a class hierarchy [18]. The object-oriented application interface has a name server that implements inheritance and polymorphism and provides access to system services, local and remote servers, and persistent objects.
Reference: [12] <author> Malony, A. D. </author> <title> Performance Observability. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: Unfortunately, data volume and accuracy are antithetic; most instrumentation and data capture techniques induce some perturbation (e.g., by modifying code or by interrupting a processor to record data) <ref> [12, 17, 16] </ref>. Operating system performance instrumentation imposes particularly thorny problems because operating systems are, by their nature, reactive, responding to external stimuli. Changing the operating system response time for requests often will also change the pattern of requests. <p> without price: instrumentation perturbs the measured system and may result in observed behavior and event orders that would not be feasible in a system without 2 To avoid potential effects of compiler differences, we also used the C++ versions of the SPLASH codes for our Unix performance experiments. 9 instrumentation <ref> [12] </ref>. <p> Under constrained conditions, the effects of direct perturbations can be removed by post-processing the captured performance data to adjust the observed event times <ref> [9, 12, 13] </ref>. 4 More generally, inserted software instrumentation has more subtle effects (e.g., displacing data values from the cache or causing pipeline stalls), the exact cost of each instrumentation point is not known, and exact compensation for instrumentation effects is not possible. <p> Indirect perturbations are more pernicious, and in the worst case may require a complete system simulation to recover the event order that would have occurred had instrumentation not been present <ref> [12] </ref>. For example, if the events have differing priorities (e.g., system and user task resource requests), or are time dependent (e.g., scheduler time slice interrupts), software instrumentation may change the event order or even alter the number of events.
Reference: [13] <author> Malony, A. D., Reed, D. A., and Wijshoff, H. </author> <title> Performance Measurement Intrusion and Perturbation Analysis. </title> <journal> IEEE Transactions on Parallel and Distributed Systems 3, </journal> <month> 4 (July </month> <year> 1992), </year> <pages> 433-450. </pages>
Reference-contexts: To maximize flexibility, the Choices instrumentation supports combinations of inherited and customized instrumentation. Based on these issues, and our instrumentation experiences, both with Choices and with other systems <ref> [13, 16] </ref> we believe that parallel operating system instrumentation must be * general-purpose, supporting instrumentation and data capture from a variety of operating system modules using a common interface, * isolated, with minimal dependence on operating system services, * dynamic, with triggers to dynamically enable and disable performance data capture based <p> Hence, the perturbation induced on each processor is identical, and there is no skewing of the tasks on different processors. By recording the total time needed to dump all data buffers, we can postprocess the performance data and adjust the observed event times to eliminate these costs <ref> [13] </ref>. <p> Under constrained conditions, the effects of direct perturbations can be removed by post-processing the captured performance data to adjust the observed event times <ref> [9, 12, 13] </ref>. 4 More generally, inserted software instrumentation has more subtle effects (e.g., displacing data values from the cache or causing pipeline stalls), the exact cost of each instrumentation point is not known, and exact compensation for instrumentation effects is not possible.
Reference: [14] <author> Rahman, M. </author> <title> Choices Instrumentation Support. </title> <type> Tech. rep., </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Each type of instrumentation object can be used to capture either application or operating system performance data. relationships. Although each is discussed briefly below, space limitations preclude a complete description; see <ref> [14] </ref> for details. The classes for event tracing, counting, and timing are all derived from 5 the abstract Instrument base class. This base class provides methods to temporarily suspend (and later resume) data recording, as well as to reset the instrumentation object.
Reference: [15] <author> Reed, D. A., Aydt, R. A., Noe, R. J., Roth, P. C., Shields, K. A., Schwartz, B. W., and Tavera, L. F. </author> <title> Scalable Performance Analysis: The Pablo Performance Analysis Environment. </title> <booktitle> In Proceedings of the Scalable Parallel Libraries Conference, </booktitle> <editor> A. Skjellum, Ed. </editor> <publisher> IEEE Computer Society, </publisher> <year> 1993. </year>
Reference-contexts: Although resource limitations did not allow us to conduct experiments with larger numbers of processors, we are confident that this approach scales to substantial numbers of processors. The belief is based on our implementation of similar instrumentation on systems with tens to hundreds of processors <ref> [15] </ref> and the use of these techniques on other massively parallel systems [8] that have hundreds of processors. 6 Experimental Data Analysis Using the native Choices operating system instrumentation and the portable application instrumentation, we instrumented members of the SPLASH benchmark suite to assess the performance of both Choices and Umax,
Reference: [16] <author> Reed, D. A., and Rudolph, D. C. </author> <title> Experiences with Hypercube Operating System Instrumentation. </title> <note> International Journal of High-Speed Computing (Dec. </note> <year> 1989), </year> <pages> 517-542. </pages>
Reference-contexts: Unfortunately, data volume and accuracy are antithetic; most instrumentation and data capture techniques induce some perturbation (e.g., by modifying code or by interrupting a processor to record data) <ref> [12, 17, 16] </ref>. Operating system performance instrumentation imposes particularly thorny problems because operating systems are, by their nature, reactive, responding to external stimuli. Changing the operating system response time for requests often will also change the pattern of requests. <p> To maximize flexibility, the Choices instrumentation supports combinations of inherited and customized instrumentation. Based on these issues, and our instrumentation experiences, both with Choices and with other systems <ref> [13, 16] </ref> we believe that parallel operating system instrumentation must be * general-purpose, supporting instrumentation and data capture from a variety of operating system modules using a common interface, * isolated, with minimal dependence on operating system services, * dynamic, with triggers to dynamically enable and disable performance data capture based
Reference: [17] <author> Rudolph, D. C. </author> <title> Performance Instrumentation for the Intel iPSC/2. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: Unfortunately, data volume and accuracy are antithetic; most instrumentation and data capture techniques induce some perturbation (e.g., by modifying code or by interrupting a processor to record data) <ref> [12, 17, 16] </ref>. Operating system performance instrumentation imposes particularly thorny problems because operating systems are, by their nature, reactive, responding to external stimuli. Changing the operating system response time for requests often will also change the pattern of requests.
Reference: [18] <author> Russo, V. F. </author> <title> An Object-Oriented Operating System. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <month> Oct. </month> <year> 1990. </year> <month> 23 </month>
Reference-contexts: Generic components are customized through object-oriented inheritance and specialization to match the specific concurrency requirements of applications. 2.1 Design Philosophy Choices has, as its kernel, a dynamic collection of C++ objects [11]. System resources, mechanisms, and policies are represented as objects that belong to a class hierarchy <ref> [18] </ref>. The object-oriented application interface has a name server that implements inheritance and polymorphism and provides access to system services, local and remote servers, and persistent objects. In the Choices design, a conceptual framework subsumes the conventional organization of an operating system as a group of layers [18, 2]. <p> The object-oriented application interface has a name server that implements inheritance and polymorphism and provides access to system services, local and remote servers, and persistent objects. In the Choices design, a conceptual framework subsumes the conventional organization of an operating system as a group of layers <ref> [18, 2] </ref>. The framework for the system provides generalized components and constraints to which the specialized subframeworks must conform. <p> First, the Choices application programming interface does not support system calls in the traditional sense; instead, the system supports requests for operating system services via proxies <ref> [18, 20] </ref>, C++ interfaces to the system software that allow interaction with objects that are not in the same protection domain. <p> Except for performance penalties attributable to process emulation or untuned system services (e.g., disk input/output), the performance of applications on Choices is competitive with Unix. This is a system-level confirmation of the micro-scale measurements reported earlier <ref> [18] </ref>. 7 Operating System Malleability The last of our research goals was to assess the feasibility of application performance tuning by adapting the operating system resource management policies to better match application resource demands. In this we were unsuccessful.
Reference: [19] <author> Russo, V. F., Madany, P. W., and Campbell, R. H. </author> <title> C++ and Operating Systems Performance: A Case Study. </title> <booktitle> In Proceedings of the 1990 USENIX C++ Conference (San Francisco, </booktitle> <address> California, </address> <year> 1990), </year> <pages> pp. 103-114. </pages>
Reference-contexts: Finally, because all processing is suspended during buffer dumping, the instrumentation system does not contend with application processes for access to disks. 4 Performance Analysis Methodology Earlier Choices performance measurements <ref> [19] </ref> focused on the cost of individual system operations (e.g., system calls) and the costs of virtual function table lookups imposed by a C++ implementation. <p> Except for performance penalties attributable to process emulation or untuned system services (e.g., disk input/output), the performance of applications on Choices is competitive with Unix. This is a system-level confirmation of the micro-scale measurements reported earlier <ref> [19] </ref>. We also observed that detailed operating system performance data could be obtained at modest cost via a flexible, general-purpose instrumentation infrastructure based on ob ject-oriented design principles. Central to efficient performance data capture is a high resolution, low access latency, memory-mapped hardware clock.
Reference: [20] <author> Shapiro, M. </author> <title> Structure and Encapsulation in Distributed Systems: The Proxy Principle. </title> <booktitle> In Proceedings of the Sixth International Conference on Distributed Systems (1986). </booktitle>
Reference-contexts: First, the Choices application programming interface does not support system calls in the traditional sense; instead, the system supports requests for operating system services via proxies <ref> [18, 20] </ref>, C++ interfaces to the system software that allow interaction with objects that are not in the same protection domain.
Reference: [21] <author> Singh, J. P., Weber, W.-D., and Gupta, A. </author> <title> SPLASH: Stanford Parallel Applications for Shared Memory. </title> <type> Tech. rep., </type> <institution> Stanford University, Department of Computer Science, </institution> <year> 1991. </year>
Reference-contexts: We obtained comparative performance data from Umax 4.2, Encore's Unix implementation. 1 As a representative scientific computation workload, we selected programs from the SPLASH (Stanford Parallel Applications for Shared-Memory) benchmark suite <ref> [21] </ref>. The SPLASH benchmarks are typical engineering and scientific codes of moderate size, written in C and Fortran, and drawn from a variety of application domains. <p> the clock, to the native Choices instrumentation, with more complex data recording and multiple proxy calls. 5.2 Observed Perturbations To establish the veracity of the application instrumentation cost model, we compared the in vitro estimates of Table 1 to in vivo measurements, obtained from the measured execution of the SPLASH <ref> [21] </ref> WATER benchmark, a molecular dynamics simulation. <p> basis for study; this allowed us to study its behavior in detail, and using this knowledge, to understand the implications for parallel operating system performance and software configuration. 6.1 WATER Application Benchmark WATER is an N-body molecular dynamics code that simulates the evolution of water molecules in the liquid phase <ref> [21] </ref>. In its parallel version, the molecules are partitioned and statically assigned to tasks. Each parallel task is responsible for calculating the time-evolutionary state of its assigned molecules.

References-found: 21

