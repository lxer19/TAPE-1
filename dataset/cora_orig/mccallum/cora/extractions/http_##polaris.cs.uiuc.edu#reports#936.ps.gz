URL: http://polaris.cs.uiuc.edu/reports/936.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/tech_reports.html
Root-URL: http://www.cs.uiuc.edu
Title: INSTRUMENTATION OF FORTRAN PROGRAMS FOR AUTOMATIC ROUNDOFF ERROR ANALYSIS AND PERFORMANCE EVALUATION  
Author: BY BRIAN EUGENE BLISS 
Degree: 1987 THESIS Submitted in partial fulfillment of the requirements for the degree of Master of Science in Computer Science in the Graduate College of the  
Address: 1990 Urbana, Illinois  
Affiliation: B.S., University of Illinois,  University of Illinois at Urbana-Champaign,  
Abstract-found: 0
Intro-found: 1
Reference: [All86] <institution> Alliant Computer Systems Corporation. FX/Series Architecture Manual. 1 Monarch Drive, Littleton, Massachusetts 01460, </institution> <month> January </month> <year> 1986. </year>
Reference-contexts: In the Alliant FX/8, a vector multiplication and a vector addition (or subtraction) may be "chained", i.e., both operations performed using a single pipeline (see the Alliant FX Series Architecture Manual <ref> [All86] </ref>).
Reference: [All87] <institution> Alliant Computer Systems Corporation. FX/FORTRAN Language Manual. </institution> <address> 1 Monarch Drive, Littleton, Massachusetts 01460, 3.0 edition, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: If this argument is optional and omitted in the intrinsic function call, a "0" is inserted in the appropriate spot in the subroutine name. According to the Alliant Fortran manual <ref> [All87] </ref>, this argument must 25 be a constant. Handling such an intrinsic argument in this manner allows the author of the subroutine to know its exact value-something not possible if it was passed as an argument to the subroutine.
Reference: [Ame78] <institution> American National Standards Institute, Inc., </institution> <address> 1430 Broadway, New York, New York 10018. </address> <booktitle> American National Standard programming language FORTRAN, </booktitle> <address> x3.9-1978 edition, </address> <month> April </month> <year> 1978. </year>
Reference-contexts: The names of the U tokens and the operations they represent are shown in Table 2.2 Within cftn, the names for these tokens are prepended by a "U ". Note that there are two different U tokens for exponentiation (**). In the ANSI Fortran 77 standard <ref> [Ame78] </ref>, when the exponentiation operation is performed, the operands are coerced to the data type of the result (as is done with all other arithmetic operations), unless the right operand (exponent) is of an integer data type.
Reference: [BG] <author> Marie-Christine Brunet and E. Gallopoulos. </author> <title> Deterministic and statistical measurements of stability: A case study. </title> <type> Technical report, </type> <institution> Center for Supercomputing Research and Development. </institution> <note> In preparation. </note>
Reference-contexts: tools that we have developed to perform two quite different types of roundoff error analysis methods: (i) The error linearization method (See Larson [Lar78], Larson and Sameh [LS78], [LS80], and Larson, Pasternak, and Wisniewski [LPW83]). (ii) A statistical technique (see Chatelin and Brunet [CB87], Brunet [Bru89], and Brunet and Gallopoulos <ref> [BG] </ref>). We begin by introducing the two methods. A detailed description of them can be found in the references. 86 5.1 Error Linearization The error linearization method used by Larson computes the condition number of each output with respect to each intermediate result and input. <p> In this case, the condition of A is underestimated. However, there are many interpretations of the "condition", with or without the right hand side b taken into account, and this estimate should be seen in that context. See Brunet and Gallopoulos <ref> [BG] </ref>. The perturbation analysis takes time proportional to the run-time of the original code. Using double precision, solving a 100 fi 100 system (once) takes 187 seconds when perturbing intermediate results, whereas it takes 16.7 seconds to solve the system with the original Linpack routines.
Reference: [Bru89] <author> Marie-Christine Brunet. </author> <title> Contributions on the Analysis of Numerical Software Reliability and its Behavior: A Statistical Approach. </title> <type> PhD thesis, </type> <institution> University of Paris IX, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: this chapter, we use the tools that we have developed to perform two quite different types of roundoff error analysis methods: (i) The error linearization method (See Larson [Lar78], Larson and Sameh [LS78], [LS80], and Larson, Pasternak, and Wisniewski [LPW83]). (ii) A statistical technique (see Chatelin and Brunet [CB87], Brunet <ref> [Bru89] </ref>, and Brunet and Gallopoulos [BG]). We begin by introducing the two methods. A detailed description of them can be found in the references. 86 5.1 Error Linearization The error linearization method used by Larson computes the condition number of each output with respect to each intermediate result and input. <p> respectively, and r provides an estimate of k _ b bk to form the inequality cond (A) k ^x k kbk (5:10) cond (A) :8276 The factor k r k = s (5:11) relative to machine * is a measure of the stability of the algorithm, as defined by Brunet <ref> [Bru89] </ref>. The exact condition number of A, as calculated by matlab, is kAkkA 1 k = 360:16. In this case, the condition of A is underestimated.
Reference: [CB87] <author> Francoise Chatelin and Marie-Christine Brunet. </author> <title> A probabilistic round-off error propagation model. application to the eigenvalue problem. </title> <type> Technical Report F-123, </type> <institution> Centre Scientifique IBM-France, </institution> <year> 1987. </year> <note> To appear in Reliable Numerical Computation, </note> <editor> M. Cox and S. Hammerling editiors, </editor> <publisher> Oxford University Press. </publisher>
Reference-contexts: The actual error analysis package can then be invoked to analyze the roundoff errors inherent in the original program/data combination. A more efficient approach was recently developed by Brunet and Chatelin <ref> [CB87] </ref>, at the price of obtaining an indication of the program's numerical stability, but no actual error bounds. This approach to automatic roundoff error analysis has been implemented on the Alliant FX/8 and Cedar, and is called the perturb package. <p> ANALYSIS In this chapter, we use the tools that we have developed to perform two quite different types of roundoff error analysis methods: (i) The error linearization method (See Larson [Lar78], Larson and Sameh [LS78], [LS80], and Larson, Pasternak, and Wisniewski [LPW83]). (ii) A statistical technique (see Chatelin and Brunet <ref> [CB87] </ref>, Brunet [Bru89], and Brunet and Gallopoulos [BG]). We begin by introducing the two methods.
Reference: [Cra88] <author> Cray Research, Inc. </author> <title> UNICOS Performance Utilities Reference Manual, </title> <year> 1987, 1988. </year>
Reference-contexts: In the report generated by these packages, the only operations summarized are addition/subtraction, multiplication, and reciprocals. Division and intrinsic function calls are broken down into the basic operations that comprise them. For information regarding these packages, see the UNICOS Performance Utilities Reference Manual <ref> [Cra88] </ref>. 73 CHAPTER 4 AUTOMATIC GENERATION OF COMPUTATIONAL GRAPHS In this chapter we describe the implementation and use of the -z preprocessor pass for generating a graph of a program's floating point computation.
Reference: [DMBS79] <author> J. J. Dongarra, C. B. Moler, J. R. Bunch, and G. W. Stewart. </author> <title> Linpack Users' Guide. </title> <publisher> SIAM, </publisher> <year> 1979. </year>
Reference-contexts: The code was then run to produce a report containing counts of the floating point operations. The report is automatically 2 The vector registers of the Alliant FX/8 have 32 elements. 3 See the Linpack Users' Guide <ref> [DMBS79] </ref> for documentation of the Linpack routines. 58 generated in the user's current directory, under the filename "for009.dat", the default name for Fortran I/O unit #9. The report for this example is shown in Figure 3.2.
Reference: [Fle85] <author> R. Fletcher. </author> <title> Expected conditioning. </title> <journal> IMA Journal of Numerical Analysis, </journal> <volume> 5 </volume> <pages> 247-273, </pages> <year> 1985. </year> <month> 128 </month>
Reference-contexts: Given an algorithm, the software finds a set of inputs which will cause the algorithm to exhibit sufficiently large roundoff errors. These packages all take as input a straight-line program of the exact sequence of computations, such as that produced by the lgraph package described in Chapter 4. See <ref> [Fle85] </ref> and [VLP74] for related work in statistical error analysis. 110 CHAPTER 6 CONCLUSION The original goal of thesis was to develop software to allow existing and future error analysis packages to be used easily on Cedar Fortran programs.
Reference: [GJMS87] <author> Kyle Gallivan, William Jalby, Ulrike Meier, and Ahmed Sameh. </author> <title> The impact of hierarchical memory systems on linear algebra algorithm design. </title> <type> Technical Report 625, </type> <institution> Center for Supercomputing Research and Development, </institution> <month> Septem-ber </month> <year> 1987. </year>
Reference-contexts: For the block method, we analyze the roundoff error of the dmxm () routine, part of the blas3 package as developed at CSRD. For a description of the blas3 routines, see Gallivan, Jalby, Meier and Sameh <ref> [GJMS87] </ref>. The routines are coded in assembly language to achieve maximum performance, with the dmxm () routine achieving more than 40 megaflops on an Alliant FX/8. <p> For a more detailed explanation of the blas3 routines, see <ref> [GJMS87] </ref>. The programs were preprocessed and run, producing a file, for009.dat, in the working directory. Larson's roundoff error analysis package was then invoked by specifying lars analyze &lt; for009.dat The results of Larson's package for the standard and block methods are shown in Figures 5.4 and 5.5, respectively.
Reference: [Guz87] <author> Mark D. Guzzi. </author> <title> Cedar fortran prorgrammer's manual. </title> <type> Technical Report 601, </type> <institution> Center for Supercomputing Research and Development, </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: From here on, we will refer to the portion of the preprocessor which is used for the software packages described in this thesis as the -z pass. The purpose of the Cedar Fortran preprocessor (described in <ref> [Guz87] </ref>) is to convert Cedar Fortran statements to statements recognized by the Alliant Fortran compiler, and to provide the programmer with constructs allowing easy access to the hierarchical memory of the Cedar Machine. <p> By default, variables local to a program unit are allocated in cluster memory. The user may specify that variables are to be allocated in global memory by use of the GLOBAL keyword, which should appear in the declaration section of the routine, in a 41 manner described in <ref> [Guz87] </ref>. If a local variable is declared to be GLOBAL in the original source code, it and all of its associated variables generated by the -z pass are made to reside in global memory. <p> We note that it was also necessary to perform the FORALL transformation before the -z pass. cftn converts the Cedar Fortran FORALL construct 14 to Alliant Fortran triplet notation, from which the -z pass can calculate memory strides for vector operations. 13 See <ref> [Guz87] </ref> for an explanation of these constructs. 14 The FORALL construct allows the programmer the flexibility to specify non-rectangular array sections in a vector operation. 49 % cftn -z &lt;options&gt; ... -o=file2.f &lt; file.f &gt; symbol_table_dump % fortran1p file2.f % txo file2.o % mv file2.o file.o Table 2.4: Compiling a program
Reference: [KLPS86] <author> David J. Kuck, Duncan H. Lawrie, David A. Padua, and Ahmed H. Sameh. </author> <title> Afosr proposal: Supercomputer environments. </title> <type> Technical Report 562, </type> <institution> Center for Supercomputing Research and Development, </institution> <month> April </month> <year> 1986. </year>
Reference-contexts: When most of the operations are done in vector mode, the overhead of the subroutine calls in the instrumented code is small enough that one does not need reduce the problem size to analyze the program. 3.4 Integration with the Faust Programming Environment The Faust <ref> [KLPS86] </ref> programming environment is a window-based environment running under X windows, under development at CSRD. The operation count package can be invoked from this environment, and the program automatically compiled and linked to perform the operation count.
Reference: [Kuc88] <author> Kuck and Associates, Inc., </author> <title> 1906 Fox Drive, Champaign, Illinois. KAP CAF User's Guide, </title> <month> November </month> <year> 1988. </year>
Reference-contexts: When not working in the context of Faust, The user may access this flag and manually set and reset it, in order to count only specified operations. 3.5 Related Work For a description of the transformations done by the kap optimizer, see the KAP CAF User's Guide <ref> [Kuc88] </ref>, Wolfe [Wol82], and Padua and Wolfe [PW86]. The Perftrace and hpm packages, available on Cray X-MP and Cray Y-MP computer systems, provide a similar summary of operation counts, on machines that have been equipped with a hardware performance monitor.
Reference: [Lar78] <author> John L. Larson. </author> <title> Methods for Automatic Error Analysis of Numerical Algorithms. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, Urbana, Illinois, </institution> <month> April </month> <year> 1978. </year> <note> Report No. UIUCDCS-R-78-916. </note>
Reference-contexts: Finally, a line containing -1 marks the end of the graph. 85 CHAPTER 5 ROUNDOFF ERROR ANALYSIS In this chapter, we use the tools that we have developed to perform two quite different types of roundoff error analysis methods: (i) The error linearization method (See Larson <ref> [Lar78] </ref>, Larson and Sameh [LS78], [LS80], and Larson, Pasternak, and Wisniewski [LPW83]). (ii) A statistical technique (see Chatelin and Brunet [CB87], Brunet [Bru89], and Brunet and Gallopoulos [BG]). We begin by introducing the two methods. <p> The computation of is more complex. The exact method requires time growing exponentially with the number of inputs and outputs of the program (See <ref> [Lar78] </ref> and [LS78]).
Reference: [Lin82] <author> Seppo Linnainmaa. </author> <title> Fortran implementation of the error linearization method for automatic error analysis. </title> <type> Technical Report A-1982-3, </type> <institution> University of Helsinki Department of Computer Science, </institution> <month> June </month> <year> 1982. </year>
Reference-contexts: A complete analysis of the problem would involve calculation of a residual, and was not undertaken here. 5.4 Related Work Linnainmaa <ref> [Lin82] </ref> has developed an implementation of the error linearization method which allows the user to compute selected error bounds at runtime. These error bounds may then be used to influence the control flow of the program, an advantage over our post-processing technique. <p> Its applications are much broader, however. Besides performing the floating point operation count using the op ct package, libraries can be generated for many other uses, such as: Linnainmaa's Package An interface to the error analysis package developed by Lin-nainmaa <ref> [Lin82] </ref> can be implemented.
Reference: [LPW83] <author> John Larson, Mary E. Pasternak, and John A. Wisniewski. </author> <title> Algorithm 594: Software for relative error analysis. </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 9(1) </volume> <pages> 125-130, </pages> <month> March </month> <year> 1983. </year>
Reference-contexts: Examples of such tools are described in Larson, Pasternak, and Wis-niewski <ref> [LPW83] </ref>, Miller [Mil75], and Miller and Spooner [MS78]. These packages require as input a directed acyclic graph of the exact sequence of computations, a far cry from the source code that the algorithm is implemented in. In order to bridge that gap, we have developed the "-z" preprocessor pass. <p> Therefore, the source language must be restricted so that straight-line code 1 may be generated for arbitrary inputs. The target language is defined in Section 4.2 Larson, Pasternak, and Wisniewski <ref> [LPW83] </ref> append the straight-line code generated by such a precompiler with sets of inputs, in order to generate input for their error analysis package. The goal of that package is to find error bounds on problems dealing with specific inputs. <p> The error analysis package of Larson, Pasternak, and Wisniewski <ref> [LPW83] </ref> did not handle exponentiation nor most of the Fortran intrinsic functions (the error analysis software was modified to accept sin (), cos (), and tan ()). The current implementation of lgraph follows these restrictions, although a future release may include support for most the Cedar Fortran intrinsic functions. <p> end of the graph. 85 CHAPTER 5 ROUNDOFF ERROR ANALYSIS In this chapter, we use the tools that we have developed to perform two quite different types of roundoff error analysis methods: (i) The error linearization method (See Larson [Lar78], Larson and Sameh [LS78], [LS80], and Larson, Pasternak, and Wisniewski <ref> [LPW83] </ref>). (ii) A statistical technique (see Chatelin and Brunet [CB87], Brunet [Bru89], and Brunet and Gallopoulos [BG]). We begin by introducing the two methods. <p> This value is extremely useful when analyzing matrix computations, where one is more interested in the overall stability of the results, rather than any particular error bound. 89 The package contains two algorithms for calculating : an exact method and a heuristic method (see <ref> [LPW83] </ref>). The package originally estimated the time required to solve the problem and chose the method of use based upon that estimate. It has been modified so that the heuristic method is the default, and one may use the exact method by specifying the -me option.
Reference: [LS78] <author> John Larson and Ahmed Sameh. </author> <title> Efficient calculation of the effects of roundoff errors. </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 4(3) </volume> <pages> 228-236, </pages> <month> Septem-ber </month> <year> 1978. </year>
Reference-contexts: Finally, a line containing -1 marks the end of the graph. 85 CHAPTER 5 ROUNDOFF ERROR ANALYSIS In this chapter, we use the tools that we have developed to perform two quite different types of roundoff error analysis methods: (i) The error linearization method (See Larson [Lar78], Larson and Sameh <ref> [LS78] </ref>, [LS80], and Larson, Pasternak, and Wisniewski [LPW83]). (ii) A statistical technique (see Chatelin and Brunet [CB87], Brunet [Bru89], and Brunet and Gallopoulos [BG]). We begin by introducing the two methods. <p> The computation of is more complex. The exact method requires time growing exponentially with the number of inputs and outputs of the program (See [Lar78] and <ref> [LS78] </ref>).
Reference: [LS80] <author> John Larson and Ahmed Sameh. </author> <title> Algorithms for roundoff error analysis-a relative error approach. </title> <booktitle> Computing, </booktitle> <year> 1980, 1980. </year>
Reference-contexts: a line containing -1 marks the end of the graph. 85 CHAPTER 5 ROUNDOFF ERROR ANALYSIS In this chapter, we use the tools that we have developed to perform two quite different types of roundoff error analysis methods: (i) The error linearization method (See Larson [Lar78], Larson and Sameh [LS78], <ref> [LS80] </ref>, and Larson, Pasternak, and Wisniewski [LPW83]). (ii) A statistical technique (see Chatelin and Brunet [CB87], Brunet [Bru89], and Brunet and Gallopoulos [BG]). We begin by introducing the two methods.
Reference: [Mil75] <author> Webb Miller. </author> <title> Software for roundoff analysis. </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 1(2), </volume> <month> June </month> <year> 1975. </year>
Reference-contexts: Examples of such tools are described in Larson, Pasternak, and Wis-niewski [LPW83], Miller <ref> [Mil75] </ref>, and Miller and Spooner [MS78]. These packages require as input a directed acyclic graph of the exact sequence of computations, a far cry from the source code that the algorithm is implemented in. In order to bridge that gap, we have developed the "-z" preprocessor pass. <p> entry for P 59 i=0 y i cos i~; the lower value is the entry for P 59 Table 5.4: Comparison of the error linearization method and the random perturbation method on Reinsch's algorithm for trigonometric polynomial evaluation. 109 Miller uses the error linearization technique to compute error bounds in <ref> [Mil75] </ref>. Lar-son's package ([LPW83]), described earlier in this chapter, is an extension of this work. Miller and Spooner take a different approach in [MS78]. Given an algorithm, the software finds a set of inputs which will cause the algorithm to exhibit sufficiently large roundoff errors.
Reference: [Moo66] <author> R. E. Moore. </author> <title> Interval Analysis. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1966. </year>
Reference-contexts: See Moore <ref> [Moo66] </ref> for a description of interval analysis techniques. Extended Precision Arithmetic One may associate with each floating point number a list of integers, one of which represents the exponent and the rest hold the value of the mantissa.
Reference: [MS78] <author> Webb Miller and David Spooner. </author> <title> Software for roundoff analysis, II. </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 4(4), </volume> <month> December </month> <year> 1978. </year>
Reference-contexts: Examples of such tools are described in Larson, Pasternak, and Wis-niewski [LPW83], Miller [Mil75], and Miller and Spooner <ref> [MS78] </ref>. These packages require as input a directed acyclic graph of the exact sequence of computations, a far cry from the source code that the algorithm is implemented in. In order to bridge that gap, we have developed the "-z" preprocessor pass. <p> A precompiler was developed by Miller and Spooner <ref> [MS78] </ref> to translate a Fortran-like language into straight-line pseudo-assembly code, representing the computational graph. The source language contains symbolic constants, multidimensional arrays, input/output statements, assignments and expressions, FOR loops and IF statements. Array bounds, FOR loop bounds, and IF statement conditions must all be compile-time evaluable integer constant expressions. <p> Lar-son's package ([LPW83]), described earlier in this chapter, is an extension of this work. Miller and Spooner take a different approach in <ref> [MS78] </ref>. Given an algorithm, the software finds a set of inputs which will cause the algorithm to exhibit sufficiently large roundoff errors. These packages all take as input a straight-line program of the exact sequence of computations, such as that produced by the lgraph package described in Chapter 4.
Reference: [Oli77] <author> J Oliver. </author> <title> An error analysis of the modified Clenshaw method for evaluating Chebyshev and Fourier series. </title> <journal> J Inst. Maths Applics, </journal> (20):397-391, 1977. 
Reference-contexts: The Fortran source codes to Goertzel's algorithm and Reinsch's algorithm are shown in Figures 5.7 and 5.8, respectively. For an explanation of the two methods see Stoer and Bulirsch [SB80], and for a conventional analysis of the roundoff error of the two methods, see Oliver <ref> [Oli77] </ref>. As input, we generate a vector ~y of 60 elements, with y i randomly distributed in the interval [1:0, 1:0], and evaluate each of the two series 59 X y i cos i~ i=0 at ~ = :1, ~ = :01, and ~ = :001.
Reference: [PW86] <author> David A. Padua and Michael J. Wolfe. </author> <title> Advanced compiler optimizations for supercomputers. </title> <journal> Communications of the ACM, </journal> <volume> 29(12), </volume> <month> December </month> <year> 1986. </year> <month> 129 </month>
Reference-contexts: the context of Faust, The user may access this flag and manually set and reset it, in order to count only specified operations. 3.5 Related Work For a description of the transformations done by the kap optimizer, see the KAP CAF User's Guide [Kuc88], Wolfe [Wol82], and Padua and Wolfe <ref> [PW86] </ref>. The Perftrace and hpm packages, available on Cray X-MP and Cray Y-MP computer systems, provide a similar summary of operation counts, on machines that have been equipped with a hardware performance monitor. In the report generated by these packages, the only operations summarized are addition/subtraction, multiplication, and reciprocals.
Reference: [SB80] <author> J. Stoer and R. </author> <title> Bulirsch. Introduction to Numerical Analysis, </title> <address> pages 84-88. </address> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: The Fortran source codes to Goertzel's algorithm and Reinsch's algorithm are shown in Figures 5.7 and 5.8, respectively. For an explanation of the two methods see Stoer and Bulirsch <ref> [SB80] </ref>, and for a conventional analysis of the roundoff error of the two methods, see Oliver [Oli77].
Reference: [Ukk79] <author> E. Ukkonen. </author> <title> An analysis of the effect of rounding errors on the flow of control in numerical processes. </title> <journal> BIT, </journal> <volume> 19 </volume> <pages> 116-133, </pages> <year> 1979. </year>
Reference-contexts: Perturbation of these numbers may cause the stopping test to fail when it would succeed without the perturbations, or vice-versa. This may make the program terminate early, or in theory, to run indefinitely. See Ukkonen <ref> [Ukk79] </ref> for a discussion of the effects of roundoff errors on the flow of control of a program.
Reference: [VLP74] <author> J. Vignes and M. La Porte. </author> <title> Error analysis in computing. </title> <booktitle> In Information Processing 1974, </booktitle> <pages> pages 610-614. </pages> <publisher> North Holland Publishing Co., </publisher> <year> 1974. </year>
Reference-contexts: These packages all take as input a straight-line program of the exact sequence of computations, such as that produced by the lgraph package described in Chapter 4. See [Fle85] and <ref> [VLP74] </ref> for related work in statistical error analysis. 110 CHAPTER 6 CONCLUSION The original goal of thesis was to develop software to allow existing and future error analysis packages to be used easily on Cedar Fortran programs.
Reference: [Wol82] <author> Michael Joseph Wolfe. </author> <title> Optimizing Compilers for Supercomputers. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, Urbana, Illinois, </institution> <month> October </month> <year> 1982. </year> <note> Center for Supercomputing Research and Development Technical Report 329. </note>
Reference-contexts: When not working in the context of Faust, The user may access this flag and manually set and reset it, in order to count only specified operations. 3.5 Related Work For a description of the transformations done by the kap optimizer, see the KAP CAF User's Guide [Kuc88], Wolfe <ref> [Wol82] </ref>, and Padua and Wolfe [PW86]. The Perftrace and hpm packages, available on Cray X-MP and Cray Y-MP computer systems, provide a similar summary of operation counts, on machines that have been equipped with a hardware performance monitor.
References-found: 27

