URL: http://www.cs.indiana.edu/l/www/ftp/pierce/pict/turner-thesis.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/pict/
Root-URL: http://www.cs.indiana.edu
Title: The Polymorphic Pi-calculus: Theory and Implementation  
Author: David N. Turner Ph. D. 
Date: 1995  
Affiliation: University of Edinburgh  
Abstract-found: 0
Intro-found: 1
Reference: [AC91] <author> Robert M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1991. </year>
Reference-contexts: Cardone and Coppo [CC91] or Amadio and Cardelli <ref> [AC91] </ref>, for example), or require explicit annotations from the programmer (cf. MacQueen, Plotkin and Sethi [MPS86], for example). We choose the 47 CHAPTER 4. RECURSIVE TYPES 48 former, since it requires the minimum of changes to our typing rules and operational semantics.
Reference: [AM87] <author> Andrew W. Appel and David B. MacQueen. </author> <title> A Standard ML compiler. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 301-324. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: However, the compilation of -calculus to C presented in this dissertation is quite closely related to the SML to C compiler described in [TAL90]. The stackless representation used here for -calculus processes is very reminiscent of the continuation-passing style of code generation used in the New Jersey ML compiler <ref> [AM87] </ref> (upon which the SML to C compiler is built). Chapter 11 Conclusions and further work Throughout this dissertation we have looked at the -calculus from the perspective of concurrent programming.
Reference: [Ama94] <author> Roberto M. Amadio. </author> <title> Translating core Facile. </title> <type> Technical Report ECRC-TR-3-94, </type> <institution> European Computer-Industry Research Centre, </institution> <year> 1994. </year>
Reference-contexts: CHAPTER 10. RELATED WORK 168 However, even though his type system is quite complicated he is still not able to allow the type of id be polymorphic. 10.4 Implementation There have been a number of proposals for abstract machines for concurrent calculi <ref> [Ama94, Car85, GMP89, etc.] </ref>. At a high-level, our implementation of communication is almost identical to that described by Cardelli [Car85]. However, our abstract machine is unique in that it implements nothing but communicating processes. <p> At a high-level, our implementation of communication is almost identical to that described by Cardelli [Car85]. However, our abstract machine is unique in that it implements nothing but communicating processes. For example, the abstract machines proposed by both Amadio <ref> [Ama94] </ref> and Giacalone et. al. [GMP89] use a separate SECD machine to implement each process (since the execution of a Facile processes may involve both -calculus reduction and communication).
Reference: [BO95] <author> Simon Brock and Gerald Ostheimer. </author> <title> Process semantics of graph reduction. </title> <type> Technical Report CS/95/2, </type> <institution> Computer Science Division, University of St Andrews, </institution> <year> 1995. </year>
Reference-contexts: e in e 0 ii : = (- x)(hhe 0 iia j flx?[b]:hheiib) 6.1.4 Call-by-need reduction It is easy to refine the previous call-by-name encoding so that it shares the evaluation of function arguments, and therefore implements call-by-need reduction (the correctness of this encoding is proved by Brock and Ostheimer <ref> [BO95] </ref>). We just replace the encoding of application in Definition 6.4 with the one below: CHAPTER 6.
Reference: [Car85] <author> Luca Cardelli. </author> <title> An implementation model of redezvous communication. </title> <booktitle> In Seminar on Concurrency, number 197 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: CHAPTER 10. RELATED WORK 168 However, even though his type system is quite complicated he is still not able to allow the type of id be polymorphic. 10.4 Implementation There have been a number of proposals for abstract machines for concurrent calculi <ref> [Ama94, Car85, GMP89, etc.] </ref>. At a high-level, our implementation of communication is almost identical to that described by Cardelli [Car85]. However, our abstract machine is unique in that it implements nothing but communicating processes. <p> At a high-level, our implementation of communication is almost identical to that described by Cardelli <ref> [Car85] </ref>. However, our abstract machine is unique in that it implements nothing but communicating processes.
Reference: [Car86] <author> Luca Cardelli. </author> <title> The Amber machine. </title> <booktitle> In Combinators and Functional Programming Languages, number 242 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: CHAPTER 1. INTRODUCTION 13 1.7 Compiling Pict to C The primary motivation of the Pict [PT95b] project was to design and implement a high-level concurrent language purely in terms of -calculus primitives. There have been many proposals for concurrent languages <ref> [Car86, Hol83, Rep92, Mat91, GMP89, etc.] </ref> which include communication primitives which are very similar to those of the -calculus. However, to our knowledge, none have proposed using -calculus primitives as the sole mechanism of computation. <p> Chapter 8 Compiling Pict to C: Design The primary motivation of the Pict [PT95b] project was to design and implement a high-level concurrent language purely in terms of -calculus primitives. There have been many proposals for concurrent languages <ref> [Car86, Hol83, Rep92, Mat91, GMP89, etc.] </ref> which include communication primitives which are very similar to those of the -calculus. However, to our knowledge, none have proposed using -calculus primitives as the sole mechanism of computation.
Reference: [CC91] <author> Felice Cardone and Mario Coppo. </author> <title> Type inference with recursive types. Syntax and semantics. </title> <journal> Information and Computation, </journal> <volume> 92(1) </volume> <pages> 48-80, </pages> <year> 1991. </year>
Reference-contexts: Definition 4.1 (Recursive types) ffi ::= ff Type variable "[ffi 1 ; : : : ; ffi n ] Channel type ff:ffi Recursive type There are now at least two possible ways to proceed: allow implicit folding and unfolding of recursive types (cf. Cardone and Coppo <ref> [CC91] </ref> or Amadio and Cardelli [AC91], for example), or require explicit annotations from the programmer (cf. MacQueen, Plotkin and Sethi [MPS86], for example). We choose the 47 CHAPTER 4. RECURSIVE TYPES 48 former, since it requires the minimum of changes to our typing rules and operational semantics.
Reference: [Cou83] <author> B. Courcelle. </author> <title> Fundamental properties of infinite trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 25 </volume> <pages> 95-169, </pages> <year> 1983. </year>
Reference-contexts: RELATED WORK 166 A 7! [B; C] B 7! [A] C 7! [ ] yielding a substitution which identifies A and D, B and E and C and F . Sort unification is similar to unification for regular trees <ref> [Cou83] </ref> (the algorithm used by Vasconcelos and Honda in their type inference algorithm). The use of subject sorts is particularly convenient when unifying recursive sorts. Many unification algorithms for recursive trees use tags to record nodes which have already been visited, thereby ensuring that the unification algorithm always terminates.
Reference: [DM82] <author> Luis Damas and Robin Milner. </author> <title> Principal type-schemes for functional programs. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1982. </year> <note> 172 BIBLIOGRAPHY 173 </note>
Reference-contexts: Perhaps the most interesting feature of these encodings is that (in the presence of polymorphism) they don't always work! For example, we find that the Damas CHAPTER 1. INTRODUCTION 12 Milner type system <ref> [DM82] </ref> does not always agree with our -calculus type system as to which types a -term may inhabit. This might not be surprising to those familiar with ML, since it is well-known that Damas-Milner polymorphism is unsafe in the presence of side-effects [Tof88]. <p> Thus, we avoid any interference between concurrent Read and Update operations. Chapter 3 Process typing The most useful type systems for programming languages are those which can be typechecked automatically (usually during compilation). The ML type system <ref> [Mil77, DM82] </ref> is a particularly good example of such a type system, since the programmer does not even have to write any type information it is all inferred automatically by the type checker. <p> Perhaps the most interesting feature of these encodings is that (in the presence of polymorphism) they don't always work! For example, we find that the Damas-Milner type system <ref> [DM82] </ref> does not always agree with our -calculus type system as to which types a -term may inhabit. This might not be surprising to those familiar with ML, since it is well-known that Damas-Milner polymorphism is unsafe in the presence of side-effects [Tof88]. <p> Thus, the final result of executing [[(x:x)y]]a is equivalent to [[y]]a, as expected. CHAPTER 6. RELATING TYPED -TERMS TO TYPED -TERMS 80 6.1.2 Encoding let-expressions The Damas-Milner typing rules <ref> [DM82] </ref> rely on explicit `let' expressions to indicate where type generalisation is allowable. <p> We will see in the next section that whenever our encoding fails to have this property we run into trouble encoding polymorphic types. CHAPTER 6. RELATING TYPED -TERMS TO TYPED -TERMS 95 6.5 Damas-Milner polymorphism The Damas-Milner type system <ref> [DM82] </ref> relies on let-expressions to indicate where type generalisation is allowable, rather than using explicit type abstraction and type application constructs.
Reference: [EG95] <author> Joost Engelfriet and Tjalling Gelsema. </author> <title> Multisets and structural congruence of the pi-calculus with replication. </title> <type> Technical Report TR95-02, </type> <institution> Department of Computer Science, Leiden University, Leiden, </institution> <address> The Netherlands, </address> <year> 1995. </year>
Reference-contexts: AN ABSTRACT MACHINE FOR -CALCULUS 101 are structurally congruent to P . It takes considerably more effort to prove that structural congruence is decidable if we retain the replication rule <ref> [EG95] </ref>. In practice, essentially all occurrences of replication appear in recursive process definitions (cf. Section 2.6) and encodings of data structures (cf. Sections 2.8 and 2.9). In both cases, the replicated input operator is all that is required.
Reference: [Gay93] <author> Simon J. Gay. </author> <title> A sort inference algorithm for the polyadic -calculus. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1993. </year>
Reference-contexts: Note that in the case of a closed -term P our algorithms already coincide, since Vasconcelos and Honda's algorithm returns a trivial type for P . Gay <ref> [Gay93] </ref> has developed an algorithm which infers principle sorts for - terms in Milner's sort system. The algorithm is based on a unification algorithm for sorts. For example, we can unify the sorts A and D below CHAPTER 10.
Reference: [Gir72] <author> J.Y. Girard. </author> <title> Interpretation Fonctionelle et Elimination des Coupres dans l' Arithmetique d'Ordre Superieur. </title> <type> PhD thesis, </type> <institution> Paris, </institution> <year> 1972. </year>
Reference-contexts: we can give to a -term: the previous propositions prove that the type structure of an encoded -term in fact contains a much more accurate reflection of its original -calculus type structure. 6.4 Encoding polymorphic -terms We first consider how to encode the explicitly-typed polymorphic -calculus of Girard and Reynolds <ref> [Gir72, Rey74] </ref>, since having explicit term syntax for type abstraction and type application clarifies some of the semantic issues we encounter when encoding polymorphic -terms in the -calculus.
Reference: [GMP89] <author> Alessandro Giacalone, Prateek Mishra, and Sanjiva Prasad. </author> <title> Facile: A symmetric integration of concurrent and functional programming. </title> <journal> In International Journal of Parallel Programming, </journal> <volume> volume 18, </volume> <month> April </month> <year> 1989. </year>
Reference-contexts: CHAPTER 1. INTRODUCTION 13 1.7 Compiling Pict to C The primary motivation of the Pict [PT95b] project was to design and implement a high-level concurrent language purely in terms of -calculus primitives. There have been many proposals for concurrent languages <ref> [Car86, Hol83, Rep92, Mat91, GMP89, etc.] </ref> which include communication primitives which are very similar to those of the -calculus. However, to our knowledge, none have proposed using -calculus primitives as the sole mechanism of computation. <p> Moreover, it is actually possible to implement (some versions of) the summation operator as a library module [PT95a]. By taking such an approach, we only pay the cost of summation when we use the summation library, rather than during every communication. In languages such as CML [Rep92] and Facile <ref> [GMP89] </ref> which mix functional and concurrent computation, communications are sufficiently infrequent that the additional cost of implementing summation may not be significant. In Pict, however, all computation is achieved via communication over channels, so the additional costs imposed by summation are unacceptable. <p> This stands in sharp contrast with concurrent languages such as CML [Rep92] or Facile <ref> [GMP89] </ref>, where each process may do a significant amount of (sequential) work before terminating, or communicating on a channel. It is therefore important to allow processes to be added and removed from the run queue without allocating any permanent storage in the heap. <p> Chapter 8 Compiling Pict to C: Design The primary motivation of the Pict [PT95b] project was to design and implement a high-level concurrent language purely in terms of -calculus primitives. There have been many proposals for concurrent languages <ref> [Car86, Hol83, Rep92, Mat91, GMP89, etc.] </ref> which include communication primitives which are very similar to those of the -calculus. However, to our knowledge, none have proposed using -calculus primitives as the sole mechanism of computation. <p> Note, however, that one benefit of restricting type generalisation to process definitions is that type inference becomes much simpler (in fact, just like the Damas-Milner type system, Vasconcelos' type system has principal types which can be computed automatically). Languages such as PFL [Hol83], Poly/ML [Mat91], CML [Rep92] and Facile <ref> [GMP89] </ref> which are concurrent extensions of Standard ML [MTH90] all allow a limited form of channel polymorphism, since they retain Standard ML's CHAPTER 10. RELATED WORK 167 polymorphic type system. <p> CHAPTER 10. RELATED WORK 168 However, even though his type system is quite complicated he is still not able to allow the type of id be polymorphic. 10.4 Implementation There have been a number of proposals for abstract machines for concurrent calculi <ref> [Ama94, Car85, GMP89, etc.] </ref>. At a high-level, our implementation of communication is almost identical to that described by Cardelli [Car85]. However, our abstract machine is unique in that it implements nothing but communicating processes. <p> At a high-level, our implementation of communication is almost identical to that described by Cardelli [Car85]. However, our abstract machine is unique in that it implements nothing but communicating processes. For example, the abstract machines proposed by both Amadio [Ama94] and Giacalone et. al. <ref> [GMP89] </ref> use a separate SECD machine to implement each process (since the execution of a Facile processes may involve both -calculus reduction and communication).
Reference: [HJW + 92] <author> Paul Hudak, Simon Peyton Jones, Philip Wadler, Brian Boutel, Jon Fairbairn, Joseph Fasel, Mara M. Guzman, Kevin Hammond, John Hughes, Thomas Johnsson, Dick Kieburtz, Rishiyur Nikhil, Will Partain, and John Peterson. </author> <title> Report on the programming language Haskell. </title> <type> Technical report, </type> <note> Version 1.2, </note> <month> March </month> <year> 1992. </year>
Reference-contexts: The simplicity of our -calculus type system allows us to infer types automatically. The benefits of automatic type inference have been clearly demonstrated in languages such as Standard ML [MTH90] and Haskell <ref> [HJW + 92] </ref>, where the programmer has to write only a minimum of explicit type information. We use similar, unification based, techniques to infer types for -terms. 1.3 Recursive types There are many useful programs which cannot be assigned a type in the simply-typed -calculus. <p> Using induction we have that ` Q 0 and the result follows by using Lemma 3.11 again. 2 3.11 Type inference The benefits of automatic type inference have been clearly demonstrated in languages such as Standard ML [MTH90] and Haskell <ref> [HJW + 92] </ref>, where the programmer has to write only a minimum of explicit type information. Using similar, unification based, techniques we now show that it is possible to automatically infer types for -terms. 3.11.1 Substitutions A substitution is a finite map from type variables to types.
Reference: [HL92] <author> Robert Harper and Mark Lillibridge. </author> <title> Explicit polymorphism and CPS conversion. </title> <type> Technical Report CS-CMU-92-210, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: that by taking a call-by-name semantics, the Damas-Milner type system can be proved sound for a language containing imperative features such as reference cells or exceptions (it is well known that the Damas-Milner type system is unsound if such a language has a call-by-value reduction semantics [Tof88]). (Harper and Lillibridge <ref> [HL92] </ref> consider similar issues in their study of the typing properties of CPS conversion for an extension of F ! with control operators.) The -calculus can encode stateful computation, so the fact that call-by-name terms are well-typed in the -calculus confirms Leroy's observation.
Reference: [Hol83] <author> S. Holmstrom. </author> <title> PFL: A functional language for parallel programming. </title> <booktitle> In Declarative Programming Workshop, Programming Methodology Group, </booktitle> <institution> Chalmers University of Technology, University of Goteborg, Sweden, </institution> <year> 1983. </year>
Reference-contexts: CHAPTER 1. INTRODUCTION 13 1.7 Compiling Pict to C The primary motivation of the Pict [PT95b] project was to design and implement a high-level concurrent language purely in terms of -calculus primitives. There have been many proposals for concurrent languages <ref> [Car86, Hol83, Rep92, Mat91, GMP89, etc.] </ref> which include communication primitives which are very similar to those of the -calculus. However, to our knowledge, none have proposed using -calculus primitives as the sole mechanism of computation. <p> Chapter 8 Compiling Pict to C: Design The primary motivation of the Pict [PT95b] project was to design and implement a high-level concurrent language purely in terms of -calculus primitives. There have been many proposals for concurrent languages <ref> [Car86, Hol83, Rep92, Mat91, GMP89, etc.] </ref> which include communication primitives which are very similar to those of the -calculus. However, to our knowledge, none have proposed using -calculus primitives as the sole mechanism of computation. <p> Note, however, that one benefit of restricting type generalisation to process definitions is that type inference becomes much simpler (in fact, just like the Damas-Milner type system, Vasconcelos' type system has principal types which can be computed automatically). Languages such as PFL <ref> [Hol83] </ref>, Poly/ML [Mat91], CML [Rep92] and Facile [GMP89] which are concurrent extensions of Standard ML [MTH90] all allow a limited form of channel polymorphism, since they retain Standard ML's CHAPTER 10. RELATED WORK 167 polymorphic type system.
Reference: [Jon92] <author> Simon L. Peyton Jones. </author> <title> Implementing lazy functional languages on stock hardware: </title> <journal> the Spineless Tagless G-machine. Journal of Functional Programming, </journal> <volume> 2(2), </volume> <month> April </month> <year> 1992. </year>
Reference-contexts: However, such a compilation scheme runs into a well-known problem with compiling to C (see <ref> [Jon92] </ref>, for example): Suppose that the processes P 1 ; P 2 ; : : : are on the run queue. We start P 1 running by calling the function representing P 1 .
Reference: [KNY95] <author> Naoki Kobayashi, Motoki Nakade, and Akinori Yonezawa. </author> <title> Static analysis on communication for asynchronous concurrent programming languages. </title> <type> Technical Report 95-04, </type> <institution> Department of Information Science, University of Tokyo, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: A number of other researchers have proposed more sophisticated analyses which produce similar information (usually about the maximum size of a channel queue) <ref> [KNY95, NN94] </ref>. The author, in collaboration with Kobayashi and Pierce, has recently developed a linear type system for Pict which can determine when a channel is used by exactly one reader/writer pair [KPT96].
Reference: [KPT96] <author> Naoki Kobayashi, Benjamin Pierce, and David N. Turner. </author> <title> Linearity and the pi-calculus. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1996. </year> <note> BIBLIOGRAPHY 174 </note>
Reference-contexts: Channel representation: A channel may, in general, contain an arbitrary number of blocked readers or writers. However, it turns out that a large percentage of channels only ever contain at most one reader or writer. In fact, if the compiler has access to linear type information <ref> [KPT96] </ref>, we can even guarantee that certain channels will contain at most one reader or writer. We therefore optimise our channel representation for this case (enabling a more compact channel representation and a faster implementation of communication). <p> The author, in collaboration with Kobayashi and Pierce, has recently developed a linear type system for Pict which can determine when a channel is used by exactly one reader/writer pair <ref> [KPT96] </ref>. If x is has a linear type then the code presented in Definition 9.32 is sufficient to implement an output on x (the case for linear input expressions is similar). <p> CONCLUSIONS AND FURTHER WORK 170 capabilities on channels (see Chapter 10 for details). The linear type system developed by the author, in collaboration with Kobayashi and Pierce <ref> [KPT96] </ref>, presents another useful refinement to channel types. However, both of these refinements add only a modest amount of information to channel types, and therefore retain simple type inference and type checking algorithms. <p> Our compilation of -calculus to C is designed so that it can easily exploit information about a channel's status at compilation time. An interesting area for further work is the development of appropriate program analyses for -calculus. The linear type system proposed by Kobayashi, Pierce and the author <ref> [KPT96] </ref> is one example of such an analysis, but there are many further potential refinements. CHAPTER 11.
Reference: [Ler93] <author> Xavier Leroy. </author> <title> Polymorphism by name for references and continuations. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 220-231, </pages> <year> 1993. </year>
Reference-contexts: In fact, we find that the soundness of the Damas-Milner type system is closely connected to the precise evaluation order used (a result which was recently discovered by Leroy <ref> [Ler93] </ref>, though not using encodings into the -calculus). <p> In fact, we find that the soundness of the Damas-Milner type system is closely connected to the precise evaluation order used (a result which was recently discovered by Leroy <ref> [Ler93] </ref>, though he did not use encodings into the -calculus). We find that the call-by-value encoding of -calculus does not preserve its Damas-Milner type structure, but the call-by-name encoding does. 77 CHAPTER 6. RELATING TYPED -TERMS TO TYPED -TERMS 78 6.1 Encoding -terms The syntax for -terms is given below. <p> It is then easy to see that the input x?[ ~ff ; b : "hht ii]:P is well-formed, and the result follows. 2 Leroy <ref> [Ler93] </ref> has already shown that by taking a call-by-name semantics, the Damas-Milner type system can be proved sound for a language containing imperative features such as reference cells or exceptions (it is well known that the Damas-Milner type system is unsound if such a language has a call-by-value reduction semantics [Tof88]).
Reference: [Mat91] <author> David C. J. Matthews. </author> <title> A distributed concurrent implementation of Standard ML. </title> <type> Technical Report ECS-LFCS-91-174, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: CHAPTER 1. INTRODUCTION 13 1.7 Compiling Pict to C The primary motivation of the Pict [PT95b] project was to design and implement a high-level concurrent language purely in terms of -calculus primitives. There have been many proposals for concurrent languages <ref> [Car86, Hol83, Rep92, Mat91, GMP89, etc.] </ref> which include communication primitives which are very similar to those of the -calculus. However, to our knowledge, none have proposed using -calculus primitives as the sole mechanism of computation. <p> Chapter 8 Compiling Pict to C: Design The primary motivation of the Pict [PT95b] project was to design and implement a high-level concurrent language purely in terms of -calculus primitives. There have been many proposals for concurrent languages <ref> [Car86, Hol83, Rep92, Mat91, GMP89, etc.] </ref> which include communication primitives which are very similar to those of the -calculus. However, to our knowledge, none have proposed using -calculus primitives as the sole mechanism of computation. <p> Note, however, that one benefit of restricting type generalisation to process definitions is that type inference becomes much simpler (in fact, just like the Damas-Milner type system, Vasconcelos' type system has principal types which can be computed automatically). Languages such as PFL [Hol83], Poly/ML <ref> [Mat91] </ref>, CML [Rep92] and Facile [GMP89] which are concurrent extensions of Standard ML [MTH90] all allow a limited form of channel polymorphism, since they retain Standard ML's CHAPTER 10. RELATED WORK 167 polymorphic type system.
Reference: [Mil77] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17(3), </volume> <year> 1977. </year>
Reference-contexts: Thus, we avoid any interference between concurrent Read and Update operations. Chapter 3 Process typing The most useful type systems for programming languages are those which can be typechecked automatically (usually during compilation). The ML type system <ref> [Mil77, DM82] </ref> is a particularly good example of such a type system, since the programmer does not even have to write any type information it is all inferred automatically by the type checker.
Reference: [Mil80] <author> Robin Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: This style of synchronous rendezvous is used in many process calculi, including CCS <ref> [Mil80, Mil89] </ref> and value-passing CCS [Mil80, Mil89]. However, unlike its predecessors, the -calculus' channels not only provide the means of communication, but are also the values exchanged during communication. <p> This style of synchronous rendezvous is used in many process calculi, including CCS <ref> [Mil80, Mil89] </ref> and value-passing CCS [Mil80, Mil89]. However, unlike its predecessors, the -calculus' channels not only provide the means of communication, but are also the values exchanged during communication. This dissertation investigates whether the -calculus is able to serve as a good foundation for the design and implementation of a strongly-typed concurrent programming language.
Reference: [Mil89] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Series in Computer Science. Prentice-Hall International, </booktitle> <year> 1989. </year>
Reference-contexts: This style of synchronous rendezvous is used in many process calculi, including CCS <ref> [Mil80, Mil89] </ref> and value-passing CCS [Mil80, Mil89]. However, unlike its predecessors, the -calculus' channels not only provide the means of communication, but are also the values exchanged during communication. <p> This style of synchronous rendezvous is used in many process calculi, including CCS <ref> [Mil80, Mil89] </ref> and value-passing CCS [Mil80, Mil89]. However, unlike its predecessors, the -calculus' channels not only provide the means of communication, but are also the values exchanged during communication. This dissertation investigates whether the -calculus is able to serve as a good foundation for the design and implementation of a strongly-typed concurrent programming language. <p> Some familiarity with CCS and the -calculus would be helpful for readers of this dissertation. Useful background reading can be found in <ref> [Mil89, MPW89a, MPW89b, MPW92, Mil90, Mil91a] </ref>. The implementation of the Pict programming language (referred to previously) is available electronically. The distribution includes a manual and tutorial, as well as a number of examples of X-Windows programs written in Pict. This dissertation is also available online.
Reference: [Mil90] <author> Robin Milner. </author> <title> Functions as processes. </title> <type> Technical Report 1154, </type> <institution> Institut National de Recherche en Informatique et en Automatique, Sophia-Antipolis, </institution> <month> February </month> <year> 1990. </year> <note> Final version in Journal of Mathematical Structures in Computer Science 2(2) 119-141, </note> <year> 1992. </year>
Reference-contexts: Milner <ref> [Mil90] </ref> has already shown that we can encode various -calculus reduction strategies in the -calculus. In Chapter 6, we show that the type structure of a -term is often preserved by these encodings. <p> For example, the -calculus can encode higher-order communication (the communication of processes along channels) [San93a, San93b], structured datatypes [Mil91a], mutable data, concurrent objects [Wal91], and even the - calculus <ref> [Mil90] </ref>. In Chapter 7, we describe an abstract machine for the -calculus which is simple and yet realistic. In fact, in Chapters 8 and 9 we present a compilation of -calculus to C which is directly based on the abstract machine presented in Chapter 7. <p> Some familiarity with CCS and the -calculus would be helpful for readers of this dissertation. Useful background reading can be found in <ref> [Mil89, MPW89a, MPW89b, MPW92, Mil90, Mil91a] </ref>. The implementation of the Pict programming language (referred to previously) is available electronically. The distribution includes a manual and tutorial, as well as a number of examples of X-Windows programs written in Pict. This dissertation is also available online. <p> Proof Similar to the proof of Theorem 3.13 2 Chapter 6 Relating typed -terms to typed -terms Our type system is constructed using type-theoretic techniques borrowed from the -calculus, so it is natural to ask if there is a precise relationship between well-typed -terms and well-typed -terms. Milner <ref> [Mil90] </ref> has already shown that we can encode various -calculus reduction strategies in the -calculus. We now show that the type structure of a -term is often preserved by these encodings. <p> For example, the -calculus can encode higher-order communication (the communication of processes along channels) [San93a, San93b], structured datatypes [Mil91a], mutable data, concurrent objects [Wal91], and even the - calculus <ref> [Mil90] </ref>. We now describe an abstract machine for the -calculus which is simple and yet realistic. In fact, in Chapters 8 and 9 we present a compilation of -calculus to C which is directly based on the abstract machine presented here.
Reference: [Mil91a] <author> Robin Milner. </author> <title> The polyadic -calculus: a tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <month> October </month> <year> 1991. </year> <booktitle> Proceedings of the International Summer School on Logic and Algebra of Specification, Marktoberdorf, </booktitle> <month> August </month> <year> 1991. </year>
Reference-contexts: The following sections summarise the contents of this dissertation. 1.1 The polyadic -calculus The input and output primitives of the -calculus are monadic: exactly one channel is exchanged during each communication. The polyadic -calculus <ref> [Mil91a] </ref> is a useful extension of the -calculus which allows the atomic communication of tuples of channels. The additional structure introduced by polyadic communication is important, since it raises the possibility of runtime failure (the tuple CHAPTER 1. <p> For example, the -calculus can encode higher-order communication (the communication of processes along channels) [San93a, San93b], structured datatypes <ref> [Mil91a] </ref>, mutable data, concurrent objects [Wal91], and even the - calculus [Mil90]. In Chapter 7, we describe an abstract machine for the -calculus which is simple and yet realistic. <p> Some familiarity with CCS and the -calculus would be helpful for readers of this dissertation. Useful background reading can be found in <ref> [Mil89, MPW89a, MPW89b, MPW92, Mil90, Mil91a] </ref>. The implementation of the Pict programming language (referred to previously) is available electronically. The distribution includes a manual and tutorial, as well as a number of examples of X-Windows programs written in Pict. This dissertation is also available online. <p> This dissertation is also available online. Chapter 2 The polyadic -calculus The input and output primitives of the -calculus are monadic: exactly one channel is exchanged during each communication. The polyadic -calculus <ref> [Mil91a] </ref> is a useful extension of the -calculus which allows the atomic communication of tuples of channels. <p> We cannot, for example, embed communications inside tuples. Thus, all computation in the polyadic - calculus is still based on processes communicating over channels, just as in the monadic -calculus. 2.2 Semantics We present the semantics of the polyadic -calculus using a reduction relation (see <ref> [Mil91a] </ref> for more details). This style of semantics involves defining two relations on processes: a reduction relation, which formalises the actual communication behaviour of processes, and a structural congruence relation. The structural congruence relation allows us to rewrite a process so that any two active input or CHAPTER 2. <p> failure in the polyadic - calculus (the rules mimic the reduction rules exactly, except for the communication rule, which actually detects the runtime failure). 2.4 Encoding polyadic communication The ability to create private channels and communicate them to other processes allows us to encode polyadic communication in the monadic -calculus <ref> [Mil91a] </ref>. <p> We use tail-calls here to simplify our examples, but they do have a useful effect in practice, since they both save creating an extra result channel and avoid a communication in g. 2.8 Booleans In <ref> [Mil91a] </ref> Milner demonstrated how data structures could be encoded in the -calculus. <p> Definition 6.20 (Encoding recursive types) [[ff:t ]] = ff:[[t ]] hhff:t ii : It is well-known that every -term inhabits the type ff:(ff ! ff), but it is in teresting to note that [[ff:(ff ! ff)]] : = ff:"[ff; "ff], since in <ref> [Mil91a] </ref> Milner shows that every call-by-value -term inhabits the type ff:"[ff; "ff] (we have rewritten CHAPTER 6. RELATING TYPED -TERMS TO TYPED -TERMS 90 Milner's type in our notation). <p> For example, the -calculus can encode higher-order communication (the communication of processes along channels) [San93a, San93b], structured datatypes <ref> [Mil91a] </ref>, mutable data, concurrent objects [Wal91], and even the - calculus [Mil90]. We now describe an abstract machine for the -calculus which is simple and yet realistic. <p> We have already shown in Chapter 6 that there is a very strong relation between -calculus types and -calculus types, so we will not discuss -calculus type systems here. 10.1 Type systems We first compare our type system with Milner's original sort system <ref> [Mil91a, Mil91b] </ref> for the polyadic -calculus (which inspired our -calculus type system). Milner's sort system partitions the channels in a -term using subject sorts.
Reference: [Mil91b] <author> Robin Milner. </author> <title> Sorts in the -calculus. </title> <booktitle> Presented at the Third Workshop on Concurrency and Compositionality, </booktitle> <address> Goslar, Germany, </address> <year> 1991. </year>
Reference-contexts: We have already shown in Chapter 6 that there is a very strong relation between -calculus types and -calculus types, so we will not discuss -calculus type systems here. 10.1 Type systems We first compare our type system with Milner's original sort system <ref> [Mil91a, Mil91b] </ref> for the polyadic -calculus (which inspired our -calculus type system). Milner's sort system partitions the channels in a -term using subject sorts.
Reference: [MP88] <author> John C. Mitchell and Gordon D. Plotkin. </author> <title> Abstract types have existential type. </title> <booktitle> In ACM Transactions on Programming Languages and Systems, </booktitle> <pages> pages 470-502, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: In <ref> [MP88] </ref>, Mitchell and Plotkin showed that the typing behaviour of an abstract datatype is correctly modeled by an existential type. In fact, it also turns out that it is possible to encode existential types in the polymorphic - calculus [Rey83].
Reference: [MPS86] <author> David MacQueen, Gordon Plotkin, and Ravi Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> <volume> 71 </volume> <pages> 95-130, </pages> <year> 1986. </year>
Reference-contexts: Cardone and Coppo [CC91] or Amadio and Cardelli [AC91], for example), or require explicit annotations from the programmer (cf. MacQueen, Plotkin and Sethi <ref> [MPS86] </ref>, for example). We choose the 47 CHAPTER 4. RECURSIVE TYPES 48 former, since it requires the minimum of changes to our typing rules and operational semantics.
Reference: [MPW89a] <author> Robin Milner, Joachim Parrow, and David Walker. </author> <title> A calculus of mobile processes, part 1. </title> <type> Technical Report ECS-LFCS-89-85, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <month> June </month> <year> 1989. </year> <note> BIBLIOGRAPHY 175 </note>
Reference-contexts: Introduction The -calculus <ref> [MPW89a, MPW89b, MPW92] </ref> is a process calculus which is able to describe dynamically changing networks of concurrent processes. An example of such a process network is shown below. The network models a mobile telephone and two ground stations. <p> Some familiarity with CCS and the -calculus would be helpful for readers of this dissertation. Useful background reading can be found in <ref> [Mil89, MPW89a, MPW89b, MPW92, Mil90, Mil91a] </ref>. The implementation of the Pict programming language (referred to previously) is available electronically. The distribution includes a manual and tutorial, as well as a number of examples of X-Windows programs written in Pict. This dissertation is also available online.
Reference: [MPW89b] <author> Robin Milner, Joachim Parrow, and David Walker. </author> <title> A calculus of mobile processes, part 2. </title> <type> Technical Report ECS-LFCS-89-86, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <month> June </month> <year> 1989. </year>
Reference-contexts: Introduction The -calculus <ref> [MPW89a, MPW89b, MPW92] </ref> is a process calculus which is able to describe dynamically changing networks of concurrent processes. An example of such a process network is shown below. The network models a mobile telephone and two ground stations. <p> Some familiarity with CCS and the -calculus would be helpful for readers of this dissertation. Useful background reading can be found in <ref> [Mil89, MPW89a, MPW89b, MPW92, Mil90, Mil91a] </ref>. The implementation of the Pict programming language (referred to previously) is available electronically. The distribution includes a manual and tutorial, as well as a number of examples of X-Windows programs written in Pict. This dissertation is also available online.
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes, (Parts I and II). </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year>
Reference-contexts: Introduction The -calculus <ref> [MPW89a, MPW89b, MPW92] </ref> is a process calculus which is able to describe dynamically changing networks of concurrent processes. An example of such a process network is shown below. The network models a mobile telephone and two ground stations. <p> Some familiarity with CCS and the -calculus would be helpful for readers of this dissertation. Useful background reading can be found in <ref> [Mil89, MPW89a, MPW89b, MPW92, Mil90, Mil91a] </ref>. The implementation of the Pict programming language (referred to previously) is available electronically. The distribution includes a manual and tutorial, as well as a number of examples of X-Windows programs written in Pict. This dissertation is also available online.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The simplicity of our -calculus type system allows us to infer types automatically. The benefits of automatic type inference have been clearly demonstrated in languages such as Standard ML <ref> [MTH90] </ref> and Haskell [HJW + 92], where the programmer has to write only a minimum of explicit type information. We use similar, unification based, techniques to infer types for -terms. 1.3 Recursive types There are many useful programs which cannot be assigned a type in the simply-typed -calculus. <p> Therefore, using Lemma 3.11, we have that ` P 0 . Using induction we have that ` Q 0 and the result follows by using Lemma 3.11 again. 2 3.11 Type inference The benefits of automatic type inference have been clearly demonstrated in languages such as Standard ML <ref> [MTH90] </ref> and Haskell [HJW + 92], where the programmer has to write only a minimum of explicit type information. Using similar, unification based, techniques we now show that it is possible to automatically infer types for -terms. 3.11.1 Substitutions A substitution is a finite map from type variables to types. <p> Languages such as PFL [Hol83], Poly/ML [Mat91], CML [Rep92] and Facile [GMP89] which are concurrent extensions of Standard ML <ref> [MTH90] </ref> all allow a limited form of channel polymorphism, since they retain Standard ML's CHAPTER 10. RELATED WORK 167 polymorphic type system.
Reference: [NN94] <author> Hanne Riis Nielson and Flemming Nielson. </author> <title> Higher-order concurrent programs with finite communication topology. </title> <booktitle> In ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: A number of other researchers have proposed more sophisticated analyses which produce similar information (usually about the maximum size of a channel queue) <ref> [KNY95, NN94] </ref>. The author, in collaboration with Kobayashi and Pierce, has recently developed a linear type system for Pict which can determine when a channel is used by exactly one reader/writer pair [KPT96].
Reference: [OD93] <author> Gerald K. Ostheimer and Antony J. T. Davie. </author> <title> -calculus character-isations of some practical -calculus reduction strategies. </title> <type> Technical Report CS/93/14, </type> <institution> Department of Mathematical and Computing Sciences, University of St Andrews, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: yielding a process which is equivalent to [[let x = e in e 0 ]]a, since the channel f cannot appear in [[e 0 ]]a. ~ (- c)([[e]]c j c?[x]:[[e 0 ]]a) = [[let x = e in e 0 ]]a 6.1.3 Call-by-name reduction Definition 6.4 presents Ostheimer and Davie's <ref> [OD93] </ref> encoding of the call-by-name -calculus. We use Ostheimer and Davie's encoding, rather than Milner's, since it shares much of the structure of the call-by-value encoding we have already presented and can easily be modified to implement call-by-need evaluation (where the evaluation of function arguments is shared).
Reference: [Pie95] <author> Benjamin C. Pierce. </author> <title> Abstract machines and fairness for Pict. </title> <type> Personal Communication, </type> <year> 1995. </year>
Reference-contexts: We do not attempt to prove such as result here, however, since the formal definition of fairness for -calculus is a topic of current research <ref> [Pie95] </ref>. However, we do conjecture that our abstract machine guarantees what Pierce calls process fairness: any individual process that is infinitely often able to communicate (i.e., some communication partner is simultaneously available infinitely often) must eventually do so.
Reference: [PS93] <author> Benjamin C. Pierce and Davide Sangiorgi. </author> <title> Typing and subtyping for mobile processes. </title> <booktitle> In IEEE Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: We will address this problem in Chapter 5. Secondly, the user of a reference cell should never write on the read channel, and never read from the write channel, but this restriction cannot be enforced by our type system. Fortunately, Pierce and Sangiorgi <ref> [PS93] </ref> have shown that it is possible to refine the channel type constructor " so that input and output capabilities can be manipulated separately. <p> We take a more direct approach here, defining equality by means of a bisimulation relation on types. Our treatment of recursive types was inspired by Pierce and Sangiorgi's form-alisation of subtyping for recursive types <ref> [PS93] </ref>. We refine their work by eliminating all uses of infinite trees: Pierce and Sangiorgi use a bisimulation relation defined over infinite trees, while we use a bisimulation relation defined directly over the syntax of types. <p> the above form: c?fl [~x]:P = (- d)( d?fl [ ]:c?[~x]:(P j d![ ]) j d![ ] ) In the Pict implementation, we enforce this restriction on replicated input using a combination of syntactic restrictions and special typing rules (Pict implements the I/O channel types proposed by Pierce and Sangiorgi <ref> [PS93] </ref>, and can therefore easily check that a channel is never used for input in a particular context). <p> They prove that their type system is sound and has the principal type property using essentially identical techniques to those proposed here. Pierce and Sangiorgi <ref> [PS93] </ref> have developed a -calculus type system which uses the idea of I/O tags to capture additional information about how a channel is used, controlling whether a channel may be written to, read from, or both. <p> Of course, that it not to say that there are no useful refinements one can make to channel types. The Pict type system includes one very useful refinement, proposed by Pierce and Sangiorgi <ref> [PS93] </ref>, which distinguishes input and output 169 CHAPTER 11. CONCLUSIONS AND FURTHER WORK 170 capabilities on channels (see Chapter 10 for details). The linear type system developed by the author, in collaboration with Kobayashi and Pierce [KPT96], presents another useful refinement to channel types.
Reference: [PT95a] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Concurrent objects in a process calculus. </title> <editor> In Takayasu Ito and Akinori Yonezawa, editors, </editor> <booktitle> Theory and Practice of Parallel Programming (TPPP), Sendai, </booktitle> <address> Japan (Nov. </address> <year> 1994), </year> <booktitle> number 907 in Lecture Notes in Computer Science, </booktitle> <pages> pages 187-215. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1995. </year>
Reference-contexts: In fact, the mere presence of summation in our calculus can double the amount of storage required for a channel (see the next section for details). Experience with the Pict programming language <ref> [PT95a] </ref> suggests that essential uses of the summation operator are infrequent. Moreover, it is actually possible to implement (some versions of) the summation operator as a library module [PT95a]. <p> Experience with the Pict programming language <ref> [PT95a] </ref> suggests that essential uses of the summation operator are infrequent. Moreover, it is actually possible to implement (some versions of) the summation operator as a library module [PT95a]. By taking such an approach, we only pay the cost of summation when we use the summation library, rather than during every communication. <p> AN ABSTRACT MACHINE FOR -CALCULUS 102 We can therefore use an operator called the replicated choice operator <ref> [PT95a] </ref> to implement Ref. The replicated choice operator exploits the fact that Ref repeatedly waits for input on either read or update, and therefore manages to implement Ref using a small amount of work to set up the communications at each iteration.
Reference: [PT95b] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Pict: A programming language based on the pi-calculus, </title> <year> 1995. </year>
Reference-contexts: waits to receive a value along c, continuing as Q with the value received substituted for the formal parameter x. (The -calculus literature has many variations on the syntax used for input and output we use a syntax which is most similar to that used in the Pict programming language <ref> [PT95b] </ref>.) Two processes may be run in parallel using the parallel composition operator j, thus enabling interactions between them. <p> In particular, we record variable bindings explicitly in environments, rather than using a substitution operation, so that the basic operations of our abstract machine are simple and efficient enough to be implemented directly. CHAPTER 1. INTRODUCTION 13 1.7 Compiling Pict to C The primary motivation of the Pict <ref> [PT95b] </ref> project was to design and implement a high-level concurrent language purely in terms of -calculus primitives. There have been many proposals for concurrent languages [Car86, Hol83, Rep92, Mat91, GMP89, etc.] which include communication primitives which are very similar to those of the -calculus. <p> Fortunately, Pierce and Sangiorgi [PS93] have shown that it is possible to refine the channel type constructor " so that input and output capabilities can be manipulated separately. The Pict programming language <ref> [PT95b] </ref> adopts Pierce and Sangiorgi's refinement, enabling it to give Ref the type [X] ) [?X; !X] (the type ?X allows only read access, while the type !X allows only write access). 3.7 Channel-based reference cells Let ChanRef X be the type "[X], the type of a reference cell represented as <p> Unfortunately, the type system presented does not allow the communication of type constructors along channels (since we do not implement high-order polymorphism). But there is no reason why we cannot add such a feature. In the Pict language <ref> [PT95b] </ref> the author, in collaboration with Benjamin Pierce, has developed a higher-order polymorphic -calculus calculus, which enables one to communicate type constructors along channels, and thereby implement abstract datatypes for type constructors such as ChanRef and List. 5.8 Type soundness We need to modify the -calculus reduction semantics we gave in <p> CHAPTER 7. AN ABSTRACT MACHINE FOR -CALCULUS 113 7.7 Asynchronous communication In the Pict programming language <ref> [PT95b] </ref>, the implementation of communication is further simplified by the use of asynchronous communication. The asynchronous -calculus is a simple sub-calculus of the -calculus where we restrict the continuation P in every output process c![~a]:P to be 0. <p> Chapter 8 Compiling Pict to C: Design The primary motivation of the Pict <ref> [PT95b] </ref> project was to design and implement a high-level concurrent language purely in terms of -calculus primitives. There have been many proposals for concurrent languages [Car86, Hol83, Rep92, Mat91, GMP89, etc.] which include communication primitives which are very similar to those of the -calculus. <p> a runtime error, since it has sent a record along c which is lacking the age field. ffi ffi 0 c : "fname : String ; age : Int g ` P c : "fname : String ; age : Int g ` c!fname = Daveg:P The Pict type system <ref> [PT95b] </ref> uses Pierce and Sangiorgi's channel subtyping, as well as subtyping for record values and patterns. 10.2 Type inference Vasconcelos and Honda [VH93] have independently developed a type inference algorithm very similar to the one presented here. <p> We have shown that the -calculus admits a simple type system which can be extended to include many of the more advanced type-theoretic features familiar from the -calculus. In fact, in the Pict programming language <ref> [PT95b] </ref> the author, in collaboration with Benjamin Pierce, has developed a higher-order polymorphic -calculus, which also includes subtyping, higher-order subtyping and extensible records. Experience to date suggests that refinements one can make to -calculus type systems are also applicable to the typed -calculus.
Reference: [PT95c] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Pict Standard Libraries. </title> <institution> Department of Computer Science, University of Cambridge and University of Glasgow, </institution> <year> 1995. </year>
Reference-contexts: For this reason, we have avoided complicating our channels types with complex protocol-like information (which often make type checking and type inference much more difficult). In Pict, the abstract datatypes provided by our polymorphic type system are used extensively throughout most library code <ref> [PT95c] </ref>, as well as being used to ensure that the internal representations of built-in datatypes such as integers and booleans can only be manipulated using the functions supplied by the compiler. Of course, that it not to say that there are no useful refinements one can make to channel types.
Reference: [Rep92] <author> John H. Reppy. </author> <title> Concurrent ML: Design, application and semantics. In Programming, Concurrency, Simulation and Automated Reasoning, </title> <booktitle> number 693 in LNCS, </booktitle> <pages> pages pp. 165-198. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <note> BIBLIOGRAPHY 176 </note>
Reference-contexts: CHAPTER 1. INTRODUCTION 13 1.7 Compiling Pict to C The primary motivation of the Pict [PT95b] project was to design and implement a high-level concurrent language purely in terms of -calculus primitives. There have been many proposals for concurrent languages <ref> [Car86, Hol83, Rep92, Mat91, GMP89, etc.] </ref> which include communication primitives which are very similar to those of the -calculus. However, to our knowledge, none have proposed using -calculus primitives as the sole mechanism of computation. <p> Moreover, it is actually possible to implement (some versions of) the summation operator as a library module [PT95a]. By taking such an approach, we only pay the cost of summation when we use the summation library, rather than during every communication. In languages such as CML <ref> [Rep92] </ref> and Facile [GMP89] which mix functional and concurrent computation, communications are sufficiently infrequent that the additional cost of implementing summation may not be significant. In Pict, however, all computation is achieved via communication over channels, so the additional costs imposed by summation are unacceptable. <p> H (E (x)) = (F; ?fl [~y]:Q) AOut-R* 7.11 Using environments more efficiently In the -calculus, processes are created very frequently, and tend run for a very short amount of time before become blocked (or terminating). This stands in sharp contrast with concurrent languages such as CML <ref> [Rep92] </ref> or Facile [GMP89], where each process may do a significant amount of (sequential) work before terminating, or communicating on a channel. It is therefore important to allow processes to be added and removed from the run queue without allocating any permanent storage in the heap. <p> Chapter 8 Compiling Pict to C: Design The primary motivation of the Pict [PT95b] project was to design and implement a high-level concurrent language purely in terms of -calculus primitives. There have been many proposals for concurrent languages <ref> [Car86, Hol83, Rep92, Mat91, GMP89, etc.] </ref> which include communication primitives which are very similar to those of the -calculus. However, to our knowledge, none have proposed using -calculus primitives as the sole mechanism of computation. <p> COMPILING PICT TO C: IMPLEMENTATION 160 Time Code size New Jersey ML 2.3s 380Kb Pict 12s 25Kb CML 46s 545Kb To get an idea how fast our implementation of communication is, we converted our ML program into a CML <ref> [Rep92] </ref> program (CML is a concurrent extension of ML which implements channel-based communication on top of New Jersey ML). <p> Note, however, that one benefit of restricting type generalisation to process definitions is that type inference becomes much simpler (in fact, just like the Damas-Milner type system, Vasconcelos' type system has principal types which can be computed automatically). Languages such as PFL [Hol83], Poly/ML [Mat91], CML <ref> [Rep92] </ref> and Facile [GMP89] which are concurrent extensions of Standard ML [MTH90] all allow a limited form of channel polymorphism, since they retain Standard ML's CHAPTER 10. RELATED WORK 167 polymorphic type system. <p> RELATED WORK 167 polymorphic type system. It is well-known that the Damas-Milner type system is unsound in the presence of side-effecting computation, so some care has to be taken with the typing of any channel creation operator. For example, in CML <ref> [Rep92] </ref> the channel function creates new channels, and has the type unit -&gt; '_a channel.
Reference: [Rey74] <author> J.C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Lecture Notes in Computer Science 19, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: we can give to a -term: the previous propositions prove that the type structure of an encoded -term in fact contains a much more accurate reflection of its original -calculus type structure. 6.4 Encoding polymorphic -terms We first consider how to encode the explicitly-typed polymorphic -calculus of Girard and Reynolds <ref> [Gir72, Rey74] </ref>, since having explicit term syntax for type abstraction and type application clarifies some of the semantic issues we encounter when encoding polymorphic -terms in the -calculus.
Reference: [Rey83] <author> John C. Reynolds. </author> <title> Types, abstraction, and parametric polymorph-ism. </title> <booktitle> In IFIP Congress, </booktitle> <address> Paris, </address> <month> September </month> <year> 1983. </year>
Reference-contexts: In [MP88], Mitchell and Plotkin showed that the typing behaviour of an abstract datatype is correctly modeled by an existential type. In fact, it also turns out that it is possible to encode existential types in the polymorphic - calculus <ref> [Rey83] </ref>. A similar technique is applicable in the polymorphic -calculus, enabling us to provide support for programming with abstract datatypes in the -calculus. The following example illustrates how we can package up our booleans and boolean operations (from Section 2.8) in an abstract datatype.
Reference: [Rob65] <author> J. A. Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 12(1), </volume> <month> January </month> <year> 1965. </year>
Reference-contexts: Lemma 3.17 (Preservation of process types under substitution) If ` P then ` P . Proof A simple induction on the structure of P. 2 3.11.2 Unification Since -calculus types are simple trees, we know from Robinson's work <ref> [Rob65] </ref> that there is a sound and complete unification algorithm for -calculus types, which we refer to as Unify. Propositions 3.18 and 3.19 state the appropriate soundness and completeness properties of the algorithm. CHAPTER 3. PROCESS TYPING 43 Proposition 3.18 (Soundness of unification algorithm [Rob65]) If Unify (ffi; fl) = then <p> trees, we know from Robinson's work <ref> [Rob65] </ref> that there is a sound and complete unification algorithm for -calculus types, which we refer to as Unify. Propositions 3.18 and 3.19 state the appropriate soundness and completeness properties of the algorithm. CHAPTER 3. PROCESS TYPING 43 Proposition 3.18 (Soundness of unification algorithm [Rob65]) If Unify (ffi; fl) = then ffi = fl. Proposition 3.19 (Completeness of unification algorithm [Rob65]) If ffi = fl then Unify (ffi; fl) succeeds, returning , and there exists a such that = . <p> Propositions 3.18 and 3.19 state the appropriate soundness and completeness properties of the algorithm. CHAPTER 3. PROCESS TYPING 43 Proposition 3.18 (Soundness of unification algorithm <ref> [Rob65] </ref>) If Unify (ffi; fl) = then ffi = fl. Proposition 3.19 (Completeness of unification algorithm [Rob65]) If ffi = fl then Unify (ffi; fl) succeeds, returning , and there exists a such that = .
Reference: [San93a] <author> D. Sangiorgi. </author> <title> Expressing Mobility in Process Algebras: First-Order and Higher-Order Paradigms. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <year> 1993. </year> <note> Also published as technical report ECS-LFCS-93-266. </note>
Reference-contexts: For example, the -calculus can encode higher-order communication (the communication of processes along channels) <ref> [San93a, San93b] </ref>, structured datatypes [Mil91a], mutable data, concurrent objects [Wal91], and even the - calculus [Mil90]. In Chapter 7, we describe an abstract machine for the -calculus which is simple and yet realistic. <p> For example, the -calculus can encode higher-order communication (the communication of processes along channels) <ref> [San93a, San93b] </ref>, structured datatypes [Mil91a], mutable data, concurrent objects [Wal91], and even the - calculus [Mil90]. We now describe an abstract machine for the -calculus which is simple and yet realistic.
Reference: [San93b] <author> D. Sangiorgi. </author> <title> From -calculus to Higher-Order -calculus | and back. </title> <booktitle> In Proceedings TAPSOFT, </booktitle> <publisher> LNCS 668. Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: For example, the -calculus can encode higher-order communication (the communication of processes along channels) <ref> [San93a, San93b] </ref>, structured datatypes [Mil91a], mutable data, concurrent objects [Wal91], and even the - calculus [Mil90]. In Chapter 7, we describe an abstract machine for the -calculus which is simple and yet realistic. <p> For example, the -calculus can encode higher-order communication (the communication of processes along channels) <ref> [San93a, San93b] </ref>, structured datatypes [Mil91a], mutable data, concurrent objects [Wal91], and even the - calculus [Mil90]. We now describe an abstract machine for the -calculus which is simple and yet realistic.
Reference: [San93c] <author> Davide Sangiorgi. </author> <title> A theory of bisimulation for the -calculus. </title> <type> Technical Report ECS-LFCS-93-270, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <year> 1993. </year>
Reference-contexts: We let ~ and denote the strong and weak congruence respectively (see <ref> [San93c] </ref> for definitions of ~ and ).
Reference: [TAL90] <author> David Tarditi, Anurag Acharya, and Peter Lee. </author> <title> No assembly required: Compiling standard ML to C. </title> <type> Technical Report CMU-CS-90-187, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: It is especially worth bearing in mind that Pict loses some performance just because we compile to C rather than to native code. Tarditi, Acharya and Lee <ref> [TAL90] </ref> found that compiling to C rather than to native code costs almost a factor of two for New Jersey ML code. <p> However, the compilation of -calculus to C presented in this dissertation is quite closely related to the SML to C compiler described in <ref> [TAL90] </ref>. The stackless representation used here for -calculus processes is very reminiscent of the continuation-passing style of code generation used in the New Jersey ML compiler [AM87] (upon which the SML to C compiler is built).
Reference: [Tar55] <author> Alfred Tarski. </author> <title> A lattice-theoretical fixpoint theorem and its applications. </title> <journal> Pacific Journal of Mathematics, </journal> <volume> 5 </volume> <pages> 285-309, </pages> <year> 1955. </year>
Reference-contexts: The relation R is a bisimulation if R F (R) where F is the following function on relations: (ffi; fl) 2 F (R) if either 1. ffi + ff and fl + ff. The function F in Definition 4.3 is monotone, so we have by Tarski's fixpoint theorem <ref> [Tar55] </ref> that the greatest fixpoint of F exists and is equal to S F (R)g. Let ' be the greatest fixpoint of F . It follows from the definition of ' that if (ffi; fl) 2 R for some bisimulation R then ffi ' fl.
Reference: [Tho93] <author> Bent Thomsen. </author> <title> Polymorphic sorts and types for concurrent functional programs. </title> <type> Technical Report ECRC-93-10, </type> <institution> European Computer-Industry Research Centre, </institution> <year> 1993. </year>
Reference-contexts: Unfortunately, the type of id can never be polymorphic, because the type of channel is weakly polymorphic. val id = channel () fun server () = let val (x,r) = receive (ch) in send (r,x); server () end Thomsen <ref> [Tho93] </ref> illustrates how one can improve upon the behaviour of polymorphic channels using an effect system (in the context of the Facile language). CHAPTER 10.
Reference: [Tof88] <author> Mads Tofte. </author> <title> Operational Semantics and Polymorphic Type Inference. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: INTRODUCTION 12 Milner type system [DM82] does not always agree with our -calculus type system as to which types a -term may inhabit. This might not be surprising to those familiar with ML, since it is well-known that Damas-Milner polymorphism is unsafe in the presence of side-effects <ref> [Tof88] </ref>. The -calculus is, by its very nature, a calculus containing side-effects, so it had better not allow the same kind of polymorphism as the Damas-Milner type system. <p> This might not be surprising to those familiar with ML, since it is well-known that Damas-Milner polymorphism is unsafe in the presence of side-effects <ref> [Tof88] </ref>. The -calculus is, by its very nature, a calculus containing side-effects, so it had better not allow the same kind of polymorphism as the Damas-Milner type system. <p> [Ler93] has already shown that by taking a call-by-name semantics, the Damas-Milner type system can be proved sound for a language containing imperative features such as reference cells or exceptions (it is well known that the Damas-Milner type system is unsound if such a language has a call-by-value reduction semantics <ref> [Tof88] </ref>). (Harper and Lillibridge [HL92] consider similar issues in their study of the typing properties of CPS conversion for an extension of F ! with control operators.) The -calculus can encode stateful computation, so the fact that call-by-name terms are well-typed in the -calculus confirms Leroy's observation.
Reference: [Vas94] <author> Vasco T. Vasconcelos. </author> <title> Predicative polymorphism in the -calculus. </title> <booktitle> In Proceedings of 5th Conference on Parallel Architectures and Languages, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1994. </year> <note> BIBLIOGRAPHY 177 </note>
Reference-contexts: This is unnecessary in sort unification, since each node (object sort) is already labelled with a subject sort. We need only keep a record of which subject sorts have already been visited. 10.3 Polymorphic types Vasconcelos <ref> [Vas94] </ref> has independently proposed a polymorphic type system for -calculus which is a special case of the polymorphic type system presented here. It relies on explicit let-expressions to indicate where type generalisation may occur (just like the Damas-Milner type system does).
Reference: [VH93] <author> Vasco T. Vasconcelos and Kohei Honda. </author> <title> Principal typing schemes in a polyadic pi-calculus. </title> <booktitle> In Proceedings of CONCUR '93, </booktitle> <month> July </month> <year> 1993. </year> <note> Also available as Keio University Report CS-92-004. </note>
Reference-contexts: CHAPTER 10. RELATED WORK 163 3. Once one has a sufficiently powerful polymorphic type system, it is possible to distinguish values of isomorphic type using the abstract datatype encodings presented in Section 5.7. Vasconcelos and Honda <ref> [VH93] </ref> have independently proposed a monomorphic type system for the polyadic -calculus which is very similar to ours (except that they treat recursive types in a more traditional way, interpreting recursive types as regular trees). <p> "fname : String ; age : Int g ` P c : "fname : String ; age : Int g ` c!fname = Daveg:P The Pict type system [PT95b] uses Pierce and Sangiorgi's channel subtyping, as well as subtyping for record values and patterns. 10.2 Type inference Vasconcelos and Honda <ref> [VH93] </ref> have independently developed a type inference algorithm very similar to the one presented here. Their algorithm, takes only a process P as argument, and constructs the principal context in which P is well-formed.
Reference: [Wal91] <author> David J. Walker. </author> <title> -calculus semantics of object-oriented programming languages. </title> <booktitle> In Conference on Theoretical Aspects of Computer Software, </booktitle> <institution> Tohoku University, </institution> <address> Japan, </address> <year> 1991. </year>
Reference-contexts: For example, the -calculus can encode higher-order communication (the communication of processes along channels) [San93a, San93b], structured datatypes [Mil91a], mutable data, concurrent objects <ref> [Wal91] </ref>, and even the - calculus [Mil90]. In Chapter 7, we describe an abstract machine for the -calculus which is simple and yet realistic. <p> For example, the -calculus can encode higher-order communication (the communication of processes along channels) [San93a, San93b], structured datatypes [Mil91a], mutable data, concurrent objects <ref> [Wal91] </ref>, and even the - calculus [Mil90]. We now describe an abstract machine for the -calculus which is simple and yet realistic. In fact, in Chapters 8 and 9 we present a compilation of -calculus to C which is directly based on the abstract machine presented here.
References-found: 54

