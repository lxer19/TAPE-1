URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-05.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-05.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A General Framework for Semantics-based Bottom-up Abstract Interpretation of Logic Programs. </title> <note> (To appear in ACM Transactions on Programming Languages and Systems). </note>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. <ref> [28, 42, 25, 26, 4, 2, 8, 1] </ref>), the algorithms (e.g. [31, 2, 6, 19, 18]), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. [41, 16, 21, 14]).
Reference: [2] <author> M. Bruynooghe. </author> <title> A Practical Framework for the Abstract Interpretation of Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 10 </volume> <pages> 91-124, </pages> <year> 1991. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. <ref> [28, 42, 25, 26, 4, 2, 8, 1] </ref>), the algorithms (e.g. [31, 2, 6, 19, 18]), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. [41, 16, 21, 14]). <p> Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. [28, 42, 25, 26, 4, 2, 8, 1]), the algorithms (e.g. <ref> [31, 2, 6, 19, 18] </ref>), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. [41, 16, 21, 14]). A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. [6, 15, 18, 40]). <p> Definition 14 [Widening operator r d ] Let fi and S be a substitution and a set of substitutions defined on the same domain. fi r d S = LUBffi [ DES1 (fi; S)g: 4.2.2 The Abstract Domain Mode The domain of [29] is a reformulation of the domain of <ref> [2] </ref>. The domain could be viewed as a simplification of the elaborate domain where the pattern information has been omitted and the sharing has been simplified to an equivalence relation. Only three modes are considered: ground, var and any.
Reference: [3] <author> M Bruynooghe and G Janssens. </author> <title> An Instance of Abstract Interpretation: Integrating Type and Mode Inferencing. </title> <booktitle> In Proc. Fifth International Conference on Logic Programming, </booktitle> <pages> pages 669-683, </pages> <address> Seattle, WA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. [28, 42, 25, 26, 4, 2, 8, 1]), the algorithms (e.g. [31, 2, 6, 19, 18]), the abstract domains (e.g. <ref> [30, 3, 17] </ref>) and the implementation (e.g. [41, 16, 21, 14]). A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. [6, 15, 18, 40]). <p> The domain is more sophisticated than the sharing domains of, for instance, [17, 30] and than the mode domains of, for instance, [41, 16]. It is best viewed as an abstraction of the domain of Bruynooghe and Janssens <ref> [3] </ref> where a pattern component has been added. The domain is fully described in [29] which contains also the proofs of monotonicity and consistency. Note also that the presentation in [29] is generic and can be instantiated to a variety of applications. The presentation here is an instantiation to modes.
Reference: [4] <author> Bruynooghe, M. et al. </author> <title> Abstract Interpretation: Towards the Global Optimization of Prolog Programs. </title> <booktitle> In Proc. 1987 Symposium on Logic Programming, </booktitle> <pages> pages 192-204, </pages> <address> San Francisco, CA, </address> <month> August </month> <year> 1987. </year> <month> 48 </month>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. <ref> [28, 42, 25, 26, 4, 2, 8, 1] </ref>), the algorithms (e.g. [31, 2, 6, 19, 18]), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. [41, 16, 21, 14]).
Reference: [5] <author> N. Chomsky. </author> <title> On Certain Formal Properties of Grammars. </title> <journal> Information and Control, </journal> <volume> 2(2):137--167, </volume> <year> 1959. </year>
Reference-contexts: Hence it is natural to suspend execution on an already encountered suffix and to collect simply its result. In essence, this idea is a generalization of Chomsky normal form for context-free grammars <ref> [5] </ref>. The nodes in the new algorithm will then be tuples of the form (fi; hbody; ci) and it is necessary to associate and update results with these nodes as if they were goals.
Reference: [6] <author> C. Codognet, P. Codognet, and J.M. Corsini. </author> <title> Abstract Interpretation of Concurrent Logic Languages. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming (NACLP-90), </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. [28, 42, 25, 26, 4, 2, 8, 1]), the algorithms (e.g. <ref> [31, 2, 6, 19, 18] </ref>), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. [41, 16, 21, 14]). A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. [6, 15, 18, 40]). <p> A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. <ref> [6, 15, 18, 40] </ref>). OLDT-resolution is often advocated as a basis for abstract interpretation because of its completeness properties for a variety of program classes. Another interesting aspect of OLDT-resolution as a framework for abstract interpretation is the very fine granularity it offers.
Reference: [7] <author> P. Codognet and G. </author> <title> File. Computations, Abstractions and Constraints in Logic Programs. </title> <booktitle> In Proceedings of the Fourth International Conference on Programming Languages (ICCL'92), </booktitle> <address> Oakland, CA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Proof Omitted. The proof of a very similar result is given in [29]. 2 2.4 Abstract Semantics (version 1) We now give a version of the generic semantics which is equivalent to the abstract computation model proposed by Codognet and File in <ref> [7] </ref> and can be used as a basis for abstract OLDT-resolution. 2.4.1 The Basic Semantic Domains Let us assume that for each finite set of program variables there exists a set AS D of so-called abstract substitutions over domain D, endowed with a concretization function: Cc : AS D ! CS
Reference: [8] <author> A. Corsini and G. </author> <title> File. A Complete Framework for the Abstract Interpretation of Logic Programs: Theory and Applications. </title> <type> Research report, </type> <institution> University of Padova, Italy, </institution> <year> 1989. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. <ref> [28, 42, 25, 26, 4, 2, 8, 1] </ref>), the algorithms (e.g. [31, 2, 6, 19, 18]), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. [41, 16, 21, 14]).
Reference: [9] <author> A. Cortesi, G. File, and W. Winsborough. </author> <title> Prop revisited: Propositional formulas as abstract domain for groundness analysis. </title> <booktitle> In Proc. Sixth Annual IEEE Symposium on Logic in Computer Science (LICS'91), </booktitle> <pages> pages 322-327, </pages> <year> 1991. </year>
Reference-contexts: On the smaller domain, both algorithms have the same accuracy and roughly the same efficiency. This indicates that, for the domains considered in this paper, OLDT-resolution may work at too fine a granularity. Similar results can be expected on the domain Prop <ref> [9, 27, 24] </ref>, since the least upper bound operation in this domain does not lose accuracy. The main open issue now is to find out applications where the tradeoff efficiency/accuracy of OLDT-based abstract interpretation is more valuable in practice. Acknowledgements Mark Johnson helped clarifying the relationships with computational linguistics.
Reference: [10] <author> P Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Conf. Record of Fourth ACM Symposium on POPL, </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, CA, </address> <year> 1977. </year>
Reference-contexts: Second, the use of subsumption precludes the need for the suffix optimization in this example, since there is only one abstract result per procedure. 3.8 Widening In the case of infinite abstract domains, widening <ref> [10] </ref> is used to ensure termination.
Reference: [11] <author> P. Cousot and R. Cousot. </author> <title> Comparison of the Galois connection and widening/narrowing approaches to abstract interpretation. </title> <editor> In M. Bruynooghe and M. Wirsing, editors, </editor> <booktitle> Proceedings of the Fourth International Workshop on Programming Language Implementation and Logic Programming (PLILP'92), Lecture Notes in Computer Science, </booktitle> <address> Leuven, </address> <month> August </month> <year> 1992. </year> <title> Springer-Verlag. </title> <type> (Invited Paper). </type>
Reference-contexts: Termination of analysis can be ensured by approximating some sets of abstract substitutions. Such an operation is called a widening in Cousot's terminology (see <ref> [11] </ref> for a complete discussion). 3 The Algorithmic Framework In this section, we present novel top-down fixpoint algorithms for OLDT-based abstract interpretation of Prolog. These algorithms can be seen as instantiations of the universal top-down fixpoint algorithm presented and proven correct in [20].
Reference: [12] <author> M. Dincbas, H. Simonis, and P. Van Hentenryck. </author> <title> Solving Large Combinatorial Problems in Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 8(1-2):75-93, </volume> <year> 1990. </year>
Reference-contexts: The program uses, in various ways, the nondeterminism of Prolog. We use two versions of the program; one of them (i.e. cs1) assumes that the data are ground while the other one (i.e. cs) assumes that the data are ground lists. The program disj is taken from <ref> [12] </ref> and is the generate and test equivalent of a constraint program used to solve a disjunctive scheduling problem. This is also a program using the nondeterminism of Prolog. Once again, we use two versions of the program with the same distinction as for the cutting stock example.
Reference: [13] <author> J. Earley. </author> <title> An Efficient Context-Free Parsing Algorithm. </title> <journal> Comm. ACM, </journal> <volume> 13(2) </volume> <pages> 94-102, </pages> <year> 1970. </year>
Reference-contexts: This is possible, since abstract interpretation manipulates few abstract substitutions, and desirable, since it allows fine-grained optimizations. As a consequence, 3 These optimizations can be viewed, in some ways, as generalizations of some techniques included in Earley's context-free grammar <ref> [13] </ref>. 4 In the context of abstract interpretation, a tuple is an abstract substitution on the clause variables. 11 our algorithm does not need query patterns, since a new subgoal is created for each abstract substitution. * The elimination of redundant computations is performed at the tuple level in our algorithms,
Reference: [14] <author> V. Englebert, B. Le Charlier, D. Roland, and P. Van Hentenryck. </author> <title> Generic Abstract Interpretation Algorithms for Prolog: Two Optimization Techniques and Their Experimental Evaluation. </title> <booktitle> In Fourth International Symposium on Programming Language Implementation and Logic Programming (PLILP-92), </booktitle> <address> Leuven (Belgium), </address> <month> August </month> <year> 1992. </year> <note> To Appear in Software Practice and Experience. </note>
Reference-contexts: area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. [28, 42, 25, 26, 4, 2, 8, 1]), the algorithms (e.g. [31, 2, 6, 19, 18]), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. <ref> [41, 16, 21, 14] </ref>). A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. [6, 15, 18, 40]). OLDT-resolution is often advocated as a basis for abstract interpretation because of its completeness properties for a variety of program classes. <p> In contrast to many abstract interpretation frameworks and algorithms which store a single result (e.g. an abstract substitution) per program point considered, OLDT-based abstract interpretation associates a set of results with each program point. In addition, with suitable optimizations such as the caching of abstract operations <ref> [14] </ref>, it can be shown that the worst-case complexity of OLDT-based abstract interpretation is no worse than more traditional algorithms storing a single result per program point and is quadratic in the size of the abstract domain (assuming a finite abstract domain). <p> The algorithm is then analyzed systematically on a finite and an infinite abstract domain and compared with a "more traditional" algorithm <ref> [21, 14] </ref>. The experimental results cover both accuracy and efficiency as well as other measures to understand the behaviour of the algorithm. Finally, design choices and variations of the algorithms are evaluated. <p> The final algorithm OLDT-GL-SU is the extension of OLDT-GL with output subsumption. It can be seen as an instantiation of the universal algorithm for an instrumental semantics based on the second abstract semantics and containing information on all program points. All algorithms also include the caching optimizations proposed in <ref> [14] </ref> which amounts to memoizing the results of all abstract operations. This optimization has both theoretical and practical interest, since it reduces the worst case complexity and the execution time for many applications. The algorithms have some commonalities with recursive query processors for deductive databases. <p> The design choices behind our algorithms were dictated by the nature of abstract interpretation, which rarely manipulates large collections of abstract substitutions and for which some of the techniques used, i.e. dependencies and caching, have also proved successful in previous algorithms <ref> [21, 14] </ref>. See the experimental results for an empirical validation of these choices. The algorithm can be applied as well to recursive query processing but we have not evaluated its adequacy in that context. The rest of this section is organized as follows. <p> This comes from the inclusion of fi in in the node and simplifies the algorithm as no work needs to be performed when a node is stable. In Section 3.5, we show how to generalize this optimization. Combining suffix dependencies with caching of operations <ref> [14] </ref> also guarantees that the cost of following the paths is almost negligible, as we will see in our experimental results. More advanced techniques have also been investigated to jump directly at the right place (using computation paths) but the improvement is negligible. <p> The experimental results were obtained on a variety of benchmarks (see Section 4.1) and on two abstract domains (see Section 4.2). Algorithm OLDT-GL-SU is used as the basic algorithm for OLDT. OLDT-GL-SU is also compared to a more traditional algorithm <ref> [19, 21, 14] </ref> storing tuples of the forms (fi in ; p; fi out ). <p> Comprehensive experimental results about the accuracy and efficiency of the algorithm are presented, using finite and infinite abstract domains. The algorithm is also compared to other algorithms, working at a coarser granularity <ref> [19, 21, 14] </ref>. Choices and variations of the algorithm are also carefully studied, including the impact of caching, dependencies, output subsumption, widening, and generalization. The experimental results have been particularly informative.
Reference: [15] <author> G File and P Sottero. </author> <title> Abstract Interpretation for Type Checking. </title> <booktitle> In Third International Symposium on Programming Language Implementation and Logic Programming (PLILP-91), </booktitle> <address> Passau (Germany), </address> <month> August </month> <year> 1991. </year>
Reference-contexts: A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. <ref> [6, 15, 18, 40] </ref>). OLDT-resolution is often advocated as a basis for abstract interpretation because of its completeness properties for a variety of program classes. Another interesting aspect of OLDT-resolution as a framework for abstract interpretation is the very fine granularity it offers.
Reference: [16] <author> M. Hermenegildo, R. Warren, and S. Debray. </author> <title> Global Flow Analysis as a Practical Compilation Tool. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(4) </volume> <pages> 349-367, </pages> <year> 1992. </year>
Reference-contexts: area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. [28, 42, 25, 26, 4, 2, 8, 1]), the algorithms (e.g. [31, 2, 6, 19, 18]), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. <ref> [41, 16, 21, 14] </ref>). A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. [6, 15, 18, 40]). OLDT-resolution is often advocated as a basis for abstract interpretation because of its completeness properties for a variety of program classes. <p> The domain is more sophisticated than the sharing domains of, for instance, [17, 30] and than the mode domains of, for instance, <ref> [41, 16] </ref>. It is best viewed as an abstraction of the domain of Bruynooghe and Janssens [3] where a pattern component has been added. The domain is fully described in [29] which contains also the proofs of monotonicity and consistency.
Reference: [17] <author> D. Jacobs and A. Langen. </author> <title> Accurate and Efficient Approximation of Variable Aliasing in Logic Programs. </title> <booktitle> In Proceedings of the North-American Conference on Logic Programming (NACLP-89), </booktitle> <address> Cleveland, Ohio, </address> <month> October </month> <year> 1989. </year> <month> 49 </month>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. [28, 42, 25, 26, 4, 2, 8, 1]), the algorithms (e.g. [31, 2, 6, 19, 18]), the abstract domains (e.g. <ref> [30, 3, 17] </ref>) and the implementation (e.g. [41, 16, 21, 14]). A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. [6, 15, 18, 40]). <p> The domain is more sophisticated than the sharing domains of, for instance, <ref> [17, 30] </ref> and than the mode domains of, for instance, [41, 16]. It is best viewed as an abstraction of the domain of Bruynooghe and Janssens [3] where a pattern component has been added. The domain is fully described in [29] which contains also the proofs of monotonicity and consistency.
Reference: [18] <author> T. Kanamori and T. Kawamura. </author> <title> Analysing Success Patterns of Logic Programs by Abstract Hybrid Interpretation. </title> <type> Technical report, </type> <institution> ICOT, </institution> <year> 1987. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. [28, 42, 25, 26, 4, 2, 8, 1]), the algorithms (e.g. <ref> [31, 2, 6, 19, 18] </ref>), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. [41, 16, 21, 14]). A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. [6, 15, 18, 40]). <p> A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. <ref> [6, 15, 18, 40] </ref>). OLDT-resolution is often advocated as a basis for abstract interpretation because of its completeness properties for a variety of program classes. Another interesting aspect of OLDT-resolution as a framework for abstract interpretation is the very fine granularity it offers.
Reference: [19] <author> B. Le Charlier, K. Musumbu, and P. Van Hentenryck. </author> <title> A Generic Abstract Interpretation Algorithm and Its Complexity Analysis (Extended Abstract). </title> <booktitle> In Eighth International Conference on Logic Programming (ICLP-91), </booktitle> <address> Paris (France), </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. [28, 42, 25, 26, 4, 2, 8, 1]), the algorithms (e.g. <ref> [31, 2, 6, 19, 18] </ref>), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. [41, 16, 21, 14]). A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. [6, 15, 18, 40]). <p> These algorithms can be seen as instantiations of the universal top-down fixpoint algorithm presented and proven correct in [20]. As a consequence, they share some of the spirit of our previous algorithms <ref> [19, 21, 22] </ref>. The algorithms are presented by stepwise refinements. We start by a naive algorithm OLDT-Naive which can be seen as an instantiation of the universal algorithm to the first abstract semantics. <p> The goal dependencies will be generalized in the optimized versions. We only introduce the basic notions here. See <ref> [19] </ref> for more discussion. <p> The experimental results were obtained on a variety of benchmarks (see Section 4.1) and on two abstract domains (see Section 4.2). Algorithm OLDT-GL-SU is used as the basic algorithm for OLDT. OLDT-GL-SU is also compared to a more traditional algorithm <ref> [19, 21, 14] </ref> storing tuples of the forms (fi in ; p; fi out ). <p> Comprehensive experimental results about the accuracy and efficiency of the algorithm are presented, using finite and infinite abstract domains. The algorithm is also compared to other algorithms, working at a coarser granularity <ref> [19, 21, 14] </ref>. Choices and variations of the algorithm are also carefully studied, including the impact of caching, dependencies, output subsumption, widening, and generalization. The experimental results have been particularly informative.
Reference: [20] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> A Universal Top-Down Fixpoint Algorithm. </title> <type> Technical Report CS-92-25, </type> <institution> CS Department, Brown University, </institution> <year> 1992. </year>
Reference-contexts: The framework allows to dissociate semantic and algorithmic aspects of the analysis, simplifying correctness proofs and comparisons between several possible approaches. In particular, it allows the algorithms to be viewed as instances of a universal fixpoint algorithm working on very general transformations <ref> [20] </ref>. The framework includes a concrete semantics equivalent to SLD-resolution and two abstract semantics which are consistent approximations of the concrete semantics. The first abstract semantics is a simple abstraction of the concrete semantics but it has several limitations for abstract interpretation. <p> Then: G S i i2I 0 i : 2 It is possible to lift this hypothesis in some cases. See [23] and <ref> [20] </ref> for details. 5 2.2.3 Generic Semantic domains In the following we assume an underlying program P and we define the semantic domains and equations with respect to this underlying program. <p> These algorithms can be seen as instantiations of the universal top-down fixpoint algorithm presented and proven correct in <ref> [20] </ref>. As a consequence, they share some of the spirit of our previous algorithms [19, 21, 22]. The algorithms are presented by stepwise refinements. We start by a naive algorithm OLDT-Naive which can be seen as an instantiation of the universal algorithm to the first abstract semantics.
Reference: [21] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental Evaluation of a Generic Abstract Interpretation Algorithm for Prolog. </title> <booktitle> In Fourth IEEE International Conference on Computer Languages (ICCL'92), </booktitle> <address> San Francisco, CA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. [28, 42, 25, 26, 4, 2, 8, 1]), the algorithms (e.g. [31, 2, 6, 19, 18]), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. <ref> [41, 16, 21, 14] </ref>). A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. [6, 15, 18, 40]). OLDT-resolution is often advocated as a basis for abstract interpretation because of its completeness properties for a variety of program classes. <p> However, worst case analysis is not always very relevant in abstract interpretation as shown in <ref> [21] </ref> and experimental results may differ significantly from the expected complexity. In addition, to the best of our knowledge, no experimental results have been reported on the efficiency of OLDT-based abstract interpretation. <p> The algorithm is then analyzed systematically on a finite and an infinite abstract domain and compared with a "more traditional" algorithm <ref> [21, 14] </ref>. The experimental results cover both accuracy and efficiency as well as other measures to understand the behaviour of the algorithm. Finally, design choices and variations of the algorithms are evaluated. <p> Moreover, there is no way to ensure termination by resorting to approximations. In many cases, it is more appropriate to use infinite domains to achieve more precision (see for instance <ref> [21] </ref>). This requires the use of approximations to guarantee the finiteness of the analysis. Such approximations require an upper bound operation for abstract substitutions and monotonicity of the concretization function. <p> These algorithms can be seen as instantiations of the universal top-down fixpoint algorithm presented and proven correct in [20]. As a consequence, they share some of the spirit of our previous algorithms <ref> [19, 21, 22] </ref>. The algorithms are presented by stepwise refinements. We start by a naive algorithm OLDT-Naive which can be seen as an instantiation of the universal algorithm to the first abstract semantics. <p> The design choices behind our algorithms were dictated by the nature of abstract interpretation, which rarely manipulates large collections of abstract substitutions and for which some of the techniques used, i.e. dependencies and caching, have also proved successful in previous algorithms <ref> [21, 14] </ref>. See the experimental results for an empirical validation of these choices. The algorithm can be applied as well to recursive query processing but we have not evaluated its adequacy in that context. The rest of this section is organized as follows. <p> See <ref> [21] </ref> for more discussion on this topic. The widening at the output level is novel and is used when a new output, say fi, is about to be inserted in an output set, say S. <p> The experimental results were obtained on a variety of benchmarks (see Section 4.1) and on two abstract domains (see Section 4.2). Algorithm OLDT-GL-SU is used as the basic algorithm for OLDT. OLDT-GL-SU is also compared to a more traditional algorithm <ref> [19, 21, 14] </ref> storing tuples of the forms (fi in ; p; fi out ). <p> Comprehensive experimental results about the accuracy and efficiency of the algorithm are presented, using finite and infinite abstract domains. The algorithm is also compared to other algorithms, working at a coarser granularity <ref> [19, 21, 14] </ref>. Choices and variations of the algorithm are also carefully studied, including the impact of caching, dependencies, output subsumption, widening, and generalization. The experimental results have been particularly informative.
Reference: [22] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Reexecution in Abstract Interpretation of Prolog. </title> <booktitle> In Proceedings of the International Joint Conference and Symposium on Logic Programming (JICSLP-92), </booktitle> <address> Washington, DC, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: These algorithms can be seen as instantiations of the universal top-down fixpoint algorithm presented and proven correct in [20]. As a consequence, they share some of the spirit of our previous algorithms <ref> [19, 21, 22] </ref>. The algorithms are presented by stepwise refinements. We start by a naive algorithm OLDT-Naive which can be seen as an instantiation of the universal algorithm to the first abstract semantics.
Reference: [23] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> A Generic Fixpoint Semantics for Logic Programming and its Application for Abstract Interpretation. </title> <type> Technical report, </type> <institution> CS Department, Brown University, </institution> <year> 1993. </year> <month> Forthcoming. </month>
Reference-contexts: The two abstract semantics are shown to have the same information content for abstract interpretation, indicating the strong advantage of the second semantics from a computational standpoint. Each of the three semantics can be seen as instances of a generic semantics for Prolog for some appropriate choice of domains <ref> [23] </ref>. To simplify presentation, we first present the generic semantics and then discuss the three semantics relevant to this paper. See [23] for other semantics not directly related to OLDT-resolution. The rest of this section is organized in the following way. <p> Each of the three semantics can be seen as instances of a generic semantics for Prolog for some appropriate choice of domains <ref> [23] </ref>. To simplify presentation, we first present the generic semantics and then discuss the three semantics relevant to this paper. See [23] for other semantics not directly related to OLDT-resolution. The rest of this section is organized in the following way. Section 2.1 presents the preliminaries, including the abstract syntax considered in this paper. Section 2.2 introduces the generic semantics. <p> Then: G S i i2I 0 i : 2 It is possible to lift this hypothesis in some cases. See <ref> [23] </ref> and [20] for details. 5 2.2.3 Generic Semantic domains In the following we assume an underlying program P and we define the semantic domains and equations with respect to this underlying program.
Reference: [24] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Groundness Analysis for Prolog: Implementation and Evaluation of the Domain Prop. </title> <booktitle> In Proceedings of the ACM Symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM93), </booktitle> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: On the smaller domain, both algorithms have the same accuracy and roughly the same efficiency. This indicates that, for the domains considered in this paper, OLDT-resolution may work at too fine a granularity. Similar results can be expected on the domain Prop <ref> [9, 27, 24] </ref>, since the least upper bound operation in this domain does not lose accuracy. The main open issue now is to find out applications where the tradeoff efficiency/accuracy of OLDT-based abstract interpretation is more valuable in practice. Acknowledgements Mark Johnson helped clarifying the relationships with computational linguistics.
Reference: [25] <author> K. Marriott and H. Sondergaard. </author> <title> Notes for a Tutorial on Abstract Interpretation of Logic Programs. </title> <booktitle> North American Conference on Logic Programming, </booktitle> <address> Cleveland, Ohio, </address> <year> 1989. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. <ref> [28, 42, 25, 26, 4, 2, 8, 1] </ref>), the algorithms (e.g. [31, 2, 6, 19, 18]), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. [41, 16, 21, 14]).
Reference: [26] <author> K. Marriott and H. Sondergaard. </author> <title> Semantics-based Dataflow Analysis of Logic Programs. </title> <booktitle> In Information Processing-89, </booktitle> <pages> pages 601-606, </pages> <address> San Fransisco, CA, </address> <year> 1989. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. <ref> [28, 42, 25, 26, 4, 2, 8, 1] </ref>), the algorithms (e.g. [31, 2, 6, 19, 18]), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. [41, 16, 21, 14]).
Reference: [27] <author> K. Marriott and H. Sondergaard. </author> <title> Analysis of Constraint Logic Programs. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming (NACLP-90), </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: On the smaller domain, both algorithms have the same accuracy and roughly the same efficiency. This indicates that, for the domains considered in this paper, OLDT-resolution may work at too fine a granularity. Similar results can be expected on the domain Prop <ref> [9, 27, 24] </ref>, since the least upper bound operation in this domain does not lose accuracy. The main open issue now is to find out applications where the tradeoff efficiency/accuracy of OLDT-based abstract interpretation is more valuable in practice. Acknowledgements Mark Johnson helped clarifying the relationships with computational linguistics.
Reference: [28] <editor> C. Mellish. </editor> <booktitle> Abstract Interpretation of Prolog Programs, </booktitle> <pages> pages 181-198. </pages> <publisher> Ellis Horwood, </publisher> <year> 1987. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. <ref> [28, 42, 25, 26, 4, 2, 8, 1] </ref>), the algorithms (e.g. [31, 2, 6, 19, 18]), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. [41, 16, 21, 14]).
Reference: [29] <author> K. Musumbu. </author> <title> Interpretation Abstraite de Programmes Prolog. </title> <type> PhD thesis, </type> <institution> University of Namur (Belgium), </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: Proof Omitted. The proof of a very similar result is given in <ref> [29] </ref>. 2 2.4 Abstract Semantics (version 1) We now give a version of the generic semantics which is equivalent to the abstract computation model proposed by Codognet and File in [7] and can be used as a basis for abstract OLDT-resolution. 2.4.1 The Basic Semantic Domains Let us assume that for <p> It is best viewed as an abstraction of the domain of Bruynooghe and Janssens [3] where a pattern component has been added. The domain is fully described in <ref> [29] </ref> which contains also the proofs of monotonicity and consistency. Note also that the presentation in [29] is generic and can be instantiated to a variety of applications. The presentation here is an instantiation to modes. <p> It is best viewed as an abstraction of the domain of Bruynooghe and Janssens [3] where a pattern component has been added. The domain is fully described in <ref> [29] </ref> which contains also the proofs of monotonicity and consistency. Note also that the presentation in [29] is generic and can be instantiated to a variety of applications. The presentation here is an instantiation to modes. The key concept in the representation of the substitutions in this domain is the notion of subterm. <p> Definition 14 [Widening operator r d ] Let fi and S be a substitution and a set of substitutions defined on the same domain. fi r d S = LUBffi [ DES1 (fi; S)g: 4.2.2 The Abstract Domain Mode The domain of <ref> [29] </ref> is a reformulation of the domain of [2]. The domain could be viewed as a simplification of the elaborate domain where the pattern information has been omitted and the sharing has been simplified to an equivalence relation. Only three modes are considered: ground, var and any.
Reference: [30] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Determination of Variable Dependence Information Through Abstract Interpretation. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming (NACLP-89), </booktitle> <address> Cleveland, Ohio, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. [28, 42, 25, 26, 4, 2, 8, 1]), the algorithms (e.g. [31, 2, 6, 19, 18]), the abstract domains (e.g. <ref> [30, 3, 17] </ref>) and the implementation (e.g. [41, 16, 21, 14]). A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. [6, 15, 18, 40]). <p> The domain is more sophisticated than the sharing domains of, for instance, <ref> [17, 30] </ref> and than the mode domains of, for instance, [41, 16]. It is best viewed as an abstraction of the domain of Bruynooghe and Janssens [3] where a pattern component has been added. The domain is fully described in [29] which contains also the proofs of monotonicity and consistency.
Reference: [31] <author> R.A. O'Keefe. </author> <title> Finite Fixed-Point Problems. </title> <editor> In J-L. Lassez, editor, </editor> <booktitle> Fourth International Conference on Logic Programming, </booktitle> <pages> pages 729-743, </pages> <address> Melbourne, Australia, </address> <year> 1987. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. [28, 42, 25, 26, 4, 2, 8, 1]), the algorithms (e.g. <ref> [31, 2, 6, 19, 18] </ref>), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. [41, 16, 21, 14]). A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. [6, 15, 18, 40]).
Reference: [32] <author> D. Schmidt. </author> <title> Denotational Semantics. Wm. </title> <address> C. </address> <publisher> Brown Publishers, </publisher> <address> Dubuque, Iowa, </address> <year> 1988. </year>
Reference-contexts: It is easy to show that SS 3 D is a cpo for this ordering. The concretization function on SS 3 D is defined as previously. Note also that the above construction is essentially similar to the relational powerdomain <ref> [32] </ref> and suggests a simple way of implementing all operations as we discuss in the next section. 2.5.2 The Primitive Operations All primitive operations are defined by taking primitive operations from the preceding framework and applying function MAXS to their result. So consistency is automatically ensured.
Reference: [33] <author> S.M. Shieber. </author> <title> Constraint Based Grammar Formalism. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1992. </year> <month> 50 </month>
Reference-contexts: The first abstract semantics is a simple abstraction of the concrete semantics but it has several limitations for abstract interpretation. The second abstract semantics removes these inconvenients and uses output sub-sumption, an idea also present in natural language parsing (e.g. <ref> [33] </ref>). The two abstract semantics are shown to have the same information content for abstract interpretation, indicating the strong advantage of the second semantics from a computational standpoint. <p> Experience in building practical abstract domains has shown that this is sometimes very difficult. But this drawback can be overcome by resorting to approximations. Note also that the idea of output subsumption has appeared in other contexts, in particular in natural language parsing <ref> [33] </ref>. 9 2.5.1 The Basic Semantic Domains We assume the same sets of abstract substitutions as before. In addition, we require that they be endowed with an ordering which reflects the inclusion of sets of concrete substitutions as closely as possible.
Reference: [34] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog: Advanced Programming Techniques. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Ma, </address> <year> 1986. </year>
Reference-contexts: The clauses containing assert and retract have been dropped in the one program containing them (i.e. Syntax error handling in the reader program). The program kalah is a program which plays the game of kalah. It is taken from <ref> [34] </ref> and implements an alpha-beta search procedure. The program press is an equation-solver program taken from [34] as well. We use two versions of this program, press1 and press2, the difference being that press2 has a procedure call repeated in the body of a procedure. <p> Syntax error handling in the reader program). The program kalah is a program which plays the game of kalah. It is taken from <ref> [34] </ref> and implements an alpha-beta search procedure. The program press is an equation-solver program taken from [34] as well. We use two versions of this program, press1 and press2, the difference being that press2 has a procedure call repeated in the body of a procedure. The program cs is a cutting-stock program taken from [36].
Reference: [35] <author> H Tamaki and T. Sato. </author> <title> OLD-resolution with Tabulation. </title> <booktitle> In Third International Conference on Logic Programming, </booktitle> <pages> pages 84-98, </pages> <address> London, </address> <month> July </month> <year> 1986. </year>
Reference-contexts: The algorithms have some commonalities with recursive query processors for deductive databases. OLDT-Naive is related to the unoptimized version of QSQ [38] and the multistage depth-first strategy for OLDT-resolution <ref> [35] </ref>.
Reference: [36] <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. Logic Programming Series, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: The program press is an equation-solver program taken from [34] as well. We use two versions of this program, press1 and press2, the difference being that press2 has a procedure call repeated in the body of a procedure. The program cs is a cutting-stock program taken from <ref> [36] </ref>. It is a program used to generate a number of configurations 27 representing various ways of cutting a wood board into small shelves. The program uses, in various ways, the nondeterminism of Prolog.
Reference: [37] <author> P. Van Hentenryck, O. Degimbe, B. Le Charlier, and L. Michel. </author> <title> The impact of Granularity in Abstract Interpretation of Prolog. </title> <type> Technical report, </type> <institution> CS Department, Brown University, </institution> <year> 1993. </year> <month> Forthcoming. </month>
Reference-contexts: The detail of these changes is outside the scope of this paper but are described in <ref> [37] </ref>. As a consequence, the granularity of the algorithm becomes coarser, since many input calls are now collapsed together, and a loss of accuracy may occur. The accuracy results of OLDT-GL-SU-SI are reported in Table 25, which reports the unification specializations for the domain pattern.
Reference: [38] <author> L. Vieille. </author> <title> Recursive Axioms in Deductive Databases : the Query/Subquery Approach. </title> <booktitle> In Proceedings of the First International Conference on Expert Databases Systems, </booktitle> <pages> pages 179-193, </pages> <address> Charleston, South Carolina, </address> <month> April </month> <year> 1986. </year>
Reference-contexts: This optimization has both theoretical and practical interest, since it reduces the worst case complexity and the execution time for many applications. The algorithms have some commonalities with recursive query processors for deductive databases. OLDT-Naive is related to the unoptimized version of QSQ <ref> [38] </ref> and the multistage depth-first strategy for OLDT-resolution [35].
Reference: [39] <author> L. Vieille. </author> <title> Recursive Query Processing: The Power of Logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 1-53, </pages> <year> 1989. </year>
Reference-contexts: The algorithms have some commonalities with recursive query processors for deductive databases. OLDT-Naive is related to the unoptimized version of QSQ [38] and the multistage depth-first strategy for OLDT-resolution [35]. OLDT-Local performs the local optimization of the QoSaq framework <ref> [39] </ref> while OLDT-GL performs the global optimization of the same framework. 3 There are however important differences between the algorithms. * Contrary to the QoSaq algorithm, our algorithm works one tuple 4 at a time instead of manipulating sets of tuples. <p> The suffix optimization also enjoys the nice property that the execution is shared when a pair (fi; p) leads to the same node in a clause using different computation paths, i.e. the suffix is executed only once. This optimization is referred to as local optimization in <ref> [39] </ref> and is generally performed using subsumption tests. In our algorithm, local optimization is a consequence of the suffix dependencies. The optimization is local, since different input pairs cannot share a suffix.
Reference: [40] <author> D.S. Warren. </author> <title> Memoization for Logic Programs. </title> <journal> Communication of the ACM, </journal> <volume> 35(3), </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. <ref> [6, 15, 18, 40] </ref>). OLDT-resolution is often advocated as a basis for abstract interpretation because of its completeness properties for a variety of program classes. Another interesting aspect of OLDT-resolution as a framework for abstract interpretation is the very fine granularity it offers.
Reference: [41] <author> R. Warren, M. Hermedegildo, and S. Debray. </author> <title> On the Practicality of Global Flow Analysis of Logic Programs. </title> <booktitle> In Proc. Fifth International Conference on Logic Programming, </booktitle> <pages> pages 684-699, </pages> <address> Seattle, WA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. [28, 42, 25, 26, 4, 2, 8, 1]), the algorithms (e.g. [31, 2, 6, 19, 18]), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. <ref> [41, 16, 21, 14] </ref>). A recurring theme in abstract interpretation of Prolog is the use of OLDT-resolution as a starting point (e.g. [6, 15, 18, 40]). OLDT-resolution is often advocated as a basis for abstract interpretation because of its completeness properties for a variety of program classes. <p> The domain is more sophisticated than the sharing domains of, for instance, [17, 30] and than the mode domains of, for instance, <ref> [41, 16] </ref>. It is best viewed as an abstraction of the domain of Bruynooghe and Janssens [3] where a pattern component has been added. The domain is fully described in [29] which contains also the proofs of monotonicity and consistency.
Reference: [42] <author> W.H. Winsborough. </author> <title> A Minimal Function Graph Semantics for Logic Programs. </title> <type> Technical Report TR-711, </type> <institution> Computer Science Department, University of Wisconsin at Madison, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: Considerable progress has been realised in this area in terms of the frameworks 1 This research was done while Olivier Degimbe and Laurent Michel were visiting Brown University. 1 (e.g. <ref> [28, 42, 25, 26, 4, 2, 8, 1] </ref>), the algorithms (e.g. [31, 2, 6, 19, 18]), the abstract domains (e.g. [30, 3, 17]) and the implementation (e.g. [41, 16, 21, 14]).
References-found: 42

