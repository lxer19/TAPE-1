URL: http://www.cis.ohio-state.edu/~hartman/PUBLIC/papers/tech-intro-compressed.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~hartman/publications.html
Root-URL: 
Email: hartman@cs.utexas.edu  
Title: Technical Introduction to the First Workshop on Artificial Intelligence and Automated Program Understanding  
Author: John Hartman 
Address: 8413 Cockney Dr. Austin, TX 78748  
Affiliation: Software Understanding  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Anne Adam and Jean Pierre Laurent. LAURA, </author> <title> A system to debug student programs. </title> <journal> Artificial Intelligence, </journal> <volume> 15 </volume> <pages> 75-122, </pages> <year> 1980. </year>
Reference: [2] <author> Ray Bareiss. </author> <title> A survey of psychological models of concept representation. </title> <type> Technical Report AI TR-87-50, </type> <institution> University of Texas at Austin, Dept. of Computer Sciences, </institution> <year> 1987. </year>
Reference: [3] <author> Ted Biggerstaff, Josiah Hoskins, and Dallas Webster. DESIRE: </author> <title> A system for design recovery. </title> <type> Technical Report STP-081-89, </type> <institution> Microelectronics and Computer Technology Corporation (MCC), </institution> <month> April </month> <year> 1989. </year>
Reference: [4] <author> Premkumar Devanbu, Ronald J. Brachman, Peter G. Selfridge, and Bruce W. Ballard. </author> <title> LASSIE: a knowledge-based information system. </title> <journal> Communications of the ACM, </journal> <volume> 34(5) </volume> <pages> 34-49, </pages> <month> May </month> <year> 1991. </year>
Reference: [5] <author> Andre Engberts, Wojtek Kozaczynski, and Jim Ning. </author> <title> Automating software maintenance by concept recognition-based program transformation. </title> <booktitle> In Conference on Software Maintenance - 1991. </booktitle> <publisher> IEEE, IEEE Press, </publisher> <month> October 14-17 </month> <year> 1991. </year>
Reference: [6] <author> Mehdi T. Harandi and Jim Q. Ning. </author> <title> Knowledge-Based program analysis. </title> <journal> IEEE Software, </journal> <pages> pages 75-81, </pages> <month> January </month> <year> 1990. </year>
Reference: [7] <author> John Hartman. </author> <title> Restructuring Cobol programs into abstract data type modules. </title> <type> Technical Report SDBEG-21, </type> <institution> Dept. of Computer Sciences, The University of Texas at Austin, </institution> <year> 1980. </year> <title> Implementation is described in "XTC User's Guide", </title> <publisher> SDBEG-18. </publisher>
Reference-contexts: Language independent representations can use various forms of decomposition. For example, analyzers can produce decomposition using only control flow, eg. D-D paths, basic blocks, natural loops, intervals [21], propers [15]; data flow [33, 9, 16]; and combined control flow and data flow, eg. PBM's, slices, and modules <ref> [31, 32, 7] </ref>,[Sherman's workshop paper]. Semantic Abstraction Concept representation depends on use. For applications, semantics of the concept and its representation is a matter of convention between recognizer and application.
Reference: [8] <author> John Hartman. </author> <title> Automatic control understanding for natural programs. </title> <type> Ph.D. Thesis AI 91-161, </type> <institution> Artificial Intelligence Laboratory, Dept. of Computer Sciences, The University of Texas at Austin, Austin, </institution> <address> TX 78712-1188., </address> <month> May </month> <year> 1991. </year>
Reference-contexts: The planfulness hypothesis asserts: 1 This decomposition, terminology, and the following two sections reflect Hartman's view of program understanding, as developed in <ref> [8] </ref>. It seems to be general and useful for discussing and comparing existing systems. Other valuable models are possible. Programming is stereotyped, making frequent use of standard implementations. Under this hypothesis, program understanders should use knowledge of standard plans rather than general reasoning designed to cover all theoretically possible programs. <p> This knowledge is indexed by plans and concepts, and uses the instance-plan-concept binding to perform an application function. Plans and concepts are then seen as preconditions for activities or transformations in the application. For example, as described in Hartman's workshop paper and <ref> [8] </ref>, restructuring knowledge associated with plans can be used in Cobol restructuring. Briefly, the application knowledge for restructuring describes how particular control concepts can be restructured and recoded. A concept specific transformation is associated with each plan. <p> This requires the planfulness hypothesis to be true. Its success is an open empirical question. Our intuition is influenced by routinely reading programs with additional information like format 4 Various models of program understanding are given in <ref> [8] </ref>. They also appear, sometimes implicitly, in the APU, software engineering, plan and software psychology literature. ting, meaningful names and comments. Additional input information provides further constraints, but also increases complexity. Constraints at higher levels, eg. application domain information, informal material, advice, can help resolve ambiguity.
Reference: [9] <author> D. H. Hutchens and V. R. Basili. </author> <title> System structure analysis: Clustering with data bindings. </title> <journal> IEEE Transactions. on Software Engineering, </journal> <volume> 11(8) </volume> <pages> 749-757, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: Language independent representations can use various forms of decomposition. For example, analyzers can produce decomposition using only control flow, eg. D-D paths, basic blocks, natural loops, intervals [21], propers [15]; data flow <ref> [33, 9, 16] </ref>; and combined control flow and data flow, eg. PBM's, slices, and modules [31, 32, 7],[Sherman's workshop paper]. Semantic Abstraction Concept representation depends on use. For applications, semantics of the concept and its representation is a matter of convention between recognizer and application.
Reference: [10] <author> W. Lewis Johnson. </author> <title> INTENTION-BASED DIAGNOSIS OF NOVICE PROGRAMMING ERRORS. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1986. </year>
Reference: [11] <author> Wojtek Kozaczynski, Stanley Letovsky, and Jim Ning. </author> <title> A knowledge-based approach to software system understanding. </title> <booktitle> In Sixth Cpnfer-ence on Knowledge-Based Software Engineer-imng. </booktitle> <address> RADC, </address> <year> 1991. </year>
Reference: [12] <author> S. Letovsky. </author> <title> Program understanding with the lambda calculus. </title> <booktitle> In Proceedings of the Tenth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 512-514, </pages> <address> Milan, Italy, </address> <month> August </month> <year> 1987. </year>
Reference: [13] <author> S. Letovsky and E. Soloway. </author> <title> Delocalized plans and program comprehension. </title> <journal> IEEE Software, </journal> <volume> 3(3) </volume> <pages> 41-49, </pages> <year> 1986. </year>
Reference: [14] <author> Stanley Ian Letovsky. </author> <title> PLAN ANALYSIS OF PROGRAMS. </title> <type> PhD thesis, </type> <institution> Yale University, Dept. of Computer Science, </institution> <month> December </month> <year> 1988. </year> <note> YALEU/CSD/RR 662. </note>
Reference: [15] <author> Richard C. Linger, Harlan D. Mills, and Bernard I. </author> <title> Witt. STRUCTURED PROGRAMMING: THEORY AND PRACTICE. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: Language independent representations can use various forms of decomposition. For example, analyzers can produce decomposition using only control flow, eg. D-D paths, basic blocks, natural loops, intervals [21], propers <ref> [15] </ref>; data flow [33, 9, 16]; and combined control flow and data flow, eg. PBM's, slices, and modules [31, 32, 7],[Sherman's workshop paper]. Semantic Abstraction Concept representation depends on use. For applications, semantics of the concept and its representation is a matter of convention between recognizer and application.
Reference: [16] <author> S. S. Liu and N. Wilde. </author> <title> Identifying objects in a conventional procedural language: An example of data design recovery. </title> <booktitle> In Conference on Software Maintenance, </booktitle> <pages> pages 266-271, </pages> <address> San Diego, CA, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: Language independent representations can use various forms of decomposition. For example, analyzers can produce decomposition using only control flow, eg. D-D paths, basic blocks, natural loops, intervals [21], propers [15]; data flow <ref> [33, 9, 16] </ref>; and combined control flow and data flow, eg. PBM's, slices, and modules [31, 32, 7],[Sherman's workshop paper]. Semantic Abstraction Concept representation depends on use. For applications, semantics of the concept and its representation is a matter of convention between recognizer and application.
Reference: [17] <author> K. Miriyala and M. T. Harandi. </author> <title> Automatic derivation of formal software specifications from informal descriptions. </title> <type> Technical Report UIUCDCS-R-90-1581, </type> <institution> University of Illi-nois at Urbana-Champaign, </institution> <type> 240 DCL, 1304 W. </type> <address> Springfield Ave., Urbana, IL 61801, </address> <month> April </month> <year> 1990. </year>
Reference: [18] <author> William R. Murray. </author> <title> AUTOMATIC PROGRAM DEBUGGING FOR INTELLIGENT TUTORING SYSTEMS. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference: [19] <author> Jim Q. Ning. </author> <title> An experiment in automating code analysis. </title> <booktitle> In AAAI SPRING SYMPOSIUM ON AI and SOFTWARE ENGINEERING, </booktitle> <month> March </month> <year> 1989. </year>
Reference: [20] <author> Jim Q. Ning. </author> <title> A KNOWLEDGE-BASED APPROACH TO AUTOMATIC PROGRAM ANALYSIS. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1989. </year>
Reference: [21] <author> Michael R. Paige. </author> <title> On partitioning program graphs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 3(6), </volume> <month> November </month> <year> 1977. </year>
Reference-contexts: Language independent representations can use various forms of decomposition. For example, analyzers can produce decomposition using only control flow, eg. D-D paths, basic blocks, natural loops, intervals <ref> [21] </ref>, propers [15]; data flow [33, 9, 16]; and combined control flow and data flow, eg. PBM's, slices, and modules [31, 32, 7],[Sherman's workshop paper]. Semantic Abstraction Concept representation depends on use. For applications, semantics of the concept and its representation is a matter of convention between recognizer and application.
Reference: [22] <author> Helmut A. Partsch. </author> <title> SPECIFICATION and TRANSFORMATION OF PROGRAMS. </title> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1990. </year>
Reference: [23] <author> L. F. Pau and J. B. Kristinsson. SOFTM: </author> <title> A software maintenance expert system in Prolog. Software Maintenance: </title> <journal> Research and Practice, </journal> <volume> 2 </volume> <pages> 87-111, </pages> <year> 1990. </year>
Reference: [24] <author> Charles Rich. </author> <title> Inspection methods in programming. </title> <type> Technical Report MIT/AI/TR-604, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> June </month> <year> 1981. </year> <type> PhD Thesis. </type>
Reference: [25] <author> Charles Rich. </author> <title> Inspection methods in programming: Cliches and plans. </title> <type> Technical Report A.I. Memo No. 1005, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> December </month> <year> 1987. </year>
Reference-contexts: Decomposition isn't emphasized in these representations, perhaps because they aren't intended for large programs. TALUS and CPU are naturally decomposed by functions. Hierarchical plan diagrams with abstract segments have been described in [30] and <ref> [25] </ref>. The most important decomposition ap proach in the Programmer's Apprentice is Waters' plan building methods (PBM's).[31] Using data flow information, loops are decomposed into fragments of looping behavior such as augmentations (initialization and incrementation), filters, terminations. Current Representations Table 2 gives some program representations used in current under-standers.
Reference: [26] <author> Charles Rich and Richard C. Waters. </author> <title> THE PROGRAMMER'S APPRENTICE. </title> <publisher> ACM Press and Addison-Wesley Publishing Co., </publisher> <year> 1990. </year>
Reference: [27] <author> Charles Rich and Linda M. Wills. </author> <title> Recognizing a program's design: A graph-parsing approach. </title> <journal> IEEE Software, </journal> <pages> pages 83-90, </pages> <month> January </month> <year> 1990. </year>
Reference: [28] <author> Elliot Soloway, Jeanne Pinto, Stan Letovsky, David Littman, and Robin Lampert. </author> <title> Designing documentation to compensate for delo-calized plans. </title> <journal> Communications of the ACM, </journal> <volume> 31(11) </volume> <pages> 1259-1267, </pages> <month> November </month> <year> 1988. </year>
Reference: [29] <author> Barbara Steele. </author> <title> An accountable source-to-source transformation system. </title> <type> Technical Report MIT AI TR-636, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> June </month> <year> 1981. </year>
Reference: [30] <author> Richard C. Waters. </author> <title> Automatic analysis of the logical structure of programs. </title> <type> Technical Report MIT AI TR-492, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> December </month> <year> 1978. </year> <type> PhD Thesis. </type>
Reference-contexts: Control flow and loops have been represented as cyclic graphs or acyclic graphs with graph recursion. Decomposition isn't emphasized in these representations, perhaps because they aren't intended for large programs. TALUS and CPU are naturally decomposed by functions. Hierarchical plan diagrams with abstract segments have been described in <ref> [30] </ref> and [25]. The most important decomposition ap proach in the Programmer's Apprentice is Waters' plan building methods (PBM's).[31] Using data flow information, loops are decomposed into fragments of looping behavior such as augmentations (initialization and incrementation), filters, terminations.
Reference: [31] <author> Richard C. Waters. </author> <title> A method for automatically analyzing programs. </title> <booktitle> In International Joint Conference on Artificial Intelligence, </booktitle> <year> 1979. </year>
Reference-contexts: Language independent representations can use various forms of decomposition. For example, analyzers can produce decomposition using only control flow, eg. D-D paths, basic blocks, natural loops, intervals [21], propers [15]; data flow [33, 9, 16]; and combined control flow and data flow, eg. PBM's, slices, and modules <ref> [31, 32, 7] </ref>,[Sherman's workshop paper]. Semantic Abstraction Concept representation depends on use. For applications, semantics of the concept and its representation is a matter of convention between recognizer and application.
Reference: [32] <author> Mark Weiser. </author> <title> Program slicing. </title> <booktitle> In 5th Int. Conf. on Software Engineering, </booktitle> <month> March </month> <year> 1981. </year>
Reference-contexts: Language independent representations can use various forms of decomposition. For example, analyzers can produce decomposition using only control flow, eg. D-D paths, basic blocks, natural loops, intervals [21], propers [15]; data flow [33, 9, 16]; and combined control flow and data flow, eg. PBM's, slices, and modules <ref> [31, 32, 7] </ref>,[Sherman's workshop paper]. Semantic Abstraction Concept representation depends on use. For applications, semantics of the concept and its representation is a matter of convention between recognizer and application.
Reference: [33] <author> Paul M. Zislis. </author> <title> Semantic decomposition of computer programs: An aid to program testing. </title> <journal> Acta Informatica, </journal> <volume> 4 </volume> <pages> 245-269, </pages> <year> 1975. </year>
Reference-contexts: Language independent representations can use various forms of decomposition. For example, analyzers can produce decomposition using only control flow, eg. D-D paths, basic blocks, natural loops, intervals [21], propers [15]; data flow <ref> [33, 9, 16] </ref>; and combined control flow and data flow, eg. PBM's, slices, and modules [31, 32, 7],[Sherman's workshop paper]. Semantic Abstraction Concept representation depends on use. For applications, semantics of the concept and its representation is a matter of convention between recognizer and application.
References-found: 33

