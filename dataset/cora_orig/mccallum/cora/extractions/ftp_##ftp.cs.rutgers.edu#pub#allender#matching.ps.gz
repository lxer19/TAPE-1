URL: ftp://ftp.cs.rutgers.edu/pub/allender/matching.ps.gz
Refering-URL: http://www.cs.rutgers.edu/~allender/publications/
Root-URL: http://www.cs.rutgers.edu
Email: e-mail: allender@cs.rutgers.edu  e-mail: reinhard@informatik.uni-tuebingen.de  e-mail: shiyu@research.bell-labs.com  
Title: Isolation, Matching, and Counting: Uniform and Nonuniform Upper Bounds  
Author: Eric Allender Klaus Reinhardt Shiyu Zhou 
Address: Piscataway, NJ 08855, USA  Sand 13, D-72076 Tubingen, Germany  700 Mountain Avenue Murray Hill, NJ 07974, USA  
Affiliation: Department of Computer Science, Rutgers University  Wilhelm-Schickard Institut fur Informatik Universitat Tubingen  Bell Laboratories  
Abstract: We show that the perfect matching problem is in the complexity class SPL (in the nonuniform setting). This provides a better upper bound on the complexity of the matching problem, as well as providing motivation for studying the complexity class SPL. Using similar techniques, we show that counting the number of accepting paths of a nondeterministic logspace machine can be done in NL/poly, if the number of paths is small. This clarifies the complexity of the class LogFew (defined and studied in [BDHM91]). Using derandomization techniques, we then improve this to show that this counting problem is in NL. Determining if our other theorems hold in the uniform setting remains an fl The material in this paper appeared in preliminary form in papers in the Proceedings of the IEEE Conference on Computational Complexity, 1998, and in the Proceedings of the Workshop on Randomized Algorithms, Brno, 1998. y Supported in part by NSF grants CCR-9509603 and CCR-9734918. z Supported in part by the DFG Project La 618/3-1 KOMET. 
Abstract-found: 1
Intro-found: 1
Reference: [ABO97] <author> E. Allender, R. Beals, and M. Ogihara. </author> <title> The complexity of matrix rank and feasible systems of linear equations. </title> <type> DIMACS technical report 97-40, </type> <note> submitted for publication, a preliminary version appeared in STOC 96, </note> <year> 1997. </year>
Reference-contexts: It was observed in [BGW] that the perfect matching problem is in (nonuniform) Mod m L for every m, and as reported in <ref> [ABO97] </ref>, Vinay has pointed out that a similar argument shows that the matching problem is in (nonuniform) co-C = L. A different argument seems to be necessary to show that the matching problem is itself in (nonuniform) C = L. <p> of which the first two have been studied previously. * PL = fA : 9f 2 GapL; x 2 A , f (x) &gt; 0g (See, e.g., [Gil77, RST84, BCP83, Ogi96, BF97].) * C = L = fA : 9f 2 GapL; x 2 A , f (x) = 0g <ref> [AO96, ABO97, ST94] </ref>. * SPL = fA : A 2 GapLg. It seems that this is the first time that SPL has been singled out for study. In the remainder of this section, we state some of the basic properties of SPL.
Reference: [AJ93] <author> C. Alvarez and B. Jenner. </author> <title> A very hard log-space counting class. </title> <journal> Theoretical Computer Science, </journal> <volume> 107 </volume> <pages> 3-30, </pages> <year> 1993. </year>
Reference-contexts: A matching is perfect if every vertex is adjacent to an edge in the matching. #L (first studied by <ref> [AJ93] </ref>) is the class of functions of the form #acc M (x) : fl ! N (counting the number of accepting computations of an NL machine M on input x). GapL consists of functions that are the difference of two #L functions.
Reference: [All97] <author> E. Allender. </author> <title> Making computation count: Arithmetic circuits in the nineties. </title> <journal> SIGACT NEWS, </journal> <volume> 28(4) </volume> <pages> 2-15, </pages> <month> December </month> <year> 1997. </year>
Reference-contexts: We will use the second class as the nonuniform version of SPL for the following reasons: * The study of nonuniform complexity classes is motivated by questions of circuit complexity. GapL/poly has a natural definition in terms of skew arithmetic circuits. (See <ref> [All97] </ref> for a survey and discussion. Skew circuits were defined in [Ven91] and have received study in [Tod92].) Thus a natural definition of SPL is in terms of skew arithmetic circuits over the integers, which produce an output value in f0,1g.
Reference: [AO96] <author> E. Allender and M. Ogihara. </author> <title> Relationships among PL, #L, and the determinant. </title> <journal> RAIRO Theoretical Information and Application, </journal> <volume> 30 </volume> <pages> 1-21, </pages> <year> 1996. </year>
Reference-contexts: GapL consists of functions that are the difference of two #L functions. Alternatively, GapL is the class of all functions that are logspace many-one reducible to computing the determinant of integer matrices. (See, e.g. <ref> [AO96, MV97] </ref>.) By analogy with the class GapP [FFK94], one may define a number of language classes by means of GapL functions. <p> of which the first two have been studied previously. * PL = fA : 9f 2 GapL; x 2 A , f (x) &gt; 0g (See, e.g., [Gil77, RST84, BCP83, Ogi96, BF97].) * C = L = fA : 9f 2 GapL; x 2 A , f (x) = 0g <ref> [AO96, ABO97, ST94] </ref>. * SPL = fA : A 2 GapLg. It seems that this is the first time that SPL has been singled out for study. In the remainder of this section, we state some of the basic properties of SPL. <p> We defer the definition of this class until Section 4, but we note here that it is immediate from the definitions that LogFew is closed under complement, and it was observed in <ref> [AO96] </ref> that LogFew is contained in C = L. 3 Matching We will find it very helpful to make use of the GapL algorithm of [MV97] for computing the determinant of a matrix. (For our purposes, it is sufficient to consider only matrices with entries in f0; 1g.) The following definitions <p> Now consider the function h (x; i; j) that is defined to be g (x; i; j) (j&lt;j 0 ) or (i 0 &lt;i and j 0 =j) It follows from the standard closure properties of GapL that h is in GapL. (See, e.g. <ref> [AO96] </ref>.) If j is the lowest-numbered "good" q-weight function for x, then for the correct value of i, h (x; i; j) is equal to 1. For all other values of i and j, h (x; i; j) is equal to 0.
Reference: [AR88] <author> E. Allender and R. Rubinstein. </author> <title> P-printable sets. </title> <journal> SIAM J. Comput., </journal> <volume> 17 </volume> <pages> 1193-1202, </pages> <year> 1988. </year>
Reference: [AS92] <author> N. Alon and J. Spencer. </author> <title> The Probabilistic Method. </title> <publisher> John Wiley and Sons, </publisher> <year> 1992. </year>
Reference: [AZ98] <author> E. Allender and S. Zhou. </author> <title> Uniform inclusions in nondeterministic logspace. </title> <editor> In R. Freivalds, editor, </editor> <booktitle> Randomized Algorithms, </booktitle> <pages> pages 35-41, </pages> <year> 1998. </year> <booktitle> MFCS Satellite Workshop, </booktitle> <address> Brno, Czech Republic. </address>
Reference-contexts: We remark that a more complicated proof of this theorem, using *-biased probability spaces, was presented in an earlier version of this work <ref> [AZ98] </ref>. 5.1.1 The classes LogFew and LogFewNL Theorem 5.1 has the following consequences. In [BDHM91], the complexity classes LogFewNL and LogFew were defined.
Reference: [BCH86] <author> P. W. Beame, S. A. Cook, and H. J. </author> <title> Hoover. Log depth circuits for division and related problems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 15 </volume> <pages> 994-1003, </pages> <year> 1986. </year>
Reference-contexts: Then f (x) is in FNL/poly. Proof: Compute i = f (x) and j = g (x) as in the preceding proof. Now note that i can be computed using a polynomial number of multiplications and one division, and thus has P-uniform NC 1 circuits <ref> [BCH86] </ref>. The resulting algorithm is NC 1 reducible to NL, and thus is in FNL/poly. (Note that, in contrast to Theorem 4.2, Theorem 4.3 cannot be derandomized using Theorem 5.4, since the construction in [BCH86] does not use a probabilis tic argument.) 5 Derandomizing the Constructions It is natural to wonder <p> using a polynomial number of multiplications and one division, and thus has P-uniform NC 1 circuits <ref> [BCH86] </ref>. The resulting algorithm is NC 1 reducible to NL, and thus is in FNL/poly. (Note that, in contrast to Theorem 4.2, Theorem 4.3 cannot be derandomized using Theorem 5.4, since the construction in [BCH86] does not use a probabilis tic argument.) 5 Derandomizing the Constructions It is natural to wonder if our constructions hold also in the uniform setting.
Reference: [BCP83] <author> A. Borodin, S. Cook, and N. Pippenger. </author> <title> Parallel Computation for Well-Endowed Rings and Space-Bounded Probabilistic Machines. </title> <journal> Inf. Control, </journal> <volume> 58(1-3):113-136, </volume> <year> 1983. </year>
Reference-contexts: We mention in particular the following three complexity classes, of which the first two have been studied previously. * PL = fA : 9f 2 GapL; x 2 A , f (x) &gt; 0g (See, e.g., <ref> [Gil77, RST84, BCP83, Ogi96, BF97] </ref>.) * C = L = fA : 9f 2 GapL; x 2 A , f (x) = 0g [AO96, ABO97, ST94]. * SPL = fA : A 2 GapLg. It seems that this is the first time that SPL has been singled out for study.
Reference: [BDHM91] <author> Gerhard Buntrock, Carsten Damm, Ulrich Hertrampf, and Christoph Meinel. </author> <title> Structure and importance of logspace-MOD class. </title> <journal> Math. Systems Theory, </journal> <volume> 25 </volume> <pages> 223-237, </pages> <year> 1991. </year>
Reference-contexts: in nonuniform SPL. (However, note that Theorem 5.4 shows that, under a plausible complexity-theoretic hypothesis, the matching problem is in uniform SPL.) 5 In addition to proving new results about the matching problem, we also prove new inclusions for the complexity class LogFew, which was originally defined and studied in <ref> [BDHM91] </ref>. <p> If there is some i for which this number is at least j, then halt and accept. The theorem now follows by closure of NL/poly under complement [Imm88, Sze88]. This is also an appropriate place to present two results that improve on a lemma of <ref> [BDHM91] </ref> in the nonuniform setting. Lemma 12 of [BDHM91] states that, if M is a "weakly unambiguous" logspace machine with f (x) = #acc M (x), and g is computable in logspace, then the function f (x) (Although we will not need the definition of a "weakly unambiguous machine" here, we <p> The theorem now follows by closure of NL/poly under complement [Imm88, Sze88]. This is also an appropriate place to present two results that improve on a lemma of <ref> [BDHM91] </ref> in the nonuniform setting. Lemma 12 of [BDHM91] states that, if M is a "weakly unambiguous" logspace machine with f (x) = #acc M (x), and g is computable in logspace, then the function f (x) (Although we will not need the definition of a "weakly unambiguous machine" here, we note that as a consequence, f (x) is <p> We remark that a more complicated proof of this theorem, using *-biased probability spaces, was presented in an earlier version of this work [AZ98]. 5.1.1 The classes LogFew and LogFewNL Theorem 5.1 has the following consequences. In <ref> [BDHM91] </ref>, the complexity classes LogFewNL and LogFew were defined. In [BDHM91], these classes were defined using "weakly unambiguous machines"; an NL machine is weakly unambiguous if, for any two accepting computation paths, the halting configurations are distinct. <p> We remark that a more complicated proof of this theorem, using *-biased probability spaces, was presented in an earlier version of this work [AZ98]. 5.1.1 The classes LogFew and LogFewNL Theorem 5.1 has the following consequences. In <ref> [BDHM91] </ref>, the complexity classes LogFewNL and LogFew were defined. In [BDHM91], these classes were defined using "weakly unambiguous machines"; an NL machine is weakly unambiguous if, for any two accepting computation paths, the halting configurations are distinct. <p> Since there are only a polynomial number of configurations for an NL machine, it follows that the number of accepting computation paths is bounded by a polynomial. Using their definitions, it is shown in <ref> [BDHM91] </ref> that LogFew is contained in Mod m L for any m. Although [BDHM91] leaves open the relationship between LogFew and NL, Buntrock [Bun98] has pointed out that there is a simple direct argument showing that LogFew is in NL, if the original definition in [BDHM91] is used. <p> Since there are only a polynomial number of configurations for an NL machine, it follows that the number of accepting computation paths is bounded by a polynomial. Using their definitions, it is shown in <ref> [BDHM91] </ref> that LogFew is contained in Mod m L for any m. Although [BDHM91] leaves open the relationship between LogFew and NL, Buntrock [Bun98] has pointed out that there is a simple direct argument showing that LogFew is in NL, if the original definition in [BDHM91] is used. The definitions in [BDHM91] were made in analogy with the complexity classes FewP and Few ([AR88, <p> definitions, it is shown in <ref> [BDHM91] </ref> that LogFew is contained in Mod m L for any m. Although [BDHM91] leaves open the relationship between LogFew and NL, Buntrock [Bun98] has pointed out that there is a simple direct argument showing that LogFew is in NL, if the original definition in [BDHM91] is used. The definitions in [BDHM91] were made in analogy with the complexity classes FewP and Few ([AR88, CH90]), and it seems that the notion of "weakly unambiguous machines" was devised primarily in order to make it easier to prove inclusion of LogFew in Mod m L. <p> Although <ref> [BDHM91] </ref> leaves open the relationship between LogFew and NL, Buntrock [Bun98] has pointed out that there is a simple direct argument showing that LogFew is in NL, if the original definition in [BDHM91] is used. The definitions in [BDHM91] were made in analogy with the complexity classes FewP and Few ([AR88, CH90]), and it seems that the notion of "weakly unambiguous machines" was devised primarily in order to make it easier to prove inclusion of LogFew in Mod m L. <p> We believe it is more natural to define these classes simply in terms of counting the number of accepting computations; we provide our definitions in the next paragraph. In so doing, we obtain classes that trivially contain the classes as they were defined in <ref> [BDHM91] </ref>. We believe that our definitions actually are equivalent to theirs (and indeed, we believe that all of these classes actually coincide with NL), but currently we cannot prove that this is the case.
Reference: [BF97] <author> R. Beigel and B. Fu. </author> <title> Circuits over PP and PL. </title> <booktitle> In IEEE Conference on Computational Complexity, </booktitle> <pages> pages 24-35, </pages> <year> 1997. </year>
Reference-contexts: We mention in particular the following three complexity classes, of which the first two have been studied previously. * PL = fA : 9f 2 GapL; x 2 A , f (x) &gt; 0g (See, e.g., <ref> [Gil77, RST84, BCP83, Ogi96, BF97] </ref>.) * C = L = fA : 9f 2 GapL; x 2 A , f (x) = 0g [AO96, ABO97, ST94]. * SPL = fA : A 2 GapLg. It seems that this is the first time that SPL has been singled out for study.
Reference: [BGW] <author> L. Babai, A. Gal, and A. Wigderson. </author> <title> Superpolynomial lower bounds for monotone span programs. </title> <type> DIMACS Technical Report 96-37. </type>
Reference-contexts: It was observed in <ref> [BGW] </ref> that the perfect matching problem is in (nonuniform) Mod m L for every m, and as reported in [ABO97], Vinay has pointed out that a similar argument shows that the matching problem is in (nonuniform) co-C = L.
Reference: [Bun98] <author> G. Buntrock. </author> <type> Personal communication. </type> <year> 1998. </year>
Reference-contexts: Using their definitions, it is shown in [BDHM91] that LogFew is contained in Mod m L for any m. Although [BDHM91] leaves open the relationship between LogFew and NL, Buntrock <ref> [Bun98] </ref> has pointed out that there is a simple direct argument showing that LogFew is in NL, if the original definition in [BDHM91] is used.
Reference: [CG88] <author> B. Chor and O. Goldreich. </author> <title> Unbiased bits from sources of weak randomness and probabilistic communication complexity. </title> <journal> SIAM J. Comput., </journal> <volume> 17(2) </volume> <pages> 230-261, </pages> <month> April </month> <year> 1988. </year>
Reference: [CH90] <author> Jin-Yi Cai and Lane A. Hemachandra. </author> <title> On the power of parity polynomial time. </title> <journal> Mathematical Systems Theory, </journal> <volume> 23 </volume> <pages> 95-106, </pages> <year> 1990. </year>
Reference: [Edm65] <author> J. Edmonds. </author> <title> Matching and a polyhedron with O-1 vertices. </title> <institution> J. Res. Natl. Bur. Stand., </institution> <month> 69 </month> <pages> 125-130, </pages> <year> 1965. </year>
Reference-contexts: In the process, we present a new upper bound on some problems related to matchings in graphs. The perfect matching problem is one of the best-studied graph problems in theoretical computer science. (For definitions, see Section 2.) It is known to have polynomial-time algorithms <ref> [Edm65] </ref>, and it is known to be in RNC [KUW86, MVV87], although at present no deterministic NC algorithm is known. Our new upper bound for matching builds on the RNC algorithm. Before we can explain the nature of our bound, we need some definitions.
Reference: [Fel50] <author> W. Feller. </author> <title> An Introduction to Probability Theory and Its Applications. </title> <publisher> John Wiley and Sons, 3rd edition, </publisher> <year> 1950. </year>
Reference: [FFK94] <author> Stephen A. Fenner, Lance J. Fortnow, and Stuart A. Kurtz. </author> <title> Gap-definable counting classes. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 48 </volume> <pages> 116-148, </pages> <year> 1994. </year>
Reference-contexts: Our new upper bound for matching builds on the RNC algorithm. Before we can explain the nature of our bound, we need some definitions. In <ref> [FFK94] </ref>, Fenner, Fortnow, and Kurtz defined the complexity class SPP to be fA : A 2 GapPg. They also showed that this same class of languages can be defined equivalently as fA : GapP A = GapPg. <p> GapL consists of functions that are the difference of two #L functions. Alternatively, GapL is the class of all functions that are logspace many-one reducible to computing the determinant of integer matrices. (See, e.g. [AO96, MV97].) By analogy with the class GapP <ref> [FFK94] </ref>, one may define a number of language classes by means of GapL functions. <p> " co-C = L. (The second inclusion holds because SPL is easily seen to be closed under complement.) Proposition 2.2 SPL = fA : GapL A = GapLg (using the Ruzzo-Simon-Tompa notion of space-bounded Turing reducibility for nondeterministic machines [RST84]). (This is proved very similarly to the analogous result in <ref> [FFK94] </ref>. In showing that GapL A GapL if A 2 SPP, we need only to observe that in the simulation of an oracle Turing machine given in [FFK94], it is not necessary to guess all of 3 UL NL LogFew SPL co-C = LC = L Matching PL @ @ D <p> GapLg (using the Ruzzo-Simon-Tompa notion of space-bounded Turing reducibility for nondeterministic machines [RST84]). (This is proved very similarly to the analogous result in <ref> [FFK94] </ref>. In showing that GapL A GapL if A 2 SPP, we need only to observe that in the simulation of an oracle Turing machine given in [FFK94], it is not necessary to guess all of 3 UL NL LogFew SPL co-C = LC = L Matching PL @ @ D D H H H H H H H H D D @ fi fi fi and classes UL = NL = LogFew Matching SPL PL D a
Reference: [FKS82] <author> M. Fredman, J. Komlos, and Endre Szemeredi. </author> <title> Storing a sparse table with o(1) worst case access time. </title> <booktitle> In 23rd IEEE Symposium on Foundations of Computer Science (FOCS), </booktitle> <pages> pages 165-169, </pages> <year> 1982. </year> <month> 18 </month>
Reference: [Gil77] <author> J. Gill. </author> <title> Computational complexity of probabilistic Turing machines. </title> <journal> SIAM J. Comput., </journal> <volume> 6(4) </volume> <pages> 675-695, </pages> <month> December </month> <year> 1977. </year>
Reference-contexts: We mention in particular the following three complexity classes, of which the first two have been studied previously. * PL = fA : 9f 2 GapL; x 2 A , f (x) &gt; 0g (See, e.g., <ref> [Gil77, RST84, BCP83, Ogi96, BF97] </ref>.) * C = L = fA : 9f 2 GapL; x 2 A , f (x) = 0g [AO96, ABO97, ST94]. * SPL = fA : A 2 GapLg. It seems that this is the first time that SPL has been singled out for study.
Reference: [Imm88] <author> N. Immerman. </author> <title> Nondeterministic space is closed under complement. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17 </volume> <pages> 935-938, </pages> <year> 1988. </year>
Reference-contexts: If there is some i for which this number is at least j, then halt and accept. The theorem now follows by closure of NL/poly under complement <ref> [Imm88, Sze88] </ref>. This is also an appropriate place to present two results that improve on a lemma of [BDHM91] in the nonuniform setting.
Reference: [IW97] <author> R. Impagliazzo and A. Wigderson. </author> <title> P = BP P if E requires exponential circuits: Derandomizing the XOR lemma. </title> <booktitle> In ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 220-229, </pages> <year> 1997. </year>
Reference-contexts: The construction of a function h meeting these parameters and computable in logspace is not explicit in [NW94], but we will use a construction communicated to us by Avi Wigderson [Wig97]. (See also <ref> [IW97] </ref>.) Assume for now that we have the function h. Here is how to compute g: On input y of length l = k log N , produce a sequence of N output bits, where the ith bit is produced as follows.
Reference: [KSTT92] <author> J. Kobler, U. Schoning, S. Toda, and J. Toran. </author> <title> Turing machines with few accepting computations and low sets for pp. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 44 </volume> <pages> 272-286, </pages> <year> 1992. </year>
Reference-contexts: It now follows easily that any LogFew language is in L SPL , which is equal to SPL. It is perhaps worth noting that Theorem 5.2 is in some sense the logspace-analog of the inclusion Few SPP, which was proved in <ref> [KSTT92] </ref>. Their proof relies on the fact that, for any #P function f and any polynomial-time function g that is bounded by a polynomial in n, the function f (x) is in #P.
Reference: [KUW86] <author> R.M. Karp, E. Upfal, and A. Wigderson. </author> <title> Constructing a perfect matching is in random NC. </title> <journal> Combinatorica, </journal> <volume> 6(1) </volume> <pages> 35-48, </pages> <year> 1986. </year>
Reference-contexts: The perfect matching problem is one of the best-studied graph problems in theoretical computer science. (For definitions, see Section 2.) It is known to have polynomial-time algorithms [Edm65], and it is known to be in RNC <ref> [KUW86, MVV87] </ref>, although at present no deterministic NC algorithm is known. Our new upper bound for matching builds on the RNC algorithm. Before we can explain the nature of our bound, we need some definitions. <p> of SPL: * perfect matching (i.e., does a perfect matching exist). * maximum matching (i.e., constructing a matching of maximum possible size) * maximum flow with unary weights All of these problems were previously known to be hard for NL, and were known to be (nonuniformly) reducible to the determinant <ref> [KUW86, MVV87] </ref>. It was observed in [BGW] that the perfect matching problem is in (nonuniform) Mod m L for every m, and as reported in [ABO97], Vinay has pointed out that a similar argument shows that the matching problem is in (nonuniform) co-C = L. <p> Otherwise, g (G) = 1. This completes the proof of the following theorem. Theorem 3.1 The perfect matching problem is in nonuniform SPL. 3.1 Construction algorithm So far we have described the decision algorithm for the existence of a perfect matching. As shown in <ref> [KUW86] </ref>, there is a function that finds a perfect matching (if it exists) in Random-NC. We will now show that this can be done in SPL. However, first, we must define what it means for a function to be in SPL. <p> By adding an increasing number of vertices having edges to every vertex until a perfect matching is found (and eliminating these vertices afterwards), we get: Corollary 3.3 Constructing a maximum matching is in nonuniform FSPL. Since by <ref> [KUW86] </ref>, constructing a maximum flow in a graph with unary weights can be reduced to constructing a maximum matching, we get: Corollary 3.4 Constructing a maximum flow in a graph with unary weights is in nonuniform FSPL.
Reference: [Meh82] <author> K. Mehlhorn. </author> <title> On the program size of perfect and universal hash functions. </title> <booktitle> In 23rd IEEE Symposium on Foundations of Computer Science (FOCS), </booktitle> <pages> pages 170-175, </pages> <year> 1982. </year>
Reference: [MV97] <author> M. Mahajan and V. Vinay. </author> <title> Determinant: Combinatorics, algorithms, and complexity. </title> <journal> Chicago Journal of Theoretical Computer Science, </journal> <volume> (5), </volume> <year> 1997. </year>
Reference-contexts: GapL consists of functions that are the difference of two #L functions. Alternatively, GapL is the class of all functions that are logspace many-one reducible to computing the determinant of integer matrices. (See, e.g. <ref> [AO96, MV97] </ref>.) By analogy with the class GapP [FFK94], one may define a number of language classes by means of GapL functions. <p> until Section 4, but we note here that it is immediate from the definitions that LogFew is closed under complement, and it was observed in [AO96] that LogFew is contained in C = L. 3 Matching We will find it very helpful to make use of the GapL algorithm of <ref> [MV97] </ref> for computing the determinant of a matrix. (For our purposes, it is sufficient to consider only matrices with entries in f0; 1g.) The following definitions are from [MV97]: A clow (clow for clo-sed w-alk) is a walk hw 1 ; : : : ; w l i starting from vertex <p> is contained in C = L. 3 Matching We will find it very helpful to make use of the GapL algorithm of <ref> [MV97] </ref> for computing the determinant of a matrix. (For our purposes, it is sufficient to consider only matrices with entries in f0; 1g.) The following definitions are from [MV97]: A clow (clow for clo-sed w-alk) is a walk hw 1 ; : : : ; w l i starting from vertex w 1 and ending at the same vertex, where any hw i ; w i+1 i is an edge in the graph. w 1 is the least numbered <p> The sequence is ordered: head (C 1 ) &lt; head (C 2 ) &lt; : : : &lt; head (C k ). The total number of edges (counted with multiplicity) adds to exactly n. The main result of <ref> [MV97] </ref> is that the determinant of a matrix A is equal to the number of accepting computations of M minus the number of rejecting computations of M , where M is the nondeterministic logspace-bounded Turing machine that, when given a matrix A, tries to guess a clow sequence C 1 ; <p> If k is odd, M rejects, and otherwise M accepts. The crucial insight that makes the construction of <ref> [MV97] </ref> work correctly is this: If C 1 ; : : : ; C k is not a cycle cover (that is, a collection of disjoint cycles covering all of the vertices of M ), then there is a "twin" clow sequence D 1 ; : : : ; D k
Reference: [MVV87] <author> K. Mulmuley, U. Vazirani, and V. Vazirani. </author> <title> Matching is as easy as matrix inversion. </title> <journal> Combinatorica, </journal> <volume> 7 </volume> <pages> 105-113, </pages> <year> 1987. </year>
Reference-contexts: The perfect matching problem is one of the best-studied graph problems in theoretical computer science. (For definitions, see Section 2.) It is known to have polynomial-time algorithms [Edm65], and it is known to be in RNC <ref> [KUW86, MVV87] </ref>, although at present no deterministic NC algorithm is known. Our new upper bound for matching builds on the RNC algorithm. Before we can explain the nature of our bound, we need some definitions. <p> of SPL: * perfect matching (i.e., does a perfect matching exist). * maximum matching (i.e., constructing a matching of maximum possible size) * maximum flow with unary weights All of these problems were previously known to be hard for NL, and were known to be (nonuniformly) reducible to the determinant <ref> [KUW86, MVV87] </ref>. It was observed in [BGW] that the perfect matching problem is in (nonuniform) Mod m L for every m, and as reported in [ABO97], Vinay has pointed out that a similar argument shows that the matching problem is in (nonuniform) co-C = L. <p> Since cycle covers correspond to permutations, this yields exactly the determinant of A.) Here is an algorithm showing that the perfect matching problem is in SPL (nonuniformly). For simplicity, we consider only the bipartite case here. The general case follows as in <ref> [MVV87] </ref>. 6 First, note that there is a sequence (w 1 ; w 2 ; : : : w r ) having length n O (1) with the property that, for every bipartite graph G on 2n vertices, either G has no perfect matching, or there is some i and some <p> property that, for every bipartite graph G on 2n vertices, either G has no perfect matching, or there is some i and some j n 6 such that, under weight function w i , the minimum-weight matching in G is unique and has weight j. (To see this, note that <ref> [MVV87] </ref> shows that if a weight function is chosen at random, giving each edge a weight in the range [1; 4n 2 ], then with probability at least 3 4 there is at most one minimum-weight matching. Now pick a sequence of n 2 such weight functions independently at random. <p> In particular, if f is a #L function such that f (x) is bounded by a polynomial in jxj, then in the nonuniform setting, computing f is no harder than NL. Proof: First we use the Isolation Lemma of <ref> [MVV87] </ref> to show that, if we choose a weight function w : (V fi V ) ! [1::4p (n) 2 n 2 ] at random, then with probability 3 4 , any graph with at most p (n) accepting paths will have no two accepting paths with the same weight. <p> Call this event Bad (i; j; v; w). Thus it suffices to bound X X X X Prob (Bad (i; j; v; w)): Now just as in <ref> [MVV87] </ref> (or as in our application of the Isolation Lemma in [RA97]), Prob (Bad (i; j; v; w)) is at most 1=(4p (n) 2 n 2 ), which completes the proof. <p> Is the perfect matching problem reducible to its complement? Is the matching problem in NL? Is it complete for SPL? (Does SPL even have any complete problems?) Is the matching problem complete for some "natural" class between NL and SPL? As in <ref> [MVV87] </ref>, our techniques apply equally well to both the perfect matching problem and to the bipartite perfect matching problem.
Reference: [NW94] <author> N. Nisan and A. Wigderson. </author> <title> Hardness vs. randomness. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 49 </volume> <pages> 149-167, </pages> <year> 1994. </year>
Reference-contexts: Note that, in contrast, this closure property is not known to hold for #L or GapL functions (but compare this with Theorem 4.3). In contrast, we still do not know how to "derandomize" Theorems 4.2 and 4.3. 5.2 A conditional derandomization Nisan and Wigderson <ref> [NW94] </ref> defined a notion of "hardness" of languages. <p> The techniques and results of Nisan and Wigderson <ref> [NW94] </ref>, together with some technical material from [IW97][Lemma18], can be used to show that if there is a set K in DSPACE (n) having hardness 2 *n , then there is a pseudorandom generator g computable in space log n with the property that no statistical test of size n can <p> The construction of a function h meeting these parameters and computable in logspace is not explicit in <ref> [NW94] </ref>, but we will use a construction communicated to us by Avi Wigderson [Wig97]. (See also [IW97].) Assume for now that we have the function h. <p> Let z be the string of length m corresponding to the bits of y in the positions in A. Output K (z) as the ith bit of g (y) (where K is the language in DSPACE (n) with hardness 2 *n ). The argument given in <ref> [NW94] </ref> shows that, given the constant * in the hardness condition for K, then for all large enough constants k 0 (where in particular k 0 must be greater than 1=*), then for any k with the property that the desired function h exists, g has the desired pseudorandomness property. <p> Thus there are infinitely many values n for which there is a graph G n on n vertices for which the algorithm gives an incorrect answer. This will give us the following statistical test of size N distinguishing pseudorandom input from random input, in contradiction to <ref> [NW94] </ref>: Given an input of length N = n 13 , check if at least one of the first n 3 weight functions works correctly for graph G n .
Reference: [Ogi96] <author> M. Ogihara. </author> <title> The PL hierarchy collapses. </title> <booktitle> In ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 84-88, </pages> <year> 1996. </year> <note> to appear in SIAM J. Comput. </note>
Reference-contexts: We mention in particular the following three complexity classes, of which the first two have been studied previously. * PL = fA : 9f 2 GapL; x 2 A , f (x) &gt; 0g (See, e.g., <ref> [Gil77, RST84, BCP83, Ogi96, BF97] </ref>.) * C = L = fA : 9f 2 GapL; x 2 A , f (x) = 0g [AO96, ABO97, ST94]. * SPL = fA : A 2 GapLg. It seems that this is the first time that SPL has been singled out for study.
Reference: [RA97] <author> K. Reinhardt and E. Allender. </author> <title> Making nondeterminism unambiguous. </title> <booktitle> In 38 th IEEE Symposium on Foundations of Computer Science (FOCS), </booktitle> <pages> pages 244-253, </pages> <year> 1997. </year>
Reference-contexts: 1 Introduction In <ref> [RA97] </ref>, the authors presented new results concerning NL, UL, and #L. The current paper builds on this earlier work, in an attempt to better understand these complexity classes, as well as some related classes. <p> = L Matching PL @ @ D D H H H D a a a a a a a a @ @ fi fi fi the oracle queries and answers at the start of the computation, but that instead these can be guessed one-by-one as needed.) Since UL/poly = NL/poly <ref> [RA97] </ref>, it follows that, in the nonuniform setting, NL is contained in SPL. However, it needs to be noted at this point that it is not quite clear what the "nonuniform version of SPL" should be. <p> Call this event Bad (i; j; v; w). Thus it suffices to bound X X X X Prob (Bad (i; j; v; w)): Now just as in [MVV87] (or as in our application of the Isolation Lemma in <ref> [RA97] </ref>), Prob (Bad (i; j; v; w)) is at most 1=(4p (n) 2 n 2 ), which completes the proof. Thus, just as in [RA97], there must exist some sequence (w 1 ; w 2 ; : : : ; w n 2 ) of weight functions such that, for all <p> bound X X X X Prob (Bad (i; j; v; w)): Now just as in [MVV87] (or as in our application of the Isolation Lemma in <ref> [RA97] </ref>), Prob (Bad (i; j; v; w)) is at most 1=(4p (n) 2 n 2 ), which completes the proof. Thus, just as in [RA97], there must exist some sequence (w 1 ; w 2 ; : : : ; w n 2 ) of weight functions such that, for all graphs G on n vertices, if G has at most p (n) accepting paths, then there is some i such that, when w i <p> Proof: Use Theorem 4.1 to find the number i = jxj O (1) such that f (x) = i. If, for all j i; g (x) 6= j, then output zero. Otherwise, let j = g (x). Using the 10 fact that NL/poly = UL/poly <ref> [RA97] </ref>, we may assume that there is a unique path that determines the correct values of i and j. <p> From the definitions, it is immediate that UL LogFewNL NL, and LogFewNL LogFew. Thus it is immediate from <ref> [RA97] </ref> that in the nonuniform setting LogFewNL and NL coincide with UL. It remained open whether LogFew is contained in NL. An affirmative answer follows from Theorem 5.1. <p> Thus, for all large N , D &lt; 1=N 2 , as desired. Theorem 5.4 If there is a set in DSPACE (n) with hardness 2 *n for some * &gt; 0, then the nonuniform constructions in this paper (and in <ref> [RA97] </ref>) hold also in the uniform setting. Proof: We illustrate with Theorem 3.1. The other constructions can be derandomized in a similar manner.
Reference: [RST84] <author> W. L. Ruzzo, J. Simon, and M. Tompa. </author> <title> Space-bounded hierarchies and probabilistic computations. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 28 </volume> <pages> 216-230, </pages> <year> 1984. </year>
Reference-contexts: We mention in particular the following three complexity classes, of which the first two have been studied previously. * PL = fA : 9f 2 GapL; x 2 A , f (x) &gt; 0g (See, e.g., <ref> [Gil77, RST84, BCP83, Ogi96, BF97] </ref>.) * C = L = fA : 9f 2 GapL; x 2 A , f (x) = 0g [AO96, ABO97, ST94]. * SPL = fA : A 2 GapLg. It seems that this is the first time that SPL has been singled out for study. <p> Proposition 2.1 UL SPL C = L " co-C = L. (The second inclusion holds because SPL is easily seen to be closed under complement.) Proposition 2.2 SPL = fA : GapL A = GapLg (using the Ruzzo-Simon-Tompa notion of space-bounded Turing reducibility for nondeterministic machines <ref> [RST84] </ref>). (This is proved very similarly to the analogous result in [FFK94].
Reference: [ST94] <author> M. Santha and S. Tan. </author> <title> Verifying the Determinant. </title> <booktitle> In Proceedings of the 5th Symposium on Algorithms and Computation, </booktitle> <volume> LNCS 834, </volume> <pages> pages 65-73. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: of which the first two have been studied previously. * PL = fA : 9f 2 GapL; x 2 A , f (x) &gt; 0g (See, e.g., [Gil77, RST84, BCP83, Ogi96, BF97].) * C = L = fA : 9f 2 GapL; x 2 A , f (x) = 0g <ref> [AO96, ABO97, ST94] </ref>. * SPL = fA : A 2 GapLg. It seems that this is the first time that SPL has been singled out for study. In the remainder of this section, we state some of the basic properties of SPL.
Reference: [Sze88] <author> R. Szelepcsenyi. </author> <title> The method of forced enumeration for nondeterministic automata. </title> <journal> Acta Informatica, </journal> <volume> 26 </volume> <pages> 279-284, </pages> <year> 1988. </year> <month> 19 </month>
Reference-contexts: If there is some i for which this number is at least j, then halt and accept. The theorem now follows by closure of NL/poly under complement <ref> [Imm88, Sze88] </ref>. This is also an appropriate place to present two results that improve on a lemma of [BDHM91] in the nonuniform setting.
Reference: [Tod92] <author> S. </author> <title> Toda. Classes of arithmetic circuits capturing the complexity of computing the determinant. </title> <journal> IEICE Trans. Inf. and Syst., </journal> <volume> E75-D:116-124, </volume> <year> 1992. </year>
Reference-contexts: GapL/poly has a natural definition in terms of skew arithmetic circuits. (See [All97] for a survey and discussion. Skew circuits were defined in [Ven91] and have received study in <ref> [Tod92] </ref>.) Thus a natural definition of SPL is in terms of skew arithmetic circuits over the integers, which produce an output value in f0,1g.
Reference: [Ven91] <author> H. Venkateswaran. </author> <title> Properties that characterize LOGCFL. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43 </volume> <pages> 380-404, </pages> <year> 1991. </year>
Reference-contexts: GapL/poly has a natural definition in terms of skew arithmetic circuits. (See [All97] for a survey and discussion. Skew circuits were defined in <ref> [Ven91] </ref> and have received study in [Tod92].) Thus a natural definition of SPL is in terms of skew arithmetic circuits over the integers, which produce an output value in f0,1g.
Reference: [Wig95] <author> Avi Wigderson. </author> <title> Lectures on the fusion method and derandom-ization. </title> <institution> Technical Report SOCS-95.2,School of Computer Science, McGill University, </institution> <year> 1995. </year>
Reference-contexts: Clearly all of this computation can be done in logspace. It suffices now to provide the proof of our claim. Proof: For 1 j n, let r j be the random variable with value set (a + i j fl b). As in [CG88][Section 3] (see also <ref> [Wig95] </ref>), for each pair of m-sets A and B, the events r i = A and r j = B are independent (so Prob (r i = A ^ r j = b) = Prob (r i = A)Prob (r j = B)).
Reference: [Wig97] <author> Avi Wigderson. </author> <type> Personal communication. </type> <year> 1997. </year> <month> 20 </month>
Reference-contexts: The construction of a function h meeting these parameters and computable in logspace is not explicit in [NW94], but we will use a construction communicated to us by Avi Wigderson <ref> [Wig97] </ref>. (See also [IW97].) Assume for now that we have the function h. Here is how to compute g: On input y of length l = k log N , produce a sequence of N output bits, where the ith bit is produced as follows.
References-found: 37

