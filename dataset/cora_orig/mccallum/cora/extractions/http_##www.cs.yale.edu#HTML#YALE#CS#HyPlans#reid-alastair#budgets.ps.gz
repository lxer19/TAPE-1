URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/reid-alastair/budgets.ps.gz
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/reid-alastair/
Root-URL: http://www.cs.yale.edu
Title: Implementing Fudgets with Standard Widget Sets  
Author: Alastair Reid Satnam Singh 
Note: Fudgets during an industrial case study.  
Date: July 6, 1998  
Affiliation: Computing Science Department University of Glasgow  
Abstract: Carlsson and Hallgren [1] describe the implementation of a set of "functional widgets" (Fudgets): components for programming graphical user interfaces under the X window system using the non-strict functional programming language Haskell. We describe an alternative implementation based on existing widget sets (currently Openlook and Motif). Our purpose is twofold: to show that the Fudgets approach can be applied to existing widget sets; and to discuss problems experienced with 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Carlsson and T. Hallgren. Fudgets: </author> <title> A Graphical User Interface in a Lazy Functional Language. </title> <booktitle> In Proceedings of the Conference on Functional Programming and Computer Architecture, </booktitle> <year> 1993. </year>
Reference-contexts: Both X11 and Xt are equipped with sophisticated resource database managers. To illustrate the idiomatic C style for writing X11 software, we show below a (slightly simplified) program that changes the label text of a user interface component (taken from <ref> [1] </ref>): static int count = 0; static void setDisplay (Widget display, int i) - char s [10]; Arg wargs [1]; sprintf (s, "%d", i); XtSetArg (wargs [0],XmNlabelString, s); XtSetValues (display, wargs, 1); - static void increment (Widget display) - count++; setDisplay (display, count); - void main () - Widget top, row, <p> To illustrate the idiomatic C style for writing X11 software, we show below a (slightly simplified) program that changes the label text of a user interface component (taken from <ref> [1] </ref>): static int count = 0; static void setDisplay (Widget display, int i) - char s [10]; Arg wargs [1]; sprintf (s, "%d", i); XtSetArg (wargs [0],XmNlabelString, s); XtSetValues (display, wargs, 1); - static void increment (Widget display) - count++; setDisplay (display, count); - void main () - Widget top, row, button, counter; top = XtInitialise (); row = XmCreateRowColumn ("row", top); display = XmCreateLabel ("display",row); button = XmCreatePushButton ("button",row); <p> The next section discusses an approach which is dramatically simpler than the above. 4 Fudgets In <ref> [1] </ref> Carlsson and Hallgren argue that functional languages are better for implementing GUIs because they offer better abstraction facilities. In particular, their approach makes extensive use of higher-order functions to capture common patterns of coding within GUI programs.
Reference: [2] <author> M. Carlsson and T. </author> <title> Hallgren. </title> <type> Private communication. </type> <month> 14 October, </month> <year> 1993. </year>
Reference-contexts: It is neither possible nor sensible to convert the first kind to the second kind. Carlsson and Hallgren have confirmed <ref> [2] </ref> that their implementation of Fudgets suffers from a similar problem though they solve it in a different manner. 2. Both the validation section and the database lookup section have two outputs; with both Carlsson and Hallgren's Fudgets and our own, Fudgets are only allowed to have a single output.
Reference: [3] <author> S.L. Peyton Jones and J. Launchbury. </author> <title> Unboxed values as first class citizens in a non-strict functional languages. </title> <editor> In J. Hughes, editor, </editor> <booktitle> Proceedings of the Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pp. 636-666, </pages> <address> Cambridge, Massachussets, USA, </address> <month> 26-28 August </month> <year> 1991. </year>
Reference-contexts: The major difficulty here is in passing values from Haskell into the imperative functions and from imperative functions into Haskell. For simple values such as integers and strings, we were able to use the method of "unboxing" described by Peyton Jones and Launchbury <ref> [3] </ref>; to allow us to pass more complex values such as callbacks, we made a small, general-purpose extension to the Glasgow compiler. 1 This basic approach can also be used to translate programs which use the X and widget libraries into Haskell.
Reference: [4] <author> S.L. Peyton-Jones and P. Wadler. </author> <title> Imperative Functional Programming. </title> <booktitle> In Proceedings of the 1993 Conference on Principles of Programming Languages, </booktitle> <address> Charleston, </address> <publisher> ACM, </publisher> <year> 1993. </year>
Reference-contexts: A more recent approach (supported by the Glasgow compiler) is to use a monad <ref> [4] </ref> to execute a series of side-effecting actions in a strict sequence. <p> When executed, a1 `thenIO` a2 first executes a1 obtaining a result r and then executes the action a2 r. We refer the reader to <ref> [4] </ref> for further details. Using the monadic approach, the main task of providing access to a set of imperative library functions is to define a set of Haskell functions which call the corresponding imperative function.
Reference: [5] <author> J. Launchbury. </author> <title> Lazy Imperative Programming. </title> <booktitle> In Proceedings of the Workshop on State in Programming Languages, </booktitle> <pages> pp. 46-56, </pages> <address> Copenhagen, </address> <year> 1993. </year> <note> (Available as YALEU/DCS/RR-968, </note> <institution> Yale University.) </institution>
Reference-contexts: One further difficulty lies in the implementation of global variables. We use the following solution described by Launchbury in <ref> [5] </ref>. * The type Var ff is an abstract data type of mutable variables of type ff. * Given an initial value x say, executing the operation newVar x allocates a variable with initial value x, and returns a reference to the variable. * Given a variable v::Var ff, executing readVar
Reference: [6] <author> A. Reid. </author> <title> A Window-based Application Front-End in Haskell BT Research Labs, </title> <editor> Martlesham Heath. </editor> <month> September </month> <year> 1993. </year>
Reference-contexts: However, in some circumstances, we found the structured approach required when using Fudgets overly restrictive. During the summer of 1993, the first author carried out a case study for BT | investigating the suitability of Functional Programming Languages for industrial use <ref> [6] </ref> | during which we implemented a front end for a small part of BT's database.
Reference: [7] <author> D. Sinclair. </author> <title> Lazy Wafe | Graphical Interfaces for Functional Languages. </title> <editor> In Heldal et al., editor, </editor> <booktitle> Glasgow Workshop on Functional Programming, </booktitle> <year> 1992. </year>
Reference-contexts: Since the X-library functions have various side-effects (the most obvious of which is drawing an image on the screen) it is necessary to ensure that the operations occur in the correct sequence. Previous approaches <ref> [8, 7] </ref> have guaranteed that actions occur in a strict sequence by sending a list of commands to an interpreter (written in an imperative language) which executes the commands in the order they are received.
Reference: [8] <author> S. Singh. </author> <title> Using XView/X11 from Miranda. </title> <editor> In Heldal et al., editor, </editor> <booktitle> Glasgow Workshop on Functional Programming, </booktitle> <year> 1992. </year> <month> 12 </month>
Reference-contexts: Since the X-library functions have various side-effects (the most obvious of which is drawing an image on the screen) it is necessary to ensure that the operations occur in the correct sequence. Previous approaches <ref> [8, 7] </ref> have guaranteed that actions occur in a strict sequence by sending a list of commands to an interpreter (written in an imperative language) which executes the commands in the order they are received.
References-found: 8

