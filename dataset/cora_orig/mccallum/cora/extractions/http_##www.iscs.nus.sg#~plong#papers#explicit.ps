URL: http://www.iscs.nus.sg/~plong/papers/explicit.ps
Refering-URL: 
Root-URL: 
Title: Explicit Bit Minimization for Motion-Compensated Video Coding (extended abstract)  
Author: Dzung T. Hoang Philip M. Long Jeffrey Scott Vitter 
Address: Box 90129 Durham, NC 27708-0129  
Affiliation: Department of Computer Science Duke University  
Abstract: We compare methods for choosing motion vectors for motion-compensated video compression. Our primary focus is on videophone and videoconferenc-ing applications, where very low bit rates are necessary, where the motion is usually limited, and where the frames must be coded in the order they are generated. We provide evidence, using established benchmark videos of this type, that choosing motion vectors to minimize codelength subject to (implicit) constraints on quality yields substantially better rate-distortion tradeoffs than minimizing notions of prediction error. We illustrate this point using an algorithm within the p fi 64 standard. We show that using quadtrees to code the motion vectors in conjunction with explicit codelength minimization yields further improvement. We describe a dynamic-programming algorithm for choosing a quadtree to minimize the codelength.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Bierling. </author> <title> Displacement estimation by hierarchical blockmatching. </title> <booktitle> SPIE Vol. 1001 Visual Communications and Image Processing, </booktitle> <pages> pages 942-951, </pages> <year> 1988. </year>
Reference-contexts: Bierling <ref> [1] </ref> described a hierarchical algorithm for choosing motion vectors in which initially motion vectors are chosen for large blocks (64 fi 64) by minimizing the prediction error. 2 Then for each large block B, motion vectors are chosen for subblocks of B again by minimizing prediction error, except looking only at
Reference: [2] <author> B. Carpentieri and J. Storer. </author> <title> A split-merge parallel block matching algorithm for video displacement estimation. </title> <booktitle> In Proceedings of the 1992 IEEE Data Compression Conference, </booktitle> <pages> pages 239-248, </pages> <address> Snowbird, UT, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: The most popular method for estimating these motion vectors originated with Jain and Jain [8] and is called block matching. In their approach, the current frame is divided into blocks (usually 8fi8) whose pixels are assigned the same motion vector. (Carpentieri and Storer <ref> [2] </ref> group together blocks with the same motion vector into superblocks, and describe a method for keeping track of which block is in which superblock, in order to reduce the encoding of the motion vectors.) Jain and Jain's approach is taken by the CCITT in Recommendation H.261 (also known as the
Reference: [3] <author> CCITT. </author> <title> Video codec for audiovisual services at p fi 64 kbit/s, 1990. Study group XV Report R 37. </title>
Reference-contexts: the same motion vector into superblocks, and describe a method for keeping track of which block is in which superblock, in order to reduce the encoding of the motion vectors.) Jain and Jain's approach is taken by the CCITT in Recommendation H.261 (also known as the p fi 64 standard) <ref> [3, 10] </ref>. The motion vector for a given block B is usually obtained by (approximately) minimizing, from among candidates ~v within a limited search area, some norm of the difference between B and the prediction obtained from ~v. <p> error, adaptively choosing a transform for each block from among those in a given list by taking the one that resulted in the shortest code. 2 Within the p fi 64 standard In this section, we compare the performance of three algorithms which conform to the p fi 64 standard <ref> [3, 10] </ref>. The first algorithm 1 chooses motion vectors to minimize a notion of the prediction error.
Reference: [4] <author> M.H. Chan, Y.B. Yu, and A.G. Constantinides. </author> <title> Variable size block matching motion compensation with applications to video coding. </title> <booktitle> IEE proceedings, </booktitle> <volume> 137(4) </volume> <pages> 205-212, </pages> <year> 1990. </year>
Reference-contexts: Potentially better results can be achieved by directly exploiting the two-dimensional correlation of motion vectors. A quadtree data structure can be used for this purpose by encoding a hierarchical decomposition of a frame into variable-sized regions of uniform motion <ref> [4] </ref>. For video sequences where there are large regions of uniform motion, a quadtree decomposition could reduce the number of bits required to encode the motion field compared to a method which used fixed-sized blocks. <p> While Bierling did not discuss how to code motion vectors obtained through by his method, Chan, Yu, and Constantinides <ref> [4] </ref> described a method where motion vectors are again chosen in a top-down fashion, starting with large blocks and refining with smaller blocks, except when the average squared prediction error for a given block B is below a given threshold, the algorithm does not refine the motion vector chosen for B <p> Zhang, Cavenor, and Arnold [15] considered various ways of using quadtrees to code the prediction error. 3.2 Description of our algorithm In <ref> [4] </ref>, Chan, Yu, and Constantinides describe several coding schemes using quadtrees in which the split/merge operations used to construct the tree are controlled by prediction error criteria.
Reference: [5] <author> F. Dufaux and M. Kunt. </author> <title> Multigrid block matching motion estimation with an adaptive local mesh refinement. </title> <booktitle> SPIE Vol. 1818 Visual Communications and Image Processing, </booktitle> <pages> pages 97-109, </pages> <year> 1992. </year>
Reference-contexts: Methods for taking a tree structure like the above (except expanded completely) and then "smoothing" the motion vectors by making children tend to be like their parents and vice-versa, were discussed by Dufaux and Kunt <ref> [5] </ref>. Zhang, Cavenor, and Arnold [15] considered various ways of using quadtrees to code the prediction error. 3.2 Description of our algorithm In [4], Chan, Yu, and Constantinides describe several coding schemes using quadtrees in which the split/merge operations used to construct the tree are controlled by prediction error criteria.
Reference: [6] <institution> Portable Video Research Group. Pvrg-p64 codec 1.1, </institution> <year> 1993. </year> <note> Available from Stanford University by anonymous ftp. </note>
Reference-contexts: This is done, for example, in the implementation of the p fi 64 standard made available by the Portable Video Research Group (PVRG) <ref> [6] </ref>. In this paper, we report on work in progress investigating the use of heuristics that more directly estimate the effect of the choice of a given motion vector on the total codelength. Our experimental results give evidence that this approach yields substantially better rate-distortion tradeoffs.
Reference: [7] <author> P. G. Howard and J. S. Vitter. </author> <title> Analysis of arithmetic coding for data compression. </title> <booktitle> Information Processing and Management, </booktitle> <volume> 28(6) </volume> <pages> 749-763, </pages> <year> 1992. </year> <title> Special issue on data compression for images and texts. </title>
Reference: [8] <author> J.R. Jain and A.K. Jain. </author> <title> Displacement measurement and its application in interframe coding. </title> <journal> IEEE Transactions on Communications, </journal> <volume> COM-29(12):1799-1808, </volume> <year> 1981. </year>
Reference-contexts: The most popular method for estimating these motion vectors originated with Jain and Jain <ref> [8] </ref> and is called block matching. <p> The basic coder design is similar to the p fi 64 coder shown in Figure 1. The difference is that now motion vectors are coded with a 2 In fact, a heuristic search <ref> [8, 9] </ref> was used to only approximately minimize the error. quadtree whose leaves represent regions of uniform motion. Conceptually, one might associate a motion vector with each node of the quadtree, which, for internal nodes, is refined further down the tree.
Reference: [9] <author> T. Koga, K. Iinuma, A. Hirano, Y. Iijima, and T. Ishiguro. </author> <title> Motion-compensated interframe coding for video conferencing. </title> <booktitle> Proceedings of the NTC 81, </booktitle> <pages> pages G5.3.1-G5.3.5, </pages> <year> 1981. </year>
Reference-contexts: The basic coder design is similar to the p fi 64 coder shown in Figure 1. The difference is that now motion vectors are coded with a 2 In fact, a heuristic search <ref> [8, 9] </ref> was used to only approximately minimize the error. quadtree whose leaves represent regions of uniform motion. Conceptually, one might associate a motion vector with each node of the quadtree, which, for internal nodes, is refined further down the tree.
Reference: [10] <author> M. Liou. </author> <title> Overview of the p fi 64 kbit/s video coding standard. </title> <journal> Communications of the ACM, </journal> <volume> 34(4) </volume> <pages> 60-63, </pages> <year> 1991. </year>
Reference-contexts: the same motion vector into superblocks, and describe a method for keeping track of which block is in which superblock, in order to reduce the encoding of the motion vectors.) Jain and Jain's approach is taken by the CCITT in Recommendation H.261 (also known as the p fi 64 standard) <ref> [3, 10] </ref>. The motion vector for a given block B is usually obtained by (approximately) minimizing, from among candidates ~v within a limited search area, some norm of the difference between B and the prediction obtained from ~v. <p> error, adaptively choosing a transform for each block from among those in a given list by taking the one that resulted in the shortest code. 2 Within the p fi 64 standard In this section, we compare the performance of three algorithms which conform to the p fi 64 standard <ref> [3, 10] </ref>. The first algorithm 1 chooses motion vectors to minimize a notion of the prediction error.
Reference: [11] <author> A. Puri and H.-M. Hang. </author> <title> Adaptive schemes for motion-compensated coding. </title> <booktitle> SPIE Vol. 1001 Visual Communications and Image Processing, </booktitle> <pages> pages 925-935, </pages> <year> 1988. </year>
Reference-contexts: To the best of our knowledge, ours is the first work investigating the effect of minimizing codelength subject to quality constraints to choose motion vectors. Puri and Hang <ref> [11] </ref> considered using transform coding for the error, adaptively choosing a transform for each block from among those in a given list by taking the one that resulted in the shortest code. 2 Within the p fi 64 standard In this section, we compare the performance of three algorithms which conform <p> In this section, we consider the instantiation of the bit-minimization principle in an algorithm which uses a quadtree to code motion vectors, thereby departing from the p fi 64 standard. 3.1 Previous work Puri and Hang <ref> [11] </ref> considered an algorithm for motion-compensated video coding which, when an 8 fi 8 block B is not coded well (that is, when coding it requires a lot of bits), chooses a separate motion vector for each of B's four 4fi4 subblocks.
Reference: [12] <author> H. Shvaytser. </author> <title> Occam algorithms for computing visual motion. </title> <booktitle> In Proceedings of ICCV, </booktitle> <year> 1993. </year>
Reference-contexts: However, an accurate motion field is desirable for motion interpolation, where a non-coded frame is interpolated from two successive coded frames by performing motion compensa tion using an interpolated motion field. We plan to apply our techniques to the compression-related optic flow techniques of <ref> [12] </ref>, which should result in improved motion estimates. In the next section, we describe the PVRG implementation of the p fi 64 standard, and then show how to modify the PVRG implementation, but remain within the p fi 64 standard, to choose motion vectors that more directly minimize codelength. <p> The MPEG approach is more suitable for computationally intensive encoding methods, as long as decoding is fast, as in the case at hand. We are also interested in adapting the optic flow algorithms of Shvaytser <ref> [12] </ref>, which use the Occam paradigm of minimizing code length in order to get better estimates of the motion. However, the algorithms in [12] only approximately minimize code length, since they ignore the coding of the error signal. <p> We are also interested in adapting the optic flow algorithms of Shvaytser <ref> [12] </ref>, which use the Occam paradigm of minimizing code length in order to get better estimates of the motion. However, the algorithms in [12] only approximately minimize code length, since they ignore the coding of the error signal. The approach we advocate in this paper, when combined with the prediction framework in [12] should yield better motion estimates. <p> However, the algorithms in <ref> [12] </ref> only approximately minimize code length, since they ignore the coding of the error signal. The approach we advocate in this paper, when combined with the prediction framework in [12] should yield better motion estimates.
Reference: [13] <author> A. Singh. </author> <title> Optic Flow Computation. </title> <publisher> IEEE Computer Science Press, </publisher> <year> 1991. </year>
Reference-contexts: Using the block-matching approach, we create only a crude, but concise, model of the motion. For video coding, we do not necessarily want to find the "correct" motion vectors, in contrast to a goal of research in optic flow, for example <ref> [13] </ref>. If a motion vector field that does not correspond to the actual motion in the scene yields the shortest description, that is sufficient for purposes of compression.
Reference: [14] <author> P. Strobach. </author> <title> Quadtree-structured interframe coding of hdtv sequences. </title> <booktitle> SPIE Vol. 1001 Visual Communications and Image Processing, </booktitle> <pages> pages 812-820, </pages> <year> 1988. </year>
Reference: [15] <author> X. Zhang, M.C. Cavenor, and J.F. Arnold. </author> <title> Adaptive quadtree coding of motion-compensated image sequences for use on the broadband isdn. </title> <journal> IEEE Transactions on Circuits and Systems for Video Technology, </journal> <volume> 3(3) </volume> <pages> 222-229, </pages> <year> 1993. </year>
Reference-contexts: Methods for taking a tree structure like the above (except expanded completely) and then "smoothing" the motion vectors by making children tend to be like their parents and vice-versa, were discussed by Dufaux and Kunt [5]. Zhang, Cavenor, and Arnold <ref> [15] </ref> considered various ways of using quadtrees to code the prediction error. 3.2 Description of our algorithm In [4], Chan, Yu, and Constantinides describe several coding schemes using quadtrees in which the split/merge operations used to construct the tree are controlled by prediction error criteria.
References-found: 15

