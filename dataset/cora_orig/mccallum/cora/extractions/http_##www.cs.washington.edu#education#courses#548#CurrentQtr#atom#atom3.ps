URL: http://www.cs.washington.edu/education/courses/548/CurrentQtr/atom/atom3.ps
Refering-URL: http://www.cs.washington.edu/education/courses/548/CurrentQtr/
Root-URL: 
Title: J U L Y  ATOM: A Flexible Interface for Building High Performance Program Analysis Tools  
Author: Alan Eustace Amitabh Srivastava d i g i t a l 
Address: Avenue Palo Alto, California 94301 USA  
Affiliation: Western Research Laboratory 250 University  
Pubnum: 1 9 9 4 Technical Note TN-44  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Anant Agarwal, Richard Sites, and Mark Horwitz. ATUM: </author> <title> A New Technique for Capturing Address Traces Using Microcode. </title> <booktitle> Proceedings of the 13th International Symposium on Computer Architecture, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: They communicate these traces to analysis routines through inter-process communication. Tracing on the WRL Titan [3] communicated with analysis routines using shared memory, but this required operating system modifications. MPTRACE [6] is similar to Pixie but it collects traces for multiprocessors by instrumenting assembly code. ATUM <ref> [1] </ref> generates address traces by modifying microcode and saves a compressed trace in a file that is analyzed offline. The third class of tools consists of simulators. Tango Lite [7] supports multiprocessor simulation by instrumenting assembly language code. <p> 12 AddCallProgram (ProgramAfter, PrintResults); 13 g 1 #include &lt;stdio.h&gt; 2 #include &lt;stdlib.h&gt; 3 long totalMalloc, totalFree = 0; 4 char *my malloc (size t size) f 5 size t *mptr = (long *) malloc (size+sizeof (long)); 6 totalMalloc += size; 7 mptr [0] = size; 8 return ((void *) &mptr <ref> [1] </ref>); 9 g 10 my free (void *ptr) f 11 size t *mptr = ptr; 12 size t size = mptr [-1]; 13 totalFree += size; 14 free (&mptr [-1]); 15 g 16 void PrintResults () f 17 FILE *file = fopen ( dyn.out, w); 18 fprintf (file, %ld %ldnn, totalMalloc,
Reference: [2] <author> Robert Bedichek. </author> <title> Some Efficient Architectures Simulation Techniques. </title> <booktitle> Winter 1990 USENIX Conference, </booktitle> <month> January </month> <year> 1990. </year>
Reference-contexts: The third class of tools consists of simulators. Tango Lite [7] supports multiprocessor simulation by instrumenting assembly language code. PROTEUS [4] also supports multiprocessor simulation but instrumentation is done by the compiler. g88 <ref> [2] </ref> simulates Motorola 88000 using threaded interpreter techniques. Shade [5] uses instruction level simulation to selectively generate traces. This technique offers considerable flexibility at the expense of much lower performance.
Reference: [3] <author> Anita Borg, R.E. Kessler, Georgia Lazana, and David Wall. </author> <title> Long Address Traces from RISC Machines: Generation and Analysis, </title> <booktitle> Proceedings of the 17th Annual Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1990, </year> <note> also available as WRL Research Report 89/14, </note> <month> Sep </month> <year> 1989. </year>
Reference-contexts: The second class consists of data and instruction address tracing tools. Pixie and QPT can also generate address traces. They communicate these traces to analysis routines through inter-process communication. Tracing on the WRL Titan <ref> [3] </ref> communicated with analysis routines using shared memory, but this required operating system modifications. MPTRACE [6] is similar to Pixie but it collects traces for multiprocessors by instrumenting assembly code. ATUM [1] generates address traces by modifying microcode and saves a compressed trace in a file that is analyzed offline.
Reference: [4] <author> Eric A. Brewer, Chrysanthos N. Dellarocas, Adrian Colbrook, and William E. Weihl. PROTEUS: </author> <title> A High-Performance Parallel-Architecture Simulator. </title> <publisher> MIT/LCS/TR-516, MIT, </publisher> <year> 1991. </year>
Reference-contexts: ATUM [1] generates address traces by modifying microcode and saves a compressed trace in a file that is analyzed offline. The third class of tools consists of simulators. Tango Lite [7] supports multiprocessor simulation by instrumenting assembly language code. PROTEUS <ref> [4] </ref> also supports multiprocessor simulation but instrumentation is done by the compiler. g88 [2] simulates Motorola 88000 using threaded interpreter techniques. Shade [5] uses instruction level simulation to selectively generate traces. This technique offers considerable flexibility at the expense of much lower performance.
Reference: [5] <author> Robert F. Cmelik and David Keppel, Shade: </author> <title> A Fast Instruction-Set Simulator for Execution Profiling. </title> <type> Technical Report UWCSE 93-06-06, </type> <institution> University of Washington. </institution>
Reference-contexts: The third class of tools consists of simulators. Tango Lite [7] supports multiprocessor simulation by instrumenting assembly language code. PROTEUS [4] also supports multiprocessor simulation but instrumentation is done by the compiler. g88 [2] simulates Motorola 88000 using threaded interpreter techniques. Shade <ref> [5] </ref> uses instruction level simulation to selectively generate traces. This technique offers considerable flexibility at the expense of much lower performance. The important features that distinguish ATOM [18, 15, 16] from previous systems are listed below. * ATOM is a tool-building system.
Reference: [6] <author> Susan J. Eggers, David R. Keppel, Eric J. Koldinger, and Henry M. Levy. </author> <title> Techniques for Efficient Inline Tracing on a Shared-Memory Multiprocessor. </title> <booktitle> SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <volume> vol 8, no 1, </volume> <month> May </month> <year> 1990. </year> <month> 15 </month>
Reference-contexts: The second class consists of data and instruction address tracing tools. Pixie and QPT can also generate address traces. They communicate these traces to analysis routines through inter-process communication. Tracing on the WRL Titan [3] communicated with analysis routines using shared memory, but this required operating system modifications. MPTRACE <ref> [6] </ref> is similar to Pixie but it collects traces for multiprocessors by instrumenting assembly code. ATUM [1] generates address traces by modifying microcode and saves a compressed trace in a file that is analyzed offline. The third class of tools consists of simulators.
Reference: [7] <author> Stephen R. Goldschmidt and John L. Hennessy, </author> <title> The Accuracy of Trace-Driven Simu--lations of Multiprocessors. </title> <institution> CSL-TR-92-546, Computer Systems Laboratory, Stanford University, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: MPTRACE [6] is similar to Pixie but it collects traces for multiprocessors by instrumenting assembly code. ATUM [1] generates address traces by modifying microcode and saves a compressed trace in a file that is analyzed offline. The third class of tools consists of simulators. Tango Lite <ref> [7] </ref> supports multiprocessor simulation by instrumenting assembly language code. PROTEUS [4] also supports multiprocessor simulation but instrumentation is done by the compiler. g88 [2] simulates Motorola 88000 using threaded interpreter techniques. Shade [5] uses instruction level simulation to selectively generate traces.
Reference: [8] <author> Robert Hastings and Bob Joyce. </author> <title> Fast Detection of Memory Leaks and Access Errors. </title> <booktitle> Winter 1992 USENIX Conference, </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: Line 14 calls the standard free procedure to deallocate the memory. The ability to replace procedures and monitor data references is fundamental to an emerging set of tools that monitor allocations, deallocations and references to memory <ref> [8] </ref>. Jeremy Dion and Louis Monier [14] recently completed an ambitious ATOM based tool called Third Degree, that finds and reports many kinds of reads of uninitialized memory, reads and writes to unallocated memory, array bound errors, and freeing the same object more than once.
Reference: [9] <author> John L. Hennessy and David A. Patterson. </author> <booktitle> Computer Architecture: A Quantitative Approach, </booktitle> <pages> pp. 408-425, </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: This disparity has led computer architects to place a subset of main memory into one or more levels of fast, expensive cache memory <ref> [9] </ref>. The effectiveness of this technique is application dependent. Applications that reference the same address multiple times or that use nearby data items benefit most from the data cache.
Reference: [10] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language, </title> <publisher> Prentice-Hall, </publisher> <year> 1978. </year>
Reference: [11] <author> James R. Larus and Thomas Ball. </author> <title> Rewriting executable files to measure program behavior. </title> <journal> Software, Practice and Experience, </journal> <volume> vol 24, no. 2, </volume> <pages> pp 197-218, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: Over the past decade three classes of tools for different machines and applications have been developed. The first class consists of basic block counting tools like Pixie [13], Epoxie [22] and QPT <ref> [11] </ref>. The second class consists of data and instruction address tracing tools. Pixie and QPT can also generate address traces. They communicate these traces to analysis routines through inter-process communication. Tracing on the WRL Titan [3] communicated with analysis routines using shared memory, but this required operating system modifications.
Reference: [12] <author> James R. Larus and Satish Chandra. </author> <title> Using Tracing and Dynamic Slicing to Tune Compilers. </title> <institution> University of Wisconsin Computer Sciences Department Technical Report #1174. </institution> <month> August, </month> <year> 1993 </year>
Reference-contexts: Unfortunately, these techniques are complicated and interact in non-trivial ways. The resulting code often misses simple optimizations. Tools that evaluate the quality of the compiled code and isolate potential performance problems are called compiler auditors <ref> [12] </ref>. This section presents a simple compiler auditing tool that adds a procedure call before each load instruction to save the contents of the destination register. Another procedure call is added after each load instruction that checks to see if the destination register was modified by the instruction.
Reference: [13] <institution> MIPS Computer Systems, Inc. Assembly Language Programmer's Guide, </institution> <year> 1986. </year>
Reference-contexts: Over the past decade three classes of tools for different machines and applications have been developed. The first class consists of basic block counting tools like Pixie <ref> [13] </ref>, Epoxie [22] and QPT [11]. The second class consists of data and instruction address tracing tools. Pixie and QPT can also generate address traces. They communicate these traces to analysis routines through inter-process communication.
Reference: [14] <author> Digital Equipment Corporation. </author> <title> Third Degree Reference Manual, </title> <year> 1993 </year>
Reference-contexts: Line 14 calls the standard free procedure to deallocate the memory. The ability to replace procedures and monitor data references is fundamental to an emerging set of tools that monitor allocations, deallocations and references to memory [8]. Jeremy Dion and Louis Monier <ref> [14] </ref> recently completed an ambitious ATOM based tool called Third Degree, that finds and reports many kinds of reads of uninitialized memory, reads and writes to unallocated memory, array bound errors, and freeing the same object more than once.
Reference: [15] <institution> Digital Equipment Corporation. </institution> <note> ATOM Reference Manual, </note> <year> 1993 </year>
Reference-contexts: Shade [5] uses instruction level simulation to selectively generate traces. This technique offers considerable flexibility at the expense of much lower performance. The important features that distinguish ATOM <ref> [18, 15, 16] </ref> from previous systems are listed below. * ATOM is a tool-building system. A diverse set of tools ranging from basic block counting to cache modeling can be easily built. * ATOM provides the common infrastructure in all code-instrumenting tools, which is the cumbersome part.
Reference: [16] <author> Digital Equipment Corporation. </author> <title> ATOM User Manual, </title> <year> 1993 </year>
Reference-contexts: Shade [5] uses instruction level simulation to selectively generate traces. This technique offers considerable flexibility at the expense of much lower performance. The important features that distinguish ATOM <ref> [18, 15, 16] </ref> from previous systems are listed below. * ATOM is a tool-building system. A diverse set of tools ranging from basic block counting to cache modeling can be easily built. * ATOM provides the common infrastructure in all code-instrumenting tools, which is the cumbersome part.
Reference: [17] <author> Richard L. Sites, ed. </author> <title> Alpha Architecture Reference Manual Digital Press, </title> <year> 1992. </year>
Reference: [18] <author> Amitabh Srivastava and Alan Eustace. </author> <title> ATOM: A System for Building Customized Program Analysis Tools. </title> <booktitle> Proceedings of the SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <month> June, </month> <year> 1994. </year>
Reference-contexts: Shade [5] uses instruction level simulation to selectively generate traces. This technique offers considerable flexibility at the expense of much lower performance. The important features that distinguish ATOM <ref> [18, 15, 16] </ref> from previous systems are listed below. * ATOM is a tool-building system. A diverse set of tools ranging from basic block counting to cache modeling can be easily built. * ATOM provides the common infrastructure in all code-instrumenting tools, which is the cumbersome part.
Reference: [19] <author> Amitabh Srivastava and David W. Wall. </author> <title> A Practical System for Intermodule Code Optimization at Link-Time. </title> <journal> Journal of Programming Language, </journal> <volume> 1(1), </volume> <pages> pp 1-18, </pages> <month> March </month> <year> 1993. </year> <note> Also available as WRL Research Report 92/6, </note> <month> December </month> <year> 1992. </year> <month> 16 </month>
Reference-contexts: To illustrate the performance of these tools, each was applied to the SPEC92 tool suite. The instrumented application times are compared to the uninstrumented applications using wall clock times. 2 Implementation of ATOM ATOM is built using OM <ref> [19, 20, 21] </ref>, a link-time code modification system. a tool specific instrumentation file to produce a custom instrumenting tool. This program reads in the user application, and modifies it by adding calls to tool specific analysis procedures.
Reference: [20] <author> Amitabh Srivastava and David W. Wall. </author> <title> Link-Time Optimization of Address Calcu--lation on a 64-bit Architecture. Proceedings of the SIGPLAN'94 Conference on Programming Language Design and Implementation, </title> <note> to appear. Also available as WRL Research Report 94/1, </note> <month> February </month> <year> 1994. </year>
Reference-contexts: To illustrate the performance of these tools, each was applied to the SPEC92 tool suite. The instrumented application times are compared to the uninstrumented applications using wall clock times. 2 Implementation of ATOM ATOM is built using OM <ref> [19, 20, 21] </ref>, a link-time code modification system. a tool specific instrumentation file to produce a custom instrumenting tool. This program reads in the user application, and modifies it by adding calls to tool specific analysis procedures.
Reference: [21] <author> Amitabh Srivastava. </author> <title> Unreachable procedures in object-oriented programming, </title> <journal> ACM LOPLAS, </journal> <volume> Vol 1, #4, </volume> <pages> pp 355-364, </pages> <month> December </month> <year> 1992. </year> <note> Also available as WRL Research Report 93/4, </note> <month> August </month> <year> 1993. </year>
Reference-contexts: To illustrate the performance of these tools, each was applied to the SPEC92 tool suite. The instrumented application times are compared to the uninstrumented applications using wall clock times. 2 Implementation of ATOM ATOM is built using OM <ref> [19, 20, 21] </ref>, a link-time code modification system. a tool specific instrumentation file to produce a custom instrumenting tool. This program reads in the user application, and modifies it by adding calls to tool specific analysis procedures.

References-found: 21

