URL: http://www.cs.tamu.edu/faculty/vaidya/papers/fault-tolerance/93-015.ps.Z
Refering-URL: http://www.cs.tamu.edu/faculty/vaidya/Vaidya-ftc.html
Root-URL: http://www.cs.tamu.edu
Title: Degradable Byzantine Agreement  
Author: Nitin H. Vaidya Dhiraj K. Pradhan 
Date: March 1993  1 93-015  
Address: College Station, TX 77843-3112  
Affiliation: Department of Computer Science Texas A&M University  
Pubnum: Technical Report  
Abstract: fl A preliminary version appears in the 13th Intl. Conf. on Distr. Comp. Systems, May 1993, Pittsburgh. 1 This report supercedes report #92-020. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Deo, </author> <title> Graph Theory with Applications to Engineering and Computer Science. </title> <address> Engle-wood Cliffs NJ: </address> <publisher> Prentice-Hall, </publisher> <year> 1984. </year>
Reference-contexts: Node A sends m + u + 1 copies of the message to node B on m + u + 1 disjoint paths. At least m + u + 1 disjoint paths exist between A and B, as the network connectivity is m + u + 1 <ref> [1] </ref>. Node B and other nodes are aware of the paths used by A to send messages to B. Assume that node D receives a message from node C.
Reference: [2] <author> D. Dolev, </author> <title> "The Byzantine generals strike again," </title> <journal> J. </journal> <volume> Algo., </volume> <pages> pp. 14-30, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction Consider a system consisting of a sender that wants to send a value to certain receivers. Byzantine agreement (weak [7] or otherwise [8]) and Crusader agreement <ref> [2] </ref> protocols have been proposed to achieve this in the presence of arbitrary (possibly malicious) failures. The requirement is typically that the fault-free receivers must all agree on the same value [8, 7]. (Dolev [2] analyzes a somewhat weaker form of agreement.) Prior work has shown that such agreements are impossible <p> Byzantine agreement (weak [7] or otherwise [8]) and Crusader agreement <ref> [2] </ref> protocols have been proposed to achieve this in the presence of arbitrary (possibly malicious) failures. The requirement is typically that the fault-free receivers must all agree on the same value [8, 7]. (Dolev [2] analyzes a somewhat weaker form of agreement.) Prior work has shown that such agreements are impossible if a third of the nodes (or more) are faulty. This paper also assumes the arbitrary failure model which is also known as the Byzantine failure model. <p> For the sake of simplicity, this paper draws on the concepts presented in two well-known papers by Lamport et al. [8] and Dolev <ref> [2] </ref>. Section 2 defines the proposed degradable agreement approach. Section 3 motivates the proposed approach and discusses an application. An algorithm for achieving degradable agreement is presented in Section 4. Bounds on the number of nodes and connectivity for the proposed form of agreement are presented in Section 5. <p> Let the connectivity of G be m + u. Proof of Necessity: This proof is similar to a proof in <ref> [2] </ref>. 21 It is clear that connectivity must be at least 2m + 1, otherwise Byzantine agreement is not possible with m faults [4]. Therefore, let 2m &lt; m + u. Assume that m=u-degradable agreement can be achieved in this system. Consider the following scenario. <p> Proof of Sufficiency: For a network of connectivity m + u + 1, algorithm BYZ presented in Section 4 can be used with the modification described here. (Instead of the following procedure, a procedure similar to purifying scheme presented by Dolev <ref> [2] </ref> may also be used.) The original sender and the final destination of each message are included in the message (in sender and destination fields). For every message sent between two nodes during algorithm BYZ, say between nodes A and B, the following procedure is used.
Reference: [3] <author> D. Dolev, J. Y. Halpern, and H. R. </author> <title> Strong, "On the possibility and impossibility of achieving clock synchronization," </title> <journal> J. Computer and System Sciences, </journal> <volume> vol. 32, </volume> <pages> pp. 230-250, </pages> <year> 1986. </year>
Reference-contexts: The following table lists the minimum number of nodes necessary for different values of m and u. m 2 - 7 8 9 10 3 It is known that if a third (or more) of the clocks are faulty, it is not possible to achieve clock synchronization <ref> [3, 6] </ref>. Clock synchronization is necessary to be able to correctly detect the presence or absence of messages. Section 6 discusses this issue. 3 Motivation Consider a fault tolerant system consisting of multiple computation channels. Figure 1 (a) illustrates a system with three channels. <p> In order to ensure that presence or absence of a message can be detected, it is necessary to synchronize the logical clocks of all the fault-free nodes. However, it has been shown that clock synchronization cannot be achieved if a third (or more) clocks are faulty <ref> [3, 6] </ref>. When using m=u-degradable agreement, u may be larger than a third of the number of nodes. Thus, clock synchronization 16 cannot be guaranteed if a node being faulty necessarily implies that its clock is faulty as well.
Reference: [4] <author> M. J. Fischer, N. A. Lynch, and M. Merritt, </author> <title> "Easy impossibility proofs for distributed consensus problems," </title> <booktitle> in Fourth ACM Conf. Distr. Comp., </booktitle> <pages> pp. 59-70, </pages> <year> 1985. </year> <month> 26 </month>
Reference-contexts: In other words, the capability to achieve Byzantine agreement can be traded with the capability to achieve degraded agreement up to a larger number of faults. (Note that the above does not contradict the impossibility result in <ref> [4] </ref>.) It is later proved that to achieve m=u-degradable agreement the system must consist of at least 2m + u + 1 nodes (including the sender), and also that 2m + u + 1 nodes are sufficient. <p> Let the connectivity of G be m + u. Proof of Necessity: This proof is similar to a proof in [2]. 21 It is clear that connectivity must be at least 2m + 1, otherwise Byzantine agreement is not possible with m faults <ref> [4] </ref>. Therefore, let 2m &lt; m + u. Assume that m=u-degradable agreement can be achieved in this system. Consider the following scenario.
Reference: [5] <author> R. E. Harper, J. H. Lala, and J. J. Deyst, </author> <title> "Fault tolerant parallel processor architecture overview," </title> <booktitle> in Digest of papers: The 18 th Int. Symp. Fault-Tolerant Comp., </booktitle> <pages> pp. 252-257, </pages> <year> 1988. </year>
Reference-contexts: Section 6.3 presents another solution that terminates BYZ within a bounded amount of time, up to u faults, using the physical clocks. 6.2 Traditional Clock Synchronization One solution, applicable to systems such as FTMP, NETS [11] and FTP <ref> [5] </ref>, is the use of hardware clock synchronization (as opposed to software algorithms). In typical systems, the complexity and cost of clock hardware is orders of magnitude lower as compared to the processor (or node) complexity. Therefore, the failure rates for clock hardware are likely to be significantly lower.
Reference: [6] <author> C. M. Krishna and I. S. Bhandari, </author> <title> "On graceful degradation of phase locked clocks," </title> <booktitle> in IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 202-211, </pages> <year> 1988. </year>
Reference-contexts: The following table lists the minimum number of nodes necessary for different values of m and u. m 2 - 7 8 9 10 3 It is known that if a third (or more) of the clocks are faulty, it is not possible to achieve clock synchronization <ref> [3, 6] </ref>. Clock synchronization is necessary to be able to correctly detect the presence or absence of messages. Section 6 discusses this issue. 3 Motivation Consider a fault tolerant system consisting of multiple computation channels. Figure 1 (a) illustrates a system with three channels. <p> In order to ensure that presence or absence of a message can be detected, it is necessary to synchronize the logical clocks of all the fault-free nodes. However, it has been shown that clock synchronization cannot be achieved if a third (or more) clocks are faulty <ref> [3, 6] </ref>. When using m=u-degradable agreement, u may be larger than a third of the number of nodes. Thus, clock synchronization 16 cannot be guaranteed if a node being faulty necessarily implies that its clock is faulty as well.
Reference: [7] <author> L. Lamport, </author> <title> "The weak Byzantine generals problem," </title> <journal> J. ACM, </journal> <volume> vol. 30, </volume> <pages> pp. 668-676, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: 1 Introduction Consider a system consisting of a sender that wants to send a value to certain receivers. Byzantine agreement (weak <ref> [7] </ref> or otherwise [8]) and Crusader agreement [2] protocols have been proposed to achieve this in the presence of arbitrary (possibly malicious) failures. <p> Byzantine agreement (weak [7] or otherwise [8]) and Crusader agreement [2] protocols have been proposed to achieve this in the presence of arbitrary (possibly malicious) failures. The requirement is typically that the fault-free receivers must all agree on the same value <ref> [8, 7] </ref>. (Dolev [2] analyzes a somewhat weaker form of agreement.) Prior work has shown that such agreements are impossible if a third of the nodes (or more) are faulty. This paper also assumes the arbitrary failure model which is also known as the Byzantine failure model.
Reference: [8] <author> L. Lamport, R. Shostak, and M. Pease, </author> <title> "The Byzantine generals problem," </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> vol. 4, </volume> <pages> pp. 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: 1 Introduction Consider a system consisting of a sender that wants to send a value to certain receivers. Byzantine agreement (weak [7] or otherwise <ref> [8] </ref>) and Crusader agreement [2] protocols have been proposed to achieve this in the presence of arbitrary (possibly malicious) failures. <p> Byzantine agreement (weak [7] or otherwise [8]) and Crusader agreement [2] protocols have been proposed to achieve this in the presence of arbitrary (possibly malicious) failures. The requirement is typically that the fault-free receivers must all agree on the same value <ref> [8, 7] </ref>. (Dolev [2] analyzes a somewhat weaker form of agreement.) Prior work has shown that such agreements are impossible if a third of the nodes (or more) are faulty. This paper also assumes the arbitrary failure model which is also known as the Byzantine failure model. <p> This paper also assumes the arbitrary failure model which is also known as the Byzantine failure model. We propose an agreement protocol that achieves Lamport's Byzantine agreement 2 <ref> [8] </ref> up to a certain number of failures and a degraded form of agreement with a higher number of faults. <p> Essentially, the degraded form of agreement allows the fault-free receivers to agree on at most two different values one of which is necessarily the default value. 3 This is a degraded form as compared to Byzantine agreement <ref> [8] </ref> which requires all the fault-free receivers to agree on a single value. The proposed approach is called "degradable Byzantine agreement" or simply "degradable agreement" for brevity. The next section presents a definition of degradable agreement. This paper shows that degradable agreement is of interest in practice. <p> For the sake of simplicity, this paper draws on the concepts presented in two well-known papers by Lamport et al. <ref> [8] </ref> and Dolev [2]. Section 2 defines the proposed degradable agreement approach. Section 3 motivates the proposed approach and discusses an application. An algorithm for achieving degradable agreement is presented in Section 4. <p> The fault-free receivers in one class must agree on the default value, and the fault-free receivers in the other class must all agree on an identical value. 2 Conditions D.1 and D.2 are identical to those satisfied by Lamport's Byzantine agree-ment <ref> [8] </ref>. Conditions D.3 and D.4 define degraded agreement and are applied in fault situations with more than m but at most u faults. Thus, when m = u, degradable agreement is equivalent to Lamport's Byzantine agreement. Let N be the number of nodes in the system. <p> The external entity takes a majority vote on the output of the three channels and determines the correct value. It is clear that if the sender is itself faulty, the external entity may not be able to obtain the correct value. Thus, in such a system, Lamport's Byzantine agreement <ref> [8] </ref> ensures the following conditions: (B.1) Given is a system with 3m channels and 1 sender. <p> VOTE (2,4) of values 1, 2, 2, 1 is V d because of the tie. Algorithm BYZ presented below may be viewed as an extension of an algorithm in 6 <ref> [8] </ref>. BYZ assumes that the nodes are fully connected. <p> Whenever a node detects a message to be absent, it assumes that the message contains value V d . Assumptions (a), (b) and (c) above are similar to those made by others <ref> [8] </ref>. The motivation behind assumption (d) will be clear in Section 6. Algorithm BYZ is recursive. The algorithm for m = 0 is omitted here. Algorithm BYZ (m; m) achieves m=u-degradable agreement given at least 2m + u + 1 nodes. <p> For future reference note that, by definition, a system that achieves m=u-degradable agreement also achieves Byzantine agreement <ref> [8] </ref> up to m faults. Theorem 2 Given N nodes, m=u-degradable agreement can be achieved only if N &gt; 2m+u. Proof: The proof is in two parts. Part I proves that 1/2-degradable agreement is impossible with less than 5 nodes. <p> As ff 6= fi 6= V d , this is a contradiction. Thus, 1/2-degradable agreement cannot be achieved with less than 5 nodes. Part II: The proof in Part II is similar to a proof in <ref> [8] </ref>. It is clear that to achieve m=u-degradable agreement at least 3m + 1 nodes are necessary (otherwise Byzantine agreement cannot be achieved for m faults). Therefore, consider a system consisting of N nodes such 15 that N = 3m + where 1 (u m). Thus, N 2m + u. <p> Additionally, the physical clock of a fault-free node will reach t upper within bounded time. Therefore, the above steps result in completion of BYZ within bounded time. 7 Summary m=u-degradable agreement protocol that achieves Lamport's Byzantine agreement <ref> [8] </ref> up to m faults, and a degraded form of agreement with more than m but at most u faults is proposed. Up to m faults, all the fault-free nodes agree on an identical value.
Reference: [9] <author> J.-F. Paris, </author> <title> "Voting with witnesses: A consistency scheme for replicated files," </title> <booktitle> in International Conf. Distributed Computing Systems, </booktitle> <pages> pp. 606-612, </pages> <year> 1986. </year>
Reference-contexts: This idea is analogous to the concept of witnesses proposed for maintaining consistency in replicated file systems <ref> [9] </ref>. 19 clock) and two new nodes (each containing only a clock) 6.3 Loosing Clock Synchronization With More Than m Faults Each node has an associated physical clock and a logical clock. The logical clocks of the fault-free nodes are kept synchronized (whenever possible).
Reference: [10] <author> D. P. Siewiorek and R. S. Swarz, </author> <title> The Theory and Practice of Reliable System Design. </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1982. </year>
Reference-contexts: In general, if more than m faults occur, Byzantine agreement may result in the external entity using an incorrect output, even if the sender is fault-free. However, Byzantine agreement tolerates up to m faults, meaning that forward recovery <ref> [10] </ref> can be performed in the presence of up to m faults. The concept of a default value is pertinent to the discussion below. If the external entity obtains a default value from the multiple channel system, it can take a "default" action which usually results in a safe operation. <p> If the external entity obtains a default value from the multiple channel system, it can take a "default" action which usually results in a safe operation. Thus, degradable agreement improves the safety of the system. Another possibility is to re-do the computation (i.e. perform backward recovery <ref> [10] </ref>) whenever the external entity receives a default value. Backward recovery is effective against transient failures. Degradable agreement, thus, improves the ability to survive more than m faults. Obviously, achieving this requires more resources, but we show that the increase in resource requirements is minimal.
Reference: [11] <author> T. B. Smith III et al., </author> <title> The Fault-Tolerant Multiprocessor Computer. </title> <address> Park Ridge, NJ: </address> <publisher> Noyes Publications, </publisher> <year> 1986. </year>
Reference-contexts: Section 6 discusses this issue. 3 Motivation Consider a fault tolerant system consisting of multiple computation channels. Figure 1 (a) illustrates a system with three channels. Byzantine agreement is useful in such systems to distribute information from a single sender (for example, a sensor) to all the channels <ref> [11] </ref>. The three channels in Figure 1 (a) obtain their input from the sensor and then perform computations on that input. Eventually, the output of the three channels must be sent to an external entity (for example, to a controller). <p> Section 6.3 presents another solution that terminates BYZ within a bounded amount of time, up to u faults, using the physical clocks. 6.2 Traditional Clock Synchronization One solution, applicable to systems such as FTMP, NETS <ref> [11] </ref> and FTP [5], is the use of hardware clock synchronization (as opposed to software algorithms). In typical systems, the complexity and cost of clock hardware is orders of magnitude lower as compared to the processor (or node) complexity.
Reference: [12] <author> T. K. Srikanth and S. Toueg, </author> <title> "Optimal clock synchronization," </title> <journal> J. ACM, </journal> <pages> pp. 626-645, </pages> <month> July </month> <year> 1987. </year> <month> 27 </month>
Reference-contexts: Such a logical clock is also said to be accurate <ref> [12] </ref>. 18 While a solution to the above m=u-Degradable Clock Synchronization problem is sufficient to guarantee termination of BYZ within bounded time, it is not a necessary condition. <p> Consider the following steps to be performed by each fault-free node. We assume that logical clocks are synchronized using any algorithm (e.g. <ref> [12] </ref>) that tolerates m faults in N nodes. * Perform algorithm BYZ. * If physical clock reads t upper , but BYZ has not terminated, then (i) terminate BYZ, and (ii) accept value V d When at most m nodes are faulty, the logical clocks of all fault-free nodes will be
References-found: 12

