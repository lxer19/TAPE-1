URL: http://www.cse.ucsc.edu/research/kestrel/papers/newdiv.ps
Refering-URL: http://www.cse.ucsc.edu/research/kestrel/papers.html
Root-URL: http://www.cse.ucsc.edu
Title: Multiprecision division on small-word parallel processors: Expanded Version  
Author: Eric Rice Richard Hughey 
Date: April 24, 1998  
Abstract: This paper presents a study of software implementation of division on small-word parallel processors containing word-by-word multipliers. It compares several algorithms for a variety of architectures. This is done by first optimizing each algorithm for the small-word environment and then comparing their performance on simple machine models. The results indicate that a modified Newton-Raphson algorithm is optimal over a wide range of conditions. The features of this algorithm include low-precision arithmetic, early introduction of the dividend, and a method by which accuracy can be inexpensively boosted if necessary by using an added term from the extended NR equation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. V. Krishnamurthy, </author> <title> On optimal iterative schemes for high-speed division, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. C-19, </volume> <pages> pp. 227231, </pages> <month> Mar. </month> <year> 1970. </year>
Reference-contexts: Q = n i (m i ). The size of each m i is of particular importance to the efficient implementation of this algorithm. Because each iteration doubles the number of accurate words, little convergence is lost by truncating m i to the size of this expected accuracy <ref> [1] </ref>. Since both n i and d i will be multiplied by this same (truncated) multiplier, the value of n i =d i will be preserved, and considerable multiprecision arithmetic will be avoided.
Reference: [2] <author> S. Waser and M. J. Flynn, </author> <title> Introduction to Arithmetic for Digital System Designers. </title> <address> New York: </address> <publisher> Holt, Rinehart and Winston, </publisher> <year> 1982. </year>
Reference-contexts: There are two parts to this study. In the first, we optimize the most promising division algorithms for the small-word environment, including Byte division <ref> [2] </ref>, the Accurate Quotient algorithm [3], Prescaling and Rounding [5] [6], Newton-Raphson division [7], and Goldschmidt's algorithm [8], and take a brief look at lower-radix algorithms as well. <p> The initial 1-word reciprocal estimate will be represented r. 4.1 Byte Division Byte division <ref> [2] </ref> was designed to achieve high radix while limiting the size of required multiplications. In each iteration, a partial quotient q i is obtained by multiplying a truncated partial remainder by a reciprocal estimate r followed by updating the partial remainder via a multiplication bq i and a subtraction.
Reference: [3] <author> D. Wong and M. Flynn, </author> <title> Fast division using accurate quotient approximations to reduce the number of iterations, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 41, </volume> <pages> pp. 981995, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: There are two parts to this study. In the first, we optimize the most promising division algorithms for the small-word environment, including Byte division [2], the Accurate Quotient algorithm <ref> [3] </ref>, Prescaling and Rounding [5] [6], Newton-Raphson division [7], and Goldschmidt's algorithm [8], and take a brief look at lower-radix algorithms as well. <p> (in which case using Newton-Raphson to pre-calculate a reciprocal estimate of full target accuracy is probably the best choice), this scheme is impractical, and a low-radix algorithm cannot compensate for its slower generation of quotient bits. 4.3 Accurate Quotient Algorithm The high-radix Accurate Quotient algorithm proposed by Wong and Flynn <ref> [3] </ref> differs from Byte division in how the partial remainders are updated and in how these are used to obtain a quotient.
Reference: [4] <author> E. Rice and R. Hughey, </author> <title> Multiprecision division on an 8-bit processor, </title> <booktitle> in Proc. 13th IEEE Symp. Computer Arithmetic (T. </booktitle> <editor> Lang, J.-M. Muller, and N. Takagi, eds.), pp. </editor> <volume> 7481, </volume> <publisher> IEEE CS, </publisher> <month> July </month> <year> 1997. </year>
Reference-contexts: Several studies have addressed the potential in certain algorithms for reduced operand size [1][2][3], but while useful, these are again targeted at hardware rather than software implementation. This paper generalizes results found for the UCSC Kestrel 8-bit parallel processor <ref> [4] </ref>, examining several algorithms for software implementation on small-word parallel processors. In addition, the results may be useful when large-word processors need very accurate results, such as when manipulating 128-bit floating point numbers in a 64-bit processor. There are two parts to this study.
Reference: [5] <author> A. Svoboda, </author> <title> An algorithm for division, </title> <booktitle> in Proc. 9th Symp. Inform. Processing Machines, </booktitle> <pages> pp. 2534, </pages> <year> 1963. </year>
Reference-contexts: There are two parts to this study. In the first, we optimize the most promising division algorithms for the small-word environment, including Byte division [2], the Accurate Quotient algorithm [3], Prescaling and Rounding <ref> [5] </ref> [6], Newton-Raphson division [7], and Goldschmidt's algorithm [8], and take a brief look at lower-radix algorithms as well. Finding opportunities to reduce operand size and comparing the costs of different implementations when significant modifications are required are the most important parts of the process of optimizing these algorithms. <p> As with Byte division, we examined the possibility of increasing the radix of this algorithm by refining r to 2-word accuracy at the beginning. 8 4.4 Prescaling and Rounding Originally proposed by Svoboda <ref> [5] </ref> and recently refined for high radix implementation by Ercegovac, Lang, and Montuschi [6], the Prescaling and Rounding algorithm multiplies both the divisor and the dividend by a reciprocal estimate in the setup. In this way partial quotients are obtained directly during the iterations: * Setup: Obtain reciprocal estimate r.
Reference: [6] <author> M. D. Ercegovac, T. Lang, and P. Montuschi, </author> <title> Very high radix division with selection by rounding and prescaling, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 43, no. 8, </volume> <pages> pp. 909918, </pages> <year> 1994. </year>
Reference-contexts: There are two parts to this study. In the first, we optimize the most promising division algorithms for the small-word environment, including Byte division [2], the Accurate Quotient algorithm [3], Prescaling and Rounding [5] <ref> [6] </ref>, Newton-Raphson division [7], and Goldschmidt's algorithm [8], and take a brief look at lower-radix algorithms as well. Finding opportunities to reduce operand size and comparing the costs of different implementations when significant modifications are required are the most important parts of the process of optimizing these algorithms. <p> As with Byte division, we examined the possibility of increasing the radix of this algorithm by refining r to 2-word accuracy at the beginning. 8 4.4 Prescaling and Rounding Originally proposed by Svoboda [5] and recently refined for high radix implementation by Ercegovac, Lang, and Montuschi <ref> [6] </ref>, the Prescaling and Rounding algorithm multiplies both the divisor and the dividend by a reciprocal estimate in the setup. In this way partial quotients are obtained directly during the iterations: * Setup: Obtain reciprocal estimate r. Set initial partial remainder P 0 = ar.
Reference: [7] <author> M. J. Flynn, </author> <title> On division by functional iteration, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. C-19, </volume> <pages> pp. 702706, </pages> <month> Aug. </month> <year> 1970. </year>
Reference-contexts: There are two parts to this study. In the first, we optimize the most promising division algorithms for the small-word environment, including Byte division [2], the Accurate Quotient algorithm [3], Prescaling and Rounding [5] [6], Newton-Raphson division <ref> [7] </ref>, and Goldschmidt's algorithm [8], and take a brief look at lower-radix algorithms as well. Finding opportunities to reduce operand size and comparing the costs of different implementations when significant modifications are required are the most important parts of the process of optimizing these algorithms. <p> rather than 4 or 8 fractional bytes in P algorithms are otherwise identical in size and costs of operations. 4.5 Newton-Raphson Division In its most basic form, the well-known Newton-Raphson method of division refines a reciprocal estimate of the divisor and then multiplies by the dividend to obtain a quotient <ref> [7] </ref>: * Setup: Obtain reciprocal estimate r 0 . * Iterate on: r i+1 = r i (2 br i ). Q = a (r final ). The iteration produces a quadratically converging reciprocal estimate that requires 2 multiplications and a subtraction, all of which must be performed consecutively.
Reference: [8] <author> R. E. Goldschmidt, </author> <title> Applications of division by convergence, </title> <type> Master's thesis, </type> <institution> MIT, </institution> <address> Cambridge, MA, </address> <year> 1964. </year>
Reference-contexts: There are two parts to this study. In the first, we optimize the most promising division algorithms for the small-word environment, including Byte division [2], the Accurate Quotient algorithm [3], Prescaling and Rounding [5] [6], Newton-Raphson division [7], and Goldschmidt's algorithm <ref> [8] </ref>, and take a brief look at lower-radix algorithms as well. Finding opportunities to reduce operand size and comparing the costs of different implementations when significant modifications are required are the most important parts of the process of optimizing these algorithms. <p> Of all methods of implementing division in small-word processors, we found Newton-Raphson to be the most efficient when certain modifications are made. These will be developed in section 5. 9 4.6 Goldschmidt's Algorithm Goldschmidt's algorithm <ref> [8] </ref>, another popular method of implementing division in hardware, obtains a quo tient by choosing a series of multipliers m 0 ; m 1 ; : : : to transform a=b to ~ Q=1: a = d 0 n 0 fi m 0 n 1 fi m 1 Q : By
Reference: [9] <author> D. M. Dahle, J. D. Hirschberg, kevin Karplus, H. Keller, E. Rice, D. Speck, D. H. Williams, and R. Hughey, Kestrel: </author> <title> Design of an 8-bit SIMD parallel processor, </title> <booktitle> in Proc. 17th Conf. on Advanced Research in VLSI, </booktitle> <publisher> IEEE CS, </publisher> <month> Sept. </month> <year> 1997. </year>
Reference-contexts: The first is word size: We include both 8-bit and 16-bit processors, several examples of which exist in the literature (for example, <ref> [9] </ref> [10][11][12]). The second is the configuration of the processor's multiplier, where we consider both multiply-accumulate (mult-acc) and multiply-accumulate-accumulate (mult-acc-acc) capabilities. In each case, it is assumed that a multiply can accumulate the high-order word of a previous multiplication from a designated register (MHI).
Reference: [10] <author> C. Ebeling, D. C. Conquist, and P. Franklin, </author> <title> RaPiD reconfigurable pipelined datapath, </title> <booktitle> in 6th Int. Wkshp. Field-Programmable Logic and Applications, </booktitle> <address> (New York), </address> <pages> pp. 126135, </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference: [11] <author> D. W. Hammerstrom and D. P. Lulich, </author> <title> Image processing using one-dimensional processor arrays, </title> <journal> Proc. IEEE, </journal> <volume> vol. 84, no. 7, </volume> <pages> pp. 10051018, </pages> <year> 1996. </year>
Reference: [12] <editor> H. Cat et al., SIMPil: </editor> <title> An OE integrated SIMD architecture for focal plan processing applications, </title> <booktitle> in Proc. Third Int. Conf. Massively Parallel Processing using Optical Interconnections (A. </booktitle> <editor> Gottlieb et al., eds.), pp. </editor> <volume> 4452, </volume> <publisher> IEEE CS, </publisher> <month> Oct. </month> <year> 1996. </year>
Reference: [13] <author> E. Rice and R. Hughey, </author> <title> Multiprecision division on small-word parallel processors: </title> <type> Expanded version, tech. rep., </type> <institution> University California, </institution> <address> Santa Cruz, CA, </address> <month> Apr. </month> <year> 1998. </year> <month> 18 </month>
Reference-contexts: They also allow efficient rounding to IEEE 754 standards by employing a highly abbreviated multi-precision multiplication where only a single bit needs to be examined to determine correct rounding (see technical report for details <ref> [13] </ref>). Second, because all algorithms evaluated employ a reciprocal estimate, we fixed this as well. Here we chose the best-possible one-word estimate, which allowed all algorithms to achieve the target accuracies in a minimum number of iterations. <p> Refined indicates NR refinement of the initial 1 word estimate to ~2-word accuracy before applying the algorithm. The numbers in parentheses indicate instruction counts when two maskable processors are used. Implementation details of all algorithms can be found in the associated technical report <ref> [13] </ref>. 15 Table II: Comparison of division algorithms on a 16-bit SIMD Processor. <p> We did not evaluate other division algorithms using this model since none are able to take significant advantage of this feature. When alternate processors are independently programmable, the modified NR algorithm still outperforms all other algorithms <ref> [13] </ref>. Instruction counts for the modified NR algorithm are given in Table III. It is likely that the modified NR would also perform well under a variety of circumstances other than those considered here.
Reference: [14] <author> S. F. Oberman and M. J. Flynn, </author> <title> Division algorithms and implementations, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 46, </volume> <pages> pp. 833854, </pages> <month> Aug. </month> <year> 1997. </year>
Reference-contexts: In this case, which is common in the second and subsequent iterations of algorithms, we can save on both the multiplication that produces the term (s) to be subtracted, and on the subtraction itself. 4 Overview of Division Algorithms While numerous strategies have been devised for hardware division <ref> [14] </ref>, many do not translate well to software. Algorithms such as SRT [15][16][17] and non-restoring division, which rely on speedy iterations to compensate for their low radix, can be seen to be inappropriate by examining the minimum cost per iteration.
Reference: [15] <author> C. V. </author> <title> Freiman, Statistical analysis of certain binary division algorithms, </title> <journal> IRE Trans. Electronic Computers, </journal> <volume> vol. 7, </volume> <pages> pp. 91103, </pages> <month> Sept. </month> <year> 1958. </year>
Reference: [16] <author> J. E. Robertson, </author> <title> A new class of digital division methods, </title> <journal> IRE Trans. Electronic Computers, </journal> <volume> vol. 7, </volume> <pages> pp. 218222, </pages> <month> Sept. </month> <year> 1958. </year>
Reference: [17] <author> K. D. Tocher, </author> <title> Techniques of multiplication and division for automatic binary computers, </title> <journal> Quarterly J. Mech. Appl. Math., </journal> <volume> vol. 11, </volume> <pages> pp. 364384, </pages> <month> 364384 </month> <year> 1958. </year>
Reference: [18] <author> D. Ferrari, </author> <title> A division method using a parallel multiplier, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. EC-16, </volume> <pages> pp. 224226, </pages> <month> Apr. </month> <year> 1967. </year> <title> 19 9 Affiliation of Authors The authors are with the Department of Computer Engineering, </title> <institution> Jack Baskin School of Engineering, University of California, </institution> <address> Santa Cruz, CA 95064 e-mail: felrice, rphg@cse.ucsc.edu </address>
Reference-contexts: that the Newton Raphson equation can be extended to the more general equation: r i+1 = r i 1 + (1 br i ) + (1 br i ) 2 + : : : + (1 br i ) n ; (2) where equation 1 corresponds to n = 1 <ref> [18] </ref>. Each inner term of equation 2 can be calculated from the previous one with a single multiprecision multiplication.
References-found: 18

