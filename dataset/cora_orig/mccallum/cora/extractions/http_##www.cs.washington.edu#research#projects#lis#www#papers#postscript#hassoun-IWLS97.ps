URL: http://www.cs.washington.edu/research/projects/lis/www/papers/postscript/hassoun-IWLS97.ps
Refering-URL: http://www.cs.washington.edu/research/projects/lis/www/archretiming/
Root-URL: http://www.cs.washington.edu
Email: fsoha,ebelingg@cs.washington.edu  
Title: Sequential Circuit Optimization Using Precomputation  
Author: Soha Hassoun and Carl Ebeling 
Web: http://www.cs.washington.edu/research/lis/www/archretiming  
Address: Seattle, WA 98195-2350  
Affiliation: Department of Computer Science and Engineering University of Washington,  
Date: May, 1997  
Note: Extended Abstract for IWLS97,  
Abstract: Summary. Precomputation is a well-known, practical technique that is often used by designers to speed up circuits. We propose in this paper an automated way of using precomputation to improve the performance of sequential logic circuits. Our approach is based on precomputation-based architectural retim-ing, a technique for optimizing latency-constrained paths [8]. We describe the basic idea behind precom-putation and propose an implementation algorithm. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Alidina, J. Monteiro, S. Devadas, A. Ghosh, and M. Pa-paefthymiou. </author> <title> "Precomputation-Based Sequential Logic Optimization for Low Power". </title> <booktitle> In Proc. of the 1994 IEEE International Conf on CAD, </booktitle> <pages> pages 74 -81, </pages> <year> 1994. </year>
Reference-contexts: In this paper we focus on how precomputation-based architectural retiming can improve the performance of sequential circuits. Precomputation is a well-known, practical technique that is often used by designers to speed up circuits. Precomputation was also used by Alidina et al. to restructure circuits to consume less power <ref> [1] </ref>. A special case of precomputation, known as look-ahead, has been used to transform sequential recursive algorithms to equivalent concurrent ones which then can be realized using pipelin-ing [9, 13]. <p> to the edges along the critical path. * If the critical path is not on a cycle in the modified circuit used to find the critical cycle, then there is no Procedure 1: Build Precomputation Logic (edge e c ) 1 for each vertex u in V [G] 2 Color <ref> [u, 1] </ref> := white 3 Color [u, 2] := white 4 Create new primary output vertex vpo in V [P G] 5 return Build Precomputation Logic Visit (source (e c ), vpo, 1) Procedure 2: Build Precomputation Logic Visit (v, target, stage) 1 Color [v, stage] := black 2 if v
Reference: [2] <author> S. Bommu. </author> <title> Sequential Logic Optimization with Implicit Re-timing. </title> <type> Master's thesis, </type> <institution> University of Massachusetts, </institution> <year> 1996. </year>
Reference-contexts: Implicit retiming, which is a limited form of the precomputation proposed here, allows the precomputation of a kernel if its support variables are all registers <ref> [2] </ref>. We begin this paper by introducing the circuit model. We then derive the precomputation function from the definition of the negative register. Next, we present an algorithm for precomputation and provide some analysis of the precomputation transformations. <p> path. * If the critical path is not on a cycle in the modified circuit used to find the critical cycle, then there is no Procedure 1: Build Precomputation Logic (edge e c ) 1 for each vertex u in V [G] 2 Color [u, 1] := white 3 Color <ref> [u, 2] </ref> := white 4 Create new primary output vertex vpo in V [P G] 5 return Build Precomputation Logic Visit (source (e c ), vpo, 1) Procedure 2: Build Precomputation Logic Visit (v, target, stage) 1 Color [v, stage] := black 2 if v is a primary input 3 if <p> primary input vertex vpi in V [P G] 6 Map := Map [ ((v, stage) ) vpi) 7 Create new edge in E [P G] from vpi to target 8 if v is a register 9 if (stage = 1), then for all in-edges e of v 10 if (Color <ref> [source (e), 2] </ref> = white), then 11 Build Precomputation Logic Visit (source (e), target, stage+1) 12 else 13 Create new edge in E [P G] from Map (source (e), 2) to target 14 else, (v is a register and stage equals 2) 15 Create new primary input vertex vpi in V
Reference: [3] <author> S. Burns. </author> <title> Performance Analysis and Optimization of Asynchronous Circuits. </title> <type> PhD thesis, </type> <institution> California Institute of Technology, </institution> <year> 1991. </year> <month> Caltech-CS-TR-91-01. </month>
Reference-contexts: Efficient algorithms can be used to find such a cycle <ref> [3, 7] </ref>. To determine where to apply architectural retiming, we must examine the relationship between the critical cycle and the critical path (s) in the circuit.
Reference: [4] <author> G. De Micheli. </author> <title> "Synchronous Logic Synthesis: Algorithms for Cycle-Time Minimization". </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 10(1) </volume> <pages> 63-73, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: The problem is that each combinational block is optimized independently of the others. Many sequential optimization techniques attempt to solve this problem by exposing combinational logic from two or more different blocks for resynthesis. De Micheli applies local algebraic transformations across register boundaries <ref> [4] </ref>. Peripheral retiming [11] attempts to expose the whole circuit for combinational resynthesis. It temporarily pushes all registers to the periphery of the circuit while placing negative weights, which indicate borrowing registers from the circuit's environment, on peripheral edges. After combinational optimizations the circuit is then retimed.
Reference: [5] <author> S. Dey, F. Brglez, and G. Kedem. </author> <title> "Partitioning Sequential Circuits for Logic Optimization.". </title> <booktitle> In IEEE International Conference on Computer Design, </booktitle> <pages> pages 70-6, </pages> <year> 1991. </year>
Reference-contexts: After combinational optimizations the circuit is then retimed. Peripheral retiming is applicable only if all paths in the circuit between each primary input/primary output pair have an equal number of registers. Dey et al. identify subcircuits with equal-weight reconvergent paths (petals) to which peripheral retiming can be applied <ref> [5] </ref>. Pipelining is another sequential optimization technique that can be combined with retiming, and followed by any of the above sequential optimization techniques. However, pipelining is not always possible because of latency constraints. Many latency constraints exist in any given circuit.
Reference: [6] <editor> C. Ebeling and B. Lockyear. </editor> <booktitle> "On the Performance of Level-Clocked Circuits". In Advanced Research in VLSI, </booktitle> <pages> pages 242-356, </pages> <year> 1995. </year>
Reference-contexts: It has been established that the ratio of the sum of the delay along the critical cycle to the number of registers is the lower bound on the clock period that can obtained even when using level-sensitive latches and/or using clock skewing techniques <ref> [12, 6] </ref>. Efficient algorithms can be used to find such a cycle [3, 7]. To determine where to apply architectural retiming, we must examine the relationship between the critical cycle and the critical path (s) in the circuit.
Reference: [7] <author> M. Hartmann and J. Orlin. </author> <title> "Finding Minimum Cost to Time Ratio Cycles With Small Integral Transit Times". </title> <type> Technical Report UNC/OR/TR/91-19, </type> <institution> University of North Carolina, Chapel Hill, </institution> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: Efficient algorithms can be used to find such a cycle <ref> [3, 7] </ref>. To determine where to apply architectural retiming, we must examine the relationship between the critical cycle and the critical path (s) in the circuit.
Reference: [8] <author> S. Hassoun and C. Ebeling. </author> <title> "Architectural Retiming: Pipelining Latency-Constrained Circuits". </title> <booktitle> In Proc. of 33th ACM-IEEE Design Automation Conf., </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: The latency constraints may be explicit, imposed by performance requirements that prevent increasing the latency between two points in the circuit. The latency constraints may also be implicit, due to cyclic dependencies in the circuit. Architectural retiming is a technique for optimizing synchronous circuits <ref> [8] </ref>. To improve a circuit's performance, it resynthesizes the latency-constrained path that limits the clock period at which the circuit can run. Architectural re-timing is based on pipelining the latency-constrained path using a pair of registers: a pipeline register and a negative register.
Reference: [9] <author> P. Kogge. </author> <title> The Architecture of Pipelined Computers. </title> <publisher> McGraw-Hill, </publisher> <year> 1981. </year>
Reference-contexts: Precomputation was also used by Alidina et al. to restructure circuits to consume less power [1]. A special case of precomputation, known as look-ahead, has been used to transform sequential recursive algorithms to equivalent concurrent ones which then can be realized using pipelin-ing <ref> [9, 13] </ref>. Implicit retiming, which is a limited form of the precomputation proposed here, allows the precomputation of a kernel if its support variables are all registers [2]. We begin this paper by introducing the circuit model. We then derive the precomputation function from the definition of the negative register.
Reference: [10] <author> C. E. Leiserson, F. Rose, and J. B. Saxe. </author> <title> "Optimizing Synchronous Circuitry by Retiming". </title> <booktitle> In Proc. of the 3rd Caltech Conference on VLSI, </booktitle> <month> Mar. </month> <year> 1983. </year>
Reference-contexts: 1 Introduction One way to improve the performance of a sequential circuit is the application of combinational logic optimizations to each combinational block in the circuit followed by retim-ing <ref> [10] </ref> to optimally place the registers. The problem is that each combinational block is optimized independently of the others. Many sequential optimization techniques attempt to solve this problem by exposing combinational logic from two or more different blocks for resynthesis. De Micheli applies local algebraic transformations across register boundaries [4].
Reference: [11] <author> S. Malik, E. M. Sentovich, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> "Retiming and Resynthesis: Optimizing Sequential Networks with Combinational Techniques". </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 10(1) </volume> <pages> 74-84, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: The problem is that each combinational block is optimized independently of the others. Many sequential optimization techniques attempt to solve this problem by exposing combinational logic from two or more different blocks for resynthesis. De Micheli applies local algebraic transformations across register boundaries [4]. Peripheral retiming <ref> [11] </ref> attempts to expose the whole circuit for combinational resynthesis. It temporarily pushes all registers to the periphery of the circuit while placing negative weights, which indicate borrowing registers from the circuit's environment, on peripheral edges. After combinational optimizations the circuit is then retimed.
Reference: [12] <author> M. C. Papaefthymiou and K. H. Randall. </author> <title> "Edge-Triggering vs. Two-Phase Level-Clocking". </title> <booktitle> In Research on Integrated Systems: Proceedings of the 1993 Symposium, </booktitle> <pages> pages 201-218, </pages> <year> 1993. </year>
Reference-contexts: It has been established that the ratio of the sum of the delay along the critical cycle to the number of registers is the lower bound on the clock period that can obtained even when using level-sensitive latches and/or using clock skewing techniques <ref> [12, 6] </ref>. Efficient algorithms can be used to find such a cycle [3, 7]. To determine where to apply architectural retiming, we must examine the relationship between the critical cycle and the critical path (s) in the circuit.
Reference: [13] <author> K. Parhi. </author> <title> "Look-ahead in Dynamic Programming and Quan-tizer Loops". </title> <booktitle> In IEEE International Symposium on Circuits and Systems, </booktitle> <pages> pages 1382-7, </pages> <year> 1989. </year>
Reference-contexts: Precomputation was also used by Alidina et al. to restructure circuits to consume less power [1]. A special case of precomputation, known as look-ahead, has been used to transform sequential recursive algorithms to equivalent concurrent ones which then can be realized using pipelin-ing <ref> [9, 13] </ref>. Implicit retiming, which is a limited form of the precomputation proposed here, allows the precomputation of a kernel if its support variables are all registers [2]. We begin this paper by introducing the circuit model. We then derive the precomputation function from the definition of the negative register.
References-found: 13

