URL: ftp://ftp.cs.brown.edu/pub/techreports/98/cs98-03.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-98-03.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> L. Michel, P. Van Hentenryck. Localizer: </author> <title> A Modeling Language for Local Search. </title> <booktitle> In Second International Conference on Principles and Practice of Constraint Programming (CP'97), </booktitle> <address> Linz, Austria, </address> <month> October </month> <year> 1997. </year> <note> (Extended Version invited to the special of Constraints on CP'97). </note>
Reference-contexts: 1 Introduction Localizer <ref> [1] </ref> is a domain-specific language for the implementation of local search algorithms, combining aspects of declarative and imperative programming, since both are important in local search algorithms. Localizer offers support for defining traditional concepts like neighborhoods, acceptance criteria, and restarting states. <p> It starts with the basic model and then discusses some improvements. The model contains several novelties, and requires new implementation techniques, compared to the applications discussed in <ref> [1] </ref>. 4.1 The Basic Model 4 Optimize Constant: nbJ : int = ...; N : int := nbJ fi nbM ; d : array [0::N + 1] of int = . . . ; m : arrray [1::N ] of int = . . . ; sj : array [i in <p> The goal of this section is to provide evidence that Localizer is a viable tool to implement local search algorithms. Similar evidence was provided in <ref> [1] </ref> for satisfiability, graph-coloring, and graph-partitioning. We do not aim at comparing local and global search algorithms (which have different functionalities). Similarly, we did not try to produce the fastest implementation possible but rather to demonstrate the potential of Localizer. <p> But a rough comparison suggests that the difference between Localizer and a specialized implementation is once again of the order of a machine generation, confirming the results in <ref> [1] </ref>. 8 Conclusion This paper explored the application of Localizer to job-shop scheduling. It presented two models for this application: a model based on traditional data structures and a model based on graph-theoretic concepts.
Reference: [2] <author> Marco Trubian Mauro Dell'Amico. </author> <title> Applying tabu search to the job-shop scheduling problem. </title> <journal> Annals of Operations Research, </journal> <volume> 41 </volume> <pages> 231-252, </pages> <year> 1993. </year> <month> 15 </month>
Reference-contexts: This local search algorithm is the essence of the procedure proposed in <ref> [2] </ref>. Other neighborhoods and strategies have been proposed and it is not difficult to generalize the results presented here to these other algorithms. The Neighborhood As mentioned, a solution to the job-shop scheduling problem mostly consists of ordering the tasks of the various machines. <p> The procedure maintains a frontier which consists of the first unscheduled tasks of each job and it selects the task with the shortest duration first. More advanced procedures such as Bidir proposed by Dell'Amico et al. in <ref> [2] </ref> can be implemented without difficulty, since Localizer includes a complete programming language. 5 A Higher-Level Localizer Model The previous section presented a model for job-shop scheduling using only simple data structures such as sets and arrays. <p> We do not aim at comparing local and global search algorithms (which have different functionalities). Similarly, we did not try to produce the fastest implementation possible but rather to demonstrate the potential of Localizer. The experiments were based on the parameters reported in <ref> [2] </ref>: the maximal number of searches (maxSearches) is 1, the maximal number of iterations for the inner loop (maxTrials) is 12000, the tabu list has a varying length constrained in between 5 and 30 and its length is updated according to the rule of [2]. Contrary to [2], our model does <p> based on the parameters reported in <ref> [2] </ref>: the maximal number of searches (maxSearches) is 1, the maximal number of iterations for the inner loop (maxTrials) is 12000, the tabu list has a varying length constrained in between 5 and 30 and its length is updated according to the rule of [2]. Contrary to [2], our model does not use a restarting strategy. Table 1 reports the preliminary results on a Sun Sparc Ultra 1 for the graph model (the first model is about 15% slower in the average). <p> parameters reported in <ref> [2] </ref>: the maximal number of searches (maxSearches) is 1, the maximal number of iterations for the inner loop (maxTrials) is 12000, the tabu list has a varying length constrained in between 5 and 30 and its length is updated according to the rule of [2]. Contrary to [2], our model does not use a restarting strategy. Table 1 reports the preliminary results on a Sun Sparc Ultra 1 for the graph model (the first model is about 15% slower in the average). <p> Loc is the CPU time in seconds to run until completion, while LO is the time to run to completion or to a known optimal solution (this is the time measure used in <ref> [2] </ref>). Column Avg. sol. gives the average makespan, while column %O gives the average distance to the optimum in percent. Results in italics indicates that the optimal solution is not known (as of 1993). The results indicate that the Localizer model model obtains near-optimal solutions quickly. <p> In fact, the model finds optimal solutions for 14 benchmarks. The table indicates that these results are also obtained quickly: from 20 seconds to 90 seconds. These results cannot be really compared with the results of <ref> [2] </ref>, since his neighborhood is an extension of the neighborhood presented here and the results are not directly comparable.
References-found: 2

