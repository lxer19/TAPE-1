URL: ftp://ftp.cs.umass.edu/pub/ccs/threads/kernel-threads-hard-environments.ps
Refering-URL: http://www-ccs.cs.umass.edu/spring/internal/spring_kernel_docs.html
Root-URL: 
Email: Email: humphrey@cs.umass.edu  
Title: Kernel-Level Threads for Dynamic, Hard Real-Time Environments  
Author: Marty Humphrey, Gary Wallace and John A. Stankovic 
Address: Amherst, MA 01003  
Affiliation: Department of Computer Science University of Massachusetts,  
Abstract: The design of a kernel-level thread package for dynamic, hard real-time environments is presented. A highly integrated design is used to ensure predictability. A system description language and real-time programming language are used to specify key properties of threads and thread groups. For a thread, this includes whether or not the thread spawns other threads at run-time, the type of performance guarantee the thread requires, how the thread interacts with other threads, and what processors the thread may execute on. A predictable kernel uses this information along with on-line dynamic guarantees to ensure predictable execution of threads. The first phase of the thread package has been implemented and performance measurements have indicated a 66% improvement in context switching costs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> IEEE, </author> <title> Realtime Extension for Portable Operating Systems, </title> <month> Feb. </month> <year> 1989, </year> <month> P1003.4/Draft6. </month>
Reference-contexts: From an operating-systems perspective, threads offer various performance benefits, because switching from one thread to another thread in a single address space does not require remapping the address space. Some attempts at developing real-time threads are based on modifications to non-real-time kernels that support threads. POSIX.4 <ref> [1] </ref> is a real-time extension fl This work is funded by the National Science Foundation under grant IRI-9208920. to POSIX; definitions within POSIX.4 are directly aimed at augmenting the threads definition (PThreads [2]) with real-time properties. The threads of Real-Time Mach [3] are based on the Mach kernel [4]. <p> The latter requires defining an interface between scheduling at the threads level and scheduling at the kernel/processor level. POSIX.4 <ref> [1] </ref> modifies PThreads for real-time computing. It specifies a priority scheduling mechanism with FIFO, RR and OTHER (implementation-defined) policies. The PThreads interface is consistent with this and has an option to indicate that these scheduling policies are implemented.
Reference: [2] <author> IEEE, </author> <title> Threads Extensions for Portable Operating Systems, </title> <month> Apr. </month> <year> 1993, </year> <month> P1003.4a/Draft7. </month>
Reference-contexts: Some attempts at developing real-time threads are based on modifications to non-real-time kernels that support threads. POSIX.4 [1] is a real-time extension fl This work is funded by the National Science Foundation under grant IRI-9208920. to POSIX; definitions within POSIX.4 are directly aimed at augmenting the threads definition (PThreads <ref> [2] </ref>) with real-time properties. The threads of Real-Time Mach [3] are based on the Mach kernel [4]. <p> Also, because scheduling is reservation-based, the problem of priority inversion does not have to be addressed, as is necessary in priority-based scheduling approaches to real-time threads <ref> [2, 3] </ref>. 5.2 Parallel Execution of Threads The context of a thread resides in physical memory on the MVME136A board of the processor executing the thread. <p> The comparison is primarily on the basis of predictability and flexibility. 6.1 PThreads POSIX 1003.4a (PThreads) <ref> [2] </ref> supplements the base POSIX standards with interfaces and functionality to support multiple flows of control within a process. The PThreads document is purely a standard and any compliant implementation of PThreads is not constrained in any way beyond providing the appropriate interfaces.
Reference: [3] <author> H. Tokuda, T. Nakajima, and P. Rao, </author> <title> "Real-time Mach: Towards predictable real-time systems," </title> <booktitle> in Proceedings of the USENIX 1990 Mach Workshop, </booktitle> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: POSIX.4 [1] is a real-time extension fl This work is funded by the National Science Foundation under grant IRI-9208920. to POSIX; definitions within POSIX.4 are directly aimed at augmenting the threads definition (PThreads [2]) with real-time properties. The threads of Real-Time Mach <ref> [3] </ref> are based on the Mach kernel [4]. The problem with founding a real-time threads package on the existing threads of a non-real-time kernel is that a key property of the real-time thread, predictability, can be difficult to achieve as the thread interacts with the non-real-time components in the kernel. <p> This memory management model is unacceptable for a real-time thread because accesses can take an unpredictable amount of time. Another feature of Mach that is not appropriate for a real-time thread is FIFO ordering in system-level queues, which can lead to unbounded delays <ref> [3] </ref>. Overall, the key difficulty in this approach for a real-time threads package is determining the subtle interactions of the real-time paradigm with the underlying time-sharing paradigm. An alternative approach taken in this work is to base a real-time threads package on a predictable real-time kernel and associated development tools. <p> Also, because scheduling is reservation-based, the problem of priority inversion does not have to be addressed, as is necessary in priority-based scheduling approaches to real-time threads <ref> [2, 3] </ref>. 5.2 Parallel Execution of Threads The context of a thread resides in physical memory on the MVME136A board of the processor executing the thread. <p> threads package presented in this research, PThreads does not incorporate schedu-lability analysis, there is no notion of guarantee, and it is not clear how the normal timesharing parts of POSIX will impact the real-time performance. 6.2 Real-Time Mach Threads To develop a real-time program that uses threads in Real-Time Mach <ref> [3] </ref>, the user is expected to perform schedulability analysis off-line. To perform a schedula-bility analysis, the user analyzes the set of tasks (each of which is a separate address space) and the threads according to a scheduling policy.
Reference: [4] <author> R. Rashid, R. Baron, A. Forin, D. Golub, M. Jones, D. Julin, D. Orr, and R. Sanzi, </author> <title> "Mach: A foundation for open systems," </title> <booktitle> in Proceedings of the Second Workshop on Workstation Operating Systems (WWOS2), </booktitle> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: POSIX.4 [1] is a real-time extension fl This work is funded by the National Science Foundation under grant IRI-9208920. to POSIX; definitions within POSIX.4 are directly aimed at augmenting the threads definition (PThreads [2]) with real-time properties. The threads of Real-Time Mach [3] are based on the Mach kernel <ref> [4] </ref>. The problem with founding a real-time threads package on the existing threads of a non-real-time kernel is that a key property of the real-time thread, predictability, can be difficult to achieve as the thread interacts with the non-real-time components in the kernel.
Reference: [5] <author> J.A. Stankovic and K. Ramamritham, </author> <title> "The Spring kernel: A new paradigm for real-time systems," </title> <journal> IEEE Software, </journal> <volume> vol. 8, no. 3, </volume> <pages> pp. 62-72, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: An alternative approach taken in this work is to base a real-time threads package on a predictable real-time kernel and associated development tools. The goal of this work is to create a real-time threads package for the Spring real-time operating system <ref> [5] </ref>. An integrated real-time threads solution has been developed that achieves predictability by involving an offline specification language, a real-time programming language, kernel boot time options, and the run-time kernel. This package co-exists with a guarantee-based, on-line dynamic scheduler.
Reference: [6] <author> D. Niehaus, </author> <title> Program Representation and Execution in Real-Time Multiprocessor Systems, </title> <type> PhD thesis, </type> <institution> University of Massachusetts, </institution> <address> Amherst MA, </address> <year> 1994. </year>
Reference-contexts: Tasks are used by the Spring scheduler, which plans the use of resources (including the CPU) in a reservation-based scheme based on the worst-case execution time (WCET) of each task. The WCET of a task is also computed at compile time <ref> [6] </ref>. Predictability in the operating system is a direct consequence of realistic estimate of the WCET, predictable switching between tasks, and predictable duration of scheduling. <p> First, the description of the thread (and thread group) entities with respect to timing properties, layout requirements, etc., are specified in constructs of the System Description Language (SDL) [8]. Next, Spring-C <ref> [6] </ref> is used to code the application threads. 3.1 SDL Threads and thread groups are defined in the System Description Language, SDL. SDL statements are used to record real-time and non-real-time properties for objects in the real-time system. <p> The main difference between the two context changes is that the change from a user process to the kernel process (dispatcher) does not require loading a user map into the MMU. Spring establishes predictable memory operations by two procedures <ref> [6] </ref>. First, page faults in the MMU are avoided by preallocating, at process creation time, a physical page for every used page in a program's address space, and loading that page in memory.
Reference: [7] <author> M. Humphrey, </author> <title> "Using a reflective real-time operating system to implement a just-in-time scheduling policy for a flexible manufacturing workcell," </title> <booktitle> Working notes., </booktitle> <year> 1995. </year>
Reference-contexts: One board is referred to as the System Processor (SP), and the other three boards are Application Processors (APs), AP 1 , AP 2 , and AP 3 . The SP is devoted to system activities such as scheduling and interacting with outside entities (such as a High-Level Scheduler <ref> [7] </ref>), while the APs execute the schedule created by the SP. The physical memory resident on each MVE136A board is available for local reference by the processor on the MVE136A board, and can be accessed by another processor through the VME bus. <p> The return value is sched yes, or sched no. Extensions are being considered that attempt to more fully explain why the thread group was not schedulable <ref> [7] </ref>. This is discussed in more detail in Section 5.3. The sync thg sched procedure causes the direct interaction of a thread with the scheduler. The sched-uler bases its actions on the guarantee requirement of each thread in the thread group that is attempting to be spawned.
Reference: [8] <author> D. Niehaus, J. Stankovic, and K. Ramaritham, </author> <title> "A real-time system description language," </title> <booktitle> in Proceedings of the 1995 IEEE Real-Time Technology and Applications Symposium, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: First, the description of the thread (and thread group) entities with respect to timing properties, layout requirements, etc., are specified in constructs of the System Description Language (SDL) <ref> [8] </ref>. Next, Spring-C [6] is used to code the application threads. 3.1 SDL Threads and thread groups are defined in the System Description Language, SDL. SDL statements are used to record real-time and non-real-time properties for objects in the real-time system.
Reference: [9] <author> J. W. S. Liu, K. J. Lin, W. K. Shih, A. C. Yu, J. Y. Chung, and W. Zhao, </author> <title> "Algorithms for scheduling imprecise computations," </title> <journal> IEEE Computer, </journal> <volume> vol. 24, no. 5, </volume> <pages> pp. 58-68, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: This guarantee type can be used as an approach to implementing imprecise computations <ref> [9] </ref>. The key difference between the two types of guarantees is the task set that is initially scheduled.
Reference: [10] <author> E.C. Cooper and R.P. Draves, </author> <title> "C threads," </title> <type> Tech. Rep. </type> <institution> CMU- CS-88-154, School of Computer Science, Carnegie Mellon University, Pittsburg, </institution> <address> PA, </address> <month> Feb. </month> <year> 1990. </year>
Reference-contexts: Note that the process set attribute of the layout SDL statement and the processors attribute of the thread SDL statement are used for different design decisions. 3.2 Spring-C This section discusses the thread language constructs for Spring-C. The convention adopted for the syntax is based on <ref> [10] </ref> and [11]. <p> If an application could arbitrarily decide to change from one thread to another, resources would be requested and released in non-determinate manner. 6.3 Schwan's Real-Time Threads The real-time threads package of Schwan [11] is based on the Mach C Threads interface <ref> [10] </ref>. The approach taken is that the schedulability of a thread should be guaranteed before it is actually run. This guarantee can be made at either program compilation time or at the time of thread creation.
Reference: [11] <author> K. Schwan, H. Zhou, and A. Gheith, </author> <title> "Multiprocessor real-time threads," </title> <journal> Operating Systems Review, </journal> <volume> vol. 26, no. 1, </volume> <pages> pp. 54-65, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: Note that the process set attribute of the layout SDL statement and the processors attribute of the thread SDL statement are used for different design decisions. 3.2 Spring-C This section discusses the thread language constructs for Spring-C. The convention adopted for the syntax is based on [10] and <ref> [11] </ref>. <p> Therefore, the constructs to lock objects that explicitly specify how long a thread is willing to wait for an object is not necessary in our model. For example, the real-time threads package of <ref> [11] </ref> contains a RTLock procedure: RESULT RTlock (rtlock, maxwait, time, func, arg) LOCK rtlock; int maxwait, time, (*func)(); any t arg; In this procedure call, maxwait is the maximum time the issuing thread can wait to acquire the lock. The difference here is the semantics of the call. <p> If an application could arbitrarily decide to change from one thread to another, resources would be requested and released in non-determinate manner. 6.3 Schwan's Real-Time Threads The real-time threads package of Schwan <ref> [11] </ref> is based on the Mach C Threads interface [10]. The approach taken is that the schedulability of a thread should be guaranteed before it is actually run. This guarantee can be made at either program compilation time or at the time of thread creation. <p> The second principle difference is the semantics of a threaded application as a function of ker nel support. In our work, a thread is scheduled based on its WCET but is guaranteed access to required resources before the thread executes. The approach of <ref> [11] </ref> is to also schedule a task based on its WCET, but only take into account the amount of time required resources will be used, without directly scheduling access to those resources.
Reference: [12] <author> J.A. Stankovic and K. Ramamritham, </author> <title> "A reflective architecture for real-time operating systems," </title> <booktitle> in Advances in Real-Time Systems, </booktitle> <publisher> Sang Son, Ed. Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: The action best chosen as a response to an external event often can depend on the exact situation in which the event occurs. Designing multiple responses creates a more robust system. Because the Spring kernel retains a significant amount of information at run-time (Spring is a reflective kernel <ref> [12] </ref>), the scheduler process has the ability to provide information in addition to sched yes or sched no in response to scheduling requests.
Reference: [13] <author> S. Oikawa and H. Tokuda, </author> <title> "User-level real-time threads," </title> <booktitle> in Proceedings of the 11th IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <address> Seattle, WA, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: The language constructs are similar to those adopted by POSIX, which is also founded on priority-based scheduling. The kernel-level threads of Real-Time Mach have recently been the basis for user-level threads <ref> [13] </ref>. User-level threads offer two benefits over kernel-level threads: the ability to switch contexts without making a system call and the ability to support a variety of scheduling models. A main goal of user-level real-time threads in Real-Time Mach is the quick, dynamic management of thread attributes.
Reference: [14] <author> J.A. Stankovic, G. Zlokapa, and K. Ramam-ritham, </author> <title> "Real-time platforms and environments for time constrained flexible manufacturing," </title> <booktitle> in IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: A range of options exist in the real-time threads package to support flexibility. This paper has also described the implementation of sterile threads and presented results from that implementation. Sterile threads are being used as the basis for experiments conducted in the Flexible Manufacturing Testbed <ref> [14] </ref> in the Center for Autonomous, Real-Time Systems (CARTS) at the University of Massachusetts. The testbed uses the Spring kernel to achieve coordinated control of multiple workcells. The implementation of fertile threads is continuing.
References-found: 14

