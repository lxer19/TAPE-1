URL: http://www.cs.rice.edu:80/~mpal/papers/IR95.ps
Refering-URL: http://www.cs.rice.edu:80/~mpal/papers/index.html
Root-URL: 
Email: cliffc@hpl.hp.com  mpal@cs.rice.edu  
Title: 35 A Simple Graph-Based Intermediate Representation  
Author: Cliff Click Michael Paleczny 
Abstract: We present a graph-based intermediate representation (IR) with simple semantics and a low-memory-cost C++ implementation. The IR uses a directed graph with l a-beled vertices and ordered inputs but unordered outputs. Vertices are labeled with opcodes, edges are unlabeled. We represent the CFG and basic blocks with the same vertex and edge structures. Each opcode is defined by a C++ class that encapsulates opcode-specific data and b e-havior. We use inheritance to abstract common opcode behavior, allowing new opcodes to be easily defined from old ones. The resulting IR is simple, fast and easy to use. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Alpern, M. Wegman, and F. Zadeck. </author> <title> Detec t-ing equality of variables in pro grams. </title> <booktitle> In Conference Record of the Fifteenth ACM Symp o-sium on the Principles of Programming La n-guages, </booktitle> <year> 1988. </year>
Reference-contexts: They are not used for program semantics but are useful for output. We show the graph representation in Figure 1 . Nodes are shown as a shadowed box with rounded corners. Edges carrying data values are shown as light arrows. In our written notation then, a [0] b, a <ref> [1] </ref> c, and a.opcode A DD . 2.2 Basic Blocks and R EGION Nodes Traditional representations have two distinct le v-els. At the top level, the CFG contains basic blocks. At the bottom level, each basic block contains instru c-tions. <p> // Class of Nodes that define integer constants virtual const char *Name () - return iLDI; - const int con; // The constant so defined -; class ProjNode : public Node - // Class of projections of other Nodes virtual const char *Name () - return Projection; - Node *src <ref> [1] </ref>; // The tuple-producing Node const int field; // The desired field out of the incoming tuple-value -; 42 gram with the results from the analysis. 4.3 Virtual Support Functions We do the local value-numbering optimization u sing a hash table, hashing the Nodes by opcode and i n-puts. <p> count and total inputs name controlling Node input 0 input 1 class SubNode : public Node - // Class of 2-input, 1-result instructions Node *src [3]; // Usually 3 inputs total to an Sub SubNode (Node *in0, Node *in1, Node *control) : Node (3,3,src) - inputs [0] = in0; inputs <ref> [1] </ref> = in1; inputs [2] = control; -; -; int Node::hash () // Hash opcode and inputs - int sum = ( int )Name; for ( int i=0; i&lt;cnt; i++ ) sum += (int)input [i]; return sum;- int IntConNode::hash () - return Node::hash ()+con; - // Constant is part of hash <p> i=0; i&lt;cnt; i++ ) sum += (int)input [i]; return sum;- int IntConNode::hash () - return Node::hash ()+con; - // Constant is part of hash function Node *Node::Identity () - return this ; - // Return a preexisting equivalent Node, if any Node *IntSubNode::Identity () // Integersubtract-specific implementation - return src <ref> [1] </ref> fi is_constant (0) ? src [0] : this ; - // Subtract of a zero is just the other input 43 making the inputs to a f function all have the same destination name. <p> GCM orders instructions by setting the control input to some R EGION node, thus selecting a basic block. Other dependences determine the order within the basic block. We compared the parse-time optimizations against a global optimization that combines Conditional Constant Propagation (CCP) [23], Global Congruence Finding (GCF) <ref> [1] </ref>, and Global Value Numbering [20]. The combination is stronger than iterating these optimizations to a fixed point ( i.e., the combination finds at least as many constants and equivalent e x-pressions) and is discussed in Clicks thesis [8]. <p> The SSA form is a convenient way to express all data dependences, but it also lacks control information at f - functions. Alpern, Wegman and Zadeck present the value graph <ref> [1] </ref>. The value graph is essen tially an SSA form of the program expressed as a directed graph. The authors extend the value graph to handle structured control flow, but do not attempt to represent complete programs this way.
Reference: [2] <author> V. Bala. </author> <title> Private conversation about the KSR register allocator, </title> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: name controlling Node input 0 input 1 class SubNode : public Node - // Class of 2-input, 1-result instructions Node *src [3]; // Usually 3 inputs total to an Sub SubNode (Node *in0, Node *in1, Node *control) : Node (3,3,src) - inputs [0] = in0; inputs [1] = in1; inputs <ref> [2] </ref> = control; -; -; int Node::hash () // Hash opcode and inputs - int sum = ( int )Name; for ( int i=0; i&lt;cnt; i++ ) sum += (int)input [i]; return sum;- int IntConNode::hash () - return Node::hash ()+con; - // Constant is part of hash function Node *Node::Identity () <p> It is possible to combine the C OPY insertion pass and the coalescing pass so that C OPY s are only inserted when values cannot be renamed (instead of inserting the C OPY s then having the coalesce phase remove them by renaming) <ref> [2] </ref>. 4.5 Fast Node Allocation Each time we make a new node we call the default operator new to get storage space. This in turn calls malloc and can be fairly time consuming. In addition, optimizations frequently delete a newly created object, requiring a call to free .
Reference: [3] <author> R. Ballance, A. Maccabe, and K. Ottenstein. </author> <title> The program dependence web: A representation supporting control, data- and demand-driven interpretation of imperative languages. </title> <booktitle> In Proceedings of the SIGPLAN 90 Conference on Programming Languages Design and Impl e-mentation, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: These topics are beyond the scope of this paper but are covered in Clicks thesis. The intermediate representation is a graph-based, objectoriented structure, similar in spirit to an oper a-tor-level Program Dependence Graph or Gated Single Assignment form <ref> [3, 11, 17, 18] </ref>. The final form co n-tains all the information required to execute the pr o-gram. The graph edges represent usedef chains. Analyses and transformations directly use and modify the usedef information. <p> One element of the pair would be a data dependence and the other a control dependence. This is an ungainly structure with co m-plicated semantics. Instead, we borrow some ideas from Ballance, et al. and Field <ref> [3, 14] </ref>. The control input comes from the R EGION node defining control for the P HI node. The other inputs to the P HI node are aligned with the R EGION nodes control inputs. <p> We give the C OPY the same destination name as the f function virtual function table count and total inputs name controlling Node input 0 input 1 class SubNode : public Node - // Class of 2-input, 1-result instructions Node *src <ref> [3] </ref>; // Usually 3 inputs total to an Sub SubNode (Node *in0, Node *in1, Node *control) : Node (3,3,src) - inputs [0] = in0; inputs [1] = in1; inputs [2] = control; -; -; int Node::hash () // Hash opcode and inputs - int sum = ( int )Name; for ( <p> The value graph lacks control i n-formation at f functions and there fore does not have a model of execution. Ballance, Maccabe and Ottenstein present the Program Dependence Web <ref> [3] </ref>. The PDW is a co m-bination of the PDG and SSA form and includes the necessary control in formation to have a model of ex e-cution. It also includes extra control edges that unne c-essarily restrict the model of execution.
Reference: [4] <author> P. Briggs. </author> <title> The Massively Scalar Compiler Pro j-ect. </title> <note> Unpublished report. Preliminary version available via ftp://cs.rice.edu/public/preston/optimizer/shared.ps. </note> <institution> Rice University, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: P HI nodes input several data values and output a single selected data value. CFG edges determine which values are merged in the f functions. Without those CFG edges our inte r-mediate representation is not compositional 1 <ref> [4, 20] </ref>. We need to associate with each data input to a P HI node the control input from the corresponding basic block. Doing this directly means that P HI nodes would have a set of pairs as inputs. <p> Both kinds of optimization are followed by a pass of GCM and Dead Code Elimination (DCE). 5.2 Experimental Method We converted a large test suite into a low-level intermediate language, ILOC <ref> [5, 4] </ref>. The ILOC produced by translation is very naive and is intended to be optimized. We then performed several optimizations at the ILOC level. We ran the result ing ILOC on a simul a-tor to collect execution cycle counts for the ILOC virtual machine. <p> Also, the PDG lacks the control information required at merges for an exec u-tion model. Cartwright and Felleisen extend the PDG to the Program Represen tation Graph adding valve nodes to the PDG <ref> [ 4] </ref>. The PRG has a model of ex e-cution. Selke's thesis gives a semantic framework for the PDG [ 20]. The PDG has fewer restric tions than our representation where control edges are required. We would like to extend the combined optimization algorithm so it understands control dependence.
Reference: [5] <author> P. Briggs and T. Harvey. </author> <title> Iloc '93. </title> <type> Technical report CRPC-TR93323, </type> <institution> Rice University, </institution> <year> 1993. </year>
Reference-contexts: Both kinds of optimization are followed by a pass of GCM and Dead Code Elimination (DCE). 5.2 Experimental Method We converted a large test suite into a low-level intermediate language, ILOC <ref> [5, 4] </ref>. The ILOC produced by translation is very naive and is intended to be optimized. We then performed several optimizations at the ILOC level. We ran the result ing ILOC on a simul a-tor to collect execution cycle counts for the ILOC virtual machine.
Reference: [6] <author> R. Cartwright and M. Felleisen. </author> <title> The semantics of program dependence. </title> <booktitle> In Proceedings of the SIGPLAN 89 Conference on Programming Languages Design and Implementation , June 1989. </booktitle>
Reference: [7] <author> D. Chase, M. Wegman, F. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the SIGPLAN 90 Conference on Programming Languages Design and Implementation , June 1990. </booktitle>
Reference-contexts: A better design would break the global STORE into many smaller, unrelated STORE s. Every independent var i-able or array would get its own STORE . Operations on the separate STORE s could proceed independently from each other. We could also add some understan ding of pointers <ref> [7] </ref>. Memory-mapped I/O ( e.g., volatile in C++) is treated like memory, except that both R EAD and W RITE nodes produce a new I/O state.
Reference: [8] <author> C. Click, </author> <title> Combining Analyses, Combining O p-timizations. </title> <type> Ph.D. thesis, </type> <institution> Rice University, </institution> <year> 1995. </year> <note> Preliminary version available via ftp://cs.rice. edu/public/cliffc/thesis.ps.gz. </note>
Reference-contexts: Our goal is a repr e-sentation that is simple and light weight while allowing easy expression of fast optimizations. This paper discusses the intermediate represent a-tion (IR) used in the research compiler implemented as part of the authors dissertation <ref> [8] </ref>. The parser that builds this IR performs significant parse-time optim i-zations, including building a form of Static Single A s-signment (SSA) at parse-time. <p> Each primitive node takes in a control input to indicate which basic block the primitive is in. This edge is not always required. Removing it enables a number of global optimizations but requires a more complex serialization operation for output <ref> [8] </ref>. Such optional control edges will be shown as dashed arrows. <p> The combination is stronger than iterating these optimizations to a fixed point ( i.e., the combination finds at least as many constants and equivalent e x-pressions) and is discussed in Clicks thesis <ref> [8] </ref>. Both kinds of optimization are followed by a pass of GCM and Dead Code Elimination (DCE). 5.2 Experimental Method We converted a large test suite into a low-level intermediate language, ILOC [5, 4]. The ILOC produced by translation is very naive and is intended to be optimized.
Reference: [9] <author> C. Click. </author> <title> Global code motion, global value numbering. </title> <note> Submitted to PLDI 95. </note>
Reference-contexts: The parser that builds this IR performs significant parse-time optim i-zations, including building a form of Static Single A s-signment (SSA) at parse-time. Classic optimizations such as Conditional Constant Propagation [23] and Global Value Numbering [20] as well as a novel global code motion algorithm <ref> [ 9] </ref> work well on the IR. These topics are beyond the scope of this paper but are covered in Clicks thesis. The intermediate representation is a graph-based, objectoriented structure, similar in spirit to an oper a-tor-level Program Dependence Graph or Gated Single Assignment form [3, 11, 17, 18].
Reference: [10] <author> R. Cytron, J. Ferrante, B. K. Rosen, M. We g-man, and F. Zadeck. </author> <title> An efficient method of computing static single assignment form. </title> <booktitle> In Conference Record of the Six teenth ACM Sy m-posium on the Principles of Programming La n-guages, </booktitle> <month> Jan. </month> <year> 1989. </year>
Reference-contexts: The PDG has fewer restric tions than our representation where control edges are required. We would like to extend the combined optimization algorithm so it understands control dependence. Cytron, Ferrante, Rosen, Wegman and Zadeck d e-scribe an efficient way to build the SSA form of a pr o-gram <ref> [ 10] </ref> which assigns only once to each vari able. The SSA form is a convenient way to express all data dependences, but it also lacks control information at f - functions. Alpern, Wegman and Zadeck present the value graph [1].
Reference: [11] <author> J. Davidson and C. Fraser. </author> <title> Code selection through object code optimization. </title> <booktitle> ACM Tran s-actions on Programming Languages and Sy stems, </booktitle> <address> 6(4):505526, </address> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: These topics are beyond the scope of this paper but are covered in Clicks thesis. The intermediate representation is a graph-based, objectoriented structure, similar in spirit to an oper a-tor-level Program Dependence Graph or Gated Single Assignment form <ref> [3, 11, 17, 18] </ref>. The final form co n-tains all the information required to execute the pr o-gram. The graph edges represent usedef chains. Analyses and transformations directly use and modify the usedef information. <p> CFGs deal with control flow and basic blocks deal with data flow. We handle both kinds of dependences with the same mechanism, r e-moving this distinction to simplify our representation. We replace basic blocks with a special R EGION node <ref> [11] </ref>. A R EGION node takes a control value from each predecessor block as inputs and produces a merged control as an output. Figure 2 shows the change from basic blocks to R EGION nodes. Edges carrying control information are shown with thick a r-rows. <p> Our pessimistic analysis requires only usedef i n-formation, which we can gather as we parse the code. The compiler looks at (and changes) a fixed-size i n-struction window of the intermediate represent a-tion <ref> [11] </ref>. This window looks over the program graph instead of sequential instructions, providing the co m-piler with access to related instructions far away in the program text. <p> This lifting of restrictions gives analysis and optimization algorithms more freedom to discover facts and reorganize code from disjoint se c-tions of the original program. Ferrante, Ottenstein and Warren present the Program Dependence Graph in <ref> [11] </ref>. The PDG is more restrictive than our representation in that control edges are added to every node. Also, the PDG lacks the control information required at merges for an exec u-tion model.
Reference: [12] <author> K. Drechsler and M. Stadel. </author> <title> A solution to a problem with Morel and Renvoises Global o p-timization by suppression of partial redunda n-cies. </title> <journal> ACM Transactions on Programming Languages and Systems , 10(4):635640, </journal> <month> Oct. </month> <year> 1988. </year>
Reference: [13] <author> J. Ferrante, K. Ottenstein, and J. Warren. </author> <title> The program dependence graph and its use in optim i-zation. </title> <journal> ACM Transactions on Programming Languages and Systems , 9(3):319349, </journal> <month> July, </month> <year> 1987. </year>
Reference: [14] <author> J. </author> <title> Field. A simple rewriting semantics for reali s-tic imperative programs and its application to program analysis. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation , pages 98107, </booktitle> <year> 1990. </year> <month> 49 </month>
Reference-contexts: One element of the pair would be a data dependence and the other a control dependence. This is an ungainly structure with co m-plicated semantics. Instead, we borrow some ideas from Ballance, et al. and Field <ref> [3, 14] </ref>. The control input comes from the R EGION node defining control for the P HI node. The other inputs to the P HI node are aligned with the R EGION nodes control inputs. <p> We stress compilation speed and code quality; our compiler is much faster and includes a larger set of classic optimizations. John Field gives a formal treatment of graph r e-writing on a representation strongly re sembling our representation. We hope to use his semantics with only minimal modifications <ref> [14] </ref>. 7. Conclusions Our intermediate representation is a compact and lightweight graph containing the essential information for both program execution and optimization. Data dependences are represented using usedef edges, as in an SSA graph, while control dependences become 48 edges to R EGION Nodes.
Reference: [15] <author> G. Forstyhe, M. Malcom, and C. Moler. </author> <title> Computer Methods for Mathematical Computations. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1977. </year>
Reference-contexts: In addition, optimizations frequently delete a newly created object, requiring a call to free . We speed up these frequent operations by hooking the class specific operator new and delete for class Node. Our replacement operators use an arena <ref> [15] </ref>. Arenas hold heap-allocated objects with similar lifetimes. When the lifetime ends, we d e lete the arena freeing all the contained objects in a fast operation. The code is given in Figure 14. Allocation checks for sufficient room in the arena. <p> Thus we choose matrix300 over matrix1000 for faster testing times, even cutting the matrix size down to 50. The remai n-ing procedures come from the Forsythe, Malcom and Moler suite of routines <ref> [15] </ref>. 5.3 Results We measured optimization time with and without the peephole pass. The total time across all applic a-tions for peephole optimization followed by global analysis was 108.8 seconds. Global analysis alone was 116.1 seconds.
Reference: [16] <author> D. Hanson. </author> <title> Fast allocation and deallocation of memory based on object lifetimes. </title> <journal> Software Practice and Experience, </journal> <volume> 20(1):512, </volume> <month> Jan. </month> <year> 1990. </year>
Reference: [17] <author> P. Havlak, </author> <title> Interprocedural Symbolic Analysis . Ph.D. </title> <type> thesis, </type> <institution> Rice University, </institution> <year> 1994. </year>
Reference-contexts: These topics are beyond the scope of this paper but are covered in Clicks thesis. The intermediate representation is a graph-based, objectoriented structure, similar in spirit to an oper a-tor-level Program Dependence Graph or Gated Single Assignment form <ref> [3, 11, 17, 18] </ref>. The final form co n-tains all the information required to execute the pr o-gram. The graph edges represent usedef chains. Analyses and transformations directly use and modify the usedef information. <p> The DFG includes anti-dependence edges to manage the store; our representation does not require these. The DFG includes a denotational semantics and has the one step Church-Rosser property. Paul Havlak has done some recent work on the thinned Gated Single Assignment form of a pr o-gram <ref> [17] </ref>. This form is both executable and compact. Currently, the GSA is lim ited to reducible programs. The GSA can find congruences amongst DAGs of b a-sic blocks not found using our representation. We can find congruences amongst loop in variant expressions not found using the GSA.
Reference: [18] <author> E. Morel and C. </author> <title> Renvoise. Global optimization by suppression of partial redundancies. </title> <journal> Communications of the ACM , 22(2):96103, </journal> <month> Feb. </month> <year> 1979. </year>
Reference-contexts: These topics are beyond the scope of this paper but are covered in Clicks thesis. The intermediate representation is a graph-based, objectoriented structure, similar in spirit to an oper a-tor-level Program Dependence Graph or Gated Single Assignment form <ref> [3, 11, 17, 18] </ref>. The final form co n-tains all the information required to execute the pr o-gram. The graph edges represent usedef chains. Analyses and transformations directly use and modify the usedef information. <p> The PDW includes m and h nodes to support a de mand-driven data model. Our representation supports a data-driven model and does not need these nodes. The PDW is complex to build, requiring several phases. Pingali, Beck, Johnson, Moudgill and Stodghill present the Dependence Flow Graph <ref> [18] </ref>. The DFG is executable and includes the compact SSA represe n-tation of data dependences. The DFG has switched data outputs that essentially add the same unneces sary control dependences found in the PDW. The DFG includes anti-dependence edges to manage the store; our representation does not require these.
Reference: [19] <author> R. Pingali, M. Beck, R. Johnson, M. Moudgill, and P. Stodghill. </author> <title> Dependence flow graphs: An algebraic approach to program dependencies. </title> <type> Technical Report TR-901152, </type> <institution> Cornell Un i-versity, </institution> <year> 1990. </year>
Reference: [20] <author> B. Rosen., M. Wegman, and F. Zadeck, </author> <title> Global Value Numbers and Redundant Computations. </title> <booktitle> In Conference Record of the Fifteenth ACM Symposium on the Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: The parser that builds this IR performs significant parse-time optim i-zations, including building a form of Static Single A s-signment (SSA) at parse-time. Classic optimizations such as Conditional Constant Propagation [23] and Global Value Numbering <ref> [20] </ref> as well as a novel global code motion algorithm [ 9] work well on the IR. These topics are beyond the scope of this paper but are covered in Clicks thesis. <p> P HI nodes input several data values and output a single selected data value. CFG edges determine which values are merged in the f functions. Without those CFG edges our inte r-mediate representation is not compositional 1 <ref> [4, 20] </ref>. We need to associate with each data input to a P HI node the control input from the corresponding basic block. Doing this directly means that P HI nodes would have a set of pairs as inputs. <p> Other dependences determine the order within the basic block. We compared the parse-time optimizations against a global optimization that combines Conditional Constant Propagation (CCP) [23], Global Congruence Finding (GCF) [1], and Global Value Numbering <ref> [20] </ref>. The combination is stronger than iterating these optimizations to a fixed point ( i.e., the combination finds at least as many constants and equivalent e x-pressions) and is discussed in Clicks thesis [8]. <p> Cartwright and Felleisen extend the PDG to the Program Represen tation Graph adding valve nodes to the PDG [ 4]. The PRG has a model of ex e-cution. Selke's thesis gives a semantic framework for the PDG <ref> [ 20] </ref>. The PDG has fewer restric tions than our representation where control edges are required. We would like to extend the combined optimization algorithm so it understands control dependence.
Reference: [21] <author> R. Selke, </author> <title> A Semantic Framework for Program Dependence. </title> <type> Ph.D. thesis, </type> <institution> Rice University, </institution> <year> 1992. </year>
Reference: [22] <author> D. Weise, R. Crew, M. Ernst, and B. Steen s-gaard. </author> <title> Value dependence graphs: Representation without taxation. </title> <booktitle> In Proceedings of the 21st ACM SIGPLAN Symposium on the Principles of Programming Languages, </booktitle> <year> 1994. </year>
Reference-contexts: A promising implementation of thinned GSA exists and has been used on a large suite of FORTRAN a p-plications with good results. Weise, Crew, Ernst, and Steensgaard present the Value Dependence Graph <ref> [22] </ref>. The VDG is similar in spirit to our representation. It represents an ind e-pendent line of research, performed in parallel with our own.
Reference: [23] <author> M. Wegman and F. Zadeck. </author> <title> Constant propag a-tion with conditional branches. </title> <booktitle> ACM Transa c-tions on Programming Languages and Systems , 13(2) </booktitle> <pages> 181-210, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: The parser that builds this IR performs significant parse-time optim i-zations, including building a form of Static Single A s-signment (SSA) at parse-time. Classic optimizations such as Conditional Constant Propagation <ref> [23] </ref> and Global Value Numbering [20] as well as a novel global code motion algorithm [ 9] work well on the IR. These topics are beyond the scope of this paper but are covered in Clicks thesis. <p> GCM orders instructions by setting the control input to some R EGION node, thus selecting a basic block. Other dependences determine the order within the basic block. We compared the parse-time optimizations against a global optimization that combines Conditional Constant Propagation (CCP) <ref> [23] </ref>, Global Congruence Finding (GCF) [1], and Global Value Numbering [20]. The combination is stronger than iterating these optimizations to a fixed point ( i.e., the combination finds at least as many constants and equivalent e x-pressions) and is discussed in Clicks thesis [8].
References-found: 23

