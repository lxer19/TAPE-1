URL: ftp://theory.lcs.mit.edu/pub/people/victor_l/thesis.ps
Refering-URL: http://theory.lcs.mit.edu/~victor_l/papers/masters.html
Root-URL: 
Title: Using Simulation Techniques to Prove Timing Properties  
Author: by Victor Luchangco Nancy A. Lynch 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degrees of Master of Science in Electrical Engineering and Computer Science and Bachelor of Science in Computer Science and Engineering at the  c Victor Luchangco, MCMXCV. All rights reserved. The author hereby grants to MIT permission to reproduce and distribute publicly paper and electronic copies of this thesis document in whole or in part, and to grant others the right to do so. Author  Certified by  Professor of Computer Science and Engineering Thesis Supervisor Accepted by Frederic R. Morgenthaler Chairman, Departmental Committee on Graduate Students  
Date: June 1995  May 19, 1995  
Address: (1992)  
Affiliation: S.B. Mathematics  Massachusetts Institute of Technology  MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [ACD90] <author> Rajeev Alur, Costas Courcoubetis, and David Dill. </author> <title> Model-checking for real-time systems. </title> <booktitle> In Proceedings of the Fifth IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 414-425, </pages> <address> Philadelphia, PA, June 1990. </address> <publisher> IEEE Computer Science Press. </publisher>
Reference-contexts: Alur and Henzinger's TPTL is also decidable, and in another paper [AH90], they explore the trade-off between complexity and expressiveness. All these logics use discrete time (i.e., the natural numbers), since extensions to dense time domains are undecidable. Alur, Courcoubetis, and Dill <ref> [ACD90] </ref>, however, present a logic based on "branching time" computation tree logic (CTL), rather than on linear time, with a dense time domain.
Reference: [AD90] <author> Rajeev Alur and David Dill. </author> <title> Automata for modeling real-time systems. In M.S. </title> <editor> Paterson, editor, </editor> <booktitle> Automata, Languages and Programming: Proceedings of the ICALP'90, volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 322-335. </pages> <publisher> Springer-Verlag, Warwick University, </publisher> <address> England, </address> <month> July </month> <year> 1990. </year> <note> To appear in Theoretical Computer Science. </note>
Reference-contexts: Their use of simulations, however, is more restricted, and they did not address how timing properties, specifically, can be approached systematically. Many others, including Haase [Haa81], Tel [Tel88], Shaw [Sha89], Harel, Lichtenstein, and Pnueli [HLP90], Alur and Dill <ref> [AD90] </ref>, and Shankar and Lam [SL87, Sha92], also use models that incorporate timing information into the state, but none of them use simulations in their proofs. Shankar uses a model almost identical to ours, except that there are no explicit time passage steps.
Reference: [AH89] <author> Rajeev Alur and Thomas Henzinger. </author> <title> A really temporal logic. </title> <booktitle> In Proceedings of Thirtieth Annual ACM Symposium on Foundations of Computer Science, </booktitle> <pages> pages 164-169, </pages> <address> Research Triangle Park, NC, October/November 1989. </address> <publisher> IEEE Computer Science Press. </publisher>
Reference-contexts: The earliest work used bounded temporal operators [BH81, KVdR83], but scattered examples of an explicit clock approach, presented systematically by Ostroff [Ost89], also can be found. Henzinger, Manna, and Pnueli [HMP94] compare these two styles. More recently, Alur and Henzinger <ref> [AH89] </ref> presented an approach called temporal quantification, embodied by their new logic, TPTL. Automatic verification motivated much of the design of recent temporal logics, so an important consideration was that they be decidable. Harel, Lichtenstein, and Pnueli [HLP90] presented a decidable restricted explicit clock logic.
Reference: [AH90] <author> Rajeev Alur and Thomas Henzinger. </author> <title> Real-time logics: Complexity and expressiveness. </title> <booktitle> In Proceedings of the Fifth IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 390-401, </pages> <address> Philadelphia, PA, June 1990. </address> <publisher> IEEE Computer Science Press. </publisher>
Reference-contexts: Automatic verification motivated much of the design of recent temporal logics, so an important consideration was that they be decidable. Harel, Lichtenstein, and Pnueli [HLP90] presented a decidable restricted explicit clock logic. Alur and Henzinger's TPTL is also decidable, and in another paper <ref> [AH90] </ref>, they explore the trade-off between complexity and expressiveness. All these logics use discrete time (i.e., the natural numbers), since extensions to dense time domains are undecidable.
Reference: [AL91] <author> Martn Abadi and Leslie Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <month> May </month> <year> 1991. </year>
Reference: [AL92] <author> Martn Abadi and Leslie Lamport. </author> <title> An old-fashioned recipe for real time. </title> <type> Research report, </type> <institution> DEC Systems Research Center, </institution> <month> December </month> <year> 1992. </year> <month> 151 </month>
Reference-contexts: More recently, simulation-based techniques have been extended to timed systems, providing a formal and systematic approach to proving timing properties <ref> [LA92, AL92] </ref>. 1 These techniques have been demonstrated on small examples, and the style and difficulty of the proofs are comparable to those of typical inductive assertional arguments. The local nature of the checks suggests that this method may scale well to more complex systems. <p> Lynch and Vaandrager have developed a very general notion of a timed automaton, and they describe a wide variety of simulation-based techniques for this model [LV91, LVarb]. Abadi and Lamport <ref> [AL92] </ref> demonstrate how timing properties can be expressed using Lamport's Temporal Logic of Actions (TLA) [Lam91], and thus, the methods developed for TLA, including simulations, can be immediately applied. Their use of simulations, however, is more restricted, and they did not address how timing properties, specifically, can be approached systematically. <p> Shankar uses a model almost identical to ours, except that there are no explicit time passage steps. Other methods for modelling timed distributed systems include temporal logic <ref> [AL92] </ref>, process algebras [DS89, Wan91, NS91], and Petri nets [CR83]. Several different approaches to proving timing properties have also been proposed, many of them based on augmented temporal logics.
Reference: [AS85] <author> Bowen Alpern and Fred Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21(4) </volume> <pages> 181-185, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: Safety properties can be expressed as 2 Again, this is a subjective empirical claim supported by many researchers [LL90, CM88, Lam93b]. 3 Alpern and Schneider define these precisely in <ref> [AS85] </ref>. 17 assertions about the states, 4 but liveness properties cannot be.
Reference: [BH81] <author> Arthur Bernstein and Paul Harter. </author> <title> Proving real-time properties of programs with temporal logic. </title> <booktitle> In Proceedings of the Eighth Annual ACM Symposium for Operating System Principles, </booktitle> <pages> pages 1-11, </pages> <address> Pacific Grove, CA, </address> <month> December </month> <year> 1981. </year> <note> ACM Press. </note>
Reference-contexts: Other methods for modelling timed distributed systems include temporal logic [AL92], process algebras [DS89, Wan91, NS91], and Petri nets [CR83]. Several different approaches to proving timing properties have also been proposed, many of them based on augmented temporal logics. The earliest work used bounded temporal operators <ref> [BH81, KVdR83] </ref>, but scattered examples of an explicit clock approach, presented systematically by Ostroff [Ost89], also can be found. Henzinger, Manna, and Pnueli [HMP94] compare these two styles. More recently, Alur and Henzinger [AH89] presented an approach called temporal quantification, embodied by their new logic, TPTL. <p> Partially Synchronous Models In recent years, there has been an increased interest in introducing a formal notion of time into distributed models (e.g., <ref> [BH81, SL87, DS89, Ost89, Wan91] </ref>), and a methodology for proving timing properties. By taking advantage of timing restrictions, a distributed 19 system designer may opt for simpler, more efficient protocols, which would not be possible in the asynchronous setting.
Reference: [BL93] <author> James Burns and Nancy Lynch. </author> <title> Bounds on shared memory for mutual exclusion. </title> <journal> Information and Computation, </journal> <volume> 107(2) </volume> <pages> 171-184, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Moreover, research in the asynchronous setting has yielded many impossibility results, usually giving lower bounds on the resources required to solve certain problems <ref> [Lyn89a, BL93] </ref>. Many of these results arise in the context of fault-tolerance, where the system is required to solve the problem, even though components may fail in some specified fashion. <p> The mutual exclusion requirement demands that at most one process has the resource at any time. Burns and Lynch <ref> [BL93] </ref> proved that in the asynchronous shared memory model, the mutual exclusion problem for n processes requires at least n atomic read/write shared variables. In this chapter, we examine Fischer's timing-based mutual exclusion algorithm [Fis85, Lam87], using only a single shared variable.
Reference: [CAZ92] <author> Baio Chen, Gopal Agrawal, and Wei Zhao. </author> <title> Optimal synchronous capacity allocation for hard real-time communications with the timed token protocol. </title> <booktitle> In Proceedings of the Thirteenth Real-Time Systems Symposium, </booktitle> <pages> pages 198-207, </pages> <address> Phoenix, AZ, December 1992. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: For these, and other problems, it is important to characterize not only correctness but also timeliness. Perhaps the most useful application of these techniques lies in the analysis of communication protocols <ref> [CAZ92, MSST93] </ref>, which generally have only informal claims of efficiency and even correctness. For many of these, especially the distributed group communication protocols, the correctness guarantees are not always clear, and only recently have there been attempts at stating these more formally [HT93, FKL95, FvR95, MBRS94].
Reference: [CE81] <author> Edmund M. Clarke and E. Allen Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching time temporal logic. </title> <editor> In Dexter Kozen, editor, </editor> <booktitle> Logics of Programs, volume 131 of Lecture Notes in Computer Science, </booktitle> <pages> pages 52-71, </pages> <address> Yorktown Heights, New York, May 1981. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Alur, Courcoubetis, and Dill [ACD90], however, present a logic based on "branching time" computation tree logic (CTL), rather than on linear time, with a dense time domain. These logics are all intended to be used with model-checking verification procedures, introduced by Clarke and Emerson <ref> [CE81] </ref>, in which a system is modelled by a finite state machine, and every reachable state is verified 12 to satisfy the desired property. There are many other approaches to automatic verification.
Reference: [CG87] <author> E.M. Clarke and O. Grumberg. </author> <title> Research on automatic verification of finite-state concurrent systems. </title> <editor> In Joseph Traub, Barbara Grosz, Butler Lampson, and Nils Nilsson, editors, </editor> <booktitle> Annual Reviews of Computer Science, </booktitle> <volume> volume 2, </volume> <pages> pages 269-290. </pages> <publisher> Annual Reviews Inc., </publisher> <year> 1987. </year>
Reference-contexts: This is especially useful for simulation-based proofs, because of their length and the amount of tedious detail that needs to be checked. 2.4.1 Choosing a Tool There is a wide range of possible useful automated tools, ranging from model-checkers <ref> [CG87] </ref>, which exhaustively search all possible states to verify properties without any human guidance, to programs that simply check the validity of each step in a detailed proof, from specialized provers optimized for a particular domain of applications, to general purpose theorem provers, from provers that halt and request guidance at
Reference: [CM88] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: This often corresponds naturally with how we might reason informally. However, since a distributed system can exhibit a wide variety of behaviors with little natural structure, it is difficult to 1 This is an empirical observation supported by many researchers in the field <ref> [CM88, LL90, Sch93] </ref>. 16 check that all behaviors have been considered. 2 Furthermore, minor modifications to the algorithm often result in some vastly different behaviors, requiring proofs to be substantially rewritten. <p> Safety properties can be expressed as 2 Again, this is a subjective empirical claim supported by many researchers <ref> [LL90, CM88, Lam93b] </ref>. 3 Alpern and Schneider define these precisely in [AS85]. 17 assertions about the states, 4 but liveness properties cannot be.
Reference: [CR79] <author> Ernest Chang and Rosemary Roberts. </author> <title> An improved algorithm for decentralized extrema-finding in circular configurations of processes. </title> <journal> Communications of the ACM, </journal> <volume> 22(5) </volume> <pages> 281-283, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: We use these simulations, together with invariant assertions, to prove correctness and timing properties of two systems, a simple message-passing protocol due to LeLann, Chang, and Roberts <ref> [LeL77, CR79] </ref> for leader election on a ring of processes, and Fischer's timing-based mutual exclusion algorithm using a single shared read-write register [Lam87, Fis85]. For both algorithms, we use intermediate specifications to obtain hierarchical proofs, and we extract general heuristics for finding these intermediate specifications. <p> Other wise, u:last (report) ( s:last (report) if s:countdown = 0 s:last (decrement) + s:countdown c 2 if s:countdown &gt; 0 ) 39 40 Chapter 4 LeLann-Chang-Roberts Election Algorithm We now consider a simple asynchronous algorithm by LeLann, Chang and Roberts <ref> [LeL77, CR79] </ref>, which solves the election problem for a ring network in the message passing model. Although the algorithm is asynchronous, we assume bounds on the communication delay and the local step times in order to prove an upper bound on the time to election. <p> We will sometimes treat a queue as the set of its elements, using appropriate notation. 4.3 LeLann-Chang-Roberts Algorithm The automaton LCR in Figure 4-3 expresses a simple protocol proposed by LeLann [LeL77], and improved by Chang and Roberts <ref> [CR79] </ref>, to elect the process with the maximum iden 43 State For each i 2 Z n status i 2 funknown; chosen; reportedg, initially unknown pending i 2 Queues (I), initially a queue with only UID i Actions External leader i Pre: status i = chosen Eff: status i = reported
Reference: [CR83] <author> J. Coolahan and N. Roussopoulus. </author> <title> Timing requirements for time-driven systems using augmented Petri nets. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-9(5):603-616, </volume> <month> September </month> <year> 1983. </year> <month> 152 </month>
Reference-contexts: Shankar uses a model almost identical to ours, except that there are no explicit time passage steps. Other methods for modelling timed distributed systems include temporal logic [AL92], process algebras [DS89, Wan91, NS91], and Petri nets <ref> [CR83] </ref>. Several different approaches to proving timing properties have also been proposed, many of them based on augmented temporal logics. The earliest work used bounded temporal operators [BH81, KVdR83], but scattered examples of an explicit clock approach, presented systematically by Ostroff [Ost89], also can be found.
Reference: [Dij65] <author> Edsger Dijkstra. </author> <title> Solution of a problem in concurrent programming control. </title> <journal> Communications of the ACM, </journal> <volume> 11(5) </volume> <pages> 341-346, </pages> <month> September </month> <year> 1965. </year>
Reference-contexts: Thus, this model is quite realistic as well, and a lot of research on distributed algorithms has been done in this context <ref> [Dij65, Lam74, LT87, Gaw92, LS93] </ref>. In this case, the time complexity an algorithm is measured by the number of steps it takes. However, these models cannot be used for systems which use timing restrictions to rule out certain behaviors, and thus achieve simpler or chaaper solutions for some problems. <p> This was one of the earliest models used <ref> [Dij65] </ref>. Because the processes are executing concurrently, it is important to define what happens when two or more processes attempt to write into a register simultaneously. <p> For example, the mutual exclusion automata in Chapter 5 have a set of state variables and actions for each process, but the proof does not depend on the number of processes. 100 [Lyn93] for Dijkstra's mutual exclusion algorithm <ref> [Dij65] </ref> should be an informative test of the enhancements made to the Larch tools. The hybrid algorithm of Lynch and Shavit [LS92] is another possibly instructive example to examine, as are Lamport's "bakery" algorithm [Lam74], and algorithms proposed by Peterson and Fischer [PF77].
Reference: [DS89] <author> Jim Davies and Steve Schneider. </author> <title> An introduction to timed CSP. </title> <type> Technical Report PRG-75, </type> <institution> Oxford University Computing Laboratory, </institution> <year> 1989. </year>
Reference-contexts: Shankar uses a model almost identical to ours, except that there are no explicit time passage steps. Other methods for modelling timed distributed systems include temporal logic [AL92], process algebras <ref> [DS89, Wan91, NS91] </ref>, and Petri nets [CR83]. Several different approaches to proving timing properties have also been proposed, many of them based on augmented temporal logics. <p> Partially Synchronous Models In recent years, there has been an increased interest in introducing a formal notion of time into distributed models (e.g., <ref> [BH81, SL87, DS89, Ost89, Wan91] </ref>), and a methodology for proving timing properties. By taking advantage of timing restrictions, a distributed 19 system designer may opt for simpler, more efficient protocols, which would not be possible in the asynchronous setting.
Reference: [EGL92] <author> Urban Engberg, Peter Grtnning, and Leslie Lamport. </author> <title> Mechanical verification of concurrent systems with TLA. </title> <editor> In G.v.Bochmann and D.K.Probst, editors, </editor> <booktitle> Computer Aided Verification: Fourth International Workshop, CAV'92, volume 663 of Lecture Notes in Computer Science, </booktitle> <pages> pages 44-55, </pages> <address> Montreal, Canada, June/July 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Our approach is to follow as closely as possible the formal reasoning we already use to convince ourselves, and use a general purpose theorem prover to verify our steps [SGG + 93, Soy94, LSGL94]. Engberg, Grtnning, and Lamport <ref> [EGL92] </ref>, and Shankar [Sha93] also take this approach, though Shankar uses PVS rather than LP. Outline of the Thesis The rest of the thesis is organized as follows. Chapter 2 contains some background and motivation for those unfamiliar with formal reasoning for distributed systems in general, and simulations in particular.
Reference: [Fis85] <author> Michael Fischer. Re: </author> <title> Where are you? E-mail to Leslie Lamport. ARPAnet message number 8506252257.AA07636@YALE.BULLDOG.YALE.ARPA, </title> <address> June 25, </address> <year> 1985. </year> <month> 18:56:29EDT. </month>
Reference-contexts: We use these simulations, together with invariant assertions, to prove correctness and timing properties of two systems, a simple message-passing protocol due to LeLann, Chang, and Roberts [LeL77, CR79] for leader election on a ring of processes, and Fischer's timing-based mutual exclusion algorithm using a single shared read-write register <ref> [Lam87, Fis85] </ref>. For both algorithms, we use intermediate specifications to obtain hierarchical proofs, and we extract general heuristics for finding these intermediate specifications. <p> Burns and Lynch [BL93] proved that in the asynchronous shared memory model, the mutual exclusion problem for n processes requires at least n atomic read/write shared variables. In this chapter, we examine Fischer's timing-based mutual exclusion algorithm <ref> [Fis85, Lam87] </ref>, using only a single shared variable. In addition to mutual exclusion, we prove an upper bound on the time any process must wait to acquire the resource while it remains unused.
Reference: [FKL95] <author> Alan Fekete, Frans Kaashoek, and Nancy Lynch. </author> <title> Implementing sequentially consistent shared objects using broadcast and point-to-point communication. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Distributed Computing Systems, </booktitle> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: For many of these, especially the distributed group communication protocols, the correctness guarantees are not always clear, and only recently have there been attempts at stating these more formally <ref> [HT93, FKL95, FvR95, MBRS94] </ref>. Unfortunately, these usually lack performance guarantees, which are essential for communication systems. Stgaard-Andersen, Lynch, and Lampson have recently done a lengthy case study applying simulation methods to communication protocols [SLL93a, SLL93b], but this does not include an analysis of the timing.
Reference: [Flo67] <author> R. Floyd. </author> <title> Assigning meanings to programs. </title> <booktitle> In Proceedings of the Symposium on Applied Mathematics, </booktitle> <volume> volume 19, </volume> <pages> pages 19-32, </pages> <year> 1967. </year>
Reference-contexts: More generally, there need not be only one set of milestones, all of which need to be passed. Rather, there could be several alternative paths, each with its own set of milestones. This is similar to the decrementing function method of Floyd <ref> [Flo67] </ref>, with milestones corresponding to decrementing the function.
Reference: [FvR95] <author> Roy Friedman and Robbert van Renesse. </author> <title> Strong and weak virtual synchrony in Horus. </title> <type> Technical Report CORNELLCS:TR95-1491, </type> <institution> Cornell University Department of Computer Science, </institution> <address> Ithaca, NY 14853, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: For many of these, especially the distributed group communication protocols, the correctness guarantees are not always clear, and only recently have there been attempts at stating these more formally <ref> [HT93, FKL95, FvR95, MBRS94] </ref>. Unfortunately, these usually lack performance guarantees, which are essential for communication systems. Stgaard-Andersen, Lynch, and Lampson have recently done a lengthy case study applying simulation methods to communication protocols [SLL93a, SLL93b], but this does not include an analysis of the timing.
Reference: [Gaw92] <author> Rainer Gawlick. </author> <title> Bounded concurrent time-stamping made simple. </title> <type> Master's thesis, </type> <institution> MIT Dept. of Electrical Engineering and Computer Science, </institution> <address> Cambridge, MA 02139, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Thus, this model is quite realistic as well, and a lot of research on distributed algorithms has been done in this context <ref> [Dij65, Lam74, LT87, Gaw92, LS93] </ref>. In this case, the time complexity an algorithm is measured by the number of steps it takes. However, these models cannot be used for systems which use timing restrictions to rule out certain behaviors, and thus achieve simpler or chaaper solutions for some problems.
Reference: [GG91] <author> Stephen J. Garland and John V. Guttag. </author> <title> A guide to LP, the Larch Prover. </title> <type> Research Report 82, </type> <institution> DEC Systems Research Center, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: We also use the Larch tools [GH93] to verify the proof for Fischer's algorithm, building on the work by Soylemez [Soy94], formalizing the basic model and techniques in the Larch Shared Language (LSL), and verifying the proofs using an enhanced version of the Larch Prover (LP) <ref> [GG91, Pog95] </ref>. This elaborates on work described in [LSGL94]. <p> The system is formalized in the Larch Shared Language, and checked using LP, the Larch Prover <ref> [GG91] </ref>, both enhanced to handle full first-order logic. 2.4.2 The Implications of Time Since time is a continuous quantity, adding time to the formal model presents additional challenges for automated tools. Tools designed specifically for finite state machines, for example, must cope with the uncountable possibilities introduced by time.
Reference: [GH93] <author> John V. Guttag and James J. Horning. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <month> 153 </month>
Reference-contexts: For both algorithms, we use intermediate specifications to obtain hierarchical proofs, and we extract general heuristics for finding these intermediate specifications. We also use the Larch tools <ref> [GH93] </ref> to verify the proof for Fischer's algorithm, building on the work by Soylemez [Soy94], formalizing the basic model and techniques in the Larch Shared Language (LSL), and verifying the proofs using an enhanced version of the Larch Prover (LP) [GG91, Pog95]. This elaborates on work described in [LSGL94]. <p> it may be sufficient to simply point out the particular step that fails, but as the program derives more of the proof for itself, it becomes less clear what is useful to a human reader in order to correct the proof. 24 In this thesis, we use the Larch tools <ref> [GH93] </ref> to formalize and verify proofs that corre-spond closely with proofs that we do without automated tools.
Reference: [GHS83] <author> R.G. Gallager, </author> <title> P.A. Humblet, and P.M. Spira. A distributed algorithm for minimum-weight spanning trees. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(1) </volume> <pages> 66-77, </pages> <month> January </month> <year> 1983. </year>
Reference-contexts: A much more ambitious study would be to attempt to analyze a more complex and subtle practical algorithm such as the distributed minimum spanning tree algorithm of Gallager, Humblet, and Spira <ref> [GHS83] </ref>. Welch, Lamport, and Lynch gave a rigorous and detailed, and very lengthy, analysis of this algorithm [WLL88], but it did not include a performance analysis.
Reference: [Haa81] <author> Volkmar Haase. </author> <title> Real-time behavior of programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-7(5):494-501, </volume> <month> September </month> <year> 1981. </year>
Reference-contexts: Their use of simulations, however, is more restricted, and they did not address how timing properties, specifically, can be approached systematically. Many others, including Haase <ref> [Haa81] </ref>, Tel [Tel88], Shaw [Sha89], Harel, Lichtenstein, and Pnueli [HLP90], Alur and Dill [AD90], and Shankar and Lam [SL87, Sha92], also use models that incorporate timing information into the state, but none of them use simulations in their proofs.
Reference: [HLP90] <author> Eyal Harel, Orna Lichtenstein, and Amir Pnueli. </author> <title> Explicit clock temporal logic. </title> <booktitle> In Proceedings of the Fifth IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 402-413, </pages> <address> Philadelphia, PA, June 1990. </address> <publisher> IEEE Computer Science Press. </publisher>
Reference-contexts: Their use of simulations, however, is more restricted, and they did not address how timing properties, specifically, can be approached systematically. Many others, including Haase [Haa81], Tel [Tel88], Shaw [Sha89], Harel, Lichtenstein, and Pnueli <ref> [HLP90] </ref>, Alur and Dill [AD90], and Shankar and Lam [SL87, Sha92], also use models that incorporate timing information into the state, but none of them use simulations in their proofs. Shankar uses a model almost identical to ours, except that there are no explicit time passage steps. <p> More recently, Alur and Henzinger [AH89] presented an approach called temporal quantification, embodied by their new logic, TPTL. Automatic verification motivated much of the design of recent temporal logics, so an important consideration was that they be decidable. Harel, Lichtenstein, and Pnueli <ref> [HLP90] </ref> presented a decidable restricted explicit clock logic. Alur and Henzinger's TPTL is also decidable, and in another paper [AH90], they explore the trade-off between complexity and expressiveness. All these logics use discrete time (i.e., the natural numbers), since extensions to dense time domains are undecidable.
Reference: [HMP94] <author> Thomas Henzinger, Zohar Manna, and Amir Pnueli. </author> <title> Temporal proof methodologies for timed transition systems. </title> <journal> Information and Computation, </journal> <volume> 112(2) </volume> <pages> 273-337, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Several different approaches to proving timing properties have also been proposed, many of them based on augmented temporal logics. The earliest work used bounded temporal operators [BH81, KVdR83], but scattered examples of an explicit clock approach, presented systematically by Ostroff [Ost89], also can be found. Henzinger, Manna, and Pnueli <ref> [HMP94] </ref> compare these two styles. More recently, Alur and Henzinger [AH89] presented an approach called temporal quantification, embodied by their new logic, TPTL. Automatic verification motivated much of the design of recent temporal logics, so an important consideration was that they be decidable.
Reference: [HT93] <author> Vassos Hadzilacos and Sam Toueg. </author> <title> Fault-tolerant broadcasts and related problems. In Sape Mullender, editor, </title> <journal> Distributed Systems, </journal> <note> chapter 5. Addison-Wesley, second edition, </note> <year> 1993. </year>
Reference-contexts: For many of these, especially the distributed group communication protocols, the correctness guarantees are not always clear, and only recently have there been attempts at stating these more formally <ref> [HT93, FKL95, FvR95, MBRS94] </ref>. Unfortunately, these usually lack performance guarantees, which are essential for communication systems. Stgaard-Andersen, Lynch, and Lampson have recently done a lengthy case study applying simulation methods to communication protocols [SLL93a, SLL93b], but this does not include an analysis of the timing.
Reference: [Jef92] <author> Kevin Jeffay. </author> <title> Scheduling sporadic tasks with shared resources in hard-real-time systems. </title> <booktitle> In Proceedings of the Thirteenth IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 89-99, </pages> <address> Phoenix, AZ, December 1992. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Operating systems, especially distributed operating systems, provide another rich domain for problems and protocols, such as synchronization [KR93] and scheduling <ref> [Jef92, Zho92] </ref> with hard real-time constraints, that might be analyzed using this methodology. For these, and other problems, it is important to characterize not only correctness but also timeliness.
Reference: [KMP93] <author> Yonit Kesten, Zohar Manna, and Amir Pnueli. </author> <title> Temporal verification and simulation and refinement. In A Decade of Concurrency: Reflections and Perspectives, </title> <booktitle> volume 803 of Lecture Notes in Computer Science, </booktitle> <pages> pages 273-346, </pages> <address> REX School/Symposium, Noordwijkerhout, the Netherlands, June 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference: [KR93] <author> Hermann Kopetz and Johannes Reisinge. </author> <title> The non-blocking write protocol nbw: A solution to a real-time synchronization problem. </title> <booktitle> In Proceedings of the Fourteenth Real-Time Systems Symposium, </booktitle> <pages> pages 131-137, </pages> <address> Raleigh-Durham, NC, December 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: A timing analysis of this algorithm, accompanied by a simple, concise proof, would be relevant for practical systems, and also serve as an interesting case study of the methods developed here. Operating systems, especially distributed operating systems, provide another rich domain for problems and protocols, such as synchronization <ref> [KR93] </ref> and scheduling [Jef92, Zho92] with hard real-time constraints, that might be analyzed using this methodology. For these, and other problems, it is important to characterize not only correctness but also timeliness.
Reference: [KVdR83] <author> Ron Koymans, J. Vytopil, and Willem-Paul de Roever. </author> <title> Real-time programming and asynchronous message passing. </title> <booktitle> In Proceedings of the Second Annual ACM 154 Symposium on the Principles of Distributed Computing, </booktitle> <pages> pages 187-197. </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1983. </year>
Reference-contexts: Other methods for modelling timed distributed systems include temporal logic [AL92], process algebras [DS89, Wan91, NS91], and Petri nets [CR83]. Several different approaches to proving timing properties have also been proposed, many of them based on augmented temporal logics. The earliest work used bounded temporal operators <ref> [BH81, KVdR83] </ref>, but scattered examples of an explicit clock approach, presented systematically by Ostroff [Ost89], also can be found. Henzinger, Manna, and Pnueli [HMP94] compare these two styles. More recently, Alur and Henzinger [AH89] presented an approach called temporal quantification, embodied by their new logic, TPTL.
Reference: [LA92] <author> Nancy Lynch and Hagit Attiya. </author> <title> Using mappings to prove timing properties. </title> <journal> Distributed Computing, </journal> <volume> 6(2) </volume> <pages> 121-139, </pages> <year> 1992. </year>
Reference-contexts: More recently, simulation-based techniques have been extended to timed systems, providing a formal and systematic approach to proving timing properties <ref> [LA92, AL92] </ref>. 1 These techniques have been demonstrated on small examples, and the style and difficulty of the proofs are comparable to those of typical inductive assertional arguments. The local nature of the checks suggests that this method may scale well to more complex systems. <p> Guidelines for picking appropriate intermediate specifications would also be very useful. A good methodology will yield modular, hierarchical proofs, with intermediate specifications and simulations that capture the intuition behind the algorithm. Also, the proofs in <ref> [LA92] </ref> are rather lengthy and involve much tedious checking. This seems to be an inevitable consequence of the demand for more formal reasoning. It is important to understand how the length and complexity of the proof increases with the system being studied. <p> General theorems can capture common arguments, and eliminate repetitive work, as well as expose additional structure. For common system components, such as channels, standard transformations may produce simpler intermediate specifications. If simulations are given in a standard form, this too can be exploited. 1 The strong possibilities mappings of <ref> [LA92] </ref> define a simulation. 10 Another promising prospect is the development of automated tools. Automated tools can be used to mechanically verify a proof, which provides added confidence in the correctness of a proof by eliminating the possibility of human error in the manipulation of formal expressions. <p> If the tool is "smart" enough, it may even deduce the desired claim without any guidance. If it cannot, it may provide information indicating its difficulty, which may be helpful in constructing the proof. This thesis builds primarily on the work by Lynch and Attiya <ref> [LA92] </ref>. To describe timed systems, we use a variation of the timed automaton of Merritt, Modugno, and Tuttle [MMT91], which we call the MMT automaton. An MMT automaton consists of an I/O automaton [LT89, LT87], together with a boundmap, which specifies the timing assumptions for the system. <p> In this proof, we also try to encapsulate commonly used arguments in lemmas, to make the proof more modular, and to expose some general principles that may be useful in other proofs. 2 This is different from the timed automaton of [MMT91]. Our terminology also differs from that of <ref> [LA92] </ref>, and reflects later usage, such as in [Lyn93, LSGL94]. 11 Related Work Other models and techniques for handling time and proving timing properties have been developed. <p> However, most examples in literature have analyzed smaller systems, not using simulations, and not proving timing properties|just correctness. This thesis builds chiefly on the work by Lynch and Attiya <ref> [LA92] </ref>, applying their techniques to systems with more actions, and which exhibit a greater variety of behaviors. We are interested in any general methods or heuristics to control the complexity of the proofs, particularly for timing properties, taking advantage of the hierarchical structure of simulation proofs. <p> require that the automaton be input-enabled, that is, for every state s and every input action , there exists a state s 0 such that (s; ; s 0 ) 2 states (A). 28 specify some restrictions on these timed executions [MMT91]; we use a special case of their definition <ref> [LA92, LV91] </ref>, which we call MMT automata. An MMT automaton partitions the actions into tasks, 3 and defines upper and lower bounds on the time it may take to perform each task. A task is considered to be performed by any action in that task. <p> However, this makes it difficult to use some of the methods developed for proving properties of I/O automata; in particular, it is not obvious how to use simulations to prove timing properties for MMT automata. Lynch and Attiya <ref> [LA92] </ref> describe how to incorporate the timing information of an MMT automaton M into the state, yielding an equivalent I/O automaton T of a special form. We call automata derived in this way timed automata. <p> This is equivalent, but notationally more convenient, to the presentation in <ref> [LA92] </ref>, which checks whether tasks of the underlying MMT automaton are enabled. 6 This forces there to be an infinite number of time-passage actions in an admissible timed execution. 32 State reported 2 ftrue; falseg, initially false countdown 2 N, initially k Actions External report Pre: countdown = 0 ^ :reported <p> We show that Counter implements Report if a 1 (k + 1)c 1 and a 2 (k + 1)c 2 . This proof is a slightly revised version of proofs in <ref> [LA92, Soy94, LSGL94] </ref>. We begin by defining a relation f between states of the implementation automaton, in this case Counter, and states of the specification automaton, in this case Report. This is shown in Figure 3-3.
Reference: [Lam74] <author> Leslie Lamport. </author> <title> A new solution of Dijkstra's concurrent programming problem. </title> <journal> Communications of the ACM, </journal> <volume> 17(8) </volume> <pages> 453-455, </pages> <month> August </month> <year> 1974. </year>
Reference-contexts: Thus, this model is quite realistic as well, and a lot of research on distributed algorithms has been done in this context <ref> [Dij65, Lam74, LT87, Gaw92, LS93] </ref>. In this case, the time complexity an algorithm is measured by the number of steps it takes. However, these models cannot be used for systems which use timing restrictions to rule out certain behaviors, and thus achieve simpler or chaaper solutions for some problems. <p> The hybrid algorithm of Lynch and Shavit [LS92] is another possibly instructive example to examine, as are Lamport's "bakery" algorithm <ref> [Lam74] </ref>, and algorithms proposed by Peterson and Fischer [PF77]. A much more ambitious study would be to attempt to analyze a more complex and subtle practical algorithm such as the distributed minimum spanning tree algorithm of Gallager, Humblet, and Spira [GHS83].
Reference: [Lam87] <author> Leslie Lamport. </author> <title> A fast mutual exclusion algorithm. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(1) </volume> <pages> 1-11, </pages> <month> February </month> <year> 1987. </year>
Reference-contexts: We use these simulations, together with invariant assertions, to prove correctness and timing properties of two systems, a simple message-passing protocol due to LeLann, Chang, and Roberts [LeL77, CR79] for leader election on a ring of processes, and Fischer's timing-based mutual exclusion algorithm using a single shared read-write register <ref> [Lam87, Fis85] </ref>. For both algorithms, we use intermediate specifications to obtain hierarchical proofs, and we extract general heuristics for finding these intermediate specifications. <p> Burns and Lynch [BL93] proved that in the asynchronous shared memory model, the mutual exclusion problem for n processes requires at least n atomic read/write shared variables. In this chapter, we examine Fischer's timing-based mutual exclusion algorithm <ref> [Fis85, Lam87] </ref>, using only a single shared variable. In addition to mutual exclusion, we prove an upper bound on the time any process must wait to acquire the resource while it remains unused.
Reference: [Lam91] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <type> Research Report 79, </type> <institution> DEC Systems Research Center, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Lynch and Vaandrager have developed a very general notion of a timed automaton, and they describe a wide variety of simulation-based techniques for this model [LV91, LVarb]. Abadi and Lamport [AL92] demonstrate how timing properties can be expressed using Lamport's Temporal Logic of Actions (TLA) <ref> [Lam91] </ref>, and thus, the methods developed for TLA, including simulations, can be immediately applied. Their use of simulations, however, is more restricted, and they did not address how timing properties, specifically, can be approached systematically.
Reference: [Lam93a] <author> Leslie Lamport. </author> <title> Verification and specification of concurrent programs. In A Decade of Concurrency: Reflections and Perspectives, </title> <booktitle> volume 803 of Lecture Notes in Computer Science, </booktitle> <pages> pages 347-374, </pages> <address> REX School/Symposium, Noord-wijkerhout, the Netherlands, June 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Simulation-based methods have been widely used for verifying safety properties of asynchronous systems, 21 and their value is well established. Lamport <ref> [Lam93a] </ref> and Lampson [Lam93b] have argued that simulation-based and related techniques are the most practical methods available for verifying concurrent systems. 2.3.1 Advantages of Simulation Proofs Like invariants, simulations are usually established by induction on the length of an execution, and the induction step is proved for every possible action.
Reference: [Lam93b] <author> Butler Lampson. </author> <title> Principles for computer system design, </title> <booktitle> 1993. Turing Award Lecture. </booktitle>
Reference-contexts: Safety properties can be expressed as 2 Again, this is a subjective empirical claim supported by many researchers <ref> [LL90, CM88, Lam93b] </ref>. 3 Alpern and Schneider define these precisely in [AS85]. 17 assertions about the states, 4 but liveness properties cannot be. <p> Simulation-based methods have been widely used for verifying safety properties of asynchronous systems, 21 and their value is well established. Lamport [Lam93a] and Lampson <ref> [Lam93b] </ref> have argued that simulation-based and related techniques are the most practical methods available for verifying concurrent systems. 2.3.1 Advantages of Simulation Proofs Like invariants, simulations are usually established by induction on the length of an execution, and the induction step is proved for every possible action.
Reference: [LeL77] <author> Gerard LeLann. </author> <title> Distributed systems, towards a formal approach. </title> <booktitle> In Information Processing 77: Proceedings of the Seventh IFIP World Congress, </booktitle> <pages> pages 155-160, </pages> <address> Toronto, Ontario, </address> <year> 1977. </year>
Reference-contexts: We use these simulations, together with invariant assertions, to prove correctness and timing properties of two systems, a simple message-passing protocol due to LeLann, Chang, and Roberts <ref> [LeL77, CR79] </ref> for leader election on a ring of processes, and Fischer's timing-based mutual exclusion algorithm using a single shared read-write register [Lam87, Fis85]. For both algorithms, we use intermediate specifications to obtain hierarchical proofs, and we extract general heuristics for finding these intermediate specifications. <p> Other wise, u:last (report) ( s:last (report) if s:countdown = 0 s:last (decrement) + s:countdown c 2 if s:countdown &gt; 0 ) 39 40 Chapter 4 LeLann-Chang-Roberts Election Algorithm We now consider a simple asynchronous algorithm by LeLann, Chang and Roberts <ref> [LeL77, CR79] </ref>, which solves the election problem for a ring network in the message passing model. Although the algorithm is asynchronous, we assume bounds on the communication delay and the local step times in order to prove an upper bound on the time to election. <p> We will sometimes treat a queue as the set of its elements, using appropriate notation. 4.3 LeLann-Chang-Roberts Algorithm The automaton LCR in Figure 4-3 expresses a simple protocol proposed by LeLann <ref> [LeL77] </ref>, and improved by Chang and Roberts [CR79], to elect the process with the maximum iden 43 State For each i 2 Z n status i 2 funknown; chosen; reportedg, initially unknown pending i 2 Queues (I), initially a queue with only UID i Actions External leader i Pre: status i
Reference: [LL90] <author> Leslie Lamport and Nancy Lynch. </author> <title> Distributed computing: Models and methods. </title> <editor> In Jan van Leeuwen, editor, </editor> <title> Formal Models and Semantics, </title> <booktitle> volume B of Handbook of Theoretical Computer Science, chapter 18, </booktitle> <pages> pages 1157-1199. </pages> <publisher> Elsevier and MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: This often corresponds naturally with how we might reason informally. However, since a distributed system can exhibit a wide variety of behaviors with little natural structure, it is difficult to 1 This is an empirical observation supported by many researchers in the field <ref> [CM88, LL90, Sch93] </ref>. 16 check that all behaviors have been considered. 2 Furthermore, minor modifications to the algorithm often result in some vastly different behaviors, requiring proofs to be substantially rewritten. <p> Safety properties can be expressed as 2 Again, this is a subjective empirical claim supported by many researchers <ref> [LL90, CM88, Lam93b] </ref>. 3 Alpern and Schneider define these precisely in [AS85]. 17 assertions about the states, 4 but liveness properties cannot be.
Reference: [LS84] <author> Simon Lam and A. Udaya Shankar. </author> <title> Protocol verification via projections. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):325-342, </volume> <month> April </month> <year> 1984. </year>
Reference: [LS92] <author> Nancy Lynch and Nir Shavit. </author> <title> Timing-based mutual exclusion. </title> <booktitle> In Proceedings of the Thirteenth IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 2-11, </pages> <address> Phoenix, Arizona, December 1992. </address> <publisher> IEEE Computer Society Press. </publisher> <pages> 155 </pages>
Reference-contexts: The hybrid algorithm of Lynch and Shavit <ref> [LS92] </ref> is another possibly instructive example to examine, as are Lamport's "bakery" algorithm [Lam74], and algorithms proposed by Peterson and Fischer [PF77].
Reference: [LS93] <author> Nancy Lynch and Boaz Patt-Shamir. </author> <title> Distributed algorithms. Lecture Notes for 6.852. </title> <type> Technical Report MIT/LCS/RSS-20, </type> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, MA 02139, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: Sometimes, even the correctness of the system may depend on these timing properties. Unfortunately, real-time systems often have subtle timing dependencies that are difficult to analyze, and proofs of these properties have typically been ad hoc. (See <ref> [LS93] </ref>, which contains several examples of such proofs.) This thesis develops a methodology for analyzing real-time systems. <p> This greatly simplifies the analysis of distributed systems, and many problems have been studied in this context <ref> [LS93] </ref>. In these models, the time complexity of an algorithm is usually measured by the number of rounds of communication it takes. On the other extreme, asynchronous models make no timing assumptions, forbidding protocols from using any timing information. <p> Thus, this model is quite realistic as well, and a lot of research on distributed algorithms has been done in this context <ref> [Dij65, Lam74, LT87, Gaw92, LS93] </ref>. In this case, the time complexity an algorithm is measured by the number of steps it takes. However, these models cannot be used for systems which use timing restrictions to rule out certain behaviors, and thus achieve simpler or chaaper solutions for some problems.
Reference: [LSGL94] <author> Victor Luchangco, Ekrem Soylemez, Stephen Garland, and Nancy Lynch. </author> <title> Verifying timing properties of concurrent algorithms. In Formal Description Techniques VII: </title> <booktitle> Proceedings of FORTE'94, </booktitle> <pages> pages 259-273, </pages> <address> Berne, Switzerland, Oc-tober 1994. </address> <publisher> IFIP WG6.1, Chapman and Hall. </publisher>
Reference-contexts: This elaborates on work described in <ref> [LSGL94] </ref>. In this proof, we also try to encapsulate commonly used arguments in lemmas, to make the proof more modular, and to expose some general principles that may be useful in other proofs. 2 This is different from the timed automaton of [MMT91]. <p> Our terminology also differs from that of [LA92], and reflects later usage, such as in <ref> [Lyn93, LSGL94] </ref>. 11 Related Work Other models and techniques for handling time and proving timing properties have been developed. Lynch and Vaandrager have developed a very general notion of a timed automaton, and they describe a wide variety of simulation-based techniques for this model [LV91, LVarb]. <p> Our approach is to follow as closely as possible the formal reasoning we already use to convince ourselves, and use a general purpose theorem prover to verify our steps <ref> [SGG + 93, Soy94, LSGL94] </ref>. Engberg, Grtnning, and Lamport [EGL92], and Shankar [Sha93] also take this approach, though Shankar uses PVS rather than LP. Outline of the Thesis The rest of the thesis is organized as follows. <p> We show that Counter implements Report if a 1 (k + 1)c 1 and a 2 (k + 1)c 2 . This proof is a slightly revised version of proofs in <ref> [LA92, Soy94, LSGL94] </ref>. We begin by defining a relation f between states of the implementation automaton, in this case Counter, and states of the specification automaton, in this case Report. This is shown in Figure 3-3. <p> For this to be meaningful, the automata are required to have a now component in their state. This trait is also parameterized by in 1 We are doing concurrent research to use decision procedures to handle time more easily [Pog95]; this was presented in <ref> [LSGL94] </ref>. 80 Bounds: trait includes Time (Time) Bounds tuple of first: Time, last: Time introduces __ + __ : Bounds, Time ! Bounds unbounded : ! Bounds asserts 8 b: Bounds, t: Time b + t = [b.first + t, b.last + t]; unbounded = [0, infinity]; BoundMap (A,b): trait includes
Reference: [LT87] <author> Nancy Lynch and Mark Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <type> Master's thesis, </type> <institution> MIT Dept. of Electrical Engineering and Computer Science, </institution> <address> Cambridge, MA 02139, </address> <month> April </month> <year> 1987. </year> <note> Also, MIT/LCS/TR-387. </note>
Reference-contexts: This thesis builds primarily on the work by Lynch and Attiya [LA92]. To describe timed systems, we use a variation of the timed automaton of Merritt, Modugno, and Tuttle [MMT91], which we call the MMT automaton. An MMT automaton consists of an I/O automaton <ref> [LT89, LT87] </ref>, together with a boundmap, which specifies the timing assumptions for the system. <p> Thus, this model is quite realistic as well, and a lot of research on distributed algorithms has been done in this context <ref> [Dij65, Lam74, LT87, Gaw92, LS93] </ref>. In this case, the time complexity an algorithm is measured by the number of steps it takes. However, these models cannot be used for systems which use timing restrictions to rule out certain behaviors, and thus achieve simpler or chaaper solutions for some problems. <p> the discussion, we omit some structure in the model typically introduced to address some important issues for distributed systems that are not considered in this thesis. 3.1 The I/O Automaton Model All the work in this thesis is done in the context of I/O automata, introduced by Lynch and Tuttle <ref> [LT87] </ref> to describe asynchronous systems. This model is a simple state transition system, where actions of the system label the transitions between states. The actions may be either external or internal.
Reference: [LT89] <author> Nancy Lynch and Mark Tuttle. </author> <title> An introduction to input/output automata. </title> <journal> CWI-Quarterly, </journal> <volume> 2(3) </volume> <pages> 219-246, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: This thesis builds primarily on the work by Lynch and Attiya [LA92]. To describe timed systems, we use a variation of the timed automaton of Merritt, Modugno, and Tuttle [MMT91], which we call the MMT automaton. An MMT automaton consists of an I/O automaton <ref> [LT89, LT87] </ref>, together with a boundmap, which specifies the timing assumptions for the system.
Reference: [LV91] <author> Nancy Lynch and Frits Vaandrager. </author> <title> Forward and backward simulations for timing-based systems. </title> <editor> In J. W. de Bakker, C. Huizing, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Real-Time: Theory in Practice, volume 600 of Lecture Notes in Computer Science, </booktitle> <pages> pages 397-446, </pages> <booktitle> REX Workshop, Mook, </booktitle> <address> the Netherlands, </address> <month> June </month> <year> 1991. </year> <note> Springer-Verlag. Also, MIT/LCS/TM-458. </note>
Reference-contexts: Lynch and Vaandrager have developed a very general notion of a timed automaton, and they describe a wide variety of simulation-based techniques for this model <ref> [LV91, LVarb] </ref>. Abadi and Lamport [AL92] demonstrate how timing properties can be expressed using Lamport's Temporal Logic of Actions (TLA) [Lam91], and thus, the methods developed for TLA, including simulations, can be immediately applied. <p> require that the automaton be input-enabled, that is, for every state s and every input action , there exists a state s 0 such that (s; ; s 0 ) 2 states (A). 28 specify some restrictions on these timed executions [MMT91]; we use a special case of their definition <ref> [LA92, LV91] </ref>, which we call MMT automata. An MMT automaton partitions the actions into tasks, 3 and defines upper and lower bounds on the time it may take to perform each task. A task is considered to be performed by any action in that task. <p> Start: If s 2 start (A) then there exists some u 2 start (B) such that f (s; u). 8 This is called a weak timed forward simulation in <ref> [LV91, LVarb, Lyn93] </ref>. 35 Step: If f (s; u) for reachable states s and u of A and B, and s ! A s 0 , then there exists some u 0 such that f (s 0 ; u 0 ) and there is some execution fragment of B from u
Reference: [LVara] <author> Nancy Lynch and Frits Vaandrager. </author> <title> Forward and backward simulations| Part I: </title> <journal> Untimed systems. Information and Computation, </journal> <note> to appear. Also, MIT/LCS/TM-486.b. </note>
Reference-contexts: Note that this relationship is not symmetric; B may allow behaviors that A will not exhibit. Two automata are equivalent if each implements the other. Simulations provide a powerful method to prove that one automaton implements another. There are many variations of simulations <ref> [LVara, LVarb] </ref>, but in this thesis, we only need one of the simplest, the timed forward simulation. 8 Formally, if A and B are timed automata then a timed forward simulation from A to B is a relation f between states (A) and states (B) such that: Time: If f (s;
Reference: [LVarb] <author> Nancy Lynch and Frits Vaandrager. </author> <title> Forward and backward simulations| Part II: </title> <journal> Timing-based systems, </journal> <note> to appear. Submitted for publication. Also, MIT/LCS/TM-487.b. </note>
Reference-contexts: Lynch and Vaandrager have developed a very general notion of a timed automaton, and they describe a wide variety of simulation-based techniques for this model <ref> [LV91, LVarb] </ref>. Abadi and Lamport [AL92] demonstrate how timing properties can be expressed using Lamport's Temporal Logic of Actions (TLA) [Lam91], and thus, the methods developed for TLA, including simulations, can be immediately applied. <p> Note that this relationship is not symmetric; B may allow behaviors that A will not exhibit. Two automata are equivalent if each implements the other. Simulations provide a powerful method to prove that one automaton implements another. There are many variations of simulations <ref> [LVara, LVarb] </ref>, but in this thesis, we only need one of the simplest, the timed forward simulation. 8 Formally, if A and B are timed automata then a timed forward simulation from A to B is a relation f between states (A) and states (B) such that: Time: If f (s; <p> Start: If s 2 start (A) then there exists some u 2 start (B) such that f (s; u). 8 This is called a weak timed forward simulation in <ref> [LV91, LVarb, Lyn93] </ref>. 35 Step: If f (s; u) for reachable states s and u of A and B, and s ! A s 0 , then there exists some u 0 such that f (s 0 ; u 0 ) and there is some execution fragment of B from u <p> The MMT automaton model used in this thesis is adequate only for expressing "hard" time bounds which usually characterize real implementations. Lynch and Vaandrager have defined a more general timed automaton model <ref> [LVarb] </ref> to specify systems which have a more complex relationship between timing and state. However, little work has been done to develop a methodology for these more 101 general automata, and in particular, this has not yet been used to model any systems with soft time bounds.
Reference: [Lyn89a] <author> Nancy Lynch. </author> <title> A hundred impossiblility proofs for distributed computing. </title> <booktitle> In Proceedings of the Eighth Annual ACM Symposium on the Principles of Distributed Computing, </booktitle> <pages> pages 1-27, </pages> <address> Edmonton, Alberta, </address> <month> August </month> <year> 1989. </year> <note> ACM Press. Also, MIT/LCS/TM-394. </note>
Reference-contexts: Moreover, research in the asynchronous setting has yielded many impossibility results, usually giving lower bounds on the resources required to solve certain problems <ref> [Lyn89a, BL93] </ref>. Many of these results arise in the context of fault-tolerance, where the system is required to solve the problem, even though components may fail in some specified fashion.
Reference: [Lyn89b] <author> Nancy Lynch. </author> <title> Multivalued possibilities mappings. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <title> Stepwise Refinement of Distributed Sys 156 tems: Models, Formalism, Correctness, </title> <booktitle> volume 430 of Lecture Notes in Com--puter Science, </booktitle> <pages> pages 519-543, </pages> <booktitle> REX Workshop, Mook, </booktitle> <address> The Netherlands, </address> <month> June </month> <year> 1989. </year> <note> Springer-Verlag. Also, MIT/LCS/TM-422. </note>
Reference: [Lyn93] <author> Nancy Lynch. </author> <title> Simulation techniques for proving properties of real-time systems. In A Decade of Concurrency: Reflections and Perspectives, </title> <booktitle> volume 803 of Lecture Notes in Computer Science, </booktitle> <pages> pages 375-424, </pages> <address> REX School/Symposium, Noordwijkerhout, the Netherlands, </address> <month> June </month> <year> 1993. </year> <note> Springer-Verlag. Also, MIT/LCS/TM-494. </note>
Reference-contexts: Our terminology also differs from that of [LA92], and reflects later usage, such as in <ref> [Lyn93, LSGL94] </ref>. 11 Related Work Other models and techniques for handling time and proving timing properties have been developed. Lynch and Vaandrager have developed a very general notion of a timed automaton, and they describe a wide variety of simulation-based techniques for this model [LV91, LVarb]. <p> Start: If s 2 start (A) then there exists some u 2 start (B) such that f (s; u). 8 This is called a weak timed forward simulation in <ref> [LV91, LVarb, Lyn93] </ref>. 35 Step: If f (s; u) for reachable states s and u of A and B, and s ! A s 0 , then there exists some u 0 such that f (s 0 ; u 0 ) and there is some execution fragment of B from u <p> For example, the mutual exclusion automata in Chapter 5 have a set of state variables and actions for each process, but the proof does not depend on the number of processes. 100 <ref> [Lyn93] </ref> for Dijkstra's mutual exclusion algorithm [Dij65] should be an informative test of the enhancements made to the Larch tools. The hybrid algorithm of Lynch and Shavit [LS92] is another possibly instructive example to examine, as are Lamport's "bakery" algorithm [Lam74], and algorithms proposed by Peterson and Fischer [PF77].
Reference: [MBRS94] <author> Dalia Malki, Ken Birman, Aleta Ricciardi, and Andre Schiper. </author> <title> Uniform actions in asynchronous distributed systems. </title> <booktitle> In Proceedings of Thirteenth Annual ACM Symposium on Principles of Distributed Computing. </booktitle> <publisher> ACM Press, </publisher> <month> August </month> <year> 1994. </year> <note> Also, CORNELLCS:TR94-1447. </note>
Reference-contexts: For many of these, especially the distributed group communication protocols, the correctness guarantees are not always clear, and only recently have there been attempts at stating these more formally <ref> [HT93, FKL95, FvR95, MBRS94] </ref>. Unfortunately, these usually lack performance guarantees, which are essential for communication systems. Stgaard-Andersen, Lynch, and Lampson have recently done a lengthy case study applying simulation methods to communication protocols [SLL93a, SLL93b], but this does not include an analysis of the timing.
Reference: [Mil89] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Series in Computer Science. </booktitle> <publisher> Prentice Hall International, </publisher> <year> 1989. </year>
Reference: [MMT91] <author> Michael Merritt, Francemary Modugno, and Mark Tuttle. </author> <title> Time constrained automata. </title> <editor> In J. C. M. Baeten and J. F. Goote, editors, CONCUR'91: </editor> <booktitle> Second International Conference on Concurrency Theory, volume 527 of Lecture Notes in Computer Science, </booktitle> <pages> pages 408-423, </pages> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: If it cannot, it may provide information indicating its difficulty, which may be helpful in constructing the proof. This thesis builds primarily on the work by Lynch and Attiya [LA92]. To describe timed systems, we use a variation of the timed automaton of Merritt, Modugno, and Tuttle <ref> [MMT91] </ref>, which we call the MMT automaton. An MMT automaton consists of an I/O automaton [LT89, LT87], together with a boundmap, which specifies the timing assumptions for the system. <p> This elaborates on work described in [LSGL94]. In this proof, we also try to encapsulate commonly used arguments in lemmas, to make the proof more modular, and to expose some general principles that may be useful in other proofs. 2 This is different from the timed automaton of <ref> [MMT91] </ref>. Our terminology also differs from that of [LA92], and reflects later usage, such as in [Lyn93, LSGL94]. 11 Related Work Other models and techniques for handling time and proving timing properties have been developed. <p> we distinguished between input and output actions, we would require that the automaton be input-enabled, that is, for every state s and every input action , there exists a state s 0 such that (s; ; s 0 ) 2 states (A). 28 specify some restrictions on these timed executions <ref> [MMT91] </ref>; we use a special case of their definition [LA92, LV91], which we call MMT automata. An MMT automaton partitions the actions into tasks, 3 and defines upper and lower bounds on the time it may take to perform each task.
Reference: [MSST93] <author> Sarit Mukherjee, Debanjan Saha, Manas C. Saksena, and Satish K. Tripathi. </author> <title> A bandwidth allocation scheme for time constrained message transmission on a slotted ring lan. </title> <booktitle> In Proceedings of the Fourteenth Real-Time Systems Symposium, </booktitle> <pages> pages 44-54, </pages> <address> Raleigh-Durham, NC, December 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: For these, and other problems, it is important to characterize not only correctness but also timeliness. Perhaps the most useful application of these techniques lies in the analysis of communication protocols <ref> [CAZ92, MSST93] </ref>, which generally have only informal claims of efficiency and even correctness. For many of these, especially the distributed group communication protocols, the correctness guarantees are not always clear, and only recently have there been attempts at stating these more formally [HT93, FKL95, FvR95, MBRS94].
Reference: [Nip89] <author> Tobias Nipkow. </author> <title> Formal verification of data type refinement. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <title> Stepwise Refinement of Distributed Systems: Models, Formalism, Correctness, </title> <booktitle> volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 561-589, </pages> <booktitle> REX Workshop, Mook, </booktitle> <address> The Netherlands, June 1989. </address> <publisher> Springer-Verlag. </publisher> <pages> 157 </pages>
Reference: [NS91] <author> Xavier Nicollin and Joseph Sifakis. </author> <title> An overview and synthesis on timed process algebras. </title> <editor> In J. W. de Bakker, C. Huizing, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Real-Time: Theory in Practice, volume 600 of Lecture Notes in Computer Science, </booktitle> <pages> pages 526-548, </pages> <booktitle> REX Workshop, Mook, </booktitle> <address> the Netherlands, June 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Shankar uses a model almost identical to ours, except that there are no explicit time passage steps. Other methods for modelling timed distributed systems include temporal logic [AL92], process algebras <ref> [DS89, Wan91, NS91] </ref>, and Petri nets [CR83]. Several different approaches to proving timing properties have also been proposed, many of them based on augmented temporal logics.
Reference: [Ost89] <author> J. Ostroff. </author> <title> Temporal Logic for Real-Time Systems. </title> <booktitle> Advanced Software Development Series. </booktitle> <publisher> Research Studies Press (John Wiley & Sons), </publisher> <year> 1989. </year>
Reference-contexts: Several different approaches to proving timing properties have also been proposed, many of them based on augmented temporal logics. The earliest work used bounded temporal operators [BH81, KVdR83], but scattered examples of an explicit clock approach, presented systematically by Ostroff <ref> [Ost89] </ref>, also can be found. Henzinger, Manna, and Pnueli [HMP94] compare these two styles. More recently, Alur and Henzinger [AH89] presented an approach called temporal quantification, embodied by their new logic, TPTL. <p> Partially Synchronous Models In recent years, there has been an increased interest in introducing a formal notion of time into distributed models (e.g., <ref> [BH81, SL87, DS89, Ost89, Wan91] </ref>), and a methodology for proving timing properties. By taking advantage of timing restrictions, a distributed 19 system designer may opt for simpler, more efficient protocols, which would not be possible in the asynchronous setting.
Reference: [PF77] <author> Gary L. Peterson and Michael J. Fischer. </author> <title> Economical solutions for the critical section problem in a distributed system. </title> <booktitle> In Proceedings of the Ninth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 91-97, </pages> <address> Boulder, CO, May 1977. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The hybrid algorithm of Lynch and Shavit [LS92] is another possibly instructive example to examine, as are Lamport's "bakery" algorithm [Lam74], and algorithms proposed by Peterson and Fischer <ref> [PF77] </ref>. A much more ambitious study would be to attempt to analyze a more complex and subtle practical algorithm such as the distributed minimum spanning tree algorithm of Gallager, Humblet, and Spira [GHS83].
Reference: [Pog95] <author> Anna Pogosyants. </author> <title> Incorporating specialized theories into a general purpose theorem prover. </title> <type> Master's thesis, </type> <institution> MIT Dept. of Electrical Engineering and Computer Science, </institution> <address> Cambridge, MA 02139, </address> <month> February </month> <year> 1995. </year>
Reference-contexts: We also use the Larch tools [GH93] to verify the proof for Fischer's algorithm, building on the work by Soylemez [Soy94], formalizing the basic model and techniques in the Larch Shared Language (LSL), and verifying the proofs using an enhanced version of the Larch Prover (LP) <ref> [GG91, Pog95] </ref>. This elaborates on work described in [LSGL94]. <p> For this to be meaningful, the automata are required to have a now component in their state. This trait is also parameterized by in 1 We are doing concurrent research to use decision procedures to handle time more easily <ref> [Pog95] </ref>; this was presented in [LSGL94]. 80 Bounds: trait includes Time (Time) Bounds tuple of first: Time, last: Time introduces __ + __ : Bounds, Time ! Bounds unbounded : ! Bounds asserts 8 b: Bounds, t: Time b + t = [b.first + t, b.last + t]; unbounded = [0,
Reference: [PS95] <author> Anna Pogosyants and Roberto Segala. </author> <title> Formal verification of timed properties for randomized distributed algorithms. </title> <booktitle> In Proceedings of Fourteenth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: Another important class of systems that cannot be handled within the framework of this thesis are randomized algorithms. Segala [Seg95] has developed a general probabilistic automaton model, which Pogosyants and Segala <ref> [PS95] </ref> have specialized to a probabilistic variant of MMT automata, and have proved some results using this model. Pogosyants is also working on automating these proofs using the Larch tools.
Reference: [Sch93] <author> Fred Schneider. </author> <title> What good are models and what models are good? In Sape Mullender, editor, </title> <journal> Distributed Systems, </journal> <note> chapter 2. Addison-Wesley, second edition, </note> <year> 1993. </year>
Reference-contexts: This often corresponds naturally with how we might reason informally. However, since a distributed system can exhibit a wide variety of behaviors with little natural structure, it is difficult to 1 This is an empirical observation supported by many researchers in the field <ref> [CM88, LL90, Sch93] </ref>. 16 check that all behaviors have been considered. 2 Furthermore, minor modifications to the algorithm often result in some vastly different behaviors, requiring proofs to be substantially rewritten.
Reference: [Seg95] <author> Roberto Segala. </author> <title> Modeling and Verification of Randomized Distributed Real-Time Systems. </title> <type> PhD thesis, </type> <institution> MIT Dept. of Electrical Engineering and Computer Science, </institution> <address> Cambridge, MA 02139, </address> <year> 1995. </year>
Reference-contexts: Furthermore, it is unclear how much additional complexity in the proofs will result with this increased dependency between timing and state. Another important class of systems that cannot be handled within the framework of this thesis are randomized algorithms. Segala <ref> [Seg95] </ref> has developed a general probabilistic automaton model, which Pogosyants and Segala [PS95] have specialized to a probabilistic variant of MMT automata, and have proved some results using this model. Pogosyants is also working on automating these proofs using the Larch tools.
Reference: [SGG + 93] <author> Jtrgen F. Stgaard-Andersen, Stephen J. Garland, John V. Guttag, Nancy A. Lynch, and Anna Pogosyants. </author> <title> Computer-assisted simulation proofs. In Costas Courcoubetis, editor, </title> <booktitle> Computer Aided Verification: Fifth International Conference, CAV'93, volume 697 of Lecture Notes in Computer Science, </booktitle> <pages> pages 305-319, </pages> <address> Elounda, Greece, June/July 1993. </address> <publisher> Springer-Verlag. </publisher> <pages> 158 </pages>
Reference-contexts: Our approach is to follow as closely as possible the formal reasoning we already use to convince ourselves, and use a general purpose theorem prover to verify our steps <ref> [SGG + 93, Soy94, LSGL94] </ref>. Engberg, Grtnning, and Lamport [EGL92], and Shankar [Sha93] also take this approach, though Shankar uses PVS rather than LP. Outline of the Thesis The rest of the thesis is organized as follows. <p> This builds mainly on work done by Soylemez [Soy94] and Stgaard-Andersen, Garland, Guttag, Lynch, and Pogosyants <ref> [SGG + 93] </ref>. In particular, we formally verify the proof in Chapter 5 using LP.
Reference: [Sha89] <author> A. Shaw. </author> <title> Reasoning about time in higher-level language software. </title> <journal> IEEE Trans--actions on Software Engineering, </journal> <volume> SE-15(7):875-889, </volume> <month> July </month> <year> 1989. </year>
Reference-contexts: Their use of simulations, however, is more restricted, and they did not address how timing properties, specifically, can be approached systematically. Many others, including Haase [Haa81], Tel [Tel88], Shaw <ref> [Sha89] </ref>, Harel, Lichtenstein, and Pnueli [HLP90], Alur and Dill [AD90], and Shankar and Lam [SL87, Sha92], also use models that incorporate timing information into the state, but none of them use simulations in their proofs.
Reference: [Sha92] <author> A. Udaya Shankar. </author> <title> A simple assertional proof system for real-time systems. </title> <booktitle> In Proceedings of the Thirteenth IEEE Real-Time Systems Symposium., </booktitle> <pages> pages 167-176, </pages> <address> Phoenix, AZ, December 1992. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Their use of simulations, however, is more restricted, and they did not address how timing properties, specifically, can be approached systematically. Many others, including Haase [Haa81], Tel [Tel88], Shaw [Sha89], Harel, Lichtenstein, and Pnueli [HLP90], Alur and Dill [AD90], and Shankar and Lam <ref> [SL87, Sha92] </ref>, also use models that incorporate timing information into the state, but none of them use simulations in their proofs. Shankar uses a model almost identical to ours, except that there are no explicit time passage steps.
Reference: [Sha93] <author> N. Shankar. </author> <title> Verification of real-time systems using PVS. </title> <booktitle> In Computer Aided Verification: Fifth International Conference, CAV'93, number 697 in Lecture Notes in Computer Science, </booktitle> <pages> pages 280-291, </pages> <address> Elounda, Greece, June/July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Our approach is to follow as closely as possible the formal reasoning we already use to convince ourselves, and use a general purpose theorem prover to verify our steps [SGG + 93, Soy94, LSGL94]. Engberg, Grtnning, and Lamport [EGL92], and Shankar <ref> [Sha93] </ref> also take this approach, though Shankar uses PVS rather than LP. Outline of the Thesis The rest of the thesis is organized as follows. Chapter 2 contains some background and motivation for those unfamiliar with formal reasoning for distributed systems in general, and simulations in particular.
Reference: [SL87] <author> A. Udaya Shankar and Simon Lam. </author> <title> Time-dependent distributed systems: Proving safety, liveness and real-time properties. </title> <journal> Distributed Computing, </journal> <volume> 2(2) </volume> <pages> 61-79, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: Their use of simulations, however, is more restricted, and they did not address how timing properties, specifically, can be approached systematically. Many others, including Haase [Haa81], Tel [Tel88], Shaw [Sha89], Harel, Lichtenstein, and Pnueli [HLP90], Alur and Dill [AD90], and Shankar and Lam <ref> [SL87, Sha92] </ref>, also use models that incorporate timing information into the state, but none of them use simulations in their proofs. Shankar uses a model almost identical to ours, except that there are no explicit time passage steps. <p> Partially Synchronous Models In recent years, there has been an increased interest in introducing a formal notion of time into distributed models (e.g., <ref> [BH81, SL87, DS89, Ost89, Wan91] </ref>), and a methodology for proving timing properties. By taking advantage of timing restrictions, a distributed 19 system designer may opt for simpler, more efficient protocols, which would not be possible in the asynchronous setting.
Reference: [SLL93a] <author> Jtrgen Stgaard-Andersen, Nancy Lynch, and Butler Lampson. </author> <title> Correctness of at-most-once message delivery protocols. In Formal Description Techniques VI: </title> <booktitle> Proceedings of FORTE'93, </booktitle> <pages> pages 387-402, </pages> <address> Boston, MA, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: Unfortunately, these usually lack performance guarantees, which are essential for communication systems. Stgaard-Andersen, Lynch, and Lampson have recently done a lengthy case study applying simulation methods to communication protocols <ref> [SLL93a, SLL93b] </ref>, but this does not include an analysis of the timing. Instead, the performance is typically determined empirically (e.g., [vRHB94]). Performance guarantees, however, are often difficult to characterize, especially "soft" time bounds, that is, bounds that hold in "typical" cases.
Reference: [SLL93b] <author> Jtrgen Stgaard-Andersen, Nancy Lynch, and Butler Lampson. </author> <title> Correctness of communication protocols: A case study. </title> <type> Technical Report MIT/LCS/TR-589, </type> <institution> Laboratory for Computer Science, Massachusetts Institute Technology, </institution> <address> Cambridge, MA 02139, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: Unfortunately, these usually lack performance guarantees, which are essential for communication systems. Stgaard-Andersen, Lynch, and Lampson have recently done a lengthy case study applying simulation methods to communication protocols <ref> [SLL93a, SLL93b] </ref>, but this does not include an analysis of the timing. Instead, the performance is typically determined empirically (e.g., [vRHB94]). Performance guarantees, however, are often difficult to characterize, especially "soft" time bounds, that is, bounds that hold in "typical" cases.
Reference: [Soy94] <author> Ekrem Soylemez. </author> <title> Automatic verification of the timing properties of MMT automata. </title> <type> Master's thesis, </type> <institution> MIT Dept. of Electrical Engineering and Computer Science, </institution> <address> Cambridge, MA 02139, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: For both algorithms, we use intermediate specifications to obtain hierarchical proofs, and we extract general heuristics for finding these intermediate specifications. We also use the Larch tools [GH93] to verify the proof for Fischer's algorithm, building on the work by Soylemez <ref> [Soy94] </ref>, formalizing the basic model and techniques in the Larch Shared Language (LSL), and verifying the proofs using an enhanced version of the Larch Prover (LP) [GG91, Pog95]. This elaborates on work described in [LSGL94]. <p> Our approach is to follow as closely as possible the formal reasoning we already use to convince ourselves, and use a general purpose theorem prover to verify our steps <ref> [SGG + 93, Soy94, LSGL94] </ref>. Engberg, Grtnning, and Lamport [EGL92], and Shankar [Sha93] also take this approach, though Shankar uses PVS rather than LP. Outline of the Thesis The rest of the thesis is organized as follows. <p> We show that Counter implements Report if a 1 (k + 1)c 1 and a 2 (k + 1)c 2 . This proof is a slightly revised version of proofs in <ref> [LA92, Soy94, LSGL94] </ref>. We begin by defining a relation f between states of the implementation automaton, in this case Counter, and states of the specification automaton, in this case Report. This is shown in Figure 3-3. <p> This builds mainly on work done by Soylemez <ref> [Soy94] </ref> and Stgaard-Andersen, Garland, Guttag, Lynch, and Pogosyants [SGG + 93]. In particular, we formally verify the proof in Chapter 5 using LP.
Reference: [Tel88] <author> Gerard Tel. </author> <title> Assertional verification of a timer based protocol. </title> <editor> In Timo Lepisto and Arta Salomaa, editors, </editor> <booktitle> Automata, Languages and Programming: Proceedings of ICALP'88, volume 317 of Lecture Notes in Computer Science, </booktitle> <pages> pages 600-614, </pages> <address> Tampere, Finland, July 1988. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Their use of simulations, however, is more restricted, and they did not address how timing properties, specifically, can be approached systematically. Many others, including Haase [Haa81], Tel <ref> [Tel88] </ref>, Shaw [Sha89], Harel, Lichtenstein, and Pnueli [HLP90], Alur and Dill [AD90], and Shankar and Lam [SL87, Sha92], also use models that incorporate timing information into the state, but none of them use simulations in their proofs.
Reference: [vRHB94] <author> Robbert van Renesse, Takako Hickey, and Ken Birman. </author> <title> Design and performance of Horus: A lightweight group communication system. </title> <type> Technical Re 159 port CORNELLCS:TR94-1442, </type> <institution> Cornell University Department of Computer Science, </institution> <address> Ithaca, NY 14853, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: Unfortunately, these usually lack performance guarantees, which are essential for communication systems. Stgaard-Andersen, Lynch, and Lampson have recently done a lengthy case study applying simulation methods to communication protocols [SLL93a, SLL93b], but this does not include an analysis of the timing. Instead, the performance is typically determined empirically (e.g., <ref> [vRHB94] </ref>). Performance guarantees, however, are often difficult to characterize, especially "soft" time bounds, that is, bounds that hold in "typical" cases. The MMT automaton model used in this thesis is adequate only for expressing "hard" time bounds which usually characterize real implementations.
Reference: [Wan91] <author> Yi Wang. </author> <title> CCS + time = an interleaving model for real time systems. </title> <editor> In J. Leach Albert, B. Monien, and M. Rodriguez Artalejo, editors, </editor> <booktitle> Automata, Languages and Programming: Proceedings of ICALP'91, volume 510 of Lecture Notes in Computer Science, </booktitle> <pages> pages 217-228, </pages> <address> Madrid, Spain, July 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Shankar uses a model almost identical to ours, except that there are no explicit time passage steps. Other methods for modelling timed distributed systems include temporal logic [AL92], process algebras <ref> [DS89, Wan91, NS91] </ref>, and Petri nets [CR83]. Several different approaches to proving timing properties have also been proposed, many of them based on augmented temporal logics. <p> Partially Synchronous Models In recent years, there has been an increased interest in introducing a formal notion of time into distributed models (e.g., <ref> [BH81, SL87, DS89, Ost89, Wan91] </ref>), and a methodology for proving timing properties. By taking advantage of timing restrictions, a distributed 19 system designer may opt for simpler, more efficient protocols, which would not be possible in the asynchronous setting.
Reference: [WLL88] <author> Jennifer Lundelius Welch, Leslie Lamport, and Nancy Lynch. </author> <title> A lattice-structured proof technique applied to a minimum spanning tree algorithm. </title> <booktitle> In Proceedings of the Seventh Annual ACM Symposium on the Principles of Distributed Computing, </booktitle> <pages> pages 28-43, </pages> <address> Toronto, Ontario, </address> <month> August </month> <year> 1988. </year> <note> ACM Press. Also, see MIT/LCS/TM-361. </note>
Reference-contexts: A much more ambitious study would be to attempt to analyze a more complex and subtle practical algorithm such as the distributed minimum spanning tree algorithm of Gallager, Humblet, and Spira [GHS83]. Welch, Lamport, and Lynch gave a rigorous and detailed, and very lengthy, analysis of this algorithm <ref> [WLL88] </ref>, but it did not include a performance analysis. A timing analysis of this algorithm, accompanied by a simple, concise proof, would be relevant for practical systems, and also serve as an interesting case study of the methods developed here.
Reference: [WPD94] <author> Yi Wang, Paul Pettersson, and Mats Daniels. </author> <title> Automatic verification of real-time communicating systems by constraint-solving. In Formal Description Techniques VII: </title> <booktitle> Proceedings of FORTE'94, </booktitle> <pages> pages 243-258, </pages> <address> Berne, Switzerland, </address> <month> October </month> <year> 1994. </year> <booktitle> IFIP WG6.1, </booktitle> <publisher> Chapman and Hall. </publisher>
Reference-contexts: There are many other approaches to automatic verification. For example, Wang, Pet-tersson, and Daniels <ref> [WPD94] </ref> present a method based on solving a system of constraints on the clock variables of a process algebraic specification.
Reference: [Zho92] <author> Hongyi Zhou. </author> <title> Performance effects of information sharing in a distributed multiprocessor real-time scheduler. </title> <booktitle> In Proceedings of the Thirteenth IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 46-55, </pages> <address> Phoenix, AZ, December 1992. </address> <publisher> IEEE Computer Society Press. </publisher> <pages> 160 </pages>
Reference-contexts: Operating systems, especially distributed operating systems, provide another rich domain for problems and protocols, such as synchronization [KR93] and scheduling <ref> [Jef92, Zho92] </ref> with hard real-time constraints, that might be analyzed using this methodology. For these, and other problems, it is important to characterize not only correctness but also timeliness.
References-found: 80

