URL: file://ftp.cs.adelaide.edu.au/pub/Realtime/CRTS-94-01.ps.Z
Refering-URL: http://www.csd.uu.se/~bjornfot/r3.html
Root-URL: 
Email: e-mail: ata@cs.adelaide.edu.au  
Title: Distributed Real-Time Computer Systems  
Author: Atanas Parashkevov 
Address: Adelaide, SA 5005, Australia  
Affiliation: Dept. of Computer Science, Univ. of  
Abstract: Distributed computer systems and real-time computer systems match each other in a number of ways. The nature of the real-time computer systems, which have to react to and process numerous events simultaneously, is inherently concurrent and also those systems are spatially distributed because the devices for interaction with the environment are usually situated at more or less remote locations. Distributed computer systems offer the flexibility, scalability and performance demanded by the new generation of complex real-time applications. Their replicated resources are valuable provision for dependable and safety-critical real-time processing. The primary goal of this report is to study the relevant issues in distributed real-time systems, to uncover the state-of-the-art and then to present a critical view and summarize the problems that are still to be resolved. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Panzieri and R. Davoli: </author> <title> "Real-Time Systems: A Tutorial", </title> <type> Tech. Report UBLCS-93-22, </type> <institution> Laboratory for Computer Science, Univ. of Bologna </institution>
Reference-contexts: They must not be confused with the more general term real-time systems that is used to refer to systems, which correctness depends on both result and time dimensions, at any possible level of abstraction. Several quite thorough introductions and surveys on distributed real-time systems have been recently available <ref> [1, 2, 26] </ref>. Our purpose is not to repeat the work that has already been carried out but rather to provide an overview and evaluation of the state-of-the-art in the area from a slightly different viewpoint|most importantly addressing the challenges of the next generation real-time systems [3]. <p> During a synchronization step it interacts with the outside world for certain actions like shared resource access and inter-task communications. Several different types of tasks must be able to coexist in real-time systems. Firstly, depending on the strictness of associated deadline, there are <ref> [1] </ref>: * hard real-time tasks, for which missing the deadline could lead to a catastrophe (for example, loss of human life) and therefore cannot be tolerated; * soft real-time tasks, for which missing the deadline is critical to the system oper ation, but cannot cause system failure and therefore may be <p> The most important property of real-time communications is the requirement for deterministically bounded message delay <ref> [1] </ref>. Message delay is defined as the amount of time passed between the instant when the source task requested message transmission and the instant when the destination task successfully accepted the message.
Reference: [2] <author> B. Mukherjee, K. Schwan and K. Ghosh: </author> <title> "A Survey of Real-Time Operating Systems", </title> <note> Preliminary draft GIT-CC-93/18, </note> <institution> College of Computing, Georgia Institute of Technology 24 </institution>
Reference-contexts: They must not be confused with the more general term real-time systems that is used to refer to systems, which correctness depends on both result and time dimensions, at any possible level of abstraction. Several quite thorough introductions and surveys on distributed real-time systems have been recently available <ref> [1, 2, 26] </ref>. Our purpose is not to repeat the work that has already been carried out but rather to provide an overview and evaluation of the state-of-the-art in the area from a slightly different viewpoint|most importantly addressing the challenges of the next generation real-time systems [3].
Reference: [3] <author> J. Stankovic: </author> <title> "Distributed Real-Time Computing: The Next Generation", </title> <type> Tech. Report UM-CS-1992-001, </type> <institution> Dept. of Computer Science, Univ. of Massachusetts at Amherst </institution>
Reference-contexts: Our purpose is not to repeat the work that has already been carried out but rather to provide an overview and evaluation of the state-of-the-art in the area from a slightly different viewpoint|most importantly addressing the challenges of the next generation real-time systems <ref> [3] </ref>. These systems are to run in very complex, highly dynamic and even nondeterministic environments and still have to satisfy timing constraints and to show predictable behaviour. 2. GENERAL MODEL OF A REAL-TIME SYSTEM In the untimed computer systems there is only the notion of algorithms and their specification.
Reference: [4] <author> J. Stankovic, D. Niehaus and K. Ramamritham: "SpringNet: </author> <title> A Scalable Architecture For High Performance, Predictable and Distributed Real-Time Computing", </title> <type> Tech. Report UM-CS-1991-074, </type> <institution> Dept. of Computer Science, Univ. of Massachusetts at Amherst </institution>
Reference-contexts: A review of several well-known distributed real-time computer systems, for example, Spring <ref> [4] </ref>, MARS [5], HARTS [6], shows use of custom processor boards containing CPU, MMU, local RAM and a communication interface. Some designs introduce multiprocessor nodes with dedicated processors for communications, system and application software in order to minimize the possible interference and therefore improve the predictability of the whole system.
Reference: [5] <author> W. Schwabl, J. Reisinger and G. Grunsteidl: </author> <title> "A Survey of MARS", Research Report No. </title> <type> 16/89, </type> <institution> Institut fur Technische Informatik, Technische Universitat Wien </institution>
Reference-contexts: A review of several well-known distributed real-time computer systems, for example, Spring [4], MARS <ref> [5] </ref>, HARTS [6], shows use of custom processor boards containing CPU, MMU, local RAM and a communication interface. Some designs introduce multiprocessor nodes with dedicated processors for communications, system and application software in order to minimize the possible interference and therefore improve the predictability of the whole system. <p> Most distributed real-time systems use current LAN technology for inter-node communications employing a real-time protocol such as TDMA in case of an Ethernet bus <ref> [5] </ref> and only one of the reviewed systems|HARTS|relies on point-to-point communications in a multiprocessor network [6]. The LAN approach has the advantages of predictable communication bandwidth and delays and easy message broadcast. However, it has a fixed overall bandwidth|10 MB/s in case of standard Ethernet|and provides limited scalability. <p> Faults can be classified depending on the assumptions made about the possible be-haviour of the faulty component. One approach is to assume fail-silent component behav 17 ior, that is, it can only provide either the correct result or no result at all <ref> [5] </ref>. However, such a behavior is quite difficult to guarantee even using the most rigorous self-checking techniques. A much more realistic assumption is to make no restrictions to the possible behavior of a failed component, which is known as a Byzantine fault.
Reference: [6] <author> K. G. Shin: </author> <title> "HARTS: A Distributed Real-Time Architecture", </title> <journal> IEEE Computer Vol. </journal> <volume> 24, No. 5, </volume> <month> May </month> <year> 1991, </year> <pages> pp. 25-35 </pages>
Reference-contexts: A review of several well-known distributed real-time computer systems, for example, Spring [4], MARS [5], HARTS <ref> [6] </ref>, shows use of custom processor boards containing CPU, MMU, local RAM and a communication interface. Some designs introduce multiprocessor nodes with dedicated processors for communications, system and application software in order to minimize the possible interference and therefore improve the predictability of the whole system. <p> Most distributed real-time systems use current LAN technology for inter-node communications employing a real-time protocol such as TDMA in case of an Ethernet bus [5] and only one of the reviewed systems|HARTS|relies on point-to-point communications in a multiprocessor network <ref> [6] </ref>. The LAN approach has the advantages of predictable communication bandwidth and delays and easy message broadcast. However, it has a fixed overall bandwidth|10 MB/s in case of standard Ethernet|and provides limited scalability.
Reference: [7] <author> D. D. Kandlur, K. G. Shin and D. Ferrari: </author> <title> "Real-time Communications in Multi-hop networks", </title> <booktitle> Proc. 11 th Int. Conf. on Distributed Computer Systems, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 300-307 </pages>
Reference-contexts: The point-to-point approach has potentially a higher bandwidth and fault-tolerance due to redundant data paths as well as better scalability, but broadcast protocols are expensive to implement. Little research has been done on real-time issues of point-to-point communications in regular topology message-passing networks <ref> [7] </ref>. It must be noted that there is a growing range of single chip VLSI computing nodes intended for easy building of message-passing multiprocessors of any scale. That includes 5 the industry-standard INMOS transputer [8], CMU-Intel iWarp [9], Texas Instruments TMS32C040 and others. <p> EDF scheduling uses dynamic priorities and the task with closer deadline is given higher priority. Both RM and EDF algorithms have been proven to be optimal fixed and dynamic priority algorithms respectively, in case of preemptive scheduling. RM and EDF scheduling policies have somehow mutually complement nature <ref> [7] </ref>. RM algorithm is static, has lower achievable processor utilization ratio of about 70% [21], but is also fully predictable, i.e. it is known which tasks will miss their deadlines in case of a transient overload. <p> As a result, a number of researchers have tried to combine the advantages of both algorithms using both dynamic deadline scheduling and preassigned fixed priorities <ref> [7, 22, 23] </ref>. Another enhancement of the EDF policy takes into account resource requirements of real-time tasks for making a non-interfering schedule [24]. Resource contention is a major concern in RM scheduling, too. <p> The most of the up-to-date research on real-time communications is connection-oriented, that is, a connection between the source and destination nodes is set up before the actual communication occurs. This is the basic idea behind the real-time channel communication abstraction, proposed and studied by the Tenet Group <ref> [7, 26, 27, 36] </ref>. A real-time channel is a unidirectional connection between two nodes in the network that is realized with two protocols: for channel establishment and for message transmission.
Reference: [8] <author> D. May, R. Shepherd and P. Thompson: </author> <title> "The T9000 Transputer", INMOS Limited, </title> <year> 1991 </year>
Reference-contexts: It must be noted that there is a growing range of single chip VLSI computing nodes intended for easy building of message-passing multiprocessors of any scale. That includes 5 the industry-standard INMOS transputer <ref> [8] </ref>, CMU-Intel iWarp [9], Texas Instruments TMS32C040 and others. Although targeted at different markets in parallel, systolic and DSP processing, they are attractive choices for real-time computing as well, providing an inexpensive, modular, easily scalable hardware base. 4.
Reference: [9] <author> S. Borkar, et al.: </author> <title> "iWarp: An Integrated Solution to High-Speed Parallel Computing", </title> <booktitle> in Proc. Supercomputing, </booktitle> <year> 1988 </year>
Reference-contexts: It must be noted that there is a growing range of single chip VLSI computing nodes intended for easy building of message-passing multiprocessors of any scale. That includes 5 the industry-standard INMOS transputer [8], CMU-Intel iWarp <ref> [9] </ref>, Texas Instruments TMS32C040 and others. Although targeted at different markets in parallel, systolic and DSP processing, they are attractive choices for real-time computing as well, providing an inexpensive, modular, easily scalable hardware base. 4.
Reference: [10] <author> J. S. Ostroff: </author> <title> "Formal Methods for the Specification and Design of Real-Time Safety Critical Systems", </title> <journal> J. of Systems and Software, </journal> <volume> Vol. 18, No. 1, </volume> <month> April </month> <year> 1992, </year> <pages> pp. 33-60 </pages>
Reference-contexts: Finally, the formal specification can significantly improve and accelerate the development stage of the system through functional decomposition or even compilation to a lower level programming language. A thorough survey of the current formal specification methods in real-time systems is given in <ref> [10] </ref>. Most of the methods, if not all, are derived from classical untimed approaches by introducing the notion of time. This leads to a great variety of methods evolving from each untimed approach.
Reference: [11] <author> C. A. R. Hoare: </author> <title> "Communicating Sequential Processes", </title> <publisher> Prentice Hall International UK Ltd, </publisher> <year> 1985 </year>
Reference-contexts: Most of the methods, if not all, are derived from classical untimed approaches by introducing the notion of time. This leads to a great variety of methods evolving from each untimed approach. For example, there are at least two real-time flavours of untimed CSP <ref> [11] </ref>: Timed CSP [12] and CSP+T [13]. It is very difficult to differentiate and evaluate the practical benefits of such very closely related methods.
Reference: [12] <author> J. Davies and S. Schneider: </author> <title> "A brief history of Timed CSP", Programming Research Group, </title> <publisher> Oxford University, </publisher> <address> UK </address>
Reference-contexts: Most of the methods, if not all, are derived from classical untimed approaches by introducing the notion of time. This leads to a great variety of methods evolving from each untimed approach. For example, there are at least two real-time flavours of untimed CSP [11]: Timed CSP <ref> [12] </ref> and CSP+T [13]. It is very difficult to differentiate and evaluate the practical benefits of such very closely related methods.
Reference: [13] <author> J. J. Zic: </author> <title> "Using CSP+T to Describe a Timing Constrained Stop-and-Wait Protocol", </title> <type> Tech. Report 9303, </type> <institution> School of Computer Science and Engineering, Univ. of New South Wales, Australia </institution>
Reference-contexts: This leads to a great variety of methods evolving from each untimed approach. For example, there are at least two real-time flavours of untimed CSP [11]: Timed CSP [12] and CSP+T <ref> [13] </ref>. It is very difficult to differentiate and evaluate the practical benefits of such very closely related methods.
Reference: [14] <author> C. Shen, K. Ramamritham and J. Stankovic: </author> <title> "Resource Reclaiming in Multiprocessor Real-Time Systems", </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> Vol. 4, No. 4, </volume> <month> April </month> <year> 1993, </year> <pages> pp. 282-397 </pages>
Reference-contexts: As a result, the available resources are quite inefficiently used. This problem has already been addressed in <ref> [14] </ref>, but in a different context. Most current real-time schedulers use static estimation of t max for the whole task code, obtained at compile-time. While this is the only possible strategy with static scheduling, in case of dynamic scheduling a more flexible approach may be used.
Reference: [15] <author> J. Hooman: </author> <title> "Specification and Compositional Verification of Real-Time Systems", </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> No. 558, </volume> <publisher> Springer-Verlag, </publisher> <year> 1991 </year>
Reference-contexts: The whole family of real-time formal specification techniques can be divided into the following main streams: * Related to Petri nets|Time Petri nets, Timed Petri nets, etc.; * Related to temporal logic|metric temporal logic <ref> [15] </ref>, timed transition model/re al-time temporal logic (TTM/RTTL), etc.; * Related to process algebras|Timed CSP, CSP+T, CCSR, Timed CCS, etc.; * Related to other formal methods|modified Hoare triples [15], extensions to Z specification language [16], etc.; * Hybrid models. There are several weaknesses present in the current timed formal methods. <p> the following main streams: * Related to Petri nets|Time Petri nets, Timed Petri nets, etc.; * Related to temporal logic|metric temporal logic <ref> [15] </ref>, timed transition model/re al-time temporal logic (TTM/RTTL), etc.; * Related to process algebras|Timed CSP, CSP+T, CCSR, Timed CCS, etc.; * Related to other formal methods|modified Hoare triples [15], extensions to Z specification language [16], etc.; * Hybrid models. There are several weaknesses present in the current timed formal methods. First of all, there is a large variety of such methods and numerous models of time introduced.
Reference: [16] <author> A. Coombes and J. McDermid: </author> <title> "Specifying temporal requirements for distributed real-time systems in Z", </title> <journal> Software Eng. Journal, </journal> <month> September </month> <year> 1993 </year>
Reference-contexts: to Petri nets|Time Petri nets, Timed Petri nets, etc.; * Related to temporal logic|metric temporal logic [15], timed transition model/re al-time temporal logic (TTM/RTTL), etc.; * Related to process algebras|Timed CSP, CSP+T, CCSR, Timed CCS, etc.; * Related to other formal methods|modified Hoare triples [15], extensions to Z specification language <ref> [16] </ref>, etc.; * Hybrid models. There are several weaknesses present in the current timed formal methods. First of all, there is a large variety of such methods and numerous models of time introduced. <p> These extensions are often insufficient to cover statements like "event X must happen as late as possible", "event X can/must happen at some future time" <ref> [16] </ref>. The natural solution could be seen in an uninhibited, down-top design 9 "from scratch" of a new timed specification method where time is a central issue and not an addendum. Finally, there is a substantial gap between the research in real-time formal methods and their practical application in industry.
Reference: [17] <author> A. Stoyenko: </author> <title> "The Evolution and State-of-the-Art of Real-Time Languages", </title> <journal> J. of Systems and Software, </journal> <volume> Vol. 18, </volume> <year> 1992, </year> <pages> pp. 61-83 </pages>
Reference-contexts: Real-time programming languages and compilers The next step after the specification is actual implementation and coding of the real-time application. This has to be done by means of some programming language. A real-time programming language should <ref> [17] </ref>: * Be independent of underlying hardware and OS; * Possess all modern programming language features such as strong typing, structured programming, modularity with well defined interfaces allowing separate compilation, high level of code reuseability, etc.; * Provide necessary primitives for low-level access and control over hardware fea tures such as <p> In practice, however, there are few languages that are really close to the "ideal" one and many of those are still under development. The most noticeable achievements in that direction are PEARL, DPS/DICON, Ada-83, FLEX and Real-Time EUCLID <ref> [17] </ref>. The early proposals for real-time extensions in Ada-9X are also very promising. The ultimate role of the real-time programming language is to ensure robust, predictable, reliable execution of every single task in the real-time application. This is to 10 be done at compile time. <p> This post-compilation stage could be used to evaluate the number of processors required to guarantee the timely execution of all hard real-time tasks and a predefined percentage of soft real-tasks in the application. As shown in <ref> [17] </ref>, real-time programming languages is an active research area with promising recent developments. In practice, however, many real-time application engineers use modifications of non-real-time languages (assembly, C, Forth), compilers lacking worst case execution time analysis and no schedulability analysis at all.
Reference: [18] <author> V. Nirkhe and W. Pugh: </author> <title> "A Partial Evaluator for the Maruti Hard Real-Time System", </title> <journal> J. Real-Time Systems, </journal> <volume> Vol. 5, No. 1, </volume> <month> March </month> <year> 1993, </year> <pages> pp. 13-30 25 </pages>
Reference-contexts: An example for such real-time language is Real-Time EUCLID. Other researchers believe that this is a too strong restriction for the practical programming. They introduce more sophisticated compile-time techniques, such as partial evaluation <ref> [18] </ref>, in order to relax those restrictions. In order to estimate the overall execution time of a general task, synchronization steps must also be taken into account.
Reference: [19] <author> R. A. Finkel: </author> <title> "An operating systems vade mecum", </title> <publisher> Prentice Hall, </publisher> <year> 1986 </year>
Reference-contexts: This leads to a hard and time consuming hand-tuning of the real-time application with compromised robustness. 5.3 Real-time scheduling One of the definitions of an operating systems (OS) is that "it is a set of algorithms that allocate resources to processes" <ref> [19] </ref>. In general purpose, multi-process, multi-user OS like UNIX the aim of those algorithms is to make efficient use of the available resources and to minimize the average response time to user interaction.
Reference: [20] <author> V. F. Wolfe, S. Davidson and I. Lee: "RTC: </author> <title> Language Support for Real-Time Con-currency", </title> <journal> J. Real-Time Systems, </journal> <volume> Vol. 5, No. 1, </volume> <month> March </month> <year> 1993, </year> <pages> pp. 63-87 </pages>
Reference-contexts: That means that apart from the pure computation time, all the intermediate synchronization times have to be bounded by the underlying operating system and known to the compiler. This has led to the introduction of new language concepts for supporting explicit resource declaration and access, like in RTC <ref> [20] </ref>. The purpose of that support is to further assist the compiler in guaranteeing the predicted t max .
Reference: [21] <author> C. L. Liu and J. W. Layland: </author> <title> "Scheduling Algorithms for Multiprogramming in a Hard Real-Time Environment", </title> <journal> J. of the ACM, </journal> <volume> Vol. 20, No. 1, </volume> <year> 1973, </year> <pages> pp. 46-61 </pages>
Reference-contexts: A simple taxonomy of real-time scheduling algorithms as a tradeoff between quality and complexity is shown in Figure 4. The most important work on local real-time scheduling was carried out more than two decades ago by Liu and Leiland <ref> [21] </ref>. They introduced two scheduling algorithms| Rate Monotonic (RM) and Earliest Deadline First (EDF). RM algorithm is a static, fixed priority scheme, where the shorter the task period the higher the task priority. EDF scheduling uses dynamic priorities and the task with closer deadline is given higher priority. <p> Both RM and EDF algorithms have been proven to be optimal fixed and dynamic priority algorithms respectively, in case of preemptive scheduling. RM and EDF scheduling policies have somehow mutually complement nature [7]. RM algorithm is static, has lower achievable processor utilization ratio of about 70% <ref> [21] </ref>, but is also fully predictable, i.e. it is known which tasks will miss their deadlines in case of a transient overload.
Reference: [22] <author> S.-C. Cheng and J. Stankovic: </author> <title> Scheduling Algorithms for Hard Real-Time Systems|A Brief Survey", Real-Time Systems, </title> <publisher> IEEE Press, </publisher> <year> 1988, </year> <pages> pp. 150-173 </pages>
Reference-contexts: As a result, a number of researchers have tried to combine the advantages of both algorithms using both dynamic deadline scheduling and preassigned fixed priorities <ref> [7, 22, 23] </ref>. Another enhancement of the EDF policy takes into account resource requirements of real-time tasks for making a non-interfering schedule [24]. Resource contention is a major concern in RM scheduling, too. <p> Distributed real-time scheduling is much more complicated than the local one. In the most general case, finding an optimal schedule for a multiprocessor distributed environment is a NP-hard problem for both static and dynamic scheduling <ref> [22] </ref>. Therefore many 13 researchers focus on applying restrictive, sub-optimal solutions usually involving heuristics. There are two most common approaches used in distributed scheduling of single, independent tasks with specific resource requirements.
Reference: [23] <author> F. Miller: </author> <title> "Predictive Deadline Multi-Processing", </title> <journal> ACM Oper. Systems Review, </journal> <volume> Vol. 24, No. 4, </volume> <month> October </month> <year> 1990, </year> <pages> pp. 52-63 </pages>
Reference-contexts: As a result, a number of researchers have tried to combine the advantages of both algorithms using both dynamic deadline scheduling and preassigned fixed priorities <ref> [7, 22, 23] </ref>. Another enhancement of the EDF policy takes into account resource requirements of real-time tasks for making a non-interfering schedule [24]. Resource contention is a major concern in RM scheduling, too.
Reference: [24] <author> W. Zhao, K. Ramamritham and J. Stankovic: </author> <title> "Preemptive Scheduling Under Time and Resource Constraints", </title> <journal> IEEE Trans. on Computers, </journal> <volume> Vol. 36, No. 8, </volume> <month> August </month> <year> 1987, </year> <pages> pp. 949-960 </pages>
Reference-contexts: As a result, a number of researchers have tried to combine the advantages of both algorithms using both dynamic deadline scheduling and preassigned fixed priorities [7, 22, 23]. Another enhancement of the EDF policy takes into account resource requirements of real-time tasks for making a non-interfering schedule <ref> [24] </ref>. Resource contention is a major concern in RM scheduling, too. The effect of preventing a higher priority task from execution by a lower priority one is called priority inversion.
Reference: [25] <author> J. Stankovic, K. Ramamritham and S. Cheng: </author> <title> "Evaluation of a Flexible Task Scheduling Algorithm for Distributed Hard Real-Time Processing", </title> <journal> IEEE Trans. on Computers, </journal> <volume> Vol. 34, No. 12, </volume> <month> December </month> <year> 1985, </year> <pages> pp. 1130-1143 </pages>
Reference-contexts: A certain task allocation algorithm that takes into account those pre-allocated resources is applied only to soft real-time tasks and its performance is often defined as the percentage of tasks meeting their timing constraints. The work presented in <ref> [25] </ref> is an example that exploits both these approaches to a full extent. Effectively, the above approach to soft real-time tasks is a best-effort technique combined with task acception/rejection by the scheduling policy that enables some small exception routine to be called if the task is rejected.
Reference: [26] <author> K. Shin and P. Ramanatham: </author> <title> "Real-Time Computing: A New Discipline of Computer Science and Engineering", </title> <journal> Proc. of the IEEE, </journal> <volume> Vol. 82, No. 1, </volume> <month> January </month> <year> 1994, </year> <pages> pp. 6-24 </pages>
Reference-contexts: They must not be confused with the more general term real-time systems that is used to refer to systems, which correctness depends on both result and time dimensions, at any possible level of abstraction. Several quite thorough introductions and surveys on distributed real-time systems have been recently available <ref> [1, 2, 26] </ref>. Our purpose is not to repeat the work that has already been carried out but rather to provide an overview and evaluation of the state-of-the-art in the area from a slightly different viewpoint|most importantly addressing the challenges of the next generation real-time systems [3]. <p> Other requirements to real-time communications include: * Broadcast facility (one-to-many communications); * High real-time traffic bandwidth; * Fault-tolerance; * Scalabity. Real-time communications can be carried out in two general types of networks: multiple access and point-to-point <ref> [26] </ref>. In multiple access networks processors share access to a common information carrier, e.g. Ethernet, real-time buses, token-rings. There are simple and reliable real-time access protocols such as TDMA that essentially reserve a time slot (bandwidth) for each node thus guaranteeing bounded worst-case message delay. <p> The most of the up-to-date research on real-time communications is connection-oriented, that is, a connection between the source and destination nodes is set up before the actual communication occurs. This is the basic idea behind the real-time channel communication abstraction, proposed and studied by the Tenet Group <ref> [7, 26, 27, 36] </ref>. A real-time channel is a unidirectional connection between two nodes in the network that is realized with two protocols: for channel establishment and for message transmission. <p> Computer systems fail because of the errors caused by the occurrence of faults. However, not every fault may lead to system failure and fault-tolerance could be informally defined as the ability of the computer system to preserve its functionality despite the presence of faults <ref> [26] </ref>. It is important to point out that no system is immune to all possible faults but rather to a limited, predetermined set. An important measure of the reliability of computer systems is the probability of failure. <p> The logical clocks in a distributed computer system are said to be synchronized if for each pair of clocks the corresponding logical time values differ from each other by less than a certain predefined bound <ref> [26, 29] </ref>. Clock synchrony can be achieved by both software and hardware methods. Software clock synchronization is performed by a system process running at each node in the system and performing a clock synchronization procedure.
Reference: [27] <institution> The Tenet Group: "Recent and Current Research", University of California, Berkeley and International Computer Science Institute, </institution> <month> April </month> <year> 1994 </year>
Reference-contexts: The most of the up-to-date research on real-time communications is connection-oriented, that is, a connection between the source and destination nodes is set up before the actual communication occurs. This is the basic idea behind the real-time channel communication abstraction, proposed and studied by the Tenet Group <ref> [7, 26, 27, 36] </ref>. A real-time channel is a unidirectional connection between two nodes in the network that is realized with two protocols: for channel establishment and for message transmission.
Reference: [28] <author> L. Sha, R. Rajkumar and J. Lehoczky: </author> <title> "Priority Inheritance Protocols: An Approach to Real-Time Synchronization", </title> <journal> IEEE Trans. on Computers, </journal> <volume> Vol. 39, No. 9, </volume> <month> September </month> <year> 1990, </year> <pages> pp. 1175-1185 </pages>
Reference-contexts: The effect of preventing a higher priority task from execution by a lower priority one is called priority inversion. An algorithm called priority ceiling protocol has been developed to restrict the number of priority violations to one per task activation <ref> [28] </ref>. Distributed real-time scheduling is much more complicated than the local one. In the most general case, finding an optimal schedule for a multiprocessor distributed environment is a NP-hard problem for both static and dynamic scheduling [22]. Therefore many 13 researchers focus on applying restrictive, sub-optimal solutions usually involving heuristics.
Reference: [29] <author> N. Suri, M. Hugue and C. Walter: </author> <title> "Synchronization Issues in Real-Time Systems", </title> <journal> Proc. of the IEEE, </journal> <volume> Vol. 82, No. 1, </volume> <month> January </month> <year> 1994, </year> <pages> pp. 41-53 </pages>
Reference-contexts: The logical clocks in a distributed computer system are said to be synchronized if for each pair of clocks the corresponding logical time values differ from each other by less than a certain predefined bound <ref> [26, 29] </ref>. Clock synchrony can be achieved by both software and hardware methods. Software clock synchronization is performed by a system process running at each node in the system and performing a clock synchronization procedure. <p> The above deterministic synchronization techniques are often classified as approximate agreement methods <ref> [29] </ref>, because the nodes end up with different, but approximately close and synchronized clock values. Another deterministic synchronization approach is called exact agreement, which differs in that all nodes elect one of the clocks as an "exact" clock and adjust their local logical clock to its value. <p> Hardware clock synchronization involves dedicated circuitry attached to the logical clock oscillator in each node and monitoring its inputs connected to other nodes' oscillators. A phase detection unit is used that controls the local oscillator and keeps the clock skew comparable to the period of single oscillation <ref> [29] </ref>. Certainly, no software technique can achieve such a level of synchronization. The major drawback of hardware synchronization is the need for a dedicated, fully interconnected network between the nodes in the system for the propagation of clock signals.
Reference: [30] <author> L. Lamport and P. Melliar-Smith: </author> <title> "Synchronizing Clocks in Presence of Faults", </title> <journal> J. of the ACM, </journal> <volume> Vol. 32, No. 1, </volume> <month> January </month> <year> 1985, </year> <pages> pp. 52-78 </pages>
Reference: [31] <author> L. Lindelius and N. Lynch: </author> <title> "An Upper and Lower Bound for Clock Synchronization", </title> <journal> Information and Control, </journal> <volume> Vol. 62, </volume> <year> 1984, </year> <pages> pp. 190-204 </pages>
Reference-contexts: The accuracy of deterministic synchronization techniques depends mainly on the message exchange delays in the distributed computer system. The closer the minimum and maximum possible delays the tighter synchronization can be achieved <ref> [31] </ref>. However, not all kinds of networks can guarantee low variance in message delays. When beyond a certain limit, this may lead to a unacceptable synchronization accuracy and as a consequence make deterministic techniques useless. This is when the probabilistic synchronization comes in place.
Reference: [32] <author> F. Cristian: </author> <title> "Probabilistic Clock Synchronization", </title> <journal> Distributed Computing, </journal> <volume> No. 3, </volume> <year> 1989, </year> <pages> pp. 146-158 </pages>
Reference-contexts: This is when the probabilistic synchronization comes in place. The original idea behind it is a master-slave query protocol that is repeated until the "slave" logical clock is read with required accuracy <ref> [32] </ref>. Such a scheme is successfully applicable even in unbounded random message delay network given that the distribution of possible message delays is known. Probabilistic clock synchronization can be used to achieve synchrony with any predefined probability.
Reference: [33] <author> M. Utting and P. Kearney: </author> <title> "Specification Issues for Real-Time Behavior of RISC Processors", </title> <booktitle> Proc. of the Australasian Workshop on Parallel and Real-Time Systems, </booktitle> <month> July </month> <year> 1994, </year> <pages> pp. 400-411 </pages>
Reference-contexts: Not all of the today's commercially available microprocessors are equally suitable for real-time processing either|the complex pipelined ALU and FPU units can make the prediction of precise execution times a hard job even for simple code sequences <ref> [33] </ref>. A review of several well-known distributed real-time computer systems, for example, Spring [4], MARS [5], HARTS [6], shows use of custom processor boards containing CPU, MMU, local RAM and a communication interface.
Reference: [34] <author> J. Lala and R. Harper: </author> <title> "Architectural Principles for Safety-Critical Real-Time Applications", </title> <journal> Proc. of the IEEE, </journal> <volume> Vol. 82, No. 1, </volume> <month> January </month> <year> 1994, </year> <pages> pp. 25-40 </pages>
Reference-contexts: However, redundancy alone does not guarantee a more fault tolerant system|it must be coupled with a concise and efficient redundancy management policy addressing the issues of voting, synchronization and consensus achievement, error propagation and others <ref> [34] </ref>. Most algorithms for fault tolerance consist of two parts. The first one does the fault detection by some kind of system monitoring and detects and signals the fault occurrence. <p> There are important requirements for proper operation of this redundancy scheme: all channels must have identical initial states, it must be ensured that they receive equal input values and all the channels must produce the output values before the deadline <ref> [34, 35] </ref>. The decision unit can employ either exact or approximate agreement in order to determine the correct result from the multiple channel outputs. The exact agreement technique is based on bit-wise comparison of the output values. <p> In addition, it is quite difficult to define the thresholds in a formal way and verify their correctness. In contrast to this, exact agreement can be formally specified and verified analytically, subject to well-defined requirements to the channel operation <ref> [34] </ref>. The voting algorithm in the decision unit normally employs a Byzantine-resilient protocol for masking out the random hardware faults. However, it cannot assist in detecting of so called common mode faults, which occur when multiple channels suffer from similar errors almost instantaneously. <p> Different implementation decisions for each channel|choice of hardware, programming language, algorithms and application code|help to reduce the probability of common faults. Design diversity is widely applied in real-world applications such as the latest Boeing-777 aircraft flight control computer <ref> [34] </ref>. Certainly, fault-tolerance techniques in real-time computer systems are not restricted to the higher channel level. They can be present within the boundaries of each channel, too.
Reference: [35] <author> A. Avizienis and J.-C. Laprie: </author> <title> "Dependable Computing: From Concepts to Design Diversity", </title> <journal> Proc. of the IEEE, </journal> <volume> Vol. 74, No. 5, </volume> <month> May </month> <year> 1986, </year> <pages> pp. 629-638 26 </pages>
Reference-contexts: There are important requirements for proper operation of this redundancy scheme: all channels must have identical initial states, it must be ensured that they receive equal input values and all the channels must produce the output values before the deadline <ref> [34, 35] </ref>. The decision unit can employ either exact or approximate agreement in order to determine the correct result from the multiple channel outputs. The exact agreement technique is based on bit-wise comparison of the output values.
Reference: [36] <author> D. Ferrari and D. Verma: </author> <title> "A Scheme for Real-Time Channel Establishment in Wide--Area Networks", </title> <journal> IEEE J. on Selected Areas in Communication, </journal> <volume> Vol. 8, No. 3, </volume> <month> April </month> <year> 1990, </year> <pages> pp. 368-379 </pages>
Reference-contexts: The schedulability analysis is then responsible to verify that those probabilities can be guaranteed. So far, probabilistic scheduling has not been applied to tasks and nodes, but only to messages and channels in a WAN <ref> [36, 37] </ref>. Another degree of complexity is added to real-time scheduling when a task group instead of a single task is to be executed in response to an external event. <p> The most of the up-to-date research on real-time communications is connection-oriented, that is, a connection between the source and destination nodes is set up before the actual communication occurs. This is the basic idea behind the real-time channel communication abstraction, proposed and studied by the Tenet Group <ref> [7, 26, 27, 36] </ref>. A real-time channel is a unidirectional connection between two nodes in the network that is realized with two protocols: for channel establishment and for message transmission.
Reference: [37] <author> H. Zhang and E. Knightly: </author> <title> "Providing End-to-End Statistical Performance Guarantees with Bounding Interval Dependent Stochastic Models", </title> <note> To appear in Proceedings of ACM Sigmetrics'94 </note>
Reference-contexts: The schedulability analysis is then responsible to verify that those probabilities can be guaranteed. So far, probabilistic scheduling has not been applied to tasks and nodes, but only to messages and channels in a WAN <ref> [36, 37] </ref>. Another degree of complexity is added to real-time scheduling when a task group instead of a single task is to be executed in response to an external event.
Reference: [38] <author> Ed. by S. Mullender: </author> <title> "Distributed Systems", Second edition, </title> <publisher> ACM Press frontier series, </publisher> <year> 1993 </year>
Reference-contexts: The set of all steps between a stimulus and response in a real-time system is often called real-time transaction <ref> [38] </ref>. The nature of the real-time environment imposes timing constraints to 3 the transaction processing and these constraints become an essential part of the real-time system specification. The real-time system normally supports some kind of interface to a human operator who is able to control its operation. <p> If all the timing requirements are soft, then the system is classified as a soft real-time system. Besides the real-time system specification, there are two other assumptions that must be counted for|the load hypothesis and the fault hypothesis <ref> [38] </ref>. The load hypothesis states the maximum frequency or rate at which each stimulus may occur. This gives an 4 estimation of the maximum load that the real-time computer system will experience during its operation.
Reference: [39] <author> D. Jensen and J. Northcutt: </author> <title> "Alpha: a non-proprietary OS for Large, Complex, Distributed Real-Time Systems", </title> <booktitle> Proc. of 2 nd IEEE Workshop on Experimental Distributed Systems, </booktitle> <month> October </month> <year> 1990, </year> <pages> pp. </pages> <month> xii+119, </month> <pages> 35-41 27 </pages>
Reference-contexts: Note that this is a rather generic set of properties. In many real-time applications and operating systems only a subset of these properties are used. For example, only a limited number of researchers address the value function v (t) in their work <ref> [39] </ref>. In most simplistic case a real-time task can be thought of as an atomic action in that it just gets the input values, performs some computation on them and comes out with 6 a result without data exchange in its intermediate states|Figure 3a.
References-found: 39

