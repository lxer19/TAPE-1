URL: ftp://www.cs.rutgers.edu/pub/technical-reports/dcs-tr-335.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Email: fpstocks,ryder,xxzhangg@cs.rutgers.edu  landi@scr.siemens.com  
Title: Comparing Flow and Context Sensitivity on the Modification-side-effects Problem  
Author: Philip A. Stocks Barbara G. Ryder William A. Landi Sean Zhang 
Keyword: Interprocedural data-flow analysis, modification side effects, flow sensitivity, context sensitivity, empirical study, pointer aliasing.  
Address: Piscataway, NJ 08855, USA  755 College Road East Princeton, NJ 08540, USA  
Affiliation: Dept of Computer Science Hill Center, Busch Campus Rutgers University  Siemens Corporate Research  
Abstract: Precision and scalability are two desirable, yet often conflicting, features of data-flow analyses. This paper reports on a case study of the modification-side-effects problem for C in the presence of pointers from the perspective of contrasting the flow and context sensitivity of the solution procedure with respect to precision and scalability. The results show that the cost of precision of flow- and context-sensitive analysis is not always prohibitive, and that the precision of flow- and context-insensitive analysis is substantially better than worst-case estimates and can be sufficient for certain applications. Program characteristics that affect the performance of data-flow analysis are identified. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Banning. </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> In Conference Record of the Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 29-41, </pages> <month> Jan. </month> <year> 1979. </year>
Reference-contexts: These applications need an efficient method to report program-point-specific side-effect information in the presence of pointers in order to handle modern languages such as C, C ++ , Fortran90 and Java; this requires practical inter-procedural side-effect analysis with pointers, something that previous techniques for FORTRAN cannot supply <ref> [1, 4, 5, 2] </ref>. A family of side-effect analyses for C, parameterized by the pointer aliasing algorithm used, has been defined [11, 10]; these analyses vary in the cost/precision tradeoffs for the calculated side-effect information. <p> For example, given char *a="moose"; the front-end does not recognize a <ref> [1] </ref> as a fixed location. Fortunately, this kind of declaration doesn't occur very often. <p> Frequently, the MOD C (FSAlias) analysis is within the same order of magnitude as the compile time, though, of course, there are dramatic exceptions such as flex and nethack. RELATED WORK Banning <ref> [1] </ref> first accomplished the decomposition of the MOD problem for FORTRAN (and other languages where aliasing is imposed only by call-by-reference parameter passing); he separated out two flow-insensitive calculations on the call multigraph: one for side effects and a separate one for aliases.
Reference: [2] <author> M. Burke. </author> <title> An interval-based approach to exhaustive and incremental interprocedural data flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 341-395, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: These applications need an efficient method to report program-point-specific side-effect information in the presence of pointers in order to handle modern languages such as C, C ++ , Fortran90 and Java; this requires practical inter-procedural side-effect analysis with pointers, something that previous techniques for FORTRAN cannot supply <ref> [1, 4, 5, 2] </ref>. A family of side-effect analyses for C, parameterized by the pointer aliasing algorithm used, has been defined [11, 10]; these analyses vary in the cost/precision tradeoffs for the calculated side-effect information. <p> Cooper and Kennedy [4, 5] further decomposed the problem into side effects on global variables and side effects accomplished through parameter passing. Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition <ref> [2] </ref>. All of this work targeted the programming model of Fortran and related languages with no pointer usage.
Reference: [3] <author> J.-D. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: All of this work targeted the programming model of Fortran and related languages with no pointer usage. Choi, Burke, and Carini mention an interprocedural modification-side-effects algorithm for languages with pointers based on their flow-sensitive pointer aliasing technique <ref> [3, 12] </ref>; it is difficult to compare this work to theirs, because they gave no description of their algorithm and offered no implementation results. time Another approach to side-effect analysis is to perform an in--terprocedural pointer aliasing algorithm and then identify all variables experiencing side effects at indirect stores through a
Reference: [4] <author> K. Cooper. </author> <title> Analyzing aliases of reference formal parameters. </title> <booktitle> In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 281-290, </pages> <month> Jan. </month> <year> 1985. </year>
Reference-contexts: These applications need an efficient method to report program-point-specific side-effect information in the presence of pointers in order to handle modern languages such as C, C ++ , Fortran90 and Java; this requires practical inter-procedural side-effect analysis with pointers, something that previous techniques for FORTRAN cannot supply <ref> [1, 4, 5, 2] </ref>. A family of side-effect analyses for C, parameterized by the pointer aliasing algorithm used, has been defined [11, 10]; these analyses vary in the cost/precision tradeoffs for the calculated side-effect information. <p> RELATED WORK Banning [1] first accomplished the decomposition of the MOD problem for FORTRAN (and other languages where aliasing is imposed only by call-by-reference parameter passing); he separated out two flow-insensitive calculations on the call multigraph: one for side effects and a separate one for aliases. Cooper and Kennedy <ref> [4, 5] </ref> further decomposed the problem into side effects on global variables and side effects accomplished through parameter passing. Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition [2].
Reference: [5] <author> K. Cooper and K. Kennedy. </author> <title> Interprocedural side-effect analysis in linear time. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 57-66, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: These applications need an efficient method to report program-point-specific side-effect information in the presence of pointers in order to handle modern languages such as C, C ++ , Fortran90 and Java; this requires practical inter-procedural side-effect analysis with pointers, something that previous techniques for FORTRAN cannot supply <ref> [1, 4, 5, 2] </ref>. A family of side-effect analyses for C, parameterized by the pointer aliasing algorithm used, has been defined [11, 10]; these analyses vary in the cost/precision tradeoffs for the calculated side-effect information. <p> RELATED WORK Banning [1] first accomplished the decomposition of the MOD problem for FORTRAN (and other languages where aliasing is imposed only by call-by-reference parameter passing); he separated out two flow-insensitive calculations on the call multigraph: one for side effects and a separate one for aliases. Cooper and Kennedy <ref> [4, 5] </ref> further decomposed the problem into side effects on global variables and side effects accomplished through parameter passing. Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition [2].
Reference: [6] <author> N. D. Jones and S. Muchnick. </author> <title> Flow analysis and optimization of lisp-like structures. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 102-131. </pages> <publisher> Prentice Hall, </publisher> <year> 1982. </year>
Reference-contexts: All data-flow algorithms must deal with the a priori unbounded nature of recursive data structures. The F SAlias algorithm uses Jones and Muchnick's k-limiting definition for recursive data structures, which truncates names to at most k distinct field references <ref> [6] </ref>. The F IAlias algorithm only computes aliases for names appearing in the program context and thus, has no need for k-limiting. Aggregate data structures are handled specially. Arrays are treated as a single variable with the assumption that pointer arithmetic stays within array bounds.
Reference: [7] <author> N. D. Jones and S. S. Muchnick. </author> <title> A flexible approach to in-terprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <month> Jan. </month> <year> 1982. </year>
Reference-contexts: For interprocedural data-flow analysis, not all paths in the usual graph representation correspond to real program executions. A realizable path is a path on which every procedure returns to the call site which invoked it <ref> [7, 9, 15, 20] </ref>.
Reference: [8] <author> W. Landi and B. G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: The calling context approximation used in the MOD C schema is the same as that of the F SAlias algorithm in <ref> [8, 9] </ref>. The data-flow fact that x and y are aliased at program point n is represented by an unordered pair h x,y i at n. <p> effects to the independent fields of a structure are distinguished. 4 Reaching aliases were referred to by the term assumed aliases in [9]. 5 For aliasing in programs restricted to one level of dereferencing, the RA sets are of cardinality one and can be used to obtain a precise solution <ref> [8] </ref>. MOD C SCHEMA The MOD C schema defines a family of algorithms which solve for modification side effects to fixed locations at program points.
Reference: [9] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximation algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedingsof the SIG-PLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The empirical experiments reported involve two MOD C methods [10] with different component pointer aliasing algorithms. MOD C (FSAlias) uses a flow-sensitive, calling-context-sensitive approximation algorithm for pointer-induced aliasing <ref> [9] </ref>. <p> For interprocedural data-flow analysis, not all paths in the usual graph representation correspond to real program executions. A realizable path is a path on which every procedure returns to the call site which invoked it <ref> [7, 9, 15, 20] </ref>. <p> The calling context approximation used in the MOD C schema is the same as that of the F SAlias algorithm in <ref> [8, 9] </ref>. The data-flow fact that x and y are aliased at program point n is represented by an unordered pair h x,y i at n. <p> Aggregate data structures are handled specially. Arrays are treated as a single variable with the assumption that pointer arithmetic stays within array bounds. Side effects to the independent fields of a structure are distinguished. 4 Reaching aliases were referred to by the term assumed aliases in <ref> [9] </ref>. 5 For aliasing in programs restricted to one level of dereferencing, the RA sets are of cardinality one and can be used to obtain a precise solution [8]. <p> statement is constructed from CMOD by summarizing over all contexts. 6 Non-visibles in procedure p are locations which map to no identifier in the scope of p; for example, a non-visible may be a local variable of the calling procedure which is accessible in the called procedure through an alias <ref> [9, 10] </ref>. EMPIRICAL RESULTS This section describes and discusses execution results of the MOD C analyses. The MOD C , F SAlias, and F IAlias analysis code is implemented in C and analyzes a reduced version of C that excludes pointers to functions, exception handling, setjump and longjump.
Reference: [10] <author> W. Landi, B. G. Ryder, P. Stocks, S. Zhang, and R. Al-tucher. </author> <title> A schema for interprocedural side effect analysis with pointer aliasing. </title> <type> Technical Report DCS-TR-336, </type> <institution> Department of Computer Science, Rutgers University, </institution> <month> Aug. </month> <year> 1997. </year> <note> see http://www.prolangs.rutgers.edu. </note>
Reference-contexts: A family of side-effect analyses for C, parameterized by the pointer aliasing algorithm used, has been defined <ref> [11, 10] </ref>; these analyses vary in the cost/precision tradeoffs for the calculated side-effect information. Using different combinations of flow-sensitive and/or context-sensitive analyses, it is possible to offer a range of cost/precision levels for different applications. <p> This paper reports on the first comparative experiments on the effectiveness of flow and context sensitivity in data-flow analyses as measured on interprocedural side-effect analysis of C codes (i.e., MOD C ). The empirical experiments reported involve two MOD C methods <ref> [10] </ref> with different component pointer aliasing algorithms. MOD C (FSAlias) uses a flow-sensitive, calling-context-sensitive approximation algorithm for pointer-induced aliasing [9]. <p> A full description of each subproblem and its corresponding data-flow equations is available in <ref> [11, 10] </ref>. ALIAS (n; RA) is the pointer alias solution. DIRMOD (n) captures all variable expressions which occur on the left hand side of the assignment at program point n (e.g., *p=, v=). At an assignment n, CondLMOD widens DIRMOD (n) to include the effects of aliasing. <p> statement is constructed from CMOD by summarizing over all contexts. 6 Non-visibles in procedure p are locations which map to no identifier in the scope of p; for example, a non-visible may be a local variable of the calling procedure which is accessible in the called procedure through an alias <ref> [9, 10] </ref>. EMPIRICAL RESULTS This section describes and discusses execution results of the MOD C analyses. The MOD C , F SAlias, and F IAlias analysis code is implemented in C and analyzes a reduced version of C that excludes pointers to functions, exception handling, setjump and longjump. <p> The MOD C analysis counts an assignment to a structure, say with three fields, as one fixed-location modification, and not as three. Counting is more complex when considering the total locations modified by a procedure; details can be found in <ref> [10] </ref>, but are not required for the data presented here. Precision at Through-dereference Statements Figures 2 (a) and 2 (b) report the average numbers of fixed locations modified per assignment through a pointer dereference for both MOD C (FSAlias) and MOD C (FIAlias).
Reference: [11] <author> W. Landi, B. G. Ryder, and S. Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 56-67, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: A family of side-effect analyses for C, parameterized by the pointer aliasing algorithm used, has been defined <ref> [11, 10] </ref>; these analyses vary in the cost/precision tradeoffs for the calculated side-effect information. Using different combinations of flow-sensitive and/or context-sensitive analyses, it is possible to offer a range of cost/precision levels for different applications. <p> A full description of each subproblem and its corresponding data-flow equations is available in <ref> [11, 10] </ref>. ALIAS (n; RA) is the pointer alias solution. DIRMOD (n) captures all variable expressions which occur on the left hand side of the assignment at program point n (e.g., *p=, v=). At an assignment n, CondLMOD widens DIRMOD (n) to include the effects of aliasing.
Reference: [12] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. Choi, M. Burke, and P. Carini. </author> <title> Pointer-induced aliasing: A clarification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(9) </volume> <pages> 67-70, </pages> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: All of this work targeted the programming model of Fortran and related languages with no pointer usage. Choi, Burke, and Carini mention an interprocedural modification-side-effects algorithm for languages with pointers based on their flow-sensitive pointer aliasing technique <ref> [3, 12] </ref>; it is difficult to compare this work to theirs, because they gave no description of their algorithm and offered no implementation results. time Another approach to side-effect analysis is to perform an in--terprocedural pointer aliasing algorithm and then identify all variables experiencing side effects at indirect stores through a
Reference: [13] <author> T. J. Marlowe and B. G. Ryder. </author> <title> Properties of data flow frameworks: A unified model. </title> <journal> Acta Informatica, </journal> <volume> 28 </volume> <pages> 121-163, </pages> <year> 1990. </year>
Reference-contexts: BASIC CONCEPTS Iterative data-flow analysis is a fixed-point calculation for recursive equations defined on a graph representing a program that safely approximates the meet over all paths solution of a data-flow problem <ref> [13] </ref>. For interprocedural data-flow analysis, not all paths in the usual graph representation correspond to real program executions. A realizable path is a path on which every procedure returns to the call site which invoked it [7, 9, 15, 20].
Reference: [14] <author> T. J. Marlowe, B. G. Ryder, and M. Burke. </author> <title> Defining flow sensitivity for data flow problems. </title> <type> Technical Report LCSR-TR-249, </type> <institution> Laboratory for Computer Science Research Technical Report, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: In contrast, an algorithm is flow-insensitive if it propagates information solely on call multigraphs, using summary information for each procedure which can be gathered without exploring paths in that procedure <ref> [14] </ref>.
Reference: [15] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reachability. </title> <booktitle> In ConferenceRecord of the Twenty-second Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: For interprocedural data-flow analysis, not all paths in the usual graph representation correspond to real program executions. A realizable path is a path on which every procedure returns to the call site which invoked it <ref> [7, 9, 15, 20] </ref>. <p> ICFG) and differences in the counting of side effects to individual structure fields. Interprocedural distributive finite subset problems can be solved using a graph reachability technique on an exploded call graph of the program <ref> [15] </ref>. Capture of calling context is not an issue here since the problems being solved are of a form such that reachability in each procedure can be analyzed once for each parameter, regardless of calling context.
Reference: [16] <author> E. Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 13-22, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: theirs, because they gave no description of their algorithm and offered no implementation results. time Another approach to side-effect analysis is to perform an in--terprocedural pointer aliasing algorithm and then identify all variables experiencing side effects at indirect stores through a pointer (i.e., at through-dereference statements) using the aliases found <ref> [16, 21] </ref>. This is often used as an empirical test of the precision of the alias solution obtained. Ruf [16] compared the effect of context-sensitivity (or its lack) on a flow-sensitive points-to algorithm. <p> This is often used as an empirical test of the precision of the alias solution obtained. Ruf <ref> [16] </ref> compared the effect of context-sensitivity (or its lack) on a flow-sensitive points-to algorithm. Most of his reported data is with respect to the difference in precision of the points-to solution, with and without context information.
Reference: [17] <author> E. Ruf. </author> <title> Partitioning data flow analysis using types. </title> <booktitle> In Conference Record of the Twenty-fourth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 15-26, </pages> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: In summary, the empirical results show the utility of both analyses for specific applications and demonstrate the precision gains from sensitivity in the aliases and thus in the side-effect information obtained. Recent work in partitioning programs for analyses <ref> [21, 17] </ref> yields hope that analyses of varying cost and precision can be applied to different parts of a program to obtain desired data-flow information at practical cost.
Reference: [18] <author> M. Shapiro and S. Horwitz. </author> <title> The effects of the precision of pointer analysis. </title> <booktitle> In to appear in Proceedings of the Fourth International Symposium on Static Analysis (SAS'97), </booktitle> <month> Sept. </month> <year> 1997. </year>
Reference-contexts: Several flow- and context-insensitive algorithms for M OD (P ), differing by the points-to analysis used, have been profiled in <ref> [18] </ref>. This study shares the philosophy of the empirical results presented here, in that the effects of pointer aliasing on applications are reported.
Reference: [19] <author> M. Shapiro and S. Horwitz. </author> <title> Fast and accurate flow-insensitive points-to analysis. </title> <booktitle> In Conference Record of the Twenty-fourth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: The intersection of the solutions generated by different, safe analyses for the same problem must also be safe, and may be closer to the real solution. Recently, Shapiro and Horwitz used this idea with several flow- and context-insensitive points-to analysis algorithms <ref> [19] </ref>. This approach needs more exploratory experimentation. The final topic is to explore more fully the kind of program construct and programming style that foils data-flow analysis. Perhaps the availability of precise, flow- and context-sensitive data-flow analysis would be sufficient motivation to change programming practice, language design and programmers' habits.
Reference: [20] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 189-234. </pages> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: For interprocedural data-flow analysis, not all paths in the usual graph representation correspond to real program executions. A realizable path is a path on which every procedure returns to the call site which invoked it <ref> [7, 9, 15, 20] </ref>.
Reference: [21] <author> S. Zhang, B. G. Ryder, and W. Landi. </author> <title> Program decomposition for pointer aliasing: A step towards practical analyses. </title> <booktitle> In Proceedings of the 4th Annual ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 81-92, </pages> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: The empirical experiments reported involve two MOD C methods [10] with different component pointer aliasing algorithms. MOD C (FSAlias) uses a flow-sensitive, calling-context-sensitive approximation algorithm for pointer-induced aliasing [9]. MOD C (FIAlias) uses a flow-insensitive, calling-context-insensitive approximation algorithm for pointer-induced aliasing which is similar to the algorithm described in <ref> [21] </ref>. 1 MOD C (FSAlias) reports program-point-specific possible modification side effects; the results are more precise than information derivable using the same alias summary for all statements of a procedure. <p> In summary, the empirical results show the utility of both analyses for specific applications and demonstrate the precision gains from sensitivity in the aliases and thus in the side-effect information obtained. Recent work in partitioning programs for analyses <ref> [21, 17] </ref> yields hope that analyses of varying cost and precision can be applied to different parts of a program to obtain desired data-flow information at practical cost. <p> theirs, because they gave no description of their algorithm and offered no implementation results. time Another approach to side-effect analysis is to perform an in--terprocedural pointer aliasing algorithm and then identify all variables experiencing side effects at indirect stores through a pointer (i.e., at through-dereference statements) using the aliases found <ref> [16, 21] </ref>. This is often used as an empirical test of the precision of the alias solution obtained. Ruf [16] compared the effect of context-sensitivity (or its lack) on a flow-sensitive points-to algorithm. <p> Where to now? This study raises three topics for further exploration. The first is how to incorporate flow and context sensitivity into analysis of very large programs. Zhang et al. <ref> [21] </ref> report on a program decomposition strategy, where the alias relation induces a partitioning of the assignment statements involving pointer variables.
References-found: 21

