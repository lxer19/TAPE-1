URL: http://kirmes.inferenzsysteme.informatik.tu-darmstadt.de/~reports/notes/ibn-97-46.ps
Refering-URL: http://www.inferenzsysteme.informatik.tu-darmstadt.de/~reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Termination of term rewriting using dependency pairs  
Author: Thomas Arts Jurgen Giesl 
Abstract: We present techniques to prove termination and innermost termination of term rewriting systems automatically. In contrast to previous approaches, we do not compare left- and right-hand sides of rewrite rules, but introduce the notion of dependency pairs to compare left-hand sides with special subterms of the right-hand sides. This results in a technique which allows to apply existing methods for automated termination proofs to term rewriting systems where they failed up to now. In particular, there are numerous term rewriting systems where a direct termination proof with simplification orderings is not possible, but in combination with our technique, well-known simplification orderings (such as the recursive path ordering, polynomial orderings, or the Knuth-Bendix ordering) can now be used to prove termination automatically. Unlike previous methods, our technique for proving innermost termination automatically can also be applied to prove innermost termination of term rewriting systems that are not terminating. Moreover, as innermost termination implies termination for certain classes of term rewriting systems, this technique can also be used for termination proofs of such systems.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Arts and J. Giesl, </author> <title> Termination of constructor systems, </title> <booktitle> in: Proc. RTA-96, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 1103 (Springer, </publisher> <address> Berlin, </address> <year> 1996) </year> <month> 63-77. </month>
Reference-contexts: Our termination criteria are based on the notion of dependency pairs. The concept of dependency pairs was introduced in [5] and a first method for its automation was proposed in <ref> [1] </ref>. For that purpose, we transferred the estimation technique [33, 34], which was originally developed for termination proofs of functional programs, to rewrite systems. However, this first method was restricted to non-overlapping constructor systems without nested recursion. <p> With our technique, termination can still be proved in the same way. 5.1.12 Permutation of lists This example is a TRS from Walther [58] to compute a permutation of a list. For instance, shu*e ([1; 2; 3; 4; 5]) reduces to <ref> [1; 5; 2; 4; 3] </ref>. app (nil; y) ! y reverse (nil) ! nil reverse (add (n; x)) ! app (reverse (x); add (n; nil)) shu*e (nil) ! nil shu*e (add (n; x)) ! add (n; shu*e (reverse (x))) The inequalities obtained from the dependency pairs on cycles in the dependency <p> Here, x. l represents the insertion of a number x into a list l (where x. y. l abbreviates (x. (y. l)) ), app computes the concatenation of lists, 57 and sum (l) is used to compute the sum of all numbers in l (e.g. sum applied to the list <ref> [1; 2; 3] </ref> returns [1 + 2 + 3]). app (nil; k) ! k app (x. l; k) ! x. app (l; k) sum (x. y. l) ! sum ((x + y). l) 0 + y ! y While this system is not simply terminating, the inequalities generated by the technique
Reference: [2] <author> T. Arts and J. Giesl, </author> <title> Automatically proving termination where simplification orderings fail, </title> <booktitle> in: Proc. TAPSOFT '97, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 1214 (Springer, </publisher> <address> Berlin, </address> <year> 1997) </year> <month> 261-272. 89 </month>
Reference-contexts: Self-labelling determines unique labels for the terms and a dependency pair can be regarded as a combination of the label for the left-hand side with the labels for the right-hand side of a rule. In <ref> [2] </ref> we developed a refined framework for dependency pairs which is independent from semantic labelling. Therefore this framework is better suited for automation (as one does not have to construct an appropriate semantic interpretation any more) and its soundness can be proved in a much easier and shorter way. <p> Moreover, in this framework we could show that our technique is applicable to arbitrary TRSs and we proved that the formulated criterion (Thm. 6) is not only sufficient, but also necessary for termination. The present paper extends the approach of <ref> [2] </ref> by the introduction of argument filtering TRSs, the addition of narrowing dependency pairs, and by proving that the whole approach up to the search for suitable quasi-orderings is sound and complete, i.e. the inequalities for which an ordering should be found by standard techniques are satisfiable if and only if <p> In Sect. 5 we give a collection of several examples which can now be proved terminating resp. innermost terminating automatically, but where automatic proofs using the techniques in <ref> [2, 3] </ref> failed. We have presented a sound and complete termination criterion. In contrast to most other complete approaches (semantic path ordering [40], general path ordering [20], semantic labelling [60] etc.) our method is particularly well suited 43 for automation as has been demonstrated in this paper. <p> Note that for the examples 5.1.39 - 5.1.46 we use the refinement of narrowing dependency pairs, i.e. these proofs were not possible with the method of <ref> [2] </ref>. 5.1.1 Division, version 1 The TRS of Ex. 2 minus (x; 0) ! x minus (s (x); s (y)) ! minus (x; y) quot (0; s (y)) ! 0 quot (s (x); s (y)) ! s (quot (minus (x; y); s (y))) is not simply terminating. <p> With our technique, termination can still be proved in the same way. 5.1.12 Permutation of lists This example is a TRS from Walther [58] to compute a permutation of a list. For instance, shu*e ([1; 2; 3; 4; 5]) reduces to <ref> [1; 5; 2; 4; 3] </ref>. app (nil; y) ! y reverse (nil) ! nil reverse (add (n; x)) ! app (reverse (x); add (n; nil)) shu*e (nil) ! nil shu*e (add (n; x)) ! add (n; shu*e (reverse (x))) The inequalities obtained from the dependency pairs on cycles in the dependency <p> y) is mapped to y, and P (x; y) is mapped to the sum of x and y (where P denotes the tuple symbol for `+'). 5.1.17 Summing elements of lists This TRS, which has overlapping rules, can be used to compute the sum of all elements of a list <ref> [2] </ref>. <p> Here, x. l represents the insertion of a number x into a list l (where x. y. l abbreviates (x. (y. l)) ), app computes the concatenation of lists, 57 and sum (l) is used to compute the sum of all numbers in l (e.g. sum applied to the list <ref> [1; 2; 3] </ref> returns [1 + 2 + 3]). app (nil; k) ! k app (x. l; k) ! x. app (l; k) sum (x. y. l) ! sum ((x + y). l) 0 + y ! y While this system is not simply terminating, the inequalities generated by the technique <p> holds for large enough x. 68 5.1.41 Factorial The following non-simply terminating TRS for computing the factorial of a natural number (cf. [54, 60]) p (s (x)) ! x fac (s (x)) ! s (x) fi fac (p (s (x))) cannot be proved terminating automatically by the technique described in <ref> [2] </ref>, since there narrowing dependency pairs was not considered.
Reference: [3] <author> T. Arts and J. Giesl, </author> <title> Proving innermost normalisation automatically, </title> <booktitle> in: Proc. RTA-97, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 1232 (Springer, </publisher> <address> Berlin, </address> <year> 1997) </year> <month> 157-171. </month>
Reference-contexts: This result suggests that the transformation described in this paper should always be applied before using any of the standard techniques for termination proofs. In <ref> [3] </ref> we presented a modification of the framework, in which the notion of chains was restricted to innermost chains and we showed that a TRS is innermost terminating if and only if no infinite innermost chains exist for the TRS. <p> Moreover, our technique can very successfully be used for termination proofs of non-overlapping systems, because for those systems innermost termination is already sufficient for termination. In the present paper we extended the technique described in <ref> [3] </ref> by a refined definition of innermost dependency graphs, a method to compute better approximations of these graphs, and a more powerful approach for narrowing dependency pairs. <p> In Sect. 5 we give a collection of several examples which can now be proved terminating resp. innermost terminating automatically, but where automatic proofs using the techniques in <ref> [2, 3] </ref> failed. We have presented a sound and complete termination criterion. In contrast to most other complete approaches (semantic path ordering [40], general path ordering [20], semantic labelling [60] etc.) our method is particularly well suited 43 for automation as has been demonstrated in this paper. <p> With our technique, termination can still be proved in the same way. 5.1.12 Permutation of lists This example is a TRS from Walther [58] to compute a permutation of a list. For instance, shu*e ([1; 2; 3; 4; 5]) reduces to <ref> [1; 5; 2; 4; 3] </ref>. app (nil; y) ! y reverse (nil) ! nil reverse (add (n; x)) ! app (reverse (x); add (n; nil)) shu*e (nil) ! nil shu*e (add (n; x)) ! add (n; shu*e (reverse (x))) The inequalities obtained from the dependency pairs on cycles in the dependency <p> Here, x. l represents the insertion of a number x into a list l (where x. y. l abbreviates (x. (y. l)) ), app computes the concatenation of lists, 57 and sum (l) is used to compute the sum of all numbers in l (e.g. sum applied to the list <ref> [1; 2; 3] </ref> returns [1 + 2 + 3]). app (nil; k) ! k app (x. l; k) ! x. app (l; k) sum (x. y. l) ! sum ((x + y). l) 0 + y ! y While this system is not simply terminating, the inequalities generated by the technique <p> The remainder of the examples (5.2.19 - 5.2.29) are non-overlapping term rewriting systems for which innermost termination suffices to guarantee termination. Note that for the examples 5.2.14 - 5.2.18 and 5.2.24 - 5.2.29 we had to use refinements which were not included in the method of <ref> [3] </ref>. 5.2.1 Toyama example A famous example of a TRS that is innermost terminating, but not terminating, is the following system from Toyama [56]. f (0; 1; x) ! f (x; x; x) g (x; y) ! y: This TRS has only one dependency pair, viz. hF (0; 1; x); F <p> F (g (x); s (0)) &gt; F (g (x); g (x)). However, then the resulting constraints would imply F (gs0; s0) &gt; F (gs0; gs0) F (gs0; sg0) F (gs0; s0): Hence, they would not be satisfied by any well-founded ordering closed under substitution. Therefore the approach of <ref> [3] </ref> would fail with this example. However, by the refined approximation of using cap s we can immediately determine that this dependency pair is not on a cycle of the innermost dependency graph. <p> F (s (0); g (x 2 )) unify using a most general unifier that instantiates F (s (0); g (x 2 )) in such a way that it is not a normal form. (However, this would not have been determined by the approximation of innermost dependency graphs as presented in <ref> [3] </ref>.) The only dependency pair that occurs on a cycle in the innermost dependency graph is hG (s (x)); G (x)i, resulting in the inequality G (s (x)) &gt; G (x) which is easily satisfied by the recursive path ordering. 5.2.17 Narrowing of pairs where right-hand sides unify with left hand
Reference: [4] <author> T. Arts and J. Giesl, </author> <title> Modularity of termination using dependency pairs, </title> <type> Technical Report IBN 97/45, </type> <institution> TH Darmstadt, Germany, </institution> <year> 1997. </year>
Reference-contexts: The automated checking of this criterion enables us to prove innermost termination automatically, even if the TRS is not terminating. Additionally, for several classes of TRSs innermost termination already suffices for termination [35, 36]. Moreover, numerous modularity results exist for innermost termination <ref> [4, 5, 6, 35, 44, 45] </ref>, which do not hold for termination. Therefore, for those classes of TRSs termination can be proved by splitting the TRS and proving innermost termination of the subsystems separately. <p> For example, the framework of dependency pairs can easily be extended for termination modulo associativity and commutativity [48]. Moreover, several well-known and new modularity results can be derived in this framework <ref> [4, 6] </ref>. 5 Examples This collection of examples demonstrates the power of the described method. The majority of them occurred as challenge problems in the literature, whereas the other examples are added to point out specific failures of existing techniques. <p> With our technique, termination can still be proved in the same way. 5.1.12 Permutation of lists This example is a TRS from Walther [58] to compute a permutation of a list. For instance, shu*e ([1; 2; 3; 4; 5]) reduces to <ref> [1; 5; 2; 4; 3] </ref>. app (nil; y) ! y reverse (nil) ! nil reverse (add (n; x)) ! app (reverse (x); add (n; nil)) shu*e (nil) ! nil shu*e (add (n; x)) ! add (n; shu*e (reverse (x))) The inequalities obtained from the dependency pairs on cycles in the dependency
Reference: [5] <author> T. </author> <title> Arts, Termination by absence of infinite chains of dependency pairs, </title> <booktitle> in: Proc. CAAP '96, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 1059 (Springer, </publisher> <address> Berlin, </address> <year> 1996) </year> <month> 196-210. </month>
Reference-contexts: The automated checking of this criterion enables us to prove innermost termination automatically, even if the TRS is not terminating. Additionally, for several classes of TRSs innermost termination already suffices for termination [35, 36]. Moreover, numerous modularity results exist for innermost termination <ref> [4, 5, 6, 35, 44, 45] </ref>, which do not hold for termination. Therefore, for those classes of TRSs termination can be proved by splitting the TRS and proving innermost termination of the subsystems separately. <p> Our termination criteria are based on the notion of dependency pairs. The concept of dependency pairs was introduced in <ref> [5] </ref> and a first method for its automation was proposed in [1]. For that purpose, we transferred the estimation technique [33, 34], which was originally developed for termination proofs of functional programs, to rewrite systems. However, this first method was restricted to non-overlapping constructor systems without nested recursion. <p> With our technique, termination can still be proved in the same way. 5.1.12 Permutation of lists This example is a TRS from Walther [58] to compute a permutation of a list. For instance, shu*e ([1; 2; 3; 4; 5]) reduces to <ref> [1; 5; 2; 4; 3] </ref>. app (nil; y) ! y reverse (nil) ! nil reverse (add (n; x)) ! app (reverse (x); add (n; nil)) shu*e (nil) ! nil shu*e (add (n; x)) ! add (n; shu*e (reverse (x))) The inequalities obtained from the dependency pairs on cycles in the dependency
Reference: [6] <author> T. </author> <title> Arts, Automatically proving termination and innermost normalisation of term rewriting systems, </title> <type> Ph.D. Thesis, </type> <institution> Utrecht University, </institution> <address> The Netherlands, </address> <year> 1997. </year>
Reference-contexts: The automated checking of this criterion enables us to prove innermost termination automatically, even if the TRS is not terminating. Additionally, for several classes of TRSs innermost termination already suffices for termination [35, 36]. Moreover, numerous modularity results exist for innermost termination <ref> [4, 5, 6, 35, 44, 45] </ref>, which do not hold for termination. Therefore, for those classes of TRSs termination can be proved by splitting the TRS and proving innermost termination of the subsystems separately. <p> For example, the framework of dependency pairs can easily be extended for termination modulo associativity and commutativity [48]. Moreover, several well-known and new modularity results can be derived in this framework <ref> [4, 6] </ref>. 5 Examples This collection of examples demonstrates the power of the described method. The majority of them occurred as challenge problems in the literature, whereas the other examples are added to point out specific failures of existing techniques.
Reference: [7] <author> T. Arts and H. Zantema, </author> <title> Termination of logic programs using semantic unification, </title> <booktitle> in: Proc. LoPSTr '95, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 1048 (Springer, </publisher> <address> Berlin, </address> <year> 1995) </year> <month> 219-233. </month>
Reference-contexts: Techniques for proving innermost termination can for example be utilized for termination proofs of functional programs (modelled by TRSs) with eager reduction strategy or of logic programs. (When transforming well-moded logic programs into TRSs, innermost termination of the TRS is sufficient for left-termination of the logic program <ref> [7] </ref>.) Up to now, the only way to prove innermost termination automatically was by showing termination of the TRS. Therefore, none of the existing techniques could prove innermost termination of non-terminating systems.
Reference: [8] <author> L. Bachmair and N. Dershowitz, </author> <title> Commutation, transformation and termination, </title> <booktitle> in: Proc. CADE-8, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 230 (Springer, </publisher> <address> Berlin, </address> <year> 1986) </year> <month> 5-20. </month>
Reference-contexts: Box 80.089, 3508 TB Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 [20, 47], semantic interpretations [12, 13, 31, 46, 53, 59], transformation order--ings <ref> [8, 11, 54] </ref>, distribution elimination [59], dummy elimination [26], semantic labelling [60] etc. | for surveys see e.g. [18, 55]). We present a new approach for the automation of termination proofs. <p> The only other complete criterion that has been used for automatic termination proofs (by Steinbach [54]) is the approach of transformation orderings <ref> [8, 11] </ref>. It turns out that the termination of several examples where the automation of Steinbach failed can be proved by our technique automatically, cf. Sect. 5. At first sight there seem to be some similarities between our method and forward closures [20, 47].
Reference: [9] <author> L. Bachmair, </author> <title> Proof methods for equational theories, </title> <type> Ph.D. Thesis, </type> <institution> University of Illinois, Urbana, IL, </institution> <year> 1987. </year>
Reference-contexts: As there is no cycle consisting of the resulting pairs, the TRS is terminating. 5.1.44 Termination by narrowing, version 2 To prove termination of the following TRS from Bachmair <ref> [9, 54] </ref> f (h (x)) ! f (i (x)) h (a) ! b the dependency pairs hF (h (x)); F (i (x))i are replaced by their narrowings hF (h (a)); F (b)i Then termination is automatically proved by the fact that the dependency graph has no cycles. 5.1.45 Termination by narrowing,
Reference: [10] <author> F. Bellegarde and P. Lescanne, </author> <title> Termination proofs based on transformation techniques, </title> <type> Technical Report, </type> <institution> Centre de Recherche en Informatique de Nancy, France, </institution> <year> 1988. </year>
Reference-contexts: In a completely analogous way, termination of the one rule TRS f (g (x)) ! f (h (g (x))) from Bellegarde and Lescanne <ref> [10] </ref> and of the one rule system f (g (x; y); y) ! f (h (g (x; y)); a) from Steinbach [54] can also be proved. 5.1.35 Mutual recursion, version 1 The following system is from Steinbach [54] again. g (s (x)) ! f (x) f (s (x)) ! s (s
Reference: [11] <author> F. Bellegarde and P. Lescanne, </author> <title> Termination by completion, </title> <booktitle> Applicable Algebra in Engineering, Communication and Computing 1 (1990) 79-96. </booktitle>
Reference-contexts: Box 80.089, 3508 TB Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 [20, 47], semantic interpretations [12, 13, 31, 46, 53, 59], transformation order--ings <ref> [8, 11, 54] </ref>, distribution elimination [59], dummy elimination [26], semantic labelling [60] etc. | for surveys see e.g. [18, 55]). We present a new approach for the automation of termination proofs. <p> The only other complete criterion that has been used for automatic termination proofs (by Steinbach [54]) is the approach of transformation orderings <ref> [8, 11] </ref>. It turns out that the termination of several examples where the automation of Steinbach failed can be proved by our technique automatically, cf. Sect. 5. At first sight there seem to be some similarities between our method and forward closures [20, 47]. <p> By using narrowing, the dependency pair hFAC (s (x)); FAC (p (s (x)))i is replaced by the dependency pair hFAC (s (x)); FAC (x)i resulting in inequalities which can easily be satisfied. 5.1.42 Binary numbers The following non-simply terminating example is due to Geser <ref> [11, 54] </ref>. half (0) ! 0 half (s (0)) ! 0 half (s (s (x))) ! s (half (x)) lastbit (0) ! 0 lastbit (s (0)) ! s (0) lastbit (s (s (x))) ! lastbit (x) conv (0) ! nil. 0 conv (s (x)) ! conv (half (s (x))). lastbit (s
Reference: [12] <author> A. Ben Cherifa and P. Lescanne, </author> <title> Termination of rewriting systems by polynomial interpretations and its implementation, </title> <institution> Sci. Comput. </institution> <note> Programming 9 (1987) 137-159. </note>
Reference-contexts: Box 80.089, 3508 TB Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 [20, 47], semantic interpretations <ref> [12, 13, 31, 46, 53, 59] </ref>, transformation order--ings [8, 11, 54], distribution elimination [59], dummy elimination [26], semantic labelling [60] etc. | for surveys see e.g. [18, 55]). We present a new approach for the automation of termination proofs.
Reference: [13] <author> E. Bevers and J. Lewi, </author> <title> Proving termination of (conditional) rewrite systems, </title> <note> Acta Informatica 30 (1993) 537-568. </note>
Reference-contexts: Box 80.089, 3508 TB Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 [20, 47], semantic interpretations <ref> [12, 13, 31, 46, 53, 59] </ref>, transformation order--ings [8, 11, 54], distribution elimination [59], dummy elimination [26], semantic labelling [60] etc. | for surveys see e.g. [18, 55]). We present a new approach for the automation of termination proofs.
Reference: [14] <editor> R. S. Boyer and J S. Moore, </editor> <publisher> A Computational Logic (Academic Press, </publisher> <year> 1979). </year>
Reference-contexts: This example was taken from Boyer and Moore <ref> [14] </ref> and Walther [57]. <p> This example is inspired by an algorithm from Boyer and Moore <ref> [14] </ref> and Walther [58]. In the corresponding example from Steinbach [54] the rules for eq, le, if rm , and if min were missing. 5.1.11 Quicksort The following TRS is used to sort a list by the well-known quicksort algorithm.
Reference: [15] <author> B. Courcelle, </author> <title> Recursive applicative program schemes, </title> <editor> in: J. van Leeuwen, ed., </editor> <booktitle> Handbook of Theoretical Computer Science. </booktitle> <volume> Vol. </volume> <editor> B (North-Holland, </editor> <year> 1990) </year> <month> 459-492. </month>
Reference-contexts: are pairwise different variables out of x 1 ; : : : ; x n , g 62 F , and for every function symbol f 2 F there is at most one f -rule in the AFS. 3 Argument filtering TRSs are a special form of recursive program schemes <ref> [15, 41] </ref>. 11 From a rewriting point of view AFSs are quite simple, because every AFS is complete. Hence, for any term t the normal form t # A w.r.t. an AFS A is unique.
Reference: [16] <author> N. Dershowitz, </author> <title> Termination of linear rewriting systems, </title> <booktitle> in: Proc. ICALP '81, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 115 (Springer, </publisher> <address> Berlin, </address> <year> 1981) </year> <month> 448-458. </month>
Reference-contexts: Hence, in our example we have 6 Provided that a variable occurs in t j , but termination is decidable for TRSs with ground right-hand sides <ref> [16] </ref>. 7 U (R; t) is well-defined, because its first argument R is decreasing. 29 U (R; F (y; y; g (x))) = Rules (R; F) [ U (R; y) [ U (R; g (x)) [ ; = U (R; g (x)) = Rules (R; g) [ U (ff (: : <p> Compared to the forward closure approach, the dependency pair technique has the advantage that it can be used for arbitrary TRSs, whereas the absence of infinite forward closures only implies termination for right-linear <ref> [16] </ref> or non-overlapping [30] TRSs. Moreover, in contrast to the dependency pair method, we do not know of any attempt to automate the forward closure approach.
Reference: [17] <author> N. Dershowitz, </author> <title> Orderings for term-rewriting systems, </title> <type> Theoret. </type> <institution> Comp. Sci. </institution> <month> 17 </month> <year> (1982) </year> <month> 279-301. </month>
Reference-contexts: 1 Introduction Termination is one of the most fundamental properties of a term rewriting system (TRS), cf. e.g. [21]. While in general this problem is undecidable [37], several methods for proving termination have been developed (e.g. path or-derings <ref> [17, 20, 40, 51, 55] </ref>, Knuth-Bendix orderings [22, 42], forward closures fl Technical Report IBN 97/46, Darmstadt University of Technology. This is a preliminary version of an article which appeared in Theoretical Computer Science. y Department of Computer Science, Utrecht University, P.O. <p> In most practical applications the synthesized orderings are total on ground terms [25] and therefore virtually all orderings used are simplification orderings <ref> [17, 18, 50, 55] </ref>. However, numerous TRSs are not simply terminating, i.e. not compatible with a simplification ordering. Hence, standard techniques like the recursive path ordering, polynomial interpretations, and the Knuth-Bendix ordering fail in proving termination of these TRSs.
Reference: [18] <author> N. Dershowitz, </author> <title> Termination of rewriting, </title> <journal> J. Symb. Comp. </journal> <month> 3 </month> <year> (1987) </year> <month> 69-116. </month>
Reference-contexts: Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 [20, 47], semantic interpretations [12, 13, 31, 46, 53, 59], transformation order--ings [8, 11, 54], distribution elimination [59], dummy elimination [26], semantic labelling [60] etc. | for surveys see e.g. <ref> [18, 55] </ref>). We present a new approach for the automation of termination proofs. Most well-known techniques for proving termination automatically try to find a well-founded ordering such that for all rules of the TRS the left-hand sides are greater than the corresponding right-hand sides. <p> In most practical applications the synthesized orderings are total on ground terms [25] and therefore virtually all orderings used are simplification orderings <ref> [17, 18, 50, 55] </ref>. However, numerous TRSs are not simply terminating, i.e. not compatible with a simplification ordering. Hence, standard techniques like the recursive path ordering, polynomial interpretations, and the Knuth-Bendix ordering fail in proving termination of these TRSs. <p> See Sect. 5 for a collection of numerous such examples, including arithmetical operations (e.g. mod, gcd, logarithm, average), sorting 42 algorithms (such as selection sort, minimum sort, and quicksort), algorithms on graphs and trees, and several other well-known non-simply terminating TRSs (e.g. from <ref> [18, 20, 54] </ref>). Our termination criteria are based on the notion of dependency pairs. The concept of dependency pairs was introduced in [5] and a first method for its automation was proposed in [1]. <p> Therefore this polynomial ordering cannot be used for a direct termination proof, but it nevertheless satisfies the inequalities generated by the technique of Sect. 2. In this way, termination can easily be proved. 5.1.21 Multiplication and addition The following example is taken from Dershowitz <ref> [18] </ref>. x fi (y + 1) ! (x fi (y + (1 fi 0))) + x x + 0 ! x The only inequality resulting from a dependency pair on a cycle in the dependency graph is TIMES (x; y + 1) &gt; TIMES (x; y + (1 fi 0)). <p> &gt; F (x): The recursive path ordering satisfies the inequalities when normalizing them by the AFS a (x; y) ! a 0 . 5.1.32 A TRS that is not totally terminating, version 1 The most famous example of a TRS that is terminating, but not totally terminating is the following <ref> [18] </ref>. f (a) ! f (b) With our approach, termination of this system is obvious, because the dependency graph does not contain any cycles. 63 5.1.33 A TRS that is not totally terminating, version 2 A TRS introduced by Ferreira [27] as an example of a TRS that is not totally <p> termination, is given by: p (f (f (x))) ! q (f (g (x))) q (f (f (x))) ! p (f (g (x))) Termination is trivially concluded from the fact that there are no cycles in the dependency graph. 5.1.34 Systems with `undefined' function symbols The following well-known system from Dershowitz <ref> [18] </ref> is one of the smallest non-simply terminating TRSs. f (f (x)) ! f (g (f (x))) As F (g (f (x))) is not connectable to F (f (x)), the only dependency pair on a cycle of the dependency graph is hF (f (x)); F (x)i.
Reference: [19] <author> N. Dershowitz, </author> <title> 33 examples of termination, </title> <booktitle> in: Proc. Term Rewriting, French Spring School of Theoretical Computer Science, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 909 (Springer, </publisher> <address> Berlin, </address> <year> 1993) </year> <month> 16-27. </month>
Reference-contexts: f (x) ! s (x) The inequalities to satisfy are f (x) s (x) F (s (s (x))) &gt; F (x) An appropriate path ordering is found by choosing f and s to be equal in the precedence. 5.1.27 Nested symbols on left-hand sides The following example is from Dershowitz <ref> [19] </ref>. <p> precedence, the inequalities are satisfied by the recursive path ordering. 5.1.28 Nested symbols on both sides of rules Termination of the following TRS cannot be proved by the lexicographic path ordering and therefore this is one of the systems for which the semantic path ordering has been used in literature <ref> [19] </ref>. However, the system can be shown to terminate using the lexicographic path ordering after applying our technique, since the demanded ordering may now be a weakly monotonic ordering instead of a monotonic ordering.
Reference: [20] <author> N. Dershowitz and C. Hoot, </author> <title> Natural termination, </title> <type> Theoret. </type> <institution> Comp. Sci. </institution> <month> 142 </month> <year> (1995) </year> <month> 179-207. </month>
Reference-contexts: 1 Introduction Termination is one of the most fundamental properties of a term rewriting system (TRS), cf. e.g. [21]. While in general this problem is undecidable [37], several methods for proving termination have been developed (e.g. path or-derings <ref> [17, 20, 40, 51, 55] </ref>, Knuth-Bendix orderings [22, 42], forward closures fl Technical Report IBN 97/46, Darmstadt University of Technology. This is a preliminary version of an article which appeared in Theoretical Computer Science. y Department of Computer Science, Utrecht University, P.O. <p> This is a preliminary version of an article which appeared in Theoretical Computer Science. y Department of Computer Science, Utrecht University, P.O. Box 80.089, 3508 TB Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 <ref> [20, 47] </ref>, semantic interpretations [12, 13, 31, 46, 53, 59], transformation order--ings [8, 11, 54], distribution elimination [59], dummy elimination [26], semantic labelling [60] etc. | for surveys see e.g. [18, 55]). We present a new approach for the automation of termination proofs. <p> See Sect. 5 for a collection of numerous such examples, including arithmetical operations (e.g. mod, gcd, logarithm, average), sorting 42 algorithms (such as selection sort, minimum sort, and quicksort), algorithms on graphs and trees, and several other well-known non-simply terminating TRSs (e.g. from <ref> [18, 20, 54] </ref>). Our termination criteria are based on the notion of dependency pairs. The concept of dependency pairs was introduced in [5] and a first method for its automation was proposed in [1]. <p> We have presented a sound and complete termination criterion. In contrast to most other complete approaches (semantic path ordering [40], general path ordering <ref> [20] </ref>, semantic labelling [60] etc.) our method is particularly well suited 43 for automation as has been demonstrated in this paper. The only other complete criterion that has been used for automatic termination proofs (by Steinbach [54]) is the approach of transformation orderings [8, 11]. <p> It turns out that the termination of several examples where the automation of Steinbach failed can be proved by our technique automatically, cf. Sect. 5. At first sight there seem to be some similarities between our method and forward closures <ref> [20, 47] </ref>. The idea of forward closures is to restrict the application of rules to that part of a term created by previous rewrites. Similar to our notion of chains, this notion also results in a sequence of terms, but the semantics of these sequences are completely different. <p> of less leaves (in the right-hand side of the last rule) would be replaced by an appropriate argument, we would obtain a non-simply terminating TRS whose termination could be proved in the same way. 5.1.15 Average of naturals The following locally confluent overlay system computes the average of two numbers <ref> [20] </ref>. average (s (x); y) ! average (x; s (y)) average (x; s (s (s (y)))) ! s (average (s (x); y)) average (0; 0) ! 0 average (0; s (0)) ! 0 average (0; s (s (0))) ! s (0) The relevant inequalities are AVERAGE (s (x); y) &gt; AVERAGE <p> the following polynomial interpretation, termination of this TRS is easily proved: 0 is mapped to 0, s (x) is mapped to x + 1, average (x; y) is mapped to x + y, and AVERAGE (x; y) is mapped to 2x + y. 5.1.16 Plus and times The following TRS <ref> [20] </ref> is again a locally confluent overlay system.
Reference: [21] <author> N. Dershowitz and J.-P. Jouannaud, </author> <title> Rewrite systems, </title> <editor> in: J. van Leeuwen, ed., </editor> <booktitle> Handbook of Theoretical Computer Science. </booktitle> <volume> Vol. </volume> <editor> B (North-Holland, </editor> <year> 1990) </year> <month> 243-320. </month>
Reference-contexts: 1 Introduction Termination is one of the most fundamental properties of a term rewriting system (TRS), cf. e.g. <ref> [21] </ref>. While in general this problem is undecidable [37], several methods for proving termination have been developed (e.g. path or-derings [17, 20, 40, 51, 55], Knuth-Bendix orderings [22, 42], forward closures fl Technical Report IBN 97/46, Darmstadt University of Technology. <p> The following definition extends these notions to arbitrary term rewriting systems R (F ; R) (with the rules R over a signature F). For an introduction to term rewriting and its notations, we refer to Dershowitz and Jouannaud <ref> [21] </ref> and Klop [41]. Here, the root of a term f (: : :) is the leading function symbol f . Definition 1 (Defined symbols and constructors) Let R (F ; R) be a TRS.
Reference: [22] <author> J. Dick, J. Kalmus, and U. Martin, </author> <title> Automating the Knuth Bendix ordering, </title> <note> Acta Informatica 28 (1990) 95-119. </note>
Reference-contexts: 1 Introduction Termination is one of the most fundamental properties of a term rewriting system (TRS), cf. e.g. [21]. While in general this problem is undecidable [37], several methods for proving termination have been developed (e.g. path or-derings [17, 20, 40, 51, 55], Knuth-Bendix orderings <ref> [22, 42] </ref>, forward closures fl Technical Report IBN 97/46, Darmstadt University of Technology. This is a preliminary version of an article which appeared in Theoretical Computer Science. y Department of Computer Science, Utrecht University, P.O.
Reference: [23] <editor> K. Drosten, Termersetzungssysteme: Grundlagen der Prototyp-Generie-rung algebraischer Spezifikationen (Springer, </editor> <address> Berlin, </address> <year> 1989). </year>
Reference-contexts: In a similar way one can also prove innermost termination of the system where the first rule has been changed to h (x; y) ! f (x; y; x): 5.2.13 Drosten example A confluent and innermost terminating TRS that is not terminating was given by Drosten <ref> [23] </ref>. f (0; 1; x) ! f (x; x; x) 0 ! 2 g (x; x; y) ! y As there exists no cycle in the innermost dependency graph, the TRS is innermost terminating. 5.2.14 Better approximations of the innermost dependency graph, version 1 For the approximation of innermost dependency graphs
Reference: [24] <author> M. Ferreira and H. Zantema, </author> <title> Total termination of term rewriting, </title> <booktitle> in: Proc. RTA-93, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 690 (Springer, </publisher> <address> Berlin, </address> <year> 1993) </year> <month> 213-227. </month>
Reference-contexts: (x))) The inequalities resulting from our transformation are satisfied by the polynomial ordering, where f (x) is mapped to the constant 1, F (x) is mapped to x, and where 0 and s are interpreted as usual. 60 5.1.25 Nested recursion, version 3 The following TRS by Ferreira and Zantema <ref> [24] </ref> is a string rewriting system with minimal ordinal ! ! associated to it. f (g (x)) ! g (f (f (x))) The relevant inequalities corresponding to this system are F (g (x)) &gt; F (x) After normalizing the inequalities by the AFS h (x) ! h 0 all inequalities are
Reference: [25] <author> M. Ferreira and H. Zantema, </author> <title> Syntactical analysis of total termination, </title> <booktitle> in: Proc. ALP '94, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 850 (Springer, </publisher> <address> Berlin, </address> <year> 1994) </year> <month> 204-222. </month>
Reference-contexts: Most well-known techniques for proving termination automatically try to find a well-founded ordering such that for all rules of the TRS the left-hand sides are greater than the corresponding right-hand sides. In most practical applications the synthesized orderings are total on ground terms <ref> [25] </ref> and therefore virtually all orderings used are simplification orderings [17, 18, 50, 55]. However, numerous TRSs are not simply terminating, i.e. not compatible with a simplification ordering. Hence, standard techniques like the recursive path ordering, polynomial interpretations, and the Knuth-Bendix ordering fail in proving termination of these TRSs.
Reference: [26] <author> M. Ferreira and H. Zantema, </author> <title> Dummy elimination: making termination easier, </title> <booktitle> in: Proc. FCT '95, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 965 (Springer, </publisher> <address> Berlin, </address> <year> 1995) </year> <month> 243-252. </month>
Reference-contexts: Box 80.089, 3508 TB Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 [20, 47], semantic interpretations [12, 13, 31, 46, 53, 59], transformation order--ings [8, 11, 54], distribution elimination [59], dummy elimination <ref> [26] </ref>, semantic labelling [60] etc. | for surveys see e.g. [18, 55]). We present a new approach for the automation of termination proofs. <p> not connectable to F (a; b) or F (c; d), neither is F (c; d) connectable to F (a; b) or F (c; d). 5.1.31 Advantage of the dependency graph, version 2 Another example where the dependency graph plays an important role is a TRS introduced by Ferreira and Zantema <ref> [26] </ref> to demonstrate the technique of `dummy elimination'. f (g (x)) ! f (a (g (g (f (x))); g (f (x)))) Since F (a (y; z)) does not unify with F (g (x)), the only two inequalities to satisfy are F (g (x)) &gt; F (x): The recursive path ordering satisfies
Reference: [27] <author> M. Ferreira, </author> <title> Termination of Term Rewriting - Well-foundedness, Totality and Transformations, </title> <type> Ph.D. Thesis, </type> <institution> Utrecht University, </institution> <address> The Netherlands, </address> <year> 1995. </year>
Reference-contexts: if the inequalities are normalized by the AFS g (z; y) ! z. 5.1.29 A TRS that is not left-linear The following TRS, originally from Geerling [28], cannot be proved terminating by the recursive path ordering (but one needs a generalization of the recursive path ordering as defined by Ferreira <ref> [27] </ref>). <p> that is terminating, but not totally terminating is the following [18]. f (a) ! f (b) With our approach, termination of this system is obvious, because the dependency graph does not contain any cycles. 63 5.1.33 A TRS that is not totally terminating, version 2 A TRS introduced by Ferreira <ref> [27] </ref> as an example of a TRS that is not totally terminating and in particular for which the recursive path ordering and the Knuth-Bendix ordering cannot be used to prove termination, is given by: p (f (f (x))) ! q (f (g (x))) q (f (f (x))) ! p (f (g
Reference: [28] <author> M. Geerling, </author> <title> Termination of term rewriting systems, </title> <type> Master's thesis, </type> <institution> Utrecht University, </institution> <address> The Netherlands, </address> <year> 1991. </year>
Reference-contexts: z) &gt; TIMES (x; z) TIMES (x + y; z) &gt; TIMES (y; z) The seven inequalities are satisfied by the lexicographic path ordering if the inequalities are normalized by the AFS g (z; y) ! z. 5.1.29 A TRS that is not left-linear The following TRS, originally from Geerling <ref> [28] </ref>, cannot be proved terminating by the recursive path ordering (but one needs a generalization of the recursive path ordering as defined by Ferreira [27]).
Reference: [29] <author> A. Geser, </author> <title> On normalizing, non-terminating one-rule string rewriting systems, </title> <type> Technical Report, WSI 96-34, </type> <institution> Universitat Tubingen, </institution> <year> 1996. </year> <month> 91 </month>
Reference-contexts: A well-founded ordering satisfying this constraint can of course be synthesized easily (e.g. the recursive path ordering). 5.2.18 Smallest normalizing non-terminating one-rule string rewrit ing system The following example from Geser <ref> [29] </ref> is the smallest normalizing non-terminating one-rule string rewriting system. a (b (a (b (x)))) ! b (a (b (a (a (b (x)))))) The dependency pairs in this example are hA (b (a (b (x)))); A (b (x))i hA (b (a (b (x)))); A (b (a (a (b (x)))))i: The second
Reference: [30] <author> O. Geupel, </author> <title> Overlap closures and termination of term rewriting systems, </title> <type> Technical Report MIP-8922 283, </type> <institution> Universitat Passau, Germany, </institution> <year> 1989. </year>
Reference-contexts: Compared to the forward closure approach, the dependency pair technique has the advantage that it can be used for arbitrary TRSs, whereas the absence of infinite forward closures only implies termination for right-linear [16] or non-overlapping <ref> [30] </ref> TRSs. Moreover, in contrast to the dependency pair method, we do not know of any attempt to automate the forward closure approach. The framework of dependency pairs, as introduced in this paper, is very general and is therefore well suited to be used for more general rewriting problems, too.
Reference: [31] <author> J. Giesl, </author> <title> Generating polynomial orderings for termination proofs, </title> <booktitle> in: Proc. RTA-95, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 914 (Springer, </publisher> <address> Berlin, </address> <year> 1995) </year> <month> 426-431. </month>
Reference-contexts: Box 80.089, 3508 TB Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 [20, 47], semantic interpretations <ref> [12, 13, 31, 46, 53, 59] </ref>, transformation order--ings [8, 11, 54], distribution elimination [59], dummy elimination [26], semantic labelling [60] etc. | for surveys see e.g. [18, 55]). We present a new approach for the automation of termination proofs. <p> Methods for the automated synthesis of polynomial orderings have for instance been developed in <ref> [31, 53] </ref>. In this way, termination 10 of this TRS can be proved fully automatically, although a direct termination proof with simplification orderings was not possible. Instead of polynomial orderings one can also use path orderings, which can easily be generated automatically. <p> Example 33 As an example regard the following TRS by Kolbe [43] where quot (x; y; z) is used to compute 1 + ffi xy , if x y and z 6= 0 (i.e. quot (x; y; y) computes j y ). be non-negative, i.e. @[F](y;y;x) @x 0, cf. <ref> [31] </ref>.
Reference: [32] <author> J. Giesl, </author> <title> Automatisierung von Terminierungsbeweisen fur rekursiv definier-te Algorithmen, </title> <type> Ph.D. Thesis (Infix, </type> <institution> St. Augustin, </institution> <year> 1995). </year>
Reference-contexts: to x + y. 5.1.13 Reachability on directed graphs To check whether there is a path from the node x to the node y in a directed graph g, the term reach (x; y; g; *) must be reducible to true with the rules of the following TRS from Giesl <ref> [32] </ref>. The fourth argument of reach is used to store edges that have already been examined but that are not included in the actual solution path. If an edge from u to v (with x 6= u) is found, then it is rejected at first.
Reference: [33] <author> J. Giesl, </author> <title> Termination analysis for functional programs using term orderings, </title> <booktitle> in: Proc. SAS '95, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 983 (Springer, </publisher> <address> Berlin, </address> <year> 1995) </year> <month> 154-171. </month>
Reference-contexts: Our termination criteria are based on the notion of dependency pairs. The concept of dependency pairs was introduced in [5] and a first method for its automation was proposed in [1]. For that purpose, we transferred the estimation technique <ref> [33, 34] </ref>, which was originally developed for termination proofs of functional programs, to rewrite systems. However, this first method was restricted to non-overlapping constructor systems without nested recursion.
Reference: [34] <author> J. Giesl, </author> <title> Termination of nested and mutually recursive algorithms, </title> <note> Journal of Automated Reasoning 19 (1997) 1-29. </note>
Reference-contexts: Our termination criteria are based on the notion of dependency pairs. The concept of dependency pairs was introduced in [5] and a first method for its automation was proposed in [1]. For that purpose, we transferred the estimation technique <ref> [33, 34] </ref>, which was originally developed for termination proofs of functional programs, to rewrite systems. However, this first method was restricted to non-overlapping constructor systems without nested recursion. <p> (y)) &gt; TIMES (x; y) P (x; s (y)) &gt; P (x; y) are satisfied by the same polynomial ordering that has been used above (where P (x; y) and TIMES (x; y) are both mapped to y). 5.1.23 Nested recursion, version 1 The following system was introduced by Giesl <ref> [34, `nest2'] </ref> as an example for a small TRS with nested recursion where all simplification orderings fail. f (0; y) ! 0 For this example, a polynomial ordering can be used where 0 and s are interpreted as usual and both f (x; y) and F (x; y) are mapped to <p> Such rewrite systems are often obtained when transforming mutually recursive functions into one function without mutual recursion, cf. <ref> [34] </ref>.) not (true) ! false not (false) ! true evenodd (x; 0) ! not (evenodd (x; s (0))) evenodd (0; s (0)) ! false evenodd (s (x); s (0)) ! evenodd (x; 0) We obtain the following relevant inequalities.
Reference: [35] <author> B. Gramlich, </author> <title> Abstract relations between restricted termination and confluence properties of rewrite systems, </title> <note> Fundamenta Informaticae 24 (1995) 3-23. </note>
Reference-contexts: For that reason, there has been an increasing interest in research on properties of rewriting under strategies. In particular, the study of termination is important when regarding such restricted versions of rewriting <ref> [35, 36, 45] </ref>. To prove innermost termination (also called (strong) innermost normalisation), one has to show that the length of every innermost reduction is finite. <p> The automated checking of this criterion enables us to prove innermost termination automatically, even if the TRS is not terminating. Additionally, for several classes of TRSs innermost termination already suffices for termination <ref> [35, 36] </ref>. Moreover, numerous modularity results exist for innermost termination [4, 5, 6, 35, 44, 45], which do not hold for termination. Therefore, for those classes of TRSs termination can be proved by splitting the TRS and proving innermost termination of the subsystems separately. <p> The automated checking of this criterion enables us to prove innermost termination automatically, even if the TRS is not terminating. Additionally, for several classes of TRSs innermost termination already suffices for termination [35, 36]. Moreover, numerous modularity results exist for innermost termination <ref> [4, 5, 6, 35, 44, 45] </ref>, which do not hold for termination. Therefore, for those classes of TRSs termination can be proved by splitting the TRS and proving innermost termination of the subsystems separately. <p> Moreover, using the results of Gramlich <ref> [35, 36] </ref>, Thm. 31 can also be applied to prove termination of TRSs that are non-overlapping (or for locally confluent overlay systems).
Reference: [36] <author> B. Gramlich, </author> <title> On proving termination by innermost termination, </title> <booktitle> in: Proc. RTA-96, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 1103 (Springer, </publisher> <address> Berlin, </address> <year> 1996) </year> <month> 93-107. </month>
Reference-contexts: For that reason, there has been an increasing interest in research on properties of rewriting under strategies. In particular, the study of termination is important when regarding such restricted versions of rewriting <ref> [35, 36, 45] </ref>. To prove innermost termination (also called (strong) innermost normalisation), one has to show that the length of every innermost reduction is finite. <p> The automated checking of this criterion enables us to prove innermost termination automatically, even if the TRS is not terminating. Additionally, for several classes of TRSs innermost termination already suffices for termination <ref> [35, 36] </ref>. Moreover, numerous modularity results exist for innermost termination [4, 5, 6, 35, 44, 45], which do not hold for termination. Therefore, for those classes of TRSs termination can be proved by splitting the TRS and proving innermost termination of the subsystems separately. <p> Moreover, using the results of Gramlich <ref> [35, 36] </ref>, Thm. 31 can also be applied to prove termination of TRSs that are non-overlapping (or for locally confluent overlay systems).
Reference: [37] <author> G. Huet and D. Lankford, </author> <title> On the uniform halting problem for term rewriting systems, </title> <type> Technical Report 283, </type> <institution> INRIA, Le Chesnay, France, </institution> <year> 1978. </year>
Reference-contexts: 1 Introduction Termination is one of the most fundamental properties of a term rewriting system (TRS), cf. e.g. [21]. While in general this problem is undecidable <ref> [37] </ref>, several methods for proving termination have been developed (e.g. path or-derings [17, 20, 40, 51, 55], Knuth-Bendix orderings [22, 42], forward closures fl Technical Report IBN 97/46, Darmstadt University of Technology.
Reference: [38] <author> G. Huet and J. M. Hullot, </author> <title> Proofs by induction in equational theories with constructors, </title> <note> Journal of Computer and System Sciences 25 (1982) 239-299. </note>
Reference-contexts: EVENODD (s (x); s (0)) &gt; EVENODD (x; 0) 65 After application of the AFS not (x) ! n, EVENODD (x; y) ! x, the recursive path ordering satisfies the resulting constraints. 5.1.38 Reversing Lists The following system is a slight variant of a TRS proposed by Huet and Hullot <ref> [38, `brev'] </ref>. Given a list x. l, the function rev calls two other functions rev1 and rev2, where rev1 (x; l) returns the last element of x. l and rev2 (x; l) returns the reversed list rev (x. l) without its first element.
Reference: [39] <author> J. M. Hullot, </author> <title> Canonical forms and unification, </title> <booktitle> in: Proc. CADE-5, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 87 (Springer, </publisher> <address> Berlin, </address> <year> 1980) </year> <month> 318-334. </month>
Reference-contexts: Note that if the reduction from t to v is always of the form t ! R t 0 ! fl then instead of s &gt; t v we may also require s &gt; t 0 v. To compute the terms t 0 we use narrowing (cf. e.g. <ref> [39] </ref>). Definition 21 (Narrowing) Let R be a TRS.
Reference: [40] <author> S. Kamin and J.-J. Levy, </author> <title> Two generalizations of the recursive path ordering, Unpublished Note, </title> <institution> Dept. of Computer Science, University of Illinois, Urbana, IL, </institution> <year> 1980. </year>
Reference-contexts: 1 Introduction Termination is one of the most fundamental properties of a term rewriting system (TRS), cf. e.g. [21]. While in general this problem is undecidable [37], several methods for proving termination have been developed (e.g. path or-derings <ref> [17, 20, 40, 51, 55] </ref>, Knuth-Bendix orderings [22, 42], forward closures fl Technical Report IBN 97/46, Darmstadt University of Technology. This is a preliminary version of an article which appeared in Theoretical Computer Science. y Department of Computer Science, Utrecht University, P.O. <p> We have presented a sound and complete termination criterion. In contrast to most other complete approaches (semantic path ordering <ref> [40] </ref>, general path ordering [20], semantic labelling [60] etc.) our method is particularly well suited 43 for automation as has been demonstrated in this paper. The only other complete criterion that has been used for automatic termination proofs (by Steinbach [54]) is the approach of transformation orderings [8, 11].
Reference: [41] <author> J. W. Klop, </author> <title> Term rewriting systems, </title> <editor> in: S. Abramsky, D. M. Gabbay, and T. S. E. Maibaum, eds., </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 2 (Oxford University Press, </publisher> <address> New York, </address> <year> 1992) </year> <month> 1-116. </month>
Reference-contexts: The following definition extends these notions to arbitrary term rewriting systems R (F ; R) (with the rules R over a signature F). For an introduction to term rewriting and its notations, we refer to Dershowitz and Jouannaud [21] and Klop <ref> [41] </ref>. Here, the root of a term f (: : :) is the leading function symbol f . Definition 1 (Defined symbols and constructors) Let R (F ; R) be a TRS. <p> are pairwise different variables out of x 1 ; : : : ; x n , g 62 F , and for every function symbol f 2 F there is at most one f -rule in the AFS. 3 Argument filtering TRSs are a special form of recursive program schemes <ref> [15, 41] </ref>. 11 From a rewriting point of view AFSs are quite simple, because every AFS is complete. Hence, for any term t the normal form t # A w.r.t. an AFS A is unique.
Reference: [42] <author> D. E. Knuth and P. B. Bendix, </author> <title> Simple word problems in universal algebras, </title> <editor> in: J. Leech, ed., </editor> <title> Computational problems in abstract algebra (Pergamon Press, </title> <year> 1970) </year> <month> 263-297. </month>
Reference-contexts: 1 Introduction Termination is one of the most fundamental properties of a term rewriting system (TRS), cf. e.g. [21]. While in general this problem is undecidable [37], several methods for proving termination have been developed (e.g. path or-derings [17, 20, 40, 51, 55], Knuth-Bendix orderings <ref> [22, 42] </ref>, forward closures fl Technical Report IBN 97/46, Darmstadt University of Technology. This is a preliminary version of an article which appeared in Theoretical Computer Science. y Department of Computer Science, Utrecht University, P.O.
Reference: [43] <author> T. Kolbe, </author> <title> Challenge problems for automated termination proofs of term rewriting systems, </title> <type> Technical Report IBN 96/42, </type> <institution> TU Darmstadt, Germany, </institution> <year> 1996. </year>
Reference-contexts: Moreover, using the results of Gramlich [35, 36], Thm. 31 can also be applied to prove termination of TRSs that are non-overlapping (or for locally confluent overlay systems). Example 33 As an example regard the following TRS by Kolbe <ref> [43] </ref> where quot (x; y; z) is used to compute 1 + ffi xy , if x y and z 6= 0 (i.e. quot (x; y; y) computes j y ). be non-negative, i.e. @[F](y;y;x) @x 0, cf. [31].
Reference: [44] <author> M. R. K. Krishna Rao, </author> <title> Modular proofs for completeness of hierarchical term rewriting systems, </title> <type> Theoret. </type> <institution> Comput. Sci. </institution> <month> 151 </month> <year> (1995) </year> <month> 487-512. </month>
Reference-contexts: The automated checking of this criterion enables us to prove innermost termination automatically, even if the TRS is not terminating. Additionally, for several classes of TRSs innermost termination already suffices for termination [35, 36]. Moreover, numerous modularity results exist for innermost termination <ref> [4, 5, 6, 35, 44, 45] </ref>, which do not hold for termination. Therefore, for those classes of TRSs termination can be proved by splitting the TRS and proving innermost termination of the subsystems separately.
Reference: [45] <author> M. R. K. Krishna Rao, </author> <title> Some characteristics of strong innermost normalization, </title> <booktitle> in: Proc. AMAST '96, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 1101 (Springer, </publisher> <address> Berlin, </address> <year> 1996) </year> <month> 406-420. </month>
Reference-contexts: For that reason, there has been an increasing interest in research on properties of rewriting under strategies. In particular, the study of termination is important when regarding such restricted versions of rewriting <ref> [35, 36, 45] </ref>. To prove innermost termination (also called (strong) innermost normalisation), one has to show that the length of every innermost reduction is finite. <p> The automated checking of this criterion enables us to prove innermost termination automatically, even if the TRS is not terminating. Additionally, for several classes of TRSs innermost termination already suffices for termination [35, 36]. Moreover, numerous modularity results exist for innermost termination <ref> [4, 5, 6, 35, 44, 45] </ref>, which do not hold for termination. Therefore, for those classes of TRSs termination can be proved by splitting the TRS and proving innermost termination of the subsystems separately.
Reference: [46] <author> D. S. Lankford, </author> <title> On proving term rewriting systems are Noetherian, </title> <institution> Memo MTP-3, Dept. of Mathematics, Louisiana Technical University, Ruston, LA, </institution> <year> 1979. </year>
Reference-contexts: Box 80.089, 3508 TB Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 [20, 47], semantic interpretations <ref> [12, 13, 31, 46, 53, 59] </ref>, transformation order--ings [8, 11, 54], distribution elimination [59], dummy elimination [26], semantic labelling [60] etc. | for surveys see e.g. [18, 55]). We present a new approach for the automation of termination proofs. <p> (x; y); s (y)) In the next section we show how quasi-orderings satisfying such sets of in equalities can be synthesized automatically using standard techniques. 2.3 Generating suitable quasi-orderings A well-founded ordering satisfying the constraints in Ex. 8 can for instance be generated by the well-known techniques of polynomial interpretations <ref> [46] </ref>. However, when using polynomial interpretations for direct termination proofs of TRSs, the polynomials have to be (strongly) monotonic in all their arguments, i.e. s &gt; t implies f (: : : s : : :) &gt; f (: : : t : : :).
Reference: [47] <author> D. S. Lankford and D. R. Musser, </author> <title> A finite termination criterion, </title> <year> 1978. </year>
Reference-contexts: This is a preliminary version of an article which appeared in Theoretical Computer Science. y Department of Computer Science, Utrecht University, P.O. Box 80.089, 3508 TB Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 <ref> [20, 47] </ref>, semantic interpretations [12, 13, 31, 46, 53, 59], transformation order--ings [8, 11, 54], distribution elimination [59], dummy elimination [26], semantic labelling [60] etc. | for surveys see e.g. [18, 55]). We present a new approach for the automation of termination proofs. <p> It turns out that the termination of several examples where the automation of Steinbach failed can be proved by our technique automatically, cf. Sect. 5. At first sight there seem to be some similarities between our method and forward closures <ref> [20, 47] </ref>. The idea of forward closures is to restrict the application of rules to that part of a term created by previous rewrites. Similar to our notion of chains, this notion also results in a sequence of terms, but the semantics of these sequences are completely different.
Reference: [48] <author> C. Marche and X. Urbain, </author> <type> Personal communication, </type> <year> 1997. </year>
Reference-contexts: The framework of dependency pairs, as introduced in this paper, is very general and is therefore well suited to be used for more general rewriting problems, too. For example, the framework of dependency pairs can easily be extended for termination modulo associativity and commutativity <ref> [48] </ref>. Moreover, several well-known and new modularity results can be derived in this framework [4, 6]. 5 Examples This collection of examples demonstrates the power of the described method.
Reference: [49] <author> A. Middeldorp, H. Ohsaki, and H. Zantema, </author> <title> Transforming termination by self-labelling, </title> <booktitle> in: Proc. CADE-13, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 1104 (Springer, </publisher> <address> Berlin, </address> <year> 1996) </year> <month> 373-387. </month>
Reference-contexts: However, this first method was restricted to non-overlapping constructor systems without nested recursion. In this approach, the dependency pair technique was based on a special form of semantic labelling (cf. [60]), called self-labelling (similar to the notion of self-labelling in <ref> [49] </ref>). Self-labelling determines unique labels for the terms and a dependency pair can be regarded as a combination of the label for the left-hand side with the labels for the right-hand side of a rule.
Reference: [50] <author> A. Middeldorp and H. Zantema, </author> <title> Simple termination of rewrite systems, </title> <type> Theoret. </type> <institution> Comput. Sci. </institution> <month> 175 </month> <year> (1997) </year> <month> 127-158. </month>
Reference-contexts: In most practical applications the synthesized orderings are total on ground terms [25] and therefore virtually all orderings used are simplification orderings <ref> [17, 18, 50, 55] </ref>. However, numerous TRSs are not simply terminating, i.e. not compatible with a simplification ordering. Hence, standard techniques like the recursive path ordering, polynomial interpretations, and the Knuth-Bendix ordering fail in proving termination of these TRSs.
Reference: [51] <author> D. A. Plaisted, </author> <title> A recursively defined ordering for proving termination of term rewriting systems, </title> <type> Report R-78-943, </type> <institution> Dept. of Computer Science, University of Illinois, Urbana, IL, </institution> <year> 1978. </year>
Reference-contexts: 1 Introduction Termination is one of the most fundamental properties of a term rewriting system (TRS), cf. e.g. [21]. While in general this problem is undecidable [37], several methods for proving termination have been developed (e.g. path or-derings <ref> [17, 20, 40, 51, 55] </ref>, Knuth-Bendix orderings [22, 42], forward closures fl Technical Report IBN 97/46, Darmstadt University of Technology. This is a preliminary version of an article which appeared in Theoretical Computer Science. y Department of Computer Science, Utrecht University, P.O.
Reference: [52] <author> D. A. Plaisted, </author> <title> A simple non-termination test for the Knuth-Bendix method, </title> <booktitle> in: Proc. CADE-8, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 230 (Springer, </publisher> <address> Berlin, </address> <year> 1986) </year> <month> 79-88. </month>
Reference-contexts: (x))) &gt; LASTBIT (x) CONV (s (s (x))) &gt; CONV (s (half (x))): After normalizing the inequalities w.r.t. the AFS half (x) ! x, x. y ! x, the con straints are satisfied by the recursive path ordering. 69 5.1.43 Termination by narrowing, version 1 The following TRS by Plaisted <ref> [52, 54] </ref> f (c) ! g (h (c)) k (x; h (x); c) ! h (x) can automatically be proved terminating by only replacing the dependency pair hH (g (x)); H (f (x))i by its narrowing hH (g (c)); H (g (h (c)))i and computing the dependency graph.
Reference: [53] <author> J. Steinbach, </author> <title> Generating polynomial orderings, </title> <journal> Inform. Processing Lett. </journal> <month> 49 </month> <year> (1994) </year> <month> 85-93. </month>
Reference-contexts: Box 80.089, 3508 TB Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 [20, 47], semantic interpretations <ref> [12, 13, 31, 46, 53, 59] </ref>, transformation order--ings [8, 11, 54], distribution elimination [59], dummy elimination [26], semantic labelling [60] etc. | for surveys see e.g. [18, 55]). We present a new approach for the automation of termination proofs. <p> Methods for the automated synthesis of polynomial orderings have for instance been developed in <ref> [31, 53] </ref>. In this way, termination 10 of this TRS can be proved fully automatically, although a direct termination proof with simplification orderings was not possible. Instead of polynomial orderings one can also use path orderings, which can easily be generated automatically.
Reference: [54] <author> J. Steinbach, </author> <title> Automatic termination proofs with transformation orderings, </title> <booktitle> in: Proc. RTA-95, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 914 (Springer, </publisher> <address> Berlin, </address> <year> 1995) </year> <month> 11-25. </month> <note> Full version appeared as Technical Report SR-92-93, </note> <institution> Universitat Kaiserslautern, Germany, </institution> <year> 1992. </year>
Reference-contexts: Box 80.089, 3508 TB Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 [20, 47], semantic interpretations [12, 13, 31, 46, 53, 59], transformation order--ings <ref> [8, 11, 54] </ref>, distribution elimination [59], dummy elimination [26], semantic labelling [60] etc. | for surveys see e.g. [18, 55]). We present a new approach for the automation of termination proofs. <p> See Sect. 5 for a collection of numerous such examples, including arithmetical operations (e.g. mod, gcd, logarithm, average), sorting 42 algorithms (such as selection sort, minimum sort, and quicksort), algorithms on graphs and trees, and several other well-known non-simply terminating TRSs (e.g. from <ref> [18, 20, 54] </ref>). Our termination criteria are based on the notion of dependency pairs. The concept of dependency pairs was introduced in [5] and a first method for its automation was proposed in [1]. <p> The only other complete criterion that has been used for automatic termination proofs (by Steinbach <ref> [54] </ref>) is the approach of transformation orderings [8, 11]. It turns out that the termination of several examples where the automation of Steinbach failed can be proved by our technique automatically, cf. Sect. 5. <p> This example was taken from Boyer and Moore [14] and Walther [57]. A variant of this example could be proved terminating using Steinbach's method for the automated generation of transformation orderings <ref> [54] </ref>, but there the rules for le and minus were missing. 5.1.7 Logarithm, version 1 The following TRS computes the dual logarithm. half (0) ! 0 half (s (s (x))) ! s (half (x)) log (s (0)) ! 0 log (s (s (x))) ! s (log (s (half (x)))) 49 The <p> This example comes from Walther [57] and a similar example was mentioned by Steinbach <ref> [54] </ref>, but in Steinbach's version the rules for eq and if rm were missing. <p> This example is inspired by an algorithm from Boyer and Moore [14] and Walther [58]. In the corresponding example from Steinbach <ref> [54] </ref> the rules for eq, le, if rm , and if min were missing. 5.1.11 Quicksort The following TRS is used to sort a list by the well-known quicksort algorithm. <p> Steinbach could prove termination of a corresponding example with transformation orderings <ref> [54] </ref>, but in his example the rules for le, if low , if high , and app were omitted. <p> more and which furthermore introduces nested recursion. plus (s (plus (x; y)); z) ! s (plus (plus (x; y); z)) Still, the resulting inequalities are satisfied using the same AFS and the lexicographic path ordering. 5.1.20 Addition with nested recursion, version 2 The following alternative TRS for addition from Steinbach <ref> [54] </ref> has nested recursion, too. 0 + y ! y s (x) + s (y) ! s (s (x) + (y + 0)) The `natural' polynomial interpretation (where + is mapped to the addition) maps left and right-hand sides of the rules to the same numbers. <p> For this example, a polynomial ordering can be used where 0 and s are interpreted as usual and both f (x; y) and F (x; y) are mapped to x. 5.1.24 Nested recursion, version 2 This system by Walther, which is similar to the preceding one, has been examined in <ref> [54] </ref>. f (0) ! s (0) f (s (s (x))) ! f (f (s (x))) The inequalities resulting from our transformation are satisfied by the polynomial ordering, where f (x) is mapped to the constant 1, F (x) is mapped to x, and where 0 and s are interpreted as usual. <p> are f (s (x); y; y) f (y; x; s (x)) which are satisfied by mapping f (x; y; z) to 0, mapping s (x) to x+1, and mapping F (x; y; z) to x + y. 5.1.30 Advantage of the dependency graph, version 1 The following system is from <ref> [54] </ref>. f (a; b) ! f (a; c) With our method, the termination proof for this system is trivial, because its dependency graph does not contain any cycles. <p> In a completely analogous way, termination of the one rule TRS f (g (x)) ! f (h (g (x))) from Bellegarde and Lescanne [10] and of the one rule system f (g (x; y); y) ! f (h (g (x; y)); a) from Steinbach <ref> [54] </ref> can also be proved. 5.1.35 Mutual recursion, version 1 The following system is from Steinbach [54] again. g (s (x)) ! f (x) f (s (x)) ! s (s (g (x))) The relevant inequalities are G (s (x)) F (x) After normalizing the resulting inequalities w.r.t. the AFS g (x) <p> TRS f (g (x)) ! f (h (g (x))) from Bellegarde and Lescanne [10] and of the one rule system f (g (x; y); y) ! f (h (g (x; y)); a) from Steinbach <ref> [54] </ref> can also be proved. 5.1.35 Mutual recursion, version 1 The following system is from Steinbach [54] again. g (s (x)) ! f (x) f (s (x)) ! s (s (g (x))) The relevant inequalities are G (s (x)) F (x) After normalizing the resulting inequalities w.r.t. the AFS g (x) ! x, the con straints are satisfied by the recursive path ordering. 64 5.1.36 Mutual recursion, <p> y + ssz) holds for large enough y and in the second case P (y + ssz; x + s0) &gt; P (x + s0; y + ssz) holds for large enough x. 68 5.1.41 Factorial The following non-simply terminating TRS for computing the factorial of a natural number (cf. <ref> [54, 60] </ref>) p (s (x)) ! x fac (s (x)) ! s (x) fi fac (p (s (x))) cannot be proved terminating automatically by the technique described in [2], since there narrowing dependency pairs was not considered. <p> By using narrowing, the dependency pair hFAC (s (x)); FAC (p (s (x)))i is replaced by the dependency pair hFAC (s (x)); FAC (x)i resulting in inequalities which can easily be satisfied. 5.1.42 Binary numbers The following non-simply terminating example is due to Geser <ref> [11, 54] </ref>. half (0) ! 0 half (s (0)) ! 0 half (s (s (x))) ! s (half (x)) lastbit (0) ! 0 lastbit (s (0)) ! s (0) lastbit (s (s (x))) ! lastbit (x) conv (0) ! nil. 0 conv (s (x)) ! conv (half (s (x))). lastbit (s <p> (x))) &gt; LASTBIT (x) CONV (s (s (x))) &gt; CONV (s (half (x))): After normalizing the inequalities w.r.t. the AFS half (x) ! x, x. y ! x, the con straints are satisfied by the recursive path ordering. 69 5.1.43 Termination by narrowing, version 1 The following TRS by Plaisted <ref> [52, 54] </ref> f (c) ! g (h (c)) k (x; h (x); c) ! h (x) can automatically be proved terminating by only replacing the dependency pair hH (g (x)); H (f (x))i by its narrowing hH (g (c)); H (g (h (c)))i and computing the dependency graph. <p> As there is no cycle consisting of the resulting pairs, the TRS is terminating. 5.1.44 Termination by narrowing, version 2 To prove termination of the following TRS from Bachmair <ref> [9, 54] </ref> f (h (x)) ! f (i (x)) h (a) ! b the dependency pairs hF (h (x)); F (i (x))i are replaced by their narrowings hF (h (a)); F (b)i Then termination is automatically proved by the fact that the dependency graph has no cycles. 5.1.45 Termination by narrowing, <p> relevant inequalities are F (s (x)) &gt; F (x) H (0. y) &gt; H (g (y)): The resulting constraints are satisfied by the recursive path ordering, if they are normalized using the AFS h (x) ! h 0 . 5.1.46 A non-totally terminating TRS The following example is from Steinbach <ref> [54] </ref>. f (x; x) ! f (a; b) This TRS is not totally terminating and without using narrowing, the inequalities generated by our technique are not satisfied by any total well-founded weakly monotonic quasi-ordering. <p> min rule would be replaced by min (add (n; nil)) ! element (n), then termination could also be proved by the termination technique of Sect. 2 using an appropriate AFS and the recursive path ordering to satisfy the constraints obtained.) 5.2.22 Intervals of Natural Numbers The following TRS from Steinbach <ref> [54] </ref> 83 intlist (nil) ! nil intlist (x. y) ! s (x). intlist (y) int (0; 0) ! 0. nil int (s (x); 0) ! nil int (s (x); s (y)) ! intlist (int (x; y)) is non-overlapping, too. <p> Hence, innermost termination (and thereby, termination) has been proved, as the TRS is non-overlapping. A similar example was mentioned by Steinbach <ref> [54] </ref>, but there the rules for le and if were missing. 5.2.26 Length of bit representation The following non-simply terminating TRS corresponds to the logarithm example (Ex. 5.1.7).
Reference: [55] <author> J. Steinbach, </author> <title> Simplification orderings: history of results, </title> <note> Fundamenta In-formaticae 24 (1995) 47-87. </note>
Reference-contexts: 1 Introduction Termination is one of the most fundamental properties of a term rewriting system (TRS), cf. e.g. [21]. While in general this problem is undecidable [37], several methods for proving termination have been developed (e.g. path or-derings <ref> [17, 20, 40, 51, 55] </ref>, Knuth-Bendix orderings [22, 42], forward closures fl Technical Report IBN 97/46, Darmstadt University of Technology. This is a preliminary version of an article which appeared in Theoretical Computer Science. y Department of Computer Science, Utrecht University, P.O. <p> Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 [20, 47], semantic interpretations [12, 13, 31, 46, 53, 59], transformation order--ings [8, 11, 54], distribution elimination [59], dummy elimination [26], semantic labelling [60] etc. | for surveys see e.g. <ref> [18, 55] </ref>). We present a new approach for the automation of termination proofs. Most well-known techniques for proving termination automatically try to find a well-founded ordering such that for all rules of the TRS the left-hand sides are greater than the corresponding right-hand sides. <p> In most practical applications the synthesized orderings are total on ground terms [25] and therefore virtually all orderings used are simplification orderings <ref> [17, 18, 50, 55] </ref>. However, numerous TRSs are not simply terminating, i.e. not compatible with a simplification ordering. Hence, standard techniques like the recursive path ordering, polynomial interpretations, and the Knuth-Bendix ordering fail in proving termination of these TRSs.
Reference: [56] <author> Y. Toyama, </author> <title> Counterexamples to the termination for the direct sum of term rewriting systems, </title> <journal> Inform. Processing Lett. </journal> <month> 25 </month> <year> (1987) </year> <month> 141-143. </month>
Reference-contexts: whenever there exists a substitution such that t ! fl R v, before unification we also have to rename multiple occurrences of the same variable x in t. (The reason is that different occurrences of x can reduce to different terms.) As an example consider the following TRS from Toyama <ref> [56] </ref>. f (0; 1; x) ! f (x; x; x) g (x; y) ! y The only dependency pair, viz. hF (0; 1; x); F (x; x; x)i, is on a cycle of the dependency graph, because F (x; x; x) reduces to F (0; 1; x 0 ), if replaces <p> Note that for the examples 5.2.14 - 5.2.18 and 5.2.24 - 5.2.29 we had to use refinements which were not included in the method of [3]. 5.2.1 Toyama example A famous example of a TRS that is innermost terminating, but not terminating, is the following system from Toyama <ref> [56] </ref>. f (0; 1; x) ! f (x; x; x) g (x; y) ! y: This TRS has only one dependency pair, viz. hF (0; 1; x); F (x; x; x)i.
Reference: [57] <author> C. Walther, Automatisierung von Terminierungsbeweisen (Vieweg, Braun-schweig, </author> <year> 1991). </year>
Reference-contexts: This example was taken from Boyer and Moore [14] and Walther <ref> [57] </ref>. <p> This example comes from Walther <ref> [57] </ref> and a similar example was mentioned by Steinbach [54], but in Steinbach's version the rules for eq and if rm were missing. <p> (s (half (x))i we obtain the relevant inequalities HALF (s (s (x))) &gt; HALF (x) BITS (s (s (x))) &gt; BITS (s (half (x)): The resulting constraints are satisfied by the recursive path ordering. 5.2.27 Multiplication for even and odd numbers The following non-simply terminating example is inspired by Walther <ref> [57] </ref>. even (0) ! true even (s (0)) ! false even (s (s (x))) ! even (x) half (0) ! 0 half (s (s (x))) ! s (half (x)) plus (0; y) ! y 86 plus (s (x); y) ! s (plus (x; y)) times (0; y) ! 0 times (s
Reference: [58] <author> C. Walther, </author> <title> On Proving the Termination of Algorithms by Machine, </title> <booktitle> Artif. Intell. </booktitle> <month> 71 </month> <year> (1994) </year> <month> 101-157. 93 </month>
Reference-contexts: But this version here is even more difficult: Termination of the corresponding algorithm cannot be proved by the method of Walther <ref> [58] </ref>, because this method cannot deal with permutations of arguments.) The relevant inequalities of this TRS are LE (s (x); s (y)) &gt; LE (x; y) GCD (s (x); s (y)) IF gcd (le (y; x); s (x); s (y)) IF gcd (true; s (x); s (y)) &gt; GCD (minus (x; <p> This example is inspired by an algorithm from Boyer and Moore [14] and Walther <ref> [58] </ref>. In the corresponding example from Steinbach [54] the rules for eq, le, if rm , and if min were missing. 5.1.11 Quicksort The following TRS is used to sort a list by the well-known quicksort algorithm. <p> With our technique, termination can still be proved in the same way. 5.1.12 Permutation of lists This example is a TRS from Walther <ref> [58] </ref> to compute a permutation of a list. <p> Hence, if in our example we perform at least one narrowing step, then we can determine that the dependency pair (42) does not form a cycle in the innermost dependency graph and then termination can again be verified using the recursive path ordering. 5.2.21 Selection sort This TRS from Walther <ref> [58] </ref> is obviously not simply terminating. The TRS can be used to sort a list by repeatedly replacing the minimum of the list by the head of the list.
Reference: [59] <author> H. Zantema, </author> <title> Termination of term rewriting: interpretation and type elim-ination, </title> <journal> J. Symb. Comp. </journal> <month> 17 </month> <year> (1994) </year> <month> 23-50. </month>
Reference-contexts: Box 80.089, 3508 TB Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 [20, 47], semantic interpretations <ref> [12, 13, 31, 46, 53, 59] </ref>, transformation order--ings [8, 11, 54], distribution elimination [59], dummy elimination [26], semantic labelling [60] etc. | for surveys see e.g. [18, 55]). We present a new approach for the automation of termination proofs. <p> Box 80.089, 3508 TB Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 [20, 47], semantic interpretations [12, 13, 31, 46, 53, 59], transformation order--ings [8, 11, 54], distribution elimination <ref> [59] </ref>, dummy elimination [26], semantic labelling [60] etc. | for surveys see e.g. [18, 55]). We present a new approach for the automation of termination proofs.
Reference: [60] <author> H. Zantema, </author> <title> Termination of Term Rewriting by Semantic Labelling, </title> <note> Fun-damenta Informaticae 24 (1995) 89-105. 94 </note>
Reference-contexts: Box 80.089, 3508 TB Utrecht, The Netherlands, E-mail: thomas@cs.ruu.nl z FB Informatik, Darmstadt University of Technology, Alexanderstr. 10, 64283 Darmstadt, Germany, E-mail: giesl@informatik.th-darmstadt.de 1 [20, 47], semantic interpretations [12, 13, 31, 46, 53, 59], transformation order--ings [8, 11, 54], distribution elimination [59], dummy elimination [26], semantic labelling <ref> [60] </ref> etc. | for surveys see e.g. [18, 55]). We present a new approach for the automation of termination proofs. <p> However, this first method was restricted to non-overlapping constructor systems without nested recursion. In this approach, the dependency pair technique was based on a special form of semantic labelling (cf. <ref> [60] </ref>), called self-labelling (similar to the notion of self-labelling in [49]). Self-labelling determines unique labels for the terms and a dependency pair can be regarded as a combination of the label for the left-hand side with the labels for the right-hand side of a rule. <p> We have presented a sound and complete termination criterion. In contrast to most other complete approaches (semantic path ordering [40], general path ordering [20], semantic labelling <ref> [60] </ref> etc.) our method is particularly well suited 43 for automation as has been demonstrated in this paper. The only other complete criterion that has been used for automatic termination proofs (by Steinbach [54]) is the approach of transformation orderings [8, 11]. <p> y + ssz) holds for large enough y and in the second case P (y + ssz; x + s0) &gt; P (x + s0; y + ssz) holds for large enough x. 68 5.1.41 Factorial The following non-simply terminating TRS for computing the factorial of a natural number (cf. <ref> [54, 60] </ref>) p (s (x)) ! x fac (s (x)) ! s (x) fi fac (p (s (x))) cannot be proved terminating automatically by the technique described in [2], since there narrowing dependency pairs was not considered.
References-found: 60

