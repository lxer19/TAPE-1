URL: http://pine.cs.yale.edu:4201/home/coin-full.ps
Refering-URL: http://pine.cs.yale.edu:4201/home/coin-abstract.html
Root-URL: http://www.cs.yale.edu
Title: Lower Bounds for Distributed Coin-Flipping and Randomized Consensus  
Author: James Aspnes 
Date: February 2, 1998  
Abstract: We examine a class of collective coin-flipping games that arises from randomized distributed algorithms with halting failures. In these games, a sequence of local coin flips is generated, which must be combined to form a single global coin flip. An adversary monitors the game and may attempt to bias its outcome by hiding the result of up to t local coin flips. We show that to guarantee at most constant bias, (t 2 ) local coins are needed, even if (a) the local coins can have arbitrary distributions and ranges, (b) the adversary is required to decide immediately whether to hide or reveal each local coin, and (c) the game can detect which local coins have been hidden. If the adversary is permitted to control the outcome of the coin except for cases whose probability is polynomial in t, (t 2 = log 2 t) local coins are needed. Combining this fact with an extended version of the well-known Fischer-Lynch-Paterson impossibility proof of deterministic consensus, we show that given an adaptive adversary, any t-resilient asynchronous consensus protocol requires (t 2 = log 2 t) local coin flips in any model that can be simulated deterministically using atomic registers. This gives the first non-trivial lower bound on the total work required by wait-free consensus and is tight to within logarithmic factors.
Abstract-found: 1
Intro-found: 1
Reference: [AAT94] <author> Rajeev Alur, Hagit Attiya, and Gadi Taubenfeld. </author> <title> Time-adaptive algorithms for synchronization. </title> <booktitle> In Proceedings of the Twenty-Sixth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 800-809, </pages> <address> Montreal, Quebec, Canada, </address> <month> may </month> <year> 1994. </year>
Reference-contexts: Restrictions on the amount of asynchrony can also have a large effect <ref> [AAT94, SSW91] </ref>.
Reference: [AB96] <author> Yonatan Aumann and Michael Bender. </author> <title> Efficient asynchronous consensus with a value-oblivious adversary scheduler. </title> <booktitle> In Proceedings of the 23rd International Conference on Automata, Languages, and Programming, </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: Various versions of this can be found in the the consensus work of Chor, Israeli, and Li [CIL87] and Abrahamson [Abr88], and in the O (n log 2 n) total work protocol of Aumann and Bender <ref> [AB96] </ref>, the O (log 2 n) work-per-process protocol of Chandra [Cha96], and the recent O (log n) work-per-process protocol of Aumann [Aum97]. Restrictions on the amount of asynchrony can also have a large effect [AAT94, SSW91].
Reference: [Abr88] <author> K. Abrahamson. </author> <title> On achieving consensus using a shared memory. </title> <booktitle> In Proceedings of the Seventh ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1988. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson <ref> [Abr88] </ref>; since its appearance, numerous polynomial-time algorithms have appeared [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96]. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting. <p> One plausible approach is to limit the knowledge the adversary has of register contents, to prevent it from discriminating against coin-flips it dislikes. Various versions of this can be found in the the consensus work of Chor, Israeli, and Li [CIL87] and Abrahamson <ref> [Abr88] </ref>, and in the O (n log 2 n) total work protocol of Aumann and Bender [AB96], the O (log 2 n) work-per-process protocol of Chandra [Cha96], and the recent O (log n) work-per-process protocol of Aumann [Aum97].
Reference: [ADS89] <author> Hagit Attiya, Danny Dolev, and Nir Shavit. </author> <title> Bounded polynomial randomized consensus. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 281-294, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting.
Reference: [AH90] <author> James Aspnes and Maurice Herlihy. </author> <title> Fast randomized consensus using shared memory. </title> <journal> Journal of Algorithms, </journal> <volume> 11(3) </volume> <pages> 441-461, </pages> <month> Septem-ber </month> <year> 1990. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting. <p> in the wait-free case), this requires a total of (n 2 ) local coin-flips, and at least (n 2 ) work in order to communicate these coin-flips. 1 Improvements in other aspects of consensus algorithms have steadily brought their costs down, from the O (n 4 ) total work of <ref> [AH90] </ref> to the O (n 2 log n) total work of [BR91]. But while these algorithms have steadily approached the (n 2 ) barrier, none have broken it.
Reference: [AN90] <author> Noga Alon and Moni Naor. </author> <title> Coin-flipping games immune against linear-sized coalitions. </title> <booktitle> In Proceedings of the 31st Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 46-54. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: Many such games assume that the locations of faulty coins are fixed in advance; under these assumptions very efficient games exist <ref> [AN90, CL93, BOL89, Sak89] </ref>.
Reference: [Asp93] <author> James Aspnes. </author> <title> Time- and space-efficient randomized consensus. </title> <journal> Journal of Algorithms, </journal> <volume> 14(3) </volume> <pages> 414-431, </pages> <month> May </month> <year> 1993. </year> <month> 35 </month>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting. <p> However, no proof was known that consensus could not be solved in less than (n 2 ) time; the barrier was solely a result of the apparent absence of alternatives to using shared coins based on majority voting. Indeed, it was asked in <ref> [Asp93] </ref> if every consensus protocol contained an embedded shared coin protocol; and (specializing a more general and still open question of Ben-Or and Linial [BOL89]) if no shared coin protocol in this model could beat the (n 2 ) cost of majority voting. 1 Some of the algorithms deviate slightly from <p> In the algorithm of Aspnes <ref> [Asp93] </ref>, some votes are generated deterministically. In the algorithm of Saks, Shavit, and Woll [SSW91], several coin-flipping protocols optimized for different execution patterns are run in parallel.
Reference: [Asp97] <author> James Aspnes. </author> <title> Lower bounds for distributed coin-flipping and ran-domized consensus. </title> <booktitle> In Proceedings of the Twenty-Ninth Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 559-568. </pages> <publisher> ACM, </publisher> <month> May </month> <year> 1997. </year>
Reference-contexts: Consensus is a fundamental problem in distributed computing in which a group of processes must agree on a bit despite the interference of an adversary. (An additional condition forbids trivial solutions that always produce the same fl A preliminary version of this paper appeared in STOC '97 <ref> [Asp97] </ref>. y Yale University, Department of Computer Science, 51 Prospect Street/P.O. Box 208285, New Haven, CT 06520-8285. Supported by NSF grants CCR-9410228 and CCR-9415410. E-mail: aspnes@cs.yale.edu. 1 answer).
Reference: [Aum97] <author> Yonatan Aumann. </author> <title> Efficient asynchronous consensus with the weak adversary scheduler. </title> <booktitle> In Proceedings of the Sixteenth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 209-218, </pages> <year> 1997. </year>
Reference-contexts: in the the consensus work of Chor, Israeli, and Li [CIL87] and Abrahamson [Abr88], and in the O (n log 2 n) total work protocol of Aumann and Bender [AB96], the O (log 2 n) work-per-process protocol of Chandra [Cha96], and the recent O (log n) work-per-process protocol of Aumann <ref> [Aum97] </ref>. Restrictions on the amount of asynchrony can also have a large effect [AAT94, SSW91].
Reference: [AW96] <author> James Aspnes and Orli Waarts. </author> <title> Randomized consensus in O(n log 2 n) operations per processor. </title> <journal> SIAM Journal on Computing, </journal> <volume> 25(5) </volume> <pages> 1024-1044, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting. <p> In the algorithm of Aspnes [Asp93], some votes are generated deterministically. In the algorithm of Saks, Shavit, and Woll [SSW91], several coin-flipping protocols optimized for different execution patterns are run in parallel. In the algorithm of Aspnes and Waarts <ref> [AW96] </ref>, processes that have already cast many votes generate votes with increasing weights in order to finish the protocol quickly.
Reference: [BOL89] <author> Michael Ben-Or and Nathan Linial. </author> <title> Collective coin flipping. </title> <editor> In Silvio Micali, editor, </editor> <booktitle> Randomness and Computation, volume 5 of Advances in Computing Research, </booktitle> <pages> pages 91-115. </pages> <publisher> JAI Press, </publisher> <year> 1989. </year>
Reference-contexts: Indeed, it was asked in [Asp93] if every consensus protocol contained an embedded shared coin protocol; and (specializing a more general and still open question of Ben-Or and Linial <ref> [BOL89] </ref>) if no shared coin protocol in this model could beat the (n 2 ) cost of majority voting. 1 Some of the algorithms deviate slightly from the simple majority-voting approach described here. In the algorithm of Aspnes [Asp93], some votes are generated deterministically. <p> Furthermore, it is tight in the sense that it shows that no constant-bias shared coin can use less than (t 2 ) local coins, a bound achieved by majority voting. 1.2 Related Work Many varieties of collective coin-flipping games have been studied, starting with the work of Ben-Or and Linial <ref> [BOL89] </ref>. Many such games assume that the locations of faulty coins are fixed in advance; under these assumptions very efficient games exist [AN90, CL93, BOL89, Sak89]. <p> Many such games assume that the locations of faulty coins are fixed in advance; under these assumptions very efficient games exist <ref> [AN90, CL93, BOL89, Sak89] </ref>. <p> based 3 on the execution of the protocol so far, the best strategy for minimizing the adversary's influence in many models seems to be to take the majority of fair coin-flips, the idea being that the majority function minimizes the influence of any single local coin. 2 Ben-Or and Linial <ref> [BOL89] </ref> observed that with a restriction to fair coins, Harper's isoperimetric inequality for the hypercube [Har66] implies that the majority function gives the least power to an off-line adversary that can see all coins before deciding which to change (a one-round protocol), and conjectured that a similar result held for multi-round <p> They show that any such consensus protocol must use ( p n) distinct registers to guarantee agreement. Unfortunately, their techniques do not appear to generalize to showing lower bounds on work. 2 Coin-Flipping Games A collective coin-flipping game <ref> [BOL89] </ref> is an algorithm for combining many local coins into a single global coin, whose bias should be small even though some of the local coins may be obscured by a malicious adversary. <p> A still more general question asked by Ben-Or and Linial in <ref> [BOL89] </ref>, also still open, is whether majority voting is optimal in a Byzantine model where 34 processes may vote more than once but in which the adversary controls all future votes of a process once it has been corrupted.
Reference: [BOLS87] <author> M. Ben-Or, N. Linial, and M. Saks. </author> <title> Collective coin flipping and other models of imperfect randomness. In Combinatorics, </title> <journal> volume 52 of Colloquia Mathematic Societatis Janos Bolyai, </journal> <pages> pages 75-112, </pages> <address> Eger (Hungary), </address> <year> 1987. </year>
Reference-contexts: first i coins, and observes that if there is a large jump between X i and X i+1 the adversary can get a large influence over 2 An excellent survey of results for a wide variety of models involving fair or nearly fair two-valued local coins can be found in <ref> [BOLS87] </ref>. 4 the outcome of the game by hiding the (i + 1)-th local coin. Part of the motivation for our work on coin-flipping games was to show a lower bound on the work used by wait-free shared-memory consensus.
Reference: [BR90] <author> Gabi Bracha and Ophir Rachman. </author> <title> Approximated counters and randomized consensus. </title> <type> Technical Report 662, </type> <institution> Technion, </institution> <year> 1990. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting.
Reference: [BR91] <author> Gabi Bracha and Ophir Rachman. </author> <title> Randomized consensus in expected O(n 2 log n) operations. </title> <booktitle> In Proceedings of the Fifth Workshop on Distributed Algorithms, </booktitle> <year> 1991. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting. <p> ) local coin-flips, and at least (n 2 ) work in order to communicate these coin-flips. 1 Improvements in other aspects of consensus algorithms have steadily brought their costs down, from the O (n 4 ) total work of [AH90] to the O (n 2 log n) total work of <ref> [BR91] </ref>. But while these algorithms have steadily approached the (n 2 ) barrier, none have broken it.
Reference: [CFG + 85] <author> Benny Chor, Joel Friedman, Oded Goldreich, Johan H-astad, Steven Rudich, and Roman Smolensky. </author> <title> The bit extraction problem or t-resilient functions. </title> <booktitle> In Proceedings of the 2th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 396-407. </pages> <publisher> IEEE, </publisher> <year> 1985. </year>
Reference-contexts: Another assumption that greatly limits the power of the adversary is to require that both the locations and values of faulty coins are fixed in advance; this is the bit extraction problem <ref> [CFG + 85, Fri92, Vaz85] </ref>, in which it is possible to derive completely unbiased random bits. If none of these limiting assumptions are made, the adversary gains considerably more power.
Reference: [Cha96] <author> Tushar Deepak Chandra. </author> <title> Polylog randomized wait-free consensus. </title> <booktitle> In Proceedings of the Fifteenth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 166-175, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: This is not the case for consensus; for example, Chandra's consensus algorithm <ref> [Cha96] </ref> for a weak adversary switches over to an algorithm that is robust against an adaptive adversary if it does not finish in its usual time. 22 or not to kill each process immediately following each internal random event. (Since this step reduces the options of the adversary it can only <p> Various versions of this can be found in the the consensus work of Chor, Israeli, and Li [CIL87] and Abrahamson [Abr88], and in the O (n log 2 n) total work protocol of Aumann and Bender [AB96], the O (log 2 n) work-per-process protocol of Chandra <ref> [Cha96] </ref>, and the recent O (log n) work-per-process protocol of Aumann [Aum97]. Restrictions on the amount of asynchrony can also have a large effect [AAT94, SSW91].
Reference: [CI93] <author> Richard Cleve and Russell Impagliazzo. </author> <title> Martingales with Boolean final value must make jumps of O(1=n 1=2 ) with constant probability. </title> <type> Unpublished manuscript, </type> <year> 1993. </year>
Reference-contexts: The best previously known bound for arbitrary local coins is a bound of (1= n) on the influence of an adversary that can hide one coin, due to Cleve and Impagliazzo <ref> [CI93] </ref>. They show that in any martingale sequence starting at 0 and ending at 1, with at least constant probability there is a jump of at least (1= n).
Reference: [CIL87] <author> B. Chor, A. Israeli, and M. Li. </author> <title> On processor coordination using asynchronous hardware. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 86-97, </pages> <year> 1987. </year>
Reference-contexts: Box 208285, New Haven, CT 06520-8285. Supported by NSF grants CCR-9410228 and CCR-9415410. E-mail: aspnes@cs.yale.edu. 1 answer). In an asynchronous setting, it has long been known that if an adversary can halt a single process, then no deterministic consensus algorithm is possible without the use of powerful synchronization primitives <ref> [CIL87, DDS87, FLP85, Her91, LAA87] </ref>. In contrast, randomized algorithms can solve consensus in a shared-memory system for n processes even if the adversary can halt up to n 1 processes. <p> One plausible approach is to limit the knowledge the adversary has of register contents, to prevent it from discriminating against coin-flips it dislikes. Various versions of this can be found in the the consensus work of Chor, Israeli, and Li <ref> [CIL87] </ref> and Abrahamson [Abr88], and in the O (n log 2 n) total work protocol of Aumann and Bender [AB96], the O (log 2 n) work-per-process protocol of Chandra [Cha96], and the recent O (log n) work-per-process protocol of Aumann [Aum97].
Reference: [CL93] <author> Jason Cooper and Nathan Linial. </author> <title> Fast perfect-information leader-election protocol with linear immunity. </title> <booktitle> In Proceedings of the Twenty-Fifth Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 662-671. </pages> <publisher> ACM, </publisher> <year> 1993. </year> <month> 36 </month>
Reference-contexts: Many such games assume that the locations of faulty coins are fixed in advance; under these assumptions very efficient games exist <ref> [AN90, CL93, BOL89, Sak89] </ref>.
Reference: [DDS87] <author> D. Dolev, C. Dwork, and L. Stockmeyer. </author> <title> On the minimal syn-chronism needed for distributed consensus. </title> <journal> Journal of the ACM, </journal> <volume> 34(1) </volume> <pages> 77-97, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Box 208285, New Haven, CT 06520-8285. Supported by NSF grants CCR-9410228 and CCR-9415410. E-mail: aspnes@cs.yale.edu. 1 answer). In an asynchronous setting, it has long been known that if an adversary can halt a single process, then no deterministic consensus algorithm is possible without the use of powerful synchronization primitives <ref> [CIL87, DDS87, FLP85, Her91, LAA87] </ref>. In contrast, randomized algorithms can solve consensus in a shared-memory system for n processes even if the adversary can halt up to n 1 processes.
Reference: [DHPW92] <author> Cynthia Dwork, Maurice Herlihy, Serge Plotkin, and Orli Waarts. </author> <title> Time-lapse snapshots. </title> <booktitle> In Proceedings of Israel Symposium on the Theory of Computing and Systems, </booktitle> <year> 1992. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting.
Reference: [FHS93] <author> Faith Fich, Maurice Herlihy, and Nir Shavit. </author> <title> On the complexity of randomized synchronization. </title> <booktitle> In Proceedings of the 12th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: Part of the motivation for our work on coin-flipping games was to show a lower bound on the work used by wait-free shared-memory consensus. A very nice lower bound on the space used by wait-free shared-memory consensus is due to Fich, Herlihy, and Shavit <ref> [FHS93] </ref>. They show that any such consensus protocol must use ( p n) distinct registers to guarantee agreement.
Reference: [FLP85] <author> M. Fischer, N.A. Lynch, </author> <title> and M.S. Paterson. Impossibility of distributed commit with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2), </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: Box 208285, New Haven, CT 06520-8285. Supported by NSF grants CCR-9410228 and CCR-9415410. E-mail: aspnes@cs.yale.edu. 1 answer). In an asynchronous setting, it has long been known that if an adversary can halt a single process, then no deterministic consensus algorithm is possible without the use of powerful synchronization primitives <ref> [CIL87, DDS87, FLP85, Her91, LAA87] </ref>. In contrast, randomized algorithms can solve consensus in a shared-memory system for n processes even if the adversary can halt up to n 1 processes. <p> These ranges are used to define a probabilistic version of the bivalence and univalence conditions used in the well-known Fischer-Lynch-Paterson (FLP) impossibility proof for deterministic consensus <ref> [FLP85] </ref>. We will define an execution as bivalent if the adversary can force either outcome with high probability. A v-valent execution will be one after which only the outcome v can be forced with high probability.
Reference: [Fri92] <author> Joel Friedman. </author> <title> On the bit extraction problem. </title> <booktitle> In Proceedings of the 33rd Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 314-319. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Another assumption that greatly limits the power of the adversary is to require that both the locations and values of faulty coins are fixed in advance; this is the bit extraction problem <ref> [CFG + 85, Fri92, Vaz85] </ref>, in which it is possible to derive completely unbiased random bits. If none of these limiting assumptions are made, the adversary gains considerably more power.
Reference: [Har66] <author> L. H. Harper. </author> <title> Optimal numberings and isoperimetric problems on graphs. </title> <journal> Journal of Combinatorial Theory, </journal> <volume> 1 </volume> <pages> 385-394, </pages> <year> 1966. </year>
Reference-contexts: the adversary's influence in many models seems to be to take the majority of fair coin-flips, the idea being that the majority function minimizes the influence of any single local coin. 2 Ben-Or and Linial [BOL89] observed that with a restriction to fair coins, Harper's isoperimetric inequality for the hypercube <ref> [Har66] </ref> implies that the majority function gives the least power to an off-line adversary that can see all coins before deciding which to change (a one-round protocol), and conjectured that a similar result held for multi-round protocols in which n processes repeatedly executed rounds in which each flipped a coin and
Reference: [Her91] <author> Maurice Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 124-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Box 208285, New Haven, CT 06520-8285. Supported by NSF grants CCR-9410228 and CCR-9415410. E-mail: aspnes@cs.yale.edu. 1 answer). In an asynchronous setting, it has long been known that if an adversary can halt a single process, then no deterministic consensus algorithm is possible without the use of powerful synchronization primitives <ref> [CIL87, DDS87, FLP85, Her91, LAA87] </ref>. In contrast, randomized algorithms can solve consensus in a shared-memory system for n processes even if the adversary can halt up to n 1 processes. <p> In contrast, randomized algorithms can solve consensus in a shared-memory system for n processes even if the adversary can halt up to n 1 processes. Such algorithms are called wait-free <ref> [Her91] </ref> because any process can finish the algorithm without waiting for slower (or possibly dead) processes.
Reference: [LAA87] <author> Michael C. Loui and Hosame H. Abu-Amara. </author> <title> Memory requirements for agreement among unreliable asynchronous processes. </title> <editor> In Franco P. Preparata, editor, </editor> <booktitle> Advances in Computing Research, </booktitle> <volume> volume 4. </volume> <publisher> JAI Press, </publisher> <year> 1987. </year>
Reference-contexts: Box 208285, New Haven, CT 06520-8285. Supported by NSF grants CCR-9410228 and CCR-9415410. E-mail: aspnes@cs.yale.edu. 1 answer). In an asynchronous setting, it has long been known that if an adversary can halt a single process, then no deterministic consensus algorithm is possible without the use of powerful synchronization primitives <ref> [CIL87, DDS87, FLP85, Her91, LAA87] </ref>. In contrast, randomized algorithms can solve consensus in a shared-memory system for n processes even if the adversary can halt up to n 1 processes.
Reference: [LLS89] <author> D. Lichtenstein, N. Linial, and M. Saks. </author> <title> Some extremal problems arising from discrete control processes. </title> <journal> Combinatorica, </journal> <volume> 9 </volume> <pages> 269-287, </pages> <year> 1989. </year>
Reference-contexts: work applies to systems in which the adversary can only alter one local coin-flip for each process that it subverts. (One can think of this restriction as assuming halting failures rather than Byzan-tine failures in the processes.) A previous paper with similar scope was that of Lichtenstein, Linial, and Saks <ref> [LLS89] </ref>, who showed that majority is optimal under the assumption of fair local coins in a sequential game similar to the one we consider here. <p> answered is the following: Does the majority of n fair coin-flips give an optimal coin-flipping game (in the sense of having minimum bias) with an adversary that can censor up to k flips? Majority is optimal for similar models (e.g., in the fair-local-coin model studied by Licht-enstein, Linial, and Saks <ref> [LLS89] </ref>).
Reference: [Lyn96] <author> Nancy A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: who is familiar with previous work on asynchronous shared-memory systems will find no surprises here, and may wish to skip ahead to the actual proof starting in Section 3.3. 3.2.1 Foundations There are many ways to represent a distributed system; we will use the I/O automaton model as described in <ref> [Lyn96] </ref>. In this model, an execution of a system is represented by a sequence s 0 ; 1 ; s 1 ; 2 ; : : : of alternating states and actions, starting with an initial state. <p> that the adversary does not itself use a randomized strategy; since we are in the lower-bound business this restriction on the adversary does 25 not affect our results. 3.2.2 Shared-Memory Model The lower bound for randomized consensus will be given in the context of the standard asynchronous shared-memory model (see <ref> [Lyn96] </ref> for a definition of the shared-memory model in terms of I/O automata). In this model, the processes communicate by reading and writing a set of shared atomic registers.
Reference: [Sak89] <author> Michael Saks. </author> <title> A robust non-cryptographic protocol for collective coin flipping. </title> <journal> SIAM Journal on Discrete Mathematics, </journal> <volume> 2(2) </volume> <pages> 240-244, </pages> <year> 1989. </year>
Reference-contexts: Many such games assume that the locations of faulty coins are fixed in advance; under these assumptions very efficient games exist <ref> [AN90, CL93, BOL89, Sak89] </ref>.
Reference: [SSW91] <author> Michael Saks, Nir Shavit, and Heather Woll. </author> <title> Optimal time randomized consensus | making resilient algorithms fast in practice. </title> <booktitle> In Proceedings of the Second Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 351-362, </pages> <year> 1991. </year> <month> 37 </month>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting. <p> In the algorithm of Aspnes [Asp93], some votes are generated deterministically. In the algorithm of Saks, Shavit, and Woll <ref> [SSW91] </ref>, several coin-flipping protocols optimized for different execution patterns are run in parallel. In the algorithm of Aspnes and Waarts [AW96], processes that have already cast many votes generate votes with increasing weights in order to finish the protocol quickly. <p> Restrictions on the amount of asynchrony can also have a large effect <ref> [AAT94, SSW91] </ref>.
Reference: [Vaz85] <author> Umesh Vazirani. </author> <title> Towards a strong communication complexity the-ory, or generating quasi-random sequences from two communicating slightly-random sources. </title> <booktitle> In Proceedings of the Twenty-Ninth Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 366-378. </pages> <publisher> ACM, </publisher> <year> 1985. </year> <month> 38 </month>
Reference-contexts: Another assumption that greatly limits the power of the adversary is to require that both the locations and values of faulty coins are fixed in advance; this is the bit extraction problem <ref> [CFG + 85, Fri92, Vaz85] </ref>, in which it is possible to derive completely unbiased random bits. If none of these limiting assumptions are made, the adversary gains considerably more power.
References-found: 32

