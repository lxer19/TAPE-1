URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/user/rdeline/www/publications/unicon-iccds-paper/ICCDS-96.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/user/rdeline/www/publications/unicon-iccds-paper/index.html
Root-URL: 
Title: Abstractions and Implementations for Architectural Connections  
Author: Mary Shaw, Robert DeLine, Gregory Zelesnik 
Keyword: software architecture, connectors, software system organization, architectural abstraction, architecture description language, system configuration  
Address: Pittsburgh PA 15213  
Affiliation: Computer Science Department Carnegie Mellon University  
Abstract: The architecture of a software system shows how the system is realized by a collection of components and the interactions among these components. Conventional design focuses on defining the components, but the properties of the system depend critically on the character of the interactions. Although software designers have good informal abstractions for these interactions, the abstractions are poorly supported by the available languages and tools. As a result, the choice of interaction is often defaulted or implicit rather than deliberate choice; further, interactions may be defined in terms of underlying mechanisms rather than the designers natural abstractions. UniCon provides a rich selection of abstractions for the connectors that mediate interactions among components. To create systems using these connector abstractions, you need to produce and integrate not only the object code for components, but also a variety of other runtime products. To extend the set of connectors supported by UniCon, you need to identify and isolate many kinds of information in the compiler, graphical editor, and associated tools. This paper describes the role of connector abstractions in software design, the connector abstractions currently supported by UniCon, and implementation issues associated with supporting an open-ended collection of connectors. 
Abstract-found: 1
Intro-found: 1
Reference: [AG94] <author> Robert Allen and David Garlan. </author> <title> Formalizing Architectural Connection. </title> <booktitle> In Proc Sixteenth International Conference on Software Engineering , 1993. </booktitle>
Reference-contexts: This type indicates which roles must be satisfied for the connector to operate properly, together with the types of players that are eligible to play the roles. Allen and Garlan have explored formal specifications of the roles <ref> [AG94] </ref>.
Reference: [Co79] <author> L. W. Cooprider. </author> <booktitle> The Representation of Families of Software Systems . PhD Thesis, </booktitle> <institution> Carnegie Mellon University. </institution> <month> April </month> <year> 1979. </year>
Reference-contexts: Since DeRemer and Krons MIL, MILs have been developed for specific languages, like Mesa [MMS79] and Ada [CE78], and have provided a base from which to support software construction [Th76], version control <ref> [Co79] </ref>, system families [Ti79], and dynamic configuration [MKS89]. Enough examples are available to develop models of the design space [Pe87, PN86]. These early module interconnection languages require considerable prior agreement between the developers of different modules.
Reference: [CE78] <institution> SARA Aided Design of Software for Concurrent Systems. </institution> <note> Proc. National Computer Conference , 1978. </note>
Reference-contexts: Since DeRemer and Krons MIL, MILs have been developed for specific languages, like Mesa [MMS79] and Ada <ref> [CE78] </ref>, and have provided a base from which to support software construction [Th76], version control [Co79], system families [Ti79], and dynamic configuration [MKS89]. Enough examples are available to develop models of the design space [Pe87, PN86].
Reference: [Cl95] <author> Goeffrey H. Clemm. </author> <title> The Odin System. </title> <booktitle> Proc. 5th Software Configuration Management Workshop (SCM5), </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: We discovered the kinds of tasks the UniCon compiler must carry out and the kinds of intermediate and final products required for each type of 1 Odin is a system construction utility similar to the make utility in Unix <ref> [Cl95] </ref>. System construction instructions are specified in an Odinfile, similar to a Makefile, which Odin uses to compute complete dependency information automatically. Odins scripts are shorter and simpler than makes.
Reference: [CP91] <author> John R. Callahan and James M. Purtilo. </author> <title> A Packaging System for Heterogeneous Execution Environments. </title> <journal> IEEE Trans. on Software Engineering , 17(6): </journal> <pages> 626-635, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Newer work has begun to soften these restrictions. In the Darwin language, modules can be dynamically instantiated and bound at runtime [MDK93]. Polygen <ref> [CP91] </ref> augments a module interconnection language with an inference engine that deduces from a user-defined set of rules how (or whether) a system can be integrated from set of modules.
Reference: [DK76] <author> Frank DeRemer and Hans H. Kron. </author> <title> Programming-in-the-Large versus Programming-in-the-Small. </title> <journal> IEEE Trans. on Software Engineering , SE-2(2):80-86, </journal> <month> June </month> <year> 1976. </year>
Reference-contexts: This knowledge is realized as Odin construction instructions that are executed to build the final system. 5. Related Work Notations for describing the configuration of software systems has a long history. In 1975, DeRemer and Kron <ref> [DK76] </ref> created a notation for describing the structure of module-based programs, called a module interconnection language (MIL). In an MIL notation, modules import and export resources, which are named elements such as type definitions, constants, variables, and functions.
Reference: [Gar95] <editor> David Garlan (ed) First International Workshop on Architectures for Software Systems, </editor> <booktitle> Workshop Summary ACM Software Engineering Notes , 20(3) </booktitle> <pages> 84-89, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: These configuration notations have recently matured enough to describe both statically and dynamically structured distributed systems [MDK94]. More recently, languages such as UniCon for describing system architectures have started to emerge <ref> [Gar95] </ref>. 6. Conclusion Our objective is to support the abstractions actually used by software designers to describe the architectures of their software systems. These abstractions are at a considerably higher level than the code.
Reference: [GS93] <author> David Garlan and Mary Shaw. </author> <title> An Introduction to Software Architecture. </title> <editor> In V. Ambriola and G. Tortora (eds), </editor> <booktitle> Advances in Software Engineering and Knowledge Engineering , vol. </booktitle> <volume> 2, </volume> <publisher> World Scientific Publishing Company, </publisher> <year> 1993, </year> <month> pp.1-39. </month>
Reference-contexts: For example, a designer may describe a system as a set of real-time processes interacting via remote procedure calls; or as a set of independent experts interacting through a shared blackboard; or as a dataflow architecture with information flowing via pipes through a set of filters <ref> [GS93, PW92] </ref>. The designer typically focuses on the components: decomposing system functionality into components, choosing representations, and defining interfaces. The choice of how the components should interactthe connectorsis often made implicitly or by default.
Reference: [KRPOH93] <author> M. H. Klein, T. Ralya, B. Pollak, R. Obenza, and M. G. Harobur. </author> <title> A Practitioners Handbook for Real-Time Analysis: Guide to Rate Monotonic Analysis for Re al-Time Systems . Kluwer Academic Publishers, </title> <year> 1993. </year>
Reference-contexts: Analysis Expertise Some parts of a design lend themselves to certain types of analyses. For example, the execution time, priority, and period properties of a set of schedulable processes can be analyzed using rate monotonic analysis (RMA) to see if they will all meet their deadlines <ref> [KRPOH93] </ref>. The knowledge of how to perform applicable analyses is contained in the connector experts.
Reference: [MDK93] <author> J. Magee, N. Dulay, and J. Kramer. </author> <title> Structuring parallel and distributed programs. </title> <journal> Software Engineering Journal , 8(2) </journal> <pages> 73-82, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Newer work has begun to soften these restrictions. In the Darwin language, modules can be dynamically instantiated and bound at runtime <ref> [MDK93] </ref>. Polygen [CP91] augments a module interconnection language with an inference engine that deduces from a user-defined set of rules how (or whether) a system can be integrated from set of modules.
Reference: [MDK94] <author> J. Magee, N. Dulay, and J. Kramer. </author> <title> A constructive development environment for parallel and distributed programs. </title> <booktitle> Proc. Second International Workshop on Configurable Distributed Systems , March 1994. </booktitle>
Reference-contexts: These configuration notations have recently matured enough to describe both statically and dynamically structured distributed systems <ref> [MDK94] </ref>. More recently, languages such as UniCon for describing system architectures have started to emerge [Gar95]. 6. Conclusion Our objective is to support the abstractions actually used by software designers to describe the architectures of their software systems. These abstractions are at a considerably higher level than the code.
Reference: [MKS89] <author> J. Magee, J. Kramer, and M. Sloman. </author> <title> Constructing distributed systems in CONIC. </title> <journal> IEEE Tr. on Software Engineering , SE-15(6):663-675, </journal> <year> 1989. </year>
Reference-contexts: Since DeRemer and Krons MIL, MILs have been developed for specific languages, like Mesa [MMS79] and Ada [CE78], and have provided a base from which to support software construction [Th76], version control [Co79], system families [Ti79], and dynamic configuration <ref> [MKS89] </ref>. Enough examples are available to develop models of the design space [Pe87, PN86]. These early module interconnection languages require considerable prior agreement between the developers of different modules.
Reference: [MMS79] <author> J. G. Mitchell, W. Maybury, and R. E. Sweet, </author> <title> Mesa Language Manual . Tech. </title> <type> Report CSL-79-3, </type> <institution> Xerox Corporation, Palo Alto Research Center, </institution> <month> April </month> <year> 1979. </year>
Reference-contexts: Since DeRemer and Krons MIL, MILs have been developed for specific languages, like Mesa <ref> [MMS79] </ref> and Ada [CE78], and have provided a base from which to support software construction [Th76], version control [Co79], system families [Ti79], and dynamic configuration [MKS89]. Enough examples are available to develop models of the design space [Pe87, PN86].
Reference: [Pe87] <author> Dewayne E. Perry. </author> <title> Software Interconnection Models. </title> <booktitle> In Proc. Ninth International Conference on Software Engineering, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> March </month> <year> 1987. </year>
Reference-contexts: Enough examples are available to develop models of the design space <ref> [Pe87, PN86] </ref>. These early module interconnection languages require considerable prior agreement between the developers of different modules.
Reference: [PN86] <author> R. Prieto-Diaz and J. M. Neighbors. </author> <title> Module Interconnection Languages. </title> <journal> Journal of Systems and Software, </journal> <volume> 6(4), </volume> <month> November </month> <year> 1986, </year> <pages> pp. 307-333. </pages>
Reference-contexts: Enough examples are available to develop models of the design space <ref> [Pe87, PN86] </ref>. These early module interconnection languages require considerable prior agreement between the developers of different modules.
Reference: [Pu90] <author> James Purtilo. </author> <title> The Polylith Software Bus. </title> <institution> Dept. of Computer Science, Univ. Maryland, </institution> <type> Tech. Rep. 2469, </type> <year> 1990. </year>
Reference-contexts: These modules can be implemented in multiple programming languages, and the machinery needed to connect them can be richer than the usual procedure linkage, for example, a software bus <ref> [Pu90] </ref>. This kind of system requires expanding the notion of a MIL to include specifics about a module's implementation, such as its programming language, its hardware/operating system platform, and the communication media needed to access it.
Reference: [PW92] <author> Dewayne E. Perry and Alexander L. Wolf. </author> <title> Foundations for the Study of Software Architecture. </title> <booktitle> ACM SIGSOFT Software Engineering Notes , 17(4) </booktitle> <pages> 40-52, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: For example, a designer may describe a system as a set of real-time processes interacting via remote procedure calls; or as a set of independent experts interacting through a shared blackboard; or as a dataflow architecture with information flowing via pipes through a set of filters <ref> [GS93, PW92] </ref>. The designer typically focuses on the components: decomposing system functionality into components, choosing representations, and defining interfaces. The choice of how the components should interactthe connectorsis often made implicitly or by default.
Reference: [SDKRYZ95] <author> Mary Shaw, Robert DeLine, Daniel V. Klein, Theodore L. Ross, David M. Young, Gregory Zelesnik. </author> <title> Abstractions for Software Architectures and Tools to Support Them. </title> <journal> IEEE Tr. on Software Engineering , 21(4) </journal> <pages> 314-335, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: When the checks are satisfied, UniCon creates the intermediate and final products (see Section 3.1) required to construct and execute the system. The details of the language and its compiler appear in a more complete description of UniCon <ref> [SDKRYZ95] </ref>. Here we focus on the connector abstractions and their implementation issues. The UniCon tools allow a software system to be described interchangeably in a graphical and textual notation.
Reference: [SG95] <author> Mary Shaw and David Garlan. </author> <title> Formulations and Formalisms in Software Architecture. </title> <editor> In Jan van Leeuwen (ed), </editor> <booktitle> Computer Science Today, Lecture Notes in Computer Science , Volume 1000, </booktitle> <publisher> Springer-Verlag 1995, </publisher> <pages> pp. 307-323. </pages>
Reference-contexts: Section 2 summarizes the UniCon language. Section 3 describes the requirements that first-class connectors impose on the UniCon compiler. It also describes our strategy of progressive codification of connector expertise in the compiler <ref> [SG95] </ref>. Section 4 gives an extended example of connector expertise. Section 5 summarizes related work. 2. Connector Abstractions in UniCon 2.1.
Reference: [Sh93] <author> Mary Shaw. </author> <title> Procedure Calls are the Assembly Language of Software Interconnection: Connectors Deserve First-Class Status. </title> <note> Proc Workshop on Studies of Software Design 1993 , to be published by Springer-Verlag 1996. </note>
Reference-contexts: Moreover, even when designers think about component interactions in terms of abstract relations, the system description itself usually refers directly to low-level mechanisms for communication, control, or data sharing. Such design relegates architectural connections to second-class status and leads to several problems <ref> [Sh93] </ref>. First, conventional design methods make it hard to localize information about interactions among components. These methods make it easy to identify individual components, because components are usually manifest in the source code.
Reference: [Sh95] <author> Mary Shaw. </author> <title> Architectural Issues in Software Reuse: Its Not Just the Funct ionality, Its the Packaging. </title> <booktitle> Proc SSR95: Symposium on Software Reuse, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: When packaging and connection expectations are hidden, systems may unintentionally use components with different and incompatible packaging, resulting in serious integration problems. We believe that this is a significant source of difficulties with software reuse <ref> [Sh95] </ref>. We are addressing these problems in UniCon, an architectural description language that makes connectorsrelations between componentsfirst-class constructs in the language. Section 2 summarizes the UniCon language. Section 3 describes the requirements that first-class connectors impose on the UniCon compiler.
Reference: [Th76] <author> J. W. Thomas. </author> <title> Module Interconnection in Programming Systems Supporting Abstraction. </title> <type> PhD Thesis, </type> <institution> Brown University. </institution> <month> June, </month> <year> 1976. </year>
Reference-contexts: Since DeRemer and Krons MIL, MILs have been developed for specific languages, like Mesa [MMS79] and Ada [CE78], and have provided a base from which to support software construction <ref> [Th76] </ref>, version control [Co79], system families [Ti79], and dynamic configuration [MKS89]. Enough examples are available to develop models of the design space [Pe87, PN86]. These early module interconnection languages require considerable prior agreement between the developers of different modules.
Reference: [Ti79] <author> Walter F. Tichy. </author> <title> Software Development Control Based on Module Interconnection. </title> <booktitle> Proc. 4th International Conference on Software Engineering , Munich, </booktitle> <year> 1979, </year> <pages> pp. 29-41. </pages>
Reference-contexts: Since DeRemer and Krons MIL, MILs have been developed for specific languages, like Mesa [MMS79] and Ada [CE78], and have provided a base from which to support software construction [Th76], version control [Co79], system families <ref> [Ti79] </ref>, and dynamic configuration [MKS89]. Enough examples are available to develop models of the design space [Pe87, PN86]. These early module interconnection languages require considerable prior agreement between the developers of different modules.
References-found: 23

