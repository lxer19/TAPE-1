URL: http://www.csl.sri.com/~gong/papers/variations.ps.gz
Refering-URL: http://www.csl.sri.com/~gong/papers/pubs93.html
Root-URL: 
Title: Variations on the Themes of Message Freshness and Replay or the Difficulty in Devising Formal
Author: Li Gong 
Address: 333 Ravenswood Avenue Menlo Park, California 94025 U.S.A.  
Affiliation: SRI International Computer Science Laboratory  
Abstract: We survey the variations on the choice and the usage of freshness identifiers, and the various forms of replay attack. Besides helping to clarify the important concepts of freshness and replay, this exercise demonstrates the potential complexity in devising formal methods to analyze cryptographic protocols. 
Abstract-found: 1
Intro-found: 1
Reference: [Bauer 83] <author> R.K. Bauer, T.A. Berson, and R.J. Feiertag, </author> <title> "A Key Distribution Protocol Using Event Markers," </title> <journal> ACM Transactions on Computer Systems, Vol.1, </journal> <volume> No.3, </volume> <month> August, </month> <year> 1983, </year> <month> pp.249-255. </month>
Reference-contexts: Consequently, all three usages are secure, given that the algorithm to produce pseudo-random sequence numbers are secure in the sense that the next number in sequence is unpredictable (to the prover) even if all previous numbers in the sequence are known. The protocol using event markers <ref> [Bauer 83] </ref> is a representative case. Usually the supplier and the verifier are one entity so that the verifier can in theory predict its own future challenges. Thus A itself must be competent in not unintentionally using future challenges; otherwise, suppress-replay attack again becomes possible.
Reference: [Bird 93] <author> B. Bird, I. Gopal, A. Herzberg, P. Jan-son, S. Kutten, R. Molva, and M. Yung, </author> <title> "Systematic Design of a Family of Attack-Resistant Authentication Protocols," </title> <journal> to appear in IEEE Journal on Selected Areas in Communications, </journal> <year> 1993. </year>
Reference-contexts: This attack would be possible if one cannot recognize messages sent by oneself that are encrypted with a shared-key cryptosys-tem (such as DES). Another necessary condition for the attack is that two messages exchanged between the two parties have identical format <ref> [Boyd 90, Gong 90a, Bird 93] </ref>. One possible solution is to arrange messages so that they can be uniquely identified by their patterns, formats or certain fields. For example, every message could bear a protocol identifier, a version number, a message sequence number, and so on.
Reference: [Boyd 90] <author> C.A. Boyd, </author> <title> "Hidden Assumptions in Cryptographic Protocols," </title> <booktitle> Proceedings of IEE, Part E, </booktitle> <address> Vol.137, No.6, </address> <month> November, </month> <year> 1990, </year> <month> pp.433-436. </month>
Reference-contexts: In usage 3, the purpose of f () is to ensure that messages 1 and 2 are not identical [Needham 78]. More care has to be taken to ensure that it is not easy for an intruder to manipulate message 1 to yield a valid message 2 <ref> [Boyd 90] </ref>. Interestingly, the use of random numbers as challenges also requires the availability of clocks that tick at some reasonably accurate (or at least fast) rate so that challenges could be timed out. This requirement is not explicitly stated in many protocol designs based on the challenge-response method. <p> This attack would be possible if one cannot recognize messages sent by oneself that are encrypted with a shared-key cryptosys-tem (such as DES). Another necessary condition for the attack is that two messages exchanged between the two parties have identical format <ref> [Boyd 90, Gong 90a, Bird 93] </ref>. One possible solution is to arrange messages so that they can be uniquely identified by their patterns, formats or certain fields. For example, every message could bear a protocol identifier, a version number, a message sequence number, and so on. <p> One possible solution is to arrange messages so that they can be uniquely identified by their patterns, formats or certain fields. For example, every message could bear a protocol identifier, a version number, a message sequence number, and so on. Or a message could include a direction bit <ref> [Steiner 88, Boyd 90] </ref>. However, this becomes tricky when the recipient's address is only an alias and the real address would have required a different direction bit. Some of these methods may introduce a form of explicit redundancy or verifiable plaintext, which is undesirable in some situations [Lomas 89]. <p> This is a generalization the case above, for which solutions would require enforced formats or inclusion of redundancy, as noted in [Tsang 87, Molva 92]. Replay after modification. For example, one message could be modified (e.g., truncated) to appear as another valid message. Proper solutions include integrity checks <ref> [Boyd 90, Stubblebine 92] </ref>. 4 Confidentiality As noted earlier in section 2, to use fresh encryption keys as freshness identifiers, the confidentiality of such keys must be protected. On the other hand, lack of freshness in certain messages may result in breach of confidentiality.
Reference: [Burrows 90] <author> M. Burrows, M. Abadi, R.M. Need-ham, </author> <title> "A Logic for Authentication," </title> <journal> ACM Transactions on Computer Systems, Vol.8, </journal> <volume> No.1, </volume> <month> February, </month> <year> 1990, </year> <month> pp.18-36. </month>
Reference-contexts: The secure usages discussed above correspond to the intuitive ideas behind the freshness rules in BAN-like logics <ref> [Burrows 90, Gong 90b, Needham 92] </ref>. The principle underlying all freshness rules can be summarized as: if a message cannot be produced (in a com-putationally feasible way) without the knowledge of some text which is fresh, then the message is fresh. <p> The principle underlying all freshness rules can be summarized as: if a message cannot be produced (in a com-putationally feasible way) without the knowledge of some text which is fresh, then the message is fresh. In this aspect, the BAN logic <ref> [Burrows 90] </ref> is more con servative than GNY [Gong 90b] in that only a small number of usages are expressed as rules. For example, GNY has rules that correspond to the following usage: Usage 4. 1.
Reference: [Dolev 83] <author> D. Dolev and A.C. Yao, </author> <title> "On the Security of Public Key Protocols," </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> Vol. IT-29, </volume> <pages> No.2, </pages> <month> March, </month> <year> 1983, </year> <month> pp.198-208. </month>
Reference-contexts: Integrating the handling of confidentiality with that of all other issues in a logic of cryptographic protocols is a difficult task. It appears possible to ease this task by restricting the class of protocols in the case of using conventional cryptosystems, parallel to what Dolev and Yao <ref> [Dolev 83] </ref> achieved for the use of public-key cryptosystems. To conclude the discussion, we note that due to the numerous ways protocols could be constructed, it is difficult to devise a formal method for analyzing cryptographic protocols that could deal with all important issues and cover all cases.
Reference: [Denning 81] <author> D.E. Denning and G.M. Sacco, </author> <title> "Times-tamps in Key Distribution Protocols," </title> <journal> Communications of the ACM, Vol.24, </journal> <volume> No.8, </volume> <month> August, </month> <year> 1981, </year> <month> pp.533-536. </month>
Reference-contexts: All subsequently suggested freshness identifiers are nonces in that the supplier is not meant to repeatly use one identifier. However, it will become clear later that nonces come in different leagues. Timestamps. To use timestamps, some form of loosely synchronized clocks must exist <ref> [Denning 81, Mills 90] </ref>. A typical usage is: Usage 0. A ! B : fT ag k where A embeds a timestamp T a in a message encrypted with k, which is shared between A and B. <p> All following variations of replay attack, many of which have been touched upon in the literature, satisfy this definition. We collect them here and discuss how to prevent and detect them. Simple replay. Replays in this simplist form could take place without the need to modify past messages <ref> [Needham 78, Denning 81] </ref>. A proper defense is to embed freshness identifiers in messages. Repetition that can be logged. For example, an attacker could replay a timestamped message within the valid time window.
Reference: [Diffie 76] <author> W. Diffie and M.E. Hellman, </author> <title> "New Directions in Cryptography," </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> Vol. </volume> <pages> IT-22, </pages> <address> No.6, </address> <month> November, </month> <year> 1976, </year> <month> pp.644-654. </month>
Reference-contexts: Note that even if the two parties use two distinct keys (in a shared-key cryptosystem) to encrypt the traffic in different directions, one of them may make a mistake and use the key that it should not use. Standard usage of public key systems <ref> [Diffie 76, Rivest 78] </ref> could easily resolve this issue of sender verification. Replay to get a different interpretation or replay in another protocol. This is a generalization the case above, for which solutions would require enforced formats or inclusion of redundancy, as noted in [Tsang 87, Molva 92].
Reference: [Gong 90a] <author> L. Gong, </author> <title> "Cryptographic Protocols for Distributed Systems," </title> <type> PhD dissertation, </type> <institution> University of Cambridge, </institution> <month> April, </month> <year> 1990. </year>
Reference-contexts: Securely resynchronizing the counters or the number generators is also important. Fresh encryption keys. A freshness identifier can be a fresh encryption key <ref> [Gong 90a] </ref>, such as a session key chosen and distributed by an authentication server, or a key chosen and agreed upon by A and B. <p> This attack would be possible if one cannot recognize messages sent by oneself that are encrypted with a shared-key cryptosys-tem (such as DES). Another necessary condition for the attack is that two messages exchanged between the two parties have identical format <ref> [Boyd 90, Gong 90a, Bird 93] </ref>. One possible solution is to arrange messages so that they can be uniquely identified by their patterns, formats or certain fields. For example, every message could bear a protocol identifier, a version number, a message sequence number, and so on.
Reference: [Gong 90b] <author> L. Gong, R. Needham, and R. Yahalom, </author> <title> "Reasoning about Belief in Cryptographic Protocols," </title> <booktitle> Proceedings of the IEEE Symposium on Research in Security and Privacy, </booktitle> <address> Oakland, California, </address> <month> May, </month> <year> 1990, </year> <month> pp.234-248. </month>
Reference-contexts: The secure usages discussed above correspond to the intuitive ideas behind the freshness rules in BAN-like logics <ref> [Burrows 90, Gong 90b, Needham 92] </ref>. The principle underlying all freshness rules can be summarized as: if a message cannot be produced (in a com-putationally feasible way) without the knowledge of some text which is fresh, then the message is fresh. <p> The principle underlying all freshness rules can be summarized as: if a message cannot be produced (in a com-putationally feasible way) without the knowledge of some text which is fresh, then the message is fresh. In this aspect, the BAN logic [Burrows 90] is more con servative than GNY <ref> [Gong 90b] </ref> in that only a small number of usages are expressed as rules. For example, GNY has rules that correspond to the following usage: Usage 4. 1.
Reference: [Gong 92] <author> L. Gong, </author> <title> "A Security Risk of Depending on Synchronized Clocks," </title> <journal> ACM Operating Systems Review, Vol.26, </journal> <volume> No.1, </volume> <month> January, </month> <year> 1992, </year> <month> pp.49-53. </month>
Reference-contexts: However, since a future counter value is predictable to an outsider, not all three usages listed above would be secure. In particular, in usage 1, an attacker could breach security by inflating N a and withholding an answer from B for future replay attack a form of suppress-replay attack <ref> [Gong 92] </ref>. The attacker could also attempt to predict a plausible reply in usage 2. Only usage 3 is secure. Even in this case, since a future challenge is predictable to the prover, the verifier has to depend on the honesty and competence of the prover. Pseudo-random numbers. <p> Repetition that cannot be detected. This situation could arise because the original message could be suppressed and thus did not arrive at its destination as expected. A solution is to embed freshness identifiers in messages but to make sure that messages are not postdated <ref> [Gong 92] </ref>. Backward replay without modification. This is replay back to the message sender rather than its originally intended recipient. This attack would be possible if one cannot recognize messages sent by oneself that are encrypted with a shared-key cryptosys-tem (such as DES).
Reference: [Lam 92] <author> K.Y. Lam and T. Beth, </author> <title> "Timely Authentication in Distributed Systems," </title> <booktitle> Proceedings of European Symposium on Research in Computer Security, </booktitle> <address> Toulouse, France, </address> <month> November, </month> <year> 1992. </year> <note> Published as Lecture Notes in Computer Science, Vol.648, Springer-Verlag, 1992, pp.293-303. </note>
Reference-contexts: The proper solution is perhaps to consider the two requirements concurrently. It seems possible to solve this chicken and egg problem, at least when there are available hardware clocks which tick at a reasonably accurate rate [Reiter 93a]. There are other approaches to secure clock synchronization (e.g., <ref> [Simons 90, Lam 92] </ref>). We also think it possible to arrange nonce-based authentication as a backup mechanism (for authentication as well as for clock re-synchronization) whenever clocks are suspected to be out of synchrony with others.
Reference: [Lamport 78] <author> L. Lamport, </author> <title> "Time, Clocks, and the Ordering of Events in a Distributed System," </title> <journal> Communications of the ACM, Vol.21, </journal> <volume> No.7, </volume> <month> July, </month> <year> 1978, </year> <month> pp.558-565. </month>
Reference-contexts: If the supplier and the verifier securely keep their respective counters in synchrony, the counters become logical clocks <ref> [Lamport 78] </ref>, and the case is the same as using real time clocks. Such counters could be used for one-way authenticated communication, as in usage 0. The other three usages become unnecessary, though only usage 3 is secure.
Reference: [Lomas 89] <author> T.M.A. Lomas, L. Gong, J.H. Saltzer, and R.M. Needham, </author> <title> "Reducing Risks from Poorly Chosen Keys," </title> <booktitle> in Proceedings of the 12th ACM Symposium on Operating System Principles, </booktitle> <address> Litchfield Park, Ari-zona, </address> <month> December, </month> <year> 1989. </year> <note> Published as ACM Operating Systems Review, Vol.23, No.5, pp.14-18. </note>
Reference-contexts: However, this becomes tricky when the recipient's address is only an alias and the real address would have required a different direction bit. Some of these methods may introduce a form of explicit redundancy or verifiable plaintext, which is undesirable in some situations <ref> [Lomas 89] </ref>. Perhaps the easiest solution is to design the protocols such that the messages one receives or sends out all have distinct formats.
Reference: [Luan 90] <author> S.W. Luan and V.D Gligor, </author> <title> "On Replay Detection in Distributed Systems," </title> <booktitle> in Proceedings of the 10th International Conference on Distributed Computing Systems, </booktitle> <address> Paris, </address> <month> May, </month> <year> 1990, </year> <month> pp.188-195. </month>
Reference-contexts: Repetition that can be logged. For example, an attacker could replay a timestamped message within the valid time window. A proper defense is to keep those messages that have been received and still valid in (possibly non-volatile) storage, and check new messages against the stored ones <ref> [Steiner 88, Luan 90] </ref>. Repetition that cannot be detected. This situation could arise because the original message could be suppressed and thus did not arrive at its destination as expected. A solution is to embed freshness identifiers in messages but to make sure that messages are not postdated [Gong 92].
Reference: [Mills 90] <author> D.L. Mills, </author> <title> "On the Accuracy and Stability of Clocks Synchronized by the Network Time Protocol in the Internet System," </title> <journal> ACM Computer Communication Review, Vol.20, </journal> <volume> No.1, </volume> <month> January, </month> <year> 1990, </year> <month> pp.65-75. </month>
Reference-contexts: All subsequently suggested freshness identifiers are nonces in that the supplier is not meant to repeatly use one identifier. However, it will become clear later that nonces come in different leagues. Timestamps. To use timestamps, some form of loosely synchronized clocks must exist <ref> [Denning 81, Mills 90] </ref>. A typical usage is: Usage 0. A ! B : fT ag k where A embeds a timestamp T a in a message encrypted with k, which is shared between A and B.
Reference: [Molva 92] <author> R. Molva, G. Tsudik, E. van Her-reweghen, and S. Zatti, </author> <title> "KryptoKnight Authentication and Key Distribution System," </title> <booktitle> Proceedings of European Symposium on Research in Computer Security, </booktitle> <address> Toulouse, France, </address> <month> November, </month> <year> 1992. </year> <note> Published as Lecture Notes in Computer Science, Vol.648, Springer-Verlag, 1992, pp.155-174. </note>
Reference-contexts: Replay to get a different interpretation or replay in another protocol. This is a generalization the case above, for which solutions would require enforced formats or inclusion of redundancy, as noted in <ref> [Tsang 87, Molva 92] </ref>. Replay after modification. For example, one message could be modified (e.g., truncated) to appear as another valid message.
Reference: [Needham 78] <author> R.M. Needham and M.D. Schroeder, </author> <title> "Using Encryption for Authentication in Large Networks of Computers," </title> <journal> Communications of the ACM, Vol.21, No.12, </journal> <volume> De-cember, </volume> <year> 1978, </year> <month> pp.993-999. </month>
Reference-contexts: With a temporal relationship, the occasion is usually distinguished by its start-time (and possibly its duration), and the message carries a timestamp to indicate its origination time. A nonce identifier anumber invented for a special occasion only <ref> [Needham 78] </ref> - is often used in a challenge-response scheme to prove that the response is associated with the challenge. <p> On the other hand, the supplier and the verifier are two distinct entities. This feature makes possible authenticated one-way communication (such as secure electronic messages) <ref> [Needham 78] </ref>. Finally, since maintaining the synchronization of clocks in a secure and practical way generally requires a secure authentication scheme, basing the latter on the availability of synchronized clocks is somewhat dubious. The proper solution is perhaps to consider the two requirements concurrently. <p> Now A does not have to trust B's honesty and competence as in the case of using timestamps, but A has to be careful not to make mistakes by itself. In usage 3, the purpose of f () is to ensure that messages 1 and 2 are not identical <ref> [Needham 78] </ref>. More care has to be taken to ensure that it is not easy for an intruder to manipulate message 1 to yield a valid message 2 [Boyd 90]. <p> All following variations of replay attack, many of which have been touched upon in the literature, satisfy this definition. We collect them here and discuss how to prevent and detect them. Simple replay. Replays in this simplist form could take place without the need to modify past messages <ref> [Needham 78, Denning 81] </ref>. A proper defense is to embed freshness identifiers in messages. Repetition that can be logged. For example, an attacker could replay a timestamped message within the valid time window. <p> On the other hand, lack of freshness in certain messages may result in breach of confidentiality. For example, if the original Needham--Schroeder protocol <ref> [Needham 78] </ref> is followed by exchange of confidential information encrypted with the session key, as illustrated below: 1. A ! S: A; B; N a 2. S ! A: fN a; B; Kab; fKab; Ag Kbs g Kas 3. A ! B: fKab; Ag Kbs 4.
Reference: [Needham 92] <author> R.M. Needham, </author> <title> "Reasoning about Cryptographic Protocols," </title> <booktitle> invited talk at the European Symposium on Research in Computer Security, </booktitle> <address> Toulouse, France, </address> <month> November, </month> <year> 1992. </year>
Reference-contexts: The secure usages discussed above correspond to the intuitive ideas behind the freshness rules in BAN-like logics <ref> [Burrows 90, Gong 90b, Needham 92] </ref>. The principle underlying all freshness rules can be summarized as: if a message cannot be produced (in a com-putationally feasible way) without the knowledge of some text which is fresh, then the message is fresh.
Reference: [Reiter 93a] <author> M. Reiter, K. Birman, and R. van Re-nesse, </author> <title> "Fault-Tolerant Key Distribution," </title> <type> TR 93-1325, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <month> January, </month> <year> 1993. </year>
Reference-contexts: The proper solution is perhaps to consider the two requirements concurrently. It seems possible to solve this chicken and egg problem, at least when there are available hardware clocks which tick at a reasonably accurate rate <ref> [Reiter 93a] </ref>. There are other approaches to secure clock synchronization (e.g., [Simons 90, Lam 92]). We also think it possible to arrange nonce-based authentication as a backup mechanism (for authentication as well as for clock re-synchronization) whenever clocks are suspected to be out of synchrony with others.
Reference: [Reiter 93b] <author> M. Reiter and L. Gong, </author> <title> "Preventing Denial and Forgery of Causal Relationships in Distributed Systems," </title> <booktitle> to appear in Proceedings of the 1993 IEEE Symposium on Research in Security and Privacy, </booktitle> <address> Oak-land, California, </address> <month> May 24-26, </month> <year> 1993. </year>
Reference-contexts: However, they do not normally form logical clocks because the randomness makes comparison difficult, which is unlike counter values, which could be signed and verified by third parties as well <ref> [Reiter 93b] </ref>. Since a future challenge is unpredictable, all three usages are secure, although they are not really necessary because of the synchronization.
Reference: [Rivest 78] <author> R.L. Rivest, A. Shamir, and L. Adleman, </author> <title> "A Method for Obtaining Digital Signatures and Public-Key Cryptosystems," </title> <journal> Communications of the ACM, Vol.21, No.2, </journal> <month> February, </month> <year> 1978, </year> <month> pp.120-126. </month>
Reference-contexts: Note that even if the two parties use two distinct keys (in a shared-key cryptosystem) to encrypt the traffic in different directions, one of them may make a mistake and use the key that it should not use. Standard usage of public key systems <ref> [Diffie 76, Rivest 78] </ref> could easily resolve this issue of sender verification. Replay to get a different interpretation or replay in another protocol. This is a generalization the case above, for which solutions would require enforced formats or inclusion of redundancy, as noted in [Tsang 87, Molva 92].
Reference: [Steiner 88] <author> J.G. Steiner, C. Neuman, and J.I. Schiller, </author> <title> "Kerberos: An Authentication Service for Open Network Systems," </title> <booktitle> in Proceedings of the USENIX Winter Conference, </booktitle> <month> February, </month> <year> 1988, </year> <month> pp.191-202. </month>
Reference-contexts: If j T a T b j is sufficiently small, then the message is regarded as fresh. In some situations, it is important to detect repetition of the same message while the message is still fresh (e.g., <ref> [Steiner 88] </ref>). Here the supplier and the prover are literally one entity even if the system is supposed to supply the current timestamp. <p> Repetition that can be logged. For example, an attacker could replay a timestamped message within the valid time window. A proper defense is to keep those messages that have been received and still valid in (possibly non-volatile) storage, and check new messages against the stored ones <ref> [Steiner 88, Luan 90] </ref>. Repetition that cannot be detected. This situation could arise because the original message could be suppressed and thus did not arrive at its destination as expected. A solution is to embed freshness identifiers in messages but to make sure that messages are not postdated [Gong 92]. <p> One possible solution is to arrange messages so that they can be uniquely identified by their patterns, formats or certain fields. For example, every message could bear a protocol identifier, a version number, a message sequence number, and so on. Or a message could include a direction bit <ref> [Steiner 88, Boyd 90] </ref>. However, this becomes tricky when the recipient's address is only an alias and the real address would have required a different direction bit. Some of these methods may introduce a form of explicit redundancy or verifiable plaintext, which is undesirable in some situations [Lomas 89].
Reference: [Stubblebine 92] <author> S. Stubblebine and V.D. Gligor, </author> <title> "On Message Integrity in Cryptographic Protocols," </title> <booktitle> in Proceedings of the 1992 IEEE Symposium on Security and Privacy, </booktitle> <address> Oak-land, California, </address> <month> May, </month> <year> 1992, </year> <month> pp.85-104. </month>
Reference-contexts: This is a generalization the case above, for which solutions would require enforced formats or inclusion of redundancy, as noted in [Tsang 87, Molva 92]. Replay after modification. For example, one message could be modified (e.g., truncated) to appear as another valid message. Proper solutions include integrity checks <ref> [Boyd 90, Stubblebine 92] </ref>. 4 Confidentiality As noted earlier in section 2, to use fresh encryption keys as freshness identifiers, the confidentiality of such keys must be protected. On the other hand, lack of freshness in certain messages may result in breach of confidentiality.
Reference: [Simons 90] <author> B. Simons, J.L. Welch, and N. Lynch, </author> <title> "An Overview of Clock Synchronization," </title> <editor> in B. Simons and A. Spector (Eds.), </editor> <booktitle> Fault-Tolerant Distributed Computing, published as Lecture Notes in Computer Science, </booktitle> <address> No.448, </address> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The proper solution is perhaps to consider the two requirements concurrently. It seems possible to solve this chicken and egg problem, at least when there are available hardware clocks which tick at a reasonably accurate rate [Reiter 93a]. There are other approaches to secure clock synchronization (e.g., <ref> [Simons 90, Lam 92] </ref>). We also think it possible to arrange nonce-based authentication as a backup mechanism (for authentication as well as for clock re-synchronization) whenever clocks are suspected to be out of synchrony with others.
Reference: [Tsang 87] <author> W.W. Tsang and J.W. John, </author> <title> "A Neglected Aspect of Digital Signatures," </title> <type> TR A5/87, </type> <institution> Department of Information Systems and Computer Science, National University of Singapore, </institution> <month> May, </month> <year> 1987. </year>
Reference-contexts: Replay to get a different interpretation or replay in another protocol. This is a generalization the case above, for which solutions would require enforced formats or inclusion of redundancy, as noted in <ref> [Tsang 87, Molva 92] </ref>. Replay after modification. For example, one message could be modified (e.g., truncated) to appear as another valid message.
Reference: [Voydock 83] <author> V.L. Voydock and S.T. Kent, </author> <title> "Security Mechanisms in High-Level Network Protocols," </title> <journal> Computing Surveys, Vol.15, No.2, </journal> <month> June, </month> <year> 1983, </year> <month> pp.135-171. </month>
Reference-contexts: Many arguments collected in this paper are not entirely new they might have been said in existing literature or circulated in folklore in some form. Moreover, some of the security mechanisms have been suggested before, notably in <ref> [Voydock 83] </ref>, though often in different contexts and for different purposes. We expect this note to be useful in clarifying the two important concepts in the design and verification of cryptographic protocols, and in illustrating the potential complexity and difficulty in devising logics or other tools to analyze cryptographic protocols.
References-found: 26

