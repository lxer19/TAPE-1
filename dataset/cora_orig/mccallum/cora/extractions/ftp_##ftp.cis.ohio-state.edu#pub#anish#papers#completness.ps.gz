URL: ftp://ftp.cis.ohio-state.edu/pub/anish/papers/completness.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~anish/pub.html
Root-URL: http://www.cis.ohio-state.edu
Title: Detectors and Correctors: A Theory of Fault-Tolerance Components 1  
Author: Anish Arora Sandeep S. Kulkarni 
Keyword: Composition, Fault environment, Tolerance components, Tolerance design  
Address: Columbus, Ohio 43210 USA  
Affiliation: Department of Computer and Information Science The Ohio State University  
Abstract: In this paper, we show that two types of tolerance components, namely detectors and correctors, appear in a rich class of fault-tolerant systems. This class includes systems designed using the wellknown techniques of encapsulation and refinement, as well as systems designed using extant fault-tolerance methods such as replication and the state-machine approach. Our demonstration is via a theory of detectors and correctors, which characterizes the particular role of these components in achieving various types of fault-tolerance. Based on this theory and on our experience with using these components in designs, we suggest that detectors and correctors provide a powerful basis for efficient, component-based design of fault-tolerance. 1 A preliminary version of this paper appeared as [6]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <month> January </month> <year> 1993. </year>
Reference: [2] <author> B. Alpern and F. B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21 </volume> <pages> 181-185, </pages> <year> 1985. </year>
Reference-contexts: The formalization of programs is a standard one and borrows from work by Chandy and Misra [8], that of specifications is adapted from Alpern and Schneider <ref> [2] </ref>, that of faults is adapted from earlier work of the first author with Mohamed Gouda [3], and that of fault-tolerance specifications is original. 2.1 Programs Definition. A program is a set of variables and a finite set of actions. Each variable has a predefined nonempty domain. <p> Note that the state sequences in a problem specification may be finite or infinite. Following Alpern and Schneider <ref> [2] </ref>, it can be shown that any problem specification is the intersection of some "safety" specification that is suffix closed and fusion closed and some "liveness" specification, defined next. 3 Definition (Safety).
Reference: [3] <author> A. Arora and M. G. Gouda. </author> <title> Closure and convergence: A foundation of fault-tolerant computing. </title> <journal> IEEE Transactions on Software Engineering, </journal> 19(11) 1015-1027, 1993. 
Reference-contexts: The formalization of programs is a standard one and borrows from work by Chandy and Misra [8], that of specifications is adapted from Alpern and Schneider [2], that of faults is adapted from earlier work of the first author with Mohamed Gouda <ref> [3] </ref>, and that of fault-tolerance specifications is original. 2.1 Programs Definition. A program is a set of variables and a finite set of actions. Each variable has a predefined nonempty domain. <p> Remark. If the witness predicate Z is identical to the correction predicate X, our definition of the corrects relation reduces to one given by Arora and Gouda <ref> [3] </ref>.
Reference: [4] <author> A. Arora and S. S. Kulkarni. </author> <title> Component based design of multitolerance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 24(1) </volume> <pages> 63-78, </pages> <month> January </month> <year> 1998. </year>
Reference-contexts: Given a fault-tolerant system, does it contain detectors and correctors components? 2. Given a fault-intolerant system, do there exist detectors and correctors components whose composition with the system yields a fault-tolerant version of the system? In previous work <ref> [4] </ref>, we have answered Question 2 affirmatively, by presenting methods for transforming a fault-intolerant system into a fault-tolerant one. <p> Subsequently, we present a simple memory access example to illustrate an instance of detectors. (As mentioned in the introduction, 7 methods for the hierarchical and distributed construction of detectors and methods for adding detectors to a fault-intolerant program are presented in <ref> [4] </ref>.) 3.1 Definition Let X and Z be state predicates. <p> Below, we define correctors formally and develop their theory. Subsequently, we build upon our memory access example to illustrate an instance of correctors. (As mentioned in the introduction, methods for the hierarchical and distributed construction of correctors and methods for adding correctors to a fault-intolerant program are presented in <ref> [4] </ref>.) 13 4.1 Definition Let X and Z be state predicates. <p> Also, for a given problem it is possible to design the detectors required for designing a fault-tolerant program for that problem using failure detectors. As mentioned in the introduction, in related work <ref> [4] </ref>, we have addressed how detectors and correctors can be added to a fault-intolerant program to obtain a fault-tolerant program. <p> Our design method has been used used to provide multitolerant and efficient solutions to barrier computations, repetitive Byzantine agreement, mutual exclusion, tree maintenance, leader election, termination detection and bounded-space network management <ref> [4, 10, 11, 5] </ref>. Based on this experience and the existence of a rich class of programs that contain detectors and correctors, we conclude that detectors and correctors provide a powerful basis for efficient, component-based design of fault-tolerance.
Reference: [5] <author> A. Arora and S. S. Kulkarni. </author> <title> Designing masking fault-tolerance via nonmasking fault-tolerance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 435-450, </pages> <month> June </month> <year> 1998. </year> <booktitle> A preliminary version appears in the Proceedings of the Fourteenth Symposium on Reliable Distributed Systems, </booktitle> <address> Bad Neuenahr, </address> <year> 1995, </year> <pages> pages 174-185. </pages>
Reference-contexts: We have applied these methods in designing fault-tolerant programs for various problems such as barrier computations, repetitive Byzantine agreement, leader election, mutual exclusion, tree maintenance, distributed reset termination detection and bounded-space network management <ref> [10, 11, 5] </ref>. (See http://www.cis.ohio-state.edu/ anish for additional references.) These designs are distinguished from existing solutions in multiple ways: in most cases, they are the first solutions that satisfy multiple fault-tolerance properties for the respective problems, all of them are at least as efficient as the existing solutions, and they are <p> Our design method has been used used to provide multitolerant and efficient solutions to barrier computations, repetitive Byzantine agreement, mutual exclusion, tree maintenance, leader election, termination detection and bounded-space network management <ref> [4, 10, 11, 5] </ref>. Based on this experience and the existence of a rich class of programs that contain detectors and correctors, we conclude that detectors and correctors provide a powerful basis for efficient, component-based design of fault-tolerance.
Reference: [6] <author> A. Arora and S. S. Kulkarni. </author> <title> Detectors and correctors: A theory of fault-tolerance components. </title> <booktitle> International Conference on Distributed Computing Systems, </booktitle> <pages> pages 436-443, </pages> <month> May </month> <year> 1998. </year>
Reference: [7] <author> T. Chandra and S. Toueg. </author> <title> Unreliable failure detectors for reliable distributed systems. </title> <journal> Journal of the ACM, </journal> <volume> 43(2), </volume> <year> 1996. </year>
Reference-contexts: Our approach was constructive in that we demonstrated how programs designed using these methods can be alternatively designed using detectors and correctors. We note that our notion of detectors also applies to the recent work of Chandra and Toueg on failure detection <ref> [7] </ref>, although that work makes some distinctions among failure detectors -such as strong and weak accuracy- that we do not need for our purposes.
Reference: [8] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Finally, we make concluding remarks in Section 7. 2 Preliminaries In this section, we give formal definitions of programs, problem specifications, faults, and fault-tolerances. The formalization of programs is a standard one and borrows from work by Chandy and Misra <ref> [8] </ref>, that of specifications is adapted from Alpern and Schneider [2], that of faults is adapted from earlier work of the first author with Mohamed Gouda [3], and that of fault-tolerance specifications is original. 2.1 Programs Definition. A program is a set of variables and a finite set of actions. <p> Remark. If the detection predicate X is closed in d, our definition of the detects relation reduces to one given by Chandy and Misra <ref> [8] </ref>.
Reference: [9] <author> E. W. Dijkstra. </author> <title> Self-stabilizing systems in spite of distributed control. </title> <journal> Communications of the ACM, </journal> <volume> 17(11), </volume> <year> 1974. </year>
Reference-contexts: Using the partial theory we have currently encoded in PVS, we have mechanically proved the correctness of Dijkstra's token ring program <ref> [9] </ref> in a compositional manner. Towards mechanized synthesis, we are developing a method that will synthesize the fault-tolerance components required for achieving each of the tolerance requirements, and compose these components with the given fault-intolerant program to obtain a fault-tolerant program.
Reference: [10] <author> S. S. Kulkarni and A. Arora. </author> <note> Multitolerance in distributed reset. Chicago Journal of Theoretical Computer Science, Special Issue on Self-Stabilization, 1998, to appear. </note>
Reference-contexts: We have applied these methods in designing fault-tolerant programs for various problems such as barrier computations, repetitive Byzantine agreement, leader election, mutual exclusion, tree maintenance, distributed reset termination detection and bounded-space network management <ref> [10, 11, 5] </ref>. (See http://www.cis.ohio-state.edu/ anish for additional references.) These designs are distinguished from existing solutions in multiple ways: in most cases, they are the first solutions that satisfy multiple fault-tolerance properties for the respective problems, all of them are at least as efficient as the existing solutions, and they are <p> Our design method has been used used to provide multitolerant and efficient solutions to barrier computations, repetitive Byzantine agreement, mutual exclusion, tree maintenance, leader election, termination detection and bounded-space network management <ref> [4, 10, 11, 5] </ref>. Based on this experience and the existence of a rich class of programs that contain detectors and correctors, we conclude that detectors and correctors provide a powerful basis for efficient, component-based design of fault-tolerance.
Reference: [11] <author> S. S. Kulkarni and A. Arora. </author> <title> Compositional design of multitolerant repetitive byzantine agreement. </title> <booktitle> Proceedings of the Seventeenth International Conference on Foundations of Software Technology and Theoretical Computer Science, Kharagpur, India, </booktitle> <pages> pages 169-183, </pages> <month> December </month> <year> 1997. </year>
Reference-contexts: We have applied these methods in designing fault-tolerant programs for various problems such as barrier computations, repetitive Byzantine agreement, leader election, mutual exclusion, tree maintenance, distributed reset termination detection and bounded-space network management <ref> [10, 11, 5] </ref>. (See http://www.cis.ohio-state.edu/ anish for additional references.) These designs are distinguished from existing solutions in multiple ways: in most cases, they are the first solutions that satisfy multiple fault-tolerance properties for the respective problems, all of them are at least as efficient as the existing solutions, and they are <p> And, regarding Schneider's state machine approach [14], we focus our attention in Section 6.2 on one of its requirements, namely Agreement, in the presence of Byzantine faults. For reasons of space, the other requirement, namely Order, is discussed in <ref> [11] </ref>. 6.1 Triple modular redundancy Consider a triple modular redundant system used for the input-output problem: the system consists of three inputs, say x, y and z, and one output, say out. In the absence of faults, all inputs are identical. Faults may corrupt any one of the three inputs. <p> For ease of exposition, we will restrict our attention to the case where the total number of processes (including g) is 4 and, hence, f is 1. (We discuss the general case where f is greater than one elsewhere <ref> [11] </ref>.) We show that a Byzantine agreement program can be designed by first designing a fault-intolerant program, IB, and then adding to it a detector, DB, followed by a corrector, CB. 23 Fault-intolerant program IB. <p> Our design method has been used used to provide multitolerant and efficient solutions to barrier computations, repetitive Byzantine agreement, mutual exclusion, tree maintenance, leader election, termination detection and bounded-space network management <ref> [4, 10, 11, 5] </ref>. Based on this experience and the existence of a rich class of programs that contain detectors and correctors, we conclude that detectors and correctors provide a powerful basis for efficient, component-based design of fault-tolerance.
Reference: [12] <author> L. Lamport, R. Shostak, and M. Pease. </author> <title> The Byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <year> 1982. </year>
Reference-contexts: Byzantine faults corrupt processes permanently and undetectably such that the corrupted processes execute arbitrarily nondeterministic actions. It is well known that masking tolerant Byzantine agreement is possible iff there are at least 3f +1 processes, where f is the number of Byzantine processes <ref> [12] </ref>.
Reference: [13] <author> B. Randell. </author> <title> System structure for software fault tolerance. </title> <journal> IEEE Transactions on Software Engineering., </journal> <pages> pages 220-232, </pages> <year> 1975. </year>
Reference-contexts: contain nonmasking correctors. (iii) "Masking" tolerant programs contain masking tolerant detectors and correctors. (Each of the terms within quotes is defined formally in the next section.) Our second set of results pertain to extant methods for designing fault-tolerance (e.g., replication based voting, Schneider's state machine approach [14], Randell's recovery blocks <ref> [13] </ref>, checkpointing and recovery, and exception handling). More specifically, they demonstrate (a) that systems designed using replication-based voting and Schneider's state machine approach contain detectors and correctors and (b) how the same systems can be alternatively designed with the direct use of detectors and correctors.
Reference: [14] <author> F. B. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 299-319, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: "nonmasking" tolerant programs 1 contain nonmasking correctors. (iii) "Masking" tolerant programs contain masking tolerant detectors and correctors. (Each of the terms within quotes is defined formally in the next section.) Our second set of results pertain to extant methods for designing fault-tolerance (e.g., replication based voting, Schneider's state machine approach <ref> [14] </ref>, Randell's recovery blocks [13], checkpointing and recovery, and exception handling). More specifically, they demonstrate (a) that systems designed using replication-based voting and Schneider's state machine approach contain detectors and correctors and (b) how the same systems can be alternatively designed with the direct use of detectors and correctors. <p> Regarding replication, we focus our attention in Section 6.1 on the problem of triple modular redundant system design. And, regarding Schneider's state machine approach <ref> [14] </ref>, we focus our attention in Section 6.2 on one of its requirements, namely Agreement, in the presence of Byzantine faults.
Reference: [15] <author> N. Shankar, S. Owre, and J. M. Rushby. </author> <title> The PVS Proof Checker: A Reference Manual. </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year> <note> A new edition for PVS Version 2 is released in 1998. 27 </note>
Reference-contexts: Towards mechanized verification, we are encoding the theory of detectors and correctors -including the theory that deals with adding these components to obtain fault-tolerant programs- into the theorem-prover PVS <ref> [15] </ref>. Using the partial theory we have currently encoded in PVS, we have mechanically proved the correctness of Dijkstra's token ring program [9] in a compositional manner.
References-found: 15

