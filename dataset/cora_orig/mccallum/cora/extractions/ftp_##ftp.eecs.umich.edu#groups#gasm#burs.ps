URL: ftp://ftp.eecs.umich.edu/groups/gasm/burs.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.eecs.umich.edu
Email: fgaul;zimmerg@ipd.info.uni-karlsruhe.de  fdold;vialardg@ki.informatik.uni-ulm.de  
Phone: 2  
Title: ASM-Based Mechanized Verification of Compiler Back-Ends  
Author: Axel Dold Thilo Gaul Vincent Vialard and Wolf Zimmermann 
Address: D-76131 Karlsruhe,  D-89069 Ulm,  
Affiliation: 1 University of Karlsruhe, Institute for Program Structures and Data Organisation,  University of Ulm, Department of AI,  
Abstract: We describe an approach to mechanically prove the correctness of BURS specifications and show how such a tool can be connected with BURS based back-end generators [9]. The proofs are based on the operational semantics of both source and target system languages specified by means of Abstract State Machines [14]. In [27] we decomposed the correctness condition based on these operational semantics into local correctness conditions for each BURS rule and showed that these local correctness conditions can be proven independently. The specification and verification system PVS is used to mechanicaly verify BURS-rules based on formal representations of the languages involved. In particular, we have defined PVS proof strategies which enable an automatic verification of the rules. Using PVS, several erroneous rules have been found. Moreover, from failed proof attempts we were able to correct them. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> E. Borger and I. Durdanovic. </author> <title> Correctness of Compiling Occam to Transputer code. </title> <journal> The Computer Journal, </journal> <volume> 39 </volume> <pages> 52-93, </pages> <year> 1996. </year>
Reference-contexts: Other approaches on compiler correctness use abstract state machine (e.g.[2, 3, 1]). Most of these works do not compile high-level programming languages into assembler languages. To our knowledge, only <ref> [3, 1, 19] </ref> and ProCos [15] discus transformations into machine code. This article is organized as follows: First we give an introduction in our correctness notion and the involved languages in Section 2.
Reference: 2. <author> E. Borger and D. Rosenzweig. </author> <title> The WAM-definition and Compiler Correctness. </title> <type> Technical Report TR-14/92, </type> <institution> Dip. di informatica, Univ. Pisa, Italy, </institution> <year> 1992. </year>
Reference: 3. <author> Egon Borger, Igor Durdanovic, and Dean Rosenzweig. </author> <title> Occam: Specification and Compiler Correctness.Part I: The Primary Model. </title> <editor> In U. Montanari and E.-R. Olderog, editors, </editor> <booktitle> Proc. Procomet'94 (IFIP TC2 Working Conference on Programming Concepts, Methods and Calculi). </booktitle> <publisher> North-Holland, </publisher> <year> 1994. </year>
Reference-contexts: Other approaches on compiler correctness use abstract state machine (e.g.[2, 3, 1]). Most of these works do not compile high-level programming languages into assembler languages. To our knowledge, only <ref> [3, 1, 19] </ref> and ProCos [15] discus transformations into machine code. This article is organized as follows: First we give an introduction in our correctness notion and the involved languages in Section 2.
Reference: 4. <author> D. F. Brown, H. Moura, and D. A. Watt. Actress: </author> <title> an action semantics directed compiler generator. </title> <booktitle> In Compiler Compilers 92, volume 641 of Lecture Notes in Computer Science, </booktitle> <year> 1992. </year>
Reference: 5. <author> B. Buth, K.-H. Buth, M. Franzle, B. v. Karger, Y. Lakhneche, H. Langmaack, and M. Muller-Olm. </author> <title> Provably correct compiler development and implementation. </title> <editor> In U. Kastens and P. Pfahler, editors, </editor> <booktitle> Compiler Construction, volume 641 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: 6. <author> Bettina Buth and Markus Muller-Olm. </author> <title> Provably Correct Compiler Implementation. </title> <booktitle> In Tutorial Material Formal Methods Europe '93, </booktitle> <pages> pages 451-465, </pages> <address> Denmark, </address> <month> April </month> <year> 1993. </year> <note> IFAD Odense Teknikum. </note>
Reference: 7. <author> D. Cyrluk. </author> <title> Microprocessor verification in pvs a methodology and simple ex-amples. </title> <type> Technical Report SRI-CSL-93-12, </type> <institution> SRI International, Computer Science Laboratory, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Here, we suppose that all update rules are combined in a one-step interpreter and adapt a generic scheme given by Cyrluk (et al) developed in the context of microprocessor verification <ref> [7] </ref>. This scheme describes the semantics of a STS by means of traces, i.e. sequences of states, which corresponds to the ASM definition of a run.
Reference: 8. <author> Axel Dold. </author> <title> Representing the Alpha Processor Family using PVS. </title> <institution> Verifix Working Paper [Verifix / Uni Ulm / 4.1], Universitat Ulm, </institution> <month> November </month> <year> 1995. </year>
Reference: 9. <author> H. Emmelmann. </author> <title> Code selection by regularly controled term rewriting. </title> <editor> In R. Giegerich and S.L. Graham, editors, </editor> <title> Code Generation Concepts, Tools, Techniques, Workshops in Computing. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: In this paper we focus on the construction of correct compiler back-ends. Compiler back-ends transform low-level intermediate language programs into machine programs. One of the well known techniques to produce efficient machine code are bottom up rewrite systems (BURS). This specification technique <ref> [9, 10, 20, 24] </ref> has two advantages: (i) the back-end can be generated from such a specification, (ii) it is possible to specify back-ends which produce efficient code.
Reference: 10. <author> H. Emmelmann, F.-W. Schroer, and R. Landwehr. </author> <title> Beg a generator for efficient back ends. </title> <booktitle> In ACM Proceedings of the Sigplan Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: In this paper we focus on the construction of correct compiler back-ends. Compiler back-ends transform low-level intermediate language programs into machine programs. One of the well known techniques to produce efficient machine code are bottom up rewrite systems (BURS). This specification technique <ref> [9, 10, 20, 24] </ref> has two advantages: (i) the back-end can be generated from such a specification, (ii) it is possible to specify back-ends which produce efficient code.
Reference: 11. <author> T.S. Gaul, A. Heberle, and W. Zimmermann. </author> <title> An Evolving Algebra Specification of the Operational Semantics of MIS. </title> <note> Verifix Working Paper [Verifix/UKA/3], </note> <institution> University of Karlsruhe, </institution> <year> 1995. </year>
Reference-contexts: We will refer to the first language as BIL and to the latter as BM L. Our example target language is the machine language of the DEC-Alpha processor family (Appendix C). The complete definitions can be found in <ref> [11] </ref> and [12]. 2.3 Code Generation by Term Rewriting Term rewriting is commonly used in compiler back-end generators for the specification of the transformation to be performed by the code selection, i.e. the mapping CS : BIL ) BML. Any intermediate language command can be viewed as a term.
Reference: 12. <author> T.S. Gaul and W. Zimmermann. </author> <title> An Evolving Algebra for the Alpha Processor Family. </title> <note> Verifix Working Paper [Verifix/UKA/4], </note> <institution> University of Karlsruhe, </institution> <year> 1995. </year>
Reference-contexts: We will refer to the first language as BIL and to the latter as BM L. Our example target language is the machine language of the DEC-Alpha processor family (Appendix C). The complete definitions can be found in [11] and <ref> [12] </ref>. 2.3 Code Generation by Term Rewriting Term rewriting is commonly used in compiler back-end generators for the specification of the transformation to be performed by the code selection, i.e. the mapping CS : BIL ) BML. Any intermediate language command can be viewed as a term.
Reference: 13. <author> Y. Gurevich. </author> <title> Evolving Algebras; A Tutorial Introduction. </title> <journal> Bulletin EATCS, </journal> <volume> 43 </volume> <pages> 264-284, </pages> <year> 1991. </year>
Reference-contexts: In particular, the detection and correction of an erroneous rule using PVS is presented. 2 Basic Definitions The semantics of our languages are defined operationally by abstract state machines <ref> [13] </ref>. The notation is oriented on [14] and uses only standard techniques. The type I N T is used to denote the 64-bit integer arithmetic of the DEC-Alpha Processor.
Reference: 14. <author> Y. Gurevich. </author> <title> Evolving Algebras: Lipari Guide. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: In particular, the detection and correction of an erroneous rule using PVS is presented. 2 Basic Definitions The semantics of our languages are defined operationally by abstract state machines [13]. The notation is oriented on <ref> [14] </ref> and uses only standard techniques. The type I N T is used to denote the 64-bit integer arithmetic of the DEC-Alpha Processor. INT [k] denotes the integer represented by k bits, i.e. the range 2 k ; : : : ; 2 k 1.
Reference: 15. <author> C.A.R. Hoare, He Jifeng, and A. Sampaio. </author> <title> Normal Form Approach to Compiler Design. </title> <journal> Acta Informatica, </journal> <volume> 30 </volume> <pages> 701-739, </pages> <year> 1993. </year>
Reference-contexts: Other approaches on compiler correctness use abstract state machine (e.g.[2, 3, 1]). Most of these works do not compile high-level programming languages into assembler languages. To our knowledge, only [3, 1, 19] and ProCos <ref> [15] </ref> discus transformations into machine code. This article is organized as follows: First we give an introduction in our correctness notion and the involved languages in Section 2. Our definition of the BURS technique (Section 3) gives the local correctness conditions and central theorem of [27].
Reference: 16. <author> J. McCarthy and J.A. Painter. </author> <title> Correctness of a compiler for arithmetical expressions. </title> <editor> In J.T. Schwartz, editor, </editor> <booktitle> Proceedings of a Symposium in Applied Mathematics, 19, Mathematical Aspects of Computer Science. </booktitle> <publisher> American Mathematical Society, </publisher> <year> 1967. </year>
Reference-contexts: We demonstrate our approach with a typical basic block oriented intermediate language with expressions (MIS) and the translation to the DEC-Alpha processor family. The operational semantics is formalized by abstract state machines (Section 2). The first work on correct compilers is <ref> [16] </ref>. Most of the following work on correct compilation is based on denotational semantics (e.g.[4, 17, 18, 22, 23, 26]) or on refinement calculi (e.g.[5, 6, 15, 19]). Other approaches on compiler correctness use abstract state machine (e.g.[2, 3, 1]).
Reference: 17. <author> P. D. Mosses. </author> <title> Abstract semantic algebras. </title> <editor> In D. Bjorner, editor, </editor> <booktitle> Formal description of programming concepts II, </booktitle> <pages> pages 63-88. </pages> <booktitle> IFIP IC-2 Working Conference, </booktitle> <publisher> North Holland, </publisher> <year> 1982. </year>
Reference: 18. <author> P. D. Mosses. </author> <title> Action Semantics. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference: 19. <author> Markus Muller-Olm. </author> <title> Modular Compiler Verification. </title> <type> PhD thesis, Techn. </type> <institution> Fakultat der Christian-Albrechts-Universitat, Kiel, </institution> <month> June </month> <year> 1996. </year> <note> Erscheint als LNCS Band im Springer-Verlag. </note>
Reference-contexts: Other approaches on compiler correctness use abstract state machine (e.g.[2, 3, 1]). Most of these works do not compile high-level programming languages into assembler languages. To our knowledge, only <ref> [3, 1, 19] </ref> and ProCos [15] discus transformations into machine code. This article is organized as follows: First we give an introduction in our correctness notion and the involved languages in Section 2.
Reference: 20. <author> Albert Nymeyer, Joost-Pieter Katoen, Ymte Westra, and Henk Alblas. </author> <title> Code Generation = A* + BURS. </title> <editor> In Tibor Gyimothy, editor, </editor> <booktitle> Compiler Construction (CC), volume 1060 of Lecture Notes in Computer Science, </booktitle> <pages> pages 160-176, </pages> <address> Heidelberg, April 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In this paper we focus on the construction of correct compiler back-ends. Compiler back-ends transform low-level intermediate language programs into machine programs. One of the well known techniques to produce efficient machine code are bottom up rewrite systems (BURS). This specification technique <ref> [9, 10, 20, 24] </ref> has two advantages: (i) the back-end can be generated from such a specification, (ii) it is possible to specify back-ends which produce efficient code.
Reference: 21. <author> S. Owre, J. M. Rushby, and N. Shankar. PVS: </author> <title> A Prototype Verification System. </title> <editor> In Deepak Kapur, editor, </editor> <booktitle> Proceedings 11th International Conference on Automated Deduction CADE, volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 748-752, </pages> <address> Saratoga, NY, </address> <month> October </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference-contexts: An adequate mechanized support is absolutely necessary. Such a system can help checking consistencies of ASM specifications, detecting erroneous rules, supporting the documentation and administration of proofs, and providing proof support by means of strategies. We have chosen the specification and verification system PVS <ref> [21] </ref>. Its specification language is based on classical higher-order logic with a rich type system including dependent types and predicate subtypes. In addition, it provides tools for analyzing, modifying and documenting theories and proofs together with a powerful sequent calculus based interactive prover.
Reference: 22. <author> J. Palsberg. </author> <title> An automatically generated and provably correct compiler for a subset of ada. </title> <booktitle> In IEEE International Conference on Computer Languages, </booktitle> <year> 1992. </year>
Reference: 23. <author> L. Paulson. </author> <title> A compiler generator for semantic grammars. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1981. </year>
Reference: 24. <author> Todd A. Proebsting. </author> <title> BURS automata generation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(3) </volume> <pages> 461-486, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: In this paper we focus on the construction of correct compiler back-ends. Compiler back-ends transform low-level intermediate language programs into machine programs. One of the well known techniques to produce efficient machine code are bottom up rewrite systems (BURS). This specification technique <ref> [9, 10, 20, 24] </ref> has two advantages: (i) the back-end can be generated from such a specification, (ii) it is possible to specify back-ends which produce efficient code.
Reference: 25. <author> Richard L. </author> <title> Sites. Alpha Architecture Reference Manual. </title> <institution> Digital Equipment Corporation, </institution> <year> 1992. </year>
Reference: 26. <author> M. Wand. </author> <title> A semantic prototyping system. </title> <journal> SIGPLAN Notices, </journal> <volume> 19(6) </volume> <pages> 213-221, </pages> <month> June </month> <year> 1984. </year> <booktitle> SIGPLAN 84 Symp. On Compiler Construction. </booktitle>
Reference: 27. <author> W. Zimmermann and T. Gaul. </author> <title> On the Construction of Correct Compiler Back--Ends: An ASM Approach. </title> <journal> Journal of Universal Computer Science, </journal> <volume> 3(5) </volume> <pages> 504-567, </pages> <year> 1997. </year>
Reference-contexts: We show in this paper how rewrite rules for code generation can be practically proven correct, thus the BURS technology becomes applicable to the construction of verified compilers. In <ref> [27] </ref> we decomposed the correctness of BURS-based compiler back-ends into the local correctness of single term-rewrite rules, and the global correctness. Furthermore we proved the global correctness under the same constraints as the applicability of the BURS-technology, i.e. no specific assumptions on the term-rewrite system are required. <p> This article is organized as follows: First we give an introduction in our correctness notion and the involved languages in Section 2. Our definition of the BURS technique (Section 3) gives the local correctness conditions and central theorem of <ref> [27] </ref>. Section 4 gives the general proof strategy for proving local correctness and demonstrates it by some examples. Section 5 describes the formalization of the intermediate and target language ASM's, the formal representation of the TRS rules and their verification using proof strategies. <p> The observable behaviour focuses on the input/output. following state transition does not change input or output. <ref> [27] </ref> defines these definitions formally. A compiler which compiles a program 1 2 L 1 into a program 2 2 L 2 implements a relation C : L 1 fi L 2 . Intuitively, C is correct if 1 and 2 have the same observable behavior. <p> A 2 simulates A 1 in a sense similar to the notion of simulations used in complexity r r r I/O I/O I/O r r Figure1. Compiler Correctness and computability theory. Figure 1 illustrates these ideas. Full definitions can be found in <ref> [27] </ref>. The relation ae maps injectively the observable part of the states of the target program to the observable part of the states of the source program. <p> The freedom of choice of ae allows optimizations. In particular, the order of instructions can be changed as long as the observable behaviour is preserved. 2.2 Languages and State Spaces In <ref> [27] </ref> we showed that it is possible to express the operational semantics of the intermediate language with the state space of the processor (except instruction pointers). In this paper we will also consider state spaces to be equal. <p> This allows to use any optimizing register allocation algorithm that fullfills the constraint, that no value containing register is reassigned. Non-terminals can be seen as variables in the sense of term rewriting. A full formal definition can again be found in <ref> [27] </ref>. 3 Correctness of TRS-based code generation In [27], we reduced the correctness condition for BURS-based compiler back-ends to the following two local correctness conditions: (i) A term-rewrite rule t ) X; fm 1 ; : : : ; m n g is locally correct iff for every state q there <p> This allows to use any optimizing register allocation algorithm that fullfills the constraint, that no value containing register is reassigned. Non-terminals can be seen as variables in the sense of term rewriting. A full formal definition can again be found in <ref> [27] </ref>. 3 Correctness of TRS-based code generation In [27], we reduced the correctness condition for BURS-based compiler back-ends to the following two local correctness conditions: (i) A term-rewrite rule t ) X; fm 1 ; : : : ; m n g is locally correct iff for every state q there are states q 1 ; : : : <p> The described technique assures, that the only part that has to be verified again for a new combination of source and target language is the set of rewrite rules that define the code selection patterns. The decomposition and proofs of the global strategy has already been shown in <ref> [27] </ref>. We are now able to parametrize a generator with a term-rewrite system, the intermediate language, the target language, and the register assignment algorithms. Therefore, if such correct generators and register assignments are available, only the local correctness of the term-rewrite rules is required for construction of correct code selection.
References-found: 27

